{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTMyNjIwMjA2", "number": 6989, "reviewThreads": {"totalCount": 43, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0yMlQxNzoyNzo0NlrOFR_I9g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMy0xOVQyMDoyNTowN1rOFoNCoQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzU0NDA0NTk4OnYy", "diffSide": "RIGHT", "path": "src/main/java/org/broadinstitute/hellbender/tools/LocalAssembler.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0yMlQxNzoyNzo0NlrOIYt3LA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0yMlQxNzoyNzo0NlrOIYt3LA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2Mjc4ODE0MA==", "bodyText": "We should fill these in with something slightly more descriptive (while keeping in mind that it is still an experiment)", "url": "https://github.com/broadinstitute/gatk/pull/6989#discussion_r562788140", "createdAt": "2021-01-22T17:27:46Z", "author": {"login": "cwhelan"}, "path": "src/main/java/org/broadinstitute/hellbender/tools/LocalAssembler.java", "diffHunk": "@@ -0,0 +1,2303 @@\n+package org.broadinstitute.hellbender.tools;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import htsjdk.samtools.Cigar;\n+import htsjdk.samtools.CigarElement;\n+import htsjdk.samtools.CigarOperator;\n+import htsjdk.samtools.SAMUtils;\n+import org.broadinstitute.barclay.argparser.Argument;\n+import org.broadinstitute.barclay.argparser.BetaFeature;\n+import org.broadinstitute.barclay.argparser.CommandLineProgramProperties;\n+import org.broadinstitute.barclay.help.DocumentedFeature;\n+import org.broadinstitute.hellbender.cmdline.StandardArgumentDefinitions;\n+import org.broadinstitute.hellbender.cmdline.programgroups.CoverageAnalysisProgramGroup;\n+import org.broadinstitute.hellbender.exceptions.GATKException;\n+import org.broadinstitute.hellbender.tools.walkers.PairWalker;\n+import org.broadinstitute.hellbender.utils.SimpleInterval;\n+import org.broadinstitute.hellbender.utils.collections.HopscotchSet;\n+import org.broadinstitute.hellbender.utils.gcs.BucketUtils;\n+import org.broadinstitute.hellbender.utils.read.GATKRead;\n+\n+import java.io.BufferedWriter;\n+import java.io.FileWriter;\n+import java.io.IOException;\n+import java.io.OutputStreamWriter;\n+import java.util.*;\n+import java.util.zip.GZIPOutputStream;\n+\n+@DocumentedFeature\n+@CommandLineProgramProperties(\n+        summary = \"experiment\",", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dea34857f3696a5eb9b7d826443b2d1b693a79ac"}, "originalPosition": 30}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzU0NDA2MjcxOnYy", "diffSide": "RIGHT", "path": "src/main/java/org/broadinstitute/hellbender/tools/PrintDistantMates.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0yMlQxNzozMjoxMVrOIYuBgQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0yMlQxNzozMjoxMVrOIYuBgQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2Mjc5MDc4NQ==", "bodyText": "Can you clarify in this comment whether it's a requirement to run this before using PairWalker?", "url": "https://github.com/broadinstitute/gatk/pull/6989#discussion_r562790785", "createdAt": "2021-01-22T17:32:11Z", "author": {"login": "cwhelan"}, "path": "src/main/java/org/broadinstitute/hellbender/tools/PrintDistantMates.java", "diffHunk": "@@ -0,0 +1,127 @@\n+package org.broadinstitute.hellbender.tools;\n+\n+import htsjdk.samtools.Cigar;\n+import htsjdk.samtools.TextCigarCodec;\n+import org.broadinstitute.barclay.argparser.Argument;\n+import org.broadinstitute.barclay.argparser.CommandLineProgramProperties;\n+import org.broadinstitute.barclay.help.DocumentedFeature;\n+import org.broadinstitute.hellbender.cmdline.StandardArgumentDefinitions;\n+import org.broadinstitute.hellbender.engine.FeatureContext;\n+import org.broadinstitute.hellbender.engine.GATKPath;\n+import org.broadinstitute.hellbender.engine.ReadWalker;\n+import org.broadinstitute.hellbender.engine.ReferenceContext;\n+import org.broadinstitute.hellbender.engine.filters.ReadFilter;\n+import org.broadinstitute.hellbender.engine.filters.ReadFilterLibrary;\n+import org.broadinstitute.hellbender.utils.read.GATKRead;\n+import org.broadinstitute.hellbender.utils.read.SAMFileGATKReadWriter;\n+import picard.cmdline.programgroups.ReadDataManipulationProgramGroup;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+@CommandLineProgramProperties(\n+        summary = \"Prints reads that have distant mates using the mate's alignment information.  Yes, this is weird, but it helps in processing pairs together (see PairWalker).\",", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dea34857f3696a5eb9b7d826443b2d1b693a79ac"}, "originalPosition": 25}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzU5OTE1MjE2OnYy", "diffSide": "RIGHT", "path": "src/main/java/org/broadinstitute/hellbender/engine/ReadWalker.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0wNVQxNzo0NzoxM1rOIgrxlQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0wNVQxNzo0NzoxM1rOIgrxlQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MTE0MjU0OQ==", "bodyText": "Are you sure you need to change this? It seems wrong to have to change ReadWalker. This will cause any read walkers to not do any of the interval merging logic in IntervalArgumentCollection which I assume must be desired sometimes. EDIT: sounds like you and @droazen might have found a way to work this out.", "url": "https://github.com/broadinstitute/gatk/pull/6989#discussion_r571142549", "createdAt": "2021-02-05T17:47:13Z", "author": {"login": "cwhelan"}, "path": "src/main/java/org/broadinstitute/hellbender/engine/ReadWalker.java", "diffHunk": "@@ -57,7 +57,7 @@ protected final void onStartup() {\n      */\n     void setReadTraversalBounds() {\n         if ( hasUserSuppliedIntervals() ) {\n-            reads.setTraversalBounds(intervalArgumentCollection.getTraversalParameters(getHeaderForReads().getSequenceDictionary()));\n+            reads.setTraversalBounds(userIntervals);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e2201c1ef4f8ba71f17e169f07756cfe2f1ecb49"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzYyMzA4Njg5OnYy", "diffSide": "RIGHT", "path": "src/main/java/org/broadinstitute/hellbender/engine/ReadWalker.java", "isResolved": false, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0xMVQxODo1MDo0NFrOIkHsjQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMy0yNVQxOTowNDo1OVrOI94-gg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3NDc0NTc0MQ==", "bodyText": "@tedsharpe Not sure if this was a temporary workaround for some issue you encountered, but the previous implementation passing in intervalArgumentCollection.getTraversalParameters() is actually necessary to support -L unmapped. Hopefully this is covered by existing tests somewhere...", "url": "https://github.com/broadinstitute/gatk/pull/6989#discussion_r574745741", "createdAt": "2021-02-11T18:50:44Z", "author": {"login": "droazen"}, "path": "src/main/java/org/broadinstitute/hellbender/engine/ReadWalker.java", "diffHunk": "@@ -57,7 +57,7 @@ protected final void onStartup() {\n      */\n     void setReadTraversalBounds() {\n         if ( hasUserSuppliedIntervals() ) {\n-            reads.setTraversalBounds(intervalArgumentCollection.getTraversalParameters(getHeaderForReads().getSequenceDictionary()));\n+            reads.setTraversalBounds(userIntervals);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e2201c1ef4f8ba71f17e169f07756cfe2f1ecb49"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3NDc2NTI3OA==", "bodyText": "Oh, bummer.  I'll have to rework this, then.  I'm a little vague on the details right now, but it had something to do with an additional tier of padding that I'm doing to make sure that I pull in the distant mates (via the tool whose design you suggested).  I had to expand the intervals over which I do read retrieval, while still having access to the underlying singly-padded intervals over which I do assembly.\nI asked Louis about why we pre-calculated userIntervals if we were just going to recalculate them here.  He thought it seemed an obvious bug at the time.  It's so hard to change engine code.  :-(", "url": "https://github.com/broadinstitute/gatk/pull/6989#discussion_r574765278", "createdAt": "2021-02-11T19:22:11Z", "author": {"login": "tedsharpe"}, "path": "src/main/java/org/broadinstitute/hellbender/engine/ReadWalker.java", "diffHunk": "@@ -57,7 +57,7 @@ protected final void onStartup() {\n      */\n     void setReadTraversalBounds() {\n         if ( hasUserSuppliedIntervals() ) {\n-            reads.setTraversalBounds(intervalArgumentCollection.getTraversalParameters(getHeaderForReads().getSequenceDictionary()));\n+            reads.setTraversalBounds(userIntervals);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3NDc0NTc0MQ=="}, "originalCommit": {"oid": "e2201c1ef4f8ba71f17e169f07756cfe2f1ecb49"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3NDc3MjQxNg==", "bodyText": "Don't despair @tedsharpe, I think we can probably fix this pretty easily! You just need to construct a new TraversalParameters here, and make sure that the user's traverseUnmapped setting gets propagated. Something like this could do for now:\n    void setReadTraversalBounds() {\n        if ( hasUserSuppliedIntervals() ) {\n            reads.setTraversalBounds(new TraversalParameters(userIntervals, intervalArgumentCollection.getTraversalParameters(getHeaderForReads().getSequenceDictionary()).traverseUnmappedReads());\n        }\n    }", "url": "https://github.com/broadinstitute/gatk/pull/6989#discussion_r574772416", "createdAt": "2021-02-11T19:33:40Z", "author": {"login": "droazen"}, "path": "src/main/java/org/broadinstitute/hellbender/engine/ReadWalker.java", "diffHunk": "@@ -57,7 +57,7 @@ protected final void onStartup() {\n      */\n     void setReadTraversalBounds() {\n         if ( hasUserSuppliedIntervals() ) {\n-            reads.setTraversalBounds(intervalArgumentCollection.getTraversalParameters(getHeaderForReads().getSequenceDictionary()));\n+            reads.setTraversalBounds(userIntervals);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3NDc0NTc0MQ=="}, "originalCommit": {"oid": "e2201c1ef4f8ba71f17e169f07756cfe2f1ecb49"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMTc2NzU1NA==", "bodyText": "I've adopted your suggestion.  Thanks very much for catching this.", "url": "https://github.com/broadinstitute/gatk/pull/6989#discussion_r601767554", "createdAt": "2021-03-25T19:04:59Z", "author": {"login": "tedsharpe"}, "path": "src/main/java/org/broadinstitute/hellbender/engine/ReadWalker.java", "diffHunk": "@@ -57,7 +57,7 @@ protected final void onStartup() {\n      */\n     void setReadTraversalBounds() {\n         if ( hasUserSuppliedIntervals() ) {\n-            reads.setTraversalBounds(intervalArgumentCollection.getTraversalParameters(getHeaderForReads().getSequenceDictionary()));\n+            reads.setTraversalBounds(userIntervals);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3NDc0NTc0MQ=="}, "originalCommit": {"oid": "e2201c1ef4f8ba71f17e169f07756cfe2f1ecb49"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzYyNzMyNzQ4OnYy", "diffSide": "RIGHT", "path": "src/main/java/org/broadinstitute/hellbender/tools/PrintDistantMates.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0xMlQxNzozODoyMlrOIkvGjQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0xMlQxNzozODoyMlrOIkvGjQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3NTM5MTM3Mw==", "bodyText": "I think these are already defined via htsjdk at eg SAMTag.MC.name().", "url": "https://github.com/broadinstitute/gatk/pull/6989#discussion_r575391373", "createdAt": "2021-02-12T17:38:22Z", "author": {"login": "cwhelan"}, "path": "src/main/java/org/broadinstitute/hellbender/tools/PrintDistantMates.java", "diffHunk": "@@ -0,0 +1,127 @@\n+package org.broadinstitute.hellbender.tools;\n+\n+import htsjdk.samtools.Cigar;\n+import htsjdk.samtools.TextCigarCodec;\n+import org.broadinstitute.barclay.argparser.Argument;\n+import org.broadinstitute.barclay.argparser.CommandLineProgramProperties;\n+import org.broadinstitute.barclay.help.DocumentedFeature;\n+import org.broadinstitute.hellbender.cmdline.StandardArgumentDefinitions;\n+import org.broadinstitute.hellbender.engine.FeatureContext;\n+import org.broadinstitute.hellbender.engine.GATKPath;\n+import org.broadinstitute.hellbender.engine.ReadWalker;\n+import org.broadinstitute.hellbender.engine.ReferenceContext;\n+import org.broadinstitute.hellbender.engine.filters.ReadFilter;\n+import org.broadinstitute.hellbender.engine.filters.ReadFilterLibrary;\n+import org.broadinstitute.hellbender.utils.read.GATKRead;\n+import org.broadinstitute.hellbender.utils.read.SAMFileGATKReadWriter;\n+import picard.cmdline.programgroups.ReadDataManipulationProgramGroup;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+@CommandLineProgramProperties(\n+        summary = \"Prints reads that have distant mates using the mate's alignment information.  Yes, this is weird, but it helps in processing pairs together (see PairWalker).\",\n+        oneLineSummary = \"Print reads with distant mates using the mate's alignment.\",\n+        programGroup = ReadDataManipulationProgramGroup.class\n+)\n+@DocumentedFeature\n+public class PrintDistantMates extends ReadWalker {\n+    @Argument(fullName = StandardArgumentDefinitions.OUTPUT_LONG_NAME,\n+            shortName = StandardArgumentDefinitions.OUTPUT_SHORT_NAME,\n+            doc=\"Write output to this file\")\n+    public GATKPath output;\n+\n+    private SAMFileGATKReadWriter outputWriter;\n+    private Map<String, GATKRead> pendingReads;\n+    private static final String MATE_CIGAR_TAG = \"MC\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e2201c1ef4f8ba71f17e169f07756cfe2f1ecb49"}, "originalPosition": 38}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzYyNzM2MzE3OnYy", "diffSide": "RIGHT", "path": "src/main/java/org/broadinstitute/hellbender/tools/PrintDistantMates.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0xMlQxNzo0NzozN1rOIkvcrw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMy0yNVQxOToxMDowMlrOI95K-A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3NTM5NzAzOQ==", "bodyText": "I think a quick comment for this (\"Provides a CIGAR that forces the alignment length to match the requested value given the actual read length. The CIGAR consists of M operations plus the necessary number of D or I operations to make alignLength equal to readLength.\")", "url": "https://github.com/broadinstitute/gatk/pull/6989#discussion_r575397039", "createdAt": "2021-02-12T17:47:37Z", "author": {"login": "cwhelan"}, "path": "src/main/java/org/broadinstitute/hellbender/tools/PrintDistantMates.java", "diffHunk": "@@ -0,0 +1,127 @@\n+package org.broadinstitute.hellbender.tools;\n+\n+import htsjdk.samtools.Cigar;\n+import htsjdk.samtools.TextCigarCodec;\n+import org.broadinstitute.barclay.argparser.Argument;\n+import org.broadinstitute.barclay.argparser.CommandLineProgramProperties;\n+import org.broadinstitute.barclay.help.DocumentedFeature;\n+import org.broadinstitute.hellbender.cmdline.StandardArgumentDefinitions;\n+import org.broadinstitute.hellbender.engine.FeatureContext;\n+import org.broadinstitute.hellbender.engine.GATKPath;\n+import org.broadinstitute.hellbender.engine.ReadWalker;\n+import org.broadinstitute.hellbender.engine.ReferenceContext;\n+import org.broadinstitute.hellbender.engine.filters.ReadFilter;\n+import org.broadinstitute.hellbender.engine.filters.ReadFilterLibrary;\n+import org.broadinstitute.hellbender.utils.read.GATKRead;\n+import org.broadinstitute.hellbender.utils.read.SAMFileGATKReadWriter;\n+import picard.cmdline.programgroups.ReadDataManipulationProgramGroup;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+@CommandLineProgramProperties(\n+        summary = \"Prints reads that have distant mates using the mate's alignment information.  Yes, this is weird, but it helps in processing pairs together (see PairWalker).\",\n+        oneLineSummary = \"Print reads with distant mates using the mate's alignment.\",\n+        programGroup = ReadDataManipulationProgramGroup.class\n+)\n+@DocumentedFeature\n+public class PrintDistantMates extends ReadWalker {\n+    @Argument(fullName = StandardArgumentDefinitions.OUTPUT_LONG_NAME,\n+            shortName = StandardArgumentDefinitions.OUTPUT_SHORT_NAME,\n+            doc=\"Write output to this file\")\n+    public GATKPath output;\n+\n+    private SAMFileGATKReadWriter outputWriter;\n+    private Map<String, GATKRead> pendingReads;\n+    private static final String MATE_CIGAR_TAG = \"MC\";\n+    private static final String ORIGINAL_CIGAR = \"OC\";\n+\n+    @Override public List<ReadFilter> getDefaultReadFilters() {\n+        final List<ReadFilter> readFilters = new ArrayList<>(super.getDefaultReadFilters());\n+        readFilters.add(ReadFilterLibrary.PAIRED);\n+        readFilters.add(ReadFilterLibrary.PRIMARY_LINE);\n+        readFilters.add(ReadFilterLibrary.NOT_DUPLICATE);\n+        readFilters.add(ReadFilterLibrary.MATE_DISTANT);\n+        return readFilters;\n+    }\n+\n+    @Override\n+    public boolean requiresReads() { return true; }\n+\n+    @Override\n+    public void onTraversalStart() {\n+        outputWriter = createSAMWriter(output, false);\n+        pendingReads = new HashMap<>(20000000);\n+    }\n+\n+    @Override\n+    public void apply( final GATKRead read,\n+                       final ReferenceContext referenceContext,\n+                       final FeatureContext featureContext ) {\n+        final String mateCigarString = read.getAttributeAsString(MATE_CIGAR_TAG);\n+        if ( mateCigarString != null ) {\n+            final Cigar mateCigar = TextCigarCodec.decode(mateCigarString);\n+            outputWriter.addRead(doDistantMateAlterations(read, mateCigar));\n+        } else {\n+            pendingReads.compute(read.getName(), (name, mate) -> {\n+                if ( mate == null ) {\n+                    return read;\n+                }\n+                outputWriter.addRead(doDistantMateAlterations(read, mate.getCigar()));\n+                outputWriter.addRead(doDistantMateAlterations(mate, read.getCigar()));\n+                return null;\n+            });\n+        }\n+    }\n+\n+    @Override\n+    public void closeTool() {\n+        if ( outputWriter != null ) {\n+            outputWriter.close();\n+        }\n+    }\n+\n+    public static GATKRead doDistantMateAlterations( final GATKRead read, final Cigar mateCigar ) {\n+        final GATKRead copy = read.copy();\n+        copy.setPosition(read.getMateContig(), read.getMateStart());\n+        copy.setMatePosition(read.getContig(), read.getStart());\n+        final int mateReadLength = mateCigar.getReadLength();\n+        final int readLength = read.getLength();\n+        if ( mateReadLength == readLength ) {\n+            copy.setCigar(mateCigar);\n+        } else {\n+            final int mateAlignLength = mateCigar.getReferenceLength();\n+            copy.setCigar(bogusCigar(mateAlignLength, readLength));\n+        }\n+        copy.setAttribute(ORIGINAL_CIGAR, read.getCigar().toString());\n+        return copy;\n+    }\n+\n+    public static boolean isDistantMate( final GATKRead read ) {\n+        return read.hasAttribute(ORIGINAL_CIGAR);\n+    }\n+\n+    public static GATKRead undoDistantMateAlterations( final GATKRead read ) {\n+        final String originalCigar = read.getAttributeAsString(ORIGINAL_CIGAR);\n+        if ( originalCigar == null ) return read;\n+        final GATKRead copy = read.copy();\n+        copy.setPosition(read.getMateContig(), read.getMateStart());\n+        copy.setMatePosition(read.getContig(), read.getStart());\n+        copy.setCigar(originalCigar);\n+        copy.clearAttribute(ORIGINAL_CIGAR);\n+        return copy;\n+    }\n+\n+    private static String bogusCigar( final int alignLength, final int readLength ) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e2201c1ef4f8ba71f17e169f07756cfe2f1ecb49"}, "originalPosition": 117}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3NTM5ODUxOQ==", "bodyText": "Maybe also leave a warning about not depending on the CIGAR of these altered reads after running this tool in the main documentation for the class?", "url": "https://github.com/broadinstitute/gatk/pull/6989#discussion_r575398519", "createdAt": "2021-02-12T17:49:08Z", "author": {"login": "cwhelan"}, "path": "src/main/java/org/broadinstitute/hellbender/tools/PrintDistantMates.java", "diffHunk": "@@ -0,0 +1,127 @@\n+package org.broadinstitute.hellbender.tools;\n+\n+import htsjdk.samtools.Cigar;\n+import htsjdk.samtools.TextCigarCodec;\n+import org.broadinstitute.barclay.argparser.Argument;\n+import org.broadinstitute.barclay.argparser.CommandLineProgramProperties;\n+import org.broadinstitute.barclay.help.DocumentedFeature;\n+import org.broadinstitute.hellbender.cmdline.StandardArgumentDefinitions;\n+import org.broadinstitute.hellbender.engine.FeatureContext;\n+import org.broadinstitute.hellbender.engine.GATKPath;\n+import org.broadinstitute.hellbender.engine.ReadWalker;\n+import org.broadinstitute.hellbender.engine.ReferenceContext;\n+import org.broadinstitute.hellbender.engine.filters.ReadFilter;\n+import org.broadinstitute.hellbender.engine.filters.ReadFilterLibrary;\n+import org.broadinstitute.hellbender.utils.read.GATKRead;\n+import org.broadinstitute.hellbender.utils.read.SAMFileGATKReadWriter;\n+import picard.cmdline.programgroups.ReadDataManipulationProgramGroup;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+@CommandLineProgramProperties(\n+        summary = \"Prints reads that have distant mates using the mate's alignment information.  Yes, this is weird, but it helps in processing pairs together (see PairWalker).\",\n+        oneLineSummary = \"Print reads with distant mates using the mate's alignment.\",\n+        programGroup = ReadDataManipulationProgramGroup.class\n+)\n+@DocumentedFeature\n+public class PrintDistantMates extends ReadWalker {\n+    @Argument(fullName = StandardArgumentDefinitions.OUTPUT_LONG_NAME,\n+            shortName = StandardArgumentDefinitions.OUTPUT_SHORT_NAME,\n+            doc=\"Write output to this file\")\n+    public GATKPath output;\n+\n+    private SAMFileGATKReadWriter outputWriter;\n+    private Map<String, GATKRead> pendingReads;\n+    private static final String MATE_CIGAR_TAG = \"MC\";\n+    private static final String ORIGINAL_CIGAR = \"OC\";\n+\n+    @Override public List<ReadFilter> getDefaultReadFilters() {\n+        final List<ReadFilter> readFilters = new ArrayList<>(super.getDefaultReadFilters());\n+        readFilters.add(ReadFilterLibrary.PAIRED);\n+        readFilters.add(ReadFilterLibrary.PRIMARY_LINE);\n+        readFilters.add(ReadFilterLibrary.NOT_DUPLICATE);\n+        readFilters.add(ReadFilterLibrary.MATE_DISTANT);\n+        return readFilters;\n+    }\n+\n+    @Override\n+    public boolean requiresReads() { return true; }\n+\n+    @Override\n+    public void onTraversalStart() {\n+        outputWriter = createSAMWriter(output, false);\n+        pendingReads = new HashMap<>(20000000);\n+    }\n+\n+    @Override\n+    public void apply( final GATKRead read,\n+                       final ReferenceContext referenceContext,\n+                       final FeatureContext featureContext ) {\n+        final String mateCigarString = read.getAttributeAsString(MATE_CIGAR_TAG);\n+        if ( mateCigarString != null ) {\n+            final Cigar mateCigar = TextCigarCodec.decode(mateCigarString);\n+            outputWriter.addRead(doDistantMateAlterations(read, mateCigar));\n+        } else {\n+            pendingReads.compute(read.getName(), (name, mate) -> {\n+                if ( mate == null ) {\n+                    return read;\n+                }\n+                outputWriter.addRead(doDistantMateAlterations(read, mate.getCigar()));\n+                outputWriter.addRead(doDistantMateAlterations(mate, read.getCigar()));\n+                return null;\n+            });\n+        }\n+    }\n+\n+    @Override\n+    public void closeTool() {\n+        if ( outputWriter != null ) {\n+            outputWriter.close();\n+        }\n+    }\n+\n+    public static GATKRead doDistantMateAlterations( final GATKRead read, final Cigar mateCigar ) {\n+        final GATKRead copy = read.copy();\n+        copy.setPosition(read.getMateContig(), read.getMateStart());\n+        copy.setMatePosition(read.getContig(), read.getStart());\n+        final int mateReadLength = mateCigar.getReadLength();\n+        final int readLength = read.getLength();\n+        if ( mateReadLength == readLength ) {\n+            copy.setCigar(mateCigar);\n+        } else {\n+            final int mateAlignLength = mateCigar.getReferenceLength();\n+            copy.setCigar(bogusCigar(mateAlignLength, readLength));\n+        }\n+        copy.setAttribute(ORIGINAL_CIGAR, read.getCigar().toString());\n+        return copy;\n+    }\n+\n+    public static boolean isDistantMate( final GATKRead read ) {\n+        return read.hasAttribute(ORIGINAL_CIGAR);\n+    }\n+\n+    public static GATKRead undoDistantMateAlterations( final GATKRead read ) {\n+        final String originalCigar = read.getAttributeAsString(ORIGINAL_CIGAR);\n+        if ( originalCigar == null ) return read;\n+        final GATKRead copy = read.copy();\n+        copy.setPosition(read.getMateContig(), read.getMateStart());\n+        copy.setMatePosition(read.getContig(), read.getStart());\n+        copy.setCigar(originalCigar);\n+        copy.clearAttribute(ORIGINAL_CIGAR);\n+        return copy;\n+    }\n+\n+    private static String bogusCigar( final int alignLength, final int readLength ) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3NTM5NzAzOQ=="}, "originalCommit": {"oid": "e2201c1ef4f8ba71f17e169f07756cfe2f1ecb49"}, "originalPosition": 117}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMTc3MDc0NA==", "bodyText": "All this silly jazz is gone.", "url": "https://github.com/broadinstitute/gatk/pull/6989#discussion_r601770744", "createdAt": "2021-03-25T19:10:02Z", "author": {"login": "tedsharpe"}, "path": "src/main/java/org/broadinstitute/hellbender/tools/PrintDistantMates.java", "diffHunk": "@@ -0,0 +1,127 @@\n+package org.broadinstitute.hellbender.tools;\n+\n+import htsjdk.samtools.Cigar;\n+import htsjdk.samtools.TextCigarCodec;\n+import org.broadinstitute.barclay.argparser.Argument;\n+import org.broadinstitute.barclay.argparser.CommandLineProgramProperties;\n+import org.broadinstitute.barclay.help.DocumentedFeature;\n+import org.broadinstitute.hellbender.cmdline.StandardArgumentDefinitions;\n+import org.broadinstitute.hellbender.engine.FeatureContext;\n+import org.broadinstitute.hellbender.engine.GATKPath;\n+import org.broadinstitute.hellbender.engine.ReadWalker;\n+import org.broadinstitute.hellbender.engine.ReferenceContext;\n+import org.broadinstitute.hellbender.engine.filters.ReadFilter;\n+import org.broadinstitute.hellbender.engine.filters.ReadFilterLibrary;\n+import org.broadinstitute.hellbender.utils.read.GATKRead;\n+import org.broadinstitute.hellbender.utils.read.SAMFileGATKReadWriter;\n+import picard.cmdline.programgroups.ReadDataManipulationProgramGroup;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+@CommandLineProgramProperties(\n+        summary = \"Prints reads that have distant mates using the mate's alignment information.  Yes, this is weird, but it helps in processing pairs together (see PairWalker).\",\n+        oneLineSummary = \"Print reads with distant mates using the mate's alignment.\",\n+        programGroup = ReadDataManipulationProgramGroup.class\n+)\n+@DocumentedFeature\n+public class PrintDistantMates extends ReadWalker {\n+    @Argument(fullName = StandardArgumentDefinitions.OUTPUT_LONG_NAME,\n+            shortName = StandardArgumentDefinitions.OUTPUT_SHORT_NAME,\n+            doc=\"Write output to this file\")\n+    public GATKPath output;\n+\n+    private SAMFileGATKReadWriter outputWriter;\n+    private Map<String, GATKRead> pendingReads;\n+    private static final String MATE_CIGAR_TAG = \"MC\";\n+    private static final String ORIGINAL_CIGAR = \"OC\";\n+\n+    @Override public List<ReadFilter> getDefaultReadFilters() {\n+        final List<ReadFilter> readFilters = new ArrayList<>(super.getDefaultReadFilters());\n+        readFilters.add(ReadFilterLibrary.PAIRED);\n+        readFilters.add(ReadFilterLibrary.PRIMARY_LINE);\n+        readFilters.add(ReadFilterLibrary.NOT_DUPLICATE);\n+        readFilters.add(ReadFilterLibrary.MATE_DISTANT);\n+        return readFilters;\n+    }\n+\n+    @Override\n+    public boolean requiresReads() { return true; }\n+\n+    @Override\n+    public void onTraversalStart() {\n+        outputWriter = createSAMWriter(output, false);\n+        pendingReads = new HashMap<>(20000000);\n+    }\n+\n+    @Override\n+    public void apply( final GATKRead read,\n+                       final ReferenceContext referenceContext,\n+                       final FeatureContext featureContext ) {\n+        final String mateCigarString = read.getAttributeAsString(MATE_CIGAR_TAG);\n+        if ( mateCigarString != null ) {\n+            final Cigar mateCigar = TextCigarCodec.decode(mateCigarString);\n+            outputWriter.addRead(doDistantMateAlterations(read, mateCigar));\n+        } else {\n+            pendingReads.compute(read.getName(), (name, mate) -> {\n+                if ( mate == null ) {\n+                    return read;\n+                }\n+                outputWriter.addRead(doDistantMateAlterations(read, mate.getCigar()));\n+                outputWriter.addRead(doDistantMateAlterations(mate, read.getCigar()));\n+                return null;\n+            });\n+        }\n+    }\n+\n+    @Override\n+    public void closeTool() {\n+        if ( outputWriter != null ) {\n+            outputWriter.close();\n+        }\n+    }\n+\n+    public static GATKRead doDistantMateAlterations( final GATKRead read, final Cigar mateCigar ) {\n+        final GATKRead copy = read.copy();\n+        copy.setPosition(read.getMateContig(), read.getMateStart());\n+        copy.setMatePosition(read.getContig(), read.getStart());\n+        final int mateReadLength = mateCigar.getReadLength();\n+        final int readLength = read.getLength();\n+        if ( mateReadLength == readLength ) {\n+            copy.setCigar(mateCigar);\n+        } else {\n+            final int mateAlignLength = mateCigar.getReferenceLength();\n+            copy.setCigar(bogusCigar(mateAlignLength, readLength));\n+        }\n+        copy.setAttribute(ORIGINAL_CIGAR, read.getCigar().toString());\n+        return copy;\n+    }\n+\n+    public static boolean isDistantMate( final GATKRead read ) {\n+        return read.hasAttribute(ORIGINAL_CIGAR);\n+    }\n+\n+    public static GATKRead undoDistantMateAlterations( final GATKRead read ) {\n+        final String originalCigar = read.getAttributeAsString(ORIGINAL_CIGAR);\n+        if ( originalCigar == null ) return read;\n+        final GATKRead copy = read.copy();\n+        copy.setPosition(read.getMateContig(), read.getMateStart());\n+        copy.setMatePosition(read.getContig(), read.getStart());\n+        copy.setCigar(originalCigar);\n+        copy.clearAttribute(ORIGINAL_CIGAR);\n+        return copy;\n+    }\n+\n+    private static String bogusCigar( final int alignLength, final int readLength ) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3NTM5NzAzOQ=="}, "originalCommit": {"oid": "e2201c1ef4f8ba71f17e169f07756cfe2f1ecb49"}, "originalPosition": 117}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzYyNzQwODQ3OnYy", "diffSide": "RIGHT", "path": "src/main/java/org/broadinstitute/hellbender/tools/PrintDistantMates.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0xMlQxNzo1NDoyOVrOIkv2uQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMy0yNVQxOToxNDowOVrOI95UeQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3NTQwMzcwNQ==", "bodyText": "If for some reason the first read has a mate cigar but the second read doesn't, it seems like this would never output an altered version of the mate. I don't know if that would ever happen or not, just thinking defensively. You could maybe add a check in closeTool() to see if there are still entries in pendingReads that never got resolved and at least emit some warnings if that's the case.", "url": "https://github.com/broadinstitute/gatk/pull/6989#discussion_r575403705", "createdAt": "2021-02-12T17:54:29Z", "author": {"login": "cwhelan"}, "path": "src/main/java/org/broadinstitute/hellbender/tools/PrintDistantMates.java", "diffHunk": "@@ -0,0 +1,127 @@\n+package org.broadinstitute.hellbender.tools;\n+\n+import htsjdk.samtools.Cigar;\n+import htsjdk.samtools.TextCigarCodec;\n+import org.broadinstitute.barclay.argparser.Argument;\n+import org.broadinstitute.barclay.argparser.CommandLineProgramProperties;\n+import org.broadinstitute.barclay.help.DocumentedFeature;\n+import org.broadinstitute.hellbender.cmdline.StandardArgumentDefinitions;\n+import org.broadinstitute.hellbender.engine.FeatureContext;\n+import org.broadinstitute.hellbender.engine.GATKPath;\n+import org.broadinstitute.hellbender.engine.ReadWalker;\n+import org.broadinstitute.hellbender.engine.ReferenceContext;\n+import org.broadinstitute.hellbender.engine.filters.ReadFilter;\n+import org.broadinstitute.hellbender.engine.filters.ReadFilterLibrary;\n+import org.broadinstitute.hellbender.utils.read.GATKRead;\n+import org.broadinstitute.hellbender.utils.read.SAMFileGATKReadWriter;\n+import picard.cmdline.programgroups.ReadDataManipulationProgramGroup;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+@CommandLineProgramProperties(\n+        summary = \"Prints reads that have distant mates using the mate's alignment information.  Yes, this is weird, but it helps in processing pairs together (see PairWalker).\",\n+        oneLineSummary = \"Print reads with distant mates using the mate's alignment.\",\n+        programGroup = ReadDataManipulationProgramGroup.class\n+)\n+@DocumentedFeature\n+public class PrintDistantMates extends ReadWalker {\n+    @Argument(fullName = StandardArgumentDefinitions.OUTPUT_LONG_NAME,\n+            shortName = StandardArgumentDefinitions.OUTPUT_SHORT_NAME,\n+            doc=\"Write output to this file\")\n+    public GATKPath output;\n+\n+    private SAMFileGATKReadWriter outputWriter;\n+    private Map<String, GATKRead> pendingReads;\n+    private static final String MATE_CIGAR_TAG = \"MC\";\n+    private static final String ORIGINAL_CIGAR = \"OC\";\n+\n+    @Override public List<ReadFilter> getDefaultReadFilters() {\n+        final List<ReadFilter> readFilters = new ArrayList<>(super.getDefaultReadFilters());\n+        readFilters.add(ReadFilterLibrary.PAIRED);\n+        readFilters.add(ReadFilterLibrary.PRIMARY_LINE);\n+        readFilters.add(ReadFilterLibrary.NOT_DUPLICATE);\n+        readFilters.add(ReadFilterLibrary.MATE_DISTANT);\n+        return readFilters;\n+    }\n+\n+    @Override\n+    public boolean requiresReads() { return true; }\n+\n+    @Override\n+    public void onTraversalStart() {\n+        outputWriter = createSAMWriter(output, false);\n+        pendingReads = new HashMap<>(20000000);\n+    }\n+\n+    @Override\n+    public void apply( final GATKRead read,\n+                       final ReferenceContext referenceContext,\n+                       final FeatureContext featureContext ) {\n+        final String mateCigarString = read.getAttributeAsString(MATE_CIGAR_TAG);\n+        if ( mateCigarString != null ) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e2201c1ef4f8ba71f17e169f07756cfe2f1ecb49"}, "originalPosition": 64}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMTc3MzE3Nw==", "bodyText": "I've rewritten the tool to take a much simpler approach.  It now just unmaps (but places) distant mates.  The original alignment is saved in an OA tag, so we can redo the mapping in the PairWalker.  We don't need mate cigars.  And, even better, the resulting output BAM contains no lies (by which I mean fictitious alignments).", "url": "https://github.com/broadinstitute/gatk/pull/6989#discussion_r601773177", "createdAt": "2021-03-25T19:14:09Z", "author": {"login": "tedsharpe"}, "path": "src/main/java/org/broadinstitute/hellbender/tools/PrintDistantMates.java", "diffHunk": "@@ -0,0 +1,127 @@\n+package org.broadinstitute.hellbender.tools;\n+\n+import htsjdk.samtools.Cigar;\n+import htsjdk.samtools.TextCigarCodec;\n+import org.broadinstitute.barclay.argparser.Argument;\n+import org.broadinstitute.barclay.argparser.CommandLineProgramProperties;\n+import org.broadinstitute.barclay.help.DocumentedFeature;\n+import org.broadinstitute.hellbender.cmdline.StandardArgumentDefinitions;\n+import org.broadinstitute.hellbender.engine.FeatureContext;\n+import org.broadinstitute.hellbender.engine.GATKPath;\n+import org.broadinstitute.hellbender.engine.ReadWalker;\n+import org.broadinstitute.hellbender.engine.ReferenceContext;\n+import org.broadinstitute.hellbender.engine.filters.ReadFilter;\n+import org.broadinstitute.hellbender.engine.filters.ReadFilterLibrary;\n+import org.broadinstitute.hellbender.utils.read.GATKRead;\n+import org.broadinstitute.hellbender.utils.read.SAMFileGATKReadWriter;\n+import picard.cmdline.programgroups.ReadDataManipulationProgramGroup;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+@CommandLineProgramProperties(\n+        summary = \"Prints reads that have distant mates using the mate's alignment information.  Yes, this is weird, but it helps in processing pairs together (see PairWalker).\",\n+        oneLineSummary = \"Print reads with distant mates using the mate's alignment.\",\n+        programGroup = ReadDataManipulationProgramGroup.class\n+)\n+@DocumentedFeature\n+public class PrintDistantMates extends ReadWalker {\n+    @Argument(fullName = StandardArgumentDefinitions.OUTPUT_LONG_NAME,\n+            shortName = StandardArgumentDefinitions.OUTPUT_SHORT_NAME,\n+            doc=\"Write output to this file\")\n+    public GATKPath output;\n+\n+    private SAMFileGATKReadWriter outputWriter;\n+    private Map<String, GATKRead> pendingReads;\n+    private static final String MATE_CIGAR_TAG = \"MC\";\n+    private static final String ORIGINAL_CIGAR = \"OC\";\n+\n+    @Override public List<ReadFilter> getDefaultReadFilters() {\n+        final List<ReadFilter> readFilters = new ArrayList<>(super.getDefaultReadFilters());\n+        readFilters.add(ReadFilterLibrary.PAIRED);\n+        readFilters.add(ReadFilterLibrary.PRIMARY_LINE);\n+        readFilters.add(ReadFilterLibrary.NOT_DUPLICATE);\n+        readFilters.add(ReadFilterLibrary.MATE_DISTANT);\n+        return readFilters;\n+    }\n+\n+    @Override\n+    public boolean requiresReads() { return true; }\n+\n+    @Override\n+    public void onTraversalStart() {\n+        outputWriter = createSAMWriter(output, false);\n+        pendingReads = new HashMap<>(20000000);\n+    }\n+\n+    @Override\n+    public void apply( final GATKRead read,\n+                       final ReferenceContext referenceContext,\n+                       final FeatureContext featureContext ) {\n+        final String mateCigarString = read.getAttributeAsString(MATE_CIGAR_TAG);\n+        if ( mateCigarString != null ) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3NTQwMzcwNQ=="}, "originalCommit": {"oid": "e2201c1ef4f8ba71f17e169f07756cfe2f1ecb49"}, "originalPosition": 64}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzYyNzQyMTQ2OnYy", "diffSide": "RIGHT", "path": "src/main/java/org/broadinstitute/hellbender/tools/LocalAssembler.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0xMlQxNzo1NjozN1rOIkv-bA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0xMlQxNzo1NjozN1rOIkv-bA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3NTQwNTY3Ng==", "bodyText": "It might be good to expose some of these (in particular, this one and QMIN) as optional parameters that could be played with depending on the coverage or other factors.", "url": "https://github.com/broadinstitute/gatk/pull/6989#discussion_r575405676", "createdAt": "2021-02-12T17:56:37Z", "author": {"login": "cwhelan"}, "path": "src/main/java/org/broadinstitute/hellbender/tools/LocalAssembler.java", "diffHunk": "@@ -0,0 +1,2306 @@\n+package org.broadinstitute.hellbender.tools;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import htsjdk.samtools.Cigar;\n+import htsjdk.samtools.CigarElement;\n+import htsjdk.samtools.CigarOperator;\n+import htsjdk.samtools.SAMUtils;\n+import org.broadinstitute.barclay.argparser.Argument;\n+import org.broadinstitute.barclay.argparser.BetaFeature;\n+import org.broadinstitute.barclay.argparser.CommandLineProgramProperties;\n+import org.broadinstitute.barclay.help.DocumentedFeature;\n+import org.broadinstitute.hellbender.cmdline.StandardArgumentDefinitions;\n+import org.broadinstitute.hellbender.cmdline.programgroups.CoverageAnalysisProgramGroup;\n+import org.broadinstitute.hellbender.exceptions.GATKException;\n+import org.broadinstitute.hellbender.tools.walkers.PairWalker;\n+import org.broadinstitute.hellbender.utils.SimpleInterval;\n+import org.broadinstitute.hellbender.utils.collections.HopscotchSet;\n+import org.broadinstitute.hellbender.utils.gcs.BucketUtils;\n+import org.broadinstitute.hellbender.utils.read.GATKRead;\n+\n+import java.io.BufferedWriter;\n+import java.io.FileWriter;\n+import java.io.IOException;\n+import java.io.OutputStreamWriter;\n+import java.util.*;\n+import java.util.zip.GZIPOutputStream;\n+\n+@DocumentedFeature\n+@CommandLineProgramProperties(\n+        summary = \"experiment\",\n+        oneLineSummary = \"experiment\",\n+        usageExample = \"gatk LocalAssembler\",\n+        programGroup = CoverageAnalysisProgramGroup.class\n+)\n+@BetaFeature\n+public class LocalAssembler extends PairWalker {\n+    public static final byte QMIN = 25;\n+    public static final int MIN_THIN_OBS = 4;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e2201c1ef4f8ba71f17e169f07756cfe2f1ecb49"}, "originalPosition": 38}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzYzOTQ5MjU4OnYy", "diffSide": "RIGHT", "path": "src/main/java/org/broadinstitute/hellbender/tools/LocalAssembler.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0xNlQyMToyNDo0NFrOImaT5g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0xNlQyMToyNDo0NFrOImaT5g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3NzE0Nzg3OA==", "bodyText": "I'd love to see a small unit test for this method, mostly just to help document what it does.", "url": "https://github.com/broadinstitute/gatk/pull/6989#discussion_r577147878", "createdAt": "2021-02-16T21:24:44Z", "author": {"login": "cwhelan"}, "path": "src/main/java/org/broadinstitute/hellbender/tools/LocalAssembler.java", "diffHunk": "@@ -0,0 +1,2306 @@\n+package org.broadinstitute.hellbender.tools;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import htsjdk.samtools.Cigar;\n+import htsjdk.samtools.CigarElement;\n+import htsjdk.samtools.CigarOperator;\n+import htsjdk.samtools.SAMUtils;\n+import org.broadinstitute.barclay.argparser.Argument;\n+import org.broadinstitute.barclay.argparser.BetaFeature;\n+import org.broadinstitute.barclay.argparser.CommandLineProgramProperties;\n+import org.broadinstitute.barclay.help.DocumentedFeature;\n+import org.broadinstitute.hellbender.cmdline.StandardArgumentDefinitions;\n+import org.broadinstitute.hellbender.cmdline.programgroups.CoverageAnalysisProgramGroup;\n+import org.broadinstitute.hellbender.exceptions.GATKException;\n+import org.broadinstitute.hellbender.tools.walkers.PairWalker;\n+import org.broadinstitute.hellbender.utils.SimpleInterval;\n+import org.broadinstitute.hellbender.utils.collections.HopscotchSet;\n+import org.broadinstitute.hellbender.utils.gcs.BucketUtils;\n+import org.broadinstitute.hellbender.utils.read.GATKRead;\n+\n+import java.io.BufferedWriter;\n+import java.io.FileWriter;\n+import java.io.IOException;\n+import java.io.OutputStreamWriter;\n+import java.util.*;\n+import java.util.zip.GZIPOutputStream;\n+\n+@DocumentedFeature\n+@CommandLineProgramProperties(\n+        summary = \"experiment\",\n+        oneLineSummary = \"experiment\",\n+        usageExample = \"gatk LocalAssembler\",\n+        programGroup = CoverageAnalysisProgramGroup.class\n+)\n+@BetaFeature\n+public class LocalAssembler extends PairWalker {\n+    public static final byte QMIN = 25;\n+    public static final int MIN_THIN_OBS = 4;\n+    public static final int MIN_GAPFILL_COUNT = 3;\n+    public static final int TOO_MANY_TRAVERSALS = 100000;\n+    public static final int TOO_MANY_SCAFFOLDS = 50000;\n+    public static final int MIN_SV_SIZE = 50;\n+\n+    @Argument(fullName=StandardArgumentDefinitions.OUTPUT_LONG_NAME,\n+            shortName=StandardArgumentDefinitions.OUTPUT_SHORT_NAME,\n+            doc=\"Write outputs to this file name prefix\", optional = true)\n+    public static String output;\n+\n+    @Argument(fullName=\"assembly-name\", doc=\"name of assembly used as a prefix for traversal names\")\n+    public static String assemblyName;\n+\n+    private final List<GATKRead> reads = new ArrayList<>();\n+\n+    @Override public boolean requiresIntervals() { return true; }\n+\n+    @Override public void apply( final GATKRead read, final GATKRead mate ) {\n+        trimOverruns(read, mate);\n+        reads.add(read);\n+        reads.add(mate);\n+    }\n+\n+    @Override public void applyUnpaired( final GATKRead read ) {\n+        reads.add(read);\n+    }\n+\n+    @Override public Object onTraversalSuccess() {\n+        super.onTraversalSuccess(); // flush any incomplete pairs\n+\n+        final int regionSize = getTraversalIntervals().stream().mapToInt(SimpleInterval::size).sum();\n+        final KmerSet<KmerAdjacency> kmerAdjacencySet = new KmerSet<>(10 * regionSize);\n+        kmerizeReads(reads, kmerAdjacencySet);\n+        List<ContigImpl> contigs = buildContigs(kmerAdjacencySet);\n+        connectContigs(contigs);\n+\n+        removeThinContigs(contigs, kmerAdjacencySet);\n+        weldPipes(contigs);\n+        markComponents(contigs);\n+\n+        if ( fillGaps(kmerAdjacencySet, reads) ) {\n+            contigs = buildContigs(kmerAdjacencySet);\n+            connectContigs(contigs);\n+            removeThinContigs(contigs, kmerAdjacencySet);\n+            weldPipes(contigs);\n+            markComponents(contigs);\n+        }\n+\n+        markCycles(contigs);\n+\n+        final String outputFilePrefix = output != null ? output : assemblyName;\n+        final List<Path> readPaths = pathReads(kmerAdjacencySet, reads);\n+        final Map<Contig,List<TransitPairCount>> contigTransitsMap =\n+                collectTransitPairCounts(contigs, readPaths);\n+        final String traversalsFilename = outputFilePrefix + \".traversals.fa.gz\";\n+        try {\n+            final List<Traversal> allTraversals =\n+                    new ArrayList<>(traverseAllPaths(contigs, readPaths, contigTransitsMap));\n+            writeTraversals(allTraversals, traversalsFilename);\n+            try {\n+                final String scaffoldsFileName = outputFilePrefix + \".scaffolds.fa.gz\";\n+                writeTraversals(createScaffolds(allTraversals), scaffoldsFileName);\n+            } catch ( final AssemblyTooComplexException x ) {\n+                logger.warn(\"Assembly too complex for scaffolding.\");\n+            }\n+        } catch ( final AssemblyTooComplexException x ) {\n+            logger.warn(\"Assembly too complex.  Writing contigs as traversals in \" +\n+                    traversalsFilename + \".\");\n+            final Collection<Traversal> contigTraversals = new ArrayList<>(contigs.size());\n+            for ( final Contig contig : contigs ) {\n+                contigTraversals.add(new Traversal(Collections.singletonList(contig)));\n+            }\n+            writeTraversals(contigTraversals, traversalsFilename);\n+        }\n+\n+        contigs.sort(Comparator.comparingInt(ContigImpl::getId));\n+        writeDOT(contigs, outputFilePrefix + \".assembly.dot\");\n+        writeContigs(contigs, outputFilePrefix + \".contigs.txt.gz\");\n+        writePaths(readPaths, outputFilePrefix + \".paths.txt.gz\");\n+        writeReads(reads, outputFilePrefix + \".reads.fastq.gz\");\n+        return null;\n+    }\n+\n+    /** trim read pairs of base calls that have gone past the end of a short fragment */\n+    private void trimOverruns( final GATKRead read, final GATKRead mate ) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e2201c1ef4f8ba71f17e169f07756cfe2f1ecb49"}, "originalPosition": 123}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzczNDkzMjYyOnYy", "diffSide": "RIGHT", "path": "src/main/java/org/broadinstitute/hellbender/tools/LocalAssembler.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMy0xMFQxMzo1NDo1NFrOI0IRJA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMy0xMFQxMzo1NDo1NFrOI0IRJA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MTUzMjMyNA==", "bodyText": "I'm curious as to whether you thought about writing results in GFA format? Might be useful for interoperability with other tools that might want to process the results of the assembly.", "url": "https://github.com/broadinstitute/gatk/pull/6989#discussion_r591532324", "createdAt": "2021-03-10T13:54:54Z", "author": {"login": "cwhelan"}, "path": "src/main/java/org/broadinstitute/hellbender/tools/LocalAssembler.java", "diffHunk": "@@ -0,0 +1,2306 @@\n+package org.broadinstitute.hellbender.tools;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import htsjdk.samtools.Cigar;\n+import htsjdk.samtools.CigarElement;\n+import htsjdk.samtools.CigarOperator;\n+import htsjdk.samtools.SAMUtils;\n+import org.broadinstitute.barclay.argparser.Argument;\n+import org.broadinstitute.barclay.argparser.BetaFeature;\n+import org.broadinstitute.barclay.argparser.CommandLineProgramProperties;\n+import org.broadinstitute.barclay.help.DocumentedFeature;\n+import org.broadinstitute.hellbender.cmdline.StandardArgumentDefinitions;\n+import org.broadinstitute.hellbender.cmdline.programgroups.CoverageAnalysisProgramGroup;\n+import org.broadinstitute.hellbender.exceptions.GATKException;\n+import org.broadinstitute.hellbender.tools.walkers.PairWalker;\n+import org.broadinstitute.hellbender.utils.SimpleInterval;\n+import org.broadinstitute.hellbender.utils.collections.HopscotchSet;\n+import org.broadinstitute.hellbender.utils.gcs.BucketUtils;\n+import org.broadinstitute.hellbender.utils.read.GATKRead;\n+\n+import java.io.BufferedWriter;\n+import java.io.FileWriter;\n+import java.io.IOException;\n+import java.io.OutputStreamWriter;\n+import java.util.*;\n+import java.util.zip.GZIPOutputStream;\n+\n+@DocumentedFeature\n+@CommandLineProgramProperties(\n+        summary = \"experiment\",\n+        oneLineSummary = \"experiment\",\n+        usageExample = \"gatk LocalAssembler\",\n+        programGroup = CoverageAnalysisProgramGroup.class\n+)\n+@BetaFeature\n+public class LocalAssembler extends PairWalker {\n+    public static final byte QMIN = 25;\n+    public static final int MIN_THIN_OBS = 4;\n+    public static final int MIN_GAPFILL_COUNT = 3;\n+    public static final int TOO_MANY_TRAVERSALS = 100000;\n+    public static final int TOO_MANY_SCAFFOLDS = 50000;\n+    public static final int MIN_SV_SIZE = 50;\n+\n+    @Argument(fullName=StandardArgumentDefinitions.OUTPUT_LONG_NAME,\n+            shortName=StandardArgumentDefinitions.OUTPUT_SHORT_NAME,\n+            doc=\"Write outputs to this file name prefix\", optional = true)\n+    public static String output;\n+\n+    @Argument(fullName=\"assembly-name\", doc=\"name of assembly used as a prefix for traversal names\")\n+    public static String assemblyName;\n+\n+    private final List<GATKRead> reads = new ArrayList<>();\n+\n+    @Override public boolean requiresIntervals() { return true; }\n+\n+    @Override public void apply( final GATKRead read, final GATKRead mate ) {\n+        trimOverruns(read, mate);\n+        reads.add(read);\n+        reads.add(mate);\n+    }\n+\n+    @Override public void applyUnpaired( final GATKRead read ) {\n+        reads.add(read);\n+    }\n+\n+    @Override public Object onTraversalSuccess() {\n+        super.onTraversalSuccess(); // flush any incomplete pairs\n+\n+        final int regionSize = getTraversalIntervals().stream().mapToInt(SimpleInterval::size).sum();\n+        final KmerSet<KmerAdjacency> kmerAdjacencySet = new KmerSet<>(10 * regionSize);\n+        kmerizeReads(reads, kmerAdjacencySet);\n+        List<ContigImpl> contigs = buildContigs(kmerAdjacencySet);\n+        connectContigs(contigs);\n+\n+        removeThinContigs(contigs, kmerAdjacencySet);\n+        weldPipes(contigs);\n+        markComponents(contigs);\n+\n+        if ( fillGaps(kmerAdjacencySet, reads) ) {\n+            contigs = buildContigs(kmerAdjacencySet);\n+            connectContigs(contigs);\n+            removeThinContigs(contigs, kmerAdjacencySet);\n+            weldPipes(contigs);\n+            markComponents(contigs);\n+        }\n+\n+        markCycles(contigs);\n+\n+        final String outputFilePrefix = output != null ? output : assemblyName;\n+        final List<Path> readPaths = pathReads(kmerAdjacencySet, reads);\n+        final Map<Contig,List<TransitPairCount>> contigTransitsMap =\n+                collectTransitPairCounts(contigs, readPaths);\n+        final String traversalsFilename = outputFilePrefix + \".traversals.fa.gz\";\n+        try {\n+            final List<Traversal> allTraversals =\n+                    new ArrayList<>(traverseAllPaths(contigs, readPaths, contigTransitsMap));\n+            writeTraversals(allTraversals, traversalsFilename);\n+            try {\n+                final String scaffoldsFileName = outputFilePrefix + \".scaffolds.fa.gz\";\n+                writeTraversals(createScaffolds(allTraversals), scaffoldsFileName);\n+            } catch ( final AssemblyTooComplexException x ) {\n+                logger.warn(\"Assembly too complex for scaffolding.\");\n+            }\n+        } catch ( final AssemblyTooComplexException x ) {\n+            logger.warn(\"Assembly too complex.  Writing contigs as traversals in \" +\n+                    traversalsFilename + \".\");\n+            final Collection<Traversal> contigTraversals = new ArrayList<>(contigs.size());\n+            for ( final Contig contig : contigs ) {\n+                contigTraversals.add(new Traversal(Collections.singletonList(contig)));\n+            }\n+            writeTraversals(contigTraversals, traversalsFilename);\n+        }\n+\n+        contigs.sort(Comparator.comparingInt(ContigImpl::getId));\n+        writeDOT(contigs, outputFilePrefix + \".assembly.dot\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e2201c1ef4f8ba71f17e169f07756cfe2f1ecb49"}, "originalPosition": 115}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzczNDk0NzIxOnYy", "diffSide": "RIGHT", "path": "src/main/java/org/broadinstitute/hellbender/tools/LocalAssembler.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMy0xMFQxMzo1NzoxMFrOI0IaPQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNC0xMlQxOTo0MTowNlrOJHjrsA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MTUzNDY1Mw==", "bodyText": "What's the reason for allowing 1 base of overhang? Is it due to something technical or just a cutoff you thought was appropriate?", "url": "https://github.com/broadinstitute/gatk/pull/6989#discussion_r591534653", "createdAt": "2021-03-10T13:57:10Z", "author": {"login": "cwhelan"}, "path": "src/main/java/org/broadinstitute/hellbender/tools/LocalAssembler.java", "diffHunk": "@@ -0,0 +1,2306 @@\n+package org.broadinstitute.hellbender.tools;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import htsjdk.samtools.Cigar;\n+import htsjdk.samtools.CigarElement;\n+import htsjdk.samtools.CigarOperator;\n+import htsjdk.samtools.SAMUtils;\n+import org.broadinstitute.barclay.argparser.Argument;\n+import org.broadinstitute.barclay.argparser.BetaFeature;\n+import org.broadinstitute.barclay.argparser.CommandLineProgramProperties;\n+import org.broadinstitute.barclay.help.DocumentedFeature;\n+import org.broadinstitute.hellbender.cmdline.StandardArgumentDefinitions;\n+import org.broadinstitute.hellbender.cmdline.programgroups.CoverageAnalysisProgramGroup;\n+import org.broadinstitute.hellbender.exceptions.GATKException;\n+import org.broadinstitute.hellbender.tools.walkers.PairWalker;\n+import org.broadinstitute.hellbender.utils.SimpleInterval;\n+import org.broadinstitute.hellbender.utils.collections.HopscotchSet;\n+import org.broadinstitute.hellbender.utils.gcs.BucketUtils;\n+import org.broadinstitute.hellbender.utils.read.GATKRead;\n+\n+import java.io.BufferedWriter;\n+import java.io.FileWriter;\n+import java.io.IOException;\n+import java.io.OutputStreamWriter;\n+import java.util.*;\n+import java.util.zip.GZIPOutputStream;\n+\n+@DocumentedFeature\n+@CommandLineProgramProperties(\n+        summary = \"experiment\",\n+        oneLineSummary = \"experiment\",\n+        usageExample = \"gatk LocalAssembler\",\n+        programGroup = CoverageAnalysisProgramGroup.class\n+)\n+@BetaFeature\n+public class LocalAssembler extends PairWalker {\n+    public static final byte QMIN = 25;\n+    public static final int MIN_THIN_OBS = 4;\n+    public static final int MIN_GAPFILL_COUNT = 3;\n+    public static final int TOO_MANY_TRAVERSALS = 100000;\n+    public static final int TOO_MANY_SCAFFOLDS = 50000;\n+    public static final int MIN_SV_SIZE = 50;\n+\n+    @Argument(fullName=StandardArgumentDefinitions.OUTPUT_LONG_NAME,\n+            shortName=StandardArgumentDefinitions.OUTPUT_SHORT_NAME,\n+            doc=\"Write outputs to this file name prefix\", optional = true)\n+    public static String output;\n+\n+    @Argument(fullName=\"assembly-name\", doc=\"name of assembly used as a prefix for traversal names\")\n+    public static String assemblyName;\n+\n+    private final List<GATKRead> reads = new ArrayList<>();\n+\n+    @Override public boolean requiresIntervals() { return true; }\n+\n+    @Override public void apply( final GATKRead read, final GATKRead mate ) {\n+        trimOverruns(read, mate);\n+        reads.add(read);\n+        reads.add(mate);\n+    }\n+\n+    @Override public void applyUnpaired( final GATKRead read ) {\n+        reads.add(read);\n+    }\n+\n+    @Override public Object onTraversalSuccess() {\n+        super.onTraversalSuccess(); // flush any incomplete pairs\n+\n+        final int regionSize = getTraversalIntervals().stream().mapToInt(SimpleInterval::size).sum();\n+        final KmerSet<KmerAdjacency> kmerAdjacencySet = new KmerSet<>(10 * regionSize);\n+        kmerizeReads(reads, kmerAdjacencySet);\n+        List<ContigImpl> contigs = buildContigs(kmerAdjacencySet);\n+        connectContigs(contigs);\n+\n+        removeThinContigs(contigs, kmerAdjacencySet);\n+        weldPipes(contigs);\n+        markComponents(contigs);\n+\n+        if ( fillGaps(kmerAdjacencySet, reads) ) {\n+            contigs = buildContigs(kmerAdjacencySet);\n+            connectContigs(contigs);\n+            removeThinContigs(contigs, kmerAdjacencySet);\n+            weldPipes(contigs);\n+            markComponents(contigs);\n+        }\n+\n+        markCycles(contigs);\n+\n+        final String outputFilePrefix = output != null ? output : assemblyName;\n+        final List<Path> readPaths = pathReads(kmerAdjacencySet, reads);\n+        final Map<Contig,List<TransitPairCount>> contigTransitsMap =\n+                collectTransitPairCounts(contigs, readPaths);\n+        final String traversalsFilename = outputFilePrefix + \".traversals.fa.gz\";\n+        try {\n+            final List<Traversal> allTraversals =\n+                    new ArrayList<>(traverseAllPaths(contigs, readPaths, contigTransitsMap));\n+            writeTraversals(allTraversals, traversalsFilename);\n+            try {\n+                final String scaffoldsFileName = outputFilePrefix + \".scaffolds.fa.gz\";\n+                writeTraversals(createScaffolds(allTraversals), scaffoldsFileName);\n+            } catch ( final AssemblyTooComplexException x ) {\n+                logger.warn(\"Assembly too complex for scaffolding.\");\n+            }\n+        } catch ( final AssemblyTooComplexException x ) {\n+            logger.warn(\"Assembly too complex.  Writing contigs as traversals in \" +\n+                    traversalsFilename + \".\");\n+            final Collection<Traversal> contigTraversals = new ArrayList<>(contigs.size());\n+            for ( final Contig contig : contigs ) {\n+                contigTraversals.add(new Traversal(Collections.singletonList(contig)));\n+            }\n+            writeTraversals(contigTraversals, traversalsFilename);\n+        }\n+\n+        contigs.sort(Comparator.comparingInt(ContigImpl::getId));\n+        writeDOT(contigs, outputFilePrefix + \".assembly.dot\");\n+        writeContigs(contigs, outputFilePrefix + \".contigs.txt.gz\");\n+        writePaths(readPaths, outputFilePrefix + \".paths.txt.gz\");\n+        writeReads(reads, outputFilePrefix + \".reads.fastq.gz\");\n+        return null;\n+    }\n+\n+    /** trim read pairs of base calls that have gone past the end of a short fragment */\n+    private void trimOverruns( final GATKRead read, final GATKRead mate ) {\n+        // if both mapped and they're on different strands\n+        if ( !read.isUnmapped() && !mate.isUnmapped() &&\n+                read.isReverseStrand() != mate.isReverseStrand() ) {\n+            // and both start within 1 base on the ref\n+            if ( Math.abs(read.getStart() - read.getMateStart()) <= 1 ) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e2201c1ef4f8ba71f17e169f07756cfe2f1ecb49"}, "originalPosition": 128}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxMTkwNDQzMg==", "bodyText": "Occasionally (like maybe 1/4 of the time) the first base of adapter will happen to agree with the reference.  So the aligned region can be extended into what's actually adapter.  Unlikely to be more than a base or two, though.", "url": "https://github.com/broadinstitute/gatk/pull/6989#discussion_r611904432", "createdAt": "2021-04-12T19:41:06Z", "author": {"login": "tedsharpe"}, "path": "src/main/java/org/broadinstitute/hellbender/tools/LocalAssembler.java", "diffHunk": "@@ -0,0 +1,2306 @@\n+package org.broadinstitute.hellbender.tools;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import htsjdk.samtools.Cigar;\n+import htsjdk.samtools.CigarElement;\n+import htsjdk.samtools.CigarOperator;\n+import htsjdk.samtools.SAMUtils;\n+import org.broadinstitute.barclay.argparser.Argument;\n+import org.broadinstitute.barclay.argparser.BetaFeature;\n+import org.broadinstitute.barclay.argparser.CommandLineProgramProperties;\n+import org.broadinstitute.barclay.help.DocumentedFeature;\n+import org.broadinstitute.hellbender.cmdline.StandardArgumentDefinitions;\n+import org.broadinstitute.hellbender.cmdline.programgroups.CoverageAnalysisProgramGroup;\n+import org.broadinstitute.hellbender.exceptions.GATKException;\n+import org.broadinstitute.hellbender.tools.walkers.PairWalker;\n+import org.broadinstitute.hellbender.utils.SimpleInterval;\n+import org.broadinstitute.hellbender.utils.collections.HopscotchSet;\n+import org.broadinstitute.hellbender.utils.gcs.BucketUtils;\n+import org.broadinstitute.hellbender.utils.read.GATKRead;\n+\n+import java.io.BufferedWriter;\n+import java.io.FileWriter;\n+import java.io.IOException;\n+import java.io.OutputStreamWriter;\n+import java.util.*;\n+import java.util.zip.GZIPOutputStream;\n+\n+@DocumentedFeature\n+@CommandLineProgramProperties(\n+        summary = \"experiment\",\n+        oneLineSummary = \"experiment\",\n+        usageExample = \"gatk LocalAssembler\",\n+        programGroup = CoverageAnalysisProgramGroup.class\n+)\n+@BetaFeature\n+public class LocalAssembler extends PairWalker {\n+    public static final byte QMIN = 25;\n+    public static final int MIN_THIN_OBS = 4;\n+    public static final int MIN_GAPFILL_COUNT = 3;\n+    public static final int TOO_MANY_TRAVERSALS = 100000;\n+    public static final int TOO_MANY_SCAFFOLDS = 50000;\n+    public static final int MIN_SV_SIZE = 50;\n+\n+    @Argument(fullName=StandardArgumentDefinitions.OUTPUT_LONG_NAME,\n+            shortName=StandardArgumentDefinitions.OUTPUT_SHORT_NAME,\n+            doc=\"Write outputs to this file name prefix\", optional = true)\n+    public static String output;\n+\n+    @Argument(fullName=\"assembly-name\", doc=\"name of assembly used as a prefix for traversal names\")\n+    public static String assemblyName;\n+\n+    private final List<GATKRead> reads = new ArrayList<>();\n+\n+    @Override public boolean requiresIntervals() { return true; }\n+\n+    @Override public void apply( final GATKRead read, final GATKRead mate ) {\n+        trimOverruns(read, mate);\n+        reads.add(read);\n+        reads.add(mate);\n+    }\n+\n+    @Override public void applyUnpaired( final GATKRead read ) {\n+        reads.add(read);\n+    }\n+\n+    @Override public Object onTraversalSuccess() {\n+        super.onTraversalSuccess(); // flush any incomplete pairs\n+\n+        final int regionSize = getTraversalIntervals().stream().mapToInt(SimpleInterval::size).sum();\n+        final KmerSet<KmerAdjacency> kmerAdjacencySet = new KmerSet<>(10 * regionSize);\n+        kmerizeReads(reads, kmerAdjacencySet);\n+        List<ContigImpl> contigs = buildContigs(kmerAdjacencySet);\n+        connectContigs(contigs);\n+\n+        removeThinContigs(contigs, kmerAdjacencySet);\n+        weldPipes(contigs);\n+        markComponents(contigs);\n+\n+        if ( fillGaps(kmerAdjacencySet, reads) ) {\n+            contigs = buildContigs(kmerAdjacencySet);\n+            connectContigs(contigs);\n+            removeThinContigs(contigs, kmerAdjacencySet);\n+            weldPipes(contigs);\n+            markComponents(contigs);\n+        }\n+\n+        markCycles(contigs);\n+\n+        final String outputFilePrefix = output != null ? output : assemblyName;\n+        final List<Path> readPaths = pathReads(kmerAdjacencySet, reads);\n+        final Map<Contig,List<TransitPairCount>> contigTransitsMap =\n+                collectTransitPairCounts(contigs, readPaths);\n+        final String traversalsFilename = outputFilePrefix + \".traversals.fa.gz\";\n+        try {\n+            final List<Traversal> allTraversals =\n+                    new ArrayList<>(traverseAllPaths(contigs, readPaths, contigTransitsMap));\n+            writeTraversals(allTraversals, traversalsFilename);\n+            try {\n+                final String scaffoldsFileName = outputFilePrefix + \".scaffolds.fa.gz\";\n+                writeTraversals(createScaffolds(allTraversals), scaffoldsFileName);\n+            } catch ( final AssemblyTooComplexException x ) {\n+                logger.warn(\"Assembly too complex for scaffolding.\");\n+            }\n+        } catch ( final AssemblyTooComplexException x ) {\n+            logger.warn(\"Assembly too complex.  Writing contigs as traversals in \" +\n+                    traversalsFilename + \".\");\n+            final Collection<Traversal> contigTraversals = new ArrayList<>(contigs.size());\n+            for ( final Contig contig : contigs ) {\n+                contigTraversals.add(new Traversal(Collections.singletonList(contig)));\n+            }\n+            writeTraversals(contigTraversals, traversalsFilename);\n+        }\n+\n+        contigs.sort(Comparator.comparingInt(ContigImpl::getId));\n+        writeDOT(contigs, outputFilePrefix + \".assembly.dot\");\n+        writeContigs(contigs, outputFilePrefix + \".contigs.txt.gz\");\n+        writePaths(readPaths, outputFilePrefix + \".paths.txt.gz\");\n+        writeReads(reads, outputFilePrefix + \".reads.fastq.gz\");\n+        return null;\n+    }\n+\n+    /** trim read pairs of base calls that have gone past the end of a short fragment */\n+    private void trimOverruns( final GATKRead read, final GATKRead mate ) {\n+        // if both mapped and they're on different strands\n+        if ( !read.isUnmapped() && !mate.isUnmapped() &&\n+                read.isReverseStrand() != mate.isReverseStrand() ) {\n+            // and both start within 1 base on the ref\n+            if ( Math.abs(read.getStart() - read.getMateStart()) <= 1 ) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MTUzNDY1Mw=="}, "originalCommit": {"oid": "e2201c1ef4f8ba71f17e169f07756cfe2f1ecb49"}, "originalPosition": 128}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzczNTI3MzQ3OnYy", "diffSide": "RIGHT", "path": "src/main/java/org/broadinstitute/hellbender/tools/LocalAssembler.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMy0xMFQxNDo0OTo1NlrOI0LikQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMy0xMFQxNDo0OTo1NlrOI0LikQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MTU4NTkzNw==", "bodyText": "Could you add a comment explaining this last case (which short circuits the construction of the rc of the contig if it's a palindrome)? It was confusing for me at first read.", "url": "https://github.com/broadinstitute/gatk/pull/6989#discussion_r591585937", "createdAt": "2021-03-10T14:49:56Z", "author": {"login": "cwhelan"}, "path": "src/main/java/org/broadinstitute/hellbender/tools/LocalAssembler.java", "diffHunk": "@@ -0,0 +1,2306 @@\n+package org.broadinstitute.hellbender.tools;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import htsjdk.samtools.Cigar;\n+import htsjdk.samtools.CigarElement;\n+import htsjdk.samtools.CigarOperator;\n+import htsjdk.samtools.SAMUtils;\n+import org.broadinstitute.barclay.argparser.Argument;\n+import org.broadinstitute.barclay.argparser.BetaFeature;\n+import org.broadinstitute.barclay.argparser.CommandLineProgramProperties;\n+import org.broadinstitute.barclay.help.DocumentedFeature;\n+import org.broadinstitute.hellbender.cmdline.StandardArgumentDefinitions;\n+import org.broadinstitute.hellbender.cmdline.programgroups.CoverageAnalysisProgramGroup;\n+import org.broadinstitute.hellbender.exceptions.GATKException;\n+import org.broadinstitute.hellbender.tools.walkers.PairWalker;\n+import org.broadinstitute.hellbender.utils.SimpleInterval;\n+import org.broadinstitute.hellbender.utils.collections.HopscotchSet;\n+import org.broadinstitute.hellbender.utils.gcs.BucketUtils;\n+import org.broadinstitute.hellbender.utils.read.GATKRead;\n+\n+import java.io.BufferedWriter;\n+import java.io.FileWriter;\n+import java.io.IOException;\n+import java.io.OutputStreamWriter;\n+import java.util.*;\n+import java.util.zip.GZIPOutputStream;\n+\n+@DocumentedFeature\n+@CommandLineProgramProperties(\n+        summary = \"experiment\",\n+        oneLineSummary = \"experiment\",\n+        usageExample = \"gatk LocalAssembler\",\n+        programGroup = CoverageAnalysisProgramGroup.class\n+)\n+@BetaFeature\n+public class LocalAssembler extends PairWalker {\n+    public static final byte QMIN = 25;\n+    public static final int MIN_THIN_OBS = 4;\n+    public static final int MIN_GAPFILL_COUNT = 3;\n+    public static final int TOO_MANY_TRAVERSALS = 100000;\n+    public static final int TOO_MANY_SCAFFOLDS = 50000;\n+    public static final int MIN_SV_SIZE = 50;\n+\n+    @Argument(fullName=StandardArgumentDefinitions.OUTPUT_LONG_NAME,\n+            shortName=StandardArgumentDefinitions.OUTPUT_SHORT_NAME,\n+            doc=\"Write outputs to this file name prefix\", optional = true)\n+    public static String output;\n+\n+    @Argument(fullName=\"assembly-name\", doc=\"name of assembly used as a prefix for traversal names\")\n+    public static String assemblyName;\n+\n+    private final List<GATKRead> reads = new ArrayList<>();\n+\n+    @Override public boolean requiresIntervals() { return true; }\n+\n+    @Override public void apply( final GATKRead read, final GATKRead mate ) {\n+        trimOverruns(read, mate);\n+        reads.add(read);\n+        reads.add(mate);\n+    }\n+\n+    @Override public void applyUnpaired( final GATKRead read ) {\n+        reads.add(read);\n+    }\n+\n+    @Override public Object onTraversalSuccess() {\n+        super.onTraversalSuccess(); // flush any incomplete pairs\n+\n+        final int regionSize = getTraversalIntervals().stream().mapToInt(SimpleInterval::size).sum();\n+        final KmerSet<KmerAdjacency> kmerAdjacencySet = new KmerSet<>(10 * regionSize);\n+        kmerizeReads(reads, kmerAdjacencySet);\n+        List<ContigImpl> contigs = buildContigs(kmerAdjacencySet);\n+        connectContigs(contigs);\n+\n+        removeThinContigs(contigs, kmerAdjacencySet);\n+        weldPipes(contigs);\n+        markComponents(contigs);\n+\n+        if ( fillGaps(kmerAdjacencySet, reads) ) {\n+            contigs = buildContigs(kmerAdjacencySet);\n+            connectContigs(contigs);\n+            removeThinContigs(contigs, kmerAdjacencySet);\n+            weldPipes(contigs);\n+            markComponents(contigs);\n+        }\n+\n+        markCycles(contigs);\n+\n+        final String outputFilePrefix = output != null ? output : assemblyName;\n+        final List<Path> readPaths = pathReads(kmerAdjacencySet, reads);\n+        final Map<Contig,List<TransitPairCount>> contigTransitsMap =\n+                collectTransitPairCounts(contigs, readPaths);\n+        final String traversalsFilename = outputFilePrefix + \".traversals.fa.gz\";\n+        try {\n+            final List<Traversal> allTraversals =\n+                    new ArrayList<>(traverseAllPaths(contigs, readPaths, contigTransitsMap));\n+            writeTraversals(allTraversals, traversalsFilename);\n+            try {\n+                final String scaffoldsFileName = outputFilePrefix + \".scaffolds.fa.gz\";\n+                writeTraversals(createScaffolds(allTraversals), scaffoldsFileName);\n+            } catch ( final AssemblyTooComplexException x ) {\n+                logger.warn(\"Assembly too complex for scaffolding.\");\n+            }\n+        } catch ( final AssemblyTooComplexException x ) {\n+            logger.warn(\"Assembly too complex.  Writing contigs as traversals in \" +\n+                    traversalsFilename + \".\");\n+            final Collection<Traversal> contigTraversals = new ArrayList<>(contigs.size());\n+            for ( final Contig contig : contigs ) {\n+                contigTraversals.add(new Traversal(Collections.singletonList(contig)));\n+            }\n+            writeTraversals(contigTraversals, traversalsFilename);\n+        }\n+\n+        contigs.sort(Comparator.comparingInt(ContigImpl::getId));\n+        writeDOT(contigs, outputFilePrefix + \".assembly.dot\");\n+        writeContigs(contigs, outputFilePrefix + \".contigs.txt.gz\");\n+        writePaths(readPaths, outputFilePrefix + \".paths.txt.gz\");\n+        writeReads(reads, outputFilePrefix + \".reads.fastq.gz\");\n+        return null;\n+    }\n+\n+    /** trim read pairs of base calls that have gone past the end of a short fragment */\n+    private void trimOverruns( final GATKRead read, final GATKRead mate ) {\n+        // if both mapped and they're on different strands\n+        if ( !read.isUnmapped() && !mate.isUnmapped() &&\n+                read.isReverseStrand() != mate.isReverseStrand() ) {\n+            // and both start within 1 base on the ref\n+            if ( Math.abs(read.getStart() - read.getMateStart()) <= 1 ) {\n+                // and both end within 1 base\n+                final int readRefLen = read.getCigar().getReferenceLength();\n+                final int mateRefLen = mate.getCigar().getReferenceLength();\n+                if ( Math.abs(readRefLen - mateRefLen) <= 1 ) {\n+                    if ( mate.isReverseStrand() ) {\n+                        trimClips(read, mate);\n+                    } else {\n+                        trimClips(mate, read);\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    private void trimClips( final GATKRead fwd, final GATKRead rev ) {\n+        final List<CigarElement> fwdElements = fwd.getCigarElements();\n+        final List<CigarElement> revElements = rev.getCigarElements();\n+        final int lastElementIdx = fwdElements.size() - 1;\n+        final CigarElement fwdLastElement = fwdElements.get(lastElementIdx);\n+        final CigarElement revFirstElement = revElements.get(0);\n+        if ( fwdLastElement.getOperator() == CigarOperator.S &&\n+                revFirstElement.getOperator() == CigarOperator.S ) {\n+            final byte[] fwdBases = fwd.getBasesNoCopy();\n+            final int lastElementLen = fwdLastElement.getLength();\n+            fwd.setBases(Arrays.copyOfRange(fwdBases, 0, fwdBases.length - lastElementLen));\n+            final byte[] fwdQuals = fwd.getBaseQualitiesNoCopy();\n+            if ( fwdQuals.length > 0 ) {\n+                final int qualsLen = fwdQuals.length - lastElementLen;\n+                fwd.setBaseQualities(Arrays.copyOfRange(fwdQuals, 0, qualsLen));\n+            }\n+            final List<CigarElement> newFwdElements = new ArrayList<>(fwdElements);\n+            newFwdElements.set(lastElementIdx, new CigarElement(lastElementLen, CigarOperator.H));\n+            fwd.setCigar(new Cigar(newFwdElements));\n+\n+            final byte[] revBases = rev.getBasesNoCopy();\n+            final int firstElementLen = revFirstElement.getLength();\n+            rev.setBases(Arrays.copyOfRange(revBases, firstElementLen, revBases.length));\n+            final byte[] revQuals = rev.getBaseQualitiesNoCopy();\n+            if ( revQuals.length > 0 ) {\n+                rev.setBaseQualities(Arrays.copyOfRange(revQuals, firstElementLen, revQuals.length));\n+            }\n+            final List<CigarElement> newRevElements = new ArrayList<>(revElements);\n+            newRevElements.set(0, new CigarElement(firstElementLen, CigarOperator.H));\n+            rev.setCigar(new Cigar(newRevElements));\n+        }\n+    }\n+\n+    @VisibleForTesting\n+    static void kmerizeReads( final List<GATKRead> reads,\n+                              final KmerSet<KmerAdjacency> kmerAdjacencySet ) {\n+        for ( final GATKRead read : reads ) {\n+            final byte[] calls = read.getBasesNoCopy();\n+            final byte[] quals = read.getBaseQualitiesNoCopy();\n+            KmerAdjacency.kmerize(calls, quals, QMIN, kmerAdjacencySet);\n+        }\n+    }\n+\n+    /** gather unbranched strings of kmers into contigs **/\n+    @VisibleForTesting\n+    static List<ContigImpl> buildContigs( final KmerSet<KmerAdjacency> kmerAdjacencySet ) {\n+        // gather strings of kmers that have a single predecessor and single successor into contigs\n+        final List<ContigImpl> contigs = new ArrayList<>();\n+        int nContigs = 0;\n+        for ( final KmerAdjacency kmerAdjacency : kmerAdjacencySet ) {\n+            if ( kmerAdjacency.getContig() == null ) {\n+                ContigImpl contig = null;\n+                final KmerAdjacency predecessor = kmerAdjacency.getSolePredecessor();\n+                if ( predecessor == null ||\n+                        predecessor.getSuccessorCount() > 1 ||\n+                        predecessor == kmerAdjacency.rc() ) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e2201c1ef4f8ba71f17e169f07756cfe2f1ecb49"}, "originalPosition": 198}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzczNTMwODYxOnYy", "diffSide": "RIGHT", "path": "src/main/java/org/broadinstitute/hellbender/tools/LocalAssembler.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMy0xMFQxNDo1NjoyNlrOI0L5Ag==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMy0xMFQxNDo1NjoyNlrOI0L5Ag==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MTU5MTY4Mg==", "bodyText": "Same concern here as above..", "url": "https://github.com/broadinstitute/gatk/pull/6989#discussion_r591591682", "createdAt": "2021-03-10T14:56:26Z", "author": {"login": "cwhelan"}, "path": "src/main/java/org/broadinstitute/hellbender/tools/LocalAssembler.java", "diffHunk": "@@ -0,0 +1,2306 @@\n+package org.broadinstitute.hellbender.tools;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import htsjdk.samtools.Cigar;\n+import htsjdk.samtools.CigarElement;\n+import htsjdk.samtools.CigarOperator;\n+import htsjdk.samtools.SAMUtils;\n+import org.broadinstitute.barclay.argparser.Argument;\n+import org.broadinstitute.barclay.argparser.BetaFeature;\n+import org.broadinstitute.barclay.argparser.CommandLineProgramProperties;\n+import org.broadinstitute.barclay.help.DocumentedFeature;\n+import org.broadinstitute.hellbender.cmdline.StandardArgumentDefinitions;\n+import org.broadinstitute.hellbender.cmdline.programgroups.CoverageAnalysisProgramGroup;\n+import org.broadinstitute.hellbender.exceptions.GATKException;\n+import org.broadinstitute.hellbender.tools.walkers.PairWalker;\n+import org.broadinstitute.hellbender.utils.SimpleInterval;\n+import org.broadinstitute.hellbender.utils.collections.HopscotchSet;\n+import org.broadinstitute.hellbender.utils.gcs.BucketUtils;\n+import org.broadinstitute.hellbender.utils.read.GATKRead;\n+\n+import java.io.BufferedWriter;\n+import java.io.FileWriter;\n+import java.io.IOException;\n+import java.io.OutputStreamWriter;\n+import java.util.*;\n+import java.util.zip.GZIPOutputStream;\n+\n+@DocumentedFeature\n+@CommandLineProgramProperties(\n+        summary = \"experiment\",\n+        oneLineSummary = \"experiment\",\n+        usageExample = \"gatk LocalAssembler\",\n+        programGroup = CoverageAnalysisProgramGroup.class\n+)\n+@BetaFeature\n+public class LocalAssembler extends PairWalker {\n+    public static final byte QMIN = 25;\n+    public static final int MIN_THIN_OBS = 4;\n+    public static final int MIN_GAPFILL_COUNT = 3;\n+    public static final int TOO_MANY_TRAVERSALS = 100000;\n+    public static final int TOO_MANY_SCAFFOLDS = 50000;\n+    public static final int MIN_SV_SIZE = 50;\n+\n+    @Argument(fullName=StandardArgumentDefinitions.OUTPUT_LONG_NAME,\n+            shortName=StandardArgumentDefinitions.OUTPUT_SHORT_NAME,\n+            doc=\"Write outputs to this file name prefix\", optional = true)\n+    public static String output;\n+\n+    @Argument(fullName=\"assembly-name\", doc=\"name of assembly used as a prefix for traversal names\")\n+    public static String assemblyName;\n+\n+    private final List<GATKRead> reads = new ArrayList<>();\n+\n+    @Override public boolean requiresIntervals() { return true; }\n+\n+    @Override public void apply( final GATKRead read, final GATKRead mate ) {\n+        trimOverruns(read, mate);\n+        reads.add(read);\n+        reads.add(mate);\n+    }\n+\n+    @Override public void applyUnpaired( final GATKRead read ) {\n+        reads.add(read);\n+    }\n+\n+    @Override public Object onTraversalSuccess() {\n+        super.onTraversalSuccess(); // flush any incomplete pairs\n+\n+        final int regionSize = getTraversalIntervals().stream().mapToInt(SimpleInterval::size).sum();\n+        final KmerSet<KmerAdjacency> kmerAdjacencySet = new KmerSet<>(10 * regionSize);\n+        kmerizeReads(reads, kmerAdjacencySet);\n+        List<ContigImpl> contigs = buildContigs(kmerAdjacencySet);\n+        connectContigs(contigs);\n+\n+        removeThinContigs(contigs, kmerAdjacencySet);\n+        weldPipes(contigs);\n+        markComponents(contigs);\n+\n+        if ( fillGaps(kmerAdjacencySet, reads) ) {\n+            contigs = buildContigs(kmerAdjacencySet);\n+            connectContigs(contigs);\n+            removeThinContigs(contigs, kmerAdjacencySet);\n+            weldPipes(contigs);\n+            markComponents(contigs);\n+        }\n+\n+        markCycles(contigs);\n+\n+        final String outputFilePrefix = output != null ? output : assemblyName;\n+        final List<Path> readPaths = pathReads(kmerAdjacencySet, reads);\n+        final Map<Contig,List<TransitPairCount>> contigTransitsMap =\n+                collectTransitPairCounts(contigs, readPaths);\n+        final String traversalsFilename = outputFilePrefix + \".traversals.fa.gz\";\n+        try {\n+            final List<Traversal> allTraversals =\n+                    new ArrayList<>(traverseAllPaths(contigs, readPaths, contigTransitsMap));\n+            writeTraversals(allTraversals, traversalsFilename);\n+            try {\n+                final String scaffoldsFileName = outputFilePrefix + \".scaffolds.fa.gz\";\n+                writeTraversals(createScaffolds(allTraversals), scaffoldsFileName);\n+            } catch ( final AssemblyTooComplexException x ) {\n+                logger.warn(\"Assembly too complex for scaffolding.\");\n+            }\n+        } catch ( final AssemblyTooComplexException x ) {\n+            logger.warn(\"Assembly too complex.  Writing contigs as traversals in \" +\n+                    traversalsFilename + \".\");\n+            final Collection<Traversal> contigTraversals = new ArrayList<>(contigs.size());\n+            for ( final Contig contig : contigs ) {\n+                contigTraversals.add(new Traversal(Collections.singletonList(contig)));\n+            }\n+            writeTraversals(contigTraversals, traversalsFilename);\n+        }\n+\n+        contigs.sort(Comparator.comparingInt(ContigImpl::getId));\n+        writeDOT(contigs, outputFilePrefix + \".assembly.dot\");\n+        writeContigs(contigs, outputFilePrefix + \".contigs.txt.gz\");\n+        writePaths(readPaths, outputFilePrefix + \".paths.txt.gz\");\n+        writeReads(reads, outputFilePrefix + \".reads.fastq.gz\");\n+        return null;\n+    }\n+\n+    /** trim read pairs of base calls that have gone past the end of a short fragment */\n+    private void trimOverruns( final GATKRead read, final GATKRead mate ) {\n+        // if both mapped and they're on different strands\n+        if ( !read.isUnmapped() && !mate.isUnmapped() &&\n+                read.isReverseStrand() != mate.isReverseStrand() ) {\n+            // and both start within 1 base on the ref\n+            if ( Math.abs(read.getStart() - read.getMateStart()) <= 1 ) {\n+                // and both end within 1 base\n+                final int readRefLen = read.getCigar().getReferenceLength();\n+                final int mateRefLen = mate.getCigar().getReferenceLength();\n+                if ( Math.abs(readRefLen - mateRefLen) <= 1 ) {\n+                    if ( mate.isReverseStrand() ) {\n+                        trimClips(read, mate);\n+                    } else {\n+                        trimClips(mate, read);\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    private void trimClips( final GATKRead fwd, final GATKRead rev ) {\n+        final List<CigarElement> fwdElements = fwd.getCigarElements();\n+        final List<CigarElement> revElements = rev.getCigarElements();\n+        final int lastElementIdx = fwdElements.size() - 1;\n+        final CigarElement fwdLastElement = fwdElements.get(lastElementIdx);\n+        final CigarElement revFirstElement = revElements.get(0);\n+        if ( fwdLastElement.getOperator() == CigarOperator.S &&\n+                revFirstElement.getOperator() == CigarOperator.S ) {\n+            final byte[] fwdBases = fwd.getBasesNoCopy();\n+            final int lastElementLen = fwdLastElement.getLength();\n+            fwd.setBases(Arrays.copyOfRange(fwdBases, 0, fwdBases.length - lastElementLen));\n+            final byte[] fwdQuals = fwd.getBaseQualitiesNoCopy();\n+            if ( fwdQuals.length > 0 ) {\n+                final int qualsLen = fwdQuals.length - lastElementLen;\n+                fwd.setBaseQualities(Arrays.copyOfRange(fwdQuals, 0, qualsLen));\n+            }\n+            final List<CigarElement> newFwdElements = new ArrayList<>(fwdElements);\n+            newFwdElements.set(lastElementIdx, new CigarElement(lastElementLen, CigarOperator.H));\n+            fwd.setCigar(new Cigar(newFwdElements));\n+\n+            final byte[] revBases = rev.getBasesNoCopy();\n+            final int firstElementLen = revFirstElement.getLength();\n+            rev.setBases(Arrays.copyOfRange(revBases, firstElementLen, revBases.length));\n+            final byte[] revQuals = rev.getBaseQualitiesNoCopy();\n+            if ( revQuals.length > 0 ) {\n+                rev.setBaseQualities(Arrays.copyOfRange(revQuals, firstElementLen, revQuals.length));\n+            }\n+            final List<CigarElement> newRevElements = new ArrayList<>(revElements);\n+            newRevElements.set(0, new CigarElement(firstElementLen, CigarOperator.H));\n+            rev.setCigar(new Cigar(newRevElements));\n+        }\n+    }\n+\n+    @VisibleForTesting\n+    static void kmerizeReads( final List<GATKRead> reads,\n+                              final KmerSet<KmerAdjacency> kmerAdjacencySet ) {\n+        for ( final GATKRead read : reads ) {\n+            final byte[] calls = read.getBasesNoCopy();\n+            final byte[] quals = read.getBaseQualitiesNoCopy();\n+            KmerAdjacency.kmerize(calls, quals, QMIN, kmerAdjacencySet);\n+        }\n+    }\n+\n+    /** gather unbranched strings of kmers into contigs **/\n+    @VisibleForTesting\n+    static List<ContigImpl> buildContigs( final KmerSet<KmerAdjacency> kmerAdjacencySet ) {\n+        // gather strings of kmers that have a single predecessor and single successor into contigs\n+        final List<ContigImpl> contigs = new ArrayList<>();\n+        int nContigs = 0;\n+        for ( final KmerAdjacency kmerAdjacency : kmerAdjacencySet ) {\n+            if ( kmerAdjacency.getContig() == null ) {\n+                ContigImpl contig = null;\n+                final KmerAdjacency predecessor = kmerAdjacency.getSolePredecessor();\n+                if ( predecessor == null ||\n+                        predecessor.getSuccessorCount() > 1 ||\n+                        predecessor == kmerAdjacency.rc() ) {\n+                    contig = new ContigImpl(++nContigs, kmerAdjacency);\n+                } else {\n+                    final KmerAdjacency successor = kmerAdjacency.getSoleSuccessor();\n+                    if ( successor == null ||\n+                            successor.getPredecessorCount() > 1 ||\n+                            successor == kmerAdjacency.rc() ) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e2201c1ef4f8ba71f17e169f07756cfe2f1ecb49"}, "originalPosition": 204}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzczNTQ5NzQ0OnYy", "diffSide": "RIGHT", "path": "src/main/java/org/broadinstitute/hellbender/tools/LocalAssembler.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMy0xMFQxNTozMDo1MlrOI0NxEg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNC0xM1QyMDozNzo1NlrOJIX5pw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MTYyMjQxOA==", "bodyText": "It was initially very surprising for me that the constructor of ContigImpl has side effects that modify the entire KmerAdjacency  structure -- I guess my principles of OO design weren't ready for this. Would it cause problems to separate this chunk of code into another method that could be explicitly named to show that it's going to modify the kmers?", "url": "https://github.com/broadinstitute/gatk/pull/6989#discussion_r591622418", "createdAt": "2021-03-10T15:30:52Z", "author": {"login": "cwhelan"}, "path": "src/main/java/org/broadinstitute/hellbender/tools/LocalAssembler.java", "diffHunk": "@@ -0,0 +1,2306 @@\n+package org.broadinstitute.hellbender.tools;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import htsjdk.samtools.Cigar;\n+import htsjdk.samtools.CigarElement;\n+import htsjdk.samtools.CigarOperator;\n+import htsjdk.samtools.SAMUtils;\n+import org.broadinstitute.barclay.argparser.Argument;\n+import org.broadinstitute.barclay.argparser.BetaFeature;\n+import org.broadinstitute.barclay.argparser.CommandLineProgramProperties;\n+import org.broadinstitute.barclay.help.DocumentedFeature;\n+import org.broadinstitute.hellbender.cmdline.StandardArgumentDefinitions;\n+import org.broadinstitute.hellbender.cmdline.programgroups.CoverageAnalysisProgramGroup;\n+import org.broadinstitute.hellbender.exceptions.GATKException;\n+import org.broadinstitute.hellbender.tools.walkers.PairWalker;\n+import org.broadinstitute.hellbender.utils.SimpleInterval;\n+import org.broadinstitute.hellbender.utils.collections.HopscotchSet;\n+import org.broadinstitute.hellbender.utils.gcs.BucketUtils;\n+import org.broadinstitute.hellbender.utils.read.GATKRead;\n+\n+import java.io.BufferedWriter;\n+import java.io.FileWriter;\n+import java.io.IOException;\n+import java.io.OutputStreamWriter;\n+import java.util.*;\n+import java.util.zip.GZIPOutputStream;\n+\n+@DocumentedFeature\n+@CommandLineProgramProperties(\n+        summary = \"experiment\",\n+        oneLineSummary = \"experiment\",\n+        usageExample = \"gatk LocalAssembler\",\n+        programGroup = CoverageAnalysisProgramGroup.class\n+)\n+@BetaFeature\n+public class LocalAssembler extends PairWalker {\n+    public static final byte QMIN = 25;\n+    public static final int MIN_THIN_OBS = 4;\n+    public static final int MIN_GAPFILL_COUNT = 3;\n+    public static final int TOO_MANY_TRAVERSALS = 100000;\n+    public static final int TOO_MANY_SCAFFOLDS = 50000;\n+    public static final int MIN_SV_SIZE = 50;\n+\n+    @Argument(fullName=StandardArgumentDefinitions.OUTPUT_LONG_NAME,\n+            shortName=StandardArgumentDefinitions.OUTPUT_SHORT_NAME,\n+            doc=\"Write outputs to this file name prefix\", optional = true)\n+    public static String output;\n+\n+    @Argument(fullName=\"assembly-name\", doc=\"name of assembly used as a prefix for traversal names\")\n+    public static String assemblyName;\n+\n+    private final List<GATKRead> reads = new ArrayList<>();\n+\n+    @Override public boolean requiresIntervals() { return true; }\n+\n+    @Override public void apply( final GATKRead read, final GATKRead mate ) {\n+        trimOverruns(read, mate);\n+        reads.add(read);\n+        reads.add(mate);\n+    }\n+\n+    @Override public void applyUnpaired( final GATKRead read ) {\n+        reads.add(read);\n+    }\n+\n+    @Override public Object onTraversalSuccess() {\n+        super.onTraversalSuccess(); // flush any incomplete pairs\n+\n+        final int regionSize = getTraversalIntervals().stream().mapToInt(SimpleInterval::size).sum();\n+        final KmerSet<KmerAdjacency> kmerAdjacencySet = new KmerSet<>(10 * regionSize);\n+        kmerizeReads(reads, kmerAdjacencySet);\n+        List<ContigImpl> contigs = buildContigs(kmerAdjacencySet);\n+        connectContigs(contigs);\n+\n+        removeThinContigs(contigs, kmerAdjacencySet);\n+        weldPipes(contigs);\n+        markComponents(contigs);\n+\n+        if ( fillGaps(kmerAdjacencySet, reads) ) {\n+            contigs = buildContigs(kmerAdjacencySet);\n+            connectContigs(contigs);\n+            removeThinContigs(contigs, kmerAdjacencySet);\n+            weldPipes(contigs);\n+            markComponents(contigs);\n+        }\n+\n+        markCycles(contigs);\n+\n+        final String outputFilePrefix = output != null ? output : assemblyName;\n+        final List<Path> readPaths = pathReads(kmerAdjacencySet, reads);\n+        final Map<Contig,List<TransitPairCount>> contigTransitsMap =\n+                collectTransitPairCounts(contigs, readPaths);\n+        final String traversalsFilename = outputFilePrefix + \".traversals.fa.gz\";\n+        try {\n+            final List<Traversal> allTraversals =\n+                    new ArrayList<>(traverseAllPaths(contigs, readPaths, contigTransitsMap));\n+            writeTraversals(allTraversals, traversalsFilename);\n+            try {\n+                final String scaffoldsFileName = outputFilePrefix + \".scaffolds.fa.gz\";\n+                writeTraversals(createScaffolds(allTraversals), scaffoldsFileName);\n+            } catch ( final AssemblyTooComplexException x ) {\n+                logger.warn(\"Assembly too complex for scaffolding.\");\n+            }\n+        } catch ( final AssemblyTooComplexException x ) {\n+            logger.warn(\"Assembly too complex.  Writing contigs as traversals in \" +\n+                    traversalsFilename + \".\");\n+            final Collection<Traversal> contigTraversals = new ArrayList<>(contigs.size());\n+            for ( final Contig contig : contigs ) {\n+                contigTraversals.add(new Traversal(Collections.singletonList(contig)));\n+            }\n+            writeTraversals(contigTraversals, traversalsFilename);\n+        }\n+\n+        contigs.sort(Comparator.comparingInt(ContigImpl::getId));\n+        writeDOT(contigs, outputFilePrefix + \".assembly.dot\");\n+        writeContigs(contigs, outputFilePrefix + \".contigs.txt.gz\");\n+        writePaths(readPaths, outputFilePrefix + \".paths.txt.gz\");\n+        writeReads(reads, outputFilePrefix + \".reads.fastq.gz\");\n+        return null;\n+    }\n+\n+    /** trim read pairs of base calls that have gone past the end of a short fragment */\n+    private void trimOverruns( final GATKRead read, final GATKRead mate ) {\n+        // if both mapped and they're on different strands\n+        if ( !read.isUnmapped() && !mate.isUnmapped() &&\n+                read.isReverseStrand() != mate.isReverseStrand() ) {\n+            // and both start within 1 base on the ref\n+            if ( Math.abs(read.getStart() - read.getMateStart()) <= 1 ) {\n+                // and both end within 1 base\n+                final int readRefLen = read.getCigar().getReferenceLength();\n+                final int mateRefLen = mate.getCigar().getReferenceLength();\n+                if ( Math.abs(readRefLen - mateRefLen) <= 1 ) {\n+                    if ( mate.isReverseStrand() ) {\n+                        trimClips(read, mate);\n+                    } else {\n+                        trimClips(mate, read);\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    private void trimClips( final GATKRead fwd, final GATKRead rev ) {\n+        final List<CigarElement> fwdElements = fwd.getCigarElements();\n+        final List<CigarElement> revElements = rev.getCigarElements();\n+        final int lastElementIdx = fwdElements.size() - 1;\n+        final CigarElement fwdLastElement = fwdElements.get(lastElementIdx);\n+        final CigarElement revFirstElement = revElements.get(0);\n+        if ( fwdLastElement.getOperator() == CigarOperator.S &&\n+                revFirstElement.getOperator() == CigarOperator.S ) {\n+            final byte[] fwdBases = fwd.getBasesNoCopy();\n+            final int lastElementLen = fwdLastElement.getLength();\n+            fwd.setBases(Arrays.copyOfRange(fwdBases, 0, fwdBases.length - lastElementLen));\n+            final byte[] fwdQuals = fwd.getBaseQualitiesNoCopy();\n+            if ( fwdQuals.length > 0 ) {\n+                final int qualsLen = fwdQuals.length - lastElementLen;\n+                fwd.setBaseQualities(Arrays.copyOfRange(fwdQuals, 0, qualsLen));\n+            }\n+            final List<CigarElement> newFwdElements = new ArrayList<>(fwdElements);\n+            newFwdElements.set(lastElementIdx, new CigarElement(lastElementLen, CigarOperator.H));\n+            fwd.setCigar(new Cigar(newFwdElements));\n+\n+            final byte[] revBases = rev.getBasesNoCopy();\n+            final int firstElementLen = revFirstElement.getLength();\n+            rev.setBases(Arrays.copyOfRange(revBases, firstElementLen, revBases.length));\n+            final byte[] revQuals = rev.getBaseQualitiesNoCopy();\n+            if ( revQuals.length > 0 ) {\n+                rev.setBaseQualities(Arrays.copyOfRange(revQuals, firstElementLen, revQuals.length));\n+            }\n+            final List<CigarElement> newRevElements = new ArrayList<>(revElements);\n+            newRevElements.set(0, new CigarElement(firstElementLen, CigarOperator.H));\n+            rev.setCigar(new Cigar(newRevElements));\n+        }\n+    }\n+\n+    @VisibleForTesting\n+    static void kmerizeReads( final List<GATKRead> reads,\n+                              final KmerSet<KmerAdjacency> kmerAdjacencySet ) {\n+        for ( final GATKRead read : reads ) {\n+            final byte[] calls = read.getBasesNoCopy();\n+            final byte[] quals = read.getBaseQualitiesNoCopy();\n+            KmerAdjacency.kmerize(calls, quals, QMIN, kmerAdjacencySet);\n+        }\n+    }\n+\n+    /** gather unbranched strings of kmers into contigs **/\n+    @VisibleForTesting\n+    static List<ContigImpl> buildContigs( final KmerSet<KmerAdjacency> kmerAdjacencySet ) {\n+        // gather strings of kmers that have a single predecessor and single successor into contigs\n+        final List<ContigImpl> contigs = new ArrayList<>();\n+        int nContigs = 0;\n+        for ( final KmerAdjacency kmerAdjacency : kmerAdjacencySet ) {\n+            if ( kmerAdjacency.getContig() == null ) {\n+                ContigImpl contig = null;\n+                final KmerAdjacency predecessor = kmerAdjacency.getSolePredecessor();\n+                if ( predecessor == null ||\n+                        predecessor.getSuccessorCount() > 1 ||\n+                        predecessor == kmerAdjacency.rc() ) {\n+                    contig = new ContigImpl(++nContigs, kmerAdjacency);\n+                } else {\n+                    final KmerAdjacency successor = kmerAdjacency.getSoleSuccessor();\n+                    if ( successor == null ||\n+                            successor.getPredecessorCount() > 1 ||\n+                            successor == kmerAdjacency.rc() ) {\n+                        contig = new ContigImpl(++nContigs, kmerAdjacency.rc());\n+                    }\n+                }\n+                if ( contig != null ) {\n+                    contigs.add(contig);\n+                }\n+            }\n+        }\n+\n+        // if there are smooth circles like a plasmid, gather them together as a contig, too\n+        for ( final KmerAdjacency kmerAdjacency : kmerAdjacencySet ) {\n+            if ( kmerAdjacency.getContig() == null ) {\n+                contigs.add(new ContigImpl(++nContigs, kmerAdjacency));\n+            }\n+        }\n+\n+        return contigs;\n+    }\n+\n+    /** connect contigs when the final kmer of one contig is adjacent to the inital contig of another **/\n+    @VisibleForTesting\n+    static void connectContigs( final List<ContigImpl> contigs ) {\n+        final int nContigs = contigs.size();\n+        final KmerSet<ContigEndKmer> contigEnds = new KmerSet<>(2*nContigs);\n+        for ( int contigId = 0; contigId != nContigs; ++contigId ) {\n+            final ContigImpl contig = contigs.get(contigId);\n+            final KmerAdjacency fwdKmer = contig.getFirstKmer();\n+            final KmerAdjacency revKmer = contig.getLastKmer().rc();\n+            if ( fwdKmer == revKmer ) {\n+                contigEnds.add(new ContigEndKmer(fwdKmer.getKVal(), contig, ContigOrientation.BOTH));\n+            } else {\n+                contigEnds.add(new ContigEndKmer(fwdKmer.getKVal(), contig, ContigOrientation.FWD));\n+                contigEnds.add(new ContigEndKmer(revKmer.getKVal(), contig, ContigOrientation.REV));\n+            }\n+        }\n+\n+        for ( int contigId = 0; contigId != nContigs; ++contigId ) {\n+            final Contig contig = contigs.get(contigId);\n+\n+            final KmerAdjacency start = contig.getFirstKmer();\n+            final int predecessorCount = start.getPredecessorCount();\n+            if ( predecessorCount > 0 ) {\n+                final List<Contig> predecessors = contig.getPredecessors();\n+                final int mask = start.getPredecessorMask();\n+                for ( int call = 0; call != 4; ++call ) {\n+                    if ( (mask & (1 << call)) != 0 ) {\n+                        final long kVal =\n+                                KmerAdjacency.reverseComplement(start.getPredecessorVal(call));\n+                        final ContigEndKmer contigEndKmer = contigEnds.find(new Kmer(kVal));\n+                        if ( contigEndKmer == null ) {\n+                            throw new GATKException(\"missing contig end kmer\");\n+                        }\n+                        switch ( contigEndKmer.getContigOrientation() ) {\n+                            case FWD:\n+                                predecessors.add(contigEndKmer.getContig().rc());\n+                                break;\n+                            case REV:\n+                                predecessors.add(contigEndKmer.getContig());\n+                                break;\n+                            case BOTH:\n+                                predecessors.add(contigEndKmer.getContig());\n+                                predecessors.add(contigEndKmer.getContig().rc());\n+                                break;\n+                        }\n+                    }\n+                }\n+            }\n+\n+            final KmerAdjacency end = contig.getLastKmer();\n+            final int successorCount = end.getSuccessorCount();\n+            if ( successorCount > 0 ) {\n+                final List<Contig> successors = contig.getSuccessors();\n+                final int mask = end.getSuccessorMask();\n+                for ( int call = 0; call != 4; ++call ) {\n+                    if ( (mask & (1 << call)) != 0 ) {\n+                        final long kVal = end.getSuccessorVal(call);\n+                        final ContigEndKmer contigEndKmer = contigEnds.find(new Kmer(kVal));\n+                        if ( contigEndKmer == null ) {\n+                            throw new GATKException(\"missing contig end kmer\");\n+                        }\n+                        switch ( contigEndKmer.getContigOrientation() ) {\n+                            case FWD:\n+                                successors.add(contigEndKmer.getContig());\n+                                break;\n+                            case REV:\n+                                successors.add(contigEndKmer.getContig().rc());\n+                                break;\n+                            case BOTH:\n+                                successors.add(contigEndKmer.getContig());\n+                                successors.add(contigEndKmer.getContig().rc());\n+                                break;\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    /** remove contigs that have little evidence **/\n+    @VisibleForTesting\n+    static void removeThinContigs( final List<ContigImpl> contigs,\n+                                           final KmerSet<KmerAdjacency> kmerAdjacencySet ) {\n+        contigs.sort(Comparator.comparingInt(ContigImpl::getMaxObservations));\n+        boolean contigRemoved;\n+        do {\n+            // figure out which contigs are cut points\n+            // i.e., those contigs which, if removed, would result in a graph with more connected components\n+            final int nContigs = contigs.size();\n+            final Map<Contig, CutData> cutDataMap = new HashMap<>(nContigs * 3);\n+\n+            for ( final ContigImpl contig : contigs ) {\n+                if ( cutDataMap.containsKey(contig) ) {\n+                    continue;\n+                }\n+\n+                cutDataMap.put(contig, new CutData());\n+                int children = 0;\n+                for ( final Contig nextContig : contig.getSuccessors() ) {\n+                    if ( !cutDataMap.containsKey(nextContig) ) {\n+                        findCuts(nextContig, contig, cutDataMap);\n+                        children += 1;\n+                    }\n+                }\n+                for ( final Contig nextContig : contig.getPredecessors() ) {\n+                    if ( !cutDataMap.containsKey(nextContig) ) {\n+                        findCuts(nextContig, contig, cutDataMap);\n+                        children += 1;\n+                    }\n+                }\n+                if ( children >= 2 ) {\n+                    contig.setCut(true);\n+                }\n+            }\n+\n+            // remove poorly attested (low max observations) contigs, unless they are cut points\n+            contigRemoved = false;\n+            final Iterator<ContigImpl> itr = contigs.iterator();\n+            while ( itr.hasNext() ) {\n+                final Contig contig = itr.next();\n+                if ( contig.getMaxObservations() < MIN_THIN_OBS && !contig.isCut() ) {\n+                    unlinkContig(contig, kmerAdjacencySet);\n+                    itr.remove();\n+                    contigRemoved = true;\n+                    break;\n+                }\n+            }\n+        } while ( contigRemoved );\n+        contigs.sort(Comparator.comparingInt(ContigImpl::getId));\n+    }\n+\n+    private static CutData findCuts( final Contig contig,\n+                                     final Contig parent,\n+                                     final Map<Contig, CutData> cutDataMap ) {\n+        final CutData cutData = new CutData();\n+        cutDataMap.put(contig, cutData);\n+        for ( final Contig nextContig : contig.getSuccessors() ) {\n+            if ( nextContig == parent ) {\n+                continue;\n+            }\n+            CutData nextCutData = cutDataMap.get(nextContig);\n+            if ( nextCutData != null ) {\n+                cutData.minVisitNum = Math.min(cutData.minVisitNum, nextCutData.visitNum);\n+            } else {\n+                nextCutData = findCuts(nextContig, contig, cutDataMap);\n+                cutData.minVisitNum = Math.min(cutData.minVisitNum, nextCutData.minVisitNum);\n+                if ( nextCutData.minVisitNum >= cutData.visitNum ) {\n+                    contig.setCut(true);\n+                }\n+            }\n+        }\n+        for ( final Contig nextContig : contig.getPredecessors() ) {\n+            if ( nextContig == parent ) {\n+                continue;\n+            }\n+            CutData nextCutData = cutDataMap.get(nextContig);\n+            if ( nextCutData != null ) {\n+                cutData.minVisitNum = Math.min(cutData.minVisitNum, nextCutData.visitNum);\n+            } else {\n+                nextCutData = findCuts(nextContig, contig, cutDataMap);\n+                cutData.minVisitNum = Math.min(cutData.minVisitNum, nextCutData.minVisitNum);\n+                if ( nextCutData.minVisitNum >= cutData.visitNum ) {\n+                    contig.setCut(true);\n+                }\n+            }\n+        }\n+        return cutData;\n+    }\n+\n+    @VisibleForTesting\n+    static void unlinkContig( final Contig contig,\n+                                      final KmerSet<KmerAdjacency> kmerAdjacencySet ) {\n+        final KmerAdjacency firstKmer = contig.getFirstKmer();\n+        final int firstKmerFinalCall = firstKmer.getFinalCall();\n+        for ( final Contig predecessor : contig.getPredecessors() ) {\n+            if ( predecessor != contig && predecessor != contig.rc() ) {\n+                predecessor.getLastKmer().removeSuccessor(firstKmerFinalCall, kmerAdjacencySet);\n+                if ( !predecessor.getSuccessors().remove(contig) ) {\n+                    throw new GATKException(\"failed to find predecessor link\");\n+                }\n+            }\n+        }\n+\n+        final KmerAdjacency lastKmer = contig.getLastKmer();\n+        final int lastKmerInitialCall = lastKmer.getInitialCall();\n+        for ( final Contig successor : contig.getSuccessors() ) {\n+            if ( successor != contig && successor != contig.rc() ) {\n+                successor.getFirstKmer().removePredecessor(lastKmerInitialCall, kmerAdjacencySet);\n+                if ( !successor.getPredecessors().remove(contig) ) {\n+                    throw new GATKException(\"failed to find successor link\");\n+                }\n+            }\n+        }\n+\n+        KmerAdjacency nextKmer = firstKmer;\n+        KmerAdjacency kmer;\n+        do {\n+            kmer = nextKmer;\n+            nextKmer = kmer.getSoleSuccessor();\n+            kmerAdjacencySet.remove(kmer.canonical());\n+        } while ( kmer != lastKmer );\n+    }\n+\n+    private static void updateKmerContig( final KmerAdjacency firstKmer,\n+                                          final KmerAdjacency lastKmer,\n+                                          final Contig contig ) {\n+        int offset = 0;\n+        for ( KmerAdjacency kmer = firstKmer; kmer != lastKmer; kmer = kmer.getSoleSuccessor() ) {\n+            if ( kmer == null ) {\n+                throw new GATKException(\"contig does not have a flat pipeline of kmers\");\n+            }\n+            kmer.clearContig();\n+            kmer.setContigOffset(contig, offset++);\n+        }\n+        lastKmer.clearContig();\n+        lastKmer.setContigOffset(contig, offset);\n+        if ( offset + Kmer.KSIZE != contig.size() ) {\n+            throw new GATKException(\"kmer chain length does not equal contig size\");\n+        }\n+    }\n+\n+    /** replace adjacent contigs without branches with a single, larger contig **/\n+    @VisibleForTesting\n+    static void weldPipes( final List<ContigImpl> contigs ) {\n+        for ( int contigIdx = 0; contigIdx != contigs.size(); ++contigIdx ) {\n+            final ContigImpl contig = contigs.get(contigIdx);\n+            if ( contig.getSuccessors().size() == 1 ) {\n+                final Contig successor = contig.getSuccessors().get(0);\n+                if ( successor != contig && successor != contig.rc() &&\n+                        successor.getPredecessors().size() == 1 ) {\n+                    contigs.set(contigIdx, join(contig.getId(), contig, successor));\n+                    if ( !contigs.remove(successor.canonical()) ) {\n+                        throw new GATKException(\"successor linkage is messed up\");\n+                    }\n+                    contigIdx -= 1; // reconsider the new contig -- there might be more joining possible\n+                    continue;\n+                }\n+            }\n+            if ( contig.getPredecessors().size() == 1 ) {\n+                final Contig predecessor = contig.getPredecessors().get(0);\n+                if ( predecessor != contig && predecessor != contig.rc() &&\n+                        predecessor.getSuccessors().size() == 1 ) {\n+                    contigs.set(contigIdx, join(contig.getId(), predecessor, contig));\n+                    if ( !contigs.remove(predecessor.canonical()) ) {\n+                        throw new GATKException(\"predecessor linkage is messed up\");\n+                    }\n+                    contigIdx -= 1; // reconsider\n+                }\n+            }\n+        }\n+    }\n+\n+    private static ContigImpl join( final int id, final Contig predecessor, final Contig successor ) {\n+        if ( !checkOverlap(predecessor.getSequence(), successor.getSequence()) ) {\n+                throw new GATKException(\"sequences can't be joined\");\n+        }\n+        final ContigImpl joinedContig = new ContigImpl(id, predecessor, successor);\n+        updateKmerContig(joinedContig.getFirstKmer(), joinedContig.getLastKmer(), joinedContig);\n+        return joinedContig;\n+    }\n+\n+    private static boolean checkOverlap( final CharSequence seq1, final CharSequence seq2 ) {\n+        final int seq1Len = seq1.length();\n+        final CharSequence seq1SubSeq = seq1.subSequence(seq1Len - Kmer.KSIZE + 1, seq1Len);\n+        final CharSequence seq2SubSeq = seq2.subSequence(0, Kmer.KSIZE - 1);\n+        return seq1SubSeq.equals(seq2SubSeq);\n+    }\n+\n+    /** set a unique componentId for every connected group of contigs **/\n+    @VisibleForTesting\n+    static int markComponents( final List<ContigImpl> contigs ) {\n+        for ( final ContigImpl contig : contigs ) {\n+            contig.setComponentId(0);\n+        }\n+\n+        int componentId = 0;\n+        for ( final ContigImpl contig : contigs ) {\n+            if ( contig.getComponentId() == 0 ) {\n+                contig.setComponentId(++componentId);\n+                markSuccessorComponents(contig);\n+                markSuccessorComponents(contig.rc());\n+            }\n+        }\n+        return componentId;\n+    }\n+\n+    private static void markSuccessorComponents( final Contig contig ) {\n+        final int componentId = contig.getComponentId();\n+        for ( final Contig successor : contig.getSuccessors() ) {\n+            if ( successor.getComponentId() == 0 ) {\n+                successor.canonical().setComponentId(componentId);\n+                markSuccessorComponents(successor);\n+                markSuccessorComponents(successor.rc());\n+            }\n+        }\n+    }\n+\n+    @VisibleForTesting\n+    static void markCycles( final List<ContigImpl> contigs ) {\n+        for ( final Contig contig : contigs ) {\n+            contig.setCyclic(false);\n+        }\n+\n+        final int nContigs = contigs.size();\n+        final Deque<Contig> deque = new ArrayDeque<>(nContigs);\n+        final Map<Contig, CutData> cutDataMap = new HashMap<>(nContigs * 3);\n+        for ( final Contig contig : contigs ) {\n+            if ( !cutDataMap.containsKey(contig) ) {\n+                markCyclesRecursion(contig, deque, cutDataMap);\n+            }\n+        }\n+    }\n+\n+    private static CutData markCyclesRecursion( final Contig contig,\n+                                                final Deque<Contig> deque,\n+                                                final Map<Contig, CutData> cutDataMap ) {\n+        final CutData cutData = new CutData();\n+        cutDataMap.put(contig, cutData);\n+        deque.addFirst(contig);\n+\n+        for ( final Contig successor : contig.getSuccessors() ) {\n+            final CutData successorCutData = cutDataMap.get(successor);\n+            if ( successorCutData == null ) {\n+                final int recursionVisitNum =\n+                        markCyclesRecursion(successor, deque, cutDataMap).minVisitNum;\n+                cutData.minVisitNum = Math.min(cutData.minVisitNum, recursionVisitNum);\n+            } else {\n+                cutData.minVisitNum = Math.min(cutData.minVisitNum, successorCutData.visitNum);\n+            }\n+        }\n+\n+        if ( cutData.visitNum == cutData.minVisitNum ) {\n+            Contig tig = deque.removeFirst();\n+            if ( tig == contig ) {\n+                cutDataMap.get(tig).visitNum = Integer.MAX_VALUE;\n+\n+                // single-vertex component -- cyclic only if self-referential\n+                if ( tig.getSuccessors().contains(tig) ) {\n+                    tig.setCyclic(true);\n+                }\n+            } else {\n+                while ( true ) {\n+                    // kill cross-links\n+                    cutDataMap.get(tig).visitNum = Integer.MAX_VALUE;\n+                    tig.setCyclic(true);\n+                    if ( tig == contig ) break;\n+                    tig = deque.removeFirst();\n+                }\n+            }\n+        }\n+        return cutData;\n+    }\n+\n+    @VisibleForTesting\n+    static boolean fillGaps( final KmerSet<KmerAdjacency> kmerAdjacencySet,\n+                             final List<GATKRead> reads ) {\n+        final Map<String, Integer> gapFillCounts = new HashMap<>();\n+        for ( final GATKRead read : reads ) {\n+            final Path path = new Path(read.getBasesNoCopy(), kmerAdjacencySet);\n+            final List<PathPart> parts = path.getParts();\n+            final int lastIdx = parts.size() - 1;\n+            for ( int idx = 1; idx < lastIdx; ++idx ) {\n+                final PathPart pathPart = parts.get(idx);\n+                if ( pathPart.isGap() ) {\n+                    final char prevCall = parts.get(idx - 1).getLastCall();\n+                    final char nextCall = parts.get(idx + 1).getFirstCall();\n+                    String gapFill = prevCall + pathPart.getSequence().toString() + nextCall;\n+                    final SequenceRC gapFillRC = new SequenceRC(gapFill);\n+                    if ( gapFillRC.compareTo(gapFill) < 0 ) {\n+                        gapFill = gapFillRC.toString();\n+                    }\n+                    gapFillCounts.merge(gapFill, 1, Integer::sum);\n+                }\n+            }\n+        }\n+\n+        boolean newKmers = false;\n+        for ( final Map.Entry<String, Integer> entry : gapFillCounts.entrySet() ) {\n+            final int nObservations = entry.getValue();\n+            if ( nObservations >= MIN_GAPFILL_COUNT ) {\n+                KmerAdjacency.kmerize(entry.getKey(), nObservations, kmerAdjacencySet);\n+                newKmers = true;\n+            }\n+        }\n+\n+        if ( newKmers ) {\n+            for ( final KmerAdjacency kmerAdjacency : kmerAdjacencySet ) {\n+                kmerAdjacency.clearContig();\n+            }\n+        }\n+        return newKmers;\n+    }\n+\n+    @VisibleForTesting\n+    static List<Path> pathReads( final KmerSet<KmerAdjacency> kmerAdjacencySet,\n+                          final List<GATKRead> reads ) {\n+        final List<Path> readPaths = new ArrayList<>(reads.size());\n+        for ( final GATKRead read : reads ) {\n+            readPaths.add(new Path(read.getBasesNoCopy(), kmerAdjacencySet));\n+        }\n+        return readPaths;\n+    }\n+\n+    @VisibleForTesting\n+    static Map<Contig,List<TransitPairCount>> collectTransitPairCounts(\n+            final List<ContigImpl> contigs,\n+            final List<Path> readPaths ) {\n+        final Map<Contig,List<TransitPairCount>> contigTransitsMap =\n+                new HashMap<>(3 * contigs.size());\n+        for ( final Path path : readPaths ) {\n+            final List<PathPart> parts = path.getParts();\n+            final int lastPart = parts.size() - 1;\n+            for ( int partIdx = 1; partIdx < lastPart; ++partIdx ) {\n+                final Contig prevContig = parts.get(partIdx - 1).getContig();\n+                if ( prevContig == null ) continue;\n+                final Contig curContig = parts.get(partIdx).getContig();\n+                if ( curContig == null ) {\n+                    partIdx += 1;\n+                    continue;\n+                }\n+                final Contig nextContig = parts.get(partIdx + 1).getContig();\n+                if ( nextContig == null ) {\n+                    partIdx += 2;\n+                    continue;\n+                }\n+                final TransitPairCount tpc = new TransitPairCount(prevContig, nextContig);\n+                final List<TransitPairCount> tpcList =\n+                        contigTransitsMap.computeIfAbsent(curContig, tig -> new ArrayList<>(4));\n+                final int idx = tpcList.indexOf(tpc);\n+                if ( idx != -1 ) {\n+                    tpcList.get(idx).observe();\n+                } else {\n+                    tpcList.add(tpc);\n+                    contigTransitsMap.computeIfAbsent(curContig.rc(), tig -> new ArrayList<>(4))\n+                            .add(tpc.getRC());\n+                }\n+            }\n+        }\n+        return contigTransitsMap;\n+    }\n+\n+    @VisibleForTesting\n+    static Set<Traversal> traverseAllPaths(\n+            final List<ContigImpl> contigs,\n+            final List<Path> readPaths,\n+            final Map<Contig, List<TransitPairCount>> contigTransitsMap ) {\n+        final Set<Traversal> traversalSet = new HashSet<>();\n+        final List<Contig> contigsList = new ArrayList<>();\n+        for ( final Contig contig : contigs ) {\n+            // untransited contigs are sources, sinks, or large contigs that can't be crossed by a read\n+            // build traversals from these\n+            if ( !contigTransitsMap.containsKey(contig) ) {\n+                boolean done = false;\n+                for ( final Contig successor : contig.getSuccessors() ) {\n+                    traverse(successor, contig,\n+                            contigsList, readPaths, contigTransitsMap, traversalSet);\n+                    done = true;\n+                }\n+                for ( final Contig predecessor : contig.getPredecessors() ) {\n+                    traverse(predecessor.rc(), contig.rc(),\n+                            contigsList, readPaths, contigTransitsMap, traversalSet);\n+                    done = true;\n+                }\n+                if ( !done ) { // if there were no predecessors or successors, it stands alone\n+                    addTraversal(new Traversal(Collections.singletonList(contig)), traversalSet);\n+                }\n+            }\n+        }\n+\n+        // look for transits that haven't been traced\n+        for ( final Map.Entry<Contig, List<TransitPairCount>> entry :\n+                contigTransitsMap.entrySet() ) {\n+            for ( final TransitPairCount tpc : entry.getValue() ) {\n+                if ( tpc.getCount() > 0 ) {\n+                    tpc.resetCount();\n+                    final Contig contig = entry.getKey();\n+                    final Set<Traversal> fwdTraversalSet = new HashSet<>();\n+                    traverse(tpc.getNextContig(), contig,\n+                            contigsList, readPaths, contigTransitsMap, fwdTraversalSet);\n+                    final Set<Traversal> revTraversalSet = new HashSet<>();\n+                    traverse(tpc.getPrevContig().rc(), contig.rc(),\n+                            contigsList, readPaths, contigTransitsMap, revTraversalSet);\n+                    for ( final Traversal revTraversal : revTraversalSet ) {\n+                        final Traversal revTraversalRC = revTraversal.rc();\n+                        for ( final Traversal fwdTraversal : fwdTraversalSet ) {\n+                            final int overlap =\n+                                    findMaxOverlap(revTraversalRC.getContigs(), fwdTraversal.getContigs());\n+                            final Traversal combo =\n+                                    Traversal.combineOverlappers(revTraversalRC, fwdTraversal, overlap);\n+                            addTraversal(combo, traversalSet);\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+\n+        return traversalSet;\n+    }\n+\n+    private static int findMaxOverlap( final List<Contig> prefixes, final List<Contig> suffixes ) {\n+        final int nPrefixes = prefixes.size();\n+        final Contig firstSuffix = suffixes.get(0);\n+        if ( !firstSuffix.isCyclic() ) {\n+            return prefixes.get(nPrefixes - 1) == firstSuffix ? 1 : 0;\n+        }\n+        final int nSuffixes = suffixes.size();\n+        for ( int prefixIdx = Math.max(0, nPrefixes - nSuffixes); prefixIdx != nPrefixes; ++prefixIdx ) {\n+            if ( prefixes.get(prefixIdx) == firstSuffix ) {\n+                int suffixIdx = 1;\n+                boolean match = true;\n+                for ( int prefixIdx2 = prefixIdx + 1; prefixIdx2 != nPrefixes; ++prefixIdx2 ) {\n+                    if ( prefixes.get(prefixIdx2) != suffixes.get(suffixIdx++) ) {\n+                        match = false;\n+                        break;\n+                    }\n+                }\n+                if ( match ) {\n+                    return nPrefixes - prefixIdx;\n+                }\n+            }\n+        }\n+        return 0;\n+    }\n+\n+    private static void traverse( final Contig contig,\n+                                  final Contig predecessor,\n+                                  final List<Contig> contigsList,\n+                                  final List<Path> readPaths,\n+                                  final Map<Contig, List<TransitPairCount>> contigTransitsMap,\n+                                  final Set<Traversal> traversalSet ) {\n+        contigsList.add(predecessor);\n+        if ( contig.isCyclic() ) {\n+            traverseCycle(contig, contigsList, readPaths, contigTransitsMap, traversalSet);\n+            contigsList.remove(contigsList.size() - 1);\n+            return;\n+        }\n+        final List<TransitPairCount> transits = contigTransitsMap.get(contig);\n+        boolean done = false;\n+        if ( transits != null ) {\n+            for ( final TransitPairCount tpc : transits ) {\n+                if ( tpc.getPrevContig() == predecessor ) {\n+                    final Contig successor = tpc.getNextContig();\n+                    if ( predecessor == contig.rc() ) {\n+                        final int nContigs = contigsList.size();\n+                        if ( nContigs > 1 ) {\n+                            if ( successor.rc() == contigsList.get(nContigs - 2) ) {\n+                                continue;\n+                            }\n+                        }\n+                    }\n+                    tpc.resetCount();\n+                    traverse(successor, contig, contigsList, readPaths, contigTransitsMap, traversalSet);\n+                    done = true;\n+                }\n+            }\n+        }\n+        if ( !done ) {\n+            contigsList.add(contig);\n+            addTraversal(new Traversal(contigsList), traversalSet);\n+            contigsList.remove(contigsList.size() - 1);\n+        }\n+        contigsList.remove(contigsList.size() - 1);\n+    }\n+\n+    private static void traverseCycle( final Contig contig,\n+                                       final List<Contig> contigsList,\n+                                       final List<Path> readPaths,\n+                                       final Map<Contig, List<TransitPairCount>> contigTransitsMap,\n+                                       final Set<Traversal> traversalSet ) {\n+        contigsList.add(contig);\n+        final int nContigs = contigsList.size();\n+        // the final element of the list is cyclic, if there's a previous element it will be\n+        // non-cyclic, so start there figuring out how far the read paths lead us\n+        final List<List<Contig>> longestPaths =\n+                findLongestPaths(contigsList.subList(Math.max(0, nContigs - 2), nContigs), readPaths);\n+        // didn't get anywhere -- just complete the traversal\n+        if ( longestPaths.isEmpty() ) {\n+            addTraversal(new Traversal(contigsList, true), traversalSet);\n+        } else {\n+            // for each unique extension into the cycle\n+            for ( final List<Contig> path : longestPaths ) {\n+                // don't think this can happen, but still\n+                if ( path.isEmpty() ) {\n+                    addTraversal(new Traversal(contigsList, true), traversalSet);\n+                    continue;\n+                }\n+                final List<Contig> extendedContigsList =\n+                        new ArrayList<>(contigsList.size() + path.size());\n+                extendedContigsList.addAll(contigsList);\n+                // if we didn't get out of the cycle\n+                if ( path.get(path.size() - 1).isCyclic() ) {\n+                    extendedContigsList.addAll(path);\n+                    addTraversal(new Traversal(extendedContigsList, true), traversalSet);\n+                } else {\n+                    // we found a cycle-exiting path, so extend that normally\n+                    for ( final Contig curContig : path ) {\n+                        if ( curContig.isCyclic() ) {\n+                            extendedContigsList.add(curContig);\n+                        } else {\n+                            final Contig prevContig =\n+                                    extendedContigsList.remove(extendedContigsList.size() - 1);\n+                            traverse(curContig, prevContig, extendedContigsList, readPaths,\n+                                    contigTransitsMap, traversalSet);\n+                            extendedContigsList.add(prevContig);\n+                            break;\n+                        }\n+                    }\n+                }\n+                clearTransitPairs(contigTransitsMap, extendedContigsList);\n+            }\n+        }\n+        contigsList.remove(contigsList.size() - 1);\n+    }\n+\n+    private static void clearTransitPairs(\n+            final Map<Contig, List<TransitPairCount>> contigTransitsMap,\n+            final List<Contig> contigsList ) {\n+        final int lastIdx = contigsList.size() - 1;\n+        for ( int idx = 1; idx < lastIdx; ++idx ) {\n+            final List<TransitPairCount> pairCounts = contigTransitsMap.get(contigsList.get(idx));\n+            if ( pairCounts != null ) {\n+                final Contig predecessor = contigsList.get(idx - 1);\n+                final Contig successor = contigsList.get(idx + 1);\n+                for ( final TransitPairCount tpc : pairCounts ) {\n+                    if ( tpc.getPrevContig() == predecessor && tpc.getNextContig() == successor ) {\n+                        tpc.resetCount();\n+                        break;\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    private static void addTraversal( final Traversal traversal,\n+                                      final Set<Traversal> traversalSet ) {\n+        if ( !traversalSet.contains(traversal.rc()) ) {\n+            traversalSet.add(traversal);\n+            if ( traversalSet.size() >= TOO_MANY_TRAVERSALS ) {\n+                throw new AssemblyTooComplexException();\n+            }\n+        }\n+    }\n+\n+    private static List<List<Contig>> findLongestPaths( final List<Contig> toMatch,\n+                                                        final List<Path> readPaths ) {\n+        final List<List<Contig>> results = new ArrayList<>();\n+        for ( final Path path : readPaths ) {\n+            testPath(path, toMatch, results);\n+            testPath(path.rc(), toMatch, results);\n+        }\n+        return results;\n+    }\n+\n+    private static void testPath( final Path path,\n+                                  final List<Contig> toMatch,\n+                                  final List<List<Contig>> results ) {\n+        final List<PathPart> pathParts = path.getParts();\n+        final int nPathParts = pathParts.size();\n+        final List<Contig> pathContigs = new ArrayList<>(nPathParts);\n+        pathParts.forEach(pp -> pathContigs.add(pp.getContig()));\n+        final int matchIdx = Collections.indexOfSubList(pathContigs, toMatch);\n+        if ( matchIdx != -1 ) {\n+            final int suffixIdx = matchIdx + toMatch.size();\n+            if ( suffixIdx < nPathParts ) {\n+                resolveResult(grabParts(pathContigs, suffixIdx), results);\n+            }\n+        }\n+    }\n+\n+    private static List<Contig> grabParts( final List<Contig> pathContigs, final int suffixIdx ) {\n+        final int nPathContigs = pathContigs.size();\n+        Contig prev = pathContigs.get(suffixIdx - 1);\n+        final List<Contig> result = new ArrayList<>(nPathContigs - suffixIdx);\n+        for ( int idx = suffixIdx; idx != nPathContigs; ++idx ) {\n+            final Contig tig = pathContigs.get(idx);\n+            if ( tig == null || !prev.getSuccessors().contains(tig) ) break;\n+            result.add(tig);\n+            prev = tig;\n+        }\n+        return result;\n+    }\n+\n+    private static void resolveResult( final List<Contig> result,\n+                                       final List<List<Contig>> results ) {\n+        final int nResults = results.size();\n+        for ( int idx = 0; idx != nResults; ++idx ) {\n+            final List<Contig> test = results.get(idx);\n+            if ( isPrefix(result, test) ) return;\n+            if ( isPrefix(test, result) ) {\n+                results.set(idx, result);\n+                return;\n+            }\n+        }\n+        results.add(result);\n+    }\n+\n+    private static boolean isPrefix( final List<Contig> list1, final List<Contig> list2 ) {\n+        final int list1Size = list1.size();\n+        final int list2Size = list2.size();\n+        if ( list1Size > list2Size ) return false;\n+        for ( int idx = 0; idx != list1Size; ++idx ) {\n+            if ( list1.get(idx) != list2.get(idx) ) return false;\n+        }\n+        return true;\n+    }\n+\n+    @VisibleForTesting\n+    static Collection<Traversal> createScaffolds( final List<Traversal> allTraversals ) {\n+        removeTriviallyDifferentTraversals(allTraversals);\n+\n+        final int nTraversals = allTraversals.size();\n+        final Map<Contig, List<Integer>> traversalsByFirstContig = new HashMap<>(3 * nTraversals);\n+        for ( int idx = 0; idx != nTraversals; ++idx ) {\n+            final Traversal traversal = allTraversals.get(idx);\n+            traversalsByFirstContig.compute(traversal.getFirstContig(),\n+                    ( k, v ) -> v == null ? new ArrayList<>(3) : v).add(idx);\n+            final Traversal rcTraversal = traversal.rc();\n+            traversalsByFirstContig.compute(rcTraversal.getFirstContig(),\n+                    ( k, v ) -> v == null ? new ArrayList<>(3) : v).add(~idx);\n+        }\n+\n+        final List<Traversal> scaffolds = new ArrayList<>(nTraversals);\n+        final boolean[] touched = new boolean[nTraversals];\n+        for ( int idx = 0; idx != nTraversals; ++idx ) {\n+            if ( !touched[idx] ) {\n+                expandTraversal(idx, touched, traversalsByFirstContig, allTraversals, scaffolds);\n+            }\n+        }\n+        return scaffolds;\n+    }\n+\n+    private static void expandTraversal( final int traversalIdx,\n+                                         final boolean[] touched,\n+                                         final Map<Contig, List<Integer>> traversalsByFirstContig,\n+                                         final List<Traversal> allTraversals,\n+                                         final List<Traversal> scaffolds ) {\n+        final Traversal traversal = allTraversals.get(traversalIdx);\n+        touched[traversalIdx] = true;\n+        final List<Traversal> downExtensions = new ArrayList<>();\n+        final Set<Contig> startingContigSet = new HashSet<>();\n+        walkTraversals(traversal, touched, startingContigSet, traversalsByFirstContig,\n+                        allTraversals, downExtensions);\n+        final List<Traversal> upExtensions = new ArrayList<>();\n+        walkTraversals(traversal.rc(), touched, startingContigSet, traversalsByFirstContig,\n+                        allTraversals, upExtensions);\n+        for ( final Traversal down : downExtensions ) {\n+            for ( final Traversal up : upExtensions ) {\n+                if ( scaffolds.size() >= TOO_MANY_SCAFFOLDS ) {\n+                    throw new AssemblyTooComplexException();\n+                }\n+                scaffolds.add(Traversal.combineOverlappers(up.rc(), down, traversal.getContigs().size()));\n+            }\n+        }\n+    }\n+\n+    private static void walkTraversals( final Traversal traversal,\n+                                        final boolean[] touched,\n+                                        final Set<Contig> startingContigSet,\n+                                        final Map<Contig, List<Integer>> traversalsByFirstContig,\n+                                        final List<Traversal> allTraversals,\n+                                        final List<Traversal> extensions ) {\n+        final Contig firstContig = traversal.getFirstContig();\n+        final List<Integer> indexList;\n+        if ( startingContigSet.contains(firstContig) ||\n+                traversal.isInextensible() ||\n+                (indexList = traversalsByFirstContig.get(traversal.getLastContig())) == null ) {\n+            extensions.add(traversal);\n+            return;\n+        }\n+        startingContigSet.add(firstContig);\n+        for ( int idx : indexList ) {\n+            final Traversal extension;\n+            if ( idx >= 0 ) {\n+                extension = allTraversals.get(idx);\n+                touched[idx] = true;\n+            } else {\n+                final int rcIdx = ~idx;\n+                extension = allTraversals.get(rcIdx).rc();\n+                touched[rcIdx] = true;\n+            }\n+            walkTraversals(Traversal.combine(traversal, extension), touched, startingContigSet,\n+                            traversalsByFirstContig, allTraversals, extensions );\n+        }\n+        startingContigSet.remove(firstContig);\n+    }\n+\n+    private static void removeTriviallyDifferentTraversals(\n+                                            final Collection<Traversal> allTraversals ) {\n+        if ( allTraversals.isEmpty() ) {\n+            return;\n+        }\n+        final TreeSet<Traversal> sortedTraversals = new TreeSet<>(new TraversalEndpointComparator());\n+        for ( final Traversal traversal : allTraversals ) {\n+            sortedTraversals.add(traversal);\n+            sortedTraversals.add(traversal.rc());\n+        }\n+        final Iterator<Traversal> traversalIterator = sortedTraversals.iterator();\n+        Traversal prevTraversal = traversalIterator.next();\n+        while ( traversalIterator.hasNext() ) {\n+            final Traversal curTraversal = traversalIterator.next();\n+            if ( isTriviallyDifferent(prevTraversal, curTraversal) ) {\n+                traversalIterator.remove();\n+            } else {\n+                prevTraversal = curTraversal;\n+            }\n+        }\n+        sortedTraversals.removeIf(Traversal::isRC);\n+        allTraversals.clear();\n+        allTraversals.addAll(sortedTraversals);\n+    }\n+\n+    private static boolean isTriviallyDifferent( final Traversal traversal1,\n+                                                 final Traversal traversal2 ) {\n+        final Contig firstContig1 = traversal1.getFirstContig();\n+        final Contig lastContig1 = traversal1.getLastContig();\n+        final Contig firstContig2 = traversal2.getFirstContig();\n+        final Contig lastContig2 = traversal2.getLastContig();\n+        if ( firstContig1 != firstContig2 || lastContig1 != lastContig2 ) {\n+            return false;\n+        }\n+        final int interiorSize1 = traversal1.getSequenceLength() - firstContig1.size() - lastContig1.size();\n+        final int interiorSize2 = traversal2.getSequenceLength() - firstContig2.size() - lastContig2.size();\n+\n+        // if the path lengths are so different that one could harbor an SV, they're not trivially different\n+        if ( Math.abs(interiorSize1 - interiorSize2) >= MIN_SV_SIZE ) {\n+            return false;\n+        }\n+\n+        // if the paths are small enough that there can't be an SV's worth of differences, they're trivially different\n+        final int maxInteriorSize = Math.max(interiorSize1, interiorSize2);\n+        if ( maxInteriorSize < MIN_SV_SIZE ) {\n+            return true;\n+        }\n+\n+        // dang, maybe there's enough material in common that there can't be an SV's worth of differences\n+        // run a longest common subsequence algorithm to figure out the length of the common material\n+        // DP matrix holds length of common material\n+        final List<Contig> contigs1 = traversal1.getContigs();\n+        final int rowLen = contigs1.size() - 1;\n+        final int[][] rowPair = new int[2][];\n+        rowPair[0] = new int[rowLen];\n+        rowPair[1] = new int[rowLen];\n+        int pairIdx = 0;\n+        final List<Contig> contigs2 = traversal2.getContigs();\n+        final int nRows = contigs2.size() - 1;\n+        for ( int idx2 = 1; idx2 != nRows; ++idx2 ) {\n+            final int[] curRow = rowPair[pairIdx];\n+            final int[] prevRow = rowPair[pairIdx ^ 1];\n+            pairIdx ^= 1;\n+\n+            final int id2 = contigs2.get(idx2).getId();\n+            for ( int idx1 = 1; idx1 != rowLen; ++idx1 ) {\n+                final Contig tig1 = contigs1.get(idx1);\n+                if ( tig1.getId() == id2 ) {\n+                    // if the previous cells also contain a match we've already removed the K-1 bases upstream\n+                    final boolean extendMatch =\n+                            contigs1.get(idx1 -1).getId() == contigs2.get(idx2 - 1).getId();\n+                    curRow[idx1] = prevRow[idx1 - 1] + (extendMatch ? tig1.getNKmers() : tig1.size());\n+                } else {\n+                    curRow[idx1] = Math.max(curRow[idx1 - 1], prevRow[idx1]);\n+                }\n+            }\n+        }\n+        final int commonLen = rowPair[pairIdx ^ 1][rowLen - 1];\n+        return (maxInteriorSize - commonLen) < MIN_SV_SIZE;\n+    }\n+\n+    private static class TraversalEndpointComparator implements Comparator<Traversal> {\n+        @Override\n+        public int compare( final Traversal traversal1, final Traversal traversal2 ) {\n+            int cmp = Integer.compare(traversal1.contigs.get(0).getId(),\n+                                      traversal2.contigs.get(0).getId());\n+            if ( cmp != 0 ) {\n+                return cmp;\n+            }\n+            final int last1 = traversal1.contigs.size() - 1;\n+            final int last2 = traversal2.contigs.size() - 1;\n+            cmp = Integer.compare(traversal1.contigs.get(last1).getId(),\n+                                  traversal2.contigs.get(last2).getId());\n+            if ( cmp != 0 ) {\n+                return cmp;\n+            }\n+            // among those starting and ending at the same place, sort least observed last\n+            return -Integer.compare(traversal1.getMinMaxObservations(), traversal2.getMinMaxObservations());\n+        }\n+    }\n+\n+    private static void writeDOT( final List<ContigImpl> contigs, final String fileName ) {\n+        try ( final BufferedWriter writer = new BufferedWriter(new FileWriter(fileName)) ) {\n+            writer.write(\"digraph {\\n\");\n+            for ( final Contig contig : contigs ) {\n+                final double width = contig.getSequence().length() / 100.;\n+                writer.write(contig + \" [width=\" + width + \"]\\n\");\n+                writer.write( contig.rc() + \" [width=\" + width + \"]\\n\");\n+            }\n+            for ( final Contig contig : contigs ) {\n+                for ( final Contig predecessor : contig.getPredecessors() ) {\n+                    final String predecessorName = predecessor.rc().toString();\n+                    writer.write(contig.rc() + \" -> \" + predecessorName + \"\\n\");\n+                }\n+                for ( final Contig successor : contig.getSuccessors() ) {\n+                    final String successorName = successor.toString();\n+                    writer.write(contig + \" -> \" + successorName + \"\\n\");\n+                }\n+            }\n+            writer.write(\"}\\n\");\n+        } catch ( final IOException ioe ) {\n+            throw new GATKException(\"Failed to write assembly DOT file.\", ioe);\n+        }\n+    }\n+\n+    private static BufferedWriter makeGZFile( final String fileName ) throws IOException {\n+        final GZIPOutputStream gzOS = new GZIPOutputStream(BucketUtils.createFile(fileName));\n+        return new BufferedWriter(new OutputStreamWriter(gzOS));\n+    }\n+\n+    private static void writeContigs( final List<ContigImpl> contigs, final String fileName ) {\n+        try ( final BufferedWriter writer = makeGZFile(fileName) ) {\n+            for ( final Contig contig : contigs ) {\n+                final List<Contig> predecessors = contig.getPredecessors();\n+                final String predecessorDescription;\n+                if ( predecessors.size() == 0 ) {\n+                    predecessorDescription = \"\\tnone\";\n+                } else {\n+                    final StringBuilder sb = new StringBuilder();\n+                    char prefix = '\\t';\n+                    for ( final Contig predecessor : predecessors ) {\n+                        sb.append(prefix);\n+                        prefix = ',';\n+                        sb.append(predecessor);\n+                    }\n+                    predecessorDescription = sb.toString();\n+                }\n+\n+                final List<Contig> successors = contig.getSuccessors();\n+                final String successorDescription;\n+                if ( successors.size() == 0 ) {\n+                    successorDescription = \"\\tnone\";\n+                } else {\n+                    final StringBuilder sb = new StringBuilder();\n+                    char prefix = '\\t';\n+                    for ( final Contig successor : successors ) {\n+                        sb.append(prefix);\n+                        prefix = ',';\n+                        sb.append(successor);\n+                    }\n+                    successorDescription = sb.toString();\n+                }\n+\n+                final String contigName = contig.toString();\n+                final String component =\n+                        (contig.isCyclic() ? \"(C)\\t\" : \"\\t\") + contig.getComponentId();\n+                writer.write(contigName + component + predecessorDescription +\n+                        successorDescription + \"\\t\" +\n+                        contig.getMaxObservations() + \"\\t\" +\n+                        contig.getFirstKmer().getNObservations() + \"\\t\" +\n+                        contig.getLastKmer().getNObservations() + \"\\t\" +\n+                        contig.size() + \"\\t\" +\n+                        contig.getSequence() + \"\\n\");\n+            }\n+        } catch ( final IOException ioe ) {\n+            throw new GATKException(\"Failed to write contigs file.\", ioe);\n+        }\n+    }\n+\n+    private static void writePaths( final List<Path> readPaths, final String fileName ) {\n+        try ( final BufferedWriter writer = makeGZFile(fileName) ) {\n+            final int nReads = readPaths.size();\n+            for ( int readId = 0; readId != nReads; ++readId ) {\n+                final Path path = readPaths.get(readId);\n+                final String pathDesc = path.toString();\n+                writer.write((readId + 1) + \": \" + pathDesc + \"\\n\");\n+            }\n+        } catch ( final IOException ioe ) {\n+            throw new GATKException(\"Failed to write paths file.\", ioe);\n+        }\n+    }\n+\n+    private static void writeReads( final List<GATKRead> reads, final String fileName ) {\n+        try ( final BufferedWriter writer = makeGZFile(fileName) ) {\n+            for ( final GATKRead read : reads ) {\n+                writer.write(\"@\" + read.getName());\n+                writer.write('\\n');\n+                writer.write(new String(read.getBasesNoCopy()));\n+                writer.write(\"\\n+\\n\");\n+                final byte[] quals = read.getBaseQualitiesNoCopy();\n+                final int nQuals = quals.length;\n+                final byte[] fastqQuals = new byte[nQuals];\n+                for ( int idx = 0; idx != nQuals; ++idx ) {\n+                    fastqQuals[idx] = (byte)SAMUtils.phredToFastq(quals[idx]);\n+                }\n+                writer.write(new String(fastqQuals));\n+                writer.write('\\n');\n+            }\n+        } catch ( final IOException ioe ) {\n+            throw new GATKException(\"Failed to write assembly sam file.\", ioe);\n+        }\n+    }\n+\n+    private static void writeTraversals( final Collection<Traversal> traversals,\n+                                         final String fileName ) {\n+        try ( final BufferedWriter writer = makeGZFile(fileName) ) {\n+            int traversalNo = 0;\n+            for ( final Traversal traversal : traversals ) {\n+                writer.write(\">\");\n+                if ( assemblyName != null ) {\n+                    writer.write(assemblyName);\n+                    writer.write(\"_\");\n+                }\n+                writer.write(\"t\");\n+                writer.write(Integer.toString(++traversalNo));\n+                writer.write(\" \");\n+                writer.write(traversal.getName());\n+                writer.newLine();\n+                writer.write(traversal.getSequence());\n+                writer.newLine();\n+            }\n+        } catch ( final IOException ioe ) {\n+            throw new GATKException(\"Failed to write assembly sam file.\", ioe);\n+        }\n+    }\n+\n+    /** fixed-size, immutable kmer.  usual 2-bit encoding: ACGT->0123.  low order bits are final call. **/\n+    public static class Kmer {\n+        public static final int KSIZE = 31; // must be odd number less than 32\n+        public static final long KMASK = (1L << 2*KSIZE) - 1L;\n+        private final long kVal;\n+\n+        public Kmer( final long kVal ) { this.kVal = kVal; }\n+\n+        public long getKVal() { return kVal; }\n+        public boolean isCanonical() { return isCanonical(kVal); }\n+        public int getInitialCall() { return (int)(kVal >> (KSIZE*2 - 2)) & 3; }\n+        public int getFinalCall() { return (int)kVal & 3; }\n+\n+        public long getPredecessorVal( final int call ) {\n+            return (kVal >> 2) | ((long)call << (2 * (KSIZE - 1)));\n+        }\n+        public long getSuccessorVal( final int call ) { return ((kVal << 2) & KMASK) | call; }\n+\n+        public static boolean isCanonical( final long val ) {\n+            return (val & (1L << KSIZE)) == 0L;\n+        }\n+\n+        @Override public boolean equals( final Object obj ) {\n+            return obj instanceof Kmer && kVal == ((Kmer)obj).kVal;\n+        }\n+\n+        @Override public int hashCode() {\n+            return (int)(kVal ^ (kVal >>> 32));\n+        }\n+    }\n+\n+    /** Set of Kmers.  Uses HopscotchSet, customized to find correct starting bin for Kmers and derivatives. **/\n+    public static final class KmerSet<KMER extends Kmer> extends HopscotchSet<KMER> {\n+        public KmerSet( final int capacity ) { super(capacity); }\n+\n+        @Override\n+        protected int hashToIndex( final Object kmer ) {\n+            return (int)(((HopscotchSet.SPREADER * ((Kmer)kmer).getKVal()) & Long.MAX_VALUE) % capacity());\n+        }\n+    }\n+\n+    /**\n+     *  A Kmer that remembers its predecessors and successors, and the number of times it's been observed\n+     *  in the assembly's input set of reads.\n+     *  The masks are bit-wise (1=A, 2=C, 4=G, 8=T) to show which predecessors or successors have been observed.\n+     *  The Kmer's position on a Contig is also tracked (in later phases of the assembly process).\n+     **/\n+    public static abstract class KmerAdjacency extends Kmer {\n+        public KmerAdjacency( final long kVal ) { super(kVal); }\n+\n+        public abstract KmerAdjacency getSolePredecessor(); // returns null if there's 0 or >1 predecessors\n+        public abstract int getPredecessorMask();\n+        public abstract int getPredecessorCount();\n+        public abstract void removePredecessor( final int callToRemove,\n+                                                final KmerSet<KmerAdjacency> kmerAdjacencySet );\n+\n+        public abstract KmerAdjacency getSoleSuccessor(); // returns null if there's 0 or > 1 successors\n+        public abstract int getSuccessorMask();\n+        public abstract int getSuccessorCount();\n+        public abstract void removeSuccessor( final int callToRemove,\n+                                              final KmerSet<KmerAdjacency> kmerAdjacencySet );\n+\n+        public abstract Contig getContig();\n+        public abstract int getContigOffset();\n+        // offset is 0-based measure on the contig sequence of the beginning of the kmer\n+        public abstract void setContigOffset( final Contig contig, final int contigOffset );\n+        public abstract void clearContig();\n+\n+        public abstract int getNObservations();\n+        public abstract KmerAdjacency rc();\n+        public abstract KmerAdjacencyImpl canonical();\n+\n+        public void observe( final KmerAdjacency predecessor, final KmerAdjacency successor ) {\n+            observe(predecessor, successor, 1);\n+        }\n+\n+        public abstract void observe( final KmerAdjacency predecessor,\n+                                      final KmerAdjacency successor,\n+                                      final int count );\n+\n+        @Override public String toString() {\n+            final StringBuilder sb = new StringBuilder(KSIZE);\n+            long currentVal = getKVal();\n+            for ( int idx = 0; idx != KSIZE; ++idx ) {\n+                sb.append(\"ACGT\".charAt((int)currentVal & 3));\n+                currentVal >>= 2;\n+            }\n+            sb.reverse(); // low order bits were loaded into sb first:  fix that now by reversing the sb.\n+            return sb.toString();\n+        }\n+\n+        /**\n+         * Transform a read's calls into KmerAdjacencies, and add them to a KmerSet.\n+         * Skip kmers that include a call with a quality < qMin.\n+         * Skip kmers with non-ACGT calls.\n+         **/\n+        public static void kmerize( final byte[] calls,\n+                                    final byte[] quals,\n+                                    final byte qMin,\n+                                    final KmerSet<KmerAdjacency> kmerAdjacencySet ) {\n+            int currentCount = 0; // number of calls loaded into currentKVal\n+            long currentKVal = 0;\n+            KmerAdjacency prevAdjacency = null;\n+            KmerAdjacency currentAdjacency = null;\n+            for ( int idx = 0; idx < calls.length; ++idx ) {\n+                if ( quals[idx] < qMin ) { // if we encounter a low-quality call\n+                    // take care of the most recent valid KmerAdjacency, if any\n+                    if ( currentAdjacency != null ) {\n+                        currentAdjacency.observe(prevAdjacency, null);\n+                    }\n+                    // ready ourselves to accumulate calls afresh\n+                    currentCount = 0;\n+                    currentAdjacency = prevAdjacency = null;\n+                    continue;\n+                }\n+                currentKVal <<= 2;\n+                switch ( calls[idx] ) {\n+                    case 'A': case 'a': break;\n+                    case 'C': case 'c': currentKVal += 1; break;\n+                    case 'G': case 'g': currentKVal += 2; break;\n+                    case 'T': case 't': currentKVal += 3; break;\n+                    default:\n+                        if ( currentAdjacency != null ) {\n+                            currentAdjacency.observe(prevAdjacency, null);\n+                        }\n+                        currentCount = 0;\n+                        currentAdjacency = prevAdjacency = null;\n+                        continue;\n+                }\n+                if ( ++currentCount >= KSIZE ) { // if we've loaded enough calls to make a complete kmer\n+                    final KmerAdjacency nextAdjacency = findOrAdd(currentKVal, kmerAdjacencySet);\n+                    if ( currentAdjacency != null ) {\n+                        currentAdjacency.observe(prevAdjacency, nextAdjacency);\n+                    }\n+                    prevAdjacency = currentAdjacency;\n+                    currentAdjacency = nextAdjacency;\n+                }\n+            }\n+            if ( currentAdjacency != null ) {\n+                currentAdjacency.observe(prevAdjacency, null);\n+            }\n+        }\n+\n+        /**\n+         * Kmerize a String.  This version is for gap fills.\n+         * The number of observations applies to all kmers except the 1st and last.\n+         **/\n+        public static void kmerize( final String sequence,\n+                                    final int nObservations,\n+                                    final KmerSet<KmerAdjacency> kmerAdjacencySet ) {\n+            int currentCount = 0;\n+            long currentKVal = 0;\n+            int nObs = 0;\n+            KmerAdjacency prevAdjacency = null;\n+            KmerAdjacency currentAdjacency = null;\n+            final int nCalls = sequence.length();\n+            for ( int idx = 0; idx != nCalls; ++idx ) {\n+                currentKVal <<= 2;\n+                switch ( sequence.charAt(idx) ) {\n+                    case 'A': case 'a': break;\n+                    case 'C': case 'c': currentKVal += 1; break;\n+                    case 'G': case 'g': currentKVal += 2; break;\n+                    case 'T': case 't': currentKVal += 3; break;\n+                    default: throw new GATKException(\"unexpected base call in string to kmerize.\");\n+                }\n+                if ( ++currentCount >= KSIZE ) {\n+                    final KmerAdjacency nextAdjacency = findOrAdd(currentKVal, kmerAdjacencySet);\n+                    if ( currentAdjacency != null ) {\n+                        currentAdjacency.observe(prevAdjacency, nextAdjacency, nObs);\n+                        nObs = nObservations;\n+                    }\n+                    prevAdjacency = currentAdjacency;\n+                    currentAdjacency = nextAdjacency;\n+                }\n+            }\n+            if ( currentAdjacency != null ) {\n+                currentAdjacency.observe(prevAdjacency, null, 0);\n+            }\n+        }\n+\n+        // Lookup table for reverse-complementing each possible byte value.\n+        // Each pair of bits represents a base, so you have to reverse bits pairwise and then invert all bits.\n+        // This is most quickly and easily done with a lookup table.\n+        private static final long[] BYTEWISE_REVERSE_COMPLEMENT;\n+        static {\n+            BYTEWISE_REVERSE_COMPLEMENT = new long[256];\n+            for ( int bIn = 0; bIn != 256; ++bIn ) {\n+                BYTEWISE_REVERSE_COMPLEMENT[bIn] =\n+                        ~(((bIn & 3) << 6) | (((bIn >> 2) & 3) << 4) |\n+                                (((bIn >> 4) & 3) << 2) | ((bIn >> 6) & 3)) & 0xffL;\n+            }\n+        }\n+\n+        public static long reverseComplement( long val ) {\n+            // process val one byte at a time\n+            long result = BYTEWISE_REVERSE_COMPLEMENT[(int)val & 0xFF]; // handle the low-order byte\n+            int nBytes = 8;\n+            while ( --nBytes != 0 ) { // pre-decrementing:  we'll go through the loop 7 times\n+                // rotate down by a byte\n+                val >>= 8;\n+                // rotate up by a byte and OR in the reverse complement of the next byte\n+                result = (result << 8) | BYTEWISE_REVERSE_COMPLEMENT[(int)val & 0xFF];\n+            }\n+            return result >>> (Long.SIZE - 2*KSIZE);\n+        }\n+\n+        // Kmer lookup in KmerSet.\n+        // KmerSets holding KmerAdjacencies have only canonical Kmers, so RC non-canonical kmers before lookup.\n+        public static KmerAdjacency find( final long kVal,\n+                                          final KmerSet<KmerAdjacency> kmerAdjacencySet ) {\n+            if ( isCanonical(kVal) ) return kmerAdjacencySet.find(new Kmer(kVal & KMASK));\n+            final KmerAdjacency result = kmerAdjacencySet.find(new Kmer(reverseComplement(kVal)));\n+            return result == null ? null : result.rc();\n+        }\n+\n+        // Kmer lookup in KmerSet.\n+        // KmerSets holding KmerAdjacencies have only canonical Kmers, so RC non-canonical kmers before lookup.\n+        // Add missing Kmers.\n+        public static KmerAdjacency findOrAdd( final long kVal,\n+                                               final KmerSet<KmerAdjacency> kmerAdjacencySet ) {\n+            if ( isCanonical(kVal) ) {\n+                return kmerAdjacencySet.findOrAdd(new Kmer(kVal & KMASK), kmer ->\n+                        new KmerAdjacencyImpl(((Kmer)kmer).getKVal()));\n+            }\n+            return kmerAdjacencySet.findOrAdd(new Kmer(reverseComplement(kVal)), kmer ->\n+                    new KmerAdjacencyImpl(((Kmer)kmer).getKVal())).rc();\n+        }\n+    }\n+\n+    /**\n+     * Class to implement KmerAdjacency for canonical Kmers.\n+     * In particular, a KmerSet created on KmerAdjacency contains only canonical Kmers.\n+     **/\n+    public static final class KmerAdjacencyImpl extends KmerAdjacency {\n+        private KmerAdjacency solePredecessor; // set to null if there are no predecessors, or multiple predecessors\n+        private KmerAdjacency soleSuccessor; // set to null if there are no successors, or multiple successors\n+        private int predecessorMask; // bit mask of observed kmers preceding this one\n+        private int successorMask; // bit mask observed kmers following this one\n+        private Contig contig; // the contig that contains this Kmer\n+        private int contigOffset; // the offset within the contig where this kmer is found\n+        private int nObservations; // the reads in which this kmer was observed\n+        private final KmerAdjacencyRC rc; // the reverse-complement of this kmer\n+        private static final int[] COUNT_FOR_MASK =\n+                //side sum for binary values from 0 -> 15\n+                //0000  0001 0010 0011 0100 0101 0110 0111 1000 1001 1010 1011 1100 1101 1110 1111\n+                {    0,    1,   1,   2,   1,   2,   2,   3,   1,   2,   2,   3,   2,   3,   3,   4 };\n+\n+        public KmerAdjacencyImpl( final long kVal ) {\n+            super(kVal);\n+            this.rc = new KmerAdjacencyRC(this);\n+        }\n+\n+        @Override public KmerAdjacency getSolePredecessor() { return solePredecessor; } // may return null\n+        @Override public int getPredecessorMask() { return predecessorMask; }\n+        @Override public int getPredecessorCount() { return COUNT_FOR_MASK[predecessorMask]; }\n+        @Override\n+        public void removePredecessor( final int callToRemove,\n+                                       final KmerSet<KmerAdjacency> kmerAdjacencySet ) {\n+            predecessorMask &= ~(1 << callToRemove);\n+            solePredecessor = null;\n+            if ( getPredecessorCount() == 1 ) {\n+                for ( int call = 0; call != 4; ++call ) {\n+                    if ( ((1 << call) & predecessorMask) != 0 ) {\n+                        solePredecessor = find(getPredecessorVal(call), kmerAdjacencySet);\n+                        break;\n+                    }\n+                }\n+            }\n+        }\n+\n+        @Override public KmerAdjacency getSoleSuccessor() { return soleSuccessor; } // may return null\n+        @Override public int getSuccessorMask() { return successorMask; }\n+        @Override public int getSuccessorCount() { return COUNT_FOR_MASK[successorMask]; }\n+        @Override\n+        public void removeSuccessor( final int callToRemove,\n+                                     final KmerSet<KmerAdjacency> kmerAdjacencySet ) {\n+            successorMask &= ~(1 << callToRemove);\n+            soleSuccessor = null;\n+            if ( getSuccessorCount() == 1 ) {\n+                for ( int call = 0; call != 4; ++call ) {\n+                    if ( ((1 << call) & successorMask) != 0 ) {\n+                        soleSuccessor = find(getSuccessorVal(call), kmerAdjacencySet);\n+                        break;\n+                    }\n+                }\n+            }\n+        }\n+\n+        @Override public Contig getContig() { return contig; }\n+        @Override public int getContigOffset() { return contigOffset; }\n+        @Override public void setContigOffset( final Contig contig, final int contigOffset ) {\n+            if ( this.contig != null ) {\n+                throw new GATKException(\"Internal error: overwriting kmer contig and offset.\");\n+            }\n+            this.contig = contig;\n+            this.contigOffset = contigOffset;\n+        }\n+        @Override public void clearContig() { contig = null; contigOffset = 0; }\n+\n+        @Override public int getNObservations() { return nObservations; }\n+        @Override public KmerAdjacency rc() { return rc; }\n+        @Override public KmerAdjacencyImpl canonical() { return this; }\n+\n+        @Override public void observe( final KmerAdjacency predecessor,\n+                                       final KmerAdjacency successor,\n+                                       final int count ) {\n+            if ( predecessor != null ) {\n+                if ( predecessor.getSuccessorVal(getFinalCall()) != getKVal() ) {\n+                    throw new GATKException(\"illegal predecessor\");\n+                }\n+                final int initialCall = predecessor.getInitialCall();\n+                final int newPredecessorMask = 1 << initialCall;\n+                if ( (newPredecessorMask & predecessorMask) == 0 ) {\n+                    if ( predecessorMask == 0 ) {\n+                        solePredecessor = predecessor;\n+                        predecessorMask = newPredecessorMask;\n+                    } else {\n+                        solePredecessor = null;\n+                        predecessorMask |= newPredecessorMask;\n+                    }\n+                }\n+            }\n+            if ( successor != null ) {\n+                if ( successor.getPredecessorVal(getInitialCall()) != getKVal() ) {\n+                    throw new GATKException(\"illegal successor\");\n+                }\n+                final int finalCall = successor.getFinalCall();\n+                final int newSuccessorMask = 1 << finalCall;\n+                if ( (newSuccessorMask & successorMask) == 0 ) {\n+                    if ( successorMask == 0 ) {\n+                        soleSuccessor = successor;\n+                        successorMask = newSuccessorMask;\n+                    } else {\n+                        soleSuccessor = null;\n+                        successorMask |= newSuccessorMask;\n+                    }\n+                }\n+            }\n+            nObservations += count;\n+        }\n+    }\n+\n+    /**\n+     * Class to implement KmerAdjacency for Kmers that are the reverse-complement of a canonical Kmer.\n+     * In particular, a KmerSet created on KmerAdjacency contains only canonical Kmers.\n+     * A KmerAdjacencyRC represents the RC of each Kmer in the KmerSet.\n+     **/\n+    public static final class KmerAdjacencyRC extends KmerAdjacency {\n+        private final KmerAdjacencyImpl rc;\n+\n+        // lookup table to bit-reverse nibbles\n+        private static final int[] NIBREV =\n+                // 0000,  0001,  0010,  0011,  0100,  0101,  0110,  0111,  1000,  1001,  1010,  1011,  1100,  1101,  1110,  1111\n+                {0b0000,0b1000,0b0100,0b1100,0b0010,0b1010,0b0110,0b1110,0b0001,0b1001,0b0101,0b1101,0b0011,0b1011,0b0111,0b1111};\n+\n+        public KmerAdjacencyRC( final KmerAdjacencyImpl rc ) {\n+            super(reverseComplement(rc.getKVal()));\n+            this.rc = rc;\n+        }\n+\n+        @Override public KmerAdjacency getSolePredecessor() {\n+            final KmerAdjacency successor = rc.getSoleSuccessor();\n+            return successor == null ? null : successor.rc();\n+        }\n+        @Override public int getPredecessorMask() { return NIBREV[rc.getSuccessorMask()]; }\n+        @Override public int getPredecessorCount() { return rc.getSuccessorCount(); }\n+        @Override\n+        public void removePredecessor( final int callToRemove,\n+                                       final KmerSet<KmerAdjacency> kmerAdjacencySet ) {\n+            rc.removeSuccessor(3 - callToRemove, kmerAdjacencySet);\n+        }\n+\n+        @Override public KmerAdjacency getSoleSuccessor() {\n+            final KmerAdjacency predecessor = rc.getSolePredecessor();\n+            return predecessor == null ? null : predecessor.rc();\n+        }\n+        @Override public int getSuccessorMask() { return NIBREV[rc.getPredecessorMask()]; }\n+        @Override public int getSuccessorCount() { return rc.getPredecessorCount(); }\n+        @Override\n+        public void removeSuccessor( final int callToRemove,\n+                                     final KmerSet<KmerAdjacency> kmerAdjacencySet ) {\n+            rc.removePredecessor(3 - callToRemove, kmerAdjacencySet);\n+        }\n+\n+        @Override public Contig getContig() {\n+            final Contig contig = rc.getContig();\n+            return contig == null ? null : contig.rc();\n+        }\n+        @Override public int getContigOffset() {\n+            final Contig contig = rc.getContig();\n+            return contig == null ? 0 : contig.size() - rc.getContigOffset() - KSIZE;\n+        }\n+        @Override public void setContigOffset( final Contig contig, final int contigOffset ) {\n+            rc.setContigOffset(contig.rc(), contig.size() - contigOffset - KSIZE);\n+        }\n+        @Override public void clearContig() { rc.clearContig(); }\n+\n+        @Override public int getNObservations() { return rc.getNObservations(); }\n+        @Override public KmerAdjacency rc() { return rc; }\n+        @Override public KmerAdjacencyImpl canonical() { return rc; }\n+\n+        @Override public void observe( final KmerAdjacency predecessor,\n+                                       final KmerAdjacency successor,\n+                                       final int count ) {\n+            rc.observe(successor == null ? null : successor.rc(),\n+                    predecessor == null ? null : predecessor.rc(),\n+                    count);\n+        }\n+    }\n+\n+    public enum ContigOrientation {\n+        FWD, // k-mer appears at the 5' end of the contig\n+        REV, // k-mer appears at the 5' end of the reverse-complemented contig\n+        BOTH // k-mer occurs on 5' end of the contig and its RC (can happen when the contig is a palindrome)\n+    }\n+\n+    /** Initial or final Kmer in a Contig. **/\n+    public static final class ContigEndKmer extends Kmer {\n+        private final Contig contig;\n+        private final ContigOrientation contigOrientation;\n+\n+        public ContigEndKmer( final long kVal,\n+                              final Contig contig,\n+                              final ContigOrientation contigEnd ) {\n+            super(kVal);\n+            this.contig = contig;\n+            this.contigOrientation = contigEnd;\n+        }\n+\n+        public Contig getContig() { return contig; }\n+        public ContigOrientation getContigOrientation() { return contigOrientation; }\n+    }\n+\n+    /**\n+     * An unbranched sequence of Kmers.\n+     * Each Kmer (except the last one) has a single successor, which allows enumerating the sequence\n+     * of Kmers in the Contig.  The sequence of base calls in the Contig is just the sequence of kmers\n+     * with the K-1 overlapping calls removed from adjacent kmers.\n+     **/\n+    public interface Contig {\n+        int getId();\n+        CharSequence getSequence();\n+        int getMaxObservations();\n+        KmerAdjacency getFirstKmer();\n+        KmerAdjacency getLastKmer();\n+        List<Contig> getPredecessors();\n+        List<Contig> getSuccessors();\n+        int getComponentId();\n+        int size();\n+        default int getNKmers() { return size() - Kmer.KSIZE + 1; }\n+        Contig rc();\n+        boolean isCyclic();\n+        void setCyclic( final boolean cyclic );\n+        boolean isCut();\n+        void setCut( final boolean cut );\n+        boolean isCanonical();\n+        ContigImpl canonical();\n+    }\n+\n+    /** Simple implementation of Contig interface. **/\n+    public static final class ContigImpl implements Contig {\n+        private final int id;\n+        private final CharSequence sequence;\n+        private final int maxObservations;\n+        private final KmerAdjacency firstKmer;\n+        private final KmerAdjacency lastKmer;\n+        private final List<Contig> predecessors;\n+        private final List<Contig> successors;\n+        private int componentId;\n+        private boolean cyclic;\n+        private boolean cut;\n+        private final Contig rc;\n+\n+        public ContigImpl( final int id, final KmerAdjacency firstKmerAdjacency ) {\n+            this.id = id;\n+            final StringBuilder sb = new StringBuilder(firstKmerAdjacency.toString());\n+            int maxObservations = firstKmerAdjacency.getNObservations();\n+            KmerAdjacency lastKmerAdjacency = firstKmerAdjacency;\n+            for ( KmerAdjacency kmerAdjacency = firstKmerAdjacency.getSoleSuccessor();\n+                  kmerAdjacency != null;\n+                  kmerAdjacency = kmerAdjacency.getSoleSuccessor() ) {\n+                // if we've gone around a circle, or if we're branching backwards, or if we hit a palindrome u-turn\n+                if ( firstKmerAdjacency == kmerAdjacency ||\n+                        kmerAdjacency.getPredecessorCount() != 1 ||\n+                        kmerAdjacency == lastKmerAdjacency.rc() ) {\n+                    break;\n+                }\n+                sb.append(\"ACGT\".charAt(kmerAdjacency.getFinalCall()));\n+                maxObservations = Math.max(maxObservations, kmerAdjacency.getNObservations());\n+                lastKmerAdjacency = kmerAdjacency;\n+            }\n+            this.sequence = sb.toString();\n+            this.maxObservations = maxObservations;\n+            this.firstKmer = firstKmerAdjacency;\n+            this.lastKmer = lastKmerAdjacency;\n+            this.predecessors = new ArrayList<>(firstKmer.getPredecessorCount());\n+            this.successors = new ArrayList<>(lastKmer.getSuccessorCount());\n+            this.rc = new ContigRCImpl(this);\n+\n+            int offset = 0;\n+            for ( KmerAdjacency kmerAdjacency = firstKmerAdjacency;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e2201c1ef4f8ba71f17e169f07756cfe2f1ecb49"}, "originalPosition": 1746}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxMjc1OTk3NQ==", "bodyText": "This didn't particularly bother me on OO principles:  KmerAdjacency isn't immutable, but each is associated with exactly one positiion on one contig.  We don't know which until we build the graph from the kmers.  Setting this back-pointer doesn't alter the KmerAdjacency object's identify (which is its kVal).\nBut I've separated it out, as suggested.", "url": "https://github.com/broadinstitute/gatk/pull/6989#discussion_r612759975", "createdAt": "2021-04-13T20:37:56Z", "author": {"login": "tedsharpe"}, "path": "src/main/java/org/broadinstitute/hellbender/tools/LocalAssembler.java", "diffHunk": "@@ -0,0 +1,2306 @@\n+package org.broadinstitute.hellbender.tools;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import htsjdk.samtools.Cigar;\n+import htsjdk.samtools.CigarElement;\n+import htsjdk.samtools.CigarOperator;\n+import htsjdk.samtools.SAMUtils;\n+import org.broadinstitute.barclay.argparser.Argument;\n+import org.broadinstitute.barclay.argparser.BetaFeature;\n+import org.broadinstitute.barclay.argparser.CommandLineProgramProperties;\n+import org.broadinstitute.barclay.help.DocumentedFeature;\n+import org.broadinstitute.hellbender.cmdline.StandardArgumentDefinitions;\n+import org.broadinstitute.hellbender.cmdline.programgroups.CoverageAnalysisProgramGroup;\n+import org.broadinstitute.hellbender.exceptions.GATKException;\n+import org.broadinstitute.hellbender.tools.walkers.PairWalker;\n+import org.broadinstitute.hellbender.utils.SimpleInterval;\n+import org.broadinstitute.hellbender.utils.collections.HopscotchSet;\n+import org.broadinstitute.hellbender.utils.gcs.BucketUtils;\n+import org.broadinstitute.hellbender.utils.read.GATKRead;\n+\n+import java.io.BufferedWriter;\n+import java.io.FileWriter;\n+import java.io.IOException;\n+import java.io.OutputStreamWriter;\n+import java.util.*;\n+import java.util.zip.GZIPOutputStream;\n+\n+@DocumentedFeature\n+@CommandLineProgramProperties(\n+        summary = \"experiment\",\n+        oneLineSummary = \"experiment\",\n+        usageExample = \"gatk LocalAssembler\",\n+        programGroup = CoverageAnalysisProgramGroup.class\n+)\n+@BetaFeature\n+public class LocalAssembler extends PairWalker {\n+    public static final byte QMIN = 25;\n+    public static final int MIN_THIN_OBS = 4;\n+    public static final int MIN_GAPFILL_COUNT = 3;\n+    public static final int TOO_MANY_TRAVERSALS = 100000;\n+    public static final int TOO_MANY_SCAFFOLDS = 50000;\n+    public static final int MIN_SV_SIZE = 50;\n+\n+    @Argument(fullName=StandardArgumentDefinitions.OUTPUT_LONG_NAME,\n+            shortName=StandardArgumentDefinitions.OUTPUT_SHORT_NAME,\n+            doc=\"Write outputs to this file name prefix\", optional = true)\n+    public static String output;\n+\n+    @Argument(fullName=\"assembly-name\", doc=\"name of assembly used as a prefix for traversal names\")\n+    public static String assemblyName;\n+\n+    private final List<GATKRead> reads = new ArrayList<>();\n+\n+    @Override public boolean requiresIntervals() { return true; }\n+\n+    @Override public void apply( final GATKRead read, final GATKRead mate ) {\n+        trimOverruns(read, mate);\n+        reads.add(read);\n+        reads.add(mate);\n+    }\n+\n+    @Override public void applyUnpaired( final GATKRead read ) {\n+        reads.add(read);\n+    }\n+\n+    @Override public Object onTraversalSuccess() {\n+        super.onTraversalSuccess(); // flush any incomplete pairs\n+\n+        final int regionSize = getTraversalIntervals().stream().mapToInt(SimpleInterval::size).sum();\n+        final KmerSet<KmerAdjacency> kmerAdjacencySet = new KmerSet<>(10 * regionSize);\n+        kmerizeReads(reads, kmerAdjacencySet);\n+        List<ContigImpl> contigs = buildContigs(kmerAdjacencySet);\n+        connectContigs(contigs);\n+\n+        removeThinContigs(contigs, kmerAdjacencySet);\n+        weldPipes(contigs);\n+        markComponents(contigs);\n+\n+        if ( fillGaps(kmerAdjacencySet, reads) ) {\n+            contigs = buildContigs(kmerAdjacencySet);\n+            connectContigs(contigs);\n+            removeThinContigs(contigs, kmerAdjacencySet);\n+            weldPipes(contigs);\n+            markComponents(contigs);\n+        }\n+\n+        markCycles(contigs);\n+\n+        final String outputFilePrefix = output != null ? output : assemblyName;\n+        final List<Path> readPaths = pathReads(kmerAdjacencySet, reads);\n+        final Map<Contig,List<TransitPairCount>> contigTransitsMap =\n+                collectTransitPairCounts(contigs, readPaths);\n+        final String traversalsFilename = outputFilePrefix + \".traversals.fa.gz\";\n+        try {\n+            final List<Traversal> allTraversals =\n+                    new ArrayList<>(traverseAllPaths(contigs, readPaths, contigTransitsMap));\n+            writeTraversals(allTraversals, traversalsFilename);\n+            try {\n+                final String scaffoldsFileName = outputFilePrefix + \".scaffolds.fa.gz\";\n+                writeTraversals(createScaffolds(allTraversals), scaffoldsFileName);\n+            } catch ( final AssemblyTooComplexException x ) {\n+                logger.warn(\"Assembly too complex for scaffolding.\");\n+            }\n+        } catch ( final AssemblyTooComplexException x ) {\n+            logger.warn(\"Assembly too complex.  Writing contigs as traversals in \" +\n+                    traversalsFilename + \".\");\n+            final Collection<Traversal> contigTraversals = new ArrayList<>(contigs.size());\n+            for ( final Contig contig : contigs ) {\n+                contigTraversals.add(new Traversal(Collections.singletonList(contig)));\n+            }\n+            writeTraversals(contigTraversals, traversalsFilename);\n+        }\n+\n+        contigs.sort(Comparator.comparingInt(ContigImpl::getId));\n+        writeDOT(contigs, outputFilePrefix + \".assembly.dot\");\n+        writeContigs(contigs, outputFilePrefix + \".contigs.txt.gz\");\n+        writePaths(readPaths, outputFilePrefix + \".paths.txt.gz\");\n+        writeReads(reads, outputFilePrefix + \".reads.fastq.gz\");\n+        return null;\n+    }\n+\n+    /** trim read pairs of base calls that have gone past the end of a short fragment */\n+    private void trimOverruns( final GATKRead read, final GATKRead mate ) {\n+        // if both mapped and they're on different strands\n+        if ( !read.isUnmapped() && !mate.isUnmapped() &&\n+                read.isReverseStrand() != mate.isReverseStrand() ) {\n+            // and both start within 1 base on the ref\n+            if ( Math.abs(read.getStart() - read.getMateStart()) <= 1 ) {\n+                // and both end within 1 base\n+                final int readRefLen = read.getCigar().getReferenceLength();\n+                final int mateRefLen = mate.getCigar().getReferenceLength();\n+                if ( Math.abs(readRefLen - mateRefLen) <= 1 ) {\n+                    if ( mate.isReverseStrand() ) {\n+                        trimClips(read, mate);\n+                    } else {\n+                        trimClips(mate, read);\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    private void trimClips( final GATKRead fwd, final GATKRead rev ) {\n+        final List<CigarElement> fwdElements = fwd.getCigarElements();\n+        final List<CigarElement> revElements = rev.getCigarElements();\n+        final int lastElementIdx = fwdElements.size() - 1;\n+        final CigarElement fwdLastElement = fwdElements.get(lastElementIdx);\n+        final CigarElement revFirstElement = revElements.get(0);\n+        if ( fwdLastElement.getOperator() == CigarOperator.S &&\n+                revFirstElement.getOperator() == CigarOperator.S ) {\n+            final byte[] fwdBases = fwd.getBasesNoCopy();\n+            final int lastElementLen = fwdLastElement.getLength();\n+            fwd.setBases(Arrays.copyOfRange(fwdBases, 0, fwdBases.length - lastElementLen));\n+            final byte[] fwdQuals = fwd.getBaseQualitiesNoCopy();\n+            if ( fwdQuals.length > 0 ) {\n+                final int qualsLen = fwdQuals.length - lastElementLen;\n+                fwd.setBaseQualities(Arrays.copyOfRange(fwdQuals, 0, qualsLen));\n+            }\n+            final List<CigarElement> newFwdElements = new ArrayList<>(fwdElements);\n+            newFwdElements.set(lastElementIdx, new CigarElement(lastElementLen, CigarOperator.H));\n+            fwd.setCigar(new Cigar(newFwdElements));\n+\n+            final byte[] revBases = rev.getBasesNoCopy();\n+            final int firstElementLen = revFirstElement.getLength();\n+            rev.setBases(Arrays.copyOfRange(revBases, firstElementLen, revBases.length));\n+            final byte[] revQuals = rev.getBaseQualitiesNoCopy();\n+            if ( revQuals.length > 0 ) {\n+                rev.setBaseQualities(Arrays.copyOfRange(revQuals, firstElementLen, revQuals.length));\n+            }\n+            final List<CigarElement> newRevElements = new ArrayList<>(revElements);\n+            newRevElements.set(0, new CigarElement(firstElementLen, CigarOperator.H));\n+            rev.setCigar(new Cigar(newRevElements));\n+        }\n+    }\n+\n+    @VisibleForTesting\n+    static void kmerizeReads( final List<GATKRead> reads,\n+                              final KmerSet<KmerAdjacency> kmerAdjacencySet ) {\n+        for ( final GATKRead read : reads ) {\n+            final byte[] calls = read.getBasesNoCopy();\n+            final byte[] quals = read.getBaseQualitiesNoCopy();\n+            KmerAdjacency.kmerize(calls, quals, QMIN, kmerAdjacencySet);\n+        }\n+    }\n+\n+    /** gather unbranched strings of kmers into contigs **/\n+    @VisibleForTesting\n+    static List<ContigImpl> buildContigs( final KmerSet<KmerAdjacency> kmerAdjacencySet ) {\n+        // gather strings of kmers that have a single predecessor and single successor into contigs\n+        final List<ContigImpl> contigs = new ArrayList<>();\n+        int nContigs = 0;\n+        for ( final KmerAdjacency kmerAdjacency : kmerAdjacencySet ) {\n+            if ( kmerAdjacency.getContig() == null ) {\n+                ContigImpl contig = null;\n+                final KmerAdjacency predecessor = kmerAdjacency.getSolePredecessor();\n+                if ( predecessor == null ||\n+                        predecessor.getSuccessorCount() > 1 ||\n+                        predecessor == kmerAdjacency.rc() ) {\n+                    contig = new ContigImpl(++nContigs, kmerAdjacency);\n+                } else {\n+                    final KmerAdjacency successor = kmerAdjacency.getSoleSuccessor();\n+                    if ( successor == null ||\n+                            successor.getPredecessorCount() > 1 ||\n+                            successor == kmerAdjacency.rc() ) {\n+                        contig = new ContigImpl(++nContigs, kmerAdjacency.rc());\n+                    }\n+                }\n+                if ( contig != null ) {\n+                    contigs.add(contig);\n+                }\n+            }\n+        }\n+\n+        // if there are smooth circles like a plasmid, gather them together as a contig, too\n+        for ( final KmerAdjacency kmerAdjacency : kmerAdjacencySet ) {\n+            if ( kmerAdjacency.getContig() == null ) {\n+                contigs.add(new ContigImpl(++nContigs, kmerAdjacency));\n+            }\n+        }\n+\n+        return contigs;\n+    }\n+\n+    /** connect contigs when the final kmer of one contig is adjacent to the inital contig of another **/\n+    @VisibleForTesting\n+    static void connectContigs( final List<ContigImpl> contigs ) {\n+        final int nContigs = contigs.size();\n+        final KmerSet<ContigEndKmer> contigEnds = new KmerSet<>(2*nContigs);\n+        for ( int contigId = 0; contigId != nContigs; ++contigId ) {\n+            final ContigImpl contig = contigs.get(contigId);\n+            final KmerAdjacency fwdKmer = contig.getFirstKmer();\n+            final KmerAdjacency revKmer = contig.getLastKmer().rc();\n+            if ( fwdKmer == revKmer ) {\n+                contigEnds.add(new ContigEndKmer(fwdKmer.getKVal(), contig, ContigOrientation.BOTH));\n+            } else {\n+                contigEnds.add(new ContigEndKmer(fwdKmer.getKVal(), contig, ContigOrientation.FWD));\n+                contigEnds.add(new ContigEndKmer(revKmer.getKVal(), contig, ContigOrientation.REV));\n+            }\n+        }\n+\n+        for ( int contigId = 0; contigId != nContigs; ++contigId ) {\n+            final Contig contig = contigs.get(contigId);\n+\n+            final KmerAdjacency start = contig.getFirstKmer();\n+            final int predecessorCount = start.getPredecessorCount();\n+            if ( predecessorCount > 0 ) {\n+                final List<Contig> predecessors = contig.getPredecessors();\n+                final int mask = start.getPredecessorMask();\n+                for ( int call = 0; call != 4; ++call ) {\n+                    if ( (mask & (1 << call)) != 0 ) {\n+                        final long kVal =\n+                                KmerAdjacency.reverseComplement(start.getPredecessorVal(call));\n+                        final ContigEndKmer contigEndKmer = contigEnds.find(new Kmer(kVal));\n+                        if ( contigEndKmer == null ) {\n+                            throw new GATKException(\"missing contig end kmer\");\n+                        }\n+                        switch ( contigEndKmer.getContigOrientation() ) {\n+                            case FWD:\n+                                predecessors.add(contigEndKmer.getContig().rc());\n+                                break;\n+                            case REV:\n+                                predecessors.add(contigEndKmer.getContig());\n+                                break;\n+                            case BOTH:\n+                                predecessors.add(contigEndKmer.getContig());\n+                                predecessors.add(contigEndKmer.getContig().rc());\n+                                break;\n+                        }\n+                    }\n+                }\n+            }\n+\n+            final KmerAdjacency end = contig.getLastKmer();\n+            final int successorCount = end.getSuccessorCount();\n+            if ( successorCount > 0 ) {\n+                final List<Contig> successors = contig.getSuccessors();\n+                final int mask = end.getSuccessorMask();\n+                for ( int call = 0; call != 4; ++call ) {\n+                    if ( (mask & (1 << call)) != 0 ) {\n+                        final long kVal = end.getSuccessorVal(call);\n+                        final ContigEndKmer contigEndKmer = contigEnds.find(new Kmer(kVal));\n+                        if ( contigEndKmer == null ) {\n+                            throw new GATKException(\"missing contig end kmer\");\n+                        }\n+                        switch ( contigEndKmer.getContigOrientation() ) {\n+                            case FWD:\n+                                successors.add(contigEndKmer.getContig());\n+                                break;\n+                            case REV:\n+                                successors.add(contigEndKmer.getContig().rc());\n+                                break;\n+                            case BOTH:\n+                                successors.add(contigEndKmer.getContig());\n+                                successors.add(contigEndKmer.getContig().rc());\n+                                break;\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    /** remove contigs that have little evidence **/\n+    @VisibleForTesting\n+    static void removeThinContigs( final List<ContigImpl> contigs,\n+                                           final KmerSet<KmerAdjacency> kmerAdjacencySet ) {\n+        contigs.sort(Comparator.comparingInt(ContigImpl::getMaxObservations));\n+        boolean contigRemoved;\n+        do {\n+            // figure out which contigs are cut points\n+            // i.e., those contigs which, if removed, would result in a graph with more connected components\n+            final int nContigs = contigs.size();\n+            final Map<Contig, CutData> cutDataMap = new HashMap<>(nContigs * 3);\n+\n+            for ( final ContigImpl contig : contigs ) {\n+                if ( cutDataMap.containsKey(contig) ) {\n+                    continue;\n+                }\n+\n+                cutDataMap.put(contig, new CutData());\n+                int children = 0;\n+                for ( final Contig nextContig : contig.getSuccessors() ) {\n+                    if ( !cutDataMap.containsKey(nextContig) ) {\n+                        findCuts(nextContig, contig, cutDataMap);\n+                        children += 1;\n+                    }\n+                }\n+                for ( final Contig nextContig : contig.getPredecessors() ) {\n+                    if ( !cutDataMap.containsKey(nextContig) ) {\n+                        findCuts(nextContig, contig, cutDataMap);\n+                        children += 1;\n+                    }\n+                }\n+                if ( children >= 2 ) {\n+                    contig.setCut(true);\n+                }\n+            }\n+\n+            // remove poorly attested (low max observations) contigs, unless they are cut points\n+            contigRemoved = false;\n+            final Iterator<ContigImpl> itr = contigs.iterator();\n+            while ( itr.hasNext() ) {\n+                final Contig contig = itr.next();\n+                if ( contig.getMaxObservations() < MIN_THIN_OBS && !contig.isCut() ) {\n+                    unlinkContig(contig, kmerAdjacencySet);\n+                    itr.remove();\n+                    contigRemoved = true;\n+                    break;\n+                }\n+            }\n+        } while ( contigRemoved );\n+        contigs.sort(Comparator.comparingInt(ContigImpl::getId));\n+    }\n+\n+    private static CutData findCuts( final Contig contig,\n+                                     final Contig parent,\n+                                     final Map<Contig, CutData> cutDataMap ) {\n+        final CutData cutData = new CutData();\n+        cutDataMap.put(contig, cutData);\n+        for ( final Contig nextContig : contig.getSuccessors() ) {\n+            if ( nextContig == parent ) {\n+                continue;\n+            }\n+            CutData nextCutData = cutDataMap.get(nextContig);\n+            if ( nextCutData != null ) {\n+                cutData.minVisitNum = Math.min(cutData.minVisitNum, nextCutData.visitNum);\n+            } else {\n+                nextCutData = findCuts(nextContig, contig, cutDataMap);\n+                cutData.minVisitNum = Math.min(cutData.minVisitNum, nextCutData.minVisitNum);\n+                if ( nextCutData.minVisitNum >= cutData.visitNum ) {\n+                    contig.setCut(true);\n+                }\n+            }\n+        }\n+        for ( final Contig nextContig : contig.getPredecessors() ) {\n+            if ( nextContig == parent ) {\n+                continue;\n+            }\n+            CutData nextCutData = cutDataMap.get(nextContig);\n+            if ( nextCutData != null ) {\n+                cutData.minVisitNum = Math.min(cutData.minVisitNum, nextCutData.visitNum);\n+            } else {\n+                nextCutData = findCuts(nextContig, contig, cutDataMap);\n+                cutData.minVisitNum = Math.min(cutData.minVisitNum, nextCutData.minVisitNum);\n+                if ( nextCutData.minVisitNum >= cutData.visitNum ) {\n+                    contig.setCut(true);\n+                }\n+            }\n+        }\n+        return cutData;\n+    }\n+\n+    @VisibleForTesting\n+    static void unlinkContig( final Contig contig,\n+                                      final KmerSet<KmerAdjacency> kmerAdjacencySet ) {\n+        final KmerAdjacency firstKmer = contig.getFirstKmer();\n+        final int firstKmerFinalCall = firstKmer.getFinalCall();\n+        for ( final Contig predecessor : contig.getPredecessors() ) {\n+            if ( predecessor != contig && predecessor != contig.rc() ) {\n+                predecessor.getLastKmer().removeSuccessor(firstKmerFinalCall, kmerAdjacencySet);\n+                if ( !predecessor.getSuccessors().remove(contig) ) {\n+                    throw new GATKException(\"failed to find predecessor link\");\n+                }\n+            }\n+        }\n+\n+        final KmerAdjacency lastKmer = contig.getLastKmer();\n+        final int lastKmerInitialCall = lastKmer.getInitialCall();\n+        for ( final Contig successor : contig.getSuccessors() ) {\n+            if ( successor != contig && successor != contig.rc() ) {\n+                successor.getFirstKmer().removePredecessor(lastKmerInitialCall, kmerAdjacencySet);\n+                if ( !successor.getPredecessors().remove(contig) ) {\n+                    throw new GATKException(\"failed to find successor link\");\n+                }\n+            }\n+        }\n+\n+        KmerAdjacency nextKmer = firstKmer;\n+        KmerAdjacency kmer;\n+        do {\n+            kmer = nextKmer;\n+            nextKmer = kmer.getSoleSuccessor();\n+            kmerAdjacencySet.remove(kmer.canonical());\n+        } while ( kmer != lastKmer );\n+    }\n+\n+    private static void updateKmerContig( final KmerAdjacency firstKmer,\n+                                          final KmerAdjacency lastKmer,\n+                                          final Contig contig ) {\n+        int offset = 0;\n+        for ( KmerAdjacency kmer = firstKmer; kmer != lastKmer; kmer = kmer.getSoleSuccessor() ) {\n+            if ( kmer == null ) {\n+                throw new GATKException(\"contig does not have a flat pipeline of kmers\");\n+            }\n+            kmer.clearContig();\n+            kmer.setContigOffset(contig, offset++);\n+        }\n+        lastKmer.clearContig();\n+        lastKmer.setContigOffset(contig, offset);\n+        if ( offset + Kmer.KSIZE != contig.size() ) {\n+            throw new GATKException(\"kmer chain length does not equal contig size\");\n+        }\n+    }\n+\n+    /** replace adjacent contigs without branches with a single, larger contig **/\n+    @VisibleForTesting\n+    static void weldPipes( final List<ContigImpl> contigs ) {\n+        for ( int contigIdx = 0; contigIdx != contigs.size(); ++contigIdx ) {\n+            final ContigImpl contig = contigs.get(contigIdx);\n+            if ( contig.getSuccessors().size() == 1 ) {\n+                final Contig successor = contig.getSuccessors().get(0);\n+                if ( successor != contig && successor != contig.rc() &&\n+                        successor.getPredecessors().size() == 1 ) {\n+                    contigs.set(contigIdx, join(contig.getId(), contig, successor));\n+                    if ( !contigs.remove(successor.canonical()) ) {\n+                        throw new GATKException(\"successor linkage is messed up\");\n+                    }\n+                    contigIdx -= 1; // reconsider the new contig -- there might be more joining possible\n+                    continue;\n+                }\n+            }\n+            if ( contig.getPredecessors().size() == 1 ) {\n+                final Contig predecessor = contig.getPredecessors().get(0);\n+                if ( predecessor != contig && predecessor != contig.rc() &&\n+                        predecessor.getSuccessors().size() == 1 ) {\n+                    contigs.set(contigIdx, join(contig.getId(), predecessor, contig));\n+                    if ( !contigs.remove(predecessor.canonical()) ) {\n+                        throw new GATKException(\"predecessor linkage is messed up\");\n+                    }\n+                    contigIdx -= 1; // reconsider\n+                }\n+            }\n+        }\n+    }\n+\n+    private static ContigImpl join( final int id, final Contig predecessor, final Contig successor ) {\n+        if ( !checkOverlap(predecessor.getSequence(), successor.getSequence()) ) {\n+                throw new GATKException(\"sequences can't be joined\");\n+        }\n+        final ContigImpl joinedContig = new ContigImpl(id, predecessor, successor);\n+        updateKmerContig(joinedContig.getFirstKmer(), joinedContig.getLastKmer(), joinedContig);\n+        return joinedContig;\n+    }\n+\n+    private static boolean checkOverlap( final CharSequence seq1, final CharSequence seq2 ) {\n+        final int seq1Len = seq1.length();\n+        final CharSequence seq1SubSeq = seq1.subSequence(seq1Len - Kmer.KSIZE + 1, seq1Len);\n+        final CharSequence seq2SubSeq = seq2.subSequence(0, Kmer.KSIZE - 1);\n+        return seq1SubSeq.equals(seq2SubSeq);\n+    }\n+\n+    /** set a unique componentId for every connected group of contigs **/\n+    @VisibleForTesting\n+    static int markComponents( final List<ContigImpl> contigs ) {\n+        for ( final ContigImpl contig : contigs ) {\n+            contig.setComponentId(0);\n+        }\n+\n+        int componentId = 0;\n+        for ( final ContigImpl contig : contigs ) {\n+            if ( contig.getComponentId() == 0 ) {\n+                contig.setComponentId(++componentId);\n+                markSuccessorComponents(contig);\n+                markSuccessorComponents(contig.rc());\n+            }\n+        }\n+        return componentId;\n+    }\n+\n+    private static void markSuccessorComponents( final Contig contig ) {\n+        final int componentId = contig.getComponentId();\n+        for ( final Contig successor : contig.getSuccessors() ) {\n+            if ( successor.getComponentId() == 0 ) {\n+                successor.canonical().setComponentId(componentId);\n+                markSuccessorComponents(successor);\n+                markSuccessorComponents(successor.rc());\n+            }\n+        }\n+    }\n+\n+    @VisibleForTesting\n+    static void markCycles( final List<ContigImpl> contigs ) {\n+        for ( final Contig contig : contigs ) {\n+            contig.setCyclic(false);\n+        }\n+\n+        final int nContigs = contigs.size();\n+        final Deque<Contig> deque = new ArrayDeque<>(nContigs);\n+        final Map<Contig, CutData> cutDataMap = new HashMap<>(nContigs * 3);\n+        for ( final Contig contig : contigs ) {\n+            if ( !cutDataMap.containsKey(contig) ) {\n+                markCyclesRecursion(contig, deque, cutDataMap);\n+            }\n+        }\n+    }\n+\n+    private static CutData markCyclesRecursion( final Contig contig,\n+                                                final Deque<Contig> deque,\n+                                                final Map<Contig, CutData> cutDataMap ) {\n+        final CutData cutData = new CutData();\n+        cutDataMap.put(contig, cutData);\n+        deque.addFirst(contig);\n+\n+        for ( final Contig successor : contig.getSuccessors() ) {\n+            final CutData successorCutData = cutDataMap.get(successor);\n+            if ( successorCutData == null ) {\n+                final int recursionVisitNum =\n+                        markCyclesRecursion(successor, deque, cutDataMap).minVisitNum;\n+                cutData.minVisitNum = Math.min(cutData.minVisitNum, recursionVisitNum);\n+            } else {\n+                cutData.minVisitNum = Math.min(cutData.minVisitNum, successorCutData.visitNum);\n+            }\n+        }\n+\n+        if ( cutData.visitNum == cutData.minVisitNum ) {\n+            Contig tig = deque.removeFirst();\n+            if ( tig == contig ) {\n+                cutDataMap.get(tig).visitNum = Integer.MAX_VALUE;\n+\n+                // single-vertex component -- cyclic only if self-referential\n+                if ( tig.getSuccessors().contains(tig) ) {\n+                    tig.setCyclic(true);\n+                }\n+            } else {\n+                while ( true ) {\n+                    // kill cross-links\n+                    cutDataMap.get(tig).visitNum = Integer.MAX_VALUE;\n+                    tig.setCyclic(true);\n+                    if ( tig == contig ) break;\n+                    tig = deque.removeFirst();\n+                }\n+            }\n+        }\n+        return cutData;\n+    }\n+\n+    @VisibleForTesting\n+    static boolean fillGaps( final KmerSet<KmerAdjacency> kmerAdjacencySet,\n+                             final List<GATKRead> reads ) {\n+        final Map<String, Integer> gapFillCounts = new HashMap<>();\n+        for ( final GATKRead read : reads ) {\n+            final Path path = new Path(read.getBasesNoCopy(), kmerAdjacencySet);\n+            final List<PathPart> parts = path.getParts();\n+            final int lastIdx = parts.size() - 1;\n+            for ( int idx = 1; idx < lastIdx; ++idx ) {\n+                final PathPart pathPart = parts.get(idx);\n+                if ( pathPart.isGap() ) {\n+                    final char prevCall = parts.get(idx - 1).getLastCall();\n+                    final char nextCall = parts.get(idx + 1).getFirstCall();\n+                    String gapFill = prevCall + pathPart.getSequence().toString() + nextCall;\n+                    final SequenceRC gapFillRC = new SequenceRC(gapFill);\n+                    if ( gapFillRC.compareTo(gapFill) < 0 ) {\n+                        gapFill = gapFillRC.toString();\n+                    }\n+                    gapFillCounts.merge(gapFill, 1, Integer::sum);\n+                }\n+            }\n+        }\n+\n+        boolean newKmers = false;\n+        for ( final Map.Entry<String, Integer> entry : gapFillCounts.entrySet() ) {\n+            final int nObservations = entry.getValue();\n+            if ( nObservations >= MIN_GAPFILL_COUNT ) {\n+                KmerAdjacency.kmerize(entry.getKey(), nObservations, kmerAdjacencySet);\n+                newKmers = true;\n+            }\n+        }\n+\n+        if ( newKmers ) {\n+            for ( final KmerAdjacency kmerAdjacency : kmerAdjacencySet ) {\n+                kmerAdjacency.clearContig();\n+            }\n+        }\n+        return newKmers;\n+    }\n+\n+    @VisibleForTesting\n+    static List<Path> pathReads( final KmerSet<KmerAdjacency> kmerAdjacencySet,\n+                          final List<GATKRead> reads ) {\n+        final List<Path> readPaths = new ArrayList<>(reads.size());\n+        for ( final GATKRead read : reads ) {\n+            readPaths.add(new Path(read.getBasesNoCopy(), kmerAdjacencySet));\n+        }\n+        return readPaths;\n+    }\n+\n+    @VisibleForTesting\n+    static Map<Contig,List<TransitPairCount>> collectTransitPairCounts(\n+            final List<ContigImpl> contigs,\n+            final List<Path> readPaths ) {\n+        final Map<Contig,List<TransitPairCount>> contigTransitsMap =\n+                new HashMap<>(3 * contigs.size());\n+        for ( final Path path : readPaths ) {\n+            final List<PathPart> parts = path.getParts();\n+            final int lastPart = parts.size() - 1;\n+            for ( int partIdx = 1; partIdx < lastPart; ++partIdx ) {\n+                final Contig prevContig = parts.get(partIdx - 1).getContig();\n+                if ( prevContig == null ) continue;\n+                final Contig curContig = parts.get(partIdx).getContig();\n+                if ( curContig == null ) {\n+                    partIdx += 1;\n+                    continue;\n+                }\n+                final Contig nextContig = parts.get(partIdx + 1).getContig();\n+                if ( nextContig == null ) {\n+                    partIdx += 2;\n+                    continue;\n+                }\n+                final TransitPairCount tpc = new TransitPairCount(prevContig, nextContig);\n+                final List<TransitPairCount> tpcList =\n+                        contigTransitsMap.computeIfAbsent(curContig, tig -> new ArrayList<>(4));\n+                final int idx = tpcList.indexOf(tpc);\n+                if ( idx != -1 ) {\n+                    tpcList.get(idx).observe();\n+                } else {\n+                    tpcList.add(tpc);\n+                    contigTransitsMap.computeIfAbsent(curContig.rc(), tig -> new ArrayList<>(4))\n+                            .add(tpc.getRC());\n+                }\n+            }\n+        }\n+        return contigTransitsMap;\n+    }\n+\n+    @VisibleForTesting\n+    static Set<Traversal> traverseAllPaths(\n+            final List<ContigImpl> contigs,\n+            final List<Path> readPaths,\n+            final Map<Contig, List<TransitPairCount>> contigTransitsMap ) {\n+        final Set<Traversal> traversalSet = new HashSet<>();\n+        final List<Contig> contigsList = new ArrayList<>();\n+        for ( final Contig contig : contigs ) {\n+            // untransited contigs are sources, sinks, or large contigs that can't be crossed by a read\n+            // build traversals from these\n+            if ( !contigTransitsMap.containsKey(contig) ) {\n+                boolean done = false;\n+                for ( final Contig successor : contig.getSuccessors() ) {\n+                    traverse(successor, contig,\n+                            contigsList, readPaths, contigTransitsMap, traversalSet);\n+                    done = true;\n+                }\n+                for ( final Contig predecessor : contig.getPredecessors() ) {\n+                    traverse(predecessor.rc(), contig.rc(),\n+                            contigsList, readPaths, contigTransitsMap, traversalSet);\n+                    done = true;\n+                }\n+                if ( !done ) { // if there were no predecessors or successors, it stands alone\n+                    addTraversal(new Traversal(Collections.singletonList(contig)), traversalSet);\n+                }\n+            }\n+        }\n+\n+        // look for transits that haven't been traced\n+        for ( final Map.Entry<Contig, List<TransitPairCount>> entry :\n+                contigTransitsMap.entrySet() ) {\n+            for ( final TransitPairCount tpc : entry.getValue() ) {\n+                if ( tpc.getCount() > 0 ) {\n+                    tpc.resetCount();\n+                    final Contig contig = entry.getKey();\n+                    final Set<Traversal> fwdTraversalSet = new HashSet<>();\n+                    traverse(tpc.getNextContig(), contig,\n+                            contigsList, readPaths, contigTransitsMap, fwdTraversalSet);\n+                    final Set<Traversal> revTraversalSet = new HashSet<>();\n+                    traverse(tpc.getPrevContig().rc(), contig.rc(),\n+                            contigsList, readPaths, contigTransitsMap, revTraversalSet);\n+                    for ( final Traversal revTraversal : revTraversalSet ) {\n+                        final Traversal revTraversalRC = revTraversal.rc();\n+                        for ( final Traversal fwdTraversal : fwdTraversalSet ) {\n+                            final int overlap =\n+                                    findMaxOverlap(revTraversalRC.getContigs(), fwdTraversal.getContigs());\n+                            final Traversal combo =\n+                                    Traversal.combineOverlappers(revTraversalRC, fwdTraversal, overlap);\n+                            addTraversal(combo, traversalSet);\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+\n+        return traversalSet;\n+    }\n+\n+    private static int findMaxOverlap( final List<Contig> prefixes, final List<Contig> suffixes ) {\n+        final int nPrefixes = prefixes.size();\n+        final Contig firstSuffix = suffixes.get(0);\n+        if ( !firstSuffix.isCyclic() ) {\n+            return prefixes.get(nPrefixes - 1) == firstSuffix ? 1 : 0;\n+        }\n+        final int nSuffixes = suffixes.size();\n+        for ( int prefixIdx = Math.max(0, nPrefixes - nSuffixes); prefixIdx != nPrefixes; ++prefixIdx ) {\n+            if ( prefixes.get(prefixIdx) == firstSuffix ) {\n+                int suffixIdx = 1;\n+                boolean match = true;\n+                for ( int prefixIdx2 = prefixIdx + 1; prefixIdx2 != nPrefixes; ++prefixIdx2 ) {\n+                    if ( prefixes.get(prefixIdx2) != suffixes.get(suffixIdx++) ) {\n+                        match = false;\n+                        break;\n+                    }\n+                }\n+                if ( match ) {\n+                    return nPrefixes - prefixIdx;\n+                }\n+            }\n+        }\n+        return 0;\n+    }\n+\n+    private static void traverse( final Contig contig,\n+                                  final Contig predecessor,\n+                                  final List<Contig> contigsList,\n+                                  final List<Path> readPaths,\n+                                  final Map<Contig, List<TransitPairCount>> contigTransitsMap,\n+                                  final Set<Traversal> traversalSet ) {\n+        contigsList.add(predecessor);\n+        if ( contig.isCyclic() ) {\n+            traverseCycle(contig, contigsList, readPaths, contigTransitsMap, traversalSet);\n+            contigsList.remove(contigsList.size() - 1);\n+            return;\n+        }\n+        final List<TransitPairCount> transits = contigTransitsMap.get(contig);\n+        boolean done = false;\n+        if ( transits != null ) {\n+            for ( final TransitPairCount tpc : transits ) {\n+                if ( tpc.getPrevContig() == predecessor ) {\n+                    final Contig successor = tpc.getNextContig();\n+                    if ( predecessor == contig.rc() ) {\n+                        final int nContigs = contigsList.size();\n+                        if ( nContigs > 1 ) {\n+                            if ( successor.rc() == contigsList.get(nContigs - 2) ) {\n+                                continue;\n+                            }\n+                        }\n+                    }\n+                    tpc.resetCount();\n+                    traverse(successor, contig, contigsList, readPaths, contigTransitsMap, traversalSet);\n+                    done = true;\n+                }\n+            }\n+        }\n+        if ( !done ) {\n+            contigsList.add(contig);\n+            addTraversal(new Traversal(contigsList), traversalSet);\n+            contigsList.remove(contigsList.size() - 1);\n+        }\n+        contigsList.remove(contigsList.size() - 1);\n+    }\n+\n+    private static void traverseCycle( final Contig contig,\n+                                       final List<Contig> contigsList,\n+                                       final List<Path> readPaths,\n+                                       final Map<Contig, List<TransitPairCount>> contigTransitsMap,\n+                                       final Set<Traversal> traversalSet ) {\n+        contigsList.add(contig);\n+        final int nContigs = contigsList.size();\n+        // the final element of the list is cyclic, if there's a previous element it will be\n+        // non-cyclic, so start there figuring out how far the read paths lead us\n+        final List<List<Contig>> longestPaths =\n+                findLongestPaths(contigsList.subList(Math.max(0, nContigs - 2), nContigs), readPaths);\n+        // didn't get anywhere -- just complete the traversal\n+        if ( longestPaths.isEmpty() ) {\n+            addTraversal(new Traversal(contigsList, true), traversalSet);\n+        } else {\n+            // for each unique extension into the cycle\n+            for ( final List<Contig> path : longestPaths ) {\n+                // don't think this can happen, but still\n+                if ( path.isEmpty() ) {\n+                    addTraversal(new Traversal(contigsList, true), traversalSet);\n+                    continue;\n+                }\n+                final List<Contig> extendedContigsList =\n+                        new ArrayList<>(contigsList.size() + path.size());\n+                extendedContigsList.addAll(contigsList);\n+                // if we didn't get out of the cycle\n+                if ( path.get(path.size() - 1).isCyclic() ) {\n+                    extendedContigsList.addAll(path);\n+                    addTraversal(new Traversal(extendedContigsList, true), traversalSet);\n+                } else {\n+                    // we found a cycle-exiting path, so extend that normally\n+                    for ( final Contig curContig : path ) {\n+                        if ( curContig.isCyclic() ) {\n+                            extendedContigsList.add(curContig);\n+                        } else {\n+                            final Contig prevContig =\n+                                    extendedContigsList.remove(extendedContigsList.size() - 1);\n+                            traverse(curContig, prevContig, extendedContigsList, readPaths,\n+                                    contigTransitsMap, traversalSet);\n+                            extendedContigsList.add(prevContig);\n+                            break;\n+                        }\n+                    }\n+                }\n+                clearTransitPairs(contigTransitsMap, extendedContigsList);\n+            }\n+        }\n+        contigsList.remove(contigsList.size() - 1);\n+    }\n+\n+    private static void clearTransitPairs(\n+            final Map<Contig, List<TransitPairCount>> contigTransitsMap,\n+            final List<Contig> contigsList ) {\n+        final int lastIdx = contigsList.size() - 1;\n+        for ( int idx = 1; idx < lastIdx; ++idx ) {\n+            final List<TransitPairCount> pairCounts = contigTransitsMap.get(contigsList.get(idx));\n+            if ( pairCounts != null ) {\n+                final Contig predecessor = contigsList.get(idx - 1);\n+                final Contig successor = contigsList.get(idx + 1);\n+                for ( final TransitPairCount tpc : pairCounts ) {\n+                    if ( tpc.getPrevContig() == predecessor && tpc.getNextContig() == successor ) {\n+                        tpc.resetCount();\n+                        break;\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    private static void addTraversal( final Traversal traversal,\n+                                      final Set<Traversal> traversalSet ) {\n+        if ( !traversalSet.contains(traversal.rc()) ) {\n+            traversalSet.add(traversal);\n+            if ( traversalSet.size() >= TOO_MANY_TRAVERSALS ) {\n+                throw new AssemblyTooComplexException();\n+            }\n+        }\n+    }\n+\n+    private static List<List<Contig>> findLongestPaths( final List<Contig> toMatch,\n+                                                        final List<Path> readPaths ) {\n+        final List<List<Contig>> results = new ArrayList<>();\n+        for ( final Path path : readPaths ) {\n+            testPath(path, toMatch, results);\n+            testPath(path.rc(), toMatch, results);\n+        }\n+        return results;\n+    }\n+\n+    private static void testPath( final Path path,\n+                                  final List<Contig> toMatch,\n+                                  final List<List<Contig>> results ) {\n+        final List<PathPart> pathParts = path.getParts();\n+        final int nPathParts = pathParts.size();\n+        final List<Contig> pathContigs = new ArrayList<>(nPathParts);\n+        pathParts.forEach(pp -> pathContigs.add(pp.getContig()));\n+        final int matchIdx = Collections.indexOfSubList(pathContigs, toMatch);\n+        if ( matchIdx != -1 ) {\n+            final int suffixIdx = matchIdx + toMatch.size();\n+            if ( suffixIdx < nPathParts ) {\n+                resolveResult(grabParts(pathContigs, suffixIdx), results);\n+            }\n+        }\n+    }\n+\n+    private static List<Contig> grabParts( final List<Contig> pathContigs, final int suffixIdx ) {\n+        final int nPathContigs = pathContigs.size();\n+        Contig prev = pathContigs.get(suffixIdx - 1);\n+        final List<Contig> result = new ArrayList<>(nPathContigs - suffixIdx);\n+        for ( int idx = suffixIdx; idx != nPathContigs; ++idx ) {\n+            final Contig tig = pathContigs.get(idx);\n+            if ( tig == null || !prev.getSuccessors().contains(tig) ) break;\n+            result.add(tig);\n+            prev = tig;\n+        }\n+        return result;\n+    }\n+\n+    private static void resolveResult( final List<Contig> result,\n+                                       final List<List<Contig>> results ) {\n+        final int nResults = results.size();\n+        for ( int idx = 0; idx != nResults; ++idx ) {\n+            final List<Contig> test = results.get(idx);\n+            if ( isPrefix(result, test) ) return;\n+            if ( isPrefix(test, result) ) {\n+                results.set(idx, result);\n+                return;\n+            }\n+        }\n+        results.add(result);\n+    }\n+\n+    private static boolean isPrefix( final List<Contig> list1, final List<Contig> list2 ) {\n+        final int list1Size = list1.size();\n+        final int list2Size = list2.size();\n+        if ( list1Size > list2Size ) return false;\n+        for ( int idx = 0; idx != list1Size; ++idx ) {\n+            if ( list1.get(idx) != list2.get(idx) ) return false;\n+        }\n+        return true;\n+    }\n+\n+    @VisibleForTesting\n+    static Collection<Traversal> createScaffolds( final List<Traversal> allTraversals ) {\n+        removeTriviallyDifferentTraversals(allTraversals);\n+\n+        final int nTraversals = allTraversals.size();\n+        final Map<Contig, List<Integer>> traversalsByFirstContig = new HashMap<>(3 * nTraversals);\n+        for ( int idx = 0; idx != nTraversals; ++idx ) {\n+            final Traversal traversal = allTraversals.get(idx);\n+            traversalsByFirstContig.compute(traversal.getFirstContig(),\n+                    ( k, v ) -> v == null ? new ArrayList<>(3) : v).add(idx);\n+            final Traversal rcTraversal = traversal.rc();\n+            traversalsByFirstContig.compute(rcTraversal.getFirstContig(),\n+                    ( k, v ) -> v == null ? new ArrayList<>(3) : v).add(~idx);\n+        }\n+\n+        final List<Traversal> scaffolds = new ArrayList<>(nTraversals);\n+        final boolean[] touched = new boolean[nTraversals];\n+        for ( int idx = 0; idx != nTraversals; ++idx ) {\n+            if ( !touched[idx] ) {\n+                expandTraversal(idx, touched, traversalsByFirstContig, allTraversals, scaffolds);\n+            }\n+        }\n+        return scaffolds;\n+    }\n+\n+    private static void expandTraversal( final int traversalIdx,\n+                                         final boolean[] touched,\n+                                         final Map<Contig, List<Integer>> traversalsByFirstContig,\n+                                         final List<Traversal> allTraversals,\n+                                         final List<Traversal> scaffolds ) {\n+        final Traversal traversal = allTraversals.get(traversalIdx);\n+        touched[traversalIdx] = true;\n+        final List<Traversal> downExtensions = new ArrayList<>();\n+        final Set<Contig> startingContigSet = new HashSet<>();\n+        walkTraversals(traversal, touched, startingContigSet, traversalsByFirstContig,\n+                        allTraversals, downExtensions);\n+        final List<Traversal> upExtensions = new ArrayList<>();\n+        walkTraversals(traversal.rc(), touched, startingContigSet, traversalsByFirstContig,\n+                        allTraversals, upExtensions);\n+        for ( final Traversal down : downExtensions ) {\n+            for ( final Traversal up : upExtensions ) {\n+                if ( scaffolds.size() >= TOO_MANY_SCAFFOLDS ) {\n+                    throw new AssemblyTooComplexException();\n+                }\n+                scaffolds.add(Traversal.combineOverlappers(up.rc(), down, traversal.getContigs().size()));\n+            }\n+        }\n+    }\n+\n+    private static void walkTraversals( final Traversal traversal,\n+                                        final boolean[] touched,\n+                                        final Set<Contig> startingContigSet,\n+                                        final Map<Contig, List<Integer>> traversalsByFirstContig,\n+                                        final List<Traversal> allTraversals,\n+                                        final List<Traversal> extensions ) {\n+        final Contig firstContig = traversal.getFirstContig();\n+        final List<Integer> indexList;\n+        if ( startingContigSet.contains(firstContig) ||\n+                traversal.isInextensible() ||\n+                (indexList = traversalsByFirstContig.get(traversal.getLastContig())) == null ) {\n+            extensions.add(traversal);\n+            return;\n+        }\n+        startingContigSet.add(firstContig);\n+        for ( int idx : indexList ) {\n+            final Traversal extension;\n+            if ( idx >= 0 ) {\n+                extension = allTraversals.get(idx);\n+                touched[idx] = true;\n+            } else {\n+                final int rcIdx = ~idx;\n+                extension = allTraversals.get(rcIdx).rc();\n+                touched[rcIdx] = true;\n+            }\n+            walkTraversals(Traversal.combine(traversal, extension), touched, startingContigSet,\n+                            traversalsByFirstContig, allTraversals, extensions );\n+        }\n+        startingContigSet.remove(firstContig);\n+    }\n+\n+    private static void removeTriviallyDifferentTraversals(\n+                                            final Collection<Traversal> allTraversals ) {\n+        if ( allTraversals.isEmpty() ) {\n+            return;\n+        }\n+        final TreeSet<Traversal> sortedTraversals = new TreeSet<>(new TraversalEndpointComparator());\n+        for ( final Traversal traversal : allTraversals ) {\n+            sortedTraversals.add(traversal);\n+            sortedTraversals.add(traversal.rc());\n+        }\n+        final Iterator<Traversal> traversalIterator = sortedTraversals.iterator();\n+        Traversal prevTraversal = traversalIterator.next();\n+        while ( traversalIterator.hasNext() ) {\n+            final Traversal curTraversal = traversalIterator.next();\n+            if ( isTriviallyDifferent(prevTraversal, curTraversal) ) {\n+                traversalIterator.remove();\n+            } else {\n+                prevTraversal = curTraversal;\n+            }\n+        }\n+        sortedTraversals.removeIf(Traversal::isRC);\n+        allTraversals.clear();\n+        allTraversals.addAll(sortedTraversals);\n+    }\n+\n+    private static boolean isTriviallyDifferent( final Traversal traversal1,\n+                                                 final Traversal traversal2 ) {\n+        final Contig firstContig1 = traversal1.getFirstContig();\n+        final Contig lastContig1 = traversal1.getLastContig();\n+        final Contig firstContig2 = traversal2.getFirstContig();\n+        final Contig lastContig2 = traversal2.getLastContig();\n+        if ( firstContig1 != firstContig2 || lastContig1 != lastContig2 ) {\n+            return false;\n+        }\n+        final int interiorSize1 = traversal1.getSequenceLength() - firstContig1.size() - lastContig1.size();\n+        final int interiorSize2 = traversal2.getSequenceLength() - firstContig2.size() - lastContig2.size();\n+\n+        // if the path lengths are so different that one could harbor an SV, they're not trivially different\n+        if ( Math.abs(interiorSize1 - interiorSize2) >= MIN_SV_SIZE ) {\n+            return false;\n+        }\n+\n+        // if the paths are small enough that there can't be an SV's worth of differences, they're trivially different\n+        final int maxInteriorSize = Math.max(interiorSize1, interiorSize2);\n+        if ( maxInteriorSize < MIN_SV_SIZE ) {\n+            return true;\n+        }\n+\n+        // dang, maybe there's enough material in common that there can't be an SV's worth of differences\n+        // run a longest common subsequence algorithm to figure out the length of the common material\n+        // DP matrix holds length of common material\n+        final List<Contig> contigs1 = traversal1.getContigs();\n+        final int rowLen = contigs1.size() - 1;\n+        final int[][] rowPair = new int[2][];\n+        rowPair[0] = new int[rowLen];\n+        rowPair[1] = new int[rowLen];\n+        int pairIdx = 0;\n+        final List<Contig> contigs2 = traversal2.getContigs();\n+        final int nRows = contigs2.size() - 1;\n+        for ( int idx2 = 1; idx2 != nRows; ++idx2 ) {\n+            final int[] curRow = rowPair[pairIdx];\n+            final int[] prevRow = rowPair[pairIdx ^ 1];\n+            pairIdx ^= 1;\n+\n+            final int id2 = contigs2.get(idx2).getId();\n+            for ( int idx1 = 1; idx1 != rowLen; ++idx1 ) {\n+                final Contig tig1 = contigs1.get(idx1);\n+                if ( tig1.getId() == id2 ) {\n+                    // if the previous cells also contain a match we've already removed the K-1 bases upstream\n+                    final boolean extendMatch =\n+                            contigs1.get(idx1 -1).getId() == contigs2.get(idx2 - 1).getId();\n+                    curRow[idx1] = prevRow[idx1 - 1] + (extendMatch ? tig1.getNKmers() : tig1.size());\n+                } else {\n+                    curRow[idx1] = Math.max(curRow[idx1 - 1], prevRow[idx1]);\n+                }\n+            }\n+        }\n+        final int commonLen = rowPair[pairIdx ^ 1][rowLen - 1];\n+        return (maxInteriorSize - commonLen) < MIN_SV_SIZE;\n+    }\n+\n+    private static class TraversalEndpointComparator implements Comparator<Traversal> {\n+        @Override\n+        public int compare( final Traversal traversal1, final Traversal traversal2 ) {\n+            int cmp = Integer.compare(traversal1.contigs.get(0).getId(),\n+                                      traversal2.contigs.get(0).getId());\n+            if ( cmp != 0 ) {\n+                return cmp;\n+            }\n+            final int last1 = traversal1.contigs.size() - 1;\n+            final int last2 = traversal2.contigs.size() - 1;\n+            cmp = Integer.compare(traversal1.contigs.get(last1).getId(),\n+                                  traversal2.contigs.get(last2).getId());\n+            if ( cmp != 0 ) {\n+                return cmp;\n+            }\n+            // among those starting and ending at the same place, sort least observed last\n+            return -Integer.compare(traversal1.getMinMaxObservations(), traversal2.getMinMaxObservations());\n+        }\n+    }\n+\n+    private static void writeDOT( final List<ContigImpl> contigs, final String fileName ) {\n+        try ( final BufferedWriter writer = new BufferedWriter(new FileWriter(fileName)) ) {\n+            writer.write(\"digraph {\\n\");\n+            for ( final Contig contig : contigs ) {\n+                final double width = contig.getSequence().length() / 100.;\n+                writer.write(contig + \" [width=\" + width + \"]\\n\");\n+                writer.write( contig.rc() + \" [width=\" + width + \"]\\n\");\n+            }\n+            for ( final Contig contig : contigs ) {\n+                for ( final Contig predecessor : contig.getPredecessors() ) {\n+                    final String predecessorName = predecessor.rc().toString();\n+                    writer.write(contig.rc() + \" -> \" + predecessorName + \"\\n\");\n+                }\n+                for ( final Contig successor : contig.getSuccessors() ) {\n+                    final String successorName = successor.toString();\n+                    writer.write(contig + \" -> \" + successorName + \"\\n\");\n+                }\n+            }\n+            writer.write(\"}\\n\");\n+        } catch ( final IOException ioe ) {\n+            throw new GATKException(\"Failed to write assembly DOT file.\", ioe);\n+        }\n+    }\n+\n+    private static BufferedWriter makeGZFile( final String fileName ) throws IOException {\n+        final GZIPOutputStream gzOS = new GZIPOutputStream(BucketUtils.createFile(fileName));\n+        return new BufferedWriter(new OutputStreamWriter(gzOS));\n+    }\n+\n+    private static void writeContigs( final List<ContigImpl> contigs, final String fileName ) {\n+        try ( final BufferedWriter writer = makeGZFile(fileName) ) {\n+            for ( final Contig contig : contigs ) {\n+                final List<Contig> predecessors = contig.getPredecessors();\n+                final String predecessorDescription;\n+                if ( predecessors.size() == 0 ) {\n+                    predecessorDescription = \"\\tnone\";\n+                } else {\n+                    final StringBuilder sb = new StringBuilder();\n+                    char prefix = '\\t';\n+                    for ( final Contig predecessor : predecessors ) {\n+                        sb.append(prefix);\n+                        prefix = ',';\n+                        sb.append(predecessor);\n+                    }\n+                    predecessorDescription = sb.toString();\n+                }\n+\n+                final List<Contig> successors = contig.getSuccessors();\n+                final String successorDescription;\n+                if ( successors.size() == 0 ) {\n+                    successorDescription = \"\\tnone\";\n+                } else {\n+                    final StringBuilder sb = new StringBuilder();\n+                    char prefix = '\\t';\n+                    for ( final Contig successor : successors ) {\n+                        sb.append(prefix);\n+                        prefix = ',';\n+                        sb.append(successor);\n+                    }\n+                    successorDescription = sb.toString();\n+                }\n+\n+                final String contigName = contig.toString();\n+                final String component =\n+                        (contig.isCyclic() ? \"(C)\\t\" : \"\\t\") + contig.getComponentId();\n+                writer.write(contigName + component + predecessorDescription +\n+                        successorDescription + \"\\t\" +\n+                        contig.getMaxObservations() + \"\\t\" +\n+                        contig.getFirstKmer().getNObservations() + \"\\t\" +\n+                        contig.getLastKmer().getNObservations() + \"\\t\" +\n+                        contig.size() + \"\\t\" +\n+                        contig.getSequence() + \"\\n\");\n+            }\n+        } catch ( final IOException ioe ) {\n+            throw new GATKException(\"Failed to write contigs file.\", ioe);\n+        }\n+    }\n+\n+    private static void writePaths( final List<Path> readPaths, final String fileName ) {\n+        try ( final BufferedWriter writer = makeGZFile(fileName) ) {\n+            final int nReads = readPaths.size();\n+            for ( int readId = 0; readId != nReads; ++readId ) {\n+                final Path path = readPaths.get(readId);\n+                final String pathDesc = path.toString();\n+                writer.write((readId + 1) + \": \" + pathDesc + \"\\n\");\n+            }\n+        } catch ( final IOException ioe ) {\n+            throw new GATKException(\"Failed to write paths file.\", ioe);\n+        }\n+    }\n+\n+    private static void writeReads( final List<GATKRead> reads, final String fileName ) {\n+        try ( final BufferedWriter writer = makeGZFile(fileName) ) {\n+            for ( final GATKRead read : reads ) {\n+                writer.write(\"@\" + read.getName());\n+                writer.write('\\n');\n+                writer.write(new String(read.getBasesNoCopy()));\n+                writer.write(\"\\n+\\n\");\n+                final byte[] quals = read.getBaseQualitiesNoCopy();\n+                final int nQuals = quals.length;\n+                final byte[] fastqQuals = new byte[nQuals];\n+                for ( int idx = 0; idx != nQuals; ++idx ) {\n+                    fastqQuals[idx] = (byte)SAMUtils.phredToFastq(quals[idx]);\n+                }\n+                writer.write(new String(fastqQuals));\n+                writer.write('\\n');\n+            }\n+        } catch ( final IOException ioe ) {\n+            throw new GATKException(\"Failed to write assembly sam file.\", ioe);\n+        }\n+    }\n+\n+    private static void writeTraversals( final Collection<Traversal> traversals,\n+                                         final String fileName ) {\n+        try ( final BufferedWriter writer = makeGZFile(fileName) ) {\n+            int traversalNo = 0;\n+            for ( final Traversal traversal : traversals ) {\n+                writer.write(\">\");\n+                if ( assemblyName != null ) {\n+                    writer.write(assemblyName);\n+                    writer.write(\"_\");\n+                }\n+                writer.write(\"t\");\n+                writer.write(Integer.toString(++traversalNo));\n+                writer.write(\" \");\n+                writer.write(traversal.getName());\n+                writer.newLine();\n+                writer.write(traversal.getSequence());\n+                writer.newLine();\n+            }\n+        } catch ( final IOException ioe ) {\n+            throw new GATKException(\"Failed to write assembly sam file.\", ioe);\n+        }\n+    }\n+\n+    /** fixed-size, immutable kmer.  usual 2-bit encoding: ACGT->0123.  low order bits are final call. **/\n+    public static class Kmer {\n+        public static final int KSIZE = 31; // must be odd number less than 32\n+        public static final long KMASK = (1L << 2*KSIZE) - 1L;\n+        private final long kVal;\n+\n+        public Kmer( final long kVal ) { this.kVal = kVal; }\n+\n+        public long getKVal() { return kVal; }\n+        public boolean isCanonical() { return isCanonical(kVal); }\n+        public int getInitialCall() { return (int)(kVal >> (KSIZE*2 - 2)) & 3; }\n+        public int getFinalCall() { return (int)kVal & 3; }\n+\n+        public long getPredecessorVal( final int call ) {\n+            return (kVal >> 2) | ((long)call << (2 * (KSIZE - 1)));\n+        }\n+        public long getSuccessorVal( final int call ) { return ((kVal << 2) & KMASK) | call; }\n+\n+        public static boolean isCanonical( final long val ) {\n+            return (val & (1L << KSIZE)) == 0L;\n+        }\n+\n+        @Override public boolean equals( final Object obj ) {\n+            return obj instanceof Kmer && kVal == ((Kmer)obj).kVal;\n+        }\n+\n+        @Override public int hashCode() {\n+            return (int)(kVal ^ (kVal >>> 32));\n+        }\n+    }\n+\n+    /** Set of Kmers.  Uses HopscotchSet, customized to find correct starting bin for Kmers and derivatives. **/\n+    public static final class KmerSet<KMER extends Kmer> extends HopscotchSet<KMER> {\n+        public KmerSet( final int capacity ) { super(capacity); }\n+\n+        @Override\n+        protected int hashToIndex( final Object kmer ) {\n+            return (int)(((HopscotchSet.SPREADER * ((Kmer)kmer).getKVal()) & Long.MAX_VALUE) % capacity());\n+        }\n+    }\n+\n+    /**\n+     *  A Kmer that remembers its predecessors and successors, and the number of times it's been observed\n+     *  in the assembly's input set of reads.\n+     *  The masks are bit-wise (1=A, 2=C, 4=G, 8=T) to show which predecessors or successors have been observed.\n+     *  The Kmer's position on a Contig is also tracked (in later phases of the assembly process).\n+     **/\n+    public static abstract class KmerAdjacency extends Kmer {\n+        public KmerAdjacency( final long kVal ) { super(kVal); }\n+\n+        public abstract KmerAdjacency getSolePredecessor(); // returns null if there's 0 or >1 predecessors\n+        public abstract int getPredecessorMask();\n+        public abstract int getPredecessorCount();\n+        public abstract void removePredecessor( final int callToRemove,\n+                                                final KmerSet<KmerAdjacency> kmerAdjacencySet );\n+\n+        public abstract KmerAdjacency getSoleSuccessor(); // returns null if there's 0 or > 1 successors\n+        public abstract int getSuccessorMask();\n+        public abstract int getSuccessorCount();\n+        public abstract void removeSuccessor( final int callToRemove,\n+                                              final KmerSet<KmerAdjacency> kmerAdjacencySet );\n+\n+        public abstract Contig getContig();\n+        public abstract int getContigOffset();\n+        // offset is 0-based measure on the contig sequence of the beginning of the kmer\n+        public abstract void setContigOffset( final Contig contig, final int contigOffset );\n+        public abstract void clearContig();\n+\n+        public abstract int getNObservations();\n+        public abstract KmerAdjacency rc();\n+        public abstract KmerAdjacencyImpl canonical();\n+\n+        public void observe( final KmerAdjacency predecessor, final KmerAdjacency successor ) {\n+            observe(predecessor, successor, 1);\n+        }\n+\n+        public abstract void observe( final KmerAdjacency predecessor,\n+                                      final KmerAdjacency successor,\n+                                      final int count );\n+\n+        @Override public String toString() {\n+            final StringBuilder sb = new StringBuilder(KSIZE);\n+            long currentVal = getKVal();\n+            for ( int idx = 0; idx != KSIZE; ++idx ) {\n+                sb.append(\"ACGT\".charAt((int)currentVal & 3));\n+                currentVal >>= 2;\n+            }\n+            sb.reverse(); // low order bits were loaded into sb first:  fix that now by reversing the sb.\n+            return sb.toString();\n+        }\n+\n+        /**\n+         * Transform a read's calls into KmerAdjacencies, and add them to a KmerSet.\n+         * Skip kmers that include a call with a quality < qMin.\n+         * Skip kmers with non-ACGT calls.\n+         **/\n+        public static void kmerize( final byte[] calls,\n+                                    final byte[] quals,\n+                                    final byte qMin,\n+                                    final KmerSet<KmerAdjacency> kmerAdjacencySet ) {\n+            int currentCount = 0; // number of calls loaded into currentKVal\n+            long currentKVal = 0;\n+            KmerAdjacency prevAdjacency = null;\n+            KmerAdjacency currentAdjacency = null;\n+            for ( int idx = 0; idx < calls.length; ++idx ) {\n+                if ( quals[idx] < qMin ) { // if we encounter a low-quality call\n+                    // take care of the most recent valid KmerAdjacency, if any\n+                    if ( currentAdjacency != null ) {\n+                        currentAdjacency.observe(prevAdjacency, null);\n+                    }\n+                    // ready ourselves to accumulate calls afresh\n+                    currentCount = 0;\n+                    currentAdjacency = prevAdjacency = null;\n+                    continue;\n+                }\n+                currentKVal <<= 2;\n+                switch ( calls[idx] ) {\n+                    case 'A': case 'a': break;\n+                    case 'C': case 'c': currentKVal += 1; break;\n+                    case 'G': case 'g': currentKVal += 2; break;\n+                    case 'T': case 't': currentKVal += 3; break;\n+                    default:\n+                        if ( currentAdjacency != null ) {\n+                            currentAdjacency.observe(prevAdjacency, null);\n+                        }\n+                        currentCount = 0;\n+                        currentAdjacency = prevAdjacency = null;\n+                        continue;\n+                }\n+                if ( ++currentCount >= KSIZE ) { // if we've loaded enough calls to make a complete kmer\n+                    final KmerAdjacency nextAdjacency = findOrAdd(currentKVal, kmerAdjacencySet);\n+                    if ( currentAdjacency != null ) {\n+                        currentAdjacency.observe(prevAdjacency, nextAdjacency);\n+                    }\n+                    prevAdjacency = currentAdjacency;\n+                    currentAdjacency = nextAdjacency;\n+                }\n+            }\n+            if ( currentAdjacency != null ) {\n+                currentAdjacency.observe(prevAdjacency, null);\n+            }\n+        }\n+\n+        /**\n+         * Kmerize a String.  This version is for gap fills.\n+         * The number of observations applies to all kmers except the 1st and last.\n+         **/\n+        public static void kmerize( final String sequence,\n+                                    final int nObservations,\n+                                    final KmerSet<KmerAdjacency> kmerAdjacencySet ) {\n+            int currentCount = 0;\n+            long currentKVal = 0;\n+            int nObs = 0;\n+            KmerAdjacency prevAdjacency = null;\n+            KmerAdjacency currentAdjacency = null;\n+            final int nCalls = sequence.length();\n+            for ( int idx = 0; idx != nCalls; ++idx ) {\n+                currentKVal <<= 2;\n+                switch ( sequence.charAt(idx) ) {\n+                    case 'A': case 'a': break;\n+                    case 'C': case 'c': currentKVal += 1; break;\n+                    case 'G': case 'g': currentKVal += 2; break;\n+                    case 'T': case 't': currentKVal += 3; break;\n+                    default: throw new GATKException(\"unexpected base call in string to kmerize.\");\n+                }\n+                if ( ++currentCount >= KSIZE ) {\n+                    final KmerAdjacency nextAdjacency = findOrAdd(currentKVal, kmerAdjacencySet);\n+                    if ( currentAdjacency != null ) {\n+                        currentAdjacency.observe(prevAdjacency, nextAdjacency, nObs);\n+                        nObs = nObservations;\n+                    }\n+                    prevAdjacency = currentAdjacency;\n+                    currentAdjacency = nextAdjacency;\n+                }\n+            }\n+            if ( currentAdjacency != null ) {\n+                currentAdjacency.observe(prevAdjacency, null, 0);\n+            }\n+        }\n+\n+        // Lookup table for reverse-complementing each possible byte value.\n+        // Each pair of bits represents a base, so you have to reverse bits pairwise and then invert all bits.\n+        // This is most quickly and easily done with a lookup table.\n+        private static final long[] BYTEWISE_REVERSE_COMPLEMENT;\n+        static {\n+            BYTEWISE_REVERSE_COMPLEMENT = new long[256];\n+            for ( int bIn = 0; bIn != 256; ++bIn ) {\n+                BYTEWISE_REVERSE_COMPLEMENT[bIn] =\n+                        ~(((bIn & 3) << 6) | (((bIn >> 2) & 3) << 4) |\n+                                (((bIn >> 4) & 3) << 2) | ((bIn >> 6) & 3)) & 0xffL;\n+            }\n+        }\n+\n+        public static long reverseComplement( long val ) {\n+            // process val one byte at a time\n+            long result = BYTEWISE_REVERSE_COMPLEMENT[(int)val & 0xFF]; // handle the low-order byte\n+            int nBytes = 8;\n+            while ( --nBytes != 0 ) { // pre-decrementing:  we'll go through the loop 7 times\n+                // rotate down by a byte\n+                val >>= 8;\n+                // rotate up by a byte and OR in the reverse complement of the next byte\n+                result = (result << 8) | BYTEWISE_REVERSE_COMPLEMENT[(int)val & 0xFF];\n+            }\n+            return result >>> (Long.SIZE - 2*KSIZE);\n+        }\n+\n+        // Kmer lookup in KmerSet.\n+        // KmerSets holding KmerAdjacencies have only canonical Kmers, so RC non-canonical kmers before lookup.\n+        public static KmerAdjacency find( final long kVal,\n+                                          final KmerSet<KmerAdjacency> kmerAdjacencySet ) {\n+            if ( isCanonical(kVal) ) return kmerAdjacencySet.find(new Kmer(kVal & KMASK));\n+            final KmerAdjacency result = kmerAdjacencySet.find(new Kmer(reverseComplement(kVal)));\n+            return result == null ? null : result.rc();\n+        }\n+\n+        // Kmer lookup in KmerSet.\n+        // KmerSets holding KmerAdjacencies have only canonical Kmers, so RC non-canonical kmers before lookup.\n+        // Add missing Kmers.\n+        public static KmerAdjacency findOrAdd( final long kVal,\n+                                               final KmerSet<KmerAdjacency> kmerAdjacencySet ) {\n+            if ( isCanonical(kVal) ) {\n+                return kmerAdjacencySet.findOrAdd(new Kmer(kVal & KMASK), kmer ->\n+                        new KmerAdjacencyImpl(((Kmer)kmer).getKVal()));\n+            }\n+            return kmerAdjacencySet.findOrAdd(new Kmer(reverseComplement(kVal)), kmer ->\n+                    new KmerAdjacencyImpl(((Kmer)kmer).getKVal())).rc();\n+        }\n+    }\n+\n+    /**\n+     * Class to implement KmerAdjacency for canonical Kmers.\n+     * In particular, a KmerSet created on KmerAdjacency contains only canonical Kmers.\n+     **/\n+    public static final class KmerAdjacencyImpl extends KmerAdjacency {\n+        private KmerAdjacency solePredecessor; // set to null if there are no predecessors, or multiple predecessors\n+        private KmerAdjacency soleSuccessor; // set to null if there are no successors, or multiple successors\n+        private int predecessorMask; // bit mask of observed kmers preceding this one\n+        private int successorMask; // bit mask observed kmers following this one\n+        private Contig contig; // the contig that contains this Kmer\n+        private int contigOffset; // the offset within the contig where this kmer is found\n+        private int nObservations; // the reads in which this kmer was observed\n+        private final KmerAdjacencyRC rc; // the reverse-complement of this kmer\n+        private static final int[] COUNT_FOR_MASK =\n+                //side sum for binary values from 0 -> 15\n+                //0000  0001 0010 0011 0100 0101 0110 0111 1000 1001 1010 1011 1100 1101 1110 1111\n+                {    0,    1,   1,   2,   1,   2,   2,   3,   1,   2,   2,   3,   2,   3,   3,   4 };\n+\n+        public KmerAdjacencyImpl( final long kVal ) {\n+            super(kVal);\n+            this.rc = new KmerAdjacencyRC(this);\n+        }\n+\n+        @Override public KmerAdjacency getSolePredecessor() { return solePredecessor; } // may return null\n+        @Override public int getPredecessorMask() { return predecessorMask; }\n+        @Override public int getPredecessorCount() { return COUNT_FOR_MASK[predecessorMask]; }\n+        @Override\n+        public void removePredecessor( final int callToRemove,\n+                                       final KmerSet<KmerAdjacency> kmerAdjacencySet ) {\n+            predecessorMask &= ~(1 << callToRemove);\n+            solePredecessor = null;\n+            if ( getPredecessorCount() == 1 ) {\n+                for ( int call = 0; call != 4; ++call ) {\n+                    if ( ((1 << call) & predecessorMask) != 0 ) {\n+                        solePredecessor = find(getPredecessorVal(call), kmerAdjacencySet);\n+                        break;\n+                    }\n+                }\n+            }\n+        }\n+\n+        @Override public KmerAdjacency getSoleSuccessor() { return soleSuccessor; } // may return null\n+        @Override public int getSuccessorMask() { return successorMask; }\n+        @Override public int getSuccessorCount() { return COUNT_FOR_MASK[successorMask]; }\n+        @Override\n+        public void removeSuccessor( final int callToRemove,\n+                                     final KmerSet<KmerAdjacency> kmerAdjacencySet ) {\n+            successorMask &= ~(1 << callToRemove);\n+            soleSuccessor = null;\n+            if ( getSuccessorCount() == 1 ) {\n+                for ( int call = 0; call != 4; ++call ) {\n+                    if ( ((1 << call) & successorMask) != 0 ) {\n+                        soleSuccessor = find(getSuccessorVal(call), kmerAdjacencySet);\n+                        break;\n+                    }\n+                }\n+            }\n+        }\n+\n+        @Override public Contig getContig() { return contig; }\n+        @Override public int getContigOffset() { return contigOffset; }\n+        @Override public void setContigOffset( final Contig contig, final int contigOffset ) {\n+            if ( this.contig != null ) {\n+                throw new GATKException(\"Internal error: overwriting kmer contig and offset.\");\n+            }\n+            this.contig = contig;\n+            this.contigOffset = contigOffset;\n+        }\n+        @Override public void clearContig() { contig = null; contigOffset = 0; }\n+\n+        @Override public int getNObservations() { return nObservations; }\n+        @Override public KmerAdjacency rc() { return rc; }\n+        @Override public KmerAdjacencyImpl canonical() { return this; }\n+\n+        @Override public void observe( final KmerAdjacency predecessor,\n+                                       final KmerAdjacency successor,\n+                                       final int count ) {\n+            if ( predecessor != null ) {\n+                if ( predecessor.getSuccessorVal(getFinalCall()) != getKVal() ) {\n+                    throw new GATKException(\"illegal predecessor\");\n+                }\n+                final int initialCall = predecessor.getInitialCall();\n+                final int newPredecessorMask = 1 << initialCall;\n+                if ( (newPredecessorMask & predecessorMask) == 0 ) {\n+                    if ( predecessorMask == 0 ) {\n+                        solePredecessor = predecessor;\n+                        predecessorMask = newPredecessorMask;\n+                    } else {\n+                        solePredecessor = null;\n+                        predecessorMask |= newPredecessorMask;\n+                    }\n+                }\n+            }\n+            if ( successor != null ) {\n+                if ( successor.getPredecessorVal(getInitialCall()) != getKVal() ) {\n+                    throw new GATKException(\"illegal successor\");\n+                }\n+                final int finalCall = successor.getFinalCall();\n+                final int newSuccessorMask = 1 << finalCall;\n+                if ( (newSuccessorMask & successorMask) == 0 ) {\n+                    if ( successorMask == 0 ) {\n+                        soleSuccessor = successor;\n+                        successorMask = newSuccessorMask;\n+                    } else {\n+                        soleSuccessor = null;\n+                        successorMask |= newSuccessorMask;\n+                    }\n+                }\n+            }\n+            nObservations += count;\n+        }\n+    }\n+\n+    /**\n+     * Class to implement KmerAdjacency for Kmers that are the reverse-complement of a canonical Kmer.\n+     * In particular, a KmerSet created on KmerAdjacency contains only canonical Kmers.\n+     * A KmerAdjacencyRC represents the RC of each Kmer in the KmerSet.\n+     **/\n+    public static final class KmerAdjacencyRC extends KmerAdjacency {\n+        private final KmerAdjacencyImpl rc;\n+\n+        // lookup table to bit-reverse nibbles\n+        private static final int[] NIBREV =\n+                // 0000,  0001,  0010,  0011,  0100,  0101,  0110,  0111,  1000,  1001,  1010,  1011,  1100,  1101,  1110,  1111\n+                {0b0000,0b1000,0b0100,0b1100,0b0010,0b1010,0b0110,0b1110,0b0001,0b1001,0b0101,0b1101,0b0011,0b1011,0b0111,0b1111};\n+\n+        public KmerAdjacencyRC( final KmerAdjacencyImpl rc ) {\n+            super(reverseComplement(rc.getKVal()));\n+            this.rc = rc;\n+        }\n+\n+        @Override public KmerAdjacency getSolePredecessor() {\n+            final KmerAdjacency successor = rc.getSoleSuccessor();\n+            return successor == null ? null : successor.rc();\n+        }\n+        @Override public int getPredecessorMask() { return NIBREV[rc.getSuccessorMask()]; }\n+        @Override public int getPredecessorCount() { return rc.getSuccessorCount(); }\n+        @Override\n+        public void removePredecessor( final int callToRemove,\n+                                       final KmerSet<KmerAdjacency> kmerAdjacencySet ) {\n+            rc.removeSuccessor(3 - callToRemove, kmerAdjacencySet);\n+        }\n+\n+        @Override public KmerAdjacency getSoleSuccessor() {\n+            final KmerAdjacency predecessor = rc.getSolePredecessor();\n+            return predecessor == null ? null : predecessor.rc();\n+        }\n+        @Override public int getSuccessorMask() { return NIBREV[rc.getPredecessorMask()]; }\n+        @Override public int getSuccessorCount() { return rc.getPredecessorCount(); }\n+        @Override\n+        public void removeSuccessor( final int callToRemove,\n+                                     final KmerSet<KmerAdjacency> kmerAdjacencySet ) {\n+            rc.removePredecessor(3 - callToRemove, kmerAdjacencySet);\n+        }\n+\n+        @Override public Contig getContig() {\n+            final Contig contig = rc.getContig();\n+            return contig == null ? null : contig.rc();\n+        }\n+        @Override public int getContigOffset() {\n+            final Contig contig = rc.getContig();\n+            return contig == null ? 0 : contig.size() - rc.getContigOffset() - KSIZE;\n+        }\n+        @Override public void setContigOffset( final Contig contig, final int contigOffset ) {\n+            rc.setContigOffset(contig.rc(), contig.size() - contigOffset - KSIZE);\n+        }\n+        @Override public void clearContig() { rc.clearContig(); }\n+\n+        @Override public int getNObservations() { return rc.getNObservations(); }\n+        @Override public KmerAdjacency rc() { return rc; }\n+        @Override public KmerAdjacencyImpl canonical() { return rc; }\n+\n+        @Override public void observe( final KmerAdjacency predecessor,\n+                                       final KmerAdjacency successor,\n+                                       final int count ) {\n+            rc.observe(successor == null ? null : successor.rc(),\n+                    predecessor == null ? null : predecessor.rc(),\n+                    count);\n+        }\n+    }\n+\n+    public enum ContigOrientation {\n+        FWD, // k-mer appears at the 5' end of the contig\n+        REV, // k-mer appears at the 5' end of the reverse-complemented contig\n+        BOTH // k-mer occurs on 5' end of the contig and its RC (can happen when the contig is a palindrome)\n+    }\n+\n+    /** Initial or final Kmer in a Contig. **/\n+    public static final class ContigEndKmer extends Kmer {\n+        private final Contig contig;\n+        private final ContigOrientation contigOrientation;\n+\n+        public ContigEndKmer( final long kVal,\n+                              final Contig contig,\n+                              final ContigOrientation contigEnd ) {\n+            super(kVal);\n+            this.contig = contig;\n+            this.contigOrientation = contigEnd;\n+        }\n+\n+        public Contig getContig() { return contig; }\n+        public ContigOrientation getContigOrientation() { return contigOrientation; }\n+    }\n+\n+    /**\n+     * An unbranched sequence of Kmers.\n+     * Each Kmer (except the last one) has a single successor, which allows enumerating the sequence\n+     * of Kmers in the Contig.  The sequence of base calls in the Contig is just the sequence of kmers\n+     * with the K-1 overlapping calls removed from adjacent kmers.\n+     **/\n+    public interface Contig {\n+        int getId();\n+        CharSequence getSequence();\n+        int getMaxObservations();\n+        KmerAdjacency getFirstKmer();\n+        KmerAdjacency getLastKmer();\n+        List<Contig> getPredecessors();\n+        List<Contig> getSuccessors();\n+        int getComponentId();\n+        int size();\n+        default int getNKmers() { return size() - Kmer.KSIZE + 1; }\n+        Contig rc();\n+        boolean isCyclic();\n+        void setCyclic( final boolean cyclic );\n+        boolean isCut();\n+        void setCut( final boolean cut );\n+        boolean isCanonical();\n+        ContigImpl canonical();\n+    }\n+\n+    /** Simple implementation of Contig interface. **/\n+    public static final class ContigImpl implements Contig {\n+        private final int id;\n+        private final CharSequence sequence;\n+        private final int maxObservations;\n+        private final KmerAdjacency firstKmer;\n+        private final KmerAdjacency lastKmer;\n+        private final List<Contig> predecessors;\n+        private final List<Contig> successors;\n+        private int componentId;\n+        private boolean cyclic;\n+        private boolean cut;\n+        private final Contig rc;\n+\n+        public ContigImpl( final int id, final KmerAdjacency firstKmerAdjacency ) {\n+            this.id = id;\n+            final StringBuilder sb = new StringBuilder(firstKmerAdjacency.toString());\n+            int maxObservations = firstKmerAdjacency.getNObservations();\n+            KmerAdjacency lastKmerAdjacency = firstKmerAdjacency;\n+            for ( KmerAdjacency kmerAdjacency = firstKmerAdjacency.getSoleSuccessor();\n+                  kmerAdjacency != null;\n+                  kmerAdjacency = kmerAdjacency.getSoleSuccessor() ) {\n+                // if we've gone around a circle, or if we're branching backwards, or if we hit a palindrome u-turn\n+                if ( firstKmerAdjacency == kmerAdjacency ||\n+                        kmerAdjacency.getPredecessorCount() != 1 ||\n+                        kmerAdjacency == lastKmerAdjacency.rc() ) {\n+                    break;\n+                }\n+                sb.append(\"ACGT\".charAt(kmerAdjacency.getFinalCall()));\n+                maxObservations = Math.max(maxObservations, kmerAdjacency.getNObservations());\n+                lastKmerAdjacency = kmerAdjacency;\n+            }\n+            this.sequence = sb.toString();\n+            this.maxObservations = maxObservations;\n+            this.firstKmer = firstKmerAdjacency;\n+            this.lastKmer = lastKmerAdjacency;\n+            this.predecessors = new ArrayList<>(firstKmer.getPredecessorCount());\n+            this.successors = new ArrayList<>(lastKmer.getSuccessorCount());\n+            this.rc = new ContigRCImpl(this);\n+\n+            int offset = 0;\n+            for ( KmerAdjacency kmerAdjacency = firstKmerAdjacency;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MTYyMjQxOA=="}, "originalCommit": {"oid": "e2201c1ef4f8ba71f17e169f07756cfe2f1ecb49"}, "originalPosition": 1746}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzczNjMxODAxOnYy", "diffSide": "RIGHT", "path": "src/main/java/org/broadinstitute/hellbender/tools/LocalAssembler.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMy0xMFQxODowOTozN1rOI0V0Jg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMy0xMFQxODowOTozN1rOI0V0Jg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MTc1NDI3OA==", "bodyText": "See my comment in ContigImpl about maybe splitting the logic that follows paths from this kmer and sets the contig into a separate method to avoid confusion.", "url": "https://github.com/broadinstitute/gatk/pull/6989#discussion_r591754278", "createdAt": "2021-03-10T18:09:37Z", "author": {"login": "cwhelan"}, "path": "src/main/java/org/broadinstitute/hellbender/tools/LocalAssembler.java", "diffHunk": "@@ -0,0 +1,2306 @@\n+package org.broadinstitute.hellbender.tools;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import htsjdk.samtools.Cigar;\n+import htsjdk.samtools.CigarElement;\n+import htsjdk.samtools.CigarOperator;\n+import htsjdk.samtools.SAMUtils;\n+import org.broadinstitute.barclay.argparser.Argument;\n+import org.broadinstitute.barclay.argparser.BetaFeature;\n+import org.broadinstitute.barclay.argparser.CommandLineProgramProperties;\n+import org.broadinstitute.barclay.help.DocumentedFeature;\n+import org.broadinstitute.hellbender.cmdline.StandardArgumentDefinitions;\n+import org.broadinstitute.hellbender.cmdline.programgroups.CoverageAnalysisProgramGroup;\n+import org.broadinstitute.hellbender.exceptions.GATKException;\n+import org.broadinstitute.hellbender.tools.walkers.PairWalker;\n+import org.broadinstitute.hellbender.utils.SimpleInterval;\n+import org.broadinstitute.hellbender.utils.collections.HopscotchSet;\n+import org.broadinstitute.hellbender.utils.gcs.BucketUtils;\n+import org.broadinstitute.hellbender.utils.read.GATKRead;\n+\n+import java.io.BufferedWriter;\n+import java.io.FileWriter;\n+import java.io.IOException;\n+import java.io.OutputStreamWriter;\n+import java.util.*;\n+import java.util.zip.GZIPOutputStream;\n+\n+@DocumentedFeature\n+@CommandLineProgramProperties(\n+        summary = \"experiment\",\n+        oneLineSummary = \"experiment\",\n+        usageExample = \"gatk LocalAssembler\",\n+        programGroup = CoverageAnalysisProgramGroup.class\n+)\n+@BetaFeature\n+public class LocalAssembler extends PairWalker {\n+    public static final byte QMIN = 25;\n+    public static final int MIN_THIN_OBS = 4;\n+    public static final int MIN_GAPFILL_COUNT = 3;\n+    public static final int TOO_MANY_TRAVERSALS = 100000;\n+    public static final int TOO_MANY_SCAFFOLDS = 50000;\n+    public static final int MIN_SV_SIZE = 50;\n+\n+    @Argument(fullName=StandardArgumentDefinitions.OUTPUT_LONG_NAME,\n+            shortName=StandardArgumentDefinitions.OUTPUT_SHORT_NAME,\n+            doc=\"Write outputs to this file name prefix\", optional = true)\n+    public static String output;\n+\n+    @Argument(fullName=\"assembly-name\", doc=\"name of assembly used as a prefix for traversal names\")\n+    public static String assemblyName;\n+\n+    private final List<GATKRead> reads = new ArrayList<>();\n+\n+    @Override public boolean requiresIntervals() { return true; }\n+\n+    @Override public void apply( final GATKRead read, final GATKRead mate ) {\n+        trimOverruns(read, mate);\n+        reads.add(read);\n+        reads.add(mate);\n+    }\n+\n+    @Override public void applyUnpaired( final GATKRead read ) {\n+        reads.add(read);\n+    }\n+\n+    @Override public Object onTraversalSuccess() {\n+        super.onTraversalSuccess(); // flush any incomplete pairs\n+\n+        final int regionSize = getTraversalIntervals().stream().mapToInt(SimpleInterval::size).sum();\n+        final KmerSet<KmerAdjacency> kmerAdjacencySet = new KmerSet<>(10 * regionSize);\n+        kmerizeReads(reads, kmerAdjacencySet);\n+        List<ContigImpl> contigs = buildContigs(kmerAdjacencySet);\n+        connectContigs(contigs);\n+\n+        removeThinContigs(contigs, kmerAdjacencySet);\n+        weldPipes(contigs);\n+        markComponents(contigs);\n+\n+        if ( fillGaps(kmerAdjacencySet, reads) ) {\n+            contigs = buildContigs(kmerAdjacencySet);\n+            connectContigs(contigs);\n+            removeThinContigs(contigs, kmerAdjacencySet);\n+            weldPipes(contigs);\n+            markComponents(contigs);\n+        }\n+\n+        markCycles(contigs);\n+\n+        final String outputFilePrefix = output != null ? output : assemblyName;\n+        final List<Path> readPaths = pathReads(kmerAdjacencySet, reads);\n+        final Map<Contig,List<TransitPairCount>> contigTransitsMap =\n+                collectTransitPairCounts(contigs, readPaths);\n+        final String traversalsFilename = outputFilePrefix + \".traversals.fa.gz\";\n+        try {\n+            final List<Traversal> allTraversals =\n+                    new ArrayList<>(traverseAllPaths(contigs, readPaths, contigTransitsMap));\n+            writeTraversals(allTraversals, traversalsFilename);\n+            try {\n+                final String scaffoldsFileName = outputFilePrefix + \".scaffolds.fa.gz\";\n+                writeTraversals(createScaffolds(allTraversals), scaffoldsFileName);\n+            } catch ( final AssemblyTooComplexException x ) {\n+                logger.warn(\"Assembly too complex for scaffolding.\");\n+            }\n+        } catch ( final AssemblyTooComplexException x ) {\n+            logger.warn(\"Assembly too complex.  Writing contigs as traversals in \" +\n+                    traversalsFilename + \".\");\n+            final Collection<Traversal> contigTraversals = new ArrayList<>(contigs.size());\n+            for ( final Contig contig : contigs ) {\n+                contigTraversals.add(new Traversal(Collections.singletonList(contig)));\n+            }\n+            writeTraversals(contigTraversals, traversalsFilename);\n+        }\n+\n+        contigs.sort(Comparator.comparingInt(ContigImpl::getId));\n+        writeDOT(contigs, outputFilePrefix + \".assembly.dot\");\n+        writeContigs(contigs, outputFilePrefix + \".contigs.txt.gz\");\n+        writePaths(readPaths, outputFilePrefix + \".paths.txt.gz\");\n+        writeReads(reads, outputFilePrefix + \".reads.fastq.gz\");\n+        return null;\n+    }\n+\n+    /** trim read pairs of base calls that have gone past the end of a short fragment */\n+    private void trimOverruns( final GATKRead read, final GATKRead mate ) {\n+        // if both mapped and they're on different strands\n+        if ( !read.isUnmapped() && !mate.isUnmapped() &&\n+                read.isReverseStrand() != mate.isReverseStrand() ) {\n+            // and both start within 1 base on the ref\n+            if ( Math.abs(read.getStart() - read.getMateStart()) <= 1 ) {\n+                // and both end within 1 base\n+                final int readRefLen = read.getCigar().getReferenceLength();\n+                final int mateRefLen = mate.getCigar().getReferenceLength();\n+                if ( Math.abs(readRefLen - mateRefLen) <= 1 ) {\n+                    if ( mate.isReverseStrand() ) {\n+                        trimClips(read, mate);\n+                    } else {\n+                        trimClips(mate, read);\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    private void trimClips( final GATKRead fwd, final GATKRead rev ) {\n+        final List<CigarElement> fwdElements = fwd.getCigarElements();\n+        final List<CigarElement> revElements = rev.getCigarElements();\n+        final int lastElementIdx = fwdElements.size() - 1;\n+        final CigarElement fwdLastElement = fwdElements.get(lastElementIdx);\n+        final CigarElement revFirstElement = revElements.get(0);\n+        if ( fwdLastElement.getOperator() == CigarOperator.S &&\n+                revFirstElement.getOperator() == CigarOperator.S ) {\n+            final byte[] fwdBases = fwd.getBasesNoCopy();\n+            final int lastElementLen = fwdLastElement.getLength();\n+            fwd.setBases(Arrays.copyOfRange(fwdBases, 0, fwdBases.length - lastElementLen));\n+            final byte[] fwdQuals = fwd.getBaseQualitiesNoCopy();\n+            if ( fwdQuals.length > 0 ) {\n+                final int qualsLen = fwdQuals.length - lastElementLen;\n+                fwd.setBaseQualities(Arrays.copyOfRange(fwdQuals, 0, qualsLen));\n+            }\n+            final List<CigarElement> newFwdElements = new ArrayList<>(fwdElements);\n+            newFwdElements.set(lastElementIdx, new CigarElement(lastElementLen, CigarOperator.H));\n+            fwd.setCigar(new Cigar(newFwdElements));\n+\n+            final byte[] revBases = rev.getBasesNoCopy();\n+            final int firstElementLen = revFirstElement.getLength();\n+            rev.setBases(Arrays.copyOfRange(revBases, firstElementLen, revBases.length));\n+            final byte[] revQuals = rev.getBaseQualitiesNoCopy();\n+            if ( revQuals.length > 0 ) {\n+                rev.setBaseQualities(Arrays.copyOfRange(revQuals, firstElementLen, revQuals.length));\n+            }\n+            final List<CigarElement> newRevElements = new ArrayList<>(revElements);\n+            newRevElements.set(0, new CigarElement(firstElementLen, CigarOperator.H));\n+            rev.setCigar(new Cigar(newRevElements));\n+        }\n+    }\n+\n+    @VisibleForTesting\n+    static void kmerizeReads( final List<GATKRead> reads,\n+                              final KmerSet<KmerAdjacency> kmerAdjacencySet ) {\n+        for ( final GATKRead read : reads ) {\n+            final byte[] calls = read.getBasesNoCopy();\n+            final byte[] quals = read.getBaseQualitiesNoCopy();\n+            KmerAdjacency.kmerize(calls, quals, QMIN, kmerAdjacencySet);\n+        }\n+    }\n+\n+    /** gather unbranched strings of kmers into contigs **/\n+    @VisibleForTesting\n+    static List<ContigImpl> buildContigs( final KmerSet<KmerAdjacency> kmerAdjacencySet ) {\n+        // gather strings of kmers that have a single predecessor and single successor into contigs\n+        final List<ContigImpl> contigs = new ArrayList<>();\n+        int nContigs = 0;\n+        for ( final KmerAdjacency kmerAdjacency : kmerAdjacencySet ) {\n+            if ( kmerAdjacency.getContig() == null ) {\n+                ContigImpl contig = null;\n+                final KmerAdjacency predecessor = kmerAdjacency.getSolePredecessor();\n+                if ( predecessor == null ||\n+                        predecessor.getSuccessorCount() > 1 ||\n+                        predecessor == kmerAdjacency.rc() ) {\n+                    contig = new ContigImpl(++nContigs, kmerAdjacency);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e2201c1ef4f8ba71f17e169f07756cfe2f1ecb49"}, "originalPosition": 199}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzczNjM5NzExOnYy", "diffSide": "RIGHT", "path": "src/main/java/org/broadinstitute/hellbender/tools/LocalAssembler.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMy0xMFQxODoyNzoyOFrOI0WlTw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNC0xMlQyMDoyNDoyNlrOJHlNyA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MTc2Njg2Mw==", "bodyText": "Here's a random idea for a possible future improvement, which might not be feasible: what if instead of a hard cutoff for MIN_THIN_OBS you compared the depth of the contig to the depth of the \"sibling\" contigs in the graph? Ie. in a bubble situation you'd maybe want to remove a contig if it had three observations and the other side of the bubble had 15 observations, but not if the other side of the bubble had only 5 observations (in which case overall depth might just be low due to sequencing bias).", "url": "https://github.com/broadinstitute/gatk/pull/6989#discussion_r591766863", "createdAt": "2021-03-10T18:27:28Z", "author": {"login": "cwhelan"}, "path": "src/main/java/org/broadinstitute/hellbender/tools/LocalAssembler.java", "diffHunk": "@@ -0,0 +1,2306 @@\n+package org.broadinstitute.hellbender.tools;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import htsjdk.samtools.Cigar;\n+import htsjdk.samtools.CigarElement;\n+import htsjdk.samtools.CigarOperator;\n+import htsjdk.samtools.SAMUtils;\n+import org.broadinstitute.barclay.argparser.Argument;\n+import org.broadinstitute.barclay.argparser.BetaFeature;\n+import org.broadinstitute.barclay.argparser.CommandLineProgramProperties;\n+import org.broadinstitute.barclay.help.DocumentedFeature;\n+import org.broadinstitute.hellbender.cmdline.StandardArgumentDefinitions;\n+import org.broadinstitute.hellbender.cmdline.programgroups.CoverageAnalysisProgramGroup;\n+import org.broadinstitute.hellbender.exceptions.GATKException;\n+import org.broadinstitute.hellbender.tools.walkers.PairWalker;\n+import org.broadinstitute.hellbender.utils.SimpleInterval;\n+import org.broadinstitute.hellbender.utils.collections.HopscotchSet;\n+import org.broadinstitute.hellbender.utils.gcs.BucketUtils;\n+import org.broadinstitute.hellbender.utils.read.GATKRead;\n+\n+import java.io.BufferedWriter;\n+import java.io.FileWriter;\n+import java.io.IOException;\n+import java.io.OutputStreamWriter;\n+import java.util.*;\n+import java.util.zip.GZIPOutputStream;\n+\n+@DocumentedFeature\n+@CommandLineProgramProperties(\n+        summary = \"experiment\",\n+        oneLineSummary = \"experiment\",\n+        usageExample = \"gatk LocalAssembler\",\n+        programGroup = CoverageAnalysisProgramGroup.class\n+)\n+@BetaFeature\n+public class LocalAssembler extends PairWalker {\n+    public static final byte QMIN = 25;\n+    public static final int MIN_THIN_OBS = 4;\n+    public static final int MIN_GAPFILL_COUNT = 3;\n+    public static final int TOO_MANY_TRAVERSALS = 100000;\n+    public static final int TOO_MANY_SCAFFOLDS = 50000;\n+    public static final int MIN_SV_SIZE = 50;\n+\n+    @Argument(fullName=StandardArgumentDefinitions.OUTPUT_LONG_NAME,\n+            shortName=StandardArgumentDefinitions.OUTPUT_SHORT_NAME,\n+            doc=\"Write outputs to this file name prefix\", optional = true)\n+    public static String output;\n+\n+    @Argument(fullName=\"assembly-name\", doc=\"name of assembly used as a prefix for traversal names\")\n+    public static String assemblyName;\n+\n+    private final List<GATKRead> reads = new ArrayList<>();\n+\n+    @Override public boolean requiresIntervals() { return true; }\n+\n+    @Override public void apply( final GATKRead read, final GATKRead mate ) {\n+        trimOverruns(read, mate);\n+        reads.add(read);\n+        reads.add(mate);\n+    }\n+\n+    @Override public void applyUnpaired( final GATKRead read ) {\n+        reads.add(read);\n+    }\n+\n+    @Override public Object onTraversalSuccess() {\n+        super.onTraversalSuccess(); // flush any incomplete pairs\n+\n+        final int regionSize = getTraversalIntervals().stream().mapToInt(SimpleInterval::size).sum();\n+        final KmerSet<KmerAdjacency> kmerAdjacencySet = new KmerSet<>(10 * regionSize);\n+        kmerizeReads(reads, kmerAdjacencySet);\n+        List<ContigImpl> contigs = buildContigs(kmerAdjacencySet);\n+        connectContigs(contigs);\n+\n+        removeThinContigs(contigs, kmerAdjacencySet);\n+        weldPipes(contigs);\n+        markComponents(contigs);\n+\n+        if ( fillGaps(kmerAdjacencySet, reads) ) {\n+            contigs = buildContigs(kmerAdjacencySet);\n+            connectContigs(contigs);\n+            removeThinContigs(contigs, kmerAdjacencySet);\n+            weldPipes(contigs);\n+            markComponents(contigs);\n+        }\n+\n+        markCycles(contigs);\n+\n+        final String outputFilePrefix = output != null ? output : assemblyName;\n+        final List<Path> readPaths = pathReads(kmerAdjacencySet, reads);\n+        final Map<Contig,List<TransitPairCount>> contigTransitsMap =\n+                collectTransitPairCounts(contigs, readPaths);\n+        final String traversalsFilename = outputFilePrefix + \".traversals.fa.gz\";\n+        try {\n+            final List<Traversal> allTraversals =\n+                    new ArrayList<>(traverseAllPaths(contigs, readPaths, contigTransitsMap));\n+            writeTraversals(allTraversals, traversalsFilename);\n+            try {\n+                final String scaffoldsFileName = outputFilePrefix + \".scaffolds.fa.gz\";\n+                writeTraversals(createScaffolds(allTraversals), scaffoldsFileName);\n+            } catch ( final AssemblyTooComplexException x ) {\n+                logger.warn(\"Assembly too complex for scaffolding.\");\n+            }\n+        } catch ( final AssemblyTooComplexException x ) {\n+            logger.warn(\"Assembly too complex.  Writing contigs as traversals in \" +\n+                    traversalsFilename + \".\");\n+            final Collection<Traversal> contigTraversals = new ArrayList<>(contigs.size());\n+            for ( final Contig contig : contigs ) {\n+                contigTraversals.add(new Traversal(Collections.singletonList(contig)));\n+            }\n+            writeTraversals(contigTraversals, traversalsFilename);\n+        }\n+\n+        contigs.sort(Comparator.comparingInt(ContigImpl::getId));\n+        writeDOT(contigs, outputFilePrefix + \".assembly.dot\");\n+        writeContigs(contigs, outputFilePrefix + \".contigs.txt.gz\");\n+        writePaths(readPaths, outputFilePrefix + \".paths.txt.gz\");\n+        writeReads(reads, outputFilePrefix + \".reads.fastq.gz\");\n+        return null;\n+    }\n+\n+    /** trim read pairs of base calls that have gone past the end of a short fragment */\n+    private void trimOverruns( final GATKRead read, final GATKRead mate ) {\n+        // if both mapped and they're on different strands\n+        if ( !read.isUnmapped() && !mate.isUnmapped() &&\n+                read.isReverseStrand() != mate.isReverseStrand() ) {\n+            // and both start within 1 base on the ref\n+            if ( Math.abs(read.getStart() - read.getMateStart()) <= 1 ) {\n+                // and both end within 1 base\n+                final int readRefLen = read.getCigar().getReferenceLength();\n+                final int mateRefLen = mate.getCigar().getReferenceLength();\n+                if ( Math.abs(readRefLen - mateRefLen) <= 1 ) {\n+                    if ( mate.isReverseStrand() ) {\n+                        trimClips(read, mate);\n+                    } else {\n+                        trimClips(mate, read);\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    private void trimClips( final GATKRead fwd, final GATKRead rev ) {\n+        final List<CigarElement> fwdElements = fwd.getCigarElements();\n+        final List<CigarElement> revElements = rev.getCigarElements();\n+        final int lastElementIdx = fwdElements.size() - 1;\n+        final CigarElement fwdLastElement = fwdElements.get(lastElementIdx);\n+        final CigarElement revFirstElement = revElements.get(0);\n+        if ( fwdLastElement.getOperator() == CigarOperator.S &&\n+                revFirstElement.getOperator() == CigarOperator.S ) {\n+            final byte[] fwdBases = fwd.getBasesNoCopy();\n+            final int lastElementLen = fwdLastElement.getLength();\n+            fwd.setBases(Arrays.copyOfRange(fwdBases, 0, fwdBases.length - lastElementLen));\n+            final byte[] fwdQuals = fwd.getBaseQualitiesNoCopy();\n+            if ( fwdQuals.length > 0 ) {\n+                final int qualsLen = fwdQuals.length - lastElementLen;\n+                fwd.setBaseQualities(Arrays.copyOfRange(fwdQuals, 0, qualsLen));\n+            }\n+            final List<CigarElement> newFwdElements = new ArrayList<>(fwdElements);\n+            newFwdElements.set(lastElementIdx, new CigarElement(lastElementLen, CigarOperator.H));\n+            fwd.setCigar(new Cigar(newFwdElements));\n+\n+            final byte[] revBases = rev.getBasesNoCopy();\n+            final int firstElementLen = revFirstElement.getLength();\n+            rev.setBases(Arrays.copyOfRange(revBases, firstElementLen, revBases.length));\n+            final byte[] revQuals = rev.getBaseQualitiesNoCopy();\n+            if ( revQuals.length > 0 ) {\n+                rev.setBaseQualities(Arrays.copyOfRange(revQuals, firstElementLen, revQuals.length));\n+            }\n+            final List<CigarElement> newRevElements = new ArrayList<>(revElements);\n+            newRevElements.set(0, new CigarElement(firstElementLen, CigarOperator.H));\n+            rev.setCigar(new Cigar(newRevElements));\n+        }\n+    }\n+\n+    @VisibleForTesting\n+    static void kmerizeReads( final List<GATKRead> reads,\n+                              final KmerSet<KmerAdjacency> kmerAdjacencySet ) {\n+        for ( final GATKRead read : reads ) {\n+            final byte[] calls = read.getBasesNoCopy();\n+            final byte[] quals = read.getBaseQualitiesNoCopy();\n+            KmerAdjacency.kmerize(calls, quals, QMIN, kmerAdjacencySet);\n+        }\n+    }\n+\n+    /** gather unbranched strings of kmers into contigs **/\n+    @VisibleForTesting\n+    static List<ContigImpl> buildContigs( final KmerSet<KmerAdjacency> kmerAdjacencySet ) {\n+        // gather strings of kmers that have a single predecessor and single successor into contigs\n+        final List<ContigImpl> contigs = new ArrayList<>();\n+        int nContigs = 0;\n+        for ( final KmerAdjacency kmerAdjacency : kmerAdjacencySet ) {\n+            if ( kmerAdjacency.getContig() == null ) {\n+                ContigImpl contig = null;\n+                final KmerAdjacency predecessor = kmerAdjacency.getSolePredecessor();\n+                if ( predecessor == null ||\n+                        predecessor.getSuccessorCount() > 1 ||\n+                        predecessor == kmerAdjacency.rc() ) {\n+                    contig = new ContigImpl(++nContigs, kmerAdjacency);\n+                } else {\n+                    final KmerAdjacency successor = kmerAdjacency.getSoleSuccessor();\n+                    if ( successor == null ||\n+                            successor.getPredecessorCount() > 1 ||\n+                            successor == kmerAdjacency.rc() ) {\n+                        contig = new ContigImpl(++nContigs, kmerAdjacency.rc());\n+                    }\n+                }\n+                if ( contig != null ) {\n+                    contigs.add(contig);\n+                }\n+            }\n+        }\n+\n+        // if there are smooth circles like a plasmid, gather them together as a contig, too\n+        for ( final KmerAdjacency kmerAdjacency : kmerAdjacencySet ) {\n+            if ( kmerAdjacency.getContig() == null ) {\n+                contigs.add(new ContigImpl(++nContigs, kmerAdjacency));\n+            }\n+        }\n+\n+        return contigs;\n+    }\n+\n+    /** connect contigs when the final kmer of one contig is adjacent to the inital contig of another **/\n+    @VisibleForTesting\n+    static void connectContigs( final List<ContigImpl> contigs ) {\n+        final int nContigs = contigs.size();\n+        final KmerSet<ContigEndKmer> contigEnds = new KmerSet<>(2*nContigs);\n+        for ( int contigId = 0; contigId != nContigs; ++contigId ) {\n+            final ContigImpl contig = contigs.get(contigId);\n+            final KmerAdjacency fwdKmer = contig.getFirstKmer();\n+            final KmerAdjacency revKmer = contig.getLastKmer().rc();\n+            if ( fwdKmer == revKmer ) {\n+                contigEnds.add(new ContigEndKmer(fwdKmer.getKVal(), contig, ContigOrientation.BOTH));\n+            } else {\n+                contigEnds.add(new ContigEndKmer(fwdKmer.getKVal(), contig, ContigOrientation.FWD));\n+                contigEnds.add(new ContigEndKmer(revKmer.getKVal(), contig, ContigOrientation.REV));\n+            }\n+        }\n+\n+        for ( int contigId = 0; contigId != nContigs; ++contigId ) {\n+            final Contig contig = contigs.get(contigId);\n+\n+            final KmerAdjacency start = contig.getFirstKmer();\n+            final int predecessorCount = start.getPredecessorCount();\n+            if ( predecessorCount > 0 ) {\n+                final List<Contig> predecessors = contig.getPredecessors();\n+                final int mask = start.getPredecessorMask();\n+                for ( int call = 0; call != 4; ++call ) {\n+                    if ( (mask & (1 << call)) != 0 ) {\n+                        final long kVal =\n+                                KmerAdjacency.reverseComplement(start.getPredecessorVal(call));\n+                        final ContigEndKmer contigEndKmer = contigEnds.find(new Kmer(kVal));\n+                        if ( contigEndKmer == null ) {\n+                            throw new GATKException(\"missing contig end kmer\");\n+                        }\n+                        switch ( contigEndKmer.getContigOrientation() ) {\n+                            case FWD:\n+                                predecessors.add(contigEndKmer.getContig().rc());\n+                                break;\n+                            case REV:\n+                                predecessors.add(contigEndKmer.getContig());\n+                                break;\n+                            case BOTH:\n+                                predecessors.add(contigEndKmer.getContig());\n+                                predecessors.add(contigEndKmer.getContig().rc());\n+                                break;\n+                        }\n+                    }\n+                }\n+            }\n+\n+            final KmerAdjacency end = contig.getLastKmer();\n+            final int successorCount = end.getSuccessorCount();\n+            if ( successorCount > 0 ) {\n+                final List<Contig> successors = contig.getSuccessors();\n+                final int mask = end.getSuccessorMask();\n+                for ( int call = 0; call != 4; ++call ) {\n+                    if ( (mask & (1 << call)) != 0 ) {\n+                        final long kVal = end.getSuccessorVal(call);\n+                        final ContigEndKmer contigEndKmer = contigEnds.find(new Kmer(kVal));\n+                        if ( contigEndKmer == null ) {\n+                            throw new GATKException(\"missing contig end kmer\");\n+                        }\n+                        switch ( contigEndKmer.getContigOrientation() ) {\n+                            case FWD:\n+                                successors.add(contigEndKmer.getContig());\n+                                break;\n+                            case REV:\n+                                successors.add(contigEndKmer.getContig().rc());\n+                                break;\n+                            case BOTH:\n+                                successors.add(contigEndKmer.getContig());\n+                                successors.add(contigEndKmer.getContig().rc());\n+                                break;\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    /** remove contigs that have little evidence **/\n+    @VisibleForTesting\n+    static void removeThinContigs( final List<ContigImpl> contigs,\n+                                           final KmerSet<KmerAdjacency> kmerAdjacencySet ) {\n+        contigs.sort(Comparator.comparingInt(ContigImpl::getMaxObservations));\n+        boolean contigRemoved;\n+        do {\n+            // figure out which contigs are cut points\n+            // i.e., those contigs which, if removed, would result in a graph with more connected components\n+            final int nContigs = contigs.size();\n+            final Map<Contig, CutData> cutDataMap = new HashMap<>(nContigs * 3);\n+\n+            for ( final ContigImpl contig : contigs ) {\n+                if ( cutDataMap.containsKey(contig) ) {\n+                    continue;\n+                }\n+\n+                cutDataMap.put(contig, new CutData());\n+                int children = 0;\n+                for ( final Contig nextContig : contig.getSuccessors() ) {\n+                    if ( !cutDataMap.containsKey(nextContig) ) {\n+                        findCuts(nextContig, contig, cutDataMap);\n+                        children += 1;\n+                    }\n+                }\n+                for ( final Contig nextContig : contig.getPredecessors() ) {\n+                    if ( !cutDataMap.containsKey(nextContig) ) {\n+                        findCuts(nextContig, contig, cutDataMap);\n+                        children += 1;\n+                    }\n+                }\n+                if ( children >= 2 ) {\n+                    contig.setCut(true);\n+                }\n+            }\n+\n+            // remove poorly attested (low max observations) contigs, unless they are cut points\n+            contigRemoved = false;\n+            final Iterator<ContigImpl> itr = contigs.iterator();\n+            while ( itr.hasNext() ) {\n+                final Contig contig = itr.next();\n+                if ( contig.getMaxObservations() < MIN_THIN_OBS && !contig.isCut() ) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e2201c1ef4f8ba71f17e169f07756cfe2f1ecb49"}, "originalPosition": 344}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxMTkyOTU0NA==", "bodyText": "For now, I'll just leave a TODO that documents the suggestion.  It's not straightforward, since not all the contigs we'd want to remove have \"bubble mates\", and even if they do, some bubble mates can have dramatically different lengths.", "url": "https://github.com/broadinstitute/gatk/pull/6989#discussion_r611929544", "createdAt": "2021-04-12T20:24:26Z", "author": {"login": "tedsharpe"}, "path": "src/main/java/org/broadinstitute/hellbender/tools/LocalAssembler.java", "diffHunk": "@@ -0,0 +1,2306 @@\n+package org.broadinstitute.hellbender.tools;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import htsjdk.samtools.Cigar;\n+import htsjdk.samtools.CigarElement;\n+import htsjdk.samtools.CigarOperator;\n+import htsjdk.samtools.SAMUtils;\n+import org.broadinstitute.barclay.argparser.Argument;\n+import org.broadinstitute.barclay.argparser.BetaFeature;\n+import org.broadinstitute.barclay.argparser.CommandLineProgramProperties;\n+import org.broadinstitute.barclay.help.DocumentedFeature;\n+import org.broadinstitute.hellbender.cmdline.StandardArgumentDefinitions;\n+import org.broadinstitute.hellbender.cmdline.programgroups.CoverageAnalysisProgramGroup;\n+import org.broadinstitute.hellbender.exceptions.GATKException;\n+import org.broadinstitute.hellbender.tools.walkers.PairWalker;\n+import org.broadinstitute.hellbender.utils.SimpleInterval;\n+import org.broadinstitute.hellbender.utils.collections.HopscotchSet;\n+import org.broadinstitute.hellbender.utils.gcs.BucketUtils;\n+import org.broadinstitute.hellbender.utils.read.GATKRead;\n+\n+import java.io.BufferedWriter;\n+import java.io.FileWriter;\n+import java.io.IOException;\n+import java.io.OutputStreamWriter;\n+import java.util.*;\n+import java.util.zip.GZIPOutputStream;\n+\n+@DocumentedFeature\n+@CommandLineProgramProperties(\n+        summary = \"experiment\",\n+        oneLineSummary = \"experiment\",\n+        usageExample = \"gatk LocalAssembler\",\n+        programGroup = CoverageAnalysisProgramGroup.class\n+)\n+@BetaFeature\n+public class LocalAssembler extends PairWalker {\n+    public static final byte QMIN = 25;\n+    public static final int MIN_THIN_OBS = 4;\n+    public static final int MIN_GAPFILL_COUNT = 3;\n+    public static final int TOO_MANY_TRAVERSALS = 100000;\n+    public static final int TOO_MANY_SCAFFOLDS = 50000;\n+    public static final int MIN_SV_SIZE = 50;\n+\n+    @Argument(fullName=StandardArgumentDefinitions.OUTPUT_LONG_NAME,\n+            shortName=StandardArgumentDefinitions.OUTPUT_SHORT_NAME,\n+            doc=\"Write outputs to this file name prefix\", optional = true)\n+    public static String output;\n+\n+    @Argument(fullName=\"assembly-name\", doc=\"name of assembly used as a prefix for traversal names\")\n+    public static String assemblyName;\n+\n+    private final List<GATKRead> reads = new ArrayList<>();\n+\n+    @Override public boolean requiresIntervals() { return true; }\n+\n+    @Override public void apply( final GATKRead read, final GATKRead mate ) {\n+        trimOverruns(read, mate);\n+        reads.add(read);\n+        reads.add(mate);\n+    }\n+\n+    @Override public void applyUnpaired( final GATKRead read ) {\n+        reads.add(read);\n+    }\n+\n+    @Override public Object onTraversalSuccess() {\n+        super.onTraversalSuccess(); // flush any incomplete pairs\n+\n+        final int regionSize = getTraversalIntervals().stream().mapToInt(SimpleInterval::size).sum();\n+        final KmerSet<KmerAdjacency> kmerAdjacencySet = new KmerSet<>(10 * regionSize);\n+        kmerizeReads(reads, kmerAdjacencySet);\n+        List<ContigImpl> contigs = buildContigs(kmerAdjacencySet);\n+        connectContigs(contigs);\n+\n+        removeThinContigs(contigs, kmerAdjacencySet);\n+        weldPipes(contigs);\n+        markComponents(contigs);\n+\n+        if ( fillGaps(kmerAdjacencySet, reads) ) {\n+            contigs = buildContigs(kmerAdjacencySet);\n+            connectContigs(contigs);\n+            removeThinContigs(contigs, kmerAdjacencySet);\n+            weldPipes(contigs);\n+            markComponents(contigs);\n+        }\n+\n+        markCycles(contigs);\n+\n+        final String outputFilePrefix = output != null ? output : assemblyName;\n+        final List<Path> readPaths = pathReads(kmerAdjacencySet, reads);\n+        final Map<Contig,List<TransitPairCount>> contigTransitsMap =\n+                collectTransitPairCounts(contigs, readPaths);\n+        final String traversalsFilename = outputFilePrefix + \".traversals.fa.gz\";\n+        try {\n+            final List<Traversal> allTraversals =\n+                    new ArrayList<>(traverseAllPaths(contigs, readPaths, contigTransitsMap));\n+            writeTraversals(allTraversals, traversalsFilename);\n+            try {\n+                final String scaffoldsFileName = outputFilePrefix + \".scaffolds.fa.gz\";\n+                writeTraversals(createScaffolds(allTraversals), scaffoldsFileName);\n+            } catch ( final AssemblyTooComplexException x ) {\n+                logger.warn(\"Assembly too complex for scaffolding.\");\n+            }\n+        } catch ( final AssemblyTooComplexException x ) {\n+            logger.warn(\"Assembly too complex.  Writing contigs as traversals in \" +\n+                    traversalsFilename + \".\");\n+            final Collection<Traversal> contigTraversals = new ArrayList<>(contigs.size());\n+            for ( final Contig contig : contigs ) {\n+                contigTraversals.add(new Traversal(Collections.singletonList(contig)));\n+            }\n+            writeTraversals(contigTraversals, traversalsFilename);\n+        }\n+\n+        contigs.sort(Comparator.comparingInt(ContigImpl::getId));\n+        writeDOT(contigs, outputFilePrefix + \".assembly.dot\");\n+        writeContigs(contigs, outputFilePrefix + \".contigs.txt.gz\");\n+        writePaths(readPaths, outputFilePrefix + \".paths.txt.gz\");\n+        writeReads(reads, outputFilePrefix + \".reads.fastq.gz\");\n+        return null;\n+    }\n+\n+    /** trim read pairs of base calls that have gone past the end of a short fragment */\n+    private void trimOverruns( final GATKRead read, final GATKRead mate ) {\n+        // if both mapped and they're on different strands\n+        if ( !read.isUnmapped() && !mate.isUnmapped() &&\n+                read.isReverseStrand() != mate.isReverseStrand() ) {\n+            // and both start within 1 base on the ref\n+            if ( Math.abs(read.getStart() - read.getMateStart()) <= 1 ) {\n+                // and both end within 1 base\n+                final int readRefLen = read.getCigar().getReferenceLength();\n+                final int mateRefLen = mate.getCigar().getReferenceLength();\n+                if ( Math.abs(readRefLen - mateRefLen) <= 1 ) {\n+                    if ( mate.isReverseStrand() ) {\n+                        trimClips(read, mate);\n+                    } else {\n+                        trimClips(mate, read);\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    private void trimClips( final GATKRead fwd, final GATKRead rev ) {\n+        final List<CigarElement> fwdElements = fwd.getCigarElements();\n+        final List<CigarElement> revElements = rev.getCigarElements();\n+        final int lastElementIdx = fwdElements.size() - 1;\n+        final CigarElement fwdLastElement = fwdElements.get(lastElementIdx);\n+        final CigarElement revFirstElement = revElements.get(0);\n+        if ( fwdLastElement.getOperator() == CigarOperator.S &&\n+                revFirstElement.getOperator() == CigarOperator.S ) {\n+            final byte[] fwdBases = fwd.getBasesNoCopy();\n+            final int lastElementLen = fwdLastElement.getLength();\n+            fwd.setBases(Arrays.copyOfRange(fwdBases, 0, fwdBases.length - lastElementLen));\n+            final byte[] fwdQuals = fwd.getBaseQualitiesNoCopy();\n+            if ( fwdQuals.length > 0 ) {\n+                final int qualsLen = fwdQuals.length - lastElementLen;\n+                fwd.setBaseQualities(Arrays.copyOfRange(fwdQuals, 0, qualsLen));\n+            }\n+            final List<CigarElement> newFwdElements = new ArrayList<>(fwdElements);\n+            newFwdElements.set(lastElementIdx, new CigarElement(lastElementLen, CigarOperator.H));\n+            fwd.setCigar(new Cigar(newFwdElements));\n+\n+            final byte[] revBases = rev.getBasesNoCopy();\n+            final int firstElementLen = revFirstElement.getLength();\n+            rev.setBases(Arrays.copyOfRange(revBases, firstElementLen, revBases.length));\n+            final byte[] revQuals = rev.getBaseQualitiesNoCopy();\n+            if ( revQuals.length > 0 ) {\n+                rev.setBaseQualities(Arrays.copyOfRange(revQuals, firstElementLen, revQuals.length));\n+            }\n+            final List<CigarElement> newRevElements = new ArrayList<>(revElements);\n+            newRevElements.set(0, new CigarElement(firstElementLen, CigarOperator.H));\n+            rev.setCigar(new Cigar(newRevElements));\n+        }\n+    }\n+\n+    @VisibleForTesting\n+    static void kmerizeReads( final List<GATKRead> reads,\n+                              final KmerSet<KmerAdjacency> kmerAdjacencySet ) {\n+        for ( final GATKRead read : reads ) {\n+            final byte[] calls = read.getBasesNoCopy();\n+            final byte[] quals = read.getBaseQualitiesNoCopy();\n+            KmerAdjacency.kmerize(calls, quals, QMIN, kmerAdjacencySet);\n+        }\n+    }\n+\n+    /** gather unbranched strings of kmers into contigs **/\n+    @VisibleForTesting\n+    static List<ContigImpl> buildContigs( final KmerSet<KmerAdjacency> kmerAdjacencySet ) {\n+        // gather strings of kmers that have a single predecessor and single successor into contigs\n+        final List<ContigImpl> contigs = new ArrayList<>();\n+        int nContigs = 0;\n+        for ( final KmerAdjacency kmerAdjacency : kmerAdjacencySet ) {\n+            if ( kmerAdjacency.getContig() == null ) {\n+                ContigImpl contig = null;\n+                final KmerAdjacency predecessor = kmerAdjacency.getSolePredecessor();\n+                if ( predecessor == null ||\n+                        predecessor.getSuccessorCount() > 1 ||\n+                        predecessor == kmerAdjacency.rc() ) {\n+                    contig = new ContigImpl(++nContigs, kmerAdjacency);\n+                } else {\n+                    final KmerAdjacency successor = kmerAdjacency.getSoleSuccessor();\n+                    if ( successor == null ||\n+                            successor.getPredecessorCount() > 1 ||\n+                            successor == kmerAdjacency.rc() ) {\n+                        contig = new ContigImpl(++nContigs, kmerAdjacency.rc());\n+                    }\n+                }\n+                if ( contig != null ) {\n+                    contigs.add(contig);\n+                }\n+            }\n+        }\n+\n+        // if there are smooth circles like a plasmid, gather them together as a contig, too\n+        for ( final KmerAdjacency kmerAdjacency : kmerAdjacencySet ) {\n+            if ( kmerAdjacency.getContig() == null ) {\n+                contigs.add(new ContigImpl(++nContigs, kmerAdjacency));\n+            }\n+        }\n+\n+        return contigs;\n+    }\n+\n+    /** connect contigs when the final kmer of one contig is adjacent to the inital contig of another **/\n+    @VisibleForTesting\n+    static void connectContigs( final List<ContigImpl> contigs ) {\n+        final int nContigs = contigs.size();\n+        final KmerSet<ContigEndKmer> contigEnds = new KmerSet<>(2*nContigs);\n+        for ( int contigId = 0; contigId != nContigs; ++contigId ) {\n+            final ContigImpl contig = contigs.get(contigId);\n+            final KmerAdjacency fwdKmer = contig.getFirstKmer();\n+            final KmerAdjacency revKmer = contig.getLastKmer().rc();\n+            if ( fwdKmer == revKmer ) {\n+                contigEnds.add(new ContigEndKmer(fwdKmer.getKVal(), contig, ContigOrientation.BOTH));\n+            } else {\n+                contigEnds.add(new ContigEndKmer(fwdKmer.getKVal(), contig, ContigOrientation.FWD));\n+                contigEnds.add(new ContigEndKmer(revKmer.getKVal(), contig, ContigOrientation.REV));\n+            }\n+        }\n+\n+        for ( int contigId = 0; contigId != nContigs; ++contigId ) {\n+            final Contig contig = contigs.get(contigId);\n+\n+            final KmerAdjacency start = contig.getFirstKmer();\n+            final int predecessorCount = start.getPredecessorCount();\n+            if ( predecessorCount > 0 ) {\n+                final List<Contig> predecessors = contig.getPredecessors();\n+                final int mask = start.getPredecessorMask();\n+                for ( int call = 0; call != 4; ++call ) {\n+                    if ( (mask & (1 << call)) != 0 ) {\n+                        final long kVal =\n+                                KmerAdjacency.reverseComplement(start.getPredecessorVal(call));\n+                        final ContigEndKmer contigEndKmer = contigEnds.find(new Kmer(kVal));\n+                        if ( contigEndKmer == null ) {\n+                            throw new GATKException(\"missing contig end kmer\");\n+                        }\n+                        switch ( contigEndKmer.getContigOrientation() ) {\n+                            case FWD:\n+                                predecessors.add(contigEndKmer.getContig().rc());\n+                                break;\n+                            case REV:\n+                                predecessors.add(contigEndKmer.getContig());\n+                                break;\n+                            case BOTH:\n+                                predecessors.add(contigEndKmer.getContig());\n+                                predecessors.add(contigEndKmer.getContig().rc());\n+                                break;\n+                        }\n+                    }\n+                }\n+            }\n+\n+            final KmerAdjacency end = contig.getLastKmer();\n+            final int successorCount = end.getSuccessorCount();\n+            if ( successorCount > 0 ) {\n+                final List<Contig> successors = contig.getSuccessors();\n+                final int mask = end.getSuccessorMask();\n+                for ( int call = 0; call != 4; ++call ) {\n+                    if ( (mask & (1 << call)) != 0 ) {\n+                        final long kVal = end.getSuccessorVal(call);\n+                        final ContigEndKmer contigEndKmer = contigEnds.find(new Kmer(kVal));\n+                        if ( contigEndKmer == null ) {\n+                            throw new GATKException(\"missing contig end kmer\");\n+                        }\n+                        switch ( contigEndKmer.getContigOrientation() ) {\n+                            case FWD:\n+                                successors.add(contigEndKmer.getContig());\n+                                break;\n+                            case REV:\n+                                successors.add(contigEndKmer.getContig().rc());\n+                                break;\n+                            case BOTH:\n+                                successors.add(contigEndKmer.getContig());\n+                                successors.add(contigEndKmer.getContig().rc());\n+                                break;\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    /** remove contigs that have little evidence **/\n+    @VisibleForTesting\n+    static void removeThinContigs( final List<ContigImpl> contigs,\n+                                           final KmerSet<KmerAdjacency> kmerAdjacencySet ) {\n+        contigs.sort(Comparator.comparingInt(ContigImpl::getMaxObservations));\n+        boolean contigRemoved;\n+        do {\n+            // figure out which contigs are cut points\n+            // i.e., those contigs which, if removed, would result in a graph with more connected components\n+            final int nContigs = contigs.size();\n+            final Map<Contig, CutData> cutDataMap = new HashMap<>(nContigs * 3);\n+\n+            for ( final ContigImpl contig : contigs ) {\n+                if ( cutDataMap.containsKey(contig) ) {\n+                    continue;\n+                }\n+\n+                cutDataMap.put(contig, new CutData());\n+                int children = 0;\n+                for ( final Contig nextContig : contig.getSuccessors() ) {\n+                    if ( !cutDataMap.containsKey(nextContig) ) {\n+                        findCuts(nextContig, contig, cutDataMap);\n+                        children += 1;\n+                    }\n+                }\n+                for ( final Contig nextContig : contig.getPredecessors() ) {\n+                    if ( !cutDataMap.containsKey(nextContig) ) {\n+                        findCuts(nextContig, contig, cutDataMap);\n+                        children += 1;\n+                    }\n+                }\n+                if ( children >= 2 ) {\n+                    contig.setCut(true);\n+                }\n+            }\n+\n+            // remove poorly attested (low max observations) contigs, unless they are cut points\n+            contigRemoved = false;\n+            final Iterator<ContigImpl> itr = contigs.iterator();\n+            while ( itr.hasNext() ) {\n+                final Contig contig = itr.next();\n+                if ( contig.getMaxObservations() < MIN_THIN_OBS && !contig.isCut() ) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MTc2Njg2Mw=="}, "originalCommit": {"oid": "e2201c1ef4f8ba71f17e169f07756cfe2f1ecb49"}, "originalPosition": 344}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzczNjQzNzUxOnYy", "diffSide": "RIGHT", "path": "src/main/java/org/broadinstitute/hellbender/tools/LocalAssembler.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMy0xMFQxODozNjo0NFrOI0W-8g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMy0xMFQxODozNjo0NFrOI0W-8g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MTc3MzQyNg==", "bodyText": "I guess from reading the algorithm that only the ordering of this value between CutData instances is important, rather than the specific value, but it still makes me a little nervous to have this be a static class variable. Would you consider having a CutDataFactory object that keeps it as an instance variable, and could be scoped into the methods that are using it? That way if we ever multithreaded this or something we'd avoid some chaos.", "url": "https://github.com/broadinstitute/gatk/pull/6989#discussion_r591773426", "createdAt": "2021-03-10T18:36:44Z", "author": {"login": "cwhelan"}, "path": "src/main/java/org/broadinstitute/hellbender/tools/LocalAssembler.java", "diffHunk": "@@ -0,0 +1,2306 @@\n+package org.broadinstitute.hellbender.tools;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import htsjdk.samtools.Cigar;\n+import htsjdk.samtools.CigarElement;\n+import htsjdk.samtools.CigarOperator;\n+import htsjdk.samtools.SAMUtils;\n+import org.broadinstitute.barclay.argparser.Argument;\n+import org.broadinstitute.barclay.argparser.BetaFeature;\n+import org.broadinstitute.barclay.argparser.CommandLineProgramProperties;\n+import org.broadinstitute.barclay.help.DocumentedFeature;\n+import org.broadinstitute.hellbender.cmdline.StandardArgumentDefinitions;\n+import org.broadinstitute.hellbender.cmdline.programgroups.CoverageAnalysisProgramGroup;\n+import org.broadinstitute.hellbender.exceptions.GATKException;\n+import org.broadinstitute.hellbender.tools.walkers.PairWalker;\n+import org.broadinstitute.hellbender.utils.SimpleInterval;\n+import org.broadinstitute.hellbender.utils.collections.HopscotchSet;\n+import org.broadinstitute.hellbender.utils.gcs.BucketUtils;\n+import org.broadinstitute.hellbender.utils.read.GATKRead;\n+\n+import java.io.BufferedWriter;\n+import java.io.FileWriter;\n+import java.io.IOException;\n+import java.io.OutputStreamWriter;\n+import java.util.*;\n+import java.util.zip.GZIPOutputStream;\n+\n+@DocumentedFeature\n+@CommandLineProgramProperties(\n+        summary = \"experiment\",\n+        oneLineSummary = \"experiment\",\n+        usageExample = \"gatk LocalAssembler\",\n+        programGroup = CoverageAnalysisProgramGroup.class\n+)\n+@BetaFeature\n+public class LocalAssembler extends PairWalker {\n+    public static final byte QMIN = 25;\n+    public static final int MIN_THIN_OBS = 4;\n+    public static final int MIN_GAPFILL_COUNT = 3;\n+    public static final int TOO_MANY_TRAVERSALS = 100000;\n+    public static final int TOO_MANY_SCAFFOLDS = 50000;\n+    public static final int MIN_SV_SIZE = 50;\n+\n+    @Argument(fullName=StandardArgumentDefinitions.OUTPUT_LONG_NAME,\n+            shortName=StandardArgumentDefinitions.OUTPUT_SHORT_NAME,\n+            doc=\"Write outputs to this file name prefix\", optional = true)\n+    public static String output;\n+\n+    @Argument(fullName=\"assembly-name\", doc=\"name of assembly used as a prefix for traversal names\")\n+    public static String assemblyName;\n+\n+    private final List<GATKRead> reads = new ArrayList<>();\n+\n+    @Override public boolean requiresIntervals() { return true; }\n+\n+    @Override public void apply( final GATKRead read, final GATKRead mate ) {\n+        trimOverruns(read, mate);\n+        reads.add(read);\n+        reads.add(mate);\n+    }\n+\n+    @Override public void applyUnpaired( final GATKRead read ) {\n+        reads.add(read);\n+    }\n+\n+    @Override public Object onTraversalSuccess() {\n+        super.onTraversalSuccess(); // flush any incomplete pairs\n+\n+        final int regionSize = getTraversalIntervals().stream().mapToInt(SimpleInterval::size).sum();\n+        final KmerSet<KmerAdjacency> kmerAdjacencySet = new KmerSet<>(10 * regionSize);\n+        kmerizeReads(reads, kmerAdjacencySet);\n+        List<ContigImpl> contigs = buildContigs(kmerAdjacencySet);\n+        connectContigs(contigs);\n+\n+        removeThinContigs(contigs, kmerAdjacencySet);\n+        weldPipes(contigs);\n+        markComponents(contigs);\n+\n+        if ( fillGaps(kmerAdjacencySet, reads) ) {\n+            contigs = buildContigs(kmerAdjacencySet);\n+            connectContigs(contigs);\n+            removeThinContigs(contigs, kmerAdjacencySet);\n+            weldPipes(contigs);\n+            markComponents(contigs);\n+        }\n+\n+        markCycles(contigs);\n+\n+        final String outputFilePrefix = output != null ? output : assemblyName;\n+        final List<Path> readPaths = pathReads(kmerAdjacencySet, reads);\n+        final Map<Contig,List<TransitPairCount>> contigTransitsMap =\n+                collectTransitPairCounts(contigs, readPaths);\n+        final String traversalsFilename = outputFilePrefix + \".traversals.fa.gz\";\n+        try {\n+            final List<Traversal> allTraversals =\n+                    new ArrayList<>(traverseAllPaths(contigs, readPaths, contigTransitsMap));\n+            writeTraversals(allTraversals, traversalsFilename);\n+            try {\n+                final String scaffoldsFileName = outputFilePrefix + \".scaffolds.fa.gz\";\n+                writeTraversals(createScaffolds(allTraversals), scaffoldsFileName);\n+            } catch ( final AssemblyTooComplexException x ) {\n+                logger.warn(\"Assembly too complex for scaffolding.\");\n+            }\n+        } catch ( final AssemblyTooComplexException x ) {\n+            logger.warn(\"Assembly too complex.  Writing contigs as traversals in \" +\n+                    traversalsFilename + \".\");\n+            final Collection<Traversal> contigTraversals = new ArrayList<>(contigs.size());\n+            for ( final Contig contig : contigs ) {\n+                contigTraversals.add(new Traversal(Collections.singletonList(contig)));\n+            }\n+            writeTraversals(contigTraversals, traversalsFilename);\n+        }\n+\n+        contigs.sort(Comparator.comparingInt(ContigImpl::getId));\n+        writeDOT(contigs, outputFilePrefix + \".assembly.dot\");\n+        writeContigs(contigs, outputFilePrefix + \".contigs.txt.gz\");\n+        writePaths(readPaths, outputFilePrefix + \".paths.txt.gz\");\n+        writeReads(reads, outputFilePrefix + \".reads.fastq.gz\");\n+        return null;\n+    }\n+\n+    /** trim read pairs of base calls that have gone past the end of a short fragment */\n+    private void trimOverruns( final GATKRead read, final GATKRead mate ) {\n+        // if both mapped and they're on different strands\n+        if ( !read.isUnmapped() && !mate.isUnmapped() &&\n+                read.isReverseStrand() != mate.isReverseStrand() ) {\n+            // and both start within 1 base on the ref\n+            if ( Math.abs(read.getStart() - read.getMateStart()) <= 1 ) {\n+                // and both end within 1 base\n+                final int readRefLen = read.getCigar().getReferenceLength();\n+                final int mateRefLen = mate.getCigar().getReferenceLength();\n+                if ( Math.abs(readRefLen - mateRefLen) <= 1 ) {\n+                    if ( mate.isReverseStrand() ) {\n+                        trimClips(read, mate);\n+                    } else {\n+                        trimClips(mate, read);\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    private void trimClips( final GATKRead fwd, final GATKRead rev ) {\n+        final List<CigarElement> fwdElements = fwd.getCigarElements();\n+        final List<CigarElement> revElements = rev.getCigarElements();\n+        final int lastElementIdx = fwdElements.size() - 1;\n+        final CigarElement fwdLastElement = fwdElements.get(lastElementIdx);\n+        final CigarElement revFirstElement = revElements.get(0);\n+        if ( fwdLastElement.getOperator() == CigarOperator.S &&\n+                revFirstElement.getOperator() == CigarOperator.S ) {\n+            final byte[] fwdBases = fwd.getBasesNoCopy();\n+            final int lastElementLen = fwdLastElement.getLength();\n+            fwd.setBases(Arrays.copyOfRange(fwdBases, 0, fwdBases.length - lastElementLen));\n+            final byte[] fwdQuals = fwd.getBaseQualitiesNoCopy();\n+            if ( fwdQuals.length > 0 ) {\n+                final int qualsLen = fwdQuals.length - lastElementLen;\n+                fwd.setBaseQualities(Arrays.copyOfRange(fwdQuals, 0, qualsLen));\n+            }\n+            final List<CigarElement> newFwdElements = new ArrayList<>(fwdElements);\n+            newFwdElements.set(lastElementIdx, new CigarElement(lastElementLen, CigarOperator.H));\n+            fwd.setCigar(new Cigar(newFwdElements));\n+\n+            final byte[] revBases = rev.getBasesNoCopy();\n+            final int firstElementLen = revFirstElement.getLength();\n+            rev.setBases(Arrays.copyOfRange(revBases, firstElementLen, revBases.length));\n+            final byte[] revQuals = rev.getBaseQualitiesNoCopy();\n+            if ( revQuals.length > 0 ) {\n+                rev.setBaseQualities(Arrays.copyOfRange(revQuals, firstElementLen, revQuals.length));\n+            }\n+            final List<CigarElement> newRevElements = new ArrayList<>(revElements);\n+            newRevElements.set(0, new CigarElement(firstElementLen, CigarOperator.H));\n+            rev.setCigar(new Cigar(newRevElements));\n+        }\n+    }\n+\n+    @VisibleForTesting\n+    static void kmerizeReads( final List<GATKRead> reads,\n+                              final KmerSet<KmerAdjacency> kmerAdjacencySet ) {\n+        for ( final GATKRead read : reads ) {\n+            final byte[] calls = read.getBasesNoCopy();\n+            final byte[] quals = read.getBaseQualitiesNoCopy();\n+            KmerAdjacency.kmerize(calls, quals, QMIN, kmerAdjacencySet);\n+        }\n+    }\n+\n+    /** gather unbranched strings of kmers into contigs **/\n+    @VisibleForTesting\n+    static List<ContigImpl> buildContigs( final KmerSet<KmerAdjacency> kmerAdjacencySet ) {\n+        // gather strings of kmers that have a single predecessor and single successor into contigs\n+        final List<ContigImpl> contigs = new ArrayList<>();\n+        int nContigs = 0;\n+        for ( final KmerAdjacency kmerAdjacency : kmerAdjacencySet ) {\n+            if ( kmerAdjacency.getContig() == null ) {\n+                ContigImpl contig = null;\n+                final KmerAdjacency predecessor = kmerAdjacency.getSolePredecessor();\n+                if ( predecessor == null ||\n+                        predecessor.getSuccessorCount() > 1 ||\n+                        predecessor == kmerAdjacency.rc() ) {\n+                    contig = new ContigImpl(++nContigs, kmerAdjacency);\n+                } else {\n+                    final KmerAdjacency successor = kmerAdjacency.getSoleSuccessor();\n+                    if ( successor == null ||\n+                            successor.getPredecessorCount() > 1 ||\n+                            successor == kmerAdjacency.rc() ) {\n+                        contig = new ContigImpl(++nContigs, kmerAdjacency.rc());\n+                    }\n+                }\n+                if ( contig != null ) {\n+                    contigs.add(contig);\n+                }\n+            }\n+        }\n+\n+        // if there are smooth circles like a plasmid, gather them together as a contig, too\n+        for ( final KmerAdjacency kmerAdjacency : kmerAdjacencySet ) {\n+            if ( kmerAdjacency.getContig() == null ) {\n+                contigs.add(new ContigImpl(++nContigs, kmerAdjacency));\n+            }\n+        }\n+\n+        return contigs;\n+    }\n+\n+    /** connect contigs when the final kmer of one contig is adjacent to the inital contig of another **/\n+    @VisibleForTesting\n+    static void connectContigs( final List<ContigImpl> contigs ) {\n+        final int nContigs = contigs.size();\n+        final KmerSet<ContigEndKmer> contigEnds = new KmerSet<>(2*nContigs);\n+        for ( int contigId = 0; contigId != nContigs; ++contigId ) {\n+            final ContigImpl contig = contigs.get(contigId);\n+            final KmerAdjacency fwdKmer = contig.getFirstKmer();\n+            final KmerAdjacency revKmer = contig.getLastKmer().rc();\n+            if ( fwdKmer == revKmer ) {\n+                contigEnds.add(new ContigEndKmer(fwdKmer.getKVal(), contig, ContigOrientation.BOTH));\n+            } else {\n+                contigEnds.add(new ContigEndKmer(fwdKmer.getKVal(), contig, ContigOrientation.FWD));\n+                contigEnds.add(new ContigEndKmer(revKmer.getKVal(), contig, ContigOrientation.REV));\n+            }\n+        }\n+\n+        for ( int contigId = 0; contigId != nContigs; ++contigId ) {\n+            final Contig contig = contigs.get(contigId);\n+\n+            final KmerAdjacency start = contig.getFirstKmer();\n+            final int predecessorCount = start.getPredecessorCount();\n+            if ( predecessorCount > 0 ) {\n+                final List<Contig> predecessors = contig.getPredecessors();\n+                final int mask = start.getPredecessorMask();\n+                for ( int call = 0; call != 4; ++call ) {\n+                    if ( (mask & (1 << call)) != 0 ) {\n+                        final long kVal =\n+                                KmerAdjacency.reverseComplement(start.getPredecessorVal(call));\n+                        final ContigEndKmer contigEndKmer = contigEnds.find(new Kmer(kVal));\n+                        if ( contigEndKmer == null ) {\n+                            throw new GATKException(\"missing contig end kmer\");\n+                        }\n+                        switch ( contigEndKmer.getContigOrientation() ) {\n+                            case FWD:\n+                                predecessors.add(contigEndKmer.getContig().rc());\n+                                break;\n+                            case REV:\n+                                predecessors.add(contigEndKmer.getContig());\n+                                break;\n+                            case BOTH:\n+                                predecessors.add(contigEndKmer.getContig());\n+                                predecessors.add(contigEndKmer.getContig().rc());\n+                                break;\n+                        }\n+                    }\n+                }\n+            }\n+\n+            final KmerAdjacency end = contig.getLastKmer();\n+            final int successorCount = end.getSuccessorCount();\n+            if ( successorCount > 0 ) {\n+                final List<Contig> successors = contig.getSuccessors();\n+                final int mask = end.getSuccessorMask();\n+                for ( int call = 0; call != 4; ++call ) {\n+                    if ( (mask & (1 << call)) != 0 ) {\n+                        final long kVal = end.getSuccessorVal(call);\n+                        final ContigEndKmer contigEndKmer = contigEnds.find(new Kmer(kVal));\n+                        if ( contigEndKmer == null ) {\n+                            throw new GATKException(\"missing contig end kmer\");\n+                        }\n+                        switch ( contigEndKmer.getContigOrientation() ) {\n+                            case FWD:\n+                                successors.add(contigEndKmer.getContig());\n+                                break;\n+                            case REV:\n+                                successors.add(contigEndKmer.getContig().rc());\n+                                break;\n+                            case BOTH:\n+                                successors.add(contigEndKmer.getContig());\n+                                successors.add(contigEndKmer.getContig().rc());\n+                                break;\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    /** remove contigs that have little evidence **/\n+    @VisibleForTesting\n+    static void removeThinContigs( final List<ContigImpl> contigs,\n+                                           final KmerSet<KmerAdjacency> kmerAdjacencySet ) {\n+        contigs.sort(Comparator.comparingInt(ContigImpl::getMaxObservations));\n+        boolean contigRemoved;\n+        do {\n+            // figure out which contigs are cut points\n+            // i.e., those contigs which, if removed, would result in a graph with more connected components\n+            final int nContigs = contigs.size();\n+            final Map<Contig, CutData> cutDataMap = new HashMap<>(nContigs * 3);\n+\n+            for ( final ContigImpl contig : contigs ) {\n+                if ( cutDataMap.containsKey(contig) ) {\n+                    continue;\n+                }\n+\n+                cutDataMap.put(contig, new CutData());\n+                int children = 0;\n+                for ( final Contig nextContig : contig.getSuccessors() ) {\n+                    if ( !cutDataMap.containsKey(nextContig) ) {\n+                        findCuts(nextContig, contig, cutDataMap);\n+                        children += 1;\n+                    }\n+                }\n+                for ( final Contig nextContig : contig.getPredecessors() ) {\n+                    if ( !cutDataMap.containsKey(nextContig) ) {\n+                        findCuts(nextContig, contig, cutDataMap);\n+                        children += 1;\n+                    }\n+                }\n+                if ( children >= 2 ) {\n+                    contig.setCut(true);\n+                }\n+            }\n+\n+            // remove poorly attested (low max observations) contigs, unless they are cut points\n+            contigRemoved = false;\n+            final Iterator<ContigImpl> itr = contigs.iterator();\n+            while ( itr.hasNext() ) {\n+                final Contig contig = itr.next();\n+                if ( contig.getMaxObservations() < MIN_THIN_OBS && !contig.isCut() ) {\n+                    unlinkContig(contig, kmerAdjacencySet);\n+                    itr.remove();\n+                    contigRemoved = true;\n+                    break;\n+                }\n+            }\n+        } while ( contigRemoved );\n+        contigs.sort(Comparator.comparingInt(ContigImpl::getId));\n+    }\n+\n+    private static CutData findCuts( final Contig contig,\n+                                     final Contig parent,\n+                                     final Map<Contig, CutData> cutDataMap ) {\n+        final CutData cutData = new CutData();\n+        cutDataMap.put(contig, cutData);\n+        for ( final Contig nextContig : contig.getSuccessors() ) {\n+            if ( nextContig == parent ) {\n+                continue;\n+            }\n+            CutData nextCutData = cutDataMap.get(nextContig);\n+            if ( nextCutData != null ) {\n+                cutData.minVisitNum = Math.min(cutData.minVisitNum, nextCutData.visitNum);\n+            } else {\n+                nextCutData = findCuts(nextContig, contig, cutDataMap);\n+                cutData.minVisitNum = Math.min(cutData.minVisitNum, nextCutData.minVisitNum);\n+                if ( nextCutData.minVisitNum >= cutData.visitNum ) {\n+                    contig.setCut(true);\n+                }\n+            }\n+        }\n+        for ( final Contig nextContig : contig.getPredecessors() ) {\n+            if ( nextContig == parent ) {\n+                continue;\n+            }\n+            CutData nextCutData = cutDataMap.get(nextContig);\n+            if ( nextCutData != null ) {\n+                cutData.minVisitNum = Math.min(cutData.minVisitNum, nextCutData.visitNum);\n+            } else {\n+                nextCutData = findCuts(nextContig, contig, cutDataMap);\n+                cutData.minVisitNum = Math.min(cutData.minVisitNum, nextCutData.minVisitNum);\n+                if ( nextCutData.minVisitNum >= cutData.visitNum ) {\n+                    contig.setCut(true);\n+                }\n+            }\n+        }\n+        return cutData;\n+    }\n+\n+    @VisibleForTesting\n+    static void unlinkContig( final Contig contig,\n+                                      final KmerSet<KmerAdjacency> kmerAdjacencySet ) {\n+        final KmerAdjacency firstKmer = contig.getFirstKmer();\n+        final int firstKmerFinalCall = firstKmer.getFinalCall();\n+        for ( final Contig predecessor : contig.getPredecessors() ) {\n+            if ( predecessor != contig && predecessor != contig.rc() ) {\n+                predecessor.getLastKmer().removeSuccessor(firstKmerFinalCall, kmerAdjacencySet);\n+                if ( !predecessor.getSuccessors().remove(contig) ) {\n+                    throw new GATKException(\"failed to find predecessor link\");\n+                }\n+            }\n+        }\n+\n+        final KmerAdjacency lastKmer = contig.getLastKmer();\n+        final int lastKmerInitialCall = lastKmer.getInitialCall();\n+        for ( final Contig successor : contig.getSuccessors() ) {\n+            if ( successor != contig && successor != contig.rc() ) {\n+                successor.getFirstKmer().removePredecessor(lastKmerInitialCall, kmerAdjacencySet);\n+                if ( !successor.getPredecessors().remove(contig) ) {\n+                    throw new GATKException(\"failed to find successor link\");\n+                }\n+            }\n+        }\n+\n+        KmerAdjacency nextKmer = firstKmer;\n+        KmerAdjacency kmer;\n+        do {\n+            kmer = nextKmer;\n+            nextKmer = kmer.getSoleSuccessor();\n+            kmerAdjacencySet.remove(kmer.canonical());\n+        } while ( kmer != lastKmer );\n+    }\n+\n+    private static void updateKmerContig( final KmerAdjacency firstKmer,\n+                                          final KmerAdjacency lastKmer,\n+                                          final Contig contig ) {\n+        int offset = 0;\n+        for ( KmerAdjacency kmer = firstKmer; kmer != lastKmer; kmer = kmer.getSoleSuccessor() ) {\n+            if ( kmer == null ) {\n+                throw new GATKException(\"contig does not have a flat pipeline of kmers\");\n+            }\n+            kmer.clearContig();\n+            kmer.setContigOffset(contig, offset++);\n+        }\n+        lastKmer.clearContig();\n+        lastKmer.setContigOffset(contig, offset);\n+        if ( offset + Kmer.KSIZE != contig.size() ) {\n+            throw new GATKException(\"kmer chain length does not equal contig size\");\n+        }\n+    }\n+\n+    /** replace adjacent contigs without branches with a single, larger contig **/\n+    @VisibleForTesting\n+    static void weldPipes( final List<ContigImpl> contigs ) {\n+        for ( int contigIdx = 0; contigIdx != contigs.size(); ++contigIdx ) {\n+            final ContigImpl contig = contigs.get(contigIdx);\n+            if ( contig.getSuccessors().size() == 1 ) {\n+                final Contig successor = contig.getSuccessors().get(0);\n+                if ( successor != contig && successor != contig.rc() &&\n+                        successor.getPredecessors().size() == 1 ) {\n+                    contigs.set(contigIdx, join(contig.getId(), contig, successor));\n+                    if ( !contigs.remove(successor.canonical()) ) {\n+                        throw new GATKException(\"successor linkage is messed up\");\n+                    }\n+                    contigIdx -= 1; // reconsider the new contig -- there might be more joining possible\n+                    continue;\n+                }\n+            }\n+            if ( contig.getPredecessors().size() == 1 ) {\n+                final Contig predecessor = contig.getPredecessors().get(0);\n+                if ( predecessor != contig && predecessor != contig.rc() &&\n+                        predecessor.getSuccessors().size() == 1 ) {\n+                    contigs.set(contigIdx, join(contig.getId(), predecessor, contig));\n+                    if ( !contigs.remove(predecessor.canonical()) ) {\n+                        throw new GATKException(\"predecessor linkage is messed up\");\n+                    }\n+                    contigIdx -= 1; // reconsider\n+                }\n+            }\n+        }\n+    }\n+\n+    private static ContigImpl join( final int id, final Contig predecessor, final Contig successor ) {\n+        if ( !checkOverlap(predecessor.getSequence(), successor.getSequence()) ) {\n+                throw new GATKException(\"sequences can't be joined\");\n+        }\n+        final ContigImpl joinedContig = new ContigImpl(id, predecessor, successor);\n+        updateKmerContig(joinedContig.getFirstKmer(), joinedContig.getLastKmer(), joinedContig);\n+        return joinedContig;\n+    }\n+\n+    private static boolean checkOverlap( final CharSequence seq1, final CharSequence seq2 ) {\n+        final int seq1Len = seq1.length();\n+        final CharSequence seq1SubSeq = seq1.subSequence(seq1Len - Kmer.KSIZE + 1, seq1Len);\n+        final CharSequence seq2SubSeq = seq2.subSequence(0, Kmer.KSIZE - 1);\n+        return seq1SubSeq.equals(seq2SubSeq);\n+    }\n+\n+    /** set a unique componentId for every connected group of contigs **/\n+    @VisibleForTesting\n+    static int markComponents( final List<ContigImpl> contigs ) {\n+        for ( final ContigImpl contig : contigs ) {\n+            contig.setComponentId(0);\n+        }\n+\n+        int componentId = 0;\n+        for ( final ContigImpl contig : contigs ) {\n+            if ( contig.getComponentId() == 0 ) {\n+                contig.setComponentId(++componentId);\n+                markSuccessorComponents(contig);\n+                markSuccessorComponents(contig.rc());\n+            }\n+        }\n+        return componentId;\n+    }\n+\n+    private static void markSuccessorComponents( final Contig contig ) {\n+        final int componentId = contig.getComponentId();\n+        for ( final Contig successor : contig.getSuccessors() ) {\n+            if ( successor.getComponentId() == 0 ) {\n+                successor.canonical().setComponentId(componentId);\n+                markSuccessorComponents(successor);\n+                markSuccessorComponents(successor.rc());\n+            }\n+        }\n+    }\n+\n+    @VisibleForTesting\n+    static void markCycles( final List<ContigImpl> contigs ) {\n+        for ( final Contig contig : contigs ) {\n+            contig.setCyclic(false);\n+        }\n+\n+        final int nContigs = contigs.size();\n+        final Deque<Contig> deque = new ArrayDeque<>(nContigs);\n+        final Map<Contig, CutData> cutDataMap = new HashMap<>(nContigs * 3);\n+        for ( final Contig contig : contigs ) {\n+            if ( !cutDataMap.containsKey(contig) ) {\n+                markCyclesRecursion(contig, deque, cutDataMap);\n+            }\n+        }\n+    }\n+\n+    private static CutData markCyclesRecursion( final Contig contig,\n+                                                final Deque<Contig> deque,\n+                                                final Map<Contig, CutData> cutDataMap ) {\n+        final CutData cutData = new CutData();\n+        cutDataMap.put(contig, cutData);\n+        deque.addFirst(contig);\n+\n+        for ( final Contig successor : contig.getSuccessors() ) {\n+            final CutData successorCutData = cutDataMap.get(successor);\n+            if ( successorCutData == null ) {\n+                final int recursionVisitNum =\n+                        markCyclesRecursion(successor, deque, cutDataMap).minVisitNum;\n+                cutData.minVisitNum = Math.min(cutData.minVisitNum, recursionVisitNum);\n+            } else {\n+                cutData.minVisitNum = Math.min(cutData.minVisitNum, successorCutData.visitNum);\n+            }\n+        }\n+\n+        if ( cutData.visitNum == cutData.minVisitNum ) {\n+            Contig tig = deque.removeFirst();\n+            if ( tig == contig ) {\n+                cutDataMap.get(tig).visitNum = Integer.MAX_VALUE;\n+\n+                // single-vertex component -- cyclic only if self-referential\n+                if ( tig.getSuccessors().contains(tig) ) {\n+                    tig.setCyclic(true);\n+                }\n+            } else {\n+                while ( true ) {\n+                    // kill cross-links\n+                    cutDataMap.get(tig).visitNum = Integer.MAX_VALUE;\n+                    tig.setCyclic(true);\n+                    if ( tig == contig ) break;\n+                    tig = deque.removeFirst();\n+                }\n+            }\n+        }\n+        return cutData;\n+    }\n+\n+    @VisibleForTesting\n+    static boolean fillGaps( final KmerSet<KmerAdjacency> kmerAdjacencySet,\n+                             final List<GATKRead> reads ) {\n+        final Map<String, Integer> gapFillCounts = new HashMap<>();\n+        for ( final GATKRead read : reads ) {\n+            final Path path = new Path(read.getBasesNoCopy(), kmerAdjacencySet);\n+            final List<PathPart> parts = path.getParts();\n+            final int lastIdx = parts.size() - 1;\n+            for ( int idx = 1; idx < lastIdx; ++idx ) {\n+                final PathPart pathPart = parts.get(idx);\n+                if ( pathPart.isGap() ) {\n+                    final char prevCall = parts.get(idx - 1).getLastCall();\n+                    final char nextCall = parts.get(idx + 1).getFirstCall();\n+                    String gapFill = prevCall + pathPart.getSequence().toString() + nextCall;\n+                    final SequenceRC gapFillRC = new SequenceRC(gapFill);\n+                    if ( gapFillRC.compareTo(gapFill) < 0 ) {\n+                        gapFill = gapFillRC.toString();\n+                    }\n+                    gapFillCounts.merge(gapFill, 1, Integer::sum);\n+                }\n+            }\n+        }\n+\n+        boolean newKmers = false;\n+        for ( final Map.Entry<String, Integer> entry : gapFillCounts.entrySet() ) {\n+            final int nObservations = entry.getValue();\n+            if ( nObservations >= MIN_GAPFILL_COUNT ) {\n+                KmerAdjacency.kmerize(entry.getKey(), nObservations, kmerAdjacencySet);\n+                newKmers = true;\n+            }\n+        }\n+\n+        if ( newKmers ) {\n+            for ( final KmerAdjacency kmerAdjacency : kmerAdjacencySet ) {\n+                kmerAdjacency.clearContig();\n+            }\n+        }\n+        return newKmers;\n+    }\n+\n+    @VisibleForTesting\n+    static List<Path> pathReads( final KmerSet<KmerAdjacency> kmerAdjacencySet,\n+                          final List<GATKRead> reads ) {\n+        final List<Path> readPaths = new ArrayList<>(reads.size());\n+        for ( final GATKRead read : reads ) {\n+            readPaths.add(new Path(read.getBasesNoCopy(), kmerAdjacencySet));\n+        }\n+        return readPaths;\n+    }\n+\n+    @VisibleForTesting\n+    static Map<Contig,List<TransitPairCount>> collectTransitPairCounts(\n+            final List<ContigImpl> contigs,\n+            final List<Path> readPaths ) {\n+        final Map<Contig,List<TransitPairCount>> contigTransitsMap =\n+                new HashMap<>(3 * contigs.size());\n+        for ( final Path path : readPaths ) {\n+            final List<PathPart> parts = path.getParts();\n+            final int lastPart = parts.size() - 1;\n+            for ( int partIdx = 1; partIdx < lastPart; ++partIdx ) {\n+                final Contig prevContig = parts.get(partIdx - 1).getContig();\n+                if ( prevContig == null ) continue;\n+                final Contig curContig = parts.get(partIdx).getContig();\n+                if ( curContig == null ) {\n+                    partIdx += 1;\n+                    continue;\n+                }\n+                final Contig nextContig = parts.get(partIdx + 1).getContig();\n+                if ( nextContig == null ) {\n+                    partIdx += 2;\n+                    continue;\n+                }\n+                final TransitPairCount tpc = new TransitPairCount(prevContig, nextContig);\n+                final List<TransitPairCount> tpcList =\n+                        contigTransitsMap.computeIfAbsent(curContig, tig -> new ArrayList<>(4));\n+                final int idx = tpcList.indexOf(tpc);\n+                if ( idx != -1 ) {\n+                    tpcList.get(idx).observe();\n+                } else {\n+                    tpcList.add(tpc);\n+                    contigTransitsMap.computeIfAbsent(curContig.rc(), tig -> new ArrayList<>(4))\n+                            .add(tpc.getRC());\n+                }\n+            }\n+        }\n+        return contigTransitsMap;\n+    }\n+\n+    @VisibleForTesting\n+    static Set<Traversal> traverseAllPaths(\n+            final List<ContigImpl> contigs,\n+            final List<Path> readPaths,\n+            final Map<Contig, List<TransitPairCount>> contigTransitsMap ) {\n+        final Set<Traversal> traversalSet = new HashSet<>();\n+        final List<Contig> contigsList = new ArrayList<>();\n+        for ( final Contig contig : contigs ) {\n+            // untransited contigs are sources, sinks, or large contigs that can't be crossed by a read\n+            // build traversals from these\n+            if ( !contigTransitsMap.containsKey(contig) ) {\n+                boolean done = false;\n+                for ( final Contig successor : contig.getSuccessors() ) {\n+                    traverse(successor, contig,\n+                            contigsList, readPaths, contigTransitsMap, traversalSet);\n+                    done = true;\n+                }\n+                for ( final Contig predecessor : contig.getPredecessors() ) {\n+                    traverse(predecessor.rc(), contig.rc(),\n+                            contigsList, readPaths, contigTransitsMap, traversalSet);\n+                    done = true;\n+                }\n+                if ( !done ) { // if there were no predecessors or successors, it stands alone\n+                    addTraversal(new Traversal(Collections.singletonList(contig)), traversalSet);\n+                }\n+            }\n+        }\n+\n+        // look for transits that haven't been traced\n+        for ( final Map.Entry<Contig, List<TransitPairCount>> entry :\n+                contigTransitsMap.entrySet() ) {\n+            for ( final TransitPairCount tpc : entry.getValue() ) {\n+                if ( tpc.getCount() > 0 ) {\n+                    tpc.resetCount();\n+                    final Contig contig = entry.getKey();\n+                    final Set<Traversal> fwdTraversalSet = new HashSet<>();\n+                    traverse(tpc.getNextContig(), contig,\n+                            contigsList, readPaths, contigTransitsMap, fwdTraversalSet);\n+                    final Set<Traversal> revTraversalSet = new HashSet<>();\n+                    traverse(tpc.getPrevContig().rc(), contig.rc(),\n+                            contigsList, readPaths, contigTransitsMap, revTraversalSet);\n+                    for ( final Traversal revTraversal : revTraversalSet ) {\n+                        final Traversal revTraversalRC = revTraversal.rc();\n+                        for ( final Traversal fwdTraversal : fwdTraversalSet ) {\n+                            final int overlap =\n+                                    findMaxOverlap(revTraversalRC.getContigs(), fwdTraversal.getContigs());\n+                            final Traversal combo =\n+                                    Traversal.combineOverlappers(revTraversalRC, fwdTraversal, overlap);\n+                            addTraversal(combo, traversalSet);\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+\n+        return traversalSet;\n+    }\n+\n+    private static int findMaxOverlap( final List<Contig> prefixes, final List<Contig> suffixes ) {\n+        final int nPrefixes = prefixes.size();\n+        final Contig firstSuffix = suffixes.get(0);\n+        if ( !firstSuffix.isCyclic() ) {\n+            return prefixes.get(nPrefixes - 1) == firstSuffix ? 1 : 0;\n+        }\n+        final int nSuffixes = suffixes.size();\n+        for ( int prefixIdx = Math.max(0, nPrefixes - nSuffixes); prefixIdx != nPrefixes; ++prefixIdx ) {\n+            if ( prefixes.get(prefixIdx) == firstSuffix ) {\n+                int suffixIdx = 1;\n+                boolean match = true;\n+                for ( int prefixIdx2 = prefixIdx + 1; prefixIdx2 != nPrefixes; ++prefixIdx2 ) {\n+                    if ( prefixes.get(prefixIdx2) != suffixes.get(suffixIdx++) ) {\n+                        match = false;\n+                        break;\n+                    }\n+                }\n+                if ( match ) {\n+                    return nPrefixes - prefixIdx;\n+                }\n+            }\n+        }\n+        return 0;\n+    }\n+\n+    private static void traverse( final Contig contig,\n+                                  final Contig predecessor,\n+                                  final List<Contig> contigsList,\n+                                  final List<Path> readPaths,\n+                                  final Map<Contig, List<TransitPairCount>> contigTransitsMap,\n+                                  final Set<Traversal> traversalSet ) {\n+        contigsList.add(predecessor);\n+        if ( contig.isCyclic() ) {\n+            traverseCycle(contig, contigsList, readPaths, contigTransitsMap, traversalSet);\n+            contigsList.remove(contigsList.size() - 1);\n+            return;\n+        }\n+        final List<TransitPairCount> transits = contigTransitsMap.get(contig);\n+        boolean done = false;\n+        if ( transits != null ) {\n+            for ( final TransitPairCount tpc : transits ) {\n+                if ( tpc.getPrevContig() == predecessor ) {\n+                    final Contig successor = tpc.getNextContig();\n+                    if ( predecessor == contig.rc() ) {\n+                        final int nContigs = contigsList.size();\n+                        if ( nContigs > 1 ) {\n+                            if ( successor.rc() == contigsList.get(nContigs - 2) ) {\n+                                continue;\n+                            }\n+                        }\n+                    }\n+                    tpc.resetCount();\n+                    traverse(successor, contig, contigsList, readPaths, contigTransitsMap, traversalSet);\n+                    done = true;\n+                }\n+            }\n+        }\n+        if ( !done ) {\n+            contigsList.add(contig);\n+            addTraversal(new Traversal(contigsList), traversalSet);\n+            contigsList.remove(contigsList.size() - 1);\n+        }\n+        contigsList.remove(contigsList.size() - 1);\n+    }\n+\n+    private static void traverseCycle( final Contig contig,\n+                                       final List<Contig> contigsList,\n+                                       final List<Path> readPaths,\n+                                       final Map<Contig, List<TransitPairCount>> contigTransitsMap,\n+                                       final Set<Traversal> traversalSet ) {\n+        contigsList.add(contig);\n+        final int nContigs = contigsList.size();\n+        // the final element of the list is cyclic, if there's a previous element it will be\n+        // non-cyclic, so start there figuring out how far the read paths lead us\n+        final List<List<Contig>> longestPaths =\n+                findLongestPaths(contigsList.subList(Math.max(0, nContigs - 2), nContigs), readPaths);\n+        // didn't get anywhere -- just complete the traversal\n+        if ( longestPaths.isEmpty() ) {\n+            addTraversal(new Traversal(contigsList, true), traversalSet);\n+        } else {\n+            // for each unique extension into the cycle\n+            for ( final List<Contig> path : longestPaths ) {\n+                // don't think this can happen, but still\n+                if ( path.isEmpty() ) {\n+                    addTraversal(new Traversal(contigsList, true), traversalSet);\n+                    continue;\n+                }\n+                final List<Contig> extendedContigsList =\n+                        new ArrayList<>(contigsList.size() + path.size());\n+                extendedContigsList.addAll(contigsList);\n+                // if we didn't get out of the cycle\n+                if ( path.get(path.size() - 1).isCyclic() ) {\n+                    extendedContigsList.addAll(path);\n+                    addTraversal(new Traversal(extendedContigsList, true), traversalSet);\n+                } else {\n+                    // we found a cycle-exiting path, so extend that normally\n+                    for ( final Contig curContig : path ) {\n+                        if ( curContig.isCyclic() ) {\n+                            extendedContigsList.add(curContig);\n+                        } else {\n+                            final Contig prevContig =\n+                                    extendedContigsList.remove(extendedContigsList.size() - 1);\n+                            traverse(curContig, prevContig, extendedContigsList, readPaths,\n+                                    contigTransitsMap, traversalSet);\n+                            extendedContigsList.add(prevContig);\n+                            break;\n+                        }\n+                    }\n+                }\n+                clearTransitPairs(contigTransitsMap, extendedContigsList);\n+            }\n+        }\n+        contigsList.remove(contigsList.size() - 1);\n+    }\n+\n+    private static void clearTransitPairs(\n+            final Map<Contig, List<TransitPairCount>> contigTransitsMap,\n+            final List<Contig> contigsList ) {\n+        final int lastIdx = contigsList.size() - 1;\n+        for ( int idx = 1; idx < lastIdx; ++idx ) {\n+            final List<TransitPairCount> pairCounts = contigTransitsMap.get(contigsList.get(idx));\n+            if ( pairCounts != null ) {\n+                final Contig predecessor = contigsList.get(idx - 1);\n+                final Contig successor = contigsList.get(idx + 1);\n+                for ( final TransitPairCount tpc : pairCounts ) {\n+                    if ( tpc.getPrevContig() == predecessor && tpc.getNextContig() == successor ) {\n+                        tpc.resetCount();\n+                        break;\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    private static void addTraversal( final Traversal traversal,\n+                                      final Set<Traversal> traversalSet ) {\n+        if ( !traversalSet.contains(traversal.rc()) ) {\n+            traversalSet.add(traversal);\n+            if ( traversalSet.size() >= TOO_MANY_TRAVERSALS ) {\n+                throw new AssemblyTooComplexException();\n+            }\n+        }\n+    }\n+\n+    private static List<List<Contig>> findLongestPaths( final List<Contig> toMatch,\n+                                                        final List<Path> readPaths ) {\n+        final List<List<Contig>> results = new ArrayList<>();\n+        for ( final Path path : readPaths ) {\n+            testPath(path, toMatch, results);\n+            testPath(path.rc(), toMatch, results);\n+        }\n+        return results;\n+    }\n+\n+    private static void testPath( final Path path,\n+                                  final List<Contig> toMatch,\n+                                  final List<List<Contig>> results ) {\n+        final List<PathPart> pathParts = path.getParts();\n+        final int nPathParts = pathParts.size();\n+        final List<Contig> pathContigs = new ArrayList<>(nPathParts);\n+        pathParts.forEach(pp -> pathContigs.add(pp.getContig()));\n+        final int matchIdx = Collections.indexOfSubList(pathContigs, toMatch);\n+        if ( matchIdx != -1 ) {\n+            final int suffixIdx = matchIdx + toMatch.size();\n+            if ( suffixIdx < nPathParts ) {\n+                resolveResult(grabParts(pathContigs, suffixIdx), results);\n+            }\n+        }\n+    }\n+\n+    private static List<Contig> grabParts( final List<Contig> pathContigs, final int suffixIdx ) {\n+        final int nPathContigs = pathContigs.size();\n+        Contig prev = pathContigs.get(suffixIdx - 1);\n+        final List<Contig> result = new ArrayList<>(nPathContigs - suffixIdx);\n+        for ( int idx = suffixIdx; idx != nPathContigs; ++idx ) {\n+            final Contig tig = pathContigs.get(idx);\n+            if ( tig == null || !prev.getSuccessors().contains(tig) ) break;\n+            result.add(tig);\n+            prev = tig;\n+        }\n+        return result;\n+    }\n+\n+    private static void resolveResult( final List<Contig> result,\n+                                       final List<List<Contig>> results ) {\n+        final int nResults = results.size();\n+        for ( int idx = 0; idx != nResults; ++idx ) {\n+            final List<Contig> test = results.get(idx);\n+            if ( isPrefix(result, test) ) return;\n+            if ( isPrefix(test, result) ) {\n+                results.set(idx, result);\n+                return;\n+            }\n+        }\n+        results.add(result);\n+    }\n+\n+    private static boolean isPrefix( final List<Contig> list1, final List<Contig> list2 ) {\n+        final int list1Size = list1.size();\n+        final int list2Size = list2.size();\n+        if ( list1Size > list2Size ) return false;\n+        for ( int idx = 0; idx != list1Size; ++idx ) {\n+            if ( list1.get(idx) != list2.get(idx) ) return false;\n+        }\n+        return true;\n+    }\n+\n+    @VisibleForTesting\n+    static Collection<Traversal> createScaffolds( final List<Traversal> allTraversals ) {\n+        removeTriviallyDifferentTraversals(allTraversals);\n+\n+        final int nTraversals = allTraversals.size();\n+        final Map<Contig, List<Integer>> traversalsByFirstContig = new HashMap<>(3 * nTraversals);\n+        for ( int idx = 0; idx != nTraversals; ++idx ) {\n+            final Traversal traversal = allTraversals.get(idx);\n+            traversalsByFirstContig.compute(traversal.getFirstContig(),\n+                    ( k, v ) -> v == null ? new ArrayList<>(3) : v).add(idx);\n+            final Traversal rcTraversal = traversal.rc();\n+            traversalsByFirstContig.compute(rcTraversal.getFirstContig(),\n+                    ( k, v ) -> v == null ? new ArrayList<>(3) : v).add(~idx);\n+        }\n+\n+        final List<Traversal> scaffolds = new ArrayList<>(nTraversals);\n+        final boolean[] touched = new boolean[nTraversals];\n+        for ( int idx = 0; idx != nTraversals; ++idx ) {\n+            if ( !touched[idx] ) {\n+                expandTraversal(idx, touched, traversalsByFirstContig, allTraversals, scaffolds);\n+            }\n+        }\n+        return scaffolds;\n+    }\n+\n+    private static void expandTraversal( final int traversalIdx,\n+                                         final boolean[] touched,\n+                                         final Map<Contig, List<Integer>> traversalsByFirstContig,\n+                                         final List<Traversal> allTraversals,\n+                                         final List<Traversal> scaffolds ) {\n+        final Traversal traversal = allTraversals.get(traversalIdx);\n+        touched[traversalIdx] = true;\n+        final List<Traversal> downExtensions = new ArrayList<>();\n+        final Set<Contig> startingContigSet = new HashSet<>();\n+        walkTraversals(traversal, touched, startingContigSet, traversalsByFirstContig,\n+                        allTraversals, downExtensions);\n+        final List<Traversal> upExtensions = new ArrayList<>();\n+        walkTraversals(traversal.rc(), touched, startingContigSet, traversalsByFirstContig,\n+                        allTraversals, upExtensions);\n+        for ( final Traversal down : downExtensions ) {\n+            for ( final Traversal up : upExtensions ) {\n+                if ( scaffolds.size() >= TOO_MANY_SCAFFOLDS ) {\n+                    throw new AssemblyTooComplexException();\n+                }\n+                scaffolds.add(Traversal.combineOverlappers(up.rc(), down, traversal.getContigs().size()));\n+            }\n+        }\n+    }\n+\n+    private static void walkTraversals( final Traversal traversal,\n+                                        final boolean[] touched,\n+                                        final Set<Contig> startingContigSet,\n+                                        final Map<Contig, List<Integer>> traversalsByFirstContig,\n+                                        final List<Traversal> allTraversals,\n+                                        final List<Traversal> extensions ) {\n+        final Contig firstContig = traversal.getFirstContig();\n+        final List<Integer> indexList;\n+        if ( startingContigSet.contains(firstContig) ||\n+                traversal.isInextensible() ||\n+                (indexList = traversalsByFirstContig.get(traversal.getLastContig())) == null ) {\n+            extensions.add(traversal);\n+            return;\n+        }\n+        startingContigSet.add(firstContig);\n+        for ( int idx : indexList ) {\n+            final Traversal extension;\n+            if ( idx >= 0 ) {\n+                extension = allTraversals.get(idx);\n+                touched[idx] = true;\n+            } else {\n+                final int rcIdx = ~idx;\n+                extension = allTraversals.get(rcIdx).rc();\n+                touched[rcIdx] = true;\n+            }\n+            walkTraversals(Traversal.combine(traversal, extension), touched, startingContigSet,\n+                            traversalsByFirstContig, allTraversals, extensions );\n+        }\n+        startingContigSet.remove(firstContig);\n+    }\n+\n+    private static void removeTriviallyDifferentTraversals(\n+                                            final Collection<Traversal> allTraversals ) {\n+        if ( allTraversals.isEmpty() ) {\n+            return;\n+        }\n+        final TreeSet<Traversal> sortedTraversals = new TreeSet<>(new TraversalEndpointComparator());\n+        for ( final Traversal traversal : allTraversals ) {\n+            sortedTraversals.add(traversal);\n+            sortedTraversals.add(traversal.rc());\n+        }\n+        final Iterator<Traversal> traversalIterator = sortedTraversals.iterator();\n+        Traversal prevTraversal = traversalIterator.next();\n+        while ( traversalIterator.hasNext() ) {\n+            final Traversal curTraversal = traversalIterator.next();\n+            if ( isTriviallyDifferent(prevTraversal, curTraversal) ) {\n+                traversalIterator.remove();\n+            } else {\n+                prevTraversal = curTraversal;\n+            }\n+        }\n+        sortedTraversals.removeIf(Traversal::isRC);\n+        allTraversals.clear();\n+        allTraversals.addAll(sortedTraversals);\n+    }\n+\n+    private static boolean isTriviallyDifferent( final Traversal traversal1,\n+                                                 final Traversal traversal2 ) {\n+        final Contig firstContig1 = traversal1.getFirstContig();\n+        final Contig lastContig1 = traversal1.getLastContig();\n+        final Contig firstContig2 = traversal2.getFirstContig();\n+        final Contig lastContig2 = traversal2.getLastContig();\n+        if ( firstContig1 != firstContig2 || lastContig1 != lastContig2 ) {\n+            return false;\n+        }\n+        final int interiorSize1 = traversal1.getSequenceLength() - firstContig1.size() - lastContig1.size();\n+        final int interiorSize2 = traversal2.getSequenceLength() - firstContig2.size() - lastContig2.size();\n+\n+        // if the path lengths are so different that one could harbor an SV, they're not trivially different\n+        if ( Math.abs(interiorSize1 - interiorSize2) >= MIN_SV_SIZE ) {\n+            return false;\n+        }\n+\n+        // if the paths are small enough that there can't be an SV's worth of differences, they're trivially different\n+        final int maxInteriorSize = Math.max(interiorSize1, interiorSize2);\n+        if ( maxInteriorSize < MIN_SV_SIZE ) {\n+            return true;\n+        }\n+\n+        // dang, maybe there's enough material in common that there can't be an SV's worth of differences\n+        // run a longest common subsequence algorithm to figure out the length of the common material\n+        // DP matrix holds length of common material\n+        final List<Contig> contigs1 = traversal1.getContigs();\n+        final int rowLen = contigs1.size() - 1;\n+        final int[][] rowPair = new int[2][];\n+        rowPair[0] = new int[rowLen];\n+        rowPair[1] = new int[rowLen];\n+        int pairIdx = 0;\n+        final List<Contig> contigs2 = traversal2.getContigs();\n+        final int nRows = contigs2.size() - 1;\n+        for ( int idx2 = 1; idx2 != nRows; ++idx2 ) {\n+            final int[] curRow = rowPair[pairIdx];\n+            final int[] prevRow = rowPair[pairIdx ^ 1];\n+            pairIdx ^= 1;\n+\n+            final int id2 = contigs2.get(idx2).getId();\n+            for ( int idx1 = 1; idx1 != rowLen; ++idx1 ) {\n+                final Contig tig1 = contigs1.get(idx1);\n+                if ( tig1.getId() == id2 ) {\n+                    // if the previous cells also contain a match we've already removed the K-1 bases upstream\n+                    final boolean extendMatch =\n+                            contigs1.get(idx1 -1).getId() == contigs2.get(idx2 - 1).getId();\n+                    curRow[idx1] = prevRow[idx1 - 1] + (extendMatch ? tig1.getNKmers() : tig1.size());\n+                } else {\n+                    curRow[idx1] = Math.max(curRow[idx1 - 1], prevRow[idx1]);\n+                }\n+            }\n+        }\n+        final int commonLen = rowPair[pairIdx ^ 1][rowLen - 1];\n+        return (maxInteriorSize - commonLen) < MIN_SV_SIZE;\n+    }\n+\n+    private static class TraversalEndpointComparator implements Comparator<Traversal> {\n+        @Override\n+        public int compare( final Traversal traversal1, final Traversal traversal2 ) {\n+            int cmp = Integer.compare(traversal1.contigs.get(0).getId(),\n+                                      traversal2.contigs.get(0).getId());\n+            if ( cmp != 0 ) {\n+                return cmp;\n+            }\n+            final int last1 = traversal1.contigs.size() - 1;\n+            final int last2 = traversal2.contigs.size() - 1;\n+            cmp = Integer.compare(traversal1.contigs.get(last1).getId(),\n+                                  traversal2.contigs.get(last2).getId());\n+            if ( cmp != 0 ) {\n+                return cmp;\n+            }\n+            // among those starting and ending at the same place, sort least observed last\n+            return -Integer.compare(traversal1.getMinMaxObservations(), traversal2.getMinMaxObservations());\n+        }\n+    }\n+\n+    private static void writeDOT( final List<ContigImpl> contigs, final String fileName ) {\n+        try ( final BufferedWriter writer = new BufferedWriter(new FileWriter(fileName)) ) {\n+            writer.write(\"digraph {\\n\");\n+            for ( final Contig contig : contigs ) {\n+                final double width = contig.getSequence().length() / 100.;\n+                writer.write(contig + \" [width=\" + width + \"]\\n\");\n+                writer.write( contig.rc() + \" [width=\" + width + \"]\\n\");\n+            }\n+            for ( final Contig contig : contigs ) {\n+                for ( final Contig predecessor : contig.getPredecessors() ) {\n+                    final String predecessorName = predecessor.rc().toString();\n+                    writer.write(contig.rc() + \" -> \" + predecessorName + \"\\n\");\n+                }\n+                for ( final Contig successor : contig.getSuccessors() ) {\n+                    final String successorName = successor.toString();\n+                    writer.write(contig + \" -> \" + successorName + \"\\n\");\n+                }\n+            }\n+            writer.write(\"}\\n\");\n+        } catch ( final IOException ioe ) {\n+            throw new GATKException(\"Failed to write assembly DOT file.\", ioe);\n+        }\n+    }\n+\n+    private static BufferedWriter makeGZFile( final String fileName ) throws IOException {\n+        final GZIPOutputStream gzOS = new GZIPOutputStream(BucketUtils.createFile(fileName));\n+        return new BufferedWriter(new OutputStreamWriter(gzOS));\n+    }\n+\n+    private static void writeContigs( final List<ContigImpl> contigs, final String fileName ) {\n+        try ( final BufferedWriter writer = makeGZFile(fileName) ) {\n+            for ( final Contig contig : contigs ) {\n+                final List<Contig> predecessors = contig.getPredecessors();\n+                final String predecessorDescription;\n+                if ( predecessors.size() == 0 ) {\n+                    predecessorDescription = \"\\tnone\";\n+                } else {\n+                    final StringBuilder sb = new StringBuilder();\n+                    char prefix = '\\t';\n+                    for ( final Contig predecessor : predecessors ) {\n+                        sb.append(prefix);\n+                        prefix = ',';\n+                        sb.append(predecessor);\n+                    }\n+                    predecessorDescription = sb.toString();\n+                }\n+\n+                final List<Contig> successors = contig.getSuccessors();\n+                final String successorDescription;\n+                if ( successors.size() == 0 ) {\n+                    successorDescription = \"\\tnone\";\n+                } else {\n+                    final StringBuilder sb = new StringBuilder();\n+                    char prefix = '\\t';\n+                    for ( final Contig successor : successors ) {\n+                        sb.append(prefix);\n+                        prefix = ',';\n+                        sb.append(successor);\n+                    }\n+                    successorDescription = sb.toString();\n+                }\n+\n+                final String contigName = contig.toString();\n+                final String component =\n+                        (contig.isCyclic() ? \"(C)\\t\" : \"\\t\") + contig.getComponentId();\n+                writer.write(contigName + component + predecessorDescription +\n+                        successorDescription + \"\\t\" +\n+                        contig.getMaxObservations() + \"\\t\" +\n+                        contig.getFirstKmer().getNObservations() + \"\\t\" +\n+                        contig.getLastKmer().getNObservations() + \"\\t\" +\n+                        contig.size() + \"\\t\" +\n+                        contig.getSequence() + \"\\n\");\n+            }\n+        } catch ( final IOException ioe ) {\n+            throw new GATKException(\"Failed to write contigs file.\", ioe);\n+        }\n+    }\n+\n+    private static void writePaths( final List<Path> readPaths, final String fileName ) {\n+        try ( final BufferedWriter writer = makeGZFile(fileName) ) {\n+            final int nReads = readPaths.size();\n+            for ( int readId = 0; readId != nReads; ++readId ) {\n+                final Path path = readPaths.get(readId);\n+                final String pathDesc = path.toString();\n+                writer.write((readId + 1) + \": \" + pathDesc + \"\\n\");\n+            }\n+        } catch ( final IOException ioe ) {\n+            throw new GATKException(\"Failed to write paths file.\", ioe);\n+        }\n+    }\n+\n+    private static void writeReads( final List<GATKRead> reads, final String fileName ) {\n+        try ( final BufferedWriter writer = makeGZFile(fileName) ) {\n+            for ( final GATKRead read : reads ) {\n+                writer.write(\"@\" + read.getName());\n+                writer.write('\\n');\n+                writer.write(new String(read.getBasesNoCopy()));\n+                writer.write(\"\\n+\\n\");\n+                final byte[] quals = read.getBaseQualitiesNoCopy();\n+                final int nQuals = quals.length;\n+                final byte[] fastqQuals = new byte[nQuals];\n+                for ( int idx = 0; idx != nQuals; ++idx ) {\n+                    fastqQuals[idx] = (byte)SAMUtils.phredToFastq(quals[idx]);\n+                }\n+                writer.write(new String(fastqQuals));\n+                writer.write('\\n');\n+            }\n+        } catch ( final IOException ioe ) {\n+            throw new GATKException(\"Failed to write assembly sam file.\", ioe);\n+        }\n+    }\n+\n+    private static void writeTraversals( final Collection<Traversal> traversals,\n+                                         final String fileName ) {\n+        try ( final BufferedWriter writer = makeGZFile(fileName) ) {\n+            int traversalNo = 0;\n+            for ( final Traversal traversal : traversals ) {\n+                writer.write(\">\");\n+                if ( assemblyName != null ) {\n+                    writer.write(assemblyName);\n+                    writer.write(\"_\");\n+                }\n+                writer.write(\"t\");\n+                writer.write(Integer.toString(++traversalNo));\n+                writer.write(\" \");\n+                writer.write(traversal.getName());\n+                writer.newLine();\n+                writer.write(traversal.getSequence());\n+                writer.newLine();\n+            }\n+        } catch ( final IOException ioe ) {\n+            throw new GATKException(\"Failed to write assembly sam file.\", ioe);\n+        }\n+    }\n+\n+    /** fixed-size, immutable kmer.  usual 2-bit encoding: ACGT->0123.  low order bits are final call. **/\n+    public static class Kmer {\n+        public static final int KSIZE = 31; // must be odd number less than 32\n+        public static final long KMASK = (1L << 2*KSIZE) - 1L;\n+        private final long kVal;\n+\n+        public Kmer( final long kVal ) { this.kVal = kVal; }\n+\n+        public long getKVal() { return kVal; }\n+        public boolean isCanonical() { return isCanonical(kVal); }\n+        public int getInitialCall() { return (int)(kVal >> (KSIZE*2 - 2)) & 3; }\n+        public int getFinalCall() { return (int)kVal & 3; }\n+\n+        public long getPredecessorVal( final int call ) {\n+            return (kVal >> 2) | ((long)call << (2 * (KSIZE - 1)));\n+        }\n+        public long getSuccessorVal( final int call ) { return ((kVal << 2) & KMASK) | call; }\n+\n+        public static boolean isCanonical( final long val ) {\n+            return (val & (1L << KSIZE)) == 0L;\n+        }\n+\n+        @Override public boolean equals( final Object obj ) {\n+            return obj instanceof Kmer && kVal == ((Kmer)obj).kVal;\n+        }\n+\n+        @Override public int hashCode() {\n+            return (int)(kVal ^ (kVal >>> 32));\n+        }\n+    }\n+\n+    /** Set of Kmers.  Uses HopscotchSet, customized to find correct starting bin for Kmers and derivatives. **/\n+    public static final class KmerSet<KMER extends Kmer> extends HopscotchSet<KMER> {\n+        public KmerSet( final int capacity ) { super(capacity); }\n+\n+        @Override\n+        protected int hashToIndex( final Object kmer ) {\n+            return (int)(((HopscotchSet.SPREADER * ((Kmer)kmer).getKVal()) & Long.MAX_VALUE) % capacity());\n+        }\n+    }\n+\n+    /**\n+     *  A Kmer that remembers its predecessors and successors, and the number of times it's been observed\n+     *  in the assembly's input set of reads.\n+     *  The masks are bit-wise (1=A, 2=C, 4=G, 8=T) to show which predecessors or successors have been observed.\n+     *  The Kmer's position on a Contig is also tracked (in later phases of the assembly process).\n+     **/\n+    public static abstract class KmerAdjacency extends Kmer {\n+        public KmerAdjacency( final long kVal ) { super(kVal); }\n+\n+        public abstract KmerAdjacency getSolePredecessor(); // returns null if there's 0 or >1 predecessors\n+        public abstract int getPredecessorMask();\n+        public abstract int getPredecessorCount();\n+        public abstract void removePredecessor( final int callToRemove,\n+                                                final KmerSet<KmerAdjacency> kmerAdjacencySet );\n+\n+        public abstract KmerAdjacency getSoleSuccessor(); // returns null if there's 0 or > 1 successors\n+        public abstract int getSuccessorMask();\n+        public abstract int getSuccessorCount();\n+        public abstract void removeSuccessor( final int callToRemove,\n+                                              final KmerSet<KmerAdjacency> kmerAdjacencySet );\n+\n+        public abstract Contig getContig();\n+        public abstract int getContigOffset();\n+        // offset is 0-based measure on the contig sequence of the beginning of the kmer\n+        public abstract void setContigOffset( final Contig contig, final int contigOffset );\n+        public abstract void clearContig();\n+\n+        public abstract int getNObservations();\n+        public abstract KmerAdjacency rc();\n+        public abstract KmerAdjacencyImpl canonical();\n+\n+        public void observe( final KmerAdjacency predecessor, final KmerAdjacency successor ) {\n+            observe(predecessor, successor, 1);\n+        }\n+\n+        public abstract void observe( final KmerAdjacency predecessor,\n+                                      final KmerAdjacency successor,\n+                                      final int count );\n+\n+        @Override public String toString() {\n+            final StringBuilder sb = new StringBuilder(KSIZE);\n+            long currentVal = getKVal();\n+            for ( int idx = 0; idx != KSIZE; ++idx ) {\n+                sb.append(\"ACGT\".charAt((int)currentVal & 3));\n+                currentVal >>= 2;\n+            }\n+            sb.reverse(); // low order bits were loaded into sb first:  fix that now by reversing the sb.\n+            return sb.toString();\n+        }\n+\n+        /**\n+         * Transform a read's calls into KmerAdjacencies, and add them to a KmerSet.\n+         * Skip kmers that include a call with a quality < qMin.\n+         * Skip kmers with non-ACGT calls.\n+         **/\n+        public static void kmerize( final byte[] calls,\n+                                    final byte[] quals,\n+                                    final byte qMin,\n+                                    final KmerSet<KmerAdjacency> kmerAdjacencySet ) {\n+            int currentCount = 0; // number of calls loaded into currentKVal\n+            long currentKVal = 0;\n+            KmerAdjacency prevAdjacency = null;\n+            KmerAdjacency currentAdjacency = null;\n+            for ( int idx = 0; idx < calls.length; ++idx ) {\n+                if ( quals[idx] < qMin ) { // if we encounter a low-quality call\n+                    // take care of the most recent valid KmerAdjacency, if any\n+                    if ( currentAdjacency != null ) {\n+                        currentAdjacency.observe(prevAdjacency, null);\n+                    }\n+                    // ready ourselves to accumulate calls afresh\n+                    currentCount = 0;\n+                    currentAdjacency = prevAdjacency = null;\n+                    continue;\n+                }\n+                currentKVal <<= 2;\n+                switch ( calls[idx] ) {\n+                    case 'A': case 'a': break;\n+                    case 'C': case 'c': currentKVal += 1; break;\n+                    case 'G': case 'g': currentKVal += 2; break;\n+                    case 'T': case 't': currentKVal += 3; break;\n+                    default:\n+                        if ( currentAdjacency != null ) {\n+                            currentAdjacency.observe(prevAdjacency, null);\n+                        }\n+                        currentCount = 0;\n+                        currentAdjacency = prevAdjacency = null;\n+                        continue;\n+                }\n+                if ( ++currentCount >= KSIZE ) { // if we've loaded enough calls to make a complete kmer\n+                    final KmerAdjacency nextAdjacency = findOrAdd(currentKVal, kmerAdjacencySet);\n+                    if ( currentAdjacency != null ) {\n+                        currentAdjacency.observe(prevAdjacency, nextAdjacency);\n+                    }\n+                    prevAdjacency = currentAdjacency;\n+                    currentAdjacency = nextAdjacency;\n+                }\n+            }\n+            if ( currentAdjacency != null ) {\n+                currentAdjacency.observe(prevAdjacency, null);\n+            }\n+        }\n+\n+        /**\n+         * Kmerize a String.  This version is for gap fills.\n+         * The number of observations applies to all kmers except the 1st and last.\n+         **/\n+        public static void kmerize( final String sequence,\n+                                    final int nObservations,\n+                                    final KmerSet<KmerAdjacency> kmerAdjacencySet ) {\n+            int currentCount = 0;\n+            long currentKVal = 0;\n+            int nObs = 0;\n+            KmerAdjacency prevAdjacency = null;\n+            KmerAdjacency currentAdjacency = null;\n+            final int nCalls = sequence.length();\n+            for ( int idx = 0; idx != nCalls; ++idx ) {\n+                currentKVal <<= 2;\n+                switch ( sequence.charAt(idx) ) {\n+                    case 'A': case 'a': break;\n+                    case 'C': case 'c': currentKVal += 1; break;\n+                    case 'G': case 'g': currentKVal += 2; break;\n+                    case 'T': case 't': currentKVal += 3; break;\n+                    default: throw new GATKException(\"unexpected base call in string to kmerize.\");\n+                }\n+                if ( ++currentCount >= KSIZE ) {\n+                    final KmerAdjacency nextAdjacency = findOrAdd(currentKVal, kmerAdjacencySet);\n+                    if ( currentAdjacency != null ) {\n+                        currentAdjacency.observe(prevAdjacency, nextAdjacency, nObs);\n+                        nObs = nObservations;\n+                    }\n+                    prevAdjacency = currentAdjacency;\n+                    currentAdjacency = nextAdjacency;\n+                }\n+            }\n+            if ( currentAdjacency != null ) {\n+                currentAdjacency.observe(prevAdjacency, null, 0);\n+            }\n+        }\n+\n+        // Lookup table for reverse-complementing each possible byte value.\n+        // Each pair of bits represents a base, so you have to reverse bits pairwise and then invert all bits.\n+        // This is most quickly and easily done with a lookup table.\n+        private static final long[] BYTEWISE_REVERSE_COMPLEMENT;\n+        static {\n+            BYTEWISE_REVERSE_COMPLEMENT = new long[256];\n+            for ( int bIn = 0; bIn != 256; ++bIn ) {\n+                BYTEWISE_REVERSE_COMPLEMENT[bIn] =\n+                        ~(((bIn & 3) << 6) | (((bIn >> 2) & 3) << 4) |\n+                                (((bIn >> 4) & 3) << 2) | ((bIn >> 6) & 3)) & 0xffL;\n+            }\n+        }\n+\n+        public static long reverseComplement( long val ) {\n+            // process val one byte at a time\n+            long result = BYTEWISE_REVERSE_COMPLEMENT[(int)val & 0xFF]; // handle the low-order byte\n+            int nBytes = 8;\n+            while ( --nBytes != 0 ) { // pre-decrementing:  we'll go through the loop 7 times\n+                // rotate down by a byte\n+                val >>= 8;\n+                // rotate up by a byte and OR in the reverse complement of the next byte\n+                result = (result << 8) | BYTEWISE_REVERSE_COMPLEMENT[(int)val & 0xFF];\n+            }\n+            return result >>> (Long.SIZE - 2*KSIZE);\n+        }\n+\n+        // Kmer lookup in KmerSet.\n+        // KmerSets holding KmerAdjacencies have only canonical Kmers, so RC non-canonical kmers before lookup.\n+        public static KmerAdjacency find( final long kVal,\n+                                          final KmerSet<KmerAdjacency> kmerAdjacencySet ) {\n+            if ( isCanonical(kVal) ) return kmerAdjacencySet.find(new Kmer(kVal & KMASK));\n+            final KmerAdjacency result = kmerAdjacencySet.find(new Kmer(reverseComplement(kVal)));\n+            return result == null ? null : result.rc();\n+        }\n+\n+        // Kmer lookup in KmerSet.\n+        // KmerSets holding KmerAdjacencies have only canonical Kmers, so RC non-canonical kmers before lookup.\n+        // Add missing Kmers.\n+        public static KmerAdjacency findOrAdd( final long kVal,\n+                                               final KmerSet<KmerAdjacency> kmerAdjacencySet ) {\n+            if ( isCanonical(kVal) ) {\n+                return kmerAdjacencySet.findOrAdd(new Kmer(kVal & KMASK), kmer ->\n+                        new KmerAdjacencyImpl(((Kmer)kmer).getKVal()));\n+            }\n+            return kmerAdjacencySet.findOrAdd(new Kmer(reverseComplement(kVal)), kmer ->\n+                    new KmerAdjacencyImpl(((Kmer)kmer).getKVal())).rc();\n+        }\n+    }\n+\n+    /**\n+     * Class to implement KmerAdjacency for canonical Kmers.\n+     * In particular, a KmerSet created on KmerAdjacency contains only canonical Kmers.\n+     **/\n+    public static final class KmerAdjacencyImpl extends KmerAdjacency {\n+        private KmerAdjacency solePredecessor; // set to null if there are no predecessors, or multiple predecessors\n+        private KmerAdjacency soleSuccessor; // set to null if there are no successors, or multiple successors\n+        private int predecessorMask; // bit mask of observed kmers preceding this one\n+        private int successorMask; // bit mask observed kmers following this one\n+        private Contig contig; // the contig that contains this Kmer\n+        private int contigOffset; // the offset within the contig where this kmer is found\n+        private int nObservations; // the reads in which this kmer was observed\n+        private final KmerAdjacencyRC rc; // the reverse-complement of this kmer\n+        private static final int[] COUNT_FOR_MASK =\n+                //side sum for binary values from 0 -> 15\n+                //0000  0001 0010 0011 0100 0101 0110 0111 1000 1001 1010 1011 1100 1101 1110 1111\n+                {    0,    1,   1,   2,   1,   2,   2,   3,   1,   2,   2,   3,   2,   3,   3,   4 };\n+\n+        public KmerAdjacencyImpl( final long kVal ) {\n+            super(kVal);\n+            this.rc = new KmerAdjacencyRC(this);\n+        }\n+\n+        @Override public KmerAdjacency getSolePredecessor() { return solePredecessor; } // may return null\n+        @Override public int getPredecessorMask() { return predecessorMask; }\n+        @Override public int getPredecessorCount() { return COUNT_FOR_MASK[predecessorMask]; }\n+        @Override\n+        public void removePredecessor( final int callToRemove,\n+                                       final KmerSet<KmerAdjacency> kmerAdjacencySet ) {\n+            predecessorMask &= ~(1 << callToRemove);\n+            solePredecessor = null;\n+            if ( getPredecessorCount() == 1 ) {\n+                for ( int call = 0; call != 4; ++call ) {\n+                    if ( ((1 << call) & predecessorMask) != 0 ) {\n+                        solePredecessor = find(getPredecessorVal(call), kmerAdjacencySet);\n+                        break;\n+                    }\n+                }\n+            }\n+        }\n+\n+        @Override public KmerAdjacency getSoleSuccessor() { return soleSuccessor; } // may return null\n+        @Override public int getSuccessorMask() { return successorMask; }\n+        @Override public int getSuccessorCount() { return COUNT_FOR_MASK[successorMask]; }\n+        @Override\n+        public void removeSuccessor( final int callToRemove,\n+                                     final KmerSet<KmerAdjacency> kmerAdjacencySet ) {\n+            successorMask &= ~(1 << callToRemove);\n+            soleSuccessor = null;\n+            if ( getSuccessorCount() == 1 ) {\n+                for ( int call = 0; call != 4; ++call ) {\n+                    if ( ((1 << call) & successorMask) != 0 ) {\n+                        soleSuccessor = find(getSuccessorVal(call), kmerAdjacencySet);\n+                        break;\n+                    }\n+                }\n+            }\n+        }\n+\n+        @Override public Contig getContig() { return contig; }\n+        @Override public int getContigOffset() { return contigOffset; }\n+        @Override public void setContigOffset( final Contig contig, final int contigOffset ) {\n+            if ( this.contig != null ) {\n+                throw new GATKException(\"Internal error: overwriting kmer contig and offset.\");\n+            }\n+            this.contig = contig;\n+            this.contigOffset = contigOffset;\n+        }\n+        @Override public void clearContig() { contig = null; contigOffset = 0; }\n+\n+        @Override public int getNObservations() { return nObservations; }\n+        @Override public KmerAdjacency rc() { return rc; }\n+        @Override public KmerAdjacencyImpl canonical() { return this; }\n+\n+        @Override public void observe( final KmerAdjacency predecessor,\n+                                       final KmerAdjacency successor,\n+                                       final int count ) {\n+            if ( predecessor != null ) {\n+                if ( predecessor.getSuccessorVal(getFinalCall()) != getKVal() ) {\n+                    throw new GATKException(\"illegal predecessor\");\n+                }\n+                final int initialCall = predecessor.getInitialCall();\n+                final int newPredecessorMask = 1 << initialCall;\n+                if ( (newPredecessorMask & predecessorMask) == 0 ) {\n+                    if ( predecessorMask == 0 ) {\n+                        solePredecessor = predecessor;\n+                        predecessorMask = newPredecessorMask;\n+                    } else {\n+                        solePredecessor = null;\n+                        predecessorMask |= newPredecessorMask;\n+                    }\n+                }\n+            }\n+            if ( successor != null ) {\n+                if ( successor.getPredecessorVal(getInitialCall()) != getKVal() ) {\n+                    throw new GATKException(\"illegal successor\");\n+                }\n+                final int finalCall = successor.getFinalCall();\n+                final int newSuccessorMask = 1 << finalCall;\n+                if ( (newSuccessorMask & successorMask) == 0 ) {\n+                    if ( successorMask == 0 ) {\n+                        soleSuccessor = successor;\n+                        successorMask = newSuccessorMask;\n+                    } else {\n+                        soleSuccessor = null;\n+                        successorMask |= newSuccessorMask;\n+                    }\n+                }\n+            }\n+            nObservations += count;\n+        }\n+    }\n+\n+    /**\n+     * Class to implement KmerAdjacency for Kmers that are the reverse-complement of a canonical Kmer.\n+     * In particular, a KmerSet created on KmerAdjacency contains only canonical Kmers.\n+     * A KmerAdjacencyRC represents the RC of each Kmer in the KmerSet.\n+     **/\n+    public static final class KmerAdjacencyRC extends KmerAdjacency {\n+        private final KmerAdjacencyImpl rc;\n+\n+        // lookup table to bit-reverse nibbles\n+        private static final int[] NIBREV =\n+                // 0000,  0001,  0010,  0011,  0100,  0101,  0110,  0111,  1000,  1001,  1010,  1011,  1100,  1101,  1110,  1111\n+                {0b0000,0b1000,0b0100,0b1100,0b0010,0b1010,0b0110,0b1110,0b0001,0b1001,0b0101,0b1101,0b0011,0b1011,0b0111,0b1111};\n+\n+        public KmerAdjacencyRC( final KmerAdjacencyImpl rc ) {\n+            super(reverseComplement(rc.getKVal()));\n+            this.rc = rc;\n+        }\n+\n+        @Override public KmerAdjacency getSolePredecessor() {\n+            final KmerAdjacency successor = rc.getSoleSuccessor();\n+            return successor == null ? null : successor.rc();\n+        }\n+        @Override public int getPredecessorMask() { return NIBREV[rc.getSuccessorMask()]; }\n+        @Override public int getPredecessorCount() { return rc.getSuccessorCount(); }\n+        @Override\n+        public void removePredecessor( final int callToRemove,\n+                                       final KmerSet<KmerAdjacency> kmerAdjacencySet ) {\n+            rc.removeSuccessor(3 - callToRemove, kmerAdjacencySet);\n+        }\n+\n+        @Override public KmerAdjacency getSoleSuccessor() {\n+            final KmerAdjacency predecessor = rc.getSolePredecessor();\n+            return predecessor == null ? null : predecessor.rc();\n+        }\n+        @Override public int getSuccessorMask() { return NIBREV[rc.getPredecessorMask()]; }\n+        @Override public int getSuccessorCount() { return rc.getPredecessorCount(); }\n+        @Override\n+        public void removeSuccessor( final int callToRemove,\n+                                     final KmerSet<KmerAdjacency> kmerAdjacencySet ) {\n+            rc.removePredecessor(3 - callToRemove, kmerAdjacencySet);\n+        }\n+\n+        @Override public Contig getContig() {\n+            final Contig contig = rc.getContig();\n+            return contig == null ? null : contig.rc();\n+        }\n+        @Override public int getContigOffset() {\n+            final Contig contig = rc.getContig();\n+            return contig == null ? 0 : contig.size() - rc.getContigOffset() - KSIZE;\n+        }\n+        @Override public void setContigOffset( final Contig contig, final int contigOffset ) {\n+            rc.setContigOffset(contig.rc(), contig.size() - contigOffset - KSIZE);\n+        }\n+        @Override public void clearContig() { rc.clearContig(); }\n+\n+        @Override public int getNObservations() { return rc.getNObservations(); }\n+        @Override public KmerAdjacency rc() { return rc; }\n+        @Override public KmerAdjacencyImpl canonical() { return rc; }\n+\n+        @Override public void observe( final KmerAdjacency predecessor,\n+                                       final KmerAdjacency successor,\n+                                       final int count ) {\n+            rc.observe(successor == null ? null : successor.rc(),\n+                    predecessor == null ? null : predecessor.rc(),\n+                    count);\n+        }\n+    }\n+\n+    public enum ContigOrientation {\n+        FWD, // k-mer appears at the 5' end of the contig\n+        REV, // k-mer appears at the 5' end of the reverse-complemented contig\n+        BOTH // k-mer occurs on 5' end of the contig and its RC (can happen when the contig is a palindrome)\n+    }\n+\n+    /** Initial or final Kmer in a Contig. **/\n+    public static final class ContigEndKmer extends Kmer {\n+        private final Contig contig;\n+        private final ContigOrientation contigOrientation;\n+\n+        public ContigEndKmer( final long kVal,\n+                              final Contig contig,\n+                              final ContigOrientation contigEnd ) {\n+            super(kVal);\n+            this.contig = contig;\n+            this.contigOrientation = contigEnd;\n+        }\n+\n+        public Contig getContig() { return contig; }\n+        public ContigOrientation getContigOrientation() { return contigOrientation; }\n+    }\n+\n+    /**\n+     * An unbranched sequence of Kmers.\n+     * Each Kmer (except the last one) has a single successor, which allows enumerating the sequence\n+     * of Kmers in the Contig.  The sequence of base calls in the Contig is just the sequence of kmers\n+     * with the K-1 overlapping calls removed from adjacent kmers.\n+     **/\n+    public interface Contig {\n+        int getId();\n+        CharSequence getSequence();\n+        int getMaxObservations();\n+        KmerAdjacency getFirstKmer();\n+        KmerAdjacency getLastKmer();\n+        List<Contig> getPredecessors();\n+        List<Contig> getSuccessors();\n+        int getComponentId();\n+        int size();\n+        default int getNKmers() { return size() - Kmer.KSIZE + 1; }\n+        Contig rc();\n+        boolean isCyclic();\n+        void setCyclic( final boolean cyclic );\n+        boolean isCut();\n+        void setCut( final boolean cut );\n+        boolean isCanonical();\n+        ContigImpl canonical();\n+    }\n+\n+    /** Simple implementation of Contig interface. **/\n+    public static final class ContigImpl implements Contig {\n+        private final int id;\n+        private final CharSequence sequence;\n+        private final int maxObservations;\n+        private final KmerAdjacency firstKmer;\n+        private final KmerAdjacency lastKmer;\n+        private final List<Contig> predecessors;\n+        private final List<Contig> successors;\n+        private int componentId;\n+        private boolean cyclic;\n+        private boolean cut;\n+        private final Contig rc;\n+\n+        public ContigImpl( final int id, final KmerAdjacency firstKmerAdjacency ) {\n+            this.id = id;\n+            final StringBuilder sb = new StringBuilder(firstKmerAdjacency.toString());\n+            int maxObservations = firstKmerAdjacency.getNObservations();\n+            KmerAdjacency lastKmerAdjacency = firstKmerAdjacency;\n+            for ( KmerAdjacency kmerAdjacency = firstKmerAdjacency.getSoleSuccessor();\n+                  kmerAdjacency != null;\n+                  kmerAdjacency = kmerAdjacency.getSoleSuccessor() ) {\n+                // if we've gone around a circle, or if we're branching backwards, or if we hit a palindrome u-turn\n+                if ( firstKmerAdjacency == kmerAdjacency ||\n+                        kmerAdjacency.getPredecessorCount() != 1 ||\n+                        kmerAdjacency == lastKmerAdjacency.rc() ) {\n+                    break;\n+                }\n+                sb.append(\"ACGT\".charAt(kmerAdjacency.getFinalCall()));\n+                maxObservations = Math.max(maxObservations, kmerAdjacency.getNObservations());\n+                lastKmerAdjacency = kmerAdjacency;\n+            }\n+            this.sequence = sb.toString();\n+            this.maxObservations = maxObservations;\n+            this.firstKmer = firstKmerAdjacency;\n+            this.lastKmer = lastKmerAdjacency;\n+            this.predecessors = new ArrayList<>(firstKmer.getPredecessorCount());\n+            this.successors = new ArrayList<>(lastKmer.getSuccessorCount());\n+            this.rc = new ContigRCImpl(this);\n+\n+            int offset = 0;\n+            for ( KmerAdjacency kmerAdjacency = firstKmerAdjacency;\n+                  kmerAdjacency != lastKmerAdjacency;\n+                  kmerAdjacency = kmerAdjacency.getSoleSuccessor() ) {\n+                kmerAdjacency.setContigOffset(this, offset++);\n+            }\n+            lastKmerAdjacency.setContigOffset(this, offset);\n+        }\n+\n+        // create a new contig by joining two contigs\n+        public ContigImpl( final int id, final Contig predecessor, final Contig successor ) {\n+            if ( predecessor == successor || predecessor == successor.rc() ) {\n+                throw new GATKException(\"can't self-join\");\n+            }\n+            this.id = id;\n+            final StringBuilder sb = new StringBuilder(predecessor.getSequence());\n+            final CharSequence successorSequence = successor.getSequence();\n+            sb.append(successorSequence.subSequence(Kmer.KSIZE - 1, successorSequence.length()));\n+            this.sequence = sb.toString();\n+            this.maxObservations =\n+                    Math.max(predecessor.getMaxObservations(), successor.getMaxObservations());\n+            this.firstKmer = predecessor.getFirstKmer();\n+            this.lastKmer = successor.getLastKmer();\n+            this.predecessors = new ArrayList<>(predecessor.getPredecessors().size());\n+            this.successors = new ArrayList<>(successor.getSuccessors().size());\n+            this.rc = new ContigRCImpl(this);\n+\n+            // fix predecessor linkages to point to new contig\n+            for ( final Contig predPredecessor : predecessor.getPredecessors() ) {\n+                if ( predPredecessor == successor ) {\n+                    predecessors.add(this);\n+                } else if ( predPredecessor == predecessor.rc() ) {\n+                    predecessors.add(rc);\n+                } else {\n+                    predecessors.add(predPredecessor);\n+                    final List<Contig> successors = predPredecessor.getSuccessors();\n+                    successors.set(successors.indexOf(predecessor), this);\n+                }\n+            }\n+\n+            // fix successor linkages to point to new contig\n+            for ( final Contig succSuccessor : successor.getSuccessors() ) {\n+                if ( succSuccessor == predecessor ) {\n+                    successors.add(this);\n+                } else if ( succSuccessor == successor.rc() ) {\n+                    successors.add(rc);\n+                } else {\n+                    successors.add(succSuccessor);\n+                    final List<Contig> predecessors = succSuccessor.getPredecessors();\n+                    predecessors.set(predecessors.indexOf(successor), this);\n+                }\n+            }\n+        }\n+\n+        @Override public int getId() { return id; }\n+        @Override public CharSequence getSequence() { return sequence; }\n+        @Override public int getMaxObservations() { return maxObservations; }\n+        @Override public KmerAdjacency getFirstKmer() { return firstKmer; }\n+        @Override public KmerAdjacency getLastKmer() { return lastKmer; }\n+        @Override public List<Contig> getPredecessors() { return predecessors; }\n+        @Override public List<Contig> getSuccessors() { return successors; }\n+        @Override public int getComponentId() { return componentId; }\n+        public void setComponentId( final int id ) { this.componentId = id; }\n+        @Override public int size() { return sequence.length(); }\n+        @Override public Contig rc() { return rc; }\n+        @Override public boolean isCyclic() { return cyclic; }\n+        @Override public void setCyclic( final boolean cyclic ) { this.cyclic = cyclic; }\n+        @Override public boolean isCut() { return cut; }\n+        @Override public void setCut( final boolean cut ) { this.cut = cut; }\n+        @Override public boolean isCanonical() { return true; }\n+        @Override public ContigImpl canonical() { return this; }\n+        @Override public String toString() { return \"c\" + id; }\n+    }\n+\n+    /**\n+     * Implementation of Contig for the reverse-complement of some other Contig.\n+     * Which one is the \"real\" Contig, and which is the \"RC\" is completely arbitrary, since there\n+     * is no notion of canonical for Contigs.\n+     **/\n+    public static final class ContigRCImpl implements Contig {\n+        private final CharSequence sequence;\n+        private final List<Contig> predecessors;\n+        private final List<Contig> successors;\n+        private final ContigImpl rc;\n+\n+        public ContigRCImpl( final ContigImpl contig ) {\n+            this.sequence = new SequenceRC(contig.getSequence());\n+            this.predecessors = new ContigListRC(contig.getSuccessors());\n+            this.successors = new ContigListRC(contig.getPredecessors());\n+            this.rc = contig;\n+        }\n+\n+        @Override public int getId() { return ~rc.getId(); }\n+        @Override public CharSequence getSequence() { return sequence; }\n+        @Override public int getMaxObservations() { return rc.getMaxObservations(); }\n+        @Override public KmerAdjacency getFirstKmer() { return rc.getLastKmer().rc(); }\n+        @Override public KmerAdjacency getLastKmer() { return rc.getFirstKmer().rc(); }\n+        @Override public List<Contig> getPredecessors() { return predecessors; }\n+        @Override public List<Contig> getSuccessors() { return successors; }\n+        @Override public int getComponentId() { return rc.getComponentId(); }\n+        @Override public int size() { return sequence.length(); }\n+        @Override public Contig rc() { return rc; }\n+        @Override public boolean isCyclic() { return rc.isCyclic(); }\n+        @Override public void setCyclic( final boolean cyclic ) { rc.setCyclic(cyclic); }\n+        @Override public boolean isCut() { return rc.isCut(); }\n+        @Override public void setCut( final boolean cut ) { rc.setCut(cut); }\n+        @Override public boolean isCanonical() { return false; }\n+        @Override public ContigImpl canonical() { return rc; }\n+        @Override public String toString() { return rc.toString() + \"RC\"; }\n+    }\n+\n+    /** A CharSequence that is a view of the reverse-complement of another sequence. **/\n+    public static final class SequenceRC implements CharSequence, Comparable<CharSequence> {\n+        private final int lenLess1;\n+        private final CharSequence sequence;\n+\n+        public SequenceRC( final CharSequence sequence ) {\n+            this.lenLess1 = sequence.length() - 1;\n+            this.sequence = sequence;\n+        }\n+\n+        @Override public int length() { return sequence.length(); }\n+        @Override public char charAt( final int index ) {\n+            final char result;\n+            switch ( Character.toUpperCase(sequence.charAt(lenLess1 - index)) ) {\n+                case 'A': result = 'T'; break;\n+                case 'C': result = 'G'; break;\n+                case 'G': result = 'C'; break;\n+                case 'T': result = 'A'; break;\n+                default: result = 'N'; break;\n+            }\n+            return result;\n+        }\n+        @Override public CharSequence subSequence( final int start, final int end ) {\n+            return new StringBuilder(end - start).append(this, start, end).toString();\n+        }\n+        @Override public String toString() { return new StringBuilder(this).toString(); }\n+\n+        @Override public int compareTo( final CharSequence charSequence ) {\n+            final int len1 = length();\n+            final int len2 = charSequence.length();\n+            final int cmpLen = Math.min(len1, len2);\n+            for ( int idx = 0; idx != cmpLen; ++idx ) {\n+                final char char1 = charAt(idx);\n+                final char char2 = Character.toUpperCase(charSequence.charAt(idx));\n+                if ( char1 > char2 ) return 1;\n+                if ( char1 < char2 ) return -1;\n+            }\n+            return Integer.compare(len1, len2);\n+        }\n+    }\n+\n+    /** A list of Contigs that presents a reverse-complemented view of a List of Contigs. **/\n+    public static final class ContigListRC extends AbstractList<Contig> {\n+        private final List<Contig> contigList;\n+\n+        public ContigListRC( final List<Contig> contigList ) {\n+            this.contigList = contigList;\n+        }\n+\n+        @Override public Contig get( final int index ) {\n+            return contigList.get(reflectIndex(index)).rc();\n+        }\n+        @Override public int size() { return contigList.size(); }\n+        @Override public Contig set( final int index, final Contig contig ) {\n+            return contigList.set(reflectIndex(index), contig.rc()).rc();\n+        }\n+        @Override public void add( final int index, final Contig contig ) {\n+            contigList.add(reflectIndex(index), contig.rc());\n+        }\n+        @Override public Contig remove( final int index ) {\n+            return contigList.remove(reflectIndex(index)).rc();\n+        }\n+\n+        private int reflectIndex( final int index ) { return size() - 1 - index; }\n+    }\n+\n+    /** A single-Contig portion of a path across the assembly graph. **/\n+    public interface PathPart {\n+        Contig getContig(); // will be null for PathParts that depart from the graph (PathPartGap)\n+        CharSequence getSequence(); // will be null for PathParts on the graph (PathPartContig)\n+        void extend( final char call );\n+        int getStart();\n+        int getStop();\n+        boolean isGap();\n+        int getLength();\n+        PathPart rc();\n+        char getFirstCall();\n+        char getLastCall();\n+        default boolean startsAtBeginning() { return getStart() == 0; }\n+        default boolean stopsAtEnd() { return getStop() + Kmer.KSIZE - 1 == getContig().size(); }\n+    }\n+\n+    /** A part of a path that isn't present in the graph. **/\n+    public static final class PathPartGap implements PathPart {\n+        private final StringBuilder sequence = new StringBuilder();\n+\n+        public PathPartGap( final KmerAdjacency kmer ) { sequence.append(kmer.toString()); }\n+        private PathPartGap( final CharSequence sequence ) { this.sequence.append(sequence); }\n+\n+        @Override public Contig getContig() { return null; }\n+        @Override public CharSequence getSequence() { return sequence.toString(); }\n+        @Override public void extend( final char call ) { sequence.append(call); }\n+        @Override public int getStart() { return 0; }\n+        @Override public int getStop() { return sequence.length(); }\n+        @Override public boolean isGap() { return true; }\n+        @Override public int getLength() { return sequence.length() - Kmer.KSIZE + 1; }\n+        @Override public PathPart rc() { return new PathPartGap(new SequenceRC(sequence)); }\n+        @Override public char getFirstCall() { return sequence.charAt(Kmer.KSIZE - 1); }\n+        @Override public char getLastCall() {\n+            return sequence.charAt(sequence.length() - Kmer.KSIZE + 1);\n+        }\n+    }\n+\n+    /** A part of a path that is present as a sub-sequence of some Contig. **/\n+    public static final class PathPartContig implements PathPart {\n+        private final Contig contig;\n+        private final int start;\n+        private int stop;\n+\n+        public PathPartContig( final Contig contig, final int start ) {\n+            this(contig, start, start+1);\n+        }\n+        public PathPartContig( final Contig contig, final int start, final int stop ) {\n+            this.contig = contig;\n+            this.start = start;\n+            this.stop = stop;\n+        }\n+\n+        @Override public Contig getContig() { return contig; }\n+        @Override public String getSequence() { return null; }\n+        @Override public void extend( final char call ) { stop += 1; }\n+        @Override public int getStart() { return start; }\n+        @Override public int getStop() { return stop; }\n+        @Override public boolean isGap() { return false; }\n+        @Override public int getLength() { return stop - start; }\n+        @Override public PathPart rc() {\n+            final int revBase = contig.size() - Kmer.KSIZE + 1;\n+            return new PathPartContig(contig.rc(), revBase - stop, revBase - start);\n+        }\n+        @Override public char getFirstCall() {\n+            return getContig().getSequence().charAt(start + Kmer.KSIZE - 1);\n+        }\n+        @Override public char getLastCall() { return getContig().getSequence().charAt(stop - 1); }\n+    }\n+\n+    /** A path through the assembly graph for something (probably a read). **/\n+    public static final class Path {\n+        private final List<PathPart> parts;\n+\n+        public Path( final byte[] calls,\n+                     final KmerSet<KmerAdjacency> kmerAdjacencySet ) {\n+            parts = new ArrayList<>();\n+            long kVal = 0;\n+            int count = 0;\n+            PathPart currentPathPart = null;\n+            for ( int idx = 0; idx != calls.length; ++idx ) {\n+                final char call = (char)calls[idx];\n+                kVal <<= 2;\n+                switch ( call ) {\n+                    case 'C': case 'c': kVal += 1; break;\n+                    case 'G': case 'g': kVal += 2; break;\n+                    case 'T': case 't': kVal += 3; break;\n+                }\n+                if ( ++count >= Kmer.KSIZE ) {\n+                    final KmerAdjacency kmer = KmerAdjacencyImpl.find(kVal, kmerAdjacencySet);\n+                    // if we fail to look up the kmer\n+                    if ( kmer == null ) {\n+                        if ( currentPathPart == null ) {\n+                            // if there's no current path part, just create the 1st one as a PathPartGap\n+                            currentPathPart = new PathPartGap(new KmerAdjacencyImpl(kVal));\n+                            parts.add(currentPathPart);\n+                        } else if ( currentPathPart.isGap() ) {\n+                            // if the current path part is a PathPartGap, just extend it\n+                            currentPathPart.extend(call);\n+                        } else {\n+                            // new PathPartGap\n+                            currentPathPart = new PathPartGap(new KmerAdjacencyImpl(kVal));\n+                            parts.add(currentPathPart);\n+                        }\n+                    } else {\n+                        // we've found our kmer\n+                        final Contig contig = kmer.getContig();\n+                        if ( currentPathPart == null ) {\n+                            // we've looked up a kmer, but don't have a current path part -- create one\n+                            currentPathPart = new PathPartContig(contig, kmer.getContigOffset());\n+                            parts.add(currentPathPart);\n+                        } else if ( contig == currentPathPart.getContig() ) {\n+                            // our lookup is on the current path part's contig -- extend it\n+                            final int kmerOffset = kmer.getContigOffset();\n+                            final int curStop = currentPathPart.getStop();\n+                            if ( kmerOffset == curStop ) {\n+                                currentPathPart.extend(call);\n+                            } else if ( kmerOffset == 0 && contig.getNKmers() == curStop ) {\n+                                // cycle onto same contig\n+                                currentPathPart = new PathPartContig(contig, 0);\n+                                parts.add(currentPathPart);\n+                            } else {\n+                                // weird:  kmer is non-contiguous.  start a new path part after a zero-length gap\n+                                parts.add(zeroLengthGap(currentPathPart));\n+                                currentPathPart = new PathPartContig(contig, kmerOffset);\n+                                parts.add(currentPathPart);\n+                            }\n+                        } else {\n+                            final int kmerContigOffset = kmer.getContigOffset();\n+                            if ( currentPathPart.isGap() ) {\n+                                // squash captured gaps caused by single-base sequencing errors\n+                                final int gapLen = currentPathPart.getLength();\n+                                if ( gapLen == Kmer.KSIZE ) {\n+                                    final int prevPartIdx = parts.size() - 2;\n+                                    if ( prevPartIdx >= 0 ) {\n+                                        final PathPart prevPart = parts.get(prevPartIdx);\n+                                        final Contig prevPartContig = prevPart.getContig();\n+                                        final int prevPartStart = prevPart.getStart();\n+                                        final int prevPartStop = prevPart.getStop();\n+                                        final int prevPartMaxStop =\n+                                                prevPartContig.size() - Kmer.KSIZE + 1;\n+                                        final int newStop = kmerContigOffset + 1;\n+                                        if ( prevPartContig == kmer.getContig() ) {\n+                                            if ( kmerContigOffset - prevPartStop == gapLen ) {\n+                                                currentPathPart =\n+                                                        new PathPartContig(prevPartContig, prevPartStart, newStop);\n+                                                parts.set(prevPartIdx, currentPathPart);\n+                                                parts.remove(prevPartIdx + 1);\n+                                                continue;\n+                                            }\n+                                        } else if ( prevPartMaxStop - prevPartStop + kmerContigOffset == gapLen ) {\n+                                            parts.set(prevPartIdx,\n+                                                    new PathPartContig(prevPartContig, prevPartStart, prevPartMaxStop));\n+                                            currentPathPart = new PathPartContig(kmer.getContig(), 0, newStop);\n+                                            parts.set(prevPartIdx + 1, currentPathPart);\n+                                            continue;\n+                                        }\n+                                    }\n+                                }\n+                            } else if ( !currentPathPart.stopsAtEnd() || kmerContigOffset != 0 ) {\n+                                // not an end-to-end join across contigs -- record a zero-length gap\n+                                parts.add(zeroLengthGap(currentPathPart));\n+                            }\n+                            // we're jumping to a new contig.  start a new path part\n+                            currentPathPart = new PathPartContig(contig, kmerContigOffset);\n+                            parts.add(currentPathPart);\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+\n+        private static PathPart zeroLengthGap( final PathPart currentPathPart ) {\n+            final int currentStop = currentPathPart.getStop();\n+            final CharSequence currentSequence = currentPathPart.getContig().getSequence();\n+            final CharSequence almostAKmer =\n+                    currentSequence.subSequence(currentStop, currentStop + Kmer.KSIZE - 1);\n+            return new PathPartGap(almostAKmer);\n+        }\n+\n+        // RCing constructor\n+        private Path( final Path that ) {\n+            final List<PathPart> thoseParts = that.parts;\n+            final int nParts = thoseParts.size();\n+            parts = new ArrayList<>(nParts);\n+            for ( int idx = nParts - 1; idx >= 0; --idx ) {\n+                parts.add(thoseParts.get(idx).rc());\n+            }\n+        }\n+\n+        public List<PathPart> getParts() { return parts; }\n+        public Path rc() { return new Path(this); }\n+\n+        @Override public String toString() {\n+            if ( parts.size() == 0 ) return \"\";\n+            final StringBuilder sb = new StringBuilder();\n+            String prefix = \"\";\n+            final PathPart firstPart = parts.get(0);\n+            final PathPart lastPart = parts.get(parts.size() - 1);\n+            for ( final PathPart pp : parts ) {\n+                sb.append(prefix);\n+                prefix = \", \";\n+                if ( pp.isGap() ) {\n+                    sb.append(\"NoKmer(\").append(pp.getLength()).append(\")\");\n+                } else {\n+                    final Contig contig = pp.getContig();\n+                    sb.append(contig);\n+                    final int maxStop = contig.size() - Kmer.KSIZE + 1;\n+                    if ( (pp != firstPart && pp.getStart() != 0) ||\n+                         (pp != lastPart && pp.getStop() != maxStop) ) {\n+                        sb.append('(').append(pp.getStart()).append('-')\n+                                .append(pp.getStop()).append('/').append(maxStop).append(')');\n+                    }\n+                }\n+            }\n+            return sb.toString();\n+        }\n+    }\n+\n+    /** Per-Contig storage for articulation points (cut vertices) algorithm. **/\n+    public static final class CutData {\n+        public static int nextNum;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e2201c1ef4f8ba71f17e169f07756cfe2f1ecb49"}, "originalPosition": 2142}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzczNjUyMDU3OnYy", "diffSide": "RIGHT", "path": "src/main/java/org/broadinstitute/hellbender/tools/LocalAssembler.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMy0xMFQxODo1NTo0MlrOI0Xy4g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNC0xMlQyMDo0ODo0NFrOJHmHCA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MTc4NjcyMg==", "bodyText": "If the kmer graph has a circle that firstKmer is part of but lastKmer is not, will this infinite loop? I'm sure there's some reason this will never happen; not sure it's worth guarding against explicitly (I guess by checking each kmer in this loop to make sure it's not equal to firstKmer.)", "url": "https://github.com/broadinstitute/gatk/pull/6989#discussion_r591786722", "createdAt": "2021-03-10T18:55:42Z", "author": {"login": "cwhelan"}, "path": "src/main/java/org/broadinstitute/hellbender/tools/LocalAssembler.java", "diffHunk": "@@ -0,0 +1,2306 @@\n+package org.broadinstitute.hellbender.tools;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import htsjdk.samtools.Cigar;\n+import htsjdk.samtools.CigarElement;\n+import htsjdk.samtools.CigarOperator;\n+import htsjdk.samtools.SAMUtils;\n+import org.broadinstitute.barclay.argparser.Argument;\n+import org.broadinstitute.barclay.argparser.BetaFeature;\n+import org.broadinstitute.barclay.argparser.CommandLineProgramProperties;\n+import org.broadinstitute.barclay.help.DocumentedFeature;\n+import org.broadinstitute.hellbender.cmdline.StandardArgumentDefinitions;\n+import org.broadinstitute.hellbender.cmdline.programgroups.CoverageAnalysisProgramGroup;\n+import org.broadinstitute.hellbender.exceptions.GATKException;\n+import org.broadinstitute.hellbender.tools.walkers.PairWalker;\n+import org.broadinstitute.hellbender.utils.SimpleInterval;\n+import org.broadinstitute.hellbender.utils.collections.HopscotchSet;\n+import org.broadinstitute.hellbender.utils.gcs.BucketUtils;\n+import org.broadinstitute.hellbender.utils.read.GATKRead;\n+\n+import java.io.BufferedWriter;\n+import java.io.FileWriter;\n+import java.io.IOException;\n+import java.io.OutputStreamWriter;\n+import java.util.*;\n+import java.util.zip.GZIPOutputStream;\n+\n+@DocumentedFeature\n+@CommandLineProgramProperties(\n+        summary = \"experiment\",\n+        oneLineSummary = \"experiment\",\n+        usageExample = \"gatk LocalAssembler\",\n+        programGroup = CoverageAnalysisProgramGroup.class\n+)\n+@BetaFeature\n+public class LocalAssembler extends PairWalker {\n+    public static final byte QMIN = 25;\n+    public static final int MIN_THIN_OBS = 4;\n+    public static final int MIN_GAPFILL_COUNT = 3;\n+    public static final int TOO_MANY_TRAVERSALS = 100000;\n+    public static final int TOO_MANY_SCAFFOLDS = 50000;\n+    public static final int MIN_SV_SIZE = 50;\n+\n+    @Argument(fullName=StandardArgumentDefinitions.OUTPUT_LONG_NAME,\n+            shortName=StandardArgumentDefinitions.OUTPUT_SHORT_NAME,\n+            doc=\"Write outputs to this file name prefix\", optional = true)\n+    public static String output;\n+\n+    @Argument(fullName=\"assembly-name\", doc=\"name of assembly used as a prefix for traversal names\")\n+    public static String assemblyName;\n+\n+    private final List<GATKRead> reads = new ArrayList<>();\n+\n+    @Override public boolean requiresIntervals() { return true; }\n+\n+    @Override public void apply( final GATKRead read, final GATKRead mate ) {\n+        trimOverruns(read, mate);\n+        reads.add(read);\n+        reads.add(mate);\n+    }\n+\n+    @Override public void applyUnpaired( final GATKRead read ) {\n+        reads.add(read);\n+    }\n+\n+    @Override public Object onTraversalSuccess() {\n+        super.onTraversalSuccess(); // flush any incomplete pairs\n+\n+        final int regionSize = getTraversalIntervals().stream().mapToInt(SimpleInterval::size).sum();\n+        final KmerSet<KmerAdjacency> kmerAdjacencySet = new KmerSet<>(10 * regionSize);\n+        kmerizeReads(reads, kmerAdjacencySet);\n+        List<ContigImpl> contigs = buildContigs(kmerAdjacencySet);\n+        connectContigs(contigs);\n+\n+        removeThinContigs(contigs, kmerAdjacencySet);\n+        weldPipes(contigs);\n+        markComponents(contigs);\n+\n+        if ( fillGaps(kmerAdjacencySet, reads) ) {\n+            contigs = buildContigs(kmerAdjacencySet);\n+            connectContigs(contigs);\n+            removeThinContigs(contigs, kmerAdjacencySet);\n+            weldPipes(contigs);\n+            markComponents(contigs);\n+        }\n+\n+        markCycles(contigs);\n+\n+        final String outputFilePrefix = output != null ? output : assemblyName;\n+        final List<Path> readPaths = pathReads(kmerAdjacencySet, reads);\n+        final Map<Contig,List<TransitPairCount>> contigTransitsMap =\n+                collectTransitPairCounts(contigs, readPaths);\n+        final String traversalsFilename = outputFilePrefix + \".traversals.fa.gz\";\n+        try {\n+            final List<Traversal> allTraversals =\n+                    new ArrayList<>(traverseAllPaths(contigs, readPaths, contigTransitsMap));\n+            writeTraversals(allTraversals, traversalsFilename);\n+            try {\n+                final String scaffoldsFileName = outputFilePrefix + \".scaffolds.fa.gz\";\n+                writeTraversals(createScaffolds(allTraversals), scaffoldsFileName);\n+            } catch ( final AssemblyTooComplexException x ) {\n+                logger.warn(\"Assembly too complex for scaffolding.\");\n+            }\n+        } catch ( final AssemblyTooComplexException x ) {\n+            logger.warn(\"Assembly too complex.  Writing contigs as traversals in \" +\n+                    traversalsFilename + \".\");\n+            final Collection<Traversal> contigTraversals = new ArrayList<>(contigs.size());\n+            for ( final Contig contig : contigs ) {\n+                contigTraversals.add(new Traversal(Collections.singletonList(contig)));\n+            }\n+            writeTraversals(contigTraversals, traversalsFilename);\n+        }\n+\n+        contigs.sort(Comparator.comparingInt(ContigImpl::getId));\n+        writeDOT(contigs, outputFilePrefix + \".assembly.dot\");\n+        writeContigs(contigs, outputFilePrefix + \".contigs.txt.gz\");\n+        writePaths(readPaths, outputFilePrefix + \".paths.txt.gz\");\n+        writeReads(reads, outputFilePrefix + \".reads.fastq.gz\");\n+        return null;\n+    }\n+\n+    /** trim read pairs of base calls that have gone past the end of a short fragment */\n+    private void trimOverruns( final GATKRead read, final GATKRead mate ) {\n+        // if both mapped and they're on different strands\n+        if ( !read.isUnmapped() && !mate.isUnmapped() &&\n+                read.isReverseStrand() != mate.isReverseStrand() ) {\n+            // and both start within 1 base on the ref\n+            if ( Math.abs(read.getStart() - read.getMateStart()) <= 1 ) {\n+                // and both end within 1 base\n+                final int readRefLen = read.getCigar().getReferenceLength();\n+                final int mateRefLen = mate.getCigar().getReferenceLength();\n+                if ( Math.abs(readRefLen - mateRefLen) <= 1 ) {\n+                    if ( mate.isReverseStrand() ) {\n+                        trimClips(read, mate);\n+                    } else {\n+                        trimClips(mate, read);\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    private void trimClips( final GATKRead fwd, final GATKRead rev ) {\n+        final List<CigarElement> fwdElements = fwd.getCigarElements();\n+        final List<CigarElement> revElements = rev.getCigarElements();\n+        final int lastElementIdx = fwdElements.size() - 1;\n+        final CigarElement fwdLastElement = fwdElements.get(lastElementIdx);\n+        final CigarElement revFirstElement = revElements.get(0);\n+        if ( fwdLastElement.getOperator() == CigarOperator.S &&\n+                revFirstElement.getOperator() == CigarOperator.S ) {\n+            final byte[] fwdBases = fwd.getBasesNoCopy();\n+            final int lastElementLen = fwdLastElement.getLength();\n+            fwd.setBases(Arrays.copyOfRange(fwdBases, 0, fwdBases.length - lastElementLen));\n+            final byte[] fwdQuals = fwd.getBaseQualitiesNoCopy();\n+            if ( fwdQuals.length > 0 ) {\n+                final int qualsLen = fwdQuals.length - lastElementLen;\n+                fwd.setBaseQualities(Arrays.copyOfRange(fwdQuals, 0, qualsLen));\n+            }\n+            final List<CigarElement> newFwdElements = new ArrayList<>(fwdElements);\n+            newFwdElements.set(lastElementIdx, new CigarElement(lastElementLen, CigarOperator.H));\n+            fwd.setCigar(new Cigar(newFwdElements));\n+\n+            final byte[] revBases = rev.getBasesNoCopy();\n+            final int firstElementLen = revFirstElement.getLength();\n+            rev.setBases(Arrays.copyOfRange(revBases, firstElementLen, revBases.length));\n+            final byte[] revQuals = rev.getBaseQualitiesNoCopy();\n+            if ( revQuals.length > 0 ) {\n+                rev.setBaseQualities(Arrays.copyOfRange(revQuals, firstElementLen, revQuals.length));\n+            }\n+            final List<CigarElement> newRevElements = new ArrayList<>(revElements);\n+            newRevElements.set(0, new CigarElement(firstElementLen, CigarOperator.H));\n+            rev.setCigar(new Cigar(newRevElements));\n+        }\n+    }\n+\n+    @VisibleForTesting\n+    static void kmerizeReads( final List<GATKRead> reads,\n+                              final KmerSet<KmerAdjacency> kmerAdjacencySet ) {\n+        for ( final GATKRead read : reads ) {\n+            final byte[] calls = read.getBasesNoCopy();\n+            final byte[] quals = read.getBaseQualitiesNoCopy();\n+            KmerAdjacency.kmerize(calls, quals, QMIN, kmerAdjacencySet);\n+        }\n+    }\n+\n+    /** gather unbranched strings of kmers into contigs **/\n+    @VisibleForTesting\n+    static List<ContigImpl> buildContigs( final KmerSet<KmerAdjacency> kmerAdjacencySet ) {\n+        // gather strings of kmers that have a single predecessor and single successor into contigs\n+        final List<ContigImpl> contigs = new ArrayList<>();\n+        int nContigs = 0;\n+        for ( final KmerAdjacency kmerAdjacency : kmerAdjacencySet ) {\n+            if ( kmerAdjacency.getContig() == null ) {\n+                ContigImpl contig = null;\n+                final KmerAdjacency predecessor = kmerAdjacency.getSolePredecessor();\n+                if ( predecessor == null ||\n+                        predecessor.getSuccessorCount() > 1 ||\n+                        predecessor == kmerAdjacency.rc() ) {\n+                    contig = new ContigImpl(++nContigs, kmerAdjacency);\n+                } else {\n+                    final KmerAdjacency successor = kmerAdjacency.getSoleSuccessor();\n+                    if ( successor == null ||\n+                            successor.getPredecessorCount() > 1 ||\n+                            successor == kmerAdjacency.rc() ) {\n+                        contig = new ContigImpl(++nContigs, kmerAdjacency.rc());\n+                    }\n+                }\n+                if ( contig != null ) {\n+                    contigs.add(contig);\n+                }\n+            }\n+        }\n+\n+        // if there are smooth circles like a plasmid, gather them together as a contig, too\n+        for ( final KmerAdjacency kmerAdjacency : kmerAdjacencySet ) {\n+            if ( kmerAdjacency.getContig() == null ) {\n+                contigs.add(new ContigImpl(++nContigs, kmerAdjacency));\n+            }\n+        }\n+\n+        return contigs;\n+    }\n+\n+    /** connect contigs when the final kmer of one contig is adjacent to the inital contig of another **/\n+    @VisibleForTesting\n+    static void connectContigs( final List<ContigImpl> contigs ) {\n+        final int nContigs = contigs.size();\n+        final KmerSet<ContigEndKmer> contigEnds = new KmerSet<>(2*nContigs);\n+        for ( int contigId = 0; contigId != nContigs; ++contigId ) {\n+            final ContigImpl contig = contigs.get(contigId);\n+            final KmerAdjacency fwdKmer = contig.getFirstKmer();\n+            final KmerAdjacency revKmer = contig.getLastKmer().rc();\n+            if ( fwdKmer == revKmer ) {\n+                contigEnds.add(new ContigEndKmer(fwdKmer.getKVal(), contig, ContigOrientation.BOTH));\n+            } else {\n+                contigEnds.add(new ContigEndKmer(fwdKmer.getKVal(), contig, ContigOrientation.FWD));\n+                contigEnds.add(new ContigEndKmer(revKmer.getKVal(), contig, ContigOrientation.REV));\n+            }\n+        }\n+\n+        for ( int contigId = 0; contigId != nContigs; ++contigId ) {\n+            final Contig contig = contigs.get(contigId);\n+\n+            final KmerAdjacency start = contig.getFirstKmer();\n+            final int predecessorCount = start.getPredecessorCount();\n+            if ( predecessorCount > 0 ) {\n+                final List<Contig> predecessors = contig.getPredecessors();\n+                final int mask = start.getPredecessorMask();\n+                for ( int call = 0; call != 4; ++call ) {\n+                    if ( (mask & (1 << call)) != 0 ) {\n+                        final long kVal =\n+                                KmerAdjacency.reverseComplement(start.getPredecessorVal(call));\n+                        final ContigEndKmer contigEndKmer = contigEnds.find(new Kmer(kVal));\n+                        if ( contigEndKmer == null ) {\n+                            throw new GATKException(\"missing contig end kmer\");\n+                        }\n+                        switch ( contigEndKmer.getContigOrientation() ) {\n+                            case FWD:\n+                                predecessors.add(contigEndKmer.getContig().rc());\n+                                break;\n+                            case REV:\n+                                predecessors.add(contigEndKmer.getContig());\n+                                break;\n+                            case BOTH:\n+                                predecessors.add(contigEndKmer.getContig());\n+                                predecessors.add(contigEndKmer.getContig().rc());\n+                                break;\n+                        }\n+                    }\n+                }\n+            }\n+\n+            final KmerAdjacency end = contig.getLastKmer();\n+            final int successorCount = end.getSuccessorCount();\n+            if ( successorCount > 0 ) {\n+                final List<Contig> successors = contig.getSuccessors();\n+                final int mask = end.getSuccessorMask();\n+                for ( int call = 0; call != 4; ++call ) {\n+                    if ( (mask & (1 << call)) != 0 ) {\n+                        final long kVal = end.getSuccessorVal(call);\n+                        final ContigEndKmer contigEndKmer = contigEnds.find(new Kmer(kVal));\n+                        if ( contigEndKmer == null ) {\n+                            throw new GATKException(\"missing contig end kmer\");\n+                        }\n+                        switch ( contigEndKmer.getContigOrientation() ) {\n+                            case FWD:\n+                                successors.add(contigEndKmer.getContig());\n+                                break;\n+                            case REV:\n+                                successors.add(contigEndKmer.getContig().rc());\n+                                break;\n+                            case BOTH:\n+                                successors.add(contigEndKmer.getContig());\n+                                successors.add(contigEndKmer.getContig().rc());\n+                                break;\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    /** remove contigs that have little evidence **/\n+    @VisibleForTesting\n+    static void removeThinContigs( final List<ContigImpl> contigs,\n+                                           final KmerSet<KmerAdjacency> kmerAdjacencySet ) {\n+        contigs.sort(Comparator.comparingInt(ContigImpl::getMaxObservations));\n+        boolean contigRemoved;\n+        do {\n+            // figure out which contigs are cut points\n+            // i.e., those contigs which, if removed, would result in a graph with more connected components\n+            final int nContigs = contigs.size();\n+            final Map<Contig, CutData> cutDataMap = new HashMap<>(nContigs * 3);\n+\n+            for ( final ContigImpl contig : contigs ) {\n+                if ( cutDataMap.containsKey(contig) ) {\n+                    continue;\n+                }\n+\n+                cutDataMap.put(contig, new CutData());\n+                int children = 0;\n+                for ( final Contig nextContig : contig.getSuccessors() ) {\n+                    if ( !cutDataMap.containsKey(nextContig) ) {\n+                        findCuts(nextContig, contig, cutDataMap);\n+                        children += 1;\n+                    }\n+                }\n+                for ( final Contig nextContig : contig.getPredecessors() ) {\n+                    if ( !cutDataMap.containsKey(nextContig) ) {\n+                        findCuts(nextContig, contig, cutDataMap);\n+                        children += 1;\n+                    }\n+                }\n+                if ( children >= 2 ) {\n+                    contig.setCut(true);\n+                }\n+            }\n+\n+            // remove poorly attested (low max observations) contigs, unless they are cut points\n+            contigRemoved = false;\n+            final Iterator<ContigImpl> itr = contigs.iterator();\n+            while ( itr.hasNext() ) {\n+                final Contig contig = itr.next();\n+                if ( contig.getMaxObservations() < MIN_THIN_OBS && !contig.isCut() ) {\n+                    unlinkContig(contig, kmerAdjacencySet);\n+                    itr.remove();\n+                    contigRemoved = true;\n+                    break;\n+                }\n+            }\n+        } while ( contigRemoved );\n+        contigs.sort(Comparator.comparingInt(ContigImpl::getId));\n+    }\n+\n+    private static CutData findCuts( final Contig contig,\n+                                     final Contig parent,\n+                                     final Map<Contig, CutData> cutDataMap ) {\n+        final CutData cutData = new CutData();\n+        cutDataMap.put(contig, cutData);\n+        for ( final Contig nextContig : contig.getSuccessors() ) {\n+            if ( nextContig == parent ) {\n+                continue;\n+            }\n+            CutData nextCutData = cutDataMap.get(nextContig);\n+            if ( nextCutData != null ) {\n+                cutData.minVisitNum = Math.min(cutData.minVisitNum, nextCutData.visitNum);\n+            } else {\n+                nextCutData = findCuts(nextContig, contig, cutDataMap);\n+                cutData.minVisitNum = Math.min(cutData.minVisitNum, nextCutData.minVisitNum);\n+                if ( nextCutData.minVisitNum >= cutData.visitNum ) {\n+                    contig.setCut(true);\n+                }\n+            }\n+        }\n+        for ( final Contig nextContig : contig.getPredecessors() ) {\n+            if ( nextContig == parent ) {\n+                continue;\n+            }\n+            CutData nextCutData = cutDataMap.get(nextContig);\n+            if ( nextCutData != null ) {\n+                cutData.minVisitNum = Math.min(cutData.minVisitNum, nextCutData.visitNum);\n+            } else {\n+                nextCutData = findCuts(nextContig, contig, cutDataMap);\n+                cutData.minVisitNum = Math.min(cutData.minVisitNum, nextCutData.minVisitNum);\n+                if ( nextCutData.minVisitNum >= cutData.visitNum ) {\n+                    contig.setCut(true);\n+                }\n+            }\n+        }\n+        return cutData;\n+    }\n+\n+    @VisibleForTesting\n+    static void unlinkContig( final Contig contig,\n+                                      final KmerSet<KmerAdjacency> kmerAdjacencySet ) {\n+        final KmerAdjacency firstKmer = contig.getFirstKmer();\n+        final int firstKmerFinalCall = firstKmer.getFinalCall();\n+        for ( final Contig predecessor : contig.getPredecessors() ) {\n+            if ( predecessor != contig && predecessor != contig.rc() ) {\n+                predecessor.getLastKmer().removeSuccessor(firstKmerFinalCall, kmerAdjacencySet);\n+                if ( !predecessor.getSuccessors().remove(contig) ) {\n+                    throw new GATKException(\"failed to find predecessor link\");\n+                }\n+            }\n+        }\n+\n+        final KmerAdjacency lastKmer = contig.getLastKmer();\n+        final int lastKmerInitialCall = lastKmer.getInitialCall();\n+        for ( final Contig successor : contig.getSuccessors() ) {\n+            if ( successor != contig && successor != contig.rc() ) {\n+                successor.getFirstKmer().removePredecessor(lastKmerInitialCall, kmerAdjacencySet);\n+                if ( !successor.getPredecessors().remove(contig) ) {\n+                    throw new GATKException(\"failed to find successor link\");\n+                }\n+            }\n+        }\n+\n+        KmerAdjacency nextKmer = firstKmer;\n+        KmerAdjacency kmer;\n+        do {\n+            kmer = nextKmer;\n+            nextKmer = kmer.getSoleSuccessor();\n+            kmerAdjacencySet.remove(kmer.canonical());\n+        } while ( kmer != lastKmer );\n+    }\n+\n+    private static void updateKmerContig( final KmerAdjacency firstKmer,\n+                                          final KmerAdjacency lastKmer,\n+                                          final Contig contig ) {\n+        int offset = 0;\n+        for ( KmerAdjacency kmer = firstKmer; kmer != lastKmer; kmer = kmer.getSoleSuccessor() ) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e2201c1ef4f8ba71f17e169f07756cfe2f1ecb49"}, "originalPosition": 431}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxMTk0NDIwMA==", "bodyText": "Can't happen because of the way we build contigs as an unbranched series of adjacent kmers.  The check you suggest happens when we build the contigs:  if we try to reassign a contig+offset to a KmerAdjacency that already has an assignment (perhaps because we went all the way around a loop), we throw an exception.\nOnly here, where we're joining two contigs with a single successor and a single predecessor, do we allow the contig+offset to be reassigned (by clearing out the old info first).\nBut I altered this and put a check in, just in case.", "url": "https://github.com/broadinstitute/gatk/pull/6989#discussion_r611944200", "createdAt": "2021-04-12T20:48:44Z", "author": {"login": "tedsharpe"}, "path": "src/main/java/org/broadinstitute/hellbender/tools/LocalAssembler.java", "diffHunk": "@@ -0,0 +1,2306 @@\n+package org.broadinstitute.hellbender.tools;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import htsjdk.samtools.Cigar;\n+import htsjdk.samtools.CigarElement;\n+import htsjdk.samtools.CigarOperator;\n+import htsjdk.samtools.SAMUtils;\n+import org.broadinstitute.barclay.argparser.Argument;\n+import org.broadinstitute.barclay.argparser.BetaFeature;\n+import org.broadinstitute.barclay.argparser.CommandLineProgramProperties;\n+import org.broadinstitute.barclay.help.DocumentedFeature;\n+import org.broadinstitute.hellbender.cmdline.StandardArgumentDefinitions;\n+import org.broadinstitute.hellbender.cmdline.programgroups.CoverageAnalysisProgramGroup;\n+import org.broadinstitute.hellbender.exceptions.GATKException;\n+import org.broadinstitute.hellbender.tools.walkers.PairWalker;\n+import org.broadinstitute.hellbender.utils.SimpleInterval;\n+import org.broadinstitute.hellbender.utils.collections.HopscotchSet;\n+import org.broadinstitute.hellbender.utils.gcs.BucketUtils;\n+import org.broadinstitute.hellbender.utils.read.GATKRead;\n+\n+import java.io.BufferedWriter;\n+import java.io.FileWriter;\n+import java.io.IOException;\n+import java.io.OutputStreamWriter;\n+import java.util.*;\n+import java.util.zip.GZIPOutputStream;\n+\n+@DocumentedFeature\n+@CommandLineProgramProperties(\n+        summary = \"experiment\",\n+        oneLineSummary = \"experiment\",\n+        usageExample = \"gatk LocalAssembler\",\n+        programGroup = CoverageAnalysisProgramGroup.class\n+)\n+@BetaFeature\n+public class LocalAssembler extends PairWalker {\n+    public static final byte QMIN = 25;\n+    public static final int MIN_THIN_OBS = 4;\n+    public static final int MIN_GAPFILL_COUNT = 3;\n+    public static final int TOO_MANY_TRAVERSALS = 100000;\n+    public static final int TOO_MANY_SCAFFOLDS = 50000;\n+    public static final int MIN_SV_SIZE = 50;\n+\n+    @Argument(fullName=StandardArgumentDefinitions.OUTPUT_LONG_NAME,\n+            shortName=StandardArgumentDefinitions.OUTPUT_SHORT_NAME,\n+            doc=\"Write outputs to this file name prefix\", optional = true)\n+    public static String output;\n+\n+    @Argument(fullName=\"assembly-name\", doc=\"name of assembly used as a prefix for traversal names\")\n+    public static String assemblyName;\n+\n+    private final List<GATKRead> reads = new ArrayList<>();\n+\n+    @Override public boolean requiresIntervals() { return true; }\n+\n+    @Override public void apply( final GATKRead read, final GATKRead mate ) {\n+        trimOverruns(read, mate);\n+        reads.add(read);\n+        reads.add(mate);\n+    }\n+\n+    @Override public void applyUnpaired( final GATKRead read ) {\n+        reads.add(read);\n+    }\n+\n+    @Override public Object onTraversalSuccess() {\n+        super.onTraversalSuccess(); // flush any incomplete pairs\n+\n+        final int regionSize = getTraversalIntervals().stream().mapToInt(SimpleInterval::size).sum();\n+        final KmerSet<KmerAdjacency> kmerAdjacencySet = new KmerSet<>(10 * regionSize);\n+        kmerizeReads(reads, kmerAdjacencySet);\n+        List<ContigImpl> contigs = buildContigs(kmerAdjacencySet);\n+        connectContigs(contigs);\n+\n+        removeThinContigs(contigs, kmerAdjacencySet);\n+        weldPipes(contigs);\n+        markComponents(contigs);\n+\n+        if ( fillGaps(kmerAdjacencySet, reads) ) {\n+            contigs = buildContigs(kmerAdjacencySet);\n+            connectContigs(contigs);\n+            removeThinContigs(contigs, kmerAdjacencySet);\n+            weldPipes(contigs);\n+            markComponents(contigs);\n+        }\n+\n+        markCycles(contigs);\n+\n+        final String outputFilePrefix = output != null ? output : assemblyName;\n+        final List<Path> readPaths = pathReads(kmerAdjacencySet, reads);\n+        final Map<Contig,List<TransitPairCount>> contigTransitsMap =\n+                collectTransitPairCounts(contigs, readPaths);\n+        final String traversalsFilename = outputFilePrefix + \".traversals.fa.gz\";\n+        try {\n+            final List<Traversal> allTraversals =\n+                    new ArrayList<>(traverseAllPaths(contigs, readPaths, contigTransitsMap));\n+            writeTraversals(allTraversals, traversalsFilename);\n+            try {\n+                final String scaffoldsFileName = outputFilePrefix + \".scaffolds.fa.gz\";\n+                writeTraversals(createScaffolds(allTraversals), scaffoldsFileName);\n+            } catch ( final AssemblyTooComplexException x ) {\n+                logger.warn(\"Assembly too complex for scaffolding.\");\n+            }\n+        } catch ( final AssemblyTooComplexException x ) {\n+            logger.warn(\"Assembly too complex.  Writing contigs as traversals in \" +\n+                    traversalsFilename + \".\");\n+            final Collection<Traversal> contigTraversals = new ArrayList<>(contigs.size());\n+            for ( final Contig contig : contigs ) {\n+                contigTraversals.add(new Traversal(Collections.singletonList(contig)));\n+            }\n+            writeTraversals(contigTraversals, traversalsFilename);\n+        }\n+\n+        contigs.sort(Comparator.comparingInt(ContigImpl::getId));\n+        writeDOT(contigs, outputFilePrefix + \".assembly.dot\");\n+        writeContigs(contigs, outputFilePrefix + \".contigs.txt.gz\");\n+        writePaths(readPaths, outputFilePrefix + \".paths.txt.gz\");\n+        writeReads(reads, outputFilePrefix + \".reads.fastq.gz\");\n+        return null;\n+    }\n+\n+    /** trim read pairs of base calls that have gone past the end of a short fragment */\n+    private void trimOverruns( final GATKRead read, final GATKRead mate ) {\n+        // if both mapped and they're on different strands\n+        if ( !read.isUnmapped() && !mate.isUnmapped() &&\n+                read.isReverseStrand() != mate.isReverseStrand() ) {\n+            // and both start within 1 base on the ref\n+            if ( Math.abs(read.getStart() - read.getMateStart()) <= 1 ) {\n+                // and both end within 1 base\n+                final int readRefLen = read.getCigar().getReferenceLength();\n+                final int mateRefLen = mate.getCigar().getReferenceLength();\n+                if ( Math.abs(readRefLen - mateRefLen) <= 1 ) {\n+                    if ( mate.isReverseStrand() ) {\n+                        trimClips(read, mate);\n+                    } else {\n+                        trimClips(mate, read);\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    private void trimClips( final GATKRead fwd, final GATKRead rev ) {\n+        final List<CigarElement> fwdElements = fwd.getCigarElements();\n+        final List<CigarElement> revElements = rev.getCigarElements();\n+        final int lastElementIdx = fwdElements.size() - 1;\n+        final CigarElement fwdLastElement = fwdElements.get(lastElementIdx);\n+        final CigarElement revFirstElement = revElements.get(0);\n+        if ( fwdLastElement.getOperator() == CigarOperator.S &&\n+                revFirstElement.getOperator() == CigarOperator.S ) {\n+            final byte[] fwdBases = fwd.getBasesNoCopy();\n+            final int lastElementLen = fwdLastElement.getLength();\n+            fwd.setBases(Arrays.copyOfRange(fwdBases, 0, fwdBases.length - lastElementLen));\n+            final byte[] fwdQuals = fwd.getBaseQualitiesNoCopy();\n+            if ( fwdQuals.length > 0 ) {\n+                final int qualsLen = fwdQuals.length - lastElementLen;\n+                fwd.setBaseQualities(Arrays.copyOfRange(fwdQuals, 0, qualsLen));\n+            }\n+            final List<CigarElement> newFwdElements = new ArrayList<>(fwdElements);\n+            newFwdElements.set(lastElementIdx, new CigarElement(lastElementLen, CigarOperator.H));\n+            fwd.setCigar(new Cigar(newFwdElements));\n+\n+            final byte[] revBases = rev.getBasesNoCopy();\n+            final int firstElementLen = revFirstElement.getLength();\n+            rev.setBases(Arrays.copyOfRange(revBases, firstElementLen, revBases.length));\n+            final byte[] revQuals = rev.getBaseQualitiesNoCopy();\n+            if ( revQuals.length > 0 ) {\n+                rev.setBaseQualities(Arrays.copyOfRange(revQuals, firstElementLen, revQuals.length));\n+            }\n+            final List<CigarElement> newRevElements = new ArrayList<>(revElements);\n+            newRevElements.set(0, new CigarElement(firstElementLen, CigarOperator.H));\n+            rev.setCigar(new Cigar(newRevElements));\n+        }\n+    }\n+\n+    @VisibleForTesting\n+    static void kmerizeReads( final List<GATKRead> reads,\n+                              final KmerSet<KmerAdjacency> kmerAdjacencySet ) {\n+        for ( final GATKRead read : reads ) {\n+            final byte[] calls = read.getBasesNoCopy();\n+            final byte[] quals = read.getBaseQualitiesNoCopy();\n+            KmerAdjacency.kmerize(calls, quals, QMIN, kmerAdjacencySet);\n+        }\n+    }\n+\n+    /** gather unbranched strings of kmers into contigs **/\n+    @VisibleForTesting\n+    static List<ContigImpl> buildContigs( final KmerSet<KmerAdjacency> kmerAdjacencySet ) {\n+        // gather strings of kmers that have a single predecessor and single successor into contigs\n+        final List<ContigImpl> contigs = new ArrayList<>();\n+        int nContigs = 0;\n+        for ( final KmerAdjacency kmerAdjacency : kmerAdjacencySet ) {\n+            if ( kmerAdjacency.getContig() == null ) {\n+                ContigImpl contig = null;\n+                final KmerAdjacency predecessor = kmerAdjacency.getSolePredecessor();\n+                if ( predecessor == null ||\n+                        predecessor.getSuccessorCount() > 1 ||\n+                        predecessor == kmerAdjacency.rc() ) {\n+                    contig = new ContigImpl(++nContigs, kmerAdjacency);\n+                } else {\n+                    final KmerAdjacency successor = kmerAdjacency.getSoleSuccessor();\n+                    if ( successor == null ||\n+                            successor.getPredecessorCount() > 1 ||\n+                            successor == kmerAdjacency.rc() ) {\n+                        contig = new ContigImpl(++nContigs, kmerAdjacency.rc());\n+                    }\n+                }\n+                if ( contig != null ) {\n+                    contigs.add(contig);\n+                }\n+            }\n+        }\n+\n+        // if there are smooth circles like a plasmid, gather them together as a contig, too\n+        for ( final KmerAdjacency kmerAdjacency : kmerAdjacencySet ) {\n+            if ( kmerAdjacency.getContig() == null ) {\n+                contigs.add(new ContigImpl(++nContigs, kmerAdjacency));\n+            }\n+        }\n+\n+        return contigs;\n+    }\n+\n+    /** connect contigs when the final kmer of one contig is adjacent to the inital contig of another **/\n+    @VisibleForTesting\n+    static void connectContigs( final List<ContigImpl> contigs ) {\n+        final int nContigs = contigs.size();\n+        final KmerSet<ContigEndKmer> contigEnds = new KmerSet<>(2*nContigs);\n+        for ( int contigId = 0; contigId != nContigs; ++contigId ) {\n+            final ContigImpl contig = contigs.get(contigId);\n+            final KmerAdjacency fwdKmer = contig.getFirstKmer();\n+            final KmerAdjacency revKmer = contig.getLastKmer().rc();\n+            if ( fwdKmer == revKmer ) {\n+                contigEnds.add(new ContigEndKmer(fwdKmer.getKVal(), contig, ContigOrientation.BOTH));\n+            } else {\n+                contigEnds.add(new ContigEndKmer(fwdKmer.getKVal(), contig, ContigOrientation.FWD));\n+                contigEnds.add(new ContigEndKmer(revKmer.getKVal(), contig, ContigOrientation.REV));\n+            }\n+        }\n+\n+        for ( int contigId = 0; contigId != nContigs; ++contigId ) {\n+            final Contig contig = contigs.get(contigId);\n+\n+            final KmerAdjacency start = contig.getFirstKmer();\n+            final int predecessorCount = start.getPredecessorCount();\n+            if ( predecessorCount > 0 ) {\n+                final List<Contig> predecessors = contig.getPredecessors();\n+                final int mask = start.getPredecessorMask();\n+                for ( int call = 0; call != 4; ++call ) {\n+                    if ( (mask & (1 << call)) != 0 ) {\n+                        final long kVal =\n+                                KmerAdjacency.reverseComplement(start.getPredecessorVal(call));\n+                        final ContigEndKmer contigEndKmer = contigEnds.find(new Kmer(kVal));\n+                        if ( contigEndKmer == null ) {\n+                            throw new GATKException(\"missing contig end kmer\");\n+                        }\n+                        switch ( contigEndKmer.getContigOrientation() ) {\n+                            case FWD:\n+                                predecessors.add(contigEndKmer.getContig().rc());\n+                                break;\n+                            case REV:\n+                                predecessors.add(contigEndKmer.getContig());\n+                                break;\n+                            case BOTH:\n+                                predecessors.add(contigEndKmer.getContig());\n+                                predecessors.add(contigEndKmer.getContig().rc());\n+                                break;\n+                        }\n+                    }\n+                }\n+            }\n+\n+            final KmerAdjacency end = contig.getLastKmer();\n+            final int successorCount = end.getSuccessorCount();\n+            if ( successorCount > 0 ) {\n+                final List<Contig> successors = contig.getSuccessors();\n+                final int mask = end.getSuccessorMask();\n+                for ( int call = 0; call != 4; ++call ) {\n+                    if ( (mask & (1 << call)) != 0 ) {\n+                        final long kVal = end.getSuccessorVal(call);\n+                        final ContigEndKmer contigEndKmer = contigEnds.find(new Kmer(kVal));\n+                        if ( contigEndKmer == null ) {\n+                            throw new GATKException(\"missing contig end kmer\");\n+                        }\n+                        switch ( contigEndKmer.getContigOrientation() ) {\n+                            case FWD:\n+                                successors.add(contigEndKmer.getContig());\n+                                break;\n+                            case REV:\n+                                successors.add(contigEndKmer.getContig().rc());\n+                                break;\n+                            case BOTH:\n+                                successors.add(contigEndKmer.getContig());\n+                                successors.add(contigEndKmer.getContig().rc());\n+                                break;\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    /** remove contigs that have little evidence **/\n+    @VisibleForTesting\n+    static void removeThinContigs( final List<ContigImpl> contigs,\n+                                           final KmerSet<KmerAdjacency> kmerAdjacencySet ) {\n+        contigs.sort(Comparator.comparingInt(ContigImpl::getMaxObservations));\n+        boolean contigRemoved;\n+        do {\n+            // figure out which contigs are cut points\n+            // i.e., those contigs which, if removed, would result in a graph with more connected components\n+            final int nContigs = contigs.size();\n+            final Map<Contig, CutData> cutDataMap = new HashMap<>(nContigs * 3);\n+\n+            for ( final ContigImpl contig : contigs ) {\n+                if ( cutDataMap.containsKey(contig) ) {\n+                    continue;\n+                }\n+\n+                cutDataMap.put(contig, new CutData());\n+                int children = 0;\n+                for ( final Contig nextContig : contig.getSuccessors() ) {\n+                    if ( !cutDataMap.containsKey(nextContig) ) {\n+                        findCuts(nextContig, contig, cutDataMap);\n+                        children += 1;\n+                    }\n+                }\n+                for ( final Contig nextContig : contig.getPredecessors() ) {\n+                    if ( !cutDataMap.containsKey(nextContig) ) {\n+                        findCuts(nextContig, contig, cutDataMap);\n+                        children += 1;\n+                    }\n+                }\n+                if ( children >= 2 ) {\n+                    contig.setCut(true);\n+                }\n+            }\n+\n+            // remove poorly attested (low max observations) contigs, unless they are cut points\n+            contigRemoved = false;\n+            final Iterator<ContigImpl> itr = contigs.iterator();\n+            while ( itr.hasNext() ) {\n+                final Contig contig = itr.next();\n+                if ( contig.getMaxObservations() < MIN_THIN_OBS && !contig.isCut() ) {\n+                    unlinkContig(contig, kmerAdjacencySet);\n+                    itr.remove();\n+                    contigRemoved = true;\n+                    break;\n+                }\n+            }\n+        } while ( contigRemoved );\n+        contigs.sort(Comparator.comparingInt(ContigImpl::getId));\n+    }\n+\n+    private static CutData findCuts( final Contig contig,\n+                                     final Contig parent,\n+                                     final Map<Contig, CutData> cutDataMap ) {\n+        final CutData cutData = new CutData();\n+        cutDataMap.put(contig, cutData);\n+        for ( final Contig nextContig : contig.getSuccessors() ) {\n+            if ( nextContig == parent ) {\n+                continue;\n+            }\n+            CutData nextCutData = cutDataMap.get(nextContig);\n+            if ( nextCutData != null ) {\n+                cutData.minVisitNum = Math.min(cutData.minVisitNum, nextCutData.visitNum);\n+            } else {\n+                nextCutData = findCuts(nextContig, contig, cutDataMap);\n+                cutData.minVisitNum = Math.min(cutData.minVisitNum, nextCutData.minVisitNum);\n+                if ( nextCutData.minVisitNum >= cutData.visitNum ) {\n+                    contig.setCut(true);\n+                }\n+            }\n+        }\n+        for ( final Contig nextContig : contig.getPredecessors() ) {\n+            if ( nextContig == parent ) {\n+                continue;\n+            }\n+            CutData nextCutData = cutDataMap.get(nextContig);\n+            if ( nextCutData != null ) {\n+                cutData.minVisitNum = Math.min(cutData.minVisitNum, nextCutData.visitNum);\n+            } else {\n+                nextCutData = findCuts(nextContig, contig, cutDataMap);\n+                cutData.minVisitNum = Math.min(cutData.minVisitNum, nextCutData.minVisitNum);\n+                if ( nextCutData.minVisitNum >= cutData.visitNum ) {\n+                    contig.setCut(true);\n+                }\n+            }\n+        }\n+        return cutData;\n+    }\n+\n+    @VisibleForTesting\n+    static void unlinkContig( final Contig contig,\n+                                      final KmerSet<KmerAdjacency> kmerAdjacencySet ) {\n+        final KmerAdjacency firstKmer = contig.getFirstKmer();\n+        final int firstKmerFinalCall = firstKmer.getFinalCall();\n+        for ( final Contig predecessor : contig.getPredecessors() ) {\n+            if ( predecessor != contig && predecessor != contig.rc() ) {\n+                predecessor.getLastKmer().removeSuccessor(firstKmerFinalCall, kmerAdjacencySet);\n+                if ( !predecessor.getSuccessors().remove(contig) ) {\n+                    throw new GATKException(\"failed to find predecessor link\");\n+                }\n+            }\n+        }\n+\n+        final KmerAdjacency lastKmer = contig.getLastKmer();\n+        final int lastKmerInitialCall = lastKmer.getInitialCall();\n+        for ( final Contig successor : contig.getSuccessors() ) {\n+            if ( successor != contig && successor != contig.rc() ) {\n+                successor.getFirstKmer().removePredecessor(lastKmerInitialCall, kmerAdjacencySet);\n+                if ( !successor.getPredecessors().remove(contig) ) {\n+                    throw new GATKException(\"failed to find successor link\");\n+                }\n+            }\n+        }\n+\n+        KmerAdjacency nextKmer = firstKmer;\n+        KmerAdjacency kmer;\n+        do {\n+            kmer = nextKmer;\n+            nextKmer = kmer.getSoleSuccessor();\n+            kmerAdjacencySet.remove(kmer.canonical());\n+        } while ( kmer != lastKmer );\n+    }\n+\n+    private static void updateKmerContig( final KmerAdjacency firstKmer,\n+                                          final KmerAdjacency lastKmer,\n+                                          final Contig contig ) {\n+        int offset = 0;\n+        for ( KmerAdjacency kmer = firstKmer; kmer != lastKmer; kmer = kmer.getSoleSuccessor() ) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MTc4NjcyMg=="}, "originalCommit": {"oid": "e2201c1ef4f8ba71f17e169f07756cfe2f1ecb49"}, "originalPosition": 431}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzczNjUzNjU5OnYy", "diffSide": "RIGHT", "path": "src/main/java/org/broadinstitute/hellbender/tools/LocalAssembler.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMy0xMFQxODo1OToxM1rOI0X87w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMy0xMFQxODo1OToxM1rOI0X87w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MTc4OTI5NQ==", "bodyText": "Since this is defensive, would it make sense to move this check to the ContigImpl(id, predecessor, successor) constructor?", "url": "https://github.com/broadinstitute/gatk/pull/6989#discussion_r591789295", "createdAt": "2021-03-10T18:59:13Z", "author": {"login": "cwhelan"}, "path": "src/main/java/org/broadinstitute/hellbender/tools/LocalAssembler.java", "diffHunk": "@@ -0,0 +1,2306 @@\n+package org.broadinstitute.hellbender.tools;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import htsjdk.samtools.Cigar;\n+import htsjdk.samtools.CigarElement;\n+import htsjdk.samtools.CigarOperator;\n+import htsjdk.samtools.SAMUtils;\n+import org.broadinstitute.barclay.argparser.Argument;\n+import org.broadinstitute.barclay.argparser.BetaFeature;\n+import org.broadinstitute.barclay.argparser.CommandLineProgramProperties;\n+import org.broadinstitute.barclay.help.DocumentedFeature;\n+import org.broadinstitute.hellbender.cmdline.StandardArgumentDefinitions;\n+import org.broadinstitute.hellbender.cmdline.programgroups.CoverageAnalysisProgramGroup;\n+import org.broadinstitute.hellbender.exceptions.GATKException;\n+import org.broadinstitute.hellbender.tools.walkers.PairWalker;\n+import org.broadinstitute.hellbender.utils.SimpleInterval;\n+import org.broadinstitute.hellbender.utils.collections.HopscotchSet;\n+import org.broadinstitute.hellbender.utils.gcs.BucketUtils;\n+import org.broadinstitute.hellbender.utils.read.GATKRead;\n+\n+import java.io.BufferedWriter;\n+import java.io.FileWriter;\n+import java.io.IOException;\n+import java.io.OutputStreamWriter;\n+import java.util.*;\n+import java.util.zip.GZIPOutputStream;\n+\n+@DocumentedFeature\n+@CommandLineProgramProperties(\n+        summary = \"experiment\",\n+        oneLineSummary = \"experiment\",\n+        usageExample = \"gatk LocalAssembler\",\n+        programGroup = CoverageAnalysisProgramGroup.class\n+)\n+@BetaFeature\n+public class LocalAssembler extends PairWalker {\n+    public static final byte QMIN = 25;\n+    public static final int MIN_THIN_OBS = 4;\n+    public static final int MIN_GAPFILL_COUNT = 3;\n+    public static final int TOO_MANY_TRAVERSALS = 100000;\n+    public static final int TOO_MANY_SCAFFOLDS = 50000;\n+    public static final int MIN_SV_SIZE = 50;\n+\n+    @Argument(fullName=StandardArgumentDefinitions.OUTPUT_LONG_NAME,\n+            shortName=StandardArgumentDefinitions.OUTPUT_SHORT_NAME,\n+            doc=\"Write outputs to this file name prefix\", optional = true)\n+    public static String output;\n+\n+    @Argument(fullName=\"assembly-name\", doc=\"name of assembly used as a prefix for traversal names\")\n+    public static String assemblyName;\n+\n+    private final List<GATKRead> reads = new ArrayList<>();\n+\n+    @Override public boolean requiresIntervals() { return true; }\n+\n+    @Override public void apply( final GATKRead read, final GATKRead mate ) {\n+        trimOverruns(read, mate);\n+        reads.add(read);\n+        reads.add(mate);\n+    }\n+\n+    @Override public void applyUnpaired( final GATKRead read ) {\n+        reads.add(read);\n+    }\n+\n+    @Override public Object onTraversalSuccess() {\n+        super.onTraversalSuccess(); // flush any incomplete pairs\n+\n+        final int regionSize = getTraversalIntervals().stream().mapToInt(SimpleInterval::size).sum();\n+        final KmerSet<KmerAdjacency> kmerAdjacencySet = new KmerSet<>(10 * regionSize);\n+        kmerizeReads(reads, kmerAdjacencySet);\n+        List<ContigImpl> contigs = buildContigs(kmerAdjacencySet);\n+        connectContigs(contigs);\n+\n+        removeThinContigs(contigs, kmerAdjacencySet);\n+        weldPipes(contigs);\n+        markComponents(contigs);\n+\n+        if ( fillGaps(kmerAdjacencySet, reads) ) {\n+            contigs = buildContigs(kmerAdjacencySet);\n+            connectContigs(contigs);\n+            removeThinContigs(contigs, kmerAdjacencySet);\n+            weldPipes(contigs);\n+            markComponents(contigs);\n+        }\n+\n+        markCycles(contigs);\n+\n+        final String outputFilePrefix = output != null ? output : assemblyName;\n+        final List<Path> readPaths = pathReads(kmerAdjacencySet, reads);\n+        final Map<Contig,List<TransitPairCount>> contigTransitsMap =\n+                collectTransitPairCounts(contigs, readPaths);\n+        final String traversalsFilename = outputFilePrefix + \".traversals.fa.gz\";\n+        try {\n+            final List<Traversal> allTraversals =\n+                    new ArrayList<>(traverseAllPaths(contigs, readPaths, contigTransitsMap));\n+            writeTraversals(allTraversals, traversalsFilename);\n+            try {\n+                final String scaffoldsFileName = outputFilePrefix + \".scaffolds.fa.gz\";\n+                writeTraversals(createScaffolds(allTraversals), scaffoldsFileName);\n+            } catch ( final AssemblyTooComplexException x ) {\n+                logger.warn(\"Assembly too complex for scaffolding.\");\n+            }\n+        } catch ( final AssemblyTooComplexException x ) {\n+            logger.warn(\"Assembly too complex.  Writing contigs as traversals in \" +\n+                    traversalsFilename + \".\");\n+            final Collection<Traversal> contigTraversals = new ArrayList<>(contigs.size());\n+            for ( final Contig contig : contigs ) {\n+                contigTraversals.add(new Traversal(Collections.singletonList(contig)));\n+            }\n+            writeTraversals(contigTraversals, traversalsFilename);\n+        }\n+\n+        contigs.sort(Comparator.comparingInt(ContigImpl::getId));\n+        writeDOT(contigs, outputFilePrefix + \".assembly.dot\");\n+        writeContigs(contigs, outputFilePrefix + \".contigs.txt.gz\");\n+        writePaths(readPaths, outputFilePrefix + \".paths.txt.gz\");\n+        writeReads(reads, outputFilePrefix + \".reads.fastq.gz\");\n+        return null;\n+    }\n+\n+    /** trim read pairs of base calls that have gone past the end of a short fragment */\n+    private void trimOverruns( final GATKRead read, final GATKRead mate ) {\n+        // if both mapped and they're on different strands\n+        if ( !read.isUnmapped() && !mate.isUnmapped() &&\n+                read.isReverseStrand() != mate.isReverseStrand() ) {\n+            // and both start within 1 base on the ref\n+            if ( Math.abs(read.getStart() - read.getMateStart()) <= 1 ) {\n+                // and both end within 1 base\n+                final int readRefLen = read.getCigar().getReferenceLength();\n+                final int mateRefLen = mate.getCigar().getReferenceLength();\n+                if ( Math.abs(readRefLen - mateRefLen) <= 1 ) {\n+                    if ( mate.isReverseStrand() ) {\n+                        trimClips(read, mate);\n+                    } else {\n+                        trimClips(mate, read);\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    private void trimClips( final GATKRead fwd, final GATKRead rev ) {\n+        final List<CigarElement> fwdElements = fwd.getCigarElements();\n+        final List<CigarElement> revElements = rev.getCigarElements();\n+        final int lastElementIdx = fwdElements.size() - 1;\n+        final CigarElement fwdLastElement = fwdElements.get(lastElementIdx);\n+        final CigarElement revFirstElement = revElements.get(0);\n+        if ( fwdLastElement.getOperator() == CigarOperator.S &&\n+                revFirstElement.getOperator() == CigarOperator.S ) {\n+            final byte[] fwdBases = fwd.getBasesNoCopy();\n+            final int lastElementLen = fwdLastElement.getLength();\n+            fwd.setBases(Arrays.copyOfRange(fwdBases, 0, fwdBases.length - lastElementLen));\n+            final byte[] fwdQuals = fwd.getBaseQualitiesNoCopy();\n+            if ( fwdQuals.length > 0 ) {\n+                final int qualsLen = fwdQuals.length - lastElementLen;\n+                fwd.setBaseQualities(Arrays.copyOfRange(fwdQuals, 0, qualsLen));\n+            }\n+            final List<CigarElement> newFwdElements = new ArrayList<>(fwdElements);\n+            newFwdElements.set(lastElementIdx, new CigarElement(lastElementLen, CigarOperator.H));\n+            fwd.setCigar(new Cigar(newFwdElements));\n+\n+            final byte[] revBases = rev.getBasesNoCopy();\n+            final int firstElementLen = revFirstElement.getLength();\n+            rev.setBases(Arrays.copyOfRange(revBases, firstElementLen, revBases.length));\n+            final byte[] revQuals = rev.getBaseQualitiesNoCopy();\n+            if ( revQuals.length > 0 ) {\n+                rev.setBaseQualities(Arrays.copyOfRange(revQuals, firstElementLen, revQuals.length));\n+            }\n+            final List<CigarElement> newRevElements = new ArrayList<>(revElements);\n+            newRevElements.set(0, new CigarElement(firstElementLen, CigarOperator.H));\n+            rev.setCigar(new Cigar(newRevElements));\n+        }\n+    }\n+\n+    @VisibleForTesting\n+    static void kmerizeReads( final List<GATKRead> reads,\n+                              final KmerSet<KmerAdjacency> kmerAdjacencySet ) {\n+        for ( final GATKRead read : reads ) {\n+            final byte[] calls = read.getBasesNoCopy();\n+            final byte[] quals = read.getBaseQualitiesNoCopy();\n+            KmerAdjacency.kmerize(calls, quals, QMIN, kmerAdjacencySet);\n+        }\n+    }\n+\n+    /** gather unbranched strings of kmers into contigs **/\n+    @VisibleForTesting\n+    static List<ContigImpl> buildContigs( final KmerSet<KmerAdjacency> kmerAdjacencySet ) {\n+        // gather strings of kmers that have a single predecessor and single successor into contigs\n+        final List<ContigImpl> contigs = new ArrayList<>();\n+        int nContigs = 0;\n+        for ( final KmerAdjacency kmerAdjacency : kmerAdjacencySet ) {\n+            if ( kmerAdjacency.getContig() == null ) {\n+                ContigImpl contig = null;\n+                final KmerAdjacency predecessor = kmerAdjacency.getSolePredecessor();\n+                if ( predecessor == null ||\n+                        predecessor.getSuccessorCount() > 1 ||\n+                        predecessor == kmerAdjacency.rc() ) {\n+                    contig = new ContigImpl(++nContigs, kmerAdjacency);\n+                } else {\n+                    final KmerAdjacency successor = kmerAdjacency.getSoleSuccessor();\n+                    if ( successor == null ||\n+                            successor.getPredecessorCount() > 1 ||\n+                            successor == kmerAdjacency.rc() ) {\n+                        contig = new ContigImpl(++nContigs, kmerAdjacency.rc());\n+                    }\n+                }\n+                if ( contig != null ) {\n+                    contigs.add(contig);\n+                }\n+            }\n+        }\n+\n+        // if there are smooth circles like a plasmid, gather them together as a contig, too\n+        for ( final KmerAdjacency kmerAdjacency : kmerAdjacencySet ) {\n+            if ( kmerAdjacency.getContig() == null ) {\n+                contigs.add(new ContigImpl(++nContigs, kmerAdjacency));\n+            }\n+        }\n+\n+        return contigs;\n+    }\n+\n+    /** connect contigs when the final kmer of one contig is adjacent to the inital contig of another **/\n+    @VisibleForTesting\n+    static void connectContigs( final List<ContigImpl> contigs ) {\n+        final int nContigs = contigs.size();\n+        final KmerSet<ContigEndKmer> contigEnds = new KmerSet<>(2*nContigs);\n+        for ( int contigId = 0; contigId != nContigs; ++contigId ) {\n+            final ContigImpl contig = contigs.get(contigId);\n+            final KmerAdjacency fwdKmer = contig.getFirstKmer();\n+            final KmerAdjacency revKmer = contig.getLastKmer().rc();\n+            if ( fwdKmer == revKmer ) {\n+                contigEnds.add(new ContigEndKmer(fwdKmer.getKVal(), contig, ContigOrientation.BOTH));\n+            } else {\n+                contigEnds.add(new ContigEndKmer(fwdKmer.getKVal(), contig, ContigOrientation.FWD));\n+                contigEnds.add(new ContigEndKmer(revKmer.getKVal(), contig, ContigOrientation.REV));\n+            }\n+        }\n+\n+        for ( int contigId = 0; contigId != nContigs; ++contigId ) {\n+            final Contig contig = contigs.get(contigId);\n+\n+            final KmerAdjacency start = contig.getFirstKmer();\n+            final int predecessorCount = start.getPredecessorCount();\n+            if ( predecessorCount > 0 ) {\n+                final List<Contig> predecessors = contig.getPredecessors();\n+                final int mask = start.getPredecessorMask();\n+                for ( int call = 0; call != 4; ++call ) {\n+                    if ( (mask & (1 << call)) != 0 ) {\n+                        final long kVal =\n+                                KmerAdjacency.reverseComplement(start.getPredecessorVal(call));\n+                        final ContigEndKmer contigEndKmer = contigEnds.find(new Kmer(kVal));\n+                        if ( contigEndKmer == null ) {\n+                            throw new GATKException(\"missing contig end kmer\");\n+                        }\n+                        switch ( contigEndKmer.getContigOrientation() ) {\n+                            case FWD:\n+                                predecessors.add(contigEndKmer.getContig().rc());\n+                                break;\n+                            case REV:\n+                                predecessors.add(contigEndKmer.getContig());\n+                                break;\n+                            case BOTH:\n+                                predecessors.add(contigEndKmer.getContig());\n+                                predecessors.add(contigEndKmer.getContig().rc());\n+                                break;\n+                        }\n+                    }\n+                }\n+            }\n+\n+            final KmerAdjacency end = contig.getLastKmer();\n+            final int successorCount = end.getSuccessorCount();\n+            if ( successorCount > 0 ) {\n+                final List<Contig> successors = contig.getSuccessors();\n+                final int mask = end.getSuccessorMask();\n+                for ( int call = 0; call != 4; ++call ) {\n+                    if ( (mask & (1 << call)) != 0 ) {\n+                        final long kVal = end.getSuccessorVal(call);\n+                        final ContigEndKmer contigEndKmer = contigEnds.find(new Kmer(kVal));\n+                        if ( contigEndKmer == null ) {\n+                            throw new GATKException(\"missing contig end kmer\");\n+                        }\n+                        switch ( contigEndKmer.getContigOrientation() ) {\n+                            case FWD:\n+                                successors.add(contigEndKmer.getContig());\n+                                break;\n+                            case REV:\n+                                successors.add(contigEndKmer.getContig().rc());\n+                                break;\n+                            case BOTH:\n+                                successors.add(contigEndKmer.getContig());\n+                                successors.add(contigEndKmer.getContig().rc());\n+                                break;\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    /** remove contigs that have little evidence **/\n+    @VisibleForTesting\n+    static void removeThinContigs( final List<ContigImpl> contigs,\n+                                           final KmerSet<KmerAdjacency> kmerAdjacencySet ) {\n+        contigs.sort(Comparator.comparingInt(ContigImpl::getMaxObservations));\n+        boolean contigRemoved;\n+        do {\n+            // figure out which contigs are cut points\n+            // i.e., those contigs which, if removed, would result in a graph with more connected components\n+            final int nContigs = contigs.size();\n+            final Map<Contig, CutData> cutDataMap = new HashMap<>(nContigs * 3);\n+\n+            for ( final ContigImpl contig : contigs ) {\n+                if ( cutDataMap.containsKey(contig) ) {\n+                    continue;\n+                }\n+\n+                cutDataMap.put(contig, new CutData());\n+                int children = 0;\n+                for ( final Contig nextContig : contig.getSuccessors() ) {\n+                    if ( !cutDataMap.containsKey(nextContig) ) {\n+                        findCuts(nextContig, contig, cutDataMap);\n+                        children += 1;\n+                    }\n+                }\n+                for ( final Contig nextContig : contig.getPredecessors() ) {\n+                    if ( !cutDataMap.containsKey(nextContig) ) {\n+                        findCuts(nextContig, contig, cutDataMap);\n+                        children += 1;\n+                    }\n+                }\n+                if ( children >= 2 ) {\n+                    contig.setCut(true);\n+                }\n+            }\n+\n+            // remove poorly attested (low max observations) contigs, unless they are cut points\n+            contigRemoved = false;\n+            final Iterator<ContigImpl> itr = contigs.iterator();\n+            while ( itr.hasNext() ) {\n+                final Contig contig = itr.next();\n+                if ( contig.getMaxObservations() < MIN_THIN_OBS && !contig.isCut() ) {\n+                    unlinkContig(contig, kmerAdjacencySet);\n+                    itr.remove();\n+                    contigRemoved = true;\n+                    break;\n+                }\n+            }\n+        } while ( contigRemoved );\n+        contigs.sort(Comparator.comparingInt(ContigImpl::getId));\n+    }\n+\n+    private static CutData findCuts( final Contig contig,\n+                                     final Contig parent,\n+                                     final Map<Contig, CutData> cutDataMap ) {\n+        final CutData cutData = new CutData();\n+        cutDataMap.put(contig, cutData);\n+        for ( final Contig nextContig : contig.getSuccessors() ) {\n+            if ( nextContig == parent ) {\n+                continue;\n+            }\n+            CutData nextCutData = cutDataMap.get(nextContig);\n+            if ( nextCutData != null ) {\n+                cutData.minVisitNum = Math.min(cutData.minVisitNum, nextCutData.visitNum);\n+            } else {\n+                nextCutData = findCuts(nextContig, contig, cutDataMap);\n+                cutData.minVisitNum = Math.min(cutData.minVisitNum, nextCutData.minVisitNum);\n+                if ( nextCutData.minVisitNum >= cutData.visitNum ) {\n+                    contig.setCut(true);\n+                }\n+            }\n+        }\n+        for ( final Contig nextContig : contig.getPredecessors() ) {\n+            if ( nextContig == parent ) {\n+                continue;\n+            }\n+            CutData nextCutData = cutDataMap.get(nextContig);\n+            if ( nextCutData != null ) {\n+                cutData.minVisitNum = Math.min(cutData.minVisitNum, nextCutData.visitNum);\n+            } else {\n+                nextCutData = findCuts(nextContig, contig, cutDataMap);\n+                cutData.minVisitNum = Math.min(cutData.minVisitNum, nextCutData.minVisitNum);\n+                if ( nextCutData.minVisitNum >= cutData.visitNum ) {\n+                    contig.setCut(true);\n+                }\n+            }\n+        }\n+        return cutData;\n+    }\n+\n+    @VisibleForTesting\n+    static void unlinkContig( final Contig contig,\n+                                      final KmerSet<KmerAdjacency> kmerAdjacencySet ) {\n+        final KmerAdjacency firstKmer = contig.getFirstKmer();\n+        final int firstKmerFinalCall = firstKmer.getFinalCall();\n+        for ( final Contig predecessor : contig.getPredecessors() ) {\n+            if ( predecessor != contig && predecessor != contig.rc() ) {\n+                predecessor.getLastKmer().removeSuccessor(firstKmerFinalCall, kmerAdjacencySet);\n+                if ( !predecessor.getSuccessors().remove(contig) ) {\n+                    throw new GATKException(\"failed to find predecessor link\");\n+                }\n+            }\n+        }\n+\n+        final KmerAdjacency lastKmer = contig.getLastKmer();\n+        final int lastKmerInitialCall = lastKmer.getInitialCall();\n+        for ( final Contig successor : contig.getSuccessors() ) {\n+            if ( successor != contig && successor != contig.rc() ) {\n+                successor.getFirstKmer().removePredecessor(lastKmerInitialCall, kmerAdjacencySet);\n+                if ( !successor.getPredecessors().remove(contig) ) {\n+                    throw new GATKException(\"failed to find successor link\");\n+                }\n+            }\n+        }\n+\n+        KmerAdjacency nextKmer = firstKmer;\n+        KmerAdjacency kmer;\n+        do {\n+            kmer = nextKmer;\n+            nextKmer = kmer.getSoleSuccessor();\n+            kmerAdjacencySet.remove(kmer.canonical());\n+        } while ( kmer != lastKmer );\n+    }\n+\n+    private static void updateKmerContig( final KmerAdjacency firstKmer,\n+                                          final KmerAdjacency lastKmer,\n+                                          final Contig contig ) {\n+        int offset = 0;\n+        for ( KmerAdjacency kmer = firstKmer; kmer != lastKmer; kmer = kmer.getSoleSuccessor() ) {\n+            if ( kmer == null ) {\n+                throw new GATKException(\"contig does not have a flat pipeline of kmers\");\n+            }\n+            kmer.clearContig();\n+            kmer.setContigOffset(contig, offset++);\n+        }\n+        lastKmer.clearContig();\n+        lastKmer.setContigOffset(contig, offset);\n+        if ( offset + Kmer.KSIZE != contig.size() ) {\n+            throw new GATKException(\"kmer chain length does not equal contig size\");\n+        }\n+    }\n+\n+    /** replace adjacent contigs without branches with a single, larger contig **/\n+    @VisibleForTesting\n+    static void weldPipes( final List<ContigImpl> contigs ) {\n+        for ( int contigIdx = 0; contigIdx != contigs.size(); ++contigIdx ) {\n+            final ContigImpl contig = contigs.get(contigIdx);\n+            if ( contig.getSuccessors().size() == 1 ) {\n+                final Contig successor = contig.getSuccessors().get(0);\n+                if ( successor != contig && successor != contig.rc() &&\n+                        successor.getPredecessors().size() == 1 ) {\n+                    contigs.set(contigIdx, join(contig.getId(), contig, successor));\n+                    if ( !contigs.remove(successor.canonical()) ) {\n+                        throw new GATKException(\"successor linkage is messed up\");\n+                    }\n+                    contigIdx -= 1; // reconsider the new contig -- there might be more joining possible\n+                    continue;\n+                }\n+            }\n+            if ( contig.getPredecessors().size() == 1 ) {\n+                final Contig predecessor = contig.getPredecessors().get(0);\n+                if ( predecessor != contig && predecessor != contig.rc() &&\n+                        predecessor.getSuccessors().size() == 1 ) {\n+                    contigs.set(contigIdx, join(contig.getId(), predecessor, contig));\n+                    if ( !contigs.remove(predecessor.canonical()) ) {\n+                        throw new GATKException(\"predecessor linkage is messed up\");\n+                    }\n+                    contigIdx -= 1; // reconsider\n+                }\n+            }\n+        }\n+    }\n+\n+    private static ContigImpl join( final int id, final Contig predecessor, final Contig successor ) {\n+        if ( !checkOverlap(predecessor.getSequence(), successor.getSequence()) ) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e2201c1ef4f8ba71f17e169f07756cfe2f1ecb49"}, "originalPosition": 477}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzczNjcyMjc3OnYy", "diffSide": "RIGHT", "path": "src/main/java/org/broadinstitute/hellbender/tools/LocalAssembler.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMy0xMFQxOTo0MToxNlrOI0ZwcQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMy0xMFQxOTo0MToxNlrOI0ZwcQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MTgxODg2NQ==", "bodyText": "Maybe make a method for this assembly pipeline (build, connect, removeThin, weld, markComponents) since you do it again if you fill any gaps.", "url": "https://github.com/broadinstitute/gatk/pull/6989#discussion_r591818865", "createdAt": "2021-03-10T19:41:16Z", "author": {"login": "cwhelan"}, "path": "src/main/java/org/broadinstitute/hellbender/tools/LocalAssembler.java", "diffHunk": "@@ -0,0 +1,2306 @@\n+package org.broadinstitute.hellbender.tools;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import htsjdk.samtools.Cigar;\n+import htsjdk.samtools.CigarElement;\n+import htsjdk.samtools.CigarOperator;\n+import htsjdk.samtools.SAMUtils;\n+import org.broadinstitute.barclay.argparser.Argument;\n+import org.broadinstitute.barclay.argparser.BetaFeature;\n+import org.broadinstitute.barclay.argparser.CommandLineProgramProperties;\n+import org.broadinstitute.barclay.help.DocumentedFeature;\n+import org.broadinstitute.hellbender.cmdline.StandardArgumentDefinitions;\n+import org.broadinstitute.hellbender.cmdline.programgroups.CoverageAnalysisProgramGroup;\n+import org.broadinstitute.hellbender.exceptions.GATKException;\n+import org.broadinstitute.hellbender.tools.walkers.PairWalker;\n+import org.broadinstitute.hellbender.utils.SimpleInterval;\n+import org.broadinstitute.hellbender.utils.collections.HopscotchSet;\n+import org.broadinstitute.hellbender.utils.gcs.BucketUtils;\n+import org.broadinstitute.hellbender.utils.read.GATKRead;\n+\n+import java.io.BufferedWriter;\n+import java.io.FileWriter;\n+import java.io.IOException;\n+import java.io.OutputStreamWriter;\n+import java.util.*;\n+import java.util.zip.GZIPOutputStream;\n+\n+@DocumentedFeature\n+@CommandLineProgramProperties(\n+        summary = \"experiment\",\n+        oneLineSummary = \"experiment\",\n+        usageExample = \"gatk LocalAssembler\",\n+        programGroup = CoverageAnalysisProgramGroup.class\n+)\n+@BetaFeature\n+public class LocalAssembler extends PairWalker {\n+    public static final byte QMIN = 25;\n+    public static final int MIN_THIN_OBS = 4;\n+    public static final int MIN_GAPFILL_COUNT = 3;\n+    public static final int TOO_MANY_TRAVERSALS = 100000;\n+    public static final int TOO_MANY_SCAFFOLDS = 50000;\n+    public static final int MIN_SV_SIZE = 50;\n+\n+    @Argument(fullName=StandardArgumentDefinitions.OUTPUT_LONG_NAME,\n+            shortName=StandardArgumentDefinitions.OUTPUT_SHORT_NAME,\n+            doc=\"Write outputs to this file name prefix\", optional = true)\n+    public static String output;\n+\n+    @Argument(fullName=\"assembly-name\", doc=\"name of assembly used as a prefix for traversal names\")\n+    public static String assemblyName;\n+\n+    private final List<GATKRead> reads = new ArrayList<>();\n+\n+    @Override public boolean requiresIntervals() { return true; }\n+\n+    @Override public void apply( final GATKRead read, final GATKRead mate ) {\n+        trimOverruns(read, mate);\n+        reads.add(read);\n+        reads.add(mate);\n+    }\n+\n+    @Override public void applyUnpaired( final GATKRead read ) {\n+        reads.add(read);\n+    }\n+\n+    @Override public Object onTraversalSuccess() {\n+        super.onTraversalSuccess(); // flush any incomplete pairs\n+\n+        final int regionSize = getTraversalIntervals().stream().mapToInt(SimpleInterval::size).sum();\n+        final KmerSet<KmerAdjacency> kmerAdjacencySet = new KmerSet<>(10 * regionSize);\n+        kmerizeReads(reads, kmerAdjacencySet);\n+        List<ContigImpl> contigs = buildContigs(kmerAdjacencySet);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e2201c1ef4f8ba71f17e169f07756cfe2f1ecb49"}, "originalPosition": 72}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzczNjc4NjQxOnYy", "diffSide": "RIGHT", "path": "src/main/java/org/broadinstitute/hellbender/tools/LocalAssembler.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMy0xMFQxOTo1Njo1MFrOI0aX7A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNC0xMlQyMDo1MjowNVrOJHmO0w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MTgyODk3Mg==", "bodyText": "A check to verify my understanding: Is the only intent of the gap filling to add in kmers that didn't make it in originally due to QMIN?", "url": "https://github.com/broadinstitute/gatk/pull/6989#discussion_r591828972", "createdAt": "2021-03-10T19:56:50Z", "author": {"login": "cwhelan"}, "path": "src/main/java/org/broadinstitute/hellbender/tools/LocalAssembler.java", "diffHunk": "@@ -0,0 +1,2306 @@\n+package org.broadinstitute.hellbender.tools;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import htsjdk.samtools.Cigar;\n+import htsjdk.samtools.CigarElement;\n+import htsjdk.samtools.CigarOperator;\n+import htsjdk.samtools.SAMUtils;\n+import org.broadinstitute.barclay.argparser.Argument;\n+import org.broadinstitute.barclay.argparser.BetaFeature;\n+import org.broadinstitute.barclay.argparser.CommandLineProgramProperties;\n+import org.broadinstitute.barclay.help.DocumentedFeature;\n+import org.broadinstitute.hellbender.cmdline.StandardArgumentDefinitions;\n+import org.broadinstitute.hellbender.cmdline.programgroups.CoverageAnalysisProgramGroup;\n+import org.broadinstitute.hellbender.exceptions.GATKException;\n+import org.broadinstitute.hellbender.tools.walkers.PairWalker;\n+import org.broadinstitute.hellbender.utils.SimpleInterval;\n+import org.broadinstitute.hellbender.utils.collections.HopscotchSet;\n+import org.broadinstitute.hellbender.utils.gcs.BucketUtils;\n+import org.broadinstitute.hellbender.utils.read.GATKRead;\n+\n+import java.io.BufferedWriter;\n+import java.io.FileWriter;\n+import java.io.IOException;\n+import java.io.OutputStreamWriter;\n+import java.util.*;\n+import java.util.zip.GZIPOutputStream;\n+\n+@DocumentedFeature\n+@CommandLineProgramProperties(\n+        summary = \"experiment\",\n+        oneLineSummary = \"experiment\",\n+        usageExample = \"gatk LocalAssembler\",\n+        programGroup = CoverageAnalysisProgramGroup.class\n+)\n+@BetaFeature\n+public class LocalAssembler extends PairWalker {\n+    public static final byte QMIN = 25;\n+    public static final int MIN_THIN_OBS = 4;\n+    public static final int MIN_GAPFILL_COUNT = 3;\n+    public static final int TOO_MANY_TRAVERSALS = 100000;\n+    public static final int TOO_MANY_SCAFFOLDS = 50000;\n+    public static final int MIN_SV_SIZE = 50;\n+\n+    @Argument(fullName=StandardArgumentDefinitions.OUTPUT_LONG_NAME,\n+            shortName=StandardArgumentDefinitions.OUTPUT_SHORT_NAME,\n+            doc=\"Write outputs to this file name prefix\", optional = true)\n+    public static String output;\n+\n+    @Argument(fullName=\"assembly-name\", doc=\"name of assembly used as a prefix for traversal names\")\n+    public static String assemblyName;\n+\n+    private final List<GATKRead> reads = new ArrayList<>();\n+\n+    @Override public boolean requiresIntervals() { return true; }\n+\n+    @Override public void apply( final GATKRead read, final GATKRead mate ) {\n+        trimOverruns(read, mate);\n+        reads.add(read);\n+        reads.add(mate);\n+    }\n+\n+    @Override public void applyUnpaired( final GATKRead read ) {\n+        reads.add(read);\n+    }\n+\n+    @Override public Object onTraversalSuccess() {\n+        super.onTraversalSuccess(); // flush any incomplete pairs\n+\n+        final int regionSize = getTraversalIntervals().stream().mapToInt(SimpleInterval::size).sum();\n+        final KmerSet<KmerAdjacency> kmerAdjacencySet = new KmerSet<>(10 * regionSize);\n+        kmerizeReads(reads, kmerAdjacencySet);\n+        List<ContigImpl> contigs = buildContigs(kmerAdjacencySet);\n+        connectContigs(contigs);\n+\n+        removeThinContigs(contigs, kmerAdjacencySet);\n+        weldPipes(contigs);\n+        markComponents(contigs);\n+\n+        if ( fillGaps(kmerAdjacencySet, reads) ) {\n+            contigs = buildContigs(kmerAdjacencySet);\n+            connectContigs(contigs);\n+            removeThinContigs(contigs, kmerAdjacencySet);\n+            weldPipes(contigs);\n+            markComponents(contigs);\n+        }\n+\n+        markCycles(contigs);\n+\n+        final String outputFilePrefix = output != null ? output : assemblyName;\n+        final List<Path> readPaths = pathReads(kmerAdjacencySet, reads);\n+        final Map<Contig,List<TransitPairCount>> contigTransitsMap =\n+                collectTransitPairCounts(contigs, readPaths);\n+        final String traversalsFilename = outputFilePrefix + \".traversals.fa.gz\";\n+        try {\n+            final List<Traversal> allTraversals =\n+                    new ArrayList<>(traverseAllPaths(contigs, readPaths, contigTransitsMap));\n+            writeTraversals(allTraversals, traversalsFilename);\n+            try {\n+                final String scaffoldsFileName = outputFilePrefix + \".scaffolds.fa.gz\";\n+                writeTraversals(createScaffolds(allTraversals), scaffoldsFileName);\n+            } catch ( final AssemblyTooComplexException x ) {\n+                logger.warn(\"Assembly too complex for scaffolding.\");\n+            }\n+        } catch ( final AssemblyTooComplexException x ) {\n+            logger.warn(\"Assembly too complex.  Writing contigs as traversals in \" +\n+                    traversalsFilename + \".\");\n+            final Collection<Traversal> contigTraversals = new ArrayList<>(contigs.size());\n+            for ( final Contig contig : contigs ) {\n+                contigTraversals.add(new Traversal(Collections.singletonList(contig)));\n+            }\n+            writeTraversals(contigTraversals, traversalsFilename);\n+        }\n+\n+        contigs.sort(Comparator.comparingInt(ContigImpl::getId));\n+        writeDOT(contigs, outputFilePrefix + \".assembly.dot\");\n+        writeContigs(contigs, outputFilePrefix + \".contigs.txt.gz\");\n+        writePaths(readPaths, outputFilePrefix + \".paths.txt.gz\");\n+        writeReads(reads, outputFilePrefix + \".reads.fastq.gz\");\n+        return null;\n+    }\n+\n+    /** trim read pairs of base calls that have gone past the end of a short fragment */\n+    private void trimOverruns( final GATKRead read, final GATKRead mate ) {\n+        // if both mapped and they're on different strands\n+        if ( !read.isUnmapped() && !mate.isUnmapped() &&\n+                read.isReverseStrand() != mate.isReverseStrand() ) {\n+            // and both start within 1 base on the ref\n+            if ( Math.abs(read.getStart() - read.getMateStart()) <= 1 ) {\n+                // and both end within 1 base\n+                final int readRefLen = read.getCigar().getReferenceLength();\n+                final int mateRefLen = mate.getCigar().getReferenceLength();\n+                if ( Math.abs(readRefLen - mateRefLen) <= 1 ) {\n+                    if ( mate.isReverseStrand() ) {\n+                        trimClips(read, mate);\n+                    } else {\n+                        trimClips(mate, read);\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    private void trimClips( final GATKRead fwd, final GATKRead rev ) {\n+        final List<CigarElement> fwdElements = fwd.getCigarElements();\n+        final List<CigarElement> revElements = rev.getCigarElements();\n+        final int lastElementIdx = fwdElements.size() - 1;\n+        final CigarElement fwdLastElement = fwdElements.get(lastElementIdx);\n+        final CigarElement revFirstElement = revElements.get(0);\n+        if ( fwdLastElement.getOperator() == CigarOperator.S &&\n+                revFirstElement.getOperator() == CigarOperator.S ) {\n+            final byte[] fwdBases = fwd.getBasesNoCopy();\n+            final int lastElementLen = fwdLastElement.getLength();\n+            fwd.setBases(Arrays.copyOfRange(fwdBases, 0, fwdBases.length - lastElementLen));\n+            final byte[] fwdQuals = fwd.getBaseQualitiesNoCopy();\n+            if ( fwdQuals.length > 0 ) {\n+                final int qualsLen = fwdQuals.length - lastElementLen;\n+                fwd.setBaseQualities(Arrays.copyOfRange(fwdQuals, 0, qualsLen));\n+            }\n+            final List<CigarElement> newFwdElements = new ArrayList<>(fwdElements);\n+            newFwdElements.set(lastElementIdx, new CigarElement(lastElementLen, CigarOperator.H));\n+            fwd.setCigar(new Cigar(newFwdElements));\n+\n+            final byte[] revBases = rev.getBasesNoCopy();\n+            final int firstElementLen = revFirstElement.getLength();\n+            rev.setBases(Arrays.copyOfRange(revBases, firstElementLen, revBases.length));\n+            final byte[] revQuals = rev.getBaseQualitiesNoCopy();\n+            if ( revQuals.length > 0 ) {\n+                rev.setBaseQualities(Arrays.copyOfRange(revQuals, firstElementLen, revQuals.length));\n+            }\n+            final List<CigarElement> newRevElements = new ArrayList<>(revElements);\n+            newRevElements.set(0, new CigarElement(firstElementLen, CigarOperator.H));\n+            rev.setCigar(new Cigar(newRevElements));\n+        }\n+    }\n+\n+    @VisibleForTesting\n+    static void kmerizeReads( final List<GATKRead> reads,\n+                              final KmerSet<KmerAdjacency> kmerAdjacencySet ) {\n+        for ( final GATKRead read : reads ) {\n+            final byte[] calls = read.getBasesNoCopy();\n+            final byte[] quals = read.getBaseQualitiesNoCopy();\n+            KmerAdjacency.kmerize(calls, quals, QMIN, kmerAdjacencySet);\n+        }\n+    }\n+\n+    /** gather unbranched strings of kmers into contigs **/\n+    @VisibleForTesting\n+    static List<ContigImpl> buildContigs( final KmerSet<KmerAdjacency> kmerAdjacencySet ) {\n+        // gather strings of kmers that have a single predecessor and single successor into contigs\n+        final List<ContigImpl> contigs = new ArrayList<>();\n+        int nContigs = 0;\n+        for ( final KmerAdjacency kmerAdjacency : kmerAdjacencySet ) {\n+            if ( kmerAdjacency.getContig() == null ) {\n+                ContigImpl contig = null;\n+                final KmerAdjacency predecessor = kmerAdjacency.getSolePredecessor();\n+                if ( predecessor == null ||\n+                        predecessor.getSuccessorCount() > 1 ||\n+                        predecessor == kmerAdjacency.rc() ) {\n+                    contig = new ContigImpl(++nContigs, kmerAdjacency);\n+                } else {\n+                    final KmerAdjacency successor = kmerAdjacency.getSoleSuccessor();\n+                    if ( successor == null ||\n+                            successor.getPredecessorCount() > 1 ||\n+                            successor == kmerAdjacency.rc() ) {\n+                        contig = new ContigImpl(++nContigs, kmerAdjacency.rc());\n+                    }\n+                }\n+                if ( contig != null ) {\n+                    contigs.add(contig);\n+                }\n+            }\n+        }\n+\n+        // if there are smooth circles like a plasmid, gather them together as a contig, too\n+        for ( final KmerAdjacency kmerAdjacency : kmerAdjacencySet ) {\n+            if ( kmerAdjacency.getContig() == null ) {\n+                contigs.add(new ContigImpl(++nContigs, kmerAdjacency));\n+            }\n+        }\n+\n+        return contigs;\n+    }\n+\n+    /** connect contigs when the final kmer of one contig is adjacent to the inital contig of another **/\n+    @VisibleForTesting\n+    static void connectContigs( final List<ContigImpl> contigs ) {\n+        final int nContigs = contigs.size();\n+        final KmerSet<ContigEndKmer> contigEnds = new KmerSet<>(2*nContigs);\n+        for ( int contigId = 0; contigId != nContigs; ++contigId ) {\n+            final ContigImpl contig = contigs.get(contigId);\n+            final KmerAdjacency fwdKmer = contig.getFirstKmer();\n+            final KmerAdjacency revKmer = contig.getLastKmer().rc();\n+            if ( fwdKmer == revKmer ) {\n+                contigEnds.add(new ContigEndKmer(fwdKmer.getKVal(), contig, ContigOrientation.BOTH));\n+            } else {\n+                contigEnds.add(new ContigEndKmer(fwdKmer.getKVal(), contig, ContigOrientation.FWD));\n+                contigEnds.add(new ContigEndKmer(revKmer.getKVal(), contig, ContigOrientation.REV));\n+            }\n+        }\n+\n+        for ( int contigId = 0; contigId != nContigs; ++contigId ) {\n+            final Contig contig = contigs.get(contigId);\n+\n+            final KmerAdjacency start = contig.getFirstKmer();\n+            final int predecessorCount = start.getPredecessorCount();\n+            if ( predecessorCount > 0 ) {\n+                final List<Contig> predecessors = contig.getPredecessors();\n+                final int mask = start.getPredecessorMask();\n+                for ( int call = 0; call != 4; ++call ) {\n+                    if ( (mask & (1 << call)) != 0 ) {\n+                        final long kVal =\n+                                KmerAdjacency.reverseComplement(start.getPredecessorVal(call));\n+                        final ContigEndKmer contigEndKmer = contigEnds.find(new Kmer(kVal));\n+                        if ( contigEndKmer == null ) {\n+                            throw new GATKException(\"missing contig end kmer\");\n+                        }\n+                        switch ( contigEndKmer.getContigOrientation() ) {\n+                            case FWD:\n+                                predecessors.add(contigEndKmer.getContig().rc());\n+                                break;\n+                            case REV:\n+                                predecessors.add(contigEndKmer.getContig());\n+                                break;\n+                            case BOTH:\n+                                predecessors.add(contigEndKmer.getContig());\n+                                predecessors.add(contigEndKmer.getContig().rc());\n+                                break;\n+                        }\n+                    }\n+                }\n+            }\n+\n+            final KmerAdjacency end = contig.getLastKmer();\n+            final int successorCount = end.getSuccessorCount();\n+            if ( successorCount > 0 ) {\n+                final List<Contig> successors = contig.getSuccessors();\n+                final int mask = end.getSuccessorMask();\n+                for ( int call = 0; call != 4; ++call ) {\n+                    if ( (mask & (1 << call)) != 0 ) {\n+                        final long kVal = end.getSuccessorVal(call);\n+                        final ContigEndKmer contigEndKmer = contigEnds.find(new Kmer(kVal));\n+                        if ( contigEndKmer == null ) {\n+                            throw new GATKException(\"missing contig end kmer\");\n+                        }\n+                        switch ( contigEndKmer.getContigOrientation() ) {\n+                            case FWD:\n+                                successors.add(contigEndKmer.getContig());\n+                                break;\n+                            case REV:\n+                                successors.add(contigEndKmer.getContig().rc());\n+                                break;\n+                            case BOTH:\n+                                successors.add(contigEndKmer.getContig());\n+                                successors.add(contigEndKmer.getContig().rc());\n+                                break;\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    /** remove contigs that have little evidence **/\n+    @VisibleForTesting\n+    static void removeThinContigs( final List<ContigImpl> contigs,\n+                                           final KmerSet<KmerAdjacency> kmerAdjacencySet ) {\n+        contigs.sort(Comparator.comparingInt(ContigImpl::getMaxObservations));\n+        boolean contigRemoved;\n+        do {\n+            // figure out which contigs are cut points\n+            // i.e., those contigs which, if removed, would result in a graph with more connected components\n+            final int nContigs = contigs.size();\n+            final Map<Contig, CutData> cutDataMap = new HashMap<>(nContigs * 3);\n+\n+            for ( final ContigImpl contig : contigs ) {\n+                if ( cutDataMap.containsKey(contig) ) {\n+                    continue;\n+                }\n+\n+                cutDataMap.put(contig, new CutData());\n+                int children = 0;\n+                for ( final Contig nextContig : contig.getSuccessors() ) {\n+                    if ( !cutDataMap.containsKey(nextContig) ) {\n+                        findCuts(nextContig, contig, cutDataMap);\n+                        children += 1;\n+                    }\n+                }\n+                for ( final Contig nextContig : contig.getPredecessors() ) {\n+                    if ( !cutDataMap.containsKey(nextContig) ) {\n+                        findCuts(nextContig, contig, cutDataMap);\n+                        children += 1;\n+                    }\n+                }\n+                if ( children >= 2 ) {\n+                    contig.setCut(true);\n+                }\n+            }\n+\n+            // remove poorly attested (low max observations) contigs, unless they are cut points\n+            contigRemoved = false;\n+            final Iterator<ContigImpl> itr = contigs.iterator();\n+            while ( itr.hasNext() ) {\n+                final Contig contig = itr.next();\n+                if ( contig.getMaxObservations() < MIN_THIN_OBS && !contig.isCut() ) {\n+                    unlinkContig(contig, kmerAdjacencySet);\n+                    itr.remove();\n+                    contigRemoved = true;\n+                    break;\n+                }\n+            }\n+        } while ( contigRemoved );\n+        contigs.sort(Comparator.comparingInt(ContigImpl::getId));\n+    }\n+\n+    private static CutData findCuts( final Contig contig,\n+                                     final Contig parent,\n+                                     final Map<Contig, CutData> cutDataMap ) {\n+        final CutData cutData = new CutData();\n+        cutDataMap.put(contig, cutData);\n+        for ( final Contig nextContig : contig.getSuccessors() ) {\n+            if ( nextContig == parent ) {\n+                continue;\n+            }\n+            CutData nextCutData = cutDataMap.get(nextContig);\n+            if ( nextCutData != null ) {\n+                cutData.minVisitNum = Math.min(cutData.minVisitNum, nextCutData.visitNum);\n+            } else {\n+                nextCutData = findCuts(nextContig, contig, cutDataMap);\n+                cutData.minVisitNum = Math.min(cutData.minVisitNum, nextCutData.minVisitNum);\n+                if ( nextCutData.minVisitNum >= cutData.visitNum ) {\n+                    contig.setCut(true);\n+                }\n+            }\n+        }\n+        for ( final Contig nextContig : contig.getPredecessors() ) {\n+            if ( nextContig == parent ) {\n+                continue;\n+            }\n+            CutData nextCutData = cutDataMap.get(nextContig);\n+            if ( nextCutData != null ) {\n+                cutData.minVisitNum = Math.min(cutData.minVisitNum, nextCutData.visitNum);\n+            } else {\n+                nextCutData = findCuts(nextContig, contig, cutDataMap);\n+                cutData.minVisitNum = Math.min(cutData.minVisitNum, nextCutData.minVisitNum);\n+                if ( nextCutData.minVisitNum >= cutData.visitNum ) {\n+                    contig.setCut(true);\n+                }\n+            }\n+        }\n+        return cutData;\n+    }\n+\n+    @VisibleForTesting\n+    static void unlinkContig( final Contig contig,\n+                                      final KmerSet<KmerAdjacency> kmerAdjacencySet ) {\n+        final KmerAdjacency firstKmer = contig.getFirstKmer();\n+        final int firstKmerFinalCall = firstKmer.getFinalCall();\n+        for ( final Contig predecessor : contig.getPredecessors() ) {\n+            if ( predecessor != contig && predecessor != contig.rc() ) {\n+                predecessor.getLastKmer().removeSuccessor(firstKmerFinalCall, kmerAdjacencySet);\n+                if ( !predecessor.getSuccessors().remove(contig) ) {\n+                    throw new GATKException(\"failed to find predecessor link\");\n+                }\n+            }\n+        }\n+\n+        final KmerAdjacency lastKmer = contig.getLastKmer();\n+        final int lastKmerInitialCall = lastKmer.getInitialCall();\n+        for ( final Contig successor : contig.getSuccessors() ) {\n+            if ( successor != contig && successor != contig.rc() ) {\n+                successor.getFirstKmer().removePredecessor(lastKmerInitialCall, kmerAdjacencySet);\n+                if ( !successor.getPredecessors().remove(contig) ) {\n+                    throw new GATKException(\"failed to find successor link\");\n+                }\n+            }\n+        }\n+\n+        KmerAdjacency nextKmer = firstKmer;\n+        KmerAdjacency kmer;\n+        do {\n+            kmer = nextKmer;\n+            nextKmer = kmer.getSoleSuccessor();\n+            kmerAdjacencySet.remove(kmer.canonical());\n+        } while ( kmer != lastKmer );\n+    }\n+\n+    private static void updateKmerContig( final KmerAdjacency firstKmer,\n+                                          final KmerAdjacency lastKmer,\n+                                          final Contig contig ) {\n+        int offset = 0;\n+        for ( KmerAdjacency kmer = firstKmer; kmer != lastKmer; kmer = kmer.getSoleSuccessor() ) {\n+            if ( kmer == null ) {\n+                throw new GATKException(\"contig does not have a flat pipeline of kmers\");\n+            }\n+            kmer.clearContig();\n+            kmer.setContigOffset(contig, offset++);\n+        }\n+        lastKmer.clearContig();\n+        lastKmer.setContigOffset(contig, offset);\n+        if ( offset + Kmer.KSIZE != contig.size() ) {\n+            throw new GATKException(\"kmer chain length does not equal contig size\");\n+        }\n+    }\n+\n+    /** replace adjacent contigs without branches with a single, larger contig **/\n+    @VisibleForTesting\n+    static void weldPipes( final List<ContigImpl> contigs ) {\n+        for ( int contigIdx = 0; contigIdx != contigs.size(); ++contigIdx ) {\n+            final ContigImpl contig = contigs.get(contigIdx);\n+            if ( contig.getSuccessors().size() == 1 ) {\n+                final Contig successor = contig.getSuccessors().get(0);\n+                if ( successor != contig && successor != contig.rc() &&\n+                        successor.getPredecessors().size() == 1 ) {\n+                    contigs.set(contigIdx, join(contig.getId(), contig, successor));\n+                    if ( !contigs.remove(successor.canonical()) ) {\n+                        throw new GATKException(\"successor linkage is messed up\");\n+                    }\n+                    contigIdx -= 1; // reconsider the new contig -- there might be more joining possible\n+                    continue;\n+                }\n+            }\n+            if ( contig.getPredecessors().size() == 1 ) {\n+                final Contig predecessor = contig.getPredecessors().get(0);\n+                if ( predecessor != contig && predecessor != contig.rc() &&\n+                        predecessor.getSuccessors().size() == 1 ) {\n+                    contigs.set(contigIdx, join(contig.getId(), predecessor, contig));\n+                    if ( !contigs.remove(predecessor.canonical()) ) {\n+                        throw new GATKException(\"predecessor linkage is messed up\");\n+                    }\n+                    contigIdx -= 1; // reconsider\n+                }\n+            }\n+        }\n+    }\n+\n+    private static ContigImpl join( final int id, final Contig predecessor, final Contig successor ) {\n+        if ( !checkOverlap(predecessor.getSequence(), successor.getSequence()) ) {\n+                throw new GATKException(\"sequences can't be joined\");\n+        }\n+        final ContigImpl joinedContig = new ContigImpl(id, predecessor, successor);\n+        updateKmerContig(joinedContig.getFirstKmer(), joinedContig.getLastKmer(), joinedContig);\n+        return joinedContig;\n+    }\n+\n+    private static boolean checkOverlap( final CharSequence seq1, final CharSequence seq2 ) {\n+        final int seq1Len = seq1.length();\n+        final CharSequence seq1SubSeq = seq1.subSequence(seq1Len - Kmer.KSIZE + 1, seq1Len);\n+        final CharSequence seq2SubSeq = seq2.subSequence(0, Kmer.KSIZE - 1);\n+        return seq1SubSeq.equals(seq2SubSeq);\n+    }\n+\n+    /** set a unique componentId for every connected group of contigs **/\n+    @VisibleForTesting\n+    static int markComponents( final List<ContigImpl> contigs ) {\n+        for ( final ContigImpl contig : contigs ) {\n+            contig.setComponentId(0);\n+        }\n+\n+        int componentId = 0;\n+        for ( final ContigImpl contig : contigs ) {\n+            if ( contig.getComponentId() == 0 ) {\n+                contig.setComponentId(++componentId);\n+                markSuccessorComponents(contig);\n+                markSuccessorComponents(contig.rc());\n+            }\n+        }\n+        return componentId;\n+    }\n+\n+    private static void markSuccessorComponents( final Contig contig ) {\n+        final int componentId = contig.getComponentId();\n+        for ( final Contig successor : contig.getSuccessors() ) {\n+            if ( successor.getComponentId() == 0 ) {\n+                successor.canonical().setComponentId(componentId);\n+                markSuccessorComponents(successor);\n+                markSuccessorComponents(successor.rc());\n+            }\n+        }\n+    }\n+\n+    @VisibleForTesting\n+    static void markCycles( final List<ContigImpl> contigs ) {\n+        for ( final Contig contig : contigs ) {\n+            contig.setCyclic(false);\n+        }\n+\n+        final int nContigs = contigs.size();\n+        final Deque<Contig> deque = new ArrayDeque<>(nContigs);\n+        final Map<Contig, CutData> cutDataMap = new HashMap<>(nContigs * 3);\n+        for ( final Contig contig : contigs ) {\n+            if ( !cutDataMap.containsKey(contig) ) {\n+                markCyclesRecursion(contig, deque, cutDataMap);\n+            }\n+        }\n+    }\n+\n+    private static CutData markCyclesRecursion( final Contig contig,\n+                                                final Deque<Contig> deque,\n+                                                final Map<Contig, CutData> cutDataMap ) {\n+        final CutData cutData = new CutData();\n+        cutDataMap.put(contig, cutData);\n+        deque.addFirst(contig);\n+\n+        for ( final Contig successor : contig.getSuccessors() ) {\n+            final CutData successorCutData = cutDataMap.get(successor);\n+            if ( successorCutData == null ) {\n+                final int recursionVisitNum =\n+                        markCyclesRecursion(successor, deque, cutDataMap).minVisitNum;\n+                cutData.minVisitNum = Math.min(cutData.minVisitNum, recursionVisitNum);\n+            } else {\n+                cutData.minVisitNum = Math.min(cutData.minVisitNum, successorCutData.visitNum);\n+            }\n+        }\n+\n+        if ( cutData.visitNum == cutData.minVisitNum ) {\n+            Contig tig = deque.removeFirst();\n+            if ( tig == contig ) {\n+                cutDataMap.get(tig).visitNum = Integer.MAX_VALUE;\n+\n+                // single-vertex component -- cyclic only if self-referential\n+                if ( tig.getSuccessors().contains(tig) ) {\n+                    tig.setCyclic(true);\n+                }\n+            } else {\n+                while ( true ) {\n+                    // kill cross-links\n+                    cutDataMap.get(tig).visitNum = Integer.MAX_VALUE;\n+                    tig.setCyclic(true);\n+                    if ( tig == contig ) break;\n+                    tig = deque.removeFirst();\n+                }\n+            }\n+        }\n+        return cutData;\n+    }\n+\n+    @VisibleForTesting\n+    static boolean fillGaps( final KmerSet<KmerAdjacency> kmerAdjacencySet,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e2201c1ef4f8ba71f17e169f07756cfe2f1ecb49"}, "originalPosition": 578}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxMTk0NjE5NQ==", "bodyText": "Yes.", "url": "https://github.com/broadinstitute/gatk/pull/6989#discussion_r611946195", "createdAt": "2021-04-12T20:52:05Z", "author": {"login": "tedsharpe"}, "path": "src/main/java/org/broadinstitute/hellbender/tools/LocalAssembler.java", "diffHunk": "@@ -0,0 +1,2306 @@\n+package org.broadinstitute.hellbender.tools;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import htsjdk.samtools.Cigar;\n+import htsjdk.samtools.CigarElement;\n+import htsjdk.samtools.CigarOperator;\n+import htsjdk.samtools.SAMUtils;\n+import org.broadinstitute.barclay.argparser.Argument;\n+import org.broadinstitute.barclay.argparser.BetaFeature;\n+import org.broadinstitute.barclay.argparser.CommandLineProgramProperties;\n+import org.broadinstitute.barclay.help.DocumentedFeature;\n+import org.broadinstitute.hellbender.cmdline.StandardArgumentDefinitions;\n+import org.broadinstitute.hellbender.cmdline.programgroups.CoverageAnalysisProgramGroup;\n+import org.broadinstitute.hellbender.exceptions.GATKException;\n+import org.broadinstitute.hellbender.tools.walkers.PairWalker;\n+import org.broadinstitute.hellbender.utils.SimpleInterval;\n+import org.broadinstitute.hellbender.utils.collections.HopscotchSet;\n+import org.broadinstitute.hellbender.utils.gcs.BucketUtils;\n+import org.broadinstitute.hellbender.utils.read.GATKRead;\n+\n+import java.io.BufferedWriter;\n+import java.io.FileWriter;\n+import java.io.IOException;\n+import java.io.OutputStreamWriter;\n+import java.util.*;\n+import java.util.zip.GZIPOutputStream;\n+\n+@DocumentedFeature\n+@CommandLineProgramProperties(\n+        summary = \"experiment\",\n+        oneLineSummary = \"experiment\",\n+        usageExample = \"gatk LocalAssembler\",\n+        programGroup = CoverageAnalysisProgramGroup.class\n+)\n+@BetaFeature\n+public class LocalAssembler extends PairWalker {\n+    public static final byte QMIN = 25;\n+    public static final int MIN_THIN_OBS = 4;\n+    public static final int MIN_GAPFILL_COUNT = 3;\n+    public static final int TOO_MANY_TRAVERSALS = 100000;\n+    public static final int TOO_MANY_SCAFFOLDS = 50000;\n+    public static final int MIN_SV_SIZE = 50;\n+\n+    @Argument(fullName=StandardArgumentDefinitions.OUTPUT_LONG_NAME,\n+            shortName=StandardArgumentDefinitions.OUTPUT_SHORT_NAME,\n+            doc=\"Write outputs to this file name prefix\", optional = true)\n+    public static String output;\n+\n+    @Argument(fullName=\"assembly-name\", doc=\"name of assembly used as a prefix for traversal names\")\n+    public static String assemblyName;\n+\n+    private final List<GATKRead> reads = new ArrayList<>();\n+\n+    @Override public boolean requiresIntervals() { return true; }\n+\n+    @Override public void apply( final GATKRead read, final GATKRead mate ) {\n+        trimOverruns(read, mate);\n+        reads.add(read);\n+        reads.add(mate);\n+    }\n+\n+    @Override public void applyUnpaired( final GATKRead read ) {\n+        reads.add(read);\n+    }\n+\n+    @Override public Object onTraversalSuccess() {\n+        super.onTraversalSuccess(); // flush any incomplete pairs\n+\n+        final int regionSize = getTraversalIntervals().stream().mapToInt(SimpleInterval::size).sum();\n+        final KmerSet<KmerAdjacency> kmerAdjacencySet = new KmerSet<>(10 * regionSize);\n+        kmerizeReads(reads, kmerAdjacencySet);\n+        List<ContigImpl> contigs = buildContigs(kmerAdjacencySet);\n+        connectContigs(contigs);\n+\n+        removeThinContigs(contigs, kmerAdjacencySet);\n+        weldPipes(contigs);\n+        markComponents(contigs);\n+\n+        if ( fillGaps(kmerAdjacencySet, reads) ) {\n+            contigs = buildContigs(kmerAdjacencySet);\n+            connectContigs(contigs);\n+            removeThinContigs(contigs, kmerAdjacencySet);\n+            weldPipes(contigs);\n+            markComponents(contigs);\n+        }\n+\n+        markCycles(contigs);\n+\n+        final String outputFilePrefix = output != null ? output : assemblyName;\n+        final List<Path> readPaths = pathReads(kmerAdjacencySet, reads);\n+        final Map<Contig,List<TransitPairCount>> contigTransitsMap =\n+                collectTransitPairCounts(contigs, readPaths);\n+        final String traversalsFilename = outputFilePrefix + \".traversals.fa.gz\";\n+        try {\n+            final List<Traversal> allTraversals =\n+                    new ArrayList<>(traverseAllPaths(contigs, readPaths, contigTransitsMap));\n+            writeTraversals(allTraversals, traversalsFilename);\n+            try {\n+                final String scaffoldsFileName = outputFilePrefix + \".scaffolds.fa.gz\";\n+                writeTraversals(createScaffolds(allTraversals), scaffoldsFileName);\n+            } catch ( final AssemblyTooComplexException x ) {\n+                logger.warn(\"Assembly too complex for scaffolding.\");\n+            }\n+        } catch ( final AssemblyTooComplexException x ) {\n+            logger.warn(\"Assembly too complex.  Writing contigs as traversals in \" +\n+                    traversalsFilename + \".\");\n+            final Collection<Traversal> contigTraversals = new ArrayList<>(contigs.size());\n+            for ( final Contig contig : contigs ) {\n+                contigTraversals.add(new Traversal(Collections.singletonList(contig)));\n+            }\n+            writeTraversals(contigTraversals, traversalsFilename);\n+        }\n+\n+        contigs.sort(Comparator.comparingInt(ContigImpl::getId));\n+        writeDOT(contigs, outputFilePrefix + \".assembly.dot\");\n+        writeContigs(contigs, outputFilePrefix + \".contigs.txt.gz\");\n+        writePaths(readPaths, outputFilePrefix + \".paths.txt.gz\");\n+        writeReads(reads, outputFilePrefix + \".reads.fastq.gz\");\n+        return null;\n+    }\n+\n+    /** trim read pairs of base calls that have gone past the end of a short fragment */\n+    private void trimOverruns( final GATKRead read, final GATKRead mate ) {\n+        // if both mapped and they're on different strands\n+        if ( !read.isUnmapped() && !mate.isUnmapped() &&\n+                read.isReverseStrand() != mate.isReverseStrand() ) {\n+            // and both start within 1 base on the ref\n+            if ( Math.abs(read.getStart() - read.getMateStart()) <= 1 ) {\n+                // and both end within 1 base\n+                final int readRefLen = read.getCigar().getReferenceLength();\n+                final int mateRefLen = mate.getCigar().getReferenceLength();\n+                if ( Math.abs(readRefLen - mateRefLen) <= 1 ) {\n+                    if ( mate.isReverseStrand() ) {\n+                        trimClips(read, mate);\n+                    } else {\n+                        trimClips(mate, read);\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    private void trimClips( final GATKRead fwd, final GATKRead rev ) {\n+        final List<CigarElement> fwdElements = fwd.getCigarElements();\n+        final List<CigarElement> revElements = rev.getCigarElements();\n+        final int lastElementIdx = fwdElements.size() - 1;\n+        final CigarElement fwdLastElement = fwdElements.get(lastElementIdx);\n+        final CigarElement revFirstElement = revElements.get(0);\n+        if ( fwdLastElement.getOperator() == CigarOperator.S &&\n+                revFirstElement.getOperator() == CigarOperator.S ) {\n+            final byte[] fwdBases = fwd.getBasesNoCopy();\n+            final int lastElementLen = fwdLastElement.getLength();\n+            fwd.setBases(Arrays.copyOfRange(fwdBases, 0, fwdBases.length - lastElementLen));\n+            final byte[] fwdQuals = fwd.getBaseQualitiesNoCopy();\n+            if ( fwdQuals.length > 0 ) {\n+                final int qualsLen = fwdQuals.length - lastElementLen;\n+                fwd.setBaseQualities(Arrays.copyOfRange(fwdQuals, 0, qualsLen));\n+            }\n+            final List<CigarElement> newFwdElements = new ArrayList<>(fwdElements);\n+            newFwdElements.set(lastElementIdx, new CigarElement(lastElementLen, CigarOperator.H));\n+            fwd.setCigar(new Cigar(newFwdElements));\n+\n+            final byte[] revBases = rev.getBasesNoCopy();\n+            final int firstElementLen = revFirstElement.getLength();\n+            rev.setBases(Arrays.copyOfRange(revBases, firstElementLen, revBases.length));\n+            final byte[] revQuals = rev.getBaseQualitiesNoCopy();\n+            if ( revQuals.length > 0 ) {\n+                rev.setBaseQualities(Arrays.copyOfRange(revQuals, firstElementLen, revQuals.length));\n+            }\n+            final List<CigarElement> newRevElements = new ArrayList<>(revElements);\n+            newRevElements.set(0, new CigarElement(firstElementLen, CigarOperator.H));\n+            rev.setCigar(new Cigar(newRevElements));\n+        }\n+    }\n+\n+    @VisibleForTesting\n+    static void kmerizeReads( final List<GATKRead> reads,\n+                              final KmerSet<KmerAdjacency> kmerAdjacencySet ) {\n+        for ( final GATKRead read : reads ) {\n+            final byte[] calls = read.getBasesNoCopy();\n+            final byte[] quals = read.getBaseQualitiesNoCopy();\n+            KmerAdjacency.kmerize(calls, quals, QMIN, kmerAdjacencySet);\n+        }\n+    }\n+\n+    /** gather unbranched strings of kmers into contigs **/\n+    @VisibleForTesting\n+    static List<ContigImpl> buildContigs( final KmerSet<KmerAdjacency> kmerAdjacencySet ) {\n+        // gather strings of kmers that have a single predecessor and single successor into contigs\n+        final List<ContigImpl> contigs = new ArrayList<>();\n+        int nContigs = 0;\n+        for ( final KmerAdjacency kmerAdjacency : kmerAdjacencySet ) {\n+            if ( kmerAdjacency.getContig() == null ) {\n+                ContigImpl contig = null;\n+                final KmerAdjacency predecessor = kmerAdjacency.getSolePredecessor();\n+                if ( predecessor == null ||\n+                        predecessor.getSuccessorCount() > 1 ||\n+                        predecessor == kmerAdjacency.rc() ) {\n+                    contig = new ContigImpl(++nContigs, kmerAdjacency);\n+                } else {\n+                    final KmerAdjacency successor = kmerAdjacency.getSoleSuccessor();\n+                    if ( successor == null ||\n+                            successor.getPredecessorCount() > 1 ||\n+                            successor == kmerAdjacency.rc() ) {\n+                        contig = new ContigImpl(++nContigs, kmerAdjacency.rc());\n+                    }\n+                }\n+                if ( contig != null ) {\n+                    contigs.add(contig);\n+                }\n+            }\n+        }\n+\n+        // if there are smooth circles like a plasmid, gather them together as a contig, too\n+        for ( final KmerAdjacency kmerAdjacency : kmerAdjacencySet ) {\n+            if ( kmerAdjacency.getContig() == null ) {\n+                contigs.add(new ContigImpl(++nContigs, kmerAdjacency));\n+            }\n+        }\n+\n+        return contigs;\n+    }\n+\n+    /** connect contigs when the final kmer of one contig is adjacent to the inital contig of another **/\n+    @VisibleForTesting\n+    static void connectContigs( final List<ContigImpl> contigs ) {\n+        final int nContigs = contigs.size();\n+        final KmerSet<ContigEndKmer> contigEnds = new KmerSet<>(2*nContigs);\n+        for ( int contigId = 0; contigId != nContigs; ++contigId ) {\n+            final ContigImpl contig = contigs.get(contigId);\n+            final KmerAdjacency fwdKmer = contig.getFirstKmer();\n+            final KmerAdjacency revKmer = contig.getLastKmer().rc();\n+            if ( fwdKmer == revKmer ) {\n+                contigEnds.add(new ContigEndKmer(fwdKmer.getKVal(), contig, ContigOrientation.BOTH));\n+            } else {\n+                contigEnds.add(new ContigEndKmer(fwdKmer.getKVal(), contig, ContigOrientation.FWD));\n+                contigEnds.add(new ContigEndKmer(revKmer.getKVal(), contig, ContigOrientation.REV));\n+            }\n+        }\n+\n+        for ( int contigId = 0; contigId != nContigs; ++contigId ) {\n+            final Contig contig = contigs.get(contigId);\n+\n+            final KmerAdjacency start = contig.getFirstKmer();\n+            final int predecessorCount = start.getPredecessorCount();\n+            if ( predecessorCount > 0 ) {\n+                final List<Contig> predecessors = contig.getPredecessors();\n+                final int mask = start.getPredecessorMask();\n+                for ( int call = 0; call != 4; ++call ) {\n+                    if ( (mask & (1 << call)) != 0 ) {\n+                        final long kVal =\n+                                KmerAdjacency.reverseComplement(start.getPredecessorVal(call));\n+                        final ContigEndKmer contigEndKmer = contigEnds.find(new Kmer(kVal));\n+                        if ( contigEndKmer == null ) {\n+                            throw new GATKException(\"missing contig end kmer\");\n+                        }\n+                        switch ( contigEndKmer.getContigOrientation() ) {\n+                            case FWD:\n+                                predecessors.add(contigEndKmer.getContig().rc());\n+                                break;\n+                            case REV:\n+                                predecessors.add(contigEndKmer.getContig());\n+                                break;\n+                            case BOTH:\n+                                predecessors.add(contigEndKmer.getContig());\n+                                predecessors.add(contigEndKmer.getContig().rc());\n+                                break;\n+                        }\n+                    }\n+                }\n+            }\n+\n+            final KmerAdjacency end = contig.getLastKmer();\n+            final int successorCount = end.getSuccessorCount();\n+            if ( successorCount > 0 ) {\n+                final List<Contig> successors = contig.getSuccessors();\n+                final int mask = end.getSuccessorMask();\n+                for ( int call = 0; call != 4; ++call ) {\n+                    if ( (mask & (1 << call)) != 0 ) {\n+                        final long kVal = end.getSuccessorVal(call);\n+                        final ContigEndKmer contigEndKmer = contigEnds.find(new Kmer(kVal));\n+                        if ( contigEndKmer == null ) {\n+                            throw new GATKException(\"missing contig end kmer\");\n+                        }\n+                        switch ( contigEndKmer.getContigOrientation() ) {\n+                            case FWD:\n+                                successors.add(contigEndKmer.getContig());\n+                                break;\n+                            case REV:\n+                                successors.add(contigEndKmer.getContig().rc());\n+                                break;\n+                            case BOTH:\n+                                successors.add(contigEndKmer.getContig());\n+                                successors.add(contigEndKmer.getContig().rc());\n+                                break;\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    /** remove contigs that have little evidence **/\n+    @VisibleForTesting\n+    static void removeThinContigs( final List<ContigImpl> contigs,\n+                                           final KmerSet<KmerAdjacency> kmerAdjacencySet ) {\n+        contigs.sort(Comparator.comparingInt(ContigImpl::getMaxObservations));\n+        boolean contigRemoved;\n+        do {\n+            // figure out which contigs are cut points\n+            // i.e., those contigs which, if removed, would result in a graph with more connected components\n+            final int nContigs = contigs.size();\n+            final Map<Contig, CutData> cutDataMap = new HashMap<>(nContigs * 3);\n+\n+            for ( final ContigImpl contig : contigs ) {\n+                if ( cutDataMap.containsKey(contig) ) {\n+                    continue;\n+                }\n+\n+                cutDataMap.put(contig, new CutData());\n+                int children = 0;\n+                for ( final Contig nextContig : contig.getSuccessors() ) {\n+                    if ( !cutDataMap.containsKey(nextContig) ) {\n+                        findCuts(nextContig, contig, cutDataMap);\n+                        children += 1;\n+                    }\n+                }\n+                for ( final Contig nextContig : contig.getPredecessors() ) {\n+                    if ( !cutDataMap.containsKey(nextContig) ) {\n+                        findCuts(nextContig, contig, cutDataMap);\n+                        children += 1;\n+                    }\n+                }\n+                if ( children >= 2 ) {\n+                    contig.setCut(true);\n+                }\n+            }\n+\n+            // remove poorly attested (low max observations) contigs, unless they are cut points\n+            contigRemoved = false;\n+            final Iterator<ContigImpl> itr = contigs.iterator();\n+            while ( itr.hasNext() ) {\n+                final Contig contig = itr.next();\n+                if ( contig.getMaxObservations() < MIN_THIN_OBS && !contig.isCut() ) {\n+                    unlinkContig(contig, kmerAdjacencySet);\n+                    itr.remove();\n+                    contigRemoved = true;\n+                    break;\n+                }\n+            }\n+        } while ( contigRemoved );\n+        contigs.sort(Comparator.comparingInt(ContigImpl::getId));\n+    }\n+\n+    private static CutData findCuts( final Contig contig,\n+                                     final Contig parent,\n+                                     final Map<Contig, CutData> cutDataMap ) {\n+        final CutData cutData = new CutData();\n+        cutDataMap.put(contig, cutData);\n+        for ( final Contig nextContig : contig.getSuccessors() ) {\n+            if ( nextContig == parent ) {\n+                continue;\n+            }\n+            CutData nextCutData = cutDataMap.get(nextContig);\n+            if ( nextCutData != null ) {\n+                cutData.minVisitNum = Math.min(cutData.minVisitNum, nextCutData.visitNum);\n+            } else {\n+                nextCutData = findCuts(nextContig, contig, cutDataMap);\n+                cutData.minVisitNum = Math.min(cutData.minVisitNum, nextCutData.minVisitNum);\n+                if ( nextCutData.minVisitNum >= cutData.visitNum ) {\n+                    contig.setCut(true);\n+                }\n+            }\n+        }\n+        for ( final Contig nextContig : contig.getPredecessors() ) {\n+            if ( nextContig == parent ) {\n+                continue;\n+            }\n+            CutData nextCutData = cutDataMap.get(nextContig);\n+            if ( nextCutData != null ) {\n+                cutData.minVisitNum = Math.min(cutData.minVisitNum, nextCutData.visitNum);\n+            } else {\n+                nextCutData = findCuts(nextContig, contig, cutDataMap);\n+                cutData.minVisitNum = Math.min(cutData.minVisitNum, nextCutData.minVisitNum);\n+                if ( nextCutData.minVisitNum >= cutData.visitNum ) {\n+                    contig.setCut(true);\n+                }\n+            }\n+        }\n+        return cutData;\n+    }\n+\n+    @VisibleForTesting\n+    static void unlinkContig( final Contig contig,\n+                                      final KmerSet<KmerAdjacency> kmerAdjacencySet ) {\n+        final KmerAdjacency firstKmer = contig.getFirstKmer();\n+        final int firstKmerFinalCall = firstKmer.getFinalCall();\n+        for ( final Contig predecessor : contig.getPredecessors() ) {\n+            if ( predecessor != contig && predecessor != contig.rc() ) {\n+                predecessor.getLastKmer().removeSuccessor(firstKmerFinalCall, kmerAdjacencySet);\n+                if ( !predecessor.getSuccessors().remove(contig) ) {\n+                    throw new GATKException(\"failed to find predecessor link\");\n+                }\n+            }\n+        }\n+\n+        final KmerAdjacency lastKmer = contig.getLastKmer();\n+        final int lastKmerInitialCall = lastKmer.getInitialCall();\n+        for ( final Contig successor : contig.getSuccessors() ) {\n+            if ( successor != contig && successor != contig.rc() ) {\n+                successor.getFirstKmer().removePredecessor(lastKmerInitialCall, kmerAdjacencySet);\n+                if ( !successor.getPredecessors().remove(contig) ) {\n+                    throw new GATKException(\"failed to find successor link\");\n+                }\n+            }\n+        }\n+\n+        KmerAdjacency nextKmer = firstKmer;\n+        KmerAdjacency kmer;\n+        do {\n+            kmer = nextKmer;\n+            nextKmer = kmer.getSoleSuccessor();\n+            kmerAdjacencySet.remove(kmer.canonical());\n+        } while ( kmer != lastKmer );\n+    }\n+\n+    private static void updateKmerContig( final KmerAdjacency firstKmer,\n+                                          final KmerAdjacency lastKmer,\n+                                          final Contig contig ) {\n+        int offset = 0;\n+        for ( KmerAdjacency kmer = firstKmer; kmer != lastKmer; kmer = kmer.getSoleSuccessor() ) {\n+            if ( kmer == null ) {\n+                throw new GATKException(\"contig does not have a flat pipeline of kmers\");\n+            }\n+            kmer.clearContig();\n+            kmer.setContigOffset(contig, offset++);\n+        }\n+        lastKmer.clearContig();\n+        lastKmer.setContigOffset(contig, offset);\n+        if ( offset + Kmer.KSIZE != contig.size() ) {\n+            throw new GATKException(\"kmer chain length does not equal contig size\");\n+        }\n+    }\n+\n+    /** replace adjacent contigs without branches with a single, larger contig **/\n+    @VisibleForTesting\n+    static void weldPipes( final List<ContigImpl> contigs ) {\n+        for ( int contigIdx = 0; contigIdx != contigs.size(); ++contigIdx ) {\n+            final ContigImpl contig = contigs.get(contigIdx);\n+            if ( contig.getSuccessors().size() == 1 ) {\n+                final Contig successor = contig.getSuccessors().get(0);\n+                if ( successor != contig && successor != contig.rc() &&\n+                        successor.getPredecessors().size() == 1 ) {\n+                    contigs.set(contigIdx, join(contig.getId(), contig, successor));\n+                    if ( !contigs.remove(successor.canonical()) ) {\n+                        throw new GATKException(\"successor linkage is messed up\");\n+                    }\n+                    contigIdx -= 1; // reconsider the new contig -- there might be more joining possible\n+                    continue;\n+                }\n+            }\n+            if ( contig.getPredecessors().size() == 1 ) {\n+                final Contig predecessor = contig.getPredecessors().get(0);\n+                if ( predecessor != contig && predecessor != contig.rc() &&\n+                        predecessor.getSuccessors().size() == 1 ) {\n+                    contigs.set(contigIdx, join(contig.getId(), predecessor, contig));\n+                    if ( !contigs.remove(predecessor.canonical()) ) {\n+                        throw new GATKException(\"predecessor linkage is messed up\");\n+                    }\n+                    contigIdx -= 1; // reconsider\n+                }\n+            }\n+        }\n+    }\n+\n+    private static ContigImpl join( final int id, final Contig predecessor, final Contig successor ) {\n+        if ( !checkOverlap(predecessor.getSequence(), successor.getSequence()) ) {\n+                throw new GATKException(\"sequences can't be joined\");\n+        }\n+        final ContigImpl joinedContig = new ContigImpl(id, predecessor, successor);\n+        updateKmerContig(joinedContig.getFirstKmer(), joinedContig.getLastKmer(), joinedContig);\n+        return joinedContig;\n+    }\n+\n+    private static boolean checkOverlap( final CharSequence seq1, final CharSequence seq2 ) {\n+        final int seq1Len = seq1.length();\n+        final CharSequence seq1SubSeq = seq1.subSequence(seq1Len - Kmer.KSIZE + 1, seq1Len);\n+        final CharSequence seq2SubSeq = seq2.subSequence(0, Kmer.KSIZE - 1);\n+        return seq1SubSeq.equals(seq2SubSeq);\n+    }\n+\n+    /** set a unique componentId for every connected group of contigs **/\n+    @VisibleForTesting\n+    static int markComponents( final List<ContigImpl> contigs ) {\n+        for ( final ContigImpl contig : contigs ) {\n+            contig.setComponentId(0);\n+        }\n+\n+        int componentId = 0;\n+        for ( final ContigImpl contig : contigs ) {\n+            if ( contig.getComponentId() == 0 ) {\n+                contig.setComponentId(++componentId);\n+                markSuccessorComponents(contig);\n+                markSuccessorComponents(contig.rc());\n+            }\n+        }\n+        return componentId;\n+    }\n+\n+    private static void markSuccessorComponents( final Contig contig ) {\n+        final int componentId = contig.getComponentId();\n+        for ( final Contig successor : contig.getSuccessors() ) {\n+            if ( successor.getComponentId() == 0 ) {\n+                successor.canonical().setComponentId(componentId);\n+                markSuccessorComponents(successor);\n+                markSuccessorComponents(successor.rc());\n+            }\n+        }\n+    }\n+\n+    @VisibleForTesting\n+    static void markCycles( final List<ContigImpl> contigs ) {\n+        for ( final Contig contig : contigs ) {\n+            contig.setCyclic(false);\n+        }\n+\n+        final int nContigs = contigs.size();\n+        final Deque<Contig> deque = new ArrayDeque<>(nContigs);\n+        final Map<Contig, CutData> cutDataMap = new HashMap<>(nContigs * 3);\n+        for ( final Contig contig : contigs ) {\n+            if ( !cutDataMap.containsKey(contig) ) {\n+                markCyclesRecursion(contig, deque, cutDataMap);\n+            }\n+        }\n+    }\n+\n+    private static CutData markCyclesRecursion( final Contig contig,\n+                                                final Deque<Contig> deque,\n+                                                final Map<Contig, CutData> cutDataMap ) {\n+        final CutData cutData = new CutData();\n+        cutDataMap.put(contig, cutData);\n+        deque.addFirst(contig);\n+\n+        for ( final Contig successor : contig.getSuccessors() ) {\n+            final CutData successorCutData = cutDataMap.get(successor);\n+            if ( successorCutData == null ) {\n+                final int recursionVisitNum =\n+                        markCyclesRecursion(successor, deque, cutDataMap).minVisitNum;\n+                cutData.minVisitNum = Math.min(cutData.minVisitNum, recursionVisitNum);\n+            } else {\n+                cutData.minVisitNum = Math.min(cutData.minVisitNum, successorCutData.visitNum);\n+            }\n+        }\n+\n+        if ( cutData.visitNum == cutData.minVisitNum ) {\n+            Contig tig = deque.removeFirst();\n+            if ( tig == contig ) {\n+                cutDataMap.get(tig).visitNum = Integer.MAX_VALUE;\n+\n+                // single-vertex component -- cyclic only if self-referential\n+                if ( tig.getSuccessors().contains(tig) ) {\n+                    tig.setCyclic(true);\n+                }\n+            } else {\n+                while ( true ) {\n+                    // kill cross-links\n+                    cutDataMap.get(tig).visitNum = Integer.MAX_VALUE;\n+                    tig.setCyclic(true);\n+                    if ( tig == contig ) break;\n+                    tig = deque.removeFirst();\n+                }\n+            }\n+        }\n+        return cutData;\n+    }\n+\n+    @VisibleForTesting\n+    static boolean fillGaps( final KmerSet<KmerAdjacency> kmerAdjacencySet,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MTgyODk3Mg=="}, "originalCommit": {"oid": "e2201c1ef4f8ba71f17e169f07756cfe2f1ecb49"}, "originalPosition": 578}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzczNjgwMTA3OnYy", "diffSide": "RIGHT", "path": "src/main/java/org/broadinstitute/hellbender/tools/LocalAssembler.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMy0xMFQyMDowMDoxM1rOI0ag0Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNC0xMlQyMTowMzo0MFrOJHmpgw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MTgzMTI0OQ==", "bodyText": "What's the relationship between how you set MIN_GAPFILL_COUNT and MIN_THIN_OBS? They seem related to me but I'm not sure I understand how yet. I guess if these kmers end up joined to a contig they will enjoy the contig's observation count.", "url": "https://github.com/broadinstitute/gatk/pull/6989#discussion_r591831249", "createdAt": "2021-03-10T20:00:13Z", "author": {"login": "cwhelan"}, "path": "src/main/java/org/broadinstitute/hellbender/tools/LocalAssembler.java", "diffHunk": "@@ -0,0 +1,2306 @@\n+package org.broadinstitute.hellbender.tools;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import htsjdk.samtools.Cigar;\n+import htsjdk.samtools.CigarElement;\n+import htsjdk.samtools.CigarOperator;\n+import htsjdk.samtools.SAMUtils;\n+import org.broadinstitute.barclay.argparser.Argument;\n+import org.broadinstitute.barclay.argparser.BetaFeature;\n+import org.broadinstitute.barclay.argparser.CommandLineProgramProperties;\n+import org.broadinstitute.barclay.help.DocumentedFeature;\n+import org.broadinstitute.hellbender.cmdline.StandardArgumentDefinitions;\n+import org.broadinstitute.hellbender.cmdline.programgroups.CoverageAnalysisProgramGroup;\n+import org.broadinstitute.hellbender.exceptions.GATKException;\n+import org.broadinstitute.hellbender.tools.walkers.PairWalker;\n+import org.broadinstitute.hellbender.utils.SimpleInterval;\n+import org.broadinstitute.hellbender.utils.collections.HopscotchSet;\n+import org.broadinstitute.hellbender.utils.gcs.BucketUtils;\n+import org.broadinstitute.hellbender.utils.read.GATKRead;\n+\n+import java.io.BufferedWriter;\n+import java.io.FileWriter;\n+import java.io.IOException;\n+import java.io.OutputStreamWriter;\n+import java.util.*;\n+import java.util.zip.GZIPOutputStream;\n+\n+@DocumentedFeature\n+@CommandLineProgramProperties(\n+        summary = \"experiment\",\n+        oneLineSummary = \"experiment\",\n+        usageExample = \"gatk LocalAssembler\",\n+        programGroup = CoverageAnalysisProgramGroup.class\n+)\n+@BetaFeature\n+public class LocalAssembler extends PairWalker {\n+    public static final byte QMIN = 25;\n+    public static final int MIN_THIN_OBS = 4;\n+    public static final int MIN_GAPFILL_COUNT = 3;\n+    public static final int TOO_MANY_TRAVERSALS = 100000;\n+    public static final int TOO_MANY_SCAFFOLDS = 50000;\n+    public static final int MIN_SV_SIZE = 50;\n+\n+    @Argument(fullName=StandardArgumentDefinitions.OUTPUT_LONG_NAME,\n+            shortName=StandardArgumentDefinitions.OUTPUT_SHORT_NAME,\n+            doc=\"Write outputs to this file name prefix\", optional = true)\n+    public static String output;\n+\n+    @Argument(fullName=\"assembly-name\", doc=\"name of assembly used as a prefix for traversal names\")\n+    public static String assemblyName;\n+\n+    private final List<GATKRead> reads = new ArrayList<>();\n+\n+    @Override public boolean requiresIntervals() { return true; }\n+\n+    @Override public void apply( final GATKRead read, final GATKRead mate ) {\n+        trimOverruns(read, mate);\n+        reads.add(read);\n+        reads.add(mate);\n+    }\n+\n+    @Override public void applyUnpaired( final GATKRead read ) {\n+        reads.add(read);\n+    }\n+\n+    @Override public Object onTraversalSuccess() {\n+        super.onTraversalSuccess(); // flush any incomplete pairs\n+\n+        final int regionSize = getTraversalIntervals().stream().mapToInt(SimpleInterval::size).sum();\n+        final KmerSet<KmerAdjacency> kmerAdjacencySet = new KmerSet<>(10 * regionSize);\n+        kmerizeReads(reads, kmerAdjacencySet);\n+        List<ContigImpl> contigs = buildContigs(kmerAdjacencySet);\n+        connectContigs(contigs);\n+\n+        removeThinContigs(contigs, kmerAdjacencySet);\n+        weldPipes(contigs);\n+        markComponents(contigs);\n+\n+        if ( fillGaps(kmerAdjacencySet, reads) ) {\n+            contigs = buildContigs(kmerAdjacencySet);\n+            connectContigs(contigs);\n+            removeThinContigs(contigs, kmerAdjacencySet);\n+            weldPipes(contigs);\n+            markComponents(contigs);\n+        }\n+\n+        markCycles(contigs);\n+\n+        final String outputFilePrefix = output != null ? output : assemblyName;\n+        final List<Path> readPaths = pathReads(kmerAdjacencySet, reads);\n+        final Map<Contig,List<TransitPairCount>> contigTransitsMap =\n+                collectTransitPairCounts(contigs, readPaths);\n+        final String traversalsFilename = outputFilePrefix + \".traversals.fa.gz\";\n+        try {\n+            final List<Traversal> allTraversals =\n+                    new ArrayList<>(traverseAllPaths(contigs, readPaths, contigTransitsMap));\n+            writeTraversals(allTraversals, traversalsFilename);\n+            try {\n+                final String scaffoldsFileName = outputFilePrefix + \".scaffolds.fa.gz\";\n+                writeTraversals(createScaffolds(allTraversals), scaffoldsFileName);\n+            } catch ( final AssemblyTooComplexException x ) {\n+                logger.warn(\"Assembly too complex for scaffolding.\");\n+            }\n+        } catch ( final AssemblyTooComplexException x ) {\n+            logger.warn(\"Assembly too complex.  Writing contigs as traversals in \" +\n+                    traversalsFilename + \".\");\n+            final Collection<Traversal> contigTraversals = new ArrayList<>(contigs.size());\n+            for ( final Contig contig : contigs ) {\n+                contigTraversals.add(new Traversal(Collections.singletonList(contig)));\n+            }\n+            writeTraversals(contigTraversals, traversalsFilename);\n+        }\n+\n+        contigs.sort(Comparator.comparingInt(ContigImpl::getId));\n+        writeDOT(contigs, outputFilePrefix + \".assembly.dot\");\n+        writeContigs(contigs, outputFilePrefix + \".contigs.txt.gz\");\n+        writePaths(readPaths, outputFilePrefix + \".paths.txt.gz\");\n+        writeReads(reads, outputFilePrefix + \".reads.fastq.gz\");\n+        return null;\n+    }\n+\n+    /** trim read pairs of base calls that have gone past the end of a short fragment */\n+    private void trimOverruns( final GATKRead read, final GATKRead mate ) {\n+        // if both mapped and they're on different strands\n+        if ( !read.isUnmapped() && !mate.isUnmapped() &&\n+                read.isReverseStrand() != mate.isReverseStrand() ) {\n+            // and both start within 1 base on the ref\n+            if ( Math.abs(read.getStart() - read.getMateStart()) <= 1 ) {\n+                // and both end within 1 base\n+                final int readRefLen = read.getCigar().getReferenceLength();\n+                final int mateRefLen = mate.getCigar().getReferenceLength();\n+                if ( Math.abs(readRefLen - mateRefLen) <= 1 ) {\n+                    if ( mate.isReverseStrand() ) {\n+                        trimClips(read, mate);\n+                    } else {\n+                        trimClips(mate, read);\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    private void trimClips( final GATKRead fwd, final GATKRead rev ) {\n+        final List<CigarElement> fwdElements = fwd.getCigarElements();\n+        final List<CigarElement> revElements = rev.getCigarElements();\n+        final int lastElementIdx = fwdElements.size() - 1;\n+        final CigarElement fwdLastElement = fwdElements.get(lastElementIdx);\n+        final CigarElement revFirstElement = revElements.get(0);\n+        if ( fwdLastElement.getOperator() == CigarOperator.S &&\n+                revFirstElement.getOperator() == CigarOperator.S ) {\n+            final byte[] fwdBases = fwd.getBasesNoCopy();\n+            final int lastElementLen = fwdLastElement.getLength();\n+            fwd.setBases(Arrays.copyOfRange(fwdBases, 0, fwdBases.length - lastElementLen));\n+            final byte[] fwdQuals = fwd.getBaseQualitiesNoCopy();\n+            if ( fwdQuals.length > 0 ) {\n+                final int qualsLen = fwdQuals.length - lastElementLen;\n+                fwd.setBaseQualities(Arrays.copyOfRange(fwdQuals, 0, qualsLen));\n+            }\n+            final List<CigarElement> newFwdElements = new ArrayList<>(fwdElements);\n+            newFwdElements.set(lastElementIdx, new CigarElement(lastElementLen, CigarOperator.H));\n+            fwd.setCigar(new Cigar(newFwdElements));\n+\n+            final byte[] revBases = rev.getBasesNoCopy();\n+            final int firstElementLen = revFirstElement.getLength();\n+            rev.setBases(Arrays.copyOfRange(revBases, firstElementLen, revBases.length));\n+            final byte[] revQuals = rev.getBaseQualitiesNoCopy();\n+            if ( revQuals.length > 0 ) {\n+                rev.setBaseQualities(Arrays.copyOfRange(revQuals, firstElementLen, revQuals.length));\n+            }\n+            final List<CigarElement> newRevElements = new ArrayList<>(revElements);\n+            newRevElements.set(0, new CigarElement(firstElementLen, CigarOperator.H));\n+            rev.setCigar(new Cigar(newRevElements));\n+        }\n+    }\n+\n+    @VisibleForTesting\n+    static void kmerizeReads( final List<GATKRead> reads,\n+                              final KmerSet<KmerAdjacency> kmerAdjacencySet ) {\n+        for ( final GATKRead read : reads ) {\n+            final byte[] calls = read.getBasesNoCopy();\n+            final byte[] quals = read.getBaseQualitiesNoCopy();\n+            KmerAdjacency.kmerize(calls, quals, QMIN, kmerAdjacencySet);\n+        }\n+    }\n+\n+    /** gather unbranched strings of kmers into contigs **/\n+    @VisibleForTesting\n+    static List<ContigImpl> buildContigs( final KmerSet<KmerAdjacency> kmerAdjacencySet ) {\n+        // gather strings of kmers that have a single predecessor and single successor into contigs\n+        final List<ContigImpl> contigs = new ArrayList<>();\n+        int nContigs = 0;\n+        for ( final KmerAdjacency kmerAdjacency : kmerAdjacencySet ) {\n+            if ( kmerAdjacency.getContig() == null ) {\n+                ContigImpl contig = null;\n+                final KmerAdjacency predecessor = kmerAdjacency.getSolePredecessor();\n+                if ( predecessor == null ||\n+                        predecessor.getSuccessorCount() > 1 ||\n+                        predecessor == kmerAdjacency.rc() ) {\n+                    contig = new ContigImpl(++nContigs, kmerAdjacency);\n+                } else {\n+                    final KmerAdjacency successor = kmerAdjacency.getSoleSuccessor();\n+                    if ( successor == null ||\n+                            successor.getPredecessorCount() > 1 ||\n+                            successor == kmerAdjacency.rc() ) {\n+                        contig = new ContigImpl(++nContigs, kmerAdjacency.rc());\n+                    }\n+                }\n+                if ( contig != null ) {\n+                    contigs.add(contig);\n+                }\n+            }\n+        }\n+\n+        // if there are smooth circles like a plasmid, gather them together as a contig, too\n+        for ( final KmerAdjacency kmerAdjacency : kmerAdjacencySet ) {\n+            if ( kmerAdjacency.getContig() == null ) {\n+                contigs.add(new ContigImpl(++nContigs, kmerAdjacency));\n+            }\n+        }\n+\n+        return contigs;\n+    }\n+\n+    /** connect contigs when the final kmer of one contig is adjacent to the inital contig of another **/\n+    @VisibleForTesting\n+    static void connectContigs( final List<ContigImpl> contigs ) {\n+        final int nContigs = contigs.size();\n+        final KmerSet<ContigEndKmer> contigEnds = new KmerSet<>(2*nContigs);\n+        for ( int contigId = 0; contigId != nContigs; ++contigId ) {\n+            final ContigImpl contig = contigs.get(contigId);\n+            final KmerAdjacency fwdKmer = contig.getFirstKmer();\n+            final KmerAdjacency revKmer = contig.getLastKmer().rc();\n+            if ( fwdKmer == revKmer ) {\n+                contigEnds.add(new ContigEndKmer(fwdKmer.getKVal(), contig, ContigOrientation.BOTH));\n+            } else {\n+                contigEnds.add(new ContigEndKmer(fwdKmer.getKVal(), contig, ContigOrientation.FWD));\n+                contigEnds.add(new ContigEndKmer(revKmer.getKVal(), contig, ContigOrientation.REV));\n+            }\n+        }\n+\n+        for ( int contigId = 0; contigId != nContigs; ++contigId ) {\n+            final Contig contig = contigs.get(contigId);\n+\n+            final KmerAdjacency start = contig.getFirstKmer();\n+            final int predecessorCount = start.getPredecessorCount();\n+            if ( predecessorCount > 0 ) {\n+                final List<Contig> predecessors = contig.getPredecessors();\n+                final int mask = start.getPredecessorMask();\n+                for ( int call = 0; call != 4; ++call ) {\n+                    if ( (mask & (1 << call)) != 0 ) {\n+                        final long kVal =\n+                                KmerAdjacency.reverseComplement(start.getPredecessorVal(call));\n+                        final ContigEndKmer contigEndKmer = contigEnds.find(new Kmer(kVal));\n+                        if ( contigEndKmer == null ) {\n+                            throw new GATKException(\"missing contig end kmer\");\n+                        }\n+                        switch ( contigEndKmer.getContigOrientation() ) {\n+                            case FWD:\n+                                predecessors.add(contigEndKmer.getContig().rc());\n+                                break;\n+                            case REV:\n+                                predecessors.add(contigEndKmer.getContig());\n+                                break;\n+                            case BOTH:\n+                                predecessors.add(contigEndKmer.getContig());\n+                                predecessors.add(contigEndKmer.getContig().rc());\n+                                break;\n+                        }\n+                    }\n+                }\n+            }\n+\n+            final KmerAdjacency end = contig.getLastKmer();\n+            final int successorCount = end.getSuccessorCount();\n+            if ( successorCount > 0 ) {\n+                final List<Contig> successors = contig.getSuccessors();\n+                final int mask = end.getSuccessorMask();\n+                for ( int call = 0; call != 4; ++call ) {\n+                    if ( (mask & (1 << call)) != 0 ) {\n+                        final long kVal = end.getSuccessorVal(call);\n+                        final ContigEndKmer contigEndKmer = contigEnds.find(new Kmer(kVal));\n+                        if ( contigEndKmer == null ) {\n+                            throw new GATKException(\"missing contig end kmer\");\n+                        }\n+                        switch ( contigEndKmer.getContigOrientation() ) {\n+                            case FWD:\n+                                successors.add(contigEndKmer.getContig());\n+                                break;\n+                            case REV:\n+                                successors.add(contigEndKmer.getContig().rc());\n+                                break;\n+                            case BOTH:\n+                                successors.add(contigEndKmer.getContig());\n+                                successors.add(contigEndKmer.getContig().rc());\n+                                break;\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    /** remove contigs that have little evidence **/\n+    @VisibleForTesting\n+    static void removeThinContigs( final List<ContigImpl> contigs,\n+                                           final KmerSet<KmerAdjacency> kmerAdjacencySet ) {\n+        contigs.sort(Comparator.comparingInt(ContigImpl::getMaxObservations));\n+        boolean contigRemoved;\n+        do {\n+            // figure out which contigs are cut points\n+            // i.e., those contigs which, if removed, would result in a graph with more connected components\n+            final int nContigs = contigs.size();\n+            final Map<Contig, CutData> cutDataMap = new HashMap<>(nContigs * 3);\n+\n+            for ( final ContigImpl contig : contigs ) {\n+                if ( cutDataMap.containsKey(contig) ) {\n+                    continue;\n+                }\n+\n+                cutDataMap.put(contig, new CutData());\n+                int children = 0;\n+                for ( final Contig nextContig : contig.getSuccessors() ) {\n+                    if ( !cutDataMap.containsKey(nextContig) ) {\n+                        findCuts(nextContig, contig, cutDataMap);\n+                        children += 1;\n+                    }\n+                }\n+                for ( final Contig nextContig : contig.getPredecessors() ) {\n+                    if ( !cutDataMap.containsKey(nextContig) ) {\n+                        findCuts(nextContig, contig, cutDataMap);\n+                        children += 1;\n+                    }\n+                }\n+                if ( children >= 2 ) {\n+                    contig.setCut(true);\n+                }\n+            }\n+\n+            // remove poorly attested (low max observations) contigs, unless they are cut points\n+            contigRemoved = false;\n+            final Iterator<ContigImpl> itr = contigs.iterator();\n+            while ( itr.hasNext() ) {\n+                final Contig contig = itr.next();\n+                if ( contig.getMaxObservations() < MIN_THIN_OBS && !contig.isCut() ) {\n+                    unlinkContig(contig, kmerAdjacencySet);\n+                    itr.remove();\n+                    contigRemoved = true;\n+                    break;\n+                }\n+            }\n+        } while ( contigRemoved );\n+        contigs.sort(Comparator.comparingInt(ContigImpl::getId));\n+    }\n+\n+    private static CutData findCuts( final Contig contig,\n+                                     final Contig parent,\n+                                     final Map<Contig, CutData> cutDataMap ) {\n+        final CutData cutData = new CutData();\n+        cutDataMap.put(contig, cutData);\n+        for ( final Contig nextContig : contig.getSuccessors() ) {\n+            if ( nextContig == parent ) {\n+                continue;\n+            }\n+            CutData nextCutData = cutDataMap.get(nextContig);\n+            if ( nextCutData != null ) {\n+                cutData.minVisitNum = Math.min(cutData.minVisitNum, nextCutData.visitNum);\n+            } else {\n+                nextCutData = findCuts(nextContig, contig, cutDataMap);\n+                cutData.minVisitNum = Math.min(cutData.minVisitNum, nextCutData.minVisitNum);\n+                if ( nextCutData.minVisitNum >= cutData.visitNum ) {\n+                    contig.setCut(true);\n+                }\n+            }\n+        }\n+        for ( final Contig nextContig : contig.getPredecessors() ) {\n+            if ( nextContig == parent ) {\n+                continue;\n+            }\n+            CutData nextCutData = cutDataMap.get(nextContig);\n+            if ( nextCutData != null ) {\n+                cutData.minVisitNum = Math.min(cutData.minVisitNum, nextCutData.visitNum);\n+            } else {\n+                nextCutData = findCuts(nextContig, contig, cutDataMap);\n+                cutData.minVisitNum = Math.min(cutData.minVisitNum, nextCutData.minVisitNum);\n+                if ( nextCutData.minVisitNum >= cutData.visitNum ) {\n+                    contig.setCut(true);\n+                }\n+            }\n+        }\n+        return cutData;\n+    }\n+\n+    @VisibleForTesting\n+    static void unlinkContig( final Contig contig,\n+                                      final KmerSet<KmerAdjacency> kmerAdjacencySet ) {\n+        final KmerAdjacency firstKmer = contig.getFirstKmer();\n+        final int firstKmerFinalCall = firstKmer.getFinalCall();\n+        for ( final Contig predecessor : contig.getPredecessors() ) {\n+            if ( predecessor != contig && predecessor != contig.rc() ) {\n+                predecessor.getLastKmer().removeSuccessor(firstKmerFinalCall, kmerAdjacencySet);\n+                if ( !predecessor.getSuccessors().remove(contig) ) {\n+                    throw new GATKException(\"failed to find predecessor link\");\n+                }\n+            }\n+        }\n+\n+        final KmerAdjacency lastKmer = contig.getLastKmer();\n+        final int lastKmerInitialCall = lastKmer.getInitialCall();\n+        for ( final Contig successor : contig.getSuccessors() ) {\n+            if ( successor != contig && successor != contig.rc() ) {\n+                successor.getFirstKmer().removePredecessor(lastKmerInitialCall, kmerAdjacencySet);\n+                if ( !successor.getPredecessors().remove(contig) ) {\n+                    throw new GATKException(\"failed to find successor link\");\n+                }\n+            }\n+        }\n+\n+        KmerAdjacency nextKmer = firstKmer;\n+        KmerAdjacency kmer;\n+        do {\n+            kmer = nextKmer;\n+            nextKmer = kmer.getSoleSuccessor();\n+            kmerAdjacencySet.remove(kmer.canonical());\n+        } while ( kmer != lastKmer );\n+    }\n+\n+    private static void updateKmerContig( final KmerAdjacency firstKmer,\n+                                          final KmerAdjacency lastKmer,\n+                                          final Contig contig ) {\n+        int offset = 0;\n+        for ( KmerAdjacency kmer = firstKmer; kmer != lastKmer; kmer = kmer.getSoleSuccessor() ) {\n+            if ( kmer == null ) {\n+                throw new GATKException(\"contig does not have a flat pipeline of kmers\");\n+            }\n+            kmer.clearContig();\n+            kmer.setContigOffset(contig, offset++);\n+        }\n+        lastKmer.clearContig();\n+        lastKmer.setContigOffset(contig, offset);\n+        if ( offset + Kmer.KSIZE != contig.size() ) {\n+            throw new GATKException(\"kmer chain length does not equal contig size\");\n+        }\n+    }\n+\n+    /** replace adjacent contigs without branches with a single, larger contig **/\n+    @VisibleForTesting\n+    static void weldPipes( final List<ContigImpl> contigs ) {\n+        for ( int contigIdx = 0; contigIdx != contigs.size(); ++contigIdx ) {\n+            final ContigImpl contig = contigs.get(contigIdx);\n+            if ( contig.getSuccessors().size() == 1 ) {\n+                final Contig successor = contig.getSuccessors().get(0);\n+                if ( successor != contig && successor != contig.rc() &&\n+                        successor.getPredecessors().size() == 1 ) {\n+                    contigs.set(contigIdx, join(contig.getId(), contig, successor));\n+                    if ( !contigs.remove(successor.canonical()) ) {\n+                        throw new GATKException(\"successor linkage is messed up\");\n+                    }\n+                    contigIdx -= 1; // reconsider the new contig -- there might be more joining possible\n+                    continue;\n+                }\n+            }\n+            if ( contig.getPredecessors().size() == 1 ) {\n+                final Contig predecessor = contig.getPredecessors().get(0);\n+                if ( predecessor != contig && predecessor != contig.rc() &&\n+                        predecessor.getSuccessors().size() == 1 ) {\n+                    contigs.set(contigIdx, join(contig.getId(), predecessor, contig));\n+                    if ( !contigs.remove(predecessor.canonical()) ) {\n+                        throw new GATKException(\"predecessor linkage is messed up\");\n+                    }\n+                    contigIdx -= 1; // reconsider\n+                }\n+            }\n+        }\n+    }\n+\n+    private static ContigImpl join( final int id, final Contig predecessor, final Contig successor ) {\n+        if ( !checkOverlap(predecessor.getSequence(), successor.getSequence()) ) {\n+                throw new GATKException(\"sequences can't be joined\");\n+        }\n+        final ContigImpl joinedContig = new ContigImpl(id, predecessor, successor);\n+        updateKmerContig(joinedContig.getFirstKmer(), joinedContig.getLastKmer(), joinedContig);\n+        return joinedContig;\n+    }\n+\n+    private static boolean checkOverlap( final CharSequence seq1, final CharSequence seq2 ) {\n+        final int seq1Len = seq1.length();\n+        final CharSequence seq1SubSeq = seq1.subSequence(seq1Len - Kmer.KSIZE + 1, seq1Len);\n+        final CharSequence seq2SubSeq = seq2.subSequence(0, Kmer.KSIZE - 1);\n+        return seq1SubSeq.equals(seq2SubSeq);\n+    }\n+\n+    /** set a unique componentId for every connected group of contigs **/\n+    @VisibleForTesting\n+    static int markComponents( final List<ContigImpl> contigs ) {\n+        for ( final ContigImpl contig : contigs ) {\n+            contig.setComponentId(0);\n+        }\n+\n+        int componentId = 0;\n+        for ( final ContigImpl contig : contigs ) {\n+            if ( contig.getComponentId() == 0 ) {\n+                contig.setComponentId(++componentId);\n+                markSuccessorComponents(contig);\n+                markSuccessorComponents(contig.rc());\n+            }\n+        }\n+        return componentId;\n+    }\n+\n+    private static void markSuccessorComponents( final Contig contig ) {\n+        final int componentId = contig.getComponentId();\n+        for ( final Contig successor : contig.getSuccessors() ) {\n+            if ( successor.getComponentId() == 0 ) {\n+                successor.canonical().setComponentId(componentId);\n+                markSuccessorComponents(successor);\n+                markSuccessorComponents(successor.rc());\n+            }\n+        }\n+    }\n+\n+    @VisibleForTesting\n+    static void markCycles( final List<ContigImpl> contigs ) {\n+        for ( final Contig contig : contigs ) {\n+            contig.setCyclic(false);\n+        }\n+\n+        final int nContigs = contigs.size();\n+        final Deque<Contig> deque = new ArrayDeque<>(nContigs);\n+        final Map<Contig, CutData> cutDataMap = new HashMap<>(nContigs * 3);\n+        for ( final Contig contig : contigs ) {\n+            if ( !cutDataMap.containsKey(contig) ) {\n+                markCyclesRecursion(contig, deque, cutDataMap);\n+            }\n+        }\n+    }\n+\n+    private static CutData markCyclesRecursion( final Contig contig,\n+                                                final Deque<Contig> deque,\n+                                                final Map<Contig, CutData> cutDataMap ) {\n+        final CutData cutData = new CutData();\n+        cutDataMap.put(contig, cutData);\n+        deque.addFirst(contig);\n+\n+        for ( final Contig successor : contig.getSuccessors() ) {\n+            final CutData successorCutData = cutDataMap.get(successor);\n+            if ( successorCutData == null ) {\n+                final int recursionVisitNum =\n+                        markCyclesRecursion(successor, deque, cutDataMap).minVisitNum;\n+                cutData.minVisitNum = Math.min(cutData.minVisitNum, recursionVisitNum);\n+            } else {\n+                cutData.minVisitNum = Math.min(cutData.minVisitNum, successorCutData.visitNum);\n+            }\n+        }\n+\n+        if ( cutData.visitNum == cutData.minVisitNum ) {\n+            Contig tig = deque.removeFirst();\n+            if ( tig == contig ) {\n+                cutDataMap.get(tig).visitNum = Integer.MAX_VALUE;\n+\n+                // single-vertex component -- cyclic only if self-referential\n+                if ( tig.getSuccessors().contains(tig) ) {\n+                    tig.setCyclic(true);\n+                }\n+            } else {\n+                while ( true ) {\n+                    // kill cross-links\n+                    cutDataMap.get(tig).visitNum = Integer.MAX_VALUE;\n+                    tig.setCyclic(true);\n+                    if ( tig == contig ) break;\n+                    tig = deque.removeFirst();\n+                }\n+            }\n+        }\n+        return cutData;\n+    }\n+\n+    @VisibleForTesting\n+    static boolean fillGaps( final KmerSet<KmerAdjacency> kmerAdjacencySet,\n+                             final List<GATKRead> reads ) {\n+        final Map<String, Integer> gapFillCounts = new HashMap<>();\n+        for ( final GATKRead read : reads ) {\n+            final Path path = new Path(read.getBasesNoCopy(), kmerAdjacencySet);\n+            final List<PathPart> parts = path.getParts();\n+            final int lastIdx = parts.size() - 1;\n+            for ( int idx = 1; idx < lastIdx; ++idx ) {\n+                final PathPart pathPart = parts.get(idx);\n+                if ( pathPart.isGap() ) {\n+                    final char prevCall = parts.get(idx - 1).getLastCall();\n+                    final char nextCall = parts.get(idx + 1).getFirstCall();\n+                    String gapFill = prevCall + pathPart.getSequence().toString() + nextCall;\n+                    final SequenceRC gapFillRC = new SequenceRC(gapFill);\n+                    if ( gapFillRC.compareTo(gapFill) < 0 ) {\n+                        gapFill = gapFillRC.toString();\n+                    }\n+                    gapFillCounts.merge(gapFill, 1, Integer::sum);\n+                }\n+            }\n+        }\n+\n+        boolean newKmers = false;\n+        for ( final Map.Entry<String, Integer> entry : gapFillCounts.entrySet() ) {\n+            final int nObservations = entry.getValue();\n+            if ( nObservations >= MIN_GAPFILL_COUNT ) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e2201c1ef4f8ba71f17e169f07756cfe2f1ecb49"}, "originalPosition": 603}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxMTk1MzAyNw==", "bodyText": "It is a little complex, but I think the two heuristics really are independent of each other.  It's conceivable that you'd remove a poorly attested contig, rebuild it by gap-filling, only to remove it once more because it's still \"thin\".  (But maybe not, since we're adding some low-quality kmers.)  It gets even more complex because we don't remove thin contigs that are \"cut points\", and these can move around as the graph gets reshaped.  I might be causing some extra work, the way I have them set, but I don't think I'm doing anything bad.", "url": "https://github.com/broadinstitute/gatk/pull/6989#discussion_r611953027", "createdAt": "2021-04-12T21:03:40Z", "author": {"login": "tedsharpe"}, "path": "src/main/java/org/broadinstitute/hellbender/tools/LocalAssembler.java", "diffHunk": "@@ -0,0 +1,2306 @@\n+package org.broadinstitute.hellbender.tools;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import htsjdk.samtools.Cigar;\n+import htsjdk.samtools.CigarElement;\n+import htsjdk.samtools.CigarOperator;\n+import htsjdk.samtools.SAMUtils;\n+import org.broadinstitute.barclay.argparser.Argument;\n+import org.broadinstitute.barclay.argparser.BetaFeature;\n+import org.broadinstitute.barclay.argparser.CommandLineProgramProperties;\n+import org.broadinstitute.barclay.help.DocumentedFeature;\n+import org.broadinstitute.hellbender.cmdline.StandardArgumentDefinitions;\n+import org.broadinstitute.hellbender.cmdline.programgroups.CoverageAnalysisProgramGroup;\n+import org.broadinstitute.hellbender.exceptions.GATKException;\n+import org.broadinstitute.hellbender.tools.walkers.PairWalker;\n+import org.broadinstitute.hellbender.utils.SimpleInterval;\n+import org.broadinstitute.hellbender.utils.collections.HopscotchSet;\n+import org.broadinstitute.hellbender.utils.gcs.BucketUtils;\n+import org.broadinstitute.hellbender.utils.read.GATKRead;\n+\n+import java.io.BufferedWriter;\n+import java.io.FileWriter;\n+import java.io.IOException;\n+import java.io.OutputStreamWriter;\n+import java.util.*;\n+import java.util.zip.GZIPOutputStream;\n+\n+@DocumentedFeature\n+@CommandLineProgramProperties(\n+        summary = \"experiment\",\n+        oneLineSummary = \"experiment\",\n+        usageExample = \"gatk LocalAssembler\",\n+        programGroup = CoverageAnalysisProgramGroup.class\n+)\n+@BetaFeature\n+public class LocalAssembler extends PairWalker {\n+    public static final byte QMIN = 25;\n+    public static final int MIN_THIN_OBS = 4;\n+    public static final int MIN_GAPFILL_COUNT = 3;\n+    public static final int TOO_MANY_TRAVERSALS = 100000;\n+    public static final int TOO_MANY_SCAFFOLDS = 50000;\n+    public static final int MIN_SV_SIZE = 50;\n+\n+    @Argument(fullName=StandardArgumentDefinitions.OUTPUT_LONG_NAME,\n+            shortName=StandardArgumentDefinitions.OUTPUT_SHORT_NAME,\n+            doc=\"Write outputs to this file name prefix\", optional = true)\n+    public static String output;\n+\n+    @Argument(fullName=\"assembly-name\", doc=\"name of assembly used as a prefix for traversal names\")\n+    public static String assemblyName;\n+\n+    private final List<GATKRead> reads = new ArrayList<>();\n+\n+    @Override public boolean requiresIntervals() { return true; }\n+\n+    @Override public void apply( final GATKRead read, final GATKRead mate ) {\n+        trimOverruns(read, mate);\n+        reads.add(read);\n+        reads.add(mate);\n+    }\n+\n+    @Override public void applyUnpaired( final GATKRead read ) {\n+        reads.add(read);\n+    }\n+\n+    @Override public Object onTraversalSuccess() {\n+        super.onTraversalSuccess(); // flush any incomplete pairs\n+\n+        final int regionSize = getTraversalIntervals().stream().mapToInt(SimpleInterval::size).sum();\n+        final KmerSet<KmerAdjacency> kmerAdjacencySet = new KmerSet<>(10 * regionSize);\n+        kmerizeReads(reads, kmerAdjacencySet);\n+        List<ContigImpl> contigs = buildContigs(kmerAdjacencySet);\n+        connectContigs(contigs);\n+\n+        removeThinContigs(contigs, kmerAdjacencySet);\n+        weldPipes(contigs);\n+        markComponents(contigs);\n+\n+        if ( fillGaps(kmerAdjacencySet, reads) ) {\n+            contigs = buildContigs(kmerAdjacencySet);\n+            connectContigs(contigs);\n+            removeThinContigs(contigs, kmerAdjacencySet);\n+            weldPipes(contigs);\n+            markComponents(contigs);\n+        }\n+\n+        markCycles(contigs);\n+\n+        final String outputFilePrefix = output != null ? output : assemblyName;\n+        final List<Path> readPaths = pathReads(kmerAdjacencySet, reads);\n+        final Map<Contig,List<TransitPairCount>> contigTransitsMap =\n+                collectTransitPairCounts(contigs, readPaths);\n+        final String traversalsFilename = outputFilePrefix + \".traversals.fa.gz\";\n+        try {\n+            final List<Traversal> allTraversals =\n+                    new ArrayList<>(traverseAllPaths(contigs, readPaths, contigTransitsMap));\n+            writeTraversals(allTraversals, traversalsFilename);\n+            try {\n+                final String scaffoldsFileName = outputFilePrefix + \".scaffolds.fa.gz\";\n+                writeTraversals(createScaffolds(allTraversals), scaffoldsFileName);\n+            } catch ( final AssemblyTooComplexException x ) {\n+                logger.warn(\"Assembly too complex for scaffolding.\");\n+            }\n+        } catch ( final AssemblyTooComplexException x ) {\n+            logger.warn(\"Assembly too complex.  Writing contigs as traversals in \" +\n+                    traversalsFilename + \".\");\n+            final Collection<Traversal> contigTraversals = new ArrayList<>(contigs.size());\n+            for ( final Contig contig : contigs ) {\n+                contigTraversals.add(new Traversal(Collections.singletonList(contig)));\n+            }\n+            writeTraversals(contigTraversals, traversalsFilename);\n+        }\n+\n+        contigs.sort(Comparator.comparingInt(ContigImpl::getId));\n+        writeDOT(contigs, outputFilePrefix + \".assembly.dot\");\n+        writeContigs(contigs, outputFilePrefix + \".contigs.txt.gz\");\n+        writePaths(readPaths, outputFilePrefix + \".paths.txt.gz\");\n+        writeReads(reads, outputFilePrefix + \".reads.fastq.gz\");\n+        return null;\n+    }\n+\n+    /** trim read pairs of base calls that have gone past the end of a short fragment */\n+    private void trimOverruns( final GATKRead read, final GATKRead mate ) {\n+        // if both mapped and they're on different strands\n+        if ( !read.isUnmapped() && !mate.isUnmapped() &&\n+                read.isReverseStrand() != mate.isReverseStrand() ) {\n+            // and both start within 1 base on the ref\n+            if ( Math.abs(read.getStart() - read.getMateStart()) <= 1 ) {\n+                // and both end within 1 base\n+                final int readRefLen = read.getCigar().getReferenceLength();\n+                final int mateRefLen = mate.getCigar().getReferenceLength();\n+                if ( Math.abs(readRefLen - mateRefLen) <= 1 ) {\n+                    if ( mate.isReverseStrand() ) {\n+                        trimClips(read, mate);\n+                    } else {\n+                        trimClips(mate, read);\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    private void trimClips( final GATKRead fwd, final GATKRead rev ) {\n+        final List<CigarElement> fwdElements = fwd.getCigarElements();\n+        final List<CigarElement> revElements = rev.getCigarElements();\n+        final int lastElementIdx = fwdElements.size() - 1;\n+        final CigarElement fwdLastElement = fwdElements.get(lastElementIdx);\n+        final CigarElement revFirstElement = revElements.get(0);\n+        if ( fwdLastElement.getOperator() == CigarOperator.S &&\n+                revFirstElement.getOperator() == CigarOperator.S ) {\n+            final byte[] fwdBases = fwd.getBasesNoCopy();\n+            final int lastElementLen = fwdLastElement.getLength();\n+            fwd.setBases(Arrays.copyOfRange(fwdBases, 0, fwdBases.length - lastElementLen));\n+            final byte[] fwdQuals = fwd.getBaseQualitiesNoCopy();\n+            if ( fwdQuals.length > 0 ) {\n+                final int qualsLen = fwdQuals.length - lastElementLen;\n+                fwd.setBaseQualities(Arrays.copyOfRange(fwdQuals, 0, qualsLen));\n+            }\n+            final List<CigarElement> newFwdElements = new ArrayList<>(fwdElements);\n+            newFwdElements.set(lastElementIdx, new CigarElement(lastElementLen, CigarOperator.H));\n+            fwd.setCigar(new Cigar(newFwdElements));\n+\n+            final byte[] revBases = rev.getBasesNoCopy();\n+            final int firstElementLen = revFirstElement.getLength();\n+            rev.setBases(Arrays.copyOfRange(revBases, firstElementLen, revBases.length));\n+            final byte[] revQuals = rev.getBaseQualitiesNoCopy();\n+            if ( revQuals.length > 0 ) {\n+                rev.setBaseQualities(Arrays.copyOfRange(revQuals, firstElementLen, revQuals.length));\n+            }\n+            final List<CigarElement> newRevElements = new ArrayList<>(revElements);\n+            newRevElements.set(0, new CigarElement(firstElementLen, CigarOperator.H));\n+            rev.setCigar(new Cigar(newRevElements));\n+        }\n+    }\n+\n+    @VisibleForTesting\n+    static void kmerizeReads( final List<GATKRead> reads,\n+                              final KmerSet<KmerAdjacency> kmerAdjacencySet ) {\n+        for ( final GATKRead read : reads ) {\n+            final byte[] calls = read.getBasesNoCopy();\n+            final byte[] quals = read.getBaseQualitiesNoCopy();\n+            KmerAdjacency.kmerize(calls, quals, QMIN, kmerAdjacencySet);\n+        }\n+    }\n+\n+    /** gather unbranched strings of kmers into contigs **/\n+    @VisibleForTesting\n+    static List<ContigImpl> buildContigs( final KmerSet<KmerAdjacency> kmerAdjacencySet ) {\n+        // gather strings of kmers that have a single predecessor and single successor into contigs\n+        final List<ContigImpl> contigs = new ArrayList<>();\n+        int nContigs = 0;\n+        for ( final KmerAdjacency kmerAdjacency : kmerAdjacencySet ) {\n+            if ( kmerAdjacency.getContig() == null ) {\n+                ContigImpl contig = null;\n+                final KmerAdjacency predecessor = kmerAdjacency.getSolePredecessor();\n+                if ( predecessor == null ||\n+                        predecessor.getSuccessorCount() > 1 ||\n+                        predecessor == kmerAdjacency.rc() ) {\n+                    contig = new ContigImpl(++nContigs, kmerAdjacency);\n+                } else {\n+                    final KmerAdjacency successor = kmerAdjacency.getSoleSuccessor();\n+                    if ( successor == null ||\n+                            successor.getPredecessorCount() > 1 ||\n+                            successor == kmerAdjacency.rc() ) {\n+                        contig = new ContigImpl(++nContigs, kmerAdjacency.rc());\n+                    }\n+                }\n+                if ( contig != null ) {\n+                    contigs.add(contig);\n+                }\n+            }\n+        }\n+\n+        // if there are smooth circles like a plasmid, gather them together as a contig, too\n+        for ( final KmerAdjacency kmerAdjacency : kmerAdjacencySet ) {\n+            if ( kmerAdjacency.getContig() == null ) {\n+                contigs.add(new ContigImpl(++nContigs, kmerAdjacency));\n+            }\n+        }\n+\n+        return contigs;\n+    }\n+\n+    /** connect contigs when the final kmer of one contig is adjacent to the inital contig of another **/\n+    @VisibleForTesting\n+    static void connectContigs( final List<ContigImpl> contigs ) {\n+        final int nContigs = contigs.size();\n+        final KmerSet<ContigEndKmer> contigEnds = new KmerSet<>(2*nContigs);\n+        for ( int contigId = 0; contigId != nContigs; ++contigId ) {\n+            final ContigImpl contig = contigs.get(contigId);\n+            final KmerAdjacency fwdKmer = contig.getFirstKmer();\n+            final KmerAdjacency revKmer = contig.getLastKmer().rc();\n+            if ( fwdKmer == revKmer ) {\n+                contigEnds.add(new ContigEndKmer(fwdKmer.getKVal(), contig, ContigOrientation.BOTH));\n+            } else {\n+                contigEnds.add(new ContigEndKmer(fwdKmer.getKVal(), contig, ContigOrientation.FWD));\n+                contigEnds.add(new ContigEndKmer(revKmer.getKVal(), contig, ContigOrientation.REV));\n+            }\n+        }\n+\n+        for ( int contigId = 0; contigId != nContigs; ++contigId ) {\n+            final Contig contig = contigs.get(contigId);\n+\n+            final KmerAdjacency start = contig.getFirstKmer();\n+            final int predecessorCount = start.getPredecessorCount();\n+            if ( predecessorCount > 0 ) {\n+                final List<Contig> predecessors = contig.getPredecessors();\n+                final int mask = start.getPredecessorMask();\n+                for ( int call = 0; call != 4; ++call ) {\n+                    if ( (mask & (1 << call)) != 0 ) {\n+                        final long kVal =\n+                                KmerAdjacency.reverseComplement(start.getPredecessorVal(call));\n+                        final ContigEndKmer contigEndKmer = contigEnds.find(new Kmer(kVal));\n+                        if ( contigEndKmer == null ) {\n+                            throw new GATKException(\"missing contig end kmer\");\n+                        }\n+                        switch ( contigEndKmer.getContigOrientation() ) {\n+                            case FWD:\n+                                predecessors.add(contigEndKmer.getContig().rc());\n+                                break;\n+                            case REV:\n+                                predecessors.add(contigEndKmer.getContig());\n+                                break;\n+                            case BOTH:\n+                                predecessors.add(contigEndKmer.getContig());\n+                                predecessors.add(contigEndKmer.getContig().rc());\n+                                break;\n+                        }\n+                    }\n+                }\n+            }\n+\n+            final KmerAdjacency end = contig.getLastKmer();\n+            final int successorCount = end.getSuccessorCount();\n+            if ( successorCount > 0 ) {\n+                final List<Contig> successors = contig.getSuccessors();\n+                final int mask = end.getSuccessorMask();\n+                for ( int call = 0; call != 4; ++call ) {\n+                    if ( (mask & (1 << call)) != 0 ) {\n+                        final long kVal = end.getSuccessorVal(call);\n+                        final ContigEndKmer contigEndKmer = contigEnds.find(new Kmer(kVal));\n+                        if ( contigEndKmer == null ) {\n+                            throw new GATKException(\"missing contig end kmer\");\n+                        }\n+                        switch ( contigEndKmer.getContigOrientation() ) {\n+                            case FWD:\n+                                successors.add(contigEndKmer.getContig());\n+                                break;\n+                            case REV:\n+                                successors.add(contigEndKmer.getContig().rc());\n+                                break;\n+                            case BOTH:\n+                                successors.add(contigEndKmer.getContig());\n+                                successors.add(contigEndKmer.getContig().rc());\n+                                break;\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    /** remove contigs that have little evidence **/\n+    @VisibleForTesting\n+    static void removeThinContigs( final List<ContigImpl> contigs,\n+                                           final KmerSet<KmerAdjacency> kmerAdjacencySet ) {\n+        contigs.sort(Comparator.comparingInt(ContigImpl::getMaxObservations));\n+        boolean contigRemoved;\n+        do {\n+            // figure out which contigs are cut points\n+            // i.e., those contigs which, if removed, would result in a graph with more connected components\n+            final int nContigs = contigs.size();\n+            final Map<Contig, CutData> cutDataMap = new HashMap<>(nContigs * 3);\n+\n+            for ( final ContigImpl contig : contigs ) {\n+                if ( cutDataMap.containsKey(contig) ) {\n+                    continue;\n+                }\n+\n+                cutDataMap.put(contig, new CutData());\n+                int children = 0;\n+                for ( final Contig nextContig : contig.getSuccessors() ) {\n+                    if ( !cutDataMap.containsKey(nextContig) ) {\n+                        findCuts(nextContig, contig, cutDataMap);\n+                        children += 1;\n+                    }\n+                }\n+                for ( final Contig nextContig : contig.getPredecessors() ) {\n+                    if ( !cutDataMap.containsKey(nextContig) ) {\n+                        findCuts(nextContig, contig, cutDataMap);\n+                        children += 1;\n+                    }\n+                }\n+                if ( children >= 2 ) {\n+                    contig.setCut(true);\n+                }\n+            }\n+\n+            // remove poorly attested (low max observations) contigs, unless they are cut points\n+            contigRemoved = false;\n+            final Iterator<ContigImpl> itr = contigs.iterator();\n+            while ( itr.hasNext() ) {\n+                final Contig contig = itr.next();\n+                if ( contig.getMaxObservations() < MIN_THIN_OBS && !contig.isCut() ) {\n+                    unlinkContig(contig, kmerAdjacencySet);\n+                    itr.remove();\n+                    contigRemoved = true;\n+                    break;\n+                }\n+            }\n+        } while ( contigRemoved );\n+        contigs.sort(Comparator.comparingInt(ContigImpl::getId));\n+    }\n+\n+    private static CutData findCuts( final Contig contig,\n+                                     final Contig parent,\n+                                     final Map<Contig, CutData> cutDataMap ) {\n+        final CutData cutData = new CutData();\n+        cutDataMap.put(contig, cutData);\n+        for ( final Contig nextContig : contig.getSuccessors() ) {\n+            if ( nextContig == parent ) {\n+                continue;\n+            }\n+            CutData nextCutData = cutDataMap.get(nextContig);\n+            if ( nextCutData != null ) {\n+                cutData.minVisitNum = Math.min(cutData.minVisitNum, nextCutData.visitNum);\n+            } else {\n+                nextCutData = findCuts(nextContig, contig, cutDataMap);\n+                cutData.minVisitNum = Math.min(cutData.minVisitNum, nextCutData.minVisitNum);\n+                if ( nextCutData.minVisitNum >= cutData.visitNum ) {\n+                    contig.setCut(true);\n+                }\n+            }\n+        }\n+        for ( final Contig nextContig : contig.getPredecessors() ) {\n+            if ( nextContig == parent ) {\n+                continue;\n+            }\n+            CutData nextCutData = cutDataMap.get(nextContig);\n+            if ( nextCutData != null ) {\n+                cutData.minVisitNum = Math.min(cutData.minVisitNum, nextCutData.visitNum);\n+            } else {\n+                nextCutData = findCuts(nextContig, contig, cutDataMap);\n+                cutData.minVisitNum = Math.min(cutData.minVisitNum, nextCutData.minVisitNum);\n+                if ( nextCutData.minVisitNum >= cutData.visitNum ) {\n+                    contig.setCut(true);\n+                }\n+            }\n+        }\n+        return cutData;\n+    }\n+\n+    @VisibleForTesting\n+    static void unlinkContig( final Contig contig,\n+                                      final KmerSet<KmerAdjacency> kmerAdjacencySet ) {\n+        final KmerAdjacency firstKmer = contig.getFirstKmer();\n+        final int firstKmerFinalCall = firstKmer.getFinalCall();\n+        for ( final Contig predecessor : contig.getPredecessors() ) {\n+            if ( predecessor != contig && predecessor != contig.rc() ) {\n+                predecessor.getLastKmer().removeSuccessor(firstKmerFinalCall, kmerAdjacencySet);\n+                if ( !predecessor.getSuccessors().remove(contig) ) {\n+                    throw new GATKException(\"failed to find predecessor link\");\n+                }\n+            }\n+        }\n+\n+        final KmerAdjacency lastKmer = contig.getLastKmer();\n+        final int lastKmerInitialCall = lastKmer.getInitialCall();\n+        for ( final Contig successor : contig.getSuccessors() ) {\n+            if ( successor != contig && successor != contig.rc() ) {\n+                successor.getFirstKmer().removePredecessor(lastKmerInitialCall, kmerAdjacencySet);\n+                if ( !successor.getPredecessors().remove(contig) ) {\n+                    throw new GATKException(\"failed to find successor link\");\n+                }\n+            }\n+        }\n+\n+        KmerAdjacency nextKmer = firstKmer;\n+        KmerAdjacency kmer;\n+        do {\n+            kmer = nextKmer;\n+            nextKmer = kmer.getSoleSuccessor();\n+            kmerAdjacencySet.remove(kmer.canonical());\n+        } while ( kmer != lastKmer );\n+    }\n+\n+    private static void updateKmerContig( final KmerAdjacency firstKmer,\n+                                          final KmerAdjacency lastKmer,\n+                                          final Contig contig ) {\n+        int offset = 0;\n+        for ( KmerAdjacency kmer = firstKmer; kmer != lastKmer; kmer = kmer.getSoleSuccessor() ) {\n+            if ( kmer == null ) {\n+                throw new GATKException(\"contig does not have a flat pipeline of kmers\");\n+            }\n+            kmer.clearContig();\n+            kmer.setContigOffset(contig, offset++);\n+        }\n+        lastKmer.clearContig();\n+        lastKmer.setContigOffset(contig, offset);\n+        if ( offset + Kmer.KSIZE != contig.size() ) {\n+            throw new GATKException(\"kmer chain length does not equal contig size\");\n+        }\n+    }\n+\n+    /** replace adjacent contigs without branches with a single, larger contig **/\n+    @VisibleForTesting\n+    static void weldPipes( final List<ContigImpl> contigs ) {\n+        for ( int contigIdx = 0; contigIdx != contigs.size(); ++contigIdx ) {\n+            final ContigImpl contig = contigs.get(contigIdx);\n+            if ( contig.getSuccessors().size() == 1 ) {\n+                final Contig successor = contig.getSuccessors().get(0);\n+                if ( successor != contig && successor != contig.rc() &&\n+                        successor.getPredecessors().size() == 1 ) {\n+                    contigs.set(contigIdx, join(contig.getId(), contig, successor));\n+                    if ( !contigs.remove(successor.canonical()) ) {\n+                        throw new GATKException(\"successor linkage is messed up\");\n+                    }\n+                    contigIdx -= 1; // reconsider the new contig -- there might be more joining possible\n+                    continue;\n+                }\n+            }\n+            if ( contig.getPredecessors().size() == 1 ) {\n+                final Contig predecessor = contig.getPredecessors().get(0);\n+                if ( predecessor != contig && predecessor != contig.rc() &&\n+                        predecessor.getSuccessors().size() == 1 ) {\n+                    contigs.set(contigIdx, join(contig.getId(), predecessor, contig));\n+                    if ( !contigs.remove(predecessor.canonical()) ) {\n+                        throw new GATKException(\"predecessor linkage is messed up\");\n+                    }\n+                    contigIdx -= 1; // reconsider\n+                }\n+            }\n+        }\n+    }\n+\n+    private static ContigImpl join( final int id, final Contig predecessor, final Contig successor ) {\n+        if ( !checkOverlap(predecessor.getSequence(), successor.getSequence()) ) {\n+                throw new GATKException(\"sequences can't be joined\");\n+        }\n+        final ContigImpl joinedContig = new ContigImpl(id, predecessor, successor);\n+        updateKmerContig(joinedContig.getFirstKmer(), joinedContig.getLastKmer(), joinedContig);\n+        return joinedContig;\n+    }\n+\n+    private static boolean checkOverlap( final CharSequence seq1, final CharSequence seq2 ) {\n+        final int seq1Len = seq1.length();\n+        final CharSequence seq1SubSeq = seq1.subSequence(seq1Len - Kmer.KSIZE + 1, seq1Len);\n+        final CharSequence seq2SubSeq = seq2.subSequence(0, Kmer.KSIZE - 1);\n+        return seq1SubSeq.equals(seq2SubSeq);\n+    }\n+\n+    /** set a unique componentId for every connected group of contigs **/\n+    @VisibleForTesting\n+    static int markComponents( final List<ContigImpl> contigs ) {\n+        for ( final ContigImpl contig : contigs ) {\n+            contig.setComponentId(0);\n+        }\n+\n+        int componentId = 0;\n+        for ( final ContigImpl contig : contigs ) {\n+            if ( contig.getComponentId() == 0 ) {\n+                contig.setComponentId(++componentId);\n+                markSuccessorComponents(contig);\n+                markSuccessorComponents(contig.rc());\n+            }\n+        }\n+        return componentId;\n+    }\n+\n+    private static void markSuccessorComponents( final Contig contig ) {\n+        final int componentId = contig.getComponentId();\n+        for ( final Contig successor : contig.getSuccessors() ) {\n+            if ( successor.getComponentId() == 0 ) {\n+                successor.canonical().setComponentId(componentId);\n+                markSuccessorComponents(successor);\n+                markSuccessorComponents(successor.rc());\n+            }\n+        }\n+    }\n+\n+    @VisibleForTesting\n+    static void markCycles( final List<ContigImpl> contigs ) {\n+        for ( final Contig contig : contigs ) {\n+            contig.setCyclic(false);\n+        }\n+\n+        final int nContigs = contigs.size();\n+        final Deque<Contig> deque = new ArrayDeque<>(nContigs);\n+        final Map<Contig, CutData> cutDataMap = new HashMap<>(nContigs * 3);\n+        for ( final Contig contig : contigs ) {\n+            if ( !cutDataMap.containsKey(contig) ) {\n+                markCyclesRecursion(contig, deque, cutDataMap);\n+            }\n+        }\n+    }\n+\n+    private static CutData markCyclesRecursion( final Contig contig,\n+                                                final Deque<Contig> deque,\n+                                                final Map<Contig, CutData> cutDataMap ) {\n+        final CutData cutData = new CutData();\n+        cutDataMap.put(contig, cutData);\n+        deque.addFirst(contig);\n+\n+        for ( final Contig successor : contig.getSuccessors() ) {\n+            final CutData successorCutData = cutDataMap.get(successor);\n+            if ( successorCutData == null ) {\n+                final int recursionVisitNum =\n+                        markCyclesRecursion(successor, deque, cutDataMap).minVisitNum;\n+                cutData.minVisitNum = Math.min(cutData.minVisitNum, recursionVisitNum);\n+            } else {\n+                cutData.minVisitNum = Math.min(cutData.minVisitNum, successorCutData.visitNum);\n+            }\n+        }\n+\n+        if ( cutData.visitNum == cutData.minVisitNum ) {\n+            Contig tig = deque.removeFirst();\n+            if ( tig == contig ) {\n+                cutDataMap.get(tig).visitNum = Integer.MAX_VALUE;\n+\n+                // single-vertex component -- cyclic only if self-referential\n+                if ( tig.getSuccessors().contains(tig) ) {\n+                    tig.setCyclic(true);\n+                }\n+            } else {\n+                while ( true ) {\n+                    // kill cross-links\n+                    cutDataMap.get(tig).visitNum = Integer.MAX_VALUE;\n+                    tig.setCyclic(true);\n+                    if ( tig == contig ) break;\n+                    tig = deque.removeFirst();\n+                }\n+            }\n+        }\n+        return cutData;\n+    }\n+\n+    @VisibleForTesting\n+    static boolean fillGaps( final KmerSet<KmerAdjacency> kmerAdjacencySet,\n+                             final List<GATKRead> reads ) {\n+        final Map<String, Integer> gapFillCounts = new HashMap<>();\n+        for ( final GATKRead read : reads ) {\n+            final Path path = new Path(read.getBasesNoCopy(), kmerAdjacencySet);\n+            final List<PathPart> parts = path.getParts();\n+            final int lastIdx = parts.size() - 1;\n+            for ( int idx = 1; idx < lastIdx; ++idx ) {\n+                final PathPart pathPart = parts.get(idx);\n+                if ( pathPart.isGap() ) {\n+                    final char prevCall = parts.get(idx - 1).getLastCall();\n+                    final char nextCall = parts.get(idx + 1).getFirstCall();\n+                    String gapFill = prevCall + pathPart.getSequence().toString() + nextCall;\n+                    final SequenceRC gapFillRC = new SequenceRC(gapFill);\n+                    if ( gapFillRC.compareTo(gapFill) < 0 ) {\n+                        gapFill = gapFillRC.toString();\n+                    }\n+                    gapFillCounts.merge(gapFill, 1, Integer::sum);\n+                }\n+            }\n+        }\n+\n+        boolean newKmers = false;\n+        for ( final Map.Entry<String, Integer> entry : gapFillCounts.entrySet() ) {\n+            final int nObservations = entry.getValue();\n+            if ( nObservations >= MIN_GAPFILL_COUNT ) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MTgzMTI0OQ=="}, "originalCommit": {"oid": "e2201c1ef4f8ba71f17e169f07756cfe2f1ecb49"}, "originalPosition": 603}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzc1NDc1Nzk4OnYy", "diffSide": "RIGHT", "path": "src/main/java/org/broadinstitute/hellbender/tools/LocalAssembler.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMy0xNVQxNzowMTo1M1rOI2-ibg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMy0xNVQxNzowMTo1M1rOI2-ibg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5NDUxODYzOA==", "bodyText": "To keep the size of files a little more manageable, I might consider breaking out collections of related methods into their own clasess. For example, would a LocalAssemblyGraphPathUtils class make sense for static methods that deal with Path objects?", "url": "https://github.com/broadinstitute/gatk/pull/6989#discussion_r594518638", "createdAt": "2021-03-15T17:01:53Z", "author": {"login": "cwhelan"}, "path": "src/main/java/org/broadinstitute/hellbender/tools/LocalAssembler.java", "diffHunk": "@@ -0,0 +1,2306 @@\n+package org.broadinstitute.hellbender.tools;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import htsjdk.samtools.Cigar;\n+import htsjdk.samtools.CigarElement;\n+import htsjdk.samtools.CigarOperator;\n+import htsjdk.samtools.SAMUtils;\n+import org.broadinstitute.barclay.argparser.Argument;\n+import org.broadinstitute.barclay.argparser.BetaFeature;\n+import org.broadinstitute.barclay.argparser.CommandLineProgramProperties;\n+import org.broadinstitute.barclay.help.DocumentedFeature;\n+import org.broadinstitute.hellbender.cmdline.StandardArgumentDefinitions;\n+import org.broadinstitute.hellbender.cmdline.programgroups.CoverageAnalysisProgramGroup;\n+import org.broadinstitute.hellbender.exceptions.GATKException;\n+import org.broadinstitute.hellbender.tools.walkers.PairWalker;\n+import org.broadinstitute.hellbender.utils.SimpleInterval;\n+import org.broadinstitute.hellbender.utils.collections.HopscotchSet;\n+import org.broadinstitute.hellbender.utils.gcs.BucketUtils;\n+import org.broadinstitute.hellbender.utils.read.GATKRead;\n+\n+import java.io.BufferedWriter;\n+import java.io.FileWriter;\n+import java.io.IOException;\n+import java.io.OutputStreamWriter;\n+import java.util.*;\n+import java.util.zip.GZIPOutputStream;\n+\n+@DocumentedFeature\n+@CommandLineProgramProperties(\n+        summary = \"experiment\",\n+        oneLineSummary = \"experiment\",\n+        usageExample = \"gatk LocalAssembler\",\n+        programGroup = CoverageAnalysisProgramGroup.class\n+)\n+@BetaFeature\n+public class LocalAssembler extends PairWalker {\n+    public static final byte QMIN = 25;\n+    public static final int MIN_THIN_OBS = 4;\n+    public static final int MIN_GAPFILL_COUNT = 3;\n+    public static final int TOO_MANY_TRAVERSALS = 100000;\n+    public static final int TOO_MANY_SCAFFOLDS = 50000;\n+    public static final int MIN_SV_SIZE = 50;\n+\n+    @Argument(fullName=StandardArgumentDefinitions.OUTPUT_LONG_NAME,\n+            shortName=StandardArgumentDefinitions.OUTPUT_SHORT_NAME,\n+            doc=\"Write outputs to this file name prefix\", optional = true)\n+    public static String output;\n+\n+    @Argument(fullName=\"assembly-name\", doc=\"name of assembly used as a prefix for traversal names\")\n+    public static String assemblyName;\n+\n+    private final List<GATKRead> reads = new ArrayList<>();\n+\n+    @Override public boolean requiresIntervals() { return true; }\n+\n+    @Override public void apply( final GATKRead read, final GATKRead mate ) {\n+        trimOverruns(read, mate);\n+        reads.add(read);\n+        reads.add(mate);\n+    }\n+\n+    @Override public void applyUnpaired( final GATKRead read ) {\n+        reads.add(read);\n+    }\n+\n+    @Override public Object onTraversalSuccess() {\n+        super.onTraversalSuccess(); // flush any incomplete pairs\n+\n+        final int regionSize = getTraversalIntervals().stream().mapToInt(SimpleInterval::size).sum();\n+        final KmerSet<KmerAdjacency> kmerAdjacencySet = new KmerSet<>(10 * regionSize);\n+        kmerizeReads(reads, kmerAdjacencySet);\n+        List<ContigImpl> contigs = buildContigs(kmerAdjacencySet);\n+        connectContigs(contigs);\n+\n+        removeThinContigs(contigs, kmerAdjacencySet);\n+        weldPipes(contigs);\n+        markComponents(contigs);\n+\n+        if ( fillGaps(kmerAdjacencySet, reads) ) {\n+            contigs = buildContigs(kmerAdjacencySet);\n+            connectContigs(contigs);\n+            removeThinContigs(contigs, kmerAdjacencySet);\n+            weldPipes(contigs);\n+            markComponents(contigs);\n+        }\n+\n+        markCycles(contigs);\n+\n+        final String outputFilePrefix = output != null ? output : assemblyName;\n+        final List<Path> readPaths = pathReads(kmerAdjacencySet, reads);\n+        final Map<Contig,List<TransitPairCount>> contigTransitsMap =\n+                collectTransitPairCounts(contigs, readPaths);\n+        final String traversalsFilename = outputFilePrefix + \".traversals.fa.gz\";\n+        try {\n+            final List<Traversal> allTraversals =\n+                    new ArrayList<>(traverseAllPaths(contigs, readPaths, contigTransitsMap));\n+            writeTraversals(allTraversals, traversalsFilename);\n+            try {\n+                final String scaffoldsFileName = outputFilePrefix + \".scaffolds.fa.gz\";\n+                writeTraversals(createScaffolds(allTraversals), scaffoldsFileName);\n+            } catch ( final AssemblyTooComplexException x ) {\n+                logger.warn(\"Assembly too complex for scaffolding.\");\n+            }\n+        } catch ( final AssemblyTooComplexException x ) {\n+            logger.warn(\"Assembly too complex.  Writing contigs as traversals in \" +\n+                    traversalsFilename + \".\");\n+            final Collection<Traversal> contigTraversals = new ArrayList<>(contigs.size());\n+            for ( final Contig contig : contigs ) {\n+                contigTraversals.add(new Traversal(Collections.singletonList(contig)));\n+            }\n+            writeTraversals(contigTraversals, traversalsFilename);\n+        }\n+\n+        contigs.sort(Comparator.comparingInt(ContigImpl::getId));\n+        writeDOT(contigs, outputFilePrefix + \".assembly.dot\");\n+        writeContigs(contigs, outputFilePrefix + \".contigs.txt.gz\");\n+        writePaths(readPaths, outputFilePrefix + \".paths.txt.gz\");\n+        writeReads(reads, outputFilePrefix + \".reads.fastq.gz\");\n+        return null;\n+    }\n+\n+    /** trim read pairs of base calls that have gone past the end of a short fragment */\n+    private void trimOverruns( final GATKRead read, final GATKRead mate ) {\n+        // if both mapped and they're on different strands\n+        if ( !read.isUnmapped() && !mate.isUnmapped() &&\n+                read.isReverseStrand() != mate.isReverseStrand() ) {\n+            // and both start within 1 base on the ref\n+            if ( Math.abs(read.getStart() - read.getMateStart()) <= 1 ) {\n+                // and both end within 1 base\n+                final int readRefLen = read.getCigar().getReferenceLength();\n+                final int mateRefLen = mate.getCigar().getReferenceLength();\n+                if ( Math.abs(readRefLen - mateRefLen) <= 1 ) {\n+                    if ( mate.isReverseStrand() ) {\n+                        trimClips(read, mate);\n+                    } else {\n+                        trimClips(mate, read);\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    private void trimClips( final GATKRead fwd, final GATKRead rev ) {\n+        final List<CigarElement> fwdElements = fwd.getCigarElements();\n+        final List<CigarElement> revElements = rev.getCigarElements();\n+        final int lastElementIdx = fwdElements.size() - 1;\n+        final CigarElement fwdLastElement = fwdElements.get(lastElementIdx);\n+        final CigarElement revFirstElement = revElements.get(0);\n+        if ( fwdLastElement.getOperator() == CigarOperator.S &&\n+                revFirstElement.getOperator() == CigarOperator.S ) {\n+            final byte[] fwdBases = fwd.getBasesNoCopy();\n+            final int lastElementLen = fwdLastElement.getLength();\n+            fwd.setBases(Arrays.copyOfRange(fwdBases, 0, fwdBases.length - lastElementLen));\n+            final byte[] fwdQuals = fwd.getBaseQualitiesNoCopy();\n+            if ( fwdQuals.length > 0 ) {\n+                final int qualsLen = fwdQuals.length - lastElementLen;\n+                fwd.setBaseQualities(Arrays.copyOfRange(fwdQuals, 0, qualsLen));\n+            }\n+            final List<CigarElement> newFwdElements = new ArrayList<>(fwdElements);\n+            newFwdElements.set(lastElementIdx, new CigarElement(lastElementLen, CigarOperator.H));\n+            fwd.setCigar(new Cigar(newFwdElements));\n+\n+            final byte[] revBases = rev.getBasesNoCopy();\n+            final int firstElementLen = revFirstElement.getLength();\n+            rev.setBases(Arrays.copyOfRange(revBases, firstElementLen, revBases.length));\n+            final byte[] revQuals = rev.getBaseQualitiesNoCopy();\n+            if ( revQuals.length > 0 ) {\n+                rev.setBaseQualities(Arrays.copyOfRange(revQuals, firstElementLen, revQuals.length));\n+            }\n+            final List<CigarElement> newRevElements = new ArrayList<>(revElements);\n+            newRevElements.set(0, new CigarElement(firstElementLen, CigarOperator.H));\n+            rev.setCigar(new Cigar(newRevElements));\n+        }\n+    }\n+\n+    @VisibleForTesting\n+    static void kmerizeReads( final List<GATKRead> reads,\n+                              final KmerSet<KmerAdjacency> kmerAdjacencySet ) {\n+        for ( final GATKRead read : reads ) {\n+            final byte[] calls = read.getBasesNoCopy();\n+            final byte[] quals = read.getBaseQualitiesNoCopy();\n+            KmerAdjacency.kmerize(calls, quals, QMIN, kmerAdjacencySet);\n+        }\n+    }\n+\n+    /** gather unbranched strings of kmers into contigs **/\n+    @VisibleForTesting\n+    static List<ContigImpl> buildContigs( final KmerSet<KmerAdjacency> kmerAdjacencySet ) {\n+        // gather strings of kmers that have a single predecessor and single successor into contigs\n+        final List<ContigImpl> contigs = new ArrayList<>();\n+        int nContigs = 0;\n+        for ( final KmerAdjacency kmerAdjacency : kmerAdjacencySet ) {\n+            if ( kmerAdjacency.getContig() == null ) {\n+                ContigImpl contig = null;\n+                final KmerAdjacency predecessor = kmerAdjacency.getSolePredecessor();\n+                if ( predecessor == null ||\n+                        predecessor.getSuccessorCount() > 1 ||\n+                        predecessor == kmerAdjacency.rc() ) {\n+                    contig = new ContigImpl(++nContigs, kmerAdjacency);\n+                } else {\n+                    final KmerAdjacency successor = kmerAdjacency.getSoleSuccessor();\n+                    if ( successor == null ||\n+                            successor.getPredecessorCount() > 1 ||\n+                            successor == kmerAdjacency.rc() ) {\n+                        contig = new ContigImpl(++nContigs, kmerAdjacency.rc());\n+                    }\n+                }\n+                if ( contig != null ) {\n+                    contigs.add(contig);\n+                }\n+            }\n+        }\n+\n+        // if there are smooth circles like a plasmid, gather them together as a contig, too\n+        for ( final KmerAdjacency kmerAdjacency : kmerAdjacencySet ) {\n+            if ( kmerAdjacency.getContig() == null ) {\n+                contigs.add(new ContigImpl(++nContigs, kmerAdjacency));\n+            }\n+        }\n+\n+        return contigs;\n+    }\n+\n+    /** connect contigs when the final kmer of one contig is adjacent to the inital contig of another **/\n+    @VisibleForTesting\n+    static void connectContigs( final List<ContigImpl> contigs ) {\n+        final int nContigs = contigs.size();\n+        final KmerSet<ContigEndKmer> contigEnds = new KmerSet<>(2*nContigs);\n+        for ( int contigId = 0; contigId != nContigs; ++contigId ) {\n+            final ContigImpl contig = contigs.get(contigId);\n+            final KmerAdjacency fwdKmer = contig.getFirstKmer();\n+            final KmerAdjacency revKmer = contig.getLastKmer().rc();\n+            if ( fwdKmer == revKmer ) {\n+                contigEnds.add(new ContigEndKmer(fwdKmer.getKVal(), contig, ContigOrientation.BOTH));\n+            } else {\n+                contigEnds.add(new ContigEndKmer(fwdKmer.getKVal(), contig, ContigOrientation.FWD));\n+                contigEnds.add(new ContigEndKmer(revKmer.getKVal(), contig, ContigOrientation.REV));\n+            }\n+        }\n+\n+        for ( int contigId = 0; contigId != nContigs; ++contigId ) {\n+            final Contig contig = contigs.get(contigId);\n+\n+            final KmerAdjacency start = contig.getFirstKmer();\n+            final int predecessorCount = start.getPredecessorCount();\n+            if ( predecessorCount > 0 ) {\n+                final List<Contig> predecessors = contig.getPredecessors();\n+                final int mask = start.getPredecessorMask();\n+                for ( int call = 0; call != 4; ++call ) {\n+                    if ( (mask & (1 << call)) != 0 ) {\n+                        final long kVal =\n+                                KmerAdjacency.reverseComplement(start.getPredecessorVal(call));\n+                        final ContigEndKmer contigEndKmer = contigEnds.find(new Kmer(kVal));\n+                        if ( contigEndKmer == null ) {\n+                            throw new GATKException(\"missing contig end kmer\");\n+                        }\n+                        switch ( contigEndKmer.getContigOrientation() ) {\n+                            case FWD:\n+                                predecessors.add(contigEndKmer.getContig().rc());\n+                                break;\n+                            case REV:\n+                                predecessors.add(contigEndKmer.getContig());\n+                                break;\n+                            case BOTH:\n+                                predecessors.add(contigEndKmer.getContig());\n+                                predecessors.add(contigEndKmer.getContig().rc());\n+                                break;\n+                        }\n+                    }\n+                }\n+            }\n+\n+            final KmerAdjacency end = contig.getLastKmer();\n+            final int successorCount = end.getSuccessorCount();\n+            if ( successorCount > 0 ) {\n+                final List<Contig> successors = contig.getSuccessors();\n+                final int mask = end.getSuccessorMask();\n+                for ( int call = 0; call != 4; ++call ) {\n+                    if ( (mask & (1 << call)) != 0 ) {\n+                        final long kVal = end.getSuccessorVal(call);\n+                        final ContigEndKmer contigEndKmer = contigEnds.find(new Kmer(kVal));\n+                        if ( contigEndKmer == null ) {\n+                            throw new GATKException(\"missing contig end kmer\");\n+                        }\n+                        switch ( contigEndKmer.getContigOrientation() ) {\n+                            case FWD:\n+                                successors.add(contigEndKmer.getContig());\n+                                break;\n+                            case REV:\n+                                successors.add(contigEndKmer.getContig().rc());\n+                                break;\n+                            case BOTH:\n+                                successors.add(contigEndKmer.getContig());\n+                                successors.add(contigEndKmer.getContig().rc());\n+                                break;\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    /** remove contigs that have little evidence **/\n+    @VisibleForTesting\n+    static void removeThinContigs( final List<ContigImpl> contigs,\n+                                           final KmerSet<KmerAdjacency> kmerAdjacencySet ) {\n+        contigs.sort(Comparator.comparingInt(ContigImpl::getMaxObservations));\n+        boolean contigRemoved;\n+        do {\n+            // figure out which contigs are cut points\n+            // i.e., those contigs which, if removed, would result in a graph with more connected components\n+            final int nContigs = contigs.size();\n+            final Map<Contig, CutData> cutDataMap = new HashMap<>(nContigs * 3);\n+\n+            for ( final ContigImpl contig : contigs ) {\n+                if ( cutDataMap.containsKey(contig) ) {\n+                    continue;\n+                }\n+\n+                cutDataMap.put(contig, new CutData());\n+                int children = 0;\n+                for ( final Contig nextContig : contig.getSuccessors() ) {\n+                    if ( !cutDataMap.containsKey(nextContig) ) {\n+                        findCuts(nextContig, contig, cutDataMap);\n+                        children += 1;\n+                    }\n+                }\n+                for ( final Contig nextContig : contig.getPredecessors() ) {\n+                    if ( !cutDataMap.containsKey(nextContig) ) {\n+                        findCuts(nextContig, contig, cutDataMap);\n+                        children += 1;\n+                    }\n+                }\n+                if ( children >= 2 ) {\n+                    contig.setCut(true);\n+                }\n+            }\n+\n+            // remove poorly attested (low max observations) contigs, unless they are cut points\n+            contigRemoved = false;\n+            final Iterator<ContigImpl> itr = contigs.iterator();\n+            while ( itr.hasNext() ) {\n+                final Contig contig = itr.next();\n+                if ( contig.getMaxObservations() < MIN_THIN_OBS && !contig.isCut() ) {\n+                    unlinkContig(contig, kmerAdjacencySet);\n+                    itr.remove();\n+                    contigRemoved = true;\n+                    break;\n+                }\n+            }\n+        } while ( contigRemoved );\n+        contigs.sort(Comparator.comparingInt(ContigImpl::getId));\n+    }\n+\n+    private static CutData findCuts( final Contig contig,\n+                                     final Contig parent,\n+                                     final Map<Contig, CutData> cutDataMap ) {\n+        final CutData cutData = new CutData();\n+        cutDataMap.put(contig, cutData);\n+        for ( final Contig nextContig : contig.getSuccessors() ) {\n+            if ( nextContig == parent ) {\n+                continue;\n+            }\n+            CutData nextCutData = cutDataMap.get(nextContig);\n+            if ( nextCutData != null ) {\n+                cutData.minVisitNum = Math.min(cutData.minVisitNum, nextCutData.visitNum);\n+            } else {\n+                nextCutData = findCuts(nextContig, contig, cutDataMap);\n+                cutData.minVisitNum = Math.min(cutData.minVisitNum, nextCutData.minVisitNum);\n+                if ( nextCutData.minVisitNum >= cutData.visitNum ) {\n+                    contig.setCut(true);\n+                }\n+            }\n+        }\n+        for ( final Contig nextContig : contig.getPredecessors() ) {\n+            if ( nextContig == parent ) {\n+                continue;\n+            }\n+            CutData nextCutData = cutDataMap.get(nextContig);\n+            if ( nextCutData != null ) {\n+                cutData.minVisitNum = Math.min(cutData.minVisitNum, nextCutData.visitNum);\n+            } else {\n+                nextCutData = findCuts(nextContig, contig, cutDataMap);\n+                cutData.minVisitNum = Math.min(cutData.minVisitNum, nextCutData.minVisitNum);\n+                if ( nextCutData.minVisitNum >= cutData.visitNum ) {\n+                    contig.setCut(true);\n+                }\n+            }\n+        }\n+        return cutData;\n+    }\n+\n+    @VisibleForTesting\n+    static void unlinkContig( final Contig contig,\n+                                      final KmerSet<KmerAdjacency> kmerAdjacencySet ) {\n+        final KmerAdjacency firstKmer = contig.getFirstKmer();\n+        final int firstKmerFinalCall = firstKmer.getFinalCall();\n+        for ( final Contig predecessor : contig.getPredecessors() ) {\n+            if ( predecessor != contig && predecessor != contig.rc() ) {\n+                predecessor.getLastKmer().removeSuccessor(firstKmerFinalCall, kmerAdjacencySet);\n+                if ( !predecessor.getSuccessors().remove(contig) ) {\n+                    throw new GATKException(\"failed to find predecessor link\");\n+                }\n+            }\n+        }\n+\n+        final KmerAdjacency lastKmer = contig.getLastKmer();\n+        final int lastKmerInitialCall = lastKmer.getInitialCall();\n+        for ( final Contig successor : contig.getSuccessors() ) {\n+            if ( successor != contig && successor != contig.rc() ) {\n+                successor.getFirstKmer().removePredecessor(lastKmerInitialCall, kmerAdjacencySet);\n+                if ( !successor.getPredecessors().remove(contig) ) {\n+                    throw new GATKException(\"failed to find successor link\");\n+                }\n+            }\n+        }\n+\n+        KmerAdjacency nextKmer = firstKmer;\n+        KmerAdjacency kmer;\n+        do {\n+            kmer = nextKmer;\n+            nextKmer = kmer.getSoleSuccessor();\n+            kmerAdjacencySet.remove(kmer.canonical());\n+        } while ( kmer != lastKmer );\n+    }\n+\n+    private static void updateKmerContig( final KmerAdjacency firstKmer,\n+                                          final KmerAdjacency lastKmer,\n+                                          final Contig contig ) {\n+        int offset = 0;\n+        for ( KmerAdjacency kmer = firstKmer; kmer != lastKmer; kmer = kmer.getSoleSuccessor() ) {\n+            if ( kmer == null ) {\n+                throw new GATKException(\"contig does not have a flat pipeline of kmers\");\n+            }\n+            kmer.clearContig();\n+            kmer.setContigOffset(contig, offset++);\n+        }\n+        lastKmer.clearContig();\n+        lastKmer.setContigOffset(contig, offset);\n+        if ( offset + Kmer.KSIZE != contig.size() ) {\n+            throw new GATKException(\"kmer chain length does not equal contig size\");\n+        }\n+    }\n+\n+    /** replace adjacent contigs without branches with a single, larger contig **/\n+    @VisibleForTesting\n+    static void weldPipes( final List<ContigImpl> contigs ) {\n+        for ( int contigIdx = 0; contigIdx != contigs.size(); ++contigIdx ) {\n+            final ContigImpl contig = contigs.get(contigIdx);\n+            if ( contig.getSuccessors().size() == 1 ) {\n+                final Contig successor = contig.getSuccessors().get(0);\n+                if ( successor != contig && successor != contig.rc() &&\n+                        successor.getPredecessors().size() == 1 ) {\n+                    contigs.set(contigIdx, join(contig.getId(), contig, successor));\n+                    if ( !contigs.remove(successor.canonical()) ) {\n+                        throw new GATKException(\"successor linkage is messed up\");\n+                    }\n+                    contigIdx -= 1; // reconsider the new contig -- there might be more joining possible\n+                    continue;\n+                }\n+            }\n+            if ( contig.getPredecessors().size() == 1 ) {\n+                final Contig predecessor = contig.getPredecessors().get(0);\n+                if ( predecessor != contig && predecessor != contig.rc() &&\n+                        predecessor.getSuccessors().size() == 1 ) {\n+                    contigs.set(contigIdx, join(contig.getId(), predecessor, contig));\n+                    if ( !contigs.remove(predecessor.canonical()) ) {\n+                        throw new GATKException(\"predecessor linkage is messed up\");\n+                    }\n+                    contigIdx -= 1; // reconsider\n+                }\n+            }\n+        }\n+    }\n+\n+    private static ContigImpl join( final int id, final Contig predecessor, final Contig successor ) {\n+        if ( !checkOverlap(predecessor.getSequence(), successor.getSequence()) ) {\n+                throw new GATKException(\"sequences can't be joined\");\n+        }\n+        final ContigImpl joinedContig = new ContigImpl(id, predecessor, successor);\n+        updateKmerContig(joinedContig.getFirstKmer(), joinedContig.getLastKmer(), joinedContig);\n+        return joinedContig;\n+    }\n+\n+    private static boolean checkOverlap( final CharSequence seq1, final CharSequence seq2 ) {\n+        final int seq1Len = seq1.length();\n+        final CharSequence seq1SubSeq = seq1.subSequence(seq1Len - Kmer.KSIZE + 1, seq1Len);\n+        final CharSequence seq2SubSeq = seq2.subSequence(0, Kmer.KSIZE - 1);\n+        return seq1SubSeq.equals(seq2SubSeq);\n+    }\n+\n+    /** set a unique componentId for every connected group of contigs **/\n+    @VisibleForTesting\n+    static int markComponents( final List<ContigImpl> contigs ) {\n+        for ( final ContigImpl contig : contigs ) {\n+            contig.setComponentId(0);\n+        }\n+\n+        int componentId = 0;\n+        for ( final ContigImpl contig : contigs ) {\n+            if ( contig.getComponentId() == 0 ) {\n+                contig.setComponentId(++componentId);\n+                markSuccessorComponents(contig);\n+                markSuccessorComponents(contig.rc());\n+            }\n+        }\n+        return componentId;\n+    }\n+\n+    private static void markSuccessorComponents( final Contig contig ) {\n+        final int componentId = contig.getComponentId();\n+        for ( final Contig successor : contig.getSuccessors() ) {\n+            if ( successor.getComponentId() == 0 ) {\n+                successor.canonical().setComponentId(componentId);\n+                markSuccessorComponents(successor);\n+                markSuccessorComponents(successor.rc());\n+            }\n+        }\n+    }\n+\n+    @VisibleForTesting\n+    static void markCycles( final List<ContigImpl> contigs ) {\n+        for ( final Contig contig : contigs ) {\n+            contig.setCyclic(false);\n+        }\n+\n+        final int nContigs = contigs.size();\n+        final Deque<Contig> deque = new ArrayDeque<>(nContigs);\n+        final Map<Contig, CutData> cutDataMap = new HashMap<>(nContigs * 3);\n+        for ( final Contig contig : contigs ) {\n+            if ( !cutDataMap.containsKey(contig) ) {\n+                markCyclesRecursion(contig, deque, cutDataMap);\n+            }\n+        }\n+    }\n+\n+    private static CutData markCyclesRecursion( final Contig contig,\n+                                                final Deque<Contig> deque,\n+                                                final Map<Contig, CutData> cutDataMap ) {\n+        final CutData cutData = new CutData();\n+        cutDataMap.put(contig, cutData);\n+        deque.addFirst(contig);\n+\n+        for ( final Contig successor : contig.getSuccessors() ) {\n+            final CutData successorCutData = cutDataMap.get(successor);\n+            if ( successorCutData == null ) {\n+                final int recursionVisitNum =\n+                        markCyclesRecursion(successor, deque, cutDataMap).minVisitNum;\n+                cutData.minVisitNum = Math.min(cutData.minVisitNum, recursionVisitNum);\n+            } else {\n+                cutData.minVisitNum = Math.min(cutData.minVisitNum, successorCutData.visitNum);\n+            }\n+        }\n+\n+        if ( cutData.visitNum == cutData.minVisitNum ) {\n+            Contig tig = deque.removeFirst();\n+            if ( tig == contig ) {\n+                cutDataMap.get(tig).visitNum = Integer.MAX_VALUE;\n+\n+                // single-vertex component -- cyclic only if self-referential\n+                if ( tig.getSuccessors().contains(tig) ) {\n+                    tig.setCyclic(true);\n+                }\n+            } else {\n+                while ( true ) {\n+                    // kill cross-links\n+                    cutDataMap.get(tig).visitNum = Integer.MAX_VALUE;\n+                    tig.setCyclic(true);\n+                    if ( tig == contig ) break;\n+                    tig = deque.removeFirst();\n+                }\n+            }\n+        }\n+        return cutData;\n+    }\n+\n+    @VisibleForTesting\n+    static boolean fillGaps( final KmerSet<KmerAdjacency> kmerAdjacencySet,\n+                             final List<GATKRead> reads ) {\n+        final Map<String, Integer> gapFillCounts = new HashMap<>();\n+        for ( final GATKRead read : reads ) {\n+            final Path path = new Path(read.getBasesNoCopy(), kmerAdjacencySet);\n+            final List<PathPart> parts = path.getParts();\n+            final int lastIdx = parts.size() - 1;\n+            for ( int idx = 1; idx < lastIdx; ++idx ) {\n+                final PathPart pathPart = parts.get(idx);\n+                if ( pathPart.isGap() ) {\n+                    final char prevCall = parts.get(idx - 1).getLastCall();\n+                    final char nextCall = parts.get(idx + 1).getFirstCall();\n+                    String gapFill = prevCall + pathPart.getSequence().toString() + nextCall;\n+                    final SequenceRC gapFillRC = new SequenceRC(gapFill);\n+                    if ( gapFillRC.compareTo(gapFill) < 0 ) {\n+                        gapFill = gapFillRC.toString();\n+                    }\n+                    gapFillCounts.merge(gapFill, 1, Integer::sum);\n+                }\n+            }\n+        }\n+\n+        boolean newKmers = false;\n+        for ( final Map.Entry<String, Integer> entry : gapFillCounts.entrySet() ) {\n+            final int nObservations = entry.getValue();\n+            if ( nObservations >= MIN_GAPFILL_COUNT ) {\n+                KmerAdjacency.kmerize(entry.getKey(), nObservations, kmerAdjacencySet);\n+                newKmers = true;\n+            }\n+        }\n+\n+        if ( newKmers ) {\n+            for ( final KmerAdjacency kmerAdjacency : kmerAdjacencySet ) {\n+                kmerAdjacency.clearContig();\n+            }\n+        }\n+        return newKmers;\n+    }\n+\n+    @VisibleForTesting\n+    static List<Path> pathReads( final KmerSet<KmerAdjacency> kmerAdjacencySet,\n+                          final List<GATKRead> reads ) {\n+        final List<Path> readPaths = new ArrayList<>(reads.size());\n+        for ( final GATKRead read : reads ) {\n+            readPaths.add(new Path(read.getBasesNoCopy(), kmerAdjacencySet));\n+        }\n+        return readPaths;\n+    }\n+\n+    @VisibleForTesting\n+    static Map<Contig,List<TransitPairCount>> collectTransitPairCounts(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e2201c1ef4f8ba71f17e169f07756cfe2f1ecb49"}, "originalPosition": 628}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzc1NDgwMjU2OnYy", "diffSide": "RIGHT", "path": "src/main/java/org/broadinstitute/hellbender/tools/LocalAssembler.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMy0xNVQxNzoxMDozOFrOI2-91w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMy0xNVQxNzoxMDozOFrOI2-91w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5NDUyNTY1NQ==", "bodyText": "This sort of method signature makes me wonder if you would consider making a TraversalSet class with this as an instance method. The traverseAllPaths methods could also be turned into a constructor.", "url": "https://github.com/broadinstitute/gatk/pull/6989#discussion_r594525655", "createdAt": "2021-03-15T17:10:38Z", "author": {"login": "cwhelan"}, "path": "src/main/java/org/broadinstitute/hellbender/tools/LocalAssembler.java", "diffHunk": "@@ -0,0 +1,2306 @@\n+package org.broadinstitute.hellbender.tools;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import htsjdk.samtools.Cigar;\n+import htsjdk.samtools.CigarElement;\n+import htsjdk.samtools.CigarOperator;\n+import htsjdk.samtools.SAMUtils;\n+import org.broadinstitute.barclay.argparser.Argument;\n+import org.broadinstitute.barclay.argparser.BetaFeature;\n+import org.broadinstitute.barclay.argparser.CommandLineProgramProperties;\n+import org.broadinstitute.barclay.help.DocumentedFeature;\n+import org.broadinstitute.hellbender.cmdline.StandardArgumentDefinitions;\n+import org.broadinstitute.hellbender.cmdline.programgroups.CoverageAnalysisProgramGroup;\n+import org.broadinstitute.hellbender.exceptions.GATKException;\n+import org.broadinstitute.hellbender.tools.walkers.PairWalker;\n+import org.broadinstitute.hellbender.utils.SimpleInterval;\n+import org.broadinstitute.hellbender.utils.collections.HopscotchSet;\n+import org.broadinstitute.hellbender.utils.gcs.BucketUtils;\n+import org.broadinstitute.hellbender.utils.read.GATKRead;\n+\n+import java.io.BufferedWriter;\n+import java.io.FileWriter;\n+import java.io.IOException;\n+import java.io.OutputStreamWriter;\n+import java.util.*;\n+import java.util.zip.GZIPOutputStream;\n+\n+@DocumentedFeature\n+@CommandLineProgramProperties(\n+        summary = \"experiment\",\n+        oneLineSummary = \"experiment\",\n+        usageExample = \"gatk LocalAssembler\",\n+        programGroup = CoverageAnalysisProgramGroup.class\n+)\n+@BetaFeature\n+public class LocalAssembler extends PairWalker {\n+    public static final byte QMIN = 25;\n+    public static final int MIN_THIN_OBS = 4;\n+    public static final int MIN_GAPFILL_COUNT = 3;\n+    public static final int TOO_MANY_TRAVERSALS = 100000;\n+    public static final int TOO_MANY_SCAFFOLDS = 50000;\n+    public static final int MIN_SV_SIZE = 50;\n+\n+    @Argument(fullName=StandardArgumentDefinitions.OUTPUT_LONG_NAME,\n+            shortName=StandardArgumentDefinitions.OUTPUT_SHORT_NAME,\n+            doc=\"Write outputs to this file name prefix\", optional = true)\n+    public static String output;\n+\n+    @Argument(fullName=\"assembly-name\", doc=\"name of assembly used as a prefix for traversal names\")\n+    public static String assemblyName;\n+\n+    private final List<GATKRead> reads = new ArrayList<>();\n+\n+    @Override public boolean requiresIntervals() { return true; }\n+\n+    @Override public void apply( final GATKRead read, final GATKRead mate ) {\n+        trimOverruns(read, mate);\n+        reads.add(read);\n+        reads.add(mate);\n+    }\n+\n+    @Override public void applyUnpaired( final GATKRead read ) {\n+        reads.add(read);\n+    }\n+\n+    @Override public Object onTraversalSuccess() {\n+        super.onTraversalSuccess(); // flush any incomplete pairs\n+\n+        final int regionSize = getTraversalIntervals().stream().mapToInt(SimpleInterval::size).sum();\n+        final KmerSet<KmerAdjacency> kmerAdjacencySet = new KmerSet<>(10 * regionSize);\n+        kmerizeReads(reads, kmerAdjacencySet);\n+        List<ContigImpl> contigs = buildContigs(kmerAdjacencySet);\n+        connectContigs(contigs);\n+\n+        removeThinContigs(contigs, kmerAdjacencySet);\n+        weldPipes(contigs);\n+        markComponents(contigs);\n+\n+        if ( fillGaps(kmerAdjacencySet, reads) ) {\n+            contigs = buildContigs(kmerAdjacencySet);\n+            connectContigs(contigs);\n+            removeThinContigs(contigs, kmerAdjacencySet);\n+            weldPipes(contigs);\n+            markComponents(contigs);\n+        }\n+\n+        markCycles(contigs);\n+\n+        final String outputFilePrefix = output != null ? output : assemblyName;\n+        final List<Path> readPaths = pathReads(kmerAdjacencySet, reads);\n+        final Map<Contig,List<TransitPairCount>> contigTransitsMap =\n+                collectTransitPairCounts(contigs, readPaths);\n+        final String traversalsFilename = outputFilePrefix + \".traversals.fa.gz\";\n+        try {\n+            final List<Traversal> allTraversals =\n+                    new ArrayList<>(traverseAllPaths(contigs, readPaths, contigTransitsMap));\n+            writeTraversals(allTraversals, traversalsFilename);\n+            try {\n+                final String scaffoldsFileName = outputFilePrefix + \".scaffolds.fa.gz\";\n+                writeTraversals(createScaffolds(allTraversals), scaffoldsFileName);\n+            } catch ( final AssemblyTooComplexException x ) {\n+                logger.warn(\"Assembly too complex for scaffolding.\");\n+            }\n+        } catch ( final AssemblyTooComplexException x ) {\n+            logger.warn(\"Assembly too complex.  Writing contigs as traversals in \" +\n+                    traversalsFilename + \".\");\n+            final Collection<Traversal> contigTraversals = new ArrayList<>(contigs.size());\n+            for ( final Contig contig : contigs ) {\n+                contigTraversals.add(new Traversal(Collections.singletonList(contig)));\n+            }\n+            writeTraversals(contigTraversals, traversalsFilename);\n+        }\n+\n+        contigs.sort(Comparator.comparingInt(ContigImpl::getId));\n+        writeDOT(contigs, outputFilePrefix + \".assembly.dot\");\n+        writeContigs(contigs, outputFilePrefix + \".contigs.txt.gz\");\n+        writePaths(readPaths, outputFilePrefix + \".paths.txt.gz\");\n+        writeReads(reads, outputFilePrefix + \".reads.fastq.gz\");\n+        return null;\n+    }\n+\n+    /** trim read pairs of base calls that have gone past the end of a short fragment */\n+    private void trimOverruns( final GATKRead read, final GATKRead mate ) {\n+        // if both mapped and they're on different strands\n+        if ( !read.isUnmapped() && !mate.isUnmapped() &&\n+                read.isReverseStrand() != mate.isReverseStrand() ) {\n+            // and both start within 1 base on the ref\n+            if ( Math.abs(read.getStart() - read.getMateStart()) <= 1 ) {\n+                // and both end within 1 base\n+                final int readRefLen = read.getCigar().getReferenceLength();\n+                final int mateRefLen = mate.getCigar().getReferenceLength();\n+                if ( Math.abs(readRefLen - mateRefLen) <= 1 ) {\n+                    if ( mate.isReverseStrand() ) {\n+                        trimClips(read, mate);\n+                    } else {\n+                        trimClips(mate, read);\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    private void trimClips( final GATKRead fwd, final GATKRead rev ) {\n+        final List<CigarElement> fwdElements = fwd.getCigarElements();\n+        final List<CigarElement> revElements = rev.getCigarElements();\n+        final int lastElementIdx = fwdElements.size() - 1;\n+        final CigarElement fwdLastElement = fwdElements.get(lastElementIdx);\n+        final CigarElement revFirstElement = revElements.get(0);\n+        if ( fwdLastElement.getOperator() == CigarOperator.S &&\n+                revFirstElement.getOperator() == CigarOperator.S ) {\n+            final byte[] fwdBases = fwd.getBasesNoCopy();\n+            final int lastElementLen = fwdLastElement.getLength();\n+            fwd.setBases(Arrays.copyOfRange(fwdBases, 0, fwdBases.length - lastElementLen));\n+            final byte[] fwdQuals = fwd.getBaseQualitiesNoCopy();\n+            if ( fwdQuals.length > 0 ) {\n+                final int qualsLen = fwdQuals.length - lastElementLen;\n+                fwd.setBaseQualities(Arrays.copyOfRange(fwdQuals, 0, qualsLen));\n+            }\n+            final List<CigarElement> newFwdElements = new ArrayList<>(fwdElements);\n+            newFwdElements.set(lastElementIdx, new CigarElement(lastElementLen, CigarOperator.H));\n+            fwd.setCigar(new Cigar(newFwdElements));\n+\n+            final byte[] revBases = rev.getBasesNoCopy();\n+            final int firstElementLen = revFirstElement.getLength();\n+            rev.setBases(Arrays.copyOfRange(revBases, firstElementLen, revBases.length));\n+            final byte[] revQuals = rev.getBaseQualitiesNoCopy();\n+            if ( revQuals.length > 0 ) {\n+                rev.setBaseQualities(Arrays.copyOfRange(revQuals, firstElementLen, revQuals.length));\n+            }\n+            final List<CigarElement> newRevElements = new ArrayList<>(revElements);\n+            newRevElements.set(0, new CigarElement(firstElementLen, CigarOperator.H));\n+            rev.setCigar(new Cigar(newRevElements));\n+        }\n+    }\n+\n+    @VisibleForTesting\n+    static void kmerizeReads( final List<GATKRead> reads,\n+                              final KmerSet<KmerAdjacency> kmerAdjacencySet ) {\n+        for ( final GATKRead read : reads ) {\n+            final byte[] calls = read.getBasesNoCopy();\n+            final byte[] quals = read.getBaseQualitiesNoCopy();\n+            KmerAdjacency.kmerize(calls, quals, QMIN, kmerAdjacencySet);\n+        }\n+    }\n+\n+    /** gather unbranched strings of kmers into contigs **/\n+    @VisibleForTesting\n+    static List<ContigImpl> buildContigs( final KmerSet<KmerAdjacency> kmerAdjacencySet ) {\n+        // gather strings of kmers that have a single predecessor and single successor into contigs\n+        final List<ContigImpl> contigs = new ArrayList<>();\n+        int nContigs = 0;\n+        for ( final KmerAdjacency kmerAdjacency : kmerAdjacencySet ) {\n+            if ( kmerAdjacency.getContig() == null ) {\n+                ContigImpl contig = null;\n+                final KmerAdjacency predecessor = kmerAdjacency.getSolePredecessor();\n+                if ( predecessor == null ||\n+                        predecessor.getSuccessorCount() > 1 ||\n+                        predecessor == kmerAdjacency.rc() ) {\n+                    contig = new ContigImpl(++nContigs, kmerAdjacency);\n+                } else {\n+                    final KmerAdjacency successor = kmerAdjacency.getSoleSuccessor();\n+                    if ( successor == null ||\n+                            successor.getPredecessorCount() > 1 ||\n+                            successor == kmerAdjacency.rc() ) {\n+                        contig = new ContigImpl(++nContigs, kmerAdjacency.rc());\n+                    }\n+                }\n+                if ( contig != null ) {\n+                    contigs.add(contig);\n+                }\n+            }\n+        }\n+\n+        // if there are smooth circles like a plasmid, gather them together as a contig, too\n+        for ( final KmerAdjacency kmerAdjacency : kmerAdjacencySet ) {\n+            if ( kmerAdjacency.getContig() == null ) {\n+                contigs.add(new ContigImpl(++nContigs, kmerAdjacency));\n+            }\n+        }\n+\n+        return contigs;\n+    }\n+\n+    /** connect contigs when the final kmer of one contig is adjacent to the inital contig of another **/\n+    @VisibleForTesting\n+    static void connectContigs( final List<ContigImpl> contigs ) {\n+        final int nContigs = contigs.size();\n+        final KmerSet<ContigEndKmer> contigEnds = new KmerSet<>(2*nContigs);\n+        for ( int contigId = 0; contigId != nContigs; ++contigId ) {\n+            final ContigImpl contig = contigs.get(contigId);\n+            final KmerAdjacency fwdKmer = contig.getFirstKmer();\n+            final KmerAdjacency revKmer = contig.getLastKmer().rc();\n+            if ( fwdKmer == revKmer ) {\n+                contigEnds.add(new ContigEndKmer(fwdKmer.getKVal(), contig, ContigOrientation.BOTH));\n+            } else {\n+                contigEnds.add(new ContigEndKmer(fwdKmer.getKVal(), contig, ContigOrientation.FWD));\n+                contigEnds.add(new ContigEndKmer(revKmer.getKVal(), contig, ContigOrientation.REV));\n+            }\n+        }\n+\n+        for ( int contigId = 0; contigId != nContigs; ++contigId ) {\n+            final Contig contig = contigs.get(contigId);\n+\n+            final KmerAdjacency start = contig.getFirstKmer();\n+            final int predecessorCount = start.getPredecessorCount();\n+            if ( predecessorCount > 0 ) {\n+                final List<Contig> predecessors = contig.getPredecessors();\n+                final int mask = start.getPredecessorMask();\n+                for ( int call = 0; call != 4; ++call ) {\n+                    if ( (mask & (1 << call)) != 0 ) {\n+                        final long kVal =\n+                                KmerAdjacency.reverseComplement(start.getPredecessorVal(call));\n+                        final ContigEndKmer contigEndKmer = contigEnds.find(new Kmer(kVal));\n+                        if ( contigEndKmer == null ) {\n+                            throw new GATKException(\"missing contig end kmer\");\n+                        }\n+                        switch ( contigEndKmer.getContigOrientation() ) {\n+                            case FWD:\n+                                predecessors.add(contigEndKmer.getContig().rc());\n+                                break;\n+                            case REV:\n+                                predecessors.add(contigEndKmer.getContig());\n+                                break;\n+                            case BOTH:\n+                                predecessors.add(contigEndKmer.getContig());\n+                                predecessors.add(contigEndKmer.getContig().rc());\n+                                break;\n+                        }\n+                    }\n+                }\n+            }\n+\n+            final KmerAdjacency end = contig.getLastKmer();\n+            final int successorCount = end.getSuccessorCount();\n+            if ( successorCount > 0 ) {\n+                final List<Contig> successors = contig.getSuccessors();\n+                final int mask = end.getSuccessorMask();\n+                for ( int call = 0; call != 4; ++call ) {\n+                    if ( (mask & (1 << call)) != 0 ) {\n+                        final long kVal = end.getSuccessorVal(call);\n+                        final ContigEndKmer contigEndKmer = contigEnds.find(new Kmer(kVal));\n+                        if ( contigEndKmer == null ) {\n+                            throw new GATKException(\"missing contig end kmer\");\n+                        }\n+                        switch ( contigEndKmer.getContigOrientation() ) {\n+                            case FWD:\n+                                successors.add(contigEndKmer.getContig());\n+                                break;\n+                            case REV:\n+                                successors.add(contigEndKmer.getContig().rc());\n+                                break;\n+                            case BOTH:\n+                                successors.add(contigEndKmer.getContig());\n+                                successors.add(contigEndKmer.getContig().rc());\n+                                break;\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    /** remove contigs that have little evidence **/\n+    @VisibleForTesting\n+    static void removeThinContigs( final List<ContigImpl> contigs,\n+                                           final KmerSet<KmerAdjacency> kmerAdjacencySet ) {\n+        contigs.sort(Comparator.comparingInt(ContigImpl::getMaxObservations));\n+        boolean contigRemoved;\n+        do {\n+            // figure out which contigs are cut points\n+            // i.e., those contigs which, if removed, would result in a graph with more connected components\n+            final int nContigs = contigs.size();\n+            final Map<Contig, CutData> cutDataMap = new HashMap<>(nContigs * 3);\n+\n+            for ( final ContigImpl contig : contigs ) {\n+                if ( cutDataMap.containsKey(contig) ) {\n+                    continue;\n+                }\n+\n+                cutDataMap.put(contig, new CutData());\n+                int children = 0;\n+                for ( final Contig nextContig : contig.getSuccessors() ) {\n+                    if ( !cutDataMap.containsKey(nextContig) ) {\n+                        findCuts(nextContig, contig, cutDataMap);\n+                        children += 1;\n+                    }\n+                }\n+                for ( final Contig nextContig : contig.getPredecessors() ) {\n+                    if ( !cutDataMap.containsKey(nextContig) ) {\n+                        findCuts(nextContig, contig, cutDataMap);\n+                        children += 1;\n+                    }\n+                }\n+                if ( children >= 2 ) {\n+                    contig.setCut(true);\n+                }\n+            }\n+\n+            // remove poorly attested (low max observations) contigs, unless they are cut points\n+            contigRemoved = false;\n+            final Iterator<ContigImpl> itr = contigs.iterator();\n+            while ( itr.hasNext() ) {\n+                final Contig contig = itr.next();\n+                if ( contig.getMaxObservations() < MIN_THIN_OBS && !contig.isCut() ) {\n+                    unlinkContig(contig, kmerAdjacencySet);\n+                    itr.remove();\n+                    contigRemoved = true;\n+                    break;\n+                }\n+            }\n+        } while ( contigRemoved );\n+        contigs.sort(Comparator.comparingInt(ContigImpl::getId));\n+    }\n+\n+    private static CutData findCuts( final Contig contig,\n+                                     final Contig parent,\n+                                     final Map<Contig, CutData> cutDataMap ) {\n+        final CutData cutData = new CutData();\n+        cutDataMap.put(contig, cutData);\n+        for ( final Contig nextContig : contig.getSuccessors() ) {\n+            if ( nextContig == parent ) {\n+                continue;\n+            }\n+            CutData nextCutData = cutDataMap.get(nextContig);\n+            if ( nextCutData != null ) {\n+                cutData.minVisitNum = Math.min(cutData.minVisitNum, nextCutData.visitNum);\n+            } else {\n+                nextCutData = findCuts(nextContig, contig, cutDataMap);\n+                cutData.minVisitNum = Math.min(cutData.minVisitNum, nextCutData.minVisitNum);\n+                if ( nextCutData.minVisitNum >= cutData.visitNum ) {\n+                    contig.setCut(true);\n+                }\n+            }\n+        }\n+        for ( final Contig nextContig : contig.getPredecessors() ) {\n+            if ( nextContig == parent ) {\n+                continue;\n+            }\n+            CutData nextCutData = cutDataMap.get(nextContig);\n+            if ( nextCutData != null ) {\n+                cutData.minVisitNum = Math.min(cutData.minVisitNum, nextCutData.visitNum);\n+            } else {\n+                nextCutData = findCuts(nextContig, contig, cutDataMap);\n+                cutData.minVisitNum = Math.min(cutData.minVisitNum, nextCutData.minVisitNum);\n+                if ( nextCutData.minVisitNum >= cutData.visitNum ) {\n+                    contig.setCut(true);\n+                }\n+            }\n+        }\n+        return cutData;\n+    }\n+\n+    @VisibleForTesting\n+    static void unlinkContig( final Contig contig,\n+                                      final KmerSet<KmerAdjacency> kmerAdjacencySet ) {\n+        final KmerAdjacency firstKmer = contig.getFirstKmer();\n+        final int firstKmerFinalCall = firstKmer.getFinalCall();\n+        for ( final Contig predecessor : contig.getPredecessors() ) {\n+            if ( predecessor != contig && predecessor != contig.rc() ) {\n+                predecessor.getLastKmer().removeSuccessor(firstKmerFinalCall, kmerAdjacencySet);\n+                if ( !predecessor.getSuccessors().remove(contig) ) {\n+                    throw new GATKException(\"failed to find predecessor link\");\n+                }\n+            }\n+        }\n+\n+        final KmerAdjacency lastKmer = contig.getLastKmer();\n+        final int lastKmerInitialCall = lastKmer.getInitialCall();\n+        for ( final Contig successor : contig.getSuccessors() ) {\n+            if ( successor != contig && successor != contig.rc() ) {\n+                successor.getFirstKmer().removePredecessor(lastKmerInitialCall, kmerAdjacencySet);\n+                if ( !successor.getPredecessors().remove(contig) ) {\n+                    throw new GATKException(\"failed to find successor link\");\n+                }\n+            }\n+        }\n+\n+        KmerAdjacency nextKmer = firstKmer;\n+        KmerAdjacency kmer;\n+        do {\n+            kmer = nextKmer;\n+            nextKmer = kmer.getSoleSuccessor();\n+            kmerAdjacencySet.remove(kmer.canonical());\n+        } while ( kmer != lastKmer );\n+    }\n+\n+    private static void updateKmerContig( final KmerAdjacency firstKmer,\n+                                          final KmerAdjacency lastKmer,\n+                                          final Contig contig ) {\n+        int offset = 0;\n+        for ( KmerAdjacency kmer = firstKmer; kmer != lastKmer; kmer = kmer.getSoleSuccessor() ) {\n+            if ( kmer == null ) {\n+                throw new GATKException(\"contig does not have a flat pipeline of kmers\");\n+            }\n+            kmer.clearContig();\n+            kmer.setContigOffset(contig, offset++);\n+        }\n+        lastKmer.clearContig();\n+        lastKmer.setContigOffset(contig, offset);\n+        if ( offset + Kmer.KSIZE != contig.size() ) {\n+            throw new GATKException(\"kmer chain length does not equal contig size\");\n+        }\n+    }\n+\n+    /** replace adjacent contigs without branches with a single, larger contig **/\n+    @VisibleForTesting\n+    static void weldPipes( final List<ContigImpl> contigs ) {\n+        for ( int contigIdx = 0; contigIdx != contigs.size(); ++contigIdx ) {\n+            final ContigImpl contig = contigs.get(contigIdx);\n+            if ( contig.getSuccessors().size() == 1 ) {\n+                final Contig successor = contig.getSuccessors().get(0);\n+                if ( successor != contig && successor != contig.rc() &&\n+                        successor.getPredecessors().size() == 1 ) {\n+                    contigs.set(contigIdx, join(contig.getId(), contig, successor));\n+                    if ( !contigs.remove(successor.canonical()) ) {\n+                        throw new GATKException(\"successor linkage is messed up\");\n+                    }\n+                    contigIdx -= 1; // reconsider the new contig -- there might be more joining possible\n+                    continue;\n+                }\n+            }\n+            if ( contig.getPredecessors().size() == 1 ) {\n+                final Contig predecessor = contig.getPredecessors().get(0);\n+                if ( predecessor != contig && predecessor != contig.rc() &&\n+                        predecessor.getSuccessors().size() == 1 ) {\n+                    contigs.set(contigIdx, join(contig.getId(), predecessor, contig));\n+                    if ( !contigs.remove(predecessor.canonical()) ) {\n+                        throw new GATKException(\"predecessor linkage is messed up\");\n+                    }\n+                    contigIdx -= 1; // reconsider\n+                }\n+            }\n+        }\n+    }\n+\n+    private static ContigImpl join( final int id, final Contig predecessor, final Contig successor ) {\n+        if ( !checkOverlap(predecessor.getSequence(), successor.getSequence()) ) {\n+                throw new GATKException(\"sequences can't be joined\");\n+        }\n+        final ContigImpl joinedContig = new ContigImpl(id, predecessor, successor);\n+        updateKmerContig(joinedContig.getFirstKmer(), joinedContig.getLastKmer(), joinedContig);\n+        return joinedContig;\n+    }\n+\n+    private static boolean checkOverlap( final CharSequence seq1, final CharSequence seq2 ) {\n+        final int seq1Len = seq1.length();\n+        final CharSequence seq1SubSeq = seq1.subSequence(seq1Len - Kmer.KSIZE + 1, seq1Len);\n+        final CharSequence seq2SubSeq = seq2.subSequence(0, Kmer.KSIZE - 1);\n+        return seq1SubSeq.equals(seq2SubSeq);\n+    }\n+\n+    /** set a unique componentId for every connected group of contigs **/\n+    @VisibleForTesting\n+    static int markComponents( final List<ContigImpl> contigs ) {\n+        for ( final ContigImpl contig : contigs ) {\n+            contig.setComponentId(0);\n+        }\n+\n+        int componentId = 0;\n+        for ( final ContigImpl contig : contigs ) {\n+            if ( contig.getComponentId() == 0 ) {\n+                contig.setComponentId(++componentId);\n+                markSuccessorComponents(contig);\n+                markSuccessorComponents(contig.rc());\n+            }\n+        }\n+        return componentId;\n+    }\n+\n+    private static void markSuccessorComponents( final Contig contig ) {\n+        final int componentId = contig.getComponentId();\n+        for ( final Contig successor : contig.getSuccessors() ) {\n+            if ( successor.getComponentId() == 0 ) {\n+                successor.canonical().setComponentId(componentId);\n+                markSuccessorComponents(successor);\n+                markSuccessorComponents(successor.rc());\n+            }\n+        }\n+    }\n+\n+    @VisibleForTesting\n+    static void markCycles( final List<ContigImpl> contigs ) {\n+        for ( final Contig contig : contigs ) {\n+            contig.setCyclic(false);\n+        }\n+\n+        final int nContigs = contigs.size();\n+        final Deque<Contig> deque = new ArrayDeque<>(nContigs);\n+        final Map<Contig, CutData> cutDataMap = new HashMap<>(nContigs * 3);\n+        for ( final Contig contig : contigs ) {\n+            if ( !cutDataMap.containsKey(contig) ) {\n+                markCyclesRecursion(contig, deque, cutDataMap);\n+            }\n+        }\n+    }\n+\n+    private static CutData markCyclesRecursion( final Contig contig,\n+                                                final Deque<Contig> deque,\n+                                                final Map<Contig, CutData> cutDataMap ) {\n+        final CutData cutData = new CutData();\n+        cutDataMap.put(contig, cutData);\n+        deque.addFirst(contig);\n+\n+        for ( final Contig successor : contig.getSuccessors() ) {\n+            final CutData successorCutData = cutDataMap.get(successor);\n+            if ( successorCutData == null ) {\n+                final int recursionVisitNum =\n+                        markCyclesRecursion(successor, deque, cutDataMap).minVisitNum;\n+                cutData.minVisitNum = Math.min(cutData.minVisitNum, recursionVisitNum);\n+            } else {\n+                cutData.minVisitNum = Math.min(cutData.minVisitNum, successorCutData.visitNum);\n+            }\n+        }\n+\n+        if ( cutData.visitNum == cutData.minVisitNum ) {\n+            Contig tig = deque.removeFirst();\n+            if ( tig == contig ) {\n+                cutDataMap.get(tig).visitNum = Integer.MAX_VALUE;\n+\n+                // single-vertex component -- cyclic only if self-referential\n+                if ( tig.getSuccessors().contains(tig) ) {\n+                    tig.setCyclic(true);\n+                }\n+            } else {\n+                while ( true ) {\n+                    // kill cross-links\n+                    cutDataMap.get(tig).visitNum = Integer.MAX_VALUE;\n+                    tig.setCyclic(true);\n+                    if ( tig == contig ) break;\n+                    tig = deque.removeFirst();\n+                }\n+            }\n+        }\n+        return cutData;\n+    }\n+\n+    @VisibleForTesting\n+    static boolean fillGaps( final KmerSet<KmerAdjacency> kmerAdjacencySet,\n+                             final List<GATKRead> reads ) {\n+        final Map<String, Integer> gapFillCounts = new HashMap<>();\n+        for ( final GATKRead read : reads ) {\n+            final Path path = new Path(read.getBasesNoCopy(), kmerAdjacencySet);\n+            final List<PathPart> parts = path.getParts();\n+            final int lastIdx = parts.size() - 1;\n+            for ( int idx = 1; idx < lastIdx; ++idx ) {\n+                final PathPart pathPart = parts.get(idx);\n+                if ( pathPart.isGap() ) {\n+                    final char prevCall = parts.get(idx - 1).getLastCall();\n+                    final char nextCall = parts.get(idx + 1).getFirstCall();\n+                    String gapFill = prevCall + pathPart.getSequence().toString() + nextCall;\n+                    final SequenceRC gapFillRC = new SequenceRC(gapFill);\n+                    if ( gapFillRC.compareTo(gapFill) < 0 ) {\n+                        gapFill = gapFillRC.toString();\n+                    }\n+                    gapFillCounts.merge(gapFill, 1, Integer::sum);\n+                }\n+            }\n+        }\n+\n+        boolean newKmers = false;\n+        for ( final Map.Entry<String, Integer> entry : gapFillCounts.entrySet() ) {\n+            final int nObservations = entry.getValue();\n+            if ( nObservations >= MIN_GAPFILL_COUNT ) {\n+                KmerAdjacency.kmerize(entry.getKey(), nObservations, kmerAdjacencySet);\n+                newKmers = true;\n+            }\n+        }\n+\n+        if ( newKmers ) {\n+            for ( final KmerAdjacency kmerAdjacency : kmerAdjacencySet ) {\n+                kmerAdjacency.clearContig();\n+            }\n+        }\n+        return newKmers;\n+    }\n+\n+    @VisibleForTesting\n+    static List<Path> pathReads( final KmerSet<KmerAdjacency> kmerAdjacencySet,\n+                          final List<GATKRead> reads ) {\n+        final List<Path> readPaths = new ArrayList<>(reads.size());\n+        for ( final GATKRead read : reads ) {\n+            readPaths.add(new Path(read.getBasesNoCopy(), kmerAdjacencySet));\n+        }\n+        return readPaths;\n+    }\n+\n+    @VisibleForTesting\n+    static Map<Contig,List<TransitPairCount>> collectTransitPairCounts(\n+            final List<ContigImpl> contigs,\n+            final List<Path> readPaths ) {\n+        final Map<Contig,List<TransitPairCount>> contigTransitsMap =\n+                new HashMap<>(3 * contigs.size());\n+        for ( final Path path : readPaths ) {\n+            final List<PathPart> parts = path.getParts();\n+            final int lastPart = parts.size() - 1;\n+            for ( int partIdx = 1; partIdx < lastPart; ++partIdx ) {\n+                final Contig prevContig = parts.get(partIdx - 1).getContig();\n+                if ( prevContig == null ) continue;\n+                final Contig curContig = parts.get(partIdx).getContig();\n+                if ( curContig == null ) {\n+                    partIdx += 1;\n+                    continue;\n+                }\n+                final Contig nextContig = parts.get(partIdx + 1).getContig();\n+                if ( nextContig == null ) {\n+                    partIdx += 2;\n+                    continue;\n+                }\n+                final TransitPairCount tpc = new TransitPairCount(prevContig, nextContig);\n+                final List<TransitPairCount> tpcList =\n+                        contigTransitsMap.computeIfAbsent(curContig, tig -> new ArrayList<>(4));\n+                final int idx = tpcList.indexOf(tpc);\n+                if ( idx != -1 ) {\n+                    tpcList.get(idx).observe();\n+                } else {\n+                    tpcList.add(tpc);\n+                    contigTransitsMap.computeIfAbsent(curContig.rc(), tig -> new ArrayList<>(4))\n+                            .add(tpc.getRC());\n+                }\n+            }\n+        }\n+        return contigTransitsMap;\n+    }\n+\n+    @VisibleForTesting\n+    static Set<Traversal> traverseAllPaths(\n+            final List<ContigImpl> contigs,\n+            final List<Path> readPaths,\n+            final Map<Contig, List<TransitPairCount>> contigTransitsMap ) {\n+        final Set<Traversal> traversalSet = new HashSet<>();\n+        final List<Contig> contigsList = new ArrayList<>();\n+        for ( final Contig contig : contigs ) {\n+            // untransited contigs are sources, sinks, or large contigs that can't be crossed by a read\n+            // build traversals from these\n+            if ( !contigTransitsMap.containsKey(contig) ) {\n+                boolean done = false;\n+                for ( final Contig successor : contig.getSuccessors() ) {\n+                    traverse(successor, contig,\n+                            contigsList, readPaths, contigTransitsMap, traversalSet);\n+                    done = true;\n+                }\n+                for ( final Contig predecessor : contig.getPredecessors() ) {\n+                    traverse(predecessor.rc(), contig.rc(),\n+                            contigsList, readPaths, contigTransitsMap, traversalSet);\n+                    done = true;\n+                }\n+                if ( !done ) { // if there were no predecessors or successors, it stands alone\n+                    addTraversal(new Traversal(Collections.singletonList(contig)), traversalSet);\n+                }\n+            }\n+        }\n+\n+        // look for transits that haven't been traced\n+        for ( final Map.Entry<Contig, List<TransitPairCount>> entry :\n+                contigTransitsMap.entrySet() ) {\n+            for ( final TransitPairCount tpc : entry.getValue() ) {\n+                if ( tpc.getCount() > 0 ) {\n+                    tpc.resetCount();\n+                    final Contig contig = entry.getKey();\n+                    final Set<Traversal> fwdTraversalSet = new HashSet<>();\n+                    traverse(tpc.getNextContig(), contig,\n+                            contigsList, readPaths, contigTransitsMap, fwdTraversalSet);\n+                    final Set<Traversal> revTraversalSet = new HashSet<>();\n+                    traverse(tpc.getPrevContig().rc(), contig.rc(),\n+                            contigsList, readPaths, contigTransitsMap, revTraversalSet);\n+                    for ( final Traversal revTraversal : revTraversalSet ) {\n+                        final Traversal revTraversalRC = revTraversal.rc();\n+                        for ( final Traversal fwdTraversal : fwdTraversalSet ) {\n+                            final int overlap =\n+                                    findMaxOverlap(revTraversalRC.getContigs(), fwdTraversal.getContigs());\n+                            final Traversal combo =\n+                                    Traversal.combineOverlappers(revTraversalRC, fwdTraversal, overlap);\n+                            addTraversal(combo, traversalSet);\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+\n+        return traversalSet;\n+    }\n+\n+    private static int findMaxOverlap( final List<Contig> prefixes, final List<Contig> suffixes ) {\n+        final int nPrefixes = prefixes.size();\n+        final Contig firstSuffix = suffixes.get(0);\n+        if ( !firstSuffix.isCyclic() ) {\n+            return prefixes.get(nPrefixes - 1) == firstSuffix ? 1 : 0;\n+        }\n+        final int nSuffixes = suffixes.size();\n+        for ( int prefixIdx = Math.max(0, nPrefixes - nSuffixes); prefixIdx != nPrefixes; ++prefixIdx ) {\n+            if ( prefixes.get(prefixIdx) == firstSuffix ) {\n+                int suffixIdx = 1;\n+                boolean match = true;\n+                for ( int prefixIdx2 = prefixIdx + 1; prefixIdx2 != nPrefixes; ++prefixIdx2 ) {\n+                    if ( prefixes.get(prefixIdx2) != suffixes.get(suffixIdx++) ) {\n+                        match = false;\n+                        break;\n+                    }\n+                }\n+                if ( match ) {\n+                    return nPrefixes - prefixIdx;\n+                }\n+            }\n+        }\n+        return 0;\n+    }\n+\n+    private static void traverse( final Contig contig,\n+                                  final Contig predecessor,\n+                                  final List<Contig> contigsList,\n+                                  final List<Path> readPaths,\n+                                  final Map<Contig, List<TransitPairCount>> contigTransitsMap,\n+                                  final Set<Traversal> traversalSet ) {\n+        contigsList.add(predecessor);\n+        if ( contig.isCyclic() ) {\n+            traverseCycle(contig, contigsList, readPaths, contigTransitsMap, traversalSet);\n+            contigsList.remove(contigsList.size() - 1);\n+            return;\n+        }\n+        final List<TransitPairCount> transits = contigTransitsMap.get(contig);\n+        boolean done = false;\n+        if ( transits != null ) {\n+            for ( final TransitPairCount tpc : transits ) {\n+                if ( tpc.getPrevContig() == predecessor ) {\n+                    final Contig successor = tpc.getNextContig();\n+                    if ( predecessor == contig.rc() ) {\n+                        final int nContigs = contigsList.size();\n+                        if ( nContigs > 1 ) {\n+                            if ( successor.rc() == contigsList.get(nContigs - 2) ) {\n+                                continue;\n+                            }\n+                        }\n+                    }\n+                    tpc.resetCount();\n+                    traverse(successor, contig, contigsList, readPaths, contigTransitsMap, traversalSet);\n+                    done = true;\n+                }\n+            }\n+        }\n+        if ( !done ) {\n+            contigsList.add(contig);\n+            addTraversal(new Traversal(contigsList), traversalSet);\n+            contigsList.remove(contigsList.size() - 1);\n+        }\n+        contigsList.remove(contigsList.size() - 1);\n+    }\n+\n+    private static void traverseCycle( final Contig contig,\n+                                       final List<Contig> contigsList,\n+                                       final List<Path> readPaths,\n+                                       final Map<Contig, List<TransitPairCount>> contigTransitsMap,\n+                                       final Set<Traversal> traversalSet ) {\n+        contigsList.add(contig);\n+        final int nContigs = contigsList.size();\n+        // the final element of the list is cyclic, if there's a previous element it will be\n+        // non-cyclic, so start there figuring out how far the read paths lead us\n+        final List<List<Contig>> longestPaths =\n+                findLongestPaths(contigsList.subList(Math.max(0, nContigs - 2), nContigs), readPaths);\n+        // didn't get anywhere -- just complete the traversal\n+        if ( longestPaths.isEmpty() ) {\n+            addTraversal(new Traversal(contigsList, true), traversalSet);\n+        } else {\n+            // for each unique extension into the cycle\n+            for ( final List<Contig> path : longestPaths ) {\n+                // don't think this can happen, but still\n+                if ( path.isEmpty() ) {\n+                    addTraversal(new Traversal(contigsList, true), traversalSet);\n+                    continue;\n+                }\n+                final List<Contig> extendedContigsList =\n+                        new ArrayList<>(contigsList.size() + path.size());\n+                extendedContigsList.addAll(contigsList);\n+                // if we didn't get out of the cycle\n+                if ( path.get(path.size() - 1).isCyclic() ) {\n+                    extendedContigsList.addAll(path);\n+                    addTraversal(new Traversal(extendedContigsList, true), traversalSet);\n+                } else {\n+                    // we found a cycle-exiting path, so extend that normally\n+                    for ( final Contig curContig : path ) {\n+                        if ( curContig.isCyclic() ) {\n+                            extendedContigsList.add(curContig);\n+                        } else {\n+                            final Contig prevContig =\n+                                    extendedContigsList.remove(extendedContigsList.size() - 1);\n+                            traverse(curContig, prevContig, extendedContigsList, readPaths,\n+                                    contigTransitsMap, traversalSet);\n+                            extendedContigsList.add(prevContig);\n+                            break;\n+                        }\n+                    }\n+                }\n+                clearTransitPairs(contigTransitsMap, extendedContigsList);\n+            }\n+        }\n+        contigsList.remove(contigsList.size() - 1);\n+    }\n+\n+    private static void clearTransitPairs(\n+            final Map<Contig, List<TransitPairCount>> contigTransitsMap,\n+            final List<Contig> contigsList ) {\n+        final int lastIdx = contigsList.size() - 1;\n+        for ( int idx = 1; idx < lastIdx; ++idx ) {\n+            final List<TransitPairCount> pairCounts = contigTransitsMap.get(contigsList.get(idx));\n+            if ( pairCounts != null ) {\n+                final Contig predecessor = contigsList.get(idx - 1);\n+                final Contig successor = contigsList.get(idx + 1);\n+                for ( final TransitPairCount tpc : pairCounts ) {\n+                    if ( tpc.getPrevContig() == predecessor && tpc.getNextContig() == successor ) {\n+                        tpc.resetCount();\n+                        break;\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    private static void addTraversal( final Traversal traversal,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e2201c1ef4f8ba71f17e169f07756cfe2f1ecb49"}, "originalPosition": 857}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzc3MDQwMTYyOnYy", "diffSide": "RIGHT", "path": "src/main/java/org/broadinstitute/hellbender/tools/LocalAssembler.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMy0xOFQxNDozOTozNlrOI5R_Cg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMy0xOFQxNDozOTozNlrOI5R_Cg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5NjkzNDQxMA==", "bodyText": "Very minor but I'd find this one-liner easier to read:\nfinal List<Contig> pathContigs = pathParts.stream().map(PathPart::getContig).collect(Collectors.toList());", "url": "https://github.com/broadinstitute/gatk/pull/6989#discussion_r596934410", "createdAt": "2021-03-18T14:39:36Z", "author": {"login": "cwhelan"}, "path": "src/main/java/org/broadinstitute/hellbender/tools/LocalAssembler.java", "diffHunk": "@@ -0,0 +1,2306 @@\n+package org.broadinstitute.hellbender.tools;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import htsjdk.samtools.Cigar;\n+import htsjdk.samtools.CigarElement;\n+import htsjdk.samtools.CigarOperator;\n+import htsjdk.samtools.SAMUtils;\n+import org.broadinstitute.barclay.argparser.Argument;\n+import org.broadinstitute.barclay.argparser.BetaFeature;\n+import org.broadinstitute.barclay.argparser.CommandLineProgramProperties;\n+import org.broadinstitute.barclay.help.DocumentedFeature;\n+import org.broadinstitute.hellbender.cmdline.StandardArgumentDefinitions;\n+import org.broadinstitute.hellbender.cmdline.programgroups.CoverageAnalysisProgramGroup;\n+import org.broadinstitute.hellbender.exceptions.GATKException;\n+import org.broadinstitute.hellbender.tools.walkers.PairWalker;\n+import org.broadinstitute.hellbender.utils.SimpleInterval;\n+import org.broadinstitute.hellbender.utils.collections.HopscotchSet;\n+import org.broadinstitute.hellbender.utils.gcs.BucketUtils;\n+import org.broadinstitute.hellbender.utils.read.GATKRead;\n+\n+import java.io.BufferedWriter;\n+import java.io.FileWriter;\n+import java.io.IOException;\n+import java.io.OutputStreamWriter;\n+import java.util.*;\n+import java.util.zip.GZIPOutputStream;\n+\n+@DocumentedFeature\n+@CommandLineProgramProperties(\n+        summary = \"experiment\",\n+        oneLineSummary = \"experiment\",\n+        usageExample = \"gatk LocalAssembler\",\n+        programGroup = CoverageAnalysisProgramGroup.class\n+)\n+@BetaFeature\n+public class LocalAssembler extends PairWalker {\n+    public static final byte QMIN = 25;\n+    public static final int MIN_THIN_OBS = 4;\n+    public static final int MIN_GAPFILL_COUNT = 3;\n+    public static final int TOO_MANY_TRAVERSALS = 100000;\n+    public static final int TOO_MANY_SCAFFOLDS = 50000;\n+    public static final int MIN_SV_SIZE = 50;\n+\n+    @Argument(fullName=StandardArgumentDefinitions.OUTPUT_LONG_NAME,\n+            shortName=StandardArgumentDefinitions.OUTPUT_SHORT_NAME,\n+            doc=\"Write outputs to this file name prefix\", optional = true)\n+    public static String output;\n+\n+    @Argument(fullName=\"assembly-name\", doc=\"name of assembly used as a prefix for traversal names\")\n+    public static String assemblyName;\n+\n+    private final List<GATKRead> reads = new ArrayList<>();\n+\n+    @Override public boolean requiresIntervals() { return true; }\n+\n+    @Override public void apply( final GATKRead read, final GATKRead mate ) {\n+        trimOverruns(read, mate);\n+        reads.add(read);\n+        reads.add(mate);\n+    }\n+\n+    @Override public void applyUnpaired( final GATKRead read ) {\n+        reads.add(read);\n+    }\n+\n+    @Override public Object onTraversalSuccess() {\n+        super.onTraversalSuccess(); // flush any incomplete pairs\n+\n+        final int regionSize = getTraversalIntervals().stream().mapToInt(SimpleInterval::size).sum();\n+        final KmerSet<KmerAdjacency> kmerAdjacencySet = new KmerSet<>(10 * regionSize);\n+        kmerizeReads(reads, kmerAdjacencySet);\n+        List<ContigImpl> contigs = buildContigs(kmerAdjacencySet);\n+        connectContigs(contigs);\n+\n+        removeThinContigs(contigs, kmerAdjacencySet);\n+        weldPipes(contigs);\n+        markComponents(contigs);\n+\n+        if ( fillGaps(kmerAdjacencySet, reads) ) {\n+            contigs = buildContigs(kmerAdjacencySet);\n+            connectContigs(contigs);\n+            removeThinContigs(contigs, kmerAdjacencySet);\n+            weldPipes(contigs);\n+            markComponents(contigs);\n+        }\n+\n+        markCycles(contigs);\n+\n+        final String outputFilePrefix = output != null ? output : assemblyName;\n+        final List<Path> readPaths = pathReads(kmerAdjacencySet, reads);\n+        final Map<Contig,List<TransitPairCount>> contigTransitsMap =\n+                collectTransitPairCounts(contigs, readPaths);\n+        final String traversalsFilename = outputFilePrefix + \".traversals.fa.gz\";\n+        try {\n+            final List<Traversal> allTraversals =\n+                    new ArrayList<>(traverseAllPaths(contigs, readPaths, contigTransitsMap));\n+            writeTraversals(allTraversals, traversalsFilename);\n+            try {\n+                final String scaffoldsFileName = outputFilePrefix + \".scaffolds.fa.gz\";\n+                writeTraversals(createScaffolds(allTraversals), scaffoldsFileName);\n+            } catch ( final AssemblyTooComplexException x ) {\n+                logger.warn(\"Assembly too complex for scaffolding.\");\n+            }\n+        } catch ( final AssemblyTooComplexException x ) {\n+            logger.warn(\"Assembly too complex.  Writing contigs as traversals in \" +\n+                    traversalsFilename + \".\");\n+            final Collection<Traversal> contigTraversals = new ArrayList<>(contigs.size());\n+            for ( final Contig contig : contigs ) {\n+                contigTraversals.add(new Traversal(Collections.singletonList(contig)));\n+            }\n+            writeTraversals(contigTraversals, traversalsFilename);\n+        }\n+\n+        contigs.sort(Comparator.comparingInt(ContigImpl::getId));\n+        writeDOT(contigs, outputFilePrefix + \".assembly.dot\");\n+        writeContigs(contigs, outputFilePrefix + \".contigs.txt.gz\");\n+        writePaths(readPaths, outputFilePrefix + \".paths.txt.gz\");\n+        writeReads(reads, outputFilePrefix + \".reads.fastq.gz\");\n+        return null;\n+    }\n+\n+    /** trim read pairs of base calls that have gone past the end of a short fragment */\n+    private void trimOverruns( final GATKRead read, final GATKRead mate ) {\n+        // if both mapped and they're on different strands\n+        if ( !read.isUnmapped() && !mate.isUnmapped() &&\n+                read.isReverseStrand() != mate.isReverseStrand() ) {\n+            // and both start within 1 base on the ref\n+            if ( Math.abs(read.getStart() - read.getMateStart()) <= 1 ) {\n+                // and both end within 1 base\n+                final int readRefLen = read.getCigar().getReferenceLength();\n+                final int mateRefLen = mate.getCigar().getReferenceLength();\n+                if ( Math.abs(readRefLen - mateRefLen) <= 1 ) {\n+                    if ( mate.isReverseStrand() ) {\n+                        trimClips(read, mate);\n+                    } else {\n+                        trimClips(mate, read);\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    private void trimClips( final GATKRead fwd, final GATKRead rev ) {\n+        final List<CigarElement> fwdElements = fwd.getCigarElements();\n+        final List<CigarElement> revElements = rev.getCigarElements();\n+        final int lastElementIdx = fwdElements.size() - 1;\n+        final CigarElement fwdLastElement = fwdElements.get(lastElementIdx);\n+        final CigarElement revFirstElement = revElements.get(0);\n+        if ( fwdLastElement.getOperator() == CigarOperator.S &&\n+                revFirstElement.getOperator() == CigarOperator.S ) {\n+            final byte[] fwdBases = fwd.getBasesNoCopy();\n+            final int lastElementLen = fwdLastElement.getLength();\n+            fwd.setBases(Arrays.copyOfRange(fwdBases, 0, fwdBases.length - lastElementLen));\n+            final byte[] fwdQuals = fwd.getBaseQualitiesNoCopy();\n+            if ( fwdQuals.length > 0 ) {\n+                final int qualsLen = fwdQuals.length - lastElementLen;\n+                fwd.setBaseQualities(Arrays.copyOfRange(fwdQuals, 0, qualsLen));\n+            }\n+            final List<CigarElement> newFwdElements = new ArrayList<>(fwdElements);\n+            newFwdElements.set(lastElementIdx, new CigarElement(lastElementLen, CigarOperator.H));\n+            fwd.setCigar(new Cigar(newFwdElements));\n+\n+            final byte[] revBases = rev.getBasesNoCopy();\n+            final int firstElementLen = revFirstElement.getLength();\n+            rev.setBases(Arrays.copyOfRange(revBases, firstElementLen, revBases.length));\n+            final byte[] revQuals = rev.getBaseQualitiesNoCopy();\n+            if ( revQuals.length > 0 ) {\n+                rev.setBaseQualities(Arrays.copyOfRange(revQuals, firstElementLen, revQuals.length));\n+            }\n+            final List<CigarElement> newRevElements = new ArrayList<>(revElements);\n+            newRevElements.set(0, new CigarElement(firstElementLen, CigarOperator.H));\n+            rev.setCigar(new Cigar(newRevElements));\n+        }\n+    }\n+\n+    @VisibleForTesting\n+    static void kmerizeReads( final List<GATKRead> reads,\n+                              final KmerSet<KmerAdjacency> kmerAdjacencySet ) {\n+        for ( final GATKRead read : reads ) {\n+            final byte[] calls = read.getBasesNoCopy();\n+            final byte[] quals = read.getBaseQualitiesNoCopy();\n+            KmerAdjacency.kmerize(calls, quals, QMIN, kmerAdjacencySet);\n+        }\n+    }\n+\n+    /** gather unbranched strings of kmers into contigs **/\n+    @VisibleForTesting\n+    static List<ContigImpl> buildContigs( final KmerSet<KmerAdjacency> kmerAdjacencySet ) {\n+        // gather strings of kmers that have a single predecessor and single successor into contigs\n+        final List<ContigImpl> contigs = new ArrayList<>();\n+        int nContigs = 0;\n+        for ( final KmerAdjacency kmerAdjacency : kmerAdjacencySet ) {\n+            if ( kmerAdjacency.getContig() == null ) {\n+                ContigImpl contig = null;\n+                final KmerAdjacency predecessor = kmerAdjacency.getSolePredecessor();\n+                if ( predecessor == null ||\n+                        predecessor.getSuccessorCount() > 1 ||\n+                        predecessor == kmerAdjacency.rc() ) {\n+                    contig = new ContigImpl(++nContigs, kmerAdjacency);\n+                } else {\n+                    final KmerAdjacency successor = kmerAdjacency.getSoleSuccessor();\n+                    if ( successor == null ||\n+                            successor.getPredecessorCount() > 1 ||\n+                            successor == kmerAdjacency.rc() ) {\n+                        contig = new ContigImpl(++nContigs, kmerAdjacency.rc());\n+                    }\n+                }\n+                if ( contig != null ) {\n+                    contigs.add(contig);\n+                }\n+            }\n+        }\n+\n+        // if there are smooth circles like a plasmid, gather them together as a contig, too\n+        for ( final KmerAdjacency kmerAdjacency : kmerAdjacencySet ) {\n+            if ( kmerAdjacency.getContig() == null ) {\n+                contigs.add(new ContigImpl(++nContigs, kmerAdjacency));\n+            }\n+        }\n+\n+        return contigs;\n+    }\n+\n+    /** connect contigs when the final kmer of one contig is adjacent to the inital contig of another **/\n+    @VisibleForTesting\n+    static void connectContigs( final List<ContigImpl> contigs ) {\n+        final int nContigs = contigs.size();\n+        final KmerSet<ContigEndKmer> contigEnds = new KmerSet<>(2*nContigs);\n+        for ( int contigId = 0; contigId != nContigs; ++contigId ) {\n+            final ContigImpl contig = contigs.get(contigId);\n+            final KmerAdjacency fwdKmer = contig.getFirstKmer();\n+            final KmerAdjacency revKmer = contig.getLastKmer().rc();\n+            if ( fwdKmer == revKmer ) {\n+                contigEnds.add(new ContigEndKmer(fwdKmer.getKVal(), contig, ContigOrientation.BOTH));\n+            } else {\n+                contigEnds.add(new ContigEndKmer(fwdKmer.getKVal(), contig, ContigOrientation.FWD));\n+                contigEnds.add(new ContigEndKmer(revKmer.getKVal(), contig, ContigOrientation.REV));\n+            }\n+        }\n+\n+        for ( int contigId = 0; contigId != nContigs; ++contigId ) {\n+            final Contig contig = contigs.get(contigId);\n+\n+            final KmerAdjacency start = contig.getFirstKmer();\n+            final int predecessorCount = start.getPredecessorCount();\n+            if ( predecessorCount > 0 ) {\n+                final List<Contig> predecessors = contig.getPredecessors();\n+                final int mask = start.getPredecessorMask();\n+                for ( int call = 0; call != 4; ++call ) {\n+                    if ( (mask & (1 << call)) != 0 ) {\n+                        final long kVal =\n+                                KmerAdjacency.reverseComplement(start.getPredecessorVal(call));\n+                        final ContigEndKmer contigEndKmer = contigEnds.find(new Kmer(kVal));\n+                        if ( contigEndKmer == null ) {\n+                            throw new GATKException(\"missing contig end kmer\");\n+                        }\n+                        switch ( contigEndKmer.getContigOrientation() ) {\n+                            case FWD:\n+                                predecessors.add(contigEndKmer.getContig().rc());\n+                                break;\n+                            case REV:\n+                                predecessors.add(contigEndKmer.getContig());\n+                                break;\n+                            case BOTH:\n+                                predecessors.add(contigEndKmer.getContig());\n+                                predecessors.add(contigEndKmer.getContig().rc());\n+                                break;\n+                        }\n+                    }\n+                }\n+            }\n+\n+            final KmerAdjacency end = contig.getLastKmer();\n+            final int successorCount = end.getSuccessorCount();\n+            if ( successorCount > 0 ) {\n+                final List<Contig> successors = contig.getSuccessors();\n+                final int mask = end.getSuccessorMask();\n+                for ( int call = 0; call != 4; ++call ) {\n+                    if ( (mask & (1 << call)) != 0 ) {\n+                        final long kVal = end.getSuccessorVal(call);\n+                        final ContigEndKmer contigEndKmer = contigEnds.find(new Kmer(kVal));\n+                        if ( contigEndKmer == null ) {\n+                            throw new GATKException(\"missing contig end kmer\");\n+                        }\n+                        switch ( contigEndKmer.getContigOrientation() ) {\n+                            case FWD:\n+                                successors.add(contigEndKmer.getContig());\n+                                break;\n+                            case REV:\n+                                successors.add(contigEndKmer.getContig().rc());\n+                                break;\n+                            case BOTH:\n+                                successors.add(contigEndKmer.getContig());\n+                                successors.add(contigEndKmer.getContig().rc());\n+                                break;\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    /** remove contigs that have little evidence **/\n+    @VisibleForTesting\n+    static void removeThinContigs( final List<ContigImpl> contigs,\n+                                           final KmerSet<KmerAdjacency> kmerAdjacencySet ) {\n+        contigs.sort(Comparator.comparingInt(ContigImpl::getMaxObservations));\n+        boolean contigRemoved;\n+        do {\n+            // figure out which contigs are cut points\n+            // i.e., those contigs which, if removed, would result in a graph with more connected components\n+            final int nContigs = contigs.size();\n+            final Map<Contig, CutData> cutDataMap = new HashMap<>(nContigs * 3);\n+\n+            for ( final ContigImpl contig : contigs ) {\n+                if ( cutDataMap.containsKey(contig) ) {\n+                    continue;\n+                }\n+\n+                cutDataMap.put(contig, new CutData());\n+                int children = 0;\n+                for ( final Contig nextContig : contig.getSuccessors() ) {\n+                    if ( !cutDataMap.containsKey(nextContig) ) {\n+                        findCuts(nextContig, contig, cutDataMap);\n+                        children += 1;\n+                    }\n+                }\n+                for ( final Contig nextContig : contig.getPredecessors() ) {\n+                    if ( !cutDataMap.containsKey(nextContig) ) {\n+                        findCuts(nextContig, contig, cutDataMap);\n+                        children += 1;\n+                    }\n+                }\n+                if ( children >= 2 ) {\n+                    contig.setCut(true);\n+                }\n+            }\n+\n+            // remove poorly attested (low max observations) contigs, unless they are cut points\n+            contigRemoved = false;\n+            final Iterator<ContigImpl> itr = contigs.iterator();\n+            while ( itr.hasNext() ) {\n+                final Contig contig = itr.next();\n+                if ( contig.getMaxObservations() < MIN_THIN_OBS && !contig.isCut() ) {\n+                    unlinkContig(contig, kmerAdjacencySet);\n+                    itr.remove();\n+                    contigRemoved = true;\n+                    break;\n+                }\n+            }\n+        } while ( contigRemoved );\n+        contigs.sort(Comparator.comparingInt(ContigImpl::getId));\n+    }\n+\n+    private static CutData findCuts( final Contig contig,\n+                                     final Contig parent,\n+                                     final Map<Contig, CutData> cutDataMap ) {\n+        final CutData cutData = new CutData();\n+        cutDataMap.put(contig, cutData);\n+        for ( final Contig nextContig : contig.getSuccessors() ) {\n+            if ( nextContig == parent ) {\n+                continue;\n+            }\n+            CutData nextCutData = cutDataMap.get(nextContig);\n+            if ( nextCutData != null ) {\n+                cutData.minVisitNum = Math.min(cutData.minVisitNum, nextCutData.visitNum);\n+            } else {\n+                nextCutData = findCuts(nextContig, contig, cutDataMap);\n+                cutData.minVisitNum = Math.min(cutData.minVisitNum, nextCutData.minVisitNum);\n+                if ( nextCutData.minVisitNum >= cutData.visitNum ) {\n+                    contig.setCut(true);\n+                }\n+            }\n+        }\n+        for ( final Contig nextContig : contig.getPredecessors() ) {\n+            if ( nextContig == parent ) {\n+                continue;\n+            }\n+            CutData nextCutData = cutDataMap.get(nextContig);\n+            if ( nextCutData != null ) {\n+                cutData.minVisitNum = Math.min(cutData.minVisitNum, nextCutData.visitNum);\n+            } else {\n+                nextCutData = findCuts(nextContig, contig, cutDataMap);\n+                cutData.minVisitNum = Math.min(cutData.minVisitNum, nextCutData.minVisitNum);\n+                if ( nextCutData.minVisitNum >= cutData.visitNum ) {\n+                    contig.setCut(true);\n+                }\n+            }\n+        }\n+        return cutData;\n+    }\n+\n+    @VisibleForTesting\n+    static void unlinkContig( final Contig contig,\n+                                      final KmerSet<KmerAdjacency> kmerAdjacencySet ) {\n+        final KmerAdjacency firstKmer = contig.getFirstKmer();\n+        final int firstKmerFinalCall = firstKmer.getFinalCall();\n+        for ( final Contig predecessor : contig.getPredecessors() ) {\n+            if ( predecessor != contig && predecessor != contig.rc() ) {\n+                predecessor.getLastKmer().removeSuccessor(firstKmerFinalCall, kmerAdjacencySet);\n+                if ( !predecessor.getSuccessors().remove(contig) ) {\n+                    throw new GATKException(\"failed to find predecessor link\");\n+                }\n+            }\n+        }\n+\n+        final KmerAdjacency lastKmer = contig.getLastKmer();\n+        final int lastKmerInitialCall = lastKmer.getInitialCall();\n+        for ( final Contig successor : contig.getSuccessors() ) {\n+            if ( successor != contig && successor != contig.rc() ) {\n+                successor.getFirstKmer().removePredecessor(lastKmerInitialCall, kmerAdjacencySet);\n+                if ( !successor.getPredecessors().remove(contig) ) {\n+                    throw new GATKException(\"failed to find successor link\");\n+                }\n+            }\n+        }\n+\n+        KmerAdjacency nextKmer = firstKmer;\n+        KmerAdjacency kmer;\n+        do {\n+            kmer = nextKmer;\n+            nextKmer = kmer.getSoleSuccessor();\n+            kmerAdjacencySet.remove(kmer.canonical());\n+        } while ( kmer != lastKmer );\n+    }\n+\n+    private static void updateKmerContig( final KmerAdjacency firstKmer,\n+                                          final KmerAdjacency lastKmer,\n+                                          final Contig contig ) {\n+        int offset = 0;\n+        for ( KmerAdjacency kmer = firstKmer; kmer != lastKmer; kmer = kmer.getSoleSuccessor() ) {\n+            if ( kmer == null ) {\n+                throw new GATKException(\"contig does not have a flat pipeline of kmers\");\n+            }\n+            kmer.clearContig();\n+            kmer.setContigOffset(contig, offset++);\n+        }\n+        lastKmer.clearContig();\n+        lastKmer.setContigOffset(contig, offset);\n+        if ( offset + Kmer.KSIZE != contig.size() ) {\n+            throw new GATKException(\"kmer chain length does not equal contig size\");\n+        }\n+    }\n+\n+    /** replace adjacent contigs without branches with a single, larger contig **/\n+    @VisibleForTesting\n+    static void weldPipes( final List<ContigImpl> contigs ) {\n+        for ( int contigIdx = 0; contigIdx != contigs.size(); ++contigIdx ) {\n+            final ContigImpl contig = contigs.get(contigIdx);\n+            if ( contig.getSuccessors().size() == 1 ) {\n+                final Contig successor = contig.getSuccessors().get(0);\n+                if ( successor != contig && successor != contig.rc() &&\n+                        successor.getPredecessors().size() == 1 ) {\n+                    contigs.set(contigIdx, join(contig.getId(), contig, successor));\n+                    if ( !contigs.remove(successor.canonical()) ) {\n+                        throw new GATKException(\"successor linkage is messed up\");\n+                    }\n+                    contigIdx -= 1; // reconsider the new contig -- there might be more joining possible\n+                    continue;\n+                }\n+            }\n+            if ( contig.getPredecessors().size() == 1 ) {\n+                final Contig predecessor = contig.getPredecessors().get(0);\n+                if ( predecessor != contig && predecessor != contig.rc() &&\n+                        predecessor.getSuccessors().size() == 1 ) {\n+                    contigs.set(contigIdx, join(contig.getId(), predecessor, contig));\n+                    if ( !contigs.remove(predecessor.canonical()) ) {\n+                        throw new GATKException(\"predecessor linkage is messed up\");\n+                    }\n+                    contigIdx -= 1; // reconsider\n+                }\n+            }\n+        }\n+    }\n+\n+    private static ContigImpl join( final int id, final Contig predecessor, final Contig successor ) {\n+        if ( !checkOverlap(predecessor.getSequence(), successor.getSequence()) ) {\n+                throw new GATKException(\"sequences can't be joined\");\n+        }\n+        final ContigImpl joinedContig = new ContigImpl(id, predecessor, successor);\n+        updateKmerContig(joinedContig.getFirstKmer(), joinedContig.getLastKmer(), joinedContig);\n+        return joinedContig;\n+    }\n+\n+    private static boolean checkOverlap( final CharSequence seq1, final CharSequence seq2 ) {\n+        final int seq1Len = seq1.length();\n+        final CharSequence seq1SubSeq = seq1.subSequence(seq1Len - Kmer.KSIZE + 1, seq1Len);\n+        final CharSequence seq2SubSeq = seq2.subSequence(0, Kmer.KSIZE - 1);\n+        return seq1SubSeq.equals(seq2SubSeq);\n+    }\n+\n+    /** set a unique componentId for every connected group of contigs **/\n+    @VisibleForTesting\n+    static int markComponents( final List<ContigImpl> contigs ) {\n+        for ( final ContigImpl contig : contigs ) {\n+            contig.setComponentId(0);\n+        }\n+\n+        int componentId = 0;\n+        for ( final ContigImpl contig : contigs ) {\n+            if ( contig.getComponentId() == 0 ) {\n+                contig.setComponentId(++componentId);\n+                markSuccessorComponents(contig);\n+                markSuccessorComponents(contig.rc());\n+            }\n+        }\n+        return componentId;\n+    }\n+\n+    private static void markSuccessorComponents( final Contig contig ) {\n+        final int componentId = contig.getComponentId();\n+        for ( final Contig successor : contig.getSuccessors() ) {\n+            if ( successor.getComponentId() == 0 ) {\n+                successor.canonical().setComponentId(componentId);\n+                markSuccessorComponents(successor);\n+                markSuccessorComponents(successor.rc());\n+            }\n+        }\n+    }\n+\n+    @VisibleForTesting\n+    static void markCycles( final List<ContigImpl> contigs ) {\n+        for ( final Contig contig : contigs ) {\n+            contig.setCyclic(false);\n+        }\n+\n+        final int nContigs = contigs.size();\n+        final Deque<Contig> deque = new ArrayDeque<>(nContigs);\n+        final Map<Contig, CutData> cutDataMap = new HashMap<>(nContigs * 3);\n+        for ( final Contig contig : contigs ) {\n+            if ( !cutDataMap.containsKey(contig) ) {\n+                markCyclesRecursion(contig, deque, cutDataMap);\n+            }\n+        }\n+    }\n+\n+    private static CutData markCyclesRecursion( final Contig contig,\n+                                                final Deque<Contig> deque,\n+                                                final Map<Contig, CutData> cutDataMap ) {\n+        final CutData cutData = new CutData();\n+        cutDataMap.put(contig, cutData);\n+        deque.addFirst(contig);\n+\n+        for ( final Contig successor : contig.getSuccessors() ) {\n+            final CutData successorCutData = cutDataMap.get(successor);\n+            if ( successorCutData == null ) {\n+                final int recursionVisitNum =\n+                        markCyclesRecursion(successor, deque, cutDataMap).minVisitNum;\n+                cutData.minVisitNum = Math.min(cutData.minVisitNum, recursionVisitNum);\n+            } else {\n+                cutData.minVisitNum = Math.min(cutData.minVisitNum, successorCutData.visitNum);\n+            }\n+        }\n+\n+        if ( cutData.visitNum == cutData.minVisitNum ) {\n+            Contig tig = deque.removeFirst();\n+            if ( tig == contig ) {\n+                cutDataMap.get(tig).visitNum = Integer.MAX_VALUE;\n+\n+                // single-vertex component -- cyclic only if self-referential\n+                if ( tig.getSuccessors().contains(tig) ) {\n+                    tig.setCyclic(true);\n+                }\n+            } else {\n+                while ( true ) {\n+                    // kill cross-links\n+                    cutDataMap.get(tig).visitNum = Integer.MAX_VALUE;\n+                    tig.setCyclic(true);\n+                    if ( tig == contig ) break;\n+                    tig = deque.removeFirst();\n+                }\n+            }\n+        }\n+        return cutData;\n+    }\n+\n+    @VisibleForTesting\n+    static boolean fillGaps( final KmerSet<KmerAdjacency> kmerAdjacencySet,\n+                             final List<GATKRead> reads ) {\n+        final Map<String, Integer> gapFillCounts = new HashMap<>();\n+        for ( final GATKRead read : reads ) {\n+            final Path path = new Path(read.getBasesNoCopy(), kmerAdjacencySet);\n+            final List<PathPart> parts = path.getParts();\n+            final int lastIdx = parts.size() - 1;\n+            for ( int idx = 1; idx < lastIdx; ++idx ) {\n+                final PathPart pathPart = parts.get(idx);\n+                if ( pathPart.isGap() ) {\n+                    final char prevCall = parts.get(idx - 1).getLastCall();\n+                    final char nextCall = parts.get(idx + 1).getFirstCall();\n+                    String gapFill = prevCall + pathPart.getSequence().toString() + nextCall;\n+                    final SequenceRC gapFillRC = new SequenceRC(gapFill);\n+                    if ( gapFillRC.compareTo(gapFill) < 0 ) {\n+                        gapFill = gapFillRC.toString();\n+                    }\n+                    gapFillCounts.merge(gapFill, 1, Integer::sum);\n+                }\n+            }\n+        }\n+\n+        boolean newKmers = false;\n+        for ( final Map.Entry<String, Integer> entry : gapFillCounts.entrySet() ) {\n+            final int nObservations = entry.getValue();\n+            if ( nObservations >= MIN_GAPFILL_COUNT ) {\n+                KmerAdjacency.kmerize(entry.getKey(), nObservations, kmerAdjacencySet);\n+                newKmers = true;\n+            }\n+        }\n+\n+        if ( newKmers ) {\n+            for ( final KmerAdjacency kmerAdjacency : kmerAdjacencySet ) {\n+                kmerAdjacency.clearContig();\n+            }\n+        }\n+        return newKmers;\n+    }\n+\n+    @VisibleForTesting\n+    static List<Path> pathReads( final KmerSet<KmerAdjacency> kmerAdjacencySet,\n+                          final List<GATKRead> reads ) {\n+        final List<Path> readPaths = new ArrayList<>(reads.size());\n+        for ( final GATKRead read : reads ) {\n+            readPaths.add(new Path(read.getBasesNoCopy(), kmerAdjacencySet));\n+        }\n+        return readPaths;\n+    }\n+\n+    @VisibleForTesting\n+    static Map<Contig,List<TransitPairCount>> collectTransitPairCounts(\n+            final List<ContigImpl> contigs,\n+            final List<Path> readPaths ) {\n+        final Map<Contig,List<TransitPairCount>> contigTransitsMap =\n+                new HashMap<>(3 * contigs.size());\n+        for ( final Path path : readPaths ) {\n+            final List<PathPart> parts = path.getParts();\n+            final int lastPart = parts.size() - 1;\n+            for ( int partIdx = 1; partIdx < lastPart; ++partIdx ) {\n+                final Contig prevContig = parts.get(partIdx - 1).getContig();\n+                if ( prevContig == null ) continue;\n+                final Contig curContig = parts.get(partIdx).getContig();\n+                if ( curContig == null ) {\n+                    partIdx += 1;\n+                    continue;\n+                }\n+                final Contig nextContig = parts.get(partIdx + 1).getContig();\n+                if ( nextContig == null ) {\n+                    partIdx += 2;\n+                    continue;\n+                }\n+                final TransitPairCount tpc = new TransitPairCount(prevContig, nextContig);\n+                final List<TransitPairCount> tpcList =\n+                        contigTransitsMap.computeIfAbsent(curContig, tig -> new ArrayList<>(4));\n+                final int idx = tpcList.indexOf(tpc);\n+                if ( idx != -1 ) {\n+                    tpcList.get(idx).observe();\n+                } else {\n+                    tpcList.add(tpc);\n+                    contigTransitsMap.computeIfAbsent(curContig.rc(), tig -> new ArrayList<>(4))\n+                            .add(tpc.getRC());\n+                }\n+            }\n+        }\n+        return contigTransitsMap;\n+    }\n+\n+    @VisibleForTesting\n+    static Set<Traversal> traverseAllPaths(\n+            final List<ContigImpl> contigs,\n+            final List<Path> readPaths,\n+            final Map<Contig, List<TransitPairCount>> contigTransitsMap ) {\n+        final Set<Traversal> traversalSet = new HashSet<>();\n+        final List<Contig> contigsList = new ArrayList<>();\n+        for ( final Contig contig : contigs ) {\n+            // untransited contigs are sources, sinks, or large contigs that can't be crossed by a read\n+            // build traversals from these\n+            if ( !contigTransitsMap.containsKey(contig) ) {\n+                boolean done = false;\n+                for ( final Contig successor : contig.getSuccessors() ) {\n+                    traverse(successor, contig,\n+                            contigsList, readPaths, contigTransitsMap, traversalSet);\n+                    done = true;\n+                }\n+                for ( final Contig predecessor : contig.getPredecessors() ) {\n+                    traverse(predecessor.rc(), contig.rc(),\n+                            contigsList, readPaths, contigTransitsMap, traversalSet);\n+                    done = true;\n+                }\n+                if ( !done ) { // if there were no predecessors or successors, it stands alone\n+                    addTraversal(new Traversal(Collections.singletonList(contig)), traversalSet);\n+                }\n+            }\n+        }\n+\n+        // look for transits that haven't been traced\n+        for ( final Map.Entry<Contig, List<TransitPairCount>> entry :\n+                contigTransitsMap.entrySet() ) {\n+            for ( final TransitPairCount tpc : entry.getValue() ) {\n+                if ( tpc.getCount() > 0 ) {\n+                    tpc.resetCount();\n+                    final Contig contig = entry.getKey();\n+                    final Set<Traversal> fwdTraversalSet = new HashSet<>();\n+                    traverse(tpc.getNextContig(), contig,\n+                            contigsList, readPaths, contigTransitsMap, fwdTraversalSet);\n+                    final Set<Traversal> revTraversalSet = new HashSet<>();\n+                    traverse(tpc.getPrevContig().rc(), contig.rc(),\n+                            contigsList, readPaths, contigTransitsMap, revTraversalSet);\n+                    for ( final Traversal revTraversal : revTraversalSet ) {\n+                        final Traversal revTraversalRC = revTraversal.rc();\n+                        for ( final Traversal fwdTraversal : fwdTraversalSet ) {\n+                            final int overlap =\n+                                    findMaxOverlap(revTraversalRC.getContigs(), fwdTraversal.getContigs());\n+                            final Traversal combo =\n+                                    Traversal.combineOverlappers(revTraversalRC, fwdTraversal, overlap);\n+                            addTraversal(combo, traversalSet);\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+\n+        return traversalSet;\n+    }\n+\n+    private static int findMaxOverlap( final List<Contig> prefixes, final List<Contig> suffixes ) {\n+        final int nPrefixes = prefixes.size();\n+        final Contig firstSuffix = suffixes.get(0);\n+        if ( !firstSuffix.isCyclic() ) {\n+            return prefixes.get(nPrefixes - 1) == firstSuffix ? 1 : 0;\n+        }\n+        final int nSuffixes = suffixes.size();\n+        for ( int prefixIdx = Math.max(0, nPrefixes - nSuffixes); prefixIdx != nPrefixes; ++prefixIdx ) {\n+            if ( prefixes.get(prefixIdx) == firstSuffix ) {\n+                int suffixIdx = 1;\n+                boolean match = true;\n+                for ( int prefixIdx2 = prefixIdx + 1; prefixIdx2 != nPrefixes; ++prefixIdx2 ) {\n+                    if ( prefixes.get(prefixIdx2) != suffixes.get(suffixIdx++) ) {\n+                        match = false;\n+                        break;\n+                    }\n+                }\n+                if ( match ) {\n+                    return nPrefixes - prefixIdx;\n+                }\n+            }\n+        }\n+        return 0;\n+    }\n+\n+    private static void traverse( final Contig contig,\n+                                  final Contig predecessor,\n+                                  final List<Contig> contigsList,\n+                                  final List<Path> readPaths,\n+                                  final Map<Contig, List<TransitPairCount>> contigTransitsMap,\n+                                  final Set<Traversal> traversalSet ) {\n+        contigsList.add(predecessor);\n+        if ( contig.isCyclic() ) {\n+            traverseCycle(contig, contigsList, readPaths, contigTransitsMap, traversalSet);\n+            contigsList.remove(contigsList.size() - 1);\n+            return;\n+        }\n+        final List<TransitPairCount> transits = contigTransitsMap.get(contig);\n+        boolean done = false;\n+        if ( transits != null ) {\n+            for ( final TransitPairCount tpc : transits ) {\n+                if ( tpc.getPrevContig() == predecessor ) {\n+                    final Contig successor = tpc.getNextContig();\n+                    if ( predecessor == contig.rc() ) {\n+                        final int nContigs = contigsList.size();\n+                        if ( nContigs > 1 ) {\n+                            if ( successor.rc() == contigsList.get(nContigs - 2) ) {\n+                                continue;\n+                            }\n+                        }\n+                    }\n+                    tpc.resetCount();\n+                    traverse(successor, contig, contigsList, readPaths, contigTransitsMap, traversalSet);\n+                    done = true;\n+                }\n+            }\n+        }\n+        if ( !done ) {\n+            contigsList.add(contig);\n+            addTraversal(new Traversal(contigsList), traversalSet);\n+            contigsList.remove(contigsList.size() - 1);\n+        }\n+        contigsList.remove(contigsList.size() - 1);\n+    }\n+\n+    private static void traverseCycle( final Contig contig,\n+                                       final List<Contig> contigsList,\n+                                       final List<Path> readPaths,\n+                                       final Map<Contig, List<TransitPairCount>> contigTransitsMap,\n+                                       final Set<Traversal> traversalSet ) {\n+        contigsList.add(contig);\n+        final int nContigs = contigsList.size();\n+        // the final element of the list is cyclic, if there's a previous element it will be\n+        // non-cyclic, so start there figuring out how far the read paths lead us\n+        final List<List<Contig>> longestPaths =\n+                findLongestPaths(contigsList.subList(Math.max(0, nContigs - 2), nContigs), readPaths);\n+        // didn't get anywhere -- just complete the traversal\n+        if ( longestPaths.isEmpty() ) {\n+            addTraversal(new Traversal(contigsList, true), traversalSet);\n+        } else {\n+            // for each unique extension into the cycle\n+            for ( final List<Contig> path : longestPaths ) {\n+                // don't think this can happen, but still\n+                if ( path.isEmpty() ) {\n+                    addTraversal(new Traversal(contigsList, true), traversalSet);\n+                    continue;\n+                }\n+                final List<Contig> extendedContigsList =\n+                        new ArrayList<>(contigsList.size() + path.size());\n+                extendedContigsList.addAll(contigsList);\n+                // if we didn't get out of the cycle\n+                if ( path.get(path.size() - 1).isCyclic() ) {\n+                    extendedContigsList.addAll(path);\n+                    addTraversal(new Traversal(extendedContigsList, true), traversalSet);\n+                } else {\n+                    // we found a cycle-exiting path, so extend that normally\n+                    for ( final Contig curContig : path ) {\n+                        if ( curContig.isCyclic() ) {\n+                            extendedContigsList.add(curContig);\n+                        } else {\n+                            final Contig prevContig =\n+                                    extendedContigsList.remove(extendedContigsList.size() - 1);\n+                            traverse(curContig, prevContig, extendedContigsList, readPaths,\n+                                    contigTransitsMap, traversalSet);\n+                            extendedContigsList.add(prevContig);\n+                            break;\n+                        }\n+                    }\n+                }\n+                clearTransitPairs(contigTransitsMap, extendedContigsList);\n+            }\n+        }\n+        contigsList.remove(contigsList.size() - 1);\n+    }\n+\n+    private static void clearTransitPairs(\n+            final Map<Contig, List<TransitPairCount>> contigTransitsMap,\n+            final List<Contig> contigsList ) {\n+        final int lastIdx = contigsList.size() - 1;\n+        for ( int idx = 1; idx < lastIdx; ++idx ) {\n+            final List<TransitPairCount> pairCounts = contigTransitsMap.get(contigsList.get(idx));\n+            if ( pairCounts != null ) {\n+                final Contig predecessor = contigsList.get(idx - 1);\n+                final Contig successor = contigsList.get(idx + 1);\n+                for ( final TransitPairCount tpc : pairCounts ) {\n+                    if ( tpc.getPrevContig() == predecessor && tpc.getNextContig() == successor ) {\n+                        tpc.resetCount();\n+                        break;\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    private static void addTraversal( final Traversal traversal,\n+                                      final Set<Traversal> traversalSet ) {\n+        if ( !traversalSet.contains(traversal.rc()) ) {\n+            traversalSet.add(traversal);\n+            if ( traversalSet.size() >= TOO_MANY_TRAVERSALS ) {\n+                throw new AssemblyTooComplexException();\n+            }\n+        }\n+    }\n+\n+    private static List<List<Contig>> findLongestPaths( final List<Contig> toMatch,\n+                                                        final List<Path> readPaths ) {\n+        final List<List<Contig>> results = new ArrayList<>();\n+        for ( final Path path : readPaths ) {\n+            testPath(path, toMatch, results);\n+            testPath(path.rc(), toMatch, results);\n+        }\n+        return results;\n+    }\n+\n+    private static void testPath( final Path path,\n+                                  final List<Contig> toMatch,\n+                                  final List<List<Contig>> results ) {\n+        final List<PathPart> pathParts = path.getParts();\n+        final int nPathParts = pathParts.size();\n+        final List<Contig> pathContigs = new ArrayList<>(nPathParts);\n+        pathParts.forEach(pp -> pathContigs.add(pp.getContig()));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e2201c1ef4f8ba71f17e169f07756cfe2f1ecb49"}, "originalPosition": 883}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzc3MDQ0MDUwOnYy", "diffSide": "RIGHT", "path": "src/main/java/org/broadinstitute/hellbender/tools/LocalAssembler.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMy0xOFQxNDo0NjozNVrOI5SXaA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMy0xOFQxNDo0NjozNVrOI5SXaA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5Njk0MDY0OA==", "bodyText": "Could you give this method and its parameters more informative names? Maybe something like addContigPathToContigPathList(final List<Contig> contigPath, final List<List<Contig>> contigPathList)?", "url": "https://github.com/broadinstitute/gatk/pull/6989#discussion_r596940648", "createdAt": "2021-03-18T14:46:35Z", "author": {"login": "cwhelan"}, "path": "src/main/java/org/broadinstitute/hellbender/tools/LocalAssembler.java", "diffHunk": "@@ -0,0 +1,2306 @@\n+package org.broadinstitute.hellbender.tools;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import htsjdk.samtools.Cigar;\n+import htsjdk.samtools.CigarElement;\n+import htsjdk.samtools.CigarOperator;\n+import htsjdk.samtools.SAMUtils;\n+import org.broadinstitute.barclay.argparser.Argument;\n+import org.broadinstitute.barclay.argparser.BetaFeature;\n+import org.broadinstitute.barclay.argparser.CommandLineProgramProperties;\n+import org.broadinstitute.barclay.help.DocumentedFeature;\n+import org.broadinstitute.hellbender.cmdline.StandardArgumentDefinitions;\n+import org.broadinstitute.hellbender.cmdline.programgroups.CoverageAnalysisProgramGroup;\n+import org.broadinstitute.hellbender.exceptions.GATKException;\n+import org.broadinstitute.hellbender.tools.walkers.PairWalker;\n+import org.broadinstitute.hellbender.utils.SimpleInterval;\n+import org.broadinstitute.hellbender.utils.collections.HopscotchSet;\n+import org.broadinstitute.hellbender.utils.gcs.BucketUtils;\n+import org.broadinstitute.hellbender.utils.read.GATKRead;\n+\n+import java.io.BufferedWriter;\n+import java.io.FileWriter;\n+import java.io.IOException;\n+import java.io.OutputStreamWriter;\n+import java.util.*;\n+import java.util.zip.GZIPOutputStream;\n+\n+@DocumentedFeature\n+@CommandLineProgramProperties(\n+        summary = \"experiment\",\n+        oneLineSummary = \"experiment\",\n+        usageExample = \"gatk LocalAssembler\",\n+        programGroup = CoverageAnalysisProgramGroup.class\n+)\n+@BetaFeature\n+public class LocalAssembler extends PairWalker {\n+    public static final byte QMIN = 25;\n+    public static final int MIN_THIN_OBS = 4;\n+    public static final int MIN_GAPFILL_COUNT = 3;\n+    public static final int TOO_MANY_TRAVERSALS = 100000;\n+    public static final int TOO_MANY_SCAFFOLDS = 50000;\n+    public static final int MIN_SV_SIZE = 50;\n+\n+    @Argument(fullName=StandardArgumentDefinitions.OUTPUT_LONG_NAME,\n+            shortName=StandardArgumentDefinitions.OUTPUT_SHORT_NAME,\n+            doc=\"Write outputs to this file name prefix\", optional = true)\n+    public static String output;\n+\n+    @Argument(fullName=\"assembly-name\", doc=\"name of assembly used as a prefix for traversal names\")\n+    public static String assemblyName;\n+\n+    private final List<GATKRead> reads = new ArrayList<>();\n+\n+    @Override public boolean requiresIntervals() { return true; }\n+\n+    @Override public void apply( final GATKRead read, final GATKRead mate ) {\n+        trimOverruns(read, mate);\n+        reads.add(read);\n+        reads.add(mate);\n+    }\n+\n+    @Override public void applyUnpaired( final GATKRead read ) {\n+        reads.add(read);\n+    }\n+\n+    @Override public Object onTraversalSuccess() {\n+        super.onTraversalSuccess(); // flush any incomplete pairs\n+\n+        final int regionSize = getTraversalIntervals().stream().mapToInt(SimpleInterval::size).sum();\n+        final KmerSet<KmerAdjacency> kmerAdjacencySet = new KmerSet<>(10 * regionSize);\n+        kmerizeReads(reads, kmerAdjacencySet);\n+        List<ContigImpl> contigs = buildContigs(kmerAdjacencySet);\n+        connectContigs(contigs);\n+\n+        removeThinContigs(contigs, kmerAdjacencySet);\n+        weldPipes(contigs);\n+        markComponents(contigs);\n+\n+        if ( fillGaps(kmerAdjacencySet, reads) ) {\n+            contigs = buildContigs(kmerAdjacencySet);\n+            connectContigs(contigs);\n+            removeThinContigs(contigs, kmerAdjacencySet);\n+            weldPipes(contigs);\n+            markComponents(contigs);\n+        }\n+\n+        markCycles(contigs);\n+\n+        final String outputFilePrefix = output != null ? output : assemblyName;\n+        final List<Path> readPaths = pathReads(kmerAdjacencySet, reads);\n+        final Map<Contig,List<TransitPairCount>> contigTransitsMap =\n+                collectTransitPairCounts(contigs, readPaths);\n+        final String traversalsFilename = outputFilePrefix + \".traversals.fa.gz\";\n+        try {\n+            final List<Traversal> allTraversals =\n+                    new ArrayList<>(traverseAllPaths(contigs, readPaths, contigTransitsMap));\n+            writeTraversals(allTraversals, traversalsFilename);\n+            try {\n+                final String scaffoldsFileName = outputFilePrefix + \".scaffolds.fa.gz\";\n+                writeTraversals(createScaffolds(allTraversals), scaffoldsFileName);\n+            } catch ( final AssemblyTooComplexException x ) {\n+                logger.warn(\"Assembly too complex for scaffolding.\");\n+            }\n+        } catch ( final AssemblyTooComplexException x ) {\n+            logger.warn(\"Assembly too complex.  Writing contigs as traversals in \" +\n+                    traversalsFilename + \".\");\n+            final Collection<Traversal> contigTraversals = new ArrayList<>(contigs.size());\n+            for ( final Contig contig : contigs ) {\n+                contigTraversals.add(new Traversal(Collections.singletonList(contig)));\n+            }\n+            writeTraversals(contigTraversals, traversalsFilename);\n+        }\n+\n+        contigs.sort(Comparator.comparingInt(ContigImpl::getId));\n+        writeDOT(contigs, outputFilePrefix + \".assembly.dot\");\n+        writeContigs(contigs, outputFilePrefix + \".contigs.txt.gz\");\n+        writePaths(readPaths, outputFilePrefix + \".paths.txt.gz\");\n+        writeReads(reads, outputFilePrefix + \".reads.fastq.gz\");\n+        return null;\n+    }\n+\n+    /** trim read pairs of base calls that have gone past the end of a short fragment */\n+    private void trimOverruns( final GATKRead read, final GATKRead mate ) {\n+        // if both mapped and they're on different strands\n+        if ( !read.isUnmapped() && !mate.isUnmapped() &&\n+                read.isReverseStrand() != mate.isReverseStrand() ) {\n+            // and both start within 1 base on the ref\n+            if ( Math.abs(read.getStart() - read.getMateStart()) <= 1 ) {\n+                // and both end within 1 base\n+                final int readRefLen = read.getCigar().getReferenceLength();\n+                final int mateRefLen = mate.getCigar().getReferenceLength();\n+                if ( Math.abs(readRefLen - mateRefLen) <= 1 ) {\n+                    if ( mate.isReverseStrand() ) {\n+                        trimClips(read, mate);\n+                    } else {\n+                        trimClips(mate, read);\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    private void trimClips( final GATKRead fwd, final GATKRead rev ) {\n+        final List<CigarElement> fwdElements = fwd.getCigarElements();\n+        final List<CigarElement> revElements = rev.getCigarElements();\n+        final int lastElementIdx = fwdElements.size() - 1;\n+        final CigarElement fwdLastElement = fwdElements.get(lastElementIdx);\n+        final CigarElement revFirstElement = revElements.get(0);\n+        if ( fwdLastElement.getOperator() == CigarOperator.S &&\n+                revFirstElement.getOperator() == CigarOperator.S ) {\n+            final byte[] fwdBases = fwd.getBasesNoCopy();\n+            final int lastElementLen = fwdLastElement.getLength();\n+            fwd.setBases(Arrays.copyOfRange(fwdBases, 0, fwdBases.length - lastElementLen));\n+            final byte[] fwdQuals = fwd.getBaseQualitiesNoCopy();\n+            if ( fwdQuals.length > 0 ) {\n+                final int qualsLen = fwdQuals.length - lastElementLen;\n+                fwd.setBaseQualities(Arrays.copyOfRange(fwdQuals, 0, qualsLen));\n+            }\n+            final List<CigarElement> newFwdElements = new ArrayList<>(fwdElements);\n+            newFwdElements.set(lastElementIdx, new CigarElement(lastElementLen, CigarOperator.H));\n+            fwd.setCigar(new Cigar(newFwdElements));\n+\n+            final byte[] revBases = rev.getBasesNoCopy();\n+            final int firstElementLen = revFirstElement.getLength();\n+            rev.setBases(Arrays.copyOfRange(revBases, firstElementLen, revBases.length));\n+            final byte[] revQuals = rev.getBaseQualitiesNoCopy();\n+            if ( revQuals.length > 0 ) {\n+                rev.setBaseQualities(Arrays.copyOfRange(revQuals, firstElementLen, revQuals.length));\n+            }\n+            final List<CigarElement> newRevElements = new ArrayList<>(revElements);\n+            newRevElements.set(0, new CigarElement(firstElementLen, CigarOperator.H));\n+            rev.setCigar(new Cigar(newRevElements));\n+        }\n+    }\n+\n+    @VisibleForTesting\n+    static void kmerizeReads( final List<GATKRead> reads,\n+                              final KmerSet<KmerAdjacency> kmerAdjacencySet ) {\n+        for ( final GATKRead read : reads ) {\n+            final byte[] calls = read.getBasesNoCopy();\n+            final byte[] quals = read.getBaseQualitiesNoCopy();\n+            KmerAdjacency.kmerize(calls, quals, QMIN, kmerAdjacencySet);\n+        }\n+    }\n+\n+    /** gather unbranched strings of kmers into contigs **/\n+    @VisibleForTesting\n+    static List<ContigImpl> buildContigs( final KmerSet<KmerAdjacency> kmerAdjacencySet ) {\n+        // gather strings of kmers that have a single predecessor and single successor into contigs\n+        final List<ContigImpl> contigs = new ArrayList<>();\n+        int nContigs = 0;\n+        for ( final KmerAdjacency kmerAdjacency : kmerAdjacencySet ) {\n+            if ( kmerAdjacency.getContig() == null ) {\n+                ContigImpl contig = null;\n+                final KmerAdjacency predecessor = kmerAdjacency.getSolePredecessor();\n+                if ( predecessor == null ||\n+                        predecessor.getSuccessorCount() > 1 ||\n+                        predecessor == kmerAdjacency.rc() ) {\n+                    contig = new ContigImpl(++nContigs, kmerAdjacency);\n+                } else {\n+                    final KmerAdjacency successor = kmerAdjacency.getSoleSuccessor();\n+                    if ( successor == null ||\n+                            successor.getPredecessorCount() > 1 ||\n+                            successor == kmerAdjacency.rc() ) {\n+                        contig = new ContigImpl(++nContigs, kmerAdjacency.rc());\n+                    }\n+                }\n+                if ( contig != null ) {\n+                    contigs.add(contig);\n+                }\n+            }\n+        }\n+\n+        // if there are smooth circles like a plasmid, gather them together as a contig, too\n+        for ( final KmerAdjacency kmerAdjacency : kmerAdjacencySet ) {\n+            if ( kmerAdjacency.getContig() == null ) {\n+                contigs.add(new ContigImpl(++nContigs, kmerAdjacency));\n+            }\n+        }\n+\n+        return contigs;\n+    }\n+\n+    /** connect contigs when the final kmer of one contig is adjacent to the inital contig of another **/\n+    @VisibleForTesting\n+    static void connectContigs( final List<ContigImpl> contigs ) {\n+        final int nContigs = contigs.size();\n+        final KmerSet<ContigEndKmer> contigEnds = new KmerSet<>(2*nContigs);\n+        for ( int contigId = 0; contigId != nContigs; ++contigId ) {\n+            final ContigImpl contig = contigs.get(contigId);\n+            final KmerAdjacency fwdKmer = contig.getFirstKmer();\n+            final KmerAdjacency revKmer = contig.getLastKmer().rc();\n+            if ( fwdKmer == revKmer ) {\n+                contigEnds.add(new ContigEndKmer(fwdKmer.getKVal(), contig, ContigOrientation.BOTH));\n+            } else {\n+                contigEnds.add(new ContigEndKmer(fwdKmer.getKVal(), contig, ContigOrientation.FWD));\n+                contigEnds.add(new ContigEndKmer(revKmer.getKVal(), contig, ContigOrientation.REV));\n+            }\n+        }\n+\n+        for ( int contigId = 0; contigId != nContigs; ++contigId ) {\n+            final Contig contig = contigs.get(contigId);\n+\n+            final KmerAdjacency start = contig.getFirstKmer();\n+            final int predecessorCount = start.getPredecessorCount();\n+            if ( predecessorCount > 0 ) {\n+                final List<Contig> predecessors = contig.getPredecessors();\n+                final int mask = start.getPredecessorMask();\n+                for ( int call = 0; call != 4; ++call ) {\n+                    if ( (mask & (1 << call)) != 0 ) {\n+                        final long kVal =\n+                                KmerAdjacency.reverseComplement(start.getPredecessorVal(call));\n+                        final ContigEndKmer contigEndKmer = contigEnds.find(new Kmer(kVal));\n+                        if ( contigEndKmer == null ) {\n+                            throw new GATKException(\"missing contig end kmer\");\n+                        }\n+                        switch ( contigEndKmer.getContigOrientation() ) {\n+                            case FWD:\n+                                predecessors.add(contigEndKmer.getContig().rc());\n+                                break;\n+                            case REV:\n+                                predecessors.add(contigEndKmer.getContig());\n+                                break;\n+                            case BOTH:\n+                                predecessors.add(contigEndKmer.getContig());\n+                                predecessors.add(contigEndKmer.getContig().rc());\n+                                break;\n+                        }\n+                    }\n+                }\n+            }\n+\n+            final KmerAdjacency end = contig.getLastKmer();\n+            final int successorCount = end.getSuccessorCount();\n+            if ( successorCount > 0 ) {\n+                final List<Contig> successors = contig.getSuccessors();\n+                final int mask = end.getSuccessorMask();\n+                for ( int call = 0; call != 4; ++call ) {\n+                    if ( (mask & (1 << call)) != 0 ) {\n+                        final long kVal = end.getSuccessorVal(call);\n+                        final ContigEndKmer contigEndKmer = contigEnds.find(new Kmer(kVal));\n+                        if ( contigEndKmer == null ) {\n+                            throw new GATKException(\"missing contig end kmer\");\n+                        }\n+                        switch ( contigEndKmer.getContigOrientation() ) {\n+                            case FWD:\n+                                successors.add(contigEndKmer.getContig());\n+                                break;\n+                            case REV:\n+                                successors.add(contigEndKmer.getContig().rc());\n+                                break;\n+                            case BOTH:\n+                                successors.add(contigEndKmer.getContig());\n+                                successors.add(contigEndKmer.getContig().rc());\n+                                break;\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    /** remove contigs that have little evidence **/\n+    @VisibleForTesting\n+    static void removeThinContigs( final List<ContigImpl> contigs,\n+                                           final KmerSet<KmerAdjacency> kmerAdjacencySet ) {\n+        contigs.sort(Comparator.comparingInt(ContigImpl::getMaxObservations));\n+        boolean contigRemoved;\n+        do {\n+            // figure out which contigs are cut points\n+            // i.e., those contigs which, if removed, would result in a graph with more connected components\n+            final int nContigs = contigs.size();\n+            final Map<Contig, CutData> cutDataMap = new HashMap<>(nContigs * 3);\n+\n+            for ( final ContigImpl contig : contigs ) {\n+                if ( cutDataMap.containsKey(contig) ) {\n+                    continue;\n+                }\n+\n+                cutDataMap.put(contig, new CutData());\n+                int children = 0;\n+                for ( final Contig nextContig : contig.getSuccessors() ) {\n+                    if ( !cutDataMap.containsKey(nextContig) ) {\n+                        findCuts(nextContig, contig, cutDataMap);\n+                        children += 1;\n+                    }\n+                }\n+                for ( final Contig nextContig : contig.getPredecessors() ) {\n+                    if ( !cutDataMap.containsKey(nextContig) ) {\n+                        findCuts(nextContig, contig, cutDataMap);\n+                        children += 1;\n+                    }\n+                }\n+                if ( children >= 2 ) {\n+                    contig.setCut(true);\n+                }\n+            }\n+\n+            // remove poorly attested (low max observations) contigs, unless they are cut points\n+            contigRemoved = false;\n+            final Iterator<ContigImpl> itr = contigs.iterator();\n+            while ( itr.hasNext() ) {\n+                final Contig contig = itr.next();\n+                if ( contig.getMaxObservations() < MIN_THIN_OBS && !contig.isCut() ) {\n+                    unlinkContig(contig, kmerAdjacencySet);\n+                    itr.remove();\n+                    contigRemoved = true;\n+                    break;\n+                }\n+            }\n+        } while ( contigRemoved );\n+        contigs.sort(Comparator.comparingInt(ContigImpl::getId));\n+    }\n+\n+    private static CutData findCuts( final Contig contig,\n+                                     final Contig parent,\n+                                     final Map<Contig, CutData> cutDataMap ) {\n+        final CutData cutData = new CutData();\n+        cutDataMap.put(contig, cutData);\n+        for ( final Contig nextContig : contig.getSuccessors() ) {\n+            if ( nextContig == parent ) {\n+                continue;\n+            }\n+            CutData nextCutData = cutDataMap.get(nextContig);\n+            if ( nextCutData != null ) {\n+                cutData.minVisitNum = Math.min(cutData.minVisitNum, nextCutData.visitNum);\n+            } else {\n+                nextCutData = findCuts(nextContig, contig, cutDataMap);\n+                cutData.minVisitNum = Math.min(cutData.minVisitNum, nextCutData.minVisitNum);\n+                if ( nextCutData.minVisitNum >= cutData.visitNum ) {\n+                    contig.setCut(true);\n+                }\n+            }\n+        }\n+        for ( final Contig nextContig : contig.getPredecessors() ) {\n+            if ( nextContig == parent ) {\n+                continue;\n+            }\n+            CutData nextCutData = cutDataMap.get(nextContig);\n+            if ( nextCutData != null ) {\n+                cutData.minVisitNum = Math.min(cutData.minVisitNum, nextCutData.visitNum);\n+            } else {\n+                nextCutData = findCuts(nextContig, contig, cutDataMap);\n+                cutData.minVisitNum = Math.min(cutData.minVisitNum, nextCutData.minVisitNum);\n+                if ( nextCutData.minVisitNum >= cutData.visitNum ) {\n+                    contig.setCut(true);\n+                }\n+            }\n+        }\n+        return cutData;\n+    }\n+\n+    @VisibleForTesting\n+    static void unlinkContig( final Contig contig,\n+                                      final KmerSet<KmerAdjacency> kmerAdjacencySet ) {\n+        final KmerAdjacency firstKmer = contig.getFirstKmer();\n+        final int firstKmerFinalCall = firstKmer.getFinalCall();\n+        for ( final Contig predecessor : contig.getPredecessors() ) {\n+            if ( predecessor != contig && predecessor != contig.rc() ) {\n+                predecessor.getLastKmer().removeSuccessor(firstKmerFinalCall, kmerAdjacencySet);\n+                if ( !predecessor.getSuccessors().remove(contig) ) {\n+                    throw new GATKException(\"failed to find predecessor link\");\n+                }\n+            }\n+        }\n+\n+        final KmerAdjacency lastKmer = contig.getLastKmer();\n+        final int lastKmerInitialCall = lastKmer.getInitialCall();\n+        for ( final Contig successor : contig.getSuccessors() ) {\n+            if ( successor != contig && successor != contig.rc() ) {\n+                successor.getFirstKmer().removePredecessor(lastKmerInitialCall, kmerAdjacencySet);\n+                if ( !successor.getPredecessors().remove(contig) ) {\n+                    throw new GATKException(\"failed to find successor link\");\n+                }\n+            }\n+        }\n+\n+        KmerAdjacency nextKmer = firstKmer;\n+        KmerAdjacency kmer;\n+        do {\n+            kmer = nextKmer;\n+            nextKmer = kmer.getSoleSuccessor();\n+            kmerAdjacencySet.remove(kmer.canonical());\n+        } while ( kmer != lastKmer );\n+    }\n+\n+    private static void updateKmerContig( final KmerAdjacency firstKmer,\n+                                          final KmerAdjacency lastKmer,\n+                                          final Contig contig ) {\n+        int offset = 0;\n+        for ( KmerAdjacency kmer = firstKmer; kmer != lastKmer; kmer = kmer.getSoleSuccessor() ) {\n+            if ( kmer == null ) {\n+                throw new GATKException(\"contig does not have a flat pipeline of kmers\");\n+            }\n+            kmer.clearContig();\n+            kmer.setContigOffset(contig, offset++);\n+        }\n+        lastKmer.clearContig();\n+        lastKmer.setContigOffset(contig, offset);\n+        if ( offset + Kmer.KSIZE != contig.size() ) {\n+            throw new GATKException(\"kmer chain length does not equal contig size\");\n+        }\n+    }\n+\n+    /** replace adjacent contigs without branches with a single, larger contig **/\n+    @VisibleForTesting\n+    static void weldPipes( final List<ContigImpl> contigs ) {\n+        for ( int contigIdx = 0; contigIdx != contigs.size(); ++contigIdx ) {\n+            final ContigImpl contig = contigs.get(contigIdx);\n+            if ( contig.getSuccessors().size() == 1 ) {\n+                final Contig successor = contig.getSuccessors().get(0);\n+                if ( successor != contig && successor != contig.rc() &&\n+                        successor.getPredecessors().size() == 1 ) {\n+                    contigs.set(contigIdx, join(contig.getId(), contig, successor));\n+                    if ( !contigs.remove(successor.canonical()) ) {\n+                        throw new GATKException(\"successor linkage is messed up\");\n+                    }\n+                    contigIdx -= 1; // reconsider the new contig -- there might be more joining possible\n+                    continue;\n+                }\n+            }\n+            if ( contig.getPredecessors().size() == 1 ) {\n+                final Contig predecessor = contig.getPredecessors().get(0);\n+                if ( predecessor != contig && predecessor != contig.rc() &&\n+                        predecessor.getSuccessors().size() == 1 ) {\n+                    contigs.set(contigIdx, join(contig.getId(), predecessor, contig));\n+                    if ( !contigs.remove(predecessor.canonical()) ) {\n+                        throw new GATKException(\"predecessor linkage is messed up\");\n+                    }\n+                    contigIdx -= 1; // reconsider\n+                }\n+            }\n+        }\n+    }\n+\n+    private static ContigImpl join( final int id, final Contig predecessor, final Contig successor ) {\n+        if ( !checkOverlap(predecessor.getSequence(), successor.getSequence()) ) {\n+                throw new GATKException(\"sequences can't be joined\");\n+        }\n+        final ContigImpl joinedContig = new ContigImpl(id, predecessor, successor);\n+        updateKmerContig(joinedContig.getFirstKmer(), joinedContig.getLastKmer(), joinedContig);\n+        return joinedContig;\n+    }\n+\n+    private static boolean checkOverlap( final CharSequence seq1, final CharSequence seq2 ) {\n+        final int seq1Len = seq1.length();\n+        final CharSequence seq1SubSeq = seq1.subSequence(seq1Len - Kmer.KSIZE + 1, seq1Len);\n+        final CharSequence seq2SubSeq = seq2.subSequence(0, Kmer.KSIZE - 1);\n+        return seq1SubSeq.equals(seq2SubSeq);\n+    }\n+\n+    /** set a unique componentId for every connected group of contigs **/\n+    @VisibleForTesting\n+    static int markComponents( final List<ContigImpl> contigs ) {\n+        for ( final ContigImpl contig : contigs ) {\n+            contig.setComponentId(0);\n+        }\n+\n+        int componentId = 0;\n+        for ( final ContigImpl contig : contigs ) {\n+            if ( contig.getComponentId() == 0 ) {\n+                contig.setComponentId(++componentId);\n+                markSuccessorComponents(contig);\n+                markSuccessorComponents(contig.rc());\n+            }\n+        }\n+        return componentId;\n+    }\n+\n+    private static void markSuccessorComponents( final Contig contig ) {\n+        final int componentId = contig.getComponentId();\n+        for ( final Contig successor : contig.getSuccessors() ) {\n+            if ( successor.getComponentId() == 0 ) {\n+                successor.canonical().setComponentId(componentId);\n+                markSuccessorComponents(successor);\n+                markSuccessorComponents(successor.rc());\n+            }\n+        }\n+    }\n+\n+    @VisibleForTesting\n+    static void markCycles( final List<ContigImpl> contigs ) {\n+        for ( final Contig contig : contigs ) {\n+            contig.setCyclic(false);\n+        }\n+\n+        final int nContigs = contigs.size();\n+        final Deque<Contig> deque = new ArrayDeque<>(nContigs);\n+        final Map<Contig, CutData> cutDataMap = new HashMap<>(nContigs * 3);\n+        for ( final Contig contig : contigs ) {\n+            if ( !cutDataMap.containsKey(contig) ) {\n+                markCyclesRecursion(contig, deque, cutDataMap);\n+            }\n+        }\n+    }\n+\n+    private static CutData markCyclesRecursion( final Contig contig,\n+                                                final Deque<Contig> deque,\n+                                                final Map<Contig, CutData> cutDataMap ) {\n+        final CutData cutData = new CutData();\n+        cutDataMap.put(contig, cutData);\n+        deque.addFirst(contig);\n+\n+        for ( final Contig successor : contig.getSuccessors() ) {\n+            final CutData successorCutData = cutDataMap.get(successor);\n+            if ( successorCutData == null ) {\n+                final int recursionVisitNum =\n+                        markCyclesRecursion(successor, deque, cutDataMap).minVisitNum;\n+                cutData.minVisitNum = Math.min(cutData.minVisitNum, recursionVisitNum);\n+            } else {\n+                cutData.minVisitNum = Math.min(cutData.minVisitNum, successorCutData.visitNum);\n+            }\n+        }\n+\n+        if ( cutData.visitNum == cutData.minVisitNum ) {\n+            Contig tig = deque.removeFirst();\n+            if ( tig == contig ) {\n+                cutDataMap.get(tig).visitNum = Integer.MAX_VALUE;\n+\n+                // single-vertex component -- cyclic only if self-referential\n+                if ( tig.getSuccessors().contains(tig) ) {\n+                    tig.setCyclic(true);\n+                }\n+            } else {\n+                while ( true ) {\n+                    // kill cross-links\n+                    cutDataMap.get(tig).visitNum = Integer.MAX_VALUE;\n+                    tig.setCyclic(true);\n+                    if ( tig == contig ) break;\n+                    tig = deque.removeFirst();\n+                }\n+            }\n+        }\n+        return cutData;\n+    }\n+\n+    @VisibleForTesting\n+    static boolean fillGaps( final KmerSet<KmerAdjacency> kmerAdjacencySet,\n+                             final List<GATKRead> reads ) {\n+        final Map<String, Integer> gapFillCounts = new HashMap<>();\n+        for ( final GATKRead read : reads ) {\n+            final Path path = new Path(read.getBasesNoCopy(), kmerAdjacencySet);\n+            final List<PathPart> parts = path.getParts();\n+            final int lastIdx = parts.size() - 1;\n+            for ( int idx = 1; idx < lastIdx; ++idx ) {\n+                final PathPart pathPart = parts.get(idx);\n+                if ( pathPart.isGap() ) {\n+                    final char prevCall = parts.get(idx - 1).getLastCall();\n+                    final char nextCall = parts.get(idx + 1).getFirstCall();\n+                    String gapFill = prevCall + pathPart.getSequence().toString() + nextCall;\n+                    final SequenceRC gapFillRC = new SequenceRC(gapFill);\n+                    if ( gapFillRC.compareTo(gapFill) < 0 ) {\n+                        gapFill = gapFillRC.toString();\n+                    }\n+                    gapFillCounts.merge(gapFill, 1, Integer::sum);\n+                }\n+            }\n+        }\n+\n+        boolean newKmers = false;\n+        for ( final Map.Entry<String, Integer> entry : gapFillCounts.entrySet() ) {\n+            final int nObservations = entry.getValue();\n+            if ( nObservations >= MIN_GAPFILL_COUNT ) {\n+                KmerAdjacency.kmerize(entry.getKey(), nObservations, kmerAdjacencySet);\n+                newKmers = true;\n+            }\n+        }\n+\n+        if ( newKmers ) {\n+            for ( final KmerAdjacency kmerAdjacency : kmerAdjacencySet ) {\n+                kmerAdjacency.clearContig();\n+            }\n+        }\n+        return newKmers;\n+    }\n+\n+    @VisibleForTesting\n+    static List<Path> pathReads( final KmerSet<KmerAdjacency> kmerAdjacencySet,\n+                          final List<GATKRead> reads ) {\n+        final List<Path> readPaths = new ArrayList<>(reads.size());\n+        for ( final GATKRead read : reads ) {\n+            readPaths.add(new Path(read.getBasesNoCopy(), kmerAdjacencySet));\n+        }\n+        return readPaths;\n+    }\n+\n+    @VisibleForTesting\n+    static Map<Contig,List<TransitPairCount>> collectTransitPairCounts(\n+            final List<ContigImpl> contigs,\n+            final List<Path> readPaths ) {\n+        final Map<Contig,List<TransitPairCount>> contigTransitsMap =\n+                new HashMap<>(3 * contigs.size());\n+        for ( final Path path : readPaths ) {\n+            final List<PathPart> parts = path.getParts();\n+            final int lastPart = parts.size() - 1;\n+            for ( int partIdx = 1; partIdx < lastPart; ++partIdx ) {\n+                final Contig prevContig = parts.get(partIdx - 1).getContig();\n+                if ( prevContig == null ) continue;\n+                final Contig curContig = parts.get(partIdx).getContig();\n+                if ( curContig == null ) {\n+                    partIdx += 1;\n+                    continue;\n+                }\n+                final Contig nextContig = parts.get(partIdx + 1).getContig();\n+                if ( nextContig == null ) {\n+                    partIdx += 2;\n+                    continue;\n+                }\n+                final TransitPairCount tpc = new TransitPairCount(prevContig, nextContig);\n+                final List<TransitPairCount> tpcList =\n+                        contigTransitsMap.computeIfAbsent(curContig, tig -> new ArrayList<>(4));\n+                final int idx = tpcList.indexOf(tpc);\n+                if ( idx != -1 ) {\n+                    tpcList.get(idx).observe();\n+                } else {\n+                    tpcList.add(tpc);\n+                    contigTransitsMap.computeIfAbsent(curContig.rc(), tig -> new ArrayList<>(4))\n+                            .add(tpc.getRC());\n+                }\n+            }\n+        }\n+        return contigTransitsMap;\n+    }\n+\n+    @VisibleForTesting\n+    static Set<Traversal> traverseAllPaths(\n+            final List<ContigImpl> contigs,\n+            final List<Path> readPaths,\n+            final Map<Contig, List<TransitPairCount>> contigTransitsMap ) {\n+        final Set<Traversal> traversalSet = new HashSet<>();\n+        final List<Contig> contigsList = new ArrayList<>();\n+        for ( final Contig contig : contigs ) {\n+            // untransited contigs are sources, sinks, or large contigs that can't be crossed by a read\n+            // build traversals from these\n+            if ( !contigTransitsMap.containsKey(contig) ) {\n+                boolean done = false;\n+                for ( final Contig successor : contig.getSuccessors() ) {\n+                    traverse(successor, contig,\n+                            contigsList, readPaths, contigTransitsMap, traversalSet);\n+                    done = true;\n+                }\n+                for ( final Contig predecessor : contig.getPredecessors() ) {\n+                    traverse(predecessor.rc(), contig.rc(),\n+                            contigsList, readPaths, contigTransitsMap, traversalSet);\n+                    done = true;\n+                }\n+                if ( !done ) { // if there were no predecessors or successors, it stands alone\n+                    addTraversal(new Traversal(Collections.singletonList(contig)), traversalSet);\n+                }\n+            }\n+        }\n+\n+        // look for transits that haven't been traced\n+        for ( final Map.Entry<Contig, List<TransitPairCount>> entry :\n+                contigTransitsMap.entrySet() ) {\n+            for ( final TransitPairCount tpc : entry.getValue() ) {\n+                if ( tpc.getCount() > 0 ) {\n+                    tpc.resetCount();\n+                    final Contig contig = entry.getKey();\n+                    final Set<Traversal> fwdTraversalSet = new HashSet<>();\n+                    traverse(tpc.getNextContig(), contig,\n+                            contigsList, readPaths, contigTransitsMap, fwdTraversalSet);\n+                    final Set<Traversal> revTraversalSet = new HashSet<>();\n+                    traverse(tpc.getPrevContig().rc(), contig.rc(),\n+                            contigsList, readPaths, contigTransitsMap, revTraversalSet);\n+                    for ( final Traversal revTraversal : revTraversalSet ) {\n+                        final Traversal revTraversalRC = revTraversal.rc();\n+                        for ( final Traversal fwdTraversal : fwdTraversalSet ) {\n+                            final int overlap =\n+                                    findMaxOverlap(revTraversalRC.getContigs(), fwdTraversal.getContigs());\n+                            final Traversal combo =\n+                                    Traversal.combineOverlappers(revTraversalRC, fwdTraversal, overlap);\n+                            addTraversal(combo, traversalSet);\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+\n+        return traversalSet;\n+    }\n+\n+    private static int findMaxOverlap( final List<Contig> prefixes, final List<Contig> suffixes ) {\n+        final int nPrefixes = prefixes.size();\n+        final Contig firstSuffix = suffixes.get(0);\n+        if ( !firstSuffix.isCyclic() ) {\n+            return prefixes.get(nPrefixes - 1) == firstSuffix ? 1 : 0;\n+        }\n+        final int nSuffixes = suffixes.size();\n+        for ( int prefixIdx = Math.max(0, nPrefixes - nSuffixes); prefixIdx != nPrefixes; ++prefixIdx ) {\n+            if ( prefixes.get(prefixIdx) == firstSuffix ) {\n+                int suffixIdx = 1;\n+                boolean match = true;\n+                for ( int prefixIdx2 = prefixIdx + 1; prefixIdx2 != nPrefixes; ++prefixIdx2 ) {\n+                    if ( prefixes.get(prefixIdx2) != suffixes.get(suffixIdx++) ) {\n+                        match = false;\n+                        break;\n+                    }\n+                }\n+                if ( match ) {\n+                    return nPrefixes - prefixIdx;\n+                }\n+            }\n+        }\n+        return 0;\n+    }\n+\n+    private static void traverse( final Contig contig,\n+                                  final Contig predecessor,\n+                                  final List<Contig> contigsList,\n+                                  final List<Path> readPaths,\n+                                  final Map<Contig, List<TransitPairCount>> contigTransitsMap,\n+                                  final Set<Traversal> traversalSet ) {\n+        contigsList.add(predecessor);\n+        if ( contig.isCyclic() ) {\n+            traverseCycle(contig, contigsList, readPaths, contigTransitsMap, traversalSet);\n+            contigsList.remove(contigsList.size() - 1);\n+            return;\n+        }\n+        final List<TransitPairCount> transits = contigTransitsMap.get(contig);\n+        boolean done = false;\n+        if ( transits != null ) {\n+            for ( final TransitPairCount tpc : transits ) {\n+                if ( tpc.getPrevContig() == predecessor ) {\n+                    final Contig successor = tpc.getNextContig();\n+                    if ( predecessor == contig.rc() ) {\n+                        final int nContigs = contigsList.size();\n+                        if ( nContigs > 1 ) {\n+                            if ( successor.rc() == contigsList.get(nContigs - 2) ) {\n+                                continue;\n+                            }\n+                        }\n+                    }\n+                    tpc.resetCount();\n+                    traverse(successor, contig, contigsList, readPaths, contigTransitsMap, traversalSet);\n+                    done = true;\n+                }\n+            }\n+        }\n+        if ( !done ) {\n+            contigsList.add(contig);\n+            addTraversal(new Traversal(contigsList), traversalSet);\n+            contigsList.remove(contigsList.size() - 1);\n+        }\n+        contigsList.remove(contigsList.size() - 1);\n+    }\n+\n+    private static void traverseCycle( final Contig contig,\n+                                       final List<Contig> contigsList,\n+                                       final List<Path> readPaths,\n+                                       final Map<Contig, List<TransitPairCount>> contigTransitsMap,\n+                                       final Set<Traversal> traversalSet ) {\n+        contigsList.add(contig);\n+        final int nContigs = contigsList.size();\n+        // the final element of the list is cyclic, if there's a previous element it will be\n+        // non-cyclic, so start there figuring out how far the read paths lead us\n+        final List<List<Contig>> longestPaths =\n+                findLongestPaths(contigsList.subList(Math.max(0, nContigs - 2), nContigs), readPaths);\n+        // didn't get anywhere -- just complete the traversal\n+        if ( longestPaths.isEmpty() ) {\n+            addTraversal(new Traversal(contigsList, true), traversalSet);\n+        } else {\n+            // for each unique extension into the cycle\n+            for ( final List<Contig> path : longestPaths ) {\n+                // don't think this can happen, but still\n+                if ( path.isEmpty() ) {\n+                    addTraversal(new Traversal(contigsList, true), traversalSet);\n+                    continue;\n+                }\n+                final List<Contig> extendedContigsList =\n+                        new ArrayList<>(contigsList.size() + path.size());\n+                extendedContigsList.addAll(contigsList);\n+                // if we didn't get out of the cycle\n+                if ( path.get(path.size() - 1).isCyclic() ) {\n+                    extendedContigsList.addAll(path);\n+                    addTraversal(new Traversal(extendedContigsList, true), traversalSet);\n+                } else {\n+                    // we found a cycle-exiting path, so extend that normally\n+                    for ( final Contig curContig : path ) {\n+                        if ( curContig.isCyclic() ) {\n+                            extendedContigsList.add(curContig);\n+                        } else {\n+                            final Contig prevContig =\n+                                    extendedContigsList.remove(extendedContigsList.size() - 1);\n+                            traverse(curContig, prevContig, extendedContigsList, readPaths,\n+                                    contigTransitsMap, traversalSet);\n+                            extendedContigsList.add(prevContig);\n+                            break;\n+                        }\n+                    }\n+                }\n+                clearTransitPairs(contigTransitsMap, extendedContigsList);\n+            }\n+        }\n+        contigsList.remove(contigsList.size() - 1);\n+    }\n+\n+    private static void clearTransitPairs(\n+            final Map<Contig, List<TransitPairCount>> contigTransitsMap,\n+            final List<Contig> contigsList ) {\n+        final int lastIdx = contigsList.size() - 1;\n+        for ( int idx = 1; idx < lastIdx; ++idx ) {\n+            final List<TransitPairCount> pairCounts = contigTransitsMap.get(contigsList.get(idx));\n+            if ( pairCounts != null ) {\n+                final Contig predecessor = contigsList.get(idx - 1);\n+                final Contig successor = contigsList.get(idx + 1);\n+                for ( final TransitPairCount tpc : pairCounts ) {\n+                    if ( tpc.getPrevContig() == predecessor && tpc.getNextContig() == successor ) {\n+                        tpc.resetCount();\n+                        break;\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    private static void addTraversal( final Traversal traversal,\n+                                      final Set<Traversal> traversalSet ) {\n+        if ( !traversalSet.contains(traversal.rc()) ) {\n+            traversalSet.add(traversal);\n+            if ( traversalSet.size() >= TOO_MANY_TRAVERSALS ) {\n+                throw new AssemblyTooComplexException();\n+            }\n+        }\n+    }\n+\n+    private static List<List<Contig>> findLongestPaths( final List<Contig> toMatch,\n+                                                        final List<Path> readPaths ) {\n+        final List<List<Contig>> results = new ArrayList<>();\n+        for ( final Path path : readPaths ) {\n+            testPath(path, toMatch, results);\n+            testPath(path.rc(), toMatch, results);\n+        }\n+        return results;\n+    }\n+\n+    private static void testPath( final Path path,\n+                                  final List<Contig> toMatch,\n+                                  final List<List<Contig>> results ) {\n+        final List<PathPart> pathParts = path.getParts();\n+        final int nPathParts = pathParts.size();\n+        final List<Contig> pathContigs = new ArrayList<>(nPathParts);\n+        pathParts.forEach(pp -> pathContigs.add(pp.getContig()));\n+        final int matchIdx = Collections.indexOfSubList(pathContigs, toMatch);\n+        if ( matchIdx != -1 ) {\n+            final int suffixIdx = matchIdx + toMatch.size();\n+            if ( suffixIdx < nPathParts ) {\n+                resolveResult(grabParts(pathContigs, suffixIdx), results);\n+            }\n+        }\n+    }\n+\n+    private static List<Contig> grabParts( final List<Contig> pathContigs, final int suffixIdx ) {\n+        final int nPathContigs = pathContigs.size();\n+        Contig prev = pathContigs.get(suffixIdx - 1);\n+        final List<Contig> result = new ArrayList<>(nPathContigs - suffixIdx);\n+        for ( int idx = suffixIdx; idx != nPathContigs; ++idx ) {\n+            final Contig tig = pathContigs.get(idx);\n+            if ( tig == null || !prev.getSuccessors().contains(tig) ) break;\n+            result.add(tig);\n+            prev = tig;\n+        }\n+        return result;\n+    }\n+\n+    private static void resolveResult( final List<Contig> result,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e2201c1ef4f8ba71f17e169f07756cfe2f1ecb49"}, "originalPosition": 906}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzc3MDUzNTk4OnYy", "diffSide": "RIGHT", "path": "src/main/java/org/broadinstitute/hellbender/tools/LocalAssembler.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMy0xOFQxNTowMjo0M1rOI5TSKQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMy0xOFQxNTowMjo0M1rOI5TSKQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5Njk1NTY4OQ==", "bodyText": "Based on my understanding, which could be wrong, this is set when a contig is part of a cycle -- it's not the contig itself which is inherently cyclic. I'd suggest renaming this to something that indicates that, like isPartOfCycle. Does that make sense?", "url": "https://github.com/broadinstitute/gatk/pull/6989#discussion_r596955689", "createdAt": "2021-03-18T15:02:43Z", "author": {"login": "cwhelan"}, "path": "src/main/java/org/broadinstitute/hellbender/tools/LocalAssembler.java", "diffHunk": "@@ -0,0 +1,2306 @@\n+package org.broadinstitute.hellbender.tools;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import htsjdk.samtools.Cigar;\n+import htsjdk.samtools.CigarElement;\n+import htsjdk.samtools.CigarOperator;\n+import htsjdk.samtools.SAMUtils;\n+import org.broadinstitute.barclay.argparser.Argument;\n+import org.broadinstitute.barclay.argparser.BetaFeature;\n+import org.broadinstitute.barclay.argparser.CommandLineProgramProperties;\n+import org.broadinstitute.barclay.help.DocumentedFeature;\n+import org.broadinstitute.hellbender.cmdline.StandardArgumentDefinitions;\n+import org.broadinstitute.hellbender.cmdline.programgroups.CoverageAnalysisProgramGroup;\n+import org.broadinstitute.hellbender.exceptions.GATKException;\n+import org.broadinstitute.hellbender.tools.walkers.PairWalker;\n+import org.broadinstitute.hellbender.utils.SimpleInterval;\n+import org.broadinstitute.hellbender.utils.collections.HopscotchSet;\n+import org.broadinstitute.hellbender.utils.gcs.BucketUtils;\n+import org.broadinstitute.hellbender.utils.read.GATKRead;\n+\n+import java.io.BufferedWriter;\n+import java.io.FileWriter;\n+import java.io.IOException;\n+import java.io.OutputStreamWriter;\n+import java.util.*;\n+import java.util.zip.GZIPOutputStream;\n+\n+@DocumentedFeature\n+@CommandLineProgramProperties(\n+        summary = \"experiment\",\n+        oneLineSummary = \"experiment\",\n+        usageExample = \"gatk LocalAssembler\",\n+        programGroup = CoverageAnalysisProgramGroup.class\n+)\n+@BetaFeature\n+public class LocalAssembler extends PairWalker {\n+    public static final byte QMIN = 25;\n+    public static final int MIN_THIN_OBS = 4;\n+    public static final int MIN_GAPFILL_COUNT = 3;\n+    public static final int TOO_MANY_TRAVERSALS = 100000;\n+    public static final int TOO_MANY_SCAFFOLDS = 50000;\n+    public static final int MIN_SV_SIZE = 50;\n+\n+    @Argument(fullName=StandardArgumentDefinitions.OUTPUT_LONG_NAME,\n+            shortName=StandardArgumentDefinitions.OUTPUT_SHORT_NAME,\n+            doc=\"Write outputs to this file name prefix\", optional = true)\n+    public static String output;\n+\n+    @Argument(fullName=\"assembly-name\", doc=\"name of assembly used as a prefix for traversal names\")\n+    public static String assemblyName;\n+\n+    private final List<GATKRead> reads = new ArrayList<>();\n+\n+    @Override public boolean requiresIntervals() { return true; }\n+\n+    @Override public void apply( final GATKRead read, final GATKRead mate ) {\n+        trimOverruns(read, mate);\n+        reads.add(read);\n+        reads.add(mate);\n+    }\n+\n+    @Override public void applyUnpaired( final GATKRead read ) {\n+        reads.add(read);\n+    }\n+\n+    @Override public Object onTraversalSuccess() {\n+        super.onTraversalSuccess(); // flush any incomplete pairs\n+\n+        final int regionSize = getTraversalIntervals().stream().mapToInt(SimpleInterval::size).sum();\n+        final KmerSet<KmerAdjacency> kmerAdjacencySet = new KmerSet<>(10 * regionSize);\n+        kmerizeReads(reads, kmerAdjacencySet);\n+        List<ContigImpl> contigs = buildContigs(kmerAdjacencySet);\n+        connectContigs(contigs);\n+\n+        removeThinContigs(contigs, kmerAdjacencySet);\n+        weldPipes(contigs);\n+        markComponents(contigs);\n+\n+        if ( fillGaps(kmerAdjacencySet, reads) ) {\n+            contigs = buildContigs(kmerAdjacencySet);\n+            connectContigs(contigs);\n+            removeThinContigs(contigs, kmerAdjacencySet);\n+            weldPipes(contigs);\n+            markComponents(contigs);\n+        }\n+\n+        markCycles(contigs);\n+\n+        final String outputFilePrefix = output != null ? output : assemblyName;\n+        final List<Path> readPaths = pathReads(kmerAdjacencySet, reads);\n+        final Map<Contig,List<TransitPairCount>> contigTransitsMap =\n+                collectTransitPairCounts(contigs, readPaths);\n+        final String traversalsFilename = outputFilePrefix + \".traversals.fa.gz\";\n+        try {\n+            final List<Traversal> allTraversals =\n+                    new ArrayList<>(traverseAllPaths(contigs, readPaths, contigTransitsMap));\n+            writeTraversals(allTraversals, traversalsFilename);\n+            try {\n+                final String scaffoldsFileName = outputFilePrefix + \".scaffolds.fa.gz\";\n+                writeTraversals(createScaffolds(allTraversals), scaffoldsFileName);\n+            } catch ( final AssemblyTooComplexException x ) {\n+                logger.warn(\"Assembly too complex for scaffolding.\");\n+            }\n+        } catch ( final AssemblyTooComplexException x ) {\n+            logger.warn(\"Assembly too complex.  Writing contigs as traversals in \" +\n+                    traversalsFilename + \".\");\n+            final Collection<Traversal> contigTraversals = new ArrayList<>(contigs.size());\n+            for ( final Contig contig : contigs ) {\n+                contigTraversals.add(new Traversal(Collections.singletonList(contig)));\n+            }\n+            writeTraversals(contigTraversals, traversalsFilename);\n+        }\n+\n+        contigs.sort(Comparator.comparingInt(ContigImpl::getId));\n+        writeDOT(contigs, outputFilePrefix + \".assembly.dot\");\n+        writeContigs(contigs, outputFilePrefix + \".contigs.txt.gz\");\n+        writePaths(readPaths, outputFilePrefix + \".paths.txt.gz\");\n+        writeReads(reads, outputFilePrefix + \".reads.fastq.gz\");\n+        return null;\n+    }\n+\n+    /** trim read pairs of base calls that have gone past the end of a short fragment */\n+    private void trimOverruns( final GATKRead read, final GATKRead mate ) {\n+        // if both mapped and they're on different strands\n+        if ( !read.isUnmapped() && !mate.isUnmapped() &&\n+                read.isReverseStrand() != mate.isReverseStrand() ) {\n+            // and both start within 1 base on the ref\n+            if ( Math.abs(read.getStart() - read.getMateStart()) <= 1 ) {\n+                // and both end within 1 base\n+                final int readRefLen = read.getCigar().getReferenceLength();\n+                final int mateRefLen = mate.getCigar().getReferenceLength();\n+                if ( Math.abs(readRefLen - mateRefLen) <= 1 ) {\n+                    if ( mate.isReverseStrand() ) {\n+                        trimClips(read, mate);\n+                    } else {\n+                        trimClips(mate, read);\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    private void trimClips( final GATKRead fwd, final GATKRead rev ) {\n+        final List<CigarElement> fwdElements = fwd.getCigarElements();\n+        final List<CigarElement> revElements = rev.getCigarElements();\n+        final int lastElementIdx = fwdElements.size() - 1;\n+        final CigarElement fwdLastElement = fwdElements.get(lastElementIdx);\n+        final CigarElement revFirstElement = revElements.get(0);\n+        if ( fwdLastElement.getOperator() == CigarOperator.S &&\n+                revFirstElement.getOperator() == CigarOperator.S ) {\n+            final byte[] fwdBases = fwd.getBasesNoCopy();\n+            final int lastElementLen = fwdLastElement.getLength();\n+            fwd.setBases(Arrays.copyOfRange(fwdBases, 0, fwdBases.length - lastElementLen));\n+            final byte[] fwdQuals = fwd.getBaseQualitiesNoCopy();\n+            if ( fwdQuals.length > 0 ) {\n+                final int qualsLen = fwdQuals.length - lastElementLen;\n+                fwd.setBaseQualities(Arrays.copyOfRange(fwdQuals, 0, qualsLen));\n+            }\n+            final List<CigarElement> newFwdElements = new ArrayList<>(fwdElements);\n+            newFwdElements.set(lastElementIdx, new CigarElement(lastElementLen, CigarOperator.H));\n+            fwd.setCigar(new Cigar(newFwdElements));\n+\n+            final byte[] revBases = rev.getBasesNoCopy();\n+            final int firstElementLen = revFirstElement.getLength();\n+            rev.setBases(Arrays.copyOfRange(revBases, firstElementLen, revBases.length));\n+            final byte[] revQuals = rev.getBaseQualitiesNoCopy();\n+            if ( revQuals.length > 0 ) {\n+                rev.setBaseQualities(Arrays.copyOfRange(revQuals, firstElementLen, revQuals.length));\n+            }\n+            final List<CigarElement> newRevElements = new ArrayList<>(revElements);\n+            newRevElements.set(0, new CigarElement(firstElementLen, CigarOperator.H));\n+            rev.setCigar(new Cigar(newRevElements));\n+        }\n+    }\n+\n+    @VisibleForTesting\n+    static void kmerizeReads( final List<GATKRead> reads,\n+                              final KmerSet<KmerAdjacency> kmerAdjacencySet ) {\n+        for ( final GATKRead read : reads ) {\n+            final byte[] calls = read.getBasesNoCopy();\n+            final byte[] quals = read.getBaseQualitiesNoCopy();\n+            KmerAdjacency.kmerize(calls, quals, QMIN, kmerAdjacencySet);\n+        }\n+    }\n+\n+    /** gather unbranched strings of kmers into contigs **/\n+    @VisibleForTesting\n+    static List<ContigImpl> buildContigs( final KmerSet<KmerAdjacency> kmerAdjacencySet ) {\n+        // gather strings of kmers that have a single predecessor and single successor into contigs\n+        final List<ContigImpl> contigs = new ArrayList<>();\n+        int nContigs = 0;\n+        for ( final KmerAdjacency kmerAdjacency : kmerAdjacencySet ) {\n+            if ( kmerAdjacency.getContig() == null ) {\n+                ContigImpl contig = null;\n+                final KmerAdjacency predecessor = kmerAdjacency.getSolePredecessor();\n+                if ( predecessor == null ||\n+                        predecessor.getSuccessorCount() > 1 ||\n+                        predecessor == kmerAdjacency.rc() ) {\n+                    contig = new ContigImpl(++nContigs, kmerAdjacency);\n+                } else {\n+                    final KmerAdjacency successor = kmerAdjacency.getSoleSuccessor();\n+                    if ( successor == null ||\n+                            successor.getPredecessorCount() > 1 ||\n+                            successor == kmerAdjacency.rc() ) {\n+                        contig = new ContigImpl(++nContigs, kmerAdjacency.rc());\n+                    }\n+                }\n+                if ( contig != null ) {\n+                    contigs.add(contig);\n+                }\n+            }\n+        }\n+\n+        // if there are smooth circles like a plasmid, gather them together as a contig, too\n+        for ( final KmerAdjacency kmerAdjacency : kmerAdjacencySet ) {\n+            if ( kmerAdjacency.getContig() == null ) {\n+                contigs.add(new ContigImpl(++nContigs, kmerAdjacency));\n+            }\n+        }\n+\n+        return contigs;\n+    }\n+\n+    /** connect contigs when the final kmer of one contig is adjacent to the inital contig of another **/\n+    @VisibleForTesting\n+    static void connectContigs( final List<ContigImpl> contigs ) {\n+        final int nContigs = contigs.size();\n+        final KmerSet<ContigEndKmer> contigEnds = new KmerSet<>(2*nContigs);\n+        for ( int contigId = 0; contigId != nContigs; ++contigId ) {\n+            final ContigImpl contig = contigs.get(contigId);\n+            final KmerAdjacency fwdKmer = contig.getFirstKmer();\n+            final KmerAdjacency revKmer = contig.getLastKmer().rc();\n+            if ( fwdKmer == revKmer ) {\n+                contigEnds.add(new ContigEndKmer(fwdKmer.getKVal(), contig, ContigOrientation.BOTH));\n+            } else {\n+                contigEnds.add(new ContigEndKmer(fwdKmer.getKVal(), contig, ContigOrientation.FWD));\n+                contigEnds.add(new ContigEndKmer(revKmer.getKVal(), contig, ContigOrientation.REV));\n+            }\n+        }\n+\n+        for ( int contigId = 0; contigId != nContigs; ++contigId ) {\n+            final Contig contig = contigs.get(contigId);\n+\n+            final KmerAdjacency start = contig.getFirstKmer();\n+            final int predecessorCount = start.getPredecessorCount();\n+            if ( predecessorCount > 0 ) {\n+                final List<Contig> predecessors = contig.getPredecessors();\n+                final int mask = start.getPredecessorMask();\n+                for ( int call = 0; call != 4; ++call ) {\n+                    if ( (mask & (1 << call)) != 0 ) {\n+                        final long kVal =\n+                                KmerAdjacency.reverseComplement(start.getPredecessorVal(call));\n+                        final ContigEndKmer contigEndKmer = contigEnds.find(new Kmer(kVal));\n+                        if ( contigEndKmer == null ) {\n+                            throw new GATKException(\"missing contig end kmer\");\n+                        }\n+                        switch ( contigEndKmer.getContigOrientation() ) {\n+                            case FWD:\n+                                predecessors.add(contigEndKmer.getContig().rc());\n+                                break;\n+                            case REV:\n+                                predecessors.add(contigEndKmer.getContig());\n+                                break;\n+                            case BOTH:\n+                                predecessors.add(contigEndKmer.getContig());\n+                                predecessors.add(contigEndKmer.getContig().rc());\n+                                break;\n+                        }\n+                    }\n+                }\n+            }\n+\n+            final KmerAdjacency end = contig.getLastKmer();\n+            final int successorCount = end.getSuccessorCount();\n+            if ( successorCount > 0 ) {\n+                final List<Contig> successors = contig.getSuccessors();\n+                final int mask = end.getSuccessorMask();\n+                for ( int call = 0; call != 4; ++call ) {\n+                    if ( (mask & (1 << call)) != 0 ) {\n+                        final long kVal = end.getSuccessorVal(call);\n+                        final ContigEndKmer contigEndKmer = contigEnds.find(new Kmer(kVal));\n+                        if ( contigEndKmer == null ) {\n+                            throw new GATKException(\"missing contig end kmer\");\n+                        }\n+                        switch ( contigEndKmer.getContigOrientation() ) {\n+                            case FWD:\n+                                successors.add(contigEndKmer.getContig());\n+                                break;\n+                            case REV:\n+                                successors.add(contigEndKmer.getContig().rc());\n+                                break;\n+                            case BOTH:\n+                                successors.add(contigEndKmer.getContig());\n+                                successors.add(contigEndKmer.getContig().rc());\n+                                break;\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    /** remove contigs that have little evidence **/\n+    @VisibleForTesting\n+    static void removeThinContigs( final List<ContigImpl> contigs,\n+                                           final KmerSet<KmerAdjacency> kmerAdjacencySet ) {\n+        contigs.sort(Comparator.comparingInt(ContigImpl::getMaxObservations));\n+        boolean contigRemoved;\n+        do {\n+            // figure out which contigs are cut points\n+            // i.e., those contigs which, if removed, would result in a graph with more connected components\n+            final int nContigs = contigs.size();\n+            final Map<Contig, CutData> cutDataMap = new HashMap<>(nContigs * 3);\n+\n+            for ( final ContigImpl contig : contigs ) {\n+                if ( cutDataMap.containsKey(contig) ) {\n+                    continue;\n+                }\n+\n+                cutDataMap.put(contig, new CutData());\n+                int children = 0;\n+                for ( final Contig nextContig : contig.getSuccessors() ) {\n+                    if ( !cutDataMap.containsKey(nextContig) ) {\n+                        findCuts(nextContig, contig, cutDataMap);\n+                        children += 1;\n+                    }\n+                }\n+                for ( final Contig nextContig : contig.getPredecessors() ) {\n+                    if ( !cutDataMap.containsKey(nextContig) ) {\n+                        findCuts(nextContig, contig, cutDataMap);\n+                        children += 1;\n+                    }\n+                }\n+                if ( children >= 2 ) {\n+                    contig.setCut(true);\n+                }\n+            }\n+\n+            // remove poorly attested (low max observations) contigs, unless they are cut points\n+            contigRemoved = false;\n+            final Iterator<ContigImpl> itr = contigs.iterator();\n+            while ( itr.hasNext() ) {\n+                final Contig contig = itr.next();\n+                if ( contig.getMaxObservations() < MIN_THIN_OBS && !contig.isCut() ) {\n+                    unlinkContig(contig, kmerAdjacencySet);\n+                    itr.remove();\n+                    contigRemoved = true;\n+                    break;\n+                }\n+            }\n+        } while ( contigRemoved );\n+        contigs.sort(Comparator.comparingInt(ContigImpl::getId));\n+    }\n+\n+    private static CutData findCuts( final Contig contig,\n+                                     final Contig parent,\n+                                     final Map<Contig, CutData> cutDataMap ) {\n+        final CutData cutData = new CutData();\n+        cutDataMap.put(contig, cutData);\n+        for ( final Contig nextContig : contig.getSuccessors() ) {\n+            if ( nextContig == parent ) {\n+                continue;\n+            }\n+            CutData nextCutData = cutDataMap.get(nextContig);\n+            if ( nextCutData != null ) {\n+                cutData.minVisitNum = Math.min(cutData.minVisitNum, nextCutData.visitNum);\n+            } else {\n+                nextCutData = findCuts(nextContig, contig, cutDataMap);\n+                cutData.minVisitNum = Math.min(cutData.minVisitNum, nextCutData.minVisitNum);\n+                if ( nextCutData.minVisitNum >= cutData.visitNum ) {\n+                    contig.setCut(true);\n+                }\n+            }\n+        }\n+        for ( final Contig nextContig : contig.getPredecessors() ) {\n+            if ( nextContig == parent ) {\n+                continue;\n+            }\n+            CutData nextCutData = cutDataMap.get(nextContig);\n+            if ( nextCutData != null ) {\n+                cutData.minVisitNum = Math.min(cutData.minVisitNum, nextCutData.visitNum);\n+            } else {\n+                nextCutData = findCuts(nextContig, contig, cutDataMap);\n+                cutData.minVisitNum = Math.min(cutData.minVisitNum, nextCutData.minVisitNum);\n+                if ( nextCutData.minVisitNum >= cutData.visitNum ) {\n+                    contig.setCut(true);\n+                }\n+            }\n+        }\n+        return cutData;\n+    }\n+\n+    @VisibleForTesting\n+    static void unlinkContig( final Contig contig,\n+                                      final KmerSet<KmerAdjacency> kmerAdjacencySet ) {\n+        final KmerAdjacency firstKmer = contig.getFirstKmer();\n+        final int firstKmerFinalCall = firstKmer.getFinalCall();\n+        for ( final Contig predecessor : contig.getPredecessors() ) {\n+            if ( predecessor != contig && predecessor != contig.rc() ) {\n+                predecessor.getLastKmer().removeSuccessor(firstKmerFinalCall, kmerAdjacencySet);\n+                if ( !predecessor.getSuccessors().remove(contig) ) {\n+                    throw new GATKException(\"failed to find predecessor link\");\n+                }\n+            }\n+        }\n+\n+        final KmerAdjacency lastKmer = contig.getLastKmer();\n+        final int lastKmerInitialCall = lastKmer.getInitialCall();\n+        for ( final Contig successor : contig.getSuccessors() ) {\n+            if ( successor != contig && successor != contig.rc() ) {\n+                successor.getFirstKmer().removePredecessor(lastKmerInitialCall, kmerAdjacencySet);\n+                if ( !successor.getPredecessors().remove(contig) ) {\n+                    throw new GATKException(\"failed to find successor link\");\n+                }\n+            }\n+        }\n+\n+        KmerAdjacency nextKmer = firstKmer;\n+        KmerAdjacency kmer;\n+        do {\n+            kmer = nextKmer;\n+            nextKmer = kmer.getSoleSuccessor();\n+            kmerAdjacencySet.remove(kmer.canonical());\n+        } while ( kmer != lastKmer );\n+    }\n+\n+    private static void updateKmerContig( final KmerAdjacency firstKmer,\n+                                          final KmerAdjacency lastKmer,\n+                                          final Contig contig ) {\n+        int offset = 0;\n+        for ( KmerAdjacency kmer = firstKmer; kmer != lastKmer; kmer = kmer.getSoleSuccessor() ) {\n+            if ( kmer == null ) {\n+                throw new GATKException(\"contig does not have a flat pipeline of kmers\");\n+            }\n+            kmer.clearContig();\n+            kmer.setContigOffset(contig, offset++);\n+        }\n+        lastKmer.clearContig();\n+        lastKmer.setContigOffset(contig, offset);\n+        if ( offset + Kmer.KSIZE != contig.size() ) {\n+            throw new GATKException(\"kmer chain length does not equal contig size\");\n+        }\n+    }\n+\n+    /** replace adjacent contigs without branches with a single, larger contig **/\n+    @VisibleForTesting\n+    static void weldPipes( final List<ContigImpl> contigs ) {\n+        for ( int contigIdx = 0; contigIdx != contigs.size(); ++contigIdx ) {\n+            final ContigImpl contig = contigs.get(contigIdx);\n+            if ( contig.getSuccessors().size() == 1 ) {\n+                final Contig successor = contig.getSuccessors().get(0);\n+                if ( successor != contig && successor != contig.rc() &&\n+                        successor.getPredecessors().size() == 1 ) {\n+                    contigs.set(contigIdx, join(contig.getId(), contig, successor));\n+                    if ( !contigs.remove(successor.canonical()) ) {\n+                        throw new GATKException(\"successor linkage is messed up\");\n+                    }\n+                    contigIdx -= 1; // reconsider the new contig -- there might be more joining possible\n+                    continue;\n+                }\n+            }\n+            if ( contig.getPredecessors().size() == 1 ) {\n+                final Contig predecessor = contig.getPredecessors().get(0);\n+                if ( predecessor != contig && predecessor != contig.rc() &&\n+                        predecessor.getSuccessors().size() == 1 ) {\n+                    contigs.set(contigIdx, join(contig.getId(), predecessor, contig));\n+                    if ( !contigs.remove(predecessor.canonical()) ) {\n+                        throw new GATKException(\"predecessor linkage is messed up\");\n+                    }\n+                    contigIdx -= 1; // reconsider\n+                }\n+            }\n+        }\n+    }\n+\n+    private static ContigImpl join( final int id, final Contig predecessor, final Contig successor ) {\n+        if ( !checkOverlap(predecessor.getSequence(), successor.getSequence()) ) {\n+                throw new GATKException(\"sequences can't be joined\");\n+        }\n+        final ContigImpl joinedContig = new ContigImpl(id, predecessor, successor);\n+        updateKmerContig(joinedContig.getFirstKmer(), joinedContig.getLastKmer(), joinedContig);\n+        return joinedContig;\n+    }\n+\n+    private static boolean checkOverlap( final CharSequence seq1, final CharSequence seq2 ) {\n+        final int seq1Len = seq1.length();\n+        final CharSequence seq1SubSeq = seq1.subSequence(seq1Len - Kmer.KSIZE + 1, seq1Len);\n+        final CharSequence seq2SubSeq = seq2.subSequence(0, Kmer.KSIZE - 1);\n+        return seq1SubSeq.equals(seq2SubSeq);\n+    }\n+\n+    /** set a unique componentId for every connected group of contigs **/\n+    @VisibleForTesting\n+    static int markComponents( final List<ContigImpl> contigs ) {\n+        for ( final ContigImpl contig : contigs ) {\n+            contig.setComponentId(0);\n+        }\n+\n+        int componentId = 0;\n+        for ( final ContigImpl contig : contigs ) {\n+            if ( contig.getComponentId() == 0 ) {\n+                contig.setComponentId(++componentId);\n+                markSuccessorComponents(contig);\n+                markSuccessorComponents(contig.rc());\n+            }\n+        }\n+        return componentId;\n+    }\n+\n+    private static void markSuccessorComponents( final Contig contig ) {\n+        final int componentId = contig.getComponentId();\n+        for ( final Contig successor : contig.getSuccessors() ) {\n+            if ( successor.getComponentId() == 0 ) {\n+                successor.canonical().setComponentId(componentId);\n+                markSuccessorComponents(successor);\n+                markSuccessorComponents(successor.rc());\n+            }\n+        }\n+    }\n+\n+    @VisibleForTesting\n+    static void markCycles( final List<ContigImpl> contigs ) {\n+        for ( final Contig contig : contigs ) {\n+            contig.setCyclic(false);\n+        }\n+\n+        final int nContigs = contigs.size();\n+        final Deque<Contig> deque = new ArrayDeque<>(nContigs);\n+        final Map<Contig, CutData> cutDataMap = new HashMap<>(nContigs * 3);\n+        for ( final Contig contig : contigs ) {\n+            if ( !cutDataMap.containsKey(contig) ) {\n+                markCyclesRecursion(contig, deque, cutDataMap);\n+            }\n+        }\n+    }\n+\n+    private static CutData markCyclesRecursion( final Contig contig,\n+                                                final Deque<Contig> deque,\n+                                                final Map<Contig, CutData> cutDataMap ) {\n+        final CutData cutData = new CutData();\n+        cutDataMap.put(contig, cutData);\n+        deque.addFirst(contig);\n+\n+        for ( final Contig successor : contig.getSuccessors() ) {\n+            final CutData successorCutData = cutDataMap.get(successor);\n+            if ( successorCutData == null ) {\n+                final int recursionVisitNum =\n+                        markCyclesRecursion(successor, deque, cutDataMap).minVisitNum;\n+                cutData.minVisitNum = Math.min(cutData.minVisitNum, recursionVisitNum);\n+            } else {\n+                cutData.minVisitNum = Math.min(cutData.minVisitNum, successorCutData.visitNum);\n+            }\n+        }\n+\n+        if ( cutData.visitNum == cutData.minVisitNum ) {\n+            Contig tig = deque.removeFirst();\n+            if ( tig == contig ) {\n+                cutDataMap.get(tig).visitNum = Integer.MAX_VALUE;\n+\n+                // single-vertex component -- cyclic only if self-referential\n+                if ( tig.getSuccessors().contains(tig) ) {\n+                    tig.setCyclic(true);\n+                }\n+            } else {\n+                while ( true ) {\n+                    // kill cross-links\n+                    cutDataMap.get(tig).visitNum = Integer.MAX_VALUE;\n+                    tig.setCyclic(true);\n+                    if ( tig == contig ) break;\n+                    tig = deque.removeFirst();\n+                }\n+            }\n+        }\n+        return cutData;\n+    }\n+\n+    @VisibleForTesting\n+    static boolean fillGaps( final KmerSet<KmerAdjacency> kmerAdjacencySet,\n+                             final List<GATKRead> reads ) {\n+        final Map<String, Integer> gapFillCounts = new HashMap<>();\n+        for ( final GATKRead read : reads ) {\n+            final Path path = new Path(read.getBasesNoCopy(), kmerAdjacencySet);\n+            final List<PathPart> parts = path.getParts();\n+            final int lastIdx = parts.size() - 1;\n+            for ( int idx = 1; idx < lastIdx; ++idx ) {\n+                final PathPart pathPart = parts.get(idx);\n+                if ( pathPart.isGap() ) {\n+                    final char prevCall = parts.get(idx - 1).getLastCall();\n+                    final char nextCall = parts.get(idx + 1).getFirstCall();\n+                    String gapFill = prevCall + pathPart.getSequence().toString() + nextCall;\n+                    final SequenceRC gapFillRC = new SequenceRC(gapFill);\n+                    if ( gapFillRC.compareTo(gapFill) < 0 ) {\n+                        gapFill = gapFillRC.toString();\n+                    }\n+                    gapFillCounts.merge(gapFill, 1, Integer::sum);\n+                }\n+            }\n+        }\n+\n+        boolean newKmers = false;\n+        for ( final Map.Entry<String, Integer> entry : gapFillCounts.entrySet() ) {\n+            final int nObservations = entry.getValue();\n+            if ( nObservations >= MIN_GAPFILL_COUNT ) {\n+                KmerAdjacency.kmerize(entry.getKey(), nObservations, kmerAdjacencySet);\n+                newKmers = true;\n+            }\n+        }\n+\n+        if ( newKmers ) {\n+            for ( final KmerAdjacency kmerAdjacency : kmerAdjacencySet ) {\n+                kmerAdjacency.clearContig();\n+            }\n+        }\n+        return newKmers;\n+    }\n+\n+    @VisibleForTesting\n+    static List<Path> pathReads( final KmerSet<KmerAdjacency> kmerAdjacencySet,\n+                          final List<GATKRead> reads ) {\n+        final List<Path> readPaths = new ArrayList<>(reads.size());\n+        for ( final GATKRead read : reads ) {\n+            readPaths.add(new Path(read.getBasesNoCopy(), kmerAdjacencySet));\n+        }\n+        return readPaths;\n+    }\n+\n+    @VisibleForTesting\n+    static Map<Contig,List<TransitPairCount>> collectTransitPairCounts(\n+            final List<ContigImpl> contigs,\n+            final List<Path> readPaths ) {\n+        final Map<Contig,List<TransitPairCount>> contigTransitsMap =\n+                new HashMap<>(3 * contigs.size());\n+        for ( final Path path : readPaths ) {\n+            final List<PathPart> parts = path.getParts();\n+            final int lastPart = parts.size() - 1;\n+            for ( int partIdx = 1; partIdx < lastPart; ++partIdx ) {\n+                final Contig prevContig = parts.get(partIdx - 1).getContig();\n+                if ( prevContig == null ) continue;\n+                final Contig curContig = parts.get(partIdx).getContig();\n+                if ( curContig == null ) {\n+                    partIdx += 1;\n+                    continue;\n+                }\n+                final Contig nextContig = parts.get(partIdx + 1).getContig();\n+                if ( nextContig == null ) {\n+                    partIdx += 2;\n+                    continue;\n+                }\n+                final TransitPairCount tpc = new TransitPairCount(prevContig, nextContig);\n+                final List<TransitPairCount> tpcList =\n+                        contigTransitsMap.computeIfAbsent(curContig, tig -> new ArrayList<>(4));\n+                final int idx = tpcList.indexOf(tpc);\n+                if ( idx != -1 ) {\n+                    tpcList.get(idx).observe();\n+                } else {\n+                    tpcList.add(tpc);\n+                    contigTransitsMap.computeIfAbsent(curContig.rc(), tig -> new ArrayList<>(4))\n+                            .add(tpc.getRC());\n+                }\n+            }\n+        }\n+        return contigTransitsMap;\n+    }\n+\n+    @VisibleForTesting\n+    static Set<Traversal> traverseAllPaths(\n+            final List<ContigImpl> contigs,\n+            final List<Path> readPaths,\n+            final Map<Contig, List<TransitPairCount>> contigTransitsMap ) {\n+        final Set<Traversal> traversalSet = new HashSet<>();\n+        final List<Contig> contigsList = new ArrayList<>();\n+        for ( final Contig contig : contigs ) {\n+            // untransited contigs are sources, sinks, or large contigs that can't be crossed by a read\n+            // build traversals from these\n+            if ( !contigTransitsMap.containsKey(contig) ) {\n+                boolean done = false;\n+                for ( final Contig successor : contig.getSuccessors() ) {\n+                    traverse(successor, contig,\n+                            contigsList, readPaths, contigTransitsMap, traversalSet);\n+                    done = true;\n+                }\n+                for ( final Contig predecessor : contig.getPredecessors() ) {\n+                    traverse(predecessor.rc(), contig.rc(),\n+                            contigsList, readPaths, contigTransitsMap, traversalSet);\n+                    done = true;\n+                }\n+                if ( !done ) { // if there were no predecessors or successors, it stands alone\n+                    addTraversal(new Traversal(Collections.singletonList(contig)), traversalSet);\n+                }\n+            }\n+        }\n+\n+        // look for transits that haven't been traced\n+        for ( final Map.Entry<Contig, List<TransitPairCount>> entry :\n+                contigTransitsMap.entrySet() ) {\n+            for ( final TransitPairCount tpc : entry.getValue() ) {\n+                if ( tpc.getCount() > 0 ) {\n+                    tpc.resetCount();\n+                    final Contig contig = entry.getKey();\n+                    final Set<Traversal> fwdTraversalSet = new HashSet<>();\n+                    traverse(tpc.getNextContig(), contig,\n+                            contigsList, readPaths, contigTransitsMap, fwdTraversalSet);\n+                    final Set<Traversal> revTraversalSet = new HashSet<>();\n+                    traverse(tpc.getPrevContig().rc(), contig.rc(),\n+                            contigsList, readPaths, contigTransitsMap, revTraversalSet);\n+                    for ( final Traversal revTraversal : revTraversalSet ) {\n+                        final Traversal revTraversalRC = revTraversal.rc();\n+                        for ( final Traversal fwdTraversal : fwdTraversalSet ) {\n+                            final int overlap =\n+                                    findMaxOverlap(revTraversalRC.getContigs(), fwdTraversal.getContigs());\n+                            final Traversal combo =\n+                                    Traversal.combineOverlappers(revTraversalRC, fwdTraversal, overlap);\n+                            addTraversal(combo, traversalSet);\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+\n+        return traversalSet;\n+    }\n+\n+    private static int findMaxOverlap( final List<Contig> prefixes, final List<Contig> suffixes ) {\n+        final int nPrefixes = prefixes.size();\n+        final Contig firstSuffix = suffixes.get(0);\n+        if ( !firstSuffix.isCyclic() ) {\n+            return prefixes.get(nPrefixes - 1) == firstSuffix ? 1 : 0;\n+        }\n+        final int nSuffixes = suffixes.size();\n+        for ( int prefixIdx = Math.max(0, nPrefixes - nSuffixes); prefixIdx != nPrefixes; ++prefixIdx ) {\n+            if ( prefixes.get(prefixIdx) == firstSuffix ) {\n+                int suffixIdx = 1;\n+                boolean match = true;\n+                for ( int prefixIdx2 = prefixIdx + 1; prefixIdx2 != nPrefixes; ++prefixIdx2 ) {\n+                    if ( prefixes.get(prefixIdx2) != suffixes.get(suffixIdx++) ) {\n+                        match = false;\n+                        break;\n+                    }\n+                }\n+                if ( match ) {\n+                    return nPrefixes - prefixIdx;\n+                }\n+            }\n+        }\n+        return 0;\n+    }\n+\n+    private static void traverse( final Contig contig,\n+                                  final Contig predecessor,\n+                                  final List<Contig> contigsList,\n+                                  final List<Path> readPaths,\n+                                  final Map<Contig, List<TransitPairCount>> contigTransitsMap,\n+                                  final Set<Traversal> traversalSet ) {\n+        contigsList.add(predecessor);\n+        if ( contig.isCyclic() ) {\n+            traverseCycle(contig, contigsList, readPaths, contigTransitsMap, traversalSet);\n+            contigsList.remove(contigsList.size() - 1);\n+            return;\n+        }\n+        final List<TransitPairCount> transits = contigTransitsMap.get(contig);\n+        boolean done = false;\n+        if ( transits != null ) {\n+            for ( final TransitPairCount tpc : transits ) {\n+                if ( tpc.getPrevContig() == predecessor ) {\n+                    final Contig successor = tpc.getNextContig();\n+                    if ( predecessor == contig.rc() ) {\n+                        final int nContigs = contigsList.size();\n+                        if ( nContigs > 1 ) {\n+                            if ( successor.rc() == contigsList.get(nContigs - 2) ) {\n+                                continue;\n+                            }\n+                        }\n+                    }\n+                    tpc.resetCount();\n+                    traverse(successor, contig, contigsList, readPaths, contigTransitsMap, traversalSet);\n+                    done = true;\n+                }\n+            }\n+        }\n+        if ( !done ) {\n+            contigsList.add(contig);\n+            addTraversal(new Traversal(contigsList), traversalSet);\n+            contigsList.remove(contigsList.size() - 1);\n+        }\n+        contigsList.remove(contigsList.size() - 1);\n+    }\n+\n+    private static void traverseCycle( final Contig contig,\n+                                       final List<Contig> contigsList,\n+                                       final List<Path> readPaths,\n+                                       final Map<Contig, List<TransitPairCount>> contigTransitsMap,\n+                                       final Set<Traversal> traversalSet ) {\n+        contigsList.add(contig);\n+        final int nContigs = contigsList.size();\n+        // the final element of the list is cyclic, if there's a previous element it will be\n+        // non-cyclic, so start there figuring out how far the read paths lead us\n+        final List<List<Contig>> longestPaths =\n+                findLongestPaths(contigsList.subList(Math.max(0, nContigs - 2), nContigs), readPaths);\n+        // didn't get anywhere -- just complete the traversal\n+        if ( longestPaths.isEmpty() ) {\n+            addTraversal(new Traversal(contigsList, true), traversalSet);\n+        } else {\n+            // for each unique extension into the cycle\n+            for ( final List<Contig> path : longestPaths ) {\n+                // don't think this can happen, but still\n+                if ( path.isEmpty() ) {\n+                    addTraversal(new Traversal(contigsList, true), traversalSet);\n+                    continue;\n+                }\n+                final List<Contig> extendedContigsList =\n+                        new ArrayList<>(contigsList.size() + path.size());\n+                extendedContigsList.addAll(contigsList);\n+                // if we didn't get out of the cycle\n+                if ( path.get(path.size() - 1).isCyclic() ) {\n+                    extendedContigsList.addAll(path);\n+                    addTraversal(new Traversal(extendedContigsList, true), traversalSet);\n+                } else {\n+                    // we found a cycle-exiting path, so extend that normally\n+                    for ( final Contig curContig : path ) {\n+                        if ( curContig.isCyclic() ) {\n+                            extendedContigsList.add(curContig);\n+                        } else {\n+                            final Contig prevContig =\n+                                    extendedContigsList.remove(extendedContigsList.size() - 1);\n+                            traverse(curContig, prevContig, extendedContigsList, readPaths,\n+                                    contigTransitsMap, traversalSet);\n+                            extendedContigsList.add(prevContig);\n+                            break;\n+                        }\n+                    }\n+                }\n+                clearTransitPairs(contigTransitsMap, extendedContigsList);\n+            }\n+        }\n+        contigsList.remove(contigsList.size() - 1);\n+    }\n+\n+    private static void clearTransitPairs(\n+            final Map<Contig, List<TransitPairCount>> contigTransitsMap,\n+            final List<Contig> contigsList ) {\n+        final int lastIdx = contigsList.size() - 1;\n+        for ( int idx = 1; idx < lastIdx; ++idx ) {\n+            final List<TransitPairCount> pairCounts = contigTransitsMap.get(contigsList.get(idx));\n+            if ( pairCounts != null ) {\n+                final Contig predecessor = contigsList.get(idx - 1);\n+                final Contig successor = contigsList.get(idx + 1);\n+                for ( final TransitPairCount tpc : pairCounts ) {\n+                    if ( tpc.getPrevContig() == predecessor && tpc.getNextContig() == successor ) {\n+                        tpc.resetCount();\n+                        break;\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    private static void addTraversal( final Traversal traversal,\n+                                      final Set<Traversal> traversalSet ) {\n+        if ( !traversalSet.contains(traversal.rc()) ) {\n+            traversalSet.add(traversal);\n+            if ( traversalSet.size() >= TOO_MANY_TRAVERSALS ) {\n+                throw new AssemblyTooComplexException();\n+            }\n+        }\n+    }\n+\n+    private static List<List<Contig>> findLongestPaths( final List<Contig> toMatch,\n+                                                        final List<Path> readPaths ) {\n+        final List<List<Contig>> results = new ArrayList<>();\n+        for ( final Path path : readPaths ) {\n+            testPath(path, toMatch, results);\n+            testPath(path.rc(), toMatch, results);\n+        }\n+        return results;\n+    }\n+\n+    private static void testPath( final Path path,\n+                                  final List<Contig> toMatch,\n+                                  final List<List<Contig>> results ) {\n+        final List<PathPart> pathParts = path.getParts();\n+        final int nPathParts = pathParts.size();\n+        final List<Contig> pathContigs = new ArrayList<>(nPathParts);\n+        pathParts.forEach(pp -> pathContigs.add(pp.getContig()));\n+        final int matchIdx = Collections.indexOfSubList(pathContigs, toMatch);\n+        if ( matchIdx != -1 ) {\n+            final int suffixIdx = matchIdx + toMatch.size();\n+            if ( suffixIdx < nPathParts ) {\n+                resolveResult(grabParts(pathContigs, suffixIdx), results);\n+            }\n+        }\n+    }\n+\n+    private static List<Contig> grabParts( final List<Contig> pathContigs, final int suffixIdx ) {\n+        final int nPathContigs = pathContigs.size();\n+        Contig prev = pathContigs.get(suffixIdx - 1);\n+        final List<Contig> result = new ArrayList<>(nPathContigs - suffixIdx);\n+        for ( int idx = suffixIdx; idx != nPathContigs; ++idx ) {\n+            final Contig tig = pathContigs.get(idx);\n+            if ( tig == null || !prev.getSuccessors().contains(tig) ) break;\n+            result.add(tig);\n+            prev = tig;\n+        }\n+        return result;\n+    }\n+\n+    private static void resolveResult( final List<Contig> result,\n+                                       final List<List<Contig>> results ) {\n+        final int nResults = results.size();\n+        for ( int idx = 0; idx != nResults; ++idx ) {\n+            final List<Contig> test = results.get(idx);\n+            if ( isPrefix(result, test) ) return;\n+            if ( isPrefix(test, result) ) {\n+                results.set(idx, result);\n+                return;\n+            }\n+        }\n+        results.add(result);\n+    }\n+\n+    private static boolean isPrefix( final List<Contig> list1, final List<Contig> list2 ) {\n+        final int list1Size = list1.size();\n+        final int list2Size = list2.size();\n+        if ( list1Size > list2Size ) return false;\n+        for ( int idx = 0; idx != list1Size; ++idx ) {\n+            if ( list1.get(idx) != list2.get(idx) ) return false;\n+        }\n+        return true;\n+    }\n+\n+    @VisibleForTesting\n+    static Collection<Traversal> createScaffolds( final List<Traversal> allTraversals ) {\n+        removeTriviallyDifferentTraversals(allTraversals);\n+\n+        final int nTraversals = allTraversals.size();\n+        final Map<Contig, List<Integer>> traversalsByFirstContig = new HashMap<>(3 * nTraversals);\n+        for ( int idx = 0; idx != nTraversals; ++idx ) {\n+            final Traversal traversal = allTraversals.get(idx);\n+            traversalsByFirstContig.compute(traversal.getFirstContig(),\n+                    ( k, v ) -> v == null ? new ArrayList<>(3) : v).add(idx);\n+            final Traversal rcTraversal = traversal.rc();\n+            traversalsByFirstContig.compute(rcTraversal.getFirstContig(),\n+                    ( k, v ) -> v == null ? new ArrayList<>(3) : v).add(~idx);\n+        }\n+\n+        final List<Traversal> scaffolds = new ArrayList<>(nTraversals);\n+        final boolean[] touched = new boolean[nTraversals];\n+        for ( int idx = 0; idx != nTraversals; ++idx ) {\n+            if ( !touched[idx] ) {\n+                expandTraversal(idx, touched, traversalsByFirstContig, allTraversals, scaffolds);\n+            }\n+        }\n+        return scaffolds;\n+    }\n+\n+    private static void expandTraversal( final int traversalIdx,\n+                                         final boolean[] touched,\n+                                         final Map<Contig, List<Integer>> traversalsByFirstContig,\n+                                         final List<Traversal> allTraversals,\n+                                         final List<Traversal> scaffolds ) {\n+        final Traversal traversal = allTraversals.get(traversalIdx);\n+        touched[traversalIdx] = true;\n+        final List<Traversal> downExtensions = new ArrayList<>();\n+        final Set<Contig> startingContigSet = new HashSet<>();\n+        walkTraversals(traversal, touched, startingContigSet, traversalsByFirstContig,\n+                        allTraversals, downExtensions);\n+        final List<Traversal> upExtensions = new ArrayList<>();\n+        walkTraversals(traversal.rc(), touched, startingContigSet, traversalsByFirstContig,\n+                        allTraversals, upExtensions);\n+        for ( final Traversal down : downExtensions ) {\n+            for ( final Traversal up : upExtensions ) {\n+                if ( scaffolds.size() >= TOO_MANY_SCAFFOLDS ) {\n+                    throw new AssemblyTooComplexException();\n+                }\n+                scaffolds.add(Traversal.combineOverlappers(up.rc(), down, traversal.getContigs().size()));\n+            }\n+        }\n+    }\n+\n+    private static void walkTraversals( final Traversal traversal,\n+                                        final boolean[] touched,\n+                                        final Set<Contig> startingContigSet,\n+                                        final Map<Contig, List<Integer>> traversalsByFirstContig,\n+                                        final List<Traversal> allTraversals,\n+                                        final List<Traversal> extensions ) {\n+        final Contig firstContig = traversal.getFirstContig();\n+        final List<Integer> indexList;\n+        if ( startingContigSet.contains(firstContig) ||\n+                traversal.isInextensible() ||\n+                (indexList = traversalsByFirstContig.get(traversal.getLastContig())) == null ) {\n+            extensions.add(traversal);\n+            return;\n+        }\n+        startingContigSet.add(firstContig);\n+        for ( int idx : indexList ) {\n+            final Traversal extension;\n+            if ( idx >= 0 ) {\n+                extension = allTraversals.get(idx);\n+                touched[idx] = true;\n+            } else {\n+                final int rcIdx = ~idx;\n+                extension = allTraversals.get(rcIdx).rc();\n+                touched[rcIdx] = true;\n+            }\n+            walkTraversals(Traversal.combine(traversal, extension), touched, startingContigSet,\n+                            traversalsByFirstContig, allTraversals, extensions );\n+        }\n+        startingContigSet.remove(firstContig);\n+    }\n+\n+    private static void removeTriviallyDifferentTraversals(\n+                                            final Collection<Traversal> allTraversals ) {\n+        if ( allTraversals.isEmpty() ) {\n+            return;\n+        }\n+        final TreeSet<Traversal> sortedTraversals = new TreeSet<>(new TraversalEndpointComparator());\n+        for ( final Traversal traversal : allTraversals ) {\n+            sortedTraversals.add(traversal);\n+            sortedTraversals.add(traversal.rc());\n+        }\n+        final Iterator<Traversal> traversalIterator = sortedTraversals.iterator();\n+        Traversal prevTraversal = traversalIterator.next();\n+        while ( traversalIterator.hasNext() ) {\n+            final Traversal curTraversal = traversalIterator.next();\n+            if ( isTriviallyDifferent(prevTraversal, curTraversal) ) {\n+                traversalIterator.remove();\n+            } else {\n+                prevTraversal = curTraversal;\n+            }\n+        }\n+        sortedTraversals.removeIf(Traversal::isRC);\n+        allTraversals.clear();\n+        allTraversals.addAll(sortedTraversals);\n+    }\n+\n+    private static boolean isTriviallyDifferent( final Traversal traversal1,\n+                                                 final Traversal traversal2 ) {\n+        final Contig firstContig1 = traversal1.getFirstContig();\n+        final Contig lastContig1 = traversal1.getLastContig();\n+        final Contig firstContig2 = traversal2.getFirstContig();\n+        final Contig lastContig2 = traversal2.getLastContig();\n+        if ( firstContig1 != firstContig2 || lastContig1 != lastContig2 ) {\n+            return false;\n+        }\n+        final int interiorSize1 = traversal1.getSequenceLength() - firstContig1.size() - lastContig1.size();\n+        final int interiorSize2 = traversal2.getSequenceLength() - firstContig2.size() - lastContig2.size();\n+\n+        // if the path lengths are so different that one could harbor an SV, they're not trivially different\n+        if ( Math.abs(interiorSize1 - interiorSize2) >= MIN_SV_SIZE ) {\n+            return false;\n+        }\n+\n+        // if the paths are small enough that there can't be an SV's worth of differences, they're trivially different\n+        final int maxInteriorSize = Math.max(interiorSize1, interiorSize2);\n+        if ( maxInteriorSize < MIN_SV_SIZE ) {\n+            return true;\n+        }\n+\n+        // dang, maybe there's enough material in common that there can't be an SV's worth of differences\n+        // run a longest common subsequence algorithm to figure out the length of the common material\n+        // DP matrix holds length of common material\n+        final List<Contig> contigs1 = traversal1.getContigs();\n+        final int rowLen = contigs1.size() - 1;\n+        final int[][] rowPair = new int[2][];\n+        rowPair[0] = new int[rowLen];\n+        rowPair[1] = new int[rowLen];\n+        int pairIdx = 0;\n+        final List<Contig> contigs2 = traversal2.getContigs();\n+        final int nRows = contigs2.size() - 1;\n+        for ( int idx2 = 1; idx2 != nRows; ++idx2 ) {\n+            final int[] curRow = rowPair[pairIdx];\n+            final int[] prevRow = rowPair[pairIdx ^ 1];\n+            pairIdx ^= 1;\n+\n+            final int id2 = contigs2.get(idx2).getId();\n+            for ( int idx1 = 1; idx1 != rowLen; ++idx1 ) {\n+                final Contig tig1 = contigs1.get(idx1);\n+                if ( tig1.getId() == id2 ) {\n+                    // if the previous cells also contain a match we've already removed the K-1 bases upstream\n+                    final boolean extendMatch =\n+                            contigs1.get(idx1 -1).getId() == contigs2.get(idx2 - 1).getId();\n+                    curRow[idx1] = prevRow[idx1 - 1] + (extendMatch ? tig1.getNKmers() : tig1.size());\n+                } else {\n+                    curRow[idx1] = Math.max(curRow[idx1 - 1], prevRow[idx1]);\n+                }\n+            }\n+        }\n+        final int commonLen = rowPair[pairIdx ^ 1][rowLen - 1];\n+        return (maxInteriorSize - commonLen) < MIN_SV_SIZE;\n+    }\n+\n+    private static class TraversalEndpointComparator implements Comparator<Traversal> {\n+        @Override\n+        public int compare( final Traversal traversal1, final Traversal traversal2 ) {\n+            int cmp = Integer.compare(traversal1.contigs.get(0).getId(),\n+                                      traversal2.contigs.get(0).getId());\n+            if ( cmp != 0 ) {\n+                return cmp;\n+            }\n+            final int last1 = traversal1.contigs.size() - 1;\n+            final int last2 = traversal2.contigs.size() - 1;\n+            cmp = Integer.compare(traversal1.contigs.get(last1).getId(),\n+                                  traversal2.contigs.get(last2).getId());\n+            if ( cmp != 0 ) {\n+                return cmp;\n+            }\n+            // among those starting and ending at the same place, sort least observed last\n+            return -Integer.compare(traversal1.getMinMaxObservations(), traversal2.getMinMaxObservations());\n+        }\n+    }\n+\n+    private static void writeDOT( final List<ContigImpl> contigs, final String fileName ) {\n+        try ( final BufferedWriter writer = new BufferedWriter(new FileWriter(fileName)) ) {\n+            writer.write(\"digraph {\\n\");\n+            for ( final Contig contig : contigs ) {\n+                final double width = contig.getSequence().length() / 100.;\n+                writer.write(contig + \" [width=\" + width + \"]\\n\");\n+                writer.write( contig.rc() + \" [width=\" + width + \"]\\n\");\n+            }\n+            for ( final Contig contig : contigs ) {\n+                for ( final Contig predecessor : contig.getPredecessors() ) {\n+                    final String predecessorName = predecessor.rc().toString();\n+                    writer.write(contig.rc() + \" -> \" + predecessorName + \"\\n\");\n+                }\n+                for ( final Contig successor : contig.getSuccessors() ) {\n+                    final String successorName = successor.toString();\n+                    writer.write(contig + \" -> \" + successorName + \"\\n\");\n+                }\n+            }\n+            writer.write(\"}\\n\");\n+        } catch ( final IOException ioe ) {\n+            throw new GATKException(\"Failed to write assembly DOT file.\", ioe);\n+        }\n+    }\n+\n+    private static BufferedWriter makeGZFile( final String fileName ) throws IOException {\n+        final GZIPOutputStream gzOS = new GZIPOutputStream(BucketUtils.createFile(fileName));\n+        return new BufferedWriter(new OutputStreamWriter(gzOS));\n+    }\n+\n+    private static void writeContigs( final List<ContigImpl> contigs, final String fileName ) {\n+        try ( final BufferedWriter writer = makeGZFile(fileName) ) {\n+            for ( final Contig contig : contigs ) {\n+                final List<Contig> predecessors = contig.getPredecessors();\n+                final String predecessorDescription;\n+                if ( predecessors.size() == 0 ) {\n+                    predecessorDescription = \"\\tnone\";\n+                } else {\n+                    final StringBuilder sb = new StringBuilder();\n+                    char prefix = '\\t';\n+                    for ( final Contig predecessor : predecessors ) {\n+                        sb.append(prefix);\n+                        prefix = ',';\n+                        sb.append(predecessor);\n+                    }\n+                    predecessorDescription = sb.toString();\n+                }\n+\n+                final List<Contig> successors = contig.getSuccessors();\n+                final String successorDescription;\n+                if ( successors.size() == 0 ) {\n+                    successorDescription = \"\\tnone\";\n+                } else {\n+                    final StringBuilder sb = new StringBuilder();\n+                    char prefix = '\\t';\n+                    for ( final Contig successor : successors ) {\n+                        sb.append(prefix);\n+                        prefix = ',';\n+                        sb.append(successor);\n+                    }\n+                    successorDescription = sb.toString();\n+                }\n+\n+                final String contigName = contig.toString();\n+                final String component =\n+                        (contig.isCyclic() ? \"(C)\\t\" : \"\\t\") + contig.getComponentId();\n+                writer.write(contigName + component + predecessorDescription +\n+                        successorDescription + \"\\t\" +\n+                        contig.getMaxObservations() + \"\\t\" +\n+                        contig.getFirstKmer().getNObservations() + \"\\t\" +\n+                        contig.getLastKmer().getNObservations() + \"\\t\" +\n+                        contig.size() + \"\\t\" +\n+                        contig.getSequence() + \"\\n\");\n+            }\n+        } catch ( final IOException ioe ) {\n+            throw new GATKException(\"Failed to write contigs file.\", ioe);\n+        }\n+    }\n+\n+    private static void writePaths( final List<Path> readPaths, final String fileName ) {\n+        try ( final BufferedWriter writer = makeGZFile(fileName) ) {\n+            final int nReads = readPaths.size();\n+            for ( int readId = 0; readId != nReads; ++readId ) {\n+                final Path path = readPaths.get(readId);\n+                final String pathDesc = path.toString();\n+                writer.write((readId + 1) + \": \" + pathDesc + \"\\n\");\n+            }\n+        } catch ( final IOException ioe ) {\n+            throw new GATKException(\"Failed to write paths file.\", ioe);\n+        }\n+    }\n+\n+    private static void writeReads( final List<GATKRead> reads, final String fileName ) {\n+        try ( final BufferedWriter writer = makeGZFile(fileName) ) {\n+            for ( final GATKRead read : reads ) {\n+                writer.write(\"@\" + read.getName());\n+                writer.write('\\n');\n+                writer.write(new String(read.getBasesNoCopy()));\n+                writer.write(\"\\n+\\n\");\n+                final byte[] quals = read.getBaseQualitiesNoCopy();\n+                final int nQuals = quals.length;\n+                final byte[] fastqQuals = new byte[nQuals];\n+                for ( int idx = 0; idx != nQuals; ++idx ) {\n+                    fastqQuals[idx] = (byte)SAMUtils.phredToFastq(quals[idx]);\n+                }\n+                writer.write(new String(fastqQuals));\n+                writer.write('\\n');\n+            }\n+        } catch ( final IOException ioe ) {\n+            throw new GATKException(\"Failed to write assembly sam file.\", ioe);\n+        }\n+    }\n+\n+    private static void writeTraversals( final Collection<Traversal> traversals,\n+                                         final String fileName ) {\n+        try ( final BufferedWriter writer = makeGZFile(fileName) ) {\n+            int traversalNo = 0;\n+            for ( final Traversal traversal : traversals ) {\n+                writer.write(\">\");\n+                if ( assemblyName != null ) {\n+                    writer.write(assemblyName);\n+                    writer.write(\"_\");\n+                }\n+                writer.write(\"t\");\n+                writer.write(Integer.toString(++traversalNo));\n+                writer.write(\" \");\n+                writer.write(traversal.getName());\n+                writer.newLine();\n+                writer.write(traversal.getSequence());\n+                writer.newLine();\n+            }\n+        } catch ( final IOException ioe ) {\n+            throw new GATKException(\"Failed to write assembly sam file.\", ioe);\n+        }\n+    }\n+\n+    /** fixed-size, immutable kmer.  usual 2-bit encoding: ACGT->0123.  low order bits are final call. **/\n+    public static class Kmer {\n+        public static final int KSIZE = 31; // must be odd number less than 32\n+        public static final long KMASK = (1L << 2*KSIZE) - 1L;\n+        private final long kVal;\n+\n+        public Kmer( final long kVal ) { this.kVal = kVal; }\n+\n+        public long getKVal() { return kVal; }\n+        public boolean isCanonical() { return isCanonical(kVal); }\n+        public int getInitialCall() { return (int)(kVal >> (KSIZE*2 - 2)) & 3; }\n+        public int getFinalCall() { return (int)kVal & 3; }\n+\n+        public long getPredecessorVal( final int call ) {\n+            return (kVal >> 2) | ((long)call << (2 * (KSIZE - 1)));\n+        }\n+        public long getSuccessorVal( final int call ) { return ((kVal << 2) & KMASK) | call; }\n+\n+        public static boolean isCanonical( final long val ) {\n+            return (val & (1L << KSIZE)) == 0L;\n+        }\n+\n+        @Override public boolean equals( final Object obj ) {\n+            return obj instanceof Kmer && kVal == ((Kmer)obj).kVal;\n+        }\n+\n+        @Override public int hashCode() {\n+            return (int)(kVal ^ (kVal >>> 32));\n+        }\n+    }\n+\n+    /** Set of Kmers.  Uses HopscotchSet, customized to find correct starting bin for Kmers and derivatives. **/\n+    public static final class KmerSet<KMER extends Kmer> extends HopscotchSet<KMER> {\n+        public KmerSet( final int capacity ) { super(capacity); }\n+\n+        @Override\n+        protected int hashToIndex( final Object kmer ) {\n+            return (int)(((HopscotchSet.SPREADER * ((Kmer)kmer).getKVal()) & Long.MAX_VALUE) % capacity());\n+        }\n+    }\n+\n+    /**\n+     *  A Kmer that remembers its predecessors and successors, and the number of times it's been observed\n+     *  in the assembly's input set of reads.\n+     *  The masks are bit-wise (1=A, 2=C, 4=G, 8=T) to show which predecessors or successors have been observed.\n+     *  The Kmer's position on a Contig is also tracked (in later phases of the assembly process).\n+     **/\n+    public static abstract class KmerAdjacency extends Kmer {\n+        public KmerAdjacency( final long kVal ) { super(kVal); }\n+\n+        public abstract KmerAdjacency getSolePredecessor(); // returns null if there's 0 or >1 predecessors\n+        public abstract int getPredecessorMask();\n+        public abstract int getPredecessorCount();\n+        public abstract void removePredecessor( final int callToRemove,\n+                                                final KmerSet<KmerAdjacency> kmerAdjacencySet );\n+\n+        public abstract KmerAdjacency getSoleSuccessor(); // returns null if there's 0 or > 1 successors\n+        public abstract int getSuccessorMask();\n+        public abstract int getSuccessorCount();\n+        public abstract void removeSuccessor( final int callToRemove,\n+                                              final KmerSet<KmerAdjacency> kmerAdjacencySet );\n+\n+        public abstract Contig getContig();\n+        public abstract int getContigOffset();\n+        // offset is 0-based measure on the contig sequence of the beginning of the kmer\n+        public abstract void setContigOffset( final Contig contig, final int contigOffset );\n+        public abstract void clearContig();\n+\n+        public abstract int getNObservations();\n+        public abstract KmerAdjacency rc();\n+        public abstract KmerAdjacencyImpl canonical();\n+\n+        public void observe( final KmerAdjacency predecessor, final KmerAdjacency successor ) {\n+            observe(predecessor, successor, 1);\n+        }\n+\n+        public abstract void observe( final KmerAdjacency predecessor,\n+                                      final KmerAdjacency successor,\n+                                      final int count );\n+\n+        @Override public String toString() {\n+            final StringBuilder sb = new StringBuilder(KSIZE);\n+            long currentVal = getKVal();\n+            for ( int idx = 0; idx != KSIZE; ++idx ) {\n+                sb.append(\"ACGT\".charAt((int)currentVal & 3));\n+                currentVal >>= 2;\n+            }\n+            sb.reverse(); // low order bits were loaded into sb first:  fix that now by reversing the sb.\n+            return sb.toString();\n+        }\n+\n+        /**\n+         * Transform a read's calls into KmerAdjacencies, and add them to a KmerSet.\n+         * Skip kmers that include a call with a quality < qMin.\n+         * Skip kmers with non-ACGT calls.\n+         **/\n+        public static void kmerize( final byte[] calls,\n+                                    final byte[] quals,\n+                                    final byte qMin,\n+                                    final KmerSet<KmerAdjacency> kmerAdjacencySet ) {\n+            int currentCount = 0; // number of calls loaded into currentKVal\n+            long currentKVal = 0;\n+            KmerAdjacency prevAdjacency = null;\n+            KmerAdjacency currentAdjacency = null;\n+            for ( int idx = 0; idx < calls.length; ++idx ) {\n+                if ( quals[idx] < qMin ) { // if we encounter a low-quality call\n+                    // take care of the most recent valid KmerAdjacency, if any\n+                    if ( currentAdjacency != null ) {\n+                        currentAdjacency.observe(prevAdjacency, null);\n+                    }\n+                    // ready ourselves to accumulate calls afresh\n+                    currentCount = 0;\n+                    currentAdjacency = prevAdjacency = null;\n+                    continue;\n+                }\n+                currentKVal <<= 2;\n+                switch ( calls[idx] ) {\n+                    case 'A': case 'a': break;\n+                    case 'C': case 'c': currentKVal += 1; break;\n+                    case 'G': case 'g': currentKVal += 2; break;\n+                    case 'T': case 't': currentKVal += 3; break;\n+                    default:\n+                        if ( currentAdjacency != null ) {\n+                            currentAdjacency.observe(prevAdjacency, null);\n+                        }\n+                        currentCount = 0;\n+                        currentAdjacency = prevAdjacency = null;\n+                        continue;\n+                }\n+                if ( ++currentCount >= KSIZE ) { // if we've loaded enough calls to make a complete kmer\n+                    final KmerAdjacency nextAdjacency = findOrAdd(currentKVal, kmerAdjacencySet);\n+                    if ( currentAdjacency != null ) {\n+                        currentAdjacency.observe(prevAdjacency, nextAdjacency);\n+                    }\n+                    prevAdjacency = currentAdjacency;\n+                    currentAdjacency = nextAdjacency;\n+                }\n+            }\n+            if ( currentAdjacency != null ) {\n+                currentAdjacency.observe(prevAdjacency, null);\n+            }\n+        }\n+\n+        /**\n+         * Kmerize a String.  This version is for gap fills.\n+         * The number of observations applies to all kmers except the 1st and last.\n+         **/\n+        public static void kmerize( final String sequence,\n+                                    final int nObservations,\n+                                    final KmerSet<KmerAdjacency> kmerAdjacencySet ) {\n+            int currentCount = 0;\n+            long currentKVal = 0;\n+            int nObs = 0;\n+            KmerAdjacency prevAdjacency = null;\n+            KmerAdjacency currentAdjacency = null;\n+            final int nCalls = sequence.length();\n+            for ( int idx = 0; idx != nCalls; ++idx ) {\n+                currentKVal <<= 2;\n+                switch ( sequence.charAt(idx) ) {\n+                    case 'A': case 'a': break;\n+                    case 'C': case 'c': currentKVal += 1; break;\n+                    case 'G': case 'g': currentKVal += 2; break;\n+                    case 'T': case 't': currentKVal += 3; break;\n+                    default: throw new GATKException(\"unexpected base call in string to kmerize.\");\n+                }\n+                if ( ++currentCount >= KSIZE ) {\n+                    final KmerAdjacency nextAdjacency = findOrAdd(currentKVal, kmerAdjacencySet);\n+                    if ( currentAdjacency != null ) {\n+                        currentAdjacency.observe(prevAdjacency, nextAdjacency, nObs);\n+                        nObs = nObservations;\n+                    }\n+                    prevAdjacency = currentAdjacency;\n+                    currentAdjacency = nextAdjacency;\n+                }\n+            }\n+            if ( currentAdjacency != null ) {\n+                currentAdjacency.observe(prevAdjacency, null, 0);\n+            }\n+        }\n+\n+        // Lookup table for reverse-complementing each possible byte value.\n+        // Each pair of bits represents a base, so you have to reverse bits pairwise and then invert all bits.\n+        // This is most quickly and easily done with a lookup table.\n+        private static final long[] BYTEWISE_REVERSE_COMPLEMENT;\n+        static {\n+            BYTEWISE_REVERSE_COMPLEMENT = new long[256];\n+            for ( int bIn = 0; bIn != 256; ++bIn ) {\n+                BYTEWISE_REVERSE_COMPLEMENT[bIn] =\n+                        ~(((bIn & 3) << 6) | (((bIn >> 2) & 3) << 4) |\n+                                (((bIn >> 4) & 3) << 2) | ((bIn >> 6) & 3)) & 0xffL;\n+            }\n+        }\n+\n+        public static long reverseComplement( long val ) {\n+            // process val one byte at a time\n+            long result = BYTEWISE_REVERSE_COMPLEMENT[(int)val & 0xFF]; // handle the low-order byte\n+            int nBytes = 8;\n+            while ( --nBytes != 0 ) { // pre-decrementing:  we'll go through the loop 7 times\n+                // rotate down by a byte\n+                val >>= 8;\n+                // rotate up by a byte and OR in the reverse complement of the next byte\n+                result = (result << 8) | BYTEWISE_REVERSE_COMPLEMENT[(int)val & 0xFF];\n+            }\n+            return result >>> (Long.SIZE - 2*KSIZE);\n+        }\n+\n+        // Kmer lookup in KmerSet.\n+        // KmerSets holding KmerAdjacencies have only canonical Kmers, so RC non-canonical kmers before lookup.\n+        public static KmerAdjacency find( final long kVal,\n+                                          final KmerSet<KmerAdjacency> kmerAdjacencySet ) {\n+            if ( isCanonical(kVal) ) return kmerAdjacencySet.find(new Kmer(kVal & KMASK));\n+            final KmerAdjacency result = kmerAdjacencySet.find(new Kmer(reverseComplement(kVal)));\n+            return result == null ? null : result.rc();\n+        }\n+\n+        // Kmer lookup in KmerSet.\n+        // KmerSets holding KmerAdjacencies have only canonical Kmers, so RC non-canonical kmers before lookup.\n+        // Add missing Kmers.\n+        public static KmerAdjacency findOrAdd( final long kVal,\n+                                               final KmerSet<KmerAdjacency> kmerAdjacencySet ) {\n+            if ( isCanonical(kVal) ) {\n+                return kmerAdjacencySet.findOrAdd(new Kmer(kVal & KMASK), kmer ->\n+                        new KmerAdjacencyImpl(((Kmer)kmer).getKVal()));\n+            }\n+            return kmerAdjacencySet.findOrAdd(new Kmer(reverseComplement(kVal)), kmer ->\n+                    new KmerAdjacencyImpl(((Kmer)kmer).getKVal())).rc();\n+        }\n+    }\n+\n+    /**\n+     * Class to implement KmerAdjacency for canonical Kmers.\n+     * In particular, a KmerSet created on KmerAdjacency contains only canonical Kmers.\n+     **/\n+    public static final class KmerAdjacencyImpl extends KmerAdjacency {\n+        private KmerAdjacency solePredecessor; // set to null if there are no predecessors, or multiple predecessors\n+        private KmerAdjacency soleSuccessor; // set to null if there are no successors, or multiple successors\n+        private int predecessorMask; // bit mask of observed kmers preceding this one\n+        private int successorMask; // bit mask observed kmers following this one\n+        private Contig contig; // the contig that contains this Kmer\n+        private int contigOffset; // the offset within the contig where this kmer is found\n+        private int nObservations; // the reads in which this kmer was observed\n+        private final KmerAdjacencyRC rc; // the reverse-complement of this kmer\n+        private static final int[] COUNT_FOR_MASK =\n+                //side sum for binary values from 0 -> 15\n+                //0000  0001 0010 0011 0100 0101 0110 0111 1000 1001 1010 1011 1100 1101 1110 1111\n+                {    0,    1,   1,   2,   1,   2,   2,   3,   1,   2,   2,   3,   2,   3,   3,   4 };\n+\n+        public KmerAdjacencyImpl( final long kVal ) {\n+            super(kVal);\n+            this.rc = new KmerAdjacencyRC(this);\n+        }\n+\n+        @Override public KmerAdjacency getSolePredecessor() { return solePredecessor; } // may return null\n+        @Override public int getPredecessorMask() { return predecessorMask; }\n+        @Override public int getPredecessorCount() { return COUNT_FOR_MASK[predecessorMask]; }\n+        @Override\n+        public void removePredecessor( final int callToRemove,\n+                                       final KmerSet<KmerAdjacency> kmerAdjacencySet ) {\n+            predecessorMask &= ~(1 << callToRemove);\n+            solePredecessor = null;\n+            if ( getPredecessorCount() == 1 ) {\n+                for ( int call = 0; call != 4; ++call ) {\n+                    if ( ((1 << call) & predecessorMask) != 0 ) {\n+                        solePredecessor = find(getPredecessorVal(call), kmerAdjacencySet);\n+                        break;\n+                    }\n+                }\n+            }\n+        }\n+\n+        @Override public KmerAdjacency getSoleSuccessor() { return soleSuccessor; } // may return null\n+        @Override public int getSuccessorMask() { return successorMask; }\n+        @Override public int getSuccessorCount() { return COUNT_FOR_MASK[successorMask]; }\n+        @Override\n+        public void removeSuccessor( final int callToRemove,\n+                                     final KmerSet<KmerAdjacency> kmerAdjacencySet ) {\n+            successorMask &= ~(1 << callToRemove);\n+            soleSuccessor = null;\n+            if ( getSuccessorCount() == 1 ) {\n+                for ( int call = 0; call != 4; ++call ) {\n+                    if ( ((1 << call) & successorMask) != 0 ) {\n+                        soleSuccessor = find(getSuccessorVal(call), kmerAdjacencySet);\n+                        break;\n+                    }\n+                }\n+            }\n+        }\n+\n+        @Override public Contig getContig() { return contig; }\n+        @Override public int getContigOffset() { return contigOffset; }\n+        @Override public void setContigOffset( final Contig contig, final int contigOffset ) {\n+            if ( this.contig != null ) {\n+                throw new GATKException(\"Internal error: overwriting kmer contig and offset.\");\n+            }\n+            this.contig = contig;\n+            this.contigOffset = contigOffset;\n+        }\n+        @Override public void clearContig() { contig = null; contigOffset = 0; }\n+\n+        @Override public int getNObservations() { return nObservations; }\n+        @Override public KmerAdjacency rc() { return rc; }\n+        @Override public KmerAdjacencyImpl canonical() { return this; }\n+\n+        @Override public void observe( final KmerAdjacency predecessor,\n+                                       final KmerAdjacency successor,\n+                                       final int count ) {\n+            if ( predecessor != null ) {\n+                if ( predecessor.getSuccessorVal(getFinalCall()) != getKVal() ) {\n+                    throw new GATKException(\"illegal predecessor\");\n+                }\n+                final int initialCall = predecessor.getInitialCall();\n+                final int newPredecessorMask = 1 << initialCall;\n+                if ( (newPredecessorMask & predecessorMask) == 0 ) {\n+                    if ( predecessorMask == 0 ) {\n+                        solePredecessor = predecessor;\n+                        predecessorMask = newPredecessorMask;\n+                    } else {\n+                        solePredecessor = null;\n+                        predecessorMask |= newPredecessorMask;\n+                    }\n+                }\n+            }\n+            if ( successor != null ) {\n+                if ( successor.getPredecessorVal(getInitialCall()) != getKVal() ) {\n+                    throw new GATKException(\"illegal successor\");\n+                }\n+                final int finalCall = successor.getFinalCall();\n+                final int newSuccessorMask = 1 << finalCall;\n+                if ( (newSuccessorMask & successorMask) == 0 ) {\n+                    if ( successorMask == 0 ) {\n+                        soleSuccessor = successor;\n+                        successorMask = newSuccessorMask;\n+                    } else {\n+                        soleSuccessor = null;\n+                        successorMask |= newSuccessorMask;\n+                    }\n+                }\n+            }\n+            nObservations += count;\n+        }\n+    }\n+\n+    /**\n+     * Class to implement KmerAdjacency for Kmers that are the reverse-complement of a canonical Kmer.\n+     * In particular, a KmerSet created on KmerAdjacency contains only canonical Kmers.\n+     * A KmerAdjacencyRC represents the RC of each Kmer in the KmerSet.\n+     **/\n+    public static final class KmerAdjacencyRC extends KmerAdjacency {\n+        private final KmerAdjacencyImpl rc;\n+\n+        // lookup table to bit-reverse nibbles\n+        private static final int[] NIBREV =\n+                // 0000,  0001,  0010,  0011,  0100,  0101,  0110,  0111,  1000,  1001,  1010,  1011,  1100,  1101,  1110,  1111\n+                {0b0000,0b1000,0b0100,0b1100,0b0010,0b1010,0b0110,0b1110,0b0001,0b1001,0b0101,0b1101,0b0011,0b1011,0b0111,0b1111};\n+\n+        public KmerAdjacencyRC( final KmerAdjacencyImpl rc ) {\n+            super(reverseComplement(rc.getKVal()));\n+            this.rc = rc;\n+        }\n+\n+        @Override public KmerAdjacency getSolePredecessor() {\n+            final KmerAdjacency successor = rc.getSoleSuccessor();\n+            return successor == null ? null : successor.rc();\n+        }\n+        @Override public int getPredecessorMask() { return NIBREV[rc.getSuccessorMask()]; }\n+        @Override public int getPredecessorCount() { return rc.getSuccessorCount(); }\n+        @Override\n+        public void removePredecessor( final int callToRemove,\n+                                       final KmerSet<KmerAdjacency> kmerAdjacencySet ) {\n+            rc.removeSuccessor(3 - callToRemove, kmerAdjacencySet);\n+        }\n+\n+        @Override public KmerAdjacency getSoleSuccessor() {\n+            final KmerAdjacency predecessor = rc.getSolePredecessor();\n+            return predecessor == null ? null : predecessor.rc();\n+        }\n+        @Override public int getSuccessorMask() { return NIBREV[rc.getPredecessorMask()]; }\n+        @Override public int getSuccessorCount() { return rc.getPredecessorCount(); }\n+        @Override\n+        public void removeSuccessor( final int callToRemove,\n+                                     final KmerSet<KmerAdjacency> kmerAdjacencySet ) {\n+            rc.removePredecessor(3 - callToRemove, kmerAdjacencySet);\n+        }\n+\n+        @Override public Contig getContig() {\n+            final Contig contig = rc.getContig();\n+            return contig == null ? null : contig.rc();\n+        }\n+        @Override public int getContigOffset() {\n+            final Contig contig = rc.getContig();\n+            return contig == null ? 0 : contig.size() - rc.getContigOffset() - KSIZE;\n+        }\n+        @Override public void setContigOffset( final Contig contig, final int contigOffset ) {\n+            rc.setContigOffset(contig.rc(), contig.size() - contigOffset - KSIZE);\n+        }\n+        @Override public void clearContig() { rc.clearContig(); }\n+\n+        @Override public int getNObservations() { return rc.getNObservations(); }\n+        @Override public KmerAdjacency rc() { return rc; }\n+        @Override public KmerAdjacencyImpl canonical() { return rc; }\n+\n+        @Override public void observe( final KmerAdjacency predecessor,\n+                                       final KmerAdjacency successor,\n+                                       final int count ) {\n+            rc.observe(successor == null ? null : successor.rc(),\n+                    predecessor == null ? null : predecessor.rc(),\n+                    count);\n+        }\n+    }\n+\n+    public enum ContigOrientation {\n+        FWD, // k-mer appears at the 5' end of the contig\n+        REV, // k-mer appears at the 5' end of the reverse-complemented contig\n+        BOTH // k-mer occurs on 5' end of the contig and its RC (can happen when the contig is a palindrome)\n+    }\n+\n+    /** Initial or final Kmer in a Contig. **/\n+    public static final class ContigEndKmer extends Kmer {\n+        private final Contig contig;\n+        private final ContigOrientation contigOrientation;\n+\n+        public ContigEndKmer( final long kVal,\n+                              final Contig contig,\n+                              final ContigOrientation contigEnd ) {\n+            super(kVal);\n+            this.contig = contig;\n+            this.contigOrientation = contigEnd;\n+        }\n+\n+        public Contig getContig() { return contig; }\n+        public ContigOrientation getContigOrientation() { return contigOrientation; }\n+    }\n+\n+    /**\n+     * An unbranched sequence of Kmers.\n+     * Each Kmer (except the last one) has a single successor, which allows enumerating the sequence\n+     * of Kmers in the Contig.  The sequence of base calls in the Contig is just the sequence of kmers\n+     * with the K-1 overlapping calls removed from adjacent kmers.\n+     **/\n+    public interface Contig {\n+        int getId();\n+        CharSequence getSequence();\n+        int getMaxObservations();\n+        KmerAdjacency getFirstKmer();\n+        KmerAdjacency getLastKmer();\n+        List<Contig> getPredecessors();\n+        List<Contig> getSuccessors();\n+        int getComponentId();\n+        int size();\n+        default int getNKmers() { return size() - Kmer.KSIZE + 1; }\n+        Contig rc();\n+        boolean isCyclic();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e2201c1ef4f8ba71f17e169f07756cfe2f1ecb49"}, "originalPosition": 1697}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzc3NjEwNzA2OnYy", "diffSide": "RIGHT", "path": "src/main/java/org/broadinstitute/hellbender/tools/LocalAssembler.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMy0xOVQxNjoyMzoxNVrOI6Hi9g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMy0xOVQxNjoyMzoxNVrOI6Hi9g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5NzgxMTk1OA==", "bodyText": "Minor style thing but I'd find it a bit more readable to use explicit ifs for this, something like:\nif (contig.hasSuccessors() || contig.hasPredecessors()) {\n  for ( final Contig successor : contig.getSuccessors() ) {\n                   traverse(successor, contig,\n                            contigsList, readPaths, contigTransitsMap, traversalSet);\n  }\n  for ( final Contig predecessor : contig.getPredecessors() ) {\n                    traverse(predecessor.rc(), contig.rc(),\n                            contigsList, readPaths, contigTransitsMap, traversalSet);\n   }\n} else {\n  addTraversal(new Traversal(Collections.singletonList(contig)), traversalSet);\n}", "url": "https://github.com/broadinstitute/gatk/pull/6989#discussion_r597811958", "createdAt": "2021-03-19T16:23:15Z", "author": {"login": "cwhelan"}, "path": "src/main/java/org/broadinstitute/hellbender/tools/LocalAssembler.java", "diffHunk": "@@ -0,0 +1,2306 @@\n+package org.broadinstitute.hellbender.tools;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import htsjdk.samtools.Cigar;\n+import htsjdk.samtools.CigarElement;\n+import htsjdk.samtools.CigarOperator;\n+import htsjdk.samtools.SAMUtils;\n+import org.broadinstitute.barclay.argparser.Argument;\n+import org.broadinstitute.barclay.argparser.BetaFeature;\n+import org.broadinstitute.barclay.argparser.CommandLineProgramProperties;\n+import org.broadinstitute.barclay.help.DocumentedFeature;\n+import org.broadinstitute.hellbender.cmdline.StandardArgumentDefinitions;\n+import org.broadinstitute.hellbender.cmdline.programgroups.CoverageAnalysisProgramGroup;\n+import org.broadinstitute.hellbender.exceptions.GATKException;\n+import org.broadinstitute.hellbender.tools.walkers.PairWalker;\n+import org.broadinstitute.hellbender.utils.SimpleInterval;\n+import org.broadinstitute.hellbender.utils.collections.HopscotchSet;\n+import org.broadinstitute.hellbender.utils.gcs.BucketUtils;\n+import org.broadinstitute.hellbender.utils.read.GATKRead;\n+\n+import java.io.BufferedWriter;\n+import java.io.FileWriter;\n+import java.io.IOException;\n+import java.io.OutputStreamWriter;\n+import java.util.*;\n+import java.util.zip.GZIPOutputStream;\n+\n+@DocumentedFeature\n+@CommandLineProgramProperties(\n+        summary = \"experiment\",\n+        oneLineSummary = \"experiment\",\n+        usageExample = \"gatk LocalAssembler\",\n+        programGroup = CoverageAnalysisProgramGroup.class\n+)\n+@BetaFeature\n+public class LocalAssembler extends PairWalker {\n+    public static final byte QMIN = 25;\n+    public static final int MIN_THIN_OBS = 4;\n+    public static final int MIN_GAPFILL_COUNT = 3;\n+    public static final int TOO_MANY_TRAVERSALS = 100000;\n+    public static final int TOO_MANY_SCAFFOLDS = 50000;\n+    public static final int MIN_SV_SIZE = 50;\n+\n+    @Argument(fullName=StandardArgumentDefinitions.OUTPUT_LONG_NAME,\n+            shortName=StandardArgumentDefinitions.OUTPUT_SHORT_NAME,\n+            doc=\"Write outputs to this file name prefix\", optional = true)\n+    public static String output;\n+\n+    @Argument(fullName=\"assembly-name\", doc=\"name of assembly used as a prefix for traversal names\")\n+    public static String assemblyName;\n+\n+    private final List<GATKRead> reads = new ArrayList<>();\n+\n+    @Override public boolean requiresIntervals() { return true; }\n+\n+    @Override public void apply( final GATKRead read, final GATKRead mate ) {\n+        trimOverruns(read, mate);\n+        reads.add(read);\n+        reads.add(mate);\n+    }\n+\n+    @Override public void applyUnpaired( final GATKRead read ) {\n+        reads.add(read);\n+    }\n+\n+    @Override public Object onTraversalSuccess() {\n+        super.onTraversalSuccess(); // flush any incomplete pairs\n+\n+        final int regionSize = getTraversalIntervals().stream().mapToInt(SimpleInterval::size).sum();\n+        final KmerSet<KmerAdjacency> kmerAdjacencySet = new KmerSet<>(10 * regionSize);\n+        kmerizeReads(reads, kmerAdjacencySet);\n+        List<ContigImpl> contigs = buildContigs(kmerAdjacencySet);\n+        connectContigs(contigs);\n+\n+        removeThinContigs(contigs, kmerAdjacencySet);\n+        weldPipes(contigs);\n+        markComponents(contigs);\n+\n+        if ( fillGaps(kmerAdjacencySet, reads) ) {\n+            contigs = buildContigs(kmerAdjacencySet);\n+            connectContigs(contigs);\n+            removeThinContigs(contigs, kmerAdjacencySet);\n+            weldPipes(contigs);\n+            markComponents(contigs);\n+        }\n+\n+        markCycles(contigs);\n+\n+        final String outputFilePrefix = output != null ? output : assemblyName;\n+        final List<Path> readPaths = pathReads(kmerAdjacencySet, reads);\n+        final Map<Contig,List<TransitPairCount>> contigTransitsMap =\n+                collectTransitPairCounts(contigs, readPaths);\n+        final String traversalsFilename = outputFilePrefix + \".traversals.fa.gz\";\n+        try {\n+            final List<Traversal> allTraversals =\n+                    new ArrayList<>(traverseAllPaths(contigs, readPaths, contigTransitsMap));\n+            writeTraversals(allTraversals, traversalsFilename);\n+            try {\n+                final String scaffoldsFileName = outputFilePrefix + \".scaffolds.fa.gz\";\n+                writeTraversals(createScaffolds(allTraversals), scaffoldsFileName);\n+            } catch ( final AssemblyTooComplexException x ) {\n+                logger.warn(\"Assembly too complex for scaffolding.\");\n+            }\n+        } catch ( final AssemblyTooComplexException x ) {\n+            logger.warn(\"Assembly too complex.  Writing contigs as traversals in \" +\n+                    traversalsFilename + \".\");\n+            final Collection<Traversal> contigTraversals = new ArrayList<>(contigs.size());\n+            for ( final Contig contig : contigs ) {\n+                contigTraversals.add(new Traversal(Collections.singletonList(contig)));\n+            }\n+            writeTraversals(contigTraversals, traversalsFilename);\n+        }\n+\n+        contigs.sort(Comparator.comparingInt(ContigImpl::getId));\n+        writeDOT(contigs, outputFilePrefix + \".assembly.dot\");\n+        writeContigs(contigs, outputFilePrefix + \".contigs.txt.gz\");\n+        writePaths(readPaths, outputFilePrefix + \".paths.txt.gz\");\n+        writeReads(reads, outputFilePrefix + \".reads.fastq.gz\");\n+        return null;\n+    }\n+\n+    /** trim read pairs of base calls that have gone past the end of a short fragment */\n+    private void trimOverruns( final GATKRead read, final GATKRead mate ) {\n+        // if both mapped and they're on different strands\n+        if ( !read.isUnmapped() && !mate.isUnmapped() &&\n+                read.isReverseStrand() != mate.isReverseStrand() ) {\n+            // and both start within 1 base on the ref\n+            if ( Math.abs(read.getStart() - read.getMateStart()) <= 1 ) {\n+                // and both end within 1 base\n+                final int readRefLen = read.getCigar().getReferenceLength();\n+                final int mateRefLen = mate.getCigar().getReferenceLength();\n+                if ( Math.abs(readRefLen - mateRefLen) <= 1 ) {\n+                    if ( mate.isReverseStrand() ) {\n+                        trimClips(read, mate);\n+                    } else {\n+                        trimClips(mate, read);\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    private void trimClips( final GATKRead fwd, final GATKRead rev ) {\n+        final List<CigarElement> fwdElements = fwd.getCigarElements();\n+        final List<CigarElement> revElements = rev.getCigarElements();\n+        final int lastElementIdx = fwdElements.size() - 1;\n+        final CigarElement fwdLastElement = fwdElements.get(lastElementIdx);\n+        final CigarElement revFirstElement = revElements.get(0);\n+        if ( fwdLastElement.getOperator() == CigarOperator.S &&\n+                revFirstElement.getOperator() == CigarOperator.S ) {\n+            final byte[] fwdBases = fwd.getBasesNoCopy();\n+            final int lastElementLen = fwdLastElement.getLength();\n+            fwd.setBases(Arrays.copyOfRange(fwdBases, 0, fwdBases.length - lastElementLen));\n+            final byte[] fwdQuals = fwd.getBaseQualitiesNoCopy();\n+            if ( fwdQuals.length > 0 ) {\n+                final int qualsLen = fwdQuals.length - lastElementLen;\n+                fwd.setBaseQualities(Arrays.copyOfRange(fwdQuals, 0, qualsLen));\n+            }\n+            final List<CigarElement> newFwdElements = new ArrayList<>(fwdElements);\n+            newFwdElements.set(lastElementIdx, new CigarElement(lastElementLen, CigarOperator.H));\n+            fwd.setCigar(new Cigar(newFwdElements));\n+\n+            final byte[] revBases = rev.getBasesNoCopy();\n+            final int firstElementLen = revFirstElement.getLength();\n+            rev.setBases(Arrays.copyOfRange(revBases, firstElementLen, revBases.length));\n+            final byte[] revQuals = rev.getBaseQualitiesNoCopy();\n+            if ( revQuals.length > 0 ) {\n+                rev.setBaseQualities(Arrays.copyOfRange(revQuals, firstElementLen, revQuals.length));\n+            }\n+            final List<CigarElement> newRevElements = new ArrayList<>(revElements);\n+            newRevElements.set(0, new CigarElement(firstElementLen, CigarOperator.H));\n+            rev.setCigar(new Cigar(newRevElements));\n+        }\n+    }\n+\n+    @VisibleForTesting\n+    static void kmerizeReads( final List<GATKRead> reads,\n+                              final KmerSet<KmerAdjacency> kmerAdjacencySet ) {\n+        for ( final GATKRead read : reads ) {\n+            final byte[] calls = read.getBasesNoCopy();\n+            final byte[] quals = read.getBaseQualitiesNoCopy();\n+            KmerAdjacency.kmerize(calls, quals, QMIN, kmerAdjacencySet);\n+        }\n+    }\n+\n+    /** gather unbranched strings of kmers into contigs **/\n+    @VisibleForTesting\n+    static List<ContigImpl> buildContigs( final KmerSet<KmerAdjacency> kmerAdjacencySet ) {\n+        // gather strings of kmers that have a single predecessor and single successor into contigs\n+        final List<ContigImpl> contigs = new ArrayList<>();\n+        int nContigs = 0;\n+        for ( final KmerAdjacency kmerAdjacency : kmerAdjacencySet ) {\n+            if ( kmerAdjacency.getContig() == null ) {\n+                ContigImpl contig = null;\n+                final KmerAdjacency predecessor = kmerAdjacency.getSolePredecessor();\n+                if ( predecessor == null ||\n+                        predecessor.getSuccessorCount() > 1 ||\n+                        predecessor == kmerAdjacency.rc() ) {\n+                    contig = new ContigImpl(++nContigs, kmerAdjacency);\n+                } else {\n+                    final KmerAdjacency successor = kmerAdjacency.getSoleSuccessor();\n+                    if ( successor == null ||\n+                            successor.getPredecessorCount() > 1 ||\n+                            successor == kmerAdjacency.rc() ) {\n+                        contig = new ContigImpl(++nContigs, kmerAdjacency.rc());\n+                    }\n+                }\n+                if ( contig != null ) {\n+                    contigs.add(contig);\n+                }\n+            }\n+        }\n+\n+        // if there are smooth circles like a plasmid, gather them together as a contig, too\n+        for ( final KmerAdjacency kmerAdjacency : kmerAdjacencySet ) {\n+            if ( kmerAdjacency.getContig() == null ) {\n+                contigs.add(new ContigImpl(++nContigs, kmerAdjacency));\n+            }\n+        }\n+\n+        return contigs;\n+    }\n+\n+    /** connect contigs when the final kmer of one contig is adjacent to the inital contig of another **/\n+    @VisibleForTesting\n+    static void connectContigs( final List<ContigImpl> contigs ) {\n+        final int nContigs = contigs.size();\n+        final KmerSet<ContigEndKmer> contigEnds = new KmerSet<>(2*nContigs);\n+        for ( int contigId = 0; contigId != nContigs; ++contigId ) {\n+            final ContigImpl contig = contigs.get(contigId);\n+            final KmerAdjacency fwdKmer = contig.getFirstKmer();\n+            final KmerAdjacency revKmer = contig.getLastKmer().rc();\n+            if ( fwdKmer == revKmer ) {\n+                contigEnds.add(new ContigEndKmer(fwdKmer.getKVal(), contig, ContigOrientation.BOTH));\n+            } else {\n+                contigEnds.add(new ContigEndKmer(fwdKmer.getKVal(), contig, ContigOrientation.FWD));\n+                contigEnds.add(new ContigEndKmer(revKmer.getKVal(), contig, ContigOrientation.REV));\n+            }\n+        }\n+\n+        for ( int contigId = 0; contigId != nContigs; ++contigId ) {\n+            final Contig contig = contigs.get(contigId);\n+\n+            final KmerAdjacency start = contig.getFirstKmer();\n+            final int predecessorCount = start.getPredecessorCount();\n+            if ( predecessorCount > 0 ) {\n+                final List<Contig> predecessors = contig.getPredecessors();\n+                final int mask = start.getPredecessorMask();\n+                for ( int call = 0; call != 4; ++call ) {\n+                    if ( (mask & (1 << call)) != 0 ) {\n+                        final long kVal =\n+                                KmerAdjacency.reverseComplement(start.getPredecessorVal(call));\n+                        final ContigEndKmer contigEndKmer = contigEnds.find(new Kmer(kVal));\n+                        if ( contigEndKmer == null ) {\n+                            throw new GATKException(\"missing contig end kmer\");\n+                        }\n+                        switch ( contigEndKmer.getContigOrientation() ) {\n+                            case FWD:\n+                                predecessors.add(contigEndKmer.getContig().rc());\n+                                break;\n+                            case REV:\n+                                predecessors.add(contigEndKmer.getContig());\n+                                break;\n+                            case BOTH:\n+                                predecessors.add(contigEndKmer.getContig());\n+                                predecessors.add(contigEndKmer.getContig().rc());\n+                                break;\n+                        }\n+                    }\n+                }\n+            }\n+\n+            final KmerAdjacency end = contig.getLastKmer();\n+            final int successorCount = end.getSuccessorCount();\n+            if ( successorCount > 0 ) {\n+                final List<Contig> successors = contig.getSuccessors();\n+                final int mask = end.getSuccessorMask();\n+                for ( int call = 0; call != 4; ++call ) {\n+                    if ( (mask & (1 << call)) != 0 ) {\n+                        final long kVal = end.getSuccessorVal(call);\n+                        final ContigEndKmer contigEndKmer = contigEnds.find(new Kmer(kVal));\n+                        if ( contigEndKmer == null ) {\n+                            throw new GATKException(\"missing contig end kmer\");\n+                        }\n+                        switch ( contigEndKmer.getContigOrientation() ) {\n+                            case FWD:\n+                                successors.add(contigEndKmer.getContig());\n+                                break;\n+                            case REV:\n+                                successors.add(contigEndKmer.getContig().rc());\n+                                break;\n+                            case BOTH:\n+                                successors.add(contigEndKmer.getContig());\n+                                successors.add(contigEndKmer.getContig().rc());\n+                                break;\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    /** remove contigs that have little evidence **/\n+    @VisibleForTesting\n+    static void removeThinContigs( final List<ContigImpl> contigs,\n+                                           final KmerSet<KmerAdjacency> kmerAdjacencySet ) {\n+        contigs.sort(Comparator.comparingInt(ContigImpl::getMaxObservations));\n+        boolean contigRemoved;\n+        do {\n+            // figure out which contigs are cut points\n+            // i.e., those contigs which, if removed, would result in a graph with more connected components\n+            final int nContigs = contigs.size();\n+            final Map<Contig, CutData> cutDataMap = new HashMap<>(nContigs * 3);\n+\n+            for ( final ContigImpl contig : contigs ) {\n+                if ( cutDataMap.containsKey(contig) ) {\n+                    continue;\n+                }\n+\n+                cutDataMap.put(contig, new CutData());\n+                int children = 0;\n+                for ( final Contig nextContig : contig.getSuccessors() ) {\n+                    if ( !cutDataMap.containsKey(nextContig) ) {\n+                        findCuts(nextContig, contig, cutDataMap);\n+                        children += 1;\n+                    }\n+                }\n+                for ( final Contig nextContig : contig.getPredecessors() ) {\n+                    if ( !cutDataMap.containsKey(nextContig) ) {\n+                        findCuts(nextContig, contig, cutDataMap);\n+                        children += 1;\n+                    }\n+                }\n+                if ( children >= 2 ) {\n+                    contig.setCut(true);\n+                }\n+            }\n+\n+            // remove poorly attested (low max observations) contigs, unless they are cut points\n+            contigRemoved = false;\n+            final Iterator<ContigImpl> itr = contigs.iterator();\n+            while ( itr.hasNext() ) {\n+                final Contig contig = itr.next();\n+                if ( contig.getMaxObservations() < MIN_THIN_OBS && !contig.isCut() ) {\n+                    unlinkContig(contig, kmerAdjacencySet);\n+                    itr.remove();\n+                    contigRemoved = true;\n+                    break;\n+                }\n+            }\n+        } while ( contigRemoved );\n+        contigs.sort(Comparator.comparingInt(ContigImpl::getId));\n+    }\n+\n+    private static CutData findCuts( final Contig contig,\n+                                     final Contig parent,\n+                                     final Map<Contig, CutData> cutDataMap ) {\n+        final CutData cutData = new CutData();\n+        cutDataMap.put(contig, cutData);\n+        for ( final Contig nextContig : contig.getSuccessors() ) {\n+            if ( nextContig == parent ) {\n+                continue;\n+            }\n+            CutData nextCutData = cutDataMap.get(nextContig);\n+            if ( nextCutData != null ) {\n+                cutData.minVisitNum = Math.min(cutData.minVisitNum, nextCutData.visitNum);\n+            } else {\n+                nextCutData = findCuts(nextContig, contig, cutDataMap);\n+                cutData.minVisitNum = Math.min(cutData.minVisitNum, nextCutData.minVisitNum);\n+                if ( nextCutData.minVisitNum >= cutData.visitNum ) {\n+                    contig.setCut(true);\n+                }\n+            }\n+        }\n+        for ( final Contig nextContig : contig.getPredecessors() ) {\n+            if ( nextContig == parent ) {\n+                continue;\n+            }\n+            CutData nextCutData = cutDataMap.get(nextContig);\n+            if ( nextCutData != null ) {\n+                cutData.minVisitNum = Math.min(cutData.minVisitNum, nextCutData.visitNum);\n+            } else {\n+                nextCutData = findCuts(nextContig, contig, cutDataMap);\n+                cutData.minVisitNum = Math.min(cutData.minVisitNum, nextCutData.minVisitNum);\n+                if ( nextCutData.minVisitNum >= cutData.visitNum ) {\n+                    contig.setCut(true);\n+                }\n+            }\n+        }\n+        return cutData;\n+    }\n+\n+    @VisibleForTesting\n+    static void unlinkContig( final Contig contig,\n+                                      final KmerSet<KmerAdjacency> kmerAdjacencySet ) {\n+        final KmerAdjacency firstKmer = contig.getFirstKmer();\n+        final int firstKmerFinalCall = firstKmer.getFinalCall();\n+        for ( final Contig predecessor : contig.getPredecessors() ) {\n+            if ( predecessor != contig && predecessor != contig.rc() ) {\n+                predecessor.getLastKmer().removeSuccessor(firstKmerFinalCall, kmerAdjacencySet);\n+                if ( !predecessor.getSuccessors().remove(contig) ) {\n+                    throw new GATKException(\"failed to find predecessor link\");\n+                }\n+            }\n+        }\n+\n+        final KmerAdjacency lastKmer = contig.getLastKmer();\n+        final int lastKmerInitialCall = lastKmer.getInitialCall();\n+        for ( final Contig successor : contig.getSuccessors() ) {\n+            if ( successor != contig && successor != contig.rc() ) {\n+                successor.getFirstKmer().removePredecessor(lastKmerInitialCall, kmerAdjacencySet);\n+                if ( !successor.getPredecessors().remove(contig) ) {\n+                    throw new GATKException(\"failed to find successor link\");\n+                }\n+            }\n+        }\n+\n+        KmerAdjacency nextKmer = firstKmer;\n+        KmerAdjacency kmer;\n+        do {\n+            kmer = nextKmer;\n+            nextKmer = kmer.getSoleSuccessor();\n+            kmerAdjacencySet.remove(kmer.canonical());\n+        } while ( kmer != lastKmer );\n+    }\n+\n+    private static void updateKmerContig( final KmerAdjacency firstKmer,\n+                                          final KmerAdjacency lastKmer,\n+                                          final Contig contig ) {\n+        int offset = 0;\n+        for ( KmerAdjacency kmer = firstKmer; kmer != lastKmer; kmer = kmer.getSoleSuccessor() ) {\n+            if ( kmer == null ) {\n+                throw new GATKException(\"contig does not have a flat pipeline of kmers\");\n+            }\n+            kmer.clearContig();\n+            kmer.setContigOffset(contig, offset++);\n+        }\n+        lastKmer.clearContig();\n+        lastKmer.setContigOffset(contig, offset);\n+        if ( offset + Kmer.KSIZE != contig.size() ) {\n+            throw new GATKException(\"kmer chain length does not equal contig size\");\n+        }\n+    }\n+\n+    /** replace adjacent contigs without branches with a single, larger contig **/\n+    @VisibleForTesting\n+    static void weldPipes( final List<ContigImpl> contigs ) {\n+        for ( int contigIdx = 0; contigIdx != contigs.size(); ++contigIdx ) {\n+            final ContigImpl contig = contigs.get(contigIdx);\n+            if ( contig.getSuccessors().size() == 1 ) {\n+                final Contig successor = contig.getSuccessors().get(0);\n+                if ( successor != contig && successor != contig.rc() &&\n+                        successor.getPredecessors().size() == 1 ) {\n+                    contigs.set(contigIdx, join(contig.getId(), contig, successor));\n+                    if ( !contigs.remove(successor.canonical()) ) {\n+                        throw new GATKException(\"successor linkage is messed up\");\n+                    }\n+                    contigIdx -= 1; // reconsider the new contig -- there might be more joining possible\n+                    continue;\n+                }\n+            }\n+            if ( contig.getPredecessors().size() == 1 ) {\n+                final Contig predecessor = contig.getPredecessors().get(0);\n+                if ( predecessor != contig && predecessor != contig.rc() &&\n+                        predecessor.getSuccessors().size() == 1 ) {\n+                    contigs.set(contigIdx, join(contig.getId(), predecessor, contig));\n+                    if ( !contigs.remove(predecessor.canonical()) ) {\n+                        throw new GATKException(\"predecessor linkage is messed up\");\n+                    }\n+                    contigIdx -= 1; // reconsider\n+                }\n+            }\n+        }\n+    }\n+\n+    private static ContigImpl join( final int id, final Contig predecessor, final Contig successor ) {\n+        if ( !checkOverlap(predecessor.getSequence(), successor.getSequence()) ) {\n+                throw new GATKException(\"sequences can't be joined\");\n+        }\n+        final ContigImpl joinedContig = new ContigImpl(id, predecessor, successor);\n+        updateKmerContig(joinedContig.getFirstKmer(), joinedContig.getLastKmer(), joinedContig);\n+        return joinedContig;\n+    }\n+\n+    private static boolean checkOverlap( final CharSequence seq1, final CharSequence seq2 ) {\n+        final int seq1Len = seq1.length();\n+        final CharSequence seq1SubSeq = seq1.subSequence(seq1Len - Kmer.KSIZE + 1, seq1Len);\n+        final CharSequence seq2SubSeq = seq2.subSequence(0, Kmer.KSIZE - 1);\n+        return seq1SubSeq.equals(seq2SubSeq);\n+    }\n+\n+    /** set a unique componentId for every connected group of contigs **/\n+    @VisibleForTesting\n+    static int markComponents( final List<ContigImpl> contigs ) {\n+        for ( final ContigImpl contig : contigs ) {\n+            contig.setComponentId(0);\n+        }\n+\n+        int componentId = 0;\n+        for ( final ContigImpl contig : contigs ) {\n+            if ( contig.getComponentId() == 0 ) {\n+                contig.setComponentId(++componentId);\n+                markSuccessorComponents(contig);\n+                markSuccessorComponents(contig.rc());\n+            }\n+        }\n+        return componentId;\n+    }\n+\n+    private static void markSuccessorComponents( final Contig contig ) {\n+        final int componentId = contig.getComponentId();\n+        for ( final Contig successor : contig.getSuccessors() ) {\n+            if ( successor.getComponentId() == 0 ) {\n+                successor.canonical().setComponentId(componentId);\n+                markSuccessorComponents(successor);\n+                markSuccessorComponents(successor.rc());\n+            }\n+        }\n+    }\n+\n+    @VisibleForTesting\n+    static void markCycles( final List<ContigImpl> contigs ) {\n+        for ( final Contig contig : contigs ) {\n+            contig.setCyclic(false);\n+        }\n+\n+        final int nContigs = contigs.size();\n+        final Deque<Contig> deque = new ArrayDeque<>(nContigs);\n+        final Map<Contig, CutData> cutDataMap = new HashMap<>(nContigs * 3);\n+        for ( final Contig contig : contigs ) {\n+            if ( !cutDataMap.containsKey(contig) ) {\n+                markCyclesRecursion(contig, deque, cutDataMap);\n+            }\n+        }\n+    }\n+\n+    private static CutData markCyclesRecursion( final Contig contig,\n+                                                final Deque<Contig> deque,\n+                                                final Map<Contig, CutData> cutDataMap ) {\n+        final CutData cutData = new CutData();\n+        cutDataMap.put(contig, cutData);\n+        deque.addFirst(contig);\n+\n+        for ( final Contig successor : contig.getSuccessors() ) {\n+            final CutData successorCutData = cutDataMap.get(successor);\n+            if ( successorCutData == null ) {\n+                final int recursionVisitNum =\n+                        markCyclesRecursion(successor, deque, cutDataMap).minVisitNum;\n+                cutData.minVisitNum = Math.min(cutData.minVisitNum, recursionVisitNum);\n+            } else {\n+                cutData.minVisitNum = Math.min(cutData.minVisitNum, successorCutData.visitNum);\n+            }\n+        }\n+\n+        if ( cutData.visitNum == cutData.minVisitNum ) {\n+            Contig tig = deque.removeFirst();\n+            if ( tig == contig ) {\n+                cutDataMap.get(tig).visitNum = Integer.MAX_VALUE;\n+\n+                // single-vertex component -- cyclic only if self-referential\n+                if ( tig.getSuccessors().contains(tig) ) {\n+                    tig.setCyclic(true);\n+                }\n+            } else {\n+                while ( true ) {\n+                    // kill cross-links\n+                    cutDataMap.get(tig).visitNum = Integer.MAX_VALUE;\n+                    tig.setCyclic(true);\n+                    if ( tig == contig ) break;\n+                    tig = deque.removeFirst();\n+                }\n+            }\n+        }\n+        return cutData;\n+    }\n+\n+    @VisibleForTesting\n+    static boolean fillGaps( final KmerSet<KmerAdjacency> kmerAdjacencySet,\n+                             final List<GATKRead> reads ) {\n+        final Map<String, Integer> gapFillCounts = new HashMap<>();\n+        for ( final GATKRead read : reads ) {\n+            final Path path = new Path(read.getBasesNoCopy(), kmerAdjacencySet);\n+            final List<PathPart> parts = path.getParts();\n+            final int lastIdx = parts.size() - 1;\n+            for ( int idx = 1; idx < lastIdx; ++idx ) {\n+                final PathPart pathPart = parts.get(idx);\n+                if ( pathPart.isGap() ) {\n+                    final char prevCall = parts.get(idx - 1).getLastCall();\n+                    final char nextCall = parts.get(idx + 1).getFirstCall();\n+                    String gapFill = prevCall + pathPart.getSequence().toString() + nextCall;\n+                    final SequenceRC gapFillRC = new SequenceRC(gapFill);\n+                    if ( gapFillRC.compareTo(gapFill) < 0 ) {\n+                        gapFill = gapFillRC.toString();\n+                    }\n+                    gapFillCounts.merge(gapFill, 1, Integer::sum);\n+                }\n+            }\n+        }\n+\n+        boolean newKmers = false;\n+        for ( final Map.Entry<String, Integer> entry : gapFillCounts.entrySet() ) {\n+            final int nObservations = entry.getValue();\n+            if ( nObservations >= MIN_GAPFILL_COUNT ) {\n+                KmerAdjacency.kmerize(entry.getKey(), nObservations, kmerAdjacencySet);\n+                newKmers = true;\n+            }\n+        }\n+\n+        if ( newKmers ) {\n+            for ( final KmerAdjacency kmerAdjacency : kmerAdjacencySet ) {\n+                kmerAdjacency.clearContig();\n+            }\n+        }\n+        return newKmers;\n+    }\n+\n+    @VisibleForTesting\n+    static List<Path> pathReads( final KmerSet<KmerAdjacency> kmerAdjacencySet,\n+                          final List<GATKRead> reads ) {\n+        final List<Path> readPaths = new ArrayList<>(reads.size());\n+        for ( final GATKRead read : reads ) {\n+            readPaths.add(new Path(read.getBasesNoCopy(), kmerAdjacencySet));\n+        }\n+        return readPaths;\n+    }\n+\n+    @VisibleForTesting\n+    static Map<Contig,List<TransitPairCount>> collectTransitPairCounts(\n+            final List<ContigImpl> contigs,\n+            final List<Path> readPaths ) {\n+        final Map<Contig,List<TransitPairCount>> contigTransitsMap =\n+                new HashMap<>(3 * contigs.size());\n+        for ( final Path path : readPaths ) {\n+            final List<PathPart> parts = path.getParts();\n+            final int lastPart = parts.size() - 1;\n+            for ( int partIdx = 1; partIdx < lastPart; ++partIdx ) {\n+                final Contig prevContig = parts.get(partIdx - 1).getContig();\n+                if ( prevContig == null ) continue;\n+                final Contig curContig = parts.get(partIdx).getContig();\n+                if ( curContig == null ) {\n+                    partIdx += 1;\n+                    continue;\n+                }\n+                final Contig nextContig = parts.get(partIdx + 1).getContig();\n+                if ( nextContig == null ) {\n+                    partIdx += 2;\n+                    continue;\n+                }\n+                final TransitPairCount tpc = new TransitPairCount(prevContig, nextContig);\n+                final List<TransitPairCount> tpcList =\n+                        contigTransitsMap.computeIfAbsent(curContig, tig -> new ArrayList<>(4));\n+                final int idx = tpcList.indexOf(tpc);\n+                if ( idx != -1 ) {\n+                    tpcList.get(idx).observe();\n+                } else {\n+                    tpcList.add(tpc);\n+                    contigTransitsMap.computeIfAbsent(curContig.rc(), tig -> new ArrayList<>(4))\n+                            .add(tpc.getRC());\n+                }\n+            }\n+        }\n+        return contigTransitsMap;\n+    }\n+\n+    @VisibleForTesting\n+    static Set<Traversal> traverseAllPaths(\n+            final List<ContigImpl> contigs,\n+            final List<Path> readPaths,\n+            final Map<Contig, List<TransitPairCount>> contigTransitsMap ) {\n+        final Set<Traversal> traversalSet = new HashSet<>();\n+        final List<Contig> contigsList = new ArrayList<>();\n+        for ( final Contig contig : contigs ) {\n+            // untransited contigs are sources, sinks, or large contigs that can't be crossed by a read\n+            // build traversals from these\n+            if ( !contigTransitsMap.containsKey(contig) ) {\n+                boolean done = false;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e2201c1ef4f8ba71f17e169f07756cfe2f1ecb49"}, "originalPosition": 676}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzc3NjE4OTg4OnYy", "diffSide": "RIGHT", "path": "src/main/java/org/broadinstitute/hellbender/tools/LocalAssembler.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMy0xOVQxNjo0Mjo0MFrOI6IXWA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNC0xNlQxNDowMzowM1rOJKYQ8A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5NzgyNTM2OA==", "bodyText": "This method is making some assumptions about prefixes and suffixes -- that if the first suffix isn't part of a cycle, overlap between the two lists is limited to the last prefix / first suffix. Can you give it a more descriptive name and add a comment to highlight that fact?", "url": "https://github.com/broadinstitute/gatk/pull/6989#discussion_r597825368", "createdAt": "2021-03-19T16:42:40Z", "author": {"login": "cwhelan"}, "path": "src/main/java/org/broadinstitute/hellbender/tools/LocalAssembler.java", "diffHunk": "@@ -0,0 +1,2306 @@\n+package org.broadinstitute.hellbender.tools;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import htsjdk.samtools.Cigar;\n+import htsjdk.samtools.CigarElement;\n+import htsjdk.samtools.CigarOperator;\n+import htsjdk.samtools.SAMUtils;\n+import org.broadinstitute.barclay.argparser.Argument;\n+import org.broadinstitute.barclay.argparser.BetaFeature;\n+import org.broadinstitute.barclay.argparser.CommandLineProgramProperties;\n+import org.broadinstitute.barclay.help.DocumentedFeature;\n+import org.broadinstitute.hellbender.cmdline.StandardArgumentDefinitions;\n+import org.broadinstitute.hellbender.cmdline.programgroups.CoverageAnalysisProgramGroup;\n+import org.broadinstitute.hellbender.exceptions.GATKException;\n+import org.broadinstitute.hellbender.tools.walkers.PairWalker;\n+import org.broadinstitute.hellbender.utils.SimpleInterval;\n+import org.broadinstitute.hellbender.utils.collections.HopscotchSet;\n+import org.broadinstitute.hellbender.utils.gcs.BucketUtils;\n+import org.broadinstitute.hellbender.utils.read.GATKRead;\n+\n+import java.io.BufferedWriter;\n+import java.io.FileWriter;\n+import java.io.IOException;\n+import java.io.OutputStreamWriter;\n+import java.util.*;\n+import java.util.zip.GZIPOutputStream;\n+\n+@DocumentedFeature\n+@CommandLineProgramProperties(\n+        summary = \"experiment\",\n+        oneLineSummary = \"experiment\",\n+        usageExample = \"gatk LocalAssembler\",\n+        programGroup = CoverageAnalysisProgramGroup.class\n+)\n+@BetaFeature\n+public class LocalAssembler extends PairWalker {\n+    public static final byte QMIN = 25;\n+    public static final int MIN_THIN_OBS = 4;\n+    public static final int MIN_GAPFILL_COUNT = 3;\n+    public static final int TOO_MANY_TRAVERSALS = 100000;\n+    public static final int TOO_MANY_SCAFFOLDS = 50000;\n+    public static final int MIN_SV_SIZE = 50;\n+\n+    @Argument(fullName=StandardArgumentDefinitions.OUTPUT_LONG_NAME,\n+            shortName=StandardArgumentDefinitions.OUTPUT_SHORT_NAME,\n+            doc=\"Write outputs to this file name prefix\", optional = true)\n+    public static String output;\n+\n+    @Argument(fullName=\"assembly-name\", doc=\"name of assembly used as a prefix for traversal names\")\n+    public static String assemblyName;\n+\n+    private final List<GATKRead> reads = new ArrayList<>();\n+\n+    @Override public boolean requiresIntervals() { return true; }\n+\n+    @Override public void apply( final GATKRead read, final GATKRead mate ) {\n+        trimOverruns(read, mate);\n+        reads.add(read);\n+        reads.add(mate);\n+    }\n+\n+    @Override public void applyUnpaired( final GATKRead read ) {\n+        reads.add(read);\n+    }\n+\n+    @Override public Object onTraversalSuccess() {\n+        super.onTraversalSuccess(); // flush any incomplete pairs\n+\n+        final int regionSize = getTraversalIntervals().stream().mapToInt(SimpleInterval::size).sum();\n+        final KmerSet<KmerAdjacency> kmerAdjacencySet = new KmerSet<>(10 * regionSize);\n+        kmerizeReads(reads, kmerAdjacencySet);\n+        List<ContigImpl> contigs = buildContigs(kmerAdjacencySet);\n+        connectContigs(contigs);\n+\n+        removeThinContigs(contigs, kmerAdjacencySet);\n+        weldPipes(contigs);\n+        markComponents(contigs);\n+\n+        if ( fillGaps(kmerAdjacencySet, reads) ) {\n+            contigs = buildContigs(kmerAdjacencySet);\n+            connectContigs(contigs);\n+            removeThinContigs(contigs, kmerAdjacencySet);\n+            weldPipes(contigs);\n+            markComponents(contigs);\n+        }\n+\n+        markCycles(contigs);\n+\n+        final String outputFilePrefix = output != null ? output : assemblyName;\n+        final List<Path> readPaths = pathReads(kmerAdjacencySet, reads);\n+        final Map<Contig,List<TransitPairCount>> contigTransitsMap =\n+                collectTransitPairCounts(contigs, readPaths);\n+        final String traversalsFilename = outputFilePrefix + \".traversals.fa.gz\";\n+        try {\n+            final List<Traversal> allTraversals =\n+                    new ArrayList<>(traverseAllPaths(contigs, readPaths, contigTransitsMap));\n+            writeTraversals(allTraversals, traversalsFilename);\n+            try {\n+                final String scaffoldsFileName = outputFilePrefix + \".scaffolds.fa.gz\";\n+                writeTraversals(createScaffolds(allTraversals), scaffoldsFileName);\n+            } catch ( final AssemblyTooComplexException x ) {\n+                logger.warn(\"Assembly too complex for scaffolding.\");\n+            }\n+        } catch ( final AssemblyTooComplexException x ) {\n+            logger.warn(\"Assembly too complex.  Writing contigs as traversals in \" +\n+                    traversalsFilename + \".\");\n+            final Collection<Traversal> contigTraversals = new ArrayList<>(contigs.size());\n+            for ( final Contig contig : contigs ) {\n+                contigTraversals.add(new Traversal(Collections.singletonList(contig)));\n+            }\n+            writeTraversals(contigTraversals, traversalsFilename);\n+        }\n+\n+        contigs.sort(Comparator.comparingInt(ContigImpl::getId));\n+        writeDOT(contigs, outputFilePrefix + \".assembly.dot\");\n+        writeContigs(contigs, outputFilePrefix + \".contigs.txt.gz\");\n+        writePaths(readPaths, outputFilePrefix + \".paths.txt.gz\");\n+        writeReads(reads, outputFilePrefix + \".reads.fastq.gz\");\n+        return null;\n+    }\n+\n+    /** trim read pairs of base calls that have gone past the end of a short fragment */\n+    private void trimOverruns( final GATKRead read, final GATKRead mate ) {\n+        // if both mapped and they're on different strands\n+        if ( !read.isUnmapped() && !mate.isUnmapped() &&\n+                read.isReverseStrand() != mate.isReverseStrand() ) {\n+            // and both start within 1 base on the ref\n+            if ( Math.abs(read.getStart() - read.getMateStart()) <= 1 ) {\n+                // and both end within 1 base\n+                final int readRefLen = read.getCigar().getReferenceLength();\n+                final int mateRefLen = mate.getCigar().getReferenceLength();\n+                if ( Math.abs(readRefLen - mateRefLen) <= 1 ) {\n+                    if ( mate.isReverseStrand() ) {\n+                        trimClips(read, mate);\n+                    } else {\n+                        trimClips(mate, read);\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    private void trimClips( final GATKRead fwd, final GATKRead rev ) {\n+        final List<CigarElement> fwdElements = fwd.getCigarElements();\n+        final List<CigarElement> revElements = rev.getCigarElements();\n+        final int lastElementIdx = fwdElements.size() - 1;\n+        final CigarElement fwdLastElement = fwdElements.get(lastElementIdx);\n+        final CigarElement revFirstElement = revElements.get(0);\n+        if ( fwdLastElement.getOperator() == CigarOperator.S &&\n+                revFirstElement.getOperator() == CigarOperator.S ) {\n+            final byte[] fwdBases = fwd.getBasesNoCopy();\n+            final int lastElementLen = fwdLastElement.getLength();\n+            fwd.setBases(Arrays.copyOfRange(fwdBases, 0, fwdBases.length - lastElementLen));\n+            final byte[] fwdQuals = fwd.getBaseQualitiesNoCopy();\n+            if ( fwdQuals.length > 0 ) {\n+                final int qualsLen = fwdQuals.length - lastElementLen;\n+                fwd.setBaseQualities(Arrays.copyOfRange(fwdQuals, 0, qualsLen));\n+            }\n+            final List<CigarElement> newFwdElements = new ArrayList<>(fwdElements);\n+            newFwdElements.set(lastElementIdx, new CigarElement(lastElementLen, CigarOperator.H));\n+            fwd.setCigar(new Cigar(newFwdElements));\n+\n+            final byte[] revBases = rev.getBasesNoCopy();\n+            final int firstElementLen = revFirstElement.getLength();\n+            rev.setBases(Arrays.copyOfRange(revBases, firstElementLen, revBases.length));\n+            final byte[] revQuals = rev.getBaseQualitiesNoCopy();\n+            if ( revQuals.length > 0 ) {\n+                rev.setBaseQualities(Arrays.copyOfRange(revQuals, firstElementLen, revQuals.length));\n+            }\n+            final List<CigarElement> newRevElements = new ArrayList<>(revElements);\n+            newRevElements.set(0, new CigarElement(firstElementLen, CigarOperator.H));\n+            rev.setCigar(new Cigar(newRevElements));\n+        }\n+    }\n+\n+    @VisibleForTesting\n+    static void kmerizeReads( final List<GATKRead> reads,\n+                              final KmerSet<KmerAdjacency> kmerAdjacencySet ) {\n+        for ( final GATKRead read : reads ) {\n+            final byte[] calls = read.getBasesNoCopy();\n+            final byte[] quals = read.getBaseQualitiesNoCopy();\n+            KmerAdjacency.kmerize(calls, quals, QMIN, kmerAdjacencySet);\n+        }\n+    }\n+\n+    /** gather unbranched strings of kmers into contigs **/\n+    @VisibleForTesting\n+    static List<ContigImpl> buildContigs( final KmerSet<KmerAdjacency> kmerAdjacencySet ) {\n+        // gather strings of kmers that have a single predecessor and single successor into contigs\n+        final List<ContigImpl> contigs = new ArrayList<>();\n+        int nContigs = 0;\n+        for ( final KmerAdjacency kmerAdjacency : kmerAdjacencySet ) {\n+            if ( kmerAdjacency.getContig() == null ) {\n+                ContigImpl contig = null;\n+                final KmerAdjacency predecessor = kmerAdjacency.getSolePredecessor();\n+                if ( predecessor == null ||\n+                        predecessor.getSuccessorCount() > 1 ||\n+                        predecessor == kmerAdjacency.rc() ) {\n+                    contig = new ContigImpl(++nContigs, kmerAdjacency);\n+                } else {\n+                    final KmerAdjacency successor = kmerAdjacency.getSoleSuccessor();\n+                    if ( successor == null ||\n+                            successor.getPredecessorCount() > 1 ||\n+                            successor == kmerAdjacency.rc() ) {\n+                        contig = new ContigImpl(++nContigs, kmerAdjacency.rc());\n+                    }\n+                }\n+                if ( contig != null ) {\n+                    contigs.add(contig);\n+                }\n+            }\n+        }\n+\n+        // if there are smooth circles like a plasmid, gather them together as a contig, too\n+        for ( final KmerAdjacency kmerAdjacency : kmerAdjacencySet ) {\n+            if ( kmerAdjacency.getContig() == null ) {\n+                contigs.add(new ContigImpl(++nContigs, kmerAdjacency));\n+            }\n+        }\n+\n+        return contigs;\n+    }\n+\n+    /** connect contigs when the final kmer of one contig is adjacent to the inital contig of another **/\n+    @VisibleForTesting\n+    static void connectContigs( final List<ContigImpl> contigs ) {\n+        final int nContigs = contigs.size();\n+        final KmerSet<ContigEndKmer> contigEnds = new KmerSet<>(2*nContigs);\n+        for ( int contigId = 0; contigId != nContigs; ++contigId ) {\n+            final ContigImpl contig = contigs.get(contigId);\n+            final KmerAdjacency fwdKmer = contig.getFirstKmer();\n+            final KmerAdjacency revKmer = contig.getLastKmer().rc();\n+            if ( fwdKmer == revKmer ) {\n+                contigEnds.add(new ContigEndKmer(fwdKmer.getKVal(), contig, ContigOrientation.BOTH));\n+            } else {\n+                contigEnds.add(new ContigEndKmer(fwdKmer.getKVal(), contig, ContigOrientation.FWD));\n+                contigEnds.add(new ContigEndKmer(revKmer.getKVal(), contig, ContigOrientation.REV));\n+            }\n+        }\n+\n+        for ( int contigId = 0; contigId != nContigs; ++contigId ) {\n+            final Contig contig = contigs.get(contigId);\n+\n+            final KmerAdjacency start = contig.getFirstKmer();\n+            final int predecessorCount = start.getPredecessorCount();\n+            if ( predecessorCount > 0 ) {\n+                final List<Contig> predecessors = contig.getPredecessors();\n+                final int mask = start.getPredecessorMask();\n+                for ( int call = 0; call != 4; ++call ) {\n+                    if ( (mask & (1 << call)) != 0 ) {\n+                        final long kVal =\n+                                KmerAdjacency.reverseComplement(start.getPredecessorVal(call));\n+                        final ContigEndKmer contigEndKmer = contigEnds.find(new Kmer(kVal));\n+                        if ( contigEndKmer == null ) {\n+                            throw new GATKException(\"missing contig end kmer\");\n+                        }\n+                        switch ( contigEndKmer.getContigOrientation() ) {\n+                            case FWD:\n+                                predecessors.add(contigEndKmer.getContig().rc());\n+                                break;\n+                            case REV:\n+                                predecessors.add(contigEndKmer.getContig());\n+                                break;\n+                            case BOTH:\n+                                predecessors.add(contigEndKmer.getContig());\n+                                predecessors.add(contigEndKmer.getContig().rc());\n+                                break;\n+                        }\n+                    }\n+                }\n+            }\n+\n+            final KmerAdjacency end = contig.getLastKmer();\n+            final int successorCount = end.getSuccessorCount();\n+            if ( successorCount > 0 ) {\n+                final List<Contig> successors = contig.getSuccessors();\n+                final int mask = end.getSuccessorMask();\n+                for ( int call = 0; call != 4; ++call ) {\n+                    if ( (mask & (1 << call)) != 0 ) {\n+                        final long kVal = end.getSuccessorVal(call);\n+                        final ContigEndKmer contigEndKmer = contigEnds.find(new Kmer(kVal));\n+                        if ( contigEndKmer == null ) {\n+                            throw new GATKException(\"missing contig end kmer\");\n+                        }\n+                        switch ( contigEndKmer.getContigOrientation() ) {\n+                            case FWD:\n+                                successors.add(contigEndKmer.getContig());\n+                                break;\n+                            case REV:\n+                                successors.add(contigEndKmer.getContig().rc());\n+                                break;\n+                            case BOTH:\n+                                successors.add(contigEndKmer.getContig());\n+                                successors.add(contigEndKmer.getContig().rc());\n+                                break;\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    /** remove contigs that have little evidence **/\n+    @VisibleForTesting\n+    static void removeThinContigs( final List<ContigImpl> contigs,\n+                                           final KmerSet<KmerAdjacency> kmerAdjacencySet ) {\n+        contigs.sort(Comparator.comparingInt(ContigImpl::getMaxObservations));\n+        boolean contigRemoved;\n+        do {\n+            // figure out which contigs are cut points\n+            // i.e., those contigs which, if removed, would result in a graph with more connected components\n+            final int nContigs = contigs.size();\n+            final Map<Contig, CutData> cutDataMap = new HashMap<>(nContigs * 3);\n+\n+            for ( final ContigImpl contig : contigs ) {\n+                if ( cutDataMap.containsKey(contig) ) {\n+                    continue;\n+                }\n+\n+                cutDataMap.put(contig, new CutData());\n+                int children = 0;\n+                for ( final Contig nextContig : contig.getSuccessors() ) {\n+                    if ( !cutDataMap.containsKey(nextContig) ) {\n+                        findCuts(nextContig, contig, cutDataMap);\n+                        children += 1;\n+                    }\n+                }\n+                for ( final Contig nextContig : contig.getPredecessors() ) {\n+                    if ( !cutDataMap.containsKey(nextContig) ) {\n+                        findCuts(nextContig, contig, cutDataMap);\n+                        children += 1;\n+                    }\n+                }\n+                if ( children >= 2 ) {\n+                    contig.setCut(true);\n+                }\n+            }\n+\n+            // remove poorly attested (low max observations) contigs, unless they are cut points\n+            contigRemoved = false;\n+            final Iterator<ContigImpl> itr = contigs.iterator();\n+            while ( itr.hasNext() ) {\n+                final Contig contig = itr.next();\n+                if ( contig.getMaxObservations() < MIN_THIN_OBS && !contig.isCut() ) {\n+                    unlinkContig(contig, kmerAdjacencySet);\n+                    itr.remove();\n+                    contigRemoved = true;\n+                    break;\n+                }\n+            }\n+        } while ( contigRemoved );\n+        contigs.sort(Comparator.comparingInt(ContigImpl::getId));\n+    }\n+\n+    private static CutData findCuts( final Contig contig,\n+                                     final Contig parent,\n+                                     final Map<Contig, CutData> cutDataMap ) {\n+        final CutData cutData = new CutData();\n+        cutDataMap.put(contig, cutData);\n+        for ( final Contig nextContig : contig.getSuccessors() ) {\n+            if ( nextContig == parent ) {\n+                continue;\n+            }\n+            CutData nextCutData = cutDataMap.get(nextContig);\n+            if ( nextCutData != null ) {\n+                cutData.minVisitNum = Math.min(cutData.minVisitNum, nextCutData.visitNum);\n+            } else {\n+                nextCutData = findCuts(nextContig, contig, cutDataMap);\n+                cutData.minVisitNum = Math.min(cutData.minVisitNum, nextCutData.minVisitNum);\n+                if ( nextCutData.minVisitNum >= cutData.visitNum ) {\n+                    contig.setCut(true);\n+                }\n+            }\n+        }\n+        for ( final Contig nextContig : contig.getPredecessors() ) {\n+            if ( nextContig == parent ) {\n+                continue;\n+            }\n+            CutData nextCutData = cutDataMap.get(nextContig);\n+            if ( nextCutData != null ) {\n+                cutData.minVisitNum = Math.min(cutData.minVisitNum, nextCutData.visitNum);\n+            } else {\n+                nextCutData = findCuts(nextContig, contig, cutDataMap);\n+                cutData.minVisitNum = Math.min(cutData.minVisitNum, nextCutData.minVisitNum);\n+                if ( nextCutData.minVisitNum >= cutData.visitNum ) {\n+                    contig.setCut(true);\n+                }\n+            }\n+        }\n+        return cutData;\n+    }\n+\n+    @VisibleForTesting\n+    static void unlinkContig( final Contig contig,\n+                                      final KmerSet<KmerAdjacency> kmerAdjacencySet ) {\n+        final KmerAdjacency firstKmer = contig.getFirstKmer();\n+        final int firstKmerFinalCall = firstKmer.getFinalCall();\n+        for ( final Contig predecessor : contig.getPredecessors() ) {\n+            if ( predecessor != contig && predecessor != contig.rc() ) {\n+                predecessor.getLastKmer().removeSuccessor(firstKmerFinalCall, kmerAdjacencySet);\n+                if ( !predecessor.getSuccessors().remove(contig) ) {\n+                    throw new GATKException(\"failed to find predecessor link\");\n+                }\n+            }\n+        }\n+\n+        final KmerAdjacency lastKmer = contig.getLastKmer();\n+        final int lastKmerInitialCall = lastKmer.getInitialCall();\n+        for ( final Contig successor : contig.getSuccessors() ) {\n+            if ( successor != contig && successor != contig.rc() ) {\n+                successor.getFirstKmer().removePredecessor(lastKmerInitialCall, kmerAdjacencySet);\n+                if ( !successor.getPredecessors().remove(contig) ) {\n+                    throw new GATKException(\"failed to find successor link\");\n+                }\n+            }\n+        }\n+\n+        KmerAdjacency nextKmer = firstKmer;\n+        KmerAdjacency kmer;\n+        do {\n+            kmer = nextKmer;\n+            nextKmer = kmer.getSoleSuccessor();\n+            kmerAdjacencySet.remove(kmer.canonical());\n+        } while ( kmer != lastKmer );\n+    }\n+\n+    private static void updateKmerContig( final KmerAdjacency firstKmer,\n+                                          final KmerAdjacency lastKmer,\n+                                          final Contig contig ) {\n+        int offset = 0;\n+        for ( KmerAdjacency kmer = firstKmer; kmer != lastKmer; kmer = kmer.getSoleSuccessor() ) {\n+            if ( kmer == null ) {\n+                throw new GATKException(\"contig does not have a flat pipeline of kmers\");\n+            }\n+            kmer.clearContig();\n+            kmer.setContigOffset(contig, offset++);\n+        }\n+        lastKmer.clearContig();\n+        lastKmer.setContigOffset(contig, offset);\n+        if ( offset + Kmer.KSIZE != contig.size() ) {\n+            throw new GATKException(\"kmer chain length does not equal contig size\");\n+        }\n+    }\n+\n+    /** replace adjacent contigs without branches with a single, larger contig **/\n+    @VisibleForTesting\n+    static void weldPipes( final List<ContigImpl> contigs ) {\n+        for ( int contigIdx = 0; contigIdx != contigs.size(); ++contigIdx ) {\n+            final ContigImpl contig = contigs.get(contigIdx);\n+            if ( contig.getSuccessors().size() == 1 ) {\n+                final Contig successor = contig.getSuccessors().get(0);\n+                if ( successor != contig && successor != contig.rc() &&\n+                        successor.getPredecessors().size() == 1 ) {\n+                    contigs.set(contigIdx, join(contig.getId(), contig, successor));\n+                    if ( !contigs.remove(successor.canonical()) ) {\n+                        throw new GATKException(\"successor linkage is messed up\");\n+                    }\n+                    contigIdx -= 1; // reconsider the new contig -- there might be more joining possible\n+                    continue;\n+                }\n+            }\n+            if ( contig.getPredecessors().size() == 1 ) {\n+                final Contig predecessor = contig.getPredecessors().get(0);\n+                if ( predecessor != contig && predecessor != contig.rc() &&\n+                        predecessor.getSuccessors().size() == 1 ) {\n+                    contigs.set(contigIdx, join(contig.getId(), predecessor, contig));\n+                    if ( !contigs.remove(predecessor.canonical()) ) {\n+                        throw new GATKException(\"predecessor linkage is messed up\");\n+                    }\n+                    contigIdx -= 1; // reconsider\n+                }\n+            }\n+        }\n+    }\n+\n+    private static ContigImpl join( final int id, final Contig predecessor, final Contig successor ) {\n+        if ( !checkOverlap(predecessor.getSequence(), successor.getSequence()) ) {\n+                throw new GATKException(\"sequences can't be joined\");\n+        }\n+        final ContigImpl joinedContig = new ContigImpl(id, predecessor, successor);\n+        updateKmerContig(joinedContig.getFirstKmer(), joinedContig.getLastKmer(), joinedContig);\n+        return joinedContig;\n+    }\n+\n+    private static boolean checkOverlap( final CharSequence seq1, final CharSequence seq2 ) {\n+        final int seq1Len = seq1.length();\n+        final CharSequence seq1SubSeq = seq1.subSequence(seq1Len - Kmer.KSIZE + 1, seq1Len);\n+        final CharSequence seq2SubSeq = seq2.subSequence(0, Kmer.KSIZE - 1);\n+        return seq1SubSeq.equals(seq2SubSeq);\n+    }\n+\n+    /** set a unique componentId for every connected group of contigs **/\n+    @VisibleForTesting\n+    static int markComponents( final List<ContigImpl> contigs ) {\n+        for ( final ContigImpl contig : contigs ) {\n+            contig.setComponentId(0);\n+        }\n+\n+        int componentId = 0;\n+        for ( final ContigImpl contig : contigs ) {\n+            if ( contig.getComponentId() == 0 ) {\n+                contig.setComponentId(++componentId);\n+                markSuccessorComponents(contig);\n+                markSuccessorComponents(contig.rc());\n+            }\n+        }\n+        return componentId;\n+    }\n+\n+    private static void markSuccessorComponents( final Contig contig ) {\n+        final int componentId = contig.getComponentId();\n+        for ( final Contig successor : contig.getSuccessors() ) {\n+            if ( successor.getComponentId() == 0 ) {\n+                successor.canonical().setComponentId(componentId);\n+                markSuccessorComponents(successor);\n+                markSuccessorComponents(successor.rc());\n+            }\n+        }\n+    }\n+\n+    @VisibleForTesting\n+    static void markCycles( final List<ContigImpl> contigs ) {\n+        for ( final Contig contig : contigs ) {\n+            contig.setCyclic(false);\n+        }\n+\n+        final int nContigs = contigs.size();\n+        final Deque<Contig> deque = new ArrayDeque<>(nContigs);\n+        final Map<Contig, CutData> cutDataMap = new HashMap<>(nContigs * 3);\n+        for ( final Contig contig : contigs ) {\n+            if ( !cutDataMap.containsKey(contig) ) {\n+                markCyclesRecursion(contig, deque, cutDataMap);\n+            }\n+        }\n+    }\n+\n+    private static CutData markCyclesRecursion( final Contig contig,\n+                                                final Deque<Contig> deque,\n+                                                final Map<Contig, CutData> cutDataMap ) {\n+        final CutData cutData = new CutData();\n+        cutDataMap.put(contig, cutData);\n+        deque.addFirst(contig);\n+\n+        for ( final Contig successor : contig.getSuccessors() ) {\n+            final CutData successorCutData = cutDataMap.get(successor);\n+            if ( successorCutData == null ) {\n+                final int recursionVisitNum =\n+                        markCyclesRecursion(successor, deque, cutDataMap).minVisitNum;\n+                cutData.minVisitNum = Math.min(cutData.minVisitNum, recursionVisitNum);\n+            } else {\n+                cutData.minVisitNum = Math.min(cutData.minVisitNum, successorCutData.visitNum);\n+            }\n+        }\n+\n+        if ( cutData.visitNum == cutData.minVisitNum ) {\n+            Contig tig = deque.removeFirst();\n+            if ( tig == contig ) {\n+                cutDataMap.get(tig).visitNum = Integer.MAX_VALUE;\n+\n+                // single-vertex component -- cyclic only if self-referential\n+                if ( tig.getSuccessors().contains(tig) ) {\n+                    tig.setCyclic(true);\n+                }\n+            } else {\n+                while ( true ) {\n+                    // kill cross-links\n+                    cutDataMap.get(tig).visitNum = Integer.MAX_VALUE;\n+                    tig.setCyclic(true);\n+                    if ( tig == contig ) break;\n+                    tig = deque.removeFirst();\n+                }\n+            }\n+        }\n+        return cutData;\n+    }\n+\n+    @VisibleForTesting\n+    static boolean fillGaps( final KmerSet<KmerAdjacency> kmerAdjacencySet,\n+                             final List<GATKRead> reads ) {\n+        final Map<String, Integer> gapFillCounts = new HashMap<>();\n+        for ( final GATKRead read : reads ) {\n+            final Path path = new Path(read.getBasesNoCopy(), kmerAdjacencySet);\n+            final List<PathPart> parts = path.getParts();\n+            final int lastIdx = parts.size() - 1;\n+            for ( int idx = 1; idx < lastIdx; ++idx ) {\n+                final PathPart pathPart = parts.get(idx);\n+                if ( pathPart.isGap() ) {\n+                    final char prevCall = parts.get(idx - 1).getLastCall();\n+                    final char nextCall = parts.get(idx + 1).getFirstCall();\n+                    String gapFill = prevCall + pathPart.getSequence().toString() + nextCall;\n+                    final SequenceRC gapFillRC = new SequenceRC(gapFill);\n+                    if ( gapFillRC.compareTo(gapFill) < 0 ) {\n+                        gapFill = gapFillRC.toString();\n+                    }\n+                    gapFillCounts.merge(gapFill, 1, Integer::sum);\n+                }\n+            }\n+        }\n+\n+        boolean newKmers = false;\n+        for ( final Map.Entry<String, Integer> entry : gapFillCounts.entrySet() ) {\n+            final int nObservations = entry.getValue();\n+            if ( nObservations >= MIN_GAPFILL_COUNT ) {\n+                KmerAdjacency.kmerize(entry.getKey(), nObservations, kmerAdjacencySet);\n+                newKmers = true;\n+            }\n+        }\n+\n+        if ( newKmers ) {\n+            for ( final KmerAdjacency kmerAdjacency : kmerAdjacencySet ) {\n+                kmerAdjacency.clearContig();\n+            }\n+        }\n+        return newKmers;\n+    }\n+\n+    @VisibleForTesting\n+    static List<Path> pathReads( final KmerSet<KmerAdjacency> kmerAdjacencySet,\n+                          final List<GATKRead> reads ) {\n+        final List<Path> readPaths = new ArrayList<>(reads.size());\n+        for ( final GATKRead read : reads ) {\n+            readPaths.add(new Path(read.getBasesNoCopy(), kmerAdjacencySet));\n+        }\n+        return readPaths;\n+    }\n+\n+    @VisibleForTesting\n+    static Map<Contig,List<TransitPairCount>> collectTransitPairCounts(\n+            final List<ContigImpl> contigs,\n+            final List<Path> readPaths ) {\n+        final Map<Contig,List<TransitPairCount>> contigTransitsMap =\n+                new HashMap<>(3 * contigs.size());\n+        for ( final Path path : readPaths ) {\n+            final List<PathPart> parts = path.getParts();\n+            final int lastPart = parts.size() - 1;\n+            for ( int partIdx = 1; partIdx < lastPart; ++partIdx ) {\n+                final Contig prevContig = parts.get(partIdx - 1).getContig();\n+                if ( prevContig == null ) continue;\n+                final Contig curContig = parts.get(partIdx).getContig();\n+                if ( curContig == null ) {\n+                    partIdx += 1;\n+                    continue;\n+                }\n+                final Contig nextContig = parts.get(partIdx + 1).getContig();\n+                if ( nextContig == null ) {\n+                    partIdx += 2;\n+                    continue;\n+                }\n+                final TransitPairCount tpc = new TransitPairCount(prevContig, nextContig);\n+                final List<TransitPairCount> tpcList =\n+                        contigTransitsMap.computeIfAbsent(curContig, tig -> new ArrayList<>(4));\n+                final int idx = tpcList.indexOf(tpc);\n+                if ( idx != -1 ) {\n+                    tpcList.get(idx).observe();\n+                } else {\n+                    tpcList.add(tpc);\n+                    contigTransitsMap.computeIfAbsent(curContig.rc(), tig -> new ArrayList<>(4))\n+                            .add(tpc.getRC());\n+                }\n+            }\n+        }\n+        return contigTransitsMap;\n+    }\n+\n+    @VisibleForTesting\n+    static Set<Traversal> traverseAllPaths(\n+            final List<ContigImpl> contigs,\n+            final List<Path> readPaths,\n+            final Map<Contig, List<TransitPairCount>> contigTransitsMap ) {\n+        final Set<Traversal> traversalSet = new HashSet<>();\n+        final List<Contig> contigsList = new ArrayList<>();\n+        for ( final Contig contig : contigs ) {\n+            // untransited contigs are sources, sinks, or large contigs that can't be crossed by a read\n+            // build traversals from these\n+            if ( !contigTransitsMap.containsKey(contig) ) {\n+                boolean done = false;\n+                for ( final Contig successor : contig.getSuccessors() ) {\n+                    traverse(successor, contig,\n+                            contigsList, readPaths, contigTransitsMap, traversalSet);\n+                    done = true;\n+                }\n+                for ( final Contig predecessor : contig.getPredecessors() ) {\n+                    traverse(predecessor.rc(), contig.rc(),\n+                            contigsList, readPaths, contigTransitsMap, traversalSet);\n+                    done = true;\n+                }\n+                if ( !done ) { // if there were no predecessors or successors, it stands alone\n+                    addTraversal(new Traversal(Collections.singletonList(contig)), traversalSet);\n+                }\n+            }\n+        }\n+\n+        // look for transits that haven't been traced\n+        for ( final Map.Entry<Contig, List<TransitPairCount>> entry :\n+                contigTransitsMap.entrySet() ) {\n+            for ( final TransitPairCount tpc : entry.getValue() ) {\n+                if ( tpc.getCount() > 0 ) {\n+                    tpc.resetCount();\n+                    final Contig contig = entry.getKey();\n+                    final Set<Traversal> fwdTraversalSet = new HashSet<>();\n+                    traverse(tpc.getNextContig(), contig,\n+                            contigsList, readPaths, contigTransitsMap, fwdTraversalSet);\n+                    final Set<Traversal> revTraversalSet = new HashSet<>();\n+                    traverse(tpc.getPrevContig().rc(), contig.rc(),\n+                            contigsList, readPaths, contigTransitsMap, revTraversalSet);\n+                    for ( final Traversal revTraversal : revTraversalSet ) {\n+                        final Traversal revTraversalRC = revTraversal.rc();\n+                        for ( final Traversal fwdTraversal : fwdTraversalSet ) {\n+                            final int overlap =\n+                                    findMaxOverlap(revTraversalRC.getContigs(), fwdTraversal.getContigs());\n+                            final Traversal combo =\n+                                    Traversal.combineOverlappers(revTraversalRC, fwdTraversal, overlap);\n+                            addTraversal(combo, traversalSet);\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+\n+        return traversalSet;\n+    }\n+\n+    private static int findMaxOverlap( final List<Contig> prefixes, final List<Contig> suffixes ) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e2201c1ef4f8ba71f17e169f07756cfe2f1ecb49"}, "originalPosition": 723}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxNDg2MzA4OA==", "bodyText": "I'm thinking about this method (findMaxOverlap): it may be providing some short-circuits that might explain my overcalling deletions.  But I'll document the assumptions.  It's actually pretty straightforward: the last Contig in the prefix list and the first Contig in the suffix list are always the same because we walked forward and backward from some given Contig as a starting point.  If the first Contig in the suffix list is not part of a cycle, that means it can appear in the suffix list only once (to appear twice would mean it is part of a cycle).  Ditto with the last Contig in the prefix list.  So the maximum overlap is just that single contig at the end of the prefix list and at the start of the suffix list.", "url": "https://github.com/broadinstitute/gatk/pull/6989#discussion_r614863088", "createdAt": "2021-04-16T14:03:03Z", "author": {"login": "tedsharpe"}, "path": "src/main/java/org/broadinstitute/hellbender/tools/LocalAssembler.java", "diffHunk": "@@ -0,0 +1,2306 @@\n+package org.broadinstitute.hellbender.tools;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import htsjdk.samtools.Cigar;\n+import htsjdk.samtools.CigarElement;\n+import htsjdk.samtools.CigarOperator;\n+import htsjdk.samtools.SAMUtils;\n+import org.broadinstitute.barclay.argparser.Argument;\n+import org.broadinstitute.barclay.argparser.BetaFeature;\n+import org.broadinstitute.barclay.argparser.CommandLineProgramProperties;\n+import org.broadinstitute.barclay.help.DocumentedFeature;\n+import org.broadinstitute.hellbender.cmdline.StandardArgumentDefinitions;\n+import org.broadinstitute.hellbender.cmdline.programgroups.CoverageAnalysisProgramGroup;\n+import org.broadinstitute.hellbender.exceptions.GATKException;\n+import org.broadinstitute.hellbender.tools.walkers.PairWalker;\n+import org.broadinstitute.hellbender.utils.SimpleInterval;\n+import org.broadinstitute.hellbender.utils.collections.HopscotchSet;\n+import org.broadinstitute.hellbender.utils.gcs.BucketUtils;\n+import org.broadinstitute.hellbender.utils.read.GATKRead;\n+\n+import java.io.BufferedWriter;\n+import java.io.FileWriter;\n+import java.io.IOException;\n+import java.io.OutputStreamWriter;\n+import java.util.*;\n+import java.util.zip.GZIPOutputStream;\n+\n+@DocumentedFeature\n+@CommandLineProgramProperties(\n+        summary = \"experiment\",\n+        oneLineSummary = \"experiment\",\n+        usageExample = \"gatk LocalAssembler\",\n+        programGroup = CoverageAnalysisProgramGroup.class\n+)\n+@BetaFeature\n+public class LocalAssembler extends PairWalker {\n+    public static final byte QMIN = 25;\n+    public static final int MIN_THIN_OBS = 4;\n+    public static final int MIN_GAPFILL_COUNT = 3;\n+    public static final int TOO_MANY_TRAVERSALS = 100000;\n+    public static final int TOO_MANY_SCAFFOLDS = 50000;\n+    public static final int MIN_SV_SIZE = 50;\n+\n+    @Argument(fullName=StandardArgumentDefinitions.OUTPUT_LONG_NAME,\n+            shortName=StandardArgumentDefinitions.OUTPUT_SHORT_NAME,\n+            doc=\"Write outputs to this file name prefix\", optional = true)\n+    public static String output;\n+\n+    @Argument(fullName=\"assembly-name\", doc=\"name of assembly used as a prefix for traversal names\")\n+    public static String assemblyName;\n+\n+    private final List<GATKRead> reads = new ArrayList<>();\n+\n+    @Override public boolean requiresIntervals() { return true; }\n+\n+    @Override public void apply( final GATKRead read, final GATKRead mate ) {\n+        trimOverruns(read, mate);\n+        reads.add(read);\n+        reads.add(mate);\n+    }\n+\n+    @Override public void applyUnpaired( final GATKRead read ) {\n+        reads.add(read);\n+    }\n+\n+    @Override public Object onTraversalSuccess() {\n+        super.onTraversalSuccess(); // flush any incomplete pairs\n+\n+        final int regionSize = getTraversalIntervals().stream().mapToInt(SimpleInterval::size).sum();\n+        final KmerSet<KmerAdjacency> kmerAdjacencySet = new KmerSet<>(10 * regionSize);\n+        kmerizeReads(reads, kmerAdjacencySet);\n+        List<ContigImpl> contigs = buildContigs(kmerAdjacencySet);\n+        connectContigs(contigs);\n+\n+        removeThinContigs(contigs, kmerAdjacencySet);\n+        weldPipes(contigs);\n+        markComponents(contigs);\n+\n+        if ( fillGaps(kmerAdjacencySet, reads) ) {\n+            contigs = buildContigs(kmerAdjacencySet);\n+            connectContigs(contigs);\n+            removeThinContigs(contigs, kmerAdjacencySet);\n+            weldPipes(contigs);\n+            markComponents(contigs);\n+        }\n+\n+        markCycles(contigs);\n+\n+        final String outputFilePrefix = output != null ? output : assemblyName;\n+        final List<Path> readPaths = pathReads(kmerAdjacencySet, reads);\n+        final Map<Contig,List<TransitPairCount>> contigTransitsMap =\n+                collectTransitPairCounts(contigs, readPaths);\n+        final String traversalsFilename = outputFilePrefix + \".traversals.fa.gz\";\n+        try {\n+            final List<Traversal> allTraversals =\n+                    new ArrayList<>(traverseAllPaths(contigs, readPaths, contigTransitsMap));\n+            writeTraversals(allTraversals, traversalsFilename);\n+            try {\n+                final String scaffoldsFileName = outputFilePrefix + \".scaffolds.fa.gz\";\n+                writeTraversals(createScaffolds(allTraversals), scaffoldsFileName);\n+            } catch ( final AssemblyTooComplexException x ) {\n+                logger.warn(\"Assembly too complex for scaffolding.\");\n+            }\n+        } catch ( final AssemblyTooComplexException x ) {\n+            logger.warn(\"Assembly too complex.  Writing contigs as traversals in \" +\n+                    traversalsFilename + \".\");\n+            final Collection<Traversal> contigTraversals = new ArrayList<>(contigs.size());\n+            for ( final Contig contig : contigs ) {\n+                contigTraversals.add(new Traversal(Collections.singletonList(contig)));\n+            }\n+            writeTraversals(contigTraversals, traversalsFilename);\n+        }\n+\n+        contigs.sort(Comparator.comparingInt(ContigImpl::getId));\n+        writeDOT(contigs, outputFilePrefix + \".assembly.dot\");\n+        writeContigs(contigs, outputFilePrefix + \".contigs.txt.gz\");\n+        writePaths(readPaths, outputFilePrefix + \".paths.txt.gz\");\n+        writeReads(reads, outputFilePrefix + \".reads.fastq.gz\");\n+        return null;\n+    }\n+\n+    /** trim read pairs of base calls that have gone past the end of a short fragment */\n+    private void trimOverruns( final GATKRead read, final GATKRead mate ) {\n+        // if both mapped and they're on different strands\n+        if ( !read.isUnmapped() && !mate.isUnmapped() &&\n+                read.isReverseStrand() != mate.isReverseStrand() ) {\n+            // and both start within 1 base on the ref\n+            if ( Math.abs(read.getStart() - read.getMateStart()) <= 1 ) {\n+                // and both end within 1 base\n+                final int readRefLen = read.getCigar().getReferenceLength();\n+                final int mateRefLen = mate.getCigar().getReferenceLength();\n+                if ( Math.abs(readRefLen - mateRefLen) <= 1 ) {\n+                    if ( mate.isReverseStrand() ) {\n+                        trimClips(read, mate);\n+                    } else {\n+                        trimClips(mate, read);\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    private void trimClips( final GATKRead fwd, final GATKRead rev ) {\n+        final List<CigarElement> fwdElements = fwd.getCigarElements();\n+        final List<CigarElement> revElements = rev.getCigarElements();\n+        final int lastElementIdx = fwdElements.size() - 1;\n+        final CigarElement fwdLastElement = fwdElements.get(lastElementIdx);\n+        final CigarElement revFirstElement = revElements.get(0);\n+        if ( fwdLastElement.getOperator() == CigarOperator.S &&\n+                revFirstElement.getOperator() == CigarOperator.S ) {\n+            final byte[] fwdBases = fwd.getBasesNoCopy();\n+            final int lastElementLen = fwdLastElement.getLength();\n+            fwd.setBases(Arrays.copyOfRange(fwdBases, 0, fwdBases.length - lastElementLen));\n+            final byte[] fwdQuals = fwd.getBaseQualitiesNoCopy();\n+            if ( fwdQuals.length > 0 ) {\n+                final int qualsLen = fwdQuals.length - lastElementLen;\n+                fwd.setBaseQualities(Arrays.copyOfRange(fwdQuals, 0, qualsLen));\n+            }\n+            final List<CigarElement> newFwdElements = new ArrayList<>(fwdElements);\n+            newFwdElements.set(lastElementIdx, new CigarElement(lastElementLen, CigarOperator.H));\n+            fwd.setCigar(new Cigar(newFwdElements));\n+\n+            final byte[] revBases = rev.getBasesNoCopy();\n+            final int firstElementLen = revFirstElement.getLength();\n+            rev.setBases(Arrays.copyOfRange(revBases, firstElementLen, revBases.length));\n+            final byte[] revQuals = rev.getBaseQualitiesNoCopy();\n+            if ( revQuals.length > 0 ) {\n+                rev.setBaseQualities(Arrays.copyOfRange(revQuals, firstElementLen, revQuals.length));\n+            }\n+            final List<CigarElement> newRevElements = new ArrayList<>(revElements);\n+            newRevElements.set(0, new CigarElement(firstElementLen, CigarOperator.H));\n+            rev.setCigar(new Cigar(newRevElements));\n+        }\n+    }\n+\n+    @VisibleForTesting\n+    static void kmerizeReads( final List<GATKRead> reads,\n+                              final KmerSet<KmerAdjacency> kmerAdjacencySet ) {\n+        for ( final GATKRead read : reads ) {\n+            final byte[] calls = read.getBasesNoCopy();\n+            final byte[] quals = read.getBaseQualitiesNoCopy();\n+            KmerAdjacency.kmerize(calls, quals, QMIN, kmerAdjacencySet);\n+        }\n+    }\n+\n+    /** gather unbranched strings of kmers into contigs **/\n+    @VisibleForTesting\n+    static List<ContigImpl> buildContigs( final KmerSet<KmerAdjacency> kmerAdjacencySet ) {\n+        // gather strings of kmers that have a single predecessor and single successor into contigs\n+        final List<ContigImpl> contigs = new ArrayList<>();\n+        int nContigs = 0;\n+        for ( final KmerAdjacency kmerAdjacency : kmerAdjacencySet ) {\n+            if ( kmerAdjacency.getContig() == null ) {\n+                ContigImpl contig = null;\n+                final KmerAdjacency predecessor = kmerAdjacency.getSolePredecessor();\n+                if ( predecessor == null ||\n+                        predecessor.getSuccessorCount() > 1 ||\n+                        predecessor == kmerAdjacency.rc() ) {\n+                    contig = new ContigImpl(++nContigs, kmerAdjacency);\n+                } else {\n+                    final KmerAdjacency successor = kmerAdjacency.getSoleSuccessor();\n+                    if ( successor == null ||\n+                            successor.getPredecessorCount() > 1 ||\n+                            successor == kmerAdjacency.rc() ) {\n+                        contig = new ContigImpl(++nContigs, kmerAdjacency.rc());\n+                    }\n+                }\n+                if ( contig != null ) {\n+                    contigs.add(contig);\n+                }\n+            }\n+        }\n+\n+        // if there are smooth circles like a plasmid, gather them together as a contig, too\n+        for ( final KmerAdjacency kmerAdjacency : kmerAdjacencySet ) {\n+            if ( kmerAdjacency.getContig() == null ) {\n+                contigs.add(new ContigImpl(++nContigs, kmerAdjacency));\n+            }\n+        }\n+\n+        return contigs;\n+    }\n+\n+    /** connect contigs when the final kmer of one contig is adjacent to the inital contig of another **/\n+    @VisibleForTesting\n+    static void connectContigs( final List<ContigImpl> contigs ) {\n+        final int nContigs = contigs.size();\n+        final KmerSet<ContigEndKmer> contigEnds = new KmerSet<>(2*nContigs);\n+        for ( int contigId = 0; contigId != nContigs; ++contigId ) {\n+            final ContigImpl contig = contigs.get(contigId);\n+            final KmerAdjacency fwdKmer = contig.getFirstKmer();\n+            final KmerAdjacency revKmer = contig.getLastKmer().rc();\n+            if ( fwdKmer == revKmer ) {\n+                contigEnds.add(new ContigEndKmer(fwdKmer.getKVal(), contig, ContigOrientation.BOTH));\n+            } else {\n+                contigEnds.add(new ContigEndKmer(fwdKmer.getKVal(), contig, ContigOrientation.FWD));\n+                contigEnds.add(new ContigEndKmer(revKmer.getKVal(), contig, ContigOrientation.REV));\n+            }\n+        }\n+\n+        for ( int contigId = 0; contigId != nContigs; ++contigId ) {\n+            final Contig contig = contigs.get(contigId);\n+\n+            final KmerAdjacency start = contig.getFirstKmer();\n+            final int predecessorCount = start.getPredecessorCount();\n+            if ( predecessorCount > 0 ) {\n+                final List<Contig> predecessors = contig.getPredecessors();\n+                final int mask = start.getPredecessorMask();\n+                for ( int call = 0; call != 4; ++call ) {\n+                    if ( (mask & (1 << call)) != 0 ) {\n+                        final long kVal =\n+                                KmerAdjacency.reverseComplement(start.getPredecessorVal(call));\n+                        final ContigEndKmer contigEndKmer = contigEnds.find(new Kmer(kVal));\n+                        if ( contigEndKmer == null ) {\n+                            throw new GATKException(\"missing contig end kmer\");\n+                        }\n+                        switch ( contigEndKmer.getContigOrientation() ) {\n+                            case FWD:\n+                                predecessors.add(contigEndKmer.getContig().rc());\n+                                break;\n+                            case REV:\n+                                predecessors.add(contigEndKmer.getContig());\n+                                break;\n+                            case BOTH:\n+                                predecessors.add(contigEndKmer.getContig());\n+                                predecessors.add(contigEndKmer.getContig().rc());\n+                                break;\n+                        }\n+                    }\n+                }\n+            }\n+\n+            final KmerAdjacency end = contig.getLastKmer();\n+            final int successorCount = end.getSuccessorCount();\n+            if ( successorCount > 0 ) {\n+                final List<Contig> successors = contig.getSuccessors();\n+                final int mask = end.getSuccessorMask();\n+                for ( int call = 0; call != 4; ++call ) {\n+                    if ( (mask & (1 << call)) != 0 ) {\n+                        final long kVal = end.getSuccessorVal(call);\n+                        final ContigEndKmer contigEndKmer = contigEnds.find(new Kmer(kVal));\n+                        if ( contigEndKmer == null ) {\n+                            throw new GATKException(\"missing contig end kmer\");\n+                        }\n+                        switch ( contigEndKmer.getContigOrientation() ) {\n+                            case FWD:\n+                                successors.add(contigEndKmer.getContig());\n+                                break;\n+                            case REV:\n+                                successors.add(contigEndKmer.getContig().rc());\n+                                break;\n+                            case BOTH:\n+                                successors.add(contigEndKmer.getContig());\n+                                successors.add(contigEndKmer.getContig().rc());\n+                                break;\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    /** remove contigs that have little evidence **/\n+    @VisibleForTesting\n+    static void removeThinContigs( final List<ContigImpl> contigs,\n+                                           final KmerSet<KmerAdjacency> kmerAdjacencySet ) {\n+        contigs.sort(Comparator.comparingInt(ContigImpl::getMaxObservations));\n+        boolean contigRemoved;\n+        do {\n+            // figure out which contigs are cut points\n+            // i.e., those contigs which, if removed, would result in a graph with more connected components\n+            final int nContigs = contigs.size();\n+            final Map<Contig, CutData> cutDataMap = new HashMap<>(nContigs * 3);\n+\n+            for ( final ContigImpl contig : contigs ) {\n+                if ( cutDataMap.containsKey(contig) ) {\n+                    continue;\n+                }\n+\n+                cutDataMap.put(contig, new CutData());\n+                int children = 0;\n+                for ( final Contig nextContig : contig.getSuccessors() ) {\n+                    if ( !cutDataMap.containsKey(nextContig) ) {\n+                        findCuts(nextContig, contig, cutDataMap);\n+                        children += 1;\n+                    }\n+                }\n+                for ( final Contig nextContig : contig.getPredecessors() ) {\n+                    if ( !cutDataMap.containsKey(nextContig) ) {\n+                        findCuts(nextContig, contig, cutDataMap);\n+                        children += 1;\n+                    }\n+                }\n+                if ( children >= 2 ) {\n+                    contig.setCut(true);\n+                }\n+            }\n+\n+            // remove poorly attested (low max observations) contigs, unless they are cut points\n+            contigRemoved = false;\n+            final Iterator<ContigImpl> itr = contigs.iterator();\n+            while ( itr.hasNext() ) {\n+                final Contig contig = itr.next();\n+                if ( contig.getMaxObservations() < MIN_THIN_OBS && !contig.isCut() ) {\n+                    unlinkContig(contig, kmerAdjacencySet);\n+                    itr.remove();\n+                    contigRemoved = true;\n+                    break;\n+                }\n+            }\n+        } while ( contigRemoved );\n+        contigs.sort(Comparator.comparingInt(ContigImpl::getId));\n+    }\n+\n+    private static CutData findCuts( final Contig contig,\n+                                     final Contig parent,\n+                                     final Map<Contig, CutData> cutDataMap ) {\n+        final CutData cutData = new CutData();\n+        cutDataMap.put(contig, cutData);\n+        for ( final Contig nextContig : contig.getSuccessors() ) {\n+            if ( nextContig == parent ) {\n+                continue;\n+            }\n+            CutData nextCutData = cutDataMap.get(nextContig);\n+            if ( nextCutData != null ) {\n+                cutData.minVisitNum = Math.min(cutData.minVisitNum, nextCutData.visitNum);\n+            } else {\n+                nextCutData = findCuts(nextContig, contig, cutDataMap);\n+                cutData.minVisitNum = Math.min(cutData.minVisitNum, nextCutData.minVisitNum);\n+                if ( nextCutData.minVisitNum >= cutData.visitNum ) {\n+                    contig.setCut(true);\n+                }\n+            }\n+        }\n+        for ( final Contig nextContig : contig.getPredecessors() ) {\n+            if ( nextContig == parent ) {\n+                continue;\n+            }\n+            CutData nextCutData = cutDataMap.get(nextContig);\n+            if ( nextCutData != null ) {\n+                cutData.minVisitNum = Math.min(cutData.minVisitNum, nextCutData.visitNum);\n+            } else {\n+                nextCutData = findCuts(nextContig, contig, cutDataMap);\n+                cutData.minVisitNum = Math.min(cutData.minVisitNum, nextCutData.minVisitNum);\n+                if ( nextCutData.minVisitNum >= cutData.visitNum ) {\n+                    contig.setCut(true);\n+                }\n+            }\n+        }\n+        return cutData;\n+    }\n+\n+    @VisibleForTesting\n+    static void unlinkContig( final Contig contig,\n+                                      final KmerSet<KmerAdjacency> kmerAdjacencySet ) {\n+        final KmerAdjacency firstKmer = contig.getFirstKmer();\n+        final int firstKmerFinalCall = firstKmer.getFinalCall();\n+        for ( final Contig predecessor : contig.getPredecessors() ) {\n+            if ( predecessor != contig && predecessor != contig.rc() ) {\n+                predecessor.getLastKmer().removeSuccessor(firstKmerFinalCall, kmerAdjacencySet);\n+                if ( !predecessor.getSuccessors().remove(contig) ) {\n+                    throw new GATKException(\"failed to find predecessor link\");\n+                }\n+            }\n+        }\n+\n+        final KmerAdjacency lastKmer = contig.getLastKmer();\n+        final int lastKmerInitialCall = lastKmer.getInitialCall();\n+        for ( final Contig successor : contig.getSuccessors() ) {\n+            if ( successor != contig && successor != contig.rc() ) {\n+                successor.getFirstKmer().removePredecessor(lastKmerInitialCall, kmerAdjacencySet);\n+                if ( !successor.getPredecessors().remove(contig) ) {\n+                    throw new GATKException(\"failed to find successor link\");\n+                }\n+            }\n+        }\n+\n+        KmerAdjacency nextKmer = firstKmer;\n+        KmerAdjacency kmer;\n+        do {\n+            kmer = nextKmer;\n+            nextKmer = kmer.getSoleSuccessor();\n+            kmerAdjacencySet.remove(kmer.canonical());\n+        } while ( kmer != lastKmer );\n+    }\n+\n+    private static void updateKmerContig( final KmerAdjacency firstKmer,\n+                                          final KmerAdjacency lastKmer,\n+                                          final Contig contig ) {\n+        int offset = 0;\n+        for ( KmerAdjacency kmer = firstKmer; kmer != lastKmer; kmer = kmer.getSoleSuccessor() ) {\n+            if ( kmer == null ) {\n+                throw new GATKException(\"contig does not have a flat pipeline of kmers\");\n+            }\n+            kmer.clearContig();\n+            kmer.setContigOffset(contig, offset++);\n+        }\n+        lastKmer.clearContig();\n+        lastKmer.setContigOffset(contig, offset);\n+        if ( offset + Kmer.KSIZE != contig.size() ) {\n+            throw new GATKException(\"kmer chain length does not equal contig size\");\n+        }\n+    }\n+\n+    /** replace adjacent contigs without branches with a single, larger contig **/\n+    @VisibleForTesting\n+    static void weldPipes( final List<ContigImpl> contigs ) {\n+        for ( int contigIdx = 0; contigIdx != contigs.size(); ++contigIdx ) {\n+            final ContigImpl contig = contigs.get(contigIdx);\n+            if ( contig.getSuccessors().size() == 1 ) {\n+                final Contig successor = contig.getSuccessors().get(0);\n+                if ( successor != contig && successor != contig.rc() &&\n+                        successor.getPredecessors().size() == 1 ) {\n+                    contigs.set(contigIdx, join(contig.getId(), contig, successor));\n+                    if ( !contigs.remove(successor.canonical()) ) {\n+                        throw new GATKException(\"successor linkage is messed up\");\n+                    }\n+                    contigIdx -= 1; // reconsider the new contig -- there might be more joining possible\n+                    continue;\n+                }\n+            }\n+            if ( contig.getPredecessors().size() == 1 ) {\n+                final Contig predecessor = contig.getPredecessors().get(0);\n+                if ( predecessor != contig && predecessor != contig.rc() &&\n+                        predecessor.getSuccessors().size() == 1 ) {\n+                    contigs.set(contigIdx, join(contig.getId(), predecessor, contig));\n+                    if ( !contigs.remove(predecessor.canonical()) ) {\n+                        throw new GATKException(\"predecessor linkage is messed up\");\n+                    }\n+                    contigIdx -= 1; // reconsider\n+                }\n+            }\n+        }\n+    }\n+\n+    private static ContigImpl join( final int id, final Contig predecessor, final Contig successor ) {\n+        if ( !checkOverlap(predecessor.getSequence(), successor.getSequence()) ) {\n+                throw new GATKException(\"sequences can't be joined\");\n+        }\n+        final ContigImpl joinedContig = new ContigImpl(id, predecessor, successor);\n+        updateKmerContig(joinedContig.getFirstKmer(), joinedContig.getLastKmer(), joinedContig);\n+        return joinedContig;\n+    }\n+\n+    private static boolean checkOverlap( final CharSequence seq1, final CharSequence seq2 ) {\n+        final int seq1Len = seq1.length();\n+        final CharSequence seq1SubSeq = seq1.subSequence(seq1Len - Kmer.KSIZE + 1, seq1Len);\n+        final CharSequence seq2SubSeq = seq2.subSequence(0, Kmer.KSIZE - 1);\n+        return seq1SubSeq.equals(seq2SubSeq);\n+    }\n+\n+    /** set a unique componentId for every connected group of contigs **/\n+    @VisibleForTesting\n+    static int markComponents( final List<ContigImpl> contigs ) {\n+        for ( final ContigImpl contig : contigs ) {\n+            contig.setComponentId(0);\n+        }\n+\n+        int componentId = 0;\n+        for ( final ContigImpl contig : contigs ) {\n+            if ( contig.getComponentId() == 0 ) {\n+                contig.setComponentId(++componentId);\n+                markSuccessorComponents(contig);\n+                markSuccessorComponents(contig.rc());\n+            }\n+        }\n+        return componentId;\n+    }\n+\n+    private static void markSuccessorComponents( final Contig contig ) {\n+        final int componentId = contig.getComponentId();\n+        for ( final Contig successor : contig.getSuccessors() ) {\n+            if ( successor.getComponentId() == 0 ) {\n+                successor.canonical().setComponentId(componentId);\n+                markSuccessorComponents(successor);\n+                markSuccessorComponents(successor.rc());\n+            }\n+        }\n+    }\n+\n+    @VisibleForTesting\n+    static void markCycles( final List<ContigImpl> contigs ) {\n+        for ( final Contig contig : contigs ) {\n+            contig.setCyclic(false);\n+        }\n+\n+        final int nContigs = contigs.size();\n+        final Deque<Contig> deque = new ArrayDeque<>(nContigs);\n+        final Map<Contig, CutData> cutDataMap = new HashMap<>(nContigs * 3);\n+        for ( final Contig contig : contigs ) {\n+            if ( !cutDataMap.containsKey(contig) ) {\n+                markCyclesRecursion(contig, deque, cutDataMap);\n+            }\n+        }\n+    }\n+\n+    private static CutData markCyclesRecursion( final Contig contig,\n+                                                final Deque<Contig> deque,\n+                                                final Map<Contig, CutData> cutDataMap ) {\n+        final CutData cutData = new CutData();\n+        cutDataMap.put(contig, cutData);\n+        deque.addFirst(contig);\n+\n+        for ( final Contig successor : contig.getSuccessors() ) {\n+            final CutData successorCutData = cutDataMap.get(successor);\n+            if ( successorCutData == null ) {\n+                final int recursionVisitNum =\n+                        markCyclesRecursion(successor, deque, cutDataMap).minVisitNum;\n+                cutData.minVisitNum = Math.min(cutData.minVisitNum, recursionVisitNum);\n+            } else {\n+                cutData.minVisitNum = Math.min(cutData.minVisitNum, successorCutData.visitNum);\n+            }\n+        }\n+\n+        if ( cutData.visitNum == cutData.minVisitNum ) {\n+            Contig tig = deque.removeFirst();\n+            if ( tig == contig ) {\n+                cutDataMap.get(tig).visitNum = Integer.MAX_VALUE;\n+\n+                // single-vertex component -- cyclic only if self-referential\n+                if ( tig.getSuccessors().contains(tig) ) {\n+                    tig.setCyclic(true);\n+                }\n+            } else {\n+                while ( true ) {\n+                    // kill cross-links\n+                    cutDataMap.get(tig).visitNum = Integer.MAX_VALUE;\n+                    tig.setCyclic(true);\n+                    if ( tig == contig ) break;\n+                    tig = deque.removeFirst();\n+                }\n+            }\n+        }\n+        return cutData;\n+    }\n+\n+    @VisibleForTesting\n+    static boolean fillGaps( final KmerSet<KmerAdjacency> kmerAdjacencySet,\n+                             final List<GATKRead> reads ) {\n+        final Map<String, Integer> gapFillCounts = new HashMap<>();\n+        for ( final GATKRead read : reads ) {\n+            final Path path = new Path(read.getBasesNoCopy(), kmerAdjacencySet);\n+            final List<PathPart> parts = path.getParts();\n+            final int lastIdx = parts.size() - 1;\n+            for ( int idx = 1; idx < lastIdx; ++idx ) {\n+                final PathPart pathPart = parts.get(idx);\n+                if ( pathPart.isGap() ) {\n+                    final char prevCall = parts.get(idx - 1).getLastCall();\n+                    final char nextCall = parts.get(idx + 1).getFirstCall();\n+                    String gapFill = prevCall + pathPart.getSequence().toString() + nextCall;\n+                    final SequenceRC gapFillRC = new SequenceRC(gapFill);\n+                    if ( gapFillRC.compareTo(gapFill) < 0 ) {\n+                        gapFill = gapFillRC.toString();\n+                    }\n+                    gapFillCounts.merge(gapFill, 1, Integer::sum);\n+                }\n+            }\n+        }\n+\n+        boolean newKmers = false;\n+        for ( final Map.Entry<String, Integer> entry : gapFillCounts.entrySet() ) {\n+            final int nObservations = entry.getValue();\n+            if ( nObservations >= MIN_GAPFILL_COUNT ) {\n+                KmerAdjacency.kmerize(entry.getKey(), nObservations, kmerAdjacencySet);\n+                newKmers = true;\n+            }\n+        }\n+\n+        if ( newKmers ) {\n+            for ( final KmerAdjacency kmerAdjacency : kmerAdjacencySet ) {\n+                kmerAdjacency.clearContig();\n+            }\n+        }\n+        return newKmers;\n+    }\n+\n+    @VisibleForTesting\n+    static List<Path> pathReads( final KmerSet<KmerAdjacency> kmerAdjacencySet,\n+                          final List<GATKRead> reads ) {\n+        final List<Path> readPaths = new ArrayList<>(reads.size());\n+        for ( final GATKRead read : reads ) {\n+            readPaths.add(new Path(read.getBasesNoCopy(), kmerAdjacencySet));\n+        }\n+        return readPaths;\n+    }\n+\n+    @VisibleForTesting\n+    static Map<Contig,List<TransitPairCount>> collectTransitPairCounts(\n+            final List<ContigImpl> contigs,\n+            final List<Path> readPaths ) {\n+        final Map<Contig,List<TransitPairCount>> contigTransitsMap =\n+                new HashMap<>(3 * contigs.size());\n+        for ( final Path path : readPaths ) {\n+            final List<PathPart> parts = path.getParts();\n+            final int lastPart = parts.size() - 1;\n+            for ( int partIdx = 1; partIdx < lastPart; ++partIdx ) {\n+                final Contig prevContig = parts.get(partIdx - 1).getContig();\n+                if ( prevContig == null ) continue;\n+                final Contig curContig = parts.get(partIdx).getContig();\n+                if ( curContig == null ) {\n+                    partIdx += 1;\n+                    continue;\n+                }\n+                final Contig nextContig = parts.get(partIdx + 1).getContig();\n+                if ( nextContig == null ) {\n+                    partIdx += 2;\n+                    continue;\n+                }\n+                final TransitPairCount tpc = new TransitPairCount(prevContig, nextContig);\n+                final List<TransitPairCount> tpcList =\n+                        contigTransitsMap.computeIfAbsent(curContig, tig -> new ArrayList<>(4));\n+                final int idx = tpcList.indexOf(tpc);\n+                if ( idx != -1 ) {\n+                    tpcList.get(idx).observe();\n+                } else {\n+                    tpcList.add(tpc);\n+                    contigTransitsMap.computeIfAbsent(curContig.rc(), tig -> new ArrayList<>(4))\n+                            .add(tpc.getRC());\n+                }\n+            }\n+        }\n+        return contigTransitsMap;\n+    }\n+\n+    @VisibleForTesting\n+    static Set<Traversal> traverseAllPaths(\n+            final List<ContigImpl> contigs,\n+            final List<Path> readPaths,\n+            final Map<Contig, List<TransitPairCount>> contigTransitsMap ) {\n+        final Set<Traversal> traversalSet = new HashSet<>();\n+        final List<Contig> contigsList = new ArrayList<>();\n+        for ( final Contig contig : contigs ) {\n+            // untransited contigs are sources, sinks, or large contigs that can't be crossed by a read\n+            // build traversals from these\n+            if ( !contigTransitsMap.containsKey(contig) ) {\n+                boolean done = false;\n+                for ( final Contig successor : contig.getSuccessors() ) {\n+                    traverse(successor, contig,\n+                            contigsList, readPaths, contigTransitsMap, traversalSet);\n+                    done = true;\n+                }\n+                for ( final Contig predecessor : contig.getPredecessors() ) {\n+                    traverse(predecessor.rc(), contig.rc(),\n+                            contigsList, readPaths, contigTransitsMap, traversalSet);\n+                    done = true;\n+                }\n+                if ( !done ) { // if there were no predecessors or successors, it stands alone\n+                    addTraversal(new Traversal(Collections.singletonList(contig)), traversalSet);\n+                }\n+            }\n+        }\n+\n+        // look for transits that haven't been traced\n+        for ( final Map.Entry<Contig, List<TransitPairCount>> entry :\n+                contigTransitsMap.entrySet() ) {\n+            for ( final TransitPairCount tpc : entry.getValue() ) {\n+                if ( tpc.getCount() > 0 ) {\n+                    tpc.resetCount();\n+                    final Contig contig = entry.getKey();\n+                    final Set<Traversal> fwdTraversalSet = new HashSet<>();\n+                    traverse(tpc.getNextContig(), contig,\n+                            contigsList, readPaths, contigTransitsMap, fwdTraversalSet);\n+                    final Set<Traversal> revTraversalSet = new HashSet<>();\n+                    traverse(tpc.getPrevContig().rc(), contig.rc(),\n+                            contigsList, readPaths, contigTransitsMap, revTraversalSet);\n+                    for ( final Traversal revTraversal : revTraversalSet ) {\n+                        final Traversal revTraversalRC = revTraversal.rc();\n+                        for ( final Traversal fwdTraversal : fwdTraversalSet ) {\n+                            final int overlap =\n+                                    findMaxOverlap(revTraversalRC.getContigs(), fwdTraversal.getContigs());\n+                            final Traversal combo =\n+                                    Traversal.combineOverlappers(revTraversalRC, fwdTraversal, overlap);\n+                            addTraversal(combo, traversalSet);\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+\n+        return traversalSet;\n+    }\n+\n+    private static int findMaxOverlap( final List<Contig> prefixes, final List<Contig> suffixes ) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5NzgyNTM2OA=="}, "originalCommit": {"oid": "e2201c1ef4f8ba71f17e169f07756cfe2f1ecb49"}, "originalPosition": 723}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzc3NjI0MDY5OnYy", "diffSide": "RIGHT", "path": "src/main/java/org/broadinstitute/hellbender/tools/LocalAssembler.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMy0xOVQxNjo1NDowOFrOI6I3MQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNC0xNVQxNjoxNjoyMlrOJJwXjg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5NzgzMzUyMQ==", "bodyText": "I'm a bit confused about why we remove the last element from contigsList here. Is it necessarily the case that contig is the last element in contigsList if contig.isCyclic is true? Could you add a clarifying comment?", "url": "https://github.com/broadinstitute/gatk/pull/6989#discussion_r597833521", "createdAt": "2021-03-19T16:54:08Z", "author": {"login": "cwhelan"}, "path": "src/main/java/org/broadinstitute/hellbender/tools/LocalAssembler.java", "diffHunk": "@@ -0,0 +1,2306 @@\n+package org.broadinstitute.hellbender.tools;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import htsjdk.samtools.Cigar;\n+import htsjdk.samtools.CigarElement;\n+import htsjdk.samtools.CigarOperator;\n+import htsjdk.samtools.SAMUtils;\n+import org.broadinstitute.barclay.argparser.Argument;\n+import org.broadinstitute.barclay.argparser.BetaFeature;\n+import org.broadinstitute.barclay.argparser.CommandLineProgramProperties;\n+import org.broadinstitute.barclay.help.DocumentedFeature;\n+import org.broadinstitute.hellbender.cmdline.StandardArgumentDefinitions;\n+import org.broadinstitute.hellbender.cmdline.programgroups.CoverageAnalysisProgramGroup;\n+import org.broadinstitute.hellbender.exceptions.GATKException;\n+import org.broadinstitute.hellbender.tools.walkers.PairWalker;\n+import org.broadinstitute.hellbender.utils.SimpleInterval;\n+import org.broadinstitute.hellbender.utils.collections.HopscotchSet;\n+import org.broadinstitute.hellbender.utils.gcs.BucketUtils;\n+import org.broadinstitute.hellbender.utils.read.GATKRead;\n+\n+import java.io.BufferedWriter;\n+import java.io.FileWriter;\n+import java.io.IOException;\n+import java.io.OutputStreamWriter;\n+import java.util.*;\n+import java.util.zip.GZIPOutputStream;\n+\n+@DocumentedFeature\n+@CommandLineProgramProperties(\n+        summary = \"experiment\",\n+        oneLineSummary = \"experiment\",\n+        usageExample = \"gatk LocalAssembler\",\n+        programGroup = CoverageAnalysisProgramGroup.class\n+)\n+@BetaFeature\n+public class LocalAssembler extends PairWalker {\n+    public static final byte QMIN = 25;\n+    public static final int MIN_THIN_OBS = 4;\n+    public static final int MIN_GAPFILL_COUNT = 3;\n+    public static final int TOO_MANY_TRAVERSALS = 100000;\n+    public static final int TOO_MANY_SCAFFOLDS = 50000;\n+    public static final int MIN_SV_SIZE = 50;\n+\n+    @Argument(fullName=StandardArgumentDefinitions.OUTPUT_LONG_NAME,\n+            shortName=StandardArgumentDefinitions.OUTPUT_SHORT_NAME,\n+            doc=\"Write outputs to this file name prefix\", optional = true)\n+    public static String output;\n+\n+    @Argument(fullName=\"assembly-name\", doc=\"name of assembly used as a prefix for traversal names\")\n+    public static String assemblyName;\n+\n+    private final List<GATKRead> reads = new ArrayList<>();\n+\n+    @Override public boolean requiresIntervals() { return true; }\n+\n+    @Override public void apply( final GATKRead read, final GATKRead mate ) {\n+        trimOverruns(read, mate);\n+        reads.add(read);\n+        reads.add(mate);\n+    }\n+\n+    @Override public void applyUnpaired( final GATKRead read ) {\n+        reads.add(read);\n+    }\n+\n+    @Override public Object onTraversalSuccess() {\n+        super.onTraversalSuccess(); // flush any incomplete pairs\n+\n+        final int regionSize = getTraversalIntervals().stream().mapToInt(SimpleInterval::size).sum();\n+        final KmerSet<KmerAdjacency> kmerAdjacencySet = new KmerSet<>(10 * regionSize);\n+        kmerizeReads(reads, kmerAdjacencySet);\n+        List<ContigImpl> contigs = buildContigs(kmerAdjacencySet);\n+        connectContigs(contigs);\n+\n+        removeThinContigs(contigs, kmerAdjacencySet);\n+        weldPipes(contigs);\n+        markComponents(contigs);\n+\n+        if ( fillGaps(kmerAdjacencySet, reads) ) {\n+            contigs = buildContigs(kmerAdjacencySet);\n+            connectContigs(contigs);\n+            removeThinContigs(contigs, kmerAdjacencySet);\n+            weldPipes(contigs);\n+            markComponents(contigs);\n+        }\n+\n+        markCycles(contigs);\n+\n+        final String outputFilePrefix = output != null ? output : assemblyName;\n+        final List<Path> readPaths = pathReads(kmerAdjacencySet, reads);\n+        final Map<Contig,List<TransitPairCount>> contigTransitsMap =\n+                collectTransitPairCounts(contigs, readPaths);\n+        final String traversalsFilename = outputFilePrefix + \".traversals.fa.gz\";\n+        try {\n+            final List<Traversal> allTraversals =\n+                    new ArrayList<>(traverseAllPaths(contigs, readPaths, contigTransitsMap));\n+            writeTraversals(allTraversals, traversalsFilename);\n+            try {\n+                final String scaffoldsFileName = outputFilePrefix + \".scaffolds.fa.gz\";\n+                writeTraversals(createScaffolds(allTraversals), scaffoldsFileName);\n+            } catch ( final AssemblyTooComplexException x ) {\n+                logger.warn(\"Assembly too complex for scaffolding.\");\n+            }\n+        } catch ( final AssemblyTooComplexException x ) {\n+            logger.warn(\"Assembly too complex.  Writing contigs as traversals in \" +\n+                    traversalsFilename + \".\");\n+            final Collection<Traversal> contigTraversals = new ArrayList<>(contigs.size());\n+            for ( final Contig contig : contigs ) {\n+                contigTraversals.add(new Traversal(Collections.singletonList(contig)));\n+            }\n+            writeTraversals(contigTraversals, traversalsFilename);\n+        }\n+\n+        contigs.sort(Comparator.comparingInt(ContigImpl::getId));\n+        writeDOT(contigs, outputFilePrefix + \".assembly.dot\");\n+        writeContigs(contigs, outputFilePrefix + \".contigs.txt.gz\");\n+        writePaths(readPaths, outputFilePrefix + \".paths.txt.gz\");\n+        writeReads(reads, outputFilePrefix + \".reads.fastq.gz\");\n+        return null;\n+    }\n+\n+    /** trim read pairs of base calls that have gone past the end of a short fragment */\n+    private void trimOverruns( final GATKRead read, final GATKRead mate ) {\n+        // if both mapped and they're on different strands\n+        if ( !read.isUnmapped() && !mate.isUnmapped() &&\n+                read.isReverseStrand() != mate.isReverseStrand() ) {\n+            // and both start within 1 base on the ref\n+            if ( Math.abs(read.getStart() - read.getMateStart()) <= 1 ) {\n+                // and both end within 1 base\n+                final int readRefLen = read.getCigar().getReferenceLength();\n+                final int mateRefLen = mate.getCigar().getReferenceLength();\n+                if ( Math.abs(readRefLen - mateRefLen) <= 1 ) {\n+                    if ( mate.isReverseStrand() ) {\n+                        trimClips(read, mate);\n+                    } else {\n+                        trimClips(mate, read);\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    private void trimClips( final GATKRead fwd, final GATKRead rev ) {\n+        final List<CigarElement> fwdElements = fwd.getCigarElements();\n+        final List<CigarElement> revElements = rev.getCigarElements();\n+        final int lastElementIdx = fwdElements.size() - 1;\n+        final CigarElement fwdLastElement = fwdElements.get(lastElementIdx);\n+        final CigarElement revFirstElement = revElements.get(0);\n+        if ( fwdLastElement.getOperator() == CigarOperator.S &&\n+                revFirstElement.getOperator() == CigarOperator.S ) {\n+            final byte[] fwdBases = fwd.getBasesNoCopy();\n+            final int lastElementLen = fwdLastElement.getLength();\n+            fwd.setBases(Arrays.copyOfRange(fwdBases, 0, fwdBases.length - lastElementLen));\n+            final byte[] fwdQuals = fwd.getBaseQualitiesNoCopy();\n+            if ( fwdQuals.length > 0 ) {\n+                final int qualsLen = fwdQuals.length - lastElementLen;\n+                fwd.setBaseQualities(Arrays.copyOfRange(fwdQuals, 0, qualsLen));\n+            }\n+            final List<CigarElement> newFwdElements = new ArrayList<>(fwdElements);\n+            newFwdElements.set(lastElementIdx, new CigarElement(lastElementLen, CigarOperator.H));\n+            fwd.setCigar(new Cigar(newFwdElements));\n+\n+            final byte[] revBases = rev.getBasesNoCopy();\n+            final int firstElementLen = revFirstElement.getLength();\n+            rev.setBases(Arrays.copyOfRange(revBases, firstElementLen, revBases.length));\n+            final byte[] revQuals = rev.getBaseQualitiesNoCopy();\n+            if ( revQuals.length > 0 ) {\n+                rev.setBaseQualities(Arrays.copyOfRange(revQuals, firstElementLen, revQuals.length));\n+            }\n+            final List<CigarElement> newRevElements = new ArrayList<>(revElements);\n+            newRevElements.set(0, new CigarElement(firstElementLen, CigarOperator.H));\n+            rev.setCigar(new Cigar(newRevElements));\n+        }\n+    }\n+\n+    @VisibleForTesting\n+    static void kmerizeReads( final List<GATKRead> reads,\n+                              final KmerSet<KmerAdjacency> kmerAdjacencySet ) {\n+        for ( final GATKRead read : reads ) {\n+            final byte[] calls = read.getBasesNoCopy();\n+            final byte[] quals = read.getBaseQualitiesNoCopy();\n+            KmerAdjacency.kmerize(calls, quals, QMIN, kmerAdjacencySet);\n+        }\n+    }\n+\n+    /** gather unbranched strings of kmers into contigs **/\n+    @VisibleForTesting\n+    static List<ContigImpl> buildContigs( final KmerSet<KmerAdjacency> kmerAdjacencySet ) {\n+        // gather strings of kmers that have a single predecessor and single successor into contigs\n+        final List<ContigImpl> contigs = new ArrayList<>();\n+        int nContigs = 0;\n+        for ( final KmerAdjacency kmerAdjacency : kmerAdjacencySet ) {\n+            if ( kmerAdjacency.getContig() == null ) {\n+                ContigImpl contig = null;\n+                final KmerAdjacency predecessor = kmerAdjacency.getSolePredecessor();\n+                if ( predecessor == null ||\n+                        predecessor.getSuccessorCount() > 1 ||\n+                        predecessor == kmerAdjacency.rc() ) {\n+                    contig = new ContigImpl(++nContigs, kmerAdjacency);\n+                } else {\n+                    final KmerAdjacency successor = kmerAdjacency.getSoleSuccessor();\n+                    if ( successor == null ||\n+                            successor.getPredecessorCount() > 1 ||\n+                            successor == kmerAdjacency.rc() ) {\n+                        contig = new ContigImpl(++nContigs, kmerAdjacency.rc());\n+                    }\n+                }\n+                if ( contig != null ) {\n+                    contigs.add(contig);\n+                }\n+            }\n+        }\n+\n+        // if there are smooth circles like a plasmid, gather them together as a contig, too\n+        for ( final KmerAdjacency kmerAdjacency : kmerAdjacencySet ) {\n+            if ( kmerAdjacency.getContig() == null ) {\n+                contigs.add(new ContigImpl(++nContigs, kmerAdjacency));\n+            }\n+        }\n+\n+        return contigs;\n+    }\n+\n+    /** connect contigs when the final kmer of one contig is adjacent to the inital contig of another **/\n+    @VisibleForTesting\n+    static void connectContigs( final List<ContigImpl> contigs ) {\n+        final int nContigs = contigs.size();\n+        final KmerSet<ContigEndKmer> contigEnds = new KmerSet<>(2*nContigs);\n+        for ( int contigId = 0; contigId != nContigs; ++contigId ) {\n+            final ContigImpl contig = contigs.get(contigId);\n+            final KmerAdjacency fwdKmer = contig.getFirstKmer();\n+            final KmerAdjacency revKmer = contig.getLastKmer().rc();\n+            if ( fwdKmer == revKmer ) {\n+                contigEnds.add(new ContigEndKmer(fwdKmer.getKVal(), contig, ContigOrientation.BOTH));\n+            } else {\n+                contigEnds.add(new ContigEndKmer(fwdKmer.getKVal(), contig, ContigOrientation.FWD));\n+                contigEnds.add(new ContigEndKmer(revKmer.getKVal(), contig, ContigOrientation.REV));\n+            }\n+        }\n+\n+        for ( int contigId = 0; contigId != nContigs; ++contigId ) {\n+            final Contig contig = contigs.get(contigId);\n+\n+            final KmerAdjacency start = contig.getFirstKmer();\n+            final int predecessorCount = start.getPredecessorCount();\n+            if ( predecessorCount > 0 ) {\n+                final List<Contig> predecessors = contig.getPredecessors();\n+                final int mask = start.getPredecessorMask();\n+                for ( int call = 0; call != 4; ++call ) {\n+                    if ( (mask & (1 << call)) != 0 ) {\n+                        final long kVal =\n+                                KmerAdjacency.reverseComplement(start.getPredecessorVal(call));\n+                        final ContigEndKmer contigEndKmer = contigEnds.find(new Kmer(kVal));\n+                        if ( contigEndKmer == null ) {\n+                            throw new GATKException(\"missing contig end kmer\");\n+                        }\n+                        switch ( contigEndKmer.getContigOrientation() ) {\n+                            case FWD:\n+                                predecessors.add(contigEndKmer.getContig().rc());\n+                                break;\n+                            case REV:\n+                                predecessors.add(contigEndKmer.getContig());\n+                                break;\n+                            case BOTH:\n+                                predecessors.add(contigEndKmer.getContig());\n+                                predecessors.add(contigEndKmer.getContig().rc());\n+                                break;\n+                        }\n+                    }\n+                }\n+            }\n+\n+            final KmerAdjacency end = contig.getLastKmer();\n+            final int successorCount = end.getSuccessorCount();\n+            if ( successorCount > 0 ) {\n+                final List<Contig> successors = contig.getSuccessors();\n+                final int mask = end.getSuccessorMask();\n+                for ( int call = 0; call != 4; ++call ) {\n+                    if ( (mask & (1 << call)) != 0 ) {\n+                        final long kVal = end.getSuccessorVal(call);\n+                        final ContigEndKmer contigEndKmer = contigEnds.find(new Kmer(kVal));\n+                        if ( contigEndKmer == null ) {\n+                            throw new GATKException(\"missing contig end kmer\");\n+                        }\n+                        switch ( contigEndKmer.getContigOrientation() ) {\n+                            case FWD:\n+                                successors.add(contigEndKmer.getContig());\n+                                break;\n+                            case REV:\n+                                successors.add(contigEndKmer.getContig().rc());\n+                                break;\n+                            case BOTH:\n+                                successors.add(contigEndKmer.getContig());\n+                                successors.add(contigEndKmer.getContig().rc());\n+                                break;\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    /** remove contigs that have little evidence **/\n+    @VisibleForTesting\n+    static void removeThinContigs( final List<ContigImpl> contigs,\n+                                           final KmerSet<KmerAdjacency> kmerAdjacencySet ) {\n+        contigs.sort(Comparator.comparingInt(ContigImpl::getMaxObservations));\n+        boolean contigRemoved;\n+        do {\n+            // figure out which contigs are cut points\n+            // i.e., those contigs which, if removed, would result in a graph with more connected components\n+            final int nContigs = contigs.size();\n+            final Map<Contig, CutData> cutDataMap = new HashMap<>(nContigs * 3);\n+\n+            for ( final ContigImpl contig : contigs ) {\n+                if ( cutDataMap.containsKey(contig) ) {\n+                    continue;\n+                }\n+\n+                cutDataMap.put(contig, new CutData());\n+                int children = 0;\n+                for ( final Contig nextContig : contig.getSuccessors() ) {\n+                    if ( !cutDataMap.containsKey(nextContig) ) {\n+                        findCuts(nextContig, contig, cutDataMap);\n+                        children += 1;\n+                    }\n+                }\n+                for ( final Contig nextContig : contig.getPredecessors() ) {\n+                    if ( !cutDataMap.containsKey(nextContig) ) {\n+                        findCuts(nextContig, contig, cutDataMap);\n+                        children += 1;\n+                    }\n+                }\n+                if ( children >= 2 ) {\n+                    contig.setCut(true);\n+                }\n+            }\n+\n+            // remove poorly attested (low max observations) contigs, unless they are cut points\n+            contigRemoved = false;\n+            final Iterator<ContigImpl> itr = contigs.iterator();\n+            while ( itr.hasNext() ) {\n+                final Contig contig = itr.next();\n+                if ( contig.getMaxObservations() < MIN_THIN_OBS && !contig.isCut() ) {\n+                    unlinkContig(contig, kmerAdjacencySet);\n+                    itr.remove();\n+                    contigRemoved = true;\n+                    break;\n+                }\n+            }\n+        } while ( contigRemoved );\n+        contigs.sort(Comparator.comparingInt(ContigImpl::getId));\n+    }\n+\n+    private static CutData findCuts( final Contig contig,\n+                                     final Contig parent,\n+                                     final Map<Contig, CutData> cutDataMap ) {\n+        final CutData cutData = new CutData();\n+        cutDataMap.put(contig, cutData);\n+        for ( final Contig nextContig : contig.getSuccessors() ) {\n+            if ( nextContig == parent ) {\n+                continue;\n+            }\n+            CutData nextCutData = cutDataMap.get(nextContig);\n+            if ( nextCutData != null ) {\n+                cutData.minVisitNum = Math.min(cutData.minVisitNum, nextCutData.visitNum);\n+            } else {\n+                nextCutData = findCuts(nextContig, contig, cutDataMap);\n+                cutData.minVisitNum = Math.min(cutData.minVisitNum, nextCutData.minVisitNum);\n+                if ( nextCutData.minVisitNum >= cutData.visitNum ) {\n+                    contig.setCut(true);\n+                }\n+            }\n+        }\n+        for ( final Contig nextContig : contig.getPredecessors() ) {\n+            if ( nextContig == parent ) {\n+                continue;\n+            }\n+            CutData nextCutData = cutDataMap.get(nextContig);\n+            if ( nextCutData != null ) {\n+                cutData.minVisitNum = Math.min(cutData.minVisitNum, nextCutData.visitNum);\n+            } else {\n+                nextCutData = findCuts(nextContig, contig, cutDataMap);\n+                cutData.minVisitNum = Math.min(cutData.minVisitNum, nextCutData.minVisitNum);\n+                if ( nextCutData.minVisitNum >= cutData.visitNum ) {\n+                    contig.setCut(true);\n+                }\n+            }\n+        }\n+        return cutData;\n+    }\n+\n+    @VisibleForTesting\n+    static void unlinkContig( final Contig contig,\n+                                      final KmerSet<KmerAdjacency> kmerAdjacencySet ) {\n+        final KmerAdjacency firstKmer = contig.getFirstKmer();\n+        final int firstKmerFinalCall = firstKmer.getFinalCall();\n+        for ( final Contig predecessor : contig.getPredecessors() ) {\n+            if ( predecessor != contig && predecessor != contig.rc() ) {\n+                predecessor.getLastKmer().removeSuccessor(firstKmerFinalCall, kmerAdjacencySet);\n+                if ( !predecessor.getSuccessors().remove(contig) ) {\n+                    throw new GATKException(\"failed to find predecessor link\");\n+                }\n+            }\n+        }\n+\n+        final KmerAdjacency lastKmer = contig.getLastKmer();\n+        final int lastKmerInitialCall = lastKmer.getInitialCall();\n+        for ( final Contig successor : contig.getSuccessors() ) {\n+            if ( successor != contig && successor != contig.rc() ) {\n+                successor.getFirstKmer().removePredecessor(lastKmerInitialCall, kmerAdjacencySet);\n+                if ( !successor.getPredecessors().remove(contig) ) {\n+                    throw new GATKException(\"failed to find successor link\");\n+                }\n+            }\n+        }\n+\n+        KmerAdjacency nextKmer = firstKmer;\n+        KmerAdjacency kmer;\n+        do {\n+            kmer = nextKmer;\n+            nextKmer = kmer.getSoleSuccessor();\n+            kmerAdjacencySet.remove(kmer.canonical());\n+        } while ( kmer != lastKmer );\n+    }\n+\n+    private static void updateKmerContig( final KmerAdjacency firstKmer,\n+                                          final KmerAdjacency lastKmer,\n+                                          final Contig contig ) {\n+        int offset = 0;\n+        for ( KmerAdjacency kmer = firstKmer; kmer != lastKmer; kmer = kmer.getSoleSuccessor() ) {\n+            if ( kmer == null ) {\n+                throw new GATKException(\"contig does not have a flat pipeline of kmers\");\n+            }\n+            kmer.clearContig();\n+            kmer.setContigOffset(contig, offset++);\n+        }\n+        lastKmer.clearContig();\n+        lastKmer.setContigOffset(contig, offset);\n+        if ( offset + Kmer.KSIZE != contig.size() ) {\n+            throw new GATKException(\"kmer chain length does not equal contig size\");\n+        }\n+    }\n+\n+    /** replace adjacent contigs without branches with a single, larger contig **/\n+    @VisibleForTesting\n+    static void weldPipes( final List<ContigImpl> contigs ) {\n+        for ( int contigIdx = 0; contigIdx != contigs.size(); ++contigIdx ) {\n+            final ContigImpl contig = contigs.get(contigIdx);\n+            if ( contig.getSuccessors().size() == 1 ) {\n+                final Contig successor = contig.getSuccessors().get(0);\n+                if ( successor != contig && successor != contig.rc() &&\n+                        successor.getPredecessors().size() == 1 ) {\n+                    contigs.set(contigIdx, join(contig.getId(), contig, successor));\n+                    if ( !contigs.remove(successor.canonical()) ) {\n+                        throw new GATKException(\"successor linkage is messed up\");\n+                    }\n+                    contigIdx -= 1; // reconsider the new contig -- there might be more joining possible\n+                    continue;\n+                }\n+            }\n+            if ( contig.getPredecessors().size() == 1 ) {\n+                final Contig predecessor = contig.getPredecessors().get(0);\n+                if ( predecessor != contig && predecessor != contig.rc() &&\n+                        predecessor.getSuccessors().size() == 1 ) {\n+                    contigs.set(contigIdx, join(contig.getId(), predecessor, contig));\n+                    if ( !contigs.remove(predecessor.canonical()) ) {\n+                        throw new GATKException(\"predecessor linkage is messed up\");\n+                    }\n+                    contigIdx -= 1; // reconsider\n+                }\n+            }\n+        }\n+    }\n+\n+    private static ContigImpl join( final int id, final Contig predecessor, final Contig successor ) {\n+        if ( !checkOverlap(predecessor.getSequence(), successor.getSequence()) ) {\n+                throw new GATKException(\"sequences can't be joined\");\n+        }\n+        final ContigImpl joinedContig = new ContigImpl(id, predecessor, successor);\n+        updateKmerContig(joinedContig.getFirstKmer(), joinedContig.getLastKmer(), joinedContig);\n+        return joinedContig;\n+    }\n+\n+    private static boolean checkOverlap( final CharSequence seq1, final CharSequence seq2 ) {\n+        final int seq1Len = seq1.length();\n+        final CharSequence seq1SubSeq = seq1.subSequence(seq1Len - Kmer.KSIZE + 1, seq1Len);\n+        final CharSequence seq2SubSeq = seq2.subSequence(0, Kmer.KSIZE - 1);\n+        return seq1SubSeq.equals(seq2SubSeq);\n+    }\n+\n+    /** set a unique componentId for every connected group of contigs **/\n+    @VisibleForTesting\n+    static int markComponents( final List<ContigImpl> contigs ) {\n+        for ( final ContigImpl contig : contigs ) {\n+            contig.setComponentId(0);\n+        }\n+\n+        int componentId = 0;\n+        for ( final ContigImpl contig : contigs ) {\n+            if ( contig.getComponentId() == 0 ) {\n+                contig.setComponentId(++componentId);\n+                markSuccessorComponents(contig);\n+                markSuccessorComponents(contig.rc());\n+            }\n+        }\n+        return componentId;\n+    }\n+\n+    private static void markSuccessorComponents( final Contig contig ) {\n+        final int componentId = contig.getComponentId();\n+        for ( final Contig successor : contig.getSuccessors() ) {\n+            if ( successor.getComponentId() == 0 ) {\n+                successor.canonical().setComponentId(componentId);\n+                markSuccessorComponents(successor);\n+                markSuccessorComponents(successor.rc());\n+            }\n+        }\n+    }\n+\n+    @VisibleForTesting\n+    static void markCycles( final List<ContigImpl> contigs ) {\n+        for ( final Contig contig : contigs ) {\n+            contig.setCyclic(false);\n+        }\n+\n+        final int nContigs = contigs.size();\n+        final Deque<Contig> deque = new ArrayDeque<>(nContigs);\n+        final Map<Contig, CutData> cutDataMap = new HashMap<>(nContigs * 3);\n+        for ( final Contig contig : contigs ) {\n+            if ( !cutDataMap.containsKey(contig) ) {\n+                markCyclesRecursion(contig, deque, cutDataMap);\n+            }\n+        }\n+    }\n+\n+    private static CutData markCyclesRecursion( final Contig contig,\n+                                                final Deque<Contig> deque,\n+                                                final Map<Contig, CutData> cutDataMap ) {\n+        final CutData cutData = new CutData();\n+        cutDataMap.put(contig, cutData);\n+        deque.addFirst(contig);\n+\n+        for ( final Contig successor : contig.getSuccessors() ) {\n+            final CutData successorCutData = cutDataMap.get(successor);\n+            if ( successorCutData == null ) {\n+                final int recursionVisitNum =\n+                        markCyclesRecursion(successor, deque, cutDataMap).minVisitNum;\n+                cutData.minVisitNum = Math.min(cutData.minVisitNum, recursionVisitNum);\n+            } else {\n+                cutData.minVisitNum = Math.min(cutData.minVisitNum, successorCutData.visitNum);\n+            }\n+        }\n+\n+        if ( cutData.visitNum == cutData.minVisitNum ) {\n+            Contig tig = deque.removeFirst();\n+            if ( tig == contig ) {\n+                cutDataMap.get(tig).visitNum = Integer.MAX_VALUE;\n+\n+                // single-vertex component -- cyclic only if self-referential\n+                if ( tig.getSuccessors().contains(tig) ) {\n+                    tig.setCyclic(true);\n+                }\n+            } else {\n+                while ( true ) {\n+                    // kill cross-links\n+                    cutDataMap.get(tig).visitNum = Integer.MAX_VALUE;\n+                    tig.setCyclic(true);\n+                    if ( tig == contig ) break;\n+                    tig = deque.removeFirst();\n+                }\n+            }\n+        }\n+        return cutData;\n+    }\n+\n+    @VisibleForTesting\n+    static boolean fillGaps( final KmerSet<KmerAdjacency> kmerAdjacencySet,\n+                             final List<GATKRead> reads ) {\n+        final Map<String, Integer> gapFillCounts = new HashMap<>();\n+        for ( final GATKRead read : reads ) {\n+            final Path path = new Path(read.getBasesNoCopy(), kmerAdjacencySet);\n+            final List<PathPart> parts = path.getParts();\n+            final int lastIdx = parts.size() - 1;\n+            for ( int idx = 1; idx < lastIdx; ++idx ) {\n+                final PathPart pathPart = parts.get(idx);\n+                if ( pathPart.isGap() ) {\n+                    final char prevCall = parts.get(idx - 1).getLastCall();\n+                    final char nextCall = parts.get(idx + 1).getFirstCall();\n+                    String gapFill = prevCall + pathPart.getSequence().toString() + nextCall;\n+                    final SequenceRC gapFillRC = new SequenceRC(gapFill);\n+                    if ( gapFillRC.compareTo(gapFill) < 0 ) {\n+                        gapFill = gapFillRC.toString();\n+                    }\n+                    gapFillCounts.merge(gapFill, 1, Integer::sum);\n+                }\n+            }\n+        }\n+\n+        boolean newKmers = false;\n+        for ( final Map.Entry<String, Integer> entry : gapFillCounts.entrySet() ) {\n+            final int nObservations = entry.getValue();\n+            if ( nObservations >= MIN_GAPFILL_COUNT ) {\n+                KmerAdjacency.kmerize(entry.getKey(), nObservations, kmerAdjacencySet);\n+                newKmers = true;\n+            }\n+        }\n+\n+        if ( newKmers ) {\n+            for ( final KmerAdjacency kmerAdjacency : kmerAdjacencySet ) {\n+                kmerAdjacency.clearContig();\n+            }\n+        }\n+        return newKmers;\n+    }\n+\n+    @VisibleForTesting\n+    static List<Path> pathReads( final KmerSet<KmerAdjacency> kmerAdjacencySet,\n+                          final List<GATKRead> reads ) {\n+        final List<Path> readPaths = new ArrayList<>(reads.size());\n+        for ( final GATKRead read : reads ) {\n+            readPaths.add(new Path(read.getBasesNoCopy(), kmerAdjacencySet));\n+        }\n+        return readPaths;\n+    }\n+\n+    @VisibleForTesting\n+    static Map<Contig,List<TransitPairCount>> collectTransitPairCounts(\n+            final List<ContigImpl> contigs,\n+            final List<Path> readPaths ) {\n+        final Map<Contig,List<TransitPairCount>> contigTransitsMap =\n+                new HashMap<>(3 * contigs.size());\n+        for ( final Path path : readPaths ) {\n+            final List<PathPart> parts = path.getParts();\n+            final int lastPart = parts.size() - 1;\n+            for ( int partIdx = 1; partIdx < lastPart; ++partIdx ) {\n+                final Contig prevContig = parts.get(partIdx - 1).getContig();\n+                if ( prevContig == null ) continue;\n+                final Contig curContig = parts.get(partIdx).getContig();\n+                if ( curContig == null ) {\n+                    partIdx += 1;\n+                    continue;\n+                }\n+                final Contig nextContig = parts.get(partIdx + 1).getContig();\n+                if ( nextContig == null ) {\n+                    partIdx += 2;\n+                    continue;\n+                }\n+                final TransitPairCount tpc = new TransitPairCount(prevContig, nextContig);\n+                final List<TransitPairCount> tpcList =\n+                        contigTransitsMap.computeIfAbsent(curContig, tig -> new ArrayList<>(4));\n+                final int idx = tpcList.indexOf(tpc);\n+                if ( idx != -1 ) {\n+                    tpcList.get(idx).observe();\n+                } else {\n+                    tpcList.add(tpc);\n+                    contigTransitsMap.computeIfAbsent(curContig.rc(), tig -> new ArrayList<>(4))\n+                            .add(tpc.getRC());\n+                }\n+            }\n+        }\n+        return contigTransitsMap;\n+    }\n+\n+    @VisibleForTesting\n+    static Set<Traversal> traverseAllPaths(\n+            final List<ContigImpl> contigs,\n+            final List<Path> readPaths,\n+            final Map<Contig, List<TransitPairCount>> contigTransitsMap ) {\n+        final Set<Traversal> traversalSet = new HashSet<>();\n+        final List<Contig> contigsList = new ArrayList<>();\n+        for ( final Contig contig : contigs ) {\n+            // untransited contigs are sources, sinks, or large contigs that can't be crossed by a read\n+            // build traversals from these\n+            if ( !contigTransitsMap.containsKey(contig) ) {\n+                boolean done = false;\n+                for ( final Contig successor : contig.getSuccessors() ) {\n+                    traverse(successor, contig,\n+                            contigsList, readPaths, contigTransitsMap, traversalSet);\n+                    done = true;\n+                }\n+                for ( final Contig predecessor : contig.getPredecessors() ) {\n+                    traverse(predecessor.rc(), contig.rc(),\n+                            contigsList, readPaths, contigTransitsMap, traversalSet);\n+                    done = true;\n+                }\n+                if ( !done ) { // if there were no predecessors or successors, it stands alone\n+                    addTraversal(new Traversal(Collections.singletonList(contig)), traversalSet);\n+                }\n+            }\n+        }\n+\n+        // look for transits that haven't been traced\n+        for ( final Map.Entry<Contig, List<TransitPairCount>> entry :\n+                contigTransitsMap.entrySet() ) {\n+            for ( final TransitPairCount tpc : entry.getValue() ) {\n+                if ( tpc.getCount() > 0 ) {\n+                    tpc.resetCount();\n+                    final Contig contig = entry.getKey();\n+                    final Set<Traversal> fwdTraversalSet = new HashSet<>();\n+                    traverse(tpc.getNextContig(), contig,\n+                            contigsList, readPaths, contigTransitsMap, fwdTraversalSet);\n+                    final Set<Traversal> revTraversalSet = new HashSet<>();\n+                    traverse(tpc.getPrevContig().rc(), contig.rc(),\n+                            contigsList, readPaths, contigTransitsMap, revTraversalSet);\n+                    for ( final Traversal revTraversal : revTraversalSet ) {\n+                        final Traversal revTraversalRC = revTraversal.rc();\n+                        for ( final Traversal fwdTraversal : fwdTraversalSet ) {\n+                            final int overlap =\n+                                    findMaxOverlap(revTraversalRC.getContigs(), fwdTraversal.getContigs());\n+                            final Traversal combo =\n+                                    Traversal.combineOverlappers(revTraversalRC, fwdTraversal, overlap);\n+                            addTraversal(combo, traversalSet);\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+\n+        return traversalSet;\n+    }\n+\n+    private static int findMaxOverlap( final List<Contig> prefixes, final List<Contig> suffixes ) {\n+        final int nPrefixes = prefixes.size();\n+        final Contig firstSuffix = suffixes.get(0);\n+        if ( !firstSuffix.isCyclic() ) {\n+            return prefixes.get(nPrefixes - 1) == firstSuffix ? 1 : 0;\n+        }\n+        final int nSuffixes = suffixes.size();\n+        for ( int prefixIdx = Math.max(0, nPrefixes - nSuffixes); prefixIdx != nPrefixes; ++prefixIdx ) {\n+            if ( prefixes.get(prefixIdx) == firstSuffix ) {\n+                int suffixIdx = 1;\n+                boolean match = true;\n+                for ( int prefixIdx2 = prefixIdx + 1; prefixIdx2 != nPrefixes; ++prefixIdx2 ) {\n+                    if ( prefixes.get(prefixIdx2) != suffixes.get(suffixIdx++) ) {\n+                        match = false;\n+                        break;\n+                    }\n+                }\n+                if ( match ) {\n+                    return nPrefixes - prefixIdx;\n+                }\n+            }\n+        }\n+        return 0;\n+    }\n+\n+    private static void traverse( final Contig contig,\n+                                  final Contig predecessor,\n+                                  final List<Contig> contigsList,\n+                                  final List<Path> readPaths,\n+                                  final Map<Contig, List<TransitPairCount>> contigTransitsMap,\n+                                  final Set<Traversal> traversalSet ) {\n+        contigsList.add(predecessor);\n+        if ( contig.isCyclic() ) {\n+            traverseCycle(contig, contigsList, readPaths, contigTransitsMap, traversalSet);\n+            contigsList.remove(contigsList.size() - 1);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e2201c1ef4f8ba71f17e169f07756cfe2f1ecb49"}, "originalPosition": 757}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxNDIwOTQyMg==", "bodyText": "This is a depth-first search and the traverse method is recursive.  So whatever we add to the list of contigs in traverse we must remove before we return.  The next line is a return, so in line 757 we're just undoing what we did on line 754 before we return.  If we don't take this early return we'll pop this last element off the list at the very end of the method.\nI'll add some comments.", "url": "https://github.com/broadinstitute/gatk/pull/6989#discussion_r614209422", "createdAt": "2021-04-15T16:16:22Z", "author": {"login": "tedsharpe"}, "path": "src/main/java/org/broadinstitute/hellbender/tools/LocalAssembler.java", "diffHunk": "@@ -0,0 +1,2306 @@\n+package org.broadinstitute.hellbender.tools;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import htsjdk.samtools.Cigar;\n+import htsjdk.samtools.CigarElement;\n+import htsjdk.samtools.CigarOperator;\n+import htsjdk.samtools.SAMUtils;\n+import org.broadinstitute.barclay.argparser.Argument;\n+import org.broadinstitute.barclay.argparser.BetaFeature;\n+import org.broadinstitute.barclay.argparser.CommandLineProgramProperties;\n+import org.broadinstitute.barclay.help.DocumentedFeature;\n+import org.broadinstitute.hellbender.cmdline.StandardArgumentDefinitions;\n+import org.broadinstitute.hellbender.cmdline.programgroups.CoverageAnalysisProgramGroup;\n+import org.broadinstitute.hellbender.exceptions.GATKException;\n+import org.broadinstitute.hellbender.tools.walkers.PairWalker;\n+import org.broadinstitute.hellbender.utils.SimpleInterval;\n+import org.broadinstitute.hellbender.utils.collections.HopscotchSet;\n+import org.broadinstitute.hellbender.utils.gcs.BucketUtils;\n+import org.broadinstitute.hellbender.utils.read.GATKRead;\n+\n+import java.io.BufferedWriter;\n+import java.io.FileWriter;\n+import java.io.IOException;\n+import java.io.OutputStreamWriter;\n+import java.util.*;\n+import java.util.zip.GZIPOutputStream;\n+\n+@DocumentedFeature\n+@CommandLineProgramProperties(\n+        summary = \"experiment\",\n+        oneLineSummary = \"experiment\",\n+        usageExample = \"gatk LocalAssembler\",\n+        programGroup = CoverageAnalysisProgramGroup.class\n+)\n+@BetaFeature\n+public class LocalAssembler extends PairWalker {\n+    public static final byte QMIN = 25;\n+    public static final int MIN_THIN_OBS = 4;\n+    public static final int MIN_GAPFILL_COUNT = 3;\n+    public static final int TOO_MANY_TRAVERSALS = 100000;\n+    public static final int TOO_MANY_SCAFFOLDS = 50000;\n+    public static final int MIN_SV_SIZE = 50;\n+\n+    @Argument(fullName=StandardArgumentDefinitions.OUTPUT_LONG_NAME,\n+            shortName=StandardArgumentDefinitions.OUTPUT_SHORT_NAME,\n+            doc=\"Write outputs to this file name prefix\", optional = true)\n+    public static String output;\n+\n+    @Argument(fullName=\"assembly-name\", doc=\"name of assembly used as a prefix for traversal names\")\n+    public static String assemblyName;\n+\n+    private final List<GATKRead> reads = new ArrayList<>();\n+\n+    @Override public boolean requiresIntervals() { return true; }\n+\n+    @Override public void apply( final GATKRead read, final GATKRead mate ) {\n+        trimOverruns(read, mate);\n+        reads.add(read);\n+        reads.add(mate);\n+    }\n+\n+    @Override public void applyUnpaired( final GATKRead read ) {\n+        reads.add(read);\n+    }\n+\n+    @Override public Object onTraversalSuccess() {\n+        super.onTraversalSuccess(); // flush any incomplete pairs\n+\n+        final int regionSize = getTraversalIntervals().stream().mapToInt(SimpleInterval::size).sum();\n+        final KmerSet<KmerAdjacency> kmerAdjacencySet = new KmerSet<>(10 * regionSize);\n+        kmerizeReads(reads, kmerAdjacencySet);\n+        List<ContigImpl> contigs = buildContigs(kmerAdjacencySet);\n+        connectContigs(contigs);\n+\n+        removeThinContigs(contigs, kmerAdjacencySet);\n+        weldPipes(contigs);\n+        markComponents(contigs);\n+\n+        if ( fillGaps(kmerAdjacencySet, reads) ) {\n+            contigs = buildContigs(kmerAdjacencySet);\n+            connectContigs(contigs);\n+            removeThinContigs(contigs, kmerAdjacencySet);\n+            weldPipes(contigs);\n+            markComponents(contigs);\n+        }\n+\n+        markCycles(contigs);\n+\n+        final String outputFilePrefix = output != null ? output : assemblyName;\n+        final List<Path> readPaths = pathReads(kmerAdjacencySet, reads);\n+        final Map<Contig,List<TransitPairCount>> contigTransitsMap =\n+                collectTransitPairCounts(contigs, readPaths);\n+        final String traversalsFilename = outputFilePrefix + \".traversals.fa.gz\";\n+        try {\n+            final List<Traversal> allTraversals =\n+                    new ArrayList<>(traverseAllPaths(contigs, readPaths, contigTransitsMap));\n+            writeTraversals(allTraversals, traversalsFilename);\n+            try {\n+                final String scaffoldsFileName = outputFilePrefix + \".scaffolds.fa.gz\";\n+                writeTraversals(createScaffolds(allTraversals), scaffoldsFileName);\n+            } catch ( final AssemblyTooComplexException x ) {\n+                logger.warn(\"Assembly too complex for scaffolding.\");\n+            }\n+        } catch ( final AssemblyTooComplexException x ) {\n+            logger.warn(\"Assembly too complex.  Writing contigs as traversals in \" +\n+                    traversalsFilename + \".\");\n+            final Collection<Traversal> contigTraversals = new ArrayList<>(contigs.size());\n+            for ( final Contig contig : contigs ) {\n+                contigTraversals.add(new Traversal(Collections.singletonList(contig)));\n+            }\n+            writeTraversals(contigTraversals, traversalsFilename);\n+        }\n+\n+        contigs.sort(Comparator.comparingInt(ContigImpl::getId));\n+        writeDOT(contigs, outputFilePrefix + \".assembly.dot\");\n+        writeContigs(contigs, outputFilePrefix + \".contigs.txt.gz\");\n+        writePaths(readPaths, outputFilePrefix + \".paths.txt.gz\");\n+        writeReads(reads, outputFilePrefix + \".reads.fastq.gz\");\n+        return null;\n+    }\n+\n+    /** trim read pairs of base calls that have gone past the end of a short fragment */\n+    private void trimOverruns( final GATKRead read, final GATKRead mate ) {\n+        // if both mapped and they're on different strands\n+        if ( !read.isUnmapped() && !mate.isUnmapped() &&\n+                read.isReverseStrand() != mate.isReverseStrand() ) {\n+            // and both start within 1 base on the ref\n+            if ( Math.abs(read.getStart() - read.getMateStart()) <= 1 ) {\n+                // and both end within 1 base\n+                final int readRefLen = read.getCigar().getReferenceLength();\n+                final int mateRefLen = mate.getCigar().getReferenceLength();\n+                if ( Math.abs(readRefLen - mateRefLen) <= 1 ) {\n+                    if ( mate.isReverseStrand() ) {\n+                        trimClips(read, mate);\n+                    } else {\n+                        trimClips(mate, read);\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    private void trimClips( final GATKRead fwd, final GATKRead rev ) {\n+        final List<CigarElement> fwdElements = fwd.getCigarElements();\n+        final List<CigarElement> revElements = rev.getCigarElements();\n+        final int lastElementIdx = fwdElements.size() - 1;\n+        final CigarElement fwdLastElement = fwdElements.get(lastElementIdx);\n+        final CigarElement revFirstElement = revElements.get(0);\n+        if ( fwdLastElement.getOperator() == CigarOperator.S &&\n+                revFirstElement.getOperator() == CigarOperator.S ) {\n+            final byte[] fwdBases = fwd.getBasesNoCopy();\n+            final int lastElementLen = fwdLastElement.getLength();\n+            fwd.setBases(Arrays.copyOfRange(fwdBases, 0, fwdBases.length - lastElementLen));\n+            final byte[] fwdQuals = fwd.getBaseQualitiesNoCopy();\n+            if ( fwdQuals.length > 0 ) {\n+                final int qualsLen = fwdQuals.length - lastElementLen;\n+                fwd.setBaseQualities(Arrays.copyOfRange(fwdQuals, 0, qualsLen));\n+            }\n+            final List<CigarElement> newFwdElements = new ArrayList<>(fwdElements);\n+            newFwdElements.set(lastElementIdx, new CigarElement(lastElementLen, CigarOperator.H));\n+            fwd.setCigar(new Cigar(newFwdElements));\n+\n+            final byte[] revBases = rev.getBasesNoCopy();\n+            final int firstElementLen = revFirstElement.getLength();\n+            rev.setBases(Arrays.copyOfRange(revBases, firstElementLen, revBases.length));\n+            final byte[] revQuals = rev.getBaseQualitiesNoCopy();\n+            if ( revQuals.length > 0 ) {\n+                rev.setBaseQualities(Arrays.copyOfRange(revQuals, firstElementLen, revQuals.length));\n+            }\n+            final List<CigarElement> newRevElements = new ArrayList<>(revElements);\n+            newRevElements.set(0, new CigarElement(firstElementLen, CigarOperator.H));\n+            rev.setCigar(new Cigar(newRevElements));\n+        }\n+    }\n+\n+    @VisibleForTesting\n+    static void kmerizeReads( final List<GATKRead> reads,\n+                              final KmerSet<KmerAdjacency> kmerAdjacencySet ) {\n+        for ( final GATKRead read : reads ) {\n+            final byte[] calls = read.getBasesNoCopy();\n+            final byte[] quals = read.getBaseQualitiesNoCopy();\n+            KmerAdjacency.kmerize(calls, quals, QMIN, kmerAdjacencySet);\n+        }\n+    }\n+\n+    /** gather unbranched strings of kmers into contigs **/\n+    @VisibleForTesting\n+    static List<ContigImpl> buildContigs( final KmerSet<KmerAdjacency> kmerAdjacencySet ) {\n+        // gather strings of kmers that have a single predecessor and single successor into contigs\n+        final List<ContigImpl> contigs = new ArrayList<>();\n+        int nContigs = 0;\n+        for ( final KmerAdjacency kmerAdjacency : kmerAdjacencySet ) {\n+            if ( kmerAdjacency.getContig() == null ) {\n+                ContigImpl contig = null;\n+                final KmerAdjacency predecessor = kmerAdjacency.getSolePredecessor();\n+                if ( predecessor == null ||\n+                        predecessor.getSuccessorCount() > 1 ||\n+                        predecessor == kmerAdjacency.rc() ) {\n+                    contig = new ContigImpl(++nContigs, kmerAdjacency);\n+                } else {\n+                    final KmerAdjacency successor = kmerAdjacency.getSoleSuccessor();\n+                    if ( successor == null ||\n+                            successor.getPredecessorCount() > 1 ||\n+                            successor == kmerAdjacency.rc() ) {\n+                        contig = new ContigImpl(++nContigs, kmerAdjacency.rc());\n+                    }\n+                }\n+                if ( contig != null ) {\n+                    contigs.add(contig);\n+                }\n+            }\n+        }\n+\n+        // if there are smooth circles like a plasmid, gather them together as a contig, too\n+        for ( final KmerAdjacency kmerAdjacency : kmerAdjacencySet ) {\n+            if ( kmerAdjacency.getContig() == null ) {\n+                contigs.add(new ContigImpl(++nContigs, kmerAdjacency));\n+            }\n+        }\n+\n+        return contigs;\n+    }\n+\n+    /** connect contigs when the final kmer of one contig is adjacent to the inital contig of another **/\n+    @VisibleForTesting\n+    static void connectContigs( final List<ContigImpl> contigs ) {\n+        final int nContigs = contigs.size();\n+        final KmerSet<ContigEndKmer> contigEnds = new KmerSet<>(2*nContigs);\n+        for ( int contigId = 0; contigId != nContigs; ++contigId ) {\n+            final ContigImpl contig = contigs.get(contigId);\n+            final KmerAdjacency fwdKmer = contig.getFirstKmer();\n+            final KmerAdjacency revKmer = contig.getLastKmer().rc();\n+            if ( fwdKmer == revKmer ) {\n+                contigEnds.add(new ContigEndKmer(fwdKmer.getKVal(), contig, ContigOrientation.BOTH));\n+            } else {\n+                contigEnds.add(new ContigEndKmer(fwdKmer.getKVal(), contig, ContigOrientation.FWD));\n+                contigEnds.add(new ContigEndKmer(revKmer.getKVal(), contig, ContigOrientation.REV));\n+            }\n+        }\n+\n+        for ( int contigId = 0; contigId != nContigs; ++contigId ) {\n+            final Contig contig = contigs.get(contigId);\n+\n+            final KmerAdjacency start = contig.getFirstKmer();\n+            final int predecessorCount = start.getPredecessorCount();\n+            if ( predecessorCount > 0 ) {\n+                final List<Contig> predecessors = contig.getPredecessors();\n+                final int mask = start.getPredecessorMask();\n+                for ( int call = 0; call != 4; ++call ) {\n+                    if ( (mask & (1 << call)) != 0 ) {\n+                        final long kVal =\n+                                KmerAdjacency.reverseComplement(start.getPredecessorVal(call));\n+                        final ContigEndKmer contigEndKmer = contigEnds.find(new Kmer(kVal));\n+                        if ( contigEndKmer == null ) {\n+                            throw new GATKException(\"missing contig end kmer\");\n+                        }\n+                        switch ( contigEndKmer.getContigOrientation() ) {\n+                            case FWD:\n+                                predecessors.add(contigEndKmer.getContig().rc());\n+                                break;\n+                            case REV:\n+                                predecessors.add(contigEndKmer.getContig());\n+                                break;\n+                            case BOTH:\n+                                predecessors.add(contigEndKmer.getContig());\n+                                predecessors.add(contigEndKmer.getContig().rc());\n+                                break;\n+                        }\n+                    }\n+                }\n+            }\n+\n+            final KmerAdjacency end = contig.getLastKmer();\n+            final int successorCount = end.getSuccessorCount();\n+            if ( successorCount > 0 ) {\n+                final List<Contig> successors = contig.getSuccessors();\n+                final int mask = end.getSuccessorMask();\n+                for ( int call = 0; call != 4; ++call ) {\n+                    if ( (mask & (1 << call)) != 0 ) {\n+                        final long kVal = end.getSuccessorVal(call);\n+                        final ContigEndKmer contigEndKmer = contigEnds.find(new Kmer(kVal));\n+                        if ( contigEndKmer == null ) {\n+                            throw new GATKException(\"missing contig end kmer\");\n+                        }\n+                        switch ( contigEndKmer.getContigOrientation() ) {\n+                            case FWD:\n+                                successors.add(contigEndKmer.getContig());\n+                                break;\n+                            case REV:\n+                                successors.add(contigEndKmer.getContig().rc());\n+                                break;\n+                            case BOTH:\n+                                successors.add(contigEndKmer.getContig());\n+                                successors.add(contigEndKmer.getContig().rc());\n+                                break;\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    /** remove contigs that have little evidence **/\n+    @VisibleForTesting\n+    static void removeThinContigs( final List<ContigImpl> contigs,\n+                                           final KmerSet<KmerAdjacency> kmerAdjacencySet ) {\n+        contigs.sort(Comparator.comparingInt(ContigImpl::getMaxObservations));\n+        boolean contigRemoved;\n+        do {\n+            // figure out which contigs are cut points\n+            // i.e., those contigs which, if removed, would result in a graph with more connected components\n+            final int nContigs = contigs.size();\n+            final Map<Contig, CutData> cutDataMap = new HashMap<>(nContigs * 3);\n+\n+            for ( final ContigImpl contig : contigs ) {\n+                if ( cutDataMap.containsKey(contig) ) {\n+                    continue;\n+                }\n+\n+                cutDataMap.put(contig, new CutData());\n+                int children = 0;\n+                for ( final Contig nextContig : contig.getSuccessors() ) {\n+                    if ( !cutDataMap.containsKey(nextContig) ) {\n+                        findCuts(nextContig, contig, cutDataMap);\n+                        children += 1;\n+                    }\n+                }\n+                for ( final Contig nextContig : contig.getPredecessors() ) {\n+                    if ( !cutDataMap.containsKey(nextContig) ) {\n+                        findCuts(nextContig, contig, cutDataMap);\n+                        children += 1;\n+                    }\n+                }\n+                if ( children >= 2 ) {\n+                    contig.setCut(true);\n+                }\n+            }\n+\n+            // remove poorly attested (low max observations) contigs, unless they are cut points\n+            contigRemoved = false;\n+            final Iterator<ContigImpl> itr = contigs.iterator();\n+            while ( itr.hasNext() ) {\n+                final Contig contig = itr.next();\n+                if ( contig.getMaxObservations() < MIN_THIN_OBS && !contig.isCut() ) {\n+                    unlinkContig(contig, kmerAdjacencySet);\n+                    itr.remove();\n+                    contigRemoved = true;\n+                    break;\n+                }\n+            }\n+        } while ( contigRemoved );\n+        contigs.sort(Comparator.comparingInt(ContigImpl::getId));\n+    }\n+\n+    private static CutData findCuts( final Contig contig,\n+                                     final Contig parent,\n+                                     final Map<Contig, CutData> cutDataMap ) {\n+        final CutData cutData = new CutData();\n+        cutDataMap.put(contig, cutData);\n+        for ( final Contig nextContig : contig.getSuccessors() ) {\n+            if ( nextContig == parent ) {\n+                continue;\n+            }\n+            CutData nextCutData = cutDataMap.get(nextContig);\n+            if ( nextCutData != null ) {\n+                cutData.minVisitNum = Math.min(cutData.minVisitNum, nextCutData.visitNum);\n+            } else {\n+                nextCutData = findCuts(nextContig, contig, cutDataMap);\n+                cutData.minVisitNum = Math.min(cutData.minVisitNum, nextCutData.minVisitNum);\n+                if ( nextCutData.minVisitNum >= cutData.visitNum ) {\n+                    contig.setCut(true);\n+                }\n+            }\n+        }\n+        for ( final Contig nextContig : contig.getPredecessors() ) {\n+            if ( nextContig == parent ) {\n+                continue;\n+            }\n+            CutData nextCutData = cutDataMap.get(nextContig);\n+            if ( nextCutData != null ) {\n+                cutData.minVisitNum = Math.min(cutData.minVisitNum, nextCutData.visitNum);\n+            } else {\n+                nextCutData = findCuts(nextContig, contig, cutDataMap);\n+                cutData.minVisitNum = Math.min(cutData.minVisitNum, nextCutData.minVisitNum);\n+                if ( nextCutData.minVisitNum >= cutData.visitNum ) {\n+                    contig.setCut(true);\n+                }\n+            }\n+        }\n+        return cutData;\n+    }\n+\n+    @VisibleForTesting\n+    static void unlinkContig( final Contig contig,\n+                                      final KmerSet<KmerAdjacency> kmerAdjacencySet ) {\n+        final KmerAdjacency firstKmer = contig.getFirstKmer();\n+        final int firstKmerFinalCall = firstKmer.getFinalCall();\n+        for ( final Contig predecessor : contig.getPredecessors() ) {\n+            if ( predecessor != contig && predecessor != contig.rc() ) {\n+                predecessor.getLastKmer().removeSuccessor(firstKmerFinalCall, kmerAdjacencySet);\n+                if ( !predecessor.getSuccessors().remove(contig) ) {\n+                    throw new GATKException(\"failed to find predecessor link\");\n+                }\n+            }\n+        }\n+\n+        final KmerAdjacency lastKmer = contig.getLastKmer();\n+        final int lastKmerInitialCall = lastKmer.getInitialCall();\n+        for ( final Contig successor : contig.getSuccessors() ) {\n+            if ( successor != contig && successor != contig.rc() ) {\n+                successor.getFirstKmer().removePredecessor(lastKmerInitialCall, kmerAdjacencySet);\n+                if ( !successor.getPredecessors().remove(contig) ) {\n+                    throw new GATKException(\"failed to find successor link\");\n+                }\n+            }\n+        }\n+\n+        KmerAdjacency nextKmer = firstKmer;\n+        KmerAdjacency kmer;\n+        do {\n+            kmer = nextKmer;\n+            nextKmer = kmer.getSoleSuccessor();\n+            kmerAdjacencySet.remove(kmer.canonical());\n+        } while ( kmer != lastKmer );\n+    }\n+\n+    private static void updateKmerContig( final KmerAdjacency firstKmer,\n+                                          final KmerAdjacency lastKmer,\n+                                          final Contig contig ) {\n+        int offset = 0;\n+        for ( KmerAdjacency kmer = firstKmer; kmer != lastKmer; kmer = kmer.getSoleSuccessor() ) {\n+            if ( kmer == null ) {\n+                throw new GATKException(\"contig does not have a flat pipeline of kmers\");\n+            }\n+            kmer.clearContig();\n+            kmer.setContigOffset(contig, offset++);\n+        }\n+        lastKmer.clearContig();\n+        lastKmer.setContigOffset(contig, offset);\n+        if ( offset + Kmer.KSIZE != contig.size() ) {\n+            throw new GATKException(\"kmer chain length does not equal contig size\");\n+        }\n+    }\n+\n+    /** replace adjacent contigs without branches with a single, larger contig **/\n+    @VisibleForTesting\n+    static void weldPipes( final List<ContigImpl> contigs ) {\n+        for ( int contigIdx = 0; contigIdx != contigs.size(); ++contigIdx ) {\n+            final ContigImpl contig = contigs.get(contigIdx);\n+            if ( contig.getSuccessors().size() == 1 ) {\n+                final Contig successor = contig.getSuccessors().get(0);\n+                if ( successor != contig && successor != contig.rc() &&\n+                        successor.getPredecessors().size() == 1 ) {\n+                    contigs.set(contigIdx, join(contig.getId(), contig, successor));\n+                    if ( !contigs.remove(successor.canonical()) ) {\n+                        throw new GATKException(\"successor linkage is messed up\");\n+                    }\n+                    contigIdx -= 1; // reconsider the new contig -- there might be more joining possible\n+                    continue;\n+                }\n+            }\n+            if ( contig.getPredecessors().size() == 1 ) {\n+                final Contig predecessor = contig.getPredecessors().get(0);\n+                if ( predecessor != contig && predecessor != contig.rc() &&\n+                        predecessor.getSuccessors().size() == 1 ) {\n+                    contigs.set(contigIdx, join(contig.getId(), predecessor, contig));\n+                    if ( !contigs.remove(predecessor.canonical()) ) {\n+                        throw new GATKException(\"predecessor linkage is messed up\");\n+                    }\n+                    contigIdx -= 1; // reconsider\n+                }\n+            }\n+        }\n+    }\n+\n+    private static ContigImpl join( final int id, final Contig predecessor, final Contig successor ) {\n+        if ( !checkOverlap(predecessor.getSequence(), successor.getSequence()) ) {\n+                throw new GATKException(\"sequences can't be joined\");\n+        }\n+        final ContigImpl joinedContig = new ContigImpl(id, predecessor, successor);\n+        updateKmerContig(joinedContig.getFirstKmer(), joinedContig.getLastKmer(), joinedContig);\n+        return joinedContig;\n+    }\n+\n+    private static boolean checkOverlap( final CharSequence seq1, final CharSequence seq2 ) {\n+        final int seq1Len = seq1.length();\n+        final CharSequence seq1SubSeq = seq1.subSequence(seq1Len - Kmer.KSIZE + 1, seq1Len);\n+        final CharSequence seq2SubSeq = seq2.subSequence(0, Kmer.KSIZE - 1);\n+        return seq1SubSeq.equals(seq2SubSeq);\n+    }\n+\n+    /** set a unique componentId for every connected group of contigs **/\n+    @VisibleForTesting\n+    static int markComponents( final List<ContigImpl> contigs ) {\n+        for ( final ContigImpl contig : contigs ) {\n+            contig.setComponentId(0);\n+        }\n+\n+        int componentId = 0;\n+        for ( final ContigImpl contig : contigs ) {\n+            if ( contig.getComponentId() == 0 ) {\n+                contig.setComponentId(++componentId);\n+                markSuccessorComponents(contig);\n+                markSuccessorComponents(contig.rc());\n+            }\n+        }\n+        return componentId;\n+    }\n+\n+    private static void markSuccessorComponents( final Contig contig ) {\n+        final int componentId = contig.getComponentId();\n+        for ( final Contig successor : contig.getSuccessors() ) {\n+            if ( successor.getComponentId() == 0 ) {\n+                successor.canonical().setComponentId(componentId);\n+                markSuccessorComponents(successor);\n+                markSuccessorComponents(successor.rc());\n+            }\n+        }\n+    }\n+\n+    @VisibleForTesting\n+    static void markCycles( final List<ContigImpl> contigs ) {\n+        for ( final Contig contig : contigs ) {\n+            contig.setCyclic(false);\n+        }\n+\n+        final int nContigs = contigs.size();\n+        final Deque<Contig> deque = new ArrayDeque<>(nContigs);\n+        final Map<Contig, CutData> cutDataMap = new HashMap<>(nContigs * 3);\n+        for ( final Contig contig : contigs ) {\n+            if ( !cutDataMap.containsKey(contig) ) {\n+                markCyclesRecursion(contig, deque, cutDataMap);\n+            }\n+        }\n+    }\n+\n+    private static CutData markCyclesRecursion( final Contig contig,\n+                                                final Deque<Contig> deque,\n+                                                final Map<Contig, CutData> cutDataMap ) {\n+        final CutData cutData = new CutData();\n+        cutDataMap.put(contig, cutData);\n+        deque.addFirst(contig);\n+\n+        for ( final Contig successor : contig.getSuccessors() ) {\n+            final CutData successorCutData = cutDataMap.get(successor);\n+            if ( successorCutData == null ) {\n+                final int recursionVisitNum =\n+                        markCyclesRecursion(successor, deque, cutDataMap).minVisitNum;\n+                cutData.minVisitNum = Math.min(cutData.minVisitNum, recursionVisitNum);\n+            } else {\n+                cutData.minVisitNum = Math.min(cutData.minVisitNum, successorCutData.visitNum);\n+            }\n+        }\n+\n+        if ( cutData.visitNum == cutData.minVisitNum ) {\n+            Contig tig = deque.removeFirst();\n+            if ( tig == contig ) {\n+                cutDataMap.get(tig).visitNum = Integer.MAX_VALUE;\n+\n+                // single-vertex component -- cyclic only if self-referential\n+                if ( tig.getSuccessors().contains(tig) ) {\n+                    tig.setCyclic(true);\n+                }\n+            } else {\n+                while ( true ) {\n+                    // kill cross-links\n+                    cutDataMap.get(tig).visitNum = Integer.MAX_VALUE;\n+                    tig.setCyclic(true);\n+                    if ( tig == contig ) break;\n+                    tig = deque.removeFirst();\n+                }\n+            }\n+        }\n+        return cutData;\n+    }\n+\n+    @VisibleForTesting\n+    static boolean fillGaps( final KmerSet<KmerAdjacency> kmerAdjacencySet,\n+                             final List<GATKRead> reads ) {\n+        final Map<String, Integer> gapFillCounts = new HashMap<>();\n+        for ( final GATKRead read : reads ) {\n+            final Path path = new Path(read.getBasesNoCopy(), kmerAdjacencySet);\n+            final List<PathPart> parts = path.getParts();\n+            final int lastIdx = parts.size() - 1;\n+            for ( int idx = 1; idx < lastIdx; ++idx ) {\n+                final PathPart pathPart = parts.get(idx);\n+                if ( pathPart.isGap() ) {\n+                    final char prevCall = parts.get(idx - 1).getLastCall();\n+                    final char nextCall = parts.get(idx + 1).getFirstCall();\n+                    String gapFill = prevCall + pathPart.getSequence().toString() + nextCall;\n+                    final SequenceRC gapFillRC = new SequenceRC(gapFill);\n+                    if ( gapFillRC.compareTo(gapFill) < 0 ) {\n+                        gapFill = gapFillRC.toString();\n+                    }\n+                    gapFillCounts.merge(gapFill, 1, Integer::sum);\n+                }\n+            }\n+        }\n+\n+        boolean newKmers = false;\n+        for ( final Map.Entry<String, Integer> entry : gapFillCounts.entrySet() ) {\n+            final int nObservations = entry.getValue();\n+            if ( nObservations >= MIN_GAPFILL_COUNT ) {\n+                KmerAdjacency.kmerize(entry.getKey(), nObservations, kmerAdjacencySet);\n+                newKmers = true;\n+            }\n+        }\n+\n+        if ( newKmers ) {\n+            for ( final KmerAdjacency kmerAdjacency : kmerAdjacencySet ) {\n+                kmerAdjacency.clearContig();\n+            }\n+        }\n+        return newKmers;\n+    }\n+\n+    @VisibleForTesting\n+    static List<Path> pathReads( final KmerSet<KmerAdjacency> kmerAdjacencySet,\n+                          final List<GATKRead> reads ) {\n+        final List<Path> readPaths = new ArrayList<>(reads.size());\n+        for ( final GATKRead read : reads ) {\n+            readPaths.add(new Path(read.getBasesNoCopy(), kmerAdjacencySet));\n+        }\n+        return readPaths;\n+    }\n+\n+    @VisibleForTesting\n+    static Map<Contig,List<TransitPairCount>> collectTransitPairCounts(\n+            final List<ContigImpl> contigs,\n+            final List<Path> readPaths ) {\n+        final Map<Contig,List<TransitPairCount>> contigTransitsMap =\n+                new HashMap<>(3 * contigs.size());\n+        for ( final Path path : readPaths ) {\n+            final List<PathPart> parts = path.getParts();\n+            final int lastPart = parts.size() - 1;\n+            for ( int partIdx = 1; partIdx < lastPart; ++partIdx ) {\n+                final Contig prevContig = parts.get(partIdx - 1).getContig();\n+                if ( prevContig == null ) continue;\n+                final Contig curContig = parts.get(partIdx).getContig();\n+                if ( curContig == null ) {\n+                    partIdx += 1;\n+                    continue;\n+                }\n+                final Contig nextContig = parts.get(partIdx + 1).getContig();\n+                if ( nextContig == null ) {\n+                    partIdx += 2;\n+                    continue;\n+                }\n+                final TransitPairCount tpc = new TransitPairCount(prevContig, nextContig);\n+                final List<TransitPairCount> tpcList =\n+                        contigTransitsMap.computeIfAbsent(curContig, tig -> new ArrayList<>(4));\n+                final int idx = tpcList.indexOf(tpc);\n+                if ( idx != -1 ) {\n+                    tpcList.get(idx).observe();\n+                } else {\n+                    tpcList.add(tpc);\n+                    contigTransitsMap.computeIfAbsent(curContig.rc(), tig -> new ArrayList<>(4))\n+                            .add(tpc.getRC());\n+                }\n+            }\n+        }\n+        return contigTransitsMap;\n+    }\n+\n+    @VisibleForTesting\n+    static Set<Traversal> traverseAllPaths(\n+            final List<ContigImpl> contigs,\n+            final List<Path> readPaths,\n+            final Map<Contig, List<TransitPairCount>> contigTransitsMap ) {\n+        final Set<Traversal> traversalSet = new HashSet<>();\n+        final List<Contig> contigsList = new ArrayList<>();\n+        for ( final Contig contig : contigs ) {\n+            // untransited contigs are sources, sinks, or large contigs that can't be crossed by a read\n+            // build traversals from these\n+            if ( !contigTransitsMap.containsKey(contig) ) {\n+                boolean done = false;\n+                for ( final Contig successor : contig.getSuccessors() ) {\n+                    traverse(successor, contig,\n+                            contigsList, readPaths, contigTransitsMap, traversalSet);\n+                    done = true;\n+                }\n+                for ( final Contig predecessor : contig.getPredecessors() ) {\n+                    traverse(predecessor.rc(), contig.rc(),\n+                            contigsList, readPaths, contigTransitsMap, traversalSet);\n+                    done = true;\n+                }\n+                if ( !done ) { // if there were no predecessors or successors, it stands alone\n+                    addTraversal(new Traversal(Collections.singletonList(contig)), traversalSet);\n+                }\n+            }\n+        }\n+\n+        // look for transits that haven't been traced\n+        for ( final Map.Entry<Contig, List<TransitPairCount>> entry :\n+                contigTransitsMap.entrySet() ) {\n+            for ( final TransitPairCount tpc : entry.getValue() ) {\n+                if ( tpc.getCount() > 0 ) {\n+                    tpc.resetCount();\n+                    final Contig contig = entry.getKey();\n+                    final Set<Traversal> fwdTraversalSet = new HashSet<>();\n+                    traverse(tpc.getNextContig(), contig,\n+                            contigsList, readPaths, contigTransitsMap, fwdTraversalSet);\n+                    final Set<Traversal> revTraversalSet = new HashSet<>();\n+                    traverse(tpc.getPrevContig().rc(), contig.rc(),\n+                            contigsList, readPaths, contigTransitsMap, revTraversalSet);\n+                    for ( final Traversal revTraversal : revTraversalSet ) {\n+                        final Traversal revTraversalRC = revTraversal.rc();\n+                        for ( final Traversal fwdTraversal : fwdTraversalSet ) {\n+                            final int overlap =\n+                                    findMaxOverlap(revTraversalRC.getContigs(), fwdTraversal.getContigs());\n+                            final Traversal combo =\n+                                    Traversal.combineOverlappers(revTraversalRC, fwdTraversal, overlap);\n+                            addTraversal(combo, traversalSet);\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+\n+        return traversalSet;\n+    }\n+\n+    private static int findMaxOverlap( final List<Contig> prefixes, final List<Contig> suffixes ) {\n+        final int nPrefixes = prefixes.size();\n+        final Contig firstSuffix = suffixes.get(0);\n+        if ( !firstSuffix.isCyclic() ) {\n+            return prefixes.get(nPrefixes - 1) == firstSuffix ? 1 : 0;\n+        }\n+        final int nSuffixes = suffixes.size();\n+        for ( int prefixIdx = Math.max(0, nPrefixes - nSuffixes); prefixIdx != nPrefixes; ++prefixIdx ) {\n+            if ( prefixes.get(prefixIdx) == firstSuffix ) {\n+                int suffixIdx = 1;\n+                boolean match = true;\n+                for ( int prefixIdx2 = prefixIdx + 1; prefixIdx2 != nPrefixes; ++prefixIdx2 ) {\n+                    if ( prefixes.get(prefixIdx2) != suffixes.get(suffixIdx++) ) {\n+                        match = false;\n+                        break;\n+                    }\n+                }\n+                if ( match ) {\n+                    return nPrefixes - prefixIdx;\n+                }\n+            }\n+        }\n+        return 0;\n+    }\n+\n+    private static void traverse( final Contig contig,\n+                                  final Contig predecessor,\n+                                  final List<Contig> contigsList,\n+                                  final List<Path> readPaths,\n+                                  final Map<Contig, List<TransitPairCount>> contigTransitsMap,\n+                                  final Set<Traversal> traversalSet ) {\n+        contigsList.add(predecessor);\n+        if ( contig.isCyclic() ) {\n+            traverseCycle(contig, contigsList, readPaths, contigTransitsMap, traversalSet);\n+            contigsList.remove(contigsList.size() - 1);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5NzgzMzUyMQ=="}, "originalCommit": {"oid": "e2201c1ef4f8ba71f17e169f07756cfe2f1ecb49"}, "originalPosition": 757}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzc3NjI1MjQ3OnYy", "diffSide": "RIGHT", "path": "src/main/java/org/broadinstitute/hellbender/tools/LocalAssembler.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMy0xOVQxNjo1NjozOFrOI6I-bw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMy0xOVQxNjo1NjozOFrOI6I-bw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5NzgzNTM3NQ==", "bodyText": "Can you rename done to something like foundTraversalInTransitPairCounts?", "url": "https://github.com/broadinstitute/gatk/pull/6989#discussion_r597835375", "createdAt": "2021-03-19T16:56:38Z", "author": {"login": "cwhelan"}, "path": "src/main/java/org/broadinstitute/hellbender/tools/LocalAssembler.java", "diffHunk": "@@ -0,0 +1,2306 @@\n+package org.broadinstitute.hellbender.tools;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import htsjdk.samtools.Cigar;\n+import htsjdk.samtools.CigarElement;\n+import htsjdk.samtools.CigarOperator;\n+import htsjdk.samtools.SAMUtils;\n+import org.broadinstitute.barclay.argparser.Argument;\n+import org.broadinstitute.barclay.argparser.BetaFeature;\n+import org.broadinstitute.barclay.argparser.CommandLineProgramProperties;\n+import org.broadinstitute.barclay.help.DocumentedFeature;\n+import org.broadinstitute.hellbender.cmdline.StandardArgumentDefinitions;\n+import org.broadinstitute.hellbender.cmdline.programgroups.CoverageAnalysisProgramGroup;\n+import org.broadinstitute.hellbender.exceptions.GATKException;\n+import org.broadinstitute.hellbender.tools.walkers.PairWalker;\n+import org.broadinstitute.hellbender.utils.SimpleInterval;\n+import org.broadinstitute.hellbender.utils.collections.HopscotchSet;\n+import org.broadinstitute.hellbender.utils.gcs.BucketUtils;\n+import org.broadinstitute.hellbender.utils.read.GATKRead;\n+\n+import java.io.BufferedWriter;\n+import java.io.FileWriter;\n+import java.io.IOException;\n+import java.io.OutputStreamWriter;\n+import java.util.*;\n+import java.util.zip.GZIPOutputStream;\n+\n+@DocumentedFeature\n+@CommandLineProgramProperties(\n+        summary = \"experiment\",\n+        oneLineSummary = \"experiment\",\n+        usageExample = \"gatk LocalAssembler\",\n+        programGroup = CoverageAnalysisProgramGroup.class\n+)\n+@BetaFeature\n+public class LocalAssembler extends PairWalker {\n+    public static final byte QMIN = 25;\n+    public static final int MIN_THIN_OBS = 4;\n+    public static final int MIN_GAPFILL_COUNT = 3;\n+    public static final int TOO_MANY_TRAVERSALS = 100000;\n+    public static final int TOO_MANY_SCAFFOLDS = 50000;\n+    public static final int MIN_SV_SIZE = 50;\n+\n+    @Argument(fullName=StandardArgumentDefinitions.OUTPUT_LONG_NAME,\n+            shortName=StandardArgumentDefinitions.OUTPUT_SHORT_NAME,\n+            doc=\"Write outputs to this file name prefix\", optional = true)\n+    public static String output;\n+\n+    @Argument(fullName=\"assembly-name\", doc=\"name of assembly used as a prefix for traversal names\")\n+    public static String assemblyName;\n+\n+    private final List<GATKRead> reads = new ArrayList<>();\n+\n+    @Override public boolean requiresIntervals() { return true; }\n+\n+    @Override public void apply( final GATKRead read, final GATKRead mate ) {\n+        trimOverruns(read, mate);\n+        reads.add(read);\n+        reads.add(mate);\n+    }\n+\n+    @Override public void applyUnpaired( final GATKRead read ) {\n+        reads.add(read);\n+    }\n+\n+    @Override public Object onTraversalSuccess() {\n+        super.onTraversalSuccess(); // flush any incomplete pairs\n+\n+        final int regionSize = getTraversalIntervals().stream().mapToInt(SimpleInterval::size).sum();\n+        final KmerSet<KmerAdjacency> kmerAdjacencySet = new KmerSet<>(10 * regionSize);\n+        kmerizeReads(reads, kmerAdjacencySet);\n+        List<ContigImpl> contigs = buildContigs(kmerAdjacencySet);\n+        connectContigs(contigs);\n+\n+        removeThinContigs(contigs, kmerAdjacencySet);\n+        weldPipes(contigs);\n+        markComponents(contigs);\n+\n+        if ( fillGaps(kmerAdjacencySet, reads) ) {\n+            contigs = buildContigs(kmerAdjacencySet);\n+            connectContigs(contigs);\n+            removeThinContigs(contigs, kmerAdjacencySet);\n+            weldPipes(contigs);\n+            markComponents(contigs);\n+        }\n+\n+        markCycles(contigs);\n+\n+        final String outputFilePrefix = output != null ? output : assemblyName;\n+        final List<Path> readPaths = pathReads(kmerAdjacencySet, reads);\n+        final Map<Contig,List<TransitPairCount>> contigTransitsMap =\n+                collectTransitPairCounts(contigs, readPaths);\n+        final String traversalsFilename = outputFilePrefix + \".traversals.fa.gz\";\n+        try {\n+            final List<Traversal> allTraversals =\n+                    new ArrayList<>(traverseAllPaths(contigs, readPaths, contigTransitsMap));\n+            writeTraversals(allTraversals, traversalsFilename);\n+            try {\n+                final String scaffoldsFileName = outputFilePrefix + \".scaffolds.fa.gz\";\n+                writeTraversals(createScaffolds(allTraversals), scaffoldsFileName);\n+            } catch ( final AssemblyTooComplexException x ) {\n+                logger.warn(\"Assembly too complex for scaffolding.\");\n+            }\n+        } catch ( final AssemblyTooComplexException x ) {\n+            logger.warn(\"Assembly too complex.  Writing contigs as traversals in \" +\n+                    traversalsFilename + \".\");\n+            final Collection<Traversal> contigTraversals = new ArrayList<>(contigs.size());\n+            for ( final Contig contig : contigs ) {\n+                contigTraversals.add(new Traversal(Collections.singletonList(contig)));\n+            }\n+            writeTraversals(contigTraversals, traversalsFilename);\n+        }\n+\n+        contigs.sort(Comparator.comparingInt(ContigImpl::getId));\n+        writeDOT(contigs, outputFilePrefix + \".assembly.dot\");\n+        writeContigs(contigs, outputFilePrefix + \".contigs.txt.gz\");\n+        writePaths(readPaths, outputFilePrefix + \".paths.txt.gz\");\n+        writeReads(reads, outputFilePrefix + \".reads.fastq.gz\");\n+        return null;\n+    }\n+\n+    /** trim read pairs of base calls that have gone past the end of a short fragment */\n+    private void trimOverruns( final GATKRead read, final GATKRead mate ) {\n+        // if both mapped and they're on different strands\n+        if ( !read.isUnmapped() && !mate.isUnmapped() &&\n+                read.isReverseStrand() != mate.isReverseStrand() ) {\n+            // and both start within 1 base on the ref\n+            if ( Math.abs(read.getStart() - read.getMateStart()) <= 1 ) {\n+                // and both end within 1 base\n+                final int readRefLen = read.getCigar().getReferenceLength();\n+                final int mateRefLen = mate.getCigar().getReferenceLength();\n+                if ( Math.abs(readRefLen - mateRefLen) <= 1 ) {\n+                    if ( mate.isReverseStrand() ) {\n+                        trimClips(read, mate);\n+                    } else {\n+                        trimClips(mate, read);\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    private void trimClips( final GATKRead fwd, final GATKRead rev ) {\n+        final List<CigarElement> fwdElements = fwd.getCigarElements();\n+        final List<CigarElement> revElements = rev.getCigarElements();\n+        final int lastElementIdx = fwdElements.size() - 1;\n+        final CigarElement fwdLastElement = fwdElements.get(lastElementIdx);\n+        final CigarElement revFirstElement = revElements.get(0);\n+        if ( fwdLastElement.getOperator() == CigarOperator.S &&\n+                revFirstElement.getOperator() == CigarOperator.S ) {\n+            final byte[] fwdBases = fwd.getBasesNoCopy();\n+            final int lastElementLen = fwdLastElement.getLength();\n+            fwd.setBases(Arrays.copyOfRange(fwdBases, 0, fwdBases.length - lastElementLen));\n+            final byte[] fwdQuals = fwd.getBaseQualitiesNoCopy();\n+            if ( fwdQuals.length > 0 ) {\n+                final int qualsLen = fwdQuals.length - lastElementLen;\n+                fwd.setBaseQualities(Arrays.copyOfRange(fwdQuals, 0, qualsLen));\n+            }\n+            final List<CigarElement> newFwdElements = new ArrayList<>(fwdElements);\n+            newFwdElements.set(lastElementIdx, new CigarElement(lastElementLen, CigarOperator.H));\n+            fwd.setCigar(new Cigar(newFwdElements));\n+\n+            final byte[] revBases = rev.getBasesNoCopy();\n+            final int firstElementLen = revFirstElement.getLength();\n+            rev.setBases(Arrays.copyOfRange(revBases, firstElementLen, revBases.length));\n+            final byte[] revQuals = rev.getBaseQualitiesNoCopy();\n+            if ( revQuals.length > 0 ) {\n+                rev.setBaseQualities(Arrays.copyOfRange(revQuals, firstElementLen, revQuals.length));\n+            }\n+            final List<CigarElement> newRevElements = new ArrayList<>(revElements);\n+            newRevElements.set(0, new CigarElement(firstElementLen, CigarOperator.H));\n+            rev.setCigar(new Cigar(newRevElements));\n+        }\n+    }\n+\n+    @VisibleForTesting\n+    static void kmerizeReads( final List<GATKRead> reads,\n+                              final KmerSet<KmerAdjacency> kmerAdjacencySet ) {\n+        for ( final GATKRead read : reads ) {\n+            final byte[] calls = read.getBasesNoCopy();\n+            final byte[] quals = read.getBaseQualitiesNoCopy();\n+            KmerAdjacency.kmerize(calls, quals, QMIN, kmerAdjacencySet);\n+        }\n+    }\n+\n+    /** gather unbranched strings of kmers into contigs **/\n+    @VisibleForTesting\n+    static List<ContigImpl> buildContigs( final KmerSet<KmerAdjacency> kmerAdjacencySet ) {\n+        // gather strings of kmers that have a single predecessor and single successor into contigs\n+        final List<ContigImpl> contigs = new ArrayList<>();\n+        int nContigs = 0;\n+        for ( final KmerAdjacency kmerAdjacency : kmerAdjacencySet ) {\n+            if ( kmerAdjacency.getContig() == null ) {\n+                ContigImpl contig = null;\n+                final KmerAdjacency predecessor = kmerAdjacency.getSolePredecessor();\n+                if ( predecessor == null ||\n+                        predecessor.getSuccessorCount() > 1 ||\n+                        predecessor == kmerAdjacency.rc() ) {\n+                    contig = new ContigImpl(++nContigs, kmerAdjacency);\n+                } else {\n+                    final KmerAdjacency successor = kmerAdjacency.getSoleSuccessor();\n+                    if ( successor == null ||\n+                            successor.getPredecessorCount() > 1 ||\n+                            successor == kmerAdjacency.rc() ) {\n+                        contig = new ContigImpl(++nContigs, kmerAdjacency.rc());\n+                    }\n+                }\n+                if ( contig != null ) {\n+                    contigs.add(contig);\n+                }\n+            }\n+        }\n+\n+        // if there are smooth circles like a plasmid, gather them together as a contig, too\n+        for ( final KmerAdjacency kmerAdjacency : kmerAdjacencySet ) {\n+            if ( kmerAdjacency.getContig() == null ) {\n+                contigs.add(new ContigImpl(++nContigs, kmerAdjacency));\n+            }\n+        }\n+\n+        return contigs;\n+    }\n+\n+    /** connect contigs when the final kmer of one contig is adjacent to the inital contig of another **/\n+    @VisibleForTesting\n+    static void connectContigs( final List<ContigImpl> contigs ) {\n+        final int nContigs = contigs.size();\n+        final KmerSet<ContigEndKmer> contigEnds = new KmerSet<>(2*nContigs);\n+        for ( int contigId = 0; contigId != nContigs; ++contigId ) {\n+            final ContigImpl contig = contigs.get(contigId);\n+            final KmerAdjacency fwdKmer = contig.getFirstKmer();\n+            final KmerAdjacency revKmer = contig.getLastKmer().rc();\n+            if ( fwdKmer == revKmer ) {\n+                contigEnds.add(new ContigEndKmer(fwdKmer.getKVal(), contig, ContigOrientation.BOTH));\n+            } else {\n+                contigEnds.add(new ContigEndKmer(fwdKmer.getKVal(), contig, ContigOrientation.FWD));\n+                contigEnds.add(new ContigEndKmer(revKmer.getKVal(), contig, ContigOrientation.REV));\n+            }\n+        }\n+\n+        for ( int contigId = 0; contigId != nContigs; ++contigId ) {\n+            final Contig contig = contigs.get(contigId);\n+\n+            final KmerAdjacency start = contig.getFirstKmer();\n+            final int predecessorCount = start.getPredecessorCount();\n+            if ( predecessorCount > 0 ) {\n+                final List<Contig> predecessors = contig.getPredecessors();\n+                final int mask = start.getPredecessorMask();\n+                for ( int call = 0; call != 4; ++call ) {\n+                    if ( (mask & (1 << call)) != 0 ) {\n+                        final long kVal =\n+                                KmerAdjacency.reverseComplement(start.getPredecessorVal(call));\n+                        final ContigEndKmer contigEndKmer = contigEnds.find(new Kmer(kVal));\n+                        if ( contigEndKmer == null ) {\n+                            throw new GATKException(\"missing contig end kmer\");\n+                        }\n+                        switch ( contigEndKmer.getContigOrientation() ) {\n+                            case FWD:\n+                                predecessors.add(contigEndKmer.getContig().rc());\n+                                break;\n+                            case REV:\n+                                predecessors.add(contigEndKmer.getContig());\n+                                break;\n+                            case BOTH:\n+                                predecessors.add(contigEndKmer.getContig());\n+                                predecessors.add(contigEndKmer.getContig().rc());\n+                                break;\n+                        }\n+                    }\n+                }\n+            }\n+\n+            final KmerAdjacency end = contig.getLastKmer();\n+            final int successorCount = end.getSuccessorCount();\n+            if ( successorCount > 0 ) {\n+                final List<Contig> successors = contig.getSuccessors();\n+                final int mask = end.getSuccessorMask();\n+                for ( int call = 0; call != 4; ++call ) {\n+                    if ( (mask & (1 << call)) != 0 ) {\n+                        final long kVal = end.getSuccessorVal(call);\n+                        final ContigEndKmer contigEndKmer = contigEnds.find(new Kmer(kVal));\n+                        if ( contigEndKmer == null ) {\n+                            throw new GATKException(\"missing contig end kmer\");\n+                        }\n+                        switch ( contigEndKmer.getContigOrientation() ) {\n+                            case FWD:\n+                                successors.add(contigEndKmer.getContig());\n+                                break;\n+                            case REV:\n+                                successors.add(contigEndKmer.getContig().rc());\n+                                break;\n+                            case BOTH:\n+                                successors.add(contigEndKmer.getContig());\n+                                successors.add(contigEndKmer.getContig().rc());\n+                                break;\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    /** remove contigs that have little evidence **/\n+    @VisibleForTesting\n+    static void removeThinContigs( final List<ContigImpl> contigs,\n+                                           final KmerSet<KmerAdjacency> kmerAdjacencySet ) {\n+        contigs.sort(Comparator.comparingInt(ContigImpl::getMaxObservations));\n+        boolean contigRemoved;\n+        do {\n+            // figure out which contigs are cut points\n+            // i.e., those contigs which, if removed, would result in a graph with more connected components\n+            final int nContigs = contigs.size();\n+            final Map<Contig, CutData> cutDataMap = new HashMap<>(nContigs * 3);\n+\n+            for ( final ContigImpl contig : contigs ) {\n+                if ( cutDataMap.containsKey(contig) ) {\n+                    continue;\n+                }\n+\n+                cutDataMap.put(contig, new CutData());\n+                int children = 0;\n+                for ( final Contig nextContig : contig.getSuccessors() ) {\n+                    if ( !cutDataMap.containsKey(nextContig) ) {\n+                        findCuts(nextContig, contig, cutDataMap);\n+                        children += 1;\n+                    }\n+                }\n+                for ( final Contig nextContig : contig.getPredecessors() ) {\n+                    if ( !cutDataMap.containsKey(nextContig) ) {\n+                        findCuts(nextContig, contig, cutDataMap);\n+                        children += 1;\n+                    }\n+                }\n+                if ( children >= 2 ) {\n+                    contig.setCut(true);\n+                }\n+            }\n+\n+            // remove poorly attested (low max observations) contigs, unless they are cut points\n+            contigRemoved = false;\n+            final Iterator<ContigImpl> itr = contigs.iterator();\n+            while ( itr.hasNext() ) {\n+                final Contig contig = itr.next();\n+                if ( contig.getMaxObservations() < MIN_THIN_OBS && !contig.isCut() ) {\n+                    unlinkContig(contig, kmerAdjacencySet);\n+                    itr.remove();\n+                    contigRemoved = true;\n+                    break;\n+                }\n+            }\n+        } while ( contigRemoved );\n+        contigs.sort(Comparator.comparingInt(ContigImpl::getId));\n+    }\n+\n+    private static CutData findCuts( final Contig contig,\n+                                     final Contig parent,\n+                                     final Map<Contig, CutData> cutDataMap ) {\n+        final CutData cutData = new CutData();\n+        cutDataMap.put(contig, cutData);\n+        for ( final Contig nextContig : contig.getSuccessors() ) {\n+            if ( nextContig == parent ) {\n+                continue;\n+            }\n+            CutData nextCutData = cutDataMap.get(nextContig);\n+            if ( nextCutData != null ) {\n+                cutData.minVisitNum = Math.min(cutData.minVisitNum, nextCutData.visitNum);\n+            } else {\n+                nextCutData = findCuts(nextContig, contig, cutDataMap);\n+                cutData.minVisitNum = Math.min(cutData.minVisitNum, nextCutData.minVisitNum);\n+                if ( nextCutData.minVisitNum >= cutData.visitNum ) {\n+                    contig.setCut(true);\n+                }\n+            }\n+        }\n+        for ( final Contig nextContig : contig.getPredecessors() ) {\n+            if ( nextContig == parent ) {\n+                continue;\n+            }\n+            CutData nextCutData = cutDataMap.get(nextContig);\n+            if ( nextCutData != null ) {\n+                cutData.minVisitNum = Math.min(cutData.minVisitNum, nextCutData.visitNum);\n+            } else {\n+                nextCutData = findCuts(nextContig, contig, cutDataMap);\n+                cutData.minVisitNum = Math.min(cutData.minVisitNum, nextCutData.minVisitNum);\n+                if ( nextCutData.minVisitNum >= cutData.visitNum ) {\n+                    contig.setCut(true);\n+                }\n+            }\n+        }\n+        return cutData;\n+    }\n+\n+    @VisibleForTesting\n+    static void unlinkContig( final Contig contig,\n+                                      final KmerSet<KmerAdjacency> kmerAdjacencySet ) {\n+        final KmerAdjacency firstKmer = contig.getFirstKmer();\n+        final int firstKmerFinalCall = firstKmer.getFinalCall();\n+        for ( final Contig predecessor : contig.getPredecessors() ) {\n+            if ( predecessor != contig && predecessor != contig.rc() ) {\n+                predecessor.getLastKmer().removeSuccessor(firstKmerFinalCall, kmerAdjacencySet);\n+                if ( !predecessor.getSuccessors().remove(contig) ) {\n+                    throw new GATKException(\"failed to find predecessor link\");\n+                }\n+            }\n+        }\n+\n+        final KmerAdjacency lastKmer = contig.getLastKmer();\n+        final int lastKmerInitialCall = lastKmer.getInitialCall();\n+        for ( final Contig successor : contig.getSuccessors() ) {\n+            if ( successor != contig && successor != contig.rc() ) {\n+                successor.getFirstKmer().removePredecessor(lastKmerInitialCall, kmerAdjacencySet);\n+                if ( !successor.getPredecessors().remove(contig) ) {\n+                    throw new GATKException(\"failed to find successor link\");\n+                }\n+            }\n+        }\n+\n+        KmerAdjacency nextKmer = firstKmer;\n+        KmerAdjacency kmer;\n+        do {\n+            kmer = nextKmer;\n+            nextKmer = kmer.getSoleSuccessor();\n+            kmerAdjacencySet.remove(kmer.canonical());\n+        } while ( kmer != lastKmer );\n+    }\n+\n+    private static void updateKmerContig( final KmerAdjacency firstKmer,\n+                                          final KmerAdjacency lastKmer,\n+                                          final Contig contig ) {\n+        int offset = 0;\n+        for ( KmerAdjacency kmer = firstKmer; kmer != lastKmer; kmer = kmer.getSoleSuccessor() ) {\n+            if ( kmer == null ) {\n+                throw new GATKException(\"contig does not have a flat pipeline of kmers\");\n+            }\n+            kmer.clearContig();\n+            kmer.setContigOffset(contig, offset++);\n+        }\n+        lastKmer.clearContig();\n+        lastKmer.setContigOffset(contig, offset);\n+        if ( offset + Kmer.KSIZE != contig.size() ) {\n+            throw new GATKException(\"kmer chain length does not equal contig size\");\n+        }\n+    }\n+\n+    /** replace adjacent contigs without branches with a single, larger contig **/\n+    @VisibleForTesting\n+    static void weldPipes( final List<ContigImpl> contigs ) {\n+        for ( int contigIdx = 0; contigIdx != contigs.size(); ++contigIdx ) {\n+            final ContigImpl contig = contigs.get(contigIdx);\n+            if ( contig.getSuccessors().size() == 1 ) {\n+                final Contig successor = contig.getSuccessors().get(0);\n+                if ( successor != contig && successor != contig.rc() &&\n+                        successor.getPredecessors().size() == 1 ) {\n+                    contigs.set(contigIdx, join(contig.getId(), contig, successor));\n+                    if ( !contigs.remove(successor.canonical()) ) {\n+                        throw new GATKException(\"successor linkage is messed up\");\n+                    }\n+                    contigIdx -= 1; // reconsider the new contig -- there might be more joining possible\n+                    continue;\n+                }\n+            }\n+            if ( contig.getPredecessors().size() == 1 ) {\n+                final Contig predecessor = contig.getPredecessors().get(0);\n+                if ( predecessor != contig && predecessor != contig.rc() &&\n+                        predecessor.getSuccessors().size() == 1 ) {\n+                    contigs.set(contigIdx, join(contig.getId(), predecessor, contig));\n+                    if ( !contigs.remove(predecessor.canonical()) ) {\n+                        throw new GATKException(\"predecessor linkage is messed up\");\n+                    }\n+                    contigIdx -= 1; // reconsider\n+                }\n+            }\n+        }\n+    }\n+\n+    private static ContigImpl join( final int id, final Contig predecessor, final Contig successor ) {\n+        if ( !checkOverlap(predecessor.getSequence(), successor.getSequence()) ) {\n+                throw new GATKException(\"sequences can't be joined\");\n+        }\n+        final ContigImpl joinedContig = new ContigImpl(id, predecessor, successor);\n+        updateKmerContig(joinedContig.getFirstKmer(), joinedContig.getLastKmer(), joinedContig);\n+        return joinedContig;\n+    }\n+\n+    private static boolean checkOverlap( final CharSequence seq1, final CharSequence seq2 ) {\n+        final int seq1Len = seq1.length();\n+        final CharSequence seq1SubSeq = seq1.subSequence(seq1Len - Kmer.KSIZE + 1, seq1Len);\n+        final CharSequence seq2SubSeq = seq2.subSequence(0, Kmer.KSIZE - 1);\n+        return seq1SubSeq.equals(seq2SubSeq);\n+    }\n+\n+    /** set a unique componentId for every connected group of contigs **/\n+    @VisibleForTesting\n+    static int markComponents( final List<ContigImpl> contigs ) {\n+        for ( final ContigImpl contig : contigs ) {\n+            contig.setComponentId(0);\n+        }\n+\n+        int componentId = 0;\n+        for ( final ContigImpl contig : contigs ) {\n+            if ( contig.getComponentId() == 0 ) {\n+                contig.setComponentId(++componentId);\n+                markSuccessorComponents(contig);\n+                markSuccessorComponents(contig.rc());\n+            }\n+        }\n+        return componentId;\n+    }\n+\n+    private static void markSuccessorComponents( final Contig contig ) {\n+        final int componentId = contig.getComponentId();\n+        for ( final Contig successor : contig.getSuccessors() ) {\n+            if ( successor.getComponentId() == 0 ) {\n+                successor.canonical().setComponentId(componentId);\n+                markSuccessorComponents(successor);\n+                markSuccessorComponents(successor.rc());\n+            }\n+        }\n+    }\n+\n+    @VisibleForTesting\n+    static void markCycles( final List<ContigImpl> contigs ) {\n+        for ( final Contig contig : contigs ) {\n+            contig.setCyclic(false);\n+        }\n+\n+        final int nContigs = contigs.size();\n+        final Deque<Contig> deque = new ArrayDeque<>(nContigs);\n+        final Map<Contig, CutData> cutDataMap = new HashMap<>(nContigs * 3);\n+        for ( final Contig contig : contigs ) {\n+            if ( !cutDataMap.containsKey(contig) ) {\n+                markCyclesRecursion(contig, deque, cutDataMap);\n+            }\n+        }\n+    }\n+\n+    private static CutData markCyclesRecursion( final Contig contig,\n+                                                final Deque<Contig> deque,\n+                                                final Map<Contig, CutData> cutDataMap ) {\n+        final CutData cutData = new CutData();\n+        cutDataMap.put(contig, cutData);\n+        deque.addFirst(contig);\n+\n+        for ( final Contig successor : contig.getSuccessors() ) {\n+            final CutData successorCutData = cutDataMap.get(successor);\n+            if ( successorCutData == null ) {\n+                final int recursionVisitNum =\n+                        markCyclesRecursion(successor, deque, cutDataMap).minVisitNum;\n+                cutData.minVisitNum = Math.min(cutData.minVisitNum, recursionVisitNum);\n+            } else {\n+                cutData.minVisitNum = Math.min(cutData.minVisitNum, successorCutData.visitNum);\n+            }\n+        }\n+\n+        if ( cutData.visitNum == cutData.minVisitNum ) {\n+            Contig tig = deque.removeFirst();\n+            if ( tig == contig ) {\n+                cutDataMap.get(tig).visitNum = Integer.MAX_VALUE;\n+\n+                // single-vertex component -- cyclic only if self-referential\n+                if ( tig.getSuccessors().contains(tig) ) {\n+                    tig.setCyclic(true);\n+                }\n+            } else {\n+                while ( true ) {\n+                    // kill cross-links\n+                    cutDataMap.get(tig).visitNum = Integer.MAX_VALUE;\n+                    tig.setCyclic(true);\n+                    if ( tig == contig ) break;\n+                    tig = deque.removeFirst();\n+                }\n+            }\n+        }\n+        return cutData;\n+    }\n+\n+    @VisibleForTesting\n+    static boolean fillGaps( final KmerSet<KmerAdjacency> kmerAdjacencySet,\n+                             final List<GATKRead> reads ) {\n+        final Map<String, Integer> gapFillCounts = new HashMap<>();\n+        for ( final GATKRead read : reads ) {\n+            final Path path = new Path(read.getBasesNoCopy(), kmerAdjacencySet);\n+            final List<PathPart> parts = path.getParts();\n+            final int lastIdx = parts.size() - 1;\n+            for ( int idx = 1; idx < lastIdx; ++idx ) {\n+                final PathPart pathPart = parts.get(idx);\n+                if ( pathPart.isGap() ) {\n+                    final char prevCall = parts.get(idx - 1).getLastCall();\n+                    final char nextCall = parts.get(idx + 1).getFirstCall();\n+                    String gapFill = prevCall + pathPart.getSequence().toString() + nextCall;\n+                    final SequenceRC gapFillRC = new SequenceRC(gapFill);\n+                    if ( gapFillRC.compareTo(gapFill) < 0 ) {\n+                        gapFill = gapFillRC.toString();\n+                    }\n+                    gapFillCounts.merge(gapFill, 1, Integer::sum);\n+                }\n+            }\n+        }\n+\n+        boolean newKmers = false;\n+        for ( final Map.Entry<String, Integer> entry : gapFillCounts.entrySet() ) {\n+            final int nObservations = entry.getValue();\n+            if ( nObservations >= MIN_GAPFILL_COUNT ) {\n+                KmerAdjacency.kmerize(entry.getKey(), nObservations, kmerAdjacencySet);\n+                newKmers = true;\n+            }\n+        }\n+\n+        if ( newKmers ) {\n+            for ( final KmerAdjacency kmerAdjacency : kmerAdjacencySet ) {\n+                kmerAdjacency.clearContig();\n+            }\n+        }\n+        return newKmers;\n+    }\n+\n+    @VisibleForTesting\n+    static List<Path> pathReads( final KmerSet<KmerAdjacency> kmerAdjacencySet,\n+                          final List<GATKRead> reads ) {\n+        final List<Path> readPaths = new ArrayList<>(reads.size());\n+        for ( final GATKRead read : reads ) {\n+            readPaths.add(new Path(read.getBasesNoCopy(), kmerAdjacencySet));\n+        }\n+        return readPaths;\n+    }\n+\n+    @VisibleForTesting\n+    static Map<Contig,List<TransitPairCount>> collectTransitPairCounts(\n+            final List<ContigImpl> contigs,\n+            final List<Path> readPaths ) {\n+        final Map<Contig,List<TransitPairCount>> contigTransitsMap =\n+                new HashMap<>(3 * contigs.size());\n+        for ( final Path path : readPaths ) {\n+            final List<PathPart> parts = path.getParts();\n+            final int lastPart = parts.size() - 1;\n+            for ( int partIdx = 1; partIdx < lastPart; ++partIdx ) {\n+                final Contig prevContig = parts.get(partIdx - 1).getContig();\n+                if ( prevContig == null ) continue;\n+                final Contig curContig = parts.get(partIdx).getContig();\n+                if ( curContig == null ) {\n+                    partIdx += 1;\n+                    continue;\n+                }\n+                final Contig nextContig = parts.get(partIdx + 1).getContig();\n+                if ( nextContig == null ) {\n+                    partIdx += 2;\n+                    continue;\n+                }\n+                final TransitPairCount tpc = new TransitPairCount(prevContig, nextContig);\n+                final List<TransitPairCount> tpcList =\n+                        contigTransitsMap.computeIfAbsent(curContig, tig -> new ArrayList<>(4));\n+                final int idx = tpcList.indexOf(tpc);\n+                if ( idx != -1 ) {\n+                    tpcList.get(idx).observe();\n+                } else {\n+                    tpcList.add(tpc);\n+                    contigTransitsMap.computeIfAbsent(curContig.rc(), tig -> new ArrayList<>(4))\n+                            .add(tpc.getRC());\n+                }\n+            }\n+        }\n+        return contigTransitsMap;\n+    }\n+\n+    @VisibleForTesting\n+    static Set<Traversal> traverseAllPaths(\n+            final List<ContigImpl> contigs,\n+            final List<Path> readPaths,\n+            final Map<Contig, List<TransitPairCount>> contigTransitsMap ) {\n+        final Set<Traversal> traversalSet = new HashSet<>();\n+        final List<Contig> contigsList = new ArrayList<>();\n+        for ( final Contig contig : contigs ) {\n+            // untransited contigs are sources, sinks, or large contigs that can't be crossed by a read\n+            // build traversals from these\n+            if ( !contigTransitsMap.containsKey(contig) ) {\n+                boolean done = false;\n+                for ( final Contig successor : contig.getSuccessors() ) {\n+                    traverse(successor, contig,\n+                            contigsList, readPaths, contigTransitsMap, traversalSet);\n+                    done = true;\n+                }\n+                for ( final Contig predecessor : contig.getPredecessors() ) {\n+                    traverse(predecessor.rc(), contig.rc(),\n+                            contigsList, readPaths, contigTransitsMap, traversalSet);\n+                    done = true;\n+                }\n+                if ( !done ) { // if there were no predecessors or successors, it stands alone\n+                    addTraversal(new Traversal(Collections.singletonList(contig)), traversalSet);\n+                }\n+            }\n+        }\n+\n+        // look for transits that haven't been traced\n+        for ( final Map.Entry<Contig, List<TransitPairCount>> entry :\n+                contigTransitsMap.entrySet() ) {\n+            for ( final TransitPairCount tpc : entry.getValue() ) {\n+                if ( tpc.getCount() > 0 ) {\n+                    tpc.resetCount();\n+                    final Contig contig = entry.getKey();\n+                    final Set<Traversal> fwdTraversalSet = new HashSet<>();\n+                    traverse(tpc.getNextContig(), contig,\n+                            contigsList, readPaths, contigTransitsMap, fwdTraversalSet);\n+                    final Set<Traversal> revTraversalSet = new HashSet<>();\n+                    traverse(tpc.getPrevContig().rc(), contig.rc(),\n+                            contigsList, readPaths, contigTransitsMap, revTraversalSet);\n+                    for ( final Traversal revTraversal : revTraversalSet ) {\n+                        final Traversal revTraversalRC = revTraversal.rc();\n+                        for ( final Traversal fwdTraversal : fwdTraversalSet ) {\n+                            final int overlap =\n+                                    findMaxOverlap(revTraversalRC.getContigs(), fwdTraversal.getContigs());\n+                            final Traversal combo =\n+                                    Traversal.combineOverlappers(revTraversalRC, fwdTraversal, overlap);\n+                            addTraversal(combo, traversalSet);\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+\n+        return traversalSet;\n+    }\n+\n+    private static int findMaxOverlap( final List<Contig> prefixes, final List<Contig> suffixes ) {\n+        final int nPrefixes = prefixes.size();\n+        final Contig firstSuffix = suffixes.get(0);\n+        if ( !firstSuffix.isCyclic() ) {\n+            return prefixes.get(nPrefixes - 1) == firstSuffix ? 1 : 0;\n+        }\n+        final int nSuffixes = suffixes.size();\n+        for ( int prefixIdx = Math.max(0, nPrefixes - nSuffixes); prefixIdx != nPrefixes; ++prefixIdx ) {\n+            if ( prefixes.get(prefixIdx) == firstSuffix ) {\n+                int suffixIdx = 1;\n+                boolean match = true;\n+                for ( int prefixIdx2 = prefixIdx + 1; prefixIdx2 != nPrefixes; ++prefixIdx2 ) {\n+                    if ( prefixes.get(prefixIdx2) != suffixes.get(suffixIdx++) ) {\n+                        match = false;\n+                        break;\n+                    }\n+                }\n+                if ( match ) {\n+                    return nPrefixes - prefixIdx;\n+                }\n+            }\n+        }\n+        return 0;\n+    }\n+\n+    private static void traverse( final Contig contig,\n+                                  final Contig predecessor,\n+                                  final List<Contig> contigsList,\n+                                  final List<Path> readPaths,\n+                                  final Map<Contig, List<TransitPairCount>> contigTransitsMap,\n+                                  final Set<Traversal> traversalSet ) {\n+        contigsList.add(predecessor);\n+        if ( contig.isCyclic() ) {\n+            traverseCycle(contig, contigsList, readPaths, contigTransitsMap, traversalSet);\n+            contigsList.remove(contigsList.size() - 1);\n+            return;\n+        }\n+        final List<TransitPairCount> transits = contigTransitsMap.get(contig);\n+        boolean done = false;\n+        if ( transits != null ) {\n+            for ( final TransitPairCount tpc : transits ) {\n+                if ( tpc.getPrevContig() == predecessor ) {\n+                    final Contig successor = tpc.getNextContig();\n+                    if ( predecessor == contig.rc() ) {\n+                        final int nContigs = contigsList.size();\n+                        if ( nContigs > 1 ) {\n+                            if ( successor.rc() == contigsList.get(nContigs - 2) ) {\n+                                continue;\n+                            }\n+                        }\n+                    }\n+                    tpc.resetCount();\n+                    traverse(successor, contig, contigsList, readPaths, contigTransitsMap, traversalSet);\n+                    done = true;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e2201c1ef4f8ba71f17e169f07756cfe2f1ecb49"}, "originalPosition": 776}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzc3NjI2MDczOnYy", "diffSide": "RIGHT", "path": "src/main/java/org/broadinstitute/hellbender/tools/LocalAssembler.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMy0xOVQxNjo1ODoyMFrOI6JDbA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNC0xNVQyMToxNDo0MFrOJJ7v4w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5NzgzNjY1Mg==", "bodyText": "Maybe assert this / throw an exception if it's not true?", "url": "https://github.com/broadinstitute/gatk/pull/6989#discussion_r597836652", "createdAt": "2021-03-19T16:58:20Z", "author": {"login": "cwhelan"}, "path": "src/main/java/org/broadinstitute/hellbender/tools/LocalAssembler.java", "diffHunk": "@@ -0,0 +1,2306 @@\n+package org.broadinstitute.hellbender.tools;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import htsjdk.samtools.Cigar;\n+import htsjdk.samtools.CigarElement;\n+import htsjdk.samtools.CigarOperator;\n+import htsjdk.samtools.SAMUtils;\n+import org.broadinstitute.barclay.argparser.Argument;\n+import org.broadinstitute.barclay.argparser.BetaFeature;\n+import org.broadinstitute.barclay.argparser.CommandLineProgramProperties;\n+import org.broadinstitute.barclay.help.DocumentedFeature;\n+import org.broadinstitute.hellbender.cmdline.StandardArgumentDefinitions;\n+import org.broadinstitute.hellbender.cmdline.programgroups.CoverageAnalysisProgramGroup;\n+import org.broadinstitute.hellbender.exceptions.GATKException;\n+import org.broadinstitute.hellbender.tools.walkers.PairWalker;\n+import org.broadinstitute.hellbender.utils.SimpleInterval;\n+import org.broadinstitute.hellbender.utils.collections.HopscotchSet;\n+import org.broadinstitute.hellbender.utils.gcs.BucketUtils;\n+import org.broadinstitute.hellbender.utils.read.GATKRead;\n+\n+import java.io.BufferedWriter;\n+import java.io.FileWriter;\n+import java.io.IOException;\n+import java.io.OutputStreamWriter;\n+import java.util.*;\n+import java.util.zip.GZIPOutputStream;\n+\n+@DocumentedFeature\n+@CommandLineProgramProperties(\n+        summary = \"experiment\",\n+        oneLineSummary = \"experiment\",\n+        usageExample = \"gatk LocalAssembler\",\n+        programGroup = CoverageAnalysisProgramGroup.class\n+)\n+@BetaFeature\n+public class LocalAssembler extends PairWalker {\n+    public static final byte QMIN = 25;\n+    public static final int MIN_THIN_OBS = 4;\n+    public static final int MIN_GAPFILL_COUNT = 3;\n+    public static final int TOO_MANY_TRAVERSALS = 100000;\n+    public static final int TOO_MANY_SCAFFOLDS = 50000;\n+    public static final int MIN_SV_SIZE = 50;\n+\n+    @Argument(fullName=StandardArgumentDefinitions.OUTPUT_LONG_NAME,\n+            shortName=StandardArgumentDefinitions.OUTPUT_SHORT_NAME,\n+            doc=\"Write outputs to this file name prefix\", optional = true)\n+    public static String output;\n+\n+    @Argument(fullName=\"assembly-name\", doc=\"name of assembly used as a prefix for traversal names\")\n+    public static String assemblyName;\n+\n+    private final List<GATKRead> reads = new ArrayList<>();\n+\n+    @Override public boolean requiresIntervals() { return true; }\n+\n+    @Override public void apply( final GATKRead read, final GATKRead mate ) {\n+        trimOverruns(read, mate);\n+        reads.add(read);\n+        reads.add(mate);\n+    }\n+\n+    @Override public void applyUnpaired( final GATKRead read ) {\n+        reads.add(read);\n+    }\n+\n+    @Override public Object onTraversalSuccess() {\n+        super.onTraversalSuccess(); // flush any incomplete pairs\n+\n+        final int regionSize = getTraversalIntervals().stream().mapToInt(SimpleInterval::size).sum();\n+        final KmerSet<KmerAdjacency> kmerAdjacencySet = new KmerSet<>(10 * regionSize);\n+        kmerizeReads(reads, kmerAdjacencySet);\n+        List<ContigImpl> contigs = buildContigs(kmerAdjacencySet);\n+        connectContigs(contigs);\n+\n+        removeThinContigs(contigs, kmerAdjacencySet);\n+        weldPipes(contigs);\n+        markComponents(contigs);\n+\n+        if ( fillGaps(kmerAdjacencySet, reads) ) {\n+            contigs = buildContigs(kmerAdjacencySet);\n+            connectContigs(contigs);\n+            removeThinContigs(contigs, kmerAdjacencySet);\n+            weldPipes(contigs);\n+            markComponents(contigs);\n+        }\n+\n+        markCycles(contigs);\n+\n+        final String outputFilePrefix = output != null ? output : assemblyName;\n+        final List<Path> readPaths = pathReads(kmerAdjacencySet, reads);\n+        final Map<Contig,List<TransitPairCount>> contigTransitsMap =\n+                collectTransitPairCounts(contigs, readPaths);\n+        final String traversalsFilename = outputFilePrefix + \".traversals.fa.gz\";\n+        try {\n+            final List<Traversal> allTraversals =\n+                    new ArrayList<>(traverseAllPaths(contigs, readPaths, contigTransitsMap));\n+            writeTraversals(allTraversals, traversalsFilename);\n+            try {\n+                final String scaffoldsFileName = outputFilePrefix + \".scaffolds.fa.gz\";\n+                writeTraversals(createScaffolds(allTraversals), scaffoldsFileName);\n+            } catch ( final AssemblyTooComplexException x ) {\n+                logger.warn(\"Assembly too complex for scaffolding.\");\n+            }\n+        } catch ( final AssemblyTooComplexException x ) {\n+            logger.warn(\"Assembly too complex.  Writing contigs as traversals in \" +\n+                    traversalsFilename + \".\");\n+            final Collection<Traversal> contigTraversals = new ArrayList<>(contigs.size());\n+            for ( final Contig contig : contigs ) {\n+                contigTraversals.add(new Traversal(Collections.singletonList(contig)));\n+            }\n+            writeTraversals(contigTraversals, traversalsFilename);\n+        }\n+\n+        contigs.sort(Comparator.comparingInt(ContigImpl::getId));\n+        writeDOT(contigs, outputFilePrefix + \".assembly.dot\");\n+        writeContigs(contigs, outputFilePrefix + \".contigs.txt.gz\");\n+        writePaths(readPaths, outputFilePrefix + \".paths.txt.gz\");\n+        writeReads(reads, outputFilePrefix + \".reads.fastq.gz\");\n+        return null;\n+    }\n+\n+    /** trim read pairs of base calls that have gone past the end of a short fragment */\n+    private void trimOverruns( final GATKRead read, final GATKRead mate ) {\n+        // if both mapped and they're on different strands\n+        if ( !read.isUnmapped() && !mate.isUnmapped() &&\n+                read.isReverseStrand() != mate.isReverseStrand() ) {\n+            // and both start within 1 base on the ref\n+            if ( Math.abs(read.getStart() - read.getMateStart()) <= 1 ) {\n+                // and both end within 1 base\n+                final int readRefLen = read.getCigar().getReferenceLength();\n+                final int mateRefLen = mate.getCigar().getReferenceLength();\n+                if ( Math.abs(readRefLen - mateRefLen) <= 1 ) {\n+                    if ( mate.isReverseStrand() ) {\n+                        trimClips(read, mate);\n+                    } else {\n+                        trimClips(mate, read);\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    private void trimClips( final GATKRead fwd, final GATKRead rev ) {\n+        final List<CigarElement> fwdElements = fwd.getCigarElements();\n+        final List<CigarElement> revElements = rev.getCigarElements();\n+        final int lastElementIdx = fwdElements.size() - 1;\n+        final CigarElement fwdLastElement = fwdElements.get(lastElementIdx);\n+        final CigarElement revFirstElement = revElements.get(0);\n+        if ( fwdLastElement.getOperator() == CigarOperator.S &&\n+                revFirstElement.getOperator() == CigarOperator.S ) {\n+            final byte[] fwdBases = fwd.getBasesNoCopy();\n+            final int lastElementLen = fwdLastElement.getLength();\n+            fwd.setBases(Arrays.copyOfRange(fwdBases, 0, fwdBases.length - lastElementLen));\n+            final byte[] fwdQuals = fwd.getBaseQualitiesNoCopy();\n+            if ( fwdQuals.length > 0 ) {\n+                final int qualsLen = fwdQuals.length - lastElementLen;\n+                fwd.setBaseQualities(Arrays.copyOfRange(fwdQuals, 0, qualsLen));\n+            }\n+            final List<CigarElement> newFwdElements = new ArrayList<>(fwdElements);\n+            newFwdElements.set(lastElementIdx, new CigarElement(lastElementLen, CigarOperator.H));\n+            fwd.setCigar(new Cigar(newFwdElements));\n+\n+            final byte[] revBases = rev.getBasesNoCopy();\n+            final int firstElementLen = revFirstElement.getLength();\n+            rev.setBases(Arrays.copyOfRange(revBases, firstElementLen, revBases.length));\n+            final byte[] revQuals = rev.getBaseQualitiesNoCopy();\n+            if ( revQuals.length > 0 ) {\n+                rev.setBaseQualities(Arrays.copyOfRange(revQuals, firstElementLen, revQuals.length));\n+            }\n+            final List<CigarElement> newRevElements = new ArrayList<>(revElements);\n+            newRevElements.set(0, new CigarElement(firstElementLen, CigarOperator.H));\n+            rev.setCigar(new Cigar(newRevElements));\n+        }\n+    }\n+\n+    @VisibleForTesting\n+    static void kmerizeReads( final List<GATKRead> reads,\n+                              final KmerSet<KmerAdjacency> kmerAdjacencySet ) {\n+        for ( final GATKRead read : reads ) {\n+            final byte[] calls = read.getBasesNoCopy();\n+            final byte[] quals = read.getBaseQualitiesNoCopy();\n+            KmerAdjacency.kmerize(calls, quals, QMIN, kmerAdjacencySet);\n+        }\n+    }\n+\n+    /** gather unbranched strings of kmers into contigs **/\n+    @VisibleForTesting\n+    static List<ContigImpl> buildContigs( final KmerSet<KmerAdjacency> kmerAdjacencySet ) {\n+        // gather strings of kmers that have a single predecessor and single successor into contigs\n+        final List<ContigImpl> contigs = new ArrayList<>();\n+        int nContigs = 0;\n+        for ( final KmerAdjacency kmerAdjacency : kmerAdjacencySet ) {\n+            if ( kmerAdjacency.getContig() == null ) {\n+                ContigImpl contig = null;\n+                final KmerAdjacency predecessor = kmerAdjacency.getSolePredecessor();\n+                if ( predecessor == null ||\n+                        predecessor.getSuccessorCount() > 1 ||\n+                        predecessor == kmerAdjacency.rc() ) {\n+                    contig = new ContigImpl(++nContigs, kmerAdjacency);\n+                } else {\n+                    final KmerAdjacency successor = kmerAdjacency.getSoleSuccessor();\n+                    if ( successor == null ||\n+                            successor.getPredecessorCount() > 1 ||\n+                            successor == kmerAdjacency.rc() ) {\n+                        contig = new ContigImpl(++nContigs, kmerAdjacency.rc());\n+                    }\n+                }\n+                if ( contig != null ) {\n+                    contigs.add(contig);\n+                }\n+            }\n+        }\n+\n+        // if there are smooth circles like a plasmid, gather them together as a contig, too\n+        for ( final KmerAdjacency kmerAdjacency : kmerAdjacencySet ) {\n+            if ( kmerAdjacency.getContig() == null ) {\n+                contigs.add(new ContigImpl(++nContigs, kmerAdjacency));\n+            }\n+        }\n+\n+        return contigs;\n+    }\n+\n+    /** connect contigs when the final kmer of one contig is adjacent to the inital contig of another **/\n+    @VisibleForTesting\n+    static void connectContigs( final List<ContigImpl> contigs ) {\n+        final int nContigs = contigs.size();\n+        final KmerSet<ContigEndKmer> contigEnds = new KmerSet<>(2*nContigs);\n+        for ( int contigId = 0; contigId != nContigs; ++contigId ) {\n+            final ContigImpl contig = contigs.get(contigId);\n+            final KmerAdjacency fwdKmer = contig.getFirstKmer();\n+            final KmerAdjacency revKmer = contig.getLastKmer().rc();\n+            if ( fwdKmer == revKmer ) {\n+                contigEnds.add(new ContigEndKmer(fwdKmer.getKVal(), contig, ContigOrientation.BOTH));\n+            } else {\n+                contigEnds.add(new ContigEndKmer(fwdKmer.getKVal(), contig, ContigOrientation.FWD));\n+                contigEnds.add(new ContigEndKmer(revKmer.getKVal(), contig, ContigOrientation.REV));\n+            }\n+        }\n+\n+        for ( int contigId = 0; contigId != nContigs; ++contigId ) {\n+            final Contig contig = contigs.get(contigId);\n+\n+            final KmerAdjacency start = contig.getFirstKmer();\n+            final int predecessorCount = start.getPredecessorCount();\n+            if ( predecessorCount > 0 ) {\n+                final List<Contig> predecessors = contig.getPredecessors();\n+                final int mask = start.getPredecessorMask();\n+                for ( int call = 0; call != 4; ++call ) {\n+                    if ( (mask & (1 << call)) != 0 ) {\n+                        final long kVal =\n+                                KmerAdjacency.reverseComplement(start.getPredecessorVal(call));\n+                        final ContigEndKmer contigEndKmer = contigEnds.find(new Kmer(kVal));\n+                        if ( contigEndKmer == null ) {\n+                            throw new GATKException(\"missing contig end kmer\");\n+                        }\n+                        switch ( contigEndKmer.getContigOrientation() ) {\n+                            case FWD:\n+                                predecessors.add(contigEndKmer.getContig().rc());\n+                                break;\n+                            case REV:\n+                                predecessors.add(contigEndKmer.getContig());\n+                                break;\n+                            case BOTH:\n+                                predecessors.add(contigEndKmer.getContig());\n+                                predecessors.add(contigEndKmer.getContig().rc());\n+                                break;\n+                        }\n+                    }\n+                }\n+            }\n+\n+            final KmerAdjacency end = contig.getLastKmer();\n+            final int successorCount = end.getSuccessorCount();\n+            if ( successorCount > 0 ) {\n+                final List<Contig> successors = contig.getSuccessors();\n+                final int mask = end.getSuccessorMask();\n+                for ( int call = 0; call != 4; ++call ) {\n+                    if ( (mask & (1 << call)) != 0 ) {\n+                        final long kVal = end.getSuccessorVal(call);\n+                        final ContigEndKmer contigEndKmer = contigEnds.find(new Kmer(kVal));\n+                        if ( contigEndKmer == null ) {\n+                            throw new GATKException(\"missing contig end kmer\");\n+                        }\n+                        switch ( contigEndKmer.getContigOrientation() ) {\n+                            case FWD:\n+                                successors.add(contigEndKmer.getContig());\n+                                break;\n+                            case REV:\n+                                successors.add(contigEndKmer.getContig().rc());\n+                                break;\n+                            case BOTH:\n+                                successors.add(contigEndKmer.getContig());\n+                                successors.add(contigEndKmer.getContig().rc());\n+                                break;\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    /** remove contigs that have little evidence **/\n+    @VisibleForTesting\n+    static void removeThinContigs( final List<ContigImpl> contigs,\n+                                           final KmerSet<KmerAdjacency> kmerAdjacencySet ) {\n+        contigs.sort(Comparator.comparingInt(ContigImpl::getMaxObservations));\n+        boolean contigRemoved;\n+        do {\n+            // figure out which contigs are cut points\n+            // i.e., those contigs which, if removed, would result in a graph with more connected components\n+            final int nContigs = contigs.size();\n+            final Map<Contig, CutData> cutDataMap = new HashMap<>(nContigs * 3);\n+\n+            for ( final ContigImpl contig : contigs ) {\n+                if ( cutDataMap.containsKey(contig) ) {\n+                    continue;\n+                }\n+\n+                cutDataMap.put(contig, new CutData());\n+                int children = 0;\n+                for ( final Contig nextContig : contig.getSuccessors() ) {\n+                    if ( !cutDataMap.containsKey(nextContig) ) {\n+                        findCuts(nextContig, contig, cutDataMap);\n+                        children += 1;\n+                    }\n+                }\n+                for ( final Contig nextContig : contig.getPredecessors() ) {\n+                    if ( !cutDataMap.containsKey(nextContig) ) {\n+                        findCuts(nextContig, contig, cutDataMap);\n+                        children += 1;\n+                    }\n+                }\n+                if ( children >= 2 ) {\n+                    contig.setCut(true);\n+                }\n+            }\n+\n+            // remove poorly attested (low max observations) contigs, unless they are cut points\n+            contigRemoved = false;\n+            final Iterator<ContigImpl> itr = contigs.iterator();\n+            while ( itr.hasNext() ) {\n+                final Contig contig = itr.next();\n+                if ( contig.getMaxObservations() < MIN_THIN_OBS && !contig.isCut() ) {\n+                    unlinkContig(contig, kmerAdjacencySet);\n+                    itr.remove();\n+                    contigRemoved = true;\n+                    break;\n+                }\n+            }\n+        } while ( contigRemoved );\n+        contigs.sort(Comparator.comparingInt(ContigImpl::getId));\n+    }\n+\n+    private static CutData findCuts( final Contig contig,\n+                                     final Contig parent,\n+                                     final Map<Contig, CutData> cutDataMap ) {\n+        final CutData cutData = new CutData();\n+        cutDataMap.put(contig, cutData);\n+        for ( final Contig nextContig : contig.getSuccessors() ) {\n+            if ( nextContig == parent ) {\n+                continue;\n+            }\n+            CutData nextCutData = cutDataMap.get(nextContig);\n+            if ( nextCutData != null ) {\n+                cutData.minVisitNum = Math.min(cutData.minVisitNum, nextCutData.visitNum);\n+            } else {\n+                nextCutData = findCuts(nextContig, contig, cutDataMap);\n+                cutData.minVisitNum = Math.min(cutData.minVisitNum, nextCutData.minVisitNum);\n+                if ( nextCutData.minVisitNum >= cutData.visitNum ) {\n+                    contig.setCut(true);\n+                }\n+            }\n+        }\n+        for ( final Contig nextContig : contig.getPredecessors() ) {\n+            if ( nextContig == parent ) {\n+                continue;\n+            }\n+            CutData nextCutData = cutDataMap.get(nextContig);\n+            if ( nextCutData != null ) {\n+                cutData.minVisitNum = Math.min(cutData.minVisitNum, nextCutData.visitNum);\n+            } else {\n+                nextCutData = findCuts(nextContig, contig, cutDataMap);\n+                cutData.minVisitNum = Math.min(cutData.minVisitNum, nextCutData.minVisitNum);\n+                if ( nextCutData.minVisitNum >= cutData.visitNum ) {\n+                    contig.setCut(true);\n+                }\n+            }\n+        }\n+        return cutData;\n+    }\n+\n+    @VisibleForTesting\n+    static void unlinkContig( final Contig contig,\n+                                      final KmerSet<KmerAdjacency> kmerAdjacencySet ) {\n+        final KmerAdjacency firstKmer = contig.getFirstKmer();\n+        final int firstKmerFinalCall = firstKmer.getFinalCall();\n+        for ( final Contig predecessor : contig.getPredecessors() ) {\n+            if ( predecessor != contig && predecessor != contig.rc() ) {\n+                predecessor.getLastKmer().removeSuccessor(firstKmerFinalCall, kmerAdjacencySet);\n+                if ( !predecessor.getSuccessors().remove(contig) ) {\n+                    throw new GATKException(\"failed to find predecessor link\");\n+                }\n+            }\n+        }\n+\n+        final KmerAdjacency lastKmer = contig.getLastKmer();\n+        final int lastKmerInitialCall = lastKmer.getInitialCall();\n+        for ( final Contig successor : contig.getSuccessors() ) {\n+            if ( successor != contig && successor != contig.rc() ) {\n+                successor.getFirstKmer().removePredecessor(lastKmerInitialCall, kmerAdjacencySet);\n+                if ( !successor.getPredecessors().remove(contig) ) {\n+                    throw new GATKException(\"failed to find successor link\");\n+                }\n+            }\n+        }\n+\n+        KmerAdjacency nextKmer = firstKmer;\n+        KmerAdjacency kmer;\n+        do {\n+            kmer = nextKmer;\n+            nextKmer = kmer.getSoleSuccessor();\n+            kmerAdjacencySet.remove(kmer.canonical());\n+        } while ( kmer != lastKmer );\n+    }\n+\n+    private static void updateKmerContig( final KmerAdjacency firstKmer,\n+                                          final KmerAdjacency lastKmer,\n+                                          final Contig contig ) {\n+        int offset = 0;\n+        for ( KmerAdjacency kmer = firstKmer; kmer != lastKmer; kmer = kmer.getSoleSuccessor() ) {\n+            if ( kmer == null ) {\n+                throw new GATKException(\"contig does not have a flat pipeline of kmers\");\n+            }\n+            kmer.clearContig();\n+            kmer.setContigOffset(contig, offset++);\n+        }\n+        lastKmer.clearContig();\n+        lastKmer.setContigOffset(contig, offset);\n+        if ( offset + Kmer.KSIZE != contig.size() ) {\n+            throw new GATKException(\"kmer chain length does not equal contig size\");\n+        }\n+    }\n+\n+    /** replace adjacent contigs without branches with a single, larger contig **/\n+    @VisibleForTesting\n+    static void weldPipes( final List<ContigImpl> contigs ) {\n+        for ( int contigIdx = 0; contigIdx != contigs.size(); ++contigIdx ) {\n+            final ContigImpl contig = contigs.get(contigIdx);\n+            if ( contig.getSuccessors().size() == 1 ) {\n+                final Contig successor = contig.getSuccessors().get(0);\n+                if ( successor != contig && successor != contig.rc() &&\n+                        successor.getPredecessors().size() == 1 ) {\n+                    contigs.set(contigIdx, join(contig.getId(), contig, successor));\n+                    if ( !contigs.remove(successor.canonical()) ) {\n+                        throw new GATKException(\"successor linkage is messed up\");\n+                    }\n+                    contigIdx -= 1; // reconsider the new contig -- there might be more joining possible\n+                    continue;\n+                }\n+            }\n+            if ( contig.getPredecessors().size() == 1 ) {\n+                final Contig predecessor = contig.getPredecessors().get(0);\n+                if ( predecessor != contig && predecessor != contig.rc() &&\n+                        predecessor.getSuccessors().size() == 1 ) {\n+                    contigs.set(contigIdx, join(contig.getId(), predecessor, contig));\n+                    if ( !contigs.remove(predecessor.canonical()) ) {\n+                        throw new GATKException(\"predecessor linkage is messed up\");\n+                    }\n+                    contigIdx -= 1; // reconsider\n+                }\n+            }\n+        }\n+    }\n+\n+    private static ContigImpl join( final int id, final Contig predecessor, final Contig successor ) {\n+        if ( !checkOverlap(predecessor.getSequence(), successor.getSequence()) ) {\n+                throw new GATKException(\"sequences can't be joined\");\n+        }\n+        final ContigImpl joinedContig = new ContigImpl(id, predecessor, successor);\n+        updateKmerContig(joinedContig.getFirstKmer(), joinedContig.getLastKmer(), joinedContig);\n+        return joinedContig;\n+    }\n+\n+    private static boolean checkOverlap( final CharSequence seq1, final CharSequence seq2 ) {\n+        final int seq1Len = seq1.length();\n+        final CharSequence seq1SubSeq = seq1.subSequence(seq1Len - Kmer.KSIZE + 1, seq1Len);\n+        final CharSequence seq2SubSeq = seq2.subSequence(0, Kmer.KSIZE - 1);\n+        return seq1SubSeq.equals(seq2SubSeq);\n+    }\n+\n+    /** set a unique componentId for every connected group of contigs **/\n+    @VisibleForTesting\n+    static int markComponents( final List<ContigImpl> contigs ) {\n+        for ( final ContigImpl contig : contigs ) {\n+            contig.setComponentId(0);\n+        }\n+\n+        int componentId = 0;\n+        for ( final ContigImpl contig : contigs ) {\n+            if ( contig.getComponentId() == 0 ) {\n+                contig.setComponentId(++componentId);\n+                markSuccessorComponents(contig);\n+                markSuccessorComponents(contig.rc());\n+            }\n+        }\n+        return componentId;\n+    }\n+\n+    private static void markSuccessorComponents( final Contig contig ) {\n+        final int componentId = contig.getComponentId();\n+        for ( final Contig successor : contig.getSuccessors() ) {\n+            if ( successor.getComponentId() == 0 ) {\n+                successor.canonical().setComponentId(componentId);\n+                markSuccessorComponents(successor);\n+                markSuccessorComponents(successor.rc());\n+            }\n+        }\n+    }\n+\n+    @VisibleForTesting\n+    static void markCycles( final List<ContigImpl> contigs ) {\n+        for ( final Contig contig : contigs ) {\n+            contig.setCyclic(false);\n+        }\n+\n+        final int nContigs = contigs.size();\n+        final Deque<Contig> deque = new ArrayDeque<>(nContigs);\n+        final Map<Contig, CutData> cutDataMap = new HashMap<>(nContigs * 3);\n+        for ( final Contig contig : contigs ) {\n+            if ( !cutDataMap.containsKey(contig) ) {\n+                markCyclesRecursion(contig, deque, cutDataMap);\n+            }\n+        }\n+    }\n+\n+    private static CutData markCyclesRecursion( final Contig contig,\n+                                                final Deque<Contig> deque,\n+                                                final Map<Contig, CutData> cutDataMap ) {\n+        final CutData cutData = new CutData();\n+        cutDataMap.put(contig, cutData);\n+        deque.addFirst(contig);\n+\n+        for ( final Contig successor : contig.getSuccessors() ) {\n+            final CutData successorCutData = cutDataMap.get(successor);\n+            if ( successorCutData == null ) {\n+                final int recursionVisitNum =\n+                        markCyclesRecursion(successor, deque, cutDataMap).minVisitNum;\n+                cutData.minVisitNum = Math.min(cutData.minVisitNum, recursionVisitNum);\n+            } else {\n+                cutData.minVisitNum = Math.min(cutData.minVisitNum, successorCutData.visitNum);\n+            }\n+        }\n+\n+        if ( cutData.visitNum == cutData.minVisitNum ) {\n+            Contig tig = deque.removeFirst();\n+            if ( tig == contig ) {\n+                cutDataMap.get(tig).visitNum = Integer.MAX_VALUE;\n+\n+                // single-vertex component -- cyclic only if self-referential\n+                if ( tig.getSuccessors().contains(tig) ) {\n+                    tig.setCyclic(true);\n+                }\n+            } else {\n+                while ( true ) {\n+                    // kill cross-links\n+                    cutDataMap.get(tig).visitNum = Integer.MAX_VALUE;\n+                    tig.setCyclic(true);\n+                    if ( tig == contig ) break;\n+                    tig = deque.removeFirst();\n+                }\n+            }\n+        }\n+        return cutData;\n+    }\n+\n+    @VisibleForTesting\n+    static boolean fillGaps( final KmerSet<KmerAdjacency> kmerAdjacencySet,\n+                             final List<GATKRead> reads ) {\n+        final Map<String, Integer> gapFillCounts = new HashMap<>();\n+        for ( final GATKRead read : reads ) {\n+            final Path path = new Path(read.getBasesNoCopy(), kmerAdjacencySet);\n+            final List<PathPart> parts = path.getParts();\n+            final int lastIdx = parts.size() - 1;\n+            for ( int idx = 1; idx < lastIdx; ++idx ) {\n+                final PathPart pathPart = parts.get(idx);\n+                if ( pathPart.isGap() ) {\n+                    final char prevCall = parts.get(idx - 1).getLastCall();\n+                    final char nextCall = parts.get(idx + 1).getFirstCall();\n+                    String gapFill = prevCall + pathPart.getSequence().toString() + nextCall;\n+                    final SequenceRC gapFillRC = new SequenceRC(gapFill);\n+                    if ( gapFillRC.compareTo(gapFill) < 0 ) {\n+                        gapFill = gapFillRC.toString();\n+                    }\n+                    gapFillCounts.merge(gapFill, 1, Integer::sum);\n+                }\n+            }\n+        }\n+\n+        boolean newKmers = false;\n+        for ( final Map.Entry<String, Integer> entry : gapFillCounts.entrySet() ) {\n+            final int nObservations = entry.getValue();\n+            if ( nObservations >= MIN_GAPFILL_COUNT ) {\n+                KmerAdjacency.kmerize(entry.getKey(), nObservations, kmerAdjacencySet);\n+                newKmers = true;\n+            }\n+        }\n+\n+        if ( newKmers ) {\n+            for ( final KmerAdjacency kmerAdjacency : kmerAdjacencySet ) {\n+                kmerAdjacency.clearContig();\n+            }\n+        }\n+        return newKmers;\n+    }\n+\n+    @VisibleForTesting\n+    static List<Path> pathReads( final KmerSet<KmerAdjacency> kmerAdjacencySet,\n+                          final List<GATKRead> reads ) {\n+        final List<Path> readPaths = new ArrayList<>(reads.size());\n+        for ( final GATKRead read : reads ) {\n+            readPaths.add(new Path(read.getBasesNoCopy(), kmerAdjacencySet));\n+        }\n+        return readPaths;\n+    }\n+\n+    @VisibleForTesting\n+    static Map<Contig,List<TransitPairCount>> collectTransitPairCounts(\n+            final List<ContigImpl> contigs,\n+            final List<Path> readPaths ) {\n+        final Map<Contig,List<TransitPairCount>> contigTransitsMap =\n+                new HashMap<>(3 * contigs.size());\n+        for ( final Path path : readPaths ) {\n+            final List<PathPart> parts = path.getParts();\n+            final int lastPart = parts.size() - 1;\n+            for ( int partIdx = 1; partIdx < lastPart; ++partIdx ) {\n+                final Contig prevContig = parts.get(partIdx - 1).getContig();\n+                if ( prevContig == null ) continue;\n+                final Contig curContig = parts.get(partIdx).getContig();\n+                if ( curContig == null ) {\n+                    partIdx += 1;\n+                    continue;\n+                }\n+                final Contig nextContig = parts.get(partIdx + 1).getContig();\n+                if ( nextContig == null ) {\n+                    partIdx += 2;\n+                    continue;\n+                }\n+                final TransitPairCount tpc = new TransitPairCount(prevContig, nextContig);\n+                final List<TransitPairCount> tpcList =\n+                        contigTransitsMap.computeIfAbsent(curContig, tig -> new ArrayList<>(4));\n+                final int idx = tpcList.indexOf(tpc);\n+                if ( idx != -1 ) {\n+                    tpcList.get(idx).observe();\n+                } else {\n+                    tpcList.add(tpc);\n+                    contigTransitsMap.computeIfAbsent(curContig.rc(), tig -> new ArrayList<>(4))\n+                            .add(tpc.getRC());\n+                }\n+            }\n+        }\n+        return contigTransitsMap;\n+    }\n+\n+    @VisibleForTesting\n+    static Set<Traversal> traverseAllPaths(\n+            final List<ContigImpl> contigs,\n+            final List<Path> readPaths,\n+            final Map<Contig, List<TransitPairCount>> contigTransitsMap ) {\n+        final Set<Traversal> traversalSet = new HashSet<>();\n+        final List<Contig> contigsList = new ArrayList<>();\n+        for ( final Contig contig : contigs ) {\n+            // untransited contigs are sources, sinks, or large contigs that can't be crossed by a read\n+            // build traversals from these\n+            if ( !contigTransitsMap.containsKey(contig) ) {\n+                boolean done = false;\n+                for ( final Contig successor : contig.getSuccessors() ) {\n+                    traverse(successor, contig,\n+                            contigsList, readPaths, contigTransitsMap, traversalSet);\n+                    done = true;\n+                }\n+                for ( final Contig predecessor : contig.getPredecessors() ) {\n+                    traverse(predecessor.rc(), contig.rc(),\n+                            contigsList, readPaths, contigTransitsMap, traversalSet);\n+                    done = true;\n+                }\n+                if ( !done ) { // if there were no predecessors or successors, it stands alone\n+                    addTraversal(new Traversal(Collections.singletonList(contig)), traversalSet);\n+                }\n+            }\n+        }\n+\n+        // look for transits that haven't been traced\n+        for ( final Map.Entry<Contig, List<TransitPairCount>> entry :\n+                contigTransitsMap.entrySet() ) {\n+            for ( final TransitPairCount tpc : entry.getValue() ) {\n+                if ( tpc.getCount() > 0 ) {\n+                    tpc.resetCount();\n+                    final Contig contig = entry.getKey();\n+                    final Set<Traversal> fwdTraversalSet = new HashSet<>();\n+                    traverse(tpc.getNextContig(), contig,\n+                            contigsList, readPaths, contigTransitsMap, fwdTraversalSet);\n+                    final Set<Traversal> revTraversalSet = new HashSet<>();\n+                    traverse(tpc.getPrevContig().rc(), contig.rc(),\n+                            contigsList, readPaths, contigTransitsMap, revTraversalSet);\n+                    for ( final Traversal revTraversal : revTraversalSet ) {\n+                        final Traversal revTraversalRC = revTraversal.rc();\n+                        for ( final Traversal fwdTraversal : fwdTraversalSet ) {\n+                            final int overlap =\n+                                    findMaxOverlap(revTraversalRC.getContigs(), fwdTraversal.getContigs());\n+                            final Traversal combo =\n+                                    Traversal.combineOverlappers(revTraversalRC, fwdTraversal, overlap);\n+                            addTraversal(combo, traversalSet);\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+\n+        return traversalSet;\n+    }\n+\n+    private static int findMaxOverlap( final List<Contig> prefixes, final List<Contig> suffixes ) {\n+        final int nPrefixes = prefixes.size();\n+        final Contig firstSuffix = suffixes.get(0);\n+        if ( !firstSuffix.isCyclic() ) {\n+            return prefixes.get(nPrefixes - 1) == firstSuffix ? 1 : 0;\n+        }\n+        final int nSuffixes = suffixes.size();\n+        for ( int prefixIdx = Math.max(0, nPrefixes - nSuffixes); prefixIdx != nPrefixes; ++prefixIdx ) {\n+            if ( prefixes.get(prefixIdx) == firstSuffix ) {\n+                int suffixIdx = 1;\n+                boolean match = true;\n+                for ( int prefixIdx2 = prefixIdx + 1; prefixIdx2 != nPrefixes; ++prefixIdx2 ) {\n+                    if ( prefixes.get(prefixIdx2) != suffixes.get(suffixIdx++) ) {\n+                        match = false;\n+                        break;\n+                    }\n+                }\n+                if ( match ) {\n+                    return nPrefixes - prefixIdx;\n+                }\n+            }\n+        }\n+        return 0;\n+    }\n+\n+    private static void traverse( final Contig contig,\n+                                  final Contig predecessor,\n+                                  final List<Contig> contigsList,\n+                                  final List<Path> readPaths,\n+                                  final Map<Contig, List<TransitPairCount>> contigTransitsMap,\n+                                  final Set<Traversal> traversalSet ) {\n+        contigsList.add(predecessor);\n+        if ( contig.isCyclic() ) {\n+            traverseCycle(contig, contigsList, readPaths, contigTransitsMap, traversalSet);\n+            contigsList.remove(contigsList.size() - 1);\n+            return;\n+        }\n+        final List<TransitPairCount> transits = contigTransitsMap.get(contig);\n+        boolean done = false;\n+        if ( transits != null ) {\n+            for ( final TransitPairCount tpc : transits ) {\n+                if ( tpc.getPrevContig() == predecessor ) {\n+                    final Contig successor = tpc.getNextContig();\n+                    if ( predecessor == contig.rc() ) {\n+                        final int nContigs = contigsList.size();\n+                        if ( nContigs > 1 ) {\n+                            if ( successor.rc() == contigsList.get(nContigs - 2) ) {\n+                                continue;\n+                            }\n+                        }\n+                    }\n+                    tpc.resetCount();\n+                    traverse(successor, contig, contigsList, readPaths, contigTransitsMap, traversalSet);\n+                    done = true;\n+                }\n+            }\n+        }\n+        if ( !done ) {\n+            contigsList.add(contig);\n+            addTraversal(new Traversal(contigsList), traversalSet);\n+            contigsList.remove(contigsList.size() - 1);\n+        }\n+        contigsList.remove(contigsList.size() - 1);\n+    }\n+\n+    private static void traverseCycle( final Contig contig,\n+                                       final List<Contig> contigsList,\n+                                       final List<Path> readPaths,\n+                                       final Map<Contig, List<TransitPairCount>> contigTransitsMap,\n+                                       final Set<Traversal> traversalSet ) {\n+        contigsList.add(contig);\n+        final int nContigs = contigsList.size();\n+        // the final element of the list is cyclic, if there's a previous element it will be\n+        // non-cyclic, so start there figuring out how far the read paths lead us", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e2201c1ef4f8ba71f17e169f07756cfe2f1ecb49"}, "originalPosition": 796}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxNDM5NTg3NQ==", "bodyText": "I've added a test that the final element is cyclic.  The assertion about the previous element was incorrect, and I've revised the comment accordingly.", "url": "https://github.com/broadinstitute/gatk/pull/6989#discussion_r614395875", "createdAt": "2021-04-15T21:14:40Z", "author": {"login": "tedsharpe"}, "path": "src/main/java/org/broadinstitute/hellbender/tools/LocalAssembler.java", "diffHunk": "@@ -0,0 +1,2306 @@\n+package org.broadinstitute.hellbender.tools;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import htsjdk.samtools.Cigar;\n+import htsjdk.samtools.CigarElement;\n+import htsjdk.samtools.CigarOperator;\n+import htsjdk.samtools.SAMUtils;\n+import org.broadinstitute.barclay.argparser.Argument;\n+import org.broadinstitute.barclay.argparser.BetaFeature;\n+import org.broadinstitute.barclay.argparser.CommandLineProgramProperties;\n+import org.broadinstitute.barclay.help.DocumentedFeature;\n+import org.broadinstitute.hellbender.cmdline.StandardArgumentDefinitions;\n+import org.broadinstitute.hellbender.cmdline.programgroups.CoverageAnalysisProgramGroup;\n+import org.broadinstitute.hellbender.exceptions.GATKException;\n+import org.broadinstitute.hellbender.tools.walkers.PairWalker;\n+import org.broadinstitute.hellbender.utils.SimpleInterval;\n+import org.broadinstitute.hellbender.utils.collections.HopscotchSet;\n+import org.broadinstitute.hellbender.utils.gcs.BucketUtils;\n+import org.broadinstitute.hellbender.utils.read.GATKRead;\n+\n+import java.io.BufferedWriter;\n+import java.io.FileWriter;\n+import java.io.IOException;\n+import java.io.OutputStreamWriter;\n+import java.util.*;\n+import java.util.zip.GZIPOutputStream;\n+\n+@DocumentedFeature\n+@CommandLineProgramProperties(\n+        summary = \"experiment\",\n+        oneLineSummary = \"experiment\",\n+        usageExample = \"gatk LocalAssembler\",\n+        programGroup = CoverageAnalysisProgramGroup.class\n+)\n+@BetaFeature\n+public class LocalAssembler extends PairWalker {\n+    public static final byte QMIN = 25;\n+    public static final int MIN_THIN_OBS = 4;\n+    public static final int MIN_GAPFILL_COUNT = 3;\n+    public static final int TOO_MANY_TRAVERSALS = 100000;\n+    public static final int TOO_MANY_SCAFFOLDS = 50000;\n+    public static final int MIN_SV_SIZE = 50;\n+\n+    @Argument(fullName=StandardArgumentDefinitions.OUTPUT_LONG_NAME,\n+            shortName=StandardArgumentDefinitions.OUTPUT_SHORT_NAME,\n+            doc=\"Write outputs to this file name prefix\", optional = true)\n+    public static String output;\n+\n+    @Argument(fullName=\"assembly-name\", doc=\"name of assembly used as a prefix for traversal names\")\n+    public static String assemblyName;\n+\n+    private final List<GATKRead> reads = new ArrayList<>();\n+\n+    @Override public boolean requiresIntervals() { return true; }\n+\n+    @Override public void apply( final GATKRead read, final GATKRead mate ) {\n+        trimOverruns(read, mate);\n+        reads.add(read);\n+        reads.add(mate);\n+    }\n+\n+    @Override public void applyUnpaired( final GATKRead read ) {\n+        reads.add(read);\n+    }\n+\n+    @Override public Object onTraversalSuccess() {\n+        super.onTraversalSuccess(); // flush any incomplete pairs\n+\n+        final int regionSize = getTraversalIntervals().stream().mapToInt(SimpleInterval::size).sum();\n+        final KmerSet<KmerAdjacency> kmerAdjacencySet = new KmerSet<>(10 * regionSize);\n+        kmerizeReads(reads, kmerAdjacencySet);\n+        List<ContigImpl> contigs = buildContigs(kmerAdjacencySet);\n+        connectContigs(contigs);\n+\n+        removeThinContigs(contigs, kmerAdjacencySet);\n+        weldPipes(contigs);\n+        markComponents(contigs);\n+\n+        if ( fillGaps(kmerAdjacencySet, reads) ) {\n+            contigs = buildContigs(kmerAdjacencySet);\n+            connectContigs(contigs);\n+            removeThinContigs(contigs, kmerAdjacencySet);\n+            weldPipes(contigs);\n+            markComponents(contigs);\n+        }\n+\n+        markCycles(contigs);\n+\n+        final String outputFilePrefix = output != null ? output : assemblyName;\n+        final List<Path> readPaths = pathReads(kmerAdjacencySet, reads);\n+        final Map<Contig,List<TransitPairCount>> contigTransitsMap =\n+                collectTransitPairCounts(contigs, readPaths);\n+        final String traversalsFilename = outputFilePrefix + \".traversals.fa.gz\";\n+        try {\n+            final List<Traversal> allTraversals =\n+                    new ArrayList<>(traverseAllPaths(contigs, readPaths, contigTransitsMap));\n+            writeTraversals(allTraversals, traversalsFilename);\n+            try {\n+                final String scaffoldsFileName = outputFilePrefix + \".scaffolds.fa.gz\";\n+                writeTraversals(createScaffolds(allTraversals), scaffoldsFileName);\n+            } catch ( final AssemblyTooComplexException x ) {\n+                logger.warn(\"Assembly too complex for scaffolding.\");\n+            }\n+        } catch ( final AssemblyTooComplexException x ) {\n+            logger.warn(\"Assembly too complex.  Writing contigs as traversals in \" +\n+                    traversalsFilename + \".\");\n+            final Collection<Traversal> contigTraversals = new ArrayList<>(contigs.size());\n+            for ( final Contig contig : contigs ) {\n+                contigTraversals.add(new Traversal(Collections.singletonList(contig)));\n+            }\n+            writeTraversals(contigTraversals, traversalsFilename);\n+        }\n+\n+        contigs.sort(Comparator.comparingInt(ContigImpl::getId));\n+        writeDOT(contigs, outputFilePrefix + \".assembly.dot\");\n+        writeContigs(contigs, outputFilePrefix + \".contigs.txt.gz\");\n+        writePaths(readPaths, outputFilePrefix + \".paths.txt.gz\");\n+        writeReads(reads, outputFilePrefix + \".reads.fastq.gz\");\n+        return null;\n+    }\n+\n+    /** trim read pairs of base calls that have gone past the end of a short fragment */\n+    private void trimOverruns( final GATKRead read, final GATKRead mate ) {\n+        // if both mapped and they're on different strands\n+        if ( !read.isUnmapped() && !mate.isUnmapped() &&\n+                read.isReverseStrand() != mate.isReverseStrand() ) {\n+            // and both start within 1 base on the ref\n+            if ( Math.abs(read.getStart() - read.getMateStart()) <= 1 ) {\n+                // and both end within 1 base\n+                final int readRefLen = read.getCigar().getReferenceLength();\n+                final int mateRefLen = mate.getCigar().getReferenceLength();\n+                if ( Math.abs(readRefLen - mateRefLen) <= 1 ) {\n+                    if ( mate.isReverseStrand() ) {\n+                        trimClips(read, mate);\n+                    } else {\n+                        trimClips(mate, read);\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    private void trimClips( final GATKRead fwd, final GATKRead rev ) {\n+        final List<CigarElement> fwdElements = fwd.getCigarElements();\n+        final List<CigarElement> revElements = rev.getCigarElements();\n+        final int lastElementIdx = fwdElements.size() - 1;\n+        final CigarElement fwdLastElement = fwdElements.get(lastElementIdx);\n+        final CigarElement revFirstElement = revElements.get(0);\n+        if ( fwdLastElement.getOperator() == CigarOperator.S &&\n+                revFirstElement.getOperator() == CigarOperator.S ) {\n+            final byte[] fwdBases = fwd.getBasesNoCopy();\n+            final int lastElementLen = fwdLastElement.getLength();\n+            fwd.setBases(Arrays.copyOfRange(fwdBases, 0, fwdBases.length - lastElementLen));\n+            final byte[] fwdQuals = fwd.getBaseQualitiesNoCopy();\n+            if ( fwdQuals.length > 0 ) {\n+                final int qualsLen = fwdQuals.length - lastElementLen;\n+                fwd.setBaseQualities(Arrays.copyOfRange(fwdQuals, 0, qualsLen));\n+            }\n+            final List<CigarElement> newFwdElements = new ArrayList<>(fwdElements);\n+            newFwdElements.set(lastElementIdx, new CigarElement(lastElementLen, CigarOperator.H));\n+            fwd.setCigar(new Cigar(newFwdElements));\n+\n+            final byte[] revBases = rev.getBasesNoCopy();\n+            final int firstElementLen = revFirstElement.getLength();\n+            rev.setBases(Arrays.copyOfRange(revBases, firstElementLen, revBases.length));\n+            final byte[] revQuals = rev.getBaseQualitiesNoCopy();\n+            if ( revQuals.length > 0 ) {\n+                rev.setBaseQualities(Arrays.copyOfRange(revQuals, firstElementLen, revQuals.length));\n+            }\n+            final List<CigarElement> newRevElements = new ArrayList<>(revElements);\n+            newRevElements.set(0, new CigarElement(firstElementLen, CigarOperator.H));\n+            rev.setCigar(new Cigar(newRevElements));\n+        }\n+    }\n+\n+    @VisibleForTesting\n+    static void kmerizeReads( final List<GATKRead> reads,\n+                              final KmerSet<KmerAdjacency> kmerAdjacencySet ) {\n+        for ( final GATKRead read : reads ) {\n+            final byte[] calls = read.getBasesNoCopy();\n+            final byte[] quals = read.getBaseQualitiesNoCopy();\n+            KmerAdjacency.kmerize(calls, quals, QMIN, kmerAdjacencySet);\n+        }\n+    }\n+\n+    /** gather unbranched strings of kmers into contigs **/\n+    @VisibleForTesting\n+    static List<ContigImpl> buildContigs( final KmerSet<KmerAdjacency> kmerAdjacencySet ) {\n+        // gather strings of kmers that have a single predecessor and single successor into contigs\n+        final List<ContigImpl> contigs = new ArrayList<>();\n+        int nContigs = 0;\n+        for ( final KmerAdjacency kmerAdjacency : kmerAdjacencySet ) {\n+            if ( kmerAdjacency.getContig() == null ) {\n+                ContigImpl contig = null;\n+                final KmerAdjacency predecessor = kmerAdjacency.getSolePredecessor();\n+                if ( predecessor == null ||\n+                        predecessor.getSuccessorCount() > 1 ||\n+                        predecessor == kmerAdjacency.rc() ) {\n+                    contig = new ContigImpl(++nContigs, kmerAdjacency);\n+                } else {\n+                    final KmerAdjacency successor = kmerAdjacency.getSoleSuccessor();\n+                    if ( successor == null ||\n+                            successor.getPredecessorCount() > 1 ||\n+                            successor == kmerAdjacency.rc() ) {\n+                        contig = new ContigImpl(++nContigs, kmerAdjacency.rc());\n+                    }\n+                }\n+                if ( contig != null ) {\n+                    contigs.add(contig);\n+                }\n+            }\n+        }\n+\n+        // if there are smooth circles like a plasmid, gather them together as a contig, too\n+        for ( final KmerAdjacency kmerAdjacency : kmerAdjacencySet ) {\n+            if ( kmerAdjacency.getContig() == null ) {\n+                contigs.add(new ContigImpl(++nContigs, kmerAdjacency));\n+            }\n+        }\n+\n+        return contigs;\n+    }\n+\n+    /** connect contigs when the final kmer of one contig is adjacent to the inital contig of another **/\n+    @VisibleForTesting\n+    static void connectContigs( final List<ContigImpl> contigs ) {\n+        final int nContigs = contigs.size();\n+        final KmerSet<ContigEndKmer> contigEnds = new KmerSet<>(2*nContigs);\n+        for ( int contigId = 0; contigId != nContigs; ++contigId ) {\n+            final ContigImpl contig = contigs.get(contigId);\n+            final KmerAdjacency fwdKmer = contig.getFirstKmer();\n+            final KmerAdjacency revKmer = contig.getLastKmer().rc();\n+            if ( fwdKmer == revKmer ) {\n+                contigEnds.add(new ContigEndKmer(fwdKmer.getKVal(), contig, ContigOrientation.BOTH));\n+            } else {\n+                contigEnds.add(new ContigEndKmer(fwdKmer.getKVal(), contig, ContigOrientation.FWD));\n+                contigEnds.add(new ContigEndKmer(revKmer.getKVal(), contig, ContigOrientation.REV));\n+            }\n+        }\n+\n+        for ( int contigId = 0; contigId != nContigs; ++contigId ) {\n+            final Contig contig = contigs.get(contigId);\n+\n+            final KmerAdjacency start = contig.getFirstKmer();\n+            final int predecessorCount = start.getPredecessorCount();\n+            if ( predecessorCount > 0 ) {\n+                final List<Contig> predecessors = contig.getPredecessors();\n+                final int mask = start.getPredecessorMask();\n+                for ( int call = 0; call != 4; ++call ) {\n+                    if ( (mask & (1 << call)) != 0 ) {\n+                        final long kVal =\n+                                KmerAdjacency.reverseComplement(start.getPredecessorVal(call));\n+                        final ContigEndKmer contigEndKmer = contigEnds.find(new Kmer(kVal));\n+                        if ( contigEndKmer == null ) {\n+                            throw new GATKException(\"missing contig end kmer\");\n+                        }\n+                        switch ( contigEndKmer.getContigOrientation() ) {\n+                            case FWD:\n+                                predecessors.add(contigEndKmer.getContig().rc());\n+                                break;\n+                            case REV:\n+                                predecessors.add(contigEndKmer.getContig());\n+                                break;\n+                            case BOTH:\n+                                predecessors.add(contigEndKmer.getContig());\n+                                predecessors.add(contigEndKmer.getContig().rc());\n+                                break;\n+                        }\n+                    }\n+                }\n+            }\n+\n+            final KmerAdjacency end = contig.getLastKmer();\n+            final int successorCount = end.getSuccessorCount();\n+            if ( successorCount > 0 ) {\n+                final List<Contig> successors = contig.getSuccessors();\n+                final int mask = end.getSuccessorMask();\n+                for ( int call = 0; call != 4; ++call ) {\n+                    if ( (mask & (1 << call)) != 0 ) {\n+                        final long kVal = end.getSuccessorVal(call);\n+                        final ContigEndKmer contigEndKmer = contigEnds.find(new Kmer(kVal));\n+                        if ( contigEndKmer == null ) {\n+                            throw new GATKException(\"missing contig end kmer\");\n+                        }\n+                        switch ( contigEndKmer.getContigOrientation() ) {\n+                            case FWD:\n+                                successors.add(contigEndKmer.getContig());\n+                                break;\n+                            case REV:\n+                                successors.add(contigEndKmer.getContig().rc());\n+                                break;\n+                            case BOTH:\n+                                successors.add(contigEndKmer.getContig());\n+                                successors.add(contigEndKmer.getContig().rc());\n+                                break;\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    /** remove contigs that have little evidence **/\n+    @VisibleForTesting\n+    static void removeThinContigs( final List<ContigImpl> contigs,\n+                                           final KmerSet<KmerAdjacency> kmerAdjacencySet ) {\n+        contigs.sort(Comparator.comparingInt(ContigImpl::getMaxObservations));\n+        boolean contigRemoved;\n+        do {\n+            // figure out which contigs are cut points\n+            // i.e., those contigs which, if removed, would result in a graph with more connected components\n+            final int nContigs = contigs.size();\n+            final Map<Contig, CutData> cutDataMap = new HashMap<>(nContigs * 3);\n+\n+            for ( final ContigImpl contig : contigs ) {\n+                if ( cutDataMap.containsKey(contig) ) {\n+                    continue;\n+                }\n+\n+                cutDataMap.put(contig, new CutData());\n+                int children = 0;\n+                for ( final Contig nextContig : contig.getSuccessors() ) {\n+                    if ( !cutDataMap.containsKey(nextContig) ) {\n+                        findCuts(nextContig, contig, cutDataMap);\n+                        children += 1;\n+                    }\n+                }\n+                for ( final Contig nextContig : contig.getPredecessors() ) {\n+                    if ( !cutDataMap.containsKey(nextContig) ) {\n+                        findCuts(nextContig, contig, cutDataMap);\n+                        children += 1;\n+                    }\n+                }\n+                if ( children >= 2 ) {\n+                    contig.setCut(true);\n+                }\n+            }\n+\n+            // remove poorly attested (low max observations) contigs, unless they are cut points\n+            contigRemoved = false;\n+            final Iterator<ContigImpl> itr = contigs.iterator();\n+            while ( itr.hasNext() ) {\n+                final Contig contig = itr.next();\n+                if ( contig.getMaxObservations() < MIN_THIN_OBS && !contig.isCut() ) {\n+                    unlinkContig(contig, kmerAdjacencySet);\n+                    itr.remove();\n+                    contigRemoved = true;\n+                    break;\n+                }\n+            }\n+        } while ( contigRemoved );\n+        contigs.sort(Comparator.comparingInt(ContigImpl::getId));\n+    }\n+\n+    private static CutData findCuts( final Contig contig,\n+                                     final Contig parent,\n+                                     final Map<Contig, CutData> cutDataMap ) {\n+        final CutData cutData = new CutData();\n+        cutDataMap.put(contig, cutData);\n+        for ( final Contig nextContig : contig.getSuccessors() ) {\n+            if ( nextContig == parent ) {\n+                continue;\n+            }\n+            CutData nextCutData = cutDataMap.get(nextContig);\n+            if ( nextCutData != null ) {\n+                cutData.minVisitNum = Math.min(cutData.minVisitNum, nextCutData.visitNum);\n+            } else {\n+                nextCutData = findCuts(nextContig, contig, cutDataMap);\n+                cutData.minVisitNum = Math.min(cutData.minVisitNum, nextCutData.minVisitNum);\n+                if ( nextCutData.minVisitNum >= cutData.visitNum ) {\n+                    contig.setCut(true);\n+                }\n+            }\n+        }\n+        for ( final Contig nextContig : contig.getPredecessors() ) {\n+            if ( nextContig == parent ) {\n+                continue;\n+            }\n+            CutData nextCutData = cutDataMap.get(nextContig);\n+            if ( nextCutData != null ) {\n+                cutData.minVisitNum = Math.min(cutData.minVisitNum, nextCutData.visitNum);\n+            } else {\n+                nextCutData = findCuts(nextContig, contig, cutDataMap);\n+                cutData.minVisitNum = Math.min(cutData.minVisitNum, nextCutData.minVisitNum);\n+                if ( nextCutData.minVisitNum >= cutData.visitNum ) {\n+                    contig.setCut(true);\n+                }\n+            }\n+        }\n+        return cutData;\n+    }\n+\n+    @VisibleForTesting\n+    static void unlinkContig( final Contig contig,\n+                                      final KmerSet<KmerAdjacency> kmerAdjacencySet ) {\n+        final KmerAdjacency firstKmer = contig.getFirstKmer();\n+        final int firstKmerFinalCall = firstKmer.getFinalCall();\n+        for ( final Contig predecessor : contig.getPredecessors() ) {\n+            if ( predecessor != contig && predecessor != contig.rc() ) {\n+                predecessor.getLastKmer().removeSuccessor(firstKmerFinalCall, kmerAdjacencySet);\n+                if ( !predecessor.getSuccessors().remove(contig) ) {\n+                    throw new GATKException(\"failed to find predecessor link\");\n+                }\n+            }\n+        }\n+\n+        final KmerAdjacency lastKmer = contig.getLastKmer();\n+        final int lastKmerInitialCall = lastKmer.getInitialCall();\n+        for ( final Contig successor : contig.getSuccessors() ) {\n+            if ( successor != contig && successor != contig.rc() ) {\n+                successor.getFirstKmer().removePredecessor(lastKmerInitialCall, kmerAdjacencySet);\n+                if ( !successor.getPredecessors().remove(contig) ) {\n+                    throw new GATKException(\"failed to find successor link\");\n+                }\n+            }\n+        }\n+\n+        KmerAdjacency nextKmer = firstKmer;\n+        KmerAdjacency kmer;\n+        do {\n+            kmer = nextKmer;\n+            nextKmer = kmer.getSoleSuccessor();\n+            kmerAdjacencySet.remove(kmer.canonical());\n+        } while ( kmer != lastKmer );\n+    }\n+\n+    private static void updateKmerContig( final KmerAdjacency firstKmer,\n+                                          final KmerAdjacency lastKmer,\n+                                          final Contig contig ) {\n+        int offset = 0;\n+        for ( KmerAdjacency kmer = firstKmer; kmer != lastKmer; kmer = kmer.getSoleSuccessor() ) {\n+            if ( kmer == null ) {\n+                throw new GATKException(\"contig does not have a flat pipeline of kmers\");\n+            }\n+            kmer.clearContig();\n+            kmer.setContigOffset(contig, offset++);\n+        }\n+        lastKmer.clearContig();\n+        lastKmer.setContigOffset(contig, offset);\n+        if ( offset + Kmer.KSIZE != contig.size() ) {\n+            throw new GATKException(\"kmer chain length does not equal contig size\");\n+        }\n+    }\n+\n+    /** replace adjacent contigs without branches with a single, larger contig **/\n+    @VisibleForTesting\n+    static void weldPipes( final List<ContigImpl> contigs ) {\n+        for ( int contigIdx = 0; contigIdx != contigs.size(); ++contigIdx ) {\n+            final ContigImpl contig = contigs.get(contigIdx);\n+            if ( contig.getSuccessors().size() == 1 ) {\n+                final Contig successor = contig.getSuccessors().get(0);\n+                if ( successor != contig && successor != contig.rc() &&\n+                        successor.getPredecessors().size() == 1 ) {\n+                    contigs.set(contigIdx, join(contig.getId(), contig, successor));\n+                    if ( !contigs.remove(successor.canonical()) ) {\n+                        throw new GATKException(\"successor linkage is messed up\");\n+                    }\n+                    contigIdx -= 1; // reconsider the new contig -- there might be more joining possible\n+                    continue;\n+                }\n+            }\n+            if ( contig.getPredecessors().size() == 1 ) {\n+                final Contig predecessor = contig.getPredecessors().get(0);\n+                if ( predecessor != contig && predecessor != contig.rc() &&\n+                        predecessor.getSuccessors().size() == 1 ) {\n+                    contigs.set(contigIdx, join(contig.getId(), predecessor, contig));\n+                    if ( !contigs.remove(predecessor.canonical()) ) {\n+                        throw new GATKException(\"predecessor linkage is messed up\");\n+                    }\n+                    contigIdx -= 1; // reconsider\n+                }\n+            }\n+        }\n+    }\n+\n+    private static ContigImpl join( final int id, final Contig predecessor, final Contig successor ) {\n+        if ( !checkOverlap(predecessor.getSequence(), successor.getSequence()) ) {\n+                throw new GATKException(\"sequences can't be joined\");\n+        }\n+        final ContigImpl joinedContig = new ContigImpl(id, predecessor, successor);\n+        updateKmerContig(joinedContig.getFirstKmer(), joinedContig.getLastKmer(), joinedContig);\n+        return joinedContig;\n+    }\n+\n+    private static boolean checkOverlap( final CharSequence seq1, final CharSequence seq2 ) {\n+        final int seq1Len = seq1.length();\n+        final CharSequence seq1SubSeq = seq1.subSequence(seq1Len - Kmer.KSIZE + 1, seq1Len);\n+        final CharSequence seq2SubSeq = seq2.subSequence(0, Kmer.KSIZE - 1);\n+        return seq1SubSeq.equals(seq2SubSeq);\n+    }\n+\n+    /** set a unique componentId for every connected group of contigs **/\n+    @VisibleForTesting\n+    static int markComponents( final List<ContigImpl> contigs ) {\n+        for ( final ContigImpl contig : contigs ) {\n+            contig.setComponentId(0);\n+        }\n+\n+        int componentId = 0;\n+        for ( final ContigImpl contig : contigs ) {\n+            if ( contig.getComponentId() == 0 ) {\n+                contig.setComponentId(++componentId);\n+                markSuccessorComponents(contig);\n+                markSuccessorComponents(contig.rc());\n+            }\n+        }\n+        return componentId;\n+    }\n+\n+    private static void markSuccessorComponents( final Contig contig ) {\n+        final int componentId = contig.getComponentId();\n+        for ( final Contig successor : contig.getSuccessors() ) {\n+            if ( successor.getComponentId() == 0 ) {\n+                successor.canonical().setComponentId(componentId);\n+                markSuccessorComponents(successor);\n+                markSuccessorComponents(successor.rc());\n+            }\n+        }\n+    }\n+\n+    @VisibleForTesting\n+    static void markCycles( final List<ContigImpl> contigs ) {\n+        for ( final Contig contig : contigs ) {\n+            contig.setCyclic(false);\n+        }\n+\n+        final int nContigs = contigs.size();\n+        final Deque<Contig> deque = new ArrayDeque<>(nContigs);\n+        final Map<Contig, CutData> cutDataMap = new HashMap<>(nContigs * 3);\n+        for ( final Contig contig : contigs ) {\n+            if ( !cutDataMap.containsKey(contig) ) {\n+                markCyclesRecursion(contig, deque, cutDataMap);\n+            }\n+        }\n+    }\n+\n+    private static CutData markCyclesRecursion( final Contig contig,\n+                                                final Deque<Contig> deque,\n+                                                final Map<Contig, CutData> cutDataMap ) {\n+        final CutData cutData = new CutData();\n+        cutDataMap.put(contig, cutData);\n+        deque.addFirst(contig);\n+\n+        for ( final Contig successor : contig.getSuccessors() ) {\n+            final CutData successorCutData = cutDataMap.get(successor);\n+            if ( successorCutData == null ) {\n+                final int recursionVisitNum =\n+                        markCyclesRecursion(successor, deque, cutDataMap).minVisitNum;\n+                cutData.minVisitNum = Math.min(cutData.minVisitNum, recursionVisitNum);\n+            } else {\n+                cutData.minVisitNum = Math.min(cutData.minVisitNum, successorCutData.visitNum);\n+            }\n+        }\n+\n+        if ( cutData.visitNum == cutData.minVisitNum ) {\n+            Contig tig = deque.removeFirst();\n+            if ( tig == contig ) {\n+                cutDataMap.get(tig).visitNum = Integer.MAX_VALUE;\n+\n+                // single-vertex component -- cyclic only if self-referential\n+                if ( tig.getSuccessors().contains(tig) ) {\n+                    tig.setCyclic(true);\n+                }\n+            } else {\n+                while ( true ) {\n+                    // kill cross-links\n+                    cutDataMap.get(tig).visitNum = Integer.MAX_VALUE;\n+                    tig.setCyclic(true);\n+                    if ( tig == contig ) break;\n+                    tig = deque.removeFirst();\n+                }\n+            }\n+        }\n+        return cutData;\n+    }\n+\n+    @VisibleForTesting\n+    static boolean fillGaps( final KmerSet<KmerAdjacency> kmerAdjacencySet,\n+                             final List<GATKRead> reads ) {\n+        final Map<String, Integer> gapFillCounts = new HashMap<>();\n+        for ( final GATKRead read : reads ) {\n+            final Path path = new Path(read.getBasesNoCopy(), kmerAdjacencySet);\n+            final List<PathPart> parts = path.getParts();\n+            final int lastIdx = parts.size() - 1;\n+            for ( int idx = 1; idx < lastIdx; ++idx ) {\n+                final PathPart pathPart = parts.get(idx);\n+                if ( pathPart.isGap() ) {\n+                    final char prevCall = parts.get(idx - 1).getLastCall();\n+                    final char nextCall = parts.get(idx + 1).getFirstCall();\n+                    String gapFill = prevCall + pathPart.getSequence().toString() + nextCall;\n+                    final SequenceRC gapFillRC = new SequenceRC(gapFill);\n+                    if ( gapFillRC.compareTo(gapFill) < 0 ) {\n+                        gapFill = gapFillRC.toString();\n+                    }\n+                    gapFillCounts.merge(gapFill, 1, Integer::sum);\n+                }\n+            }\n+        }\n+\n+        boolean newKmers = false;\n+        for ( final Map.Entry<String, Integer> entry : gapFillCounts.entrySet() ) {\n+            final int nObservations = entry.getValue();\n+            if ( nObservations >= MIN_GAPFILL_COUNT ) {\n+                KmerAdjacency.kmerize(entry.getKey(), nObservations, kmerAdjacencySet);\n+                newKmers = true;\n+            }\n+        }\n+\n+        if ( newKmers ) {\n+            for ( final KmerAdjacency kmerAdjacency : kmerAdjacencySet ) {\n+                kmerAdjacency.clearContig();\n+            }\n+        }\n+        return newKmers;\n+    }\n+\n+    @VisibleForTesting\n+    static List<Path> pathReads( final KmerSet<KmerAdjacency> kmerAdjacencySet,\n+                          final List<GATKRead> reads ) {\n+        final List<Path> readPaths = new ArrayList<>(reads.size());\n+        for ( final GATKRead read : reads ) {\n+            readPaths.add(new Path(read.getBasesNoCopy(), kmerAdjacencySet));\n+        }\n+        return readPaths;\n+    }\n+\n+    @VisibleForTesting\n+    static Map<Contig,List<TransitPairCount>> collectTransitPairCounts(\n+            final List<ContigImpl> contigs,\n+            final List<Path> readPaths ) {\n+        final Map<Contig,List<TransitPairCount>> contigTransitsMap =\n+                new HashMap<>(3 * contigs.size());\n+        for ( final Path path : readPaths ) {\n+            final List<PathPart> parts = path.getParts();\n+            final int lastPart = parts.size() - 1;\n+            for ( int partIdx = 1; partIdx < lastPart; ++partIdx ) {\n+                final Contig prevContig = parts.get(partIdx - 1).getContig();\n+                if ( prevContig == null ) continue;\n+                final Contig curContig = parts.get(partIdx).getContig();\n+                if ( curContig == null ) {\n+                    partIdx += 1;\n+                    continue;\n+                }\n+                final Contig nextContig = parts.get(partIdx + 1).getContig();\n+                if ( nextContig == null ) {\n+                    partIdx += 2;\n+                    continue;\n+                }\n+                final TransitPairCount tpc = new TransitPairCount(prevContig, nextContig);\n+                final List<TransitPairCount> tpcList =\n+                        contigTransitsMap.computeIfAbsent(curContig, tig -> new ArrayList<>(4));\n+                final int idx = tpcList.indexOf(tpc);\n+                if ( idx != -1 ) {\n+                    tpcList.get(idx).observe();\n+                } else {\n+                    tpcList.add(tpc);\n+                    contigTransitsMap.computeIfAbsent(curContig.rc(), tig -> new ArrayList<>(4))\n+                            .add(tpc.getRC());\n+                }\n+            }\n+        }\n+        return contigTransitsMap;\n+    }\n+\n+    @VisibleForTesting\n+    static Set<Traversal> traverseAllPaths(\n+            final List<ContigImpl> contigs,\n+            final List<Path> readPaths,\n+            final Map<Contig, List<TransitPairCount>> contigTransitsMap ) {\n+        final Set<Traversal> traversalSet = new HashSet<>();\n+        final List<Contig> contigsList = new ArrayList<>();\n+        for ( final Contig contig : contigs ) {\n+            // untransited contigs are sources, sinks, or large contigs that can't be crossed by a read\n+            // build traversals from these\n+            if ( !contigTransitsMap.containsKey(contig) ) {\n+                boolean done = false;\n+                for ( final Contig successor : contig.getSuccessors() ) {\n+                    traverse(successor, contig,\n+                            contigsList, readPaths, contigTransitsMap, traversalSet);\n+                    done = true;\n+                }\n+                for ( final Contig predecessor : contig.getPredecessors() ) {\n+                    traverse(predecessor.rc(), contig.rc(),\n+                            contigsList, readPaths, contigTransitsMap, traversalSet);\n+                    done = true;\n+                }\n+                if ( !done ) { // if there were no predecessors or successors, it stands alone\n+                    addTraversal(new Traversal(Collections.singletonList(contig)), traversalSet);\n+                }\n+            }\n+        }\n+\n+        // look for transits that haven't been traced\n+        for ( final Map.Entry<Contig, List<TransitPairCount>> entry :\n+                contigTransitsMap.entrySet() ) {\n+            for ( final TransitPairCount tpc : entry.getValue() ) {\n+                if ( tpc.getCount() > 0 ) {\n+                    tpc.resetCount();\n+                    final Contig contig = entry.getKey();\n+                    final Set<Traversal> fwdTraversalSet = new HashSet<>();\n+                    traverse(tpc.getNextContig(), contig,\n+                            contigsList, readPaths, contigTransitsMap, fwdTraversalSet);\n+                    final Set<Traversal> revTraversalSet = new HashSet<>();\n+                    traverse(tpc.getPrevContig().rc(), contig.rc(),\n+                            contigsList, readPaths, contigTransitsMap, revTraversalSet);\n+                    for ( final Traversal revTraversal : revTraversalSet ) {\n+                        final Traversal revTraversalRC = revTraversal.rc();\n+                        for ( final Traversal fwdTraversal : fwdTraversalSet ) {\n+                            final int overlap =\n+                                    findMaxOverlap(revTraversalRC.getContigs(), fwdTraversal.getContigs());\n+                            final Traversal combo =\n+                                    Traversal.combineOverlappers(revTraversalRC, fwdTraversal, overlap);\n+                            addTraversal(combo, traversalSet);\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+\n+        return traversalSet;\n+    }\n+\n+    private static int findMaxOverlap( final List<Contig> prefixes, final List<Contig> suffixes ) {\n+        final int nPrefixes = prefixes.size();\n+        final Contig firstSuffix = suffixes.get(0);\n+        if ( !firstSuffix.isCyclic() ) {\n+            return prefixes.get(nPrefixes - 1) == firstSuffix ? 1 : 0;\n+        }\n+        final int nSuffixes = suffixes.size();\n+        for ( int prefixIdx = Math.max(0, nPrefixes - nSuffixes); prefixIdx != nPrefixes; ++prefixIdx ) {\n+            if ( prefixes.get(prefixIdx) == firstSuffix ) {\n+                int suffixIdx = 1;\n+                boolean match = true;\n+                for ( int prefixIdx2 = prefixIdx + 1; prefixIdx2 != nPrefixes; ++prefixIdx2 ) {\n+                    if ( prefixes.get(prefixIdx2) != suffixes.get(suffixIdx++) ) {\n+                        match = false;\n+                        break;\n+                    }\n+                }\n+                if ( match ) {\n+                    return nPrefixes - prefixIdx;\n+                }\n+            }\n+        }\n+        return 0;\n+    }\n+\n+    private static void traverse( final Contig contig,\n+                                  final Contig predecessor,\n+                                  final List<Contig> contigsList,\n+                                  final List<Path> readPaths,\n+                                  final Map<Contig, List<TransitPairCount>> contigTransitsMap,\n+                                  final Set<Traversal> traversalSet ) {\n+        contigsList.add(predecessor);\n+        if ( contig.isCyclic() ) {\n+            traverseCycle(contig, contigsList, readPaths, contigTransitsMap, traversalSet);\n+            contigsList.remove(contigsList.size() - 1);\n+            return;\n+        }\n+        final List<TransitPairCount> transits = contigTransitsMap.get(contig);\n+        boolean done = false;\n+        if ( transits != null ) {\n+            for ( final TransitPairCount tpc : transits ) {\n+                if ( tpc.getPrevContig() == predecessor ) {\n+                    final Contig successor = tpc.getNextContig();\n+                    if ( predecessor == contig.rc() ) {\n+                        final int nContigs = contigsList.size();\n+                        if ( nContigs > 1 ) {\n+                            if ( successor.rc() == contigsList.get(nContigs - 2) ) {\n+                                continue;\n+                            }\n+                        }\n+                    }\n+                    tpc.resetCount();\n+                    traverse(successor, contig, contigsList, readPaths, contigTransitsMap, traversalSet);\n+                    done = true;\n+                }\n+            }\n+        }\n+        if ( !done ) {\n+            contigsList.add(contig);\n+            addTraversal(new Traversal(contigsList), traversalSet);\n+            contigsList.remove(contigsList.size() - 1);\n+        }\n+        contigsList.remove(contigsList.size() - 1);\n+    }\n+\n+    private static void traverseCycle( final Contig contig,\n+                                       final List<Contig> contigsList,\n+                                       final List<Path> readPaths,\n+                                       final Map<Contig, List<TransitPairCount>> contigTransitsMap,\n+                                       final Set<Traversal> traversalSet ) {\n+        contigsList.add(contig);\n+        final int nContigs = contigsList.size();\n+        // the final element of the list is cyclic, if there's a previous element it will be\n+        // non-cyclic, so start there figuring out how far the read paths lead us", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5NzgzNjY1Mg=="}, "originalCommit": {"oid": "e2201c1ef4f8ba71f17e169f07756cfe2f1ecb49"}, "originalPosition": 796}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzc3NjYxMDk5OnYy", "diffSide": "RIGHT", "path": "src/main/java/org/broadinstitute/hellbender/tools/LocalAssembler.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMy0xOVQxODoyNjoxMFrOI6MecQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNC0yM1QxNjozNzo0OVrOJOqfyg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5Nzg5MjcyMQ==", "bodyText": "Why do this? Are we guaranteed that both the RC and non-RC versions of the traversal are in the set?", "url": "https://github.com/broadinstitute/gatk/pull/6989#discussion_r597892721", "createdAt": "2021-03-19T18:26:10Z", "author": {"login": "cwhelan"}, "path": "src/main/java/org/broadinstitute/hellbender/tools/LocalAssembler.java", "diffHunk": "@@ -0,0 +1,2306 @@\n+package org.broadinstitute.hellbender.tools;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import htsjdk.samtools.Cigar;\n+import htsjdk.samtools.CigarElement;\n+import htsjdk.samtools.CigarOperator;\n+import htsjdk.samtools.SAMUtils;\n+import org.broadinstitute.barclay.argparser.Argument;\n+import org.broadinstitute.barclay.argparser.BetaFeature;\n+import org.broadinstitute.barclay.argparser.CommandLineProgramProperties;\n+import org.broadinstitute.barclay.help.DocumentedFeature;\n+import org.broadinstitute.hellbender.cmdline.StandardArgumentDefinitions;\n+import org.broadinstitute.hellbender.cmdline.programgroups.CoverageAnalysisProgramGroup;\n+import org.broadinstitute.hellbender.exceptions.GATKException;\n+import org.broadinstitute.hellbender.tools.walkers.PairWalker;\n+import org.broadinstitute.hellbender.utils.SimpleInterval;\n+import org.broadinstitute.hellbender.utils.collections.HopscotchSet;\n+import org.broadinstitute.hellbender.utils.gcs.BucketUtils;\n+import org.broadinstitute.hellbender.utils.read.GATKRead;\n+\n+import java.io.BufferedWriter;\n+import java.io.FileWriter;\n+import java.io.IOException;\n+import java.io.OutputStreamWriter;\n+import java.util.*;\n+import java.util.zip.GZIPOutputStream;\n+\n+@DocumentedFeature\n+@CommandLineProgramProperties(\n+        summary = \"experiment\",\n+        oneLineSummary = \"experiment\",\n+        usageExample = \"gatk LocalAssembler\",\n+        programGroup = CoverageAnalysisProgramGroup.class\n+)\n+@BetaFeature\n+public class LocalAssembler extends PairWalker {\n+    public static final byte QMIN = 25;\n+    public static final int MIN_THIN_OBS = 4;\n+    public static final int MIN_GAPFILL_COUNT = 3;\n+    public static final int TOO_MANY_TRAVERSALS = 100000;\n+    public static final int TOO_MANY_SCAFFOLDS = 50000;\n+    public static final int MIN_SV_SIZE = 50;\n+\n+    @Argument(fullName=StandardArgumentDefinitions.OUTPUT_LONG_NAME,\n+            shortName=StandardArgumentDefinitions.OUTPUT_SHORT_NAME,\n+            doc=\"Write outputs to this file name prefix\", optional = true)\n+    public static String output;\n+\n+    @Argument(fullName=\"assembly-name\", doc=\"name of assembly used as a prefix for traversal names\")\n+    public static String assemblyName;\n+\n+    private final List<GATKRead> reads = new ArrayList<>();\n+\n+    @Override public boolean requiresIntervals() { return true; }\n+\n+    @Override public void apply( final GATKRead read, final GATKRead mate ) {\n+        trimOverruns(read, mate);\n+        reads.add(read);\n+        reads.add(mate);\n+    }\n+\n+    @Override public void applyUnpaired( final GATKRead read ) {\n+        reads.add(read);\n+    }\n+\n+    @Override public Object onTraversalSuccess() {\n+        super.onTraversalSuccess(); // flush any incomplete pairs\n+\n+        final int regionSize = getTraversalIntervals().stream().mapToInt(SimpleInterval::size).sum();\n+        final KmerSet<KmerAdjacency> kmerAdjacencySet = new KmerSet<>(10 * regionSize);\n+        kmerizeReads(reads, kmerAdjacencySet);\n+        List<ContigImpl> contigs = buildContigs(kmerAdjacencySet);\n+        connectContigs(contigs);\n+\n+        removeThinContigs(contigs, kmerAdjacencySet);\n+        weldPipes(contigs);\n+        markComponents(contigs);\n+\n+        if ( fillGaps(kmerAdjacencySet, reads) ) {\n+            contigs = buildContigs(kmerAdjacencySet);\n+            connectContigs(contigs);\n+            removeThinContigs(contigs, kmerAdjacencySet);\n+            weldPipes(contigs);\n+            markComponents(contigs);\n+        }\n+\n+        markCycles(contigs);\n+\n+        final String outputFilePrefix = output != null ? output : assemblyName;\n+        final List<Path> readPaths = pathReads(kmerAdjacencySet, reads);\n+        final Map<Contig,List<TransitPairCount>> contigTransitsMap =\n+                collectTransitPairCounts(contigs, readPaths);\n+        final String traversalsFilename = outputFilePrefix + \".traversals.fa.gz\";\n+        try {\n+            final List<Traversal> allTraversals =\n+                    new ArrayList<>(traverseAllPaths(contigs, readPaths, contigTransitsMap));\n+            writeTraversals(allTraversals, traversalsFilename);\n+            try {\n+                final String scaffoldsFileName = outputFilePrefix + \".scaffolds.fa.gz\";\n+                writeTraversals(createScaffolds(allTraversals), scaffoldsFileName);\n+            } catch ( final AssemblyTooComplexException x ) {\n+                logger.warn(\"Assembly too complex for scaffolding.\");\n+            }\n+        } catch ( final AssemblyTooComplexException x ) {\n+            logger.warn(\"Assembly too complex.  Writing contigs as traversals in \" +\n+                    traversalsFilename + \".\");\n+            final Collection<Traversal> contigTraversals = new ArrayList<>(contigs.size());\n+            for ( final Contig contig : contigs ) {\n+                contigTraversals.add(new Traversal(Collections.singletonList(contig)));\n+            }\n+            writeTraversals(contigTraversals, traversalsFilename);\n+        }\n+\n+        contigs.sort(Comparator.comparingInt(ContigImpl::getId));\n+        writeDOT(contigs, outputFilePrefix + \".assembly.dot\");\n+        writeContigs(contigs, outputFilePrefix + \".contigs.txt.gz\");\n+        writePaths(readPaths, outputFilePrefix + \".paths.txt.gz\");\n+        writeReads(reads, outputFilePrefix + \".reads.fastq.gz\");\n+        return null;\n+    }\n+\n+    /** trim read pairs of base calls that have gone past the end of a short fragment */\n+    private void trimOverruns( final GATKRead read, final GATKRead mate ) {\n+        // if both mapped and they're on different strands\n+        if ( !read.isUnmapped() && !mate.isUnmapped() &&\n+                read.isReverseStrand() != mate.isReverseStrand() ) {\n+            // and both start within 1 base on the ref\n+            if ( Math.abs(read.getStart() - read.getMateStart()) <= 1 ) {\n+                // and both end within 1 base\n+                final int readRefLen = read.getCigar().getReferenceLength();\n+                final int mateRefLen = mate.getCigar().getReferenceLength();\n+                if ( Math.abs(readRefLen - mateRefLen) <= 1 ) {\n+                    if ( mate.isReverseStrand() ) {\n+                        trimClips(read, mate);\n+                    } else {\n+                        trimClips(mate, read);\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    private void trimClips( final GATKRead fwd, final GATKRead rev ) {\n+        final List<CigarElement> fwdElements = fwd.getCigarElements();\n+        final List<CigarElement> revElements = rev.getCigarElements();\n+        final int lastElementIdx = fwdElements.size() - 1;\n+        final CigarElement fwdLastElement = fwdElements.get(lastElementIdx);\n+        final CigarElement revFirstElement = revElements.get(0);\n+        if ( fwdLastElement.getOperator() == CigarOperator.S &&\n+                revFirstElement.getOperator() == CigarOperator.S ) {\n+            final byte[] fwdBases = fwd.getBasesNoCopy();\n+            final int lastElementLen = fwdLastElement.getLength();\n+            fwd.setBases(Arrays.copyOfRange(fwdBases, 0, fwdBases.length - lastElementLen));\n+            final byte[] fwdQuals = fwd.getBaseQualitiesNoCopy();\n+            if ( fwdQuals.length > 0 ) {\n+                final int qualsLen = fwdQuals.length - lastElementLen;\n+                fwd.setBaseQualities(Arrays.copyOfRange(fwdQuals, 0, qualsLen));\n+            }\n+            final List<CigarElement> newFwdElements = new ArrayList<>(fwdElements);\n+            newFwdElements.set(lastElementIdx, new CigarElement(lastElementLen, CigarOperator.H));\n+            fwd.setCigar(new Cigar(newFwdElements));\n+\n+            final byte[] revBases = rev.getBasesNoCopy();\n+            final int firstElementLen = revFirstElement.getLength();\n+            rev.setBases(Arrays.copyOfRange(revBases, firstElementLen, revBases.length));\n+            final byte[] revQuals = rev.getBaseQualitiesNoCopy();\n+            if ( revQuals.length > 0 ) {\n+                rev.setBaseQualities(Arrays.copyOfRange(revQuals, firstElementLen, revQuals.length));\n+            }\n+            final List<CigarElement> newRevElements = new ArrayList<>(revElements);\n+            newRevElements.set(0, new CigarElement(firstElementLen, CigarOperator.H));\n+            rev.setCigar(new Cigar(newRevElements));\n+        }\n+    }\n+\n+    @VisibleForTesting\n+    static void kmerizeReads( final List<GATKRead> reads,\n+                              final KmerSet<KmerAdjacency> kmerAdjacencySet ) {\n+        for ( final GATKRead read : reads ) {\n+            final byte[] calls = read.getBasesNoCopy();\n+            final byte[] quals = read.getBaseQualitiesNoCopy();\n+            KmerAdjacency.kmerize(calls, quals, QMIN, kmerAdjacencySet);\n+        }\n+    }\n+\n+    /** gather unbranched strings of kmers into contigs **/\n+    @VisibleForTesting\n+    static List<ContigImpl> buildContigs( final KmerSet<KmerAdjacency> kmerAdjacencySet ) {\n+        // gather strings of kmers that have a single predecessor and single successor into contigs\n+        final List<ContigImpl> contigs = new ArrayList<>();\n+        int nContigs = 0;\n+        for ( final KmerAdjacency kmerAdjacency : kmerAdjacencySet ) {\n+            if ( kmerAdjacency.getContig() == null ) {\n+                ContigImpl contig = null;\n+                final KmerAdjacency predecessor = kmerAdjacency.getSolePredecessor();\n+                if ( predecessor == null ||\n+                        predecessor.getSuccessorCount() > 1 ||\n+                        predecessor == kmerAdjacency.rc() ) {\n+                    contig = new ContigImpl(++nContigs, kmerAdjacency);\n+                } else {\n+                    final KmerAdjacency successor = kmerAdjacency.getSoleSuccessor();\n+                    if ( successor == null ||\n+                            successor.getPredecessorCount() > 1 ||\n+                            successor == kmerAdjacency.rc() ) {\n+                        contig = new ContigImpl(++nContigs, kmerAdjacency.rc());\n+                    }\n+                }\n+                if ( contig != null ) {\n+                    contigs.add(contig);\n+                }\n+            }\n+        }\n+\n+        // if there are smooth circles like a plasmid, gather them together as a contig, too\n+        for ( final KmerAdjacency kmerAdjacency : kmerAdjacencySet ) {\n+            if ( kmerAdjacency.getContig() == null ) {\n+                contigs.add(new ContigImpl(++nContigs, kmerAdjacency));\n+            }\n+        }\n+\n+        return contigs;\n+    }\n+\n+    /** connect contigs when the final kmer of one contig is adjacent to the inital contig of another **/\n+    @VisibleForTesting\n+    static void connectContigs( final List<ContigImpl> contigs ) {\n+        final int nContigs = contigs.size();\n+        final KmerSet<ContigEndKmer> contigEnds = new KmerSet<>(2*nContigs);\n+        for ( int contigId = 0; contigId != nContigs; ++contigId ) {\n+            final ContigImpl contig = contigs.get(contigId);\n+            final KmerAdjacency fwdKmer = contig.getFirstKmer();\n+            final KmerAdjacency revKmer = contig.getLastKmer().rc();\n+            if ( fwdKmer == revKmer ) {\n+                contigEnds.add(new ContigEndKmer(fwdKmer.getKVal(), contig, ContigOrientation.BOTH));\n+            } else {\n+                contigEnds.add(new ContigEndKmer(fwdKmer.getKVal(), contig, ContigOrientation.FWD));\n+                contigEnds.add(new ContigEndKmer(revKmer.getKVal(), contig, ContigOrientation.REV));\n+            }\n+        }\n+\n+        for ( int contigId = 0; contigId != nContigs; ++contigId ) {\n+            final Contig contig = contigs.get(contigId);\n+\n+            final KmerAdjacency start = contig.getFirstKmer();\n+            final int predecessorCount = start.getPredecessorCount();\n+            if ( predecessorCount > 0 ) {\n+                final List<Contig> predecessors = contig.getPredecessors();\n+                final int mask = start.getPredecessorMask();\n+                for ( int call = 0; call != 4; ++call ) {\n+                    if ( (mask & (1 << call)) != 0 ) {\n+                        final long kVal =\n+                                KmerAdjacency.reverseComplement(start.getPredecessorVal(call));\n+                        final ContigEndKmer contigEndKmer = contigEnds.find(new Kmer(kVal));\n+                        if ( contigEndKmer == null ) {\n+                            throw new GATKException(\"missing contig end kmer\");\n+                        }\n+                        switch ( contigEndKmer.getContigOrientation() ) {\n+                            case FWD:\n+                                predecessors.add(contigEndKmer.getContig().rc());\n+                                break;\n+                            case REV:\n+                                predecessors.add(contigEndKmer.getContig());\n+                                break;\n+                            case BOTH:\n+                                predecessors.add(contigEndKmer.getContig());\n+                                predecessors.add(contigEndKmer.getContig().rc());\n+                                break;\n+                        }\n+                    }\n+                }\n+            }\n+\n+            final KmerAdjacency end = contig.getLastKmer();\n+            final int successorCount = end.getSuccessorCount();\n+            if ( successorCount > 0 ) {\n+                final List<Contig> successors = contig.getSuccessors();\n+                final int mask = end.getSuccessorMask();\n+                for ( int call = 0; call != 4; ++call ) {\n+                    if ( (mask & (1 << call)) != 0 ) {\n+                        final long kVal = end.getSuccessorVal(call);\n+                        final ContigEndKmer contigEndKmer = contigEnds.find(new Kmer(kVal));\n+                        if ( contigEndKmer == null ) {\n+                            throw new GATKException(\"missing contig end kmer\");\n+                        }\n+                        switch ( contigEndKmer.getContigOrientation() ) {\n+                            case FWD:\n+                                successors.add(contigEndKmer.getContig());\n+                                break;\n+                            case REV:\n+                                successors.add(contigEndKmer.getContig().rc());\n+                                break;\n+                            case BOTH:\n+                                successors.add(contigEndKmer.getContig());\n+                                successors.add(contigEndKmer.getContig().rc());\n+                                break;\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    /** remove contigs that have little evidence **/\n+    @VisibleForTesting\n+    static void removeThinContigs( final List<ContigImpl> contigs,\n+                                           final KmerSet<KmerAdjacency> kmerAdjacencySet ) {\n+        contigs.sort(Comparator.comparingInt(ContigImpl::getMaxObservations));\n+        boolean contigRemoved;\n+        do {\n+            // figure out which contigs are cut points\n+            // i.e., those contigs which, if removed, would result in a graph with more connected components\n+            final int nContigs = contigs.size();\n+            final Map<Contig, CutData> cutDataMap = new HashMap<>(nContigs * 3);\n+\n+            for ( final ContigImpl contig : contigs ) {\n+                if ( cutDataMap.containsKey(contig) ) {\n+                    continue;\n+                }\n+\n+                cutDataMap.put(contig, new CutData());\n+                int children = 0;\n+                for ( final Contig nextContig : contig.getSuccessors() ) {\n+                    if ( !cutDataMap.containsKey(nextContig) ) {\n+                        findCuts(nextContig, contig, cutDataMap);\n+                        children += 1;\n+                    }\n+                }\n+                for ( final Contig nextContig : contig.getPredecessors() ) {\n+                    if ( !cutDataMap.containsKey(nextContig) ) {\n+                        findCuts(nextContig, contig, cutDataMap);\n+                        children += 1;\n+                    }\n+                }\n+                if ( children >= 2 ) {\n+                    contig.setCut(true);\n+                }\n+            }\n+\n+            // remove poorly attested (low max observations) contigs, unless they are cut points\n+            contigRemoved = false;\n+            final Iterator<ContigImpl> itr = contigs.iterator();\n+            while ( itr.hasNext() ) {\n+                final Contig contig = itr.next();\n+                if ( contig.getMaxObservations() < MIN_THIN_OBS && !contig.isCut() ) {\n+                    unlinkContig(contig, kmerAdjacencySet);\n+                    itr.remove();\n+                    contigRemoved = true;\n+                    break;\n+                }\n+            }\n+        } while ( contigRemoved );\n+        contigs.sort(Comparator.comparingInt(ContigImpl::getId));\n+    }\n+\n+    private static CutData findCuts( final Contig contig,\n+                                     final Contig parent,\n+                                     final Map<Contig, CutData> cutDataMap ) {\n+        final CutData cutData = new CutData();\n+        cutDataMap.put(contig, cutData);\n+        for ( final Contig nextContig : contig.getSuccessors() ) {\n+            if ( nextContig == parent ) {\n+                continue;\n+            }\n+            CutData nextCutData = cutDataMap.get(nextContig);\n+            if ( nextCutData != null ) {\n+                cutData.minVisitNum = Math.min(cutData.minVisitNum, nextCutData.visitNum);\n+            } else {\n+                nextCutData = findCuts(nextContig, contig, cutDataMap);\n+                cutData.minVisitNum = Math.min(cutData.minVisitNum, nextCutData.minVisitNum);\n+                if ( nextCutData.minVisitNum >= cutData.visitNum ) {\n+                    contig.setCut(true);\n+                }\n+            }\n+        }\n+        for ( final Contig nextContig : contig.getPredecessors() ) {\n+            if ( nextContig == parent ) {\n+                continue;\n+            }\n+            CutData nextCutData = cutDataMap.get(nextContig);\n+            if ( nextCutData != null ) {\n+                cutData.minVisitNum = Math.min(cutData.minVisitNum, nextCutData.visitNum);\n+            } else {\n+                nextCutData = findCuts(nextContig, contig, cutDataMap);\n+                cutData.minVisitNum = Math.min(cutData.minVisitNum, nextCutData.minVisitNum);\n+                if ( nextCutData.minVisitNum >= cutData.visitNum ) {\n+                    contig.setCut(true);\n+                }\n+            }\n+        }\n+        return cutData;\n+    }\n+\n+    @VisibleForTesting\n+    static void unlinkContig( final Contig contig,\n+                                      final KmerSet<KmerAdjacency> kmerAdjacencySet ) {\n+        final KmerAdjacency firstKmer = contig.getFirstKmer();\n+        final int firstKmerFinalCall = firstKmer.getFinalCall();\n+        for ( final Contig predecessor : contig.getPredecessors() ) {\n+            if ( predecessor != contig && predecessor != contig.rc() ) {\n+                predecessor.getLastKmer().removeSuccessor(firstKmerFinalCall, kmerAdjacencySet);\n+                if ( !predecessor.getSuccessors().remove(contig) ) {\n+                    throw new GATKException(\"failed to find predecessor link\");\n+                }\n+            }\n+        }\n+\n+        final KmerAdjacency lastKmer = contig.getLastKmer();\n+        final int lastKmerInitialCall = lastKmer.getInitialCall();\n+        for ( final Contig successor : contig.getSuccessors() ) {\n+            if ( successor != contig && successor != contig.rc() ) {\n+                successor.getFirstKmer().removePredecessor(lastKmerInitialCall, kmerAdjacencySet);\n+                if ( !successor.getPredecessors().remove(contig) ) {\n+                    throw new GATKException(\"failed to find successor link\");\n+                }\n+            }\n+        }\n+\n+        KmerAdjacency nextKmer = firstKmer;\n+        KmerAdjacency kmer;\n+        do {\n+            kmer = nextKmer;\n+            nextKmer = kmer.getSoleSuccessor();\n+            kmerAdjacencySet.remove(kmer.canonical());\n+        } while ( kmer != lastKmer );\n+    }\n+\n+    private static void updateKmerContig( final KmerAdjacency firstKmer,\n+                                          final KmerAdjacency lastKmer,\n+                                          final Contig contig ) {\n+        int offset = 0;\n+        for ( KmerAdjacency kmer = firstKmer; kmer != lastKmer; kmer = kmer.getSoleSuccessor() ) {\n+            if ( kmer == null ) {\n+                throw new GATKException(\"contig does not have a flat pipeline of kmers\");\n+            }\n+            kmer.clearContig();\n+            kmer.setContigOffset(contig, offset++);\n+        }\n+        lastKmer.clearContig();\n+        lastKmer.setContigOffset(contig, offset);\n+        if ( offset + Kmer.KSIZE != contig.size() ) {\n+            throw new GATKException(\"kmer chain length does not equal contig size\");\n+        }\n+    }\n+\n+    /** replace adjacent contigs without branches with a single, larger contig **/\n+    @VisibleForTesting\n+    static void weldPipes( final List<ContigImpl> contigs ) {\n+        for ( int contigIdx = 0; contigIdx != contigs.size(); ++contigIdx ) {\n+            final ContigImpl contig = contigs.get(contigIdx);\n+            if ( contig.getSuccessors().size() == 1 ) {\n+                final Contig successor = contig.getSuccessors().get(0);\n+                if ( successor != contig && successor != contig.rc() &&\n+                        successor.getPredecessors().size() == 1 ) {\n+                    contigs.set(contigIdx, join(contig.getId(), contig, successor));\n+                    if ( !contigs.remove(successor.canonical()) ) {\n+                        throw new GATKException(\"successor linkage is messed up\");\n+                    }\n+                    contigIdx -= 1; // reconsider the new contig -- there might be more joining possible\n+                    continue;\n+                }\n+            }\n+            if ( contig.getPredecessors().size() == 1 ) {\n+                final Contig predecessor = contig.getPredecessors().get(0);\n+                if ( predecessor != contig && predecessor != contig.rc() &&\n+                        predecessor.getSuccessors().size() == 1 ) {\n+                    contigs.set(contigIdx, join(contig.getId(), predecessor, contig));\n+                    if ( !contigs.remove(predecessor.canonical()) ) {\n+                        throw new GATKException(\"predecessor linkage is messed up\");\n+                    }\n+                    contigIdx -= 1; // reconsider\n+                }\n+            }\n+        }\n+    }\n+\n+    private static ContigImpl join( final int id, final Contig predecessor, final Contig successor ) {\n+        if ( !checkOverlap(predecessor.getSequence(), successor.getSequence()) ) {\n+                throw new GATKException(\"sequences can't be joined\");\n+        }\n+        final ContigImpl joinedContig = new ContigImpl(id, predecessor, successor);\n+        updateKmerContig(joinedContig.getFirstKmer(), joinedContig.getLastKmer(), joinedContig);\n+        return joinedContig;\n+    }\n+\n+    private static boolean checkOverlap( final CharSequence seq1, final CharSequence seq2 ) {\n+        final int seq1Len = seq1.length();\n+        final CharSequence seq1SubSeq = seq1.subSequence(seq1Len - Kmer.KSIZE + 1, seq1Len);\n+        final CharSequence seq2SubSeq = seq2.subSequence(0, Kmer.KSIZE - 1);\n+        return seq1SubSeq.equals(seq2SubSeq);\n+    }\n+\n+    /** set a unique componentId for every connected group of contigs **/\n+    @VisibleForTesting\n+    static int markComponents( final List<ContigImpl> contigs ) {\n+        for ( final ContigImpl contig : contigs ) {\n+            contig.setComponentId(0);\n+        }\n+\n+        int componentId = 0;\n+        for ( final ContigImpl contig : contigs ) {\n+            if ( contig.getComponentId() == 0 ) {\n+                contig.setComponentId(++componentId);\n+                markSuccessorComponents(contig);\n+                markSuccessorComponents(contig.rc());\n+            }\n+        }\n+        return componentId;\n+    }\n+\n+    private static void markSuccessorComponents( final Contig contig ) {\n+        final int componentId = contig.getComponentId();\n+        for ( final Contig successor : contig.getSuccessors() ) {\n+            if ( successor.getComponentId() == 0 ) {\n+                successor.canonical().setComponentId(componentId);\n+                markSuccessorComponents(successor);\n+                markSuccessorComponents(successor.rc());\n+            }\n+        }\n+    }\n+\n+    @VisibleForTesting\n+    static void markCycles( final List<ContigImpl> contigs ) {\n+        for ( final Contig contig : contigs ) {\n+            contig.setCyclic(false);\n+        }\n+\n+        final int nContigs = contigs.size();\n+        final Deque<Contig> deque = new ArrayDeque<>(nContigs);\n+        final Map<Contig, CutData> cutDataMap = new HashMap<>(nContigs * 3);\n+        for ( final Contig contig : contigs ) {\n+            if ( !cutDataMap.containsKey(contig) ) {\n+                markCyclesRecursion(contig, deque, cutDataMap);\n+            }\n+        }\n+    }\n+\n+    private static CutData markCyclesRecursion( final Contig contig,\n+                                                final Deque<Contig> deque,\n+                                                final Map<Contig, CutData> cutDataMap ) {\n+        final CutData cutData = new CutData();\n+        cutDataMap.put(contig, cutData);\n+        deque.addFirst(contig);\n+\n+        for ( final Contig successor : contig.getSuccessors() ) {\n+            final CutData successorCutData = cutDataMap.get(successor);\n+            if ( successorCutData == null ) {\n+                final int recursionVisitNum =\n+                        markCyclesRecursion(successor, deque, cutDataMap).minVisitNum;\n+                cutData.minVisitNum = Math.min(cutData.minVisitNum, recursionVisitNum);\n+            } else {\n+                cutData.minVisitNum = Math.min(cutData.minVisitNum, successorCutData.visitNum);\n+            }\n+        }\n+\n+        if ( cutData.visitNum == cutData.minVisitNum ) {\n+            Contig tig = deque.removeFirst();\n+            if ( tig == contig ) {\n+                cutDataMap.get(tig).visitNum = Integer.MAX_VALUE;\n+\n+                // single-vertex component -- cyclic only if self-referential\n+                if ( tig.getSuccessors().contains(tig) ) {\n+                    tig.setCyclic(true);\n+                }\n+            } else {\n+                while ( true ) {\n+                    // kill cross-links\n+                    cutDataMap.get(tig).visitNum = Integer.MAX_VALUE;\n+                    tig.setCyclic(true);\n+                    if ( tig == contig ) break;\n+                    tig = deque.removeFirst();\n+                }\n+            }\n+        }\n+        return cutData;\n+    }\n+\n+    @VisibleForTesting\n+    static boolean fillGaps( final KmerSet<KmerAdjacency> kmerAdjacencySet,\n+                             final List<GATKRead> reads ) {\n+        final Map<String, Integer> gapFillCounts = new HashMap<>();\n+        for ( final GATKRead read : reads ) {\n+            final Path path = new Path(read.getBasesNoCopy(), kmerAdjacencySet);\n+            final List<PathPart> parts = path.getParts();\n+            final int lastIdx = parts.size() - 1;\n+            for ( int idx = 1; idx < lastIdx; ++idx ) {\n+                final PathPart pathPart = parts.get(idx);\n+                if ( pathPart.isGap() ) {\n+                    final char prevCall = parts.get(idx - 1).getLastCall();\n+                    final char nextCall = parts.get(idx + 1).getFirstCall();\n+                    String gapFill = prevCall + pathPart.getSequence().toString() + nextCall;\n+                    final SequenceRC gapFillRC = new SequenceRC(gapFill);\n+                    if ( gapFillRC.compareTo(gapFill) < 0 ) {\n+                        gapFill = gapFillRC.toString();\n+                    }\n+                    gapFillCounts.merge(gapFill, 1, Integer::sum);\n+                }\n+            }\n+        }\n+\n+        boolean newKmers = false;\n+        for ( final Map.Entry<String, Integer> entry : gapFillCounts.entrySet() ) {\n+            final int nObservations = entry.getValue();\n+            if ( nObservations >= MIN_GAPFILL_COUNT ) {\n+                KmerAdjacency.kmerize(entry.getKey(), nObservations, kmerAdjacencySet);\n+                newKmers = true;\n+            }\n+        }\n+\n+        if ( newKmers ) {\n+            for ( final KmerAdjacency kmerAdjacency : kmerAdjacencySet ) {\n+                kmerAdjacency.clearContig();\n+            }\n+        }\n+        return newKmers;\n+    }\n+\n+    @VisibleForTesting\n+    static List<Path> pathReads( final KmerSet<KmerAdjacency> kmerAdjacencySet,\n+                          final List<GATKRead> reads ) {\n+        final List<Path> readPaths = new ArrayList<>(reads.size());\n+        for ( final GATKRead read : reads ) {\n+            readPaths.add(new Path(read.getBasesNoCopy(), kmerAdjacencySet));\n+        }\n+        return readPaths;\n+    }\n+\n+    @VisibleForTesting\n+    static Map<Contig,List<TransitPairCount>> collectTransitPairCounts(\n+            final List<ContigImpl> contigs,\n+            final List<Path> readPaths ) {\n+        final Map<Contig,List<TransitPairCount>> contigTransitsMap =\n+                new HashMap<>(3 * contigs.size());\n+        for ( final Path path : readPaths ) {\n+            final List<PathPart> parts = path.getParts();\n+            final int lastPart = parts.size() - 1;\n+            for ( int partIdx = 1; partIdx < lastPart; ++partIdx ) {\n+                final Contig prevContig = parts.get(partIdx - 1).getContig();\n+                if ( prevContig == null ) continue;\n+                final Contig curContig = parts.get(partIdx).getContig();\n+                if ( curContig == null ) {\n+                    partIdx += 1;\n+                    continue;\n+                }\n+                final Contig nextContig = parts.get(partIdx + 1).getContig();\n+                if ( nextContig == null ) {\n+                    partIdx += 2;\n+                    continue;\n+                }\n+                final TransitPairCount tpc = new TransitPairCount(prevContig, nextContig);\n+                final List<TransitPairCount> tpcList =\n+                        contigTransitsMap.computeIfAbsent(curContig, tig -> new ArrayList<>(4));\n+                final int idx = tpcList.indexOf(tpc);\n+                if ( idx != -1 ) {\n+                    tpcList.get(idx).observe();\n+                } else {\n+                    tpcList.add(tpc);\n+                    contigTransitsMap.computeIfAbsent(curContig.rc(), tig -> new ArrayList<>(4))\n+                            .add(tpc.getRC());\n+                }\n+            }\n+        }\n+        return contigTransitsMap;\n+    }\n+\n+    @VisibleForTesting\n+    static Set<Traversal> traverseAllPaths(\n+            final List<ContigImpl> contigs,\n+            final List<Path> readPaths,\n+            final Map<Contig, List<TransitPairCount>> contigTransitsMap ) {\n+        final Set<Traversal> traversalSet = new HashSet<>();\n+        final List<Contig> contigsList = new ArrayList<>();\n+        for ( final Contig contig : contigs ) {\n+            // untransited contigs are sources, sinks, or large contigs that can't be crossed by a read\n+            // build traversals from these\n+            if ( !contigTransitsMap.containsKey(contig) ) {\n+                boolean done = false;\n+                for ( final Contig successor : contig.getSuccessors() ) {\n+                    traverse(successor, contig,\n+                            contigsList, readPaths, contigTransitsMap, traversalSet);\n+                    done = true;\n+                }\n+                for ( final Contig predecessor : contig.getPredecessors() ) {\n+                    traverse(predecessor.rc(), contig.rc(),\n+                            contigsList, readPaths, contigTransitsMap, traversalSet);\n+                    done = true;\n+                }\n+                if ( !done ) { // if there were no predecessors or successors, it stands alone\n+                    addTraversal(new Traversal(Collections.singletonList(contig)), traversalSet);\n+                }\n+            }\n+        }\n+\n+        // look for transits that haven't been traced\n+        for ( final Map.Entry<Contig, List<TransitPairCount>> entry :\n+                contigTransitsMap.entrySet() ) {\n+            for ( final TransitPairCount tpc : entry.getValue() ) {\n+                if ( tpc.getCount() > 0 ) {\n+                    tpc.resetCount();\n+                    final Contig contig = entry.getKey();\n+                    final Set<Traversal> fwdTraversalSet = new HashSet<>();\n+                    traverse(tpc.getNextContig(), contig,\n+                            contigsList, readPaths, contigTransitsMap, fwdTraversalSet);\n+                    final Set<Traversal> revTraversalSet = new HashSet<>();\n+                    traverse(tpc.getPrevContig().rc(), contig.rc(),\n+                            contigsList, readPaths, contigTransitsMap, revTraversalSet);\n+                    for ( final Traversal revTraversal : revTraversalSet ) {\n+                        final Traversal revTraversalRC = revTraversal.rc();\n+                        for ( final Traversal fwdTraversal : fwdTraversalSet ) {\n+                            final int overlap =\n+                                    findMaxOverlap(revTraversalRC.getContigs(), fwdTraversal.getContigs());\n+                            final Traversal combo =\n+                                    Traversal.combineOverlappers(revTraversalRC, fwdTraversal, overlap);\n+                            addTraversal(combo, traversalSet);\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+\n+        return traversalSet;\n+    }\n+\n+    private static int findMaxOverlap( final List<Contig> prefixes, final List<Contig> suffixes ) {\n+        final int nPrefixes = prefixes.size();\n+        final Contig firstSuffix = suffixes.get(0);\n+        if ( !firstSuffix.isCyclic() ) {\n+            return prefixes.get(nPrefixes - 1) == firstSuffix ? 1 : 0;\n+        }\n+        final int nSuffixes = suffixes.size();\n+        for ( int prefixIdx = Math.max(0, nPrefixes - nSuffixes); prefixIdx != nPrefixes; ++prefixIdx ) {\n+            if ( prefixes.get(prefixIdx) == firstSuffix ) {\n+                int suffixIdx = 1;\n+                boolean match = true;\n+                for ( int prefixIdx2 = prefixIdx + 1; prefixIdx2 != nPrefixes; ++prefixIdx2 ) {\n+                    if ( prefixes.get(prefixIdx2) != suffixes.get(suffixIdx++) ) {\n+                        match = false;\n+                        break;\n+                    }\n+                }\n+                if ( match ) {\n+                    return nPrefixes - prefixIdx;\n+                }\n+            }\n+        }\n+        return 0;\n+    }\n+\n+    private static void traverse( final Contig contig,\n+                                  final Contig predecessor,\n+                                  final List<Contig> contigsList,\n+                                  final List<Path> readPaths,\n+                                  final Map<Contig, List<TransitPairCount>> contigTransitsMap,\n+                                  final Set<Traversal> traversalSet ) {\n+        contigsList.add(predecessor);\n+        if ( contig.isCyclic() ) {\n+            traverseCycle(contig, contigsList, readPaths, contigTransitsMap, traversalSet);\n+            contigsList.remove(contigsList.size() - 1);\n+            return;\n+        }\n+        final List<TransitPairCount> transits = contigTransitsMap.get(contig);\n+        boolean done = false;\n+        if ( transits != null ) {\n+            for ( final TransitPairCount tpc : transits ) {\n+                if ( tpc.getPrevContig() == predecessor ) {\n+                    final Contig successor = tpc.getNextContig();\n+                    if ( predecessor == contig.rc() ) {\n+                        final int nContigs = contigsList.size();\n+                        if ( nContigs > 1 ) {\n+                            if ( successor.rc() == contigsList.get(nContigs - 2) ) {\n+                                continue;\n+                            }\n+                        }\n+                    }\n+                    tpc.resetCount();\n+                    traverse(successor, contig, contigsList, readPaths, contigTransitsMap, traversalSet);\n+                    done = true;\n+                }\n+            }\n+        }\n+        if ( !done ) {\n+            contigsList.add(contig);\n+            addTraversal(new Traversal(contigsList), traversalSet);\n+            contigsList.remove(contigsList.size() - 1);\n+        }\n+        contigsList.remove(contigsList.size() - 1);\n+    }\n+\n+    private static void traverseCycle( final Contig contig,\n+                                       final List<Contig> contigsList,\n+                                       final List<Path> readPaths,\n+                                       final Map<Contig, List<TransitPairCount>> contigTransitsMap,\n+                                       final Set<Traversal> traversalSet ) {\n+        contigsList.add(contig);\n+        final int nContigs = contigsList.size();\n+        // the final element of the list is cyclic, if there's a previous element it will be\n+        // non-cyclic, so start there figuring out how far the read paths lead us\n+        final List<List<Contig>> longestPaths =\n+                findLongestPaths(contigsList.subList(Math.max(0, nContigs - 2), nContigs), readPaths);\n+        // didn't get anywhere -- just complete the traversal\n+        if ( longestPaths.isEmpty() ) {\n+            addTraversal(new Traversal(contigsList, true), traversalSet);\n+        } else {\n+            // for each unique extension into the cycle\n+            for ( final List<Contig> path : longestPaths ) {\n+                // don't think this can happen, but still\n+                if ( path.isEmpty() ) {\n+                    addTraversal(new Traversal(contigsList, true), traversalSet);\n+                    continue;\n+                }\n+                final List<Contig> extendedContigsList =\n+                        new ArrayList<>(contigsList.size() + path.size());\n+                extendedContigsList.addAll(contigsList);\n+                // if we didn't get out of the cycle\n+                if ( path.get(path.size() - 1).isCyclic() ) {\n+                    extendedContigsList.addAll(path);\n+                    addTraversal(new Traversal(extendedContigsList, true), traversalSet);\n+                } else {\n+                    // we found a cycle-exiting path, so extend that normally\n+                    for ( final Contig curContig : path ) {\n+                        if ( curContig.isCyclic() ) {\n+                            extendedContigsList.add(curContig);\n+                        } else {\n+                            final Contig prevContig =\n+                                    extendedContigsList.remove(extendedContigsList.size() - 1);\n+                            traverse(curContig, prevContig, extendedContigsList, readPaths,\n+                                    contigTransitsMap, traversalSet);\n+                            extendedContigsList.add(prevContig);\n+                            break;\n+                        }\n+                    }\n+                }\n+                clearTransitPairs(contigTransitsMap, extendedContigsList);\n+            }\n+        }\n+        contigsList.remove(contigsList.size() - 1);\n+    }\n+\n+    private static void clearTransitPairs(\n+            final Map<Contig, List<TransitPairCount>> contigTransitsMap,\n+            final List<Contig> contigsList ) {\n+        final int lastIdx = contigsList.size() - 1;\n+        for ( int idx = 1; idx < lastIdx; ++idx ) {\n+            final List<TransitPairCount> pairCounts = contigTransitsMap.get(contigsList.get(idx));\n+            if ( pairCounts != null ) {\n+                final Contig predecessor = contigsList.get(idx - 1);\n+                final Contig successor = contigsList.get(idx + 1);\n+                for ( final TransitPairCount tpc : pairCounts ) {\n+                    if ( tpc.getPrevContig() == predecessor && tpc.getNextContig() == successor ) {\n+                        tpc.resetCount();\n+                        break;\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    private static void addTraversal( final Traversal traversal,\n+                                      final Set<Traversal> traversalSet ) {\n+        if ( !traversalSet.contains(traversal.rc()) ) {\n+            traversalSet.add(traversal);\n+            if ( traversalSet.size() >= TOO_MANY_TRAVERSALS ) {\n+                throw new AssemblyTooComplexException();\n+            }\n+        }\n+    }\n+\n+    private static List<List<Contig>> findLongestPaths( final List<Contig> toMatch,\n+                                                        final List<Path> readPaths ) {\n+        final List<List<Contig>> results = new ArrayList<>();\n+        for ( final Path path : readPaths ) {\n+            testPath(path, toMatch, results);\n+            testPath(path.rc(), toMatch, results);\n+        }\n+        return results;\n+    }\n+\n+    private static void testPath( final Path path,\n+                                  final List<Contig> toMatch,\n+                                  final List<List<Contig>> results ) {\n+        final List<PathPart> pathParts = path.getParts();\n+        final int nPathParts = pathParts.size();\n+        final List<Contig> pathContigs = new ArrayList<>(nPathParts);\n+        pathParts.forEach(pp -> pathContigs.add(pp.getContig()));\n+        final int matchIdx = Collections.indexOfSubList(pathContigs, toMatch);\n+        if ( matchIdx != -1 ) {\n+            final int suffixIdx = matchIdx + toMatch.size();\n+            if ( suffixIdx < nPathParts ) {\n+                resolveResult(grabParts(pathContigs, suffixIdx), results);\n+            }\n+        }\n+    }\n+\n+    private static List<Contig> grabParts( final List<Contig> pathContigs, final int suffixIdx ) {\n+        final int nPathContigs = pathContigs.size();\n+        Contig prev = pathContigs.get(suffixIdx - 1);\n+        final List<Contig> result = new ArrayList<>(nPathContigs - suffixIdx);\n+        for ( int idx = suffixIdx; idx != nPathContigs; ++idx ) {\n+            final Contig tig = pathContigs.get(idx);\n+            if ( tig == null || !prev.getSuccessors().contains(tig) ) break;\n+            result.add(tig);\n+            prev = tig;\n+        }\n+        return result;\n+    }\n+\n+    private static void resolveResult( final List<Contig> result,\n+                                       final List<List<Contig>> results ) {\n+        final int nResults = results.size();\n+        for ( int idx = 0; idx != nResults; ++idx ) {\n+            final List<Contig> test = results.get(idx);\n+            if ( isPrefix(result, test) ) return;\n+            if ( isPrefix(test, result) ) {\n+                results.set(idx, result);\n+                return;\n+            }\n+        }\n+        results.add(result);\n+    }\n+\n+    private static boolean isPrefix( final List<Contig> list1, final List<Contig> list2 ) {\n+        final int list1Size = list1.size();\n+        final int list2Size = list2.size();\n+        if ( list1Size > list2Size ) return false;\n+        for ( int idx = 0; idx != list1Size; ++idx ) {\n+            if ( list1.get(idx) != list2.get(idx) ) return false;\n+        }\n+        return true;\n+    }\n+\n+    @VisibleForTesting\n+    static Collection<Traversal> createScaffolds( final List<Traversal> allTraversals ) {\n+        removeTriviallyDifferentTraversals(allTraversals);\n+\n+        final int nTraversals = allTraversals.size();\n+        final Map<Contig, List<Integer>> traversalsByFirstContig = new HashMap<>(3 * nTraversals);\n+        for ( int idx = 0; idx != nTraversals; ++idx ) {\n+            final Traversal traversal = allTraversals.get(idx);\n+            traversalsByFirstContig.compute(traversal.getFirstContig(),\n+                    ( k, v ) -> v == null ? new ArrayList<>(3) : v).add(idx);\n+            final Traversal rcTraversal = traversal.rc();\n+            traversalsByFirstContig.compute(rcTraversal.getFirstContig(),\n+                    ( k, v ) -> v == null ? new ArrayList<>(3) : v).add(~idx);\n+        }\n+\n+        final List<Traversal> scaffolds = new ArrayList<>(nTraversals);\n+        final boolean[] touched = new boolean[nTraversals];\n+        for ( int idx = 0; idx != nTraversals; ++idx ) {\n+            if ( !touched[idx] ) {\n+                expandTraversal(idx, touched, traversalsByFirstContig, allTraversals, scaffolds);\n+            }\n+        }\n+        return scaffolds;\n+    }\n+\n+    private static void expandTraversal( final int traversalIdx,\n+                                         final boolean[] touched,\n+                                         final Map<Contig, List<Integer>> traversalsByFirstContig,\n+                                         final List<Traversal> allTraversals,\n+                                         final List<Traversal> scaffolds ) {\n+        final Traversal traversal = allTraversals.get(traversalIdx);\n+        touched[traversalIdx] = true;\n+        final List<Traversal> downExtensions = new ArrayList<>();\n+        final Set<Contig> startingContigSet = new HashSet<>();\n+        walkTraversals(traversal, touched, startingContigSet, traversalsByFirstContig,\n+                        allTraversals, downExtensions);\n+        final List<Traversal> upExtensions = new ArrayList<>();\n+        walkTraversals(traversal.rc(), touched, startingContigSet, traversalsByFirstContig,\n+                        allTraversals, upExtensions);\n+        for ( final Traversal down : downExtensions ) {\n+            for ( final Traversal up : upExtensions ) {\n+                if ( scaffolds.size() >= TOO_MANY_SCAFFOLDS ) {\n+                    throw new AssemblyTooComplexException();\n+                }\n+                scaffolds.add(Traversal.combineOverlappers(up.rc(), down, traversal.getContigs().size()));\n+            }\n+        }\n+    }\n+\n+    private static void walkTraversals( final Traversal traversal,\n+                                        final boolean[] touched,\n+                                        final Set<Contig> startingContigSet,\n+                                        final Map<Contig, List<Integer>> traversalsByFirstContig,\n+                                        final List<Traversal> allTraversals,\n+                                        final List<Traversal> extensions ) {\n+        final Contig firstContig = traversal.getFirstContig();\n+        final List<Integer> indexList;\n+        if ( startingContigSet.contains(firstContig) ||\n+                traversal.isInextensible() ||\n+                (indexList = traversalsByFirstContig.get(traversal.getLastContig())) == null ) {\n+            extensions.add(traversal);\n+            return;\n+        }\n+        startingContigSet.add(firstContig);\n+        for ( int idx : indexList ) {\n+            final Traversal extension;\n+            if ( idx >= 0 ) {\n+                extension = allTraversals.get(idx);\n+                touched[idx] = true;\n+            } else {\n+                final int rcIdx = ~idx;\n+                extension = allTraversals.get(rcIdx).rc();\n+                touched[rcIdx] = true;\n+            }\n+            walkTraversals(Traversal.combine(traversal, extension), touched, startingContigSet,\n+                            traversalsByFirstContig, allTraversals, extensions );\n+        }\n+        startingContigSet.remove(firstContig);\n+    }\n+\n+    private static void removeTriviallyDifferentTraversals(\n+                                            final Collection<Traversal> allTraversals ) {\n+        if ( allTraversals.isEmpty() ) {\n+            return;\n+        }\n+        final TreeSet<Traversal> sortedTraversals = new TreeSet<>(new TraversalEndpointComparator());\n+        for ( final Traversal traversal : allTraversals ) {\n+            sortedTraversals.add(traversal);\n+            sortedTraversals.add(traversal.rc());\n+        }\n+        final Iterator<Traversal> traversalIterator = sortedTraversals.iterator();\n+        Traversal prevTraversal = traversalIterator.next();\n+        while ( traversalIterator.hasNext() ) {\n+            final Traversal curTraversal = traversalIterator.next();\n+            if ( isTriviallyDifferent(prevTraversal, curTraversal) ) {\n+                traversalIterator.remove();\n+            } else {\n+                prevTraversal = curTraversal;\n+            }\n+        }\n+        sortedTraversals.removeIf(Traversal::isRC);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e2201c1ef4f8ba71f17e169f07756cfe2f1ecb49"}, "originalPosition": 1030}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxOTM1NjEwNg==", "bodyText": "We added both strands at the beginning, and I thought I had the sort order arranged so that, for any given pair that was trivially different, at least one of the +strand guys survived removal.  Alas, that wasn't true. It's rewritten to avoid that assumption.", "url": "https://github.com/broadinstitute/gatk/pull/6989#discussion_r619356106", "createdAt": "2021-04-23T16:37:49Z", "author": {"login": "tedsharpe"}, "path": "src/main/java/org/broadinstitute/hellbender/tools/LocalAssembler.java", "diffHunk": "@@ -0,0 +1,2306 @@\n+package org.broadinstitute.hellbender.tools;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import htsjdk.samtools.Cigar;\n+import htsjdk.samtools.CigarElement;\n+import htsjdk.samtools.CigarOperator;\n+import htsjdk.samtools.SAMUtils;\n+import org.broadinstitute.barclay.argparser.Argument;\n+import org.broadinstitute.barclay.argparser.BetaFeature;\n+import org.broadinstitute.barclay.argparser.CommandLineProgramProperties;\n+import org.broadinstitute.barclay.help.DocumentedFeature;\n+import org.broadinstitute.hellbender.cmdline.StandardArgumentDefinitions;\n+import org.broadinstitute.hellbender.cmdline.programgroups.CoverageAnalysisProgramGroup;\n+import org.broadinstitute.hellbender.exceptions.GATKException;\n+import org.broadinstitute.hellbender.tools.walkers.PairWalker;\n+import org.broadinstitute.hellbender.utils.SimpleInterval;\n+import org.broadinstitute.hellbender.utils.collections.HopscotchSet;\n+import org.broadinstitute.hellbender.utils.gcs.BucketUtils;\n+import org.broadinstitute.hellbender.utils.read.GATKRead;\n+\n+import java.io.BufferedWriter;\n+import java.io.FileWriter;\n+import java.io.IOException;\n+import java.io.OutputStreamWriter;\n+import java.util.*;\n+import java.util.zip.GZIPOutputStream;\n+\n+@DocumentedFeature\n+@CommandLineProgramProperties(\n+        summary = \"experiment\",\n+        oneLineSummary = \"experiment\",\n+        usageExample = \"gatk LocalAssembler\",\n+        programGroup = CoverageAnalysisProgramGroup.class\n+)\n+@BetaFeature\n+public class LocalAssembler extends PairWalker {\n+    public static final byte QMIN = 25;\n+    public static final int MIN_THIN_OBS = 4;\n+    public static final int MIN_GAPFILL_COUNT = 3;\n+    public static final int TOO_MANY_TRAVERSALS = 100000;\n+    public static final int TOO_MANY_SCAFFOLDS = 50000;\n+    public static final int MIN_SV_SIZE = 50;\n+\n+    @Argument(fullName=StandardArgumentDefinitions.OUTPUT_LONG_NAME,\n+            shortName=StandardArgumentDefinitions.OUTPUT_SHORT_NAME,\n+            doc=\"Write outputs to this file name prefix\", optional = true)\n+    public static String output;\n+\n+    @Argument(fullName=\"assembly-name\", doc=\"name of assembly used as a prefix for traversal names\")\n+    public static String assemblyName;\n+\n+    private final List<GATKRead> reads = new ArrayList<>();\n+\n+    @Override public boolean requiresIntervals() { return true; }\n+\n+    @Override public void apply( final GATKRead read, final GATKRead mate ) {\n+        trimOverruns(read, mate);\n+        reads.add(read);\n+        reads.add(mate);\n+    }\n+\n+    @Override public void applyUnpaired( final GATKRead read ) {\n+        reads.add(read);\n+    }\n+\n+    @Override public Object onTraversalSuccess() {\n+        super.onTraversalSuccess(); // flush any incomplete pairs\n+\n+        final int regionSize = getTraversalIntervals().stream().mapToInt(SimpleInterval::size).sum();\n+        final KmerSet<KmerAdjacency> kmerAdjacencySet = new KmerSet<>(10 * regionSize);\n+        kmerizeReads(reads, kmerAdjacencySet);\n+        List<ContigImpl> contigs = buildContigs(kmerAdjacencySet);\n+        connectContigs(contigs);\n+\n+        removeThinContigs(contigs, kmerAdjacencySet);\n+        weldPipes(contigs);\n+        markComponents(contigs);\n+\n+        if ( fillGaps(kmerAdjacencySet, reads) ) {\n+            contigs = buildContigs(kmerAdjacencySet);\n+            connectContigs(contigs);\n+            removeThinContigs(contigs, kmerAdjacencySet);\n+            weldPipes(contigs);\n+            markComponents(contigs);\n+        }\n+\n+        markCycles(contigs);\n+\n+        final String outputFilePrefix = output != null ? output : assemblyName;\n+        final List<Path> readPaths = pathReads(kmerAdjacencySet, reads);\n+        final Map<Contig,List<TransitPairCount>> contigTransitsMap =\n+                collectTransitPairCounts(contigs, readPaths);\n+        final String traversalsFilename = outputFilePrefix + \".traversals.fa.gz\";\n+        try {\n+            final List<Traversal> allTraversals =\n+                    new ArrayList<>(traverseAllPaths(contigs, readPaths, contigTransitsMap));\n+            writeTraversals(allTraversals, traversalsFilename);\n+            try {\n+                final String scaffoldsFileName = outputFilePrefix + \".scaffolds.fa.gz\";\n+                writeTraversals(createScaffolds(allTraversals), scaffoldsFileName);\n+            } catch ( final AssemblyTooComplexException x ) {\n+                logger.warn(\"Assembly too complex for scaffolding.\");\n+            }\n+        } catch ( final AssemblyTooComplexException x ) {\n+            logger.warn(\"Assembly too complex.  Writing contigs as traversals in \" +\n+                    traversalsFilename + \".\");\n+            final Collection<Traversal> contigTraversals = new ArrayList<>(contigs.size());\n+            for ( final Contig contig : contigs ) {\n+                contigTraversals.add(new Traversal(Collections.singletonList(contig)));\n+            }\n+            writeTraversals(contigTraversals, traversalsFilename);\n+        }\n+\n+        contigs.sort(Comparator.comparingInt(ContigImpl::getId));\n+        writeDOT(contigs, outputFilePrefix + \".assembly.dot\");\n+        writeContigs(contigs, outputFilePrefix + \".contigs.txt.gz\");\n+        writePaths(readPaths, outputFilePrefix + \".paths.txt.gz\");\n+        writeReads(reads, outputFilePrefix + \".reads.fastq.gz\");\n+        return null;\n+    }\n+\n+    /** trim read pairs of base calls that have gone past the end of a short fragment */\n+    private void trimOverruns( final GATKRead read, final GATKRead mate ) {\n+        // if both mapped and they're on different strands\n+        if ( !read.isUnmapped() && !mate.isUnmapped() &&\n+                read.isReverseStrand() != mate.isReverseStrand() ) {\n+            // and both start within 1 base on the ref\n+            if ( Math.abs(read.getStart() - read.getMateStart()) <= 1 ) {\n+                // and both end within 1 base\n+                final int readRefLen = read.getCigar().getReferenceLength();\n+                final int mateRefLen = mate.getCigar().getReferenceLength();\n+                if ( Math.abs(readRefLen - mateRefLen) <= 1 ) {\n+                    if ( mate.isReverseStrand() ) {\n+                        trimClips(read, mate);\n+                    } else {\n+                        trimClips(mate, read);\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    private void trimClips( final GATKRead fwd, final GATKRead rev ) {\n+        final List<CigarElement> fwdElements = fwd.getCigarElements();\n+        final List<CigarElement> revElements = rev.getCigarElements();\n+        final int lastElementIdx = fwdElements.size() - 1;\n+        final CigarElement fwdLastElement = fwdElements.get(lastElementIdx);\n+        final CigarElement revFirstElement = revElements.get(0);\n+        if ( fwdLastElement.getOperator() == CigarOperator.S &&\n+                revFirstElement.getOperator() == CigarOperator.S ) {\n+            final byte[] fwdBases = fwd.getBasesNoCopy();\n+            final int lastElementLen = fwdLastElement.getLength();\n+            fwd.setBases(Arrays.copyOfRange(fwdBases, 0, fwdBases.length - lastElementLen));\n+            final byte[] fwdQuals = fwd.getBaseQualitiesNoCopy();\n+            if ( fwdQuals.length > 0 ) {\n+                final int qualsLen = fwdQuals.length - lastElementLen;\n+                fwd.setBaseQualities(Arrays.copyOfRange(fwdQuals, 0, qualsLen));\n+            }\n+            final List<CigarElement> newFwdElements = new ArrayList<>(fwdElements);\n+            newFwdElements.set(lastElementIdx, new CigarElement(lastElementLen, CigarOperator.H));\n+            fwd.setCigar(new Cigar(newFwdElements));\n+\n+            final byte[] revBases = rev.getBasesNoCopy();\n+            final int firstElementLen = revFirstElement.getLength();\n+            rev.setBases(Arrays.copyOfRange(revBases, firstElementLen, revBases.length));\n+            final byte[] revQuals = rev.getBaseQualitiesNoCopy();\n+            if ( revQuals.length > 0 ) {\n+                rev.setBaseQualities(Arrays.copyOfRange(revQuals, firstElementLen, revQuals.length));\n+            }\n+            final List<CigarElement> newRevElements = new ArrayList<>(revElements);\n+            newRevElements.set(0, new CigarElement(firstElementLen, CigarOperator.H));\n+            rev.setCigar(new Cigar(newRevElements));\n+        }\n+    }\n+\n+    @VisibleForTesting\n+    static void kmerizeReads( final List<GATKRead> reads,\n+                              final KmerSet<KmerAdjacency> kmerAdjacencySet ) {\n+        for ( final GATKRead read : reads ) {\n+            final byte[] calls = read.getBasesNoCopy();\n+            final byte[] quals = read.getBaseQualitiesNoCopy();\n+            KmerAdjacency.kmerize(calls, quals, QMIN, kmerAdjacencySet);\n+        }\n+    }\n+\n+    /** gather unbranched strings of kmers into contigs **/\n+    @VisibleForTesting\n+    static List<ContigImpl> buildContigs( final KmerSet<KmerAdjacency> kmerAdjacencySet ) {\n+        // gather strings of kmers that have a single predecessor and single successor into contigs\n+        final List<ContigImpl> contigs = new ArrayList<>();\n+        int nContigs = 0;\n+        for ( final KmerAdjacency kmerAdjacency : kmerAdjacencySet ) {\n+            if ( kmerAdjacency.getContig() == null ) {\n+                ContigImpl contig = null;\n+                final KmerAdjacency predecessor = kmerAdjacency.getSolePredecessor();\n+                if ( predecessor == null ||\n+                        predecessor.getSuccessorCount() > 1 ||\n+                        predecessor == kmerAdjacency.rc() ) {\n+                    contig = new ContigImpl(++nContigs, kmerAdjacency);\n+                } else {\n+                    final KmerAdjacency successor = kmerAdjacency.getSoleSuccessor();\n+                    if ( successor == null ||\n+                            successor.getPredecessorCount() > 1 ||\n+                            successor == kmerAdjacency.rc() ) {\n+                        contig = new ContigImpl(++nContigs, kmerAdjacency.rc());\n+                    }\n+                }\n+                if ( contig != null ) {\n+                    contigs.add(contig);\n+                }\n+            }\n+        }\n+\n+        // if there are smooth circles like a plasmid, gather them together as a contig, too\n+        for ( final KmerAdjacency kmerAdjacency : kmerAdjacencySet ) {\n+            if ( kmerAdjacency.getContig() == null ) {\n+                contigs.add(new ContigImpl(++nContigs, kmerAdjacency));\n+            }\n+        }\n+\n+        return contigs;\n+    }\n+\n+    /** connect contigs when the final kmer of one contig is adjacent to the inital contig of another **/\n+    @VisibleForTesting\n+    static void connectContigs( final List<ContigImpl> contigs ) {\n+        final int nContigs = contigs.size();\n+        final KmerSet<ContigEndKmer> contigEnds = new KmerSet<>(2*nContigs);\n+        for ( int contigId = 0; contigId != nContigs; ++contigId ) {\n+            final ContigImpl contig = contigs.get(contigId);\n+            final KmerAdjacency fwdKmer = contig.getFirstKmer();\n+            final KmerAdjacency revKmer = contig.getLastKmer().rc();\n+            if ( fwdKmer == revKmer ) {\n+                contigEnds.add(new ContigEndKmer(fwdKmer.getKVal(), contig, ContigOrientation.BOTH));\n+            } else {\n+                contigEnds.add(new ContigEndKmer(fwdKmer.getKVal(), contig, ContigOrientation.FWD));\n+                contigEnds.add(new ContigEndKmer(revKmer.getKVal(), contig, ContigOrientation.REV));\n+            }\n+        }\n+\n+        for ( int contigId = 0; contigId != nContigs; ++contigId ) {\n+            final Contig contig = contigs.get(contigId);\n+\n+            final KmerAdjacency start = contig.getFirstKmer();\n+            final int predecessorCount = start.getPredecessorCount();\n+            if ( predecessorCount > 0 ) {\n+                final List<Contig> predecessors = contig.getPredecessors();\n+                final int mask = start.getPredecessorMask();\n+                for ( int call = 0; call != 4; ++call ) {\n+                    if ( (mask & (1 << call)) != 0 ) {\n+                        final long kVal =\n+                                KmerAdjacency.reverseComplement(start.getPredecessorVal(call));\n+                        final ContigEndKmer contigEndKmer = contigEnds.find(new Kmer(kVal));\n+                        if ( contigEndKmer == null ) {\n+                            throw new GATKException(\"missing contig end kmer\");\n+                        }\n+                        switch ( contigEndKmer.getContigOrientation() ) {\n+                            case FWD:\n+                                predecessors.add(contigEndKmer.getContig().rc());\n+                                break;\n+                            case REV:\n+                                predecessors.add(contigEndKmer.getContig());\n+                                break;\n+                            case BOTH:\n+                                predecessors.add(contigEndKmer.getContig());\n+                                predecessors.add(contigEndKmer.getContig().rc());\n+                                break;\n+                        }\n+                    }\n+                }\n+            }\n+\n+            final KmerAdjacency end = contig.getLastKmer();\n+            final int successorCount = end.getSuccessorCount();\n+            if ( successorCount > 0 ) {\n+                final List<Contig> successors = contig.getSuccessors();\n+                final int mask = end.getSuccessorMask();\n+                for ( int call = 0; call != 4; ++call ) {\n+                    if ( (mask & (1 << call)) != 0 ) {\n+                        final long kVal = end.getSuccessorVal(call);\n+                        final ContigEndKmer contigEndKmer = contigEnds.find(new Kmer(kVal));\n+                        if ( contigEndKmer == null ) {\n+                            throw new GATKException(\"missing contig end kmer\");\n+                        }\n+                        switch ( contigEndKmer.getContigOrientation() ) {\n+                            case FWD:\n+                                successors.add(contigEndKmer.getContig());\n+                                break;\n+                            case REV:\n+                                successors.add(contigEndKmer.getContig().rc());\n+                                break;\n+                            case BOTH:\n+                                successors.add(contigEndKmer.getContig());\n+                                successors.add(contigEndKmer.getContig().rc());\n+                                break;\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    /** remove contigs that have little evidence **/\n+    @VisibleForTesting\n+    static void removeThinContigs( final List<ContigImpl> contigs,\n+                                           final KmerSet<KmerAdjacency> kmerAdjacencySet ) {\n+        contigs.sort(Comparator.comparingInt(ContigImpl::getMaxObservations));\n+        boolean contigRemoved;\n+        do {\n+            // figure out which contigs are cut points\n+            // i.e., those contigs which, if removed, would result in a graph with more connected components\n+            final int nContigs = contigs.size();\n+            final Map<Contig, CutData> cutDataMap = new HashMap<>(nContigs * 3);\n+\n+            for ( final ContigImpl contig : contigs ) {\n+                if ( cutDataMap.containsKey(contig) ) {\n+                    continue;\n+                }\n+\n+                cutDataMap.put(contig, new CutData());\n+                int children = 0;\n+                for ( final Contig nextContig : contig.getSuccessors() ) {\n+                    if ( !cutDataMap.containsKey(nextContig) ) {\n+                        findCuts(nextContig, contig, cutDataMap);\n+                        children += 1;\n+                    }\n+                }\n+                for ( final Contig nextContig : contig.getPredecessors() ) {\n+                    if ( !cutDataMap.containsKey(nextContig) ) {\n+                        findCuts(nextContig, contig, cutDataMap);\n+                        children += 1;\n+                    }\n+                }\n+                if ( children >= 2 ) {\n+                    contig.setCut(true);\n+                }\n+            }\n+\n+            // remove poorly attested (low max observations) contigs, unless they are cut points\n+            contigRemoved = false;\n+            final Iterator<ContigImpl> itr = contigs.iterator();\n+            while ( itr.hasNext() ) {\n+                final Contig contig = itr.next();\n+                if ( contig.getMaxObservations() < MIN_THIN_OBS && !contig.isCut() ) {\n+                    unlinkContig(contig, kmerAdjacencySet);\n+                    itr.remove();\n+                    contigRemoved = true;\n+                    break;\n+                }\n+            }\n+        } while ( contigRemoved );\n+        contigs.sort(Comparator.comparingInt(ContigImpl::getId));\n+    }\n+\n+    private static CutData findCuts( final Contig contig,\n+                                     final Contig parent,\n+                                     final Map<Contig, CutData> cutDataMap ) {\n+        final CutData cutData = new CutData();\n+        cutDataMap.put(contig, cutData);\n+        for ( final Contig nextContig : contig.getSuccessors() ) {\n+            if ( nextContig == parent ) {\n+                continue;\n+            }\n+            CutData nextCutData = cutDataMap.get(nextContig);\n+            if ( nextCutData != null ) {\n+                cutData.minVisitNum = Math.min(cutData.minVisitNum, nextCutData.visitNum);\n+            } else {\n+                nextCutData = findCuts(nextContig, contig, cutDataMap);\n+                cutData.minVisitNum = Math.min(cutData.minVisitNum, nextCutData.minVisitNum);\n+                if ( nextCutData.minVisitNum >= cutData.visitNum ) {\n+                    contig.setCut(true);\n+                }\n+            }\n+        }\n+        for ( final Contig nextContig : contig.getPredecessors() ) {\n+            if ( nextContig == parent ) {\n+                continue;\n+            }\n+            CutData nextCutData = cutDataMap.get(nextContig);\n+            if ( nextCutData != null ) {\n+                cutData.minVisitNum = Math.min(cutData.minVisitNum, nextCutData.visitNum);\n+            } else {\n+                nextCutData = findCuts(nextContig, contig, cutDataMap);\n+                cutData.minVisitNum = Math.min(cutData.minVisitNum, nextCutData.minVisitNum);\n+                if ( nextCutData.minVisitNum >= cutData.visitNum ) {\n+                    contig.setCut(true);\n+                }\n+            }\n+        }\n+        return cutData;\n+    }\n+\n+    @VisibleForTesting\n+    static void unlinkContig( final Contig contig,\n+                                      final KmerSet<KmerAdjacency> kmerAdjacencySet ) {\n+        final KmerAdjacency firstKmer = contig.getFirstKmer();\n+        final int firstKmerFinalCall = firstKmer.getFinalCall();\n+        for ( final Contig predecessor : contig.getPredecessors() ) {\n+            if ( predecessor != contig && predecessor != contig.rc() ) {\n+                predecessor.getLastKmer().removeSuccessor(firstKmerFinalCall, kmerAdjacencySet);\n+                if ( !predecessor.getSuccessors().remove(contig) ) {\n+                    throw new GATKException(\"failed to find predecessor link\");\n+                }\n+            }\n+        }\n+\n+        final KmerAdjacency lastKmer = contig.getLastKmer();\n+        final int lastKmerInitialCall = lastKmer.getInitialCall();\n+        for ( final Contig successor : contig.getSuccessors() ) {\n+            if ( successor != contig && successor != contig.rc() ) {\n+                successor.getFirstKmer().removePredecessor(lastKmerInitialCall, kmerAdjacencySet);\n+                if ( !successor.getPredecessors().remove(contig) ) {\n+                    throw new GATKException(\"failed to find successor link\");\n+                }\n+            }\n+        }\n+\n+        KmerAdjacency nextKmer = firstKmer;\n+        KmerAdjacency kmer;\n+        do {\n+            kmer = nextKmer;\n+            nextKmer = kmer.getSoleSuccessor();\n+            kmerAdjacencySet.remove(kmer.canonical());\n+        } while ( kmer != lastKmer );\n+    }\n+\n+    private static void updateKmerContig( final KmerAdjacency firstKmer,\n+                                          final KmerAdjacency lastKmer,\n+                                          final Contig contig ) {\n+        int offset = 0;\n+        for ( KmerAdjacency kmer = firstKmer; kmer != lastKmer; kmer = kmer.getSoleSuccessor() ) {\n+            if ( kmer == null ) {\n+                throw new GATKException(\"contig does not have a flat pipeline of kmers\");\n+            }\n+            kmer.clearContig();\n+            kmer.setContigOffset(contig, offset++);\n+        }\n+        lastKmer.clearContig();\n+        lastKmer.setContigOffset(contig, offset);\n+        if ( offset + Kmer.KSIZE != contig.size() ) {\n+            throw new GATKException(\"kmer chain length does not equal contig size\");\n+        }\n+    }\n+\n+    /** replace adjacent contigs without branches with a single, larger contig **/\n+    @VisibleForTesting\n+    static void weldPipes( final List<ContigImpl> contigs ) {\n+        for ( int contigIdx = 0; contigIdx != contigs.size(); ++contigIdx ) {\n+            final ContigImpl contig = contigs.get(contigIdx);\n+            if ( contig.getSuccessors().size() == 1 ) {\n+                final Contig successor = contig.getSuccessors().get(0);\n+                if ( successor != contig && successor != contig.rc() &&\n+                        successor.getPredecessors().size() == 1 ) {\n+                    contigs.set(contigIdx, join(contig.getId(), contig, successor));\n+                    if ( !contigs.remove(successor.canonical()) ) {\n+                        throw new GATKException(\"successor linkage is messed up\");\n+                    }\n+                    contigIdx -= 1; // reconsider the new contig -- there might be more joining possible\n+                    continue;\n+                }\n+            }\n+            if ( contig.getPredecessors().size() == 1 ) {\n+                final Contig predecessor = contig.getPredecessors().get(0);\n+                if ( predecessor != contig && predecessor != contig.rc() &&\n+                        predecessor.getSuccessors().size() == 1 ) {\n+                    contigs.set(contigIdx, join(contig.getId(), predecessor, contig));\n+                    if ( !contigs.remove(predecessor.canonical()) ) {\n+                        throw new GATKException(\"predecessor linkage is messed up\");\n+                    }\n+                    contigIdx -= 1; // reconsider\n+                }\n+            }\n+        }\n+    }\n+\n+    private static ContigImpl join( final int id, final Contig predecessor, final Contig successor ) {\n+        if ( !checkOverlap(predecessor.getSequence(), successor.getSequence()) ) {\n+                throw new GATKException(\"sequences can't be joined\");\n+        }\n+        final ContigImpl joinedContig = new ContigImpl(id, predecessor, successor);\n+        updateKmerContig(joinedContig.getFirstKmer(), joinedContig.getLastKmer(), joinedContig);\n+        return joinedContig;\n+    }\n+\n+    private static boolean checkOverlap( final CharSequence seq1, final CharSequence seq2 ) {\n+        final int seq1Len = seq1.length();\n+        final CharSequence seq1SubSeq = seq1.subSequence(seq1Len - Kmer.KSIZE + 1, seq1Len);\n+        final CharSequence seq2SubSeq = seq2.subSequence(0, Kmer.KSIZE - 1);\n+        return seq1SubSeq.equals(seq2SubSeq);\n+    }\n+\n+    /** set a unique componentId for every connected group of contigs **/\n+    @VisibleForTesting\n+    static int markComponents( final List<ContigImpl> contigs ) {\n+        for ( final ContigImpl contig : contigs ) {\n+            contig.setComponentId(0);\n+        }\n+\n+        int componentId = 0;\n+        for ( final ContigImpl contig : contigs ) {\n+            if ( contig.getComponentId() == 0 ) {\n+                contig.setComponentId(++componentId);\n+                markSuccessorComponents(contig);\n+                markSuccessorComponents(contig.rc());\n+            }\n+        }\n+        return componentId;\n+    }\n+\n+    private static void markSuccessorComponents( final Contig contig ) {\n+        final int componentId = contig.getComponentId();\n+        for ( final Contig successor : contig.getSuccessors() ) {\n+            if ( successor.getComponentId() == 0 ) {\n+                successor.canonical().setComponentId(componentId);\n+                markSuccessorComponents(successor);\n+                markSuccessorComponents(successor.rc());\n+            }\n+        }\n+    }\n+\n+    @VisibleForTesting\n+    static void markCycles( final List<ContigImpl> contigs ) {\n+        for ( final Contig contig : contigs ) {\n+            contig.setCyclic(false);\n+        }\n+\n+        final int nContigs = contigs.size();\n+        final Deque<Contig> deque = new ArrayDeque<>(nContigs);\n+        final Map<Contig, CutData> cutDataMap = new HashMap<>(nContigs * 3);\n+        for ( final Contig contig : contigs ) {\n+            if ( !cutDataMap.containsKey(contig) ) {\n+                markCyclesRecursion(contig, deque, cutDataMap);\n+            }\n+        }\n+    }\n+\n+    private static CutData markCyclesRecursion( final Contig contig,\n+                                                final Deque<Contig> deque,\n+                                                final Map<Contig, CutData> cutDataMap ) {\n+        final CutData cutData = new CutData();\n+        cutDataMap.put(contig, cutData);\n+        deque.addFirst(contig);\n+\n+        for ( final Contig successor : contig.getSuccessors() ) {\n+            final CutData successorCutData = cutDataMap.get(successor);\n+            if ( successorCutData == null ) {\n+                final int recursionVisitNum =\n+                        markCyclesRecursion(successor, deque, cutDataMap).minVisitNum;\n+                cutData.minVisitNum = Math.min(cutData.minVisitNum, recursionVisitNum);\n+            } else {\n+                cutData.minVisitNum = Math.min(cutData.minVisitNum, successorCutData.visitNum);\n+            }\n+        }\n+\n+        if ( cutData.visitNum == cutData.minVisitNum ) {\n+            Contig tig = deque.removeFirst();\n+            if ( tig == contig ) {\n+                cutDataMap.get(tig).visitNum = Integer.MAX_VALUE;\n+\n+                // single-vertex component -- cyclic only if self-referential\n+                if ( tig.getSuccessors().contains(tig) ) {\n+                    tig.setCyclic(true);\n+                }\n+            } else {\n+                while ( true ) {\n+                    // kill cross-links\n+                    cutDataMap.get(tig).visitNum = Integer.MAX_VALUE;\n+                    tig.setCyclic(true);\n+                    if ( tig == contig ) break;\n+                    tig = deque.removeFirst();\n+                }\n+            }\n+        }\n+        return cutData;\n+    }\n+\n+    @VisibleForTesting\n+    static boolean fillGaps( final KmerSet<KmerAdjacency> kmerAdjacencySet,\n+                             final List<GATKRead> reads ) {\n+        final Map<String, Integer> gapFillCounts = new HashMap<>();\n+        for ( final GATKRead read : reads ) {\n+            final Path path = new Path(read.getBasesNoCopy(), kmerAdjacencySet);\n+            final List<PathPart> parts = path.getParts();\n+            final int lastIdx = parts.size() - 1;\n+            for ( int idx = 1; idx < lastIdx; ++idx ) {\n+                final PathPart pathPart = parts.get(idx);\n+                if ( pathPart.isGap() ) {\n+                    final char prevCall = parts.get(idx - 1).getLastCall();\n+                    final char nextCall = parts.get(idx + 1).getFirstCall();\n+                    String gapFill = prevCall + pathPart.getSequence().toString() + nextCall;\n+                    final SequenceRC gapFillRC = new SequenceRC(gapFill);\n+                    if ( gapFillRC.compareTo(gapFill) < 0 ) {\n+                        gapFill = gapFillRC.toString();\n+                    }\n+                    gapFillCounts.merge(gapFill, 1, Integer::sum);\n+                }\n+            }\n+        }\n+\n+        boolean newKmers = false;\n+        for ( final Map.Entry<String, Integer> entry : gapFillCounts.entrySet() ) {\n+            final int nObservations = entry.getValue();\n+            if ( nObservations >= MIN_GAPFILL_COUNT ) {\n+                KmerAdjacency.kmerize(entry.getKey(), nObservations, kmerAdjacencySet);\n+                newKmers = true;\n+            }\n+        }\n+\n+        if ( newKmers ) {\n+            for ( final KmerAdjacency kmerAdjacency : kmerAdjacencySet ) {\n+                kmerAdjacency.clearContig();\n+            }\n+        }\n+        return newKmers;\n+    }\n+\n+    @VisibleForTesting\n+    static List<Path> pathReads( final KmerSet<KmerAdjacency> kmerAdjacencySet,\n+                          final List<GATKRead> reads ) {\n+        final List<Path> readPaths = new ArrayList<>(reads.size());\n+        for ( final GATKRead read : reads ) {\n+            readPaths.add(new Path(read.getBasesNoCopy(), kmerAdjacencySet));\n+        }\n+        return readPaths;\n+    }\n+\n+    @VisibleForTesting\n+    static Map<Contig,List<TransitPairCount>> collectTransitPairCounts(\n+            final List<ContigImpl> contigs,\n+            final List<Path> readPaths ) {\n+        final Map<Contig,List<TransitPairCount>> contigTransitsMap =\n+                new HashMap<>(3 * contigs.size());\n+        for ( final Path path : readPaths ) {\n+            final List<PathPart> parts = path.getParts();\n+            final int lastPart = parts.size() - 1;\n+            for ( int partIdx = 1; partIdx < lastPart; ++partIdx ) {\n+                final Contig prevContig = parts.get(partIdx - 1).getContig();\n+                if ( prevContig == null ) continue;\n+                final Contig curContig = parts.get(partIdx).getContig();\n+                if ( curContig == null ) {\n+                    partIdx += 1;\n+                    continue;\n+                }\n+                final Contig nextContig = parts.get(partIdx + 1).getContig();\n+                if ( nextContig == null ) {\n+                    partIdx += 2;\n+                    continue;\n+                }\n+                final TransitPairCount tpc = new TransitPairCount(prevContig, nextContig);\n+                final List<TransitPairCount> tpcList =\n+                        contigTransitsMap.computeIfAbsent(curContig, tig -> new ArrayList<>(4));\n+                final int idx = tpcList.indexOf(tpc);\n+                if ( idx != -1 ) {\n+                    tpcList.get(idx).observe();\n+                } else {\n+                    tpcList.add(tpc);\n+                    contigTransitsMap.computeIfAbsent(curContig.rc(), tig -> new ArrayList<>(4))\n+                            .add(tpc.getRC());\n+                }\n+            }\n+        }\n+        return contigTransitsMap;\n+    }\n+\n+    @VisibleForTesting\n+    static Set<Traversal> traverseAllPaths(\n+            final List<ContigImpl> contigs,\n+            final List<Path> readPaths,\n+            final Map<Contig, List<TransitPairCount>> contigTransitsMap ) {\n+        final Set<Traversal> traversalSet = new HashSet<>();\n+        final List<Contig> contigsList = new ArrayList<>();\n+        for ( final Contig contig : contigs ) {\n+            // untransited contigs are sources, sinks, or large contigs that can't be crossed by a read\n+            // build traversals from these\n+            if ( !contigTransitsMap.containsKey(contig) ) {\n+                boolean done = false;\n+                for ( final Contig successor : contig.getSuccessors() ) {\n+                    traverse(successor, contig,\n+                            contigsList, readPaths, contigTransitsMap, traversalSet);\n+                    done = true;\n+                }\n+                for ( final Contig predecessor : contig.getPredecessors() ) {\n+                    traverse(predecessor.rc(), contig.rc(),\n+                            contigsList, readPaths, contigTransitsMap, traversalSet);\n+                    done = true;\n+                }\n+                if ( !done ) { // if there were no predecessors or successors, it stands alone\n+                    addTraversal(new Traversal(Collections.singletonList(contig)), traversalSet);\n+                }\n+            }\n+        }\n+\n+        // look for transits that haven't been traced\n+        for ( final Map.Entry<Contig, List<TransitPairCount>> entry :\n+                contigTransitsMap.entrySet() ) {\n+            for ( final TransitPairCount tpc : entry.getValue() ) {\n+                if ( tpc.getCount() > 0 ) {\n+                    tpc.resetCount();\n+                    final Contig contig = entry.getKey();\n+                    final Set<Traversal> fwdTraversalSet = new HashSet<>();\n+                    traverse(tpc.getNextContig(), contig,\n+                            contigsList, readPaths, contigTransitsMap, fwdTraversalSet);\n+                    final Set<Traversal> revTraversalSet = new HashSet<>();\n+                    traverse(tpc.getPrevContig().rc(), contig.rc(),\n+                            contigsList, readPaths, contigTransitsMap, revTraversalSet);\n+                    for ( final Traversal revTraversal : revTraversalSet ) {\n+                        final Traversal revTraversalRC = revTraversal.rc();\n+                        for ( final Traversal fwdTraversal : fwdTraversalSet ) {\n+                            final int overlap =\n+                                    findMaxOverlap(revTraversalRC.getContigs(), fwdTraversal.getContigs());\n+                            final Traversal combo =\n+                                    Traversal.combineOverlappers(revTraversalRC, fwdTraversal, overlap);\n+                            addTraversal(combo, traversalSet);\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+\n+        return traversalSet;\n+    }\n+\n+    private static int findMaxOverlap( final List<Contig> prefixes, final List<Contig> suffixes ) {\n+        final int nPrefixes = prefixes.size();\n+        final Contig firstSuffix = suffixes.get(0);\n+        if ( !firstSuffix.isCyclic() ) {\n+            return prefixes.get(nPrefixes - 1) == firstSuffix ? 1 : 0;\n+        }\n+        final int nSuffixes = suffixes.size();\n+        for ( int prefixIdx = Math.max(0, nPrefixes - nSuffixes); prefixIdx != nPrefixes; ++prefixIdx ) {\n+            if ( prefixes.get(prefixIdx) == firstSuffix ) {\n+                int suffixIdx = 1;\n+                boolean match = true;\n+                for ( int prefixIdx2 = prefixIdx + 1; prefixIdx2 != nPrefixes; ++prefixIdx2 ) {\n+                    if ( prefixes.get(prefixIdx2) != suffixes.get(suffixIdx++) ) {\n+                        match = false;\n+                        break;\n+                    }\n+                }\n+                if ( match ) {\n+                    return nPrefixes - prefixIdx;\n+                }\n+            }\n+        }\n+        return 0;\n+    }\n+\n+    private static void traverse( final Contig contig,\n+                                  final Contig predecessor,\n+                                  final List<Contig> contigsList,\n+                                  final List<Path> readPaths,\n+                                  final Map<Contig, List<TransitPairCount>> contigTransitsMap,\n+                                  final Set<Traversal> traversalSet ) {\n+        contigsList.add(predecessor);\n+        if ( contig.isCyclic() ) {\n+            traverseCycle(contig, contigsList, readPaths, contigTransitsMap, traversalSet);\n+            contigsList.remove(contigsList.size() - 1);\n+            return;\n+        }\n+        final List<TransitPairCount> transits = contigTransitsMap.get(contig);\n+        boolean done = false;\n+        if ( transits != null ) {\n+            for ( final TransitPairCount tpc : transits ) {\n+                if ( tpc.getPrevContig() == predecessor ) {\n+                    final Contig successor = tpc.getNextContig();\n+                    if ( predecessor == contig.rc() ) {\n+                        final int nContigs = contigsList.size();\n+                        if ( nContigs > 1 ) {\n+                            if ( successor.rc() == contigsList.get(nContigs - 2) ) {\n+                                continue;\n+                            }\n+                        }\n+                    }\n+                    tpc.resetCount();\n+                    traverse(successor, contig, contigsList, readPaths, contigTransitsMap, traversalSet);\n+                    done = true;\n+                }\n+            }\n+        }\n+        if ( !done ) {\n+            contigsList.add(contig);\n+            addTraversal(new Traversal(contigsList), traversalSet);\n+            contigsList.remove(contigsList.size() - 1);\n+        }\n+        contigsList.remove(contigsList.size() - 1);\n+    }\n+\n+    private static void traverseCycle( final Contig contig,\n+                                       final List<Contig> contigsList,\n+                                       final List<Path> readPaths,\n+                                       final Map<Contig, List<TransitPairCount>> contigTransitsMap,\n+                                       final Set<Traversal> traversalSet ) {\n+        contigsList.add(contig);\n+        final int nContigs = contigsList.size();\n+        // the final element of the list is cyclic, if there's a previous element it will be\n+        // non-cyclic, so start there figuring out how far the read paths lead us\n+        final List<List<Contig>> longestPaths =\n+                findLongestPaths(contigsList.subList(Math.max(0, nContigs - 2), nContigs), readPaths);\n+        // didn't get anywhere -- just complete the traversal\n+        if ( longestPaths.isEmpty() ) {\n+            addTraversal(new Traversal(contigsList, true), traversalSet);\n+        } else {\n+            // for each unique extension into the cycle\n+            for ( final List<Contig> path : longestPaths ) {\n+                // don't think this can happen, but still\n+                if ( path.isEmpty() ) {\n+                    addTraversal(new Traversal(contigsList, true), traversalSet);\n+                    continue;\n+                }\n+                final List<Contig> extendedContigsList =\n+                        new ArrayList<>(contigsList.size() + path.size());\n+                extendedContigsList.addAll(contigsList);\n+                // if we didn't get out of the cycle\n+                if ( path.get(path.size() - 1).isCyclic() ) {\n+                    extendedContigsList.addAll(path);\n+                    addTraversal(new Traversal(extendedContigsList, true), traversalSet);\n+                } else {\n+                    // we found a cycle-exiting path, so extend that normally\n+                    for ( final Contig curContig : path ) {\n+                        if ( curContig.isCyclic() ) {\n+                            extendedContigsList.add(curContig);\n+                        } else {\n+                            final Contig prevContig =\n+                                    extendedContigsList.remove(extendedContigsList.size() - 1);\n+                            traverse(curContig, prevContig, extendedContigsList, readPaths,\n+                                    contigTransitsMap, traversalSet);\n+                            extendedContigsList.add(prevContig);\n+                            break;\n+                        }\n+                    }\n+                }\n+                clearTransitPairs(contigTransitsMap, extendedContigsList);\n+            }\n+        }\n+        contigsList.remove(contigsList.size() - 1);\n+    }\n+\n+    private static void clearTransitPairs(\n+            final Map<Contig, List<TransitPairCount>> contigTransitsMap,\n+            final List<Contig> contigsList ) {\n+        final int lastIdx = contigsList.size() - 1;\n+        for ( int idx = 1; idx < lastIdx; ++idx ) {\n+            final List<TransitPairCount> pairCounts = contigTransitsMap.get(contigsList.get(idx));\n+            if ( pairCounts != null ) {\n+                final Contig predecessor = contigsList.get(idx - 1);\n+                final Contig successor = contigsList.get(idx + 1);\n+                for ( final TransitPairCount tpc : pairCounts ) {\n+                    if ( tpc.getPrevContig() == predecessor && tpc.getNextContig() == successor ) {\n+                        tpc.resetCount();\n+                        break;\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    private static void addTraversal( final Traversal traversal,\n+                                      final Set<Traversal> traversalSet ) {\n+        if ( !traversalSet.contains(traversal.rc()) ) {\n+            traversalSet.add(traversal);\n+            if ( traversalSet.size() >= TOO_MANY_TRAVERSALS ) {\n+                throw new AssemblyTooComplexException();\n+            }\n+        }\n+    }\n+\n+    private static List<List<Contig>> findLongestPaths( final List<Contig> toMatch,\n+                                                        final List<Path> readPaths ) {\n+        final List<List<Contig>> results = new ArrayList<>();\n+        for ( final Path path : readPaths ) {\n+            testPath(path, toMatch, results);\n+            testPath(path.rc(), toMatch, results);\n+        }\n+        return results;\n+    }\n+\n+    private static void testPath( final Path path,\n+                                  final List<Contig> toMatch,\n+                                  final List<List<Contig>> results ) {\n+        final List<PathPart> pathParts = path.getParts();\n+        final int nPathParts = pathParts.size();\n+        final List<Contig> pathContigs = new ArrayList<>(nPathParts);\n+        pathParts.forEach(pp -> pathContigs.add(pp.getContig()));\n+        final int matchIdx = Collections.indexOfSubList(pathContigs, toMatch);\n+        if ( matchIdx != -1 ) {\n+            final int suffixIdx = matchIdx + toMatch.size();\n+            if ( suffixIdx < nPathParts ) {\n+                resolveResult(grabParts(pathContigs, suffixIdx), results);\n+            }\n+        }\n+    }\n+\n+    private static List<Contig> grabParts( final List<Contig> pathContigs, final int suffixIdx ) {\n+        final int nPathContigs = pathContigs.size();\n+        Contig prev = pathContigs.get(suffixIdx - 1);\n+        final List<Contig> result = new ArrayList<>(nPathContigs - suffixIdx);\n+        for ( int idx = suffixIdx; idx != nPathContigs; ++idx ) {\n+            final Contig tig = pathContigs.get(idx);\n+            if ( tig == null || !prev.getSuccessors().contains(tig) ) break;\n+            result.add(tig);\n+            prev = tig;\n+        }\n+        return result;\n+    }\n+\n+    private static void resolveResult( final List<Contig> result,\n+                                       final List<List<Contig>> results ) {\n+        final int nResults = results.size();\n+        for ( int idx = 0; idx != nResults; ++idx ) {\n+            final List<Contig> test = results.get(idx);\n+            if ( isPrefix(result, test) ) return;\n+            if ( isPrefix(test, result) ) {\n+                results.set(idx, result);\n+                return;\n+            }\n+        }\n+        results.add(result);\n+    }\n+\n+    private static boolean isPrefix( final List<Contig> list1, final List<Contig> list2 ) {\n+        final int list1Size = list1.size();\n+        final int list2Size = list2.size();\n+        if ( list1Size > list2Size ) return false;\n+        for ( int idx = 0; idx != list1Size; ++idx ) {\n+            if ( list1.get(idx) != list2.get(idx) ) return false;\n+        }\n+        return true;\n+    }\n+\n+    @VisibleForTesting\n+    static Collection<Traversal> createScaffolds( final List<Traversal> allTraversals ) {\n+        removeTriviallyDifferentTraversals(allTraversals);\n+\n+        final int nTraversals = allTraversals.size();\n+        final Map<Contig, List<Integer>> traversalsByFirstContig = new HashMap<>(3 * nTraversals);\n+        for ( int idx = 0; idx != nTraversals; ++idx ) {\n+            final Traversal traversal = allTraversals.get(idx);\n+            traversalsByFirstContig.compute(traversal.getFirstContig(),\n+                    ( k, v ) -> v == null ? new ArrayList<>(3) : v).add(idx);\n+            final Traversal rcTraversal = traversal.rc();\n+            traversalsByFirstContig.compute(rcTraversal.getFirstContig(),\n+                    ( k, v ) -> v == null ? new ArrayList<>(3) : v).add(~idx);\n+        }\n+\n+        final List<Traversal> scaffolds = new ArrayList<>(nTraversals);\n+        final boolean[] touched = new boolean[nTraversals];\n+        for ( int idx = 0; idx != nTraversals; ++idx ) {\n+            if ( !touched[idx] ) {\n+                expandTraversal(idx, touched, traversalsByFirstContig, allTraversals, scaffolds);\n+            }\n+        }\n+        return scaffolds;\n+    }\n+\n+    private static void expandTraversal( final int traversalIdx,\n+                                         final boolean[] touched,\n+                                         final Map<Contig, List<Integer>> traversalsByFirstContig,\n+                                         final List<Traversal> allTraversals,\n+                                         final List<Traversal> scaffolds ) {\n+        final Traversal traversal = allTraversals.get(traversalIdx);\n+        touched[traversalIdx] = true;\n+        final List<Traversal> downExtensions = new ArrayList<>();\n+        final Set<Contig> startingContigSet = new HashSet<>();\n+        walkTraversals(traversal, touched, startingContigSet, traversalsByFirstContig,\n+                        allTraversals, downExtensions);\n+        final List<Traversal> upExtensions = new ArrayList<>();\n+        walkTraversals(traversal.rc(), touched, startingContigSet, traversalsByFirstContig,\n+                        allTraversals, upExtensions);\n+        for ( final Traversal down : downExtensions ) {\n+            for ( final Traversal up : upExtensions ) {\n+                if ( scaffolds.size() >= TOO_MANY_SCAFFOLDS ) {\n+                    throw new AssemblyTooComplexException();\n+                }\n+                scaffolds.add(Traversal.combineOverlappers(up.rc(), down, traversal.getContigs().size()));\n+            }\n+        }\n+    }\n+\n+    private static void walkTraversals( final Traversal traversal,\n+                                        final boolean[] touched,\n+                                        final Set<Contig> startingContigSet,\n+                                        final Map<Contig, List<Integer>> traversalsByFirstContig,\n+                                        final List<Traversal> allTraversals,\n+                                        final List<Traversal> extensions ) {\n+        final Contig firstContig = traversal.getFirstContig();\n+        final List<Integer> indexList;\n+        if ( startingContigSet.contains(firstContig) ||\n+                traversal.isInextensible() ||\n+                (indexList = traversalsByFirstContig.get(traversal.getLastContig())) == null ) {\n+            extensions.add(traversal);\n+            return;\n+        }\n+        startingContigSet.add(firstContig);\n+        for ( int idx : indexList ) {\n+            final Traversal extension;\n+            if ( idx >= 0 ) {\n+                extension = allTraversals.get(idx);\n+                touched[idx] = true;\n+            } else {\n+                final int rcIdx = ~idx;\n+                extension = allTraversals.get(rcIdx).rc();\n+                touched[rcIdx] = true;\n+            }\n+            walkTraversals(Traversal.combine(traversal, extension), touched, startingContigSet,\n+                            traversalsByFirstContig, allTraversals, extensions );\n+        }\n+        startingContigSet.remove(firstContig);\n+    }\n+\n+    private static void removeTriviallyDifferentTraversals(\n+                                            final Collection<Traversal> allTraversals ) {\n+        if ( allTraversals.isEmpty() ) {\n+            return;\n+        }\n+        final TreeSet<Traversal> sortedTraversals = new TreeSet<>(new TraversalEndpointComparator());\n+        for ( final Traversal traversal : allTraversals ) {\n+            sortedTraversals.add(traversal);\n+            sortedTraversals.add(traversal.rc());\n+        }\n+        final Iterator<Traversal> traversalIterator = sortedTraversals.iterator();\n+        Traversal prevTraversal = traversalIterator.next();\n+        while ( traversalIterator.hasNext() ) {\n+            final Traversal curTraversal = traversalIterator.next();\n+            if ( isTriviallyDifferent(prevTraversal, curTraversal) ) {\n+                traversalIterator.remove();\n+            } else {\n+                prevTraversal = curTraversal;\n+            }\n+        }\n+        sortedTraversals.removeIf(Traversal::isRC);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5Nzg5MjcyMQ=="}, "originalCommit": {"oid": "e2201c1ef4f8ba71f17e169f07756cfe2f1ecb49"}, "originalPosition": 1030}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzc3NjYyNzIyOnYy", "diffSide": "RIGHT", "path": "src/main/java/org/broadinstitute/hellbender/tools/LocalAssembler.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMy0xOVQxODozMDozM1rOI6Moew==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNC0xNlQxNDo0NTowMFrOJKaOkQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5Nzg5NTI5MQ==", "bodyText": "Question: what if there are two contigs, A and B, which only differ by one base, and there are two traversals that are identical except that one starts with A and the other with B. Those won't be de-duplicated by this algorithm. Is that something to worry about?", "url": "https://github.com/broadinstitute/gatk/pull/6989#discussion_r597895291", "createdAt": "2021-03-19T18:30:33Z", "author": {"login": "cwhelan"}, "path": "src/main/java/org/broadinstitute/hellbender/tools/LocalAssembler.java", "diffHunk": "@@ -0,0 +1,2306 @@\n+package org.broadinstitute.hellbender.tools;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import htsjdk.samtools.Cigar;\n+import htsjdk.samtools.CigarElement;\n+import htsjdk.samtools.CigarOperator;\n+import htsjdk.samtools.SAMUtils;\n+import org.broadinstitute.barclay.argparser.Argument;\n+import org.broadinstitute.barclay.argparser.BetaFeature;\n+import org.broadinstitute.barclay.argparser.CommandLineProgramProperties;\n+import org.broadinstitute.barclay.help.DocumentedFeature;\n+import org.broadinstitute.hellbender.cmdline.StandardArgumentDefinitions;\n+import org.broadinstitute.hellbender.cmdline.programgroups.CoverageAnalysisProgramGroup;\n+import org.broadinstitute.hellbender.exceptions.GATKException;\n+import org.broadinstitute.hellbender.tools.walkers.PairWalker;\n+import org.broadinstitute.hellbender.utils.SimpleInterval;\n+import org.broadinstitute.hellbender.utils.collections.HopscotchSet;\n+import org.broadinstitute.hellbender.utils.gcs.BucketUtils;\n+import org.broadinstitute.hellbender.utils.read.GATKRead;\n+\n+import java.io.BufferedWriter;\n+import java.io.FileWriter;\n+import java.io.IOException;\n+import java.io.OutputStreamWriter;\n+import java.util.*;\n+import java.util.zip.GZIPOutputStream;\n+\n+@DocumentedFeature\n+@CommandLineProgramProperties(\n+        summary = \"experiment\",\n+        oneLineSummary = \"experiment\",\n+        usageExample = \"gatk LocalAssembler\",\n+        programGroup = CoverageAnalysisProgramGroup.class\n+)\n+@BetaFeature\n+public class LocalAssembler extends PairWalker {\n+    public static final byte QMIN = 25;\n+    public static final int MIN_THIN_OBS = 4;\n+    public static final int MIN_GAPFILL_COUNT = 3;\n+    public static final int TOO_MANY_TRAVERSALS = 100000;\n+    public static final int TOO_MANY_SCAFFOLDS = 50000;\n+    public static final int MIN_SV_SIZE = 50;\n+\n+    @Argument(fullName=StandardArgumentDefinitions.OUTPUT_LONG_NAME,\n+            shortName=StandardArgumentDefinitions.OUTPUT_SHORT_NAME,\n+            doc=\"Write outputs to this file name prefix\", optional = true)\n+    public static String output;\n+\n+    @Argument(fullName=\"assembly-name\", doc=\"name of assembly used as a prefix for traversal names\")\n+    public static String assemblyName;\n+\n+    private final List<GATKRead> reads = new ArrayList<>();\n+\n+    @Override public boolean requiresIntervals() { return true; }\n+\n+    @Override public void apply( final GATKRead read, final GATKRead mate ) {\n+        trimOverruns(read, mate);\n+        reads.add(read);\n+        reads.add(mate);\n+    }\n+\n+    @Override public void applyUnpaired( final GATKRead read ) {\n+        reads.add(read);\n+    }\n+\n+    @Override public Object onTraversalSuccess() {\n+        super.onTraversalSuccess(); // flush any incomplete pairs\n+\n+        final int regionSize = getTraversalIntervals().stream().mapToInt(SimpleInterval::size).sum();\n+        final KmerSet<KmerAdjacency> kmerAdjacencySet = new KmerSet<>(10 * regionSize);\n+        kmerizeReads(reads, kmerAdjacencySet);\n+        List<ContigImpl> contigs = buildContigs(kmerAdjacencySet);\n+        connectContigs(contigs);\n+\n+        removeThinContigs(contigs, kmerAdjacencySet);\n+        weldPipes(contigs);\n+        markComponents(contigs);\n+\n+        if ( fillGaps(kmerAdjacencySet, reads) ) {\n+            contigs = buildContigs(kmerAdjacencySet);\n+            connectContigs(contigs);\n+            removeThinContigs(contigs, kmerAdjacencySet);\n+            weldPipes(contigs);\n+            markComponents(contigs);\n+        }\n+\n+        markCycles(contigs);\n+\n+        final String outputFilePrefix = output != null ? output : assemblyName;\n+        final List<Path> readPaths = pathReads(kmerAdjacencySet, reads);\n+        final Map<Contig,List<TransitPairCount>> contigTransitsMap =\n+                collectTransitPairCounts(contigs, readPaths);\n+        final String traversalsFilename = outputFilePrefix + \".traversals.fa.gz\";\n+        try {\n+            final List<Traversal> allTraversals =\n+                    new ArrayList<>(traverseAllPaths(contigs, readPaths, contigTransitsMap));\n+            writeTraversals(allTraversals, traversalsFilename);\n+            try {\n+                final String scaffoldsFileName = outputFilePrefix + \".scaffolds.fa.gz\";\n+                writeTraversals(createScaffolds(allTraversals), scaffoldsFileName);\n+            } catch ( final AssemblyTooComplexException x ) {\n+                logger.warn(\"Assembly too complex for scaffolding.\");\n+            }\n+        } catch ( final AssemblyTooComplexException x ) {\n+            logger.warn(\"Assembly too complex.  Writing contigs as traversals in \" +\n+                    traversalsFilename + \".\");\n+            final Collection<Traversal> contigTraversals = new ArrayList<>(contigs.size());\n+            for ( final Contig contig : contigs ) {\n+                contigTraversals.add(new Traversal(Collections.singletonList(contig)));\n+            }\n+            writeTraversals(contigTraversals, traversalsFilename);\n+        }\n+\n+        contigs.sort(Comparator.comparingInt(ContigImpl::getId));\n+        writeDOT(contigs, outputFilePrefix + \".assembly.dot\");\n+        writeContigs(contigs, outputFilePrefix + \".contigs.txt.gz\");\n+        writePaths(readPaths, outputFilePrefix + \".paths.txt.gz\");\n+        writeReads(reads, outputFilePrefix + \".reads.fastq.gz\");\n+        return null;\n+    }\n+\n+    /** trim read pairs of base calls that have gone past the end of a short fragment */\n+    private void trimOverruns( final GATKRead read, final GATKRead mate ) {\n+        // if both mapped and they're on different strands\n+        if ( !read.isUnmapped() && !mate.isUnmapped() &&\n+                read.isReverseStrand() != mate.isReverseStrand() ) {\n+            // and both start within 1 base on the ref\n+            if ( Math.abs(read.getStart() - read.getMateStart()) <= 1 ) {\n+                // and both end within 1 base\n+                final int readRefLen = read.getCigar().getReferenceLength();\n+                final int mateRefLen = mate.getCigar().getReferenceLength();\n+                if ( Math.abs(readRefLen - mateRefLen) <= 1 ) {\n+                    if ( mate.isReverseStrand() ) {\n+                        trimClips(read, mate);\n+                    } else {\n+                        trimClips(mate, read);\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    private void trimClips( final GATKRead fwd, final GATKRead rev ) {\n+        final List<CigarElement> fwdElements = fwd.getCigarElements();\n+        final List<CigarElement> revElements = rev.getCigarElements();\n+        final int lastElementIdx = fwdElements.size() - 1;\n+        final CigarElement fwdLastElement = fwdElements.get(lastElementIdx);\n+        final CigarElement revFirstElement = revElements.get(0);\n+        if ( fwdLastElement.getOperator() == CigarOperator.S &&\n+                revFirstElement.getOperator() == CigarOperator.S ) {\n+            final byte[] fwdBases = fwd.getBasesNoCopy();\n+            final int lastElementLen = fwdLastElement.getLength();\n+            fwd.setBases(Arrays.copyOfRange(fwdBases, 0, fwdBases.length - lastElementLen));\n+            final byte[] fwdQuals = fwd.getBaseQualitiesNoCopy();\n+            if ( fwdQuals.length > 0 ) {\n+                final int qualsLen = fwdQuals.length - lastElementLen;\n+                fwd.setBaseQualities(Arrays.copyOfRange(fwdQuals, 0, qualsLen));\n+            }\n+            final List<CigarElement> newFwdElements = new ArrayList<>(fwdElements);\n+            newFwdElements.set(lastElementIdx, new CigarElement(lastElementLen, CigarOperator.H));\n+            fwd.setCigar(new Cigar(newFwdElements));\n+\n+            final byte[] revBases = rev.getBasesNoCopy();\n+            final int firstElementLen = revFirstElement.getLength();\n+            rev.setBases(Arrays.copyOfRange(revBases, firstElementLen, revBases.length));\n+            final byte[] revQuals = rev.getBaseQualitiesNoCopy();\n+            if ( revQuals.length > 0 ) {\n+                rev.setBaseQualities(Arrays.copyOfRange(revQuals, firstElementLen, revQuals.length));\n+            }\n+            final List<CigarElement> newRevElements = new ArrayList<>(revElements);\n+            newRevElements.set(0, new CigarElement(firstElementLen, CigarOperator.H));\n+            rev.setCigar(new Cigar(newRevElements));\n+        }\n+    }\n+\n+    @VisibleForTesting\n+    static void kmerizeReads( final List<GATKRead> reads,\n+                              final KmerSet<KmerAdjacency> kmerAdjacencySet ) {\n+        for ( final GATKRead read : reads ) {\n+            final byte[] calls = read.getBasesNoCopy();\n+            final byte[] quals = read.getBaseQualitiesNoCopy();\n+            KmerAdjacency.kmerize(calls, quals, QMIN, kmerAdjacencySet);\n+        }\n+    }\n+\n+    /** gather unbranched strings of kmers into contigs **/\n+    @VisibleForTesting\n+    static List<ContigImpl> buildContigs( final KmerSet<KmerAdjacency> kmerAdjacencySet ) {\n+        // gather strings of kmers that have a single predecessor and single successor into contigs\n+        final List<ContigImpl> contigs = new ArrayList<>();\n+        int nContigs = 0;\n+        for ( final KmerAdjacency kmerAdjacency : kmerAdjacencySet ) {\n+            if ( kmerAdjacency.getContig() == null ) {\n+                ContigImpl contig = null;\n+                final KmerAdjacency predecessor = kmerAdjacency.getSolePredecessor();\n+                if ( predecessor == null ||\n+                        predecessor.getSuccessorCount() > 1 ||\n+                        predecessor == kmerAdjacency.rc() ) {\n+                    contig = new ContigImpl(++nContigs, kmerAdjacency);\n+                } else {\n+                    final KmerAdjacency successor = kmerAdjacency.getSoleSuccessor();\n+                    if ( successor == null ||\n+                            successor.getPredecessorCount() > 1 ||\n+                            successor == kmerAdjacency.rc() ) {\n+                        contig = new ContigImpl(++nContigs, kmerAdjacency.rc());\n+                    }\n+                }\n+                if ( contig != null ) {\n+                    contigs.add(contig);\n+                }\n+            }\n+        }\n+\n+        // if there are smooth circles like a plasmid, gather them together as a contig, too\n+        for ( final KmerAdjacency kmerAdjacency : kmerAdjacencySet ) {\n+            if ( kmerAdjacency.getContig() == null ) {\n+                contigs.add(new ContigImpl(++nContigs, kmerAdjacency));\n+            }\n+        }\n+\n+        return contigs;\n+    }\n+\n+    /** connect contigs when the final kmer of one contig is adjacent to the inital contig of another **/\n+    @VisibleForTesting\n+    static void connectContigs( final List<ContigImpl> contigs ) {\n+        final int nContigs = contigs.size();\n+        final KmerSet<ContigEndKmer> contigEnds = new KmerSet<>(2*nContigs);\n+        for ( int contigId = 0; contigId != nContigs; ++contigId ) {\n+            final ContigImpl contig = contigs.get(contigId);\n+            final KmerAdjacency fwdKmer = contig.getFirstKmer();\n+            final KmerAdjacency revKmer = contig.getLastKmer().rc();\n+            if ( fwdKmer == revKmer ) {\n+                contigEnds.add(new ContigEndKmer(fwdKmer.getKVal(), contig, ContigOrientation.BOTH));\n+            } else {\n+                contigEnds.add(new ContigEndKmer(fwdKmer.getKVal(), contig, ContigOrientation.FWD));\n+                contigEnds.add(new ContigEndKmer(revKmer.getKVal(), contig, ContigOrientation.REV));\n+            }\n+        }\n+\n+        for ( int contigId = 0; contigId != nContigs; ++contigId ) {\n+            final Contig contig = contigs.get(contigId);\n+\n+            final KmerAdjacency start = contig.getFirstKmer();\n+            final int predecessorCount = start.getPredecessorCount();\n+            if ( predecessorCount > 0 ) {\n+                final List<Contig> predecessors = contig.getPredecessors();\n+                final int mask = start.getPredecessorMask();\n+                for ( int call = 0; call != 4; ++call ) {\n+                    if ( (mask & (1 << call)) != 0 ) {\n+                        final long kVal =\n+                                KmerAdjacency.reverseComplement(start.getPredecessorVal(call));\n+                        final ContigEndKmer contigEndKmer = contigEnds.find(new Kmer(kVal));\n+                        if ( contigEndKmer == null ) {\n+                            throw new GATKException(\"missing contig end kmer\");\n+                        }\n+                        switch ( contigEndKmer.getContigOrientation() ) {\n+                            case FWD:\n+                                predecessors.add(contigEndKmer.getContig().rc());\n+                                break;\n+                            case REV:\n+                                predecessors.add(contigEndKmer.getContig());\n+                                break;\n+                            case BOTH:\n+                                predecessors.add(contigEndKmer.getContig());\n+                                predecessors.add(contigEndKmer.getContig().rc());\n+                                break;\n+                        }\n+                    }\n+                }\n+            }\n+\n+            final KmerAdjacency end = contig.getLastKmer();\n+            final int successorCount = end.getSuccessorCount();\n+            if ( successorCount > 0 ) {\n+                final List<Contig> successors = contig.getSuccessors();\n+                final int mask = end.getSuccessorMask();\n+                for ( int call = 0; call != 4; ++call ) {\n+                    if ( (mask & (1 << call)) != 0 ) {\n+                        final long kVal = end.getSuccessorVal(call);\n+                        final ContigEndKmer contigEndKmer = contigEnds.find(new Kmer(kVal));\n+                        if ( contigEndKmer == null ) {\n+                            throw new GATKException(\"missing contig end kmer\");\n+                        }\n+                        switch ( contigEndKmer.getContigOrientation() ) {\n+                            case FWD:\n+                                successors.add(contigEndKmer.getContig());\n+                                break;\n+                            case REV:\n+                                successors.add(contigEndKmer.getContig().rc());\n+                                break;\n+                            case BOTH:\n+                                successors.add(contigEndKmer.getContig());\n+                                successors.add(contigEndKmer.getContig().rc());\n+                                break;\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    /** remove contigs that have little evidence **/\n+    @VisibleForTesting\n+    static void removeThinContigs( final List<ContigImpl> contigs,\n+                                           final KmerSet<KmerAdjacency> kmerAdjacencySet ) {\n+        contigs.sort(Comparator.comparingInt(ContigImpl::getMaxObservations));\n+        boolean contigRemoved;\n+        do {\n+            // figure out which contigs are cut points\n+            // i.e., those contigs which, if removed, would result in a graph with more connected components\n+            final int nContigs = contigs.size();\n+            final Map<Contig, CutData> cutDataMap = new HashMap<>(nContigs * 3);\n+\n+            for ( final ContigImpl contig : contigs ) {\n+                if ( cutDataMap.containsKey(contig) ) {\n+                    continue;\n+                }\n+\n+                cutDataMap.put(contig, new CutData());\n+                int children = 0;\n+                for ( final Contig nextContig : contig.getSuccessors() ) {\n+                    if ( !cutDataMap.containsKey(nextContig) ) {\n+                        findCuts(nextContig, contig, cutDataMap);\n+                        children += 1;\n+                    }\n+                }\n+                for ( final Contig nextContig : contig.getPredecessors() ) {\n+                    if ( !cutDataMap.containsKey(nextContig) ) {\n+                        findCuts(nextContig, contig, cutDataMap);\n+                        children += 1;\n+                    }\n+                }\n+                if ( children >= 2 ) {\n+                    contig.setCut(true);\n+                }\n+            }\n+\n+            // remove poorly attested (low max observations) contigs, unless they are cut points\n+            contigRemoved = false;\n+            final Iterator<ContigImpl> itr = contigs.iterator();\n+            while ( itr.hasNext() ) {\n+                final Contig contig = itr.next();\n+                if ( contig.getMaxObservations() < MIN_THIN_OBS && !contig.isCut() ) {\n+                    unlinkContig(contig, kmerAdjacencySet);\n+                    itr.remove();\n+                    contigRemoved = true;\n+                    break;\n+                }\n+            }\n+        } while ( contigRemoved );\n+        contigs.sort(Comparator.comparingInt(ContigImpl::getId));\n+    }\n+\n+    private static CutData findCuts( final Contig contig,\n+                                     final Contig parent,\n+                                     final Map<Contig, CutData> cutDataMap ) {\n+        final CutData cutData = new CutData();\n+        cutDataMap.put(contig, cutData);\n+        for ( final Contig nextContig : contig.getSuccessors() ) {\n+            if ( nextContig == parent ) {\n+                continue;\n+            }\n+            CutData nextCutData = cutDataMap.get(nextContig);\n+            if ( nextCutData != null ) {\n+                cutData.minVisitNum = Math.min(cutData.minVisitNum, nextCutData.visitNum);\n+            } else {\n+                nextCutData = findCuts(nextContig, contig, cutDataMap);\n+                cutData.minVisitNum = Math.min(cutData.minVisitNum, nextCutData.minVisitNum);\n+                if ( nextCutData.minVisitNum >= cutData.visitNum ) {\n+                    contig.setCut(true);\n+                }\n+            }\n+        }\n+        for ( final Contig nextContig : contig.getPredecessors() ) {\n+            if ( nextContig == parent ) {\n+                continue;\n+            }\n+            CutData nextCutData = cutDataMap.get(nextContig);\n+            if ( nextCutData != null ) {\n+                cutData.minVisitNum = Math.min(cutData.minVisitNum, nextCutData.visitNum);\n+            } else {\n+                nextCutData = findCuts(nextContig, contig, cutDataMap);\n+                cutData.minVisitNum = Math.min(cutData.minVisitNum, nextCutData.minVisitNum);\n+                if ( nextCutData.minVisitNum >= cutData.visitNum ) {\n+                    contig.setCut(true);\n+                }\n+            }\n+        }\n+        return cutData;\n+    }\n+\n+    @VisibleForTesting\n+    static void unlinkContig( final Contig contig,\n+                                      final KmerSet<KmerAdjacency> kmerAdjacencySet ) {\n+        final KmerAdjacency firstKmer = contig.getFirstKmer();\n+        final int firstKmerFinalCall = firstKmer.getFinalCall();\n+        for ( final Contig predecessor : contig.getPredecessors() ) {\n+            if ( predecessor != contig && predecessor != contig.rc() ) {\n+                predecessor.getLastKmer().removeSuccessor(firstKmerFinalCall, kmerAdjacencySet);\n+                if ( !predecessor.getSuccessors().remove(contig) ) {\n+                    throw new GATKException(\"failed to find predecessor link\");\n+                }\n+            }\n+        }\n+\n+        final KmerAdjacency lastKmer = contig.getLastKmer();\n+        final int lastKmerInitialCall = lastKmer.getInitialCall();\n+        for ( final Contig successor : contig.getSuccessors() ) {\n+            if ( successor != contig && successor != contig.rc() ) {\n+                successor.getFirstKmer().removePredecessor(lastKmerInitialCall, kmerAdjacencySet);\n+                if ( !successor.getPredecessors().remove(contig) ) {\n+                    throw new GATKException(\"failed to find successor link\");\n+                }\n+            }\n+        }\n+\n+        KmerAdjacency nextKmer = firstKmer;\n+        KmerAdjacency kmer;\n+        do {\n+            kmer = nextKmer;\n+            nextKmer = kmer.getSoleSuccessor();\n+            kmerAdjacencySet.remove(kmer.canonical());\n+        } while ( kmer != lastKmer );\n+    }\n+\n+    private static void updateKmerContig( final KmerAdjacency firstKmer,\n+                                          final KmerAdjacency lastKmer,\n+                                          final Contig contig ) {\n+        int offset = 0;\n+        for ( KmerAdjacency kmer = firstKmer; kmer != lastKmer; kmer = kmer.getSoleSuccessor() ) {\n+            if ( kmer == null ) {\n+                throw new GATKException(\"contig does not have a flat pipeline of kmers\");\n+            }\n+            kmer.clearContig();\n+            kmer.setContigOffset(contig, offset++);\n+        }\n+        lastKmer.clearContig();\n+        lastKmer.setContigOffset(contig, offset);\n+        if ( offset + Kmer.KSIZE != contig.size() ) {\n+            throw new GATKException(\"kmer chain length does not equal contig size\");\n+        }\n+    }\n+\n+    /** replace adjacent contigs without branches with a single, larger contig **/\n+    @VisibleForTesting\n+    static void weldPipes( final List<ContigImpl> contigs ) {\n+        for ( int contigIdx = 0; contigIdx != contigs.size(); ++contigIdx ) {\n+            final ContigImpl contig = contigs.get(contigIdx);\n+            if ( contig.getSuccessors().size() == 1 ) {\n+                final Contig successor = contig.getSuccessors().get(0);\n+                if ( successor != contig && successor != contig.rc() &&\n+                        successor.getPredecessors().size() == 1 ) {\n+                    contigs.set(contigIdx, join(contig.getId(), contig, successor));\n+                    if ( !contigs.remove(successor.canonical()) ) {\n+                        throw new GATKException(\"successor linkage is messed up\");\n+                    }\n+                    contigIdx -= 1; // reconsider the new contig -- there might be more joining possible\n+                    continue;\n+                }\n+            }\n+            if ( contig.getPredecessors().size() == 1 ) {\n+                final Contig predecessor = contig.getPredecessors().get(0);\n+                if ( predecessor != contig && predecessor != contig.rc() &&\n+                        predecessor.getSuccessors().size() == 1 ) {\n+                    contigs.set(contigIdx, join(contig.getId(), predecessor, contig));\n+                    if ( !contigs.remove(predecessor.canonical()) ) {\n+                        throw new GATKException(\"predecessor linkage is messed up\");\n+                    }\n+                    contigIdx -= 1; // reconsider\n+                }\n+            }\n+        }\n+    }\n+\n+    private static ContigImpl join( final int id, final Contig predecessor, final Contig successor ) {\n+        if ( !checkOverlap(predecessor.getSequence(), successor.getSequence()) ) {\n+                throw new GATKException(\"sequences can't be joined\");\n+        }\n+        final ContigImpl joinedContig = new ContigImpl(id, predecessor, successor);\n+        updateKmerContig(joinedContig.getFirstKmer(), joinedContig.getLastKmer(), joinedContig);\n+        return joinedContig;\n+    }\n+\n+    private static boolean checkOverlap( final CharSequence seq1, final CharSequence seq2 ) {\n+        final int seq1Len = seq1.length();\n+        final CharSequence seq1SubSeq = seq1.subSequence(seq1Len - Kmer.KSIZE + 1, seq1Len);\n+        final CharSequence seq2SubSeq = seq2.subSequence(0, Kmer.KSIZE - 1);\n+        return seq1SubSeq.equals(seq2SubSeq);\n+    }\n+\n+    /** set a unique componentId for every connected group of contigs **/\n+    @VisibleForTesting\n+    static int markComponents( final List<ContigImpl> contigs ) {\n+        for ( final ContigImpl contig : contigs ) {\n+            contig.setComponentId(0);\n+        }\n+\n+        int componentId = 0;\n+        for ( final ContigImpl contig : contigs ) {\n+            if ( contig.getComponentId() == 0 ) {\n+                contig.setComponentId(++componentId);\n+                markSuccessorComponents(contig);\n+                markSuccessorComponents(contig.rc());\n+            }\n+        }\n+        return componentId;\n+    }\n+\n+    private static void markSuccessorComponents( final Contig contig ) {\n+        final int componentId = contig.getComponentId();\n+        for ( final Contig successor : contig.getSuccessors() ) {\n+            if ( successor.getComponentId() == 0 ) {\n+                successor.canonical().setComponentId(componentId);\n+                markSuccessorComponents(successor);\n+                markSuccessorComponents(successor.rc());\n+            }\n+        }\n+    }\n+\n+    @VisibleForTesting\n+    static void markCycles( final List<ContigImpl> contigs ) {\n+        for ( final Contig contig : contigs ) {\n+            contig.setCyclic(false);\n+        }\n+\n+        final int nContigs = contigs.size();\n+        final Deque<Contig> deque = new ArrayDeque<>(nContigs);\n+        final Map<Contig, CutData> cutDataMap = new HashMap<>(nContigs * 3);\n+        for ( final Contig contig : contigs ) {\n+            if ( !cutDataMap.containsKey(contig) ) {\n+                markCyclesRecursion(contig, deque, cutDataMap);\n+            }\n+        }\n+    }\n+\n+    private static CutData markCyclesRecursion( final Contig contig,\n+                                                final Deque<Contig> deque,\n+                                                final Map<Contig, CutData> cutDataMap ) {\n+        final CutData cutData = new CutData();\n+        cutDataMap.put(contig, cutData);\n+        deque.addFirst(contig);\n+\n+        for ( final Contig successor : contig.getSuccessors() ) {\n+            final CutData successorCutData = cutDataMap.get(successor);\n+            if ( successorCutData == null ) {\n+                final int recursionVisitNum =\n+                        markCyclesRecursion(successor, deque, cutDataMap).minVisitNum;\n+                cutData.minVisitNum = Math.min(cutData.minVisitNum, recursionVisitNum);\n+            } else {\n+                cutData.minVisitNum = Math.min(cutData.minVisitNum, successorCutData.visitNum);\n+            }\n+        }\n+\n+        if ( cutData.visitNum == cutData.minVisitNum ) {\n+            Contig tig = deque.removeFirst();\n+            if ( tig == contig ) {\n+                cutDataMap.get(tig).visitNum = Integer.MAX_VALUE;\n+\n+                // single-vertex component -- cyclic only if self-referential\n+                if ( tig.getSuccessors().contains(tig) ) {\n+                    tig.setCyclic(true);\n+                }\n+            } else {\n+                while ( true ) {\n+                    // kill cross-links\n+                    cutDataMap.get(tig).visitNum = Integer.MAX_VALUE;\n+                    tig.setCyclic(true);\n+                    if ( tig == contig ) break;\n+                    tig = deque.removeFirst();\n+                }\n+            }\n+        }\n+        return cutData;\n+    }\n+\n+    @VisibleForTesting\n+    static boolean fillGaps( final KmerSet<KmerAdjacency> kmerAdjacencySet,\n+                             final List<GATKRead> reads ) {\n+        final Map<String, Integer> gapFillCounts = new HashMap<>();\n+        for ( final GATKRead read : reads ) {\n+            final Path path = new Path(read.getBasesNoCopy(), kmerAdjacencySet);\n+            final List<PathPart> parts = path.getParts();\n+            final int lastIdx = parts.size() - 1;\n+            for ( int idx = 1; idx < lastIdx; ++idx ) {\n+                final PathPart pathPart = parts.get(idx);\n+                if ( pathPart.isGap() ) {\n+                    final char prevCall = parts.get(idx - 1).getLastCall();\n+                    final char nextCall = parts.get(idx + 1).getFirstCall();\n+                    String gapFill = prevCall + pathPart.getSequence().toString() + nextCall;\n+                    final SequenceRC gapFillRC = new SequenceRC(gapFill);\n+                    if ( gapFillRC.compareTo(gapFill) < 0 ) {\n+                        gapFill = gapFillRC.toString();\n+                    }\n+                    gapFillCounts.merge(gapFill, 1, Integer::sum);\n+                }\n+            }\n+        }\n+\n+        boolean newKmers = false;\n+        for ( final Map.Entry<String, Integer> entry : gapFillCounts.entrySet() ) {\n+            final int nObservations = entry.getValue();\n+            if ( nObservations >= MIN_GAPFILL_COUNT ) {\n+                KmerAdjacency.kmerize(entry.getKey(), nObservations, kmerAdjacencySet);\n+                newKmers = true;\n+            }\n+        }\n+\n+        if ( newKmers ) {\n+            for ( final KmerAdjacency kmerAdjacency : kmerAdjacencySet ) {\n+                kmerAdjacency.clearContig();\n+            }\n+        }\n+        return newKmers;\n+    }\n+\n+    @VisibleForTesting\n+    static List<Path> pathReads( final KmerSet<KmerAdjacency> kmerAdjacencySet,\n+                          final List<GATKRead> reads ) {\n+        final List<Path> readPaths = new ArrayList<>(reads.size());\n+        for ( final GATKRead read : reads ) {\n+            readPaths.add(new Path(read.getBasesNoCopy(), kmerAdjacencySet));\n+        }\n+        return readPaths;\n+    }\n+\n+    @VisibleForTesting\n+    static Map<Contig,List<TransitPairCount>> collectTransitPairCounts(\n+            final List<ContigImpl> contigs,\n+            final List<Path> readPaths ) {\n+        final Map<Contig,List<TransitPairCount>> contigTransitsMap =\n+                new HashMap<>(3 * contigs.size());\n+        for ( final Path path : readPaths ) {\n+            final List<PathPart> parts = path.getParts();\n+            final int lastPart = parts.size() - 1;\n+            for ( int partIdx = 1; partIdx < lastPart; ++partIdx ) {\n+                final Contig prevContig = parts.get(partIdx - 1).getContig();\n+                if ( prevContig == null ) continue;\n+                final Contig curContig = parts.get(partIdx).getContig();\n+                if ( curContig == null ) {\n+                    partIdx += 1;\n+                    continue;\n+                }\n+                final Contig nextContig = parts.get(partIdx + 1).getContig();\n+                if ( nextContig == null ) {\n+                    partIdx += 2;\n+                    continue;\n+                }\n+                final TransitPairCount tpc = new TransitPairCount(prevContig, nextContig);\n+                final List<TransitPairCount> tpcList =\n+                        contigTransitsMap.computeIfAbsent(curContig, tig -> new ArrayList<>(4));\n+                final int idx = tpcList.indexOf(tpc);\n+                if ( idx != -1 ) {\n+                    tpcList.get(idx).observe();\n+                } else {\n+                    tpcList.add(tpc);\n+                    contigTransitsMap.computeIfAbsent(curContig.rc(), tig -> new ArrayList<>(4))\n+                            .add(tpc.getRC());\n+                }\n+            }\n+        }\n+        return contigTransitsMap;\n+    }\n+\n+    @VisibleForTesting\n+    static Set<Traversal> traverseAllPaths(\n+            final List<ContigImpl> contigs,\n+            final List<Path> readPaths,\n+            final Map<Contig, List<TransitPairCount>> contigTransitsMap ) {\n+        final Set<Traversal> traversalSet = new HashSet<>();\n+        final List<Contig> contigsList = new ArrayList<>();\n+        for ( final Contig contig : contigs ) {\n+            // untransited contigs are sources, sinks, or large contigs that can't be crossed by a read\n+            // build traversals from these\n+            if ( !contigTransitsMap.containsKey(contig) ) {\n+                boolean done = false;\n+                for ( final Contig successor : contig.getSuccessors() ) {\n+                    traverse(successor, contig,\n+                            contigsList, readPaths, contigTransitsMap, traversalSet);\n+                    done = true;\n+                }\n+                for ( final Contig predecessor : contig.getPredecessors() ) {\n+                    traverse(predecessor.rc(), contig.rc(),\n+                            contigsList, readPaths, contigTransitsMap, traversalSet);\n+                    done = true;\n+                }\n+                if ( !done ) { // if there were no predecessors or successors, it stands alone\n+                    addTraversal(new Traversal(Collections.singletonList(contig)), traversalSet);\n+                }\n+            }\n+        }\n+\n+        // look for transits that haven't been traced\n+        for ( final Map.Entry<Contig, List<TransitPairCount>> entry :\n+                contigTransitsMap.entrySet() ) {\n+            for ( final TransitPairCount tpc : entry.getValue() ) {\n+                if ( tpc.getCount() > 0 ) {\n+                    tpc.resetCount();\n+                    final Contig contig = entry.getKey();\n+                    final Set<Traversal> fwdTraversalSet = new HashSet<>();\n+                    traverse(tpc.getNextContig(), contig,\n+                            contigsList, readPaths, contigTransitsMap, fwdTraversalSet);\n+                    final Set<Traversal> revTraversalSet = new HashSet<>();\n+                    traverse(tpc.getPrevContig().rc(), contig.rc(),\n+                            contigsList, readPaths, contigTransitsMap, revTraversalSet);\n+                    for ( final Traversal revTraversal : revTraversalSet ) {\n+                        final Traversal revTraversalRC = revTraversal.rc();\n+                        for ( final Traversal fwdTraversal : fwdTraversalSet ) {\n+                            final int overlap =\n+                                    findMaxOverlap(revTraversalRC.getContigs(), fwdTraversal.getContigs());\n+                            final Traversal combo =\n+                                    Traversal.combineOverlappers(revTraversalRC, fwdTraversal, overlap);\n+                            addTraversal(combo, traversalSet);\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+\n+        return traversalSet;\n+    }\n+\n+    private static int findMaxOverlap( final List<Contig> prefixes, final List<Contig> suffixes ) {\n+        final int nPrefixes = prefixes.size();\n+        final Contig firstSuffix = suffixes.get(0);\n+        if ( !firstSuffix.isCyclic() ) {\n+            return prefixes.get(nPrefixes - 1) == firstSuffix ? 1 : 0;\n+        }\n+        final int nSuffixes = suffixes.size();\n+        for ( int prefixIdx = Math.max(0, nPrefixes - nSuffixes); prefixIdx != nPrefixes; ++prefixIdx ) {\n+            if ( prefixes.get(prefixIdx) == firstSuffix ) {\n+                int suffixIdx = 1;\n+                boolean match = true;\n+                for ( int prefixIdx2 = prefixIdx + 1; prefixIdx2 != nPrefixes; ++prefixIdx2 ) {\n+                    if ( prefixes.get(prefixIdx2) != suffixes.get(suffixIdx++) ) {\n+                        match = false;\n+                        break;\n+                    }\n+                }\n+                if ( match ) {\n+                    return nPrefixes - prefixIdx;\n+                }\n+            }\n+        }\n+        return 0;\n+    }\n+\n+    private static void traverse( final Contig contig,\n+                                  final Contig predecessor,\n+                                  final List<Contig> contigsList,\n+                                  final List<Path> readPaths,\n+                                  final Map<Contig, List<TransitPairCount>> contigTransitsMap,\n+                                  final Set<Traversal> traversalSet ) {\n+        contigsList.add(predecessor);\n+        if ( contig.isCyclic() ) {\n+            traverseCycle(contig, contigsList, readPaths, contigTransitsMap, traversalSet);\n+            contigsList.remove(contigsList.size() - 1);\n+            return;\n+        }\n+        final List<TransitPairCount> transits = contigTransitsMap.get(contig);\n+        boolean done = false;\n+        if ( transits != null ) {\n+            for ( final TransitPairCount tpc : transits ) {\n+                if ( tpc.getPrevContig() == predecessor ) {\n+                    final Contig successor = tpc.getNextContig();\n+                    if ( predecessor == contig.rc() ) {\n+                        final int nContigs = contigsList.size();\n+                        if ( nContigs > 1 ) {\n+                            if ( successor.rc() == contigsList.get(nContigs - 2) ) {\n+                                continue;\n+                            }\n+                        }\n+                    }\n+                    tpc.resetCount();\n+                    traverse(successor, contig, contigsList, readPaths, contigTransitsMap, traversalSet);\n+                    done = true;\n+                }\n+            }\n+        }\n+        if ( !done ) {\n+            contigsList.add(contig);\n+            addTraversal(new Traversal(contigsList), traversalSet);\n+            contigsList.remove(contigsList.size() - 1);\n+        }\n+        contigsList.remove(contigsList.size() - 1);\n+    }\n+\n+    private static void traverseCycle( final Contig contig,\n+                                       final List<Contig> contigsList,\n+                                       final List<Path> readPaths,\n+                                       final Map<Contig, List<TransitPairCount>> contigTransitsMap,\n+                                       final Set<Traversal> traversalSet ) {\n+        contigsList.add(contig);\n+        final int nContigs = contigsList.size();\n+        // the final element of the list is cyclic, if there's a previous element it will be\n+        // non-cyclic, so start there figuring out how far the read paths lead us\n+        final List<List<Contig>> longestPaths =\n+                findLongestPaths(contigsList.subList(Math.max(0, nContigs - 2), nContigs), readPaths);\n+        // didn't get anywhere -- just complete the traversal\n+        if ( longestPaths.isEmpty() ) {\n+            addTraversal(new Traversal(contigsList, true), traversalSet);\n+        } else {\n+            // for each unique extension into the cycle\n+            for ( final List<Contig> path : longestPaths ) {\n+                // don't think this can happen, but still\n+                if ( path.isEmpty() ) {\n+                    addTraversal(new Traversal(contigsList, true), traversalSet);\n+                    continue;\n+                }\n+                final List<Contig> extendedContigsList =\n+                        new ArrayList<>(contigsList.size() + path.size());\n+                extendedContigsList.addAll(contigsList);\n+                // if we didn't get out of the cycle\n+                if ( path.get(path.size() - 1).isCyclic() ) {\n+                    extendedContigsList.addAll(path);\n+                    addTraversal(new Traversal(extendedContigsList, true), traversalSet);\n+                } else {\n+                    // we found a cycle-exiting path, so extend that normally\n+                    for ( final Contig curContig : path ) {\n+                        if ( curContig.isCyclic() ) {\n+                            extendedContigsList.add(curContig);\n+                        } else {\n+                            final Contig prevContig =\n+                                    extendedContigsList.remove(extendedContigsList.size() - 1);\n+                            traverse(curContig, prevContig, extendedContigsList, readPaths,\n+                                    contigTransitsMap, traversalSet);\n+                            extendedContigsList.add(prevContig);\n+                            break;\n+                        }\n+                    }\n+                }\n+                clearTransitPairs(contigTransitsMap, extendedContigsList);\n+            }\n+        }\n+        contigsList.remove(contigsList.size() - 1);\n+    }\n+\n+    private static void clearTransitPairs(\n+            final Map<Contig, List<TransitPairCount>> contigTransitsMap,\n+            final List<Contig> contigsList ) {\n+        final int lastIdx = contigsList.size() - 1;\n+        for ( int idx = 1; idx < lastIdx; ++idx ) {\n+            final List<TransitPairCount> pairCounts = contigTransitsMap.get(contigsList.get(idx));\n+            if ( pairCounts != null ) {\n+                final Contig predecessor = contigsList.get(idx - 1);\n+                final Contig successor = contigsList.get(idx + 1);\n+                for ( final TransitPairCount tpc : pairCounts ) {\n+                    if ( tpc.getPrevContig() == predecessor && tpc.getNextContig() == successor ) {\n+                        tpc.resetCount();\n+                        break;\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    private static void addTraversal( final Traversal traversal,\n+                                      final Set<Traversal> traversalSet ) {\n+        if ( !traversalSet.contains(traversal.rc()) ) {\n+            traversalSet.add(traversal);\n+            if ( traversalSet.size() >= TOO_MANY_TRAVERSALS ) {\n+                throw new AssemblyTooComplexException();\n+            }\n+        }\n+    }\n+\n+    private static List<List<Contig>> findLongestPaths( final List<Contig> toMatch,\n+                                                        final List<Path> readPaths ) {\n+        final List<List<Contig>> results = new ArrayList<>();\n+        for ( final Path path : readPaths ) {\n+            testPath(path, toMatch, results);\n+            testPath(path.rc(), toMatch, results);\n+        }\n+        return results;\n+    }\n+\n+    private static void testPath( final Path path,\n+                                  final List<Contig> toMatch,\n+                                  final List<List<Contig>> results ) {\n+        final List<PathPart> pathParts = path.getParts();\n+        final int nPathParts = pathParts.size();\n+        final List<Contig> pathContigs = new ArrayList<>(nPathParts);\n+        pathParts.forEach(pp -> pathContigs.add(pp.getContig()));\n+        final int matchIdx = Collections.indexOfSubList(pathContigs, toMatch);\n+        if ( matchIdx != -1 ) {\n+            final int suffixIdx = matchIdx + toMatch.size();\n+            if ( suffixIdx < nPathParts ) {\n+                resolveResult(grabParts(pathContigs, suffixIdx), results);\n+            }\n+        }\n+    }\n+\n+    private static List<Contig> grabParts( final List<Contig> pathContigs, final int suffixIdx ) {\n+        final int nPathContigs = pathContigs.size();\n+        Contig prev = pathContigs.get(suffixIdx - 1);\n+        final List<Contig> result = new ArrayList<>(nPathContigs - suffixIdx);\n+        for ( int idx = suffixIdx; idx != nPathContigs; ++idx ) {\n+            final Contig tig = pathContigs.get(idx);\n+            if ( tig == null || !prev.getSuccessors().contains(tig) ) break;\n+            result.add(tig);\n+            prev = tig;\n+        }\n+        return result;\n+    }\n+\n+    private static void resolveResult( final List<Contig> result,\n+                                       final List<List<Contig>> results ) {\n+        final int nResults = results.size();\n+        for ( int idx = 0; idx != nResults; ++idx ) {\n+            final List<Contig> test = results.get(idx);\n+            if ( isPrefix(result, test) ) return;\n+            if ( isPrefix(test, result) ) {\n+                results.set(idx, result);\n+                return;\n+            }\n+        }\n+        results.add(result);\n+    }\n+\n+    private static boolean isPrefix( final List<Contig> list1, final List<Contig> list2 ) {\n+        final int list1Size = list1.size();\n+        final int list2Size = list2.size();\n+        if ( list1Size > list2Size ) return false;\n+        for ( int idx = 0; idx != list1Size; ++idx ) {\n+            if ( list1.get(idx) != list2.get(idx) ) return false;\n+        }\n+        return true;\n+    }\n+\n+    @VisibleForTesting\n+    static Collection<Traversal> createScaffolds( final List<Traversal> allTraversals ) {\n+        removeTriviallyDifferentTraversals(allTraversals);\n+\n+        final int nTraversals = allTraversals.size();\n+        final Map<Contig, List<Integer>> traversalsByFirstContig = new HashMap<>(3 * nTraversals);\n+        for ( int idx = 0; idx != nTraversals; ++idx ) {\n+            final Traversal traversal = allTraversals.get(idx);\n+            traversalsByFirstContig.compute(traversal.getFirstContig(),\n+                    ( k, v ) -> v == null ? new ArrayList<>(3) : v).add(idx);\n+            final Traversal rcTraversal = traversal.rc();\n+            traversalsByFirstContig.compute(rcTraversal.getFirstContig(),\n+                    ( k, v ) -> v == null ? new ArrayList<>(3) : v).add(~idx);\n+        }\n+\n+        final List<Traversal> scaffolds = new ArrayList<>(nTraversals);\n+        final boolean[] touched = new boolean[nTraversals];\n+        for ( int idx = 0; idx != nTraversals; ++idx ) {\n+            if ( !touched[idx] ) {\n+                expandTraversal(idx, touched, traversalsByFirstContig, allTraversals, scaffolds);\n+            }\n+        }\n+        return scaffolds;\n+    }\n+\n+    private static void expandTraversal( final int traversalIdx,\n+                                         final boolean[] touched,\n+                                         final Map<Contig, List<Integer>> traversalsByFirstContig,\n+                                         final List<Traversal> allTraversals,\n+                                         final List<Traversal> scaffolds ) {\n+        final Traversal traversal = allTraversals.get(traversalIdx);\n+        touched[traversalIdx] = true;\n+        final List<Traversal> downExtensions = new ArrayList<>();\n+        final Set<Contig> startingContigSet = new HashSet<>();\n+        walkTraversals(traversal, touched, startingContigSet, traversalsByFirstContig,\n+                        allTraversals, downExtensions);\n+        final List<Traversal> upExtensions = new ArrayList<>();\n+        walkTraversals(traversal.rc(), touched, startingContigSet, traversalsByFirstContig,\n+                        allTraversals, upExtensions);\n+        for ( final Traversal down : downExtensions ) {\n+            for ( final Traversal up : upExtensions ) {\n+                if ( scaffolds.size() >= TOO_MANY_SCAFFOLDS ) {\n+                    throw new AssemblyTooComplexException();\n+                }\n+                scaffolds.add(Traversal.combineOverlappers(up.rc(), down, traversal.getContigs().size()));\n+            }\n+        }\n+    }\n+\n+    private static void walkTraversals( final Traversal traversal,\n+                                        final boolean[] touched,\n+                                        final Set<Contig> startingContigSet,\n+                                        final Map<Contig, List<Integer>> traversalsByFirstContig,\n+                                        final List<Traversal> allTraversals,\n+                                        final List<Traversal> extensions ) {\n+        final Contig firstContig = traversal.getFirstContig();\n+        final List<Integer> indexList;\n+        if ( startingContigSet.contains(firstContig) ||\n+                traversal.isInextensible() ||\n+                (indexList = traversalsByFirstContig.get(traversal.getLastContig())) == null ) {\n+            extensions.add(traversal);\n+            return;\n+        }\n+        startingContigSet.add(firstContig);\n+        for ( int idx : indexList ) {\n+            final Traversal extension;\n+            if ( idx >= 0 ) {\n+                extension = allTraversals.get(idx);\n+                touched[idx] = true;\n+            } else {\n+                final int rcIdx = ~idx;\n+                extension = allTraversals.get(rcIdx).rc();\n+                touched[rcIdx] = true;\n+            }\n+            walkTraversals(Traversal.combine(traversal, extension), touched, startingContigSet,\n+                            traversalsByFirstContig, allTraversals, extensions );\n+        }\n+        startingContigSet.remove(firstContig);\n+    }\n+\n+    private static void removeTriviallyDifferentTraversals(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e2201c1ef4f8ba71f17e169f07756cfe2f1ecb49"}, "originalPosition": 1010}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxNDg5NTI0OQ==", "bodyText": "What you say is true (that we won't detect as trivially different Traversals that don't start and end at the same place).  But it isn't anything to worry about:  We're just trying to reduce the number of sequences that need to be aligned and searched for SVs.  We don't have to be exhaustively thorough.  I couldn't dream up a way to be more thorough that wasn't computationally much more complex.  The other thing is that the usual pattern is: large contig, pair of bubbles, large contig, pair of bubbles, large contig, etc.  So as a practical matter, I think this usually works pretty well.\nDamn fine catch, though.", "url": "https://github.com/broadinstitute/gatk/pull/6989#discussion_r614895249", "createdAt": "2021-04-16T14:45:00Z", "author": {"login": "tedsharpe"}, "path": "src/main/java/org/broadinstitute/hellbender/tools/LocalAssembler.java", "diffHunk": "@@ -0,0 +1,2306 @@\n+package org.broadinstitute.hellbender.tools;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import htsjdk.samtools.Cigar;\n+import htsjdk.samtools.CigarElement;\n+import htsjdk.samtools.CigarOperator;\n+import htsjdk.samtools.SAMUtils;\n+import org.broadinstitute.barclay.argparser.Argument;\n+import org.broadinstitute.barclay.argparser.BetaFeature;\n+import org.broadinstitute.barclay.argparser.CommandLineProgramProperties;\n+import org.broadinstitute.barclay.help.DocumentedFeature;\n+import org.broadinstitute.hellbender.cmdline.StandardArgumentDefinitions;\n+import org.broadinstitute.hellbender.cmdline.programgroups.CoverageAnalysisProgramGroup;\n+import org.broadinstitute.hellbender.exceptions.GATKException;\n+import org.broadinstitute.hellbender.tools.walkers.PairWalker;\n+import org.broadinstitute.hellbender.utils.SimpleInterval;\n+import org.broadinstitute.hellbender.utils.collections.HopscotchSet;\n+import org.broadinstitute.hellbender.utils.gcs.BucketUtils;\n+import org.broadinstitute.hellbender.utils.read.GATKRead;\n+\n+import java.io.BufferedWriter;\n+import java.io.FileWriter;\n+import java.io.IOException;\n+import java.io.OutputStreamWriter;\n+import java.util.*;\n+import java.util.zip.GZIPOutputStream;\n+\n+@DocumentedFeature\n+@CommandLineProgramProperties(\n+        summary = \"experiment\",\n+        oneLineSummary = \"experiment\",\n+        usageExample = \"gatk LocalAssembler\",\n+        programGroup = CoverageAnalysisProgramGroup.class\n+)\n+@BetaFeature\n+public class LocalAssembler extends PairWalker {\n+    public static final byte QMIN = 25;\n+    public static final int MIN_THIN_OBS = 4;\n+    public static final int MIN_GAPFILL_COUNT = 3;\n+    public static final int TOO_MANY_TRAVERSALS = 100000;\n+    public static final int TOO_MANY_SCAFFOLDS = 50000;\n+    public static final int MIN_SV_SIZE = 50;\n+\n+    @Argument(fullName=StandardArgumentDefinitions.OUTPUT_LONG_NAME,\n+            shortName=StandardArgumentDefinitions.OUTPUT_SHORT_NAME,\n+            doc=\"Write outputs to this file name prefix\", optional = true)\n+    public static String output;\n+\n+    @Argument(fullName=\"assembly-name\", doc=\"name of assembly used as a prefix for traversal names\")\n+    public static String assemblyName;\n+\n+    private final List<GATKRead> reads = new ArrayList<>();\n+\n+    @Override public boolean requiresIntervals() { return true; }\n+\n+    @Override public void apply( final GATKRead read, final GATKRead mate ) {\n+        trimOverruns(read, mate);\n+        reads.add(read);\n+        reads.add(mate);\n+    }\n+\n+    @Override public void applyUnpaired( final GATKRead read ) {\n+        reads.add(read);\n+    }\n+\n+    @Override public Object onTraversalSuccess() {\n+        super.onTraversalSuccess(); // flush any incomplete pairs\n+\n+        final int regionSize = getTraversalIntervals().stream().mapToInt(SimpleInterval::size).sum();\n+        final KmerSet<KmerAdjacency> kmerAdjacencySet = new KmerSet<>(10 * regionSize);\n+        kmerizeReads(reads, kmerAdjacencySet);\n+        List<ContigImpl> contigs = buildContigs(kmerAdjacencySet);\n+        connectContigs(contigs);\n+\n+        removeThinContigs(contigs, kmerAdjacencySet);\n+        weldPipes(contigs);\n+        markComponents(contigs);\n+\n+        if ( fillGaps(kmerAdjacencySet, reads) ) {\n+            contigs = buildContigs(kmerAdjacencySet);\n+            connectContigs(contigs);\n+            removeThinContigs(contigs, kmerAdjacencySet);\n+            weldPipes(contigs);\n+            markComponents(contigs);\n+        }\n+\n+        markCycles(contigs);\n+\n+        final String outputFilePrefix = output != null ? output : assemblyName;\n+        final List<Path> readPaths = pathReads(kmerAdjacencySet, reads);\n+        final Map<Contig,List<TransitPairCount>> contigTransitsMap =\n+                collectTransitPairCounts(contigs, readPaths);\n+        final String traversalsFilename = outputFilePrefix + \".traversals.fa.gz\";\n+        try {\n+            final List<Traversal> allTraversals =\n+                    new ArrayList<>(traverseAllPaths(contigs, readPaths, contigTransitsMap));\n+            writeTraversals(allTraversals, traversalsFilename);\n+            try {\n+                final String scaffoldsFileName = outputFilePrefix + \".scaffolds.fa.gz\";\n+                writeTraversals(createScaffolds(allTraversals), scaffoldsFileName);\n+            } catch ( final AssemblyTooComplexException x ) {\n+                logger.warn(\"Assembly too complex for scaffolding.\");\n+            }\n+        } catch ( final AssemblyTooComplexException x ) {\n+            logger.warn(\"Assembly too complex.  Writing contigs as traversals in \" +\n+                    traversalsFilename + \".\");\n+            final Collection<Traversal> contigTraversals = new ArrayList<>(contigs.size());\n+            for ( final Contig contig : contigs ) {\n+                contigTraversals.add(new Traversal(Collections.singletonList(contig)));\n+            }\n+            writeTraversals(contigTraversals, traversalsFilename);\n+        }\n+\n+        contigs.sort(Comparator.comparingInt(ContigImpl::getId));\n+        writeDOT(contigs, outputFilePrefix + \".assembly.dot\");\n+        writeContigs(contigs, outputFilePrefix + \".contigs.txt.gz\");\n+        writePaths(readPaths, outputFilePrefix + \".paths.txt.gz\");\n+        writeReads(reads, outputFilePrefix + \".reads.fastq.gz\");\n+        return null;\n+    }\n+\n+    /** trim read pairs of base calls that have gone past the end of a short fragment */\n+    private void trimOverruns( final GATKRead read, final GATKRead mate ) {\n+        // if both mapped and they're on different strands\n+        if ( !read.isUnmapped() && !mate.isUnmapped() &&\n+                read.isReverseStrand() != mate.isReverseStrand() ) {\n+            // and both start within 1 base on the ref\n+            if ( Math.abs(read.getStart() - read.getMateStart()) <= 1 ) {\n+                // and both end within 1 base\n+                final int readRefLen = read.getCigar().getReferenceLength();\n+                final int mateRefLen = mate.getCigar().getReferenceLength();\n+                if ( Math.abs(readRefLen - mateRefLen) <= 1 ) {\n+                    if ( mate.isReverseStrand() ) {\n+                        trimClips(read, mate);\n+                    } else {\n+                        trimClips(mate, read);\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    private void trimClips( final GATKRead fwd, final GATKRead rev ) {\n+        final List<CigarElement> fwdElements = fwd.getCigarElements();\n+        final List<CigarElement> revElements = rev.getCigarElements();\n+        final int lastElementIdx = fwdElements.size() - 1;\n+        final CigarElement fwdLastElement = fwdElements.get(lastElementIdx);\n+        final CigarElement revFirstElement = revElements.get(0);\n+        if ( fwdLastElement.getOperator() == CigarOperator.S &&\n+                revFirstElement.getOperator() == CigarOperator.S ) {\n+            final byte[] fwdBases = fwd.getBasesNoCopy();\n+            final int lastElementLen = fwdLastElement.getLength();\n+            fwd.setBases(Arrays.copyOfRange(fwdBases, 0, fwdBases.length - lastElementLen));\n+            final byte[] fwdQuals = fwd.getBaseQualitiesNoCopy();\n+            if ( fwdQuals.length > 0 ) {\n+                final int qualsLen = fwdQuals.length - lastElementLen;\n+                fwd.setBaseQualities(Arrays.copyOfRange(fwdQuals, 0, qualsLen));\n+            }\n+            final List<CigarElement> newFwdElements = new ArrayList<>(fwdElements);\n+            newFwdElements.set(lastElementIdx, new CigarElement(lastElementLen, CigarOperator.H));\n+            fwd.setCigar(new Cigar(newFwdElements));\n+\n+            final byte[] revBases = rev.getBasesNoCopy();\n+            final int firstElementLen = revFirstElement.getLength();\n+            rev.setBases(Arrays.copyOfRange(revBases, firstElementLen, revBases.length));\n+            final byte[] revQuals = rev.getBaseQualitiesNoCopy();\n+            if ( revQuals.length > 0 ) {\n+                rev.setBaseQualities(Arrays.copyOfRange(revQuals, firstElementLen, revQuals.length));\n+            }\n+            final List<CigarElement> newRevElements = new ArrayList<>(revElements);\n+            newRevElements.set(0, new CigarElement(firstElementLen, CigarOperator.H));\n+            rev.setCigar(new Cigar(newRevElements));\n+        }\n+    }\n+\n+    @VisibleForTesting\n+    static void kmerizeReads( final List<GATKRead> reads,\n+                              final KmerSet<KmerAdjacency> kmerAdjacencySet ) {\n+        for ( final GATKRead read : reads ) {\n+            final byte[] calls = read.getBasesNoCopy();\n+            final byte[] quals = read.getBaseQualitiesNoCopy();\n+            KmerAdjacency.kmerize(calls, quals, QMIN, kmerAdjacencySet);\n+        }\n+    }\n+\n+    /** gather unbranched strings of kmers into contigs **/\n+    @VisibleForTesting\n+    static List<ContigImpl> buildContigs( final KmerSet<KmerAdjacency> kmerAdjacencySet ) {\n+        // gather strings of kmers that have a single predecessor and single successor into contigs\n+        final List<ContigImpl> contigs = new ArrayList<>();\n+        int nContigs = 0;\n+        for ( final KmerAdjacency kmerAdjacency : kmerAdjacencySet ) {\n+            if ( kmerAdjacency.getContig() == null ) {\n+                ContigImpl contig = null;\n+                final KmerAdjacency predecessor = kmerAdjacency.getSolePredecessor();\n+                if ( predecessor == null ||\n+                        predecessor.getSuccessorCount() > 1 ||\n+                        predecessor == kmerAdjacency.rc() ) {\n+                    contig = new ContigImpl(++nContigs, kmerAdjacency);\n+                } else {\n+                    final KmerAdjacency successor = kmerAdjacency.getSoleSuccessor();\n+                    if ( successor == null ||\n+                            successor.getPredecessorCount() > 1 ||\n+                            successor == kmerAdjacency.rc() ) {\n+                        contig = new ContigImpl(++nContigs, kmerAdjacency.rc());\n+                    }\n+                }\n+                if ( contig != null ) {\n+                    contigs.add(contig);\n+                }\n+            }\n+        }\n+\n+        // if there are smooth circles like a plasmid, gather them together as a contig, too\n+        for ( final KmerAdjacency kmerAdjacency : kmerAdjacencySet ) {\n+            if ( kmerAdjacency.getContig() == null ) {\n+                contigs.add(new ContigImpl(++nContigs, kmerAdjacency));\n+            }\n+        }\n+\n+        return contigs;\n+    }\n+\n+    /** connect contigs when the final kmer of one contig is adjacent to the inital contig of another **/\n+    @VisibleForTesting\n+    static void connectContigs( final List<ContigImpl> contigs ) {\n+        final int nContigs = contigs.size();\n+        final KmerSet<ContigEndKmer> contigEnds = new KmerSet<>(2*nContigs);\n+        for ( int contigId = 0; contigId != nContigs; ++contigId ) {\n+            final ContigImpl contig = contigs.get(contigId);\n+            final KmerAdjacency fwdKmer = contig.getFirstKmer();\n+            final KmerAdjacency revKmer = contig.getLastKmer().rc();\n+            if ( fwdKmer == revKmer ) {\n+                contigEnds.add(new ContigEndKmer(fwdKmer.getKVal(), contig, ContigOrientation.BOTH));\n+            } else {\n+                contigEnds.add(new ContigEndKmer(fwdKmer.getKVal(), contig, ContigOrientation.FWD));\n+                contigEnds.add(new ContigEndKmer(revKmer.getKVal(), contig, ContigOrientation.REV));\n+            }\n+        }\n+\n+        for ( int contigId = 0; contigId != nContigs; ++contigId ) {\n+            final Contig contig = contigs.get(contigId);\n+\n+            final KmerAdjacency start = contig.getFirstKmer();\n+            final int predecessorCount = start.getPredecessorCount();\n+            if ( predecessorCount > 0 ) {\n+                final List<Contig> predecessors = contig.getPredecessors();\n+                final int mask = start.getPredecessorMask();\n+                for ( int call = 0; call != 4; ++call ) {\n+                    if ( (mask & (1 << call)) != 0 ) {\n+                        final long kVal =\n+                                KmerAdjacency.reverseComplement(start.getPredecessorVal(call));\n+                        final ContigEndKmer contigEndKmer = contigEnds.find(new Kmer(kVal));\n+                        if ( contigEndKmer == null ) {\n+                            throw new GATKException(\"missing contig end kmer\");\n+                        }\n+                        switch ( contigEndKmer.getContigOrientation() ) {\n+                            case FWD:\n+                                predecessors.add(contigEndKmer.getContig().rc());\n+                                break;\n+                            case REV:\n+                                predecessors.add(contigEndKmer.getContig());\n+                                break;\n+                            case BOTH:\n+                                predecessors.add(contigEndKmer.getContig());\n+                                predecessors.add(contigEndKmer.getContig().rc());\n+                                break;\n+                        }\n+                    }\n+                }\n+            }\n+\n+            final KmerAdjacency end = contig.getLastKmer();\n+            final int successorCount = end.getSuccessorCount();\n+            if ( successorCount > 0 ) {\n+                final List<Contig> successors = contig.getSuccessors();\n+                final int mask = end.getSuccessorMask();\n+                for ( int call = 0; call != 4; ++call ) {\n+                    if ( (mask & (1 << call)) != 0 ) {\n+                        final long kVal = end.getSuccessorVal(call);\n+                        final ContigEndKmer contigEndKmer = contigEnds.find(new Kmer(kVal));\n+                        if ( contigEndKmer == null ) {\n+                            throw new GATKException(\"missing contig end kmer\");\n+                        }\n+                        switch ( contigEndKmer.getContigOrientation() ) {\n+                            case FWD:\n+                                successors.add(contigEndKmer.getContig());\n+                                break;\n+                            case REV:\n+                                successors.add(contigEndKmer.getContig().rc());\n+                                break;\n+                            case BOTH:\n+                                successors.add(contigEndKmer.getContig());\n+                                successors.add(contigEndKmer.getContig().rc());\n+                                break;\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    /** remove contigs that have little evidence **/\n+    @VisibleForTesting\n+    static void removeThinContigs( final List<ContigImpl> contigs,\n+                                           final KmerSet<KmerAdjacency> kmerAdjacencySet ) {\n+        contigs.sort(Comparator.comparingInt(ContigImpl::getMaxObservations));\n+        boolean contigRemoved;\n+        do {\n+            // figure out which contigs are cut points\n+            // i.e., those contigs which, if removed, would result in a graph with more connected components\n+            final int nContigs = contigs.size();\n+            final Map<Contig, CutData> cutDataMap = new HashMap<>(nContigs * 3);\n+\n+            for ( final ContigImpl contig : contigs ) {\n+                if ( cutDataMap.containsKey(contig) ) {\n+                    continue;\n+                }\n+\n+                cutDataMap.put(contig, new CutData());\n+                int children = 0;\n+                for ( final Contig nextContig : contig.getSuccessors() ) {\n+                    if ( !cutDataMap.containsKey(nextContig) ) {\n+                        findCuts(nextContig, contig, cutDataMap);\n+                        children += 1;\n+                    }\n+                }\n+                for ( final Contig nextContig : contig.getPredecessors() ) {\n+                    if ( !cutDataMap.containsKey(nextContig) ) {\n+                        findCuts(nextContig, contig, cutDataMap);\n+                        children += 1;\n+                    }\n+                }\n+                if ( children >= 2 ) {\n+                    contig.setCut(true);\n+                }\n+            }\n+\n+            // remove poorly attested (low max observations) contigs, unless they are cut points\n+            contigRemoved = false;\n+            final Iterator<ContigImpl> itr = contigs.iterator();\n+            while ( itr.hasNext() ) {\n+                final Contig contig = itr.next();\n+                if ( contig.getMaxObservations() < MIN_THIN_OBS && !contig.isCut() ) {\n+                    unlinkContig(contig, kmerAdjacencySet);\n+                    itr.remove();\n+                    contigRemoved = true;\n+                    break;\n+                }\n+            }\n+        } while ( contigRemoved );\n+        contigs.sort(Comparator.comparingInt(ContigImpl::getId));\n+    }\n+\n+    private static CutData findCuts( final Contig contig,\n+                                     final Contig parent,\n+                                     final Map<Contig, CutData> cutDataMap ) {\n+        final CutData cutData = new CutData();\n+        cutDataMap.put(contig, cutData);\n+        for ( final Contig nextContig : contig.getSuccessors() ) {\n+            if ( nextContig == parent ) {\n+                continue;\n+            }\n+            CutData nextCutData = cutDataMap.get(nextContig);\n+            if ( nextCutData != null ) {\n+                cutData.minVisitNum = Math.min(cutData.minVisitNum, nextCutData.visitNum);\n+            } else {\n+                nextCutData = findCuts(nextContig, contig, cutDataMap);\n+                cutData.minVisitNum = Math.min(cutData.minVisitNum, nextCutData.minVisitNum);\n+                if ( nextCutData.minVisitNum >= cutData.visitNum ) {\n+                    contig.setCut(true);\n+                }\n+            }\n+        }\n+        for ( final Contig nextContig : contig.getPredecessors() ) {\n+            if ( nextContig == parent ) {\n+                continue;\n+            }\n+            CutData nextCutData = cutDataMap.get(nextContig);\n+            if ( nextCutData != null ) {\n+                cutData.minVisitNum = Math.min(cutData.minVisitNum, nextCutData.visitNum);\n+            } else {\n+                nextCutData = findCuts(nextContig, contig, cutDataMap);\n+                cutData.minVisitNum = Math.min(cutData.minVisitNum, nextCutData.minVisitNum);\n+                if ( nextCutData.minVisitNum >= cutData.visitNum ) {\n+                    contig.setCut(true);\n+                }\n+            }\n+        }\n+        return cutData;\n+    }\n+\n+    @VisibleForTesting\n+    static void unlinkContig( final Contig contig,\n+                                      final KmerSet<KmerAdjacency> kmerAdjacencySet ) {\n+        final KmerAdjacency firstKmer = contig.getFirstKmer();\n+        final int firstKmerFinalCall = firstKmer.getFinalCall();\n+        for ( final Contig predecessor : contig.getPredecessors() ) {\n+            if ( predecessor != contig && predecessor != contig.rc() ) {\n+                predecessor.getLastKmer().removeSuccessor(firstKmerFinalCall, kmerAdjacencySet);\n+                if ( !predecessor.getSuccessors().remove(contig) ) {\n+                    throw new GATKException(\"failed to find predecessor link\");\n+                }\n+            }\n+        }\n+\n+        final KmerAdjacency lastKmer = contig.getLastKmer();\n+        final int lastKmerInitialCall = lastKmer.getInitialCall();\n+        for ( final Contig successor : contig.getSuccessors() ) {\n+            if ( successor != contig && successor != contig.rc() ) {\n+                successor.getFirstKmer().removePredecessor(lastKmerInitialCall, kmerAdjacencySet);\n+                if ( !successor.getPredecessors().remove(contig) ) {\n+                    throw new GATKException(\"failed to find successor link\");\n+                }\n+            }\n+        }\n+\n+        KmerAdjacency nextKmer = firstKmer;\n+        KmerAdjacency kmer;\n+        do {\n+            kmer = nextKmer;\n+            nextKmer = kmer.getSoleSuccessor();\n+            kmerAdjacencySet.remove(kmer.canonical());\n+        } while ( kmer != lastKmer );\n+    }\n+\n+    private static void updateKmerContig( final KmerAdjacency firstKmer,\n+                                          final KmerAdjacency lastKmer,\n+                                          final Contig contig ) {\n+        int offset = 0;\n+        for ( KmerAdjacency kmer = firstKmer; kmer != lastKmer; kmer = kmer.getSoleSuccessor() ) {\n+            if ( kmer == null ) {\n+                throw new GATKException(\"contig does not have a flat pipeline of kmers\");\n+            }\n+            kmer.clearContig();\n+            kmer.setContigOffset(contig, offset++);\n+        }\n+        lastKmer.clearContig();\n+        lastKmer.setContigOffset(contig, offset);\n+        if ( offset + Kmer.KSIZE != contig.size() ) {\n+            throw new GATKException(\"kmer chain length does not equal contig size\");\n+        }\n+    }\n+\n+    /** replace adjacent contigs without branches with a single, larger contig **/\n+    @VisibleForTesting\n+    static void weldPipes( final List<ContigImpl> contigs ) {\n+        for ( int contigIdx = 0; contigIdx != contigs.size(); ++contigIdx ) {\n+            final ContigImpl contig = contigs.get(contigIdx);\n+            if ( contig.getSuccessors().size() == 1 ) {\n+                final Contig successor = contig.getSuccessors().get(0);\n+                if ( successor != contig && successor != contig.rc() &&\n+                        successor.getPredecessors().size() == 1 ) {\n+                    contigs.set(contigIdx, join(contig.getId(), contig, successor));\n+                    if ( !contigs.remove(successor.canonical()) ) {\n+                        throw new GATKException(\"successor linkage is messed up\");\n+                    }\n+                    contigIdx -= 1; // reconsider the new contig -- there might be more joining possible\n+                    continue;\n+                }\n+            }\n+            if ( contig.getPredecessors().size() == 1 ) {\n+                final Contig predecessor = contig.getPredecessors().get(0);\n+                if ( predecessor != contig && predecessor != contig.rc() &&\n+                        predecessor.getSuccessors().size() == 1 ) {\n+                    contigs.set(contigIdx, join(contig.getId(), predecessor, contig));\n+                    if ( !contigs.remove(predecessor.canonical()) ) {\n+                        throw new GATKException(\"predecessor linkage is messed up\");\n+                    }\n+                    contigIdx -= 1; // reconsider\n+                }\n+            }\n+        }\n+    }\n+\n+    private static ContigImpl join( final int id, final Contig predecessor, final Contig successor ) {\n+        if ( !checkOverlap(predecessor.getSequence(), successor.getSequence()) ) {\n+                throw new GATKException(\"sequences can't be joined\");\n+        }\n+        final ContigImpl joinedContig = new ContigImpl(id, predecessor, successor);\n+        updateKmerContig(joinedContig.getFirstKmer(), joinedContig.getLastKmer(), joinedContig);\n+        return joinedContig;\n+    }\n+\n+    private static boolean checkOverlap( final CharSequence seq1, final CharSequence seq2 ) {\n+        final int seq1Len = seq1.length();\n+        final CharSequence seq1SubSeq = seq1.subSequence(seq1Len - Kmer.KSIZE + 1, seq1Len);\n+        final CharSequence seq2SubSeq = seq2.subSequence(0, Kmer.KSIZE - 1);\n+        return seq1SubSeq.equals(seq2SubSeq);\n+    }\n+\n+    /** set a unique componentId for every connected group of contigs **/\n+    @VisibleForTesting\n+    static int markComponents( final List<ContigImpl> contigs ) {\n+        for ( final ContigImpl contig : contigs ) {\n+            contig.setComponentId(0);\n+        }\n+\n+        int componentId = 0;\n+        for ( final ContigImpl contig : contigs ) {\n+            if ( contig.getComponentId() == 0 ) {\n+                contig.setComponentId(++componentId);\n+                markSuccessorComponents(contig);\n+                markSuccessorComponents(contig.rc());\n+            }\n+        }\n+        return componentId;\n+    }\n+\n+    private static void markSuccessorComponents( final Contig contig ) {\n+        final int componentId = contig.getComponentId();\n+        for ( final Contig successor : contig.getSuccessors() ) {\n+            if ( successor.getComponentId() == 0 ) {\n+                successor.canonical().setComponentId(componentId);\n+                markSuccessorComponents(successor);\n+                markSuccessorComponents(successor.rc());\n+            }\n+        }\n+    }\n+\n+    @VisibleForTesting\n+    static void markCycles( final List<ContigImpl> contigs ) {\n+        for ( final Contig contig : contigs ) {\n+            contig.setCyclic(false);\n+        }\n+\n+        final int nContigs = contigs.size();\n+        final Deque<Contig> deque = new ArrayDeque<>(nContigs);\n+        final Map<Contig, CutData> cutDataMap = new HashMap<>(nContigs * 3);\n+        for ( final Contig contig : contigs ) {\n+            if ( !cutDataMap.containsKey(contig) ) {\n+                markCyclesRecursion(contig, deque, cutDataMap);\n+            }\n+        }\n+    }\n+\n+    private static CutData markCyclesRecursion( final Contig contig,\n+                                                final Deque<Contig> deque,\n+                                                final Map<Contig, CutData> cutDataMap ) {\n+        final CutData cutData = new CutData();\n+        cutDataMap.put(contig, cutData);\n+        deque.addFirst(contig);\n+\n+        for ( final Contig successor : contig.getSuccessors() ) {\n+            final CutData successorCutData = cutDataMap.get(successor);\n+            if ( successorCutData == null ) {\n+                final int recursionVisitNum =\n+                        markCyclesRecursion(successor, deque, cutDataMap).minVisitNum;\n+                cutData.minVisitNum = Math.min(cutData.minVisitNum, recursionVisitNum);\n+            } else {\n+                cutData.minVisitNum = Math.min(cutData.minVisitNum, successorCutData.visitNum);\n+            }\n+        }\n+\n+        if ( cutData.visitNum == cutData.minVisitNum ) {\n+            Contig tig = deque.removeFirst();\n+            if ( tig == contig ) {\n+                cutDataMap.get(tig).visitNum = Integer.MAX_VALUE;\n+\n+                // single-vertex component -- cyclic only if self-referential\n+                if ( tig.getSuccessors().contains(tig) ) {\n+                    tig.setCyclic(true);\n+                }\n+            } else {\n+                while ( true ) {\n+                    // kill cross-links\n+                    cutDataMap.get(tig).visitNum = Integer.MAX_VALUE;\n+                    tig.setCyclic(true);\n+                    if ( tig == contig ) break;\n+                    tig = deque.removeFirst();\n+                }\n+            }\n+        }\n+        return cutData;\n+    }\n+\n+    @VisibleForTesting\n+    static boolean fillGaps( final KmerSet<KmerAdjacency> kmerAdjacencySet,\n+                             final List<GATKRead> reads ) {\n+        final Map<String, Integer> gapFillCounts = new HashMap<>();\n+        for ( final GATKRead read : reads ) {\n+            final Path path = new Path(read.getBasesNoCopy(), kmerAdjacencySet);\n+            final List<PathPart> parts = path.getParts();\n+            final int lastIdx = parts.size() - 1;\n+            for ( int idx = 1; idx < lastIdx; ++idx ) {\n+                final PathPart pathPart = parts.get(idx);\n+                if ( pathPart.isGap() ) {\n+                    final char prevCall = parts.get(idx - 1).getLastCall();\n+                    final char nextCall = parts.get(idx + 1).getFirstCall();\n+                    String gapFill = prevCall + pathPart.getSequence().toString() + nextCall;\n+                    final SequenceRC gapFillRC = new SequenceRC(gapFill);\n+                    if ( gapFillRC.compareTo(gapFill) < 0 ) {\n+                        gapFill = gapFillRC.toString();\n+                    }\n+                    gapFillCounts.merge(gapFill, 1, Integer::sum);\n+                }\n+            }\n+        }\n+\n+        boolean newKmers = false;\n+        for ( final Map.Entry<String, Integer> entry : gapFillCounts.entrySet() ) {\n+            final int nObservations = entry.getValue();\n+            if ( nObservations >= MIN_GAPFILL_COUNT ) {\n+                KmerAdjacency.kmerize(entry.getKey(), nObservations, kmerAdjacencySet);\n+                newKmers = true;\n+            }\n+        }\n+\n+        if ( newKmers ) {\n+            for ( final KmerAdjacency kmerAdjacency : kmerAdjacencySet ) {\n+                kmerAdjacency.clearContig();\n+            }\n+        }\n+        return newKmers;\n+    }\n+\n+    @VisibleForTesting\n+    static List<Path> pathReads( final KmerSet<KmerAdjacency> kmerAdjacencySet,\n+                          final List<GATKRead> reads ) {\n+        final List<Path> readPaths = new ArrayList<>(reads.size());\n+        for ( final GATKRead read : reads ) {\n+            readPaths.add(new Path(read.getBasesNoCopy(), kmerAdjacencySet));\n+        }\n+        return readPaths;\n+    }\n+\n+    @VisibleForTesting\n+    static Map<Contig,List<TransitPairCount>> collectTransitPairCounts(\n+            final List<ContigImpl> contigs,\n+            final List<Path> readPaths ) {\n+        final Map<Contig,List<TransitPairCount>> contigTransitsMap =\n+                new HashMap<>(3 * contigs.size());\n+        for ( final Path path : readPaths ) {\n+            final List<PathPart> parts = path.getParts();\n+            final int lastPart = parts.size() - 1;\n+            for ( int partIdx = 1; partIdx < lastPart; ++partIdx ) {\n+                final Contig prevContig = parts.get(partIdx - 1).getContig();\n+                if ( prevContig == null ) continue;\n+                final Contig curContig = parts.get(partIdx).getContig();\n+                if ( curContig == null ) {\n+                    partIdx += 1;\n+                    continue;\n+                }\n+                final Contig nextContig = parts.get(partIdx + 1).getContig();\n+                if ( nextContig == null ) {\n+                    partIdx += 2;\n+                    continue;\n+                }\n+                final TransitPairCount tpc = new TransitPairCount(prevContig, nextContig);\n+                final List<TransitPairCount> tpcList =\n+                        contigTransitsMap.computeIfAbsent(curContig, tig -> new ArrayList<>(4));\n+                final int idx = tpcList.indexOf(tpc);\n+                if ( idx != -1 ) {\n+                    tpcList.get(idx).observe();\n+                } else {\n+                    tpcList.add(tpc);\n+                    contigTransitsMap.computeIfAbsent(curContig.rc(), tig -> new ArrayList<>(4))\n+                            .add(tpc.getRC());\n+                }\n+            }\n+        }\n+        return contigTransitsMap;\n+    }\n+\n+    @VisibleForTesting\n+    static Set<Traversal> traverseAllPaths(\n+            final List<ContigImpl> contigs,\n+            final List<Path> readPaths,\n+            final Map<Contig, List<TransitPairCount>> contigTransitsMap ) {\n+        final Set<Traversal> traversalSet = new HashSet<>();\n+        final List<Contig> contigsList = new ArrayList<>();\n+        for ( final Contig contig : contigs ) {\n+            // untransited contigs are sources, sinks, or large contigs that can't be crossed by a read\n+            // build traversals from these\n+            if ( !contigTransitsMap.containsKey(contig) ) {\n+                boolean done = false;\n+                for ( final Contig successor : contig.getSuccessors() ) {\n+                    traverse(successor, contig,\n+                            contigsList, readPaths, contigTransitsMap, traversalSet);\n+                    done = true;\n+                }\n+                for ( final Contig predecessor : contig.getPredecessors() ) {\n+                    traverse(predecessor.rc(), contig.rc(),\n+                            contigsList, readPaths, contigTransitsMap, traversalSet);\n+                    done = true;\n+                }\n+                if ( !done ) { // if there were no predecessors or successors, it stands alone\n+                    addTraversal(new Traversal(Collections.singletonList(contig)), traversalSet);\n+                }\n+            }\n+        }\n+\n+        // look for transits that haven't been traced\n+        for ( final Map.Entry<Contig, List<TransitPairCount>> entry :\n+                contigTransitsMap.entrySet() ) {\n+            for ( final TransitPairCount tpc : entry.getValue() ) {\n+                if ( tpc.getCount() > 0 ) {\n+                    tpc.resetCount();\n+                    final Contig contig = entry.getKey();\n+                    final Set<Traversal> fwdTraversalSet = new HashSet<>();\n+                    traverse(tpc.getNextContig(), contig,\n+                            contigsList, readPaths, contigTransitsMap, fwdTraversalSet);\n+                    final Set<Traversal> revTraversalSet = new HashSet<>();\n+                    traverse(tpc.getPrevContig().rc(), contig.rc(),\n+                            contigsList, readPaths, contigTransitsMap, revTraversalSet);\n+                    for ( final Traversal revTraversal : revTraversalSet ) {\n+                        final Traversal revTraversalRC = revTraversal.rc();\n+                        for ( final Traversal fwdTraversal : fwdTraversalSet ) {\n+                            final int overlap =\n+                                    findMaxOverlap(revTraversalRC.getContigs(), fwdTraversal.getContigs());\n+                            final Traversal combo =\n+                                    Traversal.combineOverlappers(revTraversalRC, fwdTraversal, overlap);\n+                            addTraversal(combo, traversalSet);\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+\n+        return traversalSet;\n+    }\n+\n+    private static int findMaxOverlap( final List<Contig> prefixes, final List<Contig> suffixes ) {\n+        final int nPrefixes = prefixes.size();\n+        final Contig firstSuffix = suffixes.get(0);\n+        if ( !firstSuffix.isCyclic() ) {\n+            return prefixes.get(nPrefixes - 1) == firstSuffix ? 1 : 0;\n+        }\n+        final int nSuffixes = suffixes.size();\n+        for ( int prefixIdx = Math.max(0, nPrefixes - nSuffixes); prefixIdx != nPrefixes; ++prefixIdx ) {\n+            if ( prefixes.get(prefixIdx) == firstSuffix ) {\n+                int suffixIdx = 1;\n+                boolean match = true;\n+                for ( int prefixIdx2 = prefixIdx + 1; prefixIdx2 != nPrefixes; ++prefixIdx2 ) {\n+                    if ( prefixes.get(prefixIdx2) != suffixes.get(suffixIdx++) ) {\n+                        match = false;\n+                        break;\n+                    }\n+                }\n+                if ( match ) {\n+                    return nPrefixes - prefixIdx;\n+                }\n+            }\n+        }\n+        return 0;\n+    }\n+\n+    private static void traverse( final Contig contig,\n+                                  final Contig predecessor,\n+                                  final List<Contig> contigsList,\n+                                  final List<Path> readPaths,\n+                                  final Map<Contig, List<TransitPairCount>> contigTransitsMap,\n+                                  final Set<Traversal> traversalSet ) {\n+        contigsList.add(predecessor);\n+        if ( contig.isCyclic() ) {\n+            traverseCycle(contig, contigsList, readPaths, contigTransitsMap, traversalSet);\n+            contigsList.remove(contigsList.size() - 1);\n+            return;\n+        }\n+        final List<TransitPairCount> transits = contigTransitsMap.get(contig);\n+        boolean done = false;\n+        if ( transits != null ) {\n+            for ( final TransitPairCount tpc : transits ) {\n+                if ( tpc.getPrevContig() == predecessor ) {\n+                    final Contig successor = tpc.getNextContig();\n+                    if ( predecessor == contig.rc() ) {\n+                        final int nContigs = contigsList.size();\n+                        if ( nContigs > 1 ) {\n+                            if ( successor.rc() == contigsList.get(nContigs - 2) ) {\n+                                continue;\n+                            }\n+                        }\n+                    }\n+                    tpc.resetCount();\n+                    traverse(successor, contig, contigsList, readPaths, contigTransitsMap, traversalSet);\n+                    done = true;\n+                }\n+            }\n+        }\n+        if ( !done ) {\n+            contigsList.add(contig);\n+            addTraversal(new Traversal(contigsList), traversalSet);\n+            contigsList.remove(contigsList.size() - 1);\n+        }\n+        contigsList.remove(contigsList.size() - 1);\n+    }\n+\n+    private static void traverseCycle( final Contig contig,\n+                                       final List<Contig> contigsList,\n+                                       final List<Path> readPaths,\n+                                       final Map<Contig, List<TransitPairCount>> contigTransitsMap,\n+                                       final Set<Traversal> traversalSet ) {\n+        contigsList.add(contig);\n+        final int nContigs = contigsList.size();\n+        // the final element of the list is cyclic, if there's a previous element it will be\n+        // non-cyclic, so start there figuring out how far the read paths lead us\n+        final List<List<Contig>> longestPaths =\n+                findLongestPaths(contigsList.subList(Math.max(0, nContigs - 2), nContigs), readPaths);\n+        // didn't get anywhere -- just complete the traversal\n+        if ( longestPaths.isEmpty() ) {\n+            addTraversal(new Traversal(contigsList, true), traversalSet);\n+        } else {\n+            // for each unique extension into the cycle\n+            for ( final List<Contig> path : longestPaths ) {\n+                // don't think this can happen, but still\n+                if ( path.isEmpty() ) {\n+                    addTraversal(new Traversal(contigsList, true), traversalSet);\n+                    continue;\n+                }\n+                final List<Contig> extendedContigsList =\n+                        new ArrayList<>(contigsList.size() + path.size());\n+                extendedContigsList.addAll(contigsList);\n+                // if we didn't get out of the cycle\n+                if ( path.get(path.size() - 1).isCyclic() ) {\n+                    extendedContigsList.addAll(path);\n+                    addTraversal(new Traversal(extendedContigsList, true), traversalSet);\n+                } else {\n+                    // we found a cycle-exiting path, so extend that normally\n+                    for ( final Contig curContig : path ) {\n+                        if ( curContig.isCyclic() ) {\n+                            extendedContigsList.add(curContig);\n+                        } else {\n+                            final Contig prevContig =\n+                                    extendedContigsList.remove(extendedContigsList.size() - 1);\n+                            traverse(curContig, prevContig, extendedContigsList, readPaths,\n+                                    contigTransitsMap, traversalSet);\n+                            extendedContigsList.add(prevContig);\n+                            break;\n+                        }\n+                    }\n+                }\n+                clearTransitPairs(contigTransitsMap, extendedContigsList);\n+            }\n+        }\n+        contigsList.remove(contigsList.size() - 1);\n+    }\n+\n+    private static void clearTransitPairs(\n+            final Map<Contig, List<TransitPairCount>> contigTransitsMap,\n+            final List<Contig> contigsList ) {\n+        final int lastIdx = contigsList.size() - 1;\n+        for ( int idx = 1; idx < lastIdx; ++idx ) {\n+            final List<TransitPairCount> pairCounts = contigTransitsMap.get(contigsList.get(idx));\n+            if ( pairCounts != null ) {\n+                final Contig predecessor = contigsList.get(idx - 1);\n+                final Contig successor = contigsList.get(idx + 1);\n+                for ( final TransitPairCount tpc : pairCounts ) {\n+                    if ( tpc.getPrevContig() == predecessor && tpc.getNextContig() == successor ) {\n+                        tpc.resetCount();\n+                        break;\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    private static void addTraversal( final Traversal traversal,\n+                                      final Set<Traversal> traversalSet ) {\n+        if ( !traversalSet.contains(traversal.rc()) ) {\n+            traversalSet.add(traversal);\n+            if ( traversalSet.size() >= TOO_MANY_TRAVERSALS ) {\n+                throw new AssemblyTooComplexException();\n+            }\n+        }\n+    }\n+\n+    private static List<List<Contig>> findLongestPaths( final List<Contig> toMatch,\n+                                                        final List<Path> readPaths ) {\n+        final List<List<Contig>> results = new ArrayList<>();\n+        for ( final Path path : readPaths ) {\n+            testPath(path, toMatch, results);\n+            testPath(path.rc(), toMatch, results);\n+        }\n+        return results;\n+    }\n+\n+    private static void testPath( final Path path,\n+                                  final List<Contig> toMatch,\n+                                  final List<List<Contig>> results ) {\n+        final List<PathPart> pathParts = path.getParts();\n+        final int nPathParts = pathParts.size();\n+        final List<Contig> pathContigs = new ArrayList<>(nPathParts);\n+        pathParts.forEach(pp -> pathContigs.add(pp.getContig()));\n+        final int matchIdx = Collections.indexOfSubList(pathContigs, toMatch);\n+        if ( matchIdx != -1 ) {\n+            final int suffixIdx = matchIdx + toMatch.size();\n+            if ( suffixIdx < nPathParts ) {\n+                resolveResult(grabParts(pathContigs, suffixIdx), results);\n+            }\n+        }\n+    }\n+\n+    private static List<Contig> grabParts( final List<Contig> pathContigs, final int suffixIdx ) {\n+        final int nPathContigs = pathContigs.size();\n+        Contig prev = pathContigs.get(suffixIdx - 1);\n+        final List<Contig> result = new ArrayList<>(nPathContigs - suffixIdx);\n+        for ( int idx = suffixIdx; idx != nPathContigs; ++idx ) {\n+            final Contig tig = pathContigs.get(idx);\n+            if ( tig == null || !prev.getSuccessors().contains(tig) ) break;\n+            result.add(tig);\n+            prev = tig;\n+        }\n+        return result;\n+    }\n+\n+    private static void resolveResult( final List<Contig> result,\n+                                       final List<List<Contig>> results ) {\n+        final int nResults = results.size();\n+        for ( int idx = 0; idx != nResults; ++idx ) {\n+            final List<Contig> test = results.get(idx);\n+            if ( isPrefix(result, test) ) return;\n+            if ( isPrefix(test, result) ) {\n+                results.set(idx, result);\n+                return;\n+            }\n+        }\n+        results.add(result);\n+    }\n+\n+    private static boolean isPrefix( final List<Contig> list1, final List<Contig> list2 ) {\n+        final int list1Size = list1.size();\n+        final int list2Size = list2.size();\n+        if ( list1Size > list2Size ) return false;\n+        for ( int idx = 0; idx != list1Size; ++idx ) {\n+            if ( list1.get(idx) != list2.get(idx) ) return false;\n+        }\n+        return true;\n+    }\n+\n+    @VisibleForTesting\n+    static Collection<Traversal> createScaffolds( final List<Traversal> allTraversals ) {\n+        removeTriviallyDifferentTraversals(allTraversals);\n+\n+        final int nTraversals = allTraversals.size();\n+        final Map<Contig, List<Integer>> traversalsByFirstContig = new HashMap<>(3 * nTraversals);\n+        for ( int idx = 0; idx != nTraversals; ++idx ) {\n+            final Traversal traversal = allTraversals.get(idx);\n+            traversalsByFirstContig.compute(traversal.getFirstContig(),\n+                    ( k, v ) -> v == null ? new ArrayList<>(3) : v).add(idx);\n+            final Traversal rcTraversal = traversal.rc();\n+            traversalsByFirstContig.compute(rcTraversal.getFirstContig(),\n+                    ( k, v ) -> v == null ? new ArrayList<>(3) : v).add(~idx);\n+        }\n+\n+        final List<Traversal> scaffolds = new ArrayList<>(nTraversals);\n+        final boolean[] touched = new boolean[nTraversals];\n+        for ( int idx = 0; idx != nTraversals; ++idx ) {\n+            if ( !touched[idx] ) {\n+                expandTraversal(idx, touched, traversalsByFirstContig, allTraversals, scaffolds);\n+            }\n+        }\n+        return scaffolds;\n+    }\n+\n+    private static void expandTraversal( final int traversalIdx,\n+                                         final boolean[] touched,\n+                                         final Map<Contig, List<Integer>> traversalsByFirstContig,\n+                                         final List<Traversal> allTraversals,\n+                                         final List<Traversal> scaffolds ) {\n+        final Traversal traversal = allTraversals.get(traversalIdx);\n+        touched[traversalIdx] = true;\n+        final List<Traversal> downExtensions = new ArrayList<>();\n+        final Set<Contig> startingContigSet = new HashSet<>();\n+        walkTraversals(traversal, touched, startingContigSet, traversalsByFirstContig,\n+                        allTraversals, downExtensions);\n+        final List<Traversal> upExtensions = new ArrayList<>();\n+        walkTraversals(traversal.rc(), touched, startingContigSet, traversalsByFirstContig,\n+                        allTraversals, upExtensions);\n+        for ( final Traversal down : downExtensions ) {\n+            for ( final Traversal up : upExtensions ) {\n+                if ( scaffolds.size() >= TOO_MANY_SCAFFOLDS ) {\n+                    throw new AssemblyTooComplexException();\n+                }\n+                scaffolds.add(Traversal.combineOverlappers(up.rc(), down, traversal.getContigs().size()));\n+            }\n+        }\n+    }\n+\n+    private static void walkTraversals( final Traversal traversal,\n+                                        final boolean[] touched,\n+                                        final Set<Contig> startingContigSet,\n+                                        final Map<Contig, List<Integer>> traversalsByFirstContig,\n+                                        final List<Traversal> allTraversals,\n+                                        final List<Traversal> extensions ) {\n+        final Contig firstContig = traversal.getFirstContig();\n+        final List<Integer> indexList;\n+        if ( startingContigSet.contains(firstContig) ||\n+                traversal.isInextensible() ||\n+                (indexList = traversalsByFirstContig.get(traversal.getLastContig())) == null ) {\n+            extensions.add(traversal);\n+            return;\n+        }\n+        startingContigSet.add(firstContig);\n+        for ( int idx : indexList ) {\n+            final Traversal extension;\n+            if ( idx >= 0 ) {\n+                extension = allTraversals.get(idx);\n+                touched[idx] = true;\n+            } else {\n+                final int rcIdx = ~idx;\n+                extension = allTraversals.get(rcIdx).rc();\n+                touched[rcIdx] = true;\n+            }\n+            walkTraversals(Traversal.combine(traversal, extension), touched, startingContigSet,\n+                            traversalsByFirstContig, allTraversals, extensions );\n+        }\n+        startingContigSet.remove(firstContig);\n+    }\n+\n+    private static void removeTriviallyDifferentTraversals(", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5Nzg5NTI5MQ=="}, "originalCommit": {"oid": "e2201c1ef4f8ba71f17e169f07756cfe2f1ecb49"}, "originalPosition": 1010}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzc3NjY5NjU2OnYy", "diffSide": "RIGHT", "path": "src/main/java/org/broadinstitute/hellbender/tools/LocalAssembler.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMy0xOVQxODo1MDowOFrOI6NS6Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNC0xNlQxNDowNTozNVrOJKYYCA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5NzkwNjE1Mw==", "bodyText": "Is it worth writing these loops out vs a one-liner like sb.append(predecessors.stream().map(Objects::toString).collect(Collectors.joining(\",\")));?", "url": "https://github.com/broadinstitute/gatk/pull/6989#discussion_r597906153", "createdAt": "2021-03-19T18:50:08Z", "author": {"login": "cwhelan"}, "path": "src/main/java/org/broadinstitute/hellbender/tools/LocalAssembler.java", "diffHunk": "@@ -0,0 +1,2306 @@\n+package org.broadinstitute.hellbender.tools;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import htsjdk.samtools.Cigar;\n+import htsjdk.samtools.CigarElement;\n+import htsjdk.samtools.CigarOperator;\n+import htsjdk.samtools.SAMUtils;\n+import org.broadinstitute.barclay.argparser.Argument;\n+import org.broadinstitute.barclay.argparser.BetaFeature;\n+import org.broadinstitute.barclay.argparser.CommandLineProgramProperties;\n+import org.broadinstitute.barclay.help.DocumentedFeature;\n+import org.broadinstitute.hellbender.cmdline.StandardArgumentDefinitions;\n+import org.broadinstitute.hellbender.cmdline.programgroups.CoverageAnalysisProgramGroup;\n+import org.broadinstitute.hellbender.exceptions.GATKException;\n+import org.broadinstitute.hellbender.tools.walkers.PairWalker;\n+import org.broadinstitute.hellbender.utils.SimpleInterval;\n+import org.broadinstitute.hellbender.utils.collections.HopscotchSet;\n+import org.broadinstitute.hellbender.utils.gcs.BucketUtils;\n+import org.broadinstitute.hellbender.utils.read.GATKRead;\n+\n+import java.io.BufferedWriter;\n+import java.io.FileWriter;\n+import java.io.IOException;\n+import java.io.OutputStreamWriter;\n+import java.util.*;\n+import java.util.zip.GZIPOutputStream;\n+\n+@DocumentedFeature\n+@CommandLineProgramProperties(\n+        summary = \"experiment\",\n+        oneLineSummary = \"experiment\",\n+        usageExample = \"gatk LocalAssembler\",\n+        programGroup = CoverageAnalysisProgramGroup.class\n+)\n+@BetaFeature\n+public class LocalAssembler extends PairWalker {\n+    public static final byte QMIN = 25;\n+    public static final int MIN_THIN_OBS = 4;\n+    public static final int MIN_GAPFILL_COUNT = 3;\n+    public static final int TOO_MANY_TRAVERSALS = 100000;\n+    public static final int TOO_MANY_SCAFFOLDS = 50000;\n+    public static final int MIN_SV_SIZE = 50;\n+\n+    @Argument(fullName=StandardArgumentDefinitions.OUTPUT_LONG_NAME,\n+            shortName=StandardArgumentDefinitions.OUTPUT_SHORT_NAME,\n+            doc=\"Write outputs to this file name prefix\", optional = true)\n+    public static String output;\n+\n+    @Argument(fullName=\"assembly-name\", doc=\"name of assembly used as a prefix for traversal names\")\n+    public static String assemblyName;\n+\n+    private final List<GATKRead> reads = new ArrayList<>();\n+\n+    @Override public boolean requiresIntervals() { return true; }\n+\n+    @Override public void apply( final GATKRead read, final GATKRead mate ) {\n+        trimOverruns(read, mate);\n+        reads.add(read);\n+        reads.add(mate);\n+    }\n+\n+    @Override public void applyUnpaired( final GATKRead read ) {\n+        reads.add(read);\n+    }\n+\n+    @Override public Object onTraversalSuccess() {\n+        super.onTraversalSuccess(); // flush any incomplete pairs\n+\n+        final int regionSize = getTraversalIntervals().stream().mapToInt(SimpleInterval::size).sum();\n+        final KmerSet<KmerAdjacency> kmerAdjacencySet = new KmerSet<>(10 * regionSize);\n+        kmerizeReads(reads, kmerAdjacencySet);\n+        List<ContigImpl> contigs = buildContigs(kmerAdjacencySet);\n+        connectContigs(contigs);\n+\n+        removeThinContigs(contigs, kmerAdjacencySet);\n+        weldPipes(contigs);\n+        markComponents(contigs);\n+\n+        if ( fillGaps(kmerAdjacencySet, reads) ) {\n+            contigs = buildContigs(kmerAdjacencySet);\n+            connectContigs(contigs);\n+            removeThinContigs(contigs, kmerAdjacencySet);\n+            weldPipes(contigs);\n+            markComponents(contigs);\n+        }\n+\n+        markCycles(contigs);\n+\n+        final String outputFilePrefix = output != null ? output : assemblyName;\n+        final List<Path> readPaths = pathReads(kmerAdjacencySet, reads);\n+        final Map<Contig,List<TransitPairCount>> contigTransitsMap =\n+                collectTransitPairCounts(contigs, readPaths);\n+        final String traversalsFilename = outputFilePrefix + \".traversals.fa.gz\";\n+        try {\n+            final List<Traversal> allTraversals =\n+                    new ArrayList<>(traverseAllPaths(contigs, readPaths, contigTransitsMap));\n+            writeTraversals(allTraversals, traversalsFilename);\n+            try {\n+                final String scaffoldsFileName = outputFilePrefix + \".scaffolds.fa.gz\";\n+                writeTraversals(createScaffolds(allTraversals), scaffoldsFileName);\n+            } catch ( final AssemblyTooComplexException x ) {\n+                logger.warn(\"Assembly too complex for scaffolding.\");\n+            }\n+        } catch ( final AssemblyTooComplexException x ) {\n+            logger.warn(\"Assembly too complex.  Writing contigs as traversals in \" +\n+                    traversalsFilename + \".\");\n+            final Collection<Traversal> contigTraversals = new ArrayList<>(contigs.size());\n+            for ( final Contig contig : contigs ) {\n+                contigTraversals.add(new Traversal(Collections.singletonList(contig)));\n+            }\n+            writeTraversals(contigTraversals, traversalsFilename);\n+        }\n+\n+        contigs.sort(Comparator.comparingInt(ContigImpl::getId));\n+        writeDOT(contigs, outputFilePrefix + \".assembly.dot\");\n+        writeContigs(contigs, outputFilePrefix + \".contigs.txt.gz\");\n+        writePaths(readPaths, outputFilePrefix + \".paths.txt.gz\");\n+        writeReads(reads, outputFilePrefix + \".reads.fastq.gz\");\n+        return null;\n+    }\n+\n+    /** trim read pairs of base calls that have gone past the end of a short fragment */\n+    private void trimOverruns( final GATKRead read, final GATKRead mate ) {\n+        // if both mapped and they're on different strands\n+        if ( !read.isUnmapped() && !mate.isUnmapped() &&\n+                read.isReverseStrand() != mate.isReverseStrand() ) {\n+            // and both start within 1 base on the ref\n+            if ( Math.abs(read.getStart() - read.getMateStart()) <= 1 ) {\n+                // and both end within 1 base\n+                final int readRefLen = read.getCigar().getReferenceLength();\n+                final int mateRefLen = mate.getCigar().getReferenceLength();\n+                if ( Math.abs(readRefLen - mateRefLen) <= 1 ) {\n+                    if ( mate.isReverseStrand() ) {\n+                        trimClips(read, mate);\n+                    } else {\n+                        trimClips(mate, read);\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    private void trimClips( final GATKRead fwd, final GATKRead rev ) {\n+        final List<CigarElement> fwdElements = fwd.getCigarElements();\n+        final List<CigarElement> revElements = rev.getCigarElements();\n+        final int lastElementIdx = fwdElements.size() - 1;\n+        final CigarElement fwdLastElement = fwdElements.get(lastElementIdx);\n+        final CigarElement revFirstElement = revElements.get(0);\n+        if ( fwdLastElement.getOperator() == CigarOperator.S &&\n+                revFirstElement.getOperator() == CigarOperator.S ) {\n+            final byte[] fwdBases = fwd.getBasesNoCopy();\n+            final int lastElementLen = fwdLastElement.getLength();\n+            fwd.setBases(Arrays.copyOfRange(fwdBases, 0, fwdBases.length - lastElementLen));\n+            final byte[] fwdQuals = fwd.getBaseQualitiesNoCopy();\n+            if ( fwdQuals.length > 0 ) {\n+                final int qualsLen = fwdQuals.length - lastElementLen;\n+                fwd.setBaseQualities(Arrays.copyOfRange(fwdQuals, 0, qualsLen));\n+            }\n+            final List<CigarElement> newFwdElements = new ArrayList<>(fwdElements);\n+            newFwdElements.set(lastElementIdx, new CigarElement(lastElementLen, CigarOperator.H));\n+            fwd.setCigar(new Cigar(newFwdElements));\n+\n+            final byte[] revBases = rev.getBasesNoCopy();\n+            final int firstElementLen = revFirstElement.getLength();\n+            rev.setBases(Arrays.copyOfRange(revBases, firstElementLen, revBases.length));\n+            final byte[] revQuals = rev.getBaseQualitiesNoCopy();\n+            if ( revQuals.length > 0 ) {\n+                rev.setBaseQualities(Arrays.copyOfRange(revQuals, firstElementLen, revQuals.length));\n+            }\n+            final List<CigarElement> newRevElements = new ArrayList<>(revElements);\n+            newRevElements.set(0, new CigarElement(firstElementLen, CigarOperator.H));\n+            rev.setCigar(new Cigar(newRevElements));\n+        }\n+    }\n+\n+    @VisibleForTesting\n+    static void kmerizeReads( final List<GATKRead> reads,\n+                              final KmerSet<KmerAdjacency> kmerAdjacencySet ) {\n+        for ( final GATKRead read : reads ) {\n+            final byte[] calls = read.getBasesNoCopy();\n+            final byte[] quals = read.getBaseQualitiesNoCopy();\n+            KmerAdjacency.kmerize(calls, quals, QMIN, kmerAdjacencySet);\n+        }\n+    }\n+\n+    /** gather unbranched strings of kmers into contigs **/\n+    @VisibleForTesting\n+    static List<ContigImpl> buildContigs( final KmerSet<KmerAdjacency> kmerAdjacencySet ) {\n+        // gather strings of kmers that have a single predecessor and single successor into contigs\n+        final List<ContigImpl> contigs = new ArrayList<>();\n+        int nContigs = 0;\n+        for ( final KmerAdjacency kmerAdjacency : kmerAdjacencySet ) {\n+            if ( kmerAdjacency.getContig() == null ) {\n+                ContigImpl contig = null;\n+                final KmerAdjacency predecessor = kmerAdjacency.getSolePredecessor();\n+                if ( predecessor == null ||\n+                        predecessor.getSuccessorCount() > 1 ||\n+                        predecessor == kmerAdjacency.rc() ) {\n+                    contig = new ContigImpl(++nContigs, kmerAdjacency);\n+                } else {\n+                    final KmerAdjacency successor = kmerAdjacency.getSoleSuccessor();\n+                    if ( successor == null ||\n+                            successor.getPredecessorCount() > 1 ||\n+                            successor == kmerAdjacency.rc() ) {\n+                        contig = new ContigImpl(++nContigs, kmerAdjacency.rc());\n+                    }\n+                }\n+                if ( contig != null ) {\n+                    contigs.add(contig);\n+                }\n+            }\n+        }\n+\n+        // if there are smooth circles like a plasmid, gather them together as a contig, too\n+        for ( final KmerAdjacency kmerAdjacency : kmerAdjacencySet ) {\n+            if ( kmerAdjacency.getContig() == null ) {\n+                contigs.add(new ContigImpl(++nContigs, kmerAdjacency));\n+            }\n+        }\n+\n+        return contigs;\n+    }\n+\n+    /** connect contigs when the final kmer of one contig is adjacent to the inital contig of another **/\n+    @VisibleForTesting\n+    static void connectContigs( final List<ContigImpl> contigs ) {\n+        final int nContigs = contigs.size();\n+        final KmerSet<ContigEndKmer> contigEnds = new KmerSet<>(2*nContigs);\n+        for ( int contigId = 0; contigId != nContigs; ++contigId ) {\n+            final ContigImpl contig = contigs.get(contigId);\n+            final KmerAdjacency fwdKmer = contig.getFirstKmer();\n+            final KmerAdjacency revKmer = contig.getLastKmer().rc();\n+            if ( fwdKmer == revKmer ) {\n+                contigEnds.add(new ContigEndKmer(fwdKmer.getKVal(), contig, ContigOrientation.BOTH));\n+            } else {\n+                contigEnds.add(new ContigEndKmer(fwdKmer.getKVal(), contig, ContigOrientation.FWD));\n+                contigEnds.add(new ContigEndKmer(revKmer.getKVal(), contig, ContigOrientation.REV));\n+            }\n+        }\n+\n+        for ( int contigId = 0; contigId != nContigs; ++contigId ) {\n+            final Contig contig = contigs.get(contigId);\n+\n+            final KmerAdjacency start = contig.getFirstKmer();\n+            final int predecessorCount = start.getPredecessorCount();\n+            if ( predecessorCount > 0 ) {\n+                final List<Contig> predecessors = contig.getPredecessors();\n+                final int mask = start.getPredecessorMask();\n+                for ( int call = 0; call != 4; ++call ) {\n+                    if ( (mask & (1 << call)) != 0 ) {\n+                        final long kVal =\n+                                KmerAdjacency.reverseComplement(start.getPredecessorVal(call));\n+                        final ContigEndKmer contigEndKmer = contigEnds.find(new Kmer(kVal));\n+                        if ( contigEndKmer == null ) {\n+                            throw new GATKException(\"missing contig end kmer\");\n+                        }\n+                        switch ( contigEndKmer.getContigOrientation() ) {\n+                            case FWD:\n+                                predecessors.add(contigEndKmer.getContig().rc());\n+                                break;\n+                            case REV:\n+                                predecessors.add(contigEndKmer.getContig());\n+                                break;\n+                            case BOTH:\n+                                predecessors.add(contigEndKmer.getContig());\n+                                predecessors.add(contigEndKmer.getContig().rc());\n+                                break;\n+                        }\n+                    }\n+                }\n+            }\n+\n+            final KmerAdjacency end = contig.getLastKmer();\n+            final int successorCount = end.getSuccessorCount();\n+            if ( successorCount > 0 ) {\n+                final List<Contig> successors = contig.getSuccessors();\n+                final int mask = end.getSuccessorMask();\n+                for ( int call = 0; call != 4; ++call ) {\n+                    if ( (mask & (1 << call)) != 0 ) {\n+                        final long kVal = end.getSuccessorVal(call);\n+                        final ContigEndKmer contigEndKmer = contigEnds.find(new Kmer(kVal));\n+                        if ( contigEndKmer == null ) {\n+                            throw new GATKException(\"missing contig end kmer\");\n+                        }\n+                        switch ( contigEndKmer.getContigOrientation() ) {\n+                            case FWD:\n+                                successors.add(contigEndKmer.getContig());\n+                                break;\n+                            case REV:\n+                                successors.add(contigEndKmer.getContig().rc());\n+                                break;\n+                            case BOTH:\n+                                successors.add(contigEndKmer.getContig());\n+                                successors.add(contigEndKmer.getContig().rc());\n+                                break;\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    /** remove contigs that have little evidence **/\n+    @VisibleForTesting\n+    static void removeThinContigs( final List<ContigImpl> contigs,\n+                                           final KmerSet<KmerAdjacency> kmerAdjacencySet ) {\n+        contigs.sort(Comparator.comparingInt(ContigImpl::getMaxObservations));\n+        boolean contigRemoved;\n+        do {\n+            // figure out which contigs are cut points\n+            // i.e., those contigs which, if removed, would result in a graph with more connected components\n+            final int nContigs = contigs.size();\n+            final Map<Contig, CutData> cutDataMap = new HashMap<>(nContigs * 3);\n+\n+            for ( final ContigImpl contig : contigs ) {\n+                if ( cutDataMap.containsKey(contig) ) {\n+                    continue;\n+                }\n+\n+                cutDataMap.put(contig, new CutData());\n+                int children = 0;\n+                for ( final Contig nextContig : contig.getSuccessors() ) {\n+                    if ( !cutDataMap.containsKey(nextContig) ) {\n+                        findCuts(nextContig, contig, cutDataMap);\n+                        children += 1;\n+                    }\n+                }\n+                for ( final Contig nextContig : contig.getPredecessors() ) {\n+                    if ( !cutDataMap.containsKey(nextContig) ) {\n+                        findCuts(nextContig, contig, cutDataMap);\n+                        children += 1;\n+                    }\n+                }\n+                if ( children >= 2 ) {\n+                    contig.setCut(true);\n+                }\n+            }\n+\n+            // remove poorly attested (low max observations) contigs, unless they are cut points\n+            contigRemoved = false;\n+            final Iterator<ContigImpl> itr = contigs.iterator();\n+            while ( itr.hasNext() ) {\n+                final Contig contig = itr.next();\n+                if ( contig.getMaxObservations() < MIN_THIN_OBS && !contig.isCut() ) {\n+                    unlinkContig(contig, kmerAdjacencySet);\n+                    itr.remove();\n+                    contigRemoved = true;\n+                    break;\n+                }\n+            }\n+        } while ( contigRemoved );\n+        contigs.sort(Comparator.comparingInt(ContigImpl::getId));\n+    }\n+\n+    private static CutData findCuts( final Contig contig,\n+                                     final Contig parent,\n+                                     final Map<Contig, CutData> cutDataMap ) {\n+        final CutData cutData = new CutData();\n+        cutDataMap.put(contig, cutData);\n+        for ( final Contig nextContig : contig.getSuccessors() ) {\n+            if ( nextContig == parent ) {\n+                continue;\n+            }\n+            CutData nextCutData = cutDataMap.get(nextContig);\n+            if ( nextCutData != null ) {\n+                cutData.minVisitNum = Math.min(cutData.minVisitNum, nextCutData.visitNum);\n+            } else {\n+                nextCutData = findCuts(nextContig, contig, cutDataMap);\n+                cutData.minVisitNum = Math.min(cutData.minVisitNum, nextCutData.minVisitNum);\n+                if ( nextCutData.minVisitNum >= cutData.visitNum ) {\n+                    contig.setCut(true);\n+                }\n+            }\n+        }\n+        for ( final Contig nextContig : contig.getPredecessors() ) {\n+            if ( nextContig == parent ) {\n+                continue;\n+            }\n+            CutData nextCutData = cutDataMap.get(nextContig);\n+            if ( nextCutData != null ) {\n+                cutData.minVisitNum = Math.min(cutData.minVisitNum, nextCutData.visitNum);\n+            } else {\n+                nextCutData = findCuts(nextContig, contig, cutDataMap);\n+                cutData.minVisitNum = Math.min(cutData.minVisitNum, nextCutData.minVisitNum);\n+                if ( nextCutData.minVisitNum >= cutData.visitNum ) {\n+                    contig.setCut(true);\n+                }\n+            }\n+        }\n+        return cutData;\n+    }\n+\n+    @VisibleForTesting\n+    static void unlinkContig( final Contig contig,\n+                                      final KmerSet<KmerAdjacency> kmerAdjacencySet ) {\n+        final KmerAdjacency firstKmer = contig.getFirstKmer();\n+        final int firstKmerFinalCall = firstKmer.getFinalCall();\n+        for ( final Contig predecessor : contig.getPredecessors() ) {\n+            if ( predecessor != contig && predecessor != contig.rc() ) {\n+                predecessor.getLastKmer().removeSuccessor(firstKmerFinalCall, kmerAdjacencySet);\n+                if ( !predecessor.getSuccessors().remove(contig) ) {\n+                    throw new GATKException(\"failed to find predecessor link\");\n+                }\n+            }\n+        }\n+\n+        final KmerAdjacency lastKmer = contig.getLastKmer();\n+        final int lastKmerInitialCall = lastKmer.getInitialCall();\n+        for ( final Contig successor : contig.getSuccessors() ) {\n+            if ( successor != contig && successor != contig.rc() ) {\n+                successor.getFirstKmer().removePredecessor(lastKmerInitialCall, kmerAdjacencySet);\n+                if ( !successor.getPredecessors().remove(contig) ) {\n+                    throw new GATKException(\"failed to find successor link\");\n+                }\n+            }\n+        }\n+\n+        KmerAdjacency nextKmer = firstKmer;\n+        KmerAdjacency kmer;\n+        do {\n+            kmer = nextKmer;\n+            nextKmer = kmer.getSoleSuccessor();\n+            kmerAdjacencySet.remove(kmer.canonical());\n+        } while ( kmer != lastKmer );\n+    }\n+\n+    private static void updateKmerContig( final KmerAdjacency firstKmer,\n+                                          final KmerAdjacency lastKmer,\n+                                          final Contig contig ) {\n+        int offset = 0;\n+        for ( KmerAdjacency kmer = firstKmer; kmer != lastKmer; kmer = kmer.getSoleSuccessor() ) {\n+            if ( kmer == null ) {\n+                throw new GATKException(\"contig does not have a flat pipeline of kmers\");\n+            }\n+            kmer.clearContig();\n+            kmer.setContigOffset(contig, offset++);\n+        }\n+        lastKmer.clearContig();\n+        lastKmer.setContigOffset(contig, offset);\n+        if ( offset + Kmer.KSIZE != contig.size() ) {\n+            throw new GATKException(\"kmer chain length does not equal contig size\");\n+        }\n+    }\n+\n+    /** replace adjacent contigs without branches with a single, larger contig **/\n+    @VisibleForTesting\n+    static void weldPipes( final List<ContigImpl> contigs ) {\n+        for ( int contigIdx = 0; contigIdx != contigs.size(); ++contigIdx ) {\n+            final ContigImpl contig = contigs.get(contigIdx);\n+            if ( contig.getSuccessors().size() == 1 ) {\n+                final Contig successor = contig.getSuccessors().get(0);\n+                if ( successor != contig && successor != contig.rc() &&\n+                        successor.getPredecessors().size() == 1 ) {\n+                    contigs.set(contigIdx, join(contig.getId(), contig, successor));\n+                    if ( !contigs.remove(successor.canonical()) ) {\n+                        throw new GATKException(\"successor linkage is messed up\");\n+                    }\n+                    contigIdx -= 1; // reconsider the new contig -- there might be more joining possible\n+                    continue;\n+                }\n+            }\n+            if ( contig.getPredecessors().size() == 1 ) {\n+                final Contig predecessor = contig.getPredecessors().get(0);\n+                if ( predecessor != contig && predecessor != contig.rc() &&\n+                        predecessor.getSuccessors().size() == 1 ) {\n+                    contigs.set(contigIdx, join(contig.getId(), predecessor, contig));\n+                    if ( !contigs.remove(predecessor.canonical()) ) {\n+                        throw new GATKException(\"predecessor linkage is messed up\");\n+                    }\n+                    contigIdx -= 1; // reconsider\n+                }\n+            }\n+        }\n+    }\n+\n+    private static ContigImpl join( final int id, final Contig predecessor, final Contig successor ) {\n+        if ( !checkOverlap(predecessor.getSequence(), successor.getSequence()) ) {\n+                throw new GATKException(\"sequences can't be joined\");\n+        }\n+        final ContigImpl joinedContig = new ContigImpl(id, predecessor, successor);\n+        updateKmerContig(joinedContig.getFirstKmer(), joinedContig.getLastKmer(), joinedContig);\n+        return joinedContig;\n+    }\n+\n+    private static boolean checkOverlap( final CharSequence seq1, final CharSequence seq2 ) {\n+        final int seq1Len = seq1.length();\n+        final CharSequence seq1SubSeq = seq1.subSequence(seq1Len - Kmer.KSIZE + 1, seq1Len);\n+        final CharSequence seq2SubSeq = seq2.subSequence(0, Kmer.KSIZE - 1);\n+        return seq1SubSeq.equals(seq2SubSeq);\n+    }\n+\n+    /** set a unique componentId for every connected group of contigs **/\n+    @VisibleForTesting\n+    static int markComponents( final List<ContigImpl> contigs ) {\n+        for ( final ContigImpl contig : contigs ) {\n+            contig.setComponentId(0);\n+        }\n+\n+        int componentId = 0;\n+        for ( final ContigImpl contig : contigs ) {\n+            if ( contig.getComponentId() == 0 ) {\n+                contig.setComponentId(++componentId);\n+                markSuccessorComponents(contig);\n+                markSuccessorComponents(contig.rc());\n+            }\n+        }\n+        return componentId;\n+    }\n+\n+    private static void markSuccessorComponents( final Contig contig ) {\n+        final int componentId = contig.getComponentId();\n+        for ( final Contig successor : contig.getSuccessors() ) {\n+            if ( successor.getComponentId() == 0 ) {\n+                successor.canonical().setComponentId(componentId);\n+                markSuccessorComponents(successor);\n+                markSuccessorComponents(successor.rc());\n+            }\n+        }\n+    }\n+\n+    @VisibleForTesting\n+    static void markCycles( final List<ContigImpl> contigs ) {\n+        for ( final Contig contig : contigs ) {\n+            contig.setCyclic(false);\n+        }\n+\n+        final int nContigs = contigs.size();\n+        final Deque<Contig> deque = new ArrayDeque<>(nContigs);\n+        final Map<Contig, CutData> cutDataMap = new HashMap<>(nContigs * 3);\n+        for ( final Contig contig : contigs ) {\n+            if ( !cutDataMap.containsKey(contig) ) {\n+                markCyclesRecursion(contig, deque, cutDataMap);\n+            }\n+        }\n+    }\n+\n+    private static CutData markCyclesRecursion( final Contig contig,\n+                                                final Deque<Contig> deque,\n+                                                final Map<Contig, CutData> cutDataMap ) {\n+        final CutData cutData = new CutData();\n+        cutDataMap.put(contig, cutData);\n+        deque.addFirst(contig);\n+\n+        for ( final Contig successor : contig.getSuccessors() ) {\n+            final CutData successorCutData = cutDataMap.get(successor);\n+            if ( successorCutData == null ) {\n+                final int recursionVisitNum =\n+                        markCyclesRecursion(successor, deque, cutDataMap).minVisitNum;\n+                cutData.minVisitNum = Math.min(cutData.minVisitNum, recursionVisitNum);\n+            } else {\n+                cutData.minVisitNum = Math.min(cutData.minVisitNum, successorCutData.visitNum);\n+            }\n+        }\n+\n+        if ( cutData.visitNum == cutData.minVisitNum ) {\n+            Contig tig = deque.removeFirst();\n+            if ( tig == contig ) {\n+                cutDataMap.get(tig).visitNum = Integer.MAX_VALUE;\n+\n+                // single-vertex component -- cyclic only if self-referential\n+                if ( tig.getSuccessors().contains(tig) ) {\n+                    tig.setCyclic(true);\n+                }\n+            } else {\n+                while ( true ) {\n+                    // kill cross-links\n+                    cutDataMap.get(tig).visitNum = Integer.MAX_VALUE;\n+                    tig.setCyclic(true);\n+                    if ( tig == contig ) break;\n+                    tig = deque.removeFirst();\n+                }\n+            }\n+        }\n+        return cutData;\n+    }\n+\n+    @VisibleForTesting\n+    static boolean fillGaps( final KmerSet<KmerAdjacency> kmerAdjacencySet,\n+                             final List<GATKRead> reads ) {\n+        final Map<String, Integer> gapFillCounts = new HashMap<>();\n+        for ( final GATKRead read : reads ) {\n+            final Path path = new Path(read.getBasesNoCopy(), kmerAdjacencySet);\n+            final List<PathPart> parts = path.getParts();\n+            final int lastIdx = parts.size() - 1;\n+            for ( int idx = 1; idx < lastIdx; ++idx ) {\n+                final PathPart pathPart = parts.get(idx);\n+                if ( pathPart.isGap() ) {\n+                    final char prevCall = parts.get(idx - 1).getLastCall();\n+                    final char nextCall = parts.get(idx + 1).getFirstCall();\n+                    String gapFill = prevCall + pathPart.getSequence().toString() + nextCall;\n+                    final SequenceRC gapFillRC = new SequenceRC(gapFill);\n+                    if ( gapFillRC.compareTo(gapFill) < 0 ) {\n+                        gapFill = gapFillRC.toString();\n+                    }\n+                    gapFillCounts.merge(gapFill, 1, Integer::sum);\n+                }\n+            }\n+        }\n+\n+        boolean newKmers = false;\n+        for ( final Map.Entry<String, Integer> entry : gapFillCounts.entrySet() ) {\n+            final int nObservations = entry.getValue();\n+            if ( nObservations >= MIN_GAPFILL_COUNT ) {\n+                KmerAdjacency.kmerize(entry.getKey(), nObservations, kmerAdjacencySet);\n+                newKmers = true;\n+            }\n+        }\n+\n+        if ( newKmers ) {\n+            for ( final KmerAdjacency kmerAdjacency : kmerAdjacencySet ) {\n+                kmerAdjacency.clearContig();\n+            }\n+        }\n+        return newKmers;\n+    }\n+\n+    @VisibleForTesting\n+    static List<Path> pathReads( final KmerSet<KmerAdjacency> kmerAdjacencySet,\n+                          final List<GATKRead> reads ) {\n+        final List<Path> readPaths = new ArrayList<>(reads.size());\n+        for ( final GATKRead read : reads ) {\n+            readPaths.add(new Path(read.getBasesNoCopy(), kmerAdjacencySet));\n+        }\n+        return readPaths;\n+    }\n+\n+    @VisibleForTesting\n+    static Map<Contig,List<TransitPairCount>> collectTransitPairCounts(\n+            final List<ContigImpl> contigs,\n+            final List<Path> readPaths ) {\n+        final Map<Contig,List<TransitPairCount>> contigTransitsMap =\n+                new HashMap<>(3 * contigs.size());\n+        for ( final Path path : readPaths ) {\n+            final List<PathPart> parts = path.getParts();\n+            final int lastPart = parts.size() - 1;\n+            for ( int partIdx = 1; partIdx < lastPart; ++partIdx ) {\n+                final Contig prevContig = parts.get(partIdx - 1).getContig();\n+                if ( prevContig == null ) continue;\n+                final Contig curContig = parts.get(partIdx).getContig();\n+                if ( curContig == null ) {\n+                    partIdx += 1;\n+                    continue;\n+                }\n+                final Contig nextContig = parts.get(partIdx + 1).getContig();\n+                if ( nextContig == null ) {\n+                    partIdx += 2;\n+                    continue;\n+                }\n+                final TransitPairCount tpc = new TransitPairCount(prevContig, nextContig);\n+                final List<TransitPairCount> tpcList =\n+                        contigTransitsMap.computeIfAbsent(curContig, tig -> new ArrayList<>(4));\n+                final int idx = tpcList.indexOf(tpc);\n+                if ( idx != -1 ) {\n+                    tpcList.get(idx).observe();\n+                } else {\n+                    tpcList.add(tpc);\n+                    contigTransitsMap.computeIfAbsent(curContig.rc(), tig -> new ArrayList<>(4))\n+                            .add(tpc.getRC());\n+                }\n+            }\n+        }\n+        return contigTransitsMap;\n+    }\n+\n+    @VisibleForTesting\n+    static Set<Traversal> traverseAllPaths(\n+            final List<ContigImpl> contigs,\n+            final List<Path> readPaths,\n+            final Map<Contig, List<TransitPairCount>> contigTransitsMap ) {\n+        final Set<Traversal> traversalSet = new HashSet<>();\n+        final List<Contig> contigsList = new ArrayList<>();\n+        for ( final Contig contig : contigs ) {\n+            // untransited contigs are sources, sinks, or large contigs that can't be crossed by a read\n+            // build traversals from these\n+            if ( !contigTransitsMap.containsKey(contig) ) {\n+                boolean done = false;\n+                for ( final Contig successor : contig.getSuccessors() ) {\n+                    traverse(successor, contig,\n+                            contigsList, readPaths, contigTransitsMap, traversalSet);\n+                    done = true;\n+                }\n+                for ( final Contig predecessor : contig.getPredecessors() ) {\n+                    traverse(predecessor.rc(), contig.rc(),\n+                            contigsList, readPaths, contigTransitsMap, traversalSet);\n+                    done = true;\n+                }\n+                if ( !done ) { // if there were no predecessors or successors, it stands alone\n+                    addTraversal(new Traversal(Collections.singletonList(contig)), traversalSet);\n+                }\n+            }\n+        }\n+\n+        // look for transits that haven't been traced\n+        for ( final Map.Entry<Contig, List<TransitPairCount>> entry :\n+                contigTransitsMap.entrySet() ) {\n+            for ( final TransitPairCount tpc : entry.getValue() ) {\n+                if ( tpc.getCount() > 0 ) {\n+                    tpc.resetCount();\n+                    final Contig contig = entry.getKey();\n+                    final Set<Traversal> fwdTraversalSet = new HashSet<>();\n+                    traverse(tpc.getNextContig(), contig,\n+                            contigsList, readPaths, contigTransitsMap, fwdTraversalSet);\n+                    final Set<Traversal> revTraversalSet = new HashSet<>();\n+                    traverse(tpc.getPrevContig().rc(), contig.rc(),\n+                            contigsList, readPaths, contigTransitsMap, revTraversalSet);\n+                    for ( final Traversal revTraversal : revTraversalSet ) {\n+                        final Traversal revTraversalRC = revTraversal.rc();\n+                        for ( final Traversal fwdTraversal : fwdTraversalSet ) {\n+                            final int overlap =\n+                                    findMaxOverlap(revTraversalRC.getContigs(), fwdTraversal.getContigs());\n+                            final Traversal combo =\n+                                    Traversal.combineOverlappers(revTraversalRC, fwdTraversal, overlap);\n+                            addTraversal(combo, traversalSet);\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+\n+        return traversalSet;\n+    }\n+\n+    private static int findMaxOverlap( final List<Contig> prefixes, final List<Contig> suffixes ) {\n+        final int nPrefixes = prefixes.size();\n+        final Contig firstSuffix = suffixes.get(0);\n+        if ( !firstSuffix.isCyclic() ) {\n+            return prefixes.get(nPrefixes - 1) == firstSuffix ? 1 : 0;\n+        }\n+        final int nSuffixes = suffixes.size();\n+        for ( int prefixIdx = Math.max(0, nPrefixes - nSuffixes); prefixIdx != nPrefixes; ++prefixIdx ) {\n+            if ( prefixes.get(prefixIdx) == firstSuffix ) {\n+                int suffixIdx = 1;\n+                boolean match = true;\n+                for ( int prefixIdx2 = prefixIdx + 1; prefixIdx2 != nPrefixes; ++prefixIdx2 ) {\n+                    if ( prefixes.get(prefixIdx2) != suffixes.get(suffixIdx++) ) {\n+                        match = false;\n+                        break;\n+                    }\n+                }\n+                if ( match ) {\n+                    return nPrefixes - prefixIdx;\n+                }\n+            }\n+        }\n+        return 0;\n+    }\n+\n+    private static void traverse( final Contig contig,\n+                                  final Contig predecessor,\n+                                  final List<Contig> contigsList,\n+                                  final List<Path> readPaths,\n+                                  final Map<Contig, List<TransitPairCount>> contigTransitsMap,\n+                                  final Set<Traversal> traversalSet ) {\n+        contigsList.add(predecessor);\n+        if ( contig.isCyclic() ) {\n+            traverseCycle(contig, contigsList, readPaths, contigTransitsMap, traversalSet);\n+            contigsList.remove(contigsList.size() - 1);\n+            return;\n+        }\n+        final List<TransitPairCount> transits = contigTransitsMap.get(contig);\n+        boolean done = false;\n+        if ( transits != null ) {\n+            for ( final TransitPairCount tpc : transits ) {\n+                if ( tpc.getPrevContig() == predecessor ) {\n+                    final Contig successor = tpc.getNextContig();\n+                    if ( predecessor == contig.rc() ) {\n+                        final int nContigs = contigsList.size();\n+                        if ( nContigs > 1 ) {\n+                            if ( successor.rc() == contigsList.get(nContigs - 2) ) {\n+                                continue;\n+                            }\n+                        }\n+                    }\n+                    tpc.resetCount();\n+                    traverse(successor, contig, contigsList, readPaths, contigTransitsMap, traversalSet);\n+                    done = true;\n+                }\n+            }\n+        }\n+        if ( !done ) {\n+            contigsList.add(contig);\n+            addTraversal(new Traversal(contigsList), traversalSet);\n+            contigsList.remove(contigsList.size() - 1);\n+        }\n+        contigsList.remove(contigsList.size() - 1);\n+    }\n+\n+    private static void traverseCycle( final Contig contig,\n+                                       final List<Contig> contigsList,\n+                                       final List<Path> readPaths,\n+                                       final Map<Contig, List<TransitPairCount>> contigTransitsMap,\n+                                       final Set<Traversal> traversalSet ) {\n+        contigsList.add(contig);\n+        final int nContigs = contigsList.size();\n+        // the final element of the list is cyclic, if there's a previous element it will be\n+        // non-cyclic, so start there figuring out how far the read paths lead us\n+        final List<List<Contig>> longestPaths =\n+                findLongestPaths(contigsList.subList(Math.max(0, nContigs - 2), nContigs), readPaths);\n+        // didn't get anywhere -- just complete the traversal\n+        if ( longestPaths.isEmpty() ) {\n+            addTraversal(new Traversal(contigsList, true), traversalSet);\n+        } else {\n+            // for each unique extension into the cycle\n+            for ( final List<Contig> path : longestPaths ) {\n+                // don't think this can happen, but still\n+                if ( path.isEmpty() ) {\n+                    addTraversal(new Traversal(contigsList, true), traversalSet);\n+                    continue;\n+                }\n+                final List<Contig> extendedContigsList =\n+                        new ArrayList<>(contigsList.size() + path.size());\n+                extendedContigsList.addAll(contigsList);\n+                // if we didn't get out of the cycle\n+                if ( path.get(path.size() - 1).isCyclic() ) {\n+                    extendedContigsList.addAll(path);\n+                    addTraversal(new Traversal(extendedContigsList, true), traversalSet);\n+                } else {\n+                    // we found a cycle-exiting path, so extend that normally\n+                    for ( final Contig curContig : path ) {\n+                        if ( curContig.isCyclic() ) {\n+                            extendedContigsList.add(curContig);\n+                        } else {\n+                            final Contig prevContig =\n+                                    extendedContigsList.remove(extendedContigsList.size() - 1);\n+                            traverse(curContig, prevContig, extendedContigsList, readPaths,\n+                                    contigTransitsMap, traversalSet);\n+                            extendedContigsList.add(prevContig);\n+                            break;\n+                        }\n+                    }\n+                }\n+                clearTransitPairs(contigTransitsMap, extendedContigsList);\n+            }\n+        }\n+        contigsList.remove(contigsList.size() - 1);\n+    }\n+\n+    private static void clearTransitPairs(\n+            final Map<Contig, List<TransitPairCount>> contigTransitsMap,\n+            final List<Contig> contigsList ) {\n+        final int lastIdx = contigsList.size() - 1;\n+        for ( int idx = 1; idx < lastIdx; ++idx ) {\n+            final List<TransitPairCount> pairCounts = contigTransitsMap.get(contigsList.get(idx));\n+            if ( pairCounts != null ) {\n+                final Contig predecessor = contigsList.get(idx - 1);\n+                final Contig successor = contigsList.get(idx + 1);\n+                for ( final TransitPairCount tpc : pairCounts ) {\n+                    if ( tpc.getPrevContig() == predecessor && tpc.getNextContig() == successor ) {\n+                        tpc.resetCount();\n+                        break;\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    private static void addTraversal( final Traversal traversal,\n+                                      final Set<Traversal> traversalSet ) {\n+        if ( !traversalSet.contains(traversal.rc()) ) {\n+            traversalSet.add(traversal);\n+            if ( traversalSet.size() >= TOO_MANY_TRAVERSALS ) {\n+                throw new AssemblyTooComplexException();\n+            }\n+        }\n+    }\n+\n+    private static List<List<Contig>> findLongestPaths( final List<Contig> toMatch,\n+                                                        final List<Path> readPaths ) {\n+        final List<List<Contig>> results = new ArrayList<>();\n+        for ( final Path path : readPaths ) {\n+            testPath(path, toMatch, results);\n+            testPath(path.rc(), toMatch, results);\n+        }\n+        return results;\n+    }\n+\n+    private static void testPath( final Path path,\n+                                  final List<Contig> toMatch,\n+                                  final List<List<Contig>> results ) {\n+        final List<PathPart> pathParts = path.getParts();\n+        final int nPathParts = pathParts.size();\n+        final List<Contig> pathContigs = new ArrayList<>(nPathParts);\n+        pathParts.forEach(pp -> pathContigs.add(pp.getContig()));\n+        final int matchIdx = Collections.indexOfSubList(pathContigs, toMatch);\n+        if ( matchIdx != -1 ) {\n+            final int suffixIdx = matchIdx + toMatch.size();\n+            if ( suffixIdx < nPathParts ) {\n+                resolveResult(grabParts(pathContigs, suffixIdx), results);\n+            }\n+        }\n+    }\n+\n+    private static List<Contig> grabParts( final List<Contig> pathContigs, final int suffixIdx ) {\n+        final int nPathContigs = pathContigs.size();\n+        Contig prev = pathContigs.get(suffixIdx - 1);\n+        final List<Contig> result = new ArrayList<>(nPathContigs - suffixIdx);\n+        for ( int idx = suffixIdx; idx != nPathContigs; ++idx ) {\n+            final Contig tig = pathContigs.get(idx);\n+            if ( tig == null || !prev.getSuccessors().contains(tig) ) break;\n+            result.add(tig);\n+            prev = tig;\n+        }\n+        return result;\n+    }\n+\n+    private static void resolveResult( final List<Contig> result,\n+                                       final List<List<Contig>> results ) {\n+        final int nResults = results.size();\n+        for ( int idx = 0; idx != nResults; ++idx ) {\n+            final List<Contig> test = results.get(idx);\n+            if ( isPrefix(result, test) ) return;\n+            if ( isPrefix(test, result) ) {\n+                results.set(idx, result);\n+                return;\n+            }\n+        }\n+        results.add(result);\n+    }\n+\n+    private static boolean isPrefix( final List<Contig> list1, final List<Contig> list2 ) {\n+        final int list1Size = list1.size();\n+        final int list2Size = list2.size();\n+        if ( list1Size > list2Size ) return false;\n+        for ( int idx = 0; idx != list1Size; ++idx ) {\n+            if ( list1.get(idx) != list2.get(idx) ) return false;\n+        }\n+        return true;\n+    }\n+\n+    @VisibleForTesting\n+    static Collection<Traversal> createScaffolds( final List<Traversal> allTraversals ) {\n+        removeTriviallyDifferentTraversals(allTraversals);\n+\n+        final int nTraversals = allTraversals.size();\n+        final Map<Contig, List<Integer>> traversalsByFirstContig = new HashMap<>(3 * nTraversals);\n+        for ( int idx = 0; idx != nTraversals; ++idx ) {\n+            final Traversal traversal = allTraversals.get(idx);\n+            traversalsByFirstContig.compute(traversal.getFirstContig(),\n+                    ( k, v ) -> v == null ? new ArrayList<>(3) : v).add(idx);\n+            final Traversal rcTraversal = traversal.rc();\n+            traversalsByFirstContig.compute(rcTraversal.getFirstContig(),\n+                    ( k, v ) -> v == null ? new ArrayList<>(3) : v).add(~idx);\n+        }\n+\n+        final List<Traversal> scaffolds = new ArrayList<>(nTraversals);\n+        final boolean[] touched = new boolean[nTraversals];\n+        for ( int idx = 0; idx != nTraversals; ++idx ) {\n+            if ( !touched[idx] ) {\n+                expandTraversal(idx, touched, traversalsByFirstContig, allTraversals, scaffolds);\n+            }\n+        }\n+        return scaffolds;\n+    }\n+\n+    private static void expandTraversal( final int traversalIdx,\n+                                         final boolean[] touched,\n+                                         final Map<Contig, List<Integer>> traversalsByFirstContig,\n+                                         final List<Traversal> allTraversals,\n+                                         final List<Traversal> scaffolds ) {\n+        final Traversal traversal = allTraversals.get(traversalIdx);\n+        touched[traversalIdx] = true;\n+        final List<Traversal> downExtensions = new ArrayList<>();\n+        final Set<Contig> startingContigSet = new HashSet<>();\n+        walkTraversals(traversal, touched, startingContigSet, traversalsByFirstContig,\n+                        allTraversals, downExtensions);\n+        final List<Traversal> upExtensions = new ArrayList<>();\n+        walkTraversals(traversal.rc(), touched, startingContigSet, traversalsByFirstContig,\n+                        allTraversals, upExtensions);\n+        for ( final Traversal down : downExtensions ) {\n+            for ( final Traversal up : upExtensions ) {\n+                if ( scaffolds.size() >= TOO_MANY_SCAFFOLDS ) {\n+                    throw new AssemblyTooComplexException();\n+                }\n+                scaffolds.add(Traversal.combineOverlappers(up.rc(), down, traversal.getContigs().size()));\n+            }\n+        }\n+    }\n+\n+    private static void walkTraversals( final Traversal traversal,\n+                                        final boolean[] touched,\n+                                        final Set<Contig> startingContigSet,\n+                                        final Map<Contig, List<Integer>> traversalsByFirstContig,\n+                                        final List<Traversal> allTraversals,\n+                                        final List<Traversal> extensions ) {\n+        final Contig firstContig = traversal.getFirstContig();\n+        final List<Integer> indexList;\n+        if ( startingContigSet.contains(firstContig) ||\n+                traversal.isInextensible() ||\n+                (indexList = traversalsByFirstContig.get(traversal.getLastContig())) == null ) {\n+            extensions.add(traversal);\n+            return;\n+        }\n+        startingContigSet.add(firstContig);\n+        for ( int idx : indexList ) {\n+            final Traversal extension;\n+            if ( idx >= 0 ) {\n+                extension = allTraversals.get(idx);\n+                touched[idx] = true;\n+            } else {\n+                final int rcIdx = ~idx;\n+                extension = allTraversals.get(rcIdx).rc();\n+                touched[rcIdx] = true;\n+            }\n+            walkTraversals(Traversal.combine(traversal, extension), touched, startingContigSet,\n+                            traversalsByFirstContig, allTraversals, extensions );\n+        }\n+        startingContigSet.remove(firstContig);\n+    }\n+\n+    private static void removeTriviallyDifferentTraversals(\n+                                            final Collection<Traversal> allTraversals ) {\n+        if ( allTraversals.isEmpty() ) {\n+            return;\n+        }\n+        final TreeSet<Traversal> sortedTraversals = new TreeSet<>(new TraversalEndpointComparator());\n+        for ( final Traversal traversal : allTraversals ) {\n+            sortedTraversals.add(traversal);\n+            sortedTraversals.add(traversal.rc());\n+        }\n+        final Iterator<Traversal> traversalIterator = sortedTraversals.iterator();\n+        Traversal prevTraversal = traversalIterator.next();\n+        while ( traversalIterator.hasNext() ) {\n+            final Traversal curTraversal = traversalIterator.next();\n+            if ( isTriviallyDifferent(prevTraversal, curTraversal) ) {\n+                traversalIterator.remove();\n+            } else {\n+                prevTraversal = curTraversal;\n+            }\n+        }\n+        sortedTraversals.removeIf(Traversal::isRC);\n+        allTraversals.clear();\n+        allTraversals.addAll(sortedTraversals);\n+    }\n+\n+    private static boolean isTriviallyDifferent( final Traversal traversal1,\n+                                                 final Traversal traversal2 ) {\n+        final Contig firstContig1 = traversal1.getFirstContig();\n+        final Contig lastContig1 = traversal1.getLastContig();\n+        final Contig firstContig2 = traversal2.getFirstContig();\n+        final Contig lastContig2 = traversal2.getLastContig();\n+        if ( firstContig1 != firstContig2 || lastContig1 != lastContig2 ) {\n+            return false;\n+        }\n+        final int interiorSize1 = traversal1.getSequenceLength() - firstContig1.size() - lastContig1.size();\n+        final int interiorSize2 = traversal2.getSequenceLength() - firstContig2.size() - lastContig2.size();\n+\n+        // if the path lengths are so different that one could harbor an SV, they're not trivially different\n+        if ( Math.abs(interiorSize1 - interiorSize2) >= MIN_SV_SIZE ) {\n+            return false;\n+        }\n+\n+        // if the paths are small enough that there can't be an SV's worth of differences, they're trivially different\n+        final int maxInteriorSize = Math.max(interiorSize1, interiorSize2);\n+        if ( maxInteriorSize < MIN_SV_SIZE ) {\n+            return true;\n+        }\n+\n+        // dang, maybe there's enough material in common that there can't be an SV's worth of differences\n+        // run a longest common subsequence algorithm to figure out the length of the common material\n+        // DP matrix holds length of common material\n+        final List<Contig> contigs1 = traversal1.getContigs();\n+        final int rowLen = contigs1.size() - 1;\n+        final int[][] rowPair = new int[2][];\n+        rowPair[0] = new int[rowLen];\n+        rowPair[1] = new int[rowLen];\n+        int pairIdx = 0;\n+        final List<Contig> contigs2 = traversal2.getContigs();\n+        final int nRows = contigs2.size() - 1;\n+        for ( int idx2 = 1; idx2 != nRows; ++idx2 ) {\n+            final int[] curRow = rowPair[pairIdx];\n+            final int[] prevRow = rowPair[pairIdx ^ 1];\n+            pairIdx ^= 1;\n+\n+            final int id2 = contigs2.get(idx2).getId();\n+            for ( int idx1 = 1; idx1 != rowLen; ++idx1 ) {\n+                final Contig tig1 = contigs1.get(idx1);\n+                if ( tig1.getId() == id2 ) {\n+                    // if the previous cells also contain a match we've already removed the K-1 bases upstream\n+                    final boolean extendMatch =\n+                            contigs1.get(idx1 -1).getId() == contigs2.get(idx2 - 1).getId();\n+                    curRow[idx1] = prevRow[idx1 - 1] + (extendMatch ? tig1.getNKmers() : tig1.size());\n+                } else {\n+                    curRow[idx1] = Math.max(curRow[idx1 - 1], prevRow[idx1]);\n+                }\n+            }\n+        }\n+        final int commonLen = rowPair[pairIdx ^ 1][rowLen - 1];\n+        return (maxInteriorSize - commonLen) < MIN_SV_SIZE;\n+    }\n+\n+    private static class TraversalEndpointComparator implements Comparator<Traversal> {\n+        @Override\n+        public int compare( final Traversal traversal1, final Traversal traversal2 ) {\n+            int cmp = Integer.compare(traversal1.contigs.get(0).getId(),\n+                                      traversal2.contigs.get(0).getId());\n+            if ( cmp != 0 ) {\n+                return cmp;\n+            }\n+            final int last1 = traversal1.contigs.size() - 1;\n+            final int last2 = traversal2.contigs.size() - 1;\n+            cmp = Integer.compare(traversal1.contigs.get(last1).getId(),\n+                                  traversal2.contigs.get(last2).getId());\n+            if ( cmp != 0 ) {\n+                return cmp;\n+            }\n+            // among those starting and ending at the same place, sort least observed last\n+            return -Integer.compare(traversal1.getMinMaxObservations(), traversal2.getMinMaxObservations());\n+        }\n+    }\n+\n+    private static void writeDOT( final List<ContigImpl> contigs, final String fileName ) {\n+        try ( final BufferedWriter writer = new BufferedWriter(new FileWriter(fileName)) ) {\n+            writer.write(\"digraph {\\n\");\n+            for ( final Contig contig : contigs ) {\n+                final double width = contig.getSequence().length() / 100.;\n+                writer.write(contig + \" [width=\" + width + \"]\\n\");\n+                writer.write( contig.rc() + \" [width=\" + width + \"]\\n\");\n+            }\n+            for ( final Contig contig : contigs ) {\n+                for ( final Contig predecessor : contig.getPredecessors() ) {\n+                    final String predecessorName = predecessor.rc().toString();\n+                    writer.write(contig.rc() + \" -> \" + predecessorName + \"\\n\");\n+                }\n+                for ( final Contig successor : contig.getSuccessors() ) {\n+                    final String successorName = successor.toString();\n+                    writer.write(contig + \" -> \" + successorName + \"\\n\");\n+                }\n+            }\n+            writer.write(\"}\\n\");\n+        } catch ( final IOException ioe ) {\n+            throw new GATKException(\"Failed to write assembly DOT file.\", ioe);\n+        }\n+    }\n+\n+    private static BufferedWriter makeGZFile( final String fileName ) throws IOException {\n+        final GZIPOutputStream gzOS = new GZIPOutputStream(BucketUtils.createFile(fileName));\n+        return new BufferedWriter(new OutputStreamWriter(gzOS));\n+    }\n+\n+    private static void writeContigs( final List<ContigImpl> contigs, final String fileName ) {\n+        try ( final BufferedWriter writer = makeGZFile(fileName) ) {\n+            for ( final Contig contig : contigs ) {\n+                final List<Contig> predecessors = contig.getPredecessors();\n+                final String predecessorDescription;\n+                if ( predecessors.size() == 0 ) {\n+                    predecessorDescription = \"\\tnone\";\n+                } else {\n+                    final StringBuilder sb = new StringBuilder();\n+                    char prefix = '\\t';\n+                    for ( final Contig predecessor : predecessors ) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e2201c1ef4f8ba71f17e169f07756cfe2f1ecb49"}, "originalPosition": 1150}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxNDg2NDkwNA==", "bodyText": "This code went away when I switched to writing GFA.  I've switched to functional style in that new code.", "url": "https://github.com/broadinstitute/gatk/pull/6989#discussion_r614864904", "createdAt": "2021-04-16T14:05:35Z", "author": {"login": "tedsharpe"}, "path": "src/main/java/org/broadinstitute/hellbender/tools/LocalAssembler.java", "diffHunk": "@@ -0,0 +1,2306 @@\n+package org.broadinstitute.hellbender.tools;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import htsjdk.samtools.Cigar;\n+import htsjdk.samtools.CigarElement;\n+import htsjdk.samtools.CigarOperator;\n+import htsjdk.samtools.SAMUtils;\n+import org.broadinstitute.barclay.argparser.Argument;\n+import org.broadinstitute.barclay.argparser.BetaFeature;\n+import org.broadinstitute.barclay.argparser.CommandLineProgramProperties;\n+import org.broadinstitute.barclay.help.DocumentedFeature;\n+import org.broadinstitute.hellbender.cmdline.StandardArgumentDefinitions;\n+import org.broadinstitute.hellbender.cmdline.programgroups.CoverageAnalysisProgramGroup;\n+import org.broadinstitute.hellbender.exceptions.GATKException;\n+import org.broadinstitute.hellbender.tools.walkers.PairWalker;\n+import org.broadinstitute.hellbender.utils.SimpleInterval;\n+import org.broadinstitute.hellbender.utils.collections.HopscotchSet;\n+import org.broadinstitute.hellbender.utils.gcs.BucketUtils;\n+import org.broadinstitute.hellbender.utils.read.GATKRead;\n+\n+import java.io.BufferedWriter;\n+import java.io.FileWriter;\n+import java.io.IOException;\n+import java.io.OutputStreamWriter;\n+import java.util.*;\n+import java.util.zip.GZIPOutputStream;\n+\n+@DocumentedFeature\n+@CommandLineProgramProperties(\n+        summary = \"experiment\",\n+        oneLineSummary = \"experiment\",\n+        usageExample = \"gatk LocalAssembler\",\n+        programGroup = CoverageAnalysisProgramGroup.class\n+)\n+@BetaFeature\n+public class LocalAssembler extends PairWalker {\n+    public static final byte QMIN = 25;\n+    public static final int MIN_THIN_OBS = 4;\n+    public static final int MIN_GAPFILL_COUNT = 3;\n+    public static final int TOO_MANY_TRAVERSALS = 100000;\n+    public static final int TOO_MANY_SCAFFOLDS = 50000;\n+    public static final int MIN_SV_SIZE = 50;\n+\n+    @Argument(fullName=StandardArgumentDefinitions.OUTPUT_LONG_NAME,\n+            shortName=StandardArgumentDefinitions.OUTPUT_SHORT_NAME,\n+            doc=\"Write outputs to this file name prefix\", optional = true)\n+    public static String output;\n+\n+    @Argument(fullName=\"assembly-name\", doc=\"name of assembly used as a prefix for traversal names\")\n+    public static String assemblyName;\n+\n+    private final List<GATKRead> reads = new ArrayList<>();\n+\n+    @Override public boolean requiresIntervals() { return true; }\n+\n+    @Override public void apply( final GATKRead read, final GATKRead mate ) {\n+        trimOverruns(read, mate);\n+        reads.add(read);\n+        reads.add(mate);\n+    }\n+\n+    @Override public void applyUnpaired( final GATKRead read ) {\n+        reads.add(read);\n+    }\n+\n+    @Override public Object onTraversalSuccess() {\n+        super.onTraversalSuccess(); // flush any incomplete pairs\n+\n+        final int regionSize = getTraversalIntervals().stream().mapToInt(SimpleInterval::size).sum();\n+        final KmerSet<KmerAdjacency> kmerAdjacencySet = new KmerSet<>(10 * regionSize);\n+        kmerizeReads(reads, kmerAdjacencySet);\n+        List<ContigImpl> contigs = buildContigs(kmerAdjacencySet);\n+        connectContigs(contigs);\n+\n+        removeThinContigs(contigs, kmerAdjacencySet);\n+        weldPipes(contigs);\n+        markComponents(contigs);\n+\n+        if ( fillGaps(kmerAdjacencySet, reads) ) {\n+            contigs = buildContigs(kmerAdjacencySet);\n+            connectContigs(contigs);\n+            removeThinContigs(contigs, kmerAdjacencySet);\n+            weldPipes(contigs);\n+            markComponents(contigs);\n+        }\n+\n+        markCycles(contigs);\n+\n+        final String outputFilePrefix = output != null ? output : assemblyName;\n+        final List<Path> readPaths = pathReads(kmerAdjacencySet, reads);\n+        final Map<Contig,List<TransitPairCount>> contigTransitsMap =\n+                collectTransitPairCounts(contigs, readPaths);\n+        final String traversalsFilename = outputFilePrefix + \".traversals.fa.gz\";\n+        try {\n+            final List<Traversal> allTraversals =\n+                    new ArrayList<>(traverseAllPaths(contigs, readPaths, contigTransitsMap));\n+            writeTraversals(allTraversals, traversalsFilename);\n+            try {\n+                final String scaffoldsFileName = outputFilePrefix + \".scaffolds.fa.gz\";\n+                writeTraversals(createScaffolds(allTraversals), scaffoldsFileName);\n+            } catch ( final AssemblyTooComplexException x ) {\n+                logger.warn(\"Assembly too complex for scaffolding.\");\n+            }\n+        } catch ( final AssemblyTooComplexException x ) {\n+            logger.warn(\"Assembly too complex.  Writing contigs as traversals in \" +\n+                    traversalsFilename + \".\");\n+            final Collection<Traversal> contigTraversals = new ArrayList<>(contigs.size());\n+            for ( final Contig contig : contigs ) {\n+                contigTraversals.add(new Traversal(Collections.singletonList(contig)));\n+            }\n+            writeTraversals(contigTraversals, traversalsFilename);\n+        }\n+\n+        contigs.sort(Comparator.comparingInt(ContigImpl::getId));\n+        writeDOT(contigs, outputFilePrefix + \".assembly.dot\");\n+        writeContigs(contigs, outputFilePrefix + \".contigs.txt.gz\");\n+        writePaths(readPaths, outputFilePrefix + \".paths.txt.gz\");\n+        writeReads(reads, outputFilePrefix + \".reads.fastq.gz\");\n+        return null;\n+    }\n+\n+    /** trim read pairs of base calls that have gone past the end of a short fragment */\n+    private void trimOverruns( final GATKRead read, final GATKRead mate ) {\n+        // if both mapped and they're on different strands\n+        if ( !read.isUnmapped() && !mate.isUnmapped() &&\n+                read.isReverseStrand() != mate.isReverseStrand() ) {\n+            // and both start within 1 base on the ref\n+            if ( Math.abs(read.getStart() - read.getMateStart()) <= 1 ) {\n+                // and both end within 1 base\n+                final int readRefLen = read.getCigar().getReferenceLength();\n+                final int mateRefLen = mate.getCigar().getReferenceLength();\n+                if ( Math.abs(readRefLen - mateRefLen) <= 1 ) {\n+                    if ( mate.isReverseStrand() ) {\n+                        trimClips(read, mate);\n+                    } else {\n+                        trimClips(mate, read);\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    private void trimClips( final GATKRead fwd, final GATKRead rev ) {\n+        final List<CigarElement> fwdElements = fwd.getCigarElements();\n+        final List<CigarElement> revElements = rev.getCigarElements();\n+        final int lastElementIdx = fwdElements.size() - 1;\n+        final CigarElement fwdLastElement = fwdElements.get(lastElementIdx);\n+        final CigarElement revFirstElement = revElements.get(0);\n+        if ( fwdLastElement.getOperator() == CigarOperator.S &&\n+                revFirstElement.getOperator() == CigarOperator.S ) {\n+            final byte[] fwdBases = fwd.getBasesNoCopy();\n+            final int lastElementLen = fwdLastElement.getLength();\n+            fwd.setBases(Arrays.copyOfRange(fwdBases, 0, fwdBases.length - lastElementLen));\n+            final byte[] fwdQuals = fwd.getBaseQualitiesNoCopy();\n+            if ( fwdQuals.length > 0 ) {\n+                final int qualsLen = fwdQuals.length - lastElementLen;\n+                fwd.setBaseQualities(Arrays.copyOfRange(fwdQuals, 0, qualsLen));\n+            }\n+            final List<CigarElement> newFwdElements = new ArrayList<>(fwdElements);\n+            newFwdElements.set(lastElementIdx, new CigarElement(lastElementLen, CigarOperator.H));\n+            fwd.setCigar(new Cigar(newFwdElements));\n+\n+            final byte[] revBases = rev.getBasesNoCopy();\n+            final int firstElementLen = revFirstElement.getLength();\n+            rev.setBases(Arrays.copyOfRange(revBases, firstElementLen, revBases.length));\n+            final byte[] revQuals = rev.getBaseQualitiesNoCopy();\n+            if ( revQuals.length > 0 ) {\n+                rev.setBaseQualities(Arrays.copyOfRange(revQuals, firstElementLen, revQuals.length));\n+            }\n+            final List<CigarElement> newRevElements = new ArrayList<>(revElements);\n+            newRevElements.set(0, new CigarElement(firstElementLen, CigarOperator.H));\n+            rev.setCigar(new Cigar(newRevElements));\n+        }\n+    }\n+\n+    @VisibleForTesting\n+    static void kmerizeReads( final List<GATKRead> reads,\n+                              final KmerSet<KmerAdjacency> kmerAdjacencySet ) {\n+        for ( final GATKRead read : reads ) {\n+            final byte[] calls = read.getBasesNoCopy();\n+            final byte[] quals = read.getBaseQualitiesNoCopy();\n+            KmerAdjacency.kmerize(calls, quals, QMIN, kmerAdjacencySet);\n+        }\n+    }\n+\n+    /** gather unbranched strings of kmers into contigs **/\n+    @VisibleForTesting\n+    static List<ContigImpl> buildContigs( final KmerSet<KmerAdjacency> kmerAdjacencySet ) {\n+        // gather strings of kmers that have a single predecessor and single successor into contigs\n+        final List<ContigImpl> contigs = new ArrayList<>();\n+        int nContigs = 0;\n+        for ( final KmerAdjacency kmerAdjacency : kmerAdjacencySet ) {\n+            if ( kmerAdjacency.getContig() == null ) {\n+                ContigImpl contig = null;\n+                final KmerAdjacency predecessor = kmerAdjacency.getSolePredecessor();\n+                if ( predecessor == null ||\n+                        predecessor.getSuccessorCount() > 1 ||\n+                        predecessor == kmerAdjacency.rc() ) {\n+                    contig = new ContigImpl(++nContigs, kmerAdjacency);\n+                } else {\n+                    final KmerAdjacency successor = kmerAdjacency.getSoleSuccessor();\n+                    if ( successor == null ||\n+                            successor.getPredecessorCount() > 1 ||\n+                            successor == kmerAdjacency.rc() ) {\n+                        contig = new ContigImpl(++nContigs, kmerAdjacency.rc());\n+                    }\n+                }\n+                if ( contig != null ) {\n+                    contigs.add(contig);\n+                }\n+            }\n+        }\n+\n+        // if there are smooth circles like a plasmid, gather them together as a contig, too\n+        for ( final KmerAdjacency kmerAdjacency : kmerAdjacencySet ) {\n+            if ( kmerAdjacency.getContig() == null ) {\n+                contigs.add(new ContigImpl(++nContigs, kmerAdjacency));\n+            }\n+        }\n+\n+        return contigs;\n+    }\n+\n+    /** connect contigs when the final kmer of one contig is adjacent to the inital contig of another **/\n+    @VisibleForTesting\n+    static void connectContigs( final List<ContigImpl> contigs ) {\n+        final int nContigs = contigs.size();\n+        final KmerSet<ContigEndKmer> contigEnds = new KmerSet<>(2*nContigs);\n+        for ( int contigId = 0; contigId != nContigs; ++contigId ) {\n+            final ContigImpl contig = contigs.get(contigId);\n+            final KmerAdjacency fwdKmer = contig.getFirstKmer();\n+            final KmerAdjacency revKmer = contig.getLastKmer().rc();\n+            if ( fwdKmer == revKmer ) {\n+                contigEnds.add(new ContigEndKmer(fwdKmer.getKVal(), contig, ContigOrientation.BOTH));\n+            } else {\n+                contigEnds.add(new ContigEndKmer(fwdKmer.getKVal(), contig, ContigOrientation.FWD));\n+                contigEnds.add(new ContigEndKmer(revKmer.getKVal(), contig, ContigOrientation.REV));\n+            }\n+        }\n+\n+        for ( int contigId = 0; contigId != nContigs; ++contigId ) {\n+            final Contig contig = contigs.get(contigId);\n+\n+            final KmerAdjacency start = contig.getFirstKmer();\n+            final int predecessorCount = start.getPredecessorCount();\n+            if ( predecessorCount > 0 ) {\n+                final List<Contig> predecessors = contig.getPredecessors();\n+                final int mask = start.getPredecessorMask();\n+                for ( int call = 0; call != 4; ++call ) {\n+                    if ( (mask & (1 << call)) != 0 ) {\n+                        final long kVal =\n+                                KmerAdjacency.reverseComplement(start.getPredecessorVal(call));\n+                        final ContigEndKmer contigEndKmer = contigEnds.find(new Kmer(kVal));\n+                        if ( contigEndKmer == null ) {\n+                            throw new GATKException(\"missing contig end kmer\");\n+                        }\n+                        switch ( contigEndKmer.getContigOrientation() ) {\n+                            case FWD:\n+                                predecessors.add(contigEndKmer.getContig().rc());\n+                                break;\n+                            case REV:\n+                                predecessors.add(contigEndKmer.getContig());\n+                                break;\n+                            case BOTH:\n+                                predecessors.add(contigEndKmer.getContig());\n+                                predecessors.add(contigEndKmer.getContig().rc());\n+                                break;\n+                        }\n+                    }\n+                }\n+            }\n+\n+            final KmerAdjacency end = contig.getLastKmer();\n+            final int successorCount = end.getSuccessorCount();\n+            if ( successorCount > 0 ) {\n+                final List<Contig> successors = contig.getSuccessors();\n+                final int mask = end.getSuccessorMask();\n+                for ( int call = 0; call != 4; ++call ) {\n+                    if ( (mask & (1 << call)) != 0 ) {\n+                        final long kVal = end.getSuccessorVal(call);\n+                        final ContigEndKmer contigEndKmer = contigEnds.find(new Kmer(kVal));\n+                        if ( contigEndKmer == null ) {\n+                            throw new GATKException(\"missing contig end kmer\");\n+                        }\n+                        switch ( contigEndKmer.getContigOrientation() ) {\n+                            case FWD:\n+                                successors.add(contigEndKmer.getContig());\n+                                break;\n+                            case REV:\n+                                successors.add(contigEndKmer.getContig().rc());\n+                                break;\n+                            case BOTH:\n+                                successors.add(contigEndKmer.getContig());\n+                                successors.add(contigEndKmer.getContig().rc());\n+                                break;\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    /** remove contigs that have little evidence **/\n+    @VisibleForTesting\n+    static void removeThinContigs( final List<ContigImpl> contigs,\n+                                           final KmerSet<KmerAdjacency> kmerAdjacencySet ) {\n+        contigs.sort(Comparator.comparingInt(ContigImpl::getMaxObservations));\n+        boolean contigRemoved;\n+        do {\n+            // figure out which contigs are cut points\n+            // i.e., those contigs which, if removed, would result in a graph with more connected components\n+            final int nContigs = contigs.size();\n+            final Map<Contig, CutData> cutDataMap = new HashMap<>(nContigs * 3);\n+\n+            for ( final ContigImpl contig : contigs ) {\n+                if ( cutDataMap.containsKey(contig) ) {\n+                    continue;\n+                }\n+\n+                cutDataMap.put(contig, new CutData());\n+                int children = 0;\n+                for ( final Contig nextContig : contig.getSuccessors() ) {\n+                    if ( !cutDataMap.containsKey(nextContig) ) {\n+                        findCuts(nextContig, contig, cutDataMap);\n+                        children += 1;\n+                    }\n+                }\n+                for ( final Contig nextContig : contig.getPredecessors() ) {\n+                    if ( !cutDataMap.containsKey(nextContig) ) {\n+                        findCuts(nextContig, contig, cutDataMap);\n+                        children += 1;\n+                    }\n+                }\n+                if ( children >= 2 ) {\n+                    contig.setCut(true);\n+                }\n+            }\n+\n+            // remove poorly attested (low max observations) contigs, unless they are cut points\n+            contigRemoved = false;\n+            final Iterator<ContigImpl> itr = contigs.iterator();\n+            while ( itr.hasNext() ) {\n+                final Contig contig = itr.next();\n+                if ( contig.getMaxObservations() < MIN_THIN_OBS && !contig.isCut() ) {\n+                    unlinkContig(contig, kmerAdjacencySet);\n+                    itr.remove();\n+                    contigRemoved = true;\n+                    break;\n+                }\n+            }\n+        } while ( contigRemoved );\n+        contigs.sort(Comparator.comparingInt(ContigImpl::getId));\n+    }\n+\n+    private static CutData findCuts( final Contig contig,\n+                                     final Contig parent,\n+                                     final Map<Contig, CutData> cutDataMap ) {\n+        final CutData cutData = new CutData();\n+        cutDataMap.put(contig, cutData);\n+        for ( final Contig nextContig : contig.getSuccessors() ) {\n+            if ( nextContig == parent ) {\n+                continue;\n+            }\n+            CutData nextCutData = cutDataMap.get(nextContig);\n+            if ( nextCutData != null ) {\n+                cutData.minVisitNum = Math.min(cutData.minVisitNum, nextCutData.visitNum);\n+            } else {\n+                nextCutData = findCuts(nextContig, contig, cutDataMap);\n+                cutData.minVisitNum = Math.min(cutData.minVisitNum, nextCutData.minVisitNum);\n+                if ( nextCutData.minVisitNum >= cutData.visitNum ) {\n+                    contig.setCut(true);\n+                }\n+            }\n+        }\n+        for ( final Contig nextContig : contig.getPredecessors() ) {\n+            if ( nextContig == parent ) {\n+                continue;\n+            }\n+            CutData nextCutData = cutDataMap.get(nextContig);\n+            if ( nextCutData != null ) {\n+                cutData.minVisitNum = Math.min(cutData.minVisitNum, nextCutData.visitNum);\n+            } else {\n+                nextCutData = findCuts(nextContig, contig, cutDataMap);\n+                cutData.minVisitNum = Math.min(cutData.minVisitNum, nextCutData.minVisitNum);\n+                if ( nextCutData.minVisitNum >= cutData.visitNum ) {\n+                    contig.setCut(true);\n+                }\n+            }\n+        }\n+        return cutData;\n+    }\n+\n+    @VisibleForTesting\n+    static void unlinkContig( final Contig contig,\n+                                      final KmerSet<KmerAdjacency> kmerAdjacencySet ) {\n+        final KmerAdjacency firstKmer = contig.getFirstKmer();\n+        final int firstKmerFinalCall = firstKmer.getFinalCall();\n+        for ( final Contig predecessor : contig.getPredecessors() ) {\n+            if ( predecessor != contig && predecessor != contig.rc() ) {\n+                predecessor.getLastKmer().removeSuccessor(firstKmerFinalCall, kmerAdjacencySet);\n+                if ( !predecessor.getSuccessors().remove(contig) ) {\n+                    throw new GATKException(\"failed to find predecessor link\");\n+                }\n+            }\n+        }\n+\n+        final KmerAdjacency lastKmer = contig.getLastKmer();\n+        final int lastKmerInitialCall = lastKmer.getInitialCall();\n+        for ( final Contig successor : contig.getSuccessors() ) {\n+            if ( successor != contig && successor != contig.rc() ) {\n+                successor.getFirstKmer().removePredecessor(lastKmerInitialCall, kmerAdjacencySet);\n+                if ( !successor.getPredecessors().remove(contig) ) {\n+                    throw new GATKException(\"failed to find successor link\");\n+                }\n+            }\n+        }\n+\n+        KmerAdjacency nextKmer = firstKmer;\n+        KmerAdjacency kmer;\n+        do {\n+            kmer = nextKmer;\n+            nextKmer = kmer.getSoleSuccessor();\n+            kmerAdjacencySet.remove(kmer.canonical());\n+        } while ( kmer != lastKmer );\n+    }\n+\n+    private static void updateKmerContig( final KmerAdjacency firstKmer,\n+                                          final KmerAdjacency lastKmer,\n+                                          final Contig contig ) {\n+        int offset = 0;\n+        for ( KmerAdjacency kmer = firstKmer; kmer != lastKmer; kmer = kmer.getSoleSuccessor() ) {\n+            if ( kmer == null ) {\n+                throw new GATKException(\"contig does not have a flat pipeline of kmers\");\n+            }\n+            kmer.clearContig();\n+            kmer.setContigOffset(contig, offset++);\n+        }\n+        lastKmer.clearContig();\n+        lastKmer.setContigOffset(contig, offset);\n+        if ( offset + Kmer.KSIZE != contig.size() ) {\n+            throw new GATKException(\"kmer chain length does not equal contig size\");\n+        }\n+    }\n+\n+    /** replace adjacent contigs without branches with a single, larger contig **/\n+    @VisibleForTesting\n+    static void weldPipes( final List<ContigImpl> contigs ) {\n+        for ( int contigIdx = 0; contigIdx != contigs.size(); ++contigIdx ) {\n+            final ContigImpl contig = contigs.get(contigIdx);\n+            if ( contig.getSuccessors().size() == 1 ) {\n+                final Contig successor = contig.getSuccessors().get(0);\n+                if ( successor != contig && successor != contig.rc() &&\n+                        successor.getPredecessors().size() == 1 ) {\n+                    contigs.set(contigIdx, join(contig.getId(), contig, successor));\n+                    if ( !contigs.remove(successor.canonical()) ) {\n+                        throw new GATKException(\"successor linkage is messed up\");\n+                    }\n+                    contigIdx -= 1; // reconsider the new contig -- there might be more joining possible\n+                    continue;\n+                }\n+            }\n+            if ( contig.getPredecessors().size() == 1 ) {\n+                final Contig predecessor = contig.getPredecessors().get(0);\n+                if ( predecessor != contig && predecessor != contig.rc() &&\n+                        predecessor.getSuccessors().size() == 1 ) {\n+                    contigs.set(contigIdx, join(contig.getId(), predecessor, contig));\n+                    if ( !contigs.remove(predecessor.canonical()) ) {\n+                        throw new GATKException(\"predecessor linkage is messed up\");\n+                    }\n+                    contigIdx -= 1; // reconsider\n+                }\n+            }\n+        }\n+    }\n+\n+    private static ContigImpl join( final int id, final Contig predecessor, final Contig successor ) {\n+        if ( !checkOverlap(predecessor.getSequence(), successor.getSequence()) ) {\n+                throw new GATKException(\"sequences can't be joined\");\n+        }\n+        final ContigImpl joinedContig = new ContigImpl(id, predecessor, successor);\n+        updateKmerContig(joinedContig.getFirstKmer(), joinedContig.getLastKmer(), joinedContig);\n+        return joinedContig;\n+    }\n+\n+    private static boolean checkOverlap( final CharSequence seq1, final CharSequence seq2 ) {\n+        final int seq1Len = seq1.length();\n+        final CharSequence seq1SubSeq = seq1.subSequence(seq1Len - Kmer.KSIZE + 1, seq1Len);\n+        final CharSequence seq2SubSeq = seq2.subSequence(0, Kmer.KSIZE - 1);\n+        return seq1SubSeq.equals(seq2SubSeq);\n+    }\n+\n+    /** set a unique componentId for every connected group of contigs **/\n+    @VisibleForTesting\n+    static int markComponents( final List<ContigImpl> contigs ) {\n+        for ( final ContigImpl contig : contigs ) {\n+            contig.setComponentId(0);\n+        }\n+\n+        int componentId = 0;\n+        for ( final ContigImpl contig : contigs ) {\n+            if ( contig.getComponentId() == 0 ) {\n+                contig.setComponentId(++componentId);\n+                markSuccessorComponents(contig);\n+                markSuccessorComponents(contig.rc());\n+            }\n+        }\n+        return componentId;\n+    }\n+\n+    private static void markSuccessorComponents( final Contig contig ) {\n+        final int componentId = contig.getComponentId();\n+        for ( final Contig successor : contig.getSuccessors() ) {\n+            if ( successor.getComponentId() == 0 ) {\n+                successor.canonical().setComponentId(componentId);\n+                markSuccessorComponents(successor);\n+                markSuccessorComponents(successor.rc());\n+            }\n+        }\n+    }\n+\n+    @VisibleForTesting\n+    static void markCycles( final List<ContigImpl> contigs ) {\n+        for ( final Contig contig : contigs ) {\n+            contig.setCyclic(false);\n+        }\n+\n+        final int nContigs = contigs.size();\n+        final Deque<Contig> deque = new ArrayDeque<>(nContigs);\n+        final Map<Contig, CutData> cutDataMap = new HashMap<>(nContigs * 3);\n+        for ( final Contig contig : contigs ) {\n+            if ( !cutDataMap.containsKey(contig) ) {\n+                markCyclesRecursion(contig, deque, cutDataMap);\n+            }\n+        }\n+    }\n+\n+    private static CutData markCyclesRecursion( final Contig contig,\n+                                                final Deque<Contig> deque,\n+                                                final Map<Contig, CutData> cutDataMap ) {\n+        final CutData cutData = new CutData();\n+        cutDataMap.put(contig, cutData);\n+        deque.addFirst(contig);\n+\n+        for ( final Contig successor : contig.getSuccessors() ) {\n+            final CutData successorCutData = cutDataMap.get(successor);\n+            if ( successorCutData == null ) {\n+                final int recursionVisitNum =\n+                        markCyclesRecursion(successor, deque, cutDataMap).minVisitNum;\n+                cutData.minVisitNum = Math.min(cutData.minVisitNum, recursionVisitNum);\n+            } else {\n+                cutData.minVisitNum = Math.min(cutData.minVisitNum, successorCutData.visitNum);\n+            }\n+        }\n+\n+        if ( cutData.visitNum == cutData.minVisitNum ) {\n+            Contig tig = deque.removeFirst();\n+            if ( tig == contig ) {\n+                cutDataMap.get(tig).visitNum = Integer.MAX_VALUE;\n+\n+                // single-vertex component -- cyclic only if self-referential\n+                if ( tig.getSuccessors().contains(tig) ) {\n+                    tig.setCyclic(true);\n+                }\n+            } else {\n+                while ( true ) {\n+                    // kill cross-links\n+                    cutDataMap.get(tig).visitNum = Integer.MAX_VALUE;\n+                    tig.setCyclic(true);\n+                    if ( tig == contig ) break;\n+                    tig = deque.removeFirst();\n+                }\n+            }\n+        }\n+        return cutData;\n+    }\n+\n+    @VisibleForTesting\n+    static boolean fillGaps( final KmerSet<KmerAdjacency> kmerAdjacencySet,\n+                             final List<GATKRead> reads ) {\n+        final Map<String, Integer> gapFillCounts = new HashMap<>();\n+        for ( final GATKRead read : reads ) {\n+            final Path path = new Path(read.getBasesNoCopy(), kmerAdjacencySet);\n+            final List<PathPart> parts = path.getParts();\n+            final int lastIdx = parts.size() - 1;\n+            for ( int idx = 1; idx < lastIdx; ++idx ) {\n+                final PathPart pathPart = parts.get(idx);\n+                if ( pathPart.isGap() ) {\n+                    final char prevCall = parts.get(idx - 1).getLastCall();\n+                    final char nextCall = parts.get(idx + 1).getFirstCall();\n+                    String gapFill = prevCall + pathPart.getSequence().toString() + nextCall;\n+                    final SequenceRC gapFillRC = new SequenceRC(gapFill);\n+                    if ( gapFillRC.compareTo(gapFill) < 0 ) {\n+                        gapFill = gapFillRC.toString();\n+                    }\n+                    gapFillCounts.merge(gapFill, 1, Integer::sum);\n+                }\n+            }\n+        }\n+\n+        boolean newKmers = false;\n+        for ( final Map.Entry<String, Integer> entry : gapFillCounts.entrySet() ) {\n+            final int nObservations = entry.getValue();\n+            if ( nObservations >= MIN_GAPFILL_COUNT ) {\n+                KmerAdjacency.kmerize(entry.getKey(), nObservations, kmerAdjacencySet);\n+                newKmers = true;\n+            }\n+        }\n+\n+        if ( newKmers ) {\n+            for ( final KmerAdjacency kmerAdjacency : kmerAdjacencySet ) {\n+                kmerAdjacency.clearContig();\n+            }\n+        }\n+        return newKmers;\n+    }\n+\n+    @VisibleForTesting\n+    static List<Path> pathReads( final KmerSet<KmerAdjacency> kmerAdjacencySet,\n+                          final List<GATKRead> reads ) {\n+        final List<Path> readPaths = new ArrayList<>(reads.size());\n+        for ( final GATKRead read : reads ) {\n+            readPaths.add(new Path(read.getBasesNoCopy(), kmerAdjacencySet));\n+        }\n+        return readPaths;\n+    }\n+\n+    @VisibleForTesting\n+    static Map<Contig,List<TransitPairCount>> collectTransitPairCounts(\n+            final List<ContigImpl> contigs,\n+            final List<Path> readPaths ) {\n+        final Map<Contig,List<TransitPairCount>> contigTransitsMap =\n+                new HashMap<>(3 * contigs.size());\n+        for ( final Path path : readPaths ) {\n+            final List<PathPart> parts = path.getParts();\n+            final int lastPart = parts.size() - 1;\n+            for ( int partIdx = 1; partIdx < lastPart; ++partIdx ) {\n+                final Contig prevContig = parts.get(partIdx - 1).getContig();\n+                if ( prevContig == null ) continue;\n+                final Contig curContig = parts.get(partIdx).getContig();\n+                if ( curContig == null ) {\n+                    partIdx += 1;\n+                    continue;\n+                }\n+                final Contig nextContig = parts.get(partIdx + 1).getContig();\n+                if ( nextContig == null ) {\n+                    partIdx += 2;\n+                    continue;\n+                }\n+                final TransitPairCount tpc = new TransitPairCount(prevContig, nextContig);\n+                final List<TransitPairCount> tpcList =\n+                        contigTransitsMap.computeIfAbsent(curContig, tig -> new ArrayList<>(4));\n+                final int idx = tpcList.indexOf(tpc);\n+                if ( idx != -1 ) {\n+                    tpcList.get(idx).observe();\n+                } else {\n+                    tpcList.add(tpc);\n+                    contigTransitsMap.computeIfAbsent(curContig.rc(), tig -> new ArrayList<>(4))\n+                            .add(tpc.getRC());\n+                }\n+            }\n+        }\n+        return contigTransitsMap;\n+    }\n+\n+    @VisibleForTesting\n+    static Set<Traversal> traverseAllPaths(\n+            final List<ContigImpl> contigs,\n+            final List<Path> readPaths,\n+            final Map<Contig, List<TransitPairCount>> contigTransitsMap ) {\n+        final Set<Traversal> traversalSet = new HashSet<>();\n+        final List<Contig> contigsList = new ArrayList<>();\n+        for ( final Contig contig : contigs ) {\n+            // untransited contigs are sources, sinks, or large contigs that can't be crossed by a read\n+            // build traversals from these\n+            if ( !contigTransitsMap.containsKey(contig) ) {\n+                boolean done = false;\n+                for ( final Contig successor : contig.getSuccessors() ) {\n+                    traverse(successor, contig,\n+                            contigsList, readPaths, contigTransitsMap, traversalSet);\n+                    done = true;\n+                }\n+                for ( final Contig predecessor : contig.getPredecessors() ) {\n+                    traverse(predecessor.rc(), contig.rc(),\n+                            contigsList, readPaths, contigTransitsMap, traversalSet);\n+                    done = true;\n+                }\n+                if ( !done ) { // if there were no predecessors or successors, it stands alone\n+                    addTraversal(new Traversal(Collections.singletonList(contig)), traversalSet);\n+                }\n+            }\n+        }\n+\n+        // look for transits that haven't been traced\n+        for ( final Map.Entry<Contig, List<TransitPairCount>> entry :\n+                contigTransitsMap.entrySet() ) {\n+            for ( final TransitPairCount tpc : entry.getValue() ) {\n+                if ( tpc.getCount() > 0 ) {\n+                    tpc.resetCount();\n+                    final Contig contig = entry.getKey();\n+                    final Set<Traversal> fwdTraversalSet = new HashSet<>();\n+                    traverse(tpc.getNextContig(), contig,\n+                            contigsList, readPaths, contigTransitsMap, fwdTraversalSet);\n+                    final Set<Traversal> revTraversalSet = new HashSet<>();\n+                    traverse(tpc.getPrevContig().rc(), contig.rc(),\n+                            contigsList, readPaths, contigTransitsMap, revTraversalSet);\n+                    for ( final Traversal revTraversal : revTraversalSet ) {\n+                        final Traversal revTraversalRC = revTraversal.rc();\n+                        for ( final Traversal fwdTraversal : fwdTraversalSet ) {\n+                            final int overlap =\n+                                    findMaxOverlap(revTraversalRC.getContigs(), fwdTraversal.getContigs());\n+                            final Traversal combo =\n+                                    Traversal.combineOverlappers(revTraversalRC, fwdTraversal, overlap);\n+                            addTraversal(combo, traversalSet);\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+\n+        return traversalSet;\n+    }\n+\n+    private static int findMaxOverlap( final List<Contig> prefixes, final List<Contig> suffixes ) {\n+        final int nPrefixes = prefixes.size();\n+        final Contig firstSuffix = suffixes.get(0);\n+        if ( !firstSuffix.isCyclic() ) {\n+            return prefixes.get(nPrefixes - 1) == firstSuffix ? 1 : 0;\n+        }\n+        final int nSuffixes = suffixes.size();\n+        for ( int prefixIdx = Math.max(0, nPrefixes - nSuffixes); prefixIdx != nPrefixes; ++prefixIdx ) {\n+            if ( prefixes.get(prefixIdx) == firstSuffix ) {\n+                int suffixIdx = 1;\n+                boolean match = true;\n+                for ( int prefixIdx2 = prefixIdx + 1; prefixIdx2 != nPrefixes; ++prefixIdx2 ) {\n+                    if ( prefixes.get(prefixIdx2) != suffixes.get(suffixIdx++) ) {\n+                        match = false;\n+                        break;\n+                    }\n+                }\n+                if ( match ) {\n+                    return nPrefixes - prefixIdx;\n+                }\n+            }\n+        }\n+        return 0;\n+    }\n+\n+    private static void traverse( final Contig contig,\n+                                  final Contig predecessor,\n+                                  final List<Contig> contigsList,\n+                                  final List<Path> readPaths,\n+                                  final Map<Contig, List<TransitPairCount>> contigTransitsMap,\n+                                  final Set<Traversal> traversalSet ) {\n+        contigsList.add(predecessor);\n+        if ( contig.isCyclic() ) {\n+            traverseCycle(contig, contigsList, readPaths, contigTransitsMap, traversalSet);\n+            contigsList.remove(contigsList.size() - 1);\n+            return;\n+        }\n+        final List<TransitPairCount> transits = contigTransitsMap.get(contig);\n+        boolean done = false;\n+        if ( transits != null ) {\n+            for ( final TransitPairCount tpc : transits ) {\n+                if ( tpc.getPrevContig() == predecessor ) {\n+                    final Contig successor = tpc.getNextContig();\n+                    if ( predecessor == contig.rc() ) {\n+                        final int nContigs = contigsList.size();\n+                        if ( nContigs > 1 ) {\n+                            if ( successor.rc() == contigsList.get(nContigs - 2) ) {\n+                                continue;\n+                            }\n+                        }\n+                    }\n+                    tpc.resetCount();\n+                    traverse(successor, contig, contigsList, readPaths, contigTransitsMap, traversalSet);\n+                    done = true;\n+                }\n+            }\n+        }\n+        if ( !done ) {\n+            contigsList.add(contig);\n+            addTraversal(new Traversal(contigsList), traversalSet);\n+            contigsList.remove(contigsList.size() - 1);\n+        }\n+        contigsList.remove(contigsList.size() - 1);\n+    }\n+\n+    private static void traverseCycle( final Contig contig,\n+                                       final List<Contig> contigsList,\n+                                       final List<Path> readPaths,\n+                                       final Map<Contig, List<TransitPairCount>> contigTransitsMap,\n+                                       final Set<Traversal> traversalSet ) {\n+        contigsList.add(contig);\n+        final int nContigs = contigsList.size();\n+        // the final element of the list is cyclic, if there's a previous element it will be\n+        // non-cyclic, so start there figuring out how far the read paths lead us\n+        final List<List<Contig>> longestPaths =\n+                findLongestPaths(contigsList.subList(Math.max(0, nContigs - 2), nContigs), readPaths);\n+        // didn't get anywhere -- just complete the traversal\n+        if ( longestPaths.isEmpty() ) {\n+            addTraversal(new Traversal(contigsList, true), traversalSet);\n+        } else {\n+            // for each unique extension into the cycle\n+            for ( final List<Contig> path : longestPaths ) {\n+                // don't think this can happen, but still\n+                if ( path.isEmpty() ) {\n+                    addTraversal(new Traversal(contigsList, true), traversalSet);\n+                    continue;\n+                }\n+                final List<Contig> extendedContigsList =\n+                        new ArrayList<>(contigsList.size() + path.size());\n+                extendedContigsList.addAll(contigsList);\n+                // if we didn't get out of the cycle\n+                if ( path.get(path.size() - 1).isCyclic() ) {\n+                    extendedContigsList.addAll(path);\n+                    addTraversal(new Traversal(extendedContigsList, true), traversalSet);\n+                } else {\n+                    // we found a cycle-exiting path, so extend that normally\n+                    for ( final Contig curContig : path ) {\n+                        if ( curContig.isCyclic() ) {\n+                            extendedContigsList.add(curContig);\n+                        } else {\n+                            final Contig prevContig =\n+                                    extendedContigsList.remove(extendedContigsList.size() - 1);\n+                            traverse(curContig, prevContig, extendedContigsList, readPaths,\n+                                    contigTransitsMap, traversalSet);\n+                            extendedContigsList.add(prevContig);\n+                            break;\n+                        }\n+                    }\n+                }\n+                clearTransitPairs(contigTransitsMap, extendedContigsList);\n+            }\n+        }\n+        contigsList.remove(contigsList.size() - 1);\n+    }\n+\n+    private static void clearTransitPairs(\n+            final Map<Contig, List<TransitPairCount>> contigTransitsMap,\n+            final List<Contig> contigsList ) {\n+        final int lastIdx = contigsList.size() - 1;\n+        for ( int idx = 1; idx < lastIdx; ++idx ) {\n+            final List<TransitPairCount> pairCounts = contigTransitsMap.get(contigsList.get(idx));\n+            if ( pairCounts != null ) {\n+                final Contig predecessor = contigsList.get(idx - 1);\n+                final Contig successor = contigsList.get(idx + 1);\n+                for ( final TransitPairCount tpc : pairCounts ) {\n+                    if ( tpc.getPrevContig() == predecessor && tpc.getNextContig() == successor ) {\n+                        tpc.resetCount();\n+                        break;\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    private static void addTraversal( final Traversal traversal,\n+                                      final Set<Traversal> traversalSet ) {\n+        if ( !traversalSet.contains(traversal.rc()) ) {\n+            traversalSet.add(traversal);\n+            if ( traversalSet.size() >= TOO_MANY_TRAVERSALS ) {\n+                throw new AssemblyTooComplexException();\n+            }\n+        }\n+    }\n+\n+    private static List<List<Contig>> findLongestPaths( final List<Contig> toMatch,\n+                                                        final List<Path> readPaths ) {\n+        final List<List<Contig>> results = new ArrayList<>();\n+        for ( final Path path : readPaths ) {\n+            testPath(path, toMatch, results);\n+            testPath(path.rc(), toMatch, results);\n+        }\n+        return results;\n+    }\n+\n+    private static void testPath( final Path path,\n+                                  final List<Contig> toMatch,\n+                                  final List<List<Contig>> results ) {\n+        final List<PathPart> pathParts = path.getParts();\n+        final int nPathParts = pathParts.size();\n+        final List<Contig> pathContigs = new ArrayList<>(nPathParts);\n+        pathParts.forEach(pp -> pathContigs.add(pp.getContig()));\n+        final int matchIdx = Collections.indexOfSubList(pathContigs, toMatch);\n+        if ( matchIdx != -1 ) {\n+            final int suffixIdx = matchIdx + toMatch.size();\n+            if ( suffixIdx < nPathParts ) {\n+                resolveResult(grabParts(pathContigs, suffixIdx), results);\n+            }\n+        }\n+    }\n+\n+    private static List<Contig> grabParts( final List<Contig> pathContigs, final int suffixIdx ) {\n+        final int nPathContigs = pathContigs.size();\n+        Contig prev = pathContigs.get(suffixIdx - 1);\n+        final List<Contig> result = new ArrayList<>(nPathContigs - suffixIdx);\n+        for ( int idx = suffixIdx; idx != nPathContigs; ++idx ) {\n+            final Contig tig = pathContigs.get(idx);\n+            if ( tig == null || !prev.getSuccessors().contains(tig) ) break;\n+            result.add(tig);\n+            prev = tig;\n+        }\n+        return result;\n+    }\n+\n+    private static void resolveResult( final List<Contig> result,\n+                                       final List<List<Contig>> results ) {\n+        final int nResults = results.size();\n+        for ( int idx = 0; idx != nResults; ++idx ) {\n+            final List<Contig> test = results.get(idx);\n+            if ( isPrefix(result, test) ) return;\n+            if ( isPrefix(test, result) ) {\n+                results.set(idx, result);\n+                return;\n+            }\n+        }\n+        results.add(result);\n+    }\n+\n+    private static boolean isPrefix( final List<Contig> list1, final List<Contig> list2 ) {\n+        final int list1Size = list1.size();\n+        final int list2Size = list2.size();\n+        if ( list1Size > list2Size ) return false;\n+        for ( int idx = 0; idx != list1Size; ++idx ) {\n+            if ( list1.get(idx) != list2.get(idx) ) return false;\n+        }\n+        return true;\n+    }\n+\n+    @VisibleForTesting\n+    static Collection<Traversal> createScaffolds( final List<Traversal> allTraversals ) {\n+        removeTriviallyDifferentTraversals(allTraversals);\n+\n+        final int nTraversals = allTraversals.size();\n+        final Map<Contig, List<Integer>> traversalsByFirstContig = new HashMap<>(3 * nTraversals);\n+        for ( int idx = 0; idx != nTraversals; ++idx ) {\n+            final Traversal traversal = allTraversals.get(idx);\n+            traversalsByFirstContig.compute(traversal.getFirstContig(),\n+                    ( k, v ) -> v == null ? new ArrayList<>(3) : v).add(idx);\n+            final Traversal rcTraversal = traversal.rc();\n+            traversalsByFirstContig.compute(rcTraversal.getFirstContig(),\n+                    ( k, v ) -> v == null ? new ArrayList<>(3) : v).add(~idx);\n+        }\n+\n+        final List<Traversal> scaffolds = new ArrayList<>(nTraversals);\n+        final boolean[] touched = new boolean[nTraversals];\n+        for ( int idx = 0; idx != nTraversals; ++idx ) {\n+            if ( !touched[idx] ) {\n+                expandTraversal(idx, touched, traversalsByFirstContig, allTraversals, scaffolds);\n+            }\n+        }\n+        return scaffolds;\n+    }\n+\n+    private static void expandTraversal( final int traversalIdx,\n+                                         final boolean[] touched,\n+                                         final Map<Contig, List<Integer>> traversalsByFirstContig,\n+                                         final List<Traversal> allTraversals,\n+                                         final List<Traversal> scaffolds ) {\n+        final Traversal traversal = allTraversals.get(traversalIdx);\n+        touched[traversalIdx] = true;\n+        final List<Traversal> downExtensions = new ArrayList<>();\n+        final Set<Contig> startingContigSet = new HashSet<>();\n+        walkTraversals(traversal, touched, startingContigSet, traversalsByFirstContig,\n+                        allTraversals, downExtensions);\n+        final List<Traversal> upExtensions = new ArrayList<>();\n+        walkTraversals(traversal.rc(), touched, startingContigSet, traversalsByFirstContig,\n+                        allTraversals, upExtensions);\n+        for ( final Traversal down : downExtensions ) {\n+            for ( final Traversal up : upExtensions ) {\n+                if ( scaffolds.size() >= TOO_MANY_SCAFFOLDS ) {\n+                    throw new AssemblyTooComplexException();\n+                }\n+                scaffolds.add(Traversal.combineOverlappers(up.rc(), down, traversal.getContigs().size()));\n+            }\n+        }\n+    }\n+\n+    private static void walkTraversals( final Traversal traversal,\n+                                        final boolean[] touched,\n+                                        final Set<Contig> startingContigSet,\n+                                        final Map<Contig, List<Integer>> traversalsByFirstContig,\n+                                        final List<Traversal> allTraversals,\n+                                        final List<Traversal> extensions ) {\n+        final Contig firstContig = traversal.getFirstContig();\n+        final List<Integer> indexList;\n+        if ( startingContigSet.contains(firstContig) ||\n+                traversal.isInextensible() ||\n+                (indexList = traversalsByFirstContig.get(traversal.getLastContig())) == null ) {\n+            extensions.add(traversal);\n+            return;\n+        }\n+        startingContigSet.add(firstContig);\n+        for ( int idx : indexList ) {\n+            final Traversal extension;\n+            if ( idx >= 0 ) {\n+                extension = allTraversals.get(idx);\n+                touched[idx] = true;\n+            } else {\n+                final int rcIdx = ~idx;\n+                extension = allTraversals.get(rcIdx).rc();\n+                touched[rcIdx] = true;\n+            }\n+            walkTraversals(Traversal.combine(traversal, extension), touched, startingContigSet,\n+                            traversalsByFirstContig, allTraversals, extensions );\n+        }\n+        startingContigSet.remove(firstContig);\n+    }\n+\n+    private static void removeTriviallyDifferentTraversals(\n+                                            final Collection<Traversal> allTraversals ) {\n+        if ( allTraversals.isEmpty() ) {\n+            return;\n+        }\n+        final TreeSet<Traversal> sortedTraversals = new TreeSet<>(new TraversalEndpointComparator());\n+        for ( final Traversal traversal : allTraversals ) {\n+            sortedTraversals.add(traversal);\n+            sortedTraversals.add(traversal.rc());\n+        }\n+        final Iterator<Traversal> traversalIterator = sortedTraversals.iterator();\n+        Traversal prevTraversal = traversalIterator.next();\n+        while ( traversalIterator.hasNext() ) {\n+            final Traversal curTraversal = traversalIterator.next();\n+            if ( isTriviallyDifferent(prevTraversal, curTraversal) ) {\n+                traversalIterator.remove();\n+            } else {\n+                prevTraversal = curTraversal;\n+            }\n+        }\n+        sortedTraversals.removeIf(Traversal::isRC);\n+        allTraversals.clear();\n+        allTraversals.addAll(sortedTraversals);\n+    }\n+\n+    private static boolean isTriviallyDifferent( final Traversal traversal1,\n+                                                 final Traversal traversal2 ) {\n+        final Contig firstContig1 = traversal1.getFirstContig();\n+        final Contig lastContig1 = traversal1.getLastContig();\n+        final Contig firstContig2 = traversal2.getFirstContig();\n+        final Contig lastContig2 = traversal2.getLastContig();\n+        if ( firstContig1 != firstContig2 || lastContig1 != lastContig2 ) {\n+            return false;\n+        }\n+        final int interiorSize1 = traversal1.getSequenceLength() - firstContig1.size() - lastContig1.size();\n+        final int interiorSize2 = traversal2.getSequenceLength() - firstContig2.size() - lastContig2.size();\n+\n+        // if the path lengths are so different that one could harbor an SV, they're not trivially different\n+        if ( Math.abs(interiorSize1 - interiorSize2) >= MIN_SV_SIZE ) {\n+            return false;\n+        }\n+\n+        // if the paths are small enough that there can't be an SV's worth of differences, they're trivially different\n+        final int maxInteriorSize = Math.max(interiorSize1, interiorSize2);\n+        if ( maxInteriorSize < MIN_SV_SIZE ) {\n+            return true;\n+        }\n+\n+        // dang, maybe there's enough material in common that there can't be an SV's worth of differences\n+        // run a longest common subsequence algorithm to figure out the length of the common material\n+        // DP matrix holds length of common material\n+        final List<Contig> contigs1 = traversal1.getContigs();\n+        final int rowLen = contigs1.size() - 1;\n+        final int[][] rowPair = new int[2][];\n+        rowPair[0] = new int[rowLen];\n+        rowPair[1] = new int[rowLen];\n+        int pairIdx = 0;\n+        final List<Contig> contigs2 = traversal2.getContigs();\n+        final int nRows = contigs2.size() - 1;\n+        for ( int idx2 = 1; idx2 != nRows; ++idx2 ) {\n+            final int[] curRow = rowPair[pairIdx];\n+            final int[] prevRow = rowPair[pairIdx ^ 1];\n+            pairIdx ^= 1;\n+\n+            final int id2 = contigs2.get(idx2).getId();\n+            for ( int idx1 = 1; idx1 != rowLen; ++idx1 ) {\n+                final Contig tig1 = contigs1.get(idx1);\n+                if ( tig1.getId() == id2 ) {\n+                    // if the previous cells also contain a match we've already removed the K-1 bases upstream\n+                    final boolean extendMatch =\n+                            contigs1.get(idx1 -1).getId() == contigs2.get(idx2 - 1).getId();\n+                    curRow[idx1] = prevRow[idx1 - 1] + (extendMatch ? tig1.getNKmers() : tig1.size());\n+                } else {\n+                    curRow[idx1] = Math.max(curRow[idx1 - 1], prevRow[idx1]);\n+                }\n+            }\n+        }\n+        final int commonLen = rowPair[pairIdx ^ 1][rowLen - 1];\n+        return (maxInteriorSize - commonLen) < MIN_SV_SIZE;\n+    }\n+\n+    private static class TraversalEndpointComparator implements Comparator<Traversal> {\n+        @Override\n+        public int compare( final Traversal traversal1, final Traversal traversal2 ) {\n+            int cmp = Integer.compare(traversal1.contigs.get(0).getId(),\n+                                      traversal2.contigs.get(0).getId());\n+            if ( cmp != 0 ) {\n+                return cmp;\n+            }\n+            final int last1 = traversal1.contigs.size() - 1;\n+            final int last2 = traversal2.contigs.size() - 1;\n+            cmp = Integer.compare(traversal1.contigs.get(last1).getId(),\n+                                  traversal2.contigs.get(last2).getId());\n+            if ( cmp != 0 ) {\n+                return cmp;\n+            }\n+            // among those starting and ending at the same place, sort least observed last\n+            return -Integer.compare(traversal1.getMinMaxObservations(), traversal2.getMinMaxObservations());\n+        }\n+    }\n+\n+    private static void writeDOT( final List<ContigImpl> contigs, final String fileName ) {\n+        try ( final BufferedWriter writer = new BufferedWriter(new FileWriter(fileName)) ) {\n+            writer.write(\"digraph {\\n\");\n+            for ( final Contig contig : contigs ) {\n+                final double width = contig.getSequence().length() / 100.;\n+                writer.write(contig + \" [width=\" + width + \"]\\n\");\n+                writer.write( contig.rc() + \" [width=\" + width + \"]\\n\");\n+            }\n+            for ( final Contig contig : contigs ) {\n+                for ( final Contig predecessor : contig.getPredecessors() ) {\n+                    final String predecessorName = predecessor.rc().toString();\n+                    writer.write(contig.rc() + \" -> \" + predecessorName + \"\\n\");\n+                }\n+                for ( final Contig successor : contig.getSuccessors() ) {\n+                    final String successorName = successor.toString();\n+                    writer.write(contig + \" -> \" + successorName + \"\\n\");\n+                }\n+            }\n+            writer.write(\"}\\n\");\n+        } catch ( final IOException ioe ) {\n+            throw new GATKException(\"Failed to write assembly DOT file.\", ioe);\n+        }\n+    }\n+\n+    private static BufferedWriter makeGZFile( final String fileName ) throws IOException {\n+        final GZIPOutputStream gzOS = new GZIPOutputStream(BucketUtils.createFile(fileName));\n+        return new BufferedWriter(new OutputStreamWriter(gzOS));\n+    }\n+\n+    private static void writeContigs( final List<ContigImpl> contigs, final String fileName ) {\n+        try ( final BufferedWriter writer = makeGZFile(fileName) ) {\n+            for ( final Contig contig : contigs ) {\n+                final List<Contig> predecessors = contig.getPredecessors();\n+                final String predecessorDescription;\n+                if ( predecessors.size() == 0 ) {\n+                    predecessorDescription = \"\\tnone\";\n+                } else {\n+                    final StringBuilder sb = new StringBuilder();\n+                    char prefix = '\\t';\n+                    for ( final Contig predecessor : predecessors ) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5NzkwNjE1Mw=="}, "originalCommit": {"oid": "e2201c1ef4f8ba71f17e169f07756cfe2f1ecb49"}, "originalPosition": 1150}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzc3NjcxNTUzOnYy", "diffSide": "RIGHT", "path": "src/main/java/org/broadinstitute/hellbender/tools/LocalAssembler.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMy0xOVQxODo1NTozN1rOI6Neow==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMy0xOVQxODo1NTozN1rOI6Neow==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5NzkwOTE1NQ==", "bodyText": "I think we are supposed to be using GATKPath to construct input and output file paths whenever possible. I'd consider changing these parameters to take a GATKPath pointing to an output directory and a filename prefix.", "url": "https://github.com/broadinstitute/gatk/pull/6989#discussion_r597909155", "createdAt": "2021-03-19T18:55:37Z", "author": {"login": "cwhelan"}, "path": "src/main/java/org/broadinstitute/hellbender/tools/LocalAssembler.java", "diffHunk": "@@ -0,0 +1,2306 @@\n+package org.broadinstitute.hellbender.tools;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import htsjdk.samtools.Cigar;\n+import htsjdk.samtools.CigarElement;\n+import htsjdk.samtools.CigarOperator;\n+import htsjdk.samtools.SAMUtils;\n+import org.broadinstitute.barclay.argparser.Argument;\n+import org.broadinstitute.barclay.argparser.BetaFeature;\n+import org.broadinstitute.barclay.argparser.CommandLineProgramProperties;\n+import org.broadinstitute.barclay.help.DocumentedFeature;\n+import org.broadinstitute.hellbender.cmdline.StandardArgumentDefinitions;\n+import org.broadinstitute.hellbender.cmdline.programgroups.CoverageAnalysisProgramGroup;\n+import org.broadinstitute.hellbender.exceptions.GATKException;\n+import org.broadinstitute.hellbender.tools.walkers.PairWalker;\n+import org.broadinstitute.hellbender.utils.SimpleInterval;\n+import org.broadinstitute.hellbender.utils.collections.HopscotchSet;\n+import org.broadinstitute.hellbender.utils.gcs.BucketUtils;\n+import org.broadinstitute.hellbender.utils.read.GATKRead;\n+\n+import java.io.BufferedWriter;\n+import java.io.FileWriter;\n+import java.io.IOException;\n+import java.io.OutputStreamWriter;\n+import java.util.*;\n+import java.util.zip.GZIPOutputStream;\n+\n+@DocumentedFeature\n+@CommandLineProgramProperties(\n+        summary = \"experiment\",\n+        oneLineSummary = \"experiment\",\n+        usageExample = \"gatk LocalAssembler\",\n+        programGroup = CoverageAnalysisProgramGroup.class\n+)\n+@BetaFeature\n+public class LocalAssembler extends PairWalker {\n+    public static final byte QMIN = 25;\n+    public static final int MIN_THIN_OBS = 4;\n+    public static final int MIN_GAPFILL_COUNT = 3;\n+    public static final int TOO_MANY_TRAVERSALS = 100000;\n+    public static final int TOO_MANY_SCAFFOLDS = 50000;\n+    public static final int MIN_SV_SIZE = 50;\n+\n+    @Argument(fullName=StandardArgumentDefinitions.OUTPUT_LONG_NAME,\n+            shortName=StandardArgumentDefinitions.OUTPUT_SHORT_NAME,\n+            doc=\"Write outputs to this file name prefix\", optional = true)\n+    public static String output;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e2201c1ef4f8ba71f17e169f07756cfe2f1ecb49"}, "originalPosition": 47}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzc3NjgwODYyOnYy", "diffSide": "RIGHT", "path": "src/main/java/org/broadinstitute/hellbender/tools/LocalAssembler.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMy0xOVQxOToyMjo1MVrOI6OXfA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNC0xNlQxNDoyNzozNlrOJKZZDw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5NzkyMzcwOA==", "bodyText": "Is it your opinion that 31 is good enough for this problem? I remember in the spark pipeline we had an SVKmerLong class as well. Do you think we could build better graphs in some cases with longer kmers? Or do the read traversals remove the benefits? It looks like it might be tricky to support a long version of a kmer given the way KmerAdjacency is implemented.", "url": "https://github.com/broadinstitute/gatk/pull/6989#discussion_r597923708", "createdAt": "2021-03-19T19:22:51Z", "author": {"login": "cwhelan"}, "path": "src/main/java/org/broadinstitute/hellbender/tools/LocalAssembler.java", "diffHunk": "@@ -0,0 +1,2306 @@\n+package org.broadinstitute.hellbender.tools;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import htsjdk.samtools.Cigar;\n+import htsjdk.samtools.CigarElement;\n+import htsjdk.samtools.CigarOperator;\n+import htsjdk.samtools.SAMUtils;\n+import org.broadinstitute.barclay.argparser.Argument;\n+import org.broadinstitute.barclay.argparser.BetaFeature;\n+import org.broadinstitute.barclay.argparser.CommandLineProgramProperties;\n+import org.broadinstitute.barclay.help.DocumentedFeature;\n+import org.broadinstitute.hellbender.cmdline.StandardArgumentDefinitions;\n+import org.broadinstitute.hellbender.cmdline.programgroups.CoverageAnalysisProgramGroup;\n+import org.broadinstitute.hellbender.exceptions.GATKException;\n+import org.broadinstitute.hellbender.tools.walkers.PairWalker;\n+import org.broadinstitute.hellbender.utils.SimpleInterval;\n+import org.broadinstitute.hellbender.utils.collections.HopscotchSet;\n+import org.broadinstitute.hellbender.utils.gcs.BucketUtils;\n+import org.broadinstitute.hellbender.utils.read.GATKRead;\n+\n+import java.io.BufferedWriter;\n+import java.io.FileWriter;\n+import java.io.IOException;\n+import java.io.OutputStreamWriter;\n+import java.util.*;\n+import java.util.zip.GZIPOutputStream;\n+\n+@DocumentedFeature\n+@CommandLineProgramProperties(\n+        summary = \"experiment\",\n+        oneLineSummary = \"experiment\",\n+        usageExample = \"gatk LocalAssembler\",\n+        programGroup = CoverageAnalysisProgramGroup.class\n+)\n+@BetaFeature\n+public class LocalAssembler extends PairWalker {\n+    public static final byte QMIN = 25;\n+    public static final int MIN_THIN_OBS = 4;\n+    public static final int MIN_GAPFILL_COUNT = 3;\n+    public static final int TOO_MANY_TRAVERSALS = 100000;\n+    public static final int TOO_MANY_SCAFFOLDS = 50000;\n+    public static final int MIN_SV_SIZE = 50;\n+\n+    @Argument(fullName=StandardArgumentDefinitions.OUTPUT_LONG_NAME,\n+            shortName=StandardArgumentDefinitions.OUTPUT_SHORT_NAME,\n+            doc=\"Write outputs to this file name prefix\", optional = true)\n+    public static String output;\n+\n+    @Argument(fullName=\"assembly-name\", doc=\"name of assembly used as a prefix for traversal names\")\n+    public static String assemblyName;\n+\n+    private final List<GATKRead> reads = new ArrayList<>();\n+\n+    @Override public boolean requiresIntervals() { return true; }\n+\n+    @Override public void apply( final GATKRead read, final GATKRead mate ) {\n+        trimOverruns(read, mate);\n+        reads.add(read);\n+        reads.add(mate);\n+    }\n+\n+    @Override public void applyUnpaired( final GATKRead read ) {\n+        reads.add(read);\n+    }\n+\n+    @Override public Object onTraversalSuccess() {\n+        super.onTraversalSuccess(); // flush any incomplete pairs\n+\n+        final int regionSize = getTraversalIntervals().stream().mapToInt(SimpleInterval::size).sum();\n+        final KmerSet<KmerAdjacency> kmerAdjacencySet = new KmerSet<>(10 * regionSize);\n+        kmerizeReads(reads, kmerAdjacencySet);\n+        List<ContigImpl> contigs = buildContigs(kmerAdjacencySet);\n+        connectContigs(contigs);\n+\n+        removeThinContigs(contigs, kmerAdjacencySet);\n+        weldPipes(contigs);\n+        markComponents(contigs);\n+\n+        if ( fillGaps(kmerAdjacencySet, reads) ) {\n+            contigs = buildContigs(kmerAdjacencySet);\n+            connectContigs(contigs);\n+            removeThinContigs(contigs, kmerAdjacencySet);\n+            weldPipes(contigs);\n+            markComponents(contigs);\n+        }\n+\n+        markCycles(contigs);\n+\n+        final String outputFilePrefix = output != null ? output : assemblyName;\n+        final List<Path> readPaths = pathReads(kmerAdjacencySet, reads);\n+        final Map<Contig,List<TransitPairCount>> contigTransitsMap =\n+                collectTransitPairCounts(contigs, readPaths);\n+        final String traversalsFilename = outputFilePrefix + \".traversals.fa.gz\";\n+        try {\n+            final List<Traversal> allTraversals =\n+                    new ArrayList<>(traverseAllPaths(contigs, readPaths, contigTransitsMap));\n+            writeTraversals(allTraversals, traversalsFilename);\n+            try {\n+                final String scaffoldsFileName = outputFilePrefix + \".scaffolds.fa.gz\";\n+                writeTraversals(createScaffolds(allTraversals), scaffoldsFileName);\n+            } catch ( final AssemblyTooComplexException x ) {\n+                logger.warn(\"Assembly too complex for scaffolding.\");\n+            }\n+        } catch ( final AssemblyTooComplexException x ) {\n+            logger.warn(\"Assembly too complex.  Writing contigs as traversals in \" +\n+                    traversalsFilename + \".\");\n+            final Collection<Traversal> contigTraversals = new ArrayList<>(contigs.size());\n+            for ( final Contig contig : contigs ) {\n+                contigTraversals.add(new Traversal(Collections.singletonList(contig)));\n+            }\n+            writeTraversals(contigTraversals, traversalsFilename);\n+        }\n+\n+        contigs.sort(Comparator.comparingInt(ContigImpl::getId));\n+        writeDOT(contigs, outputFilePrefix + \".assembly.dot\");\n+        writeContigs(contigs, outputFilePrefix + \".contigs.txt.gz\");\n+        writePaths(readPaths, outputFilePrefix + \".paths.txt.gz\");\n+        writeReads(reads, outputFilePrefix + \".reads.fastq.gz\");\n+        return null;\n+    }\n+\n+    /** trim read pairs of base calls that have gone past the end of a short fragment */\n+    private void trimOverruns( final GATKRead read, final GATKRead mate ) {\n+        // if both mapped and they're on different strands\n+        if ( !read.isUnmapped() && !mate.isUnmapped() &&\n+                read.isReverseStrand() != mate.isReverseStrand() ) {\n+            // and both start within 1 base on the ref\n+            if ( Math.abs(read.getStart() - read.getMateStart()) <= 1 ) {\n+                // and both end within 1 base\n+                final int readRefLen = read.getCigar().getReferenceLength();\n+                final int mateRefLen = mate.getCigar().getReferenceLength();\n+                if ( Math.abs(readRefLen - mateRefLen) <= 1 ) {\n+                    if ( mate.isReverseStrand() ) {\n+                        trimClips(read, mate);\n+                    } else {\n+                        trimClips(mate, read);\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    private void trimClips( final GATKRead fwd, final GATKRead rev ) {\n+        final List<CigarElement> fwdElements = fwd.getCigarElements();\n+        final List<CigarElement> revElements = rev.getCigarElements();\n+        final int lastElementIdx = fwdElements.size() - 1;\n+        final CigarElement fwdLastElement = fwdElements.get(lastElementIdx);\n+        final CigarElement revFirstElement = revElements.get(0);\n+        if ( fwdLastElement.getOperator() == CigarOperator.S &&\n+                revFirstElement.getOperator() == CigarOperator.S ) {\n+            final byte[] fwdBases = fwd.getBasesNoCopy();\n+            final int lastElementLen = fwdLastElement.getLength();\n+            fwd.setBases(Arrays.copyOfRange(fwdBases, 0, fwdBases.length - lastElementLen));\n+            final byte[] fwdQuals = fwd.getBaseQualitiesNoCopy();\n+            if ( fwdQuals.length > 0 ) {\n+                final int qualsLen = fwdQuals.length - lastElementLen;\n+                fwd.setBaseQualities(Arrays.copyOfRange(fwdQuals, 0, qualsLen));\n+            }\n+            final List<CigarElement> newFwdElements = new ArrayList<>(fwdElements);\n+            newFwdElements.set(lastElementIdx, new CigarElement(lastElementLen, CigarOperator.H));\n+            fwd.setCigar(new Cigar(newFwdElements));\n+\n+            final byte[] revBases = rev.getBasesNoCopy();\n+            final int firstElementLen = revFirstElement.getLength();\n+            rev.setBases(Arrays.copyOfRange(revBases, firstElementLen, revBases.length));\n+            final byte[] revQuals = rev.getBaseQualitiesNoCopy();\n+            if ( revQuals.length > 0 ) {\n+                rev.setBaseQualities(Arrays.copyOfRange(revQuals, firstElementLen, revQuals.length));\n+            }\n+            final List<CigarElement> newRevElements = new ArrayList<>(revElements);\n+            newRevElements.set(0, new CigarElement(firstElementLen, CigarOperator.H));\n+            rev.setCigar(new Cigar(newRevElements));\n+        }\n+    }\n+\n+    @VisibleForTesting\n+    static void kmerizeReads( final List<GATKRead> reads,\n+                              final KmerSet<KmerAdjacency> kmerAdjacencySet ) {\n+        for ( final GATKRead read : reads ) {\n+            final byte[] calls = read.getBasesNoCopy();\n+            final byte[] quals = read.getBaseQualitiesNoCopy();\n+            KmerAdjacency.kmerize(calls, quals, QMIN, kmerAdjacencySet);\n+        }\n+    }\n+\n+    /** gather unbranched strings of kmers into contigs **/\n+    @VisibleForTesting\n+    static List<ContigImpl> buildContigs( final KmerSet<KmerAdjacency> kmerAdjacencySet ) {\n+        // gather strings of kmers that have a single predecessor and single successor into contigs\n+        final List<ContigImpl> contigs = new ArrayList<>();\n+        int nContigs = 0;\n+        for ( final KmerAdjacency kmerAdjacency : kmerAdjacencySet ) {\n+            if ( kmerAdjacency.getContig() == null ) {\n+                ContigImpl contig = null;\n+                final KmerAdjacency predecessor = kmerAdjacency.getSolePredecessor();\n+                if ( predecessor == null ||\n+                        predecessor.getSuccessorCount() > 1 ||\n+                        predecessor == kmerAdjacency.rc() ) {\n+                    contig = new ContigImpl(++nContigs, kmerAdjacency);\n+                } else {\n+                    final KmerAdjacency successor = kmerAdjacency.getSoleSuccessor();\n+                    if ( successor == null ||\n+                            successor.getPredecessorCount() > 1 ||\n+                            successor == kmerAdjacency.rc() ) {\n+                        contig = new ContigImpl(++nContigs, kmerAdjacency.rc());\n+                    }\n+                }\n+                if ( contig != null ) {\n+                    contigs.add(contig);\n+                }\n+            }\n+        }\n+\n+        // if there are smooth circles like a plasmid, gather them together as a contig, too\n+        for ( final KmerAdjacency kmerAdjacency : kmerAdjacencySet ) {\n+            if ( kmerAdjacency.getContig() == null ) {\n+                contigs.add(new ContigImpl(++nContigs, kmerAdjacency));\n+            }\n+        }\n+\n+        return contigs;\n+    }\n+\n+    /** connect contigs when the final kmer of one contig is adjacent to the inital contig of another **/\n+    @VisibleForTesting\n+    static void connectContigs( final List<ContigImpl> contigs ) {\n+        final int nContigs = contigs.size();\n+        final KmerSet<ContigEndKmer> contigEnds = new KmerSet<>(2*nContigs);\n+        for ( int contigId = 0; contigId != nContigs; ++contigId ) {\n+            final ContigImpl contig = contigs.get(contigId);\n+            final KmerAdjacency fwdKmer = contig.getFirstKmer();\n+            final KmerAdjacency revKmer = contig.getLastKmer().rc();\n+            if ( fwdKmer == revKmer ) {\n+                contigEnds.add(new ContigEndKmer(fwdKmer.getKVal(), contig, ContigOrientation.BOTH));\n+            } else {\n+                contigEnds.add(new ContigEndKmer(fwdKmer.getKVal(), contig, ContigOrientation.FWD));\n+                contigEnds.add(new ContigEndKmer(revKmer.getKVal(), contig, ContigOrientation.REV));\n+            }\n+        }\n+\n+        for ( int contigId = 0; contigId != nContigs; ++contigId ) {\n+            final Contig contig = contigs.get(contigId);\n+\n+            final KmerAdjacency start = contig.getFirstKmer();\n+            final int predecessorCount = start.getPredecessorCount();\n+            if ( predecessorCount > 0 ) {\n+                final List<Contig> predecessors = contig.getPredecessors();\n+                final int mask = start.getPredecessorMask();\n+                for ( int call = 0; call != 4; ++call ) {\n+                    if ( (mask & (1 << call)) != 0 ) {\n+                        final long kVal =\n+                                KmerAdjacency.reverseComplement(start.getPredecessorVal(call));\n+                        final ContigEndKmer contigEndKmer = contigEnds.find(new Kmer(kVal));\n+                        if ( contigEndKmer == null ) {\n+                            throw new GATKException(\"missing contig end kmer\");\n+                        }\n+                        switch ( contigEndKmer.getContigOrientation() ) {\n+                            case FWD:\n+                                predecessors.add(contigEndKmer.getContig().rc());\n+                                break;\n+                            case REV:\n+                                predecessors.add(contigEndKmer.getContig());\n+                                break;\n+                            case BOTH:\n+                                predecessors.add(contigEndKmer.getContig());\n+                                predecessors.add(contigEndKmer.getContig().rc());\n+                                break;\n+                        }\n+                    }\n+                }\n+            }\n+\n+            final KmerAdjacency end = contig.getLastKmer();\n+            final int successorCount = end.getSuccessorCount();\n+            if ( successorCount > 0 ) {\n+                final List<Contig> successors = contig.getSuccessors();\n+                final int mask = end.getSuccessorMask();\n+                for ( int call = 0; call != 4; ++call ) {\n+                    if ( (mask & (1 << call)) != 0 ) {\n+                        final long kVal = end.getSuccessorVal(call);\n+                        final ContigEndKmer contigEndKmer = contigEnds.find(new Kmer(kVal));\n+                        if ( contigEndKmer == null ) {\n+                            throw new GATKException(\"missing contig end kmer\");\n+                        }\n+                        switch ( contigEndKmer.getContigOrientation() ) {\n+                            case FWD:\n+                                successors.add(contigEndKmer.getContig());\n+                                break;\n+                            case REV:\n+                                successors.add(contigEndKmer.getContig().rc());\n+                                break;\n+                            case BOTH:\n+                                successors.add(contigEndKmer.getContig());\n+                                successors.add(contigEndKmer.getContig().rc());\n+                                break;\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    /** remove contigs that have little evidence **/\n+    @VisibleForTesting\n+    static void removeThinContigs( final List<ContigImpl> contigs,\n+                                           final KmerSet<KmerAdjacency> kmerAdjacencySet ) {\n+        contigs.sort(Comparator.comparingInt(ContigImpl::getMaxObservations));\n+        boolean contigRemoved;\n+        do {\n+            // figure out which contigs are cut points\n+            // i.e., those contigs which, if removed, would result in a graph with more connected components\n+            final int nContigs = contigs.size();\n+            final Map<Contig, CutData> cutDataMap = new HashMap<>(nContigs * 3);\n+\n+            for ( final ContigImpl contig : contigs ) {\n+                if ( cutDataMap.containsKey(contig) ) {\n+                    continue;\n+                }\n+\n+                cutDataMap.put(contig, new CutData());\n+                int children = 0;\n+                for ( final Contig nextContig : contig.getSuccessors() ) {\n+                    if ( !cutDataMap.containsKey(nextContig) ) {\n+                        findCuts(nextContig, contig, cutDataMap);\n+                        children += 1;\n+                    }\n+                }\n+                for ( final Contig nextContig : contig.getPredecessors() ) {\n+                    if ( !cutDataMap.containsKey(nextContig) ) {\n+                        findCuts(nextContig, contig, cutDataMap);\n+                        children += 1;\n+                    }\n+                }\n+                if ( children >= 2 ) {\n+                    contig.setCut(true);\n+                }\n+            }\n+\n+            // remove poorly attested (low max observations) contigs, unless they are cut points\n+            contigRemoved = false;\n+            final Iterator<ContigImpl> itr = contigs.iterator();\n+            while ( itr.hasNext() ) {\n+                final Contig contig = itr.next();\n+                if ( contig.getMaxObservations() < MIN_THIN_OBS && !contig.isCut() ) {\n+                    unlinkContig(contig, kmerAdjacencySet);\n+                    itr.remove();\n+                    contigRemoved = true;\n+                    break;\n+                }\n+            }\n+        } while ( contigRemoved );\n+        contigs.sort(Comparator.comparingInt(ContigImpl::getId));\n+    }\n+\n+    private static CutData findCuts( final Contig contig,\n+                                     final Contig parent,\n+                                     final Map<Contig, CutData> cutDataMap ) {\n+        final CutData cutData = new CutData();\n+        cutDataMap.put(contig, cutData);\n+        for ( final Contig nextContig : contig.getSuccessors() ) {\n+            if ( nextContig == parent ) {\n+                continue;\n+            }\n+            CutData nextCutData = cutDataMap.get(nextContig);\n+            if ( nextCutData != null ) {\n+                cutData.minVisitNum = Math.min(cutData.minVisitNum, nextCutData.visitNum);\n+            } else {\n+                nextCutData = findCuts(nextContig, contig, cutDataMap);\n+                cutData.minVisitNum = Math.min(cutData.minVisitNum, nextCutData.minVisitNum);\n+                if ( nextCutData.minVisitNum >= cutData.visitNum ) {\n+                    contig.setCut(true);\n+                }\n+            }\n+        }\n+        for ( final Contig nextContig : contig.getPredecessors() ) {\n+            if ( nextContig == parent ) {\n+                continue;\n+            }\n+            CutData nextCutData = cutDataMap.get(nextContig);\n+            if ( nextCutData != null ) {\n+                cutData.minVisitNum = Math.min(cutData.minVisitNum, nextCutData.visitNum);\n+            } else {\n+                nextCutData = findCuts(nextContig, contig, cutDataMap);\n+                cutData.minVisitNum = Math.min(cutData.minVisitNum, nextCutData.minVisitNum);\n+                if ( nextCutData.minVisitNum >= cutData.visitNum ) {\n+                    contig.setCut(true);\n+                }\n+            }\n+        }\n+        return cutData;\n+    }\n+\n+    @VisibleForTesting\n+    static void unlinkContig( final Contig contig,\n+                                      final KmerSet<KmerAdjacency> kmerAdjacencySet ) {\n+        final KmerAdjacency firstKmer = contig.getFirstKmer();\n+        final int firstKmerFinalCall = firstKmer.getFinalCall();\n+        for ( final Contig predecessor : contig.getPredecessors() ) {\n+            if ( predecessor != contig && predecessor != contig.rc() ) {\n+                predecessor.getLastKmer().removeSuccessor(firstKmerFinalCall, kmerAdjacencySet);\n+                if ( !predecessor.getSuccessors().remove(contig) ) {\n+                    throw new GATKException(\"failed to find predecessor link\");\n+                }\n+            }\n+        }\n+\n+        final KmerAdjacency lastKmer = contig.getLastKmer();\n+        final int lastKmerInitialCall = lastKmer.getInitialCall();\n+        for ( final Contig successor : contig.getSuccessors() ) {\n+            if ( successor != contig && successor != contig.rc() ) {\n+                successor.getFirstKmer().removePredecessor(lastKmerInitialCall, kmerAdjacencySet);\n+                if ( !successor.getPredecessors().remove(contig) ) {\n+                    throw new GATKException(\"failed to find successor link\");\n+                }\n+            }\n+        }\n+\n+        KmerAdjacency nextKmer = firstKmer;\n+        KmerAdjacency kmer;\n+        do {\n+            kmer = nextKmer;\n+            nextKmer = kmer.getSoleSuccessor();\n+            kmerAdjacencySet.remove(kmer.canonical());\n+        } while ( kmer != lastKmer );\n+    }\n+\n+    private static void updateKmerContig( final KmerAdjacency firstKmer,\n+                                          final KmerAdjacency lastKmer,\n+                                          final Contig contig ) {\n+        int offset = 0;\n+        for ( KmerAdjacency kmer = firstKmer; kmer != lastKmer; kmer = kmer.getSoleSuccessor() ) {\n+            if ( kmer == null ) {\n+                throw new GATKException(\"contig does not have a flat pipeline of kmers\");\n+            }\n+            kmer.clearContig();\n+            kmer.setContigOffset(contig, offset++);\n+        }\n+        lastKmer.clearContig();\n+        lastKmer.setContigOffset(contig, offset);\n+        if ( offset + Kmer.KSIZE != contig.size() ) {\n+            throw new GATKException(\"kmer chain length does not equal contig size\");\n+        }\n+    }\n+\n+    /** replace adjacent contigs without branches with a single, larger contig **/\n+    @VisibleForTesting\n+    static void weldPipes( final List<ContigImpl> contigs ) {\n+        for ( int contigIdx = 0; contigIdx != contigs.size(); ++contigIdx ) {\n+            final ContigImpl contig = contigs.get(contigIdx);\n+            if ( contig.getSuccessors().size() == 1 ) {\n+                final Contig successor = contig.getSuccessors().get(0);\n+                if ( successor != contig && successor != contig.rc() &&\n+                        successor.getPredecessors().size() == 1 ) {\n+                    contigs.set(contigIdx, join(contig.getId(), contig, successor));\n+                    if ( !contigs.remove(successor.canonical()) ) {\n+                        throw new GATKException(\"successor linkage is messed up\");\n+                    }\n+                    contigIdx -= 1; // reconsider the new contig -- there might be more joining possible\n+                    continue;\n+                }\n+            }\n+            if ( contig.getPredecessors().size() == 1 ) {\n+                final Contig predecessor = contig.getPredecessors().get(0);\n+                if ( predecessor != contig && predecessor != contig.rc() &&\n+                        predecessor.getSuccessors().size() == 1 ) {\n+                    contigs.set(contigIdx, join(contig.getId(), predecessor, contig));\n+                    if ( !contigs.remove(predecessor.canonical()) ) {\n+                        throw new GATKException(\"predecessor linkage is messed up\");\n+                    }\n+                    contigIdx -= 1; // reconsider\n+                }\n+            }\n+        }\n+    }\n+\n+    private static ContigImpl join( final int id, final Contig predecessor, final Contig successor ) {\n+        if ( !checkOverlap(predecessor.getSequence(), successor.getSequence()) ) {\n+                throw new GATKException(\"sequences can't be joined\");\n+        }\n+        final ContigImpl joinedContig = new ContigImpl(id, predecessor, successor);\n+        updateKmerContig(joinedContig.getFirstKmer(), joinedContig.getLastKmer(), joinedContig);\n+        return joinedContig;\n+    }\n+\n+    private static boolean checkOverlap( final CharSequence seq1, final CharSequence seq2 ) {\n+        final int seq1Len = seq1.length();\n+        final CharSequence seq1SubSeq = seq1.subSequence(seq1Len - Kmer.KSIZE + 1, seq1Len);\n+        final CharSequence seq2SubSeq = seq2.subSequence(0, Kmer.KSIZE - 1);\n+        return seq1SubSeq.equals(seq2SubSeq);\n+    }\n+\n+    /** set a unique componentId for every connected group of contigs **/\n+    @VisibleForTesting\n+    static int markComponents( final List<ContigImpl> contigs ) {\n+        for ( final ContigImpl contig : contigs ) {\n+            contig.setComponentId(0);\n+        }\n+\n+        int componentId = 0;\n+        for ( final ContigImpl contig : contigs ) {\n+            if ( contig.getComponentId() == 0 ) {\n+                contig.setComponentId(++componentId);\n+                markSuccessorComponents(contig);\n+                markSuccessorComponents(contig.rc());\n+            }\n+        }\n+        return componentId;\n+    }\n+\n+    private static void markSuccessorComponents( final Contig contig ) {\n+        final int componentId = contig.getComponentId();\n+        for ( final Contig successor : contig.getSuccessors() ) {\n+            if ( successor.getComponentId() == 0 ) {\n+                successor.canonical().setComponentId(componentId);\n+                markSuccessorComponents(successor);\n+                markSuccessorComponents(successor.rc());\n+            }\n+        }\n+    }\n+\n+    @VisibleForTesting\n+    static void markCycles( final List<ContigImpl> contigs ) {\n+        for ( final Contig contig : contigs ) {\n+            contig.setCyclic(false);\n+        }\n+\n+        final int nContigs = contigs.size();\n+        final Deque<Contig> deque = new ArrayDeque<>(nContigs);\n+        final Map<Contig, CutData> cutDataMap = new HashMap<>(nContigs * 3);\n+        for ( final Contig contig : contigs ) {\n+            if ( !cutDataMap.containsKey(contig) ) {\n+                markCyclesRecursion(contig, deque, cutDataMap);\n+            }\n+        }\n+    }\n+\n+    private static CutData markCyclesRecursion( final Contig contig,\n+                                                final Deque<Contig> deque,\n+                                                final Map<Contig, CutData> cutDataMap ) {\n+        final CutData cutData = new CutData();\n+        cutDataMap.put(contig, cutData);\n+        deque.addFirst(contig);\n+\n+        for ( final Contig successor : contig.getSuccessors() ) {\n+            final CutData successorCutData = cutDataMap.get(successor);\n+            if ( successorCutData == null ) {\n+                final int recursionVisitNum =\n+                        markCyclesRecursion(successor, deque, cutDataMap).minVisitNum;\n+                cutData.minVisitNum = Math.min(cutData.minVisitNum, recursionVisitNum);\n+            } else {\n+                cutData.minVisitNum = Math.min(cutData.minVisitNum, successorCutData.visitNum);\n+            }\n+        }\n+\n+        if ( cutData.visitNum == cutData.minVisitNum ) {\n+            Contig tig = deque.removeFirst();\n+            if ( tig == contig ) {\n+                cutDataMap.get(tig).visitNum = Integer.MAX_VALUE;\n+\n+                // single-vertex component -- cyclic only if self-referential\n+                if ( tig.getSuccessors().contains(tig) ) {\n+                    tig.setCyclic(true);\n+                }\n+            } else {\n+                while ( true ) {\n+                    // kill cross-links\n+                    cutDataMap.get(tig).visitNum = Integer.MAX_VALUE;\n+                    tig.setCyclic(true);\n+                    if ( tig == contig ) break;\n+                    tig = deque.removeFirst();\n+                }\n+            }\n+        }\n+        return cutData;\n+    }\n+\n+    @VisibleForTesting\n+    static boolean fillGaps( final KmerSet<KmerAdjacency> kmerAdjacencySet,\n+                             final List<GATKRead> reads ) {\n+        final Map<String, Integer> gapFillCounts = new HashMap<>();\n+        for ( final GATKRead read : reads ) {\n+            final Path path = new Path(read.getBasesNoCopy(), kmerAdjacencySet);\n+            final List<PathPart> parts = path.getParts();\n+            final int lastIdx = parts.size() - 1;\n+            for ( int idx = 1; idx < lastIdx; ++idx ) {\n+                final PathPart pathPart = parts.get(idx);\n+                if ( pathPart.isGap() ) {\n+                    final char prevCall = parts.get(idx - 1).getLastCall();\n+                    final char nextCall = parts.get(idx + 1).getFirstCall();\n+                    String gapFill = prevCall + pathPart.getSequence().toString() + nextCall;\n+                    final SequenceRC gapFillRC = new SequenceRC(gapFill);\n+                    if ( gapFillRC.compareTo(gapFill) < 0 ) {\n+                        gapFill = gapFillRC.toString();\n+                    }\n+                    gapFillCounts.merge(gapFill, 1, Integer::sum);\n+                }\n+            }\n+        }\n+\n+        boolean newKmers = false;\n+        for ( final Map.Entry<String, Integer> entry : gapFillCounts.entrySet() ) {\n+            final int nObservations = entry.getValue();\n+            if ( nObservations >= MIN_GAPFILL_COUNT ) {\n+                KmerAdjacency.kmerize(entry.getKey(), nObservations, kmerAdjacencySet);\n+                newKmers = true;\n+            }\n+        }\n+\n+        if ( newKmers ) {\n+            for ( final KmerAdjacency kmerAdjacency : kmerAdjacencySet ) {\n+                kmerAdjacency.clearContig();\n+            }\n+        }\n+        return newKmers;\n+    }\n+\n+    @VisibleForTesting\n+    static List<Path> pathReads( final KmerSet<KmerAdjacency> kmerAdjacencySet,\n+                          final List<GATKRead> reads ) {\n+        final List<Path> readPaths = new ArrayList<>(reads.size());\n+        for ( final GATKRead read : reads ) {\n+            readPaths.add(new Path(read.getBasesNoCopy(), kmerAdjacencySet));\n+        }\n+        return readPaths;\n+    }\n+\n+    @VisibleForTesting\n+    static Map<Contig,List<TransitPairCount>> collectTransitPairCounts(\n+            final List<ContigImpl> contigs,\n+            final List<Path> readPaths ) {\n+        final Map<Contig,List<TransitPairCount>> contigTransitsMap =\n+                new HashMap<>(3 * contigs.size());\n+        for ( final Path path : readPaths ) {\n+            final List<PathPart> parts = path.getParts();\n+            final int lastPart = parts.size() - 1;\n+            for ( int partIdx = 1; partIdx < lastPart; ++partIdx ) {\n+                final Contig prevContig = parts.get(partIdx - 1).getContig();\n+                if ( prevContig == null ) continue;\n+                final Contig curContig = parts.get(partIdx).getContig();\n+                if ( curContig == null ) {\n+                    partIdx += 1;\n+                    continue;\n+                }\n+                final Contig nextContig = parts.get(partIdx + 1).getContig();\n+                if ( nextContig == null ) {\n+                    partIdx += 2;\n+                    continue;\n+                }\n+                final TransitPairCount tpc = new TransitPairCount(prevContig, nextContig);\n+                final List<TransitPairCount> tpcList =\n+                        contigTransitsMap.computeIfAbsent(curContig, tig -> new ArrayList<>(4));\n+                final int idx = tpcList.indexOf(tpc);\n+                if ( idx != -1 ) {\n+                    tpcList.get(idx).observe();\n+                } else {\n+                    tpcList.add(tpc);\n+                    contigTransitsMap.computeIfAbsent(curContig.rc(), tig -> new ArrayList<>(4))\n+                            .add(tpc.getRC());\n+                }\n+            }\n+        }\n+        return contigTransitsMap;\n+    }\n+\n+    @VisibleForTesting\n+    static Set<Traversal> traverseAllPaths(\n+            final List<ContigImpl> contigs,\n+            final List<Path> readPaths,\n+            final Map<Contig, List<TransitPairCount>> contigTransitsMap ) {\n+        final Set<Traversal> traversalSet = new HashSet<>();\n+        final List<Contig> contigsList = new ArrayList<>();\n+        for ( final Contig contig : contigs ) {\n+            // untransited contigs are sources, sinks, or large contigs that can't be crossed by a read\n+            // build traversals from these\n+            if ( !contigTransitsMap.containsKey(contig) ) {\n+                boolean done = false;\n+                for ( final Contig successor : contig.getSuccessors() ) {\n+                    traverse(successor, contig,\n+                            contigsList, readPaths, contigTransitsMap, traversalSet);\n+                    done = true;\n+                }\n+                for ( final Contig predecessor : contig.getPredecessors() ) {\n+                    traverse(predecessor.rc(), contig.rc(),\n+                            contigsList, readPaths, contigTransitsMap, traversalSet);\n+                    done = true;\n+                }\n+                if ( !done ) { // if there were no predecessors or successors, it stands alone\n+                    addTraversal(new Traversal(Collections.singletonList(contig)), traversalSet);\n+                }\n+            }\n+        }\n+\n+        // look for transits that haven't been traced\n+        for ( final Map.Entry<Contig, List<TransitPairCount>> entry :\n+                contigTransitsMap.entrySet() ) {\n+            for ( final TransitPairCount tpc : entry.getValue() ) {\n+                if ( tpc.getCount() > 0 ) {\n+                    tpc.resetCount();\n+                    final Contig contig = entry.getKey();\n+                    final Set<Traversal> fwdTraversalSet = new HashSet<>();\n+                    traverse(tpc.getNextContig(), contig,\n+                            contigsList, readPaths, contigTransitsMap, fwdTraversalSet);\n+                    final Set<Traversal> revTraversalSet = new HashSet<>();\n+                    traverse(tpc.getPrevContig().rc(), contig.rc(),\n+                            contigsList, readPaths, contigTransitsMap, revTraversalSet);\n+                    for ( final Traversal revTraversal : revTraversalSet ) {\n+                        final Traversal revTraversalRC = revTraversal.rc();\n+                        for ( final Traversal fwdTraversal : fwdTraversalSet ) {\n+                            final int overlap =\n+                                    findMaxOverlap(revTraversalRC.getContigs(), fwdTraversal.getContigs());\n+                            final Traversal combo =\n+                                    Traversal.combineOverlappers(revTraversalRC, fwdTraversal, overlap);\n+                            addTraversal(combo, traversalSet);\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+\n+        return traversalSet;\n+    }\n+\n+    private static int findMaxOverlap( final List<Contig> prefixes, final List<Contig> suffixes ) {\n+        final int nPrefixes = prefixes.size();\n+        final Contig firstSuffix = suffixes.get(0);\n+        if ( !firstSuffix.isCyclic() ) {\n+            return prefixes.get(nPrefixes - 1) == firstSuffix ? 1 : 0;\n+        }\n+        final int nSuffixes = suffixes.size();\n+        for ( int prefixIdx = Math.max(0, nPrefixes - nSuffixes); prefixIdx != nPrefixes; ++prefixIdx ) {\n+            if ( prefixes.get(prefixIdx) == firstSuffix ) {\n+                int suffixIdx = 1;\n+                boolean match = true;\n+                for ( int prefixIdx2 = prefixIdx + 1; prefixIdx2 != nPrefixes; ++prefixIdx2 ) {\n+                    if ( prefixes.get(prefixIdx2) != suffixes.get(suffixIdx++) ) {\n+                        match = false;\n+                        break;\n+                    }\n+                }\n+                if ( match ) {\n+                    return nPrefixes - prefixIdx;\n+                }\n+            }\n+        }\n+        return 0;\n+    }\n+\n+    private static void traverse( final Contig contig,\n+                                  final Contig predecessor,\n+                                  final List<Contig> contigsList,\n+                                  final List<Path> readPaths,\n+                                  final Map<Contig, List<TransitPairCount>> contigTransitsMap,\n+                                  final Set<Traversal> traversalSet ) {\n+        contigsList.add(predecessor);\n+        if ( contig.isCyclic() ) {\n+            traverseCycle(contig, contigsList, readPaths, contigTransitsMap, traversalSet);\n+            contigsList.remove(contigsList.size() - 1);\n+            return;\n+        }\n+        final List<TransitPairCount> transits = contigTransitsMap.get(contig);\n+        boolean done = false;\n+        if ( transits != null ) {\n+            for ( final TransitPairCount tpc : transits ) {\n+                if ( tpc.getPrevContig() == predecessor ) {\n+                    final Contig successor = tpc.getNextContig();\n+                    if ( predecessor == contig.rc() ) {\n+                        final int nContigs = contigsList.size();\n+                        if ( nContigs > 1 ) {\n+                            if ( successor.rc() == contigsList.get(nContigs - 2) ) {\n+                                continue;\n+                            }\n+                        }\n+                    }\n+                    tpc.resetCount();\n+                    traverse(successor, contig, contigsList, readPaths, contigTransitsMap, traversalSet);\n+                    done = true;\n+                }\n+            }\n+        }\n+        if ( !done ) {\n+            contigsList.add(contig);\n+            addTraversal(new Traversal(contigsList), traversalSet);\n+            contigsList.remove(contigsList.size() - 1);\n+        }\n+        contigsList.remove(contigsList.size() - 1);\n+    }\n+\n+    private static void traverseCycle( final Contig contig,\n+                                       final List<Contig> contigsList,\n+                                       final List<Path> readPaths,\n+                                       final Map<Contig, List<TransitPairCount>> contigTransitsMap,\n+                                       final Set<Traversal> traversalSet ) {\n+        contigsList.add(contig);\n+        final int nContigs = contigsList.size();\n+        // the final element of the list is cyclic, if there's a previous element it will be\n+        // non-cyclic, so start there figuring out how far the read paths lead us\n+        final List<List<Contig>> longestPaths =\n+                findLongestPaths(contigsList.subList(Math.max(0, nContigs - 2), nContigs), readPaths);\n+        // didn't get anywhere -- just complete the traversal\n+        if ( longestPaths.isEmpty() ) {\n+            addTraversal(new Traversal(contigsList, true), traversalSet);\n+        } else {\n+            // for each unique extension into the cycle\n+            for ( final List<Contig> path : longestPaths ) {\n+                // don't think this can happen, but still\n+                if ( path.isEmpty() ) {\n+                    addTraversal(new Traversal(contigsList, true), traversalSet);\n+                    continue;\n+                }\n+                final List<Contig> extendedContigsList =\n+                        new ArrayList<>(contigsList.size() + path.size());\n+                extendedContigsList.addAll(contigsList);\n+                // if we didn't get out of the cycle\n+                if ( path.get(path.size() - 1).isCyclic() ) {\n+                    extendedContigsList.addAll(path);\n+                    addTraversal(new Traversal(extendedContigsList, true), traversalSet);\n+                } else {\n+                    // we found a cycle-exiting path, so extend that normally\n+                    for ( final Contig curContig : path ) {\n+                        if ( curContig.isCyclic() ) {\n+                            extendedContigsList.add(curContig);\n+                        } else {\n+                            final Contig prevContig =\n+                                    extendedContigsList.remove(extendedContigsList.size() - 1);\n+                            traverse(curContig, prevContig, extendedContigsList, readPaths,\n+                                    contigTransitsMap, traversalSet);\n+                            extendedContigsList.add(prevContig);\n+                            break;\n+                        }\n+                    }\n+                }\n+                clearTransitPairs(contigTransitsMap, extendedContigsList);\n+            }\n+        }\n+        contigsList.remove(contigsList.size() - 1);\n+    }\n+\n+    private static void clearTransitPairs(\n+            final Map<Contig, List<TransitPairCount>> contigTransitsMap,\n+            final List<Contig> contigsList ) {\n+        final int lastIdx = contigsList.size() - 1;\n+        for ( int idx = 1; idx < lastIdx; ++idx ) {\n+            final List<TransitPairCount> pairCounts = contigTransitsMap.get(contigsList.get(idx));\n+            if ( pairCounts != null ) {\n+                final Contig predecessor = contigsList.get(idx - 1);\n+                final Contig successor = contigsList.get(idx + 1);\n+                for ( final TransitPairCount tpc : pairCounts ) {\n+                    if ( tpc.getPrevContig() == predecessor && tpc.getNextContig() == successor ) {\n+                        tpc.resetCount();\n+                        break;\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    private static void addTraversal( final Traversal traversal,\n+                                      final Set<Traversal> traversalSet ) {\n+        if ( !traversalSet.contains(traversal.rc()) ) {\n+            traversalSet.add(traversal);\n+            if ( traversalSet.size() >= TOO_MANY_TRAVERSALS ) {\n+                throw new AssemblyTooComplexException();\n+            }\n+        }\n+    }\n+\n+    private static List<List<Contig>> findLongestPaths( final List<Contig> toMatch,\n+                                                        final List<Path> readPaths ) {\n+        final List<List<Contig>> results = new ArrayList<>();\n+        for ( final Path path : readPaths ) {\n+            testPath(path, toMatch, results);\n+            testPath(path.rc(), toMatch, results);\n+        }\n+        return results;\n+    }\n+\n+    private static void testPath( final Path path,\n+                                  final List<Contig> toMatch,\n+                                  final List<List<Contig>> results ) {\n+        final List<PathPart> pathParts = path.getParts();\n+        final int nPathParts = pathParts.size();\n+        final List<Contig> pathContigs = new ArrayList<>(nPathParts);\n+        pathParts.forEach(pp -> pathContigs.add(pp.getContig()));\n+        final int matchIdx = Collections.indexOfSubList(pathContigs, toMatch);\n+        if ( matchIdx != -1 ) {\n+            final int suffixIdx = matchIdx + toMatch.size();\n+            if ( suffixIdx < nPathParts ) {\n+                resolveResult(grabParts(pathContigs, suffixIdx), results);\n+            }\n+        }\n+    }\n+\n+    private static List<Contig> grabParts( final List<Contig> pathContigs, final int suffixIdx ) {\n+        final int nPathContigs = pathContigs.size();\n+        Contig prev = pathContigs.get(suffixIdx - 1);\n+        final List<Contig> result = new ArrayList<>(nPathContigs - suffixIdx);\n+        for ( int idx = suffixIdx; idx != nPathContigs; ++idx ) {\n+            final Contig tig = pathContigs.get(idx);\n+            if ( tig == null || !prev.getSuccessors().contains(tig) ) break;\n+            result.add(tig);\n+            prev = tig;\n+        }\n+        return result;\n+    }\n+\n+    private static void resolveResult( final List<Contig> result,\n+                                       final List<List<Contig>> results ) {\n+        final int nResults = results.size();\n+        for ( int idx = 0; idx != nResults; ++idx ) {\n+            final List<Contig> test = results.get(idx);\n+            if ( isPrefix(result, test) ) return;\n+            if ( isPrefix(test, result) ) {\n+                results.set(idx, result);\n+                return;\n+            }\n+        }\n+        results.add(result);\n+    }\n+\n+    private static boolean isPrefix( final List<Contig> list1, final List<Contig> list2 ) {\n+        final int list1Size = list1.size();\n+        final int list2Size = list2.size();\n+        if ( list1Size > list2Size ) return false;\n+        for ( int idx = 0; idx != list1Size; ++idx ) {\n+            if ( list1.get(idx) != list2.get(idx) ) return false;\n+        }\n+        return true;\n+    }\n+\n+    @VisibleForTesting\n+    static Collection<Traversal> createScaffolds( final List<Traversal> allTraversals ) {\n+        removeTriviallyDifferentTraversals(allTraversals);\n+\n+        final int nTraversals = allTraversals.size();\n+        final Map<Contig, List<Integer>> traversalsByFirstContig = new HashMap<>(3 * nTraversals);\n+        for ( int idx = 0; idx != nTraversals; ++idx ) {\n+            final Traversal traversal = allTraversals.get(idx);\n+            traversalsByFirstContig.compute(traversal.getFirstContig(),\n+                    ( k, v ) -> v == null ? new ArrayList<>(3) : v).add(idx);\n+            final Traversal rcTraversal = traversal.rc();\n+            traversalsByFirstContig.compute(rcTraversal.getFirstContig(),\n+                    ( k, v ) -> v == null ? new ArrayList<>(3) : v).add(~idx);\n+        }\n+\n+        final List<Traversal> scaffolds = new ArrayList<>(nTraversals);\n+        final boolean[] touched = new boolean[nTraversals];\n+        for ( int idx = 0; idx != nTraversals; ++idx ) {\n+            if ( !touched[idx] ) {\n+                expandTraversal(idx, touched, traversalsByFirstContig, allTraversals, scaffolds);\n+            }\n+        }\n+        return scaffolds;\n+    }\n+\n+    private static void expandTraversal( final int traversalIdx,\n+                                         final boolean[] touched,\n+                                         final Map<Contig, List<Integer>> traversalsByFirstContig,\n+                                         final List<Traversal> allTraversals,\n+                                         final List<Traversal> scaffolds ) {\n+        final Traversal traversal = allTraversals.get(traversalIdx);\n+        touched[traversalIdx] = true;\n+        final List<Traversal> downExtensions = new ArrayList<>();\n+        final Set<Contig> startingContigSet = new HashSet<>();\n+        walkTraversals(traversal, touched, startingContigSet, traversalsByFirstContig,\n+                        allTraversals, downExtensions);\n+        final List<Traversal> upExtensions = new ArrayList<>();\n+        walkTraversals(traversal.rc(), touched, startingContigSet, traversalsByFirstContig,\n+                        allTraversals, upExtensions);\n+        for ( final Traversal down : downExtensions ) {\n+            for ( final Traversal up : upExtensions ) {\n+                if ( scaffolds.size() >= TOO_MANY_SCAFFOLDS ) {\n+                    throw new AssemblyTooComplexException();\n+                }\n+                scaffolds.add(Traversal.combineOverlappers(up.rc(), down, traversal.getContigs().size()));\n+            }\n+        }\n+    }\n+\n+    private static void walkTraversals( final Traversal traversal,\n+                                        final boolean[] touched,\n+                                        final Set<Contig> startingContigSet,\n+                                        final Map<Contig, List<Integer>> traversalsByFirstContig,\n+                                        final List<Traversal> allTraversals,\n+                                        final List<Traversal> extensions ) {\n+        final Contig firstContig = traversal.getFirstContig();\n+        final List<Integer> indexList;\n+        if ( startingContigSet.contains(firstContig) ||\n+                traversal.isInextensible() ||\n+                (indexList = traversalsByFirstContig.get(traversal.getLastContig())) == null ) {\n+            extensions.add(traversal);\n+            return;\n+        }\n+        startingContigSet.add(firstContig);\n+        for ( int idx : indexList ) {\n+            final Traversal extension;\n+            if ( idx >= 0 ) {\n+                extension = allTraversals.get(idx);\n+                touched[idx] = true;\n+            } else {\n+                final int rcIdx = ~idx;\n+                extension = allTraversals.get(rcIdx).rc();\n+                touched[rcIdx] = true;\n+            }\n+            walkTraversals(Traversal.combine(traversal, extension), touched, startingContigSet,\n+                            traversalsByFirstContig, allTraversals, extensions );\n+        }\n+        startingContigSet.remove(firstContig);\n+    }\n+\n+    private static void removeTriviallyDifferentTraversals(\n+                                            final Collection<Traversal> allTraversals ) {\n+        if ( allTraversals.isEmpty() ) {\n+            return;\n+        }\n+        final TreeSet<Traversal> sortedTraversals = new TreeSet<>(new TraversalEndpointComparator());\n+        for ( final Traversal traversal : allTraversals ) {\n+            sortedTraversals.add(traversal);\n+            sortedTraversals.add(traversal.rc());\n+        }\n+        final Iterator<Traversal> traversalIterator = sortedTraversals.iterator();\n+        Traversal prevTraversal = traversalIterator.next();\n+        while ( traversalIterator.hasNext() ) {\n+            final Traversal curTraversal = traversalIterator.next();\n+            if ( isTriviallyDifferent(prevTraversal, curTraversal) ) {\n+                traversalIterator.remove();\n+            } else {\n+                prevTraversal = curTraversal;\n+            }\n+        }\n+        sortedTraversals.removeIf(Traversal::isRC);\n+        allTraversals.clear();\n+        allTraversals.addAll(sortedTraversals);\n+    }\n+\n+    private static boolean isTriviallyDifferent( final Traversal traversal1,\n+                                                 final Traversal traversal2 ) {\n+        final Contig firstContig1 = traversal1.getFirstContig();\n+        final Contig lastContig1 = traversal1.getLastContig();\n+        final Contig firstContig2 = traversal2.getFirstContig();\n+        final Contig lastContig2 = traversal2.getLastContig();\n+        if ( firstContig1 != firstContig2 || lastContig1 != lastContig2 ) {\n+            return false;\n+        }\n+        final int interiorSize1 = traversal1.getSequenceLength() - firstContig1.size() - lastContig1.size();\n+        final int interiorSize2 = traversal2.getSequenceLength() - firstContig2.size() - lastContig2.size();\n+\n+        // if the path lengths are so different that one could harbor an SV, they're not trivially different\n+        if ( Math.abs(interiorSize1 - interiorSize2) >= MIN_SV_SIZE ) {\n+            return false;\n+        }\n+\n+        // if the paths are small enough that there can't be an SV's worth of differences, they're trivially different\n+        final int maxInteriorSize = Math.max(interiorSize1, interiorSize2);\n+        if ( maxInteriorSize < MIN_SV_SIZE ) {\n+            return true;\n+        }\n+\n+        // dang, maybe there's enough material in common that there can't be an SV's worth of differences\n+        // run a longest common subsequence algorithm to figure out the length of the common material\n+        // DP matrix holds length of common material\n+        final List<Contig> contigs1 = traversal1.getContigs();\n+        final int rowLen = contigs1.size() - 1;\n+        final int[][] rowPair = new int[2][];\n+        rowPair[0] = new int[rowLen];\n+        rowPair[1] = new int[rowLen];\n+        int pairIdx = 0;\n+        final List<Contig> contigs2 = traversal2.getContigs();\n+        final int nRows = contigs2.size() - 1;\n+        for ( int idx2 = 1; idx2 != nRows; ++idx2 ) {\n+            final int[] curRow = rowPair[pairIdx];\n+            final int[] prevRow = rowPair[pairIdx ^ 1];\n+            pairIdx ^= 1;\n+\n+            final int id2 = contigs2.get(idx2).getId();\n+            for ( int idx1 = 1; idx1 != rowLen; ++idx1 ) {\n+                final Contig tig1 = contigs1.get(idx1);\n+                if ( tig1.getId() == id2 ) {\n+                    // if the previous cells also contain a match we've already removed the K-1 bases upstream\n+                    final boolean extendMatch =\n+                            contigs1.get(idx1 -1).getId() == contigs2.get(idx2 - 1).getId();\n+                    curRow[idx1] = prevRow[idx1 - 1] + (extendMatch ? tig1.getNKmers() : tig1.size());\n+                } else {\n+                    curRow[idx1] = Math.max(curRow[idx1 - 1], prevRow[idx1]);\n+                }\n+            }\n+        }\n+        final int commonLen = rowPair[pairIdx ^ 1][rowLen - 1];\n+        return (maxInteriorSize - commonLen) < MIN_SV_SIZE;\n+    }\n+\n+    private static class TraversalEndpointComparator implements Comparator<Traversal> {\n+        @Override\n+        public int compare( final Traversal traversal1, final Traversal traversal2 ) {\n+            int cmp = Integer.compare(traversal1.contigs.get(0).getId(),\n+                                      traversal2.contigs.get(0).getId());\n+            if ( cmp != 0 ) {\n+                return cmp;\n+            }\n+            final int last1 = traversal1.contigs.size() - 1;\n+            final int last2 = traversal2.contigs.size() - 1;\n+            cmp = Integer.compare(traversal1.contigs.get(last1).getId(),\n+                                  traversal2.contigs.get(last2).getId());\n+            if ( cmp != 0 ) {\n+                return cmp;\n+            }\n+            // among those starting and ending at the same place, sort least observed last\n+            return -Integer.compare(traversal1.getMinMaxObservations(), traversal2.getMinMaxObservations());\n+        }\n+    }\n+\n+    private static void writeDOT( final List<ContigImpl> contigs, final String fileName ) {\n+        try ( final BufferedWriter writer = new BufferedWriter(new FileWriter(fileName)) ) {\n+            writer.write(\"digraph {\\n\");\n+            for ( final Contig contig : contigs ) {\n+                final double width = contig.getSequence().length() / 100.;\n+                writer.write(contig + \" [width=\" + width + \"]\\n\");\n+                writer.write( contig.rc() + \" [width=\" + width + \"]\\n\");\n+            }\n+            for ( final Contig contig : contigs ) {\n+                for ( final Contig predecessor : contig.getPredecessors() ) {\n+                    final String predecessorName = predecessor.rc().toString();\n+                    writer.write(contig.rc() + \" -> \" + predecessorName + \"\\n\");\n+                }\n+                for ( final Contig successor : contig.getSuccessors() ) {\n+                    final String successorName = successor.toString();\n+                    writer.write(contig + \" -> \" + successorName + \"\\n\");\n+                }\n+            }\n+            writer.write(\"}\\n\");\n+        } catch ( final IOException ioe ) {\n+            throw new GATKException(\"Failed to write assembly DOT file.\", ioe);\n+        }\n+    }\n+\n+    private static BufferedWriter makeGZFile( final String fileName ) throws IOException {\n+        final GZIPOutputStream gzOS = new GZIPOutputStream(BucketUtils.createFile(fileName));\n+        return new BufferedWriter(new OutputStreamWriter(gzOS));\n+    }\n+\n+    private static void writeContigs( final List<ContigImpl> contigs, final String fileName ) {\n+        try ( final BufferedWriter writer = makeGZFile(fileName) ) {\n+            for ( final Contig contig : contigs ) {\n+                final List<Contig> predecessors = contig.getPredecessors();\n+                final String predecessorDescription;\n+                if ( predecessors.size() == 0 ) {\n+                    predecessorDescription = \"\\tnone\";\n+                } else {\n+                    final StringBuilder sb = new StringBuilder();\n+                    char prefix = '\\t';\n+                    for ( final Contig predecessor : predecessors ) {\n+                        sb.append(prefix);\n+                        prefix = ',';\n+                        sb.append(predecessor);\n+                    }\n+                    predecessorDescription = sb.toString();\n+                }\n+\n+                final List<Contig> successors = contig.getSuccessors();\n+                final String successorDescription;\n+                if ( successors.size() == 0 ) {\n+                    successorDescription = \"\\tnone\";\n+                } else {\n+                    final StringBuilder sb = new StringBuilder();\n+                    char prefix = '\\t';\n+                    for ( final Contig successor : successors ) {\n+                        sb.append(prefix);\n+                        prefix = ',';\n+                        sb.append(successor);\n+                    }\n+                    successorDescription = sb.toString();\n+                }\n+\n+                final String contigName = contig.toString();\n+                final String component =\n+                        (contig.isCyclic() ? \"(C)\\t\" : \"\\t\") + contig.getComponentId();\n+                writer.write(contigName + component + predecessorDescription +\n+                        successorDescription + \"\\t\" +\n+                        contig.getMaxObservations() + \"\\t\" +\n+                        contig.getFirstKmer().getNObservations() + \"\\t\" +\n+                        contig.getLastKmer().getNObservations() + \"\\t\" +\n+                        contig.size() + \"\\t\" +\n+                        contig.getSequence() + \"\\n\");\n+            }\n+        } catch ( final IOException ioe ) {\n+            throw new GATKException(\"Failed to write contigs file.\", ioe);\n+        }\n+    }\n+\n+    private static void writePaths( final List<Path> readPaths, final String fileName ) {\n+        try ( final BufferedWriter writer = makeGZFile(fileName) ) {\n+            final int nReads = readPaths.size();\n+            for ( int readId = 0; readId != nReads; ++readId ) {\n+                final Path path = readPaths.get(readId);\n+                final String pathDesc = path.toString();\n+                writer.write((readId + 1) + \": \" + pathDesc + \"\\n\");\n+            }\n+        } catch ( final IOException ioe ) {\n+            throw new GATKException(\"Failed to write paths file.\", ioe);\n+        }\n+    }\n+\n+    private static void writeReads( final List<GATKRead> reads, final String fileName ) {\n+        try ( final BufferedWriter writer = makeGZFile(fileName) ) {\n+            for ( final GATKRead read : reads ) {\n+                writer.write(\"@\" + read.getName());\n+                writer.write('\\n');\n+                writer.write(new String(read.getBasesNoCopy()));\n+                writer.write(\"\\n+\\n\");\n+                final byte[] quals = read.getBaseQualitiesNoCopy();\n+                final int nQuals = quals.length;\n+                final byte[] fastqQuals = new byte[nQuals];\n+                for ( int idx = 0; idx != nQuals; ++idx ) {\n+                    fastqQuals[idx] = (byte)SAMUtils.phredToFastq(quals[idx]);\n+                }\n+                writer.write(new String(fastqQuals));\n+                writer.write('\\n');\n+            }\n+        } catch ( final IOException ioe ) {\n+            throw new GATKException(\"Failed to write assembly sam file.\", ioe);\n+        }\n+    }\n+\n+    private static void writeTraversals( final Collection<Traversal> traversals,\n+                                         final String fileName ) {\n+        try ( final BufferedWriter writer = makeGZFile(fileName) ) {\n+            int traversalNo = 0;\n+            for ( final Traversal traversal : traversals ) {\n+                writer.write(\">\");\n+                if ( assemblyName != null ) {\n+                    writer.write(assemblyName);\n+                    writer.write(\"_\");\n+                }\n+                writer.write(\"t\");\n+                writer.write(Integer.toString(++traversalNo));\n+                writer.write(\" \");\n+                writer.write(traversal.getName());\n+                writer.newLine();\n+                writer.write(traversal.getSequence());\n+                writer.newLine();\n+            }\n+        } catch ( final IOException ioe ) {\n+            throw new GATKException(\"Failed to write assembly sam file.\", ioe);\n+        }\n+    }\n+\n+    /** fixed-size, immutable kmer.  usual 2-bit encoding: ACGT->0123.  low order bits are final call. **/\n+    public static class Kmer {\n+        public static final int KSIZE = 31; // must be odd number less than 32", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e2201c1ef4f8ba71f17e169f07756cfe2f1ecb49"}, "originalPosition": 1248}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxNDg4MTU1MQ==", "bodyText": "KSIZE=31 is fine for well-behaved regions of the genome, and woefully inadequate for ill-behaved, low-complexity regions.  I decided to see what could be done just with graph operations, rather than do the thing that assemblers usually do (use a small K to build a graph, error correct the reads, use a larger K to build a less tangled graph).  Error correction has its own hazards, and it's computationally expensive.  So I guess I'm reasonably satisfied:  This is fast, but it sometimes produces graphs so tangled as to be not particularly informative.  But to tell you the truth, most assemblers don't produce great results on the highly repetitive regions.\nIt would be easy enough to revise this one Kmer class to allow larger K.  What's hard is to provide an option for a variety of sizes (as we did for our first attempt at an SV tool in Spark).  But with uncorrected short reads you can't start with a K much higher than 31, anyway.", "url": "https://github.com/broadinstitute/gatk/pull/6989#discussion_r614881551", "createdAt": "2021-04-16T14:27:36Z", "author": {"login": "tedsharpe"}, "path": "src/main/java/org/broadinstitute/hellbender/tools/LocalAssembler.java", "diffHunk": "@@ -0,0 +1,2306 @@\n+package org.broadinstitute.hellbender.tools;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import htsjdk.samtools.Cigar;\n+import htsjdk.samtools.CigarElement;\n+import htsjdk.samtools.CigarOperator;\n+import htsjdk.samtools.SAMUtils;\n+import org.broadinstitute.barclay.argparser.Argument;\n+import org.broadinstitute.barclay.argparser.BetaFeature;\n+import org.broadinstitute.barclay.argparser.CommandLineProgramProperties;\n+import org.broadinstitute.barclay.help.DocumentedFeature;\n+import org.broadinstitute.hellbender.cmdline.StandardArgumentDefinitions;\n+import org.broadinstitute.hellbender.cmdline.programgroups.CoverageAnalysisProgramGroup;\n+import org.broadinstitute.hellbender.exceptions.GATKException;\n+import org.broadinstitute.hellbender.tools.walkers.PairWalker;\n+import org.broadinstitute.hellbender.utils.SimpleInterval;\n+import org.broadinstitute.hellbender.utils.collections.HopscotchSet;\n+import org.broadinstitute.hellbender.utils.gcs.BucketUtils;\n+import org.broadinstitute.hellbender.utils.read.GATKRead;\n+\n+import java.io.BufferedWriter;\n+import java.io.FileWriter;\n+import java.io.IOException;\n+import java.io.OutputStreamWriter;\n+import java.util.*;\n+import java.util.zip.GZIPOutputStream;\n+\n+@DocumentedFeature\n+@CommandLineProgramProperties(\n+        summary = \"experiment\",\n+        oneLineSummary = \"experiment\",\n+        usageExample = \"gatk LocalAssembler\",\n+        programGroup = CoverageAnalysisProgramGroup.class\n+)\n+@BetaFeature\n+public class LocalAssembler extends PairWalker {\n+    public static final byte QMIN = 25;\n+    public static final int MIN_THIN_OBS = 4;\n+    public static final int MIN_GAPFILL_COUNT = 3;\n+    public static final int TOO_MANY_TRAVERSALS = 100000;\n+    public static final int TOO_MANY_SCAFFOLDS = 50000;\n+    public static final int MIN_SV_SIZE = 50;\n+\n+    @Argument(fullName=StandardArgumentDefinitions.OUTPUT_LONG_NAME,\n+            shortName=StandardArgumentDefinitions.OUTPUT_SHORT_NAME,\n+            doc=\"Write outputs to this file name prefix\", optional = true)\n+    public static String output;\n+\n+    @Argument(fullName=\"assembly-name\", doc=\"name of assembly used as a prefix for traversal names\")\n+    public static String assemblyName;\n+\n+    private final List<GATKRead> reads = new ArrayList<>();\n+\n+    @Override public boolean requiresIntervals() { return true; }\n+\n+    @Override public void apply( final GATKRead read, final GATKRead mate ) {\n+        trimOverruns(read, mate);\n+        reads.add(read);\n+        reads.add(mate);\n+    }\n+\n+    @Override public void applyUnpaired( final GATKRead read ) {\n+        reads.add(read);\n+    }\n+\n+    @Override public Object onTraversalSuccess() {\n+        super.onTraversalSuccess(); // flush any incomplete pairs\n+\n+        final int regionSize = getTraversalIntervals().stream().mapToInt(SimpleInterval::size).sum();\n+        final KmerSet<KmerAdjacency> kmerAdjacencySet = new KmerSet<>(10 * regionSize);\n+        kmerizeReads(reads, kmerAdjacencySet);\n+        List<ContigImpl> contigs = buildContigs(kmerAdjacencySet);\n+        connectContigs(contigs);\n+\n+        removeThinContigs(contigs, kmerAdjacencySet);\n+        weldPipes(contigs);\n+        markComponents(contigs);\n+\n+        if ( fillGaps(kmerAdjacencySet, reads) ) {\n+            contigs = buildContigs(kmerAdjacencySet);\n+            connectContigs(contigs);\n+            removeThinContigs(contigs, kmerAdjacencySet);\n+            weldPipes(contigs);\n+            markComponents(contigs);\n+        }\n+\n+        markCycles(contigs);\n+\n+        final String outputFilePrefix = output != null ? output : assemblyName;\n+        final List<Path> readPaths = pathReads(kmerAdjacencySet, reads);\n+        final Map<Contig,List<TransitPairCount>> contigTransitsMap =\n+                collectTransitPairCounts(contigs, readPaths);\n+        final String traversalsFilename = outputFilePrefix + \".traversals.fa.gz\";\n+        try {\n+            final List<Traversal> allTraversals =\n+                    new ArrayList<>(traverseAllPaths(contigs, readPaths, contigTransitsMap));\n+            writeTraversals(allTraversals, traversalsFilename);\n+            try {\n+                final String scaffoldsFileName = outputFilePrefix + \".scaffolds.fa.gz\";\n+                writeTraversals(createScaffolds(allTraversals), scaffoldsFileName);\n+            } catch ( final AssemblyTooComplexException x ) {\n+                logger.warn(\"Assembly too complex for scaffolding.\");\n+            }\n+        } catch ( final AssemblyTooComplexException x ) {\n+            logger.warn(\"Assembly too complex.  Writing contigs as traversals in \" +\n+                    traversalsFilename + \".\");\n+            final Collection<Traversal> contigTraversals = new ArrayList<>(contigs.size());\n+            for ( final Contig contig : contigs ) {\n+                contigTraversals.add(new Traversal(Collections.singletonList(contig)));\n+            }\n+            writeTraversals(contigTraversals, traversalsFilename);\n+        }\n+\n+        contigs.sort(Comparator.comparingInt(ContigImpl::getId));\n+        writeDOT(contigs, outputFilePrefix + \".assembly.dot\");\n+        writeContigs(contigs, outputFilePrefix + \".contigs.txt.gz\");\n+        writePaths(readPaths, outputFilePrefix + \".paths.txt.gz\");\n+        writeReads(reads, outputFilePrefix + \".reads.fastq.gz\");\n+        return null;\n+    }\n+\n+    /** trim read pairs of base calls that have gone past the end of a short fragment */\n+    private void trimOverruns( final GATKRead read, final GATKRead mate ) {\n+        // if both mapped and they're on different strands\n+        if ( !read.isUnmapped() && !mate.isUnmapped() &&\n+                read.isReverseStrand() != mate.isReverseStrand() ) {\n+            // and both start within 1 base on the ref\n+            if ( Math.abs(read.getStart() - read.getMateStart()) <= 1 ) {\n+                // and both end within 1 base\n+                final int readRefLen = read.getCigar().getReferenceLength();\n+                final int mateRefLen = mate.getCigar().getReferenceLength();\n+                if ( Math.abs(readRefLen - mateRefLen) <= 1 ) {\n+                    if ( mate.isReverseStrand() ) {\n+                        trimClips(read, mate);\n+                    } else {\n+                        trimClips(mate, read);\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    private void trimClips( final GATKRead fwd, final GATKRead rev ) {\n+        final List<CigarElement> fwdElements = fwd.getCigarElements();\n+        final List<CigarElement> revElements = rev.getCigarElements();\n+        final int lastElementIdx = fwdElements.size() - 1;\n+        final CigarElement fwdLastElement = fwdElements.get(lastElementIdx);\n+        final CigarElement revFirstElement = revElements.get(0);\n+        if ( fwdLastElement.getOperator() == CigarOperator.S &&\n+                revFirstElement.getOperator() == CigarOperator.S ) {\n+            final byte[] fwdBases = fwd.getBasesNoCopy();\n+            final int lastElementLen = fwdLastElement.getLength();\n+            fwd.setBases(Arrays.copyOfRange(fwdBases, 0, fwdBases.length - lastElementLen));\n+            final byte[] fwdQuals = fwd.getBaseQualitiesNoCopy();\n+            if ( fwdQuals.length > 0 ) {\n+                final int qualsLen = fwdQuals.length - lastElementLen;\n+                fwd.setBaseQualities(Arrays.copyOfRange(fwdQuals, 0, qualsLen));\n+            }\n+            final List<CigarElement> newFwdElements = new ArrayList<>(fwdElements);\n+            newFwdElements.set(lastElementIdx, new CigarElement(lastElementLen, CigarOperator.H));\n+            fwd.setCigar(new Cigar(newFwdElements));\n+\n+            final byte[] revBases = rev.getBasesNoCopy();\n+            final int firstElementLen = revFirstElement.getLength();\n+            rev.setBases(Arrays.copyOfRange(revBases, firstElementLen, revBases.length));\n+            final byte[] revQuals = rev.getBaseQualitiesNoCopy();\n+            if ( revQuals.length > 0 ) {\n+                rev.setBaseQualities(Arrays.copyOfRange(revQuals, firstElementLen, revQuals.length));\n+            }\n+            final List<CigarElement> newRevElements = new ArrayList<>(revElements);\n+            newRevElements.set(0, new CigarElement(firstElementLen, CigarOperator.H));\n+            rev.setCigar(new Cigar(newRevElements));\n+        }\n+    }\n+\n+    @VisibleForTesting\n+    static void kmerizeReads( final List<GATKRead> reads,\n+                              final KmerSet<KmerAdjacency> kmerAdjacencySet ) {\n+        for ( final GATKRead read : reads ) {\n+            final byte[] calls = read.getBasesNoCopy();\n+            final byte[] quals = read.getBaseQualitiesNoCopy();\n+            KmerAdjacency.kmerize(calls, quals, QMIN, kmerAdjacencySet);\n+        }\n+    }\n+\n+    /** gather unbranched strings of kmers into contigs **/\n+    @VisibleForTesting\n+    static List<ContigImpl> buildContigs( final KmerSet<KmerAdjacency> kmerAdjacencySet ) {\n+        // gather strings of kmers that have a single predecessor and single successor into contigs\n+        final List<ContigImpl> contigs = new ArrayList<>();\n+        int nContigs = 0;\n+        for ( final KmerAdjacency kmerAdjacency : kmerAdjacencySet ) {\n+            if ( kmerAdjacency.getContig() == null ) {\n+                ContigImpl contig = null;\n+                final KmerAdjacency predecessor = kmerAdjacency.getSolePredecessor();\n+                if ( predecessor == null ||\n+                        predecessor.getSuccessorCount() > 1 ||\n+                        predecessor == kmerAdjacency.rc() ) {\n+                    contig = new ContigImpl(++nContigs, kmerAdjacency);\n+                } else {\n+                    final KmerAdjacency successor = kmerAdjacency.getSoleSuccessor();\n+                    if ( successor == null ||\n+                            successor.getPredecessorCount() > 1 ||\n+                            successor == kmerAdjacency.rc() ) {\n+                        contig = new ContigImpl(++nContigs, kmerAdjacency.rc());\n+                    }\n+                }\n+                if ( contig != null ) {\n+                    contigs.add(contig);\n+                }\n+            }\n+        }\n+\n+        // if there are smooth circles like a plasmid, gather them together as a contig, too\n+        for ( final KmerAdjacency kmerAdjacency : kmerAdjacencySet ) {\n+            if ( kmerAdjacency.getContig() == null ) {\n+                contigs.add(new ContigImpl(++nContigs, kmerAdjacency));\n+            }\n+        }\n+\n+        return contigs;\n+    }\n+\n+    /** connect contigs when the final kmer of one contig is adjacent to the inital contig of another **/\n+    @VisibleForTesting\n+    static void connectContigs( final List<ContigImpl> contigs ) {\n+        final int nContigs = contigs.size();\n+        final KmerSet<ContigEndKmer> contigEnds = new KmerSet<>(2*nContigs);\n+        for ( int contigId = 0; contigId != nContigs; ++contigId ) {\n+            final ContigImpl contig = contigs.get(contigId);\n+            final KmerAdjacency fwdKmer = contig.getFirstKmer();\n+            final KmerAdjacency revKmer = contig.getLastKmer().rc();\n+            if ( fwdKmer == revKmer ) {\n+                contigEnds.add(new ContigEndKmer(fwdKmer.getKVal(), contig, ContigOrientation.BOTH));\n+            } else {\n+                contigEnds.add(new ContigEndKmer(fwdKmer.getKVal(), contig, ContigOrientation.FWD));\n+                contigEnds.add(new ContigEndKmer(revKmer.getKVal(), contig, ContigOrientation.REV));\n+            }\n+        }\n+\n+        for ( int contigId = 0; contigId != nContigs; ++contigId ) {\n+            final Contig contig = contigs.get(contigId);\n+\n+            final KmerAdjacency start = contig.getFirstKmer();\n+            final int predecessorCount = start.getPredecessorCount();\n+            if ( predecessorCount > 0 ) {\n+                final List<Contig> predecessors = contig.getPredecessors();\n+                final int mask = start.getPredecessorMask();\n+                for ( int call = 0; call != 4; ++call ) {\n+                    if ( (mask & (1 << call)) != 0 ) {\n+                        final long kVal =\n+                                KmerAdjacency.reverseComplement(start.getPredecessorVal(call));\n+                        final ContigEndKmer contigEndKmer = contigEnds.find(new Kmer(kVal));\n+                        if ( contigEndKmer == null ) {\n+                            throw new GATKException(\"missing contig end kmer\");\n+                        }\n+                        switch ( contigEndKmer.getContigOrientation() ) {\n+                            case FWD:\n+                                predecessors.add(contigEndKmer.getContig().rc());\n+                                break;\n+                            case REV:\n+                                predecessors.add(contigEndKmer.getContig());\n+                                break;\n+                            case BOTH:\n+                                predecessors.add(contigEndKmer.getContig());\n+                                predecessors.add(contigEndKmer.getContig().rc());\n+                                break;\n+                        }\n+                    }\n+                }\n+            }\n+\n+            final KmerAdjacency end = contig.getLastKmer();\n+            final int successorCount = end.getSuccessorCount();\n+            if ( successorCount > 0 ) {\n+                final List<Contig> successors = contig.getSuccessors();\n+                final int mask = end.getSuccessorMask();\n+                for ( int call = 0; call != 4; ++call ) {\n+                    if ( (mask & (1 << call)) != 0 ) {\n+                        final long kVal = end.getSuccessorVal(call);\n+                        final ContigEndKmer contigEndKmer = contigEnds.find(new Kmer(kVal));\n+                        if ( contigEndKmer == null ) {\n+                            throw new GATKException(\"missing contig end kmer\");\n+                        }\n+                        switch ( contigEndKmer.getContigOrientation() ) {\n+                            case FWD:\n+                                successors.add(contigEndKmer.getContig());\n+                                break;\n+                            case REV:\n+                                successors.add(contigEndKmer.getContig().rc());\n+                                break;\n+                            case BOTH:\n+                                successors.add(contigEndKmer.getContig());\n+                                successors.add(contigEndKmer.getContig().rc());\n+                                break;\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    /** remove contigs that have little evidence **/\n+    @VisibleForTesting\n+    static void removeThinContigs( final List<ContigImpl> contigs,\n+                                           final KmerSet<KmerAdjacency> kmerAdjacencySet ) {\n+        contigs.sort(Comparator.comparingInt(ContigImpl::getMaxObservations));\n+        boolean contigRemoved;\n+        do {\n+            // figure out which contigs are cut points\n+            // i.e., those contigs which, if removed, would result in a graph with more connected components\n+            final int nContigs = contigs.size();\n+            final Map<Contig, CutData> cutDataMap = new HashMap<>(nContigs * 3);\n+\n+            for ( final ContigImpl contig : contigs ) {\n+                if ( cutDataMap.containsKey(contig) ) {\n+                    continue;\n+                }\n+\n+                cutDataMap.put(contig, new CutData());\n+                int children = 0;\n+                for ( final Contig nextContig : contig.getSuccessors() ) {\n+                    if ( !cutDataMap.containsKey(nextContig) ) {\n+                        findCuts(nextContig, contig, cutDataMap);\n+                        children += 1;\n+                    }\n+                }\n+                for ( final Contig nextContig : contig.getPredecessors() ) {\n+                    if ( !cutDataMap.containsKey(nextContig) ) {\n+                        findCuts(nextContig, contig, cutDataMap);\n+                        children += 1;\n+                    }\n+                }\n+                if ( children >= 2 ) {\n+                    contig.setCut(true);\n+                }\n+            }\n+\n+            // remove poorly attested (low max observations) contigs, unless they are cut points\n+            contigRemoved = false;\n+            final Iterator<ContigImpl> itr = contigs.iterator();\n+            while ( itr.hasNext() ) {\n+                final Contig contig = itr.next();\n+                if ( contig.getMaxObservations() < MIN_THIN_OBS && !contig.isCut() ) {\n+                    unlinkContig(contig, kmerAdjacencySet);\n+                    itr.remove();\n+                    contigRemoved = true;\n+                    break;\n+                }\n+            }\n+        } while ( contigRemoved );\n+        contigs.sort(Comparator.comparingInt(ContigImpl::getId));\n+    }\n+\n+    private static CutData findCuts( final Contig contig,\n+                                     final Contig parent,\n+                                     final Map<Contig, CutData> cutDataMap ) {\n+        final CutData cutData = new CutData();\n+        cutDataMap.put(contig, cutData);\n+        for ( final Contig nextContig : contig.getSuccessors() ) {\n+            if ( nextContig == parent ) {\n+                continue;\n+            }\n+            CutData nextCutData = cutDataMap.get(nextContig);\n+            if ( nextCutData != null ) {\n+                cutData.minVisitNum = Math.min(cutData.minVisitNum, nextCutData.visitNum);\n+            } else {\n+                nextCutData = findCuts(nextContig, contig, cutDataMap);\n+                cutData.minVisitNum = Math.min(cutData.minVisitNum, nextCutData.minVisitNum);\n+                if ( nextCutData.minVisitNum >= cutData.visitNum ) {\n+                    contig.setCut(true);\n+                }\n+            }\n+        }\n+        for ( final Contig nextContig : contig.getPredecessors() ) {\n+            if ( nextContig == parent ) {\n+                continue;\n+            }\n+            CutData nextCutData = cutDataMap.get(nextContig);\n+            if ( nextCutData != null ) {\n+                cutData.minVisitNum = Math.min(cutData.minVisitNum, nextCutData.visitNum);\n+            } else {\n+                nextCutData = findCuts(nextContig, contig, cutDataMap);\n+                cutData.minVisitNum = Math.min(cutData.minVisitNum, nextCutData.minVisitNum);\n+                if ( nextCutData.minVisitNum >= cutData.visitNum ) {\n+                    contig.setCut(true);\n+                }\n+            }\n+        }\n+        return cutData;\n+    }\n+\n+    @VisibleForTesting\n+    static void unlinkContig( final Contig contig,\n+                                      final KmerSet<KmerAdjacency> kmerAdjacencySet ) {\n+        final KmerAdjacency firstKmer = contig.getFirstKmer();\n+        final int firstKmerFinalCall = firstKmer.getFinalCall();\n+        for ( final Contig predecessor : contig.getPredecessors() ) {\n+            if ( predecessor != contig && predecessor != contig.rc() ) {\n+                predecessor.getLastKmer().removeSuccessor(firstKmerFinalCall, kmerAdjacencySet);\n+                if ( !predecessor.getSuccessors().remove(contig) ) {\n+                    throw new GATKException(\"failed to find predecessor link\");\n+                }\n+            }\n+        }\n+\n+        final KmerAdjacency lastKmer = contig.getLastKmer();\n+        final int lastKmerInitialCall = lastKmer.getInitialCall();\n+        for ( final Contig successor : contig.getSuccessors() ) {\n+            if ( successor != contig && successor != contig.rc() ) {\n+                successor.getFirstKmer().removePredecessor(lastKmerInitialCall, kmerAdjacencySet);\n+                if ( !successor.getPredecessors().remove(contig) ) {\n+                    throw new GATKException(\"failed to find successor link\");\n+                }\n+            }\n+        }\n+\n+        KmerAdjacency nextKmer = firstKmer;\n+        KmerAdjacency kmer;\n+        do {\n+            kmer = nextKmer;\n+            nextKmer = kmer.getSoleSuccessor();\n+            kmerAdjacencySet.remove(kmer.canonical());\n+        } while ( kmer != lastKmer );\n+    }\n+\n+    private static void updateKmerContig( final KmerAdjacency firstKmer,\n+                                          final KmerAdjacency lastKmer,\n+                                          final Contig contig ) {\n+        int offset = 0;\n+        for ( KmerAdjacency kmer = firstKmer; kmer != lastKmer; kmer = kmer.getSoleSuccessor() ) {\n+            if ( kmer == null ) {\n+                throw new GATKException(\"contig does not have a flat pipeline of kmers\");\n+            }\n+            kmer.clearContig();\n+            kmer.setContigOffset(contig, offset++);\n+        }\n+        lastKmer.clearContig();\n+        lastKmer.setContigOffset(contig, offset);\n+        if ( offset + Kmer.KSIZE != contig.size() ) {\n+            throw new GATKException(\"kmer chain length does not equal contig size\");\n+        }\n+    }\n+\n+    /** replace adjacent contigs without branches with a single, larger contig **/\n+    @VisibleForTesting\n+    static void weldPipes( final List<ContigImpl> contigs ) {\n+        for ( int contigIdx = 0; contigIdx != contigs.size(); ++contigIdx ) {\n+            final ContigImpl contig = contigs.get(contigIdx);\n+            if ( contig.getSuccessors().size() == 1 ) {\n+                final Contig successor = contig.getSuccessors().get(0);\n+                if ( successor != contig && successor != contig.rc() &&\n+                        successor.getPredecessors().size() == 1 ) {\n+                    contigs.set(contigIdx, join(contig.getId(), contig, successor));\n+                    if ( !contigs.remove(successor.canonical()) ) {\n+                        throw new GATKException(\"successor linkage is messed up\");\n+                    }\n+                    contigIdx -= 1; // reconsider the new contig -- there might be more joining possible\n+                    continue;\n+                }\n+            }\n+            if ( contig.getPredecessors().size() == 1 ) {\n+                final Contig predecessor = contig.getPredecessors().get(0);\n+                if ( predecessor != contig && predecessor != contig.rc() &&\n+                        predecessor.getSuccessors().size() == 1 ) {\n+                    contigs.set(contigIdx, join(contig.getId(), predecessor, contig));\n+                    if ( !contigs.remove(predecessor.canonical()) ) {\n+                        throw new GATKException(\"predecessor linkage is messed up\");\n+                    }\n+                    contigIdx -= 1; // reconsider\n+                }\n+            }\n+        }\n+    }\n+\n+    private static ContigImpl join( final int id, final Contig predecessor, final Contig successor ) {\n+        if ( !checkOverlap(predecessor.getSequence(), successor.getSequence()) ) {\n+                throw new GATKException(\"sequences can't be joined\");\n+        }\n+        final ContigImpl joinedContig = new ContigImpl(id, predecessor, successor);\n+        updateKmerContig(joinedContig.getFirstKmer(), joinedContig.getLastKmer(), joinedContig);\n+        return joinedContig;\n+    }\n+\n+    private static boolean checkOverlap( final CharSequence seq1, final CharSequence seq2 ) {\n+        final int seq1Len = seq1.length();\n+        final CharSequence seq1SubSeq = seq1.subSequence(seq1Len - Kmer.KSIZE + 1, seq1Len);\n+        final CharSequence seq2SubSeq = seq2.subSequence(0, Kmer.KSIZE - 1);\n+        return seq1SubSeq.equals(seq2SubSeq);\n+    }\n+\n+    /** set a unique componentId for every connected group of contigs **/\n+    @VisibleForTesting\n+    static int markComponents( final List<ContigImpl> contigs ) {\n+        for ( final ContigImpl contig : contigs ) {\n+            contig.setComponentId(0);\n+        }\n+\n+        int componentId = 0;\n+        for ( final ContigImpl contig : contigs ) {\n+            if ( contig.getComponentId() == 0 ) {\n+                contig.setComponentId(++componentId);\n+                markSuccessorComponents(contig);\n+                markSuccessorComponents(contig.rc());\n+            }\n+        }\n+        return componentId;\n+    }\n+\n+    private static void markSuccessorComponents( final Contig contig ) {\n+        final int componentId = contig.getComponentId();\n+        for ( final Contig successor : contig.getSuccessors() ) {\n+            if ( successor.getComponentId() == 0 ) {\n+                successor.canonical().setComponentId(componentId);\n+                markSuccessorComponents(successor);\n+                markSuccessorComponents(successor.rc());\n+            }\n+        }\n+    }\n+\n+    @VisibleForTesting\n+    static void markCycles( final List<ContigImpl> contigs ) {\n+        for ( final Contig contig : contigs ) {\n+            contig.setCyclic(false);\n+        }\n+\n+        final int nContigs = contigs.size();\n+        final Deque<Contig> deque = new ArrayDeque<>(nContigs);\n+        final Map<Contig, CutData> cutDataMap = new HashMap<>(nContigs * 3);\n+        for ( final Contig contig : contigs ) {\n+            if ( !cutDataMap.containsKey(contig) ) {\n+                markCyclesRecursion(contig, deque, cutDataMap);\n+            }\n+        }\n+    }\n+\n+    private static CutData markCyclesRecursion( final Contig contig,\n+                                                final Deque<Contig> deque,\n+                                                final Map<Contig, CutData> cutDataMap ) {\n+        final CutData cutData = new CutData();\n+        cutDataMap.put(contig, cutData);\n+        deque.addFirst(contig);\n+\n+        for ( final Contig successor : contig.getSuccessors() ) {\n+            final CutData successorCutData = cutDataMap.get(successor);\n+            if ( successorCutData == null ) {\n+                final int recursionVisitNum =\n+                        markCyclesRecursion(successor, deque, cutDataMap).minVisitNum;\n+                cutData.minVisitNum = Math.min(cutData.minVisitNum, recursionVisitNum);\n+            } else {\n+                cutData.minVisitNum = Math.min(cutData.minVisitNum, successorCutData.visitNum);\n+            }\n+        }\n+\n+        if ( cutData.visitNum == cutData.minVisitNum ) {\n+            Contig tig = deque.removeFirst();\n+            if ( tig == contig ) {\n+                cutDataMap.get(tig).visitNum = Integer.MAX_VALUE;\n+\n+                // single-vertex component -- cyclic only if self-referential\n+                if ( tig.getSuccessors().contains(tig) ) {\n+                    tig.setCyclic(true);\n+                }\n+            } else {\n+                while ( true ) {\n+                    // kill cross-links\n+                    cutDataMap.get(tig).visitNum = Integer.MAX_VALUE;\n+                    tig.setCyclic(true);\n+                    if ( tig == contig ) break;\n+                    tig = deque.removeFirst();\n+                }\n+            }\n+        }\n+        return cutData;\n+    }\n+\n+    @VisibleForTesting\n+    static boolean fillGaps( final KmerSet<KmerAdjacency> kmerAdjacencySet,\n+                             final List<GATKRead> reads ) {\n+        final Map<String, Integer> gapFillCounts = new HashMap<>();\n+        for ( final GATKRead read : reads ) {\n+            final Path path = new Path(read.getBasesNoCopy(), kmerAdjacencySet);\n+            final List<PathPart> parts = path.getParts();\n+            final int lastIdx = parts.size() - 1;\n+            for ( int idx = 1; idx < lastIdx; ++idx ) {\n+                final PathPart pathPart = parts.get(idx);\n+                if ( pathPart.isGap() ) {\n+                    final char prevCall = parts.get(idx - 1).getLastCall();\n+                    final char nextCall = parts.get(idx + 1).getFirstCall();\n+                    String gapFill = prevCall + pathPart.getSequence().toString() + nextCall;\n+                    final SequenceRC gapFillRC = new SequenceRC(gapFill);\n+                    if ( gapFillRC.compareTo(gapFill) < 0 ) {\n+                        gapFill = gapFillRC.toString();\n+                    }\n+                    gapFillCounts.merge(gapFill, 1, Integer::sum);\n+                }\n+            }\n+        }\n+\n+        boolean newKmers = false;\n+        for ( final Map.Entry<String, Integer> entry : gapFillCounts.entrySet() ) {\n+            final int nObservations = entry.getValue();\n+            if ( nObservations >= MIN_GAPFILL_COUNT ) {\n+                KmerAdjacency.kmerize(entry.getKey(), nObservations, kmerAdjacencySet);\n+                newKmers = true;\n+            }\n+        }\n+\n+        if ( newKmers ) {\n+            for ( final KmerAdjacency kmerAdjacency : kmerAdjacencySet ) {\n+                kmerAdjacency.clearContig();\n+            }\n+        }\n+        return newKmers;\n+    }\n+\n+    @VisibleForTesting\n+    static List<Path> pathReads( final KmerSet<KmerAdjacency> kmerAdjacencySet,\n+                          final List<GATKRead> reads ) {\n+        final List<Path> readPaths = new ArrayList<>(reads.size());\n+        for ( final GATKRead read : reads ) {\n+            readPaths.add(new Path(read.getBasesNoCopy(), kmerAdjacencySet));\n+        }\n+        return readPaths;\n+    }\n+\n+    @VisibleForTesting\n+    static Map<Contig,List<TransitPairCount>> collectTransitPairCounts(\n+            final List<ContigImpl> contigs,\n+            final List<Path> readPaths ) {\n+        final Map<Contig,List<TransitPairCount>> contigTransitsMap =\n+                new HashMap<>(3 * contigs.size());\n+        for ( final Path path : readPaths ) {\n+            final List<PathPart> parts = path.getParts();\n+            final int lastPart = parts.size() - 1;\n+            for ( int partIdx = 1; partIdx < lastPart; ++partIdx ) {\n+                final Contig prevContig = parts.get(partIdx - 1).getContig();\n+                if ( prevContig == null ) continue;\n+                final Contig curContig = parts.get(partIdx).getContig();\n+                if ( curContig == null ) {\n+                    partIdx += 1;\n+                    continue;\n+                }\n+                final Contig nextContig = parts.get(partIdx + 1).getContig();\n+                if ( nextContig == null ) {\n+                    partIdx += 2;\n+                    continue;\n+                }\n+                final TransitPairCount tpc = new TransitPairCount(prevContig, nextContig);\n+                final List<TransitPairCount> tpcList =\n+                        contigTransitsMap.computeIfAbsent(curContig, tig -> new ArrayList<>(4));\n+                final int idx = tpcList.indexOf(tpc);\n+                if ( idx != -1 ) {\n+                    tpcList.get(idx).observe();\n+                } else {\n+                    tpcList.add(tpc);\n+                    contigTransitsMap.computeIfAbsent(curContig.rc(), tig -> new ArrayList<>(4))\n+                            .add(tpc.getRC());\n+                }\n+            }\n+        }\n+        return contigTransitsMap;\n+    }\n+\n+    @VisibleForTesting\n+    static Set<Traversal> traverseAllPaths(\n+            final List<ContigImpl> contigs,\n+            final List<Path> readPaths,\n+            final Map<Contig, List<TransitPairCount>> contigTransitsMap ) {\n+        final Set<Traversal> traversalSet = new HashSet<>();\n+        final List<Contig> contigsList = new ArrayList<>();\n+        for ( final Contig contig : contigs ) {\n+            // untransited contigs are sources, sinks, or large contigs that can't be crossed by a read\n+            // build traversals from these\n+            if ( !contigTransitsMap.containsKey(contig) ) {\n+                boolean done = false;\n+                for ( final Contig successor : contig.getSuccessors() ) {\n+                    traverse(successor, contig,\n+                            contigsList, readPaths, contigTransitsMap, traversalSet);\n+                    done = true;\n+                }\n+                for ( final Contig predecessor : contig.getPredecessors() ) {\n+                    traverse(predecessor.rc(), contig.rc(),\n+                            contigsList, readPaths, contigTransitsMap, traversalSet);\n+                    done = true;\n+                }\n+                if ( !done ) { // if there were no predecessors or successors, it stands alone\n+                    addTraversal(new Traversal(Collections.singletonList(contig)), traversalSet);\n+                }\n+            }\n+        }\n+\n+        // look for transits that haven't been traced\n+        for ( final Map.Entry<Contig, List<TransitPairCount>> entry :\n+                contigTransitsMap.entrySet() ) {\n+            for ( final TransitPairCount tpc : entry.getValue() ) {\n+                if ( tpc.getCount() > 0 ) {\n+                    tpc.resetCount();\n+                    final Contig contig = entry.getKey();\n+                    final Set<Traversal> fwdTraversalSet = new HashSet<>();\n+                    traverse(tpc.getNextContig(), contig,\n+                            contigsList, readPaths, contigTransitsMap, fwdTraversalSet);\n+                    final Set<Traversal> revTraversalSet = new HashSet<>();\n+                    traverse(tpc.getPrevContig().rc(), contig.rc(),\n+                            contigsList, readPaths, contigTransitsMap, revTraversalSet);\n+                    for ( final Traversal revTraversal : revTraversalSet ) {\n+                        final Traversal revTraversalRC = revTraversal.rc();\n+                        for ( final Traversal fwdTraversal : fwdTraversalSet ) {\n+                            final int overlap =\n+                                    findMaxOverlap(revTraversalRC.getContigs(), fwdTraversal.getContigs());\n+                            final Traversal combo =\n+                                    Traversal.combineOverlappers(revTraversalRC, fwdTraversal, overlap);\n+                            addTraversal(combo, traversalSet);\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+\n+        return traversalSet;\n+    }\n+\n+    private static int findMaxOverlap( final List<Contig> prefixes, final List<Contig> suffixes ) {\n+        final int nPrefixes = prefixes.size();\n+        final Contig firstSuffix = suffixes.get(0);\n+        if ( !firstSuffix.isCyclic() ) {\n+            return prefixes.get(nPrefixes - 1) == firstSuffix ? 1 : 0;\n+        }\n+        final int nSuffixes = suffixes.size();\n+        for ( int prefixIdx = Math.max(0, nPrefixes - nSuffixes); prefixIdx != nPrefixes; ++prefixIdx ) {\n+            if ( prefixes.get(prefixIdx) == firstSuffix ) {\n+                int suffixIdx = 1;\n+                boolean match = true;\n+                for ( int prefixIdx2 = prefixIdx + 1; prefixIdx2 != nPrefixes; ++prefixIdx2 ) {\n+                    if ( prefixes.get(prefixIdx2) != suffixes.get(suffixIdx++) ) {\n+                        match = false;\n+                        break;\n+                    }\n+                }\n+                if ( match ) {\n+                    return nPrefixes - prefixIdx;\n+                }\n+            }\n+        }\n+        return 0;\n+    }\n+\n+    private static void traverse( final Contig contig,\n+                                  final Contig predecessor,\n+                                  final List<Contig> contigsList,\n+                                  final List<Path> readPaths,\n+                                  final Map<Contig, List<TransitPairCount>> contigTransitsMap,\n+                                  final Set<Traversal> traversalSet ) {\n+        contigsList.add(predecessor);\n+        if ( contig.isCyclic() ) {\n+            traverseCycle(contig, contigsList, readPaths, contigTransitsMap, traversalSet);\n+            contigsList.remove(contigsList.size() - 1);\n+            return;\n+        }\n+        final List<TransitPairCount> transits = contigTransitsMap.get(contig);\n+        boolean done = false;\n+        if ( transits != null ) {\n+            for ( final TransitPairCount tpc : transits ) {\n+                if ( tpc.getPrevContig() == predecessor ) {\n+                    final Contig successor = tpc.getNextContig();\n+                    if ( predecessor == contig.rc() ) {\n+                        final int nContigs = contigsList.size();\n+                        if ( nContigs > 1 ) {\n+                            if ( successor.rc() == contigsList.get(nContigs - 2) ) {\n+                                continue;\n+                            }\n+                        }\n+                    }\n+                    tpc.resetCount();\n+                    traverse(successor, contig, contigsList, readPaths, contigTransitsMap, traversalSet);\n+                    done = true;\n+                }\n+            }\n+        }\n+        if ( !done ) {\n+            contigsList.add(contig);\n+            addTraversal(new Traversal(contigsList), traversalSet);\n+            contigsList.remove(contigsList.size() - 1);\n+        }\n+        contigsList.remove(contigsList.size() - 1);\n+    }\n+\n+    private static void traverseCycle( final Contig contig,\n+                                       final List<Contig> contigsList,\n+                                       final List<Path> readPaths,\n+                                       final Map<Contig, List<TransitPairCount>> contigTransitsMap,\n+                                       final Set<Traversal> traversalSet ) {\n+        contigsList.add(contig);\n+        final int nContigs = contigsList.size();\n+        // the final element of the list is cyclic, if there's a previous element it will be\n+        // non-cyclic, so start there figuring out how far the read paths lead us\n+        final List<List<Contig>> longestPaths =\n+                findLongestPaths(contigsList.subList(Math.max(0, nContigs - 2), nContigs), readPaths);\n+        // didn't get anywhere -- just complete the traversal\n+        if ( longestPaths.isEmpty() ) {\n+            addTraversal(new Traversal(contigsList, true), traversalSet);\n+        } else {\n+            // for each unique extension into the cycle\n+            for ( final List<Contig> path : longestPaths ) {\n+                // don't think this can happen, but still\n+                if ( path.isEmpty() ) {\n+                    addTraversal(new Traversal(contigsList, true), traversalSet);\n+                    continue;\n+                }\n+                final List<Contig> extendedContigsList =\n+                        new ArrayList<>(contigsList.size() + path.size());\n+                extendedContigsList.addAll(contigsList);\n+                // if we didn't get out of the cycle\n+                if ( path.get(path.size() - 1).isCyclic() ) {\n+                    extendedContigsList.addAll(path);\n+                    addTraversal(new Traversal(extendedContigsList, true), traversalSet);\n+                } else {\n+                    // we found a cycle-exiting path, so extend that normally\n+                    for ( final Contig curContig : path ) {\n+                        if ( curContig.isCyclic() ) {\n+                            extendedContigsList.add(curContig);\n+                        } else {\n+                            final Contig prevContig =\n+                                    extendedContigsList.remove(extendedContigsList.size() - 1);\n+                            traverse(curContig, prevContig, extendedContigsList, readPaths,\n+                                    contigTransitsMap, traversalSet);\n+                            extendedContigsList.add(prevContig);\n+                            break;\n+                        }\n+                    }\n+                }\n+                clearTransitPairs(contigTransitsMap, extendedContigsList);\n+            }\n+        }\n+        contigsList.remove(contigsList.size() - 1);\n+    }\n+\n+    private static void clearTransitPairs(\n+            final Map<Contig, List<TransitPairCount>> contigTransitsMap,\n+            final List<Contig> contigsList ) {\n+        final int lastIdx = contigsList.size() - 1;\n+        for ( int idx = 1; idx < lastIdx; ++idx ) {\n+            final List<TransitPairCount> pairCounts = contigTransitsMap.get(contigsList.get(idx));\n+            if ( pairCounts != null ) {\n+                final Contig predecessor = contigsList.get(idx - 1);\n+                final Contig successor = contigsList.get(idx + 1);\n+                for ( final TransitPairCount tpc : pairCounts ) {\n+                    if ( tpc.getPrevContig() == predecessor && tpc.getNextContig() == successor ) {\n+                        tpc.resetCount();\n+                        break;\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    private static void addTraversal( final Traversal traversal,\n+                                      final Set<Traversal> traversalSet ) {\n+        if ( !traversalSet.contains(traversal.rc()) ) {\n+            traversalSet.add(traversal);\n+            if ( traversalSet.size() >= TOO_MANY_TRAVERSALS ) {\n+                throw new AssemblyTooComplexException();\n+            }\n+        }\n+    }\n+\n+    private static List<List<Contig>> findLongestPaths( final List<Contig> toMatch,\n+                                                        final List<Path> readPaths ) {\n+        final List<List<Contig>> results = new ArrayList<>();\n+        for ( final Path path : readPaths ) {\n+            testPath(path, toMatch, results);\n+            testPath(path.rc(), toMatch, results);\n+        }\n+        return results;\n+    }\n+\n+    private static void testPath( final Path path,\n+                                  final List<Contig> toMatch,\n+                                  final List<List<Contig>> results ) {\n+        final List<PathPart> pathParts = path.getParts();\n+        final int nPathParts = pathParts.size();\n+        final List<Contig> pathContigs = new ArrayList<>(nPathParts);\n+        pathParts.forEach(pp -> pathContigs.add(pp.getContig()));\n+        final int matchIdx = Collections.indexOfSubList(pathContigs, toMatch);\n+        if ( matchIdx != -1 ) {\n+            final int suffixIdx = matchIdx + toMatch.size();\n+            if ( suffixIdx < nPathParts ) {\n+                resolveResult(grabParts(pathContigs, suffixIdx), results);\n+            }\n+        }\n+    }\n+\n+    private static List<Contig> grabParts( final List<Contig> pathContigs, final int suffixIdx ) {\n+        final int nPathContigs = pathContigs.size();\n+        Contig prev = pathContigs.get(suffixIdx - 1);\n+        final List<Contig> result = new ArrayList<>(nPathContigs - suffixIdx);\n+        for ( int idx = suffixIdx; idx != nPathContigs; ++idx ) {\n+            final Contig tig = pathContigs.get(idx);\n+            if ( tig == null || !prev.getSuccessors().contains(tig) ) break;\n+            result.add(tig);\n+            prev = tig;\n+        }\n+        return result;\n+    }\n+\n+    private static void resolveResult( final List<Contig> result,\n+                                       final List<List<Contig>> results ) {\n+        final int nResults = results.size();\n+        for ( int idx = 0; idx != nResults; ++idx ) {\n+            final List<Contig> test = results.get(idx);\n+            if ( isPrefix(result, test) ) return;\n+            if ( isPrefix(test, result) ) {\n+                results.set(idx, result);\n+                return;\n+            }\n+        }\n+        results.add(result);\n+    }\n+\n+    private static boolean isPrefix( final List<Contig> list1, final List<Contig> list2 ) {\n+        final int list1Size = list1.size();\n+        final int list2Size = list2.size();\n+        if ( list1Size > list2Size ) return false;\n+        for ( int idx = 0; idx != list1Size; ++idx ) {\n+            if ( list1.get(idx) != list2.get(idx) ) return false;\n+        }\n+        return true;\n+    }\n+\n+    @VisibleForTesting\n+    static Collection<Traversal> createScaffolds( final List<Traversal> allTraversals ) {\n+        removeTriviallyDifferentTraversals(allTraversals);\n+\n+        final int nTraversals = allTraversals.size();\n+        final Map<Contig, List<Integer>> traversalsByFirstContig = new HashMap<>(3 * nTraversals);\n+        for ( int idx = 0; idx != nTraversals; ++idx ) {\n+            final Traversal traversal = allTraversals.get(idx);\n+            traversalsByFirstContig.compute(traversal.getFirstContig(),\n+                    ( k, v ) -> v == null ? new ArrayList<>(3) : v).add(idx);\n+            final Traversal rcTraversal = traversal.rc();\n+            traversalsByFirstContig.compute(rcTraversal.getFirstContig(),\n+                    ( k, v ) -> v == null ? new ArrayList<>(3) : v).add(~idx);\n+        }\n+\n+        final List<Traversal> scaffolds = new ArrayList<>(nTraversals);\n+        final boolean[] touched = new boolean[nTraversals];\n+        for ( int idx = 0; idx != nTraversals; ++idx ) {\n+            if ( !touched[idx] ) {\n+                expandTraversal(idx, touched, traversalsByFirstContig, allTraversals, scaffolds);\n+            }\n+        }\n+        return scaffolds;\n+    }\n+\n+    private static void expandTraversal( final int traversalIdx,\n+                                         final boolean[] touched,\n+                                         final Map<Contig, List<Integer>> traversalsByFirstContig,\n+                                         final List<Traversal> allTraversals,\n+                                         final List<Traversal> scaffolds ) {\n+        final Traversal traversal = allTraversals.get(traversalIdx);\n+        touched[traversalIdx] = true;\n+        final List<Traversal> downExtensions = new ArrayList<>();\n+        final Set<Contig> startingContigSet = new HashSet<>();\n+        walkTraversals(traversal, touched, startingContigSet, traversalsByFirstContig,\n+                        allTraversals, downExtensions);\n+        final List<Traversal> upExtensions = new ArrayList<>();\n+        walkTraversals(traversal.rc(), touched, startingContigSet, traversalsByFirstContig,\n+                        allTraversals, upExtensions);\n+        for ( final Traversal down : downExtensions ) {\n+            for ( final Traversal up : upExtensions ) {\n+                if ( scaffolds.size() >= TOO_MANY_SCAFFOLDS ) {\n+                    throw new AssemblyTooComplexException();\n+                }\n+                scaffolds.add(Traversal.combineOverlappers(up.rc(), down, traversal.getContigs().size()));\n+            }\n+        }\n+    }\n+\n+    private static void walkTraversals( final Traversal traversal,\n+                                        final boolean[] touched,\n+                                        final Set<Contig> startingContigSet,\n+                                        final Map<Contig, List<Integer>> traversalsByFirstContig,\n+                                        final List<Traversal> allTraversals,\n+                                        final List<Traversal> extensions ) {\n+        final Contig firstContig = traversal.getFirstContig();\n+        final List<Integer> indexList;\n+        if ( startingContigSet.contains(firstContig) ||\n+                traversal.isInextensible() ||\n+                (indexList = traversalsByFirstContig.get(traversal.getLastContig())) == null ) {\n+            extensions.add(traversal);\n+            return;\n+        }\n+        startingContigSet.add(firstContig);\n+        for ( int idx : indexList ) {\n+            final Traversal extension;\n+            if ( idx >= 0 ) {\n+                extension = allTraversals.get(idx);\n+                touched[idx] = true;\n+            } else {\n+                final int rcIdx = ~idx;\n+                extension = allTraversals.get(rcIdx).rc();\n+                touched[rcIdx] = true;\n+            }\n+            walkTraversals(Traversal.combine(traversal, extension), touched, startingContigSet,\n+                            traversalsByFirstContig, allTraversals, extensions );\n+        }\n+        startingContigSet.remove(firstContig);\n+    }\n+\n+    private static void removeTriviallyDifferentTraversals(\n+                                            final Collection<Traversal> allTraversals ) {\n+        if ( allTraversals.isEmpty() ) {\n+            return;\n+        }\n+        final TreeSet<Traversal> sortedTraversals = new TreeSet<>(new TraversalEndpointComparator());\n+        for ( final Traversal traversal : allTraversals ) {\n+            sortedTraversals.add(traversal);\n+            sortedTraversals.add(traversal.rc());\n+        }\n+        final Iterator<Traversal> traversalIterator = sortedTraversals.iterator();\n+        Traversal prevTraversal = traversalIterator.next();\n+        while ( traversalIterator.hasNext() ) {\n+            final Traversal curTraversal = traversalIterator.next();\n+            if ( isTriviallyDifferent(prevTraversal, curTraversal) ) {\n+                traversalIterator.remove();\n+            } else {\n+                prevTraversal = curTraversal;\n+            }\n+        }\n+        sortedTraversals.removeIf(Traversal::isRC);\n+        allTraversals.clear();\n+        allTraversals.addAll(sortedTraversals);\n+    }\n+\n+    private static boolean isTriviallyDifferent( final Traversal traversal1,\n+                                                 final Traversal traversal2 ) {\n+        final Contig firstContig1 = traversal1.getFirstContig();\n+        final Contig lastContig1 = traversal1.getLastContig();\n+        final Contig firstContig2 = traversal2.getFirstContig();\n+        final Contig lastContig2 = traversal2.getLastContig();\n+        if ( firstContig1 != firstContig2 || lastContig1 != lastContig2 ) {\n+            return false;\n+        }\n+        final int interiorSize1 = traversal1.getSequenceLength() - firstContig1.size() - lastContig1.size();\n+        final int interiorSize2 = traversal2.getSequenceLength() - firstContig2.size() - lastContig2.size();\n+\n+        // if the path lengths are so different that one could harbor an SV, they're not trivially different\n+        if ( Math.abs(interiorSize1 - interiorSize2) >= MIN_SV_SIZE ) {\n+            return false;\n+        }\n+\n+        // if the paths are small enough that there can't be an SV's worth of differences, they're trivially different\n+        final int maxInteriorSize = Math.max(interiorSize1, interiorSize2);\n+        if ( maxInteriorSize < MIN_SV_SIZE ) {\n+            return true;\n+        }\n+\n+        // dang, maybe there's enough material in common that there can't be an SV's worth of differences\n+        // run a longest common subsequence algorithm to figure out the length of the common material\n+        // DP matrix holds length of common material\n+        final List<Contig> contigs1 = traversal1.getContigs();\n+        final int rowLen = contigs1.size() - 1;\n+        final int[][] rowPair = new int[2][];\n+        rowPair[0] = new int[rowLen];\n+        rowPair[1] = new int[rowLen];\n+        int pairIdx = 0;\n+        final List<Contig> contigs2 = traversal2.getContigs();\n+        final int nRows = contigs2.size() - 1;\n+        for ( int idx2 = 1; idx2 != nRows; ++idx2 ) {\n+            final int[] curRow = rowPair[pairIdx];\n+            final int[] prevRow = rowPair[pairIdx ^ 1];\n+            pairIdx ^= 1;\n+\n+            final int id2 = contigs2.get(idx2).getId();\n+            for ( int idx1 = 1; idx1 != rowLen; ++idx1 ) {\n+                final Contig tig1 = contigs1.get(idx1);\n+                if ( tig1.getId() == id2 ) {\n+                    // if the previous cells also contain a match we've already removed the K-1 bases upstream\n+                    final boolean extendMatch =\n+                            contigs1.get(idx1 -1).getId() == contigs2.get(idx2 - 1).getId();\n+                    curRow[idx1] = prevRow[idx1 - 1] + (extendMatch ? tig1.getNKmers() : tig1.size());\n+                } else {\n+                    curRow[idx1] = Math.max(curRow[idx1 - 1], prevRow[idx1]);\n+                }\n+            }\n+        }\n+        final int commonLen = rowPair[pairIdx ^ 1][rowLen - 1];\n+        return (maxInteriorSize - commonLen) < MIN_SV_SIZE;\n+    }\n+\n+    private static class TraversalEndpointComparator implements Comparator<Traversal> {\n+        @Override\n+        public int compare( final Traversal traversal1, final Traversal traversal2 ) {\n+            int cmp = Integer.compare(traversal1.contigs.get(0).getId(),\n+                                      traversal2.contigs.get(0).getId());\n+            if ( cmp != 0 ) {\n+                return cmp;\n+            }\n+            final int last1 = traversal1.contigs.size() - 1;\n+            final int last2 = traversal2.contigs.size() - 1;\n+            cmp = Integer.compare(traversal1.contigs.get(last1).getId(),\n+                                  traversal2.contigs.get(last2).getId());\n+            if ( cmp != 0 ) {\n+                return cmp;\n+            }\n+            // among those starting and ending at the same place, sort least observed last\n+            return -Integer.compare(traversal1.getMinMaxObservations(), traversal2.getMinMaxObservations());\n+        }\n+    }\n+\n+    private static void writeDOT( final List<ContigImpl> contigs, final String fileName ) {\n+        try ( final BufferedWriter writer = new BufferedWriter(new FileWriter(fileName)) ) {\n+            writer.write(\"digraph {\\n\");\n+            for ( final Contig contig : contigs ) {\n+                final double width = contig.getSequence().length() / 100.;\n+                writer.write(contig + \" [width=\" + width + \"]\\n\");\n+                writer.write( contig.rc() + \" [width=\" + width + \"]\\n\");\n+            }\n+            for ( final Contig contig : contigs ) {\n+                for ( final Contig predecessor : contig.getPredecessors() ) {\n+                    final String predecessorName = predecessor.rc().toString();\n+                    writer.write(contig.rc() + \" -> \" + predecessorName + \"\\n\");\n+                }\n+                for ( final Contig successor : contig.getSuccessors() ) {\n+                    final String successorName = successor.toString();\n+                    writer.write(contig + \" -> \" + successorName + \"\\n\");\n+                }\n+            }\n+            writer.write(\"}\\n\");\n+        } catch ( final IOException ioe ) {\n+            throw new GATKException(\"Failed to write assembly DOT file.\", ioe);\n+        }\n+    }\n+\n+    private static BufferedWriter makeGZFile( final String fileName ) throws IOException {\n+        final GZIPOutputStream gzOS = new GZIPOutputStream(BucketUtils.createFile(fileName));\n+        return new BufferedWriter(new OutputStreamWriter(gzOS));\n+    }\n+\n+    private static void writeContigs( final List<ContigImpl> contigs, final String fileName ) {\n+        try ( final BufferedWriter writer = makeGZFile(fileName) ) {\n+            for ( final Contig contig : contigs ) {\n+                final List<Contig> predecessors = contig.getPredecessors();\n+                final String predecessorDescription;\n+                if ( predecessors.size() == 0 ) {\n+                    predecessorDescription = \"\\tnone\";\n+                } else {\n+                    final StringBuilder sb = new StringBuilder();\n+                    char prefix = '\\t';\n+                    for ( final Contig predecessor : predecessors ) {\n+                        sb.append(prefix);\n+                        prefix = ',';\n+                        sb.append(predecessor);\n+                    }\n+                    predecessorDescription = sb.toString();\n+                }\n+\n+                final List<Contig> successors = contig.getSuccessors();\n+                final String successorDescription;\n+                if ( successors.size() == 0 ) {\n+                    successorDescription = \"\\tnone\";\n+                } else {\n+                    final StringBuilder sb = new StringBuilder();\n+                    char prefix = '\\t';\n+                    for ( final Contig successor : successors ) {\n+                        sb.append(prefix);\n+                        prefix = ',';\n+                        sb.append(successor);\n+                    }\n+                    successorDescription = sb.toString();\n+                }\n+\n+                final String contigName = contig.toString();\n+                final String component =\n+                        (contig.isCyclic() ? \"(C)\\t\" : \"\\t\") + contig.getComponentId();\n+                writer.write(contigName + component + predecessorDescription +\n+                        successorDescription + \"\\t\" +\n+                        contig.getMaxObservations() + \"\\t\" +\n+                        contig.getFirstKmer().getNObservations() + \"\\t\" +\n+                        contig.getLastKmer().getNObservations() + \"\\t\" +\n+                        contig.size() + \"\\t\" +\n+                        contig.getSequence() + \"\\n\");\n+            }\n+        } catch ( final IOException ioe ) {\n+            throw new GATKException(\"Failed to write contigs file.\", ioe);\n+        }\n+    }\n+\n+    private static void writePaths( final List<Path> readPaths, final String fileName ) {\n+        try ( final BufferedWriter writer = makeGZFile(fileName) ) {\n+            final int nReads = readPaths.size();\n+            for ( int readId = 0; readId != nReads; ++readId ) {\n+                final Path path = readPaths.get(readId);\n+                final String pathDesc = path.toString();\n+                writer.write((readId + 1) + \": \" + pathDesc + \"\\n\");\n+            }\n+        } catch ( final IOException ioe ) {\n+            throw new GATKException(\"Failed to write paths file.\", ioe);\n+        }\n+    }\n+\n+    private static void writeReads( final List<GATKRead> reads, final String fileName ) {\n+        try ( final BufferedWriter writer = makeGZFile(fileName) ) {\n+            for ( final GATKRead read : reads ) {\n+                writer.write(\"@\" + read.getName());\n+                writer.write('\\n');\n+                writer.write(new String(read.getBasesNoCopy()));\n+                writer.write(\"\\n+\\n\");\n+                final byte[] quals = read.getBaseQualitiesNoCopy();\n+                final int nQuals = quals.length;\n+                final byte[] fastqQuals = new byte[nQuals];\n+                for ( int idx = 0; idx != nQuals; ++idx ) {\n+                    fastqQuals[idx] = (byte)SAMUtils.phredToFastq(quals[idx]);\n+                }\n+                writer.write(new String(fastqQuals));\n+                writer.write('\\n');\n+            }\n+        } catch ( final IOException ioe ) {\n+            throw new GATKException(\"Failed to write assembly sam file.\", ioe);\n+        }\n+    }\n+\n+    private static void writeTraversals( final Collection<Traversal> traversals,\n+                                         final String fileName ) {\n+        try ( final BufferedWriter writer = makeGZFile(fileName) ) {\n+            int traversalNo = 0;\n+            for ( final Traversal traversal : traversals ) {\n+                writer.write(\">\");\n+                if ( assemblyName != null ) {\n+                    writer.write(assemblyName);\n+                    writer.write(\"_\");\n+                }\n+                writer.write(\"t\");\n+                writer.write(Integer.toString(++traversalNo));\n+                writer.write(\" \");\n+                writer.write(traversal.getName());\n+                writer.newLine();\n+                writer.write(traversal.getSequence());\n+                writer.newLine();\n+            }\n+        } catch ( final IOException ioe ) {\n+            throw new GATKException(\"Failed to write assembly sam file.\", ioe);\n+        }\n+    }\n+\n+    /** fixed-size, immutable kmer.  usual 2-bit encoding: ACGT->0123.  low order bits are final call. **/\n+    public static class Kmer {\n+        public static final int KSIZE = 31; // must be odd number less than 32", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5NzkyMzcwOA=="}, "originalCommit": {"oid": "e2201c1ef4f8ba71f17e169f07756cfe2f1ecb49"}, "originalPosition": 1248}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzc3NjgyODM0OnYy", "diffSide": "RIGHT", "path": "src/main/java/org/broadinstitute/hellbender/tools/LocalAssembler.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMy0xOVQxOToyODo0NlrOI6OjiA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMy0yNVQxOToyMDo1NVrOI95kSQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5NzkyNjc5Mg==", "bodyText": "Is there a reason you chose 25 for this? Q25 leaves us with very high quality bases, but I'm wondering if what we lose in graph construction would make up for it? Did you experiment with this at all?", "url": "https://github.com/broadinstitute/gatk/pull/6989#discussion_r597926792", "createdAt": "2021-03-19T19:28:46Z", "author": {"login": "cwhelan"}, "path": "src/main/java/org/broadinstitute/hellbender/tools/LocalAssembler.java", "diffHunk": "@@ -0,0 +1,2306 @@\n+package org.broadinstitute.hellbender.tools;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import htsjdk.samtools.Cigar;\n+import htsjdk.samtools.CigarElement;\n+import htsjdk.samtools.CigarOperator;\n+import htsjdk.samtools.SAMUtils;\n+import org.broadinstitute.barclay.argparser.Argument;\n+import org.broadinstitute.barclay.argparser.BetaFeature;\n+import org.broadinstitute.barclay.argparser.CommandLineProgramProperties;\n+import org.broadinstitute.barclay.help.DocumentedFeature;\n+import org.broadinstitute.hellbender.cmdline.StandardArgumentDefinitions;\n+import org.broadinstitute.hellbender.cmdline.programgroups.CoverageAnalysisProgramGroup;\n+import org.broadinstitute.hellbender.exceptions.GATKException;\n+import org.broadinstitute.hellbender.tools.walkers.PairWalker;\n+import org.broadinstitute.hellbender.utils.SimpleInterval;\n+import org.broadinstitute.hellbender.utils.collections.HopscotchSet;\n+import org.broadinstitute.hellbender.utils.gcs.BucketUtils;\n+import org.broadinstitute.hellbender.utils.read.GATKRead;\n+\n+import java.io.BufferedWriter;\n+import java.io.FileWriter;\n+import java.io.IOException;\n+import java.io.OutputStreamWriter;\n+import java.util.*;\n+import java.util.zip.GZIPOutputStream;\n+\n+@DocumentedFeature\n+@CommandLineProgramProperties(\n+        summary = \"experiment\",\n+        oneLineSummary = \"experiment\",\n+        usageExample = \"gatk LocalAssembler\",\n+        programGroup = CoverageAnalysisProgramGroup.class\n+)\n+@BetaFeature\n+public class LocalAssembler extends PairWalker {\n+    public static final byte QMIN = 25;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e2201c1ef4f8ba71f17e169f07756cfe2f1ecb49"}, "originalPosition": 37}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMTc3NzIyNQ==", "bodyText": "I did fiddle a bit.  The quality score bins are now so sparse in order to improve compression and save space that we'd have to lower QMIN to 20 to make any difference, and that's just too low.  We're walking a narrow path between building a furry graph that we fail to clean up adequately, and building a poorly connected graph that we fail to gap-fill adequately.\nI have reasonable confidence that this is the right number.", "url": "https://github.com/broadinstitute/gatk/pull/6989#discussion_r601777225", "createdAt": "2021-03-25T19:20:55Z", "author": {"login": "tedsharpe"}, "path": "src/main/java/org/broadinstitute/hellbender/tools/LocalAssembler.java", "diffHunk": "@@ -0,0 +1,2306 @@\n+package org.broadinstitute.hellbender.tools;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import htsjdk.samtools.Cigar;\n+import htsjdk.samtools.CigarElement;\n+import htsjdk.samtools.CigarOperator;\n+import htsjdk.samtools.SAMUtils;\n+import org.broadinstitute.barclay.argparser.Argument;\n+import org.broadinstitute.barclay.argparser.BetaFeature;\n+import org.broadinstitute.barclay.argparser.CommandLineProgramProperties;\n+import org.broadinstitute.barclay.help.DocumentedFeature;\n+import org.broadinstitute.hellbender.cmdline.StandardArgumentDefinitions;\n+import org.broadinstitute.hellbender.cmdline.programgroups.CoverageAnalysisProgramGroup;\n+import org.broadinstitute.hellbender.exceptions.GATKException;\n+import org.broadinstitute.hellbender.tools.walkers.PairWalker;\n+import org.broadinstitute.hellbender.utils.SimpleInterval;\n+import org.broadinstitute.hellbender.utils.collections.HopscotchSet;\n+import org.broadinstitute.hellbender.utils.gcs.BucketUtils;\n+import org.broadinstitute.hellbender.utils.read.GATKRead;\n+\n+import java.io.BufferedWriter;\n+import java.io.FileWriter;\n+import java.io.IOException;\n+import java.io.OutputStreamWriter;\n+import java.util.*;\n+import java.util.zip.GZIPOutputStream;\n+\n+@DocumentedFeature\n+@CommandLineProgramProperties(\n+        summary = \"experiment\",\n+        oneLineSummary = \"experiment\",\n+        usageExample = \"gatk LocalAssembler\",\n+        programGroup = CoverageAnalysisProgramGroup.class\n+)\n+@BetaFeature\n+public class LocalAssembler extends PairWalker {\n+    public static final byte QMIN = 25;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5NzkyNjc5Mg=="}, "originalCommit": {"oid": "e2201c1ef4f8ba71f17e169f07756cfe2f1ecb49"}, "originalPosition": 37}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzc3NjkzMjg1OnYy", "diffSide": "RIGHT", "path": "src/main/java/org/broadinstitute/hellbender/tools/LocalAssembler.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMy0xOVQyMDowMDowMlrOI6PiZg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMy0xOVQyMDowMDowMlrOI6PiZg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5Nzk0Mjg4Ng==", "bodyText": "The first and third clauses of this if statement look identical. Maybe combine them by changing this to\ncurrentPathPart == null || ! currentPathPart.isGap()", "url": "https://github.com/broadinstitute/gatk/pull/6989#discussion_r597942886", "createdAt": "2021-03-19T20:00:02Z", "author": {"login": "cwhelan"}, "path": "src/main/java/org/broadinstitute/hellbender/tools/LocalAssembler.java", "diffHunk": "@@ -0,0 +1,2306 @@\n+package org.broadinstitute.hellbender.tools;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import htsjdk.samtools.Cigar;\n+import htsjdk.samtools.CigarElement;\n+import htsjdk.samtools.CigarOperator;\n+import htsjdk.samtools.SAMUtils;\n+import org.broadinstitute.barclay.argparser.Argument;\n+import org.broadinstitute.barclay.argparser.BetaFeature;\n+import org.broadinstitute.barclay.argparser.CommandLineProgramProperties;\n+import org.broadinstitute.barclay.help.DocumentedFeature;\n+import org.broadinstitute.hellbender.cmdline.StandardArgumentDefinitions;\n+import org.broadinstitute.hellbender.cmdline.programgroups.CoverageAnalysisProgramGroup;\n+import org.broadinstitute.hellbender.exceptions.GATKException;\n+import org.broadinstitute.hellbender.tools.walkers.PairWalker;\n+import org.broadinstitute.hellbender.utils.SimpleInterval;\n+import org.broadinstitute.hellbender.utils.collections.HopscotchSet;\n+import org.broadinstitute.hellbender.utils.gcs.BucketUtils;\n+import org.broadinstitute.hellbender.utils.read.GATKRead;\n+\n+import java.io.BufferedWriter;\n+import java.io.FileWriter;\n+import java.io.IOException;\n+import java.io.OutputStreamWriter;\n+import java.util.*;\n+import java.util.zip.GZIPOutputStream;\n+\n+@DocumentedFeature\n+@CommandLineProgramProperties(\n+        summary = \"experiment\",\n+        oneLineSummary = \"experiment\",\n+        usageExample = \"gatk LocalAssembler\",\n+        programGroup = CoverageAnalysisProgramGroup.class\n+)\n+@BetaFeature\n+public class LocalAssembler extends PairWalker {\n+    public static final byte QMIN = 25;\n+    public static final int MIN_THIN_OBS = 4;\n+    public static final int MIN_GAPFILL_COUNT = 3;\n+    public static final int TOO_MANY_TRAVERSALS = 100000;\n+    public static final int TOO_MANY_SCAFFOLDS = 50000;\n+    public static final int MIN_SV_SIZE = 50;\n+\n+    @Argument(fullName=StandardArgumentDefinitions.OUTPUT_LONG_NAME,\n+            shortName=StandardArgumentDefinitions.OUTPUT_SHORT_NAME,\n+            doc=\"Write outputs to this file name prefix\", optional = true)\n+    public static String output;\n+\n+    @Argument(fullName=\"assembly-name\", doc=\"name of assembly used as a prefix for traversal names\")\n+    public static String assemblyName;\n+\n+    private final List<GATKRead> reads = new ArrayList<>();\n+\n+    @Override public boolean requiresIntervals() { return true; }\n+\n+    @Override public void apply( final GATKRead read, final GATKRead mate ) {\n+        trimOverruns(read, mate);\n+        reads.add(read);\n+        reads.add(mate);\n+    }\n+\n+    @Override public void applyUnpaired( final GATKRead read ) {\n+        reads.add(read);\n+    }\n+\n+    @Override public Object onTraversalSuccess() {\n+        super.onTraversalSuccess(); // flush any incomplete pairs\n+\n+        final int regionSize = getTraversalIntervals().stream().mapToInt(SimpleInterval::size).sum();\n+        final KmerSet<KmerAdjacency> kmerAdjacencySet = new KmerSet<>(10 * regionSize);\n+        kmerizeReads(reads, kmerAdjacencySet);\n+        List<ContigImpl> contigs = buildContigs(kmerAdjacencySet);\n+        connectContigs(contigs);\n+\n+        removeThinContigs(contigs, kmerAdjacencySet);\n+        weldPipes(contigs);\n+        markComponents(contigs);\n+\n+        if ( fillGaps(kmerAdjacencySet, reads) ) {\n+            contigs = buildContigs(kmerAdjacencySet);\n+            connectContigs(contigs);\n+            removeThinContigs(contigs, kmerAdjacencySet);\n+            weldPipes(contigs);\n+            markComponents(contigs);\n+        }\n+\n+        markCycles(contigs);\n+\n+        final String outputFilePrefix = output != null ? output : assemblyName;\n+        final List<Path> readPaths = pathReads(kmerAdjacencySet, reads);\n+        final Map<Contig,List<TransitPairCount>> contigTransitsMap =\n+                collectTransitPairCounts(contigs, readPaths);\n+        final String traversalsFilename = outputFilePrefix + \".traversals.fa.gz\";\n+        try {\n+            final List<Traversal> allTraversals =\n+                    new ArrayList<>(traverseAllPaths(contigs, readPaths, contigTransitsMap));\n+            writeTraversals(allTraversals, traversalsFilename);\n+            try {\n+                final String scaffoldsFileName = outputFilePrefix + \".scaffolds.fa.gz\";\n+                writeTraversals(createScaffolds(allTraversals), scaffoldsFileName);\n+            } catch ( final AssemblyTooComplexException x ) {\n+                logger.warn(\"Assembly too complex for scaffolding.\");\n+            }\n+        } catch ( final AssemblyTooComplexException x ) {\n+            logger.warn(\"Assembly too complex.  Writing contigs as traversals in \" +\n+                    traversalsFilename + \".\");\n+            final Collection<Traversal> contigTraversals = new ArrayList<>(contigs.size());\n+            for ( final Contig contig : contigs ) {\n+                contigTraversals.add(new Traversal(Collections.singletonList(contig)));\n+            }\n+            writeTraversals(contigTraversals, traversalsFilename);\n+        }\n+\n+        contigs.sort(Comparator.comparingInt(ContigImpl::getId));\n+        writeDOT(contigs, outputFilePrefix + \".assembly.dot\");\n+        writeContigs(contigs, outputFilePrefix + \".contigs.txt.gz\");\n+        writePaths(readPaths, outputFilePrefix + \".paths.txt.gz\");\n+        writeReads(reads, outputFilePrefix + \".reads.fastq.gz\");\n+        return null;\n+    }\n+\n+    /** trim read pairs of base calls that have gone past the end of a short fragment */\n+    private void trimOverruns( final GATKRead read, final GATKRead mate ) {\n+        // if both mapped and they're on different strands\n+        if ( !read.isUnmapped() && !mate.isUnmapped() &&\n+                read.isReverseStrand() != mate.isReverseStrand() ) {\n+            // and both start within 1 base on the ref\n+            if ( Math.abs(read.getStart() - read.getMateStart()) <= 1 ) {\n+                // and both end within 1 base\n+                final int readRefLen = read.getCigar().getReferenceLength();\n+                final int mateRefLen = mate.getCigar().getReferenceLength();\n+                if ( Math.abs(readRefLen - mateRefLen) <= 1 ) {\n+                    if ( mate.isReverseStrand() ) {\n+                        trimClips(read, mate);\n+                    } else {\n+                        trimClips(mate, read);\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    private void trimClips( final GATKRead fwd, final GATKRead rev ) {\n+        final List<CigarElement> fwdElements = fwd.getCigarElements();\n+        final List<CigarElement> revElements = rev.getCigarElements();\n+        final int lastElementIdx = fwdElements.size() - 1;\n+        final CigarElement fwdLastElement = fwdElements.get(lastElementIdx);\n+        final CigarElement revFirstElement = revElements.get(0);\n+        if ( fwdLastElement.getOperator() == CigarOperator.S &&\n+                revFirstElement.getOperator() == CigarOperator.S ) {\n+            final byte[] fwdBases = fwd.getBasesNoCopy();\n+            final int lastElementLen = fwdLastElement.getLength();\n+            fwd.setBases(Arrays.copyOfRange(fwdBases, 0, fwdBases.length - lastElementLen));\n+            final byte[] fwdQuals = fwd.getBaseQualitiesNoCopy();\n+            if ( fwdQuals.length > 0 ) {\n+                final int qualsLen = fwdQuals.length - lastElementLen;\n+                fwd.setBaseQualities(Arrays.copyOfRange(fwdQuals, 0, qualsLen));\n+            }\n+            final List<CigarElement> newFwdElements = new ArrayList<>(fwdElements);\n+            newFwdElements.set(lastElementIdx, new CigarElement(lastElementLen, CigarOperator.H));\n+            fwd.setCigar(new Cigar(newFwdElements));\n+\n+            final byte[] revBases = rev.getBasesNoCopy();\n+            final int firstElementLen = revFirstElement.getLength();\n+            rev.setBases(Arrays.copyOfRange(revBases, firstElementLen, revBases.length));\n+            final byte[] revQuals = rev.getBaseQualitiesNoCopy();\n+            if ( revQuals.length > 0 ) {\n+                rev.setBaseQualities(Arrays.copyOfRange(revQuals, firstElementLen, revQuals.length));\n+            }\n+            final List<CigarElement> newRevElements = new ArrayList<>(revElements);\n+            newRevElements.set(0, new CigarElement(firstElementLen, CigarOperator.H));\n+            rev.setCigar(new Cigar(newRevElements));\n+        }\n+    }\n+\n+    @VisibleForTesting\n+    static void kmerizeReads( final List<GATKRead> reads,\n+                              final KmerSet<KmerAdjacency> kmerAdjacencySet ) {\n+        for ( final GATKRead read : reads ) {\n+            final byte[] calls = read.getBasesNoCopy();\n+            final byte[] quals = read.getBaseQualitiesNoCopy();\n+            KmerAdjacency.kmerize(calls, quals, QMIN, kmerAdjacencySet);\n+        }\n+    }\n+\n+    /** gather unbranched strings of kmers into contigs **/\n+    @VisibleForTesting\n+    static List<ContigImpl> buildContigs( final KmerSet<KmerAdjacency> kmerAdjacencySet ) {\n+        // gather strings of kmers that have a single predecessor and single successor into contigs\n+        final List<ContigImpl> contigs = new ArrayList<>();\n+        int nContigs = 0;\n+        for ( final KmerAdjacency kmerAdjacency : kmerAdjacencySet ) {\n+            if ( kmerAdjacency.getContig() == null ) {\n+                ContigImpl contig = null;\n+                final KmerAdjacency predecessor = kmerAdjacency.getSolePredecessor();\n+                if ( predecessor == null ||\n+                        predecessor.getSuccessorCount() > 1 ||\n+                        predecessor == kmerAdjacency.rc() ) {\n+                    contig = new ContigImpl(++nContigs, kmerAdjacency);\n+                } else {\n+                    final KmerAdjacency successor = kmerAdjacency.getSoleSuccessor();\n+                    if ( successor == null ||\n+                            successor.getPredecessorCount() > 1 ||\n+                            successor == kmerAdjacency.rc() ) {\n+                        contig = new ContigImpl(++nContigs, kmerAdjacency.rc());\n+                    }\n+                }\n+                if ( contig != null ) {\n+                    contigs.add(contig);\n+                }\n+            }\n+        }\n+\n+        // if there are smooth circles like a plasmid, gather them together as a contig, too\n+        for ( final KmerAdjacency kmerAdjacency : kmerAdjacencySet ) {\n+            if ( kmerAdjacency.getContig() == null ) {\n+                contigs.add(new ContigImpl(++nContigs, kmerAdjacency));\n+            }\n+        }\n+\n+        return contigs;\n+    }\n+\n+    /** connect contigs when the final kmer of one contig is adjacent to the inital contig of another **/\n+    @VisibleForTesting\n+    static void connectContigs( final List<ContigImpl> contigs ) {\n+        final int nContigs = contigs.size();\n+        final KmerSet<ContigEndKmer> contigEnds = new KmerSet<>(2*nContigs);\n+        for ( int contigId = 0; contigId != nContigs; ++contigId ) {\n+            final ContigImpl contig = contigs.get(contigId);\n+            final KmerAdjacency fwdKmer = contig.getFirstKmer();\n+            final KmerAdjacency revKmer = contig.getLastKmer().rc();\n+            if ( fwdKmer == revKmer ) {\n+                contigEnds.add(new ContigEndKmer(fwdKmer.getKVal(), contig, ContigOrientation.BOTH));\n+            } else {\n+                contigEnds.add(new ContigEndKmer(fwdKmer.getKVal(), contig, ContigOrientation.FWD));\n+                contigEnds.add(new ContigEndKmer(revKmer.getKVal(), contig, ContigOrientation.REV));\n+            }\n+        }\n+\n+        for ( int contigId = 0; contigId != nContigs; ++contigId ) {\n+            final Contig contig = contigs.get(contigId);\n+\n+            final KmerAdjacency start = contig.getFirstKmer();\n+            final int predecessorCount = start.getPredecessorCount();\n+            if ( predecessorCount > 0 ) {\n+                final List<Contig> predecessors = contig.getPredecessors();\n+                final int mask = start.getPredecessorMask();\n+                for ( int call = 0; call != 4; ++call ) {\n+                    if ( (mask & (1 << call)) != 0 ) {\n+                        final long kVal =\n+                                KmerAdjacency.reverseComplement(start.getPredecessorVal(call));\n+                        final ContigEndKmer contigEndKmer = contigEnds.find(new Kmer(kVal));\n+                        if ( contigEndKmer == null ) {\n+                            throw new GATKException(\"missing contig end kmer\");\n+                        }\n+                        switch ( contigEndKmer.getContigOrientation() ) {\n+                            case FWD:\n+                                predecessors.add(contigEndKmer.getContig().rc());\n+                                break;\n+                            case REV:\n+                                predecessors.add(contigEndKmer.getContig());\n+                                break;\n+                            case BOTH:\n+                                predecessors.add(contigEndKmer.getContig());\n+                                predecessors.add(contigEndKmer.getContig().rc());\n+                                break;\n+                        }\n+                    }\n+                }\n+            }\n+\n+            final KmerAdjacency end = contig.getLastKmer();\n+            final int successorCount = end.getSuccessorCount();\n+            if ( successorCount > 0 ) {\n+                final List<Contig> successors = contig.getSuccessors();\n+                final int mask = end.getSuccessorMask();\n+                for ( int call = 0; call != 4; ++call ) {\n+                    if ( (mask & (1 << call)) != 0 ) {\n+                        final long kVal = end.getSuccessorVal(call);\n+                        final ContigEndKmer contigEndKmer = contigEnds.find(new Kmer(kVal));\n+                        if ( contigEndKmer == null ) {\n+                            throw new GATKException(\"missing contig end kmer\");\n+                        }\n+                        switch ( contigEndKmer.getContigOrientation() ) {\n+                            case FWD:\n+                                successors.add(contigEndKmer.getContig());\n+                                break;\n+                            case REV:\n+                                successors.add(contigEndKmer.getContig().rc());\n+                                break;\n+                            case BOTH:\n+                                successors.add(contigEndKmer.getContig());\n+                                successors.add(contigEndKmer.getContig().rc());\n+                                break;\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    /** remove contigs that have little evidence **/\n+    @VisibleForTesting\n+    static void removeThinContigs( final List<ContigImpl> contigs,\n+                                           final KmerSet<KmerAdjacency> kmerAdjacencySet ) {\n+        contigs.sort(Comparator.comparingInt(ContigImpl::getMaxObservations));\n+        boolean contigRemoved;\n+        do {\n+            // figure out which contigs are cut points\n+            // i.e., those contigs which, if removed, would result in a graph with more connected components\n+            final int nContigs = contigs.size();\n+            final Map<Contig, CutData> cutDataMap = new HashMap<>(nContigs * 3);\n+\n+            for ( final ContigImpl contig : contigs ) {\n+                if ( cutDataMap.containsKey(contig) ) {\n+                    continue;\n+                }\n+\n+                cutDataMap.put(contig, new CutData());\n+                int children = 0;\n+                for ( final Contig nextContig : contig.getSuccessors() ) {\n+                    if ( !cutDataMap.containsKey(nextContig) ) {\n+                        findCuts(nextContig, contig, cutDataMap);\n+                        children += 1;\n+                    }\n+                }\n+                for ( final Contig nextContig : contig.getPredecessors() ) {\n+                    if ( !cutDataMap.containsKey(nextContig) ) {\n+                        findCuts(nextContig, contig, cutDataMap);\n+                        children += 1;\n+                    }\n+                }\n+                if ( children >= 2 ) {\n+                    contig.setCut(true);\n+                }\n+            }\n+\n+            // remove poorly attested (low max observations) contigs, unless they are cut points\n+            contigRemoved = false;\n+            final Iterator<ContigImpl> itr = contigs.iterator();\n+            while ( itr.hasNext() ) {\n+                final Contig contig = itr.next();\n+                if ( contig.getMaxObservations() < MIN_THIN_OBS && !contig.isCut() ) {\n+                    unlinkContig(contig, kmerAdjacencySet);\n+                    itr.remove();\n+                    contigRemoved = true;\n+                    break;\n+                }\n+            }\n+        } while ( contigRemoved );\n+        contigs.sort(Comparator.comparingInt(ContigImpl::getId));\n+    }\n+\n+    private static CutData findCuts( final Contig contig,\n+                                     final Contig parent,\n+                                     final Map<Contig, CutData> cutDataMap ) {\n+        final CutData cutData = new CutData();\n+        cutDataMap.put(contig, cutData);\n+        for ( final Contig nextContig : contig.getSuccessors() ) {\n+            if ( nextContig == parent ) {\n+                continue;\n+            }\n+            CutData nextCutData = cutDataMap.get(nextContig);\n+            if ( nextCutData != null ) {\n+                cutData.minVisitNum = Math.min(cutData.minVisitNum, nextCutData.visitNum);\n+            } else {\n+                nextCutData = findCuts(nextContig, contig, cutDataMap);\n+                cutData.minVisitNum = Math.min(cutData.minVisitNum, nextCutData.minVisitNum);\n+                if ( nextCutData.minVisitNum >= cutData.visitNum ) {\n+                    contig.setCut(true);\n+                }\n+            }\n+        }\n+        for ( final Contig nextContig : contig.getPredecessors() ) {\n+            if ( nextContig == parent ) {\n+                continue;\n+            }\n+            CutData nextCutData = cutDataMap.get(nextContig);\n+            if ( nextCutData != null ) {\n+                cutData.minVisitNum = Math.min(cutData.minVisitNum, nextCutData.visitNum);\n+            } else {\n+                nextCutData = findCuts(nextContig, contig, cutDataMap);\n+                cutData.minVisitNum = Math.min(cutData.minVisitNum, nextCutData.minVisitNum);\n+                if ( nextCutData.minVisitNum >= cutData.visitNum ) {\n+                    contig.setCut(true);\n+                }\n+            }\n+        }\n+        return cutData;\n+    }\n+\n+    @VisibleForTesting\n+    static void unlinkContig( final Contig contig,\n+                                      final KmerSet<KmerAdjacency> kmerAdjacencySet ) {\n+        final KmerAdjacency firstKmer = contig.getFirstKmer();\n+        final int firstKmerFinalCall = firstKmer.getFinalCall();\n+        for ( final Contig predecessor : contig.getPredecessors() ) {\n+            if ( predecessor != contig && predecessor != contig.rc() ) {\n+                predecessor.getLastKmer().removeSuccessor(firstKmerFinalCall, kmerAdjacencySet);\n+                if ( !predecessor.getSuccessors().remove(contig) ) {\n+                    throw new GATKException(\"failed to find predecessor link\");\n+                }\n+            }\n+        }\n+\n+        final KmerAdjacency lastKmer = contig.getLastKmer();\n+        final int lastKmerInitialCall = lastKmer.getInitialCall();\n+        for ( final Contig successor : contig.getSuccessors() ) {\n+            if ( successor != contig && successor != contig.rc() ) {\n+                successor.getFirstKmer().removePredecessor(lastKmerInitialCall, kmerAdjacencySet);\n+                if ( !successor.getPredecessors().remove(contig) ) {\n+                    throw new GATKException(\"failed to find successor link\");\n+                }\n+            }\n+        }\n+\n+        KmerAdjacency nextKmer = firstKmer;\n+        KmerAdjacency kmer;\n+        do {\n+            kmer = nextKmer;\n+            nextKmer = kmer.getSoleSuccessor();\n+            kmerAdjacencySet.remove(kmer.canonical());\n+        } while ( kmer != lastKmer );\n+    }\n+\n+    private static void updateKmerContig( final KmerAdjacency firstKmer,\n+                                          final KmerAdjacency lastKmer,\n+                                          final Contig contig ) {\n+        int offset = 0;\n+        for ( KmerAdjacency kmer = firstKmer; kmer != lastKmer; kmer = kmer.getSoleSuccessor() ) {\n+            if ( kmer == null ) {\n+                throw new GATKException(\"contig does not have a flat pipeline of kmers\");\n+            }\n+            kmer.clearContig();\n+            kmer.setContigOffset(contig, offset++);\n+        }\n+        lastKmer.clearContig();\n+        lastKmer.setContigOffset(contig, offset);\n+        if ( offset + Kmer.KSIZE != contig.size() ) {\n+            throw new GATKException(\"kmer chain length does not equal contig size\");\n+        }\n+    }\n+\n+    /** replace adjacent contigs without branches with a single, larger contig **/\n+    @VisibleForTesting\n+    static void weldPipes( final List<ContigImpl> contigs ) {\n+        for ( int contigIdx = 0; contigIdx != contigs.size(); ++contigIdx ) {\n+            final ContigImpl contig = contigs.get(contigIdx);\n+            if ( contig.getSuccessors().size() == 1 ) {\n+                final Contig successor = contig.getSuccessors().get(0);\n+                if ( successor != contig && successor != contig.rc() &&\n+                        successor.getPredecessors().size() == 1 ) {\n+                    contigs.set(contigIdx, join(contig.getId(), contig, successor));\n+                    if ( !contigs.remove(successor.canonical()) ) {\n+                        throw new GATKException(\"successor linkage is messed up\");\n+                    }\n+                    contigIdx -= 1; // reconsider the new contig -- there might be more joining possible\n+                    continue;\n+                }\n+            }\n+            if ( contig.getPredecessors().size() == 1 ) {\n+                final Contig predecessor = contig.getPredecessors().get(0);\n+                if ( predecessor != contig && predecessor != contig.rc() &&\n+                        predecessor.getSuccessors().size() == 1 ) {\n+                    contigs.set(contigIdx, join(contig.getId(), predecessor, contig));\n+                    if ( !contigs.remove(predecessor.canonical()) ) {\n+                        throw new GATKException(\"predecessor linkage is messed up\");\n+                    }\n+                    contigIdx -= 1; // reconsider\n+                }\n+            }\n+        }\n+    }\n+\n+    private static ContigImpl join( final int id, final Contig predecessor, final Contig successor ) {\n+        if ( !checkOverlap(predecessor.getSequence(), successor.getSequence()) ) {\n+                throw new GATKException(\"sequences can't be joined\");\n+        }\n+        final ContigImpl joinedContig = new ContigImpl(id, predecessor, successor);\n+        updateKmerContig(joinedContig.getFirstKmer(), joinedContig.getLastKmer(), joinedContig);\n+        return joinedContig;\n+    }\n+\n+    private static boolean checkOverlap( final CharSequence seq1, final CharSequence seq2 ) {\n+        final int seq1Len = seq1.length();\n+        final CharSequence seq1SubSeq = seq1.subSequence(seq1Len - Kmer.KSIZE + 1, seq1Len);\n+        final CharSequence seq2SubSeq = seq2.subSequence(0, Kmer.KSIZE - 1);\n+        return seq1SubSeq.equals(seq2SubSeq);\n+    }\n+\n+    /** set a unique componentId for every connected group of contigs **/\n+    @VisibleForTesting\n+    static int markComponents( final List<ContigImpl> contigs ) {\n+        for ( final ContigImpl contig : contigs ) {\n+            contig.setComponentId(0);\n+        }\n+\n+        int componentId = 0;\n+        for ( final ContigImpl contig : contigs ) {\n+            if ( contig.getComponentId() == 0 ) {\n+                contig.setComponentId(++componentId);\n+                markSuccessorComponents(contig);\n+                markSuccessorComponents(contig.rc());\n+            }\n+        }\n+        return componentId;\n+    }\n+\n+    private static void markSuccessorComponents( final Contig contig ) {\n+        final int componentId = contig.getComponentId();\n+        for ( final Contig successor : contig.getSuccessors() ) {\n+            if ( successor.getComponentId() == 0 ) {\n+                successor.canonical().setComponentId(componentId);\n+                markSuccessorComponents(successor);\n+                markSuccessorComponents(successor.rc());\n+            }\n+        }\n+    }\n+\n+    @VisibleForTesting\n+    static void markCycles( final List<ContigImpl> contigs ) {\n+        for ( final Contig contig : contigs ) {\n+            contig.setCyclic(false);\n+        }\n+\n+        final int nContigs = contigs.size();\n+        final Deque<Contig> deque = new ArrayDeque<>(nContigs);\n+        final Map<Contig, CutData> cutDataMap = new HashMap<>(nContigs * 3);\n+        for ( final Contig contig : contigs ) {\n+            if ( !cutDataMap.containsKey(contig) ) {\n+                markCyclesRecursion(contig, deque, cutDataMap);\n+            }\n+        }\n+    }\n+\n+    private static CutData markCyclesRecursion( final Contig contig,\n+                                                final Deque<Contig> deque,\n+                                                final Map<Contig, CutData> cutDataMap ) {\n+        final CutData cutData = new CutData();\n+        cutDataMap.put(contig, cutData);\n+        deque.addFirst(contig);\n+\n+        for ( final Contig successor : contig.getSuccessors() ) {\n+            final CutData successorCutData = cutDataMap.get(successor);\n+            if ( successorCutData == null ) {\n+                final int recursionVisitNum =\n+                        markCyclesRecursion(successor, deque, cutDataMap).minVisitNum;\n+                cutData.minVisitNum = Math.min(cutData.minVisitNum, recursionVisitNum);\n+            } else {\n+                cutData.minVisitNum = Math.min(cutData.minVisitNum, successorCutData.visitNum);\n+            }\n+        }\n+\n+        if ( cutData.visitNum == cutData.minVisitNum ) {\n+            Contig tig = deque.removeFirst();\n+            if ( tig == contig ) {\n+                cutDataMap.get(tig).visitNum = Integer.MAX_VALUE;\n+\n+                // single-vertex component -- cyclic only if self-referential\n+                if ( tig.getSuccessors().contains(tig) ) {\n+                    tig.setCyclic(true);\n+                }\n+            } else {\n+                while ( true ) {\n+                    // kill cross-links\n+                    cutDataMap.get(tig).visitNum = Integer.MAX_VALUE;\n+                    tig.setCyclic(true);\n+                    if ( tig == contig ) break;\n+                    tig = deque.removeFirst();\n+                }\n+            }\n+        }\n+        return cutData;\n+    }\n+\n+    @VisibleForTesting\n+    static boolean fillGaps( final KmerSet<KmerAdjacency> kmerAdjacencySet,\n+                             final List<GATKRead> reads ) {\n+        final Map<String, Integer> gapFillCounts = new HashMap<>();\n+        for ( final GATKRead read : reads ) {\n+            final Path path = new Path(read.getBasesNoCopy(), kmerAdjacencySet);\n+            final List<PathPart> parts = path.getParts();\n+            final int lastIdx = parts.size() - 1;\n+            for ( int idx = 1; idx < lastIdx; ++idx ) {\n+                final PathPart pathPart = parts.get(idx);\n+                if ( pathPart.isGap() ) {\n+                    final char prevCall = parts.get(idx - 1).getLastCall();\n+                    final char nextCall = parts.get(idx + 1).getFirstCall();\n+                    String gapFill = prevCall + pathPart.getSequence().toString() + nextCall;\n+                    final SequenceRC gapFillRC = new SequenceRC(gapFill);\n+                    if ( gapFillRC.compareTo(gapFill) < 0 ) {\n+                        gapFill = gapFillRC.toString();\n+                    }\n+                    gapFillCounts.merge(gapFill, 1, Integer::sum);\n+                }\n+            }\n+        }\n+\n+        boolean newKmers = false;\n+        for ( final Map.Entry<String, Integer> entry : gapFillCounts.entrySet() ) {\n+            final int nObservations = entry.getValue();\n+            if ( nObservations >= MIN_GAPFILL_COUNT ) {\n+                KmerAdjacency.kmerize(entry.getKey(), nObservations, kmerAdjacencySet);\n+                newKmers = true;\n+            }\n+        }\n+\n+        if ( newKmers ) {\n+            for ( final KmerAdjacency kmerAdjacency : kmerAdjacencySet ) {\n+                kmerAdjacency.clearContig();\n+            }\n+        }\n+        return newKmers;\n+    }\n+\n+    @VisibleForTesting\n+    static List<Path> pathReads( final KmerSet<KmerAdjacency> kmerAdjacencySet,\n+                          final List<GATKRead> reads ) {\n+        final List<Path> readPaths = new ArrayList<>(reads.size());\n+        for ( final GATKRead read : reads ) {\n+            readPaths.add(new Path(read.getBasesNoCopy(), kmerAdjacencySet));\n+        }\n+        return readPaths;\n+    }\n+\n+    @VisibleForTesting\n+    static Map<Contig,List<TransitPairCount>> collectTransitPairCounts(\n+            final List<ContigImpl> contigs,\n+            final List<Path> readPaths ) {\n+        final Map<Contig,List<TransitPairCount>> contigTransitsMap =\n+                new HashMap<>(3 * contigs.size());\n+        for ( final Path path : readPaths ) {\n+            final List<PathPart> parts = path.getParts();\n+            final int lastPart = parts.size() - 1;\n+            for ( int partIdx = 1; partIdx < lastPart; ++partIdx ) {\n+                final Contig prevContig = parts.get(partIdx - 1).getContig();\n+                if ( prevContig == null ) continue;\n+                final Contig curContig = parts.get(partIdx).getContig();\n+                if ( curContig == null ) {\n+                    partIdx += 1;\n+                    continue;\n+                }\n+                final Contig nextContig = parts.get(partIdx + 1).getContig();\n+                if ( nextContig == null ) {\n+                    partIdx += 2;\n+                    continue;\n+                }\n+                final TransitPairCount tpc = new TransitPairCount(prevContig, nextContig);\n+                final List<TransitPairCount> tpcList =\n+                        contigTransitsMap.computeIfAbsent(curContig, tig -> new ArrayList<>(4));\n+                final int idx = tpcList.indexOf(tpc);\n+                if ( idx != -1 ) {\n+                    tpcList.get(idx).observe();\n+                } else {\n+                    tpcList.add(tpc);\n+                    contigTransitsMap.computeIfAbsent(curContig.rc(), tig -> new ArrayList<>(4))\n+                            .add(tpc.getRC());\n+                }\n+            }\n+        }\n+        return contigTransitsMap;\n+    }\n+\n+    @VisibleForTesting\n+    static Set<Traversal> traverseAllPaths(\n+            final List<ContigImpl> contigs,\n+            final List<Path> readPaths,\n+            final Map<Contig, List<TransitPairCount>> contigTransitsMap ) {\n+        final Set<Traversal> traversalSet = new HashSet<>();\n+        final List<Contig> contigsList = new ArrayList<>();\n+        for ( final Contig contig : contigs ) {\n+            // untransited contigs are sources, sinks, or large contigs that can't be crossed by a read\n+            // build traversals from these\n+            if ( !contigTransitsMap.containsKey(contig) ) {\n+                boolean done = false;\n+                for ( final Contig successor : contig.getSuccessors() ) {\n+                    traverse(successor, contig,\n+                            contigsList, readPaths, contigTransitsMap, traversalSet);\n+                    done = true;\n+                }\n+                for ( final Contig predecessor : contig.getPredecessors() ) {\n+                    traverse(predecessor.rc(), contig.rc(),\n+                            contigsList, readPaths, contigTransitsMap, traversalSet);\n+                    done = true;\n+                }\n+                if ( !done ) { // if there were no predecessors or successors, it stands alone\n+                    addTraversal(new Traversal(Collections.singletonList(contig)), traversalSet);\n+                }\n+            }\n+        }\n+\n+        // look for transits that haven't been traced\n+        for ( final Map.Entry<Contig, List<TransitPairCount>> entry :\n+                contigTransitsMap.entrySet() ) {\n+            for ( final TransitPairCount tpc : entry.getValue() ) {\n+                if ( tpc.getCount() > 0 ) {\n+                    tpc.resetCount();\n+                    final Contig contig = entry.getKey();\n+                    final Set<Traversal> fwdTraversalSet = new HashSet<>();\n+                    traverse(tpc.getNextContig(), contig,\n+                            contigsList, readPaths, contigTransitsMap, fwdTraversalSet);\n+                    final Set<Traversal> revTraversalSet = new HashSet<>();\n+                    traverse(tpc.getPrevContig().rc(), contig.rc(),\n+                            contigsList, readPaths, contigTransitsMap, revTraversalSet);\n+                    for ( final Traversal revTraversal : revTraversalSet ) {\n+                        final Traversal revTraversalRC = revTraversal.rc();\n+                        for ( final Traversal fwdTraversal : fwdTraversalSet ) {\n+                            final int overlap =\n+                                    findMaxOverlap(revTraversalRC.getContigs(), fwdTraversal.getContigs());\n+                            final Traversal combo =\n+                                    Traversal.combineOverlappers(revTraversalRC, fwdTraversal, overlap);\n+                            addTraversal(combo, traversalSet);\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+\n+        return traversalSet;\n+    }\n+\n+    private static int findMaxOverlap( final List<Contig> prefixes, final List<Contig> suffixes ) {\n+        final int nPrefixes = prefixes.size();\n+        final Contig firstSuffix = suffixes.get(0);\n+        if ( !firstSuffix.isCyclic() ) {\n+            return prefixes.get(nPrefixes - 1) == firstSuffix ? 1 : 0;\n+        }\n+        final int nSuffixes = suffixes.size();\n+        for ( int prefixIdx = Math.max(0, nPrefixes - nSuffixes); prefixIdx != nPrefixes; ++prefixIdx ) {\n+            if ( prefixes.get(prefixIdx) == firstSuffix ) {\n+                int suffixIdx = 1;\n+                boolean match = true;\n+                for ( int prefixIdx2 = prefixIdx + 1; prefixIdx2 != nPrefixes; ++prefixIdx2 ) {\n+                    if ( prefixes.get(prefixIdx2) != suffixes.get(suffixIdx++) ) {\n+                        match = false;\n+                        break;\n+                    }\n+                }\n+                if ( match ) {\n+                    return nPrefixes - prefixIdx;\n+                }\n+            }\n+        }\n+        return 0;\n+    }\n+\n+    private static void traverse( final Contig contig,\n+                                  final Contig predecessor,\n+                                  final List<Contig> contigsList,\n+                                  final List<Path> readPaths,\n+                                  final Map<Contig, List<TransitPairCount>> contigTransitsMap,\n+                                  final Set<Traversal> traversalSet ) {\n+        contigsList.add(predecessor);\n+        if ( contig.isCyclic() ) {\n+            traverseCycle(contig, contigsList, readPaths, contigTransitsMap, traversalSet);\n+            contigsList.remove(contigsList.size() - 1);\n+            return;\n+        }\n+        final List<TransitPairCount> transits = contigTransitsMap.get(contig);\n+        boolean done = false;\n+        if ( transits != null ) {\n+            for ( final TransitPairCount tpc : transits ) {\n+                if ( tpc.getPrevContig() == predecessor ) {\n+                    final Contig successor = tpc.getNextContig();\n+                    if ( predecessor == contig.rc() ) {\n+                        final int nContigs = contigsList.size();\n+                        if ( nContigs > 1 ) {\n+                            if ( successor.rc() == contigsList.get(nContigs - 2) ) {\n+                                continue;\n+                            }\n+                        }\n+                    }\n+                    tpc.resetCount();\n+                    traverse(successor, contig, contigsList, readPaths, contigTransitsMap, traversalSet);\n+                    done = true;\n+                }\n+            }\n+        }\n+        if ( !done ) {\n+            contigsList.add(contig);\n+            addTraversal(new Traversal(contigsList), traversalSet);\n+            contigsList.remove(contigsList.size() - 1);\n+        }\n+        contigsList.remove(contigsList.size() - 1);\n+    }\n+\n+    private static void traverseCycle( final Contig contig,\n+                                       final List<Contig> contigsList,\n+                                       final List<Path> readPaths,\n+                                       final Map<Contig, List<TransitPairCount>> contigTransitsMap,\n+                                       final Set<Traversal> traversalSet ) {\n+        contigsList.add(contig);\n+        final int nContigs = contigsList.size();\n+        // the final element of the list is cyclic, if there's a previous element it will be\n+        // non-cyclic, so start there figuring out how far the read paths lead us\n+        final List<List<Contig>> longestPaths =\n+                findLongestPaths(contigsList.subList(Math.max(0, nContigs - 2), nContigs), readPaths);\n+        // didn't get anywhere -- just complete the traversal\n+        if ( longestPaths.isEmpty() ) {\n+            addTraversal(new Traversal(contigsList, true), traversalSet);\n+        } else {\n+            // for each unique extension into the cycle\n+            for ( final List<Contig> path : longestPaths ) {\n+                // don't think this can happen, but still\n+                if ( path.isEmpty() ) {\n+                    addTraversal(new Traversal(contigsList, true), traversalSet);\n+                    continue;\n+                }\n+                final List<Contig> extendedContigsList =\n+                        new ArrayList<>(contigsList.size() + path.size());\n+                extendedContigsList.addAll(contigsList);\n+                // if we didn't get out of the cycle\n+                if ( path.get(path.size() - 1).isCyclic() ) {\n+                    extendedContigsList.addAll(path);\n+                    addTraversal(new Traversal(extendedContigsList, true), traversalSet);\n+                } else {\n+                    // we found a cycle-exiting path, so extend that normally\n+                    for ( final Contig curContig : path ) {\n+                        if ( curContig.isCyclic() ) {\n+                            extendedContigsList.add(curContig);\n+                        } else {\n+                            final Contig prevContig =\n+                                    extendedContigsList.remove(extendedContigsList.size() - 1);\n+                            traverse(curContig, prevContig, extendedContigsList, readPaths,\n+                                    contigTransitsMap, traversalSet);\n+                            extendedContigsList.add(prevContig);\n+                            break;\n+                        }\n+                    }\n+                }\n+                clearTransitPairs(contigTransitsMap, extendedContigsList);\n+            }\n+        }\n+        contigsList.remove(contigsList.size() - 1);\n+    }\n+\n+    private static void clearTransitPairs(\n+            final Map<Contig, List<TransitPairCount>> contigTransitsMap,\n+            final List<Contig> contigsList ) {\n+        final int lastIdx = contigsList.size() - 1;\n+        for ( int idx = 1; idx < lastIdx; ++idx ) {\n+            final List<TransitPairCount> pairCounts = contigTransitsMap.get(contigsList.get(idx));\n+            if ( pairCounts != null ) {\n+                final Contig predecessor = contigsList.get(idx - 1);\n+                final Contig successor = contigsList.get(idx + 1);\n+                for ( final TransitPairCount tpc : pairCounts ) {\n+                    if ( tpc.getPrevContig() == predecessor && tpc.getNextContig() == successor ) {\n+                        tpc.resetCount();\n+                        break;\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    private static void addTraversal( final Traversal traversal,\n+                                      final Set<Traversal> traversalSet ) {\n+        if ( !traversalSet.contains(traversal.rc()) ) {\n+            traversalSet.add(traversal);\n+            if ( traversalSet.size() >= TOO_MANY_TRAVERSALS ) {\n+                throw new AssemblyTooComplexException();\n+            }\n+        }\n+    }\n+\n+    private static List<List<Contig>> findLongestPaths( final List<Contig> toMatch,\n+                                                        final List<Path> readPaths ) {\n+        final List<List<Contig>> results = new ArrayList<>();\n+        for ( final Path path : readPaths ) {\n+            testPath(path, toMatch, results);\n+            testPath(path.rc(), toMatch, results);\n+        }\n+        return results;\n+    }\n+\n+    private static void testPath( final Path path,\n+                                  final List<Contig> toMatch,\n+                                  final List<List<Contig>> results ) {\n+        final List<PathPart> pathParts = path.getParts();\n+        final int nPathParts = pathParts.size();\n+        final List<Contig> pathContigs = new ArrayList<>(nPathParts);\n+        pathParts.forEach(pp -> pathContigs.add(pp.getContig()));\n+        final int matchIdx = Collections.indexOfSubList(pathContigs, toMatch);\n+        if ( matchIdx != -1 ) {\n+            final int suffixIdx = matchIdx + toMatch.size();\n+            if ( suffixIdx < nPathParts ) {\n+                resolveResult(grabParts(pathContigs, suffixIdx), results);\n+            }\n+        }\n+    }\n+\n+    private static List<Contig> grabParts( final List<Contig> pathContigs, final int suffixIdx ) {\n+        final int nPathContigs = pathContigs.size();\n+        Contig prev = pathContigs.get(suffixIdx - 1);\n+        final List<Contig> result = new ArrayList<>(nPathContigs - suffixIdx);\n+        for ( int idx = suffixIdx; idx != nPathContigs; ++idx ) {\n+            final Contig tig = pathContigs.get(idx);\n+            if ( tig == null || !prev.getSuccessors().contains(tig) ) break;\n+            result.add(tig);\n+            prev = tig;\n+        }\n+        return result;\n+    }\n+\n+    private static void resolveResult( final List<Contig> result,\n+                                       final List<List<Contig>> results ) {\n+        final int nResults = results.size();\n+        for ( int idx = 0; idx != nResults; ++idx ) {\n+            final List<Contig> test = results.get(idx);\n+            if ( isPrefix(result, test) ) return;\n+            if ( isPrefix(test, result) ) {\n+                results.set(idx, result);\n+                return;\n+            }\n+        }\n+        results.add(result);\n+    }\n+\n+    private static boolean isPrefix( final List<Contig> list1, final List<Contig> list2 ) {\n+        final int list1Size = list1.size();\n+        final int list2Size = list2.size();\n+        if ( list1Size > list2Size ) return false;\n+        for ( int idx = 0; idx != list1Size; ++idx ) {\n+            if ( list1.get(idx) != list2.get(idx) ) return false;\n+        }\n+        return true;\n+    }\n+\n+    @VisibleForTesting\n+    static Collection<Traversal> createScaffolds( final List<Traversal> allTraversals ) {\n+        removeTriviallyDifferentTraversals(allTraversals);\n+\n+        final int nTraversals = allTraversals.size();\n+        final Map<Contig, List<Integer>> traversalsByFirstContig = new HashMap<>(3 * nTraversals);\n+        for ( int idx = 0; idx != nTraversals; ++idx ) {\n+            final Traversal traversal = allTraversals.get(idx);\n+            traversalsByFirstContig.compute(traversal.getFirstContig(),\n+                    ( k, v ) -> v == null ? new ArrayList<>(3) : v).add(idx);\n+            final Traversal rcTraversal = traversal.rc();\n+            traversalsByFirstContig.compute(rcTraversal.getFirstContig(),\n+                    ( k, v ) -> v == null ? new ArrayList<>(3) : v).add(~idx);\n+        }\n+\n+        final List<Traversal> scaffolds = new ArrayList<>(nTraversals);\n+        final boolean[] touched = new boolean[nTraversals];\n+        for ( int idx = 0; idx != nTraversals; ++idx ) {\n+            if ( !touched[idx] ) {\n+                expandTraversal(idx, touched, traversalsByFirstContig, allTraversals, scaffolds);\n+            }\n+        }\n+        return scaffolds;\n+    }\n+\n+    private static void expandTraversal( final int traversalIdx,\n+                                         final boolean[] touched,\n+                                         final Map<Contig, List<Integer>> traversalsByFirstContig,\n+                                         final List<Traversal> allTraversals,\n+                                         final List<Traversal> scaffolds ) {\n+        final Traversal traversal = allTraversals.get(traversalIdx);\n+        touched[traversalIdx] = true;\n+        final List<Traversal> downExtensions = new ArrayList<>();\n+        final Set<Contig> startingContigSet = new HashSet<>();\n+        walkTraversals(traversal, touched, startingContigSet, traversalsByFirstContig,\n+                        allTraversals, downExtensions);\n+        final List<Traversal> upExtensions = new ArrayList<>();\n+        walkTraversals(traversal.rc(), touched, startingContigSet, traversalsByFirstContig,\n+                        allTraversals, upExtensions);\n+        for ( final Traversal down : downExtensions ) {\n+            for ( final Traversal up : upExtensions ) {\n+                if ( scaffolds.size() >= TOO_MANY_SCAFFOLDS ) {\n+                    throw new AssemblyTooComplexException();\n+                }\n+                scaffolds.add(Traversal.combineOverlappers(up.rc(), down, traversal.getContigs().size()));\n+            }\n+        }\n+    }\n+\n+    private static void walkTraversals( final Traversal traversal,\n+                                        final boolean[] touched,\n+                                        final Set<Contig> startingContigSet,\n+                                        final Map<Contig, List<Integer>> traversalsByFirstContig,\n+                                        final List<Traversal> allTraversals,\n+                                        final List<Traversal> extensions ) {\n+        final Contig firstContig = traversal.getFirstContig();\n+        final List<Integer> indexList;\n+        if ( startingContigSet.contains(firstContig) ||\n+                traversal.isInextensible() ||\n+                (indexList = traversalsByFirstContig.get(traversal.getLastContig())) == null ) {\n+            extensions.add(traversal);\n+            return;\n+        }\n+        startingContigSet.add(firstContig);\n+        for ( int idx : indexList ) {\n+            final Traversal extension;\n+            if ( idx >= 0 ) {\n+                extension = allTraversals.get(idx);\n+                touched[idx] = true;\n+            } else {\n+                final int rcIdx = ~idx;\n+                extension = allTraversals.get(rcIdx).rc();\n+                touched[rcIdx] = true;\n+            }\n+            walkTraversals(Traversal.combine(traversal, extension), touched, startingContigSet,\n+                            traversalsByFirstContig, allTraversals, extensions );\n+        }\n+        startingContigSet.remove(firstContig);\n+    }\n+\n+    private static void removeTriviallyDifferentTraversals(\n+                                            final Collection<Traversal> allTraversals ) {\n+        if ( allTraversals.isEmpty() ) {\n+            return;\n+        }\n+        final TreeSet<Traversal> sortedTraversals = new TreeSet<>(new TraversalEndpointComparator());\n+        for ( final Traversal traversal : allTraversals ) {\n+            sortedTraversals.add(traversal);\n+            sortedTraversals.add(traversal.rc());\n+        }\n+        final Iterator<Traversal> traversalIterator = sortedTraversals.iterator();\n+        Traversal prevTraversal = traversalIterator.next();\n+        while ( traversalIterator.hasNext() ) {\n+            final Traversal curTraversal = traversalIterator.next();\n+            if ( isTriviallyDifferent(prevTraversal, curTraversal) ) {\n+                traversalIterator.remove();\n+            } else {\n+                prevTraversal = curTraversal;\n+            }\n+        }\n+        sortedTraversals.removeIf(Traversal::isRC);\n+        allTraversals.clear();\n+        allTraversals.addAll(sortedTraversals);\n+    }\n+\n+    private static boolean isTriviallyDifferent( final Traversal traversal1,\n+                                                 final Traversal traversal2 ) {\n+        final Contig firstContig1 = traversal1.getFirstContig();\n+        final Contig lastContig1 = traversal1.getLastContig();\n+        final Contig firstContig2 = traversal2.getFirstContig();\n+        final Contig lastContig2 = traversal2.getLastContig();\n+        if ( firstContig1 != firstContig2 || lastContig1 != lastContig2 ) {\n+            return false;\n+        }\n+        final int interiorSize1 = traversal1.getSequenceLength() - firstContig1.size() - lastContig1.size();\n+        final int interiorSize2 = traversal2.getSequenceLength() - firstContig2.size() - lastContig2.size();\n+\n+        // if the path lengths are so different that one could harbor an SV, they're not trivially different\n+        if ( Math.abs(interiorSize1 - interiorSize2) >= MIN_SV_SIZE ) {\n+            return false;\n+        }\n+\n+        // if the paths are small enough that there can't be an SV's worth of differences, they're trivially different\n+        final int maxInteriorSize = Math.max(interiorSize1, interiorSize2);\n+        if ( maxInteriorSize < MIN_SV_SIZE ) {\n+            return true;\n+        }\n+\n+        // dang, maybe there's enough material in common that there can't be an SV's worth of differences\n+        // run a longest common subsequence algorithm to figure out the length of the common material\n+        // DP matrix holds length of common material\n+        final List<Contig> contigs1 = traversal1.getContigs();\n+        final int rowLen = contigs1.size() - 1;\n+        final int[][] rowPair = new int[2][];\n+        rowPair[0] = new int[rowLen];\n+        rowPair[1] = new int[rowLen];\n+        int pairIdx = 0;\n+        final List<Contig> contigs2 = traversal2.getContigs();\n+        final int nRows = contigs2.size() - 1;\n+        for ( int idx2 = 1; idx2 != nRows; ++idx2 ) {\n+            final int[] curRow = rowPair[pairIdx];\n+            final int[] prevRow = rowPair[pairIdx ^ 1];\n+            pairIdx ^= 1;\n+\n+            final int id2 = contigs2.get(idx2).getId();\n+            for ( int idx1 = 1; idx1 != rowLen; ++idx1 ) {\n+                final Contig tig1 = contigs1.get(idx1);\n+                if ( tig1.getId() == id2 ) {\n+                    // if the previous cells also contain a match we've already removed the K-1 bases upstream\n+                    final boolean extendMatch =\n+                            contigs1.get(idx1 -1).getId() == contigs2.get(idx2 - 1).getId();\n+                    curRow[idx1] = prevRow[idx1 - 1] + (extendMatch ? tig1.getNKmers() : tig1.size());\n+                } else {\n+                    curRow[idx1] = Math.max(curRow[idx1 - 1], prevRow[idx1]);\n+                }\n+            }\n+        }\n+        final int commonLen = rowPair[pairIdx ^ 1][rowLen - 1];\n+        return (maxInteriorSize - commonLen) < MIN_SV_SIZE;\n+    }\n+\n+    private static class TraversalEndpointComparator implements Comparator<Traversal> {\n+        @Override\n+        public int compare( final Traversal traversal1, final Traversal traversal2 ) {\n+            int cmp = Integer.compare(traversal1.contigs.get(0).getId(),\n+                                      traversal2.contigs.get(0).getId());\n+            if ( cmp != 0 ) {\n+                return cmp;\n+            }\n+            final int last1 = traversal1.contigs.size() - 1;\n+            final int last2 = traversal2.contigs.size() - 1;\n+            cmp = Integer.compare(traversal1.contigs.get(last1).getId(),\n+                                  traversal2.contigs.get(last2).getId());\n+            if ( cmp != 0 ) {\n+                return cmp;\n+            }\n+            // among those starting and ending at the same place, sort least observed last\n+            return -Integer.compare(traversal1.getMinMaxObservations(), traversal2.getMinMaxObservations());\n+        }\n+    }\n+\n+    private static void writeDOT( final List<ContigImpl> contigs, final String fileName ) {\n+        try ( final BufferedWriter writer = new BufferedWriter(new FileWriter(fileName)) ) {\n+            writer.write(\"digraph {\\n\");\n+            for ( final Contig contig : contigs ) {\n+                final double width = contig.getSequence().length() / 100.;\n+                writer.write(contig + \" [width=\" + width + \"]\\n\");\n+                writer.write( contig.rc() + \" [width=\" + width + \"]\\n\");\n+            }\n+            for ( final Contig contig : contigs ) {\n+                for ( final Contig predecessor : contig.getPredecessors() ) {\n+                    final String predecessorName = predecessor.rc().toString();\n+                    writer.write(contig.rc() + \" -> \" + predecessorName + \"\\n\");\n+                }\n+                for ( final Contig successor : contig.getSuccessors() ) {\n+                    final String successorName = successor.toString();\n+                    writer.write(contig + \" -> \" + successorName + \"\\n\");\n+                }\n+            }\n+            writer.write(\"}\\n\");\n+        } catch ( final IOException ioe ) {\n+            throw new GATKException(\"Failed to write assembly DOT file.\", ioe);\n+        }\n+    }\n+\n+    private static BufferedWriter makeGZFile( final String fileName ) throws IOException {\n+        final GZIPOutputStream gzOS = new GZIPOutputStream(BucketUtils.createFile(fileName));\n+        return new BufferedWriter(new OutputStreamWriter(gzOS));\n+    }\n+\n+    private static void writeContigs( final List<ContigImpl> contigs, final String fileName ) {\n+        try ( final BufferedWriter writer = makeGZFile(fileName) ) {\n+            for ( final Contig contig : contigs ) {\n+                final List<Contig> predecessors = contig.getPredecessors();\n+                final String predecessorDescription;\n+                if ( predecessors.size() == 0 ) {\n+                    predecessorDescription = \"\\tnone\";\n+                } else {\n+                    final StringBuilder sb = new StringBuilder();\n+                    char prefix = '\\t';\n+                    for ( final Contig predecessor : predecessors ) {\n+                        sb.append(prefix);\n+                        prefix = ',';\n+                        sb.append(predecessor);\n+                    }\n+                    predecessorDescription = sb.toString();\n+                }\n+\n+                final List<Contig> successors = contig.getSuccessors();\n+                final String successorDescription;\n+                if ( successors.size() == 0 ) {\n+                    successorDescription = \"\\tnone\";\n+                } else {\n+                    final StringBuilder sb = new StringBuilder();\n+                    char prefix = '\\t';\n+                    for ( final Contig successor : successors ) {\n+                        sb.append(prefix);\n+                        prefix = ',';\n+                        sb.append(successor);\n+                    }\n+                    successorDescription = sb.toString();\n+                }\n+\n+                final String contigName = contig.toString();\n+                final String component =\n+                        (contig.isCyclic() ? \"(C)\\t\" : \"\\t\") + contig.getComponentId();\n+                writer.write(contigName + component + predecessorDescription +\n+                        successorDescription + \"\\t\" +\n+                        contig.getMaxObservations() + \"\\t\" +\n+                        contig.getFirstKmer().getNObservations() + \"\\t\" +\n+                        contig.getLastKmer().getNObservations() + \"\\t\" +\n+                        contig.size() + \"\\t\" +\n+                        contig.getSequence() + \"\\n\");\n+            }\n+        } catch ( final IOException ioe ) {\n+            throw new GATKException(\"Failed to write contigs file.\", ioe);\n+        }\n+    }\n+\n+    private static void writePaths( final List<Path> readPaths, final String fileName ) {\n+        try ( final BufferedWriter writer = makeGZFile(fileName) ) {\n+            final int nReads = readPaths.size();\n+            for ( int readId = 0; readId != nReads; ++readId ) {\n+                final Path path = readPaths.get(readId);\n+                final String pathDesc = path.toString();\n+                writer.write((readId + 1) + \": \" + pathDesc + \"\\n\");\n+            }\n+        } catch ( final IOException ioe ) {\n+            throw new GATKException(\"Failed to write paths file.\", ioe);\n+        }\n+    }\n+\n+    private static void writeReads( final List<GATKRead> reads, final String fileName ) {\n+        try ( final BufferedWriter writer = makeGZFile(fileName) ) {\n+            for ( final GATKRead read : reads ) {\n+                writer.write(\"@\" + read.getName());\n+                writer.write('\\n');\n+                writer.write(new String(read.getBasesNoCopy()));\n+                writer.write(\"\\n+\\n\");\n+                final byte[] quals = read.getBaseQualitiesNoCopy();\n+                final int nQuals = quals.length;\n+                final byte[] fastqQuals = new byte[nQuals];\n+                for ( int idx = 0; idx != nQuals; ++idx ) {\n+                    fastqQuals[idx] = (byte)SAMUtils.phredToFastq(quals[idx]);\n+                }\n+                writer.write(new String(fastqQuals));\n+                writer.write('\\n');\n+            }\n+        } catch ( final IOException ioe ) {\n+            throw new GATKException(\"Failed to write assembly sam file.\", ioe);\n+        }\n+    }\n+\n+    private static void writeTraversals( final Collection<Traversal> traversals,\n+                                         final String fileName ) {\n+        try ( final BufferedWriter writer = makeGZFile(fileName) ) {\n+            int traversalNo = 0;\n+            for ( final Traversal traversal : traversals ) {\n+                writer.write(\">\");\n+                if ( assemblyName != null ) {\n+                    writer.write(assemblyName);\n+                    writer.write(\"_\");\n+                }\n+                writer.write(\"t\");\n+                writer.write(Integer.toString(++traversalNo));\n+                writer.write(\" \");\n+                writer.write(traversal.getName());\n+                writer.newLine();\n+                writer.write(traversal.getSequence());\n+                writer.newLine();\n+            }\n+        } catch ( final IOException ioe ) {\n+            throw new GATKException(\"Failed to write assembly sam file.\", ioe);\n+        }\n+    }\n+\n+    /** fixed-size, immutable kmer.  usual 2-bit encoding: ACGT->0123.  low order bits are final call. **/\n+    public static class Kmer {\n+        public static final int KSIZE = 31; // must be odd number less than 32\n+        public static final long KMASK = (1L << 2*KSIZE) - 1L;\n+        private final long kVal;\n+\n+        public Kmer( final long kVal ) { this.kVal = kVal; }\n+\n+        public long getKVal() { return kVal; }\n+        public boolean isCanonical() { return isCanonical(kVal); }\n+        public int getInitialCall() { return (int)(kVal >> (KSIZE*2 - 2)) & 3; }\n+        public int getFinalCall() { return (int)kVal & 3; }\n+\n+        public long getPredecessorVal( final int call ) {\n+            return (kVal >> 2) | ((long)call << (2 * (KSIZE - 1)));\n+        }\n+        public long getSuccessorVal( final int call ) { return ((kVal << 2) & KMASK) | call; }\n+\n+        public static boolean isCanonical( final long val ) {\n+            return (val & (1L << KSIZE)) == 0L;\n+        }\n+\n+        @Override public boolean equals( final Object obj ) {\n+            return obj instanceof Kmer && kVal == ((Kmer)obj).kVal;\n+        }\n+\n+        @Override public int hashCode() {\n+            return (int)(kVal ^ (kVal >>> 32));\n+        }\n+    }\n+\n+    /** Set of Kmers.  Uses HopscotchSet, customized to find correct starting bin for Kmers and derivatives. **/\n+    public static final class KmerSet<KMER extends Kmer> extends HopscotchSet<KMER> {\n+        public KmerSet( final int capacity ) { super(capacity); }\n+\n+        @Override\n+        protected int hashToIndex( final Object kmer ) {\n+            return (int)(((HopscotchSet.SPREADER * ((Kmer)kmer).getKVal()) & Long.MAX_VALUE) % capacity());\n+        }\n+    }\n+\n+    /**\n+     *  A Kmer that remembers its predecessors and successors, and the number of times it's been observed\n+     *  in the assembly's input set of reads.\n+     *  The masks are bit-wise (1=A, 2=C, 4=G, 8=T) to show which predecessors or successors have been observed.\n+     *  The Kmer's position on a Contig is also tracked (in later phases of the assembly process).\n+     **/\n+    public static abstract class KmerAdjacency extends Kmer {\n+        public KmerAdjacency( final long kVal ) { super(kVal); }\n+\n+        public abstract KmerAdjacency getSolePredecessor(); // returns null if there's 0 or >1 predecessors\n+        public abstract int getPredecessorMask();\n+        public abstract int getPredecessorCount();\n+        public abstract void removePredecessor( final int callToRemove,\n+                                                final KmerSet<KmerAdjacency> kmerAdjacencySet );\n+\n+        public abstract KmerAdjacency getSoleSuccessor(); // returns null if there's 0 or > 1 successors\n+        public abstract int getSuccessorMask();\n+        public abstract int getSuccessorCount();\n+        public abstract void removeSuccessor( final int callToRemove,\n+                                              final KmerSet<KmerAdjacency> kmerAdjacencySet );\n+\n+        public abstract Contig getContig();\n+        public abstract int getContigOffset();\n+        // offset is 0-based measure on the contig sequence of the beginning of the kmer\n+        public abstract void setContigOffset( final Contig contig, final int contigOffset );\n+        public abstract void clearContig();\n+\n+        public abstract int getNObservations();\n+        public abstract KmerAdjacency rc();\n+        public abstract KmerAdjacencyImpl canonical();\n+\n+        public void observe( final KmerAdjacency predecessor, final KmerAdjacency successor ) {\n+            observe(predecessor, successor, 1);\n+        }\n+\n+        public abstract void observe( final KmerAdjacency predecessor,\n+                                      final KmerAdjacency successor,\n+                                      final int count );\n+\n+        @Override public String toString() {\n+            final StringBuilder sb = new StringBuilder(KSIZE);\n+            long currentVal = getKVal();\n+            for ( int idx = 0; idx != KSIZE; ++idx ) {\n+                sb.append(\"ACGT\".charAt((int)currentVal & 3));\n+                currentVal >>= 2;\n+            }\n+            sb.reverse(); // low order bits were loaded into sb first:  fix that now by reversing the sb.\n+            return sb.toString();\n+        }\n+\n+        /**\n+         * Transform a read's calls into KmerAdjacencies, and add them to a KmerSet.\n+         * Skip kmers that include a call with a quality < qMin.\n+         * Skip kmers with non-ACGT calls.\n+         **/\n+        public static void kmerize( final byte[] calls,\n+                                    final byte[] quals,\n+                                    final byte qMin,\n+                                    final KmerSet<KmerAdjacency> kmerAdjacencySet ) {\n+            int currentCount = 0; // number of calls loaded into currentKVal\n+            long currentKVal = 0;\n+            KmerAdjacency prevAdjacency = null;\n+            KmerAdjacency currentAdjacency = null;\n+            for ( int idx = 0; idx < calls.length; ++idx ) {\n+                if ( quals[idx] < qMin ) { // if we encounter a low-quality call\n+                    // take care of the most recent valid KmerAdjacency, if any\n+                    if ( currentAdjacency != null ) {\n+                        currentAdjacency.observe(prevAdjacency, null);\n+                    }\n+                    // ready ourselves to accumulate calls afresh\n+                    currentCount = 0;\n+                    currentAdjacency = prevAdjacency = null;\n+                    continue;\n+                }\n+                currentKVal <<= 2;\n+                switch ( calls[idx] ) {\n+                    case 'A': case 'a': break;\n+                    case 'C': case 'c': currentKVal += 1; break;\n+                    case 'G': case 'g': currentKVal += 2; break;\n+                    case 'T': case 't': currentKVal += 3; break;\n+                    default:\n+                        if ( currentAdjacency != null ) {\n+                            currentAdjacency.observe(prevAdjacency, null);\n+                        }\n+                        currentCount = 0;\n+                        currentAdjacency = prevAdjacency = null;\n+                        continue;\n+                }\n+                if ( ++currentCount >= KSIZE ) { // if we've loaded enough calls to make a complete kmer\n+                    final KmerAdjacency nextAdjacency = findOrAdd(currentKVal, kmerAdjacencySet);\n+                    if ( currentAdjacency != null ) {\n+                        currentAdjacency.observe(prevAdjacency, nextAdjacency);\n+                    }\n+                    prevAdjacency = currentAdjacency;\n+                    currentAdjacency = nextAdjacency;\n+                }\n+            }\n+            if ( currentAdjacency != null ) {\n+                currentAdjacency.observe(prevAdjacency, null);\n+            }\n+        }\n+\n+        /**\n+         * Kmerize a String.  This version is for gap fills.\n+         * The number of observations applies to all kmers except the 1st and last.\n+         **/\n+        public static void kmerize( final String sequence,\n+                                    final int nObservations,\n+                                    final KmerSet<KmerAdjacency> kmerAdjacencySet ) {\n+            int currentCount = 0;\n+            long currentKVal = 0;\n+            int nObs = 0;\n+            KmerAdjacency prevAdjacency = null;\n+            KmerAdjacency currentAdjacency = null;\n+            final int nCalls = sequence.length();\n+            for ( int idx = 0; idx != nCalls; ++idx ) {\n+                currentKVal <<= 2;\n+                switch ( sequence.charAt(idx) ) {\n+                    case 'A': case 'a': break;\n+                    case 'C': case 'c': currentKVal += 1; break;\n+                    case 'G': case 'g': currentKVal += 2; break;\n+                    case 'T': case 't': currentKVal += 3; break;\n+                    default: throw new GATKException(\"unexpected base call in string to kmerize.\");\n+                }\n+                if ( ++currentCount >= KSIZE ) {\n+                    final KmerAdjacency nextAdjacency = findOrAdd(currentKVal, kmerAdjacencySet);\n+                    if ( currentAdjacency != null ) {\n+                        currentAdjacency.observe(prevAdjacency, nextAdjacency, nObs);\n+                        nObs = nObservations;\n+                    }\n+                    prevAdjacency = currentAdjacency;\n+                    currentAdjacency = nextAdjacency;\n+                }\n+            }\n+            if ( currentAdjacency != null ) {\n+                currentAdjacency.observe(prevAdjacency, null, 0);\n+            }\n+        }\n+\n+        // Lookup table for reverse-complementing each possible byte value.\n+        // Each pair of bits represents a base, so you have to reverse bits pairwise and then invert all bits.\n+        // This is most quickly and easily done with a lookup table.\n+        private static final long[] BYTEWISE_REVERSE_COMPLEMENT;\n+        static {\n+            BYTEWISE_REVERSE_COMPLEMENT = new long[256];\n+            for ( int bIn = 0; bIn != 256; ++bIn ) {\n+                BYTEWISE_REVERSE_COMPLEMENT[bIn] =\n+                        ~(((bIn & 3) << 6) | (((bIn >> 2) & 3) << 4) |\n+                                (((bIn >> 4) & 3) << 2) | ((bIn >> 6) & 3)) & 0xffL;\n+            }\n+        }\n+\n+        public static long reverseComplement( long val ) {\n+            // process val one byte at a time\n+            long result = BYTEWISE_REVERSE_COMPLEMENT[(int)val & 0xFF]; // handle the low-order byte\n+            int nBytes = 8;\n+            while ( --nBytes != 0 ) { // pre-decrementing:  we'll go through the loop 7 times\n+                // rotate down by a byte\n+                val >>= 8;\n+                // rotate up by a byte and OR in the reverse complement of the next byte\n+                result = (result << 8) | BYTEWISE_REVERSE_COMPLEMENT[(int)val & 0xFF];\n+            }\n+            return result >>> (Long.SIZE - 2*KSIZE);\n+        }\n+\n+        // Kmer lookup in KmerSet.\n+        // KmerSets holding KmerAdjacencies have only canonical Kmers, so RC non-canonical kmers before lookup.\n+        public static KmerAdjacency find( final long kVal,\n+                                          final KmerSet<KmerAdjacency> kmerAdjacencySet ) {\n+            if ( isCanonical(kVal) ) return kmerAdjacencySet.find(new Kmer(kVal & KMASK));\n+            final KmerAdjacency result = kmerAdjacencySet.find(new Kmer(reverseComplement(kVal)));\n+            return result == null ? null : result.rc();\n+        }\n+\n+        // Kmer lookup in KmerSet.\n+        // KmerSets holding KmerAdjacencies have only canonical Kmers, so RC non-canonical kmers before lookup.\n+        // Add missing Kmers.\n+        public static KmerAdjacency findOrAdd( final long kVal,\n+                                               final KmerSet<KmerAdjacency> kmerAdjacencySet ) {\n+            if ( isCanonical(kVal) ) {\n+                return kmerAdjacencySet.findOrAdd(new Kmer(kVal & KMASK), kmer ->\n+                        new KmerAdjacencyImpl(((Kmer)kmer).getKVal()));\n+            }\n+            return kmerAdjacencySet.findOrAdd(new Kmer(reverseComplement(kVal)), kmer ->\n+                    new KmerAdjacencyImpl(((Kmer)kmer).getKVal())).rc();\n+        }\n+    }\n+\n+    /**\n+     * Class to implement KmerAdjacency for canonical Kmers.\n+     * In particular, a KmerSet created on KmerAdjacency contains only canonical Kmers.\n+     **/\n+    public static final class KmerAdjacencyImpl extends KmerAdjacency {\n+        private KmerAdjacency solePredecessor; // set to null if there are no predecessors, or multiple predecessors\n+        private KmerAdjacency soleSuccessor; // set to null if there are no successors, or multiple successors\n+        private int predecessorMask; // bit mask of observed kmers preceding this one\n+        private int successorMask; // bit mask observed kmers following this one\n+        private Contig contig; // the contig that contains this Kmer\n+        private int contigOffset; // the offset within the contig where this kmer is found\n+        private int nObservations; // the reads in which this kmer was observed\n+        private final KmerAdjacencyRC rc; // the reverse-complement of this kmer\n+        private static final int[] COUNT_FOR_MASK =\n+                //side sum for binary values from 0 -> 15\n+                //0000  0001 0010 0011 0100 0101 0110 0111 1000 1001 1010 1011 1100 1101 1110 1111\n+                {    0,    1,   1,   2,   1,   2,   2,   3,   1,   2,   2,   3,   2,   3,   3,   4 };\n+\n+        public KmerAdjacencyImpl( final long kVal ) {\n+            super(kVal);\n+            this.rc = new KmerAdjacencyRC(this);\n+        }\n+\n+        @Override public KmerAdjacency getSolePredecessor() { return solePredecessor; } // may return null\n+        @Override public int getPredecessorMask() { return predecessorMask; }\n+        @Override public int getPredecessorCount() { return COUNT_FOR_MASK[predecessorMask]; }\n+        @Override\n+        public void removePredecessor( final int callToRemove,\n+                                       final KmerSet<KmerAdjacency> kmerAdjacencySet ) {\n+            predecessorMask &= ~(1 << callToRemove);\n+            solePredecessor = null;\n+            if ( getPredecessorCount() == 1 ) {\n+                for ( int call = 0; call != 4; ++call ) {\n+                    if ( ((1 << call) & predecessorMask) != 0 ) {\n+                        solePredecessor = find(getPredecessorVal(call), kmerAdjacencySet);\n+                        break;\n+                    }\n+                }\n+            }\n+        }\n+\n+        @Override public KmerAdjacency getSoleSuccessor() { return soleSuccessor; } // may return null\n+        @Override public int getSuccessorMask() { return successorMask; }\n+        @Override public int getSuccessorCount() { return COUNT_FOR_MASK[successorMask]; }\n+        @Override\n+        public void removeSuccessor( final int callToRemove,\n+                                     final KmerSet<KmerAdjacency> kmerAdjacencySet ) {\n+            successorMask &= ~(1 << callToRemove);\n+            soleSuccessor = null;\n+            if ( getSuccessorCount() == 1 ) {\n+                for ( int call = 0; call != 4; ++call ) {\n+                    if ( ((1 << call) & successorMask) != 0 ) {\n+                        soleSuccessor = find(getSuccessorVal(call), kmerAdjacencySet);\n+                        break;\n+                    }\n+                }\n+            }\n+        }\n+\n+        @Override public Contig getContig() { return contig; }\n+        @Override public int getContigOffset() { return contigOffset; }\n+        @Override public void setContigOffset( final Contig contig, final int contigOffset ) {\n+            if ( this.contig != null ) {\n+                throw new GATKException(\"Internal error: overwriting kmer contig and offset.\");\n+            }\n+            this.contig = contig;\n+            this.contigOffset = contigOffset;\n+        }\n+        @Override public void clearContig() { contig = null; contigOffset = 0; }\n+\n+        @Override public int getNObservations() { return nObservations; }\n+        @Override public KmerAdjacency rc() { return rc; }\n+        @Override public KmerAdjacencyImpl canonical() { return this; }\n+\n+        @Override public void observe( final KmerAdjacency predecessor,\n+                                       final KmerAdjacency successor,\n+                                       final int count ) {\n+            if ( predecessor != null ) {\n+                if ( predecessor.getSuccessorVal(getFinalCall()) != getKVal() ) {\n+                    throw new GATKException(\"illegal predecessor\");\n+                }\n+                final int initialCall = predecessor.getInitialCall();\n+                final int newPredecessorMask = 1 << initialCall;\n+                if ( (newPredecessorMask & predecessorMask) == 0 ) {\n+                    if ( predecessorMask == 0 ) {\n+                        solePredecessor = predecessor;\n+                        predecessorMask = newPredecessorMask;\n+                    } else {\n+                        solePredecessor = null;\n+                        predecessorMask |= newPredecessorMask;\n+                    }\n+                }\n+            }\n+            if ( successor != null ) {\n+                if ( successor.getPredecessorVal(getInitialCall()) != getKVal() ) {\n+                    throw new GATKException(\"illegal successor\");\n+                }\n+                final int finalCall = successor.getFinalCall();\n+                final int newSuccessorMask = 1 << finalCall;\n+                if ( (newSuccessorMask & successorMask) == 0 ) {\n+                    if ( successorMask == 0 ) {\n+                        soleSuccessor = successor;\n+                        successorMask = newSuccessorMask;\n+                    } else {\n+                        soleSuccessor = null;\n+                        successorMask |= newSuccessorMask;\n+                    }\n+                }\n+            }\n+            nObservations += count;\n+        }\n+    }\n+\n+    /**\n+     * Class to implement KmerAdjacency for Kmers that are the reverse-complement of a canonical Kmer.\n+     * In particular, a KmerSet created on KmerAdjacency contains only canonical Kmers.\n+     * A KmerAdjacencyRC represents the RC of each Kmer in the KmerSet.\n+     **/\n+    public static final class KmerAdjacencyRC extends KmerAdjacency {\n+        private final KmerAdjacencyImpl rc;\n+\n+        // lookup table to bit-reverse nibbles\n+        private static final int[] NIBREV =\n+                // 0000,  0001,  0010,  0011,  0100,  0101,  0110,  0111,  1000,  1001,  1010,  1011,  1100,  1101,  1110,  1111\n+                {0b0000,0b1000,0b0100,0b1100,0b0010,0b1010,0b0110,0b1110,0b0001,0b1001,0b0101,0b1101,0b0011,0b1011,0b0111,0b1111};\n+\n+        public KmerAdjacencyRC( final KmerAdjacencyImpl rc ) {\n+            super(reverseComplement(rc.getKVal()));\n+            this.rc = rc;\n+        }\n+\n+        @Override public KmerAdjacency getSolePredecessor() {\n+            final KmerAdjacency successor = rc.getSoleSuccessor();\n+            return successor == null ? null : successor.rc();\n+        }\n+        @Override public int getPredecessorMask() { return NIBREV[rc.getSuccessorMask()]; }\n+        @Override public int getPredecessorCount() { return rc.getSuccessorCount(); }\n+        @Override\n+        public void removePredecessor( final int callToRemove,\n+                                       final KmerSet<KmerAdjacency> kmerAdjacencySet ) {\n+            rc.removeSuccessor(3 - callToRemove, kmerAdjacencySet);\n+        }\n+\n+        @Override public KmerAdjacency getSoleSuccessor() {\n+            final KmerAdjacency predecessor = rc.getSolePredecessor();\n+            return predecessor == null ? null : predecessor.rc();\n+        }\n+        @Override public int getSuccessorMask() { return NIBREV[rc.getPredecessorMask()]; }\n+        @Override public int getSuccessorCount() { return rc.getPredecessorCount(); }\n+        @Override\n+        public void removeSuccessor( final int callToRemove,\n+                                     final KmerSet<KmerAdjacency> kmerAdjacencySet ) {\n+            rc.removePredecessor(3 - callToRemove, kmerAdjacencySet);\n+        }\n+\n+        @Override public Contig getContig() {\n+            final Contig contig = rc.getContig();\n+            return contig == null ? null : contig.rc();\n+        }\n+        @Override public int getContigOffset() {\n+            final Contig contig = rc.getContig();\n+            return contig == null ? 0 : contig.size() - rc.getContigOffset() - KSIZE;\n+        }\n+        @Override public void setContigOffset( final Contig contig, final int contigOffset ) {\n+            rc.setContigOffset(contig.rc(), contig.size() - contigOffset - KSIZE);\n+        }\n+        @Override public void clearContig() { rc.clearContig(); }\n+\n+        @Override public int getNObservations() { return rc.getNObservations(); }\n+        @Override public KmerAdjacency rc() { return rc; }\n+        @Override public KmerAdjacencyImpl canonical() { return rc; }\n+\n+        @Override public void observe( final KmerAdjacency predecessor,\n+                                       final KmerAdjacency successor,\n+                                       final int count ) {\n+            rc.observe(successor == null ? null : successor.rc(),\n+                    predecessor == null ? null : predecessor.rc(),\n+                    count);\n+        }\n+    }\n+\n+    public enum ContigOrientation {\n+        FWD, // k-mer appears at the 5' end of the contig\n+        REV, // k-mer appears at the 5' end of the reverse-complemented contig\n+        BOTH // k-mer occurs on 5' end of the contig and its RC (can happen when the contig is a palindrome)\n+    }\n+\n+    /** Initial or final Kmer in a Contig. **/\n+    public static final class ContigEndKmer extends Kmer {\n+        private final Contig contig;\n+        private final ContigOrientation contigOrientation;\n+\n+        public ContigEndKmer( final long kVal,\n+                              final Contig contig,\n+                              final ContigOrientation contigEnd ) {\n+            super(kVal);\n+            this.contig = contig;\n+            this.contigOrientation = contigEnd;\n+        }\n+\n+        public Contig getContig() { return contig; }\n+        public ContigOrientation getContigOrientation() { return contigOrientation; }\n+    }\n+\n+    /**\n+     * An unbranched sequence of Kmers.\n+     * Each Kmer (except the last one) has a single successor, which allows enumerating the sequence\n+     * of Kmers in the Contig.  The sequence of base calls in the Contig is just the sequence of kmers\n+     * with the K-1 overlapping calls removed from adjacent kmers.\n+     **/\n+    public interface Contig {\n+        int getId();\n+        CharSequence getSequence();\n+        int getMaxObservations();\n+        KmerAdjacency getFirstKmer();\n+        KmerAdjacency getLastKmer();\n+        List<Contig> getPredecessors();\n+        List<Contig> getSuccessors();\n+        int getComponentId();\n+        int size();\n+        default int getNKmers() { return size() - Kmer.KSIZE + 1; }\n+        Contig rc();\n+        boolean isCyclic();\n+        void setCyclic( final boolean cyclic );\n+        boolean isCut();\n+        void setCut( final boolean cut );\n+        boolean isCanonical();\n+        ContigImpl canonical();\n+    }\n+\n+    /** Simple implementation of Contig interface. **/\n+    public static final class ContigImpl implements Contig {\n+        private final int id;\n+        private final CharSequence sequence;\n+        private final int maxObservations;\n+        private final KmerAdjacency firstKmer;\n+        private final KmerAdjacency lastKmer;\n+        private final List<Contig> predecessors;\n+        private final List<Contig> successors;\n+        private int componentId;\n+        private boolean cyclic;\n+        private boolean cut;\n+        private final Contig rc;\n+\n+        public ContigImpl( final int id, final KmerAdjacency firstKmerAdjacency ) {\n+            this.id = id;\n+            final StringBuilder sb = new StringBuilder(firstKmerAdjacency.toString());\n+            int maxObservations = firstKmerAdjacency.getNObservations();\n+            KmerAdjacency lastKmerAdjacency = firstKmerAdjacency;\n+            for ( KmerAdjacency kmerAdjacency = firstKmerAdjacency.getSoleSuccessor();\n+                  kmerAdjacency != null;\n+                  kmerAdjacency = kmerAdjacency.getSoleSuccessor() ) {\n+                // if we've gone around a circle, or if we're branching backwards, or if we hit a palindrome u-turn\n+                if ( firstKmerAdjacency == kmerAdjacency ||\n+                        kmerAdjacency.getPredecessorCount() != 1 ||\n+                        kmerAdjacency == lastKmerAdjacency.rc() ) {\n+                    break;\n+                }\n+                sb.append(\"ACGT\".charAt(kmerAdjacency.getFinalCall()));\n+                maxObservations = Math.max(maxObservations, kmerAdjacency.getNObservations());\n+                lastKmerAdjacency = kmerAdjacency;\n+            }\n+            this.sequence = sb.toString();\n+            this.maxObservations = maxObservations;\n+            this.firstKmer = firstKmerAdjacency;\n+            this.lastKmer = lastKmerAdjacency;\n+            this.predecessors = new ArrayList<>(firstKmer.getPredecessorCount());\n+            this.successors = new ArrayList<>(lastKmer.getSuccessorCount());\n+            this.rc = new ContigRCImpl(this);\n+\n+            int offset = 0;\n+            for ( KmerAdjacency kmerAdjacency = firstKmerAdjacency;\n+                  kmerAdjacency != lastKmerAdjacency;\n+                  kmerAdjacency = kmerAdjacency.getSoleSuccessor() ) {\n+                kmerAdjacency.setContigOffset(this, offset++);\n+            }\n+            lastKmerAdjacency.setContigOffset(this, offset);\n+        }\n+\n+        // create a new contig by joining two contigs\n+        public ContigImpl( final int id, final Contig predecessor, final Contig successor ) {\n+            if ( predecessor == successor || predecessor == successor.rc() ) {\n+                throw new GATKException(\"can't self-join\");\n+            }\n+            this.id = id;\n+            final StringBuilder sb = new StringBuilder(predecessor.getSequence());\n+            final CharSequence successorSequence = successor.getSequence();\n+            sb.append(successorSequence.subSequence(Kmer.KSIZE - 1, successorSequence.length()));\n+            this.sequence = sb.toString();\n+            this.maxObservations =\n+                    Math.max(predecessor.getMaxObservations(), successor.getMaxObservations());\n+            this.firstKmer = predecessor.getFirstKmer();\n+            this.lastKmer = successor.getLastKmer();\n+            this.predecessors = new ArrayList<>(predecessor.getPredecessors().size());\n+            this.successors = new ArrayList<>(successor.getSuccessors().size());\n+            this.rc = new ContigRCImpl(this);\n+\n+            // fix predecessor linkages to point to new contig\n+            for ( final Contig predPredecessor : predecessor.getPredecessors() ) {\n+                if ( predPredecessor == successor ) {\n+                    predecessors.add(this);\n+                } else if ( predPredecessor == predecessor.rc() ) {\n+                    predecessors.add(rc);\n+                } else {\n+                    predecessors.add(predPredecessor);\n+                    final List<Contig> successors = predPredecessor.getSuccessors();\n+                    successors.set(successors.indexOf(predecessor), this);\n+                }\n+            }\n+\n+            // fix successor linkages to point to new contig\n+            for ( final Contig succSuccessor : successor.getSuccessors() ) {\n+                if ( succSuccessor == predecessor ) {\n+                    successors.add(this);\n+                } else if ( succSuccessor == successor.rc() ) {\n+                    successors.add(rc);\n+                } else {\n+                    successors.add(succSuccessor);\n+                    final List<Contig> predecessors = succSuccessor.getPredecessors();\n+                    predecessors.set(predecessors.indexOf(successor), this);\n+                }\n+            }\n+        }\n+\n+        @Override public int getId() { return id; }\n+        @Override public CharSequence getSequence() { return sequence; }\n+        @Override public int getMaxObservations() { return maxObservations; }\n+        @Override public KmerAdjacency getFirstKmer() { return firstKmer; }\n+        @Override public KmerAdjacency getLastKmer() { return lastKmer; }\n+        @Override public List<Contig> getPredecessors() { return predecessors; }\n+        @Override public List<Contig> getSuccessors() { return successors; }\n+        @Override public int getComponentId() { return componentId; }\n+        public void setComponentId( final int id ) { this.componentId = id; }\n+        @Override public int size() { return sequence.length(); }\n+        @Override public Contig rc() { return rc; }\n+        @Override public boolean isCyclic() { return cyclic; }\n+        @Override public void setCyclic( final boolean cyclic ) { this.cyclic = cyclic; }\n+        @Override public boolean isCut() { return cut; }\n+        @Override public void setCut( final boolean cut ) { this.cut = cut; }\n+        @Override public boolean isCanonical() { return true; }\n+        @Override public ContigImpl canonical() { return this; }\n+        @Override public String toString() { return \"c\" + id; }\n+    }\n+\n+    /**\n+     * Implementation of Contig for the reverse-complement of some other Contig.\n+     * Which one is the \"real\" Contig, and which is the \"RC\" is completely arbitrary, since there\n+     * is no notion of canonical for Contigs.\n+     **/\n+    public static final class ContigRCImpl implements Contig {\n+        private final CharSequence sequence;\n+        private final List<Contig> predecessors;\n+        private final List<Contig> successors;\n+        private final ContigImpl rc;\n+\n+        public ContigRCImpl( final ContigImpl contig ) {\n+            this.sequence = new SequenceRC(contig.getSequence());\n+            this.predecessors = new ContigListRC(contig.getSuccessors());\n+            this.successors = new ContigListRC(contig.getPredecessors());\n+            this.rc = contig;\n+        }\n+\n+        @Override public int getId() { return ~rc.getId(); }\n+        @Override public CharSequence getSequence() { return sequence; }\n+        @Override public int getMaxObservations() { return rc.getMaxObservations(); }\n+        @Override public KmerAdjacency getFirstKmer() { return rc.getLastKmer().rc(); }\n+        @Override public KmerAdjacency getLastKmer() { return rc.getFirstKmer().rc(); }\n+        @Override public List<Contig> getPredecessors() { return predecessors; }\n+        @Override public List<Contig> getSuccessors() { return successors; }\n+        @Override public int getComponentId() { return rc.getComponentId(); }\n+        @Override public int size() { return sequence.length(); }\n+        @Override public Contig rc() { return rc; }\n+        @Override public boolean isCyclic() { return rc.isCyclic(); }\n+        @Override public void setCyclic( final boolean cyclic ) { rc.setCyclic(cyclic); }\n+        @Override public boolean isCut() { return rc.isCut(); }\n+        @Override public void setCut( final boolean cut ) { rc.setCut(cut); }\n+        @Override public boolean isCanonical() { return false; }\n+        @Override public ContigImpl canonical() { return rc; }\n+        @Override public String toString() { return rc.toString() + \"RC\"; }\n+    }\n+\n+    /** A CharSequence that is a view of the reverse-complement of another sequence. **/\n+    public static final class SequenceRC implements CharSequence, Comparable<CharSequence> {\n+        private final int lenLess1;\n+        private final CharSequence sequence;\n+\n+        public SequenceRC( final CharSequence sequence ) {\n+            this.lenLess1 = sequence.length() - 1;\n+            this.sequence = sequence;\n+        }\n+\n+        @Override public int length() { return sequence.length(); }\n+        @Override public char charAt( final int index ) {\n+            final char result;\n+            switch ( Character.toUpperCase(sequence.charAt(lenLess1 - index)) ) {\n+                case 'A': result = 'T'; break;\n+                case 'C': result = 'G'; break;\n+                case 'G': result = 'C'; break;\n+                case 'T': result = 'A'; break;\n+                default: result = 'N'; break;\n+            }\n+            return result;\n+        }\n+        @Override public CharSequence subSequence( final int start, final int end ) {\n+            return new StringBuilder(end - start).append(this, start, end).toString();\n+        }\n+        @Override public String toString() { return new StringBuilder(this).toString(); }\n+\n+        @Override public int compareTo( final CharSequence charSequence ) {\n+            final int len1 = length();\n+            final int len2 = charSequence.length();\n+            final int cmpLen = Math.min(len1, len2);\n+            for ( int idx = 0; idx != cmpLen; ++idx ) {\n+                final char char1 = charAt(idx);\n+                final char char2 = Character.toUpperCase(charSequence.charAt(idx));\n+                if ( char1 > char2 ) return 1;\n+                if ( char1 < char2 ) return -1;\n+            }\n+            return Integer.compare(len1, len2);\n+        }\n+    }\n+\n+    /** A list of Contigs that presents a reverse-complemented view of a List of Contigs. **/\n+    public static final class ContigListRC extends AbstractList<Contig> {\n+        private final List<Contig> contigList;\n+\n+        public ContigListRC( final List<Contig> contigList ) {\n+            this.contigList = contigList;\n+        }\n+\n+        @Override public Contig get( final int index ) {\n+            return contigList.get(reflectIndex(index)).rc();\n+        }\n+        @Override public int size() { return contigList.size(); }\n+        @Override public Contig set( final int index, final Contig contig ) {\n+            return contigList.set(reflectIndex(index), contig.rc()).rc();\n+        }\n+        @Override public void add( final int index, final Contig contig ) {\n+            contigList.add(reflectIndex(index), contig.rc());\n+        }\n+        @Override public Contig remove( final int index ) {\n+            return contigList.remove(reflectIndex(index)).rc();\n+        }\n+\n+        private int reflectIndex( final int index ) { return size() - 1 - index; }\n+    }\n+\n+    /** A single-Contig portion of a path across the assembly graph. **/\n+    public interface PathPart {\n+        Contig getContig(); // will be null for PathParts that depart from the graph (PathPartGap)\n+        CharSequence getSequence(); // will be null for PathParts on the graph (PathPartContig)\n+        void extend( final char call );\n+        int getStart();\n+        int getStop();\n+        boolean isGap();\n+        int getLength();\n+        PathPart rc();\n+        char getFirstCall();\n+        char getLastCall();\n+        default boolean startsAtBeginning() { return getStart() == 0; }\n+        default boolean stopsAtEnd() { return getStop() + Kmer.KSIZE - 1 == getContig().size(); }\n+    }\n+\n+    /** A part of a path that isn't present in the graph. **/\n+    public static final class PathPartGap implements PathPart {\n+        private final StringBuilder sequence = new StringBuilder();\n+\n+        public PathPartGap( final KmerAdjacency kmer ) { sequence.append(kmer.toString()); }\n+        private PathPartGap( final CharSequence sequence ) { this.sequence.append(sequence); }\n+\n+        @Override public Contig getContig() { return null; }\n+        @Override public CharSequence getSequence() { return sequence.toString(); }\n+        @Override public void extend( final char call ) { sequence.append(call); }\n+        @Override public int getStart() { return 0; }\n+        @Override public int getStop() { return sequence.length(); }\n+        @Override public boolean isGap() { return true; }\n+        @Override public int getLength() { return sequence.length() - Kmer.KSIZE + 1; }\n+        @Override public PathPart rc() { return new PathPartGap(new SequenceRC(sequence)); }\n+        @Override public char getFirstCall() { return sequence.charAt(Kmer.KSIZE - 1); }\n+        @Override public char getLastCall() {\n+            return sequence.charAt(sequence.length() - Kmer.KSIZE + 1);\n+        }\n+    }\n+\n+    /** A part of a path that is present as a sub-sequence of some Contig. **/\n+    public static final class PathPartContig implements PathPart {\n+        private final Contig contig;\n+        private final int start;\n+        private int stop;\n+\n+        public PathPartContig( final Contig contig, final int start ) {\n+            this(contig, start, start+1);\n+        }\n+        public PathPartContig( final Contig contig, final int start, final int stop ) {\n+            this.contig = contig;\n+            this.start = start;\n+            this.stop = stop;\n+        }\n+\n+        @Override public Contig getContig() { return contig; }\n+        @Override public String getSequence() { return null; }\n+        @Override public void extend( final char call ) { stop += 1; }\n+        @Override public int getStart() { return start; }\n+        @Override public int getStop() { return stop; }\n+        @Override public boolean isGap() { return false; }\n+        @Override public int getLength() { return stop - start; }\n+        @Override public PathPart rc() {\n+            final int revBase = contig.size() - Kmer.KSIZE + 1;\n+            return new PathPartContig(contig.rc(), revBase - stop, revBase - start);\n+        }\n+        @Override public char getFirstCall() {\n+            return getContig().getSequence().charAt(start + Kmer.KSIZE - 1);\n+        }\n+        @Override public char getLastCall() { return getContig().getSequence().charAt(stop - 1); }\n+    }\n+\n+    /** A path through the assembly graph for something (probably a read). **/\n+    public static final class Path {\n+        private final List<PathPart> parts;\n+\n+        public Path( final byte[] calls,\n+                     final KmerSet<KmerAdjacency> kmerAdjacencySet ) {\n+            parts = new ArrayList<>();\n+            long kVal = 0;\n+            int count = 0;\n+            PathPart currentPathPart = null;\n+            for ( int idx = 0; idx != calls.length; ++idx ) {\n+                final char call = (char)calls[idx];\n+                kVal <<= 2;\n+                switch ( call ) {\n+                    case 'C': case 'c': kVal += 1; break;\n+                    case 'G': case 'g': kVal += 2; break;\n+                    case 'T': case 't': kVal += 3; break;\n+                }\n+                if ( ++count >= Kmer.KSIZE ) {\n+                    final KmerAdjacency kmer = KmerAdjacencyImpl.find(kVal, kmerAdjacencySet);\n+                    // if we fail to look up the kmer\n+                    if ( kmer == null ) {\n+                        if ( currentPathPart == null ) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e2201c1ef4f8ba71f17e169f07756cfe2f1ecb49"}, "originalPosition": 2013}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzc3NjkzNzI3OnYy", "diffSide": "RIGHT", "path": "src/main/java/org/broadinstitute/hellbender/tools/LocalAssembler.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMy0xOVQyMDowMTozOFrOI6PlJw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNC0xNVQyMToyNzo0M1rOJJ8J8A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5Nzk0MzU5MQ==", "bodyText": "I am confused about how this can happen. Should it be an error condition?", "url": "https://github.com/broadinstitute/gatk/pull/6989#discussion_r597943591", "createdAt": "2021-03-19T20:01:38Z", "author": {"login": "cwhelan"}, "path": "src/main/java/org/broadinstitute/hellbender/tools/LocalAssembler.java", "diffHunk": "@@ -0,0 +1,2306 @@\n+package org.broadinstitute.hellbender.tools;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import htsjdk.samtools.Cigar;\n+import htsjdk.samtools.CigarElement;\n+import htsjdk.samtools.CigarOperator;\n+import htsjdk.samtools.SAMUtils;\n+import org.broadinstitute.barclay.argparser.Argument;\n+import org.broadinstitute.barclay.argparser.BetaFeature;\n+import org.broadinstitute.barclay.argparser.CommandLineProgramProperties;\n+import org.broadinstitute.barclay.help.DocumentedFeature;\n+import org.broadinstitute.hellbender.cmdline.StandardArgumentDefinitions;\n+import org.broadinstitute.hellbender.cmdline.programgroups.CoverageAnalysisProgramGroup;\n+import org.broadinstitute.hellbender.exceptions.GATKException;\n+import org.broadinstitute.hellbender.tools.walkers.PairWalker;\n+import org.broadinstitute.hellbender.utils.SimpleInterval;\n+import org.broadinstitute.hellbender.utils.collections.HopscotchSet;\n+import org.broadinstitute.hellbender.utils.gcs.BucketUtils;\n+import org.broadinstitute.hellbender.utils.read.GATKRead;\n+\n+import java.io.BufferedWriter;\n+import java.io.FileWriter;\n+import java.io.IOException;\n+import java.io.OutputStreamWriter;\n+import java.util.*;\n+import java.util.zip.GZIPOutputStream;\n+\n+@DocumentedFeature\n+@CommandLineProgramProperties(\n+        summary = \"experiment\",\n+        oneLineSummary = \"experiment\",\n+        usageExample = \"gatk LocalAssembler\",\n+        programGroup = CoverageAnalysisProgramGroup.class\n+)\n+@BetaFeature\n+public class LocalAssembler extends PairWalker {\n+    public static final byte QMIN = 25;\n+    public static final int MIN_THIN_OBS = 4;\n+    public static final int MIN_GAPFILL_COUNT = 3;\n+    public static final int TOO_MANY_TRAVERSALS = 100000;\n+    public static final int TOO_MANY_SCAFFOLDS = 50000;\n+    public static final int MIN_SV_SIZE = 50;\n+\n+    @Argument(fullName=StandardArgumentDefinitions.OUTPUT_LONG_NAME,\n+            shortName=StandardArgumentDefinitions.OUTPUT_SHORT_NAME,\n+            doc=\"Write outputs to this file name prefix\", optional = true)\n+    public static String output;\n+\n+    @Argument(fullName=\"assembly-name\", doc=\"name of assembly used as a prefix for traversal names\")\n+    public static String assemblyName;\n+\n+    private final List<GATKRead> reads = new ArrayList<>();\n+\n+    @Override public boolean requiresIntervals() { return true; }\n+\n+    @Override public void apply( final GATKRead read, final GATKRead mate ) {\n+        trimOverruns(read, mate);\n+        reads.add(read);\n+        reads.add(mate);\n+    }\n+\n+    @Override public void applyUnpaired( final GATKRead read ) {\n+        reads.add(read);\n+    }\n+\n+    @Override public Object onTraversalSuccess() {\n+        super.onTraversalSuccess(); // flush any incomplete pairs\n+\n+        final int regionSize = getTraversalIntervals().stream().mapToInt(SimpleInterval::size).sum();\n+        final KmerSet<KmerAdjacency> kmerAdjacencySet = new KmerSet<>(10 * regionSize);\n+        kmerizeReads(reads, kmerAdjacencySet);\n+        List<ContigImpl> contigs = buildContigs(kmerAdjacencySet);\n+        connectContigs(contigs);\n+\n+        removeThinContigs(contigs, kmerAdjacencySet);\n+        weldPipes(contigs);\n+        markComponents(contigs);\n+\n+        if ( fillGaps(kmerAdjacencySet, reads) ) {\n+            contigs = buildContigs(kmerAdjacencySet);\n+            connectContigs(contigs);\n+            removeThinContigs(contigs, kmerAdjacencySet);\n+            weldPipes(contigs);\n+            markComponents(contigs);\n+        }\n+\n+        markCycles(contigs);\n+\n+        final String outputFilePrefix = output != null ? output : assemblyName;\n+        final List<Path> readPaths = pathReads(kmerAdjacencySet, reads);\n+        final Map<Contig,List<TransitPairCount>> contigTransitsMap =\n+                collectTransitPairCounts(contigs, readPaths);\n+        final String traversalsFilename = outputFilePrefix + \".traversals.fa.gz\";\n+        try {\n+            final List<Traversal> allTraversals =\n+                    new ArrayList<>(traverseAllPaths(contigs, readPaths, contigTransitsMap));\n+            writeTraversals(allTraversals, traversalsFilename);\n+            try {\n+                final String scaffoldsFileName = outputFilePrefix + \".scaffolds.fa.gz\";\n+                writeTraversals(createScaffolds(allTraversals), scaffoldsFileName);\n+            } catch ( final AssemblyTooComplexException x ) {\n+                logger.warn(\"Assembly too complex for scaffolding.\");\n+            }\n+        } catch ( final AssemblyTooComplexException x ) {\n+            logger.warn(\"Assembly too complex.  Writing contigs as traversals in \" +\n+                    traversalsFilename + \".\");\n+            final Collection<Traversal> contigTraversals = new ArrayList<>(contigs.size());\n+            for ( final Contig contig : contigs ) {\n+                contigTraversals.add(new Traversal(Collections.singletonList(contig)));\n+            }\n+            writeTraversals(contigTraversals, traversalsFilename);\n+        }\n+\n+        contigs.sort(Comparator.comparingInt(ContigImpl::getId));\n+        writeDOT(contigs, outputFilePrefix + \".assembly.dot\");\n+        writeContigs(contigs, outputFilePrefix + \".contigs.txt.gz\");\n+        writePaths(readPaths, outputFilePrefix + \".paths.txt.gz\");\n+        writeReads(reads, outputFilePrefix + \".reads.fastq.gz\");\n+        return null;\n+    }\n+\n+    /** trim read pairs of base calls that have gone past the end of a short fragment */\n+    private void trimOverruns( final GATKRead read, final GATKRead mate ) {\n+        // if both mapped and they're on different strands\n+        if ( !read.isUnmapped() && !mate.isUnmapped() &&\n+                read.isReverseStrand() != mate.isReverseStrand() ) {\n+            // and both start within 1 base on the ref\n+            if ( Math.abs(read.getStart() - read.getMateStart()) <= 1 ) {\n+                // and both end within 1 base\n+                final int readRefLen = read.getCigar().getReferenceLength();\n+                final int mateRefLen = mate.getCigar().getReferenceLength();\n+                if ( Math.abs(readRefLen - mateRefLen) <= 1 ) {\n+                    if ( mate.isReverseStrand() ) {\n+                        trimClips(read, mate);\n+                    } else {\n+                        trimClips(mate, read);\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    private void trimClips( final GATKRead fwd, final GATKRead rev ) {\n+        final List<CigarElement> fwdElements = fwd.getCigarElements();\n+        final List<CigarElement> revElements = rev.getCigarElements();\n+        final int lastElementIdx = fwdElements.size() - 1;\n+        final CigarElement fwdLastElement = fwdElements.get(lastElementIdx);\n+        final CigarElement revFirstElement = revElements.get(0);\n+        if ( fwdLastElement.getOperator() == CigarOperator.S &&\n+                revFirstElement.getOperator() == CigarOperator.S ) {\n+            final byte[] fwdBases = fwd.getBasesNoCopy();\n+            final int lastElementLen = fwdLastElement.getLength();\n+            fwd.setBases(Arrays.copyOfRange(fwdBases, 0, fwdBases.length - lastElementLen));\n+            final byte[] fwdQuals = fwd.getBaseQualitiesNoCopy();\n+            if ( fwdQuals.length > 0 ) {\n+                final int qualsLen = fwdQuals.length - lastElementLen;\n+                fwd.setBaseQualities(Arrays.copyOfRange(fwdQuals, 0, qualsLen));\n+            }\n+            final List<CigarElement> newFwdElements = new ArrayList<>(fwdElements);\n+            newFwdElements.set(lastElementIdx, new CigarElement(lastElementLen, CigarOperator.H));\n+            fwd.setCigar(new Cigar(newFwdElements));\n+\n+            final byte[] revBases = rev.getBasesNoCopy();\n+            final int firstElementLen = revFirstElement.getLength();\n+            rev.setBases(Arrays.copyOfRange(revBases, firstElementLen, revBases.length));\n+            final byte[] revQuals = rev.getBaseQualitiesNoCopy();\n+            if ( revQuals.length > 0 ) {\n+                rev.setBaseQualities(Arrays.copyOfRange(revQuals, firstElementLen, revQuals.length));\n+            }\n+            final List<CigarElement> newRevElements = new ArrayList<>(revElements);\n+            newRevElements.set(0, new CigarElement(firstElementLen, CigarOperator.H));\n+            rev.setCigar(new Cigar(newRevElements));\n+        }\n+    }\n+\n+    @VisibleForTesting\n+    static void kmerizeReads( final List<GATKRead> reads,\n+                              final KmerSet<KmerAdjacency> kmerAdjacencySet ) {\n+        for ( final GATKRead read : reads ) {\n+            final byte[] calls = read.getBasesNoCopy();\n+            final byte[] quals = read.getBaseQualitiesNoCopy();\n+            KmerAdjacency.kmerize(calls, quals, QMIN, kmerAdjacencySet);\n+        }\n+    }\n+\n+    /** gather unbranched strings of kmers into contigs **/\n+    @VisibleForTesting\n+    static List<ContigImpl> buildContigs( final KmerSet<KmerAdjacency> kmerAdjacencySet ) {\n+        // gather strings of kmers that have a single predecessor and single successor into contigs\n+        final List<ContigImpl> contigs = new ArrayList<>();\n+        int nContigs = 0;\n+        for ( final KmerAdjacency kmerAdjacency : kmerAdjacencySet ) {\n+            if ( kmerAdjacency.getContig() == null ) {\n+                ContigImpl contig = null;\n+                final KmerAdjacency predecessor = kmerAdjacency.getSolePredecessor();\n+                if ( predecessor == null ||\n+                        predecessor.getSuccessorCount() > 1 ||\n+                        predecessor == kmerAdjacency.rc() ) {\n+                    contig = new ContigImpl(++nContigs, kmerAdjacency);\n+                } else {\n+                    final KmerAdjacency successor = kmerAdjacency.getSoleSuccessor();\n+                    if ( successor == null ||\n+                            successor.getPredecessorCount() > 1 ||\n+                            successor == kmerAdjacency.rc() ) {\n+                        contig = new ContigImpl(++nContigs, kmerAdjacency.rc());\n+                    }\n+                }\n+                if ( contig != null ) {\n+                    contigs.add(contig);\n+                }\n+            }\n+        }\n+\n+        // if there are smooth circles like a plasmid, gather them together as a contig, too\n+        for ( final KmerAdjacency kmerAdjacency : kmerAdjacencySet ) {\n+            if ( kmerAdjacency.getContig() == null ) {\n+                contigs.add(new ContigImpl(++nContigs, kmerAdjacency));\n+            }\n+        }\n+\n+        return contigs;\n+    }\n+\n+    /** connect contigs when the final kmer of one contig is adjacent to the inital contig of another **/\n+    @VisibleForTesting\n+    static void connectContigs( final List<ContigImpl> contigs ) {\n+        final int nContigs = contigs.size();\n+        final KmerSet<ContigEndKmer> contigEnds = new KmerSet<>(2*nContigs);\n+        for ( int contigId = 0; contigId != nContigs; ++contigId ) {\n+            final ContigImpl contig = contigs.get(contigId);\n+            final KmerAdjacency fwdKmer = contig.getFirstKmer();\n+            final KmerAdjacency revKmer = contig.getLastKmer().rc();\n+            if ( fwdKmer == revKmer ) {\n+                contigEnds.add(new ContigEndKmer(fwdKmer.getKVal(), contig, ContigOrientation.BOTH));\n+            } else {\n+                contigEnds.add(new ContigEndKmer(fwdKmer.getKVal(), contig, ContigOrientation.FWD));\n+                contigEnds.add(new ContigEndKmer(revKmer.getKVal(), contig, ContigOrientation.REV));\n+            }\n+        }\n+\n+        for ( int contigId = 0; contigId != nContigs; ++contigId ) {\n+            final Contig contig = contigs.get(contigId);\n+\n+            final KmerAdjacency start = contig.getFirstKmer();\n+            final int predecessorCount = start.getPredecessorCount();\n+            if ( predecessorCount > 0 ) {\n+                final List<Contig> predecessors = contig.getPredecessors();\n+                final int mask = start.getPredecessorMask();\n+                for ( int call = 0; call != 4; ++call ) {\n+                    if ( (mask & (1 << call)) != 0 ) {\n+                        final long kVal =\n+                                KmerAdjacency.reverseComplement(start.getPredecessorVal(call));\n+                        final ContigEndKmer contigEndKmer = contigEnds.find(new Kmer(kVal));\n+                        if ( contigEndKmer == null ) {\n+                            throw new GATKException(\"missing contig end kmer\");\n+                        }\n+                        switch ( contigEndKmer.getContigOrientation() ) {\n+                            case FWD:\n+                                predecessors.add(contigEndKmer.getContig().rc());\n+                                break;\n+                            case REV:\n+                                predecessors.add(contigEndKmer.getContig());\n+                                break;\n+                            case BOTH:\n+                                predecessors.add(contigEndKmer.getContig());\n+                                predecessors.add(contigEndKmer.getContig().rc());\n+                                break;\n+                        }\n+                    }\n+                }\n+            }\n+\n+            final KmerAdjacency end = contig.getLastKmer();\n+            final int successorCount = end.getSuccessorCount();\n+            if ( successorCount > 0 ) {\n+                final List<Contig> successors = contig.getSuccessors();\n+                final int mask = end.getSuccessorMask();\n+                for ( int call = 0; call != 4; ++call ) {\n+                    if ( (mask & (1 << call)) != 0 ) {\n+                        final long kVal = end.getSuccessorVal(call);\n+                        final ContigEndKmer contigEndKmer = contigEnds.find(new Kmer(kVal));\n+                        if ( contigEndKmer == null ) {\n+                            throw new GATKException(\"missing contig end kmer\");\n+                        }\n+                        switch ( contigEndKmer.getContigOrientation() ) {\n+                            case FWD:\n+                                successors.add(contigEndKmer.getContig());\n+                                break;\n+                            case REV:\n+                                successors.add(contigEndKmer.getContig().rc());\n+                                break;\n+                            case BOTH:\n+                                successors.add(contigEndKmer.getContig());\n+                                successors.add(contigEndKmer.getContig().rc());\n+                                break;\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    /** remove contigs that have little evidence **/\n+    @VisibleForTesting\n+    static void removeThinContigs( final List<ContigImpl> contigs,\n+                                           final KmerSet<KmerAdjacency> kmerAdjacencySet ) {\n+        contigs.sort(Comparator.comparingInt(ContigImpl::getMaxObservations));\n+        boolean contigRemoved;\n+        do {\n+            // figure out which contigs are cut points\n+            // i.e., those contigs which, if removed, would result in a graph with more connected components\n+            final int nContigs = contigs.size();\n+            final Map<Contig, CutData> cutDataMap = new HashMap<>(nContigs * 3);\n+\n+            for ( final ContigImpl contig : contigs ) {\n+                if ( cutDataMap.containsKey(contig) ) {\n+                    continue;\n+                }\n+\n+                cutDataMap.put(contig, new CutData());\n+                int children = 0;\n+                for ( final Contig nextContig : contig.getSuccessors() ) {\n+                    if ( !cutDataMap.containsKey(nextContig) ) {\n+                        findCuts(nextContig, contig, cutDataMap);\n+                        children += 1;\n+                    }\n+                }\n+                for ( final Contig nextContig : contig.getPredecessors() ) {\n+                    if ( !cutDataMap.containsKey(nextContig) ) {\n+                        findCuts(nextContig, contig, cutDataMap);\n+                        children += 1;\n+                    }\n+                }\n+                if ( children >= 2 ) {\n+                    contig.setCut(true);\n+                }\n+            }\n+\n+            // remove poorly attested (low max observations) contigs, unless they are cut points\n+            contigRemoved = false;\n+            final Iterator<ContigImpl> itr = contigs.iterator();\n+            while ( itr.hasNext() ) {\n+                final Contig contig = itr.next();\n+                if ( contig.getMaxObservations() < MIN_THIN_OBS && !contig.isCut() ) {\n+                    unlinkContig(contig, kmerAdjacencySet);\n+                    itr.remove();\n+                    contigRemoved = true;\n+                    break;\n+                }\n+            }\n+        } while ( contigRemoved );\n+        contigs.sort(Comparator.comparingInt(ContigImpl::getId));\n+    }\n+\n+    private static CutData findCuts( final Contig contig,\n+                                     final Contig parent,\n+                                     final Map<Contig, CutData> cutDataMap ) {\n+        final CutData cutData = new CutData();\n+        cutDataMap.put(contig, cutData);\n+        for ( final Contig nextContig : contig.getSuccessors() ) {\n+            if ( nextContig == parent ) {\n+                continue;\n+            }\n+            CutData nextCutData = cutDataMap.get(nextContig);\n+            if ( nextCutData != null ) {\n+                cutData.minVisitNum = Math.min(cutData.minVisitNum, nextCutData.visitNum);\n+            } else {\n+                nextCutData = findCuts(nextContig, contig, cutDataMap);\n+                cutData.minVisitNum = Math.min(cutData.minVisitNum, nextCutData.minVisitNum);\n+                if ( nextCutData.minVisitNum >= cutData.visitNum ) {\n+                    contig.setCut(true);\n+                }\n+            }\n+        }\n+        for ( final Contig nextContig : contig.getPredecessors() ) {\n+            if ( nextContig == parent ) {\n+                continue;\n+            }\n+            CutData nextCutData = cutDataMap.get(nextContig);\n+            if ( nextCutData != null ) {\n+                cutData.minVisitNum = Math.min(cutData.minVisitNum, nextCutData.visitNum);\n+            } else {\n+                nextCutData = findCuts(nextContig, contig, cutDataMap);\n+                cutData.minVisitNum = Math.min(cutData.minVisitNum, nextCutData.minVisitNum);\n+                if ( nextCutData.minVisitNum >= cutData.visitNum ) {\n+                    contig.setCut(true);\n+                }\n+            }\n+        }\n+        return cutData;\n+    }\n+\n+    @VisibleForTesting\n+    static void unlinkContig( final Contig contig,\n+                                      final KmerSet<KmerAdjacency> kmerAdjacencySet ) {\n+        final KmerAdjacency firstKmer = contig.getFirstKmer();\n+        final int firstKmerFinalCall = firstKmer.getFinalCall();\n+        for ( final Contig predecessor : contig.getPredecessors() ) {\n+            if ( predecessor != contig && predecessor != contig.rc() ) {\n+                predecessor.getLastKmer().removeSuccessor(firstKmerFinalCall, kmerAdjacencySet);\n+                if ( !predecessor.getSuccessors().remove(contig) ) {\n+                    throw new GATKException(\"failed to find predecessor link\");\n+                }\n+            }\n+        }\n+\n+        final KmerAdjacency lastKmer = contig.getLastKmer();\n+        final int lastKmerInitialCall = lastKmer.getInitialCall();\n+        for ( final Contig successor : contig.getSuccessors() ) {\n+            if ( successor != contig && successor != contig.rc() ) {\n+                successor.getFirstKmer().removePredecessor(lastKmerInitialCall, kmerAdjacencySet);\n+                if ( !successor.getPredecessors().remove(contig) ) {\n+                    throw new GATKException(\"failed to find successor link\");\n+                }\n+            }\n+        }\n+\n+        KmerAdjacency nextKmer = firstKmer;\n+        KmerAdjacency kmer;\n+        do {\n+            kmer = nextKmer;\n+            nextKmer = kmer.getSoleSuccessor();\n+            kmerAdjacencySet.remove(kmer.canonical());\n+        } while ( kmer != lastKmer );\n+    }\n+\n+    private static void updateKmerContig( final KmerAdjacency firstKmer,\n+                                          final KmerAdjacency lastKmer,\n+                                          final Contig contig ) {\n+        int offset = 0;\n+        for ( KmerAdjacency kmer = firstKmer; kmer != lastKmer; kmer = kmer.getSoleSuccessor() ) {\n+            if ( kmer == null ) {\n+                throw new GATKException(\"contig does not have a flat pipeline of kmers\");\n+            }\n+            kmer.clearContig();\n+            kmer.setContigOffset(contig, offset++);\n+        }\n+        lastKmer.clearContig();\n+        lastKmer.setContigOffset(contig, offset);\n+        if ( offset + Kmer.KSIZE != contig.size() ) {\n+            throw new GATKException(\"kmer chain length does not equal contig size\");\n+        }\n+    }\n+\n+    /** replace adjacent contigs without branches with a single, larger contig **/\n+    @VisibleForTesting\n+    static void weldPipes( final List<ContigImpl> contigs ) {\n+        for ( int contigIdx = 0; contigIdx != contigs.size(); ++contigIdx ) {\n+            final ContigImpl contig = contigs.get(contigIdx);\n+            if ( contig.getSuccessors().size() == 1 ) {\n+                final Contig successor = contig.getSuccessors().get(0);\n+                if ( successor != contig && successor != contig.rc() &&\n+                        successor.getPredecessors().size() == 1 ) {\n+                    contigs.set(contigIdx, join(contig.getId(), contig, successor));\n+                    if ( !contigs.remove(successor.canonical()) ) {\n+                        throw new GATKException(\"successor linkage is messed up\");\n+                    }\n+                    contigIdx -= 1; // reconsider the new contig -- there might be more joining possible\n+                    continue;\n+                }\n+            }\n+            if ( contig.getPredecessors().size() == 1 ) {\n+                final Contig predecessor = contig.getPredecessors().get(0);\n+                if ( predecessor != contig && predecessor != contig.rc() &&\n+                        predecessor.getSuccessors().size() == 1 ) {\n+                    contigs.set(contigIdx, join(contig.getId(), predecessor, contig));\n+                    if ( !contigs.remove(predecessor.canonical()) ) {\n+                        throw new GATKException(\"predecessor linkage is messed up\");\n+                    }\n+                    contigIdx -= 1; // reconsider\n+                }\n+            }\n+        }\n+    }\n+\n+    private static ContigImpl join( final int id, final Contig predecessor, final Contig successor ) {\n+        if ( !checkOverlap(predecessor.getSequence(), successor.getSequence()) ) {\n+                throw new GATKException(\"sequences can't be joined\");\n+        }\n+        final ContigImpl joinedContig = new ContigImpl(id, predecessor, successor);\n+        updateKmerContig(joinedContig.getFirstKmer(), joinedContig.getLastKmer(), joinedContig);\n+        return joinedContig;\n+    }\n+\n+    private static boolean checkOverlap( final CharSequence seq1, final CharSequence seq2 ) {\n+        final int seq1Len = seq1.length();\n+        final CharSequence seq1SubSeq = seq1.subSequence(seq1Len - Kmer.KSIZE + 1, seq1Len);\n+        final CharSequence seq2SubSeq = seq2.subSequence(0, Kmer.KSIZE - 1);\n+        return seq1SubSeq.equals(seq2SubSeq);\n+    }\n+\n+    /** set a unique componentId for every connected group of contigs **/\n+    @VisibleForTesting\n+    static int markComponents( final List<ContigImpl> contigs ) {\n+        for ( final ContigImpl contig : contigs ) {\n+            contig.setComponentId(0);\n+        }\n+\n+        int componentId = 0;\n+        for ( final ContigImpl contig : contigs ) {\n+            if ( contig.getComponentId() == 0 ) {\n+                contig.setComponentId(++componentId);\n+                markSuccessorComponents(contig);\n+                markSuccessorComponents(contig.rc());\n+            }\n+        }\n+        return componentId;\n+    }\n+\n+    private static void markSuccessorComponents( final Contig contig ) {\n+        final int componentId = contig.getComponentId();\n+        for ( final Contig successor : contig.getSuccessors() ) {\n+            if ( successor.getComponentId() == 0 ) {\n+                successor.canonical().setComponentId(componentId);\n+                markSuccessorComponents(successor);\n+                markSuccessorComponents(successor.rc());\n+            }\n+        }\n+    }\n+\n+    @VisibleForTesting\n+    static void markCycles( final List<ContigImpl> contigs ) {\n+        for ( final Contig contig : contigs ) {\n+            contig.setCyclic(false);\n+        }\n+\n+        final int nContigs = contigs.size();\n+        final Deque<Contig> deque = new ArrayDeque<>(nContigs);\n+        final Map<Contig, CutData> cutDataMap = new HashMap<>(nContigs * 3);\n+        for ( final Contig contig : contigs ) {\n+            if ( !cutDataMap.containsKey(contig) ) {\n+                markCyclesRecursion(contig, deque, cutDataMap);\n+            }\n+        }\n+    }\n+\n+    private static CutData markCyclesRecursion( final Contig contig,\n+                                                final Deque<Contig> deque,\n+                                                final Map<Contig, CutData> cutDataMap ) {\n+        final CutData cutData = new CutData();\n+        cutDataMap.put(contig, cutData);\n+        deque.addFirst(contig);\n+\n+        for ( final Contig successor : contig.getSuccessors() ) {\n+            final CutData successorCutData = cutDataMap.get(successor);\n+            if ( successorCutData == null ) {\n+                final int recursionVisitNum =\n+                        markCyclesRecursion(successor, deque, cutDataMap).minVisitNum;\n+                cutData.minVisitNum = Math.min(cutData.minVisitNum, recursionVisitNum);\n+            } else {\n+                cutData.minVisitNum = Math.min(cutData.minVisitNum, successorCutData.visitNum);\n+            }\n+        }\n+\n+        if ( cutData.visitNum == cutData.minVisitNum ) {\n+            Contig tig = deque.removeFirst();\n+            if ( tig == contig ) {\n+                cutDataMap.get(tig).visitNum = Integer.MAX_VALUE;\n+\n+                // single-vertex component -- cyclic only if self-referential\n+                if ( tig.getSuccessors().contains(tig) ) {\n+                    tig.setCyclic(true);\n+                }\n+            } else {\n+                while ( true ) {\n+                    // kill cross-links\n+                    cutDataMap.get(tig).visitNum = Integer.MAX_VALUE;\n+                    tig.setCyclic(true);\n+                    if ( tig == contig ) break;\n+                    tig = deque.removeFirst();\n+                }\n+            }\n+        }\n+        return cutData;\n+    }\n+\n+    @VisibleForTesting\n+    static boolean fillGaps( final KmerSet<KmerAdjacency> kmerAdjacencySet,\n+                             final List<GATKRead> reads ) {\n+        final Map<String, Integer> gapFillCounts = new HashMap<>();\n+        for ( final GATKRead read : reads ) {\n+            final Path path = new Path(read.getBasesNoCopy(), kmerAdjacencySet);\n+            final List<PathPart> parts = path.getParts();\n+            final int lastIdx = parts.size() - 1;\n+            for ( int idx = 1; idx < lastIdx; ++idx ) {\n+                final PathPart pathPart = parts.get(idx);\n+                if ( pathPart.isGap() ) {\n+                    final char prevCall = parts.get(idx - 1).getLastCall();\n+                    final char nextCall = parts.get(idx + 1).getFirstCall();\n+                    String gapFill = prevCall + pathPart.getSequence().toString() + nextCall;\n+                    final SequenceRC gapFillRC = new SequenceRC(gapFill);\n+                    if ( gapFillRC.compareTo(gapFill) < 0 ) {\n+                        gapFill = gapFillRC.toString();\n+                    }\n+                    gapFillCounts.merge(gapFill, 1, Integer::sum);\n+                }\n+            }\n+        }\n+\n+        boolean newKmers = false;\n+        for ( final Map.Entry<String, Integer> entry : gapFillCounts.entrySet() ) {\n+            final int nObservations = entry.getValue();\n+            if ( nObservations >= MIN_GAPFILL_COUNT ) {\n+                KmerAdjacency.kmerize(entry.getKey(), nObservations, kmerAdjacencySet);\n+                newKmers = true;\n+            }\n+        }\n+\n+        if ( newKmers ) {\n+            for ( final KmerAdjacency kmerAdjacency : kmerAdjacencySet ) {\n+                kmerAdjacency.clearContig();\n+            }\n+        }\n+        return newKmers;\n+    }\n+\n+    @VisibleForTesting\n+    static List<Path> pathReads( final KmerSet<KmerAdjacency> kmerAdjacencySet,\n+                          final List<GATKRead> reads ) {\n+        final List<Path> readPaths = new ArrayList<>(reads.size());\n+        for ( final GATKRead read : reads ) {\n+            readPaths.add(new Path(read.getBasesNoCopy(), kmerAdjacencySet));\n+        }\n+        return readPaths;\n+    }\n+\n+    @VisibleForTesting\n+    static Map<Contig,List<TransitPairCount>> collectTransitPairCounts(\n+            final List<ContigImpl> contigs,\n+            final List<Path> readPaths ) {\n+        final Map<Contig,List<TransitPairCount>> contigTransitsMap =\n+                new HashMap<>(3 * contigs.size());\n+        for ( final Path path : readPaths ) {\n+            final List<PathPart> parts = path.getParts();\n+            final int lastPart = parts.size() - 1;\n+            for ( int partIdx = 1; partIdx < lastPart; ++partIdx ) {\n+                final Contig prevContig = parts.get(partIdx - 1).getContig();\n+                if ( prevContig == null ) continue;\n+                final Contig curContig = parts.get(partIdx).getContig();\n+                if ( curContig == null ) {\n+                    partIdx += 1;\n+                    continue;\n+                }\n+                final Contig nextContig = parts.get(partIdx + 1).getContig();\n+                if ( nextContig == null ) {\n+                    partIdx += 2;\n+                    continue;\n+                }\n+                final TransitPairCount tpc = new TransitPairCount(prevContig, nextContig);\n+                final List<TransitPairCount> tpcList =\n+                        contigTransitsMap.computeIfAbsent(curContig, tig -> new ArrayList<>(4));\n+                final int idx = tpcList.indexOf(tpc);\n+                if ( idx != -1 ) {\n+                    tpcList.get(idx).observe();\n+                } else {\n+                    tpcList.add(tpc);\n+                    contigTransitsMap.computeIfAbsent(curContig.rc(), tig -> new ArrayList<>(4))\n+                            .add(tpc.getRC());\n+                }\n+            }\n+        }\n+        return contigTransitsMap;\n+    }\n+\n+    @VisibleForTesting\n+    static Set<Traversal> traverseAllPaths(\n+            final List<ContigImpl> contigs,\n+            final List<Path> readPaths,\n+            final Map<Contig, List<TransitPairCount>> contigTransitsMap ) {\n+        final Set<Traversal> traversalSet = new HashSet<>();\n+        final List<Contig> contigsList = new ArrayList<>();\n+        for ( final Contig contig : contigs ) {\n+            // untransited contigs are sources, sinks, or large contigs that can't be crossed by a read\n+            // build traversals from these\n+            if ( !contigTransitsMap.containsKey(contig) ) {\n+                boolean done = false;\n+                for ( final Contig successor : contig.getSuccessors() ) {\n+                    traverse(successor, contig,\n+                            contigsList, readPaths, contigTransitsMap, traversalSet);\n+                    done = true;\n+                }\n+                for ( final Contig predecessor : contig.getPredecessors() ) {\n+                    traverse(predecessor.rc(), contig.rc(),\n+                            contigsList, readPaths, contigTransitsMap, traversalSet);\n+                    done = true;\n+                }\n+                if ( !done ) { // if there were no predecessors or successors, it stands alone\n+                    addTraversal(new Traversal(Collections.singletonList(contig)), traversalSet);\n+                }\n+            }\n+        }\n+\n+        // look for transits that haven't been traced\n+        for ( final Map.Entry<Contig, List<TransitPairCount>> entry :\n+                contigTransitsMap.entrySet() ) {\n+            for ( final TransitPairCount tpc : entry.getValue() ) {\n+                if ( tpc.getCount() > 0 ) {\n+                    tpc.resetCount();\n+                    final Contig contig = entry.getKey();\n+                    final Set<Traversal> fwdTraversalSet = new HashSet<>();\n+                    traverse(tpc.getNextContig(), contig,\n+                            contigsList, readPaths, contigTransitsMap, fwdTraversalSet);\n+                    final Set<Traversal> revTraversalSet = new HashSet<>();\n+                    traverse(tpc.getPrevContig().rc(), contig.rc(),\n+                            contigsList, readPaths, contigTransitsMap, revTraversalSet);\n+                    for ( final Traversal revTraversal : revTraversalSet ) {\n+                        final Traversal revTraversalRC = revTraversal.rc();\n+                        for ( final Traversal fwdTraversal : fwdTraversalSet ) {\n+                            final int overlap =\n+                                    findMaxOverlap(revTraversalRC.getContigs(), fwdTraversal.getContigs());\n+                            final Traversal combo =\n+                                    Traversal.combineOverlappers(revTraversalRC, fwdTraversal, overlap);\n+                            addTraversal(combo, traversalSet);\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+\n+        return traversalSet;\n+    }\n+\n+    private static int findMaxOverlap( final List<Contig> prefixes, final List<Contig> suffixes ) {\n+        final int nPrefixes = prefixes.size();\n+        final Contig firstSuffix = suffixes.get(0);\n+        if ( !firstSuffix.isCyclic() ) {\n+            return prefixes.get(nPrefixes - 1) == firstSuffix ? 1 : 0;\n+        }\n+        final int nSuffixes = suffixes.size();\n+        for ( int prefixIdx = Math.max(0, nPrefixes - nSuffixes); prefixIdx != nPrefixes; ++prefixIdx ) {\n+            if ( prefixes.get(prefixIdx) == firstSuffix ) {\n+                int suffixIdx = 1;\n+                boolean match = true;\n+                for ( int prefixIdx2 = prefixIdx + 1; prefixIdx2 != nPrefixes; ++prefixIdx2 ) {\n+                    if ( prefixes.get(prefixIdx2) != suffixes.get(suffixIdx++) ) {\n+                        match = false;\n+                        break;\n+                    }\n+                }\n+                if ( match ) {\n+                    return nPrefixes - prefixIdx;\n+                }\n+            }\n+        }\n+        return 0;\n+    }\n+\n+    private static void traverse( final Contig contig,\n+                                  final Contig predecessor,\n+                                  final List<Contig> contigsList,\n+                                  final List<Path> readPaths,\n+                                  final Map<Contig, List<TransitPairCount>> contigTransitsMap,\n+                                  final Set<Traversal> traversalSet ) {\n+        contigsList.add(predecessor);\n+        if ( contig.isCyclic() ) {\n+            traverseCycle(contig, contigsList, readPaths, contigTransitsMap, traversalSet);\n+            contigsList.remove(contigsList.size() - 1);\n+            return;\n+        }\n+        final List<TransitPairCount> transits = contigTransitsMap.get(contig);\n+        boolean done = false;\n+        if ( transits != null ) {\n+            for ( final TransitPairCount tpc : transits ) {\n+                if ( tpc.getPrevContig() == predecessor ) {\n+                    final Contig successor = tpc.getNextContig();\n+                    if ( predecessor == contig.rc() ) {\n+                        final int nContigs = contigsList.size();\n+                        if ( nContigs > 1 ) {\n+                            if ( successor.rc() == contigsList.get(nContigs - 2) ) {\n+                                continue;\n+                            }\n+                        }\n+                    }\n+                    tpc.resetCount();\n+                    traverse(successor, contig, contigsList, readPaths, contigTransitsMap, traversalSet);\n+                    done = true;\n+                }\n+            }\n+        }\n+        if ( !done ) {\n+            contigsList.add(contig);\n+            addTraversal(new Traversal(contigsList), traversalSet);\n+            contigsList.remove(contigsList.size() - 1);\n+        }\n+        contigsList.remove(contigsList.size() - 1);\n+    }\n+\n+    private static void traverseCycle( final Contig contig,\n+                                       final List<Contig> contigsList,\n+                                       final List<Path> readPaths,\n+                                       final Map<Contig, List<TransitPairCount>> contigTransitsMap,\n+                                       final Set<Traversal> traversalSet ) {\n+        contigsList.add(contig);\n+        final int nContigs = contigsList.size();\n+        // the final element of the list is cyclic, if there's a previous element it will be\n+        // non-cyclic, so start there figuring out how far the read paths lead us\n+        final List<List<Contig>> longestPaths =\n+                findLongestPaths(contigsList.subList(Math.max(0, nContigs - 2), nContigs), readPaths);\n+        // didn't get anywhere -- just complete the traversal\n+        if ( longestPaths.isEmpty() ) {\n+            addTraversal(new Traversal(contigsList, true), traversalSet);\n+        } else {\n+            // for each unique extension into the cycle\n+            for ( final List<Contig> path : longestPaths ) {\n+                // don't think this can happen, but still\n+                if ( path.isEmpty() ) {\n+                    addTraversal(new Traversal(contigsList, true), traversalSet);\n+                    continue;\n+                }\n+                final List<Contig> extendedContigsList =\n+                        new ArrayList<>(contigsList.size() + path.size());\n+                extendedContigsList.addAll(contigsList);\n+                // if we didn't get out of the cycle\n+                if ( path.get(path.size() - 1).isCyclic() ) {\n+                    extendedContigsList.addAll(path);\n+                    addTraversal(new Traversal(extendedContigsList, true), traversalSet);\n+                } else {\n+                    // we found a cycle-exiting path, so extend that normally\n+                    for ( final Contig curContig : path ) {\n+                        if ( curContig.isCyclic() ) {\n+                            extendedContigsList.add(curContig);\n+                        } else {\n+                            final Contig prevContig =\n+                                    extendedContigsList.remove(extendedContigsList.size() - 1);\n+                            traverse(curContig, prevContig, extendedContigsList, readPaths,\n+                                    contigTransitsMap, traversalSet);\n+                            extendedContigsList.add(prevContig);\n+                            break;\n+                        }\n+                    }\n+                }\n+                clearTransitPairs(contigTransitsMap, extendedContigsList);\n+            }\n+        }\n+        contigsList.remove(contigsList.size() - 1);\n+    }\n+\n+    private static void clearTransitPairs(\n+            final Map<Contig, List<TransitPairCount>> contigTransitsMap,\n+            final List<Contig> contigsList ) {\n+        final int lastIdx = contigsList.size() - 1;\n+        for ( int idx = 1; idx < lastIdx; ++idx ) {\n+            final List<TransitPairCount> pairCounts = contigTransitsMap.get(contigsList.get(idx));\n+            if ( pairCounts != null ) {\n+                final Contig predecessor = contigsList.get(idx - 1);\n+                final Contig successor = contigsList.get(idx + 1);\n+                for ( final TransitPairCount tpc : pairCounts ) {\n+                    if ( tpc.getPrevContig() == predecessor && tpc.getNextContig() == successor ) {\n+                        tpc.resetCount();\n+                        break;\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    private static void addTraversal( final Traversal traversal,\n+                                      final Set<Traversal> traversalSet ) {\n+        if ( !traversalSet.contains(traversal.rc()) ) {\n+            traversalSet.add(traversal);\n+            if ( traversalSet.size() >= TOO_MANY_TRAVERSALS ) {\n+                throw new AssemblyTooComplexException();\n+            }\n+        }\n+    }\n+\n+    private static List<List<Contig>> findLongestPaths( final List<Contig> toMatch,\n+                                                        final List<Path> readPaths ) {\n+        final List<List<Contig>> results = new ArrayList<>();\n+        for ( final Path path : readPaths ) {\n+            testPath(path, toMatch, results);\n+            testPath(path.rc(), toMatch, results);\n+        }\n+        return results;\n+    }\n+\n+    private static void testPath( final Path path,\n+                                  final List<Contig> toMatch,\n+                                  final List<List<Contig>> results ) {\n+        final List<PathPart> pathParts = path.getParts();\n+        final int nPathParts = pathParts.size();\n+        final List<Contig> pathContigs = new ArrayList<>(nPathParts);\n+        pathParts.forEach(pp -> pathContigs.add(pp.getContig()));\n+        final int matchIdx = Collections.indexOfSubList(pathContigs, toMatch);\n+        if ( matchIdx != -1 ) {\n+            final int suffixIdx = matchIdx + toMatch.size();\n+            if ( suffixIdx < nPathParts ) {\n+                resolveResult(grabParts(pathContigs, suffixIdx), results);\n+            }\n+        }\n+    }\n+\n+    private static List<Contig> grabParts( final List<Contig> pathContigs, final int suffixIdx ) {\n+        final int nPathContigs = pathContigs.size();\n+        Contig prev = pathContigs.get(suffixIdx - 1);\n+        final List<Contig> result = new ArrayList<>(nPathContigs - suffixIdx);\n+        for ( int idx = suffixIdx; idx != nPathContigs; ++idx ) {\n+            final Contig tig = pathContigs.get(idx);\n+            if ( tig == null || !prev.getSuccessors().contains(tig) ) break;\n+            result.add(tig);\n+            prev = tig;\n+        }\n+        return result;\n+    }\n+\n+    private static void resolveResult( final List<Contig> result,\n+                                       final List<List<Contig>> results ) {\n+        final int nResults = results.size();\n+        for ( int idx = 0; idx != nResults; ++idx ) {\n+            final List<Contig> test = results.get(idx);\n+            if ( isPrefix(result, test) ) return;\n+            if ( isPrefix(test, result) ) {\n+                results.set(idx, result);\n+                return;\n+            }\n+        }\n+        results.add(result);\n+    }\n+\n+    private static boolean isPrefix( final List<Contig> list1, final List<Contig> list2 ) {\n+        final int list1Size = list1.size();\n+        final int list2Size = list2.size();\n+        if ( list1Size > list2Size ) return false;\n+        for ( int idx = 0; idx != list1Size; ++idx ) {\n+            if ( list1.get(idx) != list2.get(idx) ) return false;\n+        }\n+        return true;\n+    }\n+\n+    @VisibleForTesting\n+    static Collection<Traversal> createScaffolds( final List<Traversal> allTraversals ) {\n+        removeTriviallyDifferentTraversals(allTraversals);\n+\n+        final int nTraversals = allTraversals.size();\n+        final Map<Contig, List<Integer>> traversalsByFirstContig = new HashMap<>(3 * nTraversals);\n+        for ( int idx = 0; idx != nTraversals; ++idx ) {\n+            final Traversal traversal = allTraversals.get(idx);\n+            traversalsByFirstContig.compute(traversal.getFirstContig(),\n+                    ( k, v ) -> v == null ? new ArrayList<>(3) : v).add(idx);\n+            final Traversal rcTraversal = traversal.rc();\n+            traversalsByFirstContig.compute(rcTraversal.getFirstContig(),\n+                    ( k, v ) -> v == null ? new ArrayList<>(3) : v).add(~idx);\n+        }\n+\n+        final List<Traversal> scaffolds = new ArrayList<>(nTraversals);\n+        final boolean[] touched = new boolean[nTraversals];\n+        for ( int idx = 0; idx != nTraversals; ++idx ) {\n+            if ( !touched[idx] ) {\n+                expandTraversal(idx, touched, traversalsByFirstContig, allTraversals, scaffolds);\n+            }\n+        }\n+        return scaffolds;\n+    }\n+\n+    private static void expandTraversal( final int traversalIdx,\n+                                         final boolean[] touched,\n+                                         final Map<Contig, List<Integer>> traversalsByFirstContig,\n+                                         final List<Traversal> allTraversals,\n+                                         final List<Traversal> scaffolds ) {\n+        final Traversal traversal = allTraversals.get(traversalIdx);\n+        touched[traversalIdx] = true;\n+        final List<Traversal> downExtensions = new ArrayList<>();\n+        final Set<Contig> startingContigSet = new HashSet<>();\n+        walkTraversals(traversal, touched, startingContigSet, traversalsByFirstContig,\n+                        allTraversals, downExtensions);\n+        final List<Traversal> upExtensions = new ArrayList<>();\n+        walkTraversals(traversal.rc(), touched, startingContigSet, traversalsByFirstContig,\n+                        allTraversals, upExtensions);\n+        for ( final Traversal down : downExtensions ) {\n+            for ( final Traversal up : upExtensions ) {\n+                if ( scaffolds.size() >= TOO_MANY_SCAFFOLDS ) {\n+                    throw new AssemblyTooComplexException();\n+                }\n+                scaffolds.add(Traversal.combineOverlappers(up.rc(), down, traversal.getContigs().size()));\n+            }\n+        }\n+    }\n+\n+    private static void walkTraversals( final Traversal traversal,\n+                                        final boolean[] touched,\n+                                        final Set<Contig> startingContigSet,\n+                                        final Map<Contig, List<Integer>> traversalsByFirstContig,\n+                                        final List<Traversal> allTraversals,\n+                                        final List<Traversal> extensions ) {\n+        final Contig firstContig = traversal.getFirstContig();\n+        final List<Integer> indexList;\n+        if ( startingContigSet.contains(firstContig) ||\n+                traversal.isInextensible() ||\n+                (indexList = traversalsByFirstContig.get(traversal.getLastContig())) == null ) {\n+            extensions.add(traversal);\n+            return;\n+        }\n+        startingContigSet.add(firstContig);\n+        for ( int idx : indexList ) {\n+            final Traversal extension;\n+            if ( idx >= 0 ) {\n+                extension = allTraversals.get(idx);\n+                touched[idx] = true;\n+            } else {\n+                final int rcIdx = ~idx;\n+                extension = allTraversals.get(rcIdx).rc();\n+                touched[rcIdx] = true;\n+            }\n+            walkTraversals(Traversal.combine(traversal, extension), touched, startingContigSet,\n+                            traversalsByFirstContig, allTraversals, extensions );\n+        }\n+        startingContigSet.remove(firstContig);\n+    }\n+\n+    private static void removeTriviallyDifferentTraversals(\n+                                            final Collection<Traversal> allTraversals ) {\n+        if ( allTraversals.isEmpty() ) {\n+            return;\n+        }\n+        final TreeSet<Traversal> sortedTraversals = new TreeSet<>(new TraversalEndpointComparator());\n+        for ( final Traversal traversal : allTraversals ) {\n+            sortedTraversals.add(traversal);\n+            sortedTraversals.add(traversal.rc());\n+        }\n+        final Iterator<Traversal> traversalIterator = sortedTraversals.iterator();\n+        Traversal prevTraversal = traversalIterator.next();\n+        while ( traversalIterator.hasNext() ) {\n+            final Traversal curTraversal = traversalIterator.next();\n+            if ( isTriviallyDifferent(prevTraversal, curTraversal) ) {\n+                traversalIterator.remove();\n+            } else {\n+                prevTraversal = curTraversal;\n+            }\n+        }\n+        sortedTraversals.removeIf(Traversal::isRC);\n+        allTraversals.clear();\n+        allTraversals.addAll(sortedTraversals);\n+    }\n+\n+    private static boolean isTriviallyDifferent( final Traversal traversal1,\n+                                                 final Traversal traversal2 ) {\n+        final Contig firstContig1 = traversal1.getFirstContig();\n+        final Contig lastContig1 = traversal1.getLastContig();\n+        final Contig firstContig2 = traversal2.getFirstContig();\n+        final Contig lastContig2 = traversal2.getLastContig();\n+        if ( firstContig1 != firstContig2 || lastContig1 != lastContig2 ) {\n+            return false;\n+        }\n+        final int interiorSize1 = traversal1.getSequenceLength() - firstContig1.size() - lastContig1.size();\n+        final int interiorSize2 = traversal2.getSequenceLength() - firstContig2.size() - lastContig2.size();\n+\n+        // if the path lengths are so different that one could harbor an SV, they're not trivially different\n+        if ( Math.abs(interiorSize1 - interiorSize2) >= MIN_SV_SIZE ) {\n+            return false;\n+        }\n+\n+        // if the paths are small enough that there can't be an SV's worth of differences, they're trivially different\n+        final int maxInteriorSize = Math.max(interiorSize1, interiorSize2);\n+        if ( maxInteriorSize < MIN_SV_SIZE ) {\n+            return true;\n+        }\n+\n+        // dang, maybe there's enough material in common that there can't be an SV's worth of differences\n+        // run a longest common subsequence algorithm to figure out the length of the common material\n+        // DP matrix holds length of common material\n+        final List<Contig> contigs1 = traversal1.getContigs();\n+        final int rowLen = contigs1.size() - 1;\n+        final int[][] rowPair = new int[2][];\n+        rowPair[0] = new int[rowLen];\n+        rowPair[1] = new int[rowLen];\n+        int pairIdx = 0;\n+        final List<Contig> contigs2 = traversal2.getContigs();\n+        final int nRows = contigs2.size() - 1;\n+        for ( int idx2 = 1; idx2 != nRows; ++idx2 ) {\n+            final int[] curRow = rowPair[pairIdx];\n+            final int[] prevRow = rowPair[pairIdx ^ 1];\n+            pairIdx ^= 1;\n+\n+            final int id2 = contigs2.get(idx2).getId();\n+            for ( int idx1 = 1; idx1 != rowLen; ++idx1 ) {\n+                final Contig tig1 = contigs1.get(idx1);\n+                if ( tig1.getId() == id2 ) {\n+                    // if the previous cells also contain a match we've already removed the K-1 bases upstream\n+                    final boolean extendMatch =\n+                            contigs1.get(idx1 -1).getId() == contigs2.get(idx2 - 1).getId();\n+                    curRow[idx1] = prevRow[idx1 - 1] + (extendMatch ? tig1.getNKmers() : tig1.size());\n+                } else {\n+                    curRow[idx1] = Math.max(curRow[idx1 - 1], prevRow[idx1]);\n+                }\n+            }\n+        }\n+        final int commonLen = rowPair[pairIdx ^ 1][rowLen - 1];\n+        return (maxInteriorSize - commonLen) < MIN_SV_SIZE;\n+    }\n+\n+    private static class TraversalEndpointComparator implements Comparator<Traversal> {\n+        @Override\n+        public int compare( final Traversal traversal1, final Traversal traversal2 ) {\n+            int cmp = Integer.compare(traversal1.contigs.get(0).getId(),\n+                                      traversal2.contigs.get(0).getId());\n+            if ( cmp != 0 ) {\n+                return cmp;\n+            }\n+            final int last1 = traversal1.contigs.size() - 1;\n+            final int last2 = traversal2.contigs.size() - 1;\n+            cmp = Integer.compare(traversal1.contigs.get(last1).getId(),\n+                                  traversal2.contigs.get(last2).getId());\n+            if ( cmp != 0 ) {\n+                return cmp;\n+            }\n+            // among those starting and ending at the same place, sort least observed last\n+            return -Integer.compare(traversal1.getMinMaxObservations(), traversal2.getMinMaxObservations());\n+        }\n+    }\n+\n+    private static void writeDOT( final List<ContigImpl> contigs, final String fileName ) {\n+        try ( final BufferedWriter writer = new BufferedWriter(new FileWriter(fileName)) ) {\n+            writer.write(\"digraph {\\n\");\n+            for ( final Contig contig : contigs ) {\n+                final double width = contig.getSequence().length() / 100.;\n+                writer.write(contig + \" [width=\" + width + \"]\\n\");\n+                writer.write( contig.rc() + \" [width=\" + width + \"]\\n\");\n+            }\n+            for ( final Contig contig : contigs ) {\n+                for ( final Contig predecessor : contig.getPredecessors() ) {\n+                    final String predecessorName = predecessor.rc().toString();\n+                    writer.write(contig.rc() + \" -> \" + predecessorName + \"\\n\");\n+                }\n+                for ( final Contig successor : contig.getSuccessors() ) {\n+                    final String successorName = successor.toString();\n+                    writer.write(contig + \" -> \" + successorName + \"\\n\");\n+                }\n+            }\n+            writer.write(\"}\\n\");\n+        } catch ( final IOException ioe ) {\n+            throw new GATKException(\"Failed to write assembly DOT file.\", ioe);\n+        }\n+    }\n+\n+    private static BufferedWriter makeGZFile( final String fileName ) throws IOException {\n+        final GZIPOutputStream gzOS = new GZIPOutputStream(BucketUtils.createFile(fileName));\n+        return new BufferedWriter(new OutputStreamWriter(gzOS));\n+    }\n+\n+    private static void writeContigs( final List<ContigImpl> contigs, final String fileName ) {\n+        try ( final BufferedWriter writer = makeGZFile(fileName) ) {\n+            for ( final Contig contig : contigs ) {\n+                final List<Contig> predecessors = contig.getPredecessors();\n+                final String predecessorDescription;\n+                if ( predecessors.size() == 0 ) {\n+                    predecessorDescription = \"\\tnone\";\n+                } else {\n+                    final StringBuilder sb = new StringBuilder();\n+                    char prefix = '\\t';\n+                    for ( final Contig predecessor : predecessors ) {\n+                        sb.append(prefix);\n+                        prefix = ',';\n+                        sb.append(predecessor);\n+                    }\n+                    predecessorDescription = sb.toString();\n+                }\n+\n+                final List<Contig> successors = contig.getSuccessors();\n+                final String successorDescription;\n+                if ( successors.size() == 0 ) {\n+                    successorDescription = \"\\tnone\";\n+                } else {\n+                    final StringBuilder sb = new StringBuilder();\n+                    char prefix = '\\t';\n+                    for ( final Contig successor : successors ) {\n+                        sb.append(prefix);\n+                        prefix = ',';\n+                        sb.append(successor);\n+                    }\n+                    successorDescription = sb.toString();\n+                }\n+\n+                final String contigName = contig.toString();\n+                final String component =\n+                        (contig.isCyclic() ? \"(C)\\t\" : \"\\t\") + contig.getComponentId();\n+                writer.write(contigName + component + predecessorDescription +\n+                        successorDescription + \"\\t\" +\n+                        contig.getMaxObservations() + \"\\t\" +\n+                        contig.getFirstKmer().getNObservations() + \"\\t\" +\n+                        contig.getLastKmer().getNObservations() + \"\\t\" +\n+                        contig.size() + \"\\t\" +\n+                        contig.getSequence() + \"\\n\");\n+            }\n+        } catch ( final IOException ioe ) {\n+            throw new GATKException(\"Failed to write contigs file.\", ioe);\n+        }\n+    }\n+\n+    private static void writePaths( final List<Path> readPaths, final String fileName ) {\n+        try ( final BufferedWriter writer = makeGZFile(fileName) ) {\n+            final int nReads = readPaths.size();\n+            for ( int readId = 0; readId != nReads; ++readId ) {\n+                final Path path = readPaths.get(readId);\n+                final String pathDesc = path.toString();\n+                writer.write((readId + 1) + \": \" + pathDesc + \"\\n\");\n+            }\n+        } catch ( final IOException ioe ) {\n+            throw new GATKException(\"Failed to write paths file.\", ioe);\n+        }\n+    }\n+\n+    private static void writeReads( final List<GATKRead> reads, final String fileName ) {\n+        try ( final BufferedWriter writer = makeGZFile(fileName) ) {\n+            for ( final GATKRead read : reads ) {\n+                writer.write(\"@\" + read.getName());\n+                writer.write('\\n');\n+                writer.write(new String(read.getBasesNoCopy()));\n+                writer.write(\"\\n+\\n\");\n+                final byte[] quals = read.getBaseQualitiesNoCopy();\n+                final int nQuals = quals.length;\n+                final byte[] fastqQuals = new byte[nQuals];\n+                for ( int idx = 0; idx != nQuals; ++idx ) {\n+                    fastqQuals[idx] = (byte)SAMUtils.phredToFastq(quals[idx]);\n+                }\n+                writer.write(new String(fastqQuals));\n+                writer.write('\\n');\n+            }\n+        } catch ( final IOException ioe ) {\n+            throw new GATKException(\"Failed to write assembly sam file.\", ioe);\n+        }\n+    }\n+\n+    private static void writeTraversals( final Collection<Traversal> traversals,\n+                                         final String fileName ) {\n+        try ( final BufferedWriter writer = makeGZFile(fileName) ) {\n+            int traversalNo = 0;\n+            for ( final Traversal traversal : traversals ) {\n+                writer.write(\">\");\n+                if ( assemblyName != null ) {\n+                    writer.write(assemblyName);\n+                    writer.write(\"_\");\n+                }\n+                writer.write(\"t\");\n+                writer.write(Integer.toString(++traversalNo));\n+                writer.write(\" \");\n+                writer.write(traversal.getName());\n+                writer.newLine();\n+                writer.write(traversal.getSequence());\n+                writer.newLine();\n+            }\n+        } catch ( final IOException ioe ) {\n+            throw new GATKException(\"Failed to write assembly sam file.\", ioe);\n+        }\n+    }\n+\n+    /** fixed-size, immutable kmer.  usual 2-bit encoding: ACGT->0123.  low order bits are final call. **/\n+    public static class Kmer {\n+        public static final int KSIZE = 31; // must be odd number less than 32\n+        public static final long KMASK = (1L << 2*KSIZE) - 1L;\n+        private final long kVal;\n+\n+        public Kmer( final long kVal ) { this.kVal = kVal; }\n+\n+        public long getKVal() { return kVal; }\n+        public boolean isCanonical() { return isCanonical(kVal); }\n+        public int getInitialCall() { return (int)(kVal >> (KSIZE*2 - 2)) & 3; }\n+        public int getFinalCall() { return (int)kVal & 3; }\n+\n+        public long getPredecessorVal( final int call ) {\n+            return (kVal >> 2) | ((long)call << (2 * (KSIZE - 1)));\n+        }\n+        public long getSuccessorVal( final int call ) { return ((kVal << 2) & KMASK) | call; }\n+\n+        public static boolean isCanonical( final long val ) {\n+            return (val & (1L << KSIZE)) == 0L;\n+        }\n+\n+        @Override public boolean equals( final Object obj ) {\n+            return obj instanceof Kmer && kVal == ((Kmer)obj).kVal;\n+        }\n+\n+        @Override public int hashCode() {\n+            return (int)(kVal ^ (kVal >>> 32));\n+        }\n+    }\n+\n+    /** Set of Kmers.  Uses HopscotchSet, customized to find correct starting bin for Kmers and derivatives. **/\n+    public static final class KmerSet<KMER extends Kmer> extends HopscotchSet<KMER> {\n+        public KmerSet( final int capacity ) { super(capacity); }\n+\n+        @Override\n+        protected int hashToIndex( final Object kmer ) {\n+            return (int)(((HopscotchSet.SPREADER * ((Kmer)kmer).getKVal()) & Long.MAX_VALUE) % capacity());\n+        }\n+    }\n+\n+    /**\n+     *  A Kmer that remembers its predecessors and successors, and the number of times it's been observed\n+     *  in the assembly's input set of reads.\n+     *  The masks are bit-wise (1=A, 2=C, 4=G, 8=T) to show which predecessors or successors have been observed.\n+     *  The Kmer's position on a Contig is also tracked (in later phases of the assembly process).\n+     **/\n+    public static abstract class KmerAdjacency extends Kmer {\n+        public KmerAdjacency( final long kVal ) { super(kVal); }\n+\n+        public abstract KmerAdjacency getSolePredecessor(); // returns null if there's 0 or >1 predecessors\n+        public abstract int getPredecessorMask();\n+        public abstract int getPredecessorCount();\n+        public abstract void removePredecessor( final int callToRemove,\n+                                                final KmerSet<KmerAdjacency> kmerAdjacencySet );\n+\n+        public abstract KmerAdjacency getSoleSuccessor(); // returns null if there's 0 or > 1 successors\n+        public abstract int getSuccessorMask();\n+        public abstract int getSuccessorCount();\n+        public abstract void removeSuccessor( final int callToRemove,\n+                                              final KmerSet<KmerAdjacency> kmerAdjacencySet );\n+\n+        public abstract Contig getContig();\n+        public abstract int getContigOffset();\n+        // offset is 0-based measure on the contig sequence of the beginning of the kmer\n+        public abstract void setContigOffset( final Contig contig, final int contigOffset );\n+        public abstract void clearContig();\n+\n+        public abstract int getNObservations();\n+        public abstract KmerAdjacency rc();\n+        public abstract KmerAdjacencyImpl canonical();\n+\n+        public void observe( final KmerAdjacency predecessor, final KmerAdjacency successor ) {\n+            observe(predecessor, successor, 1);\n+        }\n+\n+        public abstract void observe( final KmerAdjacency predecessor,\n+                                      final KmerAdjacency successor,\n+                                      final int count );\n+\n+        @Override public String toString() {\n+            final StringBuilder sb = new StringBuilder(KSIZE);\n+            long currentVal = getKVal();\n+            for ( int idx = 0; idx != KSIZE; ++idx ) {\n+                sb.append(\"ACGT\".charAt((int)currentVal & 3));\n+                currentVal >>= 2;\n+            }\n+            sb.reverse(); // low order bits were loaded into sb first:  fix that now by reversing the sb.\n+            return sb.toString();\n+        }\n+\n+        /**\n+         * Transform a read's calls into KmerAdjacencies, and add them to a KmerSet.\n+         * Skip kmers that include a call with a quality < qMin.\n+         * Skip kmers with non-ACGT calls.\n+         **/\n+        public static void kmerize( final byte[] calls,\n+                                    final byte[] quals,\n+                                    final byte qMin,\n+                                    final KmerSet<KmerAdjacency> kmerAdjacencySet ) {\n+            int currentCount = 0; // number of calls loaded into currentKVal\n+            long currentKVal = 0;\n+            KmerAdjacency prevAdjacency = null;\n+            KmerAdjacency currentAdjacency = null;\n+            for ( int idx = 0; idx < calls.length; ++idx ) {\n+                if ( quals[idx] < qMin ) { // if we encounter a low-quality call\n+                    // take care of the most recent valid KmerAdjacency, if any\n+                    if ( currentAdjacency != null ) {\n+                        currentAdjacency.observe(prevAdjacency, null);\n+                    }\n+                    // ready ourselves to accumulate calls afresh\n+                    currentCount = 0;\n+                    currentAdjacency = prevAdjacency = null;\n+                    continue;\n+                }\n+                currentKVal <<= 2;\n+                switch ( calls[idx] ) {\n+                    case 'A': case 'a': break;\n+                    case 'C': case 'c': currentKVal += 1; break;\n+                    case 'G': case 'g': currentKVal += 2; break;\n+                    case 'T': case 't': currentKVal += 3; break;\n+                    default:\n+                        if ( currentAdjacency != null ) {\n+                            currentAdjacency.observe(prevAdjacency, null);\n+                        }\n+                        currentCount = 0;\n+                        currentAdjacency = prevAdjacency = null;\n+                        continue;\n+                }\n+                if ( ++currentCount >= KSIZE ) { // if we've loaded enough calls to make a complete kmer\n+                    final KmerAdjacency nextAdjacency = findOrAdd(currentKVal, kmerAdjacencySet);\n+                    if ( currentAdjacency != null ) {\n+                        currentAdjacency.observe(prevAdjacency, nextAdjacency);\n+                    }\n+                    prevAdjacency = currentAdjacency;\n+                    currentAdjacency = nextAdjacency;\n+                }\n+            }\n+            if ( currentAdjacency != null ) {\n+                currentAdjacency.observe(prevAdjacency, null);\n+            }\n+        }\n+\n+        /**\n+         * Kmerize a String.  This version is for gap fills.\n+         * The number of observations applies to all kmers except the 1st and last.\n+         **/\n+        public static void kmerize( final String sequence,\n+                                    final int nObservations,\n+                                    final KmerSet<KmerAdjacency> kmerAdjacencySet ) {\n+            int currentCount = 0;\n+            long currentKVal = 0;\n+            int nObs = 0;\n+            KmerAdjacency prevAdjacency = null;\n+            KmerAdjacency currentAdjacency = null;\n+            final int nCalls = sequence.length();\n+            for ( int idx = 0; idx != nCalls; ++idx ) {\n+                currentKVal <<= 2;\n+                switch ( sequence.charAt(idx) ) {\n+                    case 'A': case 'a': break;\n+                    case 'C': case 'c': currentKVal += 1; break;\n+                    case 'G': case 'g': currentKVal += 2; break;\n+                    case 'T': case 't': currentKVal += 3; break;\n+                    default: throw new GATKException(\"unexpected base call in string to kmerize.\");\n+                }\n+                if ( ++currentCount >= KSIZE ) {\n+                    final KmerAdjacency nextAdjacency = findOrAdd(currentKVal, kmerAdjacencySet);\n+                    if ( currentAdjacency != null ) {\n+                        currentAdjacency.observe(prevAdjacency, nextAdjacency, nObs);\n+                        nObs = nObservations;\n+                    }\n+                    prevAdjacency = currentAdjacency;\n+                    currentAdjacency = nextAdjacency;\n+                }\n+            }\n+            if ( currentAdjacency != null ) {\n+                currentAdjacency.observe(prevAdjacency, null, 0);\n+            }\n+        }\n+\n+        // Lookup table for reverse-complementing each possible byte value.\n+        // Each pair of bits represents a base, so you have to reverse bits pairwise and then invert all bits.\n+        // This is most quickly and easily done with a lookup table.\n+        private static final long[] BYTEWISE_REVERSE_COMPLEMENT;\n+        static {\n+            BYTEWISE_REVERSE_COMPLEMENT = new long[256];\n+            for ( int bIn = 0; bIn != 256; ++bIn ) {\n+                BYTEWISE_REVERSE_COMPLEMENT[bIn] =\n+                        ~(((bIn & 3) << 6) | (((bIn >> 2) & 3) << 4) |\n+                                (((bIn >> 4) & 3) << 2) | ((bIn >> 6) & 3)) & 0xffL;\n+            }\n+        }\n+\n+        public static long reverseComplement( long val ) {\n+            // process val one byte at a time\n+            long result = BYTEWISE_REVERSE_COMPLEMENT[(int)val & 0xFF]; // handle the low-order byte\n+            int nBytes = 8;\n+            while ( --nBytes != 0 ) { // pre-decrementing:  we'll go through the loop 7 times\n+                // rotate down by a byte\n+                val >>= 8;\n+                // rotate up by a byte and OR in the reverse complement of the next byte\n+                result = (result << 8) | BYTEWISE_REVERSE_COMPLEMENT[(int)val & 0xFF];\n+            }\n+            return result >>> (Long.SIZE - 2*KSIZE);\n+        }\n+\n+        // Kmer lookup in KmerSet.\n+        // KmerSets holding KmerAdjacencies have only canonical Kmers, so RC non-canonical kmers before lookup.\n+        public static KmerAdjacency find( final long kVal,\n+                                          final KmerSet<KmerAdjacency> kmerAdjacencySet ) {\n+            if ( isCanonical(kVal) ) return kmerAdjacencySet.find(new Kmer(kVal & KMASK));\n+            final KmerAdjacency result = kmerAdjacencySet.find(new Kmer(reverseComplement(kVal)));\n+            return result == null ? null : result.rc();\n+        }\n+\n+        // Kmer lookup in KmerSet.\n+        // KmerSets holding KmerAdjacencies have only canonical Kmers, so RC non-canonical kmers before lookup.\n+        // Add missing Kmers.\n+        public static KmerAdjacency findOrAdd( final long kVal,\n+                                               final KmerSet<KmerAdjacency> kmerAdjacencySet ) {\n+            if ( isCanonical(kVal) ) {\n+                return kmerAdjacencySet.findOrAdd(new Kmer(kVal & KMASK), kmer ->\n+                        new KmerAdjacencyImpl(((Kmer)kmer).getKVal()));\n+            }\n+            return kmerAdjacencySet.findOrAdd(new Kmer(reverseComplement(kVal)), kmer ->\n+                    new KmerAdjacencyImpl(((Kmer)kmer).getKVal())).rc();\n+        }\n+    }\n+\n+    /**\n+     * Class to implement KmerAdjacency for canonical Kmers.\n+     * In particular, a KmerSet created on KmerAdjacency contains only canonical Kmers.\n+     **/\n+    public static final class KmerAdjacencyImpl extends KmerAdjacency {\n+        private KmerAdjacency solePredecessor; // set to null if there are no predecessors, or multiple predecessors\n+        private KmerAdjacency soleSuccessor; // set to null if there are no successors, or multiple successors\n+        private int predecessorMask; // bit mask of observed kmers preceding this one\n+        private int successorMask; // bit mask observed kmers following this one\n+        private Contig contig; // the contig that contains this Kmer\n+        private int contigOffset; // the offset within the contig where this kmer is found\n+        private int nObservations; // the reads in which this kmer was observed\n+        private final KmerAdjacencyRC rc; // the reverse-complement of this kmer\n+        private static final int[] COUNT_FOR_MASK =\n+                //side sum for binary values from 0 -> 15\n+                //0000  0001 0010 0011 0100 0101 0110 0111 1000 1001 1010 1011 1100 1101 1110 1111\n+                {    0,    1,   1,   2,   1,   2,   2,   3,   1,   2,   2,   3,   2,   3,   3,   4 };\n+\n+        public KmerAdjacencyImpl( final long kVal ) {\n+            super(kVal);\n+            this.rc = new KmerAdjacencyRC(this);\n+        }\n+\n+        @Override public KmerAdjacency getSolePredecessor() { return solePredecessor; } // may return null\n+        @Override public int getPredecessorMask() { return predecessorMask; }\n+        @Override public int getPredecessorCount() { return COUNT_FOR_MASK[predecessorMask]; }\n+        @Override\n+        public void removePredecessor( final int callToRemove,\n+                                       final KmerSet<KmerAdjacency> kmerAdjacencySet ) {\n+            predecessorMask &= ~(1 << callToRemove);\n+            solePredecessor = null;\n+            if ( getPredecessorCount() == 1 ) {\n+                for ( int call = 0; call != 4; ++call ) {\n+                    if ( ((1 << call) & predecessorMask) != 0 ) {\n+                        solePredecessor = find(getPredecessorVal(call), kmerAdjacencySet);\n+                        break;\n+                    }\n+                }\n+            }\n+        }\n+\n+        @Override public KmerAdjacency getSoleSuccessor() { return soleSuccessor; } // may return null\n+        @Override public int getSuccessorMask() { return successorMask; }\n+        @Override public int getSuccessorCount() { return COUNT_FOR_MASK[successorMask]; }\n+        @Override\n+        public void removeSuccessor( final int callToRemove,\n+                                     final KmerSet<KmerAdjacency> kmerAdjacencySet ) {\n+            successorMask &= ~(1 << callToRemove);\n+            soleSuccessor = null;\n+            if ( getSuccessorCount() == 1 ) {\n+                for ( int call = 0; call != 4; ++call ) {\n+                    if ( ((1 << call) & successorMask) != 0 ) {\n+                        soleSuccessor = find(getSuccessorVal(call), kmerAdjacencySet);\n+                        break;\n+                    }\n+                }\n+            }\n+        }\n+\n+        @Override public Contig getContig() { return contig; }\n+        @Override public int getContigOffset() { return contigOffset; }\n+        @Override public void setContigOffset( final Contig contig, final int contigOffset ) {\n+            if ( this.contig != null ) {\n+                throw new GATKException(\"Internal error: overwriting kmer contig and offset.\");\n+            }\n+            this.contig = contig;\n+            this.contigOffset = contigOffset;\n+        }\n+        @Override public void clearContig() { contig = null; contigOffset = 0; }\n+\n+        @Override public int getNObservations() { return nObservations; }\n+        @Override public KmerAdjacency rc() { return rc; }\n+        @Override public KmerAdjacencyImpl canonical() { return this; }\n+\n+        @Override public void observe( final KmerAdjacency predecessor,\n+                                       final KmerAdjacency successor,\n+                                       final int count ) {\n+            if ( predecessor != null ) {\n+                if ( predecessor.getSuccessorVal(getFinalCall()) != getKVal() ) {\n+                    throw new GATKException(\"illegal predecessor\");\n+                }\n+                final int initialCall = predecessor.getInitialCall();\n+                final int newPredecessorMask = 1 << initialCall;\n+                if ( (newPredecessorMask & predecessorMask) == 0 ) {\n+                    if ( predecessorMask == 0 ) {\n+                        solePredecessor = predecessor;\n+                        predecessorMask = newPredecessorMask;\n+                    } else {\n+                        solePredecessor = null;\n+                        predecessorMask |= newPredecessorMask;\n+                    }\n+                }\n+            }\n+            if ( successor != null ) {\n+                if ( successor.getPredecessorVal(getInitialCall()) != getKVal() ) {\n+                    throw new GATKException(\"illegal successor\");\n+                }\n+                final int finalCall = successor.getFinalCall();\n+                final int newSuccessorMask = 1 << finalCall;\n+                if ( (newSuccessorMask & successorMask) == 0 ) {\n+                    if ( successorMask == 0 ) {\n+                        soleSuccessor = successor;\n+                        successorMask = newSuccessorMask;\n+                    } else {\n+                        soleSuccessor = null;\n+                        successorMask |= newSuccessorMask;\n+                    }\n+                }\n+            }\n+            nObservations += count;\n+        }\n+    }\n+\n+    /**\n+     * Class to implement KmerAdjacency for Kmers that are the reverse-complement of a canonical Kmer.\n+     * In particular, a KmerSet created on KmerAdjacency contains only canonical Kmers.\n+     * A KmerAdjacencyRC represents the RC of each Kmer in the KmerSet.\n+     **/\n+    public static final class KmerAdjacencyRC extends KmerAdjacency {\n+        private final KmerAdjacencyImpl rc;\n+\n+        // lookup table to bit-reverse nibbles\n+        private static final int[] NIBREV =\n+                // 0000,  0001,  0010,  0011,  0100,  0101,  0110,  0111,  1000,  1001,  1010,  1011,  1100,  1101,  1110,  1111\n+                {0b0000,0b1000,0b0100,0b1100,0b0010,0b1010,0b0110,0b1110,0b0001,0b1001,0b0101,0b1101,0b0011,0b1011,0b0111,0b1111};\n+\n+        public KmerAdjacencyRC( final KmerAdjacencyImpl rc ) {\n+            super(reverseComplement(rc.getKVal()));\n+            this.rc = rc;\n+        }\n+\n+        @Override public KmerAdjacency getSolePredecessor() {\n+            final KmerAdjacency successor = rc.getSoleSuccessor();\n+            return successor == null ? null : successor.rc();\n+        }\n+        @Override public int getPredecessorMask() { return NIBREV[rc.getSuccessorMask()]; }\n+        @Override public int getPredecessorCount() { return rc.getSuccessorCount(); }\n+        @Override\n+        public void removePredecessor( final int callToRemove,\n+                                       final KmerSet<KmerAdjacency> kmerAdjacencySet ) {\n+            rc.removeSuccessor(3 - callToRemove, kmerAdjacencySet);\n+        }\n+\n+        @Override public KmerAdjacency getSoleSuccessor() {\n+            final KmerAdjacency predecessor = rc.getSolePredecessor();\n+            return predecessor == null ? null : predecessor.rc();\n+        }\n+        @Override public int getSuccessorMask() { return NIBREV[rc.getPredecessorMask()]; }\n+        @Override public int getSuccessorCount() { return rc.getPredecessorCount(); }\n+        @Override\n+        public void removeSuccessor( final int callToRemove,\n+                                     final KmerSet<KmerAdjacency> kmerAdjacencySet ) {\n+            rc.removePredecessor(3 - callToRemove, kmerAdjacencySet);\n+        }\n+\n+        @Override public Contig getContig() {\n+            final Contig contig = rc.getContig();\n+            return contig == null ? null : contig.rc();\n+        }\n+        @Override public int getContigOffset() {\n+            final Contig contig = rc.getContig();\n+            return contig == null ? 0 : contig.size() - rc.getContigOffset() - KSIZE;\n+        }\n+        @Override public void setContigOffset( final Contig contig, final int contigOffset ) {\n+            rc.setContigOffset(contig.rc(), contig.size() - contigOffset - KSIZE);\n+        }\n+        @Override public void clearContig() { rc.clearContig(); }\n+\n+        @Override public int getNObservations() { return rc.getNObservations(); }\n+        @Override public KmerAdjacency rc() { return rc; }\n+        @Override public KmerAdjacencyImpl canonical() { return rc; }\n+\n+        @Override public void observe( final KmerAdjacency predecessor,\n+                                       final KmerAdjacency successor,\n+                                       final int count ) {\n+            rc.observe(successor == null ? null : successor.rc(),\n+                    predecessor == null ? null : predecessor.rc(),\n+                    count);\n+        }\n+    }\n+\n+    public enum ContigOrientation {\n+        FWD, // k-mer appears at the 5' end of the contig\n+        REV, // k-mer appears at the 5' end of the reverse-complemented contig\n+        BOTH // k-mer occurs on 5' end of the contig and its RC (can happen when the contig is a palindrome)\n+    }\n+\n+    /** Initial or final Kmer in a Contig. **/\n+    public static final class ContigEndKmer extends Kmer {\n+        private final Contig contig;\n+        private final ContigOrientation contigOrientation;\n+\n+        public ContigEndKmer( final long kVal,\n+                              final Contig contig,\n+                              final ContigOrientation contigEnd ) {\n+            super(kVal);\n+            this.contig = contig;\n+            this.contigOrientation = contigEnd;\n+        }\n+\n+        public Contig getContig() { return contig; }\n+        public ContigOrientation getContigOrientation() { return contigOrientation; }\n+    }\n+\n+    /**\n+     * An unbranched sequence of Kmers.\n+     * Each Kmer (except the last one) has a single successor, which allows enumerating the sequence\n+     * of Kmers in the Contig.  The sequence of base calls in the Contig is just the sequence of kmers\n+     * with the K-1 overlapping calls removed from adjacent kmers.\n+     **/\n+    public interface Contig {\n+        int getId();\n+        CharSequence getSequence();\n+        int getMaxObservations();\n+        KmerAdjacency getFirstKmer();\n+        KmerAdjacency getLastKmer();\n+        List<Contig> getPredecessors();\n+        List<Contig> getSuccessors();\n+        int getComponentId();\n+        int size();\n+        default int getNKmers() { return size() - Kmer.KSIZE + 1; }\n+        Contig rc();\n+        boolean isCyclic();\n+        void setCyclic( final boolean cyclic );\n+        boolean isCut();\n+        void setCut( final boolean cut );\n+        boolean isCanonical();\n+        ContigImpl canonical();\n+    }\n+\n+    /** Simple implementation of Contig interface. **/\n+    public static final class ContigImpl implements Contig {\n+        private final int id;\n+        private final CharSequence sequence;\n+        private final int maxObservations;\n+        private final KmerAdjacency firstKmer;\n+        private final KmerAdjacency lastKmer;\n+        private final List<Contig> predecessors;\n+        private final List<Contig> successors;\n+        private int componentId;\n+        private boolean cyclic;\n+        private boolean cut;\n+        private final Contig rc;\n+\n+        public ContigImpl( final int id, final KmerAdjacency firstKmerAdjacency ) {\n+            this.id = id;\n+            final StringBuilder sb = new StringBuilder(firstKmerAdjacency.toString());\n+            int maxObservations = firstKmerAdjacency.getNObservations();\n+            KmerAdjacency lastKmerAdjacency = firstKmerAdjacency;\n+            for ( KmerAdjacency kmerAdjacency = firstKmerAdjacency.getSoleSuccessor();\n+                  kmerAdjacency != null;\n+                  kmerAdjacency = kmerAdjacency.getSoleSuccessor() ) {\n+                // if we've gone around a circle, or if we're branching backwards, or if we hit a palindrome u-turn\n+                if ( firstKmerAdjacency == kmerAdjacency ||\n+                        kmerAdjacency.getPredecessorCount() != 1 ||\n+                        kmerAdjacency == lastKmerAdjacency.rc() ) {\n+                    break;\n+                }\n+                sb.append(\"ACGT\".charAt(kmerAdjacency.getFinalCall()));\n+                maxObservations = Math.max(maxObservations, kmerAdjacency.getNObservations());\n+                lastKmerAdjacency = kmerAdjacency;\n+            }\n+            this.sequence = sb.toString();\n+            this.maxObservations = maxObservations;\n+            this.firstKmer = firstKmerAdjacency;\n+            this.lastKmer = lastKmerAdjacency;\n+            this.predecessors = new ArrayList<>(firstKmer.getPredecessorCount());\n+            this.successors = new ArrayList<>(lastKmer.getSuccessorCount());\n+            this.rc = new ContigRCImpl(this);\n+\n+            int offset = 0;\n+            for ( KmerAdjacency kmerAdjacency = firstKmerAdjacency;\n+                  kmerAdjacency != lastKmerAdjacency;\n+                  kmerAdjacency = kmerAdjacency.getSoleSuccessor() ) {\n+                kmerAdjacency.setContigOffset(this, offset++);\n+            }\n+            lastKmerAdjacency.setContigOffset(this, offset);\n+        }\n+\n+        // create a new contig by joining two contigs\n+        public ContigImpl( final int id, final Contig predecessor, final Contig successor ) {\n+            if ( predecessor == successor || predecessor == successor.rc() ) {\n+                throw new GATKException(\"can't self-join\");\n+            }\n+            this.id = id;\n+            final StringBuilder sb = new StringBuilder(predecessor.getSequence());\n+            final CharSequence successorSequence = successor.getSequence();\n+            sb.append(successorSequence.subSequence(Kmer.KSIZE - 1, successorSequence.length()));\n+            this.sequence = sb.toString();\n+            this.maxObservations =\n+                    Math.max(predecessor.getMaxObservations(), successor.getMaxObservations());\n+            this.firstKmer = predecessor.getFirstKmer();\n+            this.lastKmer = successor.getLastKmer();\n+            this.predecessors = new ArrayList<>(predecessor.getPredecessors().size());\n+            this.successors = new ArrayList<>(successor.getSuccessors().size());\n+            this.rc = new ContigRCImpl(this);\n+\n+            // fix predecessor linkages to point to new contig\n+            for ( final Contig predPredecessor : predecessor.getPredecessors() ) {\n+                if ( predPredecessor == successor ) {\n+                    predecessors.add(this);\n+                } else if ( predPredecessor == predecessor.rc() ) {\n+                    predecessors.add(rc);\n+                } else {\n+                    predecessors.add(predPredecessor);\n+                    final List<Contig> successors = predPredecessor.getSuccessors();\n+                    successors.set(successors.indexOf(predecessor), this);\n+                }\n+            }\n+\n+            // fix successor linkages to point to new contig\n+            for ( final Contig succSuccessor : successor.getSuccessors() ) {\n+                if ( succSuccessor == predecessor ) {\n+                    successors.add(this);\n+                } else if ( succSuccessor == successor.rc() ) {\n+                    successors.add(rc);\n+                } else {\n+                    successors.add(succSuccessor);\n+                    final List<Contig> predecessors = succSuccessor.getPredecessors();\n+                    predecessors.set(predecessors.indexOf(successor), this);\n+                }\n+            }\n+        }\n+\n+        @Override public int getId() { return id; }\n+        @Override public CharSequence getSequence() { return sequence; }\n+        @Override public int getMaxObservations() { return maxObservations; }\n+        @Override public KmerAdjacency getFirstKmer() { return firstKmer; }\n+        @Override public KmerAdjacency getLastKmer() { return lastKmer; }\n+        @Override public List<Contig> getPredecessors() { return predecessors; }\n+        @Override public List<Contig> getSuccessors() { return successors; }\n+        @Override public int getComponentId() { return componentId; }\n+        public void setComponentId( final int id ) { this.componentId = id; }\n+        @Override public int size() { return sequence.length(); }\n+        @Override public Contig rc() { return rc; }\n+        @Override public boolean isCyclic() { return cyclic; }\n+        @Override public void setCyclic( final boolean cyclic ) { this.cyclic = cyclic; }\n+        @Override public boolean isCut() { return cut; }\n+        @Override public void setCut( final boolean cut ) { this.cut = cut; }\n+        @Override public boolean isCanonical() { return true; }\n+        @Override public ContigImpl canonical() { return this; }\n+        @Override public String toString() { return \"c\" + id; }\n+    }\n+\n+    /**\n+     * Implementation of Contig for the reverse-complement of some other Contig.\n+     * Which one is the \"real\" Contig, and which is the \"RC\" is completely arbitrary, since there\n+     * is no notion of canonical for Contigs.\n+     **/\n+    public static final class ContigRCImpl implements Contig {\n+        private final CharSequence sequence;\n+        private final List<Contig> predecessors;\n+        private final List<Contig> successors;\n+        private final ContigImpl rc;\n+\n+        public ContigRCImpl( final ContigImpl contig ) {\n+            this.sequence = new SequenceRC(contig.getSequence());\n+            this.predecessors = new ContigListRC(contig.getSuccessors());\n+            this.successors = new ContigListRC(contig.getPredecessors());\n+            this.rc = contig;\n+        }\n+\n+        @Override public int getId() { return ~rc.getId(); }\n+        @Override public CharSequence getSequence() { return sequence; }\n+        @Override public int getMaxObservations() { return rc.getMaxObservations(); }\n+        @Override public KmerAdjacency getFirstKmer() { return rc.getLastKmer().rc(); }\n+        @Override public KmerAdjacency getLastKmer() { return rc.getFirstKmer().rc(); }\n+        @Override public List<Contig> getPredecessors() { return predecessors; }\n+        @Override public List<Contig> getSuccessors() { return successors; }\n+        @Override public int getComponentId() { return rc.getComponentId(); }\n+        @Override public int size() { return sequence.length(); }\n+        @Override public Contig rc() { return rc; }\n+        @Override public boolean isCyclic() { return rc.isCyclic(); }\n+        @Override public void setCyclic( final boolean cyclic ) { rc.setCyclic(cyclic); }\n+        @Override public boolean isCut() { return rc.isCut(); }\n+        @Override public void setCut( final boolean cut ) { rc.setCut(cut); }\n+        @Override public boolean isCanonical() { return false; }\n+        @Override public ContigImpl canonical() { return rc; }\n+        @Override public String toString() { return rc.toString() + \"RC\"; }\n+    }\n+\n+    /** A CharSequence that is a view of the reverse-complement of another sequence. **/\n+    public static final class SequenceRC implements CharSequence, Comparable<CharSequence> {\n+        private final int lenLess1;\n+        private final CharSequence sequence;\n+\n+        public SequenceRC( final CharSequence sequence ) {\n+            this.lenLess1 = sequence.length() - 1;\n+            this.sequence = sequence;\n+        }\n+\n+        @Override public int length() { return sequence.length(); }\n+        @Override public char charAt( final int index ) {\n+            final char result;\n+            switch ( Character.toUpperCase(sequence.charAt(lenLess1 - index)) ) {\n+                case 'A': result = 'T'; break;\n+                case 'C': result = 'G'; break;\n+                case 'G': result = 'C'; break;\n+                case 'T': result = 'A'; break;\n+                default: result = 'N'; break;\n+            }\n+            return result;\n+        }\n+        @Override public CharSequence subSequence( final int start, final int end ) {\n+            return new StringBuilder(end - start).append(this, start, end).toString();\n+        }\n+        @Override public String toString() { return new StringBuilder(this).toString(); }\n+\n+        @Override public int compareTo( final CharSequence charSequence ) {\n+            final int len1 = length();\n+            final int len2 = charSequence.length();\n+            final int cmpLen = Math.min(len1, len2);\n+            for ( int idx = 0; idx != cmpLen; ++idx ) {\n+                final char char1 = charAt(idx);\n+                final char char2 = Character.toUpperCase(charSequence.charAt(idx));\n+                if ( char1 > char2 ) return 1;\n+                if ( char1 < char2 ) return -1;\n+            }\n+            return Integer.compare(len1, len2);\n+        }\n+    }\n+\n+    /** A list of Contigs that presents a reverse-complemented view of a List of Contigs. **/\n+    public static final class ContigListRC extends AbstractList<Contig> {\n+        private final List<Contig> contigList;\n+\n+        public ContigListRC( final List<Contig> contigList ) {\n+            this.contigList = contigList;\n+        }\n+\n+        @Override public Contig get( final int index ) {\n+            return contigList.get(reflectIndex(index)).rc();\n+        }\n+        @Override public int size() { return contigList.size(); }\n+        @Override public Contig set( final int index, final Contig contig ) {\n+            return contigList.set(reflectIndex(index), contig.rc()).rc();\n+        }\n+        @Override public void add( final int index, final Contig contig ) {\n+            contigList.add(reflectIndex(index), contig.rc());\n+        }\n+        @Override public Contig remove( final int index ) {\n+            return contigList.remove(reflectIndex(index)).rc();\n+        }\n+\n+        private int reflectIndex( final int index ) { return size() - 1 - index; }\n+    }\n+\n+    /** A single-Contig portion of a path across the assembly graph. **/\n+    public interface PathPart {\n+        Contig getContig(); // will be null for PathParts that depart from the graph (PathPartGap)\n+        CharSequence getSequence(); // will be null for PathParts on the graph (PathPartContig)\n+        void extend( final char call );\n+        int getStart();\n+        int getStop();\n+        boolean isGap();\n+        int getLength();\n+        PathPart rc();\n+        char getFirstCall();\n+        char getLastCall();\n+        default boolean startsAtBeginning() { return getStart() == 0; }\n+        default boolean stopsAtEnd() { return getStop() + Kmer.KSIZE - 1 == getContig().size(); }\n+    }\n+\n+    /** A part of a path that isn't present in the graph. **/\n+    public static final class PathPartGap implements PathPart {\n+        private final StringBuilder sequence = new StringBuilder();\n+\n+        public PathPartGap( final KmerAdjacency kmer ) { sequence.append(kmer.toString()); }\n+        private PathPartGap( final CharSequence sequence ) { this.sequence.append(sequence); }\n+\n+        @Override public Contig getContig() { return null; }\n+        @Override public CharSequence getSequence() { return sequence.toString(); }\n+        @Override public void extend( final char call ) { sequence.append(call); }\n+        @Override public int getStart() { return 0; }\n+        @Override public int getStop() { return sequence.length(); }\n+        @Override public boolean isGap() { return true; }\n+        @Override public int getLength() { return sequence.length() - Kmer.KSIZE + 1; }\n+        @Override public PathPart rc() { return new PathPartGap(new SequenceRC(sequence)); }\n+        @Override public char getFirstCall() { return sequence.charAt(Kmer.KSIZE - 1); }\n+        @Override public char getLastCall() {\n+            return sequence.charAt(sequence.length() - Kmer.KSIZE + 1);\n+        }\n+    }\n+\n+    /** A part of a path that is present as a sub-sequence of some Contig. **/\n+    public static final class PathPartContig implements PathPart {\n+        private final Contig contig;\n+        private final int start;\n+        private int stop;\n+\n+        public PathPartContig( final Contig contig, final int start ) {\n+            this(contig, start, start+1);\n+        }\n+        public PathPartContig( final Contig contig, final int start, final int stop ) {\n+            this.contig = contig;\n+            this.start = start;\n+            this.stop = stop;\n+        }\n+\n+        @Override public Contig getContig() { return contig; }\n+        @Override public String getSequence() { return null; }\n+        @Override public void extend( final char call ) { stop += 1; }\n+        @Override public int getStart() { return start; }\n+        @Override public int getStop() { return stop; }\n+        @Override public boolean isGap() { return false; }\n+        @Override public int getLength() { return stop - start; }\n+        @Override public PathPart rc() {\n+            final int revBase = contig.size() - Kmer.KSIZE + 1;\n+            return new PathPartContig(contig.rc(), revBase - stop, revBase - start);\n+        }\n+        @Override public char getFirstCall() {\n+            return getContig().getSequence().charAt(start + Kmer.KSIZE - 1);\n+        }\n+        @Override public char getLastCall() { return getContig().getSequence().charAt(stop - 1); }\n+    }\n+\n+    /** A path through the assembly graph for something (probably a read). **/\n+    public static final class Path {\n+        private final List<PathPart> parts;\n+\n+        public Path( final byte[] calls,\n+                     final KmerSet<KmerAdjacency> kmerAdjacencySet ) {\n+            parts = new ArrayList<>();\n+            long kVal = 0;\n+            int count = 0;\n+            PathPart currentPathPart = null;\n+            for ( int idx = 0; idx != calls.length; ++idx ) {\n+                final char call = (char)calls[idx];\n+                kVal <<= 2;\n+                switch ( call ) {\n+                    case 'C': case 'c': kVal += 1; break;\n+                    case 'G': case 'g': kVal += 2; break;\n+                    case 'T': case 't': kVal += 3; break;\n+                }\n+                if ( ++count >= Kmer.KSIZE ) {\n+                    final KmerAdjacency kmer = KmerAdjacencyImpl.find(kVal, kmerAdjacencySet);\n+                    // if we fail to look up the kmer\n+                    if ( kmer == null ) {\n+                        if ( currentPathPart == null ) {\n+                            // if there's no current path part, just create the 1st one as a PathPartGap\n+                            currentPathPart = new PathPartGap(new KmerAdjacencyImpl(kVal));\n+                            parts.add(currentPathPart);\n+                        } else if ( currentPathPart.isGap() ) {\n+                            // if the current path part is a PathPartGap, just extend it\n+                            currentPathPart.extend(call);\n+                        } else {\n+                            // new PathPartGap\n+                            currentPathPart = new PathPartGap(new KmerAdjacencyImpl(kVal));\n+                            parts.add(currentPathPart);\n+                        }\n+                    } else {\n+                        // we've found our kmer\n+                        final Contig contig = kmer.getContig();\n+                        if ( currentPathPart == null ) {\n+                            // we've looked up a kmer, but don't have a current path part -- create one\n+                            currentPathPart = new PathPartContig(contig, kmer.getContigOffset());\n+                            parts.add(currentPathPart);\n+                        } else if ( contig == currentPathPart.getContig() ) {\n+                            // our lookup is on the current path part's contig -- extend it\n+                            final int kmerOffset = kmer.getContigOffset();\n+                            final int curStop = currentPathPart.getStop();\n+                            if ( kmerOffset == curStop ) {\n+                                currentPathPart.extend(call);\n+                            } else if ( kmerOffset == 0 && contig.getNKmers() == curStop ) {\n+                                // cycle onto same contig\n+                                currentPathPart = new PathPartContig(contig, 0);\n+                                parts.add(currentPathPart);\n+                            } else {\n+                                // weird:  kmer is non-contiguous.  start a new path part after a zero-length gap", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e2201c1ef4f8ba71f17e169f07756cfe2f1ecb49"}, "originalPosition": 2043}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxNDQwMjU0NA==", "bodyText": "Not an error, and I've changed the comment to make it less alarming.  Reads with sequencing errors that produce kmers that aren't in the graph can make the read paths appear to jump arbitrarily.", "url": "https://github.com/broadinstitute/gatk/pull/6989#discussion_r614402544", "createdAt": "2021-04-15T21:27:43Z", "author": {"login": "tedsharpe"}, "path": "src/main/java/org/broadinstitute/hellbender/tools/LocalAssembler.java", "diffHunk": "@@ -0,0 +1,2306 @@\n+package org.broadinstitute.hellbender.tools;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import htsjdk.samtools.Cigar;\n+import htsjdk.samtools.CigarElement;\n+import htsjdk.samtools.CigarOperator;\n+import htsjdk.samtools.SAMUtils;\n+import org.broadinstitute.barclay.argparser.Argument;\n+import org.broadinstitute.barclay.argparser.BetaFeature;\n+import org.broadinstitute.barclay.argparser.CommandLineProgramProperties;\n+import org.broadinstitute.barclay.help.DocumentedFeature;\n+import org.broadinstitute.hellbender.cmdline.StandardArgumentDefinitions;\n+import org.broadinstitute.hellbender.cmdline.programgroups.CoverageAnalysisProgramGroup;\n+import org.broadinstitute.hellbender.exceptions.GATKException;\n+import org.broadinstitute.hellbender.tools.walkers.PairWalker;\n+import org.broadinstitute.hellbender.utils.SimpleInterval;\n+import org.broadinstitute.hellbender.utils.collections.HopscotchSet;\n+import org.broadinstitute.hellbender.utils.gcs.BucketUtils;\n+import org.broadinstitute.hellbender.utils.read.GATKRead;\n+\n+import java.io.BufferedWriter;\n+import java.io.FileWriter;\n+import java.io.IOException;\n+import java.io.OutputStreamWriter;\n+import java.util.*;\n+import java.util.zip.GZIPOutputStream;\n+\n+@DocumentedFeature\n+@CommandLineProgramProperties(\n+        summary = \"experiment\",\n+        oneLineSummary = \"experiment\",\n+        usageExample = \"gatk LocalAssembler\",\n+        programGroup = CoverageAnalysisProgramGroup.class\n+)\n+@BetaFeature\n+public class LocalAssembler extends PairWalker {\n+    public static final byte QMIN = 25;\n+    public static final int MIN_THIN_OBS = 4;\n+    public static final int MIN_GAPFILL_COUNT = 3;\n+    public static final int TOO_MANY_TRAVERSALS = 100000;\n+    public static final int TOO_MANY_SCAFFOLDS = 50000;\n+    public static final int MIN_SV_SIZE = 50;\n+\n+    @Argument(fullName=StandardArgumentDefinitions.OUTPUT_LONG_NAME,\n+            shortName=StandardArgumentDefinitions.OUTPUT_SHORT_NAME,\n+            doc=\"Write outputs to this file name prefix\", optional = true)\n+    public static String output;\n+\n+    @Argument(fullName=\"assembly-name\", doc=\"name of assembly used as a prefix for traversal names\")\n+    public static String assemblyName;\n+\n+    private final List<GATKRead> reads = new ArrayList<>();\n+\n+    @Override public boolean requiresIntervals() { return true; }\n+\n+    @Override public void apply( final GATKRead read, final GATKRead mate ) {\n+        trimOverruns(read, mate);\n+        reads.add(read);\n+        reads.add(mate);\n+    }\n+\n+    @Override public void applyUnpaired( final GATKRead read ) {\n+        reads.add(read);\n+    }\n+\n+    @Override public Object onTraversalSuccess() {\n+        super.onTraversalSuccess(); // flush any incomplete pairs\n+\n+        final int regionSize = getTraversalIntervals().stream().mapToInt(SimpleInterval::size).sum();\n+        final KmerSet<KmerAdjacency> kmerAdjacencySet = new KmerSet<>(10 * regionSize);\n+        kmerizeReads(reads, kmerAdjacencySet);\n+        List<ContigImpl> contigs = buildContigs(kmerAdjacencySet);\n+        connectContigs(contigs);\n+\n+        removeThinContigs(contigs, kmerAdjacencySet);\n+        weldPipes(contigs);\n+        markComponents(contigs);\n+\n+        if ( fillGaps(kmerAdjacencySet, reads) ) {\n+            contigs = buildContigs(kmerAdjacencySet);\n+            connectContigs(contigs);\n+            removeThinContigs(contigs, kmerAdjacencySet);\n+            weldPipes(contigs);\n+            markComponents(contigs);\n+        }\n+\n+        markCycles(contigs);\n+\n+        final String outputFilePrefix = output != null ? output : assemblyName;\n+        final List<Path> readPaths = pathReads(kmerAdjacencySet, reads);\n+        final Map<Contig,List<TransitPairCount>> contigTransitsMap =\n+                collectTransitPairCounts(contigs, readPaths);\n+        final String traversalsFilename = outputFilePrefix + \".traversals.fa.gz\";\n+        try {\n+            final List<Traversal> allTraversals =\n+                    new ArrayList<>(traverseAllPaths(contigs, readPaths, contigTransitsMap));\n+            writeTraversals(allTraversals, traversalsFilename);\n+            try {\n+                final String scaffoldsFileName = outputFilePrefix + \".scaffolds.fa.gz\";\n+                writeTraversals(createScaffolds(allTraversals), scaffoldsFileName);\n+            } catch ( final AssemblyTooComplexException x ) {\n+                logger.warn(\"Assembly too complex for scaffolding.\");\n+            }\n+        } catch ( final AssemblyTooComplexException x ) {\n+            logger.warn(\"Assembly too complex.  Writing contigs as traversals in \" +\n+                    traversalsFilename + \".\");\n+            final Collection<Traversal> contigTraversals = new ArrayList<>(contigs.size());\n+            for ( final Contig contig : contigs ) {\n+                contigTraversals.add(new Traversal(Collections.singletonList(contig)));\n+            }\n+            writeTraversals(contigTraversals, traversalsFilename);\n+        }\n+\n+        contigs.sort(Comparator.comparingInt(ContigImpl::getId));\n+        writeDOT(contigs, outputFilePrefix + \".assembly.dot\");\n+        writeContigs(contigs, outputFilePrefix + \".contigs.txt.gz\");\n+        writePaths(readPaths, outputFilePrefix + \".paths.txt.gz\");\n+        writeReads(reads, outputFilePrefix + \".reads.fastq.gz\");\n+        return null;\n+    }\n+\n+    /** trim read pairs of base calls that have gone past the end of a short fragment */\n+    private void trimOverruns( final GATKRead read, final GATKRead mate ) {\n+        // if both mapped and they're on different strands\n+        if ( !read.isUnmapped() && !mate.isUnmapped() &&\n+                read.isReverseStrand() != mate.isReverseStrand() ) {\n+            // and both start within 1 base on the ref\n+            if ( Math.abs(read.getStart() - read.getMateStart()) <= 1 ) {\n+                // and both end within 1 base\n+                final int readRefLen = read.getCigar().getReferenceLength();\n+                final int mateRefLen = mate.getCigar().getReferenceLength();\n+                if ( Math.abs(readRefLen - mateRefLen) <= 1 ) {\n+                    if ( mate.isReverseStrand() ) {\n+                        trimClips(read, mate);\n+                    } else {\n+                        trimClips(mate, read);\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    private void trimClips( final GATKRead fwd, final GATKRead rev ) {\n+        final List<CigarElement> fwdElements = fwd.getCigarElements();\n+        final List<CigarElement> revElements = rev.getCigarElements();\n+        final int lastElementIdx = fwdElements.size() - 1;\n+        final CigarElement fwdLastElement = fwdElements.get(lastElementIdx);\n+        final CigarElement revFirstElement = revElements.get(0);\n+        if ( fwdLastElement.getOperator() == CigarOperator.S &&\n+                revFirstElement.getOperator() == CigarOperator.S ) {\n+            final byte[] fwdBases = fwd.getBasesNoCopy();\n+            final int lastElementLen = fwdLastElement.getLength();\n+            fwd.setBases(Arrays.copyOfRange(fwdBases, 0, fwdBases.length - lastElementLen));\n+            final byte[] fwdQuals = fwd.getBaseQualitiesNoCopy();\n+            if ( fwdQuals.length > 0 ) {\n+                final int qualsLen = fwdQuals.length - lastElementLen;\n+                fwd.setBaseQualities(Arrays.copyOfRange(fwdQuals, 0, qualsLen));\n+            }\n+            final List<CigarElement> newFwdElements = new ArrayList<>(fwdElements);\n+            newFwdElements.set(lastElementIdx, new CigarElement(lastElementLen, CigarOperator.H));\n+            fwd.setCigar(new Cigar(newFwdElements));\n+\n+            final byte[] revBases = rev.getBasesNoCopy();\n+            final int firstElementLen = revFirstElement.getLength();\n+            rev.setBases(Arrays.copyOfRange(revBases, firstElementLen, revBases.length));\n+            final byte[] revQuals = rev.getBaseQualitiesNoCopy();\n+            if ( revQuals.length > 0 ) {\n+                rev.setBaseQualities(Arrays.copyOfRange(revQuals, firstElementLen, revQuals.length));\n+            }\n+            final List<CigarElement> newRevElements = new ArrayList<>(revElements);\n+            newRevElements.set(0, new CigarElement(firstElementLen, CigarOperator.H));\n+            rev.setCigar(new Cigar(newRevElements));\n+        }\n+    }\n+\n+    @VisibleForTesting\n+    static void kmerizeReads( final List<GATKRead> reads,\n+                              final KmerSet<KmerAdjacency> kmerAdjacencySet ) {\n+        for ( final GATKRead read : reads ) {\n+            final byte[] calls = read.getBasesNoCopy();\n+            final byte[] quals = read.getBaseQualitiesNoCopy();\n+            KmerAdjacency.kmerize(calls, quals, QMIN, kmerAdjacencySet);\n+        }\n+    }\n+\n+    /** gather unbranched strings of kmers into contigs **/\n+    @VisibleForTesting\n+    static List<ContigImpl> buildContigs( final KmerSet<KmerAdjacency> kmerAdjacencySet ) {\n+        // gather strings of kmers that have a single predecessor and single successor into contigs\n+        final List<ContigImpl> contigs = new ArrayList<>();\n+        int nContigs = 0;\n+        for ( final KmerAdjacency kmerAdjacency : kmerAdjacencySet ) {\n+            if ( kmerAdjacency.getContig() == null ) {\n+                ContigImpl contig = null;\n+                final KmerAdjacency predecessor = kmerAdjacency.getSolePredecessor();\n+                if ( predecessor == null ||\n+                        predecessor.getSuccessorCount() > 1 ||\n+                        predecessor == kmerAdjacency.rc() ) {\n+                    contig = new ContigImpl(++nContigs, kmerAdjacency);\n+                } else {\n+                    final KmerAdjacency successor = kmerAdjacency.getSoleSuccessor();\n+                    if ( successor == null ||\n+                            successor.getPredecessorCount() > 1 ||\n+                            successor == kmerAdjacency.rc() ) {\n+                        contig = new ContigImpl(++nContigs, kmerAdjacency.rc());\n+                    }\n+                }\n+                if ( contig != null ) {\n+                    contigs.add(contig);\n+                }\n+            }\n+        }\n+\n+        // if there are smooth circles like a plasmid, gather them together as a contig, too\n+        for ( final KmerAdjacency kmerAdjacency : kmerAdjacencySet ) {\n+            if ( kmerAdjacency.getContig() == null ) {\n+                contigs.add(new ContigImpl(++nContigs, kmerAdjacency));\n+            }\n+        }\n+\n+        return contigs;\n+    }\n+\n+    /** connect contigs when the final kmer of one contig is adjacent to the inital contig of another **/\n+    @VisibleForTesting\n+    static void connectContigs( final List<ContigImpl> contigs ) {\n+        final int nContigs = contigs.size();\n+        final KmerSet<ContigEndKmer> contigEnds = new KmerSet<>(2*nContigs);\n+        for ( int contigId = 0; contigId != nContigs; ++contigId ) {\n+            final ContigImpl contig = contigs.get(contigId);\n+            final KmerAdjacency fwdKmer = contig.getFirstKmer();\n+            final KmerAdjacency revKmer = contig.getLastKmer().rc();\n+            if ( fwdKmer == revKmer ) {\n+                contigEnds.add(new ContigEndKmer(fwdKmer.getKVal(), contig, ContigOrientation.BOTH));\n+            } else {\n+                contigEnds.add(new ContigEndKmer(fwdKmer.getKVal(), contig, ContigOrientation.FWD));\n+                contigEnds.add(new ContigEndKmer(revKmer.getKVal(), contig, ContigOrientation.REV));\n+            }\n+        }\n+\n+        for ( int contigId = 0; contigId != nContigs; ++contigId ) {\n+            final Contig contig = contigs.get(contigId);\n+\n+            final KmerAdjacency start = contig.getFirstKmer();\n+            final int predecessorCount = start.getPredecessorCount();\n+            if ( predecessorCount > 0 ) {\n+                final List<Contig> predecessors = contig.getPredecessors();\n+                final int mask = start.getPredecessorMask();\n+                for ( int call = 0; call != 4; ++call ) {\n+                    if ( (mask & (1 << call)) != 0 ) {\n+                        final long kVal =\n+                                KmerAdjacency.reverseComplement(start.getPredecessorVal(call));\n+                        final ContigEndKmer contigEndKmer = contigEnds.find(new Kmer(kVal));\n+                        if ( contigEndKmer == null ) {\n+                            throw new GATKException(\"missing contig end kmer\");\n+                        }\n+                        switch ( contigEndKmer.getContigOrientation() ) {\n+                            case FWD:\n+                                predecessors.add(contigEndKmer.getContig().rc());\n+                                break;\n+                            case REV:\n+                                predecessors.add(contigEndKmer.getContig());\n+                                break;\n+                            case BOTH:\n+                                predecessors.add(contigEndKmer.getContig());\n+                                predecessors.add(contigEndKmer.getContig().rc());\n+                                break;\n+                        }\n+                    }\n+                }\n+            }\n+\n+            final KmerAdjacency end = contig.getLastKmer();\n+            final int successorCount = end.getSuccessorCount();\n+            if ( successorCount > 0 ) {\n+                final List<Contig> successors = contig.getSuccessors();\n+                final int mask = end.getSuccessorMask();\n+                for ( int call = 0; call != 4; ++call ) {\n+                    if ( (mask & (1 << call)) != 0 ) {\n+                        final long kVal = end.getSuccessorVal(call);\n+                        final ContigEndKmer contigEndKmer = contigEnds.find(new Kmer(kVal));\n+                        if ( contigEndKmer == null ) {\n+                            throw new GATKException(\"missing contig end kmer\");\n+                        }\n+                        switch ( contigEndKmer.getContigOrientation() ) {\n+                            case FWD:\n+                                successors.add(contigEndKmer.getContig());\n+                                break;\n+                            case REV:\n+                                successors.add(contigEndKmer.getContig().rc());\n+                                break;\n+                            case BOTH:\n+                                successors.add(contigEndKmer.getContig());\n+                                successors.add(contigEndKmer.getContig().rc());\n+                                break;\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    /** remove contigs that have little evidence **/\n+    @VisibleForTesting\n+    static void removeThinContigs( final List<ContigImpl> contigs,\n+                                           final KmerSet<KmerAdjacency> kmerAdjacencySet ) {\n+        contigs.sort(Comparator.comparingInt(ContigImpl::getMaxObservations));\n+        boolean contigRemoved;\n+        do {\n+            // figure out which contigs are cut points\n+            // i.e., those contigs which, if removed, would result in a graph with more connected components\n+            final int nContigs = contigs.size();\n+            final Map<Contig, CutData> cutDataMap = new HashMap<>(nContigs * 3);\n+\n+            for ( final ContigImpl contig : contigs ) {\n+                if ( cutDataMap.containsKey(contig) ) {\n+                    continue;\n+                }\n+\n+                cutDataMap.put(contig, new CutData());\n+                int children = 0;\n+                for ( final Contig nextContig : contig.getSuccessors() ) {\n+                    if ( !cutDataMap.containsKey(nextContig) ) {\n+                        findCuts(nextContig, contig, cutDataMap);\n+                        children += 1;\n+                    }\n+                }\n+                for ( final Contig nextContig : contig.getPredecessors() ) {\n+                    if ( !cutDataMap.containsKey(nextContig) ) {\n+                        findCuts(nextContig, contig, cutDataMap);\n+                        children += 1;\n+                    }\n+                }\n+                if ( children >= 2 ) {\n+                    contig.setCut(true);\n+                }\n+            }\n+\n+            // remove poorly attested (low max observations) contigs, unless they are cut points\n+            contigRemoved = false;\n+            final Iterator<ContigImpl> itr = contigs.iterator();\n+            while ( itr.hasNext() ) {\n+                final Contig contig = itr.next();\n+                if ( contig.getMaxObservations() < MIN_THIN_OBS && !contig.isCut() ) {\n+                    unlinkContig(contig, kmerAdjacencySet);\n+                    itr.remove();\n+                    contigRemoved = true;\n+                    break;\n+                }\n+            }\n+        } while ( contigRemoved );\n+        contigs.sort(Comparator.comparingInt(ContigImpl::getId));\n+    }\n+\n+    private static CutData findCuts( final Contig contig,\n+                                     final Contig parent,\n+                                     final Map<Contig, CutData> cutDataMap ) {\n+        final CutData cutData = new CutData();\n+        cutDataMap.put(contig, cutData);\n+        for ( final Contig nextContig : contig.getSuccessors() ) {\n+            if ( nextContig == parent ) {\n+                continue;\n+            }\n+            CutData nextCutData = cutDataMap.get(nextContig);\n+            if ( nextCutData != null ) {\n+                cutData.minVisitNum = Math.min(cutData.minVisitNum, nextCutData.visitNum);\n+            } else {\n+                nextCutData = findCuts(nextContig, contig, cutDataMap);\n+                cutData.minVisitNum = Math.min(cutData.minVisitNum, nextCutData.minVisitNum);\n+                if ( nextCutData.minVisitNum >= cutData.visitNum ) {\n+                    contig.setCut(true);\n+                }\n+            }\n+        }\n+        for ( final Contig nextContig : contig.getPredecessors() ) {\n+            if ( nextContig == parent ) {\n+                continue;\n+            }\n+            CutData nextCutData = cutDataMap.get(nextContig);\n+            if ( nextCutData != null ) {\n+                cutData.minVisitNum = Math.min(cutData.minVisitNum, nextCutData.visitNum);\n+            } else {\n+                nextCutData = findCuts(nextContig, contig, cutDataMap);\n+                cutData.minVisitNum = Math.min(cutData.minVisitNum, nextCutData.minVisitNum);\n+                if ( nextCutData.minVisitNum >= cutData.visitNum ) {\n+                    contig.setCut(true);\n+                }\n+            }\n+        }\n+        return cutData;\n+    }\n+\n+    @VisibleForTesting\n+    static void unlinkContig( final Contig contig,\n+                                      final KmerSet<KmerAdjacency> kmerAdjacencySet ) {\n+        final KmerAdjacency firstKmer = contig.getFirstKmer();\n+        final int firstKmerFinalCall = firstKmer.getFinalCall();\n+        for ( final Contig predecessor : contig.getPredecessors() ) {\n+            if ( predecessor != contig && predecessor != contig.rc() ) {\n+                predecessor.getLastKmer().removeSuccessor(firstKmerFinalCall, kmerAdjacencySet);\n+                if ( !predecessor.getSuccessors().remove(contig) ) {\n+                    throw new GATKException(\"failed to find predecessor link\");\n+                }\n+            }\n+        }\n+\n+        final KmerAdjacency lastKmer = contig.getLastKmer();\n+        final int lastKmerInitialCall = lastKmer.getInitialCall();\n+        for ( final Contig successor : contig.getSuccessors() ) {\n+            if ( successor != contig && successor != contig.rc() ) {\n+                successor.getFirstKmer().removePredecessor(lastKmerInitialCall, kmerAdjacencySet);\n+                if ( !successor.getPredecessors().remove(contig) ) {\n+                    throw new GATKException(\"failed to find successor link\");\n+                }\n+            }\n+        }\n+\n+        KmerAdjacency nextKmer = firstKmer;\n+        KmerAdjacency kmer;\n+        do {\n+            kmer = nextKmer;\n+            nextKmer = kmer.getSoleSuccessor();\n+            kmerAdjacencySet.remove(kmer.canonical());\n+        } while ( kmer != lastKmer );\n+    }\n+\n+    private static void updateKmerContig( final KmerAdjacency firstKmer,\n+                                          final KmerAdjacency lastKmer,\n+                                          final Contig contig ) {\n+        int offset = 0;\n+        for ( KmerAdjacency kmer = firstKmer; kmer != lastKmer; kmer = kmer.getSoleSuccessor() ) {\n+            if ( kmer == null ) {\n+                throw new GATKException(\"contig does not have a flat pipeline of kmers\");\n+            }\n+            kmer.clearContig();\n+            kmer.setContigOffset(contig, offset++);\n+        }\n+        lastKmer.clearContig();\n+        lastKmer.setContigOffset(contig, offset);\n+        if ( offset + Kmer.KSIZE != contig.size() ) {\n+            throw new GATKException(\"kmer chain length does not equal contig size\");\n+        }\n+    }\n+\n+    /** replace adjacent contigs without branches with a single, larger contig **/\n+    @VisibleForTesting\n+    static void weldPipes( final List<ContigImpl> contigs ) {\n+        for ( int contigIdx = 0; contigIdx != contigs.size(); ++contigIdx ) {\n+            final ContigImpl contig = contigs.get(contigIdx);\n+            if ( contig.getSuccessors().size() == 1 ) {\n+                final Contig successor = contig.getSuccessors().get(0);\n+                if ( successor != contig && successor != contig.rc() &&\n+                        successor.getPredecessors().size() == 1 ) {\n+                    contigs.set(contigIdx, join(contig.getId(), contig, successor));\n+                    if ( !contigs.remove(successor.canonical()) ) {\n+                        throw new GATKException(\"successor linkage is messed up\");\n+                    }\n+                    contigIdx -= 1; // reconsider the new contig -- there might be more joining possible\n+                    continue;\n+                }\n+            }\n+            if ( contig.getPredecessors().size() == 1 ) {\n+                final Contig predecessor = contig.getPredecessors().get(0);\n+                if ( predecessor != contig && predecessor != contig.rc() &&\n+                        predecessor.getSuccessors().size() == 1 ) {\n+                    contigs.set(contigIdx, join(contig.getId(), predecessor, contig));\n+                    if ( !contigs.remove(predecessor.canonical()) ) {\n+                        throw new GATKException(\"predecessor linkage is messed up\");\n+                    }\n+                    contigIdx -= 1; // reconsider\n+                }\n+            }\n+        }\n+    }\n+\n+    private static ContigImpl join( final int id, final Contig predecessor, final Contig successor ) {\n+        if ( !checkOverlap(predecessor.getSequence(), successor.getSequence()) ) {\n+                throw new GATKException(\"sequences can't be joined\");\n+        }\n+        final ContigImpl joinedContig = new ContigImpl(id, predecessor, successor);\n+        updateKmerContig(joinedContig.getFirstKmer(), joinedContig.getLastKmer(), joinedContig);\n+        return joinedContig;\n+    }\n+\n+    private static boolean checkOverlap( final CharSequence seq1, final CharSequence seq2 ) {\n+        final int seq1Len = seq1.length();\n+        final CharSequence seq1SubSeq = seq1.subSequence(seq1Len - Kmer.KSIZE + 1, seq1Len);\n+        final CharSequence seq2SubSeq = seq2.subSequence(0, Kmer.KSIZE - 1);\n+        return seq1SubSeq.equals(seq2SubSeq);\n+    }\n+\n+    /** set a unique componentId for every connected group of contigs **/\n+    @VisibleForTesting\n+    static int markComponents( final List<ContigImpl> contigs ) {\n+        for ( final ContigImpl contig : contigs ) {\n+            contig.setComponentId(0);\n+        }\n+\n+        int componentId = 0;\n+        for ( final ContigImpl contig : contigs ) {\n+            if ( contig.getComponentId() == 0 ) {\n+                contig.setComponentId(++componentId);\n+                markSuccessorComponents(contig);\n+                markSuccessorComponents(contig.rc());\n+            }\n+        }\n+        return componentId;\n+    }\n+\n+    private static void markSuccessorComponents( final Contig contig ) {\n+        final int componentId = contig.getComponentId();\n+        for ( final Contig successor : contig.getSuccessors() ) {\n+            if ( successor.getComponentId() == 0 ) {\n+                successor.canonical().setComponentId(componentId);\n+                markSuccessorComponents(successor);\n+                markSuccessorComponents(successor.rc());\n+            }\n+        }\n+    }\n+\n+    @VisibleForTesting\n+    static void markCycles( final List<ContigImpl> contigs ) {\n+        for ( final Contig contig : contigs ) {\n+            contig.setCyclic(false);\n+        }\n+\n+        final int nContigs = contigs.size();\n+        final Deque<Contig> deque = new ArrayDeque<>(nContigs);\n+        final Map<Contig, CutData> cutDataMap = new HashMap<>(nContigs * 3);\n+        for ( final Contig contig : contigs ) {\n+            if ( !cutDataMap.containsKey(contig) ) {\n+                markCyclesRecursion(contig, deque, cutDataMap);\n+            }\n+        }\n+    }\n+\n+    private static CutData markCyclesRecursion( final Contig contig,\n+                                                final Deque<Contig> deque,\n+                                                final Map<Contig, CutData> cutDataMap ) {\n+        final CutData cutData = new CutData();\n+        cutDataMap.put(contig, cutData);\n+        deque.addFirst(contig);\n+\n+        for ( final Contig successor : contig.getSuccessors() ) {\n+            final CutData successorCutData = cutDataMap.get(successor);\n+            if ( successorCutData == null ) {\n+                final int recursionVisitNum =\n+                        markCyclesRecursion(successor, deque, cutDataMap).minVisitNum;\n+                cutData.minVisitNum = Math.min(cutData.minVisitNum, recursionVisitNum);\n+            } else {\n+                cutData.minVisitNum = Math.min(cutData.minVisitNum, successorCutData.visitNum);\n+            }\n+        }\n+\n+        if ( cutData.visitNum == cutData.minVisitNum ) {\n+            Contig tig = deque.removeFirst();\n+            if ( tig == contig ) {\n+                cutDataMap.get(tig).visitNum = Integer.MAX_VALUE;\n+\n+                // single-vertex component -- cyclic only if self-referential\n+                if ( tig.getSuccessors().contains(tig) ) {\n+                    tig.setCyclic(true);\n+                }\n+            } else {\n+                while ( true ) {\n+                    // kill cross-links\n+                    cutDataMap.get(tig).visitNum = Integer.MAX_VALUE;\n+                    tig.setCyclic(true);\n+                    if ( tig == contig ) break;\n+                    tig = deque.removeFirst();\n+                }\n+            }\n+        }\n+        return cutData;\n+    }\n+\n+    @VisibleForTesting\n+    static boolean fillGaps( final KmerSet<KmerAdjacency> kmerAdjacencySet,\n+                             final List<GATKRead> reads ) {\n+        final Map<String, Integer> gapFillCounts = new HashMap<>();\n+        for ( final GATKRead read : reads ) {\n+            final Path path = new Path(read.getBasesNoCopy(), kmerAdjacencySet);\n+            final List<PathPart> parts = path.getParts();\n+            final int lastIdx = parts.size() - 1;\n+            for ( int idx = 1; idx < lastIdx; ++idx ) {\n+                final PathPart pathPart = parts.get(idx);\n+                if ( pathPart.isGap() ) {\n+                    final char prevCall = parts.get(idx - 1).getLastCall();\n+                    final char nextCall = parts.get(idx + 1).getFirstCall();\n+                    String gapFill = prevCall + pathPart.getSequence().toString() + nextCall;\n+                    final SequenceRC gapFillRC = new SequenceRC(gapFill);\n+                    if ( gapFillRC.compareTo(gapFill) < 0 ) {\n+                        gapFill = gapFillRC.toString();\n+                    }\n+                    gapFillCounts.merge(gapFill, 1, Integer::sum);\n+                }\n+            }\n+        }\n+\n+        boolean newKmers = false;\n+        for ( final Map.Entry<String, Integer> entry : gapFillCounts.entrySet() ) {\n+            final int nObservations = entry.getValue();\n+            if ( nObservations >= MIN_GAPFILL_COUNT ) {\n+                KmerAdjacency.kmerize(entry.getKey(), nObservations, kmerAdjacencySet);\n+                newKmers = true;\n+            }\n+        }\n+\n+        if ( newKmers ) {\n+            for ( final KmerAdjacency kmerAdjacency : kmerAdjacencySet ) {\n+                kmerAdjacency.clearContig();\n+            }\n+        }\n+        return newKmers;\n+    }\n+\n+    @VisibleForTesting\n+    static List<Path> pathReads( final KmerSet<KmerAdjacency> kmerAdjacencySet,\n+                          final List<GATKRead> reads ) {\n+        final List<Path> readPaths = new ArrayList<>(reads.size());\n+        for ( final GATKRead read : reads ) {\n+            readPaths.add(new Path(read.getBasesNoCopy(), kmerAdjacencySet));\n+        }\n+        return readPaths;\n+    }\n+\n+    @VisibleForTesting\n+    static Map<Contig,List<TransitPairCount>> collectTransitPairCounts(\n+            final List<ContigImpl> contigs,\n+            final List<Path> readPaths ) {\n+        final Map<Contig,List<TransitPairCount>> contigTransitsMap =\n+                new HashMap<>(3 * contigs.size());\n+        for ( final Path path : readPaths ) {\n+            final List<PathPart> parts = path.getParts();\n+            final int lastPart = parts.size() - 1;\n+            for ( int partIdx = 1; partIdx < lastPart; ++partIdx ) {\n+                final Contig prevContig = parts.get(partIdx - 1).getContig();\n+                if ( prevContig == null ) continue;\n+                final Contig curContig = parts.get(partIdx).getContig();\n+                if ( curContig == null ) {\n+                    partIdx += 1;\n+                    continue;\n+                }\n+                final Contig nextContig = parts.get(partIdx + 1).getContig();\n+                if ( nextContig == null ) {\n+                    partIdx += 2;\n+                    continue;\n+                }\n+                final TransitPairCount tpc = new TransitPairCount(prevContig, nextContig);\n+                final List<TransitPairCount> tpcList =\n+                        contigTransitsMap.computeIfAbsent(curContig, tig -> new ArrayList<>(4));\n+                final int idx = tpcList.indexOf(tpc);\n+                if ( idx != -1 ) {\n+                    tpcList.get(idx).observe();\n+                } else {\n+                    tpcList.add(tpc);\n+                    contigTransitsMap.computeIfAbsent(curContig.rc(), tig -> new ArrayList<>(4))\n+                            .add(tpc.getRC());\n+                }\n+            }\n+        }\n+        return contigTransitsMap;\n+    }\n+\n+    @VisibleForTesting\n+    static Set<Traversal> traverseAllPaths(\n+            final List<ContigImpl> contigs,\n+            final List<Path> readPaths,\n+            final Map<Contig, List<TransitPairCount>> contigTransitsMap ) {\n+        final Set<Traversal> traversalSet = new HashSet<>();\n+        final List<Contig> contigsList = new ArrayList<>();\n+        for ( final Contig contig : contigs ) {\n+            // untransited contigs are sources, sinks, or large contigs that can't be crossed by a read\n+            // build traversals from these\n+            if ( !contigTransitsMap.containsKey(contig) ) {\n+                boolean done = false;\n+                for ( final Contig successor : contig.getSuccessors() ) {\n+                    traverse(successor, contig,\n+                            contigsList, readPaths, contigTransitsMap, traversalSet);\n+                    done = true;\n+                }\n+                for ( final Contig predecessor : contig.getPredecessors() ) {\n+                    traverse(predecessor.rc(), contig.rc(),\n+                            contigsList, readPaths, contigTransitsMap, traversalSet);\n+                    done = true;\n+                }\n+                if ( !done ) { // if there were no predecessors or successors, it stands alone\n+                    addTraversal(new Traversal(Collections.singletonList(contig)), traversalSet);\n+                }\n+            }\n+        }\n+\n+        // look for transits that haven't been traced\n+        for ( final Map.Entry<Contig, List<TransitPairCount>> entry :\n+                contigTransitsMap.entrySet() ) {\n+            for ( final TransitPairCount tpc : entry.getValue() ) {\n+                if ( tpc.getCount() > 0 ) {\n+                    tpc.resetCount();\n+                    final Contig contig = entry.getKey();\n+                    final Set<Traversal> fwdTraversalSet = new HashSet<>();\n+                    traverse(tpc.getNextContig(), contig,\n+                            contigsList, readPaths, contigTransitsMap, fwdTraversalSet);\n+                    final Set<Traversal> revTraversalSet = new HashSet<>();\n+                    traverse(tpc.getPrevContig().rc(), contig.rc(),\n+                            contigsList, readPaths, contigTransitsMap, revTraversalSet);\n+                    for ( final Traversal revTraversal : revTraversalSet ) {\n+                        final Traversal revTraversalRC = revTraversal.rc();\n+                        for ( final Traversal fwdTraversal : fwdTraversalSet ) {\n+                            final int overlap =\n+                                    findMaxOverlap(revTraversalRC.getContigs(), fwdTraversal.getContigs());\n+                            final Traversal combo =\n+                                    Traversal.combineOverlappers(revTraversalRC, fwdTraversal, overlap);\n+                            addTraversal(combo, traversalSet);\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+\n+        return traversalSet;\n+    }\n+\n+    private static int findMaxOverlap( final List<Contig> prefixes, final List<Contig> suffixes ) {\n+        final int nPrefixes = prefixes.size();\n+        final Contig firstSuffix = suffixes.get(0);\n+        if ( !firstSuffix.isCyclic() ) {\n+            return prefixes.get(nPrefixes - 1) == firstSuffix ? 1 : 0;\n+        }\n+        final int nSuffixes = suffixes.size();\n+        for ( int prefixIdx = Math.max(0, nPrefixes - nSuffixes); prefixIdx != nPrefixes; ++prefixIdx ) {\n+            if ( prefixes.get(prefixIdx) == firstSuffix ) {\n+                int suffixIdx = 1;\n+                boolean match = true;\n+                for ( int prefixIdx2 = prefixIdx + 1; prefixIdx2 != nPrefixes; ++prefixIdx2 ) {\n+                    if ( prefixes.get(prefixIdx2) != suffixes.get(suffixIdx++) ) {\n+                        match = false;\n+                        break;\n+                    }\n+                }\n+                if ( match ) {\n+                    return nPrefixes - prefixIdx;\n+                }\n+            }\n+        }\n+        return 0;\n+    }\n+\n+    private static void traverse( final Contig contig,\n+                                  final Contig predecessor,\n+                                  final List<Contig> contigsList,\n+                                  final List<Path> readPaths,\n+                                  final Map<Contig, List<TransitPairCount>> contigTransitsMap,\n+                                  final Set<Traversal> traversalSet ) {\n+        contigsList.add(predecessor);\n+        if ( contig.isCyclic() ) {\n+            traverseCycle(contig, contigsList, readPaths, contigTransitsMap, traversalSet);\n+            contigsList.remove(contigsList.size() - 1);\n+            return;\n+        }\n+        final List<TransitPairCount> transits = contigTransitsMap.get(contig);\n+        boolean done = false;\n+        if ( transits != null ) {\n+            for ( final TransitPairCount tpc : transits ) {\n+                if ( tpc.getPrevContig() == predecessor ) {\n+                    final Contig successor = tpc.getNextContig();\n+                    if ( predecessor == contig.rc() ) {\n+                        final int nContigs = contigsList.size();\n+                        if ( nContigs > 1 ) {\n+                            if ( successor.rc() == contigsList.get(nContigs - 2) ) {\n+                                continue;\n+                            }\n+                        }\n+                    }\n+                    tpc.resetCount();\n+                    traverse(successor, contig, contigsList, readPaths, contigTransitsMap, traversalSet);\n+                    done = true;\n+                }\n+            }\n+        }\n+        if ( !done ) {\n+            contigsList.add(contig);\n+            addTraversal(new Traversal(contigsList), traversalSet);\n+            contigsList.remove(contigsList.size() - 1);\n+        }\n+        contigsList.remove(contigsList.size() - 1);\n+    }\n+\n+    private static void traverseCycle( final Contig contig,\n+                                       final List<Contig> contigsList,\n+                                       final List<Path> readPaths,\n+                                       final Map<Contig, List<TransitPairCount>> contigTransitsMap,\n+                                       final Set<Traversal> traversalSet ) {\n+        contigsList.add(contig);\n+        final int nContigs = contigsList.size();\n+        // the final element of the list is cyclic, if there's a previous element it will be\n+        // non-cyclic, so start there figuring out how far the read paths lead us\n+        final List<List<Contig>> longestPaths =\n+                findLongestPaths(contigsList.subList(Math.max(0, nContigs - 2), nContigs), readPaths);\n+        // didn't get anywhere -- just complete the traversal\n+        if ( longestPaths.isEmpty() ) {\n+            addTraversal(new Traversal(contigsList, true), traversalSet);\n+        } else {\n+            // for each unique extension into the cycle\n+            for ( final List<Contig> path : longestPaths ) {\n+                // don't think this can happen, but still\n+                if ( path.isEmpty() ) {\n+                    addTraversal(new Traversal(contigsList, true), traversalSet);\n+                    continue;\n+                }\n+                final List<Contig> extendedContigsList =\n+                        new ArrayList<>(contigsList.size() + path.size());\n+                extendedContigsList.addAll(contigsList);\n+                // if we didn't get out of the cycle\n+                if ( path.get(path.size() - 1).isCyclic() ) {\n+                    extendedContigsList.addAll(path);\n+                    addTraversal(new Traversal(extendedContigsList, true), traversalSet);\n+                } else {\n+                    // we found a cycle-exiting path, so extend that normally\n+                    for ( final Contig curContig : path ) {\n+                        if ( curContig.isCyclic() ) {\n+                            extendedContigsList.add(curContig);\n+                        } else {\n+                            final Contig prevContig =\n+                                    extendedContigsList.remove(extendedContigsList.size() - 1);\n+                            traverse(curContig, prevContig, extendedContigsList, readPaths,\n+                                    contigTransitsMap, traversalSet);\n+                            extendedContigsList.add(prevContig);\n+                            break;\n+                        }\n+                    }\n+                }\n+                clearTransitPairs(contigTransitsMap, extendedContigsList);\n+            }\n+        }\n+        contigsList.remove(contigsList.size() - 1);\n+    }\n+\n+    private static void clearTransitPairs(\n+            final Map<Contig, List<TransitPairCount>> contigTransitsMap,\n+            final List<Contig> contigsList ) {\n+        final int lastIdx = contigsList.size() - 1;\n+        for ( int idx = 1; idx < lastIdx; ++idx ) {\n+            final List<TransitPairCount> pairCounts = contigTransitsMap.get(contigsList.get(idx));\n+            if ( pairCounts != null ) {\n+                final Contig predecessor = contigsList.get(idx - 1);\n+                final Contig successor = contigsList.get(idx + 1);\n+                for ( final TransitPairCount tpc : pairCounts ) {\n+                    if ( tpc.getPrevContig() == predecessor && tpc.getNextContig() == successor ) {\n+                        tpc.resetCount();\n+                        break;\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    private static void addTraversal( final Traversal traversal,\n+                                      final Set<Traversal> traversalSet ) {\n+        if ( !traversalSet.contains(traversal.rc()) ) {\n+            traversalSet.add(traversal);\n+            if ( traversalSet.size() >= TOO_MANY_TRAVERSALS ) {\n+                throw new AssemblyTooComplexException();\n+            }\n+        }\n+    }\n+\n+    private static List<List<Contig>> findLongestPaths( final List<Contig> toMatch,\n+                                                        final List<Path> readPaths ) {\n+        final List<List<Contig>> results = new ArrayList<>();\n+        for ( final Path path : readPaths ) {\n+            testPath(path, toMatch, results);\n+            testPath(path.rc(), toMatch, results);\n+        }\n+        return results;\n+    }\n+\n+    private static void testPath( final Path path,\n+                                  final List<Contig> toMatch,\n+                                  final List<List<Contig>> results ) {\n+        final List<PathPart> pathParts = path.getParts();\n+        final int nPathParts = pathParts.size();\n+        final List<Contig> pathContigs = new ArrayList<>(nPathParts);\n+        pathParts.forEach(pp -> pathContigs.add(pp.getContig()));\n+        final int matchIdx = Collections.indexOfSubList(pathContigs, toMatch);\n+        if ( matchIdx != -1 ) {\n+            final int suffixIdx = matchIdx + toMatch.size();\n+            if ( suffixIdx < nPathParts ) {\n+                resolveResult(grabParts(pathContigs, suffixIdx), results);\n+            }\n+        }\n+    }\n+\n+    private static List<Contig> grabParts( final List<Contig> pathContigs, final int suffixIdx ) {\n+        final int nPathContigs = pathContigs.size();\n+        Contig prev = pathContigs.get(suffixIdx - 1);\n+        final List<Contig> result = new ArrayList<>(nPathContigs - suffixIdx);\n+        for ( int idx = suffixIdx; idx != nPathContigs; ++idx ) {\n+            final Contig tig = pathContigs.get(idx);\n+            if ( tig == null || !prev.getSuccessors().contains(tig) ) break;\n+            result.add(tig);\n+            prev = tig;\n+        }\n+        return result;\n+    }\n+\n+    private static void resolveResult( final List<Contig> result,\n+                                       final List<List<Contig>> results ) {\n+        final int nResults = results.size();\n+        for ( int idx = 0; idx != nResults; ++idx ) {\n+            final List<Contig> test = results.get(idx);\n+            if ( isPrefix(result, test) ) return;\n+            if ( isPrefix(test, result) ) {\n+                results.set(idx, result);\n+                return;\n+            }\n+        }\n+        results.add(result);\n+    }\n+\n+    private static boolean isPrefix( final List<Contig> list1, final List<Contig> list2 ) {\n+        final int list1Size = list1.size();\n+        final int list2Size = list2.size();\n+        if ( list1Size > list2Size ) return false;\n+        for ( int idx = 0; idx != list1Size; ++idx ) {\n+            if ( list1.get(idx) != list2.get(idx) ) return false;\n+        }\n+        return true;\n+    }\n+\n+    @VisibleForTesting\n+    static Collection<Traversal> createScaffolds( final List<Traversal> allTraversals ) {\n+        removeTriviallyDifferentTraversals(allTraversals);\n+\n+        final int nTraversals = allTraversals.size();\n+        final Map<Contig, List<Integer>> traversalsByFirstContig = new HashMap<>(3 * nTraversals);\n+        for ( int idx = 0; idx != nTraversals; ++idx ) {\n+            final Traversal traversal = allTraversals.get(idx);\n+            traversalsByFirstContig.compute(traversal.getFirstContig(),\n+                    ( k, v ) -> v == null ? new ArrayList<>(3) : v).add(idx);\n+            final Traversal rcTraversal = traversal.rc();\n+            traversalsByFirstContig.compute(rcTraversal.getFirstContig(),\n+                    ( k, v ) -> v == null ? new ArrayList<>(3) : v).add(~idx);\n+        }\n+\n+        final List<Traversal> scaffolds = new ArrayList<>(nTraversals);\n+        final boolean[] touched = new boolean[nTraversals];\n+        for ( int idx = 0; idx != nTraversals; ++idx ) {\n+            if ( !touched[idx] ) {\n+                expandTraversal(idx, touched, traversalsByFirstContig, allTraversals, scaffolds);\n+            }\n+        }\n+        return scaffolds;\n+    }\n+\n+    private static void expandTraversal( final int traversalIdx,\n+                                         final boolean[] touched,\n+                                         final Map<Contig, List<Integer>> traversalsByFirstContig,\n+                                         final List<Traversal> allTraversals,\n+                                         final List<Traversal> scaffolds ) {\n+        final Traversal traversal = allTraversals.get(traversalIdx);\n+        touched[traversalIdx] = true;\n+        final List<Traversal> downExtensions = new ArrayList<>();\n+        final Set<Contig> startingContigSet = new HashSet<>();\n+        walkTraversals(traversal, touched, startingContigSet, traversalsByFirstContig,\n+                        allTraversals, downExtensions);\n+        final List<Traversal> upExtensions = new ArrayList<>();\n+        walkTraversals(traversal.rc(), touched, startingContigSet, traversalsByFirstContig,\n+                        allTraversals, upExtensions);\n+        for ( final Traversal down : downExtensions ) {\n+            for ( final Traversal up : upExtensions ) {\n+                if ( scaffolds.size() >= TOO_MANY_SCAFFOLDS ) {\n+                    throw new AssemblyTooComplexException();\n+                }\n+                scaffolds.add(Traversal.combineOverlappers(up.rc(), down, traversal.getContigs().size()));\n+            }\n+        }\n+    }\n+\n+    private static void walkTraversals( final Traversal traversal,\n+                                        final boolean[] touched,\n+                                        final Set<Contig> startingContigSet,\n+                                        final Map<Contig, List<Integer>> traversalsByFirstContig,\n+                                        final List<Traversal> allTraversals,\n+                                        final List<Traversal> extensions ) {\n+        final Contig firstContig = traversal.getFirstContig();\n+        final List<Integer> indexList;\n+        if ( startingContigSet.contains(firstContig) ||\n+                traversal.isInextensible() ||\n+                (indexList = traversalsByFirstContig.get(traversal.getLastContig())) == null ) {\n+            extensions.add(traversal);\n+            return;\n+        }\n+        startingContigSet.add(firstContig);\n+        for ( int idx : indexList ) {\n+            final Traversal extension;\n+            if ( idx >= 0 ) {\n+                extension = allTraversals.get(idx);\n+                touched[idx] = true;\n+            } else {\n+                final int rcIdx = ~idx;\n+                extension = allTraversals.get(rcIdx).rc();\n+                touched[rcIdx] = true;\n+            }\n+            walkTraversals(Traversal.combine(traversal, extension), touched, startingContigSet,\n+                            traversalsByFirstContig, allTraversals, extensions );\n+        }\n+        startingContigSet.remove(firstContig);\n+    }\n+\n+    private static void removeTriviallyDifferentTraversals(\n+                                            final Collection<Traversal> allTraversals ) {\n+        if ( allTraversals.isEmpty() ) {\n+            return;\n+        }\n+        final TreeSet<Traversal> sortedTraversals = new TreeSet<>(new TraversalEndpointComparator());\n+        for ( final Traversal traversal : allTraversals ) {\n+            sortedTraversals.add(traversal);\n+            sortedTraversals.add(traversal.rc());\n+        }\n+        final Iterator<Traversal> traversalIterator = sortedTraversals.iterator();\n+        Traversal prevTraversal = traversalIterator.next();\n+        while ( traversalIterator.hasNext() ) {\n+            final Traversal curTraversal = traversalIterator.next();\n+            if ( isTriviallyDifferent(prevTraversal, curTraversal) ) {\n+                traversalIterator.remove();\n+            } else {\n+                prevTraversal = curTraversal;\n+            }\n+        }\n+        sortedTraversals.removeIf(Traversal::isRC);\n+        allTraversals.clear();\n+        allTraversals.addAll(sortedTraversals);\n+    }\n+\n+    private static boolean isTriviallyDifferent( final Traversal traversal1,\n+                                                 final Traversal traversal2 ) {\n+        final Contig firstContig1 = traversal1.getFirstContig();\n+        final Contig lastContig1 = traversal1.getLastContig();\n+        final Contig firstContig2 = traversal2.getFirstContig();\n+        final Contig lastContig2 = traversal2.getLastContig();\n+        if ( firstContig1 != firstContig2 || lastContig1 != lastContig2 ) {\n+            return false;\n+        }\n+        final int interiorSize1 = traversal1.getSequenceLength() - firstContig1.size() - lastContig1.size();\n+        final int interiorSize2 = traversal2.getSequenceLength() - firstContig2.size() - lastContig2.size();\n+\n+        // if the path lengths are so different that one could harbor an SV, they're not trivially different\n+        if ( Math.abs(interiorSize1 - interiorSize2) >= MIN_SV_SIZE ) {\n+            return false;\n+        }\n+\n+        // if the paths are small enough that there can't be an SV's worth of differences, they're trivially different\n+        final int maxInteriorSize = Math.max(interiorSize1, interiorSize2);\n+        if ( maxInteriorSize < MIN_SV_SIZE ) {\n+            return true;\n+        }\n+\n+        // dang, maybe there's enough material in common that there can't be an SV's worth of differences\n+        // run a longest common subsequence algorithm to figure out the length of the common material\n+        // DP matrix holds length of common material\n+        final List<Contig> contigs1 = traversal1.getContigs();\n+        final int rowLen = contigs1.size() - 1;\n+        final int[][] rowPair = new int[2][];\n+        rowPair[0] = new int[rowLen];\n+        rowPair[1] = new int[rowLen];\n+        int pairIdx = 0;\n+        final List<Contig> contigs2 = traversal2.getContigs();\n+        final int nRows = contigs2.size() - 1;\n+        for ( int idx2 = 1; idx2 != nRows; ++idx2 ) {\n+            final int[] curRow = rowPair[pairIdx];\n+            final int[] prevRow = rowPair[pairIdx ^ 1];\n+            pairIdx ^= 1;\n+\n+            final int id2 = contigs2.get(idx2).getId();\n+            for ( int idx1 = 1; idx1 != rowLen; ++idx1 ) {\n+                final Contig tig1 = contigs1.get(idx1);\n+                if ( tig1.getId() == id2 ) {\n+                    // if the previous cells also contain a match we've already removed the K-1 bases upstream\n+                    final boolean extendMatch =\n+                            contigs1.get(idx1 -1).getId() == contigs2.get(idx2 - 1).getId();\n+                    curRow[idx1] = prevRow[idx1 - 1] + (extendMatch ? tig1.getNKmers() : tig1.size());\n+                } else {\n+                    curRow[idx1] = Math.max(curRow[idx1 - 1], prevRow[idx1]);\n+                }\n+            }\n+        }\n+        final int commonLen = rowPair[pairIdx ^ 1][rowLen - 1];\n+        return (maxInteriorSize - commonLen) < MIN_SV_SIZE;\n+    }\n+\n+    private static class TraversalEndpointComparator implements Comparator<Traversal> {\n+        @Override\n+        public int compare( final Traversal traversal1, final Traversal traversal2 ) {\n+            int cmp = Integer.compare(traversal1.contigs.get(0).getId(),\n+                                      traversal2.contigs.get(0).getId());\n+            if ( cmp != 0 ) {\n+                return cmp;\n+            }\n+            final int last1 = traversal1.contigs.size() - 1;\n+            final int last2 = traversal2.contigs.size() - 1;\n+            cmp = Integer.compare(traversal1.contigs.get(last1).getId(),\n+                                  traversal2.contigs.get(last2).getId());\n+            if ( cmp != 0 ) {\n+                return cmp;\n+            }\n+            // among those starting and ending at the same place, sort least observed last\n+            return -Integer.compare(traversal1.getMinMaxObservations(), traversal2.getMinMaxObservations());\n+        }\n+    }\n+\n+    private static void writeDOT( final List<ContigImpl> contigs, final String fileName ) {\n+        try ( final BufferedWriter writer = new BufferedWriter(new FileWriter(fileName)) ) {\n+            writer.write(\"digraph {\\n\");\n+            for ( final Contig contig : contigs ) {\n+                final double width = contig.getSequence().length() / 100.;\n+                writer.write(contig + \" [width=\" + width + \"]\\n\");\n+                writer.write( contig.rc() + \" [width=\" + width + \"]\\n\");\n+            }\n+            for ( final Contig contig : contigs ) {\n+                for ( final Contig predecessor : contig.getPredecessors() ) {\n+                    final String predecessorName = predecessor.rc().toString();\n+                    writer.write(contig.rc() + \" -> \" + predecessorName + \"\\n\");\n+                }\n+                for ( final Contig successor : contig.getSuccessors() ) {\n+                    final String successorName = successor.toString();\n+                    writer.write(contig + \" -> \" + successorName + \"\\n\");\n+                }\n+            }\n+            writer.write(\"}\\n\");\n+        } catch ( final IOException ioe ) {\n+            throw new GATKException(\"Failed to write assembly DOT file.\", ioe);\n+        }\n+    }\n+\n+    private static BufferedWriter makeGZFile( final String fileName ) throws IOException {\n+        final GZIPOutputStream gzOS = new GZIPOutputStream(BucketUtils.createFile(fileName));\n+        return new BufferedWriter(new OutputStreamWriter(gzOS));\n+    }\n+\n+    private static void writeContigs( final List<ContigImpl> contigs, final String fileName ) {\n+        try ( final BufferedWriter writer = makeGZFile(fileName) ) {\n+            for ( final Contig contig : contigs ) {\n+                final List<Contig> predecessors = contig.getPredecessors();\n+                final String predecessorDescription;\n+                if ( predecessors.size() == 0 ) {\n+                    predecessorDescription = \"\\tnone\";\n+                } else {\n+                    final StringBuilder sb = new StringBuilder();\n+                    char prefix = '\\t';\n+                    for ( final Contig predecessor : predecessors ) {\n+                        sb.append(prefix);\n+                        prefix = ',';\n+                        sb.append(predecessor);\n+                    }\n+                    predecessorDescription = sb.toString();\n+                }\n+\n+                final List<Contig> successors = contig.getSuccessors();\n+                final String successorDescription;\n+                if ( successors.size() == 0 ) {\n+                    successorDescription = \"\\tnone\";\n+                } else {\n+                    final StringBuilder sb = new StringBuilder();\n+                    char prefix = '\\t';\n+                    for ( final Contig successor : successors ) {\n+                        sb.append(prefix);\n+                        prefix = ',';\n+                        sb.append(successor);\n+                    }\n+                    successorDescription = sb.toString();\n+                }\n+\n+                final String contigName = contig.toString();\n+                final String component =\n+                        (contig.isCyclic() ? \"(C)\\t\" : \"\\t\") + contig.getComponentId();\n+                writer.write(contigName + component + predecessorDescription +\n+                        successorDescription + \"\\t\" +\n+                        contig.getMaxObservations() + \"\\t\" +\n+                        contig.getFirstKmer().getNObservations() + \"\\t\" +\n+                        contig.getLastKmer().getNObservations() + \"\\t\" +\n+                        contig.size() + \"\\t\" +\n+                        contig.getSequence() + \"\\n\");\n+            }\n+        } catch ( final IOException ioe ) {\n+            throw new GATKException(\"Failed to write contigs file.\", ioe);\n+        }\n+    }\n+\n+    private static void writePaths( final List<Path> readPaths, final String fileName ) {\n+        try ( final BufferedWriter writer = makeGZFile(fileName) ) {\n+            final int nReads = readPaths.size();\n+            for ( int readId = 0; readId != nReads; ++readId ) {\n+                final Path path = readPaths.get(readId);\n+                final String pathDesc = path.toString();\n+                writer.write((readId + 1) + \": \" + pathDesc + \"\\n\");\n+            }\n+        } catch ( final IOException ioe ) {\n+            throw new GATKException(\"Failed to write paths file.\", ioe);\n+        }\n+    }\n+\n+    private static void writeReads( final List<GATKRead> reads, final String fileName ) {\n+        try ( final BufferedWriter writer = makeGZFile(fileName) ) {\n+            for ( final GATKRead read : reads ) {\n+                writer.write(\"@\" + read.getName());\n+                writer.write('\\n');\n+                writer.write(new String(read.getBasesNoCopy()));\n+                writer.write(\"\\n+\\n\");\n+                final byte[] quals = read.getBaseQualitiesNoCopy();\n+                final int nQuals = quals.length;\n+                final byte[] fastqQuals = new byte[nQuals];\n+                for ( int idx = 0; idx != nQuals; ++idx ) {\n+                    fastqQuals[idx] = (byte)SAMUtils.phredToFastq(quals[idx]);\n+                }\n+                writer.write(new String(fastqQuals));\n+                writer.write('\\n');\n+            }\n+        } catch ( final IOException ioe ) {\n+            throw new GATKException(\"Failed to write assembly sam file.\", ioe);\n+        }\n+    }\n+\n+    private static void writeTraversals( final Collection<Traversal> traversals,\n+                                         final String fileName ) {\n+        try ( final BufferedWriter writer = makeGZFile(fileName) ) {\n+            int traversalNo = 0;\n+            for ( final Traversal traversal : traversals ) {\n+                writer.write(\">\");\n+                if ( assemblyName != null ) {\n+                    writer.write(assemblyName);\n+                    writer.write(\"_\");\n+                }\n+                writer.write(\"t\");\n+                writer.write(Integer.toString(++traversalNo));\n+                writer.write(\" \");\n+                writer.write(traversal.getName());\n+                writer.newLine();\n+                writer.write(traversal.getSequence());\n+                writer.newLine();\n+            }\n+        } catch ( final IOException ioe ) {\n+            throw new GATKException(\"Failed to write assembly sam file.\", ioe);\n+        }\n+    }\n+\n+    /** fixed-size, immutable kmer.  usual 2-bit encoding: ACGT->0123.  low order bits are final call. **/\n+    public static class Kmer {\n+        public static final int KSIZE = 31; // must be odd number less than 32\n+        public static final long KMASK = (1L << 2*KSIZE) - 1L;\n+        private final long kVal;\n+\n+        public Kmer( final long kVal ) { this.kVal = kVal; }\n+\n+        public long getKVal() { return kVal; }\n+        public boolean isCanonical() { return isCanonical(kVal); }\n+        public int getInitialCall() { return (int)(kVal >> (KSIZE*2 - 2)) & 3; }\n+        public int getFinalCall() { return (int)kVal & 3; }\n+\n+        public long getPredecessorVal( final int call ) {\n+            return (kVal >> 2) | ((long)call << (2 * (KSIZE - 1)));\n+        }\n+        public long getSuccessorVal( final int call ) { return ((kVal << 2) & KMASK) | call; }\n+\n+        public static boolean isCanonical( final long val ) {\n+            return (val & (1L << KSIZE)) == 0L;\n+        }\n+\n+        @Override public boolean equals( final Object obj ) {\n+            return obj instanceof Kmer && kVal == ((Kmer)obj).kVal;\n+        }\n+\n+        @Override public int hashCode() {\n+            return (int)(kVal ^ (kVal >>> 32));\n+        }\n+    }\n+\n+    /** Set of Kmers.  Uses HopscotchSet, customized to find correct starting bin for Kmers and derivatives. **/\n+    public static final class KmerSet<KMER extends Kmer> extends HopscotchSet<KMER> {\n+        public KmerSet( final int capacity ) { super(capacity); }\n+\n+        @Override\n+        protected int hashToIndex( final Object kmer ) {\n+            return (int)(((HopscotchSet.SPREADER * ((Kmer)kmer).getKVal()) & Long.MAX_VALUE) % capacity());\n+        }\n+    }\n+\n+    /**\n+     *  A Kmer that remembers its predecessors and successors, and the number of times it's been observed\n+     *  in the assembly's input set of reads.\n+     *  The masks are bit-wise (1=A, 2=C, 4=G, 8=T) to show which predecessors or successors have been observed.\n+     *  The Kmer's position on a Contig is also tracked (in later phases of the assembly process).\n+     **/\n+    public static abstract class KmerAdjacency extends Kmer {\n+        public KmerAdjacency( final long kVal ) { super(kVal); }\n+\n+        public abstract KmerAdjacency getSolePredecessor(); // returns null if there's 0 or >1 predecessors\n+        public abstract int getPredecessorMask();\n+        public abstract int getPredecessorCount();\n+        public abstract void removePredecessor( final int callToRemove,\n+                                                final KmerSet<KmerAdjacency> kmerAdjacencySet );\n+\n+        public abstract KmerAdjacency getSoleSuccessor(); // returns null if there's 0 or > 1 successors\n+        public abstract int getSuccessorMask();\n+        public abstract int getSuccessorCount();\n+        public abstract void removeSuccessor( final int callToRemove,\n+                                              final KmerSet<KmerAdjacency> kmerAdjacencySet );\n+\n+        public abstract Contig getContig();\n+        public abstract int getContigOffset();\n+        // offset is 0-based measure on the contig sequence of the beginning of the kmer\n+        public abstract void setContigOffset( final Contig contig, final int contigOffset );\n+        public abstract void clearContig();\n+\n+        public abstract int getNObservations();\n+        public abstract KmerAdjacency rc();\n+        public abstract KmerAdjacencyImpl canonical();\n+\n+        public void observe( final KmerAdjacency predecessor, final KmerAdjacency successor ) {\n+            observe(predecessor, successor, 1);\n+        }\n+\n+        public abstract void observe( final KmerAdjacency predecessor,\n+                                      final KmerAdjacency successor,\n+                                      final int count );\n+\n+        @Override public String toString() {\n+            final StringBuilder sb = new StringBuilder(KSIZE);\n+            long currentVal = getKVal();\n+            for ( int idx = 0; idx != KSIZE; ++idx ) {\n+                sb.append(\"ACGT\".charAt((int)currentVal & 3));\n+                currentVal >>= 2;\n+            }\n+            sb.reverse(); // low order bits were loaded into sb first:  fix that now by reversing the sb.\n+            return sb.toString();\n+        }\n+\n+        /**\n+         * Transform a read's calls into KmerAdjacencies, and add them to a KmerSet.\n+         * Skip kmers that include a call with a quality < qMin.\n+         * Skip kmers with non-ACGT calls.\n+         **/\n+        public static void kmerize( final byte[] calls,\n+                                    final byte[] quals,\n+                                    final byte qMin,\n+                                    final KmerSet<KmerAdjacency> kmerAdjacencySet ) {\n+            int currentCount = 0; // number of calls loaded into currentKVal\n+            long currentKVal = 0;\n+            KmerAdjacency prevAdjacency = null;\n+            KmerAdjacency currentAdjacency = null;\n+            for ( int idx = 0; idx < calls.length; ++idx ) {\n+                if ( quals[idx] < qMin ) { // if we encounter a low-quality call\n+                    // take care of the most recent valid KmerAdjacency, if any\n+                    if ( currentAdjacency != null ) {\n+                        currentAdjacency.observe(prevAdjacency, null);\n+                    }\n+                    // ready ourselves to accumulate calls afresh\n+                    currentCount = 0;\n+                    currentAdjacency = prevAdjacency = null;\n+                    continue;\n+                }\n+                currentKVal <<= 2;\n+                switch ( calls[idx] ) {\n+                    case 'A': case 'a': break;\n+                    case 'C': case 'c': currentKVal += 1; break;\n+                    case 'G': case 'g': currentKVal += 2; break;\n+                    case 'T': case 't': currentKVal += 3; break;\n+                    default:\n+                        if ( currentAdjacency != null ) {\n+                            currentAdjacency.observe(prevAdjacency, null);\n+                        }\n+                        currentCount = 0;\n+                        currentAdjacency = prevAdjacency = null;\n+                        continue;\n+                }\n+                if ( ++currentCount >= KSIZE ) { // if we've loaded enough calls to make a complete kmer\n+                    final KmerAdjacency nextAdjacency = findOrAdd(currentKVal, kmerAdjacencySet);\n+                    if ( currentAdjacency != null ) {\n+                        currentAdjacency.observe(prevAdjacency, nextAdjacency);\n+                    }\n+                    prevAdjacency = currentAdjacency;\n+                    currentAdjacency = nextAdjacency;\n+                }\n+            }\n+            if ( currentAdjacency != null ) {\n+                currentAdjacency.observe(prevAdjacency, null);\n+            }\n+        }\n+\n+        /**\n+         * Kmerize a String.  This version is for gap fills.\n+         * The number of observations applies to all kmers except the 1st and last.\n+         **/\n+        public static void kmerize( final String sequence,\n+                                    final int nObservations,\n+                                    final KmerSet<KmerAdjacency> kmerAdjacencySet ) {\n+            int currentCount = 0;\n+            long currentKVal = 0;\n+            int nObs = 0;\n+            KmerAdjacency prevAdjacency = null;\n+            KmerAdjacency currentAdjacency = null;\n+            final int nCalls = sequence.length();\n+            for ( int idx = 0; idx != nCalls; ++idx ) {\n+                currentKVal <<= 2;\n+                switch ( sequence.charAt(idx) ) {\n+                    case 'A': case 'a': break;\n+                    case 'C': case 'c': currentKVal += 1; break;\n+                    case 'G': case 'g': currentKVal += 2; break;\n+                    case 'T': case 't': currentKVal += 3; break;\n+                    default: throw new GATKException(\"unexpected base call in string to kmerize.\");\n+                }\n+                if ( ++currentCount >= KSIZE ) {\n+                    final KmerAdjacency nextAdjacency = findOrAdd(currentKVal, kmerAdjacencySet);\n+                    if ( currentAdjacency != null ) {\n+                        currentAdjacency.observe(prevAdjacency, nextAdjacency, nObs);\n+                        nObs = nObservations;\n+                    }\n+                    prevAdjacency = currentAdjacency;\n+                    currentAdjacency = nextAdjacency;\n+                }\n+            }\n+            if ( currentAdjacency != null ) {\n+                currentAdjacency.observe(prevAdjacency, null, 0);\n+            }\n+        }\n+\n+        // Lookup table for reverse-complementing each possible byte value.\n+        // Each pair of bits represents a base, so you have to reverse bits pairwise and then invert all bits.\n+        // This is most quickly and easily done with a lookup table.\n+        private static final long[] BYTEWISE_REVERSE_COMPLEMENT;\n+        static {\n+            BYTEWISE_REVERSE_COMPLEMENT = new long[256];\n+            for ( int bIn = 0; bIn != 256; ++bIn ) {\n+                BYTEWISE_REVERSE_COMPLEMENT[bIn] =\n+                        ~(((bIn & 3) << 6) | (((bIn >> 2) & 3) << 4) |\n+                                (((bIn >> 4) & 3) << 2) | ((bIn >> 6) & 3)) & 0xffL;\n+            }\n+        }\n+\n+        public static long reverseComplement( long val ) {\n+            // process val one byte at a time\n+            long result = BYTEWISE_REVERSE_COMPLEMENT[(int)val & 0xFF]; // handle the low-order byte\n+            int nBytes = 8;\n+            while ( --nBytes != 0 ) { // pre-decrementing:  we'll go through the loop 7 times\n+                // rotate down by a byte\n+                val >>= 8;\n+                // rotate up by a byte and OR in the reverse complement of the next byte\n+                result = (result << 8) | BYTEWISE_REVERSE_COMPLEMENT[(int)val & 0xFF];\n+            }\n+            return result >>> (Long.SIZE - 2*KSIZE);\n+        }\n+\n+        // Kmer lookup in KmerSet.\n+        // KmerSets holding KmerAdjacencies have only canonical Kmers, so RC non-canonical kmers before lookup.\n+        public static KmerAdjacency find( final long kVal,\n+                                          final KmerSet<KmerAdjacency> kmerAdjacencySet ) {\n+            if ( isCanonical(kVal) ) return kmerAdjacencySet.find(new Kmer(kVal & KMASK));\n+            final KmerAdjacency result = kmerAdjacencySet.find(new Kmer(reverseComplement(kVal)));\n+            return result == null ? null : result.rc();\n+        }\n+\n+        // Kmer lookup in KmerSet.\n+        // KmerSets holding KmerAdjacencies have only canonical Kmers, so RC non-canonical kmers before lookup.\n+        // Add missing Kmers.\n+        public static KmerAdjacency findOrAdd( final long kVal,\n+                                               final KmerSet<KmerAdjacency> kmerAdjacencySet ) {\n+            if ( isCanonical(kVal) ) {\n+                return kmerAdjacencySet.findOrAdd(new Kmer(kVal & KMASK), kmer ->\n+                        new KmerAdjacencyImpl(((Kmer)kmer).getKVal()));\n+            }\n+            return kmerAdjacencySet.findOrAdd(new Kmer(reverseComplement(kVal)), kmer ->\n+                    new KmerAdjacencyImpl(((Kmer)kmer).getKVal())).rc();\n+        }\n+    }\n+\n+    /**\n+     * Class to implement KmerAdjacency for canonical Kmers.\n+     * In particular, a KmerSet created on KmerAdjacency contains only canonical Kmers.\n+     **/\n+    public static final class KmerAdjacencyImpl extends KmerAdjacency {\n+        private KmerAdjacency solePredecessor; // set to null if there are no predecessors, or multiple predecessors\n+        private KmerAdjacency soleSuccessor; // set to null if there are no successors, or multiple successors\n+        private int predecessorMask; // bit mask of observed kmers preceding this one\n+        private int successorMask; // bit mask observed kmers following this one\n+        private Contig contig; // the contig that contains this Kmer\n+        private int contigOffset; // the offset within the contig where this kmer is found\n+        private int nObservations; // the reads in which this kmer was observed\n+        private final KmerAdjacencyRC rc; // the reverse-complement of this kmer\n+        private static final int[] COUNT_FOR_MASK =\n+                //side sum for binary values from 0 -> 15\n+                //0000  0001 0010 0011 0100 0101 0110 0111 1000 1001 1010 1011 1100 1101 1110 1111\n+                {    0,    1,   1,   2,   1,   2,   2,   3,   1,   2,   2,   3,   2,   3,   3,   4 };\n+\n+        public KmerAdjacencyImpl( final long kVal ) {\n+            super(kVal);\n+            this.rc = new KmerAdjacencyRC(this);\n+        }\n+\n+        @Override public KmerAdjacency getSolePredecessor() { return solePredecessor; } // may return null\n+        @Override public int getPredecessorMask() { return predecessorMask; }\n+        @Override public int getPredecessorCount() { return COUNT_FOR_MASK[predecessorMask]; }\n+        @Override\n+        public void removePredecessor( final int callToRemove,\n+                                       final KmerSet<KmerAdjacency> kmerAdjacencySet ) {\n+            predecessorMask &= ~(1 << callToRemove);\n+            solePredecessor = null;\n+            if ( getPredecessorCount() == 1 ) {\n+                for ( int call = 0; call != 4; ++call ) {\n+                    if ( ((1 << call) & predecessorMask) != 0 ) {\n+                        solePredecessor = find(getPredecessorVal(call), kmerAdjacencySet);\n+                        break;\n+                    }\n+                }\n+            }\n+        }\n+\n+        @Override public KmerAdjacency getSoleSuccessor() { return soleSuccessor; } // may return null\n+        @Override public int getSuccessorMask() { return successorMask; }\n+        @Override public int getSuccessorCount() { return COUNT_FOR_MASK[successorMask]; }\n+        @Override\n+        public void removeSuccessor( final int callToRemove,\n+                                     final KmerSet<KmerAdjacency> kmerAdjacencySet ) {\n+            successorMask &= ~(1 << callToRemove);\n+            soleSuccessor = null;\n+            if ( getSuccessorCount() == 1 ) {\n+                for ( int call = 0; call != 4; ++call ) {\n+                    if ( ((1 << call) & successorMask) != 0 ) {\n+                        soleSuccessor = find(getSuccessorVal(call), kmerAdjacencySet);\n+                        break;\n+                    }\n+                }\n+            }\n+        }\n+\n+        @Override public Contig getContig() { return contig; }\n+        @Override public int getContigOffset() { return contigOffset; }\n+        @Override public void setContigOffset( final Contig contig, final int contigOffset ) {\n+            if ( this.contig != null ) {\n+                throw new GATKException(\"Internal error: overwriting kmer contig and offset.\");\n+            }\n+            this.contig = contig;\n+            this.contigOffset = contigOffset;\n+        }\n+        @Override public void clearContig() { contig = null; contigOffset = 0; }\n+\n+        @Override public int getNObservations() { return nObservations; }\n+        @Override public KmerAdjacency rc() { return rc; }\n+        @Override public KmerAdjacencyImpl canonical() { return this; }\n+\n+        @Override public void observe( final KmerAdjacency predecessor,\n+                                       final KmerAdjacency successor,\n+                                       final int count ) {\n+            if ( predecessor != null ) {\n+                if ( predecessor.getSuccessorVal(getFinalCall()) != getKVal() ) {\n+                    throw new GATKException(\"illegal predecessor\");\n+                }\n+                final int initialCall = predecessor.getInitialCall();\n+                final int newPredecessorMask = 1 << initialCall;\n+                if ( (newPredecessorMask & predecessorMask) == 0 ) {\n+                    if ( predecessorMask == 0 ) {\n+                        solePredecessor = predecessor;\n+                        predecessorMask = newPredecessorMask;\n+                    } else {\n+                        solePredecessor = null;\n+                        predecessorMask |= newPredecessorMask;\n+                    }\n+                }\n+            }\n+            if ( successor != null ) {\n+                if ( successor.getPredecessorVal(getInitialCall()) != getKVal() ) {\n+                    throw new GATKException(\"illegal successor\");\n+                }\n+                final int finalCall = successor.getFinalCall();\n+                final int newSuccessorMask = 1 << finalCall;\n+                if ( (newSuccessorMask & successorMask) == 0 ) {\n+                    if ( successorMask == 0 ) {\n+                        soleSuccessor = successor;\n+                        successorMask = newSuccessorMask;\n+                    } else {\n+                        soleSuccessor = null;\n+                        successorMask |= newSuccessorMask;\n+                    }\n+                }\n+            }\n+            nObservations += count;\n+        }\n+    }\n+\n+    /**\n+     * Class to implement KmerAdjacency for Kmers that are the reverse-complement of a canonical Kmer.\n+     * In particular, a KmerSet created on KmerAdjacency contains only canonical Kmers.\n+     * A KmerAdjacencyRC represents the RC of each Kmer in the KmerSet.\n+     **/\n+    public static final class KmerAdjacencyRC extends KmerAdjacency {\n+        private final KmerAdjacencyImpl rc;\n+\n+        // lookup table to bit-reverse nibbles\n+        private static final int[] NIBREV =\n+                // 0000,  0001,  0010,  0011,  0100,  0101,  0110,  0111,  1000,  1001,  1010,  1011,  1100,  1101,  1110,  1111\n+                {0b0000,0b1000,0b0100,0b1100,0b0010,0b1010,0b0110,0b1110,0b0001,0b1001,0b0101,0b1101,0b0011,0b1011,0b0111,0b1111};\n+\n+        public KmerAdjacencyRC( final KmerAdjacencyImpl rc ) {\n+            super(reverseComplement(rc.getKVal()));\n+            this.rc = rc;\n+        }\n+\n+        @Override public KmerAdjacency getSolePredecessor() {\n+            final KmerAdjacency successor = rc.getSoleSuccessor();\n+            return successor == null ? null : successor.rc();\n+        }\n+        @Override public int getPredecessorMask() { return NIBREV[rc.getSuccessorMask()]; }\n+        @Override public int getPredecessorCount() { return rc.getSuccessorCount(); }\n+        @Override\n+        public void removePredecessor( final int callToRemove,\n+                                       final KmerSet<KmerAdjacency> kmerAdjacencySet ) {\n+            rc.removeSuccessor(3 - callToRemove, kmerAdjacencySet);\n+        }\n+\n+        @Override public KmerAdjacency getSoleSuccessor() {\n+            final KmerAdjacency predecessor = rc.getSolePredecessor();\n+            return predecessor == null ? null : predecessor.rc();\n+        }\n+        @Override public int getSuccessorMask() { return NIBREV[rc.getPredecessorMask()]; }\n+        @Override public int getSuccessorCount() { return rc.getPredecessorCount(); }\n+        @Override\n+        public void removeSuccessor( final int callToRemove,\n+                                     final KmerSet<KmerAdjacency> kmerAdjacencySet ) {\n+            rc.removePredecessor(3 - callToRemove, kmerAdjacencySet);\n+        }\n+\n+        @Override public Contig getContig() {\n+            final Contig contig = rc.getContig();\n+            return contig == null ? null : contig.rc();\n+        }\n+        @Override public int getContigOffset() {\n+            final Contig contig = rc.getContig();\n+            return contig == null ? 0 : contig.size() - rc.getContigOffset() - KSIZE;\n+        }\n+        @Override public void setContigOffset( final Contig contig, final int contigOffset ) {\n+            rc.setContigOffset(contig.rc(), contig.size() - contigOffset - KSIZE);\n+        }\n+        @Override public void clearContig() { rc.clearContig(); }\n+\n+        @Override public int getNObservations() { return rc.getNObservations(); }\n+        @Override public KmerAdjacency rc() { return rc; }\n+        @Override public KmerAdjacencyImpl canonical() { return rc; }\n+\n+        @Override public void observe( final KmerAdjacency predecessor,\n+                                       final KmerAdjacency successor,\n+                                       final int count ) {\n+            rc.observe(successor == null ? null : successor.rc(),\n+                    predecessor == null ? null : predecessor.rc(),\n+                    count);\n+        }\n+    }\n+\n+    public enum ContigOrientation {\n+        FWD, // k-mer appears at the 5' end of the contig\n+        REV, // k-mer appears at the 5' end of the reverse-complemented contig\n+        BOTH // k-mer occurs on 5' end of the contig and its RC (can happen when the contig is a palindrome)\n+    }\n+\n+    /** Initial or final Kmer in a Contig. **/\n+    public static final class ContigEndKmer extends Kmer {\n+        private final Contig contig;\n+        private final ContigOrientation contigOrientation;\n+\n+        public ContigEndKmer( final long kVal,\n+                              final Contig contig,\n+                              final ContigOrientation contigEnd ) {\n+            super(kVal);\n+            this.contig = contig;\n+            this.contigOrientation = contigEnd;\n+        }\n+\n+        public Contig getContig() { return contig; }\n+        public ContigOrientation getContigOrientation() { return contigOrientation; }\n+    }\n+\n+    /**\n+     * An unbranched sequence of Kmers.\n+     * Each Kmer (except the last one) has a single successor, which allows enumerating the sequence\n+     * of Kmers in the Contig.  The sequence of base calls in the Contig is just the sequence of kmers\n+     * with the K-1 overlapping calls removed from adjacent kmers.\n+     **/\n+    public interface Contig {\n+        int getId();\n+        CharSequence getSequence();\n+        int getMaxObservations();\n+        KmerAdjacency getFirstKmer();\n+        KmerAdjacency getLastKmer();\n+        List<Contig> getPredecessors();\n+        List<Contig> getSuccessors();\n+        int getComponentId();\n+        int size();\n+        default int getNKmers() { return size() - Kmer.KSIZE + 1; }\n+        Contig rc();\n+        boolean isCyclic();\n+        void setCyclic( final boolean cyclic );\n+        boolean isCut();\n+        void setCut( final boolean cut );\n+        boolean isCanonical();\n+        ContigImpl canonical();\n+    }\n+\n+    /** Simple implementation of Contig interface. **/\n+    public static final class ContigImpl implements Contig {\n+        private final int id;\n+        private final CharSequence sequence;\n+        private final int maxObservations;\n+        private final KmerAdjacency firstKmer;\n+        private final KmerAdjacency lastKmer;\n+        private final List<Contig> predecessors;\n+        private final List<Contig> successors;\n+        private int componentId;\n+        private boolean cyclic;\n+        private boolean cut;\n+        private final Contig rc;\n+\n+        public ContigImpl( final int id, final KmerAdjacency firstKmerAdjacency ) {\n+            this.id = id;\n+            final StringBuilder sb = new StringBuilder(firstKmerAdjacency.toString());\n+            int maxObservations = firstKmerAdjacency.getNObservations();\n+            KmerAdjacency lastKmerAdjacency = firstKmerAdjacency;\n+            for ( KmerAdjacency kmerAdjacency = firstKmerAdjacency.getSoleSuccessor();\n+                  kmerAdjacency != null;\n+                  kmerAdjacency = kmerAdjacency.getSoleSuccessor() ) {\n+                // if we've gone around a circle, or if we're branching backwards, or if we hit a palindrome u-turn\n+                if ( firstKmerAdjacency == kmerAdjacency ||\n+                        kmerAdjacency.getPredecessorCount() != 1 ||\n+                        kmerAdjacency == lastKmerAdjacency.rc() ) {\n+                    break;\n+                }\n+                sb.append(\"ACGT\".charAt(kmerAdjacency.getFinalCall()));\n+                maxObservations = Math.max(maxObservations, kmerAdjacency.getNObservations());\n+                lastKmerAdjacency = kmerAdjacency;\n+            }\n+            this.sequence = sb.toString();\n+            this.maxObservations = maxObservations;\n+            this.firstKmer = firstKmerAdjacency;\n+            this.lastKmer = lastKmerAdjacency;\n+            this.predecessors = new ArrayList<>(firstKmer.getPredecessorCount());\n+            this.successors = new ArrayList<>(lastKmer.getSuccessorCount());\n+            this.rc = new ContigRCImpl(this);\n+\n+            int offset = 0;\n+            for ( KmerAdjacency kmerAdjacency = firstKmerAdjacency;\n+                  kmerAdjacency != lastKmerAdjacency;\n+                  kmerAdjacency = kmerAdjacency.getSoleSuccessor() ) {\n+                kmerAdjacency.setContigOffset(this, offset++);\n+            }\n+            lastKmerAdjacency.setContigOffset(this, offset);\n+        }\n+\n+        // create a new contig by joining two contigs\n+        public ContigImpl( final int id, final Contig predecessor, final Contig successor ) {\n+            if ( predecessor == successor || predecessor == successor.rc() ) {\n+                throw new GATKException(\"can't self-join\");\n+            }\n+            this.id = id;\n+            final StringBuilder sb = new StringBuilder(predecessor.getSequence());\n+            final CharSequence successorSequence = successor.getSequence();\n+            sb.append(successorSequence.subSequence(Kmer.KSIZE - 1, successorSequence.length()));\n+            this.sequence = sb.toString();\n+            this.maxObservations =\n+                    Math.max(predecessor.getMaxObservations(), successor.getMaxObservations());\n+            this.firstKmer = predecessor.getFirstKmer();\n+            this.lastKmer = successor.getLastKmer();\n+            this.predecessors = new ArrayList<>(predecessor.getPredecessors().size());\n+            this.successors = new ArrayList<>(successor.getSuccessors().size());\n+            this.rc = new ContigRCImpl(this);\n+\n+            // fix predecessor linkages to point to new contig\n+            for ( final Contig predPredecessor : predecessor.getPredecessors() ) {\n+                if ( predPredecessor == successor ) {\n+                    predecessors.add(this);\n+                } else if ( predPredecessor == predecessor.rc() ) {\n+                    predecessors.add(rc);\n+                } else {\n+                    predecessors.add(predPredecessor);\n+                    final List<Contig> successors = predPredecessor.getSuccessors();\n+                    successors.set(successors.indexOf(predecessor), this);\n+                }\n+            }\n+\n+            // fix successor linkages to point to new contig\n+            for ( final Contig succSuccessor : successor.getSuccessors() ) {\n+                if ( succSuccessor == predecessor ) {\n+                    successors.add(this);\n+                } else if ( succSuccessor == successor.rc() ) {\n+                    successors.add(rc);\n+                } else {\n+                    successors.add(succSuccessor);\n+                    final List<Contig> predecessors = succSuccessor.getPredecessors();\n+                    predecessors.set(predecessors.indexOf(successor), this);\n+                }\n+            }\n+        }\n+\n+        @Override public int getId() { return id; }\n+        @Override public CharSequence getSequence() { return sequence; }\n+        @Override public int getMaxObservations() { return maxObservations; }\n+        @Override public KmerAdjacency getFirstKmer() { return firstKmer; }\n+        @Override public KmerAdjacency getLastKmer() { return lastKmer; }\n+        @Override public List<Contig> getPredecessors() { return predecessors; }\n+        @Override public List<Contig> getSuccessors() { return successors; }\n+        @Override public int getComponentId() { return componentId; }\n+        public void setComponentId( final int id ) { this.componentId = id; }\n+        @Override public int size() { return sequence.length(); }\n+        @Override public Contig rc() { return rc; }\n+        @Override public boolean isCyclic() { return cyclic; }\n+        @Override public void setCyclic( final boolean cyclic ) { this.cyclic = cyclic; }\n+        @Override public boolean isCut() { return cut; }\n+        @Override public void setCut( final boolean cut ) { this.cut = cut; }\n+        @Override public boolean isCanonical() { return true; }\n+        @Override public ContigImpl canonical() { return this; }\n+        @Override public String toString() { return \"c\" + id; }\n+    }\n+\n+    /**\n+     * Implementation of Contig for the reverse-complement of some other Contig.\n+     * Which one is the \"real\" Contig, and which is the \"RC\" is completely arbitrary, since there\n+     * is no notion of canonical for Contigs.\n+     **/\n+    public static final class ContigRCImpl implements Contig {\n+        private final CharSequence sequence;\n+        private final List<Contig> predecessors;\n+        private final List<Contig> successors;\n+        private final ContigImpl rc;\n+\n+        public ContigRCImpl( final ContigImpl contig ) {\n+            this.sequence = new SequenceRC(contig.getSequence());\n+            this.predecessors = new ContigListRC(contig.getSuccessors());\n+            this.successors = new ContigListRC(contig.getPredecessors());\n+            this.rc = contig;\n+        }\n+\n+        @Override public int getId() { return ~rc.getId(); }\n+        @Override public CharSequence getSequence() { return sequence; }\n+        @Override public int getMaxObservations() { return rc.getMaxObservations(); }\n+        @Override public KmerAdjacency getFirstKmer() { return rc.getLastKmer().rc(); }\n+        @Override public KmerAdjacency getLastKmer() { return rc.getFirstKmer().rc(); }\n+        @Override public List<Contig> getPredecessors() { return predecessors; }\n+        @Override public List<Contig> getSuccessors() { return successors; }\n+        @Override public int getComponentId() { return rc.getComponentId(); }\n+        @Override public int size() { return sequence.length(); }\n+        @Override public Contig rc() { return rc; }\n+        @Override public boolean isCyclic() { return rc.isCyclic(); }\n+        @Override public void setCyclic( final boolean cyclic ) { rc.setCyclic(cyclic); }\n+        @Override public boolean isCut() { return rc.isCut(); }\n+        @Override public void setCut( final boolean cut ) { rc.setCut(cut); }\n+        @Override public boolean isCanonical() { return false; }\n+        @Override public ContigImpl canonical() { return rc; }\n+        @Override public String toString() { return rc.toString() + \"RC\"; }\n+    }\n+\n+    /** A CharSequence that is a view of the reverse-complement of another sequence. **/\n+    public static final class SequenceRC implements CharSequence, Comparable<CharSequence> {\n+        private final int lenLess1;\n+        private final CharSequence sequence;\n+\n+        public SequenceRC( final CharSequence sequence ) {\n+            this.lenLess1 = sequence.length() - 1;\n+            this.sequence = sequence;\n+        }\n+\n+        @Override public int length() { return sequence.length(); }\n+        @Override public char charAt( final int index ) {\n+            final char result;\n+            switch ( Character.toUpperCase(sequence.charAt(lenLess1 - index)) ) {\n+                case 'A': result = 'T'; break;\n+                case 'C': result = 'G'; break;\n+                case 'G': result = 'C'; break;\n+                case 'T': result = 'A'; break;\n+                default: result = 'N'; break;\n+            }\n+            return result;\n+        }\n+        @Override public CharSequence subSequence( final int start, final int end ) {\n+            return new StringBuilder(end - start).append(this, start, end).toString();\n+        }\n+        @Override public String toString() { return new StringBuilder(this).toString(); }\n+\n+        @Override public int compareTo( final CharSequence charSequence ) {\n+            final int len1 = length();\n+            final int len2 = charSequence.length();\n+            final int cmpLen = Math.min(len1, len2);\n+            for ( int idx = 0; idx != cmpLen; ++idx ) {\n+                final char char1 = charAt(idx);\n+                final char char2 = Character.toUpperCase(charSequence.charAt(idx));\n+                if ( char1 > char2 ) return 1;\n+                if ( char1 < char2 ) return -1;\n+            }\n+            return Integer.compare(len1, len2);\n+        }\n+    }\n+\n+    /** A list of Contigs that presents a reverse-complemented view of a List of Contigs. **/\n+    public static final class ContigListRC extends AbstractList<Contig> {\n+        private final List<Contig> contigList;\n+\n+        public ContigListRC( final List<Contig> contigList ) {\n+            this.contigList = contigList;\n+        }\n+\n+        @Override public Contig get( final int index ) {\n+            return contigList.get(reflectIndex(index)).rc();\n+        }\n+        @Override public int size() { return contigList.size(); }\n+        @Override public Contig set( final int index, final Contig contig ) {\n+            return contigList.set(reflectIndex(index), contig.rc()).rc();\n+        }\n+        @Override public void add( final int index, final Contig contig ) {\n+            contigList.add(reflectIndex(index), contig.rc());\n+        }\n+        @Override public Contig remove( final int index ) {\n+            return contigList.remove(reflectIndex(index)).rc();\n+        }\n+\n+        private int reflectIndex( final int index ) { return size() - 1 - index; }\n+    }\n+\n+    /** A single-Contig portion of a path across the assembly graph. **/\n+    public interface PathPart {\n+        Contig getContig(); // will be null for PathParts that depart from the graph (PathPartGap)\n+        CharSequence getSequence(); // will be null for PathParts on the graph (PathPartContig)\n+        void extend( final char call );\n+        int getStart();\n+        int getStop();\n+        boolean isGap();\n+        int getLength();\n+        PathPart rc();\n+        char getFirstCall();\n+        char getLastCall();\n+        default boolean startsAtBeginning() { return getStart() == 0; }\n+        default boolean stopsAtEnd() { return getStop() + Kmer.KSIZE - 1 == getContig().size(); }\n+    }\n+\n+    /** A part of a path that isn't present in the graph. **/\n+    public static final class PathPartGap implements PathPart {\n+        private final StringBuilder sequence = new StringBuilder();\n+\n+        public PathPartGap( final KmerAdjacency kmer ) { sequence.append(kmer.toString()); }\n+        private PathPartGap( final CharSequence sequence ) { this.sequence.append(sequence); }\n+\n+        @Override public Contig getContig() { return null; }\n+        @Override public CharSequence getSequence() { return sequence.toString(); }\n+        @Override public void extend( final char call ) { sequence.append(call); }\n+        @Override public int getStart() { return 0; }\n+        @Override public int getStop() { return sequence.length(); }\n+        @Override public boolean isGap() { return true; }\n+        @Override public int getLength() { return sequence.length() - Kmer.KSIZE + 1; }\n+        @Override public PathPart rc() { return new PathPartGap(new SequenceRC(sequence)); }\n+        @Override public char getFirstCall() { return sequence.charAt(Kmer.KSIZE - 1); }\n+        @Override public char getLastCall() {\n+            return sequence.charAt(sequence.length() - Kmer.KSIZE + 1);\n+        }\n+    }\n+\n+    /** A part of a path that is present as a sub-sequence of some Contig. **/\n+    public static final class PathPartContig implements PathPart {\n+        private final Contig contig;\n+        private final int start;\n+        private int stop;\n+\n+        public PathPartContig( final Contig contig, final int start ) {\n+            this(contig, start, start+1);\n+        }\n+        public PathPartContig( final Contig contig, final int start, final int stop ) {\n+            this.contig = contig;\n+            this.start = start;\n+            this.stop = stop;\n+        }\n+\n+        @Override public Contig getContig() { return contig; }\n+        @Override public String getSequence() { return null; }\n+        @Override public void extend( final char call ) { stop += 1; }\n+        @Override public int getStart() { return start; }\n+        @Override public int getStop() { return stop; }\n+        @Override public boolean isGap() { return false; }\n+        @Override public int getLength() { return stop - start; }\n+        @Override public PathPart rc() {\n+            final int revBase = contig.size() - Kmer.KSIZE + 1;\n+            return new PathPartContig(contig.rc(), revBase - stop, revBase - start);\n+        }\n+        @Override public char getFirstCall() {\n+            return getContig().getSequence().charAt(start + Kmer.KSIZE - 1);\n+        }\n+        @Override public char getLastCall() { return getContig().getSequence().charAt(stop - 1); }\n+    }\n+\n+    /** A path through the assembly graph for something (probably a read). **/\n+    public static final class Path {\n+        private final List<PathPart> parts;\n+\n+        public Path( final byte[] calls,\n+                     final KmerSet<KmerAdjacency> kmerAdjacencySet ) {\n+            parts = new ArrayList<>();\n+            long kVal = 0;\n+            int count = 0;\n+            PathPart currentPathPart = null;\n+            for ( int idx = 0; idx != calls.length; ++idx ) {\n+                final char call = (char)calls[idx];\n+                kVal <<= 2;\n+                switch ( call ) {\n+                    case 'C': case 'c': kVal += 1; break;\n+                    case 'G': case 'g': kVal += 2; break;\n+                    case 'T': case 't': kVal += 3; break;\n+                }\n+                if ( ++count >= Kmer.KSIZE ) {\n+                    final KmerAdjacency kmer = KmerAdjacencyImpl.find(kVal, kmerAdjacencySet);\n+                    // if we fail to look up the kmer\n+                    if ( kmer == null ) {\n+                        if ( currentPathPart == null ) {\n+                            // if there's no current path part, just create the 1st one as a PathPartGap\n+                            currentPathPart = new PathPartGap(new KmerAdjacencyImpl(kVal));\n+                            parts.add(currentPathPart);\n+                        } else if ( currentPathPart.isGap() ) {\n+                            // if the current path part is a PathPartGap, just extend it\n+                            currentPathPart.extend(call);\n+                        } else {\n+                            // new PathPartGap\n+                            currentPathPart = new PathPartGap(new KmerAdjacencyImpl(kVal));\n+                            parts.add(currentPathPart);\n+                        }\n+                    } else {\n+                        // we've found our kmer\n+                        final Contig contig = kmer.getContig();\n+                        if ( currentPathPart == null ) {\n+                            // we've looked up a kmer, but don't have a current path part -- create one\n+                            currentPathPart = new PathPartContig(contig, kmer.getContigOffset());\n+                            parts.add(currentPathPart);\n+                        } else if ( contig == currentPathPart.getContig() ) {\n+                            // our lookup is on the current path part's contig -- extend it\n+                            final int kmerOffset = kmer.getContigOffset();\n+                            final int curStop = currentPathPart.getStop();\n+                            if ( kmerOffset == curStop ) {\n+                                currentPathPart.extend(call);\n+                            } else if ( kmerOffset == 0 && contig.getNKmers() == curStop ) {\n+                                // cycle onto same contig\n+                                currentPathPart = new PathPartContig(contig, 0);\n+                                parts.add(currentPathPart);\n+                            } else {\n+                                // weird:  kmer is non-contiguous.  start a new path part after a zero-length gap", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5Nzk0MzU5MQ=="}, "originalCommit": {"oid": "e2201c1ef4f8ba71f17e169f07756cfe2f1ecb49"}, "originalPosition": 2043}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzc3Njk2MDEyOnYy", "diffSide": "RIGHT", "path": "src/main/java/org/broadinstitute/hellbender/tools/LocalAssembler.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMy0xOVQyMDowOTowNVrOI6PzgA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMy0xOVQyMDowOTowNVrOI6PzgA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5Nzk0NzI2NA==", "bodyText": "The nested ifs get pretty hairy in this method. Any chance you could pull some of the clauses into little methods for readability. For example this could be:\nif (kmer == null) { currentPathPart = addGapKmer(...) } else { ... }\nI just find it hard to match up so many levels of indentation in this method.", "url": "https://github.com/broadinstitute/gatk/pull/6989#discussion_r597947264", "createdAt": "2021-03-19T20:09:05Z", "author": {"login": "cwhelan"}, "path": "src/main/java/org/broadinstitute/hellbender/tools/LocalAssembler.java", "diffHunk": "@@ -0,0 +1,2306 @@\n+package org.broadinstitute.hellbender.tools;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import htsjdk.samtools.Cigar;\n+import htsjdk.samtools.CigarElement;\n+import htsjdk.samtools.CigarOperator;\n+import htsjdk.samtools.SAMUtils;\n+import org.broadinstitute.barclay.argparser.Argument;\n+import org.broadinstitute.barclay.argparser.BetaFeature;\n+import org.broadinstitute.barclay.argparser.CommandLineProgramProperties;\n+import org.broadinstitute.barclay.help.DocumentedFeature;\n+import org.broadinstitute.hellbender.cmdline.StandardArgumentDefinitions;\n+import org.broadinstitute.hellbender.cmdline.programgroups.CoverageAnalysisProgramGroup;\n+import org.broadinstitute.hellbender.exceptions.GATKException;\n+import org.broadinstitute.hellbender.tools.walkers.PairWalker;\n+import org.broadinstitute.hellbender.utils.SimpleInterval;\n+import org.broadinstitute.hellbender.utils.collections.HopscotchSet;\n+import org.broadinstitute.hellbender.utils.gcs.BucketUtils;\n+import org.broadinstitute.hellbender.utils.read.GATKRead;\n+\n+import java.io.BufferedWriter;\n+import java.io.FileWriter;\n+import java.io.IOException;\n+import java.io.OutputStreamWriter;\n+import java.util.*;\n+import java.util.zip.GZIPOutputStream;\n+\n+@DocumentedFeature\n+@CommandLineProgramProperties(\n+        summary = \"experiment\",\n+        oneLineSummary = \"experiment\",\n+        usageExample = \"gatk LocalAssembler\",\n+        programGroup = CoverageAnalysisProgramGroup.class\n+)\n+@BetaFeature\n+public class LocalAssembler extends PairWalker {\n+    public static final byte QMIN = 25;\n+    public static final int MIN_THIN_OBS = 4;\n+    public static final int MIN_GAPFILL_COUNT = 3;\n+    public static final int TOO_MANY_TRAVERSALS = 100000;\n+    public static final int TOO_MANY_SCAFFOLDS = 50000;\n+    public static final int MIN_SV_SIZE = 50;\n+\n+    @Argument(fullName=StandardArgumentDefinitions.OUTPUT_LONG_NAME,\n+            shortName=StandardArgumentDefinitions.OUTPUT_SHORT_NAME,\n+            doc=\"Write outputs to this file name prefix\", optional = true)\n+    public static String output;\n+\n+    @Argument(fullName=\"assembly-name\", doc=\"name of assembly used as a prefix for traversal names\")\n+    public static String assemblyName;\n+\n+    private final List<GATKRead> reads = new ArrayList<>();\n+\n+    @Override public boolean requiresIntervals() { return true; }\n+\n+    @Override public void apply( final GATKRead read, final GATKRead mate ) {\n+        trimOverruns(read, mate);\n+        reads.add(read);\n+        reads.add(mate);\n+    }\n+\n+    @Override public void applyUnpaired( final GATKRead read ) {\n+        reads.add(read);\n+    }\n+\n+    @Override public Object onTraversalSuccess() {\n+        super.onTraversalSuccess(); // flush any incomplete pairs\n+\n+        final int regionSize = getTraversalIntervals().stream().mapToInt(SimpleInterval::size).sum();\n+        final KmerSet<KmerAdjacency> kmerAdjacencySet = new KmerSet<>(10 * regionSize);\n+        kmerizeReads(reads, kmerAdjacencySet);\n+        List<ContigImpl> contigs = buildContigs(kmerAdjacencySet);\n+        connectContigs(contigs);\n+\n+        removeThinContigs(contigs, kmerAdjacencySet);\n+        weldPipes(contigs);\n+        markComponents(contigs);\n+\n+        if ( fillGaps(kmerAdjacencySet, reads) ) {\n+            contigs = buildContigs(kmerAdjacencySet);\n+            connectContigs(contigs);\n+            removeThinContigs(contigs, kmerAdjacencySet);\n+            weldPipes(contigs);\n+            markComponents(contigs);\n+        }\n+\n+        markCycles(contigs);\n+\n+        final String outputFilePrefix = output != null ? output : assemblyName;\n+        final List<Path> readPaths = pathReads(kmerAdjacencySet, reads);\n+        final Map<Contig,List<TransitPairCount>> contigTransitsMap =\n+                collectTransitPairCounts(contigs, readPaths);\n+        final String traversalsFilename = outputFilePrefix + \".traversals.fa.gz\";\n+        try {\n+            final List<Traversal> allTraversals =\n+                    new ArrayList<>(traverseAllPaths(contigs, readPaths, contigTransitsMap));\n+            writeTraversals(allTraversals, traversalsFilename);\n+            try {\n+                final String scaffoldsFileName = outputFilePrefix + \".scaffolds.fa.gz\";\n+                writeTraversals(createScaffolds(allTraversals), scaffoldsFileName);\n+            } catch ( final AssemblyTooComplexException x ) {\n+                logger.warn(\"Assembly too complex for scaffolding.\");\n+            }\n+        } catch ( final AssemblyTooComplexException x ) {\n+            logger.warn(\"Assembly too complex.  Writing contigs as traversals in \" +\n+                    traversalsFilename + \".\");\n+            final Collection<Traversal> contigTraversals = new ArrayList<>(contigs.size());\n+            for ( final Contig contig : contigs ) {\n+                contigTraversals.add(new Traversal(Collections.singletonList(contig)));\n+            }\n+            writeTraversals(contigTraversals, traversalsFilename);\n+        }\n+\n+        contigs.sort(Comparator.comparingInt(ContigImpl::getId));\n+        writeDOT(contigs, outputFilePrefix + \".assembly.dot\");\n+        writeContigs(contigs, outputFilePrefix + \".contigs.txt.gz\");\n+        writePaths(readPaths, outputFilePrefix + \".paths.txt.gz\");\n+        writeReads(reads, outputFilePrefix + \".reads.fastq.gz\");\n+        return null;\n+    }\n+\n+    /** trim read pairs of base calls that have gone past the end of a short fragment */\n+    private void trimOverruns( final GATKRead read, final GATKRead mate ) {\n+        // if both mapped and they're on different strands\n+        if ( !read.isUnmapped() && !mate.isUnmapped() &&\n+                read.isReverseStrand() != mate.isReverseStrand() ) {\n+            // and both start within 1 base on the ref\n+            if ( Math.abs(read.getStart() - read.getMateStart()) <= 1 ) {\n+                // and both end within 1 base\n+                final int readRefLen = read.getCigar().getReferenceLength();\n+                final int mateRefLen = mate.getCigar().getReferenceLength();\n+                if ( Math.abs(readRefLen - mateRefLen) <= 1 ) {\n+                    if ( mate.isReverseStrand() ) {\n+                        trimClips(read, mate);\n+                    } else {\n+                        trimClips(mate, read);\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    private void trimClips( final GATKRead fwd, final GATKRead rev ) {\n+        final List<CigarElement> fwdElements = fwd.getCigarElements();\n+        final List<CigarElement> revElements = rev.getCigarElements();\n+        final int lastElementIdx = fwdElements.size() - 1;\n+        final CigarElement fwdLastElement = fwdElements.get(lastElementIdx);\n+        final CigarElement revFirstElement = revElements.get(0);\n+        if ( fwdLastElement.getOperator() == CigarOperator.S &&\n+                revFirstElement.getOperator() == CigarOperator.S ) {\n+            final byte[] fwdBases = fwd.getBasesNoCopy();\n+            final int lastElementLen = fwdLastElement.getLength();\n+            fwd.setBases(Arrays.copyOfRange(fwdBases, 0, fwdBases.length - lastElementLen));\n+            final byte[] fwdQuals = fwd.getBaseQualitiesNoCopy();\n+            if ( fwdQuals.length > 0 ) {\n+                final int qualsLen = fwdQuals.length - lastElementLen;\n+                fwd.setBaseQualities(Arrays.copyOfRange(fwdQuals, 0, qualsLen));\n+            }\n+            final List<CigarElement> newFwdElements = new ArrayList<>(fwdElements);\n+            newFwdElements.set(lastElementIdx, new CigarElement(lastElementLen, CigarOperator.H));\n+            fwd.setCigar(new Cigar(newFwdElements));\n+\n+            final byte[] revBases = rev.getBasesNoCopy();\n+            final int firstElementLen = revFirstElement.getLength();\n+            rev.setBases(Arrays.copyOfRange(revBases, firstElementLen, revBases.length));\n+            final byte[] revQuals = rev.getBaseQualitiesNoCopy();\n+            if ( revQuals.length > 0 ) {\n+                rev.setBaseQualities(Arrays.copyOfRange(revQuals, firstElementLen, revQuals.length));\n+            }\n+            final List<CigarElement> newRevElements = new ArrayList<>(revElements);\n+            newRevElements.set(0, new CigarElement(firstElementLen, CigarOperator.H));\n+            rev.setCigar(new Cigar(newRevElements));\n+        }\n+    }\n+\n+    @VisibleForTesting\n+    static void kmerizeReads( final List<GATKRead> reads,\n+                              final KmerSet<KmerAdjacency> kmerAdjacencySet ) {\n+        for ( final GATKRead read : reads ) {\n+            final byte[] calls = read.getBasesNoCopy();\n+            final byte[] quals = read.getBaseQualitiesNoCopy();\n+            KmerAdjacency.kmerize(calls, quals, QMIN, kmerAdjacencySet);\n+        }\n+    }\n+\n+    /** gather unbranched strings of kmers into contigs **/\n+    @VisibleForTesting\n+    static List<ContigImpl> buildContigs( final KmerSet<KmerAdjacency> kmerAdjacencySet ) {\n+        // gather strings of kmers that have a single predecessor and single successor into contigs\n+        final List<ContigImpl> contigs = new ArrayList<>();\n+        int nContigs = 0;\n+        for ( final KmerAdjacency kmerAdjacency : kmerAdjacencySet ) {\n+            if ( kmerAdjacency.getContig() == null ) {\n+                ContigImpl contig = null;\n+                final KmerAdjacency predecessor = kmerAdjacency.getSolePredecessor();\n+                if ( predecessor == null ||\n+                        predecessor.getSuccessorCount() > 1 ||\n+                        predecessor == kmerAdjacency.rc() ) {\n+                    contig = new ContigImpl(++nContigs, kmerAdjacency);\n+                } else {\n+                    final KmerAdjacency successor = kmerAdjacency.getSoleSuccessor();\n+                    if ( successor == null ||\n+                            successor.getPredecessorCount() > 1 ||\n+                            successor == kmerAdjacency.rc() ) {\n+                        contig = new ContigImpl(++nContigs, kmerAdjacency.rc());\n+                    }\n+                }\n+                if ( contig != null ) {\n+                    contigs.add(contig);\n+                }\n+            }\n+        }\n+\n+        // if there are smooth circles like a plasmid, gather them together as a contig, too\n+        for ( final KmerAdjacency kmerAdjacency : kmerAdjacencySet ) {\n+            if ( kmerAdjacency.getContig() == null ) {\n+                contigs.add(new ContigImpl(++nContigs, kmerAdjacency));\n+            }\n+        }\n+\n+        return contigs;\n+    }\n+\n+    /** connect contigs when the final kmer of one contig is adjacent to the inital contig of another **/\n+    @VisibleForTesting\n+    static void connectContigs( final List<ContigImpl> contigs ) {\n+        final int nContigs = contigs.size();\n+        final KmerSet<ContigEndKmer> contigEnds = new KmerSet<>(2*nContigs);\n+        for ( int contigId = 0; contigId != nContigs; ++contigId ) {\n+            final ContigImpl contig = contigs.get(contigId);\n+            final KmerAdjacency fwdKmer = contig.getFirstKmer();\n+            final KmerAdjacency revKmer = contig.getLastKmer().rc();\n+            if ( fwdKmer == revKmer ) {\n+                contigEnds.add(new ContigEndKmer(fwdKmer.getKVal(), contig, ContigOrientation.BOTH));\n+            } else {\n+                contigEnds.add(new ContigEndKmer(fwdKmer.getKVal(), contig, ContigOrientation.FWD));\n+                contigEnds.add(new ContigEndKmer(revKmer.getKVal(), contig, ContigOrientation.REV));\n+            }\n+        }\n+\n+        for ( int contigId = 0; contigId != nContigs; ++contigId ) {\n+            final Contig contig = contigs.get(contigId);\n+\n+            final KmerAdjacency start = contig.getFirstKmer();\n+            final int predecessorCount = start.getPredecessorCount();\n+            if ( predecessorCount > 0 ) {\n+                final List<Contig> predecessors = contig.getPredecessors();\n+                final int mask = start.getPredecessorMask();\n+                for ( int call = 0; call != 4; ++call ) {\n+                    if ( (mask & (1 << call)) != 0 ) {\n+                        final long kVal =\n+                                KmerAdjacency.reverseComplement(start.getPredecessorVal(call));\n+                        final ContigEndKmer contigEndKmer = contigEnds.find(new Kmer(kVal));\n+                        if ( contigEndKmer == null ) {\n+                            throw new GATKException(\"missing contig end kmer\");\n+                        }\n+                        switch ( contigEndKmer.getContigOrientation() ) {\n+                            case FWD:\n+                                predecessors.add(contigEndKmer.getContig().rc());\n+                                break;\n+                            case REV:\n+                                predecessors.add(contigEndKmer.getContig());\n+                                break;\n+                            case BOTH:\n+                                predecessors.add(contigEndKmer.getContig());\n+                                predecessors.add(contigEndKmer.getContig().rc());\n+                                break;\n+                        }\n+                    }\n+                }\n+            }\n+\n+            final KmerAdjacency end = contig.getLastKmer();\n+            final int successorCount = end.getSuccessorCount();\n+            if ( successorCount > 0 ) {\n+                final List<Contig> successors = contig.getSuccessors();\n+                final int mask = end.getSuccessorMask();\n+                for ( int call = 0; call != 4; ++call ) {\n+                    if ( (mask & (1 << call)) != 0 ) {\n+                        final long kVal = end.getSuccessorVal(call);\n+                        final ContigEndKmer contigEndKmer = contigEnds.find(new Kmer(kVal));\n+                        if ( contigEndKmer == null ) {\n+                            throw new GATKException(\"missing contig end kmer\");\n+                        }\n+                        switch ( contigEndKmer.getContigOrientation() ) {\n+                            case FWD:\n+                                successors.add(contigEndKmer.getContig());\n+                                break;\n+                            case REV:\n+                                successors.add(contigEndKmer.getContig().rc());\n+                                break;\n+                            case BOTH:\n+                                successors.add(contigEndKmer.getContig());\n+                                successors.add(contigEndKmer.getContig().rc());\n+                                break;\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    /** remove contigs that have little evidence **/\n+    @VisibleForTesting\n+    static void removeThinContigs( final List<ContigImpl> contigs,\n+                                           final KmerSet<KmerAdjacency> kmerAdjacencySet ) {\n+        contigs.sort(Comparator.comparingInt(ContigImpl::getMaxObservations));\n+        boolean contigRemoved;\n+        do {\n+            // figure out which contigs are cut points\n+            // i.e., those contigs which, if removed, would result in a graph with more connected components\n+            final int nContigs = contigs.size();\n+            final Map<Contig, CutData> cutDataMap = new HashMap<>(nContigs * 3);\n+\n+            for ( final ContigImpl contig : contigs ) {\n+                if ( cutDataMap.containsKey(contig) ) {\n+                    continue;\n+                }\n+\n+                cutDataMap.put(contig, new CutData());\n+                int children = 0;\n+                for ( final Contig nextContig : contig.getSuccessors() ) {\n+                    if ( !cutDataMap.containsKey(nextContig) ) {\n+                        findCuts(nextContig, contig, cutDataMap);\n+                        children += 1;\n+                    }\n+                }\n+                for ( final Contig nextContig : contig.getPredecessors() ) {\n+                    if ( !cutDataMap.containsKey(nextContig) ) {\n+                        findCuts(nextContig, contig, cutDataMap);\n+                        children += 1;\n+                    }\n+                }\n+                if ( children >= 2 ) {\n+                    contig.setCut(true);\n+                }\n+            }\n+\n+            // remove poorly attested (low max observations) contigs, unless they are cut points\n+            contigRemoved = false;\n+            final Iterator<ContigImpl> itr = contigs.iterator();\n+            while ( itr.hasNext() ) {\n+                final Contig contig = itr.next();\n+                if ( contig.getMaxObservations() < MIN_THIN_OBS && !contig.isCut() ) {\n+                    unlinkContig(contig, kmerAdjacencySet);\n+                    itr.remove();\n+                    contigRemoved = true;\n+                    break;\n+                }\n+            }\n+        } while ( contigRemoved );\n+        contigs.sort(Comparator.comparingInt(ContigImpl::getId));\n+    }\n+\n+    private static CutData findCuts( final Contig contig,\n+                                     final Contig parent,\n+                                     final Map<Contig, CutData> cutDataMap ) {\n+        final CutData cutData = new CutData();\n+        cutDataMap.put(contig, cutData);\n+        for ( final Contig nextContig : contig.getSuccessors() ) {\n+            if ( nextContig == parent ) {\n+                continue;\n+            }\n+            CutData nextCutData = cutDataMap.get(nextContig);\n+            if ( nextCutData != null ) {\n+                cutData.minVisitNum = Math.min(cutData.minVisitNum, nextCutData.visitNum);\n+            } else {\n+                nextCutData = findCuts(nextContig, contig, cutDataMap);\n+                cutData.minVisitNum = Math.min(cutData.minVisitNum, nextCutData.minVisitNum);\n+                if ( nextCutData.minVisitNum >= cutData.visitNum ) {\n+                    contig.setCut(true);\n+                }\n+            }\n+        }\n+        for ( final Contig nextContig : contig.getPredecessors() ) {\n+            if ( nextContig == parent ) {\n+                continue;\n+            }\n+            CutData nextCutData = cutDataMap.get(nextContig);\n+            if ( nextCutData != null ) {\n+                cutData.minVisitNum = Math.min(cutData.minVisitNum, nextCutData.visitNum);\n+            } else {\n+                nextCutData = findCuts(nextContig, contig, cutDataMap);\n+                cutData.minVisitNum = Math.min(cutData.minVisitNum, nextCutData.minVisitNum);\n+                if ( nextCutData.minVisitNum >= cutData.visitNum ) {\n+                    contig.setCut(true);\n+                }\n+            }\n+        }\n+        return cutData;\n+    }\n+\n+    @VisibleForTesting\n+    static void unlinkContig( final Contig contig,\n+                                      final KmerSet<KmerAdjacency> kmerAdjacencySet ) {\n+        final KmerAdjacency firstKmer = contig.getFirstKmer();\n+        final int firstKmerFinalCall = firstKmer.getFinalCall();\n+        for ( final Contig predecessor : contig.getPredecessors() ) {\n+            if ( predecessor != contig && predecessor != contig.rc() ) {\n+                predecessor.getLastKmer().removeSuccessor(firstKmerFinalCall, kmerAdjacencySet);\n+                if ( !predecessor.getSuccessors().remove(contig) ) {\n+                    throw new GATKException(\"failed to find predecessor link\");\n+                }\n+            }\n+        }\n+\n+        final KmerAdjacency lastKmer = contig.getLastKmer();\n+        final int lastKmerInitialCall = lastKmer.getInitialCall();\n+        for ( final Contig successor : contig.getSuccessors() ) {\n+            if ( successor != contig && successor != contig.rc() ) {\n+                successor.getFirstKmer().removePredecessor(lastKmerInitialCall, kmerAdjacencySet);\n+                if ( !successor.getPredecessors().remove(contig) ) {\n+                    throw new GATKException(\"failed to find successor link\");\n+                }\n+            }\n+        }\n+\n+        KmerAdjacency nextKmer = firstKmer;\n+        KmerAdjacency kmer;\n+        do {\n+            kmer = nextKmer;\n+            nextKmer = kmer.getSoleSuccessor();\n+            kmerAdjacencySet.remove(kmer.canonical());\n+        } while ( kmer != lastKmer );\n+    }\n+\n+    private static void updateKmerContig( final KmerAdjacency firstKmer,\n+                                          final KmerAdjacency lastKmer,\n+                                          final Contig contig ) {\n+        int offset = 0;\n+        for ( KmerAdjacency kmer = firstKmer; kmer != lastKmer; kmer = kmer.getSoleSuccessor() ) {\n+            if ( kmer == null ) {\n+                throw new GATKException(\"contig does not have a flat pipeline of kmers\");\n+            }\n+            kmer.clearContig();\n+            kmer.setContigOffset(contig, offset++);\n+        }\n+        lastKmer.clearContig();\n+        lastKmer.setContigOffset(contig, offset);\n+        if ( offset + Kmer.KSIZE != contig.size() ) {\n+            throw new GATKException(\"kmer chain length does not equal contig size\");\n+        }\n+    }\n+\n+    /** replace adjacent contigs without branches with a single, larger contig **/\n+    @VisibleForTesting\n+    static void weldPipes( final List<ContigImpl> contigs ) {\n+        for ( int contigIdx = 0; contigIdx != contigs.size(); ++contigIdx ) {\n+            final ContigImpl contig = contigs.get(contigIdx);\n+            if ( contig.getSuccessors().size() == 1 ) {\n+                final Contig successor = contig.getSuccessors().get(0);\n+                if ( successor != contig && successor != contig.rc() &&\n+                        successor.getPredecessors().size() == 1 ) {\n+                    contigs.set(contigIdx, join(contig.getId(), contig, successor));\n+                    if ( !contigs.remove(successor.canonical()) ) {\n+                        throw new GATKException(\"successor linkage is messed up\");\n+                    }\n+                    contigIdx -= 1; // reconsider the new contig -- there might be more joining possible\n+                    continue;\n+                }\n+            }\n+            if ( contig.getPredecessors().size() == 1 ) {\n+                final Contig predecessor = contig.getPredecessors().get(0);\n+                if ( predecessor != contig && predecessor != contig.rc() &&\n+                        predecessor.getSuccessors().size() == 1 ) {\n+                    contigs.set(contigIdx, join(contig.getId(), predecessor, contig));\n+                    if ( !contigs.remove(predecessor.canonical()) ) {\n+                        throw new GATKException(\"predecessor linkage is messed up\");\n+                    }\n+                    contigIdx -= 1; // reconsider\n+                }\n+            }\n+        }\n+    }\n+\n+    private static ContigImpl join( final int id, final Contig predecessor, final Contig successor ) {\n+        if ( !checkOverlap(predecessor.getSequence(), successor.getSequence()) ) {\n+                throw new GATKException(\"sequences can't be joined\");\n+        }\n+        final ContigImpl joinedContig = new ContigImpl(id, predecessor, successor);\n+        updateKmerContig(joinedContig.getFirstKmer(), joinedContig.getLastKmer(), joinedContig);\n+        return joinedContig;\n+    }\n+\n+    private static boolean checkOverlap( final CharSequence seq1, final CharSequence seq2 ) {\n+        final int seq1Len = seq1.length();\n+        final CharSequence seq1SubSeq = seq1.subSequence(seq1Len - Kmer.KSIZE + 1, seq1Len);\n+        final CharSequence seq2SubSeq = seq2.subSequence(0, Kmer.KSIZE - 1);\n+        return seq1SubSeq.equals(seq2SubSeq);\n+    }\n+\n+    /** set a unique componentId for every connected group of contigs **/\n+    @VisibleForTesting\n+    static int markComponents( final List<ContigImpl> contigs ) {\n+        for ( final ContigImpl contig : contigs ) {\n+            contig.setComponentId(0);\n+        }\n+\n+        int componentId = 0;\n+        for ( final ContigImpl contig : contigs ) {\n+            if ( contig.getComponentId() == 0 ) {\n+                contig.setComponentId(++componentId);\n+                markSuccessorComponents(contig);\n+                markSuccessorComponents(contig.rc());\n+            }\n+        }\n+        return componentId;\n+    }\n+\n+    private static void markSuccessorComponents( final Contig contig ) {\n+        final int componentId = contig.getComponentId();\n+        for ( final Contig successor : contig.getSuccessors() ) {\n+            if ( successor.getComponentId() == 0 ) {\n+                successor.canonical().setComponentId(componentId);\n+                markSuccessorComponents(successor);\n+                markSuccessorComponents(successor.rc());\n+            }\n+        }\n+    }\n+\n+    @VisibleForTesting\n+    static void markCycles( final List<ContigImpl> contigs ) {\n+        for ( final Contig contig : contigs ) {\n+            contig.setCyclic(false);\n+        }\n+\n+        final int nContigs = contigs.size();\n+        final Deque<Contig> deque = new ArrayDeque<>(nContigs);\n+        final Map<Contig, CutData> cutDataMap = new HashMap<>(nContigs * 3);\n+        for ( final Contig contig : contigs ) {\n+            if ( !cutDataMap.containsKey(contig) ) {\n+                markCyclesRecursion(contig, deque, cutDataMap);\n+            }\n+        }\n+    }\n+\n+    private static CutData markCyclesRecursion( final Contig contig,\n+                                                final Deque<Contig> deque,\n+                                                final Map<Contig, CutData> cutDataMap ) {\n+        final CutData cutData = new CutData();\n+        cutDataMap.put(contig, cutData);\n+        deque.addFirst(contig);\n+\n+        for ( final Contig successor : contig.getSuccessors() ) {\n+            final CutData successorCutData = cutDataMap.get(successor);\n+            if ( successorCutData == null ) {\n+                final int recursionVisitNum =\n+                        markCyclesRecursion(successor, deque, cutDataMap).minVisitNum;\n+                cutData.minVisitNum = Math.min(cutData.minVisitNum, recursionVisitNum);\n+            } else {\n+                cutData.minVisitNum = Math.min(cutData.minVisitNum, successorCutData.visitNum);\n+            }\n+        }\n+\n+        if ( cutData.visitNum == cutData.minVisitNum ) {\n+            Contig tig = deque.removeFirst();\n+            if ( tig == contig ) {\n+                cutDataMap.get(tig).visitNum = Integer.MAX_VALUE;\n+\n+                // single-vertex component -- cyclic only if self-referential\n+                if ( tig.getSuccessors().contains(tig) ) {\n+                    tig.setCyclic(true);\n+                }\n+            } else {\n+                while ( true ) {\n+                    // kill cross-links\n+                    cutDataMap.get(tig).visitNum = Integer.MAX_VALUE;\n+                    tig.setCyclic(true);\n+                    if ( tig == contig ) break;\n+                    tig = deque.removeFirst();\n+                }\n+            }\n+        }\n+        return cutData;\n+    }\n+\n+    @VisibleForTesting\n+    static boolean fillGaps( final KmerSet<KmerAdjacency> kmerAdjacencySet,\n+                             final List<GATKRead> reads ) {\n+        final Map<String, Integer> gapFillCounts = new HashMap<>();\n+        for ( final GATKRead read : reads ) {\n+            final Path path = new Path(read.getBasesNoCopy(), kmerAdjacencySet);\n+            final List<PathPart> parts = path.getParts();\n+            final int lastIdx = parts.size() - 1;\n+            for ( int idx = 1; idx < lastIdx; ++idx ) {\n+                final PathPart pathPart = parts.get(idx);\n+                if ( pathPart.isGap() ) {\n+                    final char prevCall = parts.get(idx - 1).getLastCall();\n+                    final char nextCall = parts.get(idx + 1).getFirstCall();\n+                    String gapFill = prevCall + pathPart.getSequence().toString() + nextCall;\n+                    final SequenceRC gapFillRC = new SequenceRC(gapFill);\n+                    if ( gapFillRC.compareTo(gapFill) < 0 ) {\n+                        gapFill = gapFillRC.toString();\n+                    }\n+                    gapFillCounts.merge(gapFill, 1, Integer::sum);\n+                }\n+            }\n+        }\n+\n+        boolean newKmers = false;\n+        for ( final Map.Entry<String, Integer> entry : gapFillCounts.entrySet() ) {\n+            final int nObservations = entry.getValue();\n+            if ( nObservations >= MIN_GAPFILL_COUNT ) {\n+                KmerAdjacency.kmerize(entry.getKey(), nObservations, kmerAdjacencySet);\n+                newKmers = true;\n+            }\n+        }\n+\n+        if ( newKmers ) {\n+            for ( final KmerAdjacency kmerAdjacency : kmerAdjacencySet ) {\n+                kmerAdjacency.clearContig();\n+            }\n+        }\n+        return newKmers;\n+    }\n+\n+    @VisibleForTesting\n+    static List<Path> pathReads( final KmerSet<KmerAdjacency> kmerAdjacencySet,\n+                          final List<GATKRead> reads ) {\n+        final List<Path> readPaths = new ArrayList<>(reads.size());\n+        for ( final GATKRead read : reads ) {\n+            readPaths.add(new Path(read.getBasesNoCopy(), kmerAdjacencySet));\n+        }\n+        return readPaths;\n+    }\n+\n+    @VisibleForTesting\n+    static Map<Contig,List<TransitPairCount>> collectTransitPairCounts(\n+            final List<ContigImpl> contigs,\n+            final List<Path> readPaths ) {\n+        final Map<Contig,List<TransitPairCount>> contigTransitsMap =\n+                new HashMap<>(3 * contigs.size());\n+        for ( final Path path : readPaths ) {\n+            final List<PathPart> parts = path.getParts();\n+            final int lastPart = parts.size() - 1;\n+            for ( int partIdx = 1; partIdx < lastPart; ++partIdx ) {\n+                final Contig prevContig = parts.get(partIdx - 1).getContig();\n+                if ( prevContig == null ) continue;\n+                final Contig curContig = parts.get(partIdx).getContig();\n+                if ( curContig == null ) {\n+                    partIdx += 1;\n+                    continue;\n+                }\n+                final Contig nextContig = parts.get(partIdx + 1).getContig();\n+                if ( nextContig == null ) {\n+                    partIdx += 2;\n+                    continue;\n+                }\n+                final TransitPairCount tpc = new TransitPairCount(prevContig, nextContig);\n+                final List<TransitPairCount> tpcList =\n+                        contigTransitsMap.computeIfAbsent(curContig, tig -> new ArrayList<>(4));\n+                final int idx = tpcList.indexOf(tpc);\n+                if ( idx != -1 ) {\n+                    tpcList.get(idx).observe();\n+                } else {\n+                    tpcList.add(tpc);\n+                    contigTransitsMap.computeIfAbsent(curContig.rc(), tig -> new ArrayList<>(4))\n+                            .add(tpc.getRC());\n+                }\n+            }\n+        }\n+        return contigTransitsMap;\n+    }\n+\n+    @VisibleForTesting\n+    static Set<Traversal> traverseAllPaths(\n+            final List<ContigImpl> contigs,\n+            final List<Path> readPaths,\n+            final Map<Contig, List<TransitPairCount>> contigTransitsMap ) {\n+        final Set<Traversal> traversalSet = new HashSet<>();\n+        final List<Contig> contigsList = new ArrayList<>();\n+        for ( final Contig contig : contigs ) {\n+            // untransited contigs are sources, sinks, or large contigs that can't be crossed by a read\n+            // build traversals from these\n+            if ( !contigTransitsMap.containsKey(contig) ) {\n+                boolean done = false;\n+                for ( final Contig successor : contig.getSuccessors() ) {\n+                    traverse(successor, contig,\n+                            contigsList, readPaths, contigTransitsMap, traversalSet);\n+                    done = true;\n+                }\n+                for ( final Contig predecessor : contig.getPredecessors() ) {\n+                    traverse(predecessor.rc(), contig.rc(),\n+                            contigsList, readPaths, contigTransitsMap, traversalSet);\n+                    done = true;\n+                }\n+                if ( !done ) { // if there were no predecessors or successors, it stands alone\n+                    addTraversal(new Traversal(Collections.singletonList(contig)), traversalSet);\n+                }\n+            }\n+        }\n+\n+        // look for transits that haven't been traced\n+        for ( final Map.Entry<Contig, List<TransitPairCount>> entry :\n+                contigTransitsMap.entrySet() ) {\n+            for ( final TransitPairCount tpc : entry.getValue() ) {\n+                if ( tpc.getCount() > 0 ) {\n+                    tpc.resetCount();\n+                    final Contig contig = entry.getKey();\n+                    final Set<Traversal> fwdTraversalSet = new HashSet<>();\n+                    traverse(tpc.getNextContig(), contig,\n+                            contigsList, readPaths, contigTransitsMap, fwdTraversalSet);\n+                    final Set<Traversal> revTraversalSet = new HashSet<>();\n+                    traverse(tpc.getPrevContig().rc(), contig.rc(),\n+                            contigsList, readPaths, contigTransitsMap, revTraversalSet);\n+                    for ( final Traversal revTraversal : revTraversalSet ) {\n+                        final Traversal revTraversalRC = revTraversal.rc();\n+                        for ( final Traversal fwdTraversal : fwdTraversalSet ) {\n+                            final int overlap =\n+                                    findMaxOverlap(revTraversalRC.getContigs(), fwdTraversal.getContigs());\n+                            final Traversal combo =\n+                                    Traversal.combineOverlappers(revTraversalRC, fwdTraversal, overlap);\n+                            addTraversal(combo, traversalSet);\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+\n+        return traversalSet;\n+    }\n+\n+    private static int findMaxOverlap( final List<Contig> prefixes, final List<Contig> suffixes ) {\n+        final int nPrefixes = prefixes.size();\n+        final Contig firstSuffix = suffixes.get(0);\n+        if ( !firstSuffix.isCyclic() ) {\n+            return prefixes.get(nPrefixes - 1) == firstSuffix ? 1 : 0;\n+        }\n+        final int nSuffixes = suffixes.size();\n+        for ( int prefixIdx = Math.max(0, nPrefixes - nSuffixes); prefixIdx != nPrefixes; ++prefixIdx ) {\n+            if ( prefixes.get(prefixIdx) == firstSuffix ) {\n+                int suffixIdx = 1;\n+                boolean match = true;\n+                for ( int prefixIdx2 = prefixIdx + 1; prefixIdx2 != nPrefixes; ++prefixIdx2 ) {\n+                    if ( prefixes.get(prefixIdx2) != suffixes.get(suffixIdx++) ) {\n+                        match = false;\n+                        break;\n+                    }\n+                }\n+                if ( match ) {\n+                    return nPrefixes - prefixIdx;\n+                }\n+            }\n+        }\n+        return 0;\n+    }\n+\n+    private static void traverse( final Contig contig,\n+                                  final Contig predecessor,\n+                                  final List<Contig> contigsList,\n+                                  final List<Path> readPaths,\n+                                  final Map<Contig, List<TransitPairCount>> contigTransitsMap,\n+                                  final Set<Traversal> traversalSet ) {\n+        contigsList.add(predecessor);\n+        if ( contig.isCyclic() ) {\n+            traverseCycle(contig, contigsList, readPaths, contigTransitsMap, traversalSet);\n+            contigsList.remove(contigsList.size() - 1);\n+            return;\n+        }\n+        final List<TransitPairCount> transits = contigTransitsMap.get(contig);\n+        boolean done = false;\n+        if ( transits != null ) {\n+            for ( final TransitPairCount tpc : transits ) {\n+                if ( tpc.getPrevContig() == predecessor ) {\n+                    final Contig successor = tpc.getNextContig();\n+                    if ( predecessor == contig.rc() ) {\n+                        final int nContigs = contigsList.size();\n+                        if ( nContigs > 1 ) {\n+                            if ( successor.rc() == contigsList.get(nContigs - 2) ) {\n+                                continue;\n+                            }\n+                        }\n+                    }\n+                    tpc.resetCount();\n+                    traverse(successor, contig, contigsList, readPaths, contigTransitsMap, traversalSet);\n+                    done = true;\n+                }\n+            }\n+        }\n+        if ( !done ) {\n+            contigsList.add(contig);\n+            addTraversal(new Traversal(contigsList), traversalSet);\n+            contigsList.remove(contigsList.size() - 1);\n+        }\n+        contigsList.remove(contigsList.size() - 1);\n+    }\n+\n+    private static void traverseCycle( final Contig contig,\n+                                       final List<Contig> contigsList,\n+                                       final List<Path> readPaths,\n+                                       final Map<Contig, List<TransitPairCount>> contigTransitsMap,\n+                                       final Set<Traversal> traversalSet ) {\n+        contigsList.add(contig);\n+        final int nContigs = contigsList.size();\n+        // the final element of the list is cyclic, if there's a previous element it will be\n+        // non-cyclic, so start there figuring out how far the read paths lead us\n+        final List<List<Contig>> longestPaths =\n+                findLongestPaths(contigsList.subList(Math.max(0, nContigs - 2), nContigs), readPaths);\n+        // didn't get anywhere -- just complete the traversal\n+        if ( longestPaths.isEmpty() ) {\n+            addTraversal(new Traversal(contigsList, true), traversalSet);\n+        } else {\n+            // for each unique extension into the cycle\n+            for ( final List<Contig> path : longestPaths ) {\n+                // don't think this can happen, but still\n+                if ( path.isEmpty() ) {\n+                    addTraversal(new Traversal(contigsList, true), traversalSet);\n+                    continue;\n+                }\n+                final List<Contig> extendedContigsList =\n+                        new ArrayList<>(contigsList.size() + path.size());\n+                extendedContigsList.addAll(contigsList);\n+                // if we didn't get out of the cycle\n+                if ( path.get(path.size() - 1).isCyclic() ) {\n+                    extendedContigsList.addAll(path);\n+                    addTraversal(new Traversal(extendedContigsList, true), traversalSet);\n+                } else {\n+                    // we found a cycle-exiting path, so extend that normally\n+                    for ( final Contig curContig : path ) {\n+                        if ( curContig.isCyclic() ) {\n+                            extendedContigsList.add(curContig);\n+                        } else {\n+                            final Contig prevContig =\n+                                    extendedContigsList.remove(extendedContigsList.size() - 1);\n+                            traverse(curContig, prevContig, extendedContigsList, readPaths,\n+                                    contigTransitsMap, traversalSet);\n+                            extendedContigsList.add(prevContig);\n+                            break;\n+                        }\n+                    }\n+                }\n+                clearTransitPairs(contigTransitsMap, extendedContigsList);\n+            }\n+        }\n+        contigsList.remove(contigsList.size() - 1);\n+    }\n+\n+    private static void clearTransitPairs(\n+            final Map<Contig, List<TransitPairCount>> contigTransitsMap,\n+            final List<Contig> contigsList ) {\n+        final int lastIdx = contigsList.size() - 1;\n+        for ( int idx = 1; idx < lastIdx; ++idx ) {\n+            final List<TransitPairCount> pairCounts = contigTransitsMap.get(contigsList.get(idx));\n+            if ( pairCounts != null ) {\n+                final Contig predecessor = contigsList.get(idx - 1);\n+                final Contig successor = contigsList.get(idx + 1);\n+                for ( final TransitPairCount tpc : pairCounts ) {\n+                    if ( tpc.getPrevContig() == predecessor && tpc.getNextContig() == successor ) {\n+                        tpc.resetCount();\n+                        break;\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    private static void addTraversal( final Traversal traversal,\n+                                      final Set<Traversal> traversalSet ) {\n+        if ( !traversalSet.contains(traversal.rc()) ) {\n+            traversalSet.add(traversal);\n+            if ( traversalSet.size() >= TOO_MANY_TRAVERSALS ) {\n+                throw new AssemblyTooComplexException();\n+            }\n+        }\n+    }\n+\n+    private static List<List<Contig>> findLongestPaths( final List<Contig> toMatch,\n+                                                        final List<Path> readPaths ) {\n+        final List<List<Contig>> results = new ArrayList<>();\n+        for ( final Path path : readPaths ) {\n+            testPath(path, toMatch, results);\n+            testPath(path.rc(), toMatch, results);\n+        }\n+        return results;\n+    }\n+\n+    private static void testPath( final Path path,\n+                                  final List<Contig> toMatch,\n+                                  final List<List<Contig>> results ) {\n+        final List<PathPart> pathParts = path.getParts();\n+        final int nPathParts = pathParts.size();\n+        final List<Contig> pathContigs = new ArrayList<>(nPathParts);\n+        pathParts.forEach(pp -> pathContigs.add(pp.getContig()));\n+        final int matchIdx = Collections.indexOfSubList(pathContigs, toMatch);\n+        if ( matchIdx != -1 ) {\n+            final int suffixIdx = matchIdx + toMatch.size();\n+            if ( suffixIdx < nPathParts ) {\n+                resolveResult(grabParts(pathContigs, suffixIdx), results);\n+            }\n+        }\n+    }\n+\n+    private static List<Contig> grabParts( final List<Contig> pathContigs, final int suffixIdx ) {\n+        final int nPathContigs = pathContigs.size();\n+        Contig prev = pathContigs.get(suffixIdx - 1);\n+        final List<Contig> result = new ArrayList<>(nPathContigs - suffixIdx);\n+        for ( int idx = suffixIdx; idx != nPathContigs; ++idx ) {\n+            final Contig tig = pathContigs.get(idx);\n+            if ( tig == null || !prev.getSuccessors().contains(tig) ) break;\n+            result.add(tig);\n+            prev = tig;\n+        }\n+        return result;\n+    }\n+\n+    private static void resolveResult( final List<Contig> result,\n+                                       final List<List<Contig>> results ) {\n+        final int nResults = results.size();\n+        for ( int idx = 0; idx != nResults; ++idx ) {\n+            final List<Contig> test = results.get(idx);\n+            if ( isPrefix(result, test) ) return;\n+            if ( isPrefix(test, result) ) {\n+                results.set(idx, result);\n+                return;\n+            }\n+        }\n+        results.add(result);\n+    }\n+\n+    private static boolean isPrefix( final List<Contig> list1, final List<Contig> list2 ) {\n+        final int list1Size = list1.size();\n+        final int list2Size = list2.size();\n+        if ( list1Size > list2Size ) return false;\n+        for ( int idx = 0; idx != list1Size; ++idx ) {\n+            if ( list1.get(idx) != list2.get(idx) ) return false;\n+        }\n+        return true;\n+    }\n+\n+    @VisibleForTesting\n+    static Collection<Traversal> createScaffolds( final List<Traversal> allTraversals ) {\n+        removeTriviallyDifferentTraversals(allTraversals);\n+\n+        final int nTraversals = allTraversals.size();\n+        final Map<Contig, List<Integer>> traversalsByFirstContig = new HashMap<>(3 * nTraversals);\n+        for ( int idx = 0; idx != nTraversals; ++idx ) {\n+            final Traversal traversal = allTraversals.get(idx);\n+            traversalsByFirstContig.compute(traversal.getFirstContig(),\n+                    ( k, v ) -> v == null ? new ArrayList<>(3) : v).add(idx);\n+            final Traversal rcTraversal = traversal.rc();\n+            traversalsByFirstContig.compute(rcTraversal.getFirstContig(),\n+                    ( k, v ) -> v == null ? new ArrayList<>(3) : v).add(~idx);\n+        }\n+\n+        final List<Traversal> scaffolds = new ArrayList<>(nTraversals);\n+        final boolean[] touched = new boolean[nTraversals];\n+        for ( int idx = 0; idx != nTraversals; ++idx ) {\n+            if ( !touched[idx] ) {\n+                expandTraversal(idx, touched, traversalsByFirstContig, allTraversals, scaffolds);\n+            }\n+        }\n+        return scaffolds;\n+    }\n+\n+    private static void expandTraversal( final int traversalIdx,\n+                                         final boolean[] touched,\n+                                         final Map<Contig, List<Integer>> traversalsByFirstContig,\n+                                         final List<Traversal> allTraversals,\n+                                         final List<Traversal> scaffolds ) {\n+        final Traversal traversal = allTraversals.get(traversalIdx);\n+        touched[traversalIdx] = true;\n+        final List<Traversal> downExtensions = new ArrayList<>();\n+        final Set<Contig> startingContigSet = new HashSet<>();\n+        walkTraversals(traversal, touched, startingContigSet, traversalsByFirstContig,\n+                        allTraversals, downExtensions);\n+        final List<Traversal> upExtensions = new ArrayList<>();\n+        walkTraversals(traversal.rc(), touched, startingContigSet, traversalsByFirstContig,\n+                        allTraversals, upExtensions);\n+        for ( final Traversal down : downExtensions ) {\n+            for ( final Traversal up : upExtensions ) {\n+                if ( scaffolds.size() >= TOO_MANY_SCAFFOLDS ) {\n+                    throw new AssemblyTooComplexException();\n+                }\n+                scaffolds.add(Traversal.combineOverlappers(up.rc(), down, traversal.getContigs().size()));\n+            }\n+        }\n+    }\n+\n+    private static void walkTraversals( final Traversal traversal,\n+                                        final boolean[] touched,\n+                                        final Set<Contig> startingContigSet,\n+                                        final Map<Contig, List<Integer>> traversalsByFirstContig,\n+                                        final List<Traversal> allTraversals,\n+                                        final List<Traversal> extensions ) {\n+        final Contig firstContig = traversal.getFirstContig();\n+        final List<Integer> indexList;\n+        if ( startingContigSet.contains(firstContig) ||\n+                traversal.isInextensible() ||\n+                (indexList = traversalsByFirstContig.get(traversal.getLastContig())) == null ) {\n+            extensions.add(traversal);\n+            return;\n+        }\n+        startingContigSet.add(firstContig);\n+        for ( int idx : indexList ) {\n+            final Traversal extension;\n+            if ( idx >= 0 ) {\n+                extension = allTraversals.get(idx);\n+                touched[idx] = true;\n+            } else {\n+                final int rcIdx = ~idx;\n+                extension = allTraversals.get(rcIdx).rc();\n+                touched[rcIdx] = true;\n+            }\n+            walkTraversals(Traversal.combine(traversal, extension), touched, startingContigSet,\n+                            traversalsByFirstContig, allTraversals, extensions );\n+        }\n+        startingContigSet.remove(firstContig);\n+    }\n+\n+    private static void removeTriviallyDifferentTraversals(\n+                                            final Collection<Traversal> allTraversals ) {\n+        if ( allTraversals.isEmpty() ) {\n+            return;\n+        }\n+        final TreeSet<Traversal> sortedTraversals = new TreeSet<>(new TraversalEndpointComparator());\n+        for ( final Traversal traversal : allTraversals ) {\n+            sortedTraversals.add(traversal);\n+            sortedTraversals.add(traversal.rc());\n+        }\n+        final Iterator<Traversal> traversalIterator = sortedTraversals.iterator();\n+        Traversal prevTraversal = traversalIterator.next();\n+        while ( traversalIterator.hasNext() ) {\n+            final Traversal curTraversal = traversalIterator.next();\n+            if ( isTriviallyDifferent(prevTraversal, curTraversal) ) {\n+                traversalIterator.remove();\n+            } else {\n+                prevTraversal = curTraversal;\n+            }\n+        }\n+        sortedTraversals.removeIf(Traversal::isRC);\n+        allTraversals.clear();\n+        allTraversals.addAll(sortedTraversals);\n+    }\n+\n+    private static boolean isTriviallyDifferent( final Traversal traversal1,\n+                                                 final Traversal traversal2 ) {\n+        final Contig firstContig1 = traversal1.getFirstContig();\n+        final Contig lastContig1 = traversal1.getLastContig();\n+        final Contig firstContig2 = traversal2.getFirstContig();\n+        final Contig lastContig2 = traversal2.getLastContig();\n+        if ( firstContig1 != firstContig2 || lastContig1 != lastContig2 ) {\n+            return false;\n+        }\n+        final int interiorSize1 = traversal1.getSequenceLength() - firstContig1.size() - lastContig1.size();\n+        final int interiorSize2 = traversal2.getSequenceLength() - firstContig2.size() - lastContig2.size();\n+\n+        // if the path lengths are so different that one could harbor an SV, they're not trivially different\n+        if ( Math.abs(interiorSize1 - interiorSize2) >= MIN_SV_SIZE ) {\n+            return false;\n+        }\n+\n+        // if the paths are small enough that there can't be an SV's worth of differences, they're trivially different\n+        final int maxInteriorSize = Math.max(interiorSize1, interiorSize2);\n+        if ( maxInteriorSize < MIN_SV_SIZE ) {\n+            return true;\n+        }\n+\n+        // dang, maybe there's enough material in common that there can't be an SV's worth of differences\n+        // run a longest common subsequence algorithm to figure out the length of the common material\n+        // DP matrix holds length of common material\n+        final List<Contig> contigs1 = traversal1.getContigs();\n+        final int rowLen = contigs1.size() - 1;\n+        final int[][] rowPair = new int[2][];\n+        rowPair[0] = new int[rowLen];\n+        rowPair[1] = new int[rowLen];\n+        int pairIdx = 0;\n+        final List<Contig> contigs2 = traversal2.getContigs();\n+        final int nRows = contigs2.size() - 1;\n+        for ( int idx2 = 1; idx2 != nRows; ++idx2 ) {\n+            final int[] curRow = rowPair[pairIdx];\n+            final int[] prevRow = rowPair[pairIdx ^ 1];\n+            pairIdx ^= 1;\n+\n+            final int id2 = contigs2.get(idx2).getId();\n+            for ( int idx1 = 1; idx1 != rowLen; ++idx1 ) {\n+                final Contig tig1 = contigs1.get(idx1);\n+                if ( tig1.getId() == id2 ) {\n+                    // if the previous cells also contain a match we've already removed the K-1 bases upstream\n+                    final boolean extendMatch =\n+                            contigs1.get(idx1 -1).getId() == contigs2.get(idx2 - 1).getId();\n+                    curRow[idx1] = prevRow[idx1 - 1] + (extendMatch ? tig1.getNKmers() : tig1.size());\n+                } else {\n+                    curRow[idx1] = Math.max(curRow[idx1 - 1], prevRow[idx1]);\n+                }\n+            }\n+        }\n+        final int commonLen = rowPair[pairIdx ^ 1][rowLen - 1];\n+        return (maxInteriorSize - commonLen) < MIN_SV_SIZE;\n+    }\n+\n+    private static class TraversalEndpointComparator implements Comparator<Traversal> {\n+        @Override\n+        public int compare( final Traversal traversal1, final Traversal traversal2 ) {\n+            int cmp = Integer.compare(traversal1.contigs.get(0).getId(),\n+                                      traversal2.contigs.get(0).getId());\n+            if ( cmp != 0 ) {\n+                return cmp;\n+            }\n+            final int last1 = traversal1.contigs.size() - 1;\n+            final int last2 = traversal2.contigs.size() - 1;\n+            cmp = Integer.compare(traversal1.contigs.get(last1).getId(),\n+                                  traversal2.contigs.get(last2).getId());\n+            if ( cmp != 0 ) {\n+                return cmp;\n+            }\n+            // among those starting and ending at the same place, sort least observed last\n+            return -Integer.compare(traversal1.getMinMaxObservations(), traversal2.getMinMaxObservations());\n+        }\n+    }\n+\n+    private static void writeDOT( final List<ContigImpl> contigs, final String fileName ) {\n+        try ( final BufferedWriter writer = new BufferedWriter(new FileWriter(fileName)) ) {\n+            writer.write(\"digraph {\\n\");\n+            for ( final Contig contig : contigs ) {\n+                final double width = contig.getSequence().length() / 100.;\n+                writer.write(contig + \" [width=\" + width + \"]\\n\");\n+                writer.write( contig.rc() + \" [width=\" + width + \"]\\n\");\n+            }\n+            for ( final Contig contig : contigs ) {\n+                for ( final Contig predecessor : contig.getPredecessors() ) {\n+                    final String predecessorName = predecessor.rc().toString();\n+                    writer.write(contig.rc() + \" -> \" + predecessorName + \"\\n\");\n+                }\n+                for ( final Contig successor : contig.getSuccessors() ) {\n+                    final String successorName = successor.toString();\n+                    writer.write(contig + \" -> \" + successorName + \"\\n\");\n+                }\n+            }\n+            writer.write(\"}\\n\");\n+        } catch ( final IOException ioe ) {\n+            throw new GATKException(\"Failed to write assembly DOT file.\", ioe);\n+        }\n+    }\n+\n+    private static BufferedWriter makeGZFile( final String fileName ) throws IOException {\n+        final GZIPOutputStream gzOS = new GZIPOutputStream(BucketUtils.createFile(fileName));\n+        return new BufferedWriter(new OutputStreamWriter(gzOS));\n+    }\n+\n+    private static void writeContigs( final List<ContigImpl> contigs, final String fileName ) {\n+        try ( final BufferedWriter writer = makeGZFile(fileName) ) {\n+            for ( final Contig contig : contigs ) {\n+                final List<Contig> predecessors = contig.getPredecessors();\n+                final String predecessorDescription;\n+                if ( predecessors.size() == 0 ) {\n+                    predecessorDescription = \"\\tnone\";\n+                } else {\n+                    final StringBuilder sb = new StringBuilder();\n+                    char prefix = '\\t';\n+                    for ( final Contig predecessor : predecessors ) {\n+                        sb.append(prefix);\n+                        prefix = ',';\n+                        sb.append(predecessor);\n+                    }\n+                    predecessorDescription = sb.toString();\n+                }\n+\n+                final List<Contig> successors = contig.getSuccessors();\n+                final String successorDescription;\n+                if ( successors.size() == 0 ) {\n+                    successorDescription = \"\\tnone\";\n+                } else {\n+                    final StringBuilder sb = new StringBuilder();\n+                    char prefix = '\\t';\n+                    for ( final Contig successor : successors ) {\n+                        sb.append(prefix);\n+                        prefix = ',';\n+                        sb.append(successor);\n+                    }\n+                    successorDescription = sb.toString();\n+                }\n+\n+                final String contigName = contig.toString();\n+                final String component =\n+                        (contig.isCyclic() ? \"(C)\\t\" : \"\\t\") + contig.getComponentId();\n+                writer.write(contigName + component + predecessorDescription +\n+                        successorDescription + \"\\t\" +\n+                        contig.getMaxObservations() + \"\\t\" +\n+                        contig.getFirstKmer().getNObservations() + \"\\t\" +\n+                        contig.getLastKmer().getNObservations() + \"\\t\" +\n+                        contig.size() + \"\\t\" +\n+                        contig.getSequence() + \"\\n\");\n+            }\n+        } catch ( final IOException ioe ) {\n+            throw new GATKException(\"Failed to write contigs file.\", ioe);\n+        }\n+    }\n+\n+    private static void writePaths( final List<Path> readPaths, final String fileName ) {\n+        try ( final BufferedWriter writer = makeGZFile(fileName) ) {\n+            final int nReads = readPaths.size();\n+            for ( int readId = 0; readId != nReads; ++readId ) {\n+                final Path path = readPaths.get(readId);\n+                final String pathDesc = path.toString();\n+                writer.write((readId + 1) + \": \" + pathDesc + \"\\n\");\n+            }\n+        } catch ( final IOException ioe ) {\n+            throw new GATKException(\"Failed to write paths file.\", ioe);\n+        }\n+    }\n+\n+    private static void writeReads( final List<GATKRead> reads, final String fileName ) {\n+        try ( final BufferedWriter writer = makeGZFile(fileName) ) {\n+            for ( final GATKRead read : reads ) {\n+                writer.write(\"@\" + read.getName());\n+                writer.write('\\n');\n+                writer.write(new String(read.getBasesNoCopy()));\n+                writer.write(\"\\n+\\n\");\n+                final byte[] quals = read.getBaseQualitiesNoCopy();\n+                final int nQuals = quals.length;\n+                final byte[] fastqQuals = new byte[nQuals];\n+                for ( int idx = 0; idx != nQuals; ++idx ) {\n+                    fastqQuals[idx] = (byte)SAMUtils.phredToFastq(quals[idx]);\n+                }\n+                writer.write(new String(fastqQuals));\n+                writer.write('\\n');\n+            }\n+        } catch ( final IOException ioe ) {\n+            throw new GATKException(\"Failed to write assembly sam file.\", ioe);\n+        }\n+    }\n+\n+    private static void writeTraversals( final Collection<Traversal> traversals,\n+                                         final String fileName ) {\n+        try ( final BufferedWriter writer = makeGZFile(fileName) ) {\n+            int traversalNo = 0;\n+            for ( final Traversal traversal : traversals ) {\n+                writer.write(\">\");\n+                if ( assemblyName != null ) {\n+                    writer.write(assemblyName);\n+                    writer.write(\"_\");\n+                }\n+                writer.write(\"t\");\n+                writer.write(Integer.toString(++traversalNo));\n+                writer.write(\" \");\n+                writer.write(traversal.getName());\n+                writer.newLine();\n+                writer.write(traversal.getSequence());\n+                writer.newLine();\n+            }\n+        } catch ( final IOException ioe ) {\n+            throw new GATKException(\"Failed to write assembly sam file.\", ioe);\n+        }\n+    }\n+\n+    /** fixed-size, immutable kmer.  usual 2-bit encoding: ACGT->0123.  low order bits are final call. **/\n+    public static class Kmer {\n+        public static final int KSIZE = 31; // must be odd number less than 32\n+        public static final long KMASK = (1L << 2*KSIZE) - 1L;\n+        private final long kVal;\n+\n+        public Kmer( final long kVal ) { this.kVal = kVal; }\n+\n+        public long getKVal() { return kVal; }\n+        public boolean isCanonical() { return isCanonical(kVal); }\n+        public int getInitialCall() { return (int)(kVal >> (KSIZE*2 - 2)) & 3; }\n+        public int getFinalCall() { return (int)kVal & 3; }\n+\n+        public long getPredecessorVal( final int call ) {\n+            return (kVal >> 2) | ((long)call << (2 * (KSIZE - 1)));\n+        }\n+        public long getSuccessorVal( final int call ) { return ((kVal << 2) & KMASK) | call; }\n+\n+        public static boolean isCanonical( final long val ) {\n+            return (val & (1L << KSIZE)) == 0L;\n+        }\n+\n+        @Override public boolean equals( final Object obj ) {\n+            return obj instanceof Kmer && kVal == ((Kmer)obj).kVal;\n+        }\n+\n+        @Override public int hashCode() {\n+            return (int)(kVal ^ (kVal >>> 32));\n+        }\n+    }\n+\n+    /** Set of Kmers.  Uses HopscotchSet, customized to find correct starting bin for Kmers and derivatives. **/\n+    public static final class KmerSet<KMER extends Kmer> extends HopscotchSet<KMER> {\n+        public KmerSet( final int capacity ) { super(capacity); }\n+\n+        @Override\n+        protected int hashToIndex( final Object kmer ) {\n+            return (int)(((HopscotchSet.SPREADER * ((Kmer)kmer).getKVal()) & Long.MAX_VALUE) % capacity());\n+        }\n+    }\n+\n+    /**\n+     *  A Kmer that remembers its predecessors and successors, and the number of times it's been observed\n+     *  in the assembly's input set of reads.\n+     *  The masks are bit-wise (1=A, 2=C, 4=G, 8=T) to show which predecessors or successors have been observed.\n+     *  The Kmer's position on a Contig is also tracked (in later phases of the assembly process).\n+     **/\n+    public static abstract class KmerAdjacency extends Kmer {\n+        public KmerAdjacency( final long kVal ) { super(kVal); }\n+\n+        public abstract KmerAdjacency getSolePredecessor(); // returns null if there's 0 or >1 predecessors\n+        public abstract int getPredecessorMask();\n+        public abstract int getPredecessorCount();\n+        public abstract void removePredecessor( final int callToRemove,\n+                                                final KmerSet<KmerAdjacency> kmerAdjacencySet );\n+\n+        public abstract KmerAdjacency getSoleSuccessor(); // returns null if there's 0 or > 1 successors\n+        public abstract int getSuccessorMask();\n+        public abstract int getSuccessorCount();\n+        public abstract void removeSuccessor( final int callToRemove,\n+                                              final KmerSet<KmerAdjacency> kmerAdjacencySet );\n+\n+        public abstract Contig getContig();\n+        public abstract int getContigOffset();\n+        // offset is 0-based measure on the contig sequence of the beginning of the kmer\n+        public abstract void setContigOffset( final Contig contig, final int contigOffset );\n+        public abstract void clearContig();\n+\n+        public abstract int getNObservations();\n+        public abstract KmerAdjacency rc();\n+        public abstract KmerAdjacencyImpl canonical();\n+\n+        public void observe( final KmerAdjacency predecessor, final KmerAdjacency successor ) {\n+            observe(predecessor, successor, 1);\n+        }\n+\n+        public abstract void observe( final KmerAdjacency predecessor,\n+                                      final KmerAdjacency successor,\n+                                      final int count );\n+\n+        @Override public String toString() {\n+            final StringBuilder sb = new StringBuilder(KSIZE);\n+            long currentVal = getKVal();\n+            for ( int idx = 0; idx != KSIZE; ++idx ) {\n+                sb.append(\"ACGT\".charAt((int)currentVal & 3));\n+                currentVal >>= 2;\n+            }\n+            sb.reverse(); // low order bits were loaded into sb first:  fix that now by reversing the sb.\n+            return sb.toString();\n+        }\n+\n+        /**\n+         * Transform a read's calls into KmerAdjacencies, and add them to a KmerSet.\n+         * Skip kmers that include a call with a quality < qMin.\n+         * Skip kmers with non-ACGT calls.\n+         **/\n+        public static void kmerize( final byte[] calls,\n+                                    final byte[] quals,\n+                                    final byte qMin,\n+                                    final KmerSet<KmerAdjacency> kmerAdjacencySet ) {\n+            int currentCount = 0; // number of calls loaded into currentKVal\n+            long currentKVal = 0;\n+            KmerAdjacency prevAdjacency = null;\n+            KmerAdjacency currentAdjacency = null;\n+            for ( int idx = 0; idx < calls.length; ++idx ) {\n+                if ( quals[idx] < qMin ) { // if we encounter a low-quality call\n+                    // take care of the most recent valid KmerAdjacency, if any\n+                    if ( currentAdjacency != null ) {\n+                        currentAdjacency.observe(prevAdjacency, null);\n+                    }\n+                    // ready ourselves to accumulate calls afresh\n+                    currentCount = 0;\n+                    currentAdjacency = prevAdjacency = null;\n+                    continue;\n+                }\n+                currentKVal <<= 2;\n+                switch ( calls[idx] ) {\n+                    case 'A': case 'a': break;\n+                    case 'C': case 'c': currentKVal += 1; break;\n+                    case 'G': case 'g': currentKVal += 2; break;\n+                    case 'T': case 't': currentKVal += 3; break;\n+                    default:\n+                        if ( currentAdjacency != null ) {\n+                            currentAdjacency.observe(prevAdjacency, null);\n+                        }\n+                        currentCount = 0;\n+                        currentAdjacency = prevAdjacency = null;\n+                        continue;\n+                }\n+                if ( ++currentCount >= KSIZE ) { // if we've loaded enough calls to make a complete kmer\n+                    final KmerAdjacency nextAdjacency = findOrAdd(currentKVal, kmerAdjacencySet);\n+                    if ( currentAdjacency != null ) {\n+                        currentAdjacency.observe(prevAdjacency, nextAdjacency);\n+                    }\n+                    prevAdjacency = currentAdjacency;\n+                    currentAdjacency = nextAdjacency;\n+                }\n+            }\n+            if ( currentAdjacency != null ) {\n+                currentAdjacency.observe(prevAdjacency, null);\n+            }\n+        }\n+\n+        /**\n+         * Kmerize a String.  This version is for gap fills.\n+         * The number of observations applies to all kmers except the 1st and last.\n+         **/\n+        public static void kmerize( final String sequence,\n+                                    final int nObservations,\n+                                    final KmerSet<KmerAdjacency> kmerAdjacencySet ) {\n+            int currentCount = 0;\n+            long currentKVal = 0;\n+            int nObs = 0;\n+            KmerAdjacency prevAdjacency = null;\n+            KmerAdjacency currentAdjacency = null;\n+            final int nCalls = sequence.length();\n+            for ( int idx = 0; idx != nCalls; ++idx ) {\n+                currentKVal <<= 2;\n+                switch ( sequence.charAt(idx) ) {\n+                    case 'A': case 'a': break;\n+                    case 'C': case 'c': currentKVal += 1; break;\n+                    case 'G': case 'g': currentKVal += 2; break;\n+                    case 'T': case 't': currentKVal += 3; break;\n+                    default: throw new GATKException(\"unexpected base call in string to kmerize.\");\n+                }\n+                if ( ++currentCount >= KSIZE ) {\n+                    final KmerAdjacency nextAdjacency = findOrAdd(currentKVal, kmerAdjacencySet);\n+                    if ( currentAdjacency != null ) {\n+                        currentAdjacency.observe(prevAdjacency, nextAdjacency, nObs);\n+                        nObs = nObservations;\n+                    }\n+                    prevAdjacency = currentAdjacency;\n+                    currentAdjacency = nextAdjacency;\n+                }\n+            }\n+            if ( currentAdjacency != null ) {\n+                currentAdjacency.observe(prevAdjacency, null, 0);\n+            }\n+        }\n+\n+        // Lookup table for reverse-complementing each possible byte value.\n+        // Each pair of bits represents a base, so you have to reverse bits pairwise and then invert all bits.\n+        // This is most quickly and easily done with a lookup table.\n+        private static final long[] BYTEWISE_REVERSE_COMPLEMENT;\n+        static {\n+            BYTEWISE_REVERSE_COMPLEMENT = new long[256];\n+            for ( int bIn = 0; bIn != 256; ++bIn ) {\n+                BYTEWISE_REVERSE_COMPLEMENT[bIn] =\n+                        ~(((bIn & 3) << 6) | (((bIn >> 2) & 3) << 4) |\n+                                (((bIn >> 4) & 3) << 2) | ((bIn >> 6) & 3)) & 0xffL;\n+            }\n+        }\n+\n+        public static long reverseComplement( long val ) {\n+            // process val one byte at a time\n+            long result = BYTEWISE_REVERSE_COMPLEMENT[(int)val & 0xFF]; // handle the low-order byte\n+            int nBytes = 8;\n+            while ( --nBytes != 0 ) { // pre-decrementing:  we'll go through the loop 7 times\n+                // rotate down by a byte\n+                val >>= 8;\n+                // rotate up by a byte and OR in the reverse complement of the next byte\n+                result = (result << 8) | BYTEWISE_REVERSE_COMPLEMENT[(int)val & 0xFF];\n+            }\n+            return result >>> (Long.SIZE - 2*KSIZE);\n+        }\n+\n+        // Kmer lookup in KmerSet.\n+        // KmerSets holding KmerAdjacencies have only canonical Kmers, so RC non-canonical kmers before lookup.\n+        public static KmerAdjacency find( final long kVal,\n+                                          final KmerSet<KmerAdjacency> kmerAdjacencySet ) {\n+            if ( isCanonical(kVal) ) return kmerAdjacencySet.find(new Kmer(kVal & KMASK));\n+            final KmerAdjacency result = kmerAdjacencySet.find(new Kmer(reverseComplement(kVal)));\n+            return result == null ? null : result.rc();\n+        }\n+\n+        // Kmer lookup in KmerSet.\n+        // KmerSets holding KmerAdjacencies have only canonical Kmers, so RC non-canonical kmers before lookup.\n+        // Add missing Kmers.\n+        public static KmerAdjacency findOrAdd( final long kVal,\n+                                               final KmerSet<KmerAdjacency> kmerAdjacencySet ) {\n+            if ( isCanonical(kVal) ) {\n+                return kmerAdjacencySet.findOrAdd(new Kmer(kVal & KMASK), kmer ->\n+                        new KmerAdjacencyImpl(((Kmer)kmer).getKVal()));\n+            }\n+            return kmerAdjacencySet.findOrAdd(new Kmer(reverseComplement(kVal)), kmer ->\n+                    new KmerAdjacencyImpl(((Kmer)kmer).getKVal())).rc();\n+        }\n+    }\n+\n+    /**\n+     * Class to implement KmerAdjacency for canonical Kmers.\n+     * In particular, a KmerSet created on KmerAdjacency contains only canonical Kmers.\n+     **/\n+    public static final class KmerAdjacencyImpl extends KmerAdjacency {\n+        private KmerAdjacency solePredecessor; // set to null if there are no predecessors, or multiple predecessors\n+        private KmerAdjacency soleSuccessor; // set to null if there are no successors, or multiple successors\n+        private int predecessorMask; // bit mask of observed kmers preceding this one\n+        private int successorMask; // bit mask observed kmers following this one\n+        private Contig contig; // the contig that contains this Kmer\n+        private int contigOffset; // the offset within the contig where this kmer is found\n+        private int nObservations; // the reads in which this kmer was observed\n+        private final KmerAdjacencyRC rc; // the reverse-complement of this kmer\n+        private static final int[] COUNT_FOR_MASK =\n+                //side sum for binary values from 0 -> 15\n+                //0000  0001 0010 0011 0100 0101 0110 0111 1000 1001 1010 1011 1100 1101 1110 1111\n+                {    0,    1,   1,   2,   1,   2,   2,   3,   1,   2,   2,   3,   2,   3,   3,   4 };\n+\n+        public KmerAdjacencyImpl( final long kVal ) {\n+            super(kVal);\n+            this.rc = new KmerAdjacencyRC(this);\n+        }\n+\n+        @Override public KmerAdjacency getSolePredecessor() { return solePredecessor; } // may return null\n+        @Override public int getPredecessorMask() { return predecessorMask; }\n+        @Override public int getPredecessorCount() { return COUNT_FOR_MASK[predecessorMask]; }\n+        @Override\n+        public void removePredecessor( final int callToRemove,\n+                                       final KmerSet<KmerAdjacency> kmerAdjacencySet ) {\n+            predecessorMask &= ~(1 << callToRemove);\n+            solePredecessor = null;\n+            if ( getPredecessorCount() == 1 ) {\n+                for ( int call = 0; call != 4; ++call ) {\n+                    if ( ((1 << call) & predecessorMask) != 0 ) {\n+                        solePredecessor = find(getPredecessorVal(call), kmerAdjacencySet);\n+                        break;\n+                    }\n+                }\n+            }\n+        }\n+\n+        @Override public KmerAdjacency getSoleSuccessor() { return soleSuccessor; } // may return null\n+        @Override public int getSuccessorMask() { return successorMask; }\n+        @Override public int getSuccessorCount() { return COUNT_FOR_MASK[successorMask]; }\n+        @Override\n+        public void removeSuccessor( final int callToRemove,\n+                                     final KmerSet<KmerAdjacency> kmerAdjacencySet ) {\n+            successorMask &= ~(1 << callToRemove);\n+            soleSuccessor = null;\n+            if ( getSuccessorCount() == 1 ) {\n+                for ( int call = 0; call != 4; ++call ) {\n+                    if ( ((1 << call) & successorMask) != 0 ) {\n+                        soleSuccessor = find(getSuccessorVal(call), kmerAdjacencySet);\n+                        break;\n+                    }\n+                }\n+            }\n+        }\n+\n+        @Override public Contig getContig() { return contig; }\n+        @Override public int getContigOffset() { return contigOffset; }\n+        @Override public void setContigOffset( final Contig contig, final int contigOffset ) {\n+            if ( this.contig != null ) {\n+                throw new GATKException(\"Internal error: overwriting kmer contig and offset.\");\n+            }\n+            this.contig = contig;\n+            this.contigOffset = contigOffset;\n+        }\n+        @Override public void clearContig() { contig = null; contigOffset = 0; }\n+\n+        @Override public int getNObservations() { return nObservations; }\n+        @Override public KmerAdjacency rc() { return rc; }\n+        @Override public KmerAdjacencyImpl canonical() { return this; }\n+\n+        @Override public void observe( final KmerAdjacency predecessor,\n+                                       final KmerAdjacency successor,\n+                                       final int count ) {\n+            if ( predecessor != null ) {\n+                if ( predecessor.getSuccessorVal(getFinalCall()) != getKVal() ) {\n+                    throw new GATKException(\"illegal predecessor\");\n+                }\n+                final int initialCall = predecessor.getInitialCall();\n+                final int newPredecessorMask = 1 << initialCall;\n+                if ( (newPredecessorMask & predecessorMask) == 0 ) {\n+                    if ( predecessorMask == 0 ) {\n+                        solePredecessor = predecessor;\n+                        predecessorMask = newPredecessorMask;\n+                    } else {\n+                        solePredecessor = null;\n+                        predecessorMask |= newPredecessorMask;\n+                    }\n+                }\n+            }\n+            if ( successor != null ) {\n+                if ( successor.getPredecessorVal(getInitialCall()) != getKVal() ) {\n+                    throw new GATKException(\"illegal successor\");\n+                }\n+                final int finalCall = successor.getFinalCall();\n+                final int newSuccessorMask = 1 << finalCall;\n+                if ( (newSuccessorMask & successorMask) == 0 ) {\n+                    if ( successorMask == 0 ) {\n+                        soleSuccessor = successor;\n+                        successorMask = newSuccessorMask;\n+                    } else {\n+                        soleSuccessor = null;\n+                        successorMask |= newSuccessorMask;\n+                    }\n+                }\n+            }\n+            nObservations += count;\n+        }\n+    }\n+\n+    /**\n+     * Class to implement KmerAdjacency for Kmers that are the reverse-complement of a canonical Kmer.\n+     * In particular, a KmerSet created on KmerAdjacency contains only canonical Kmers.\n+     * A KmerAdjacencyRC represents the RC of each Kmer in the KmerSet.\n+     **/\n+    public static final class KmerAdjacencyRC extends KmerAdjacency {\n+        private final KmerAdjacencyImpl rc;\n+\n+        // lookup table to bit-reverse nibbles\n+        private static final int[] NIBREV =\n+                // 0000,  0001,  0010,  0011,  0100,  0101,  0110,  0111,  1000,  1001,  1010,  1011,  1100,  1101,  1110,  1111\n+                {0b0000,0b1000,0b0100,0b1100,0b0010,0b1010,0b0110,0b1110,0b0001,0b1001,0b0101,0b1101,0b0011,0b1011,0b0111,0b1111};\n+\n+        public KmerAdjacencyRC( final KmerAdjacencyImpl rc ) {\n+            super(reverseComplement(rc.getKVal()));\n+            this.rc = rc;\n+        }\n+\n+        @Override public KmerAdjacency getSolePredecessor() {\n+            final KmerAdjacency successor = rc.getSoleSuccessor();\n+            return successor == null ? null : successor.rc();\n+        }\n+        @Override public int getPredecessorMask() { return NIBREV[rc.getSuccessorMask()]; }\n+        @Override public int getPredecessorCount() { return rc.getSuccessorCount(); }\n+        @Override\n+        public void removePredecessor( final int callToRemove,\n+                                       final KmerSet<KmerAdjacency> kmerAdjacencySet ) {\n+            rc.removeSuccessor(3 - callToRemove, kmerAdjacencySet);\n+        }\n+\n+        @Override public KmerAdjacency getSoleSuccessor() {\n+            final KmerAdjacency predecessor = rc.getSolePredecessor();\n+            return predecessor == null ? null : predecessor.rc();\n+        }\n+        @Override public int getSuccessorMask() { return NIBREV[rc.getPredecessorMask()]; }\n+        @Override public int getSuccessorCount() { return rc.getPredecessorCount(); }\n+        @Override\n+        public void removeSuccessor( final int callToRemove,\n+                                     final KmerSet<KmerAdjacency> kmerAdjacencySet ) {\n+            rc.removePredecessor(3 - callToRemove, kmerAdjacencySet);\n+        }\n+\n+        @Override public Contig getContig() {\n+            final Contig contig = rc.getContig();\n+            return contig == null ? null : contig.rc();\n+        }\n+        @Override public int getContigOffset() {\n+            final Contig contig = rc.getContig();\n+            return contig == null ? 0 : contig.size() - rc.getContigOffset() - KSIZE;\n+        }\n+        @Override public void setContigOffset( final Contig contig, final int contigOffset ) {\n+            rc.setContigOffset(contig.rc(), contig.size() - contigOffset - KSIZE);\n+        }\n+        @Override public void clearContig() { rc.clearContig(); }\n+\n+        @Override public int getNObservations() { return rc.getNObservations(); }\n+        @Override public KmerAdjacency rc() { return rc; }\n+        @Override public KmerAdjacencyImpl canonical() { return rc; }\n+\n+        @Override public void observe( final KmerAdjacency predecessor,\n+                                       final KmerAdjacency successor,\n+                                       final int count ) {\n+            rc.observe(successor == null ? null : successor.rc(),\n+                    predecessor == null ? null : predecessor.rc(),\n+                    count);\n+        }\n+    }\n+\n+    public enum ContigOrientation {\n+        FWD, // k-mer appears at the 5' end of the contig\n+        REV, // k-mer appears at the 5' end of the reverse-complemented contig\n+        BOTH // k-mer occurs on 5' end of the contig and its RC (can happen when the contig is a palindrome)\n+    }\n+\n+    /** Initial or final Kmer in a Contig. **/\n+    public static final class ContigEndKmer extends Kmer {\n+        private final Contig contig;\n+        private final ContigOrientation contigOrientation;\n+\n+        public ContigEndKmer( final long kVal,\n+                              final Contig contig,\n+                              final ContigOrientation contigEnd ) {\n+            super(kVal);\n+            this.contig = contig;\n+            this.contigOrientation = contigEnd;\n+        }\n+\n+        public Contig getContig() { return contig; }\n+        public ContigOrientation getContigOrientation() { return contigOrientation; }\n+    }\n+\n+    /**\n+     * An unbranched sequence of Kmers.\n+     * Each Kmer (except the last one) has a single successor, which allows enumerating the sequence\n+     * of Kmers in the Contig.  The sequence of base calls in the Contig is just the sequence of kmers\n+     * with the K-1 overlapping calls removed from adjacent kmers.\n+     **/\n+    public interface Contig {\n+        int getId();\n+        CharSequence getSequence();\n+        int getMaxObservations();\n+        KmerAdjacency getFirstKmer();\n+        KmerAdjacency getLastKmer();\n+        List<Contig> getPredecessors();\n+        List<Contig> getSuccessors();\n+        int getComponentId();\n+        int size();\n+        default int getNKmers() { return size() - Kmer.KSIZE + 1; }\n+        Contig rc();\n+        boolean isCyclic();\n+        void setCyclic( final boolean cyclic );\n+        boolean isCut();\n+        void setCut( final boolean cut );\n+        boolean isCanonical();\n+        ContigImpl canonical();\n+    }\n+\n+    /** Simple implementation of Contig interface. **/\n+    public static final class ContigImpl implements Contig {\n+        private final int id;\n+        private final CharSequence sequence;\n+        private final int maxObservations;\n+        private final KmerAdjacency firstKmer;\n+        private final KmerAdjacency lastKmer;\n+        private final List<Contig> predecessors;\n+        private final List<Contig> successors;\n+        private int componentId;\n+        private boolean cyclic;\n+        private boolean cut;\n+        private final Contig rc;\n+\n+        public ContigImpl( final int id, final KmerAdjacency firstKmerAdjacency ) {\n+            this.id = id;\n+            final StringBuilder sb = new StringBuilder(firstKmerAdjacency.toString());\n+            int maxObservations = firstKmerAdjacency.getNObservations();\n+            KmerAdjacency lastKmerAdjacency = firstKmerAdjacency;\n+            for ( KmerAdjacency kmerAdjacency = firstKmerAdjacency.getSoleSuccessor();\n+                  kmerAdjacency != null;\n+                  kmerAdjacency = kmerAdjacency.getSoleSuccessor() ) {\n+                // if we've gone around a circle, or if we're branching backwards, or if we hit a palindrome u-turn\n+                if ( firstKmerAdjacency == kmerAdjacency ||\n+                        kmerAdjacency.getPredecessorCount() != 1 ||\n+                        kmerAdjacency == lastKmerAdjacency.rc() ) {\n+                    break;\n+                }\n+                sb.append(\"ACGT\".charAt(kmerAdjacency.getFinalCall()));\n+                maxObservations = Math.max(maxObservations, kmerAdjacency.getNObservations());\n+                lastKmerAdjacency = kmerAdjacency;\n+            }\n+            this.sequence = sb.toString();\n+            this.maxObservations = maxObservations;\n+            this.firstKmer = firstKmerAdjacency;\n+            this.lastKmer = lastKmerAdjacency;\n+            this.predecessors = new ArrayList<>(firstKmer.getPredecessorCount());\n+            this.successors = new ArrayList<>(lastKmer.getSuccessorCount());\n+            this.rc = new ContigRCImpl(this);\n+\n+            int offset = 0;\n+            for ( KmerAdjacency kmerAdjacency = firstKmerAdjacency;\n+                  kmerAdjacency != lastKmerAdjacency;\n+                  kmerAdjacency = kmerAdjacency.getSoleSuccessor() ) {\n+                kmerAdjacency.setContigOffset(this, offset++);\n+            }\n+            lastKmerAdjacency.setContigOffset(this, offset);\n+        }\n+\n+        // create a new contig by joining two contigs\n+        public ContigImpl( final int id, final Contig predecessor, final Contig successor ) {\n+            if ( predecessor == successor || predecessor == successor.rc() ) {\n+                throw new GATKException(\"can't self-join\");\n+            }\n+            this.id = id;\n+            final StringBuilder sb = new StringBuilder(predecessor.getSequence());\n+            final CharSequence successorSequence = successor.getSequence();\n+            sb.append(successorSequence.subSequence(Kmer.KSIZE - 1, successorSequence.length()));\n+            this.sequence = sb.toString();\n+            this.maxObservations =\n+                    Math.max(predecessor.getMaxObservations(), successor.getMaxObservations());\n+            this.firstKmer = predecessor.getFirstKmer();\n+            this.lastKmer = successor.getLastKmer();\n+            this.predecessors = new ArrayList<>(predecessor.getPredecessors().size());\n+            this.successors = new ArrayList<>(successor.getSuccessors().size());\n+            this.rc = new ContigRCImpl(this);\n+\n+            // fix predecessor linkages to point to new contig\n+            for ( final Contig predPredecessor : predecessor.getPredecessors() ) {\n+                if ( predPredecessor == successor ) {\n+                    predecessors.add(this);\n+                } else if ( predPredecessor == predecessor.rc() ) {\n+                    predecessors.add(rc);\n+                } else {\n+                    predecessors.add(predPredecessor);\n+                    final List<Contig> successors = predPredecessor.getSuccessors();\n+                    successors.set(successors.indexOf(predecessor), this);\n+                }\n+            }\n+\n+            // fix successor linkages to point to new contig\n+            for ( final Contig succSuccessor : successor.getSuccessors() ) {\n+                if ( succSuccessor == predecessor ) {\n+                    successors.add(this);\n+                } else if ( succSuccessor == successor.rc() ) {\n+                    successors.add(rc);\n+                } else {\n+                    successors.add(succSuccessor);\n+                    final List<Contig> predecessors = succSuccessor.getPredecessors();\n+                    predecessors.set(predecessors.indexOf(successor), this);\n+                }\n+            }\n+        }\n+\n+        @Override public int getId() { return id; }\n+        @Override public CharSequence getSequence() { return sequence; }\n+        @Override public int getMaxObservations() { return maxObservations; }\n+        @Override public KmerAdjacency getFirstKmer() { return firstKmer; }\n+        @Override public KmerAdjacency getLastKmer() { return lastKmer; }\n+        @Override public List<Contig> getPredecessors() { return predecessors; }\n+        @Override public List<Contig> getSuccessors() { return successors; }\n+        @Override public int getComponentId() { return componentId; }\n+        public void setComponentId( final int id ) { this.componentId = id; }\n+        @Override public int size() { return sequence.length(); }\n+        @Override public Contig rc() { return rc; }\n+        @Override public boolean isCyclic() { return cyclic; }\n+        @Override public void setCyclic( final boolean cyclic ) { this.cyclic = cyclic; }\n+        @Override public boolean isCut() { return cut; }\n+        @Override public void setCut( final boolean cut ) { this.cut = cut; }\n+        @Override public boolean isCanonical() { return true; }\n+        @Override public ContigImpl canonical() { return this; }\n+        @Override public String toString() { return \"c\" + id; }\n+    }\n+\n+    /**\n+     * Implementation of Contig for the reverse-complement of some other Contig.\n+     * Which one is the \"real\" Contig, and which is the \"RC\" is completely arbitrary, since there\n+     * is no notion of canonical for Contigs.\n+     **/\n+    public static final class ContigRCImpl implements Contig {\n+        private final CharSequence sequence;\n+        private final List<Contig> predecessors;\n+        private final List<Contig> successors;\n+        private final ContigImpl rc;\n+\n+        public ContigRCImpl( final ContigImpl contig ) {\n+            this.sequence = new SequenceRC(contig.getSequence());\n+            this.predecessors = new ContigListRC(contig.getSuccessors());\n+            this.successors = new ContigListRC(contig.getPredecessors());\n+            this.rc = contig;\n+        }\n+\n+        @Override public int getId() { return ~rc.getId(); }\n+        @Override public CharSequence getSequence() { return sequence; }\n+        @Override public int getMaxObservations() { return rc.getMaxObservations(); }\n+        @Override public KmerAdjacency getFirstKmer() { return rc.getLastKmer().rc(); }\n+        @Override public KmerAdjacency getLastKmer() { return rc.getFirstKmer().rc(); }\n+        @Override public List<Contig> getPredecessors() { return predecessors; }\n+        @Override public List<Contig> getSuccessors() { return successors; }\n+        @Override public int getComponentId() { return rc.getComponentId(); }\n+        @Override public int size() { return sequence.length(); }\n+        @Override public Contig rc() { return rc; }\n+        @Override public boolean isCyclic() { return rc.isCyclic(); }\n+        @Override public void setCyclic( final boolean cyclic ) { rc.setCyclic(cyclic); }\n+        @Override public boolean isCut() { return rc.isCut(); }\n+        @Override public void setCut( final boolean cut ) { rc.setCut(cut); }\n+        @Override public boolean isCanonical() { return false; }\n+        @Override public ContigImpl canonical() { return rc; }\n+        @Override public String toString() { return rc.toString() + \"RC\"; }\n+    }\n+\n+    /** A CharSequence that is a view of the reverse-complement of another sequence. **/\n+    public static final class SequenceRC implements CharSequence, Comparable<CharSequence> {\n+        private final int lenLess1;\n+        private final CharSequence sequence;\n+\n+        public SequenceRC( final CharSequence sequence ) {\n+            this.lenLess1 = sequence.length() - 1;\n+            this.sequence = sequence;\n+        }\n+\n+        @Override public int length() { return sequence.length(); }\n+        @Override public char charAt( final int index ) {\n+            final char result;\n+            switch ( Character.toUpperCase(sequence.charAt(lenLess1 - index)) ) {\n+                case 'A': result = 'T'; break;\n+                case 'C': result = 'G'; break;\n+                case 'G': result = 'C'; break;\n+                case 'T': result = 'A'; break;\n+                default: result = 'N'; break;\n+            }\n+            return result;\n+        }\n+        @Override public CharSequence subSequence( final int start, final int end ) {\n+            return new StringBuilder(end - start).append(this, start, end).toString();\n+        }\n+        @Override public String toString() { return new StringBuilder(this).toString(); }\n+\n+        @Override public int compareTo( final CharSequence charSequence ) {\n+            final int len1 = length();\n+            final int len2 = charSequence.length();\n+            final int cmpLen = Math.min(len1, len2);\n+            for ( int idx = 0; idx != cmpLen; ++idx ) {\n+                final char char1 = charAt(idx);\n+                final char char2 = Character.toUpperCase(charSequence.charAt(idx));\n+                if ( char1 > char2 ) return 1;\n+                if ( char1 < char2 ) return -1;\n+            }\n+            return Integer.compare(len1, len2);\n+        }\n+    }\n+\n+    /** A list of Contigs that presents a reverse-complemented view of a List of Contigs. **/\n+    public static final class ContigListRC extends AbstractList<Contig> {\n+        private final List<Contig> contigList;\n+\n+        public ContigListRC( final List<Contig> contigList ) {\n+            this.contigList = contigList;\n+        }\n+\n+        @Override public Contig get( final int index ) {\n+            return contigList.get(reflectIndex(index)).rc();\n+        }\n+        @Override public int size() { return contigList.size(); }\n+        @Override public Contig set( final int index, final Contig contig ) {\n+            return contigList.set(reflectIndex(index), contig.rc()).rc();\n+        }\n+        @Override public void add( final int index, final Contig contig ) {\n+            contigList.add(reflectIndex(index), contig.rc());\n+        }\n+        @Override public Contig remove( final int index ) {\n+            return contigList.remove(reflectIndex(index)).rc();\n+        }\n+\n+        private int reflectIndex( final int index ) { return size() - 1 - index; }\n+    }\n+\n+    /** A single-Contig portion of a path across the assembly graph. **/\n+    public interface PathPart {\n+        Contig getContig(); // will be null for PathParts that depart from the graph (PathPartGap)\n+        CharSequence getSequence(); // will be null for PathParts on the graph (PathPartContig)\n+        void extend( final char call );\n+        int getStart();\n+        int getStop();\n+        boolean isGap();\n+        int getLength();\n+        PathPart rc();\n+        char getFirstCall();\n+        char getLastCall();\n+        default boolean startsAtBeginning() { return getStart() == 0; }\n+        default boolean stopsAtEnd() { return getStop() + Kmer.KSIZE - 1 == getContig().size(); }\n+    }\n+\n+    /** A part of a path that isn't present in the graph. **/\n+    public static final class PathPartGap implements PathPart {\n+        private final StringBuilder sequence = new StringBuilder();\n+\n+        public PathPartGap( final KmerAdjacency kmer ) { sequence.append(kmer.toString()); }\n+        private PathPartGap( final CharSequence sequence ) { this.sequence.append(sequence); }\n+\n+        @Override public Contig getContig() { return null; }\n+        @Override public CharSequence getSequence() { return sequence.toString(); }\n+        @Override public void extend( final char call ) { sequence.append(call); }\n+        @Override public int getStart() { return 0; }\n+        @Override public int getStop() { return sequence.length(); }\n+        @Override public boolean isGap() { return true; }\n+        @Override public int getLength() { return sequence.length() - Kmer.KSIZE + 1; }\n+        @Override public PathPart rc() { return new PathPartGap(new SequenceRC(sequence)); }\n+        @Override public char getFirstCall() { return sequence.charAt(Kmer.KSIZE - 1); }\n+        @Override public char getLastCall() {\n+            return sequence.charAt(sequence.length() - Kmer.KSIZE + 1);\n+        }\n+    }\n+\n+    /** A part of a path that is present as a sub-sequence of some Contig. **/\n+    public static final class PathPartContig implements PathPart {\n+        private final Contig contig;\n+        private final int start;\n+        private int stop;\n+\n+        public PathPartContig( final Contig contig, final int start ) {\n+            this(contig, start, start+1);\n+        }\n+        public PathPartContig( final Contig contig, final int start, final int stop ) {\n+            this.contig = contig;\n+            this.start = start;\n+            this.stop = stop;\n+        }\n+\n+        @Override public Contig getContig() { return contig; }\n+        @Override public String getSequence() { return null; }\n+        @Override public void extend( final char call ) { stop += 1; }\n+        @Override public int getStart() { return start; }\n+        @Override public int getStop() { return stop; }\n+        @Override public boolean isGap() { return false; }\n+        @Override public int getLength() { return stop - start; }\n+        @Override public PathPart rc() {\n+            final int revBase = contig.size() - Kmer.KSIZE + 1;\n+            return new PathPartContig(contig.rc(), revBase - stop, revBase - start);\n+        }\n+        @Override public char getFirstCall() {\n+            return getContig().getSequence().charAt(start + Kmer.KSIZE - 1);\n+        }\n+        @Override public char getLastCall() { return getContig().getSequence().charAt(stop - 1); }\n+    }\n+\n+    /** A path through the assembly graph for something (probably a read). **/\n+    public static final class Path {\n+        private final List<PathPart> parts;\n+\n+        public Path( final byte[] calls,\n+                     final KmerSet<KmerAdjacency> kmerAdjacencySet ) {\n+            parts = new ArrayList<>();\n+            long kVal = 0;\n+            int count = 0;\n+            PathPart currentPathPart = null;\n+            for ( int idx = 0; idx != calls.length; ++idx ) {\n+                final char call = (char)calls[idx];\n+                kVal <<= 2;\n+                switch ( call ) {\n+                    case 'C': case 'c': kVal += 1; break;\n+                    case 'G': case 'g': kVal += 2; break;\n+                    case 'T': case 't': kVal += 3; break;\n+                }\n+                if ( ++count >= Kmer.KSIZE ) {\n+                    final KmerAdjacency kmer = KmerAdjacencyImpl.find(kVal, kmerAdjacencySet);\n+                    // if we fail to look up the kmer\n+                    if ( kmer == null ) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e2201c1ef4f8ba71f17e169f07756cfe2f1ecb49"}, "originalPosition": 2012}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzc3Njk3MTE3OnYy", "diffSide": "RIGHT", "path": "src/main/java/org/broadinstitute/hellbender/tools/LocalAssembler.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMy0xOVQyMDoxMjo0NVrOI6P6Qg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNC0xM1QxOToyMjoyOFrOJIVNqQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5Nzk0ODk5NA==", "bodyText": "This is the transition out of a gap back to a contig, right? Otherwise we wouldn't have found our kmer in the set?", "url": "https://github.com/broadinstitute/gatk/pull/6989#discussion_r597948994", "createdAt": "2021-03-19T20:12:45Z", "author": {"login": "cwhelan"}, "path": "src/main/java/org/broadinstitute/hellbender/tools/LocalAssembler.java", "diffHunk": "@@ -0,0 +1,2306 @@\n+package org.broadinstitute.hellbender.tools;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import htsjdk.samtools.Cigar;\n+import htsjdk.samtools.CigarElement;\n+import htsjdk.samtools.CigarOperator;\n+import htsjdk.samtools.SAMUtils;\n+import org.broadinstitute.barclay.argparser.Argument;\n+import org.broadinstitute.barclay.argparser.BetaFeature;\n+import org.broadinstitute.barclay.argparser.CommandLineProgramProperties;\n+import org.broadinstitute.barclay.help.DocumentedFeature;\n+import org.broadinstitute.hellbender.cmdline.StandardArgumentDefinitions;\n+import org.broadinstitute.hellbender.cmdline.programgroups.CoverageAnalysisProgramGroup;\n+import org.broadinstitute.hellbender.exceptions.GATKException;\n+import org.broadinstitute.hellbender.tools.walkers.PairWalker;\n+import org.broadinstitute.hellbender.utils.SimpleInterval;\n+import org.broadinstitute.hellbender.utils.collections.HopscotchSet;\n+import org.broadinstitute.hellbender.utils.gcs.BucketUtils;\n+import org.broadinstitute.hellbender.utils.read.GATKRead;\n+\n+import java.io.BufferedWriter;\n+import java.io.FileWriter;\n+import java.io.IOException;\n+import java.io.OutputStreamWriter;\n+import java.util.*;\n+import java.util.zip.GZIPOutputStream;\n+\n+@DocumentedFeature\n+@CommandLineProgramProperties(\n+        summary = \"experiment\",\n+        oneLineSummary = \"experiment\",\n+        usageExample = \"gatk LocalAssembler\",\n+        programGroup = CoverageAnalysisProgramGroup.class\n+)\n+@BetaFeature\n+public class LocalAssembler extends PairWalker {\n+    public static final byte QMIN = 25;\n+    public static final int MIN_THIN_OBS = 4;\n+    public static final int MIN_GAPFILL_COUNT = 3;\n+    public static final int TOO_MANY_TRAVERSALS = 100000;\n+    public static final int TOO_MANY_SCAFFOLDS = 50000;\n+    public static final int MIN_SV_SIZE = 50;\n+\n+    @Argument(fullName=StandardArgumentDefinitions.OUTPUT_LONG_NAME,\n+            shortName=StandardArgumentDefinitions.OUTPUT_SHORT_NAME,\n+            doc=\"Write outputs to this file name prefix\", optional = true)\n+    public static String output;\n+\n+    @Argument(fullName=\"assembly-name\", doc=\"name of assembly used as a prefix for traversal names\")\n+    public static String assemblyName;\n+\n+    private final List<GATKRead> reads = new ArrayList<>();\n+\n+    @Override public boolean requiresIntervals() { return true; }\n+\n+    @Override public void apply( final GATKRead read, final GATKRead mate ) {\n+        trimOverruns(read, mate);\n+        reads.add(read);\n+        reads.add(mate);\n+    }\n+\n+    @Override public void applyUnpaired( final GATKRead read ) {\n+        reads.add(read);\n+    }\n+\n+    @Override public Object onTraversalSuccess() {\n+        super.onTraversalSuccess(); // flush any incomplete pairs\n+\n+        final int regionSize = getTraversalIntervals().stream().mapToInt(SimpleInterval::size).sum();\n+        final KmerSet<KmerAdjacency> kmerAdjacencySet = new KmerSet<>(10 * regionSize);\n+        kmerizeReads(reads, kmerAdjacencySet);\n+        List<ContigImpl> contigs = buildContigs(kmerAdjacencySet);\n+        connectContigs(contigs);\n+\n+        removeThinContigs(contigs, kmerAdjacencySet);\n+        weldPipes(contigs);\n+        markComponents(contigs);\n+\n+        if ( fillGaps(kmerAdjacencySet, reads) ) {\n+            contigs = buildContigs(kmerAdjacencySet);\n+            connectContigs(contigs);\n+            removeThinContigs(contigs, kmerAdjacencySet);\n+            weldPipes(contigs);\n+            markComponents(contigs);\n+        }\n+\n+        markCycles(contigs);\n+\n+        final String outputFilePrefix = output != null ? output : assemblyName;\n+        final List<Path> readPaths = pathReads(kmerAdjacencySet, reads);\n+        final Map<Contig,List<TransitPairCount>> contigTransitsMap =\n+                collectTransitPairCounts(contigs, readPaths);\n+        final String traversalsFilename = outputFilePrefix + \".traversals.fa.gz\";\n+        try {\n+            final List<Traversal> allTraversals =\n+                    new ArrayList<>(traverseAllPaths(contigs, readPaths, contigTransitsMap));\n+            writeTraversals(allTraversals, traversalsFilename);\n+            try {\n+                final String scaffoldsFileName = outputFilePrefix + \".scaffolds.fa.gz\";\n+                writeTraversals(createScaffolds(allTraversals), scaffoldsFileName);\n+            } catch ( final AssemblyTooComplexException x ) {\n+                logger.warn(\"Assembly too complex for scaffolding.\");\n+            }\n+        } catch ( final AssemblyTooComplexException x ) {\n+            logger.warn(\"Assembly too complex.  Writing contigs as traversals in \" +\n+                    traversalsFilename + \".\");\n+            final Collection<Traversal> contigTraversals = new ArrayList<>(contigs.size());\n+            for ( final Contig contig : contigs ) {\n+                contigTraversals.add(new Traversal(Collections.singletonList(contig)));\n+            }\n+            writeTraversals(contigTraversals, traversalsFilename);\n+        }\n+\n+        contigs.sort(Comparator.comparingInt(ContigImpl::getId));\n+        writeDOT(contigs, outputFilePrefix + \".assembly.dot\");\n+        writeContigs(contigs, outputFilePrefix + \".contigs.txt.gz\");\n+        writePaths(readPaths, outputFilePrefix + \".paths.txt.gz\");\n+        writeReads(reads, outputFilePrefix + \".reads.fastq.gz\");\n+        return null;\n+    }\n+\n+    /** trim read pairs of base calls that have gone past the end of a short fragment */\n+    private void trimOverruns( final GATKRead read, final GATKRead mate ) {\n+        // if both mapped and they're on different strands\n+        if ( !read.isUnmapped() && !mate.isUnmapped() &&\n+                read.isReverseStrand() != mate.isReverseStrand() ) {\n+            // and both start within 1 base on the ref\n+            if ( Math.abs(read.getStart() - read.getMateStart()) <= 1 ) {\n+                // and both end within 1 base\n+                final int readRefLen = read.getCigar().getReferenceLength();\n+                final int mateRefLen = mate.getCigar().getReferenceLength();\n+                if ( Math.abs(readRefLen - mateRefLen) <= 1 ) {\n+                    if ( mate.isReverseStrand() ) {\n+                        trimClips(read, mate);\n+                    } else {\n+                        trimClips(mate, read);\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    private void trimClips( final GATKRead fwd, final GATKRead rev ) {\n+        final List<CigarElement> fwdElements = fwd.getCigarElements();\n+        final List<CigarElement> revElements = rev.getCigarElements();\n+        final int lastElementIdx = fwdElements.size() - 1;\n+        final CigarElement fwdLastElement = fwdElements.get(lastElementIdx);\n+        final CigarElement revFirstElement = revElements.get(0);\n+        if ( fwdLastElement.getOperator() == CigarOperator.S &&\n+                revFirstElement.getOperator() == CigarOperator.S ) {\n+            final byte[] fwdBases = fwd.getBasesNoCopy();\n+            final int lastElementLen = fwdLastElement.getLength();\n+            fwd.setBases(Arrays.copyOfRange(fwdBases, 0, fwdBases.length - lastElementLen));\n+            final byte[] fwdQuals = fwd.getBaseQualitiesNoCopy();\n+            if ( fwdQuals.length > 0 ) {\n+                final int qualsLen = fwdQuals.length - lastElementLen;\n+                fwd.setBaseQualities(Arrays.copyOfRange(fwdQuals, 0, qualsLen));\n+            }\n+            final List<CigarElement> newFwdElements = new ArrayList<>(fwdElements);\n+            newFwdElements.set(lastElementIdx, new CigarElement(lastElementLen, CigarOperator.H));\n+            fwd.setCigar(new Cigar(newFwdElements));\n+\n+            final byte[] revBases = rev.getBasesNoCopy();\n+            final int firstElementLen = revFirstElement.getLength();\n+            rev.setBases(Arrays.copyOfRange(revBases, firstElementLen, revBases.length));\n+            final byte[] revQuals = rev.getBaseQualitiesNoCopy();\n+            if ( revQuals.length > 0 ) {\n+                rev.setBaseQualities(Arrays.copyOfRange(revQuals, firstElementLen, revQuals.length));\n+            }\n+            final List<CigarElement> newRevElements = new ArrayList<>(revElements);\n+            newRevElements.set(0, new CigarElement(firstElementLen, CigarOperator.H));\n+            rev.setCigar(new Cigar(newRevElements));\n+        }\n+    }\n+\n+    @VisibleForTesting\n+    static void kmerizeReads( final List<GATKRead> reads,\n+                              final KmerSet<KmerAdjacency> kmerAdjacencySet ) {\n+        for ( final GATKRead read : reads ) {\n+            final byte[] calls = read.getBasesNoCopy();\n+            final byte[] quals = read.getBaseQualitiesNoCopy();\n+            KmerAdjacency.kmerize(calls, quals, QMIN, kmerAdjacencySet);\n+        }\n+    }\n+\n+    /** gather unbranched strings of kmers into contigs **/\n+    @VisibleForTesting\n+    static List<ContigImpl> buildContigs( final KmerSet<KmerAdjacency> kmerAdjacencySet ) {\n+        // gather strings of kmers that have a single predecessor and single successor into contigs\n+        final List<ContigImpl> contigs = new ArrayList<>();\n+        int nContigs = 0;\n+        for ( final KmerAdjacency kmerAdjacency : kmerAdjacencySet ) {\n+            if ( kmerAdjacency.getContig() == null ) {\n+                ContigImpl contig = null;\n+                final KmerAdjacency predecessor = kmerAdjacency.getSolePredecessor();\n+                if ( predecessor == null ||\n+                        predecessor.getSuccessorCount() > 1 ||\n+                        predecessor == kmerAdjacency.rc() ) {\n+                    contig = new ContigImpl(++nContigs, kmerAdjacency);\n+                } else {\n+                    final KmerAdjacency successor = kmerAdjacency.getSoleSuccessor();\n+                    if ( successor == null ||\n+                            successor.getPredecessorCount() > 1 ||\n+                            successor == kmerAdjacency.rc() ) {\n+                        contig = new ContigImpl(++nContigs, kmerAdjacency.rc());\n+                    }\n+                }\n+                if ( contig != null ) {\n+                    contigs.add(contig);\n+                }\n+            }\n+        }\n+\n+        // if there are smooth circles like a plasmid, gather them together as a contig, too\n+        for ( final KmerAdjacency kmerAdjacency : kmerAdjacencySet ) {\n+            if ( kmerAdjacency.getContig() == null ) {\n+                contigs.add(new ContigImpl(++nContigs, kmerAdjacency));\n+            }\n+        }\n+\n+        return contigs;\n+    }\n+\n+    /** connect contigs when the final kmer of one contig is adjacent to the inital contig of another **/\n+    @VisibleForTesting\n+    static void connectContigs( final List<ContigImpl> contigs ) {\n+        final int nContigs = contigs.size();\n+        final KmerSet<ContigEndKmer> contigEnds = new KmerSet<>(2*nContigs);\n+        for ( int contigId = 0; contigId != nContigs; ++contigId ) {\n+            final ContigImpl contig = contigs.get(contigId);\n+            final KmerAdjacency fwdKmer = contig.getFirstKmer();\n+            final KmerAdjacency revKmer = contig.getLastKmer().rc();\n+            if ( fwdKmer == revKmer ) {\n+                contigEnds.add(new ContigEndKmer(fwdKmer.getKVal(), contig, ContigOrientation.BOTH));\n+            } else {\n+                contigEnds.add(new ContigEndKmer(fwdKmer.getKVal(), contig, ContigOrientation.FWD));\n+                contigEnds.add(new ContigEndKmer(revKmer.getKVal(), contig, ContigOrientation.REV));\n+            }\n+        }\n+\n+        for ( int contigId = 0; contigId != nContigs; ++contigId ) {\n+            final Contig contig = contigs.get(contigId);\n+\n+            final KmerAdjacency start = contig.getFirstKmer();\n+            final int predecessorCount = start.getPredecessorCount();\n+            if ( predecessorCount > 0 ) {\n+                final List<Contig> predecessors = contig.getPredecessors();\n+                final int mask = start.getPredecessorMask();\n+                for ( int call = 0; call != 4; ++call ) {\n+                    if ( (mask & (1 << call)) != 0 ) {\n+                        final long kVal =\n+                                KmerAdjacency.reverseComplement(start.getPredecessorVal(call));\n+                        final ContigEndKmer contigEndKmer = contigEnds.find(new Kmer(kVal));\n+                        if ( contigEndKmer == null ) {\n+                            throw new GATKException(\"missing contig end kmer\");\n+                        }\n+                        switch ( contigEndKmer.getContigOrientation() ) {\n+                            case FWD:\n+                                predecessors.add(contigEndKmer.getContig().rc());\n+                                break;\n+                            case REV:\n+                                predecessors.add(contigEndKmer.getContig());\n+                                break;\n+                            case BOTH:\n+                                predecessors.add(contigEndKmer.getContig());\n+                                predecessors.add(contigEndKmer.getContig().rc());\n+                                break;\n+                        }\n+                    }\n+                }\n+            }\n+\n+            final KmerAdjacency end = contig.getLastKmer();\n+            final int successorCount = end.getSuccessorCount();\n+            if ( successorCount > 0 ) {\n+                final List<Contig> successors = contig.getSuccessors();\n+                final int mask = end.getSuccessorMask();\n+                for ( int call = 0; call != 4; ++call ) {\n+                    if ( (mask & (1 << call)) != 0 ) {\n+                        final long kVal = end.getSuccessorVal(call);\n+                        final ContigEndKmer contigEndKmer = contigEnds.find(new Kmer(kVal));\n+                        if ( contigEndKmer == null ) {\n+                            throw new GATKException(\"missing contig end kmer\");\n+                        }\n+                        switch ( contigEndKmer.getContigOrientation() ) {\n+                            case FWD:\n+                                successors.add(contigEndKmer.getContig());\n+                                break;\n+                            case REV:\n+                                successors.add(contigEndKmer.getContig().rc());\n+                                break;\n+                            case BOTH:\n+                                successors.add(contigEndKmer.getContig());\n+                                successors.add(contigEndKmer.getContig().rc());\n+                                break;\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    /** remove contigs that have little evidence **/\n+    @VisibleForTesting\n+    static void removeThinContigs( final List<ContigImpl> contigs,\n+                                           final KmerSet<KmerAdjacency> kmerAdjacencySet ) {\n+        contigs.sort(Comparator.comparingInt(ContigImpl::getMaxObservations));\n+        boolean contigRemoved;\n+        do {\n+            // figure out which contigs are cut points\n+            // i.e., those contigs which, if removed, would result in a graph with more connected components\n+            final int nContigs = contigs.size();\n+            final Map<Contig, CutData> cutDataMap = new HashMap<>(nContigs * 3);\n+\n+            for ( final ContigImpl contig : contigs ) {\n+                if ( cutDataMap.containsKey(contig) ) {\n+                    continue;\n+                }\n+\n+                cutDataMap.put(contig, new CutData());\n+                int children = 0;\n+                for ( final Contig nextContig : contig.getSuccessors() ) {\n+                    if ( !cutDataMap.containsKey(nextContig) ) {\n+                        findCuts(nextContig, contig, cutDataMap);\n+                        children += 1;\n+                    }\n+                }\n+                for ( final Contig nextContig : contig.getPredecessors() ) {\n+                    if ( !cutDataMap.containsKey(nextContig) ) {\n+                        findCuts(nextContig, contig, cutDataMap);\n+                        children += 1;\n+                    }\n+                }\n+                if ( children >= 2 ) {\n+                    contig.setCut(true);\n+                }\n+            }\n+\n+            // remove poorly attested (low max observations) contigs, unless they are cut points\n+            contigRemoved = false;\n+            final Iterator<ContigImpl> itr = contigs.iterator();\n+            while ( itr.hasNext() ) {\n+                final Contig contig = itr.next();\n+                if ( contig.getMaxObservations() < MIN_THIN_OBS && !contig.isCut() ) {\n+                    unlinkContig(contig, kmerAdjacencySet);\n+                    itr.remove();\n+                    contigRemoved = true;\n+                    break;\n+                }\n+            }\n+        } while ( contigRemoved );\n+        contigs.sort(Comparator.comparingInt(ContigImpl::getId));\n+    }\n+\n+    private static CutData findCuts( final Contig contig,\n+                                     final Contig parent,\n+                                     final Map<Contig, CutData> cutDataMap ) {\n+        final CutData cutData = new CutData();\n+        cutDataMap.put(contig, cutData);\n+        for ( final Contig nextContig : contig.getSuccessors() ) {\n+            if ( nextContig == parent ) {\n+                continue;\n+            }\n+            CutData nextCutData = cutDataMap.get(nextContig);\n+            if ( nextCutData != null ) {\n+                cutData.minVisitNum = Math.min(cutData.minVisitNum, nextCutData.visitNum);\n+            } else {\n+                nextCutData = findCuts(nextContig, contig, cutDataMap);\n+                cutData.minVisitNum = Math.min(cutData.minVisitNum, nextCutData.minVisitNum);\n+                if ( nextCutData.minVisitNum >= cutData.visitNum ) {\n+                    contig.setCut(true);\n+                }\n+            }\n+        }\n+        for ( final Contig nextContig : contig.getPredecessors() ) {\n+            if ( nextContig == parent ) {\n+                continue;\n+            }\n+            CutData nextCutData = cutDataMap.get(nextContig);\n+            if ( nextCutData != null ) {\n+                cutData.minVisitNum = Math.min(cutData.minVisitNum, nextCutData.visitNum);\n+            } else {\n+                nextCutData = findCuts(nextContig, contig, cutDataMap);\n+                cutData.minVisitNum = Math.min(cutData.minVisitNum, nextCutData.minVisitNum);\n+                if ( nextCutData.minVisitNum >= cutData.visitNum ) {\n+                    contig.setCut(true);\n+                }\n+            }\n+        }\n+        return cutData;\n+    }\n+\n+    @VisibleForTesting\n+    static void unlinkContig( final Contig contig,\n+                                      final KmerSet<KmerAdjacency> kmerAdjacencySet ) {\n+        final KmerAdjacency firstKmer = contig.getFirstKmer();\n+        final int firstKmerFinalCall = firstKmer.getFinalCall();\n+        for ( final Contig predecessor : contig.getPredecessors() ) {\n+            if ( predecessor != contig && predecessor != contig.rc() ) {\n+                predecessor.getLastKmer().removeSuccessor(firstKmerFinalCall, kmerAdjacencySet);\n+                if ( !predecessor.getSuccessors().remove(contig) ) {\n+                    throw new GATKException(\"failed to find predecessor link\");\n+                }\n+            }\n+        }\n+\n+        final KmerAdjacency lastKmer = contig.getLastKmer();\n+        final int lastKmerInitialCall = lastKmer.getInitialCall();\n+        for ( final Contig successor : contig.getSuccessors() ) {\n+            if ( successor != contig && successor != contig.rc() ) {\n+                successor.getFirstKmer().removePredecessor(lastKmerInitialCall, kmerAdjacencySet);\n+                if ( !successor.getPredecessors().remove(contig) ) {\n+                    throw new GATKException(\"failed to find successor link\");\n+                }\n+            }\n+        }\n+\n+        KmerAdjacency nextKmer = firstKmer;\n+        KmerAdjacency kmer;\n+        do {\n+            kmer = nextKmer;\n+            nextKmer = kmer.getSoleSuccessor();\n+            kmerAdjacencySet.remove(kmer.canonical());\n+        } while ( kmer != lastKmer );\n+    }\n+\n+    private static void updateKmerContig( final KmerAdjacency firstKmer,\n+                                          final KmerAdjacency lastKmer,\n+                                          final Contig contig ) {\n+        int offset = 0;\n+        for ( KmerAdjacency kmer = firstKmer; kmer != lastKmer; kmer = kmer.getSoleSuccessor() ) {\n+            if ( kmer == null ) {\n+                throw new GATKException(\"contig does not have a flat pipeline of kmers\");\n+            }\n+            kmer.clearContig();\n+            kmer.setContigOffset(contig, offset++);\n+        }\n+        lastKmer.clearContig();\n+        lastKmer.setContigOffset(contig, offset);\n+        if ( offset + Kmer.KSIZE != contig.size() ) {\n+            throw new GATKException(\"kmer chain length does not equal contig size\");\n+        }\n+    }\n+\n+    /** replace adjacent contigs without branches with a single, larger contig **/\n+    @VisibleForTesting\n+    static void weldPipes( final List<ContigImpl> contigs ) {\n+        for ( int contigIdx = 0; contigIdx != contigs.size(); ++contigIdx ) {\n+            final ContigImpl contig = contigs.get(contigIdx);\n+            if ( contig.getSuccessors().size() == 1 ) {\n+                final Contig successor = contig.getSuccessors().get(0);\n+                if ( successor != contig && successor != contig.rc() &&\n+                        successor.getPredecessors().size() == 1 ) {\n+                    contigs.set(contigIdx, join(contig.getId(), contig, successor));\n+                    if ( !contigs.remove(successor.canonical()) ) {\n+                        throw new GATKException(\"successor linkage is messed up\");\n+                    }\n+                    contigIdx -= 1; // reconsider the new contig -- there might be more joining possible\n+                    continue;\n+                }\n+            }\n+            if ( contig.getPredecessors().size() == 1 ) {\n+                final Contig predecessor = contig.getPredecessors().get(0);\n+                if ( predecessor != contig && predecessor != contig.rc() &&\n+                        predecessor.getSuccessors().size() == 1 ) {\n+                    contigs.set(contigIdx, join(contig.getId(), predecessor, contig));\n+                    if ( !contigs.remove(predecessor.canonical()) ) {\n+                        throw new GATKException(\"predecessor linkage is messed up\");\n+                    }\n+                    contigIdx -= 1; // reconsider\n+                }\n+            }\n+        }\n+    }\n+\n+    private static ContigImpl join( final int id, final Contig predecessor, final Contig successor ) {\n+        if ( !checkOverlap(predecessor.getSequence(), successor.getSequence()) ) {\n+                throw new GATKException(\"sequences can't be joined\");\n+        }\n+        final ContigImpl joinedContig = new ContigImpl(id, predecessor, successor);\n+        updateKmerContig(joinedContig.getFirstKmer(), joinedContig.getLastKmer(), joinedContig);\n+        return joinedContig;\n+    }\n+\n+    private static boolean checkOverlap( final CharSequence seq1, final CharSequence seq2 ) {\n+        final int seq1Len = seq1.length();\n+        final CharSequence seq1SubSeq = seq1.subSequence(seq1Len - Kmer.KSIZE + 1, seq1Len);\n+        final CharSequence seq2SubSeq = seq2.subSequence(0, Kmer.KSIZE - 1);\n+        return seq1SubSeq.equals(seq2SubSeq);\n+    }\n+\n+    /** set a unique componentId for every connected group of contigs **/\n+    @VisibleForTesting\n+    static int markComponents( final List<ContigImpl> contigs ) {\n+        for ( final ContigImpl contig : contigs ) {\n+            contig.setComponentId(0);\n+        }\n+\n+        int componentId = 0;\n+        for ( final ContigImpl contig : contigs ) {\n+            if ( contig.getComponentId() == 0 ) {\n+                contig.setComponentId(++componentId);\n+                markSuccessorComponents(contig);\n+                markSuccessorComponents(contig.rc());\n+            }\n+        }\n+        return componentId;\n+    }\n+\n+    private static void markSuccessorComponents( final Contig contig ) {\n+        final int componentId = contig.getComponentId();\n+        for ( final Contig successor : contig.getSuccessors() ) {\n+            if ( successor.getComponentId() == 0 ) {\n+                successor.canonical().setComponentId(componentId);\n+                markSuccessorComponents(successor);\n+                markSuccessorComponents(successor.rc());\n+            }\n+        }\n+    }\n+\n+    @VisibleForTesting\n+    static void markCycles( final List<ContigImpl> contigs ) {\n+        for ( final Contig contig : contigs ) {\n+            contig.setCyclic(false);\n+        }\n+\n+        final int nContigs = contigs.size();\n+        final Deque<Contig> deque = new ArrayDeque<>(nContigs);\n+        final Map<Contig, CutData> cutDataMap = new HashMap<>(nContigs * 3);\n+        for ( final Contig contig : contigs ) {\n+            if ( !cutDataMap.containsKey(contig) ) {\n+                markCyclesRecursion(contig, deque, cutDataMap);\n+            }\n+        }\n+    }\n+\n+    private static CutData markCyclesRecursion( final Contig contig,\n+                                                final Deque<Contig> deque,\n+                                                final Map<Contig, CutData> cutDataMap ) {\n+        final CutData cutData = new CutData();\n+        cutDataMap.put(contig, cutData);\n+        deque.addFirst(contig);\n+\n+        for ( final Contig successor : contig.getSuccessors() ) {\n+            final CutData successorCutData = cutDataMap.get(successor);\n+            if ( successorCutData == null ) {\n+                final int recursionVisitNum =\n+                        markCyclesRecursion(successor, deque, cutDataMap).minVisitNum;\n+                cutData.minVisitNum = Math.min(cutData.minVisitNum, recursionVisitNum);\n+            } else {\n+                cutData.minVisitNum = Math.min(cutData.minVisitNum, successorCutData.visitNum);\n+            }\n+        }\n+\n+        if ( cutData.visitNum == cutData.minVisitNum ) {\n+            Contig tig = deque.removeFirst();\n+            if ( tig == contig ) {\n+                cutDataMap.get(tig).visitNum = Integer.MAX_VALUE;\n+\n+                // single-vertex component -- cyclic only if self-referential\n+                if ( tig.getSuccessors().contains(tig) ) {\n+                    tig.setCyclic(true);\n+                }\n+            } else {\n+                while ( true ) {\n+                    // kill cross-links\n+                    cutDataMap.get(tig).visitNum = Integer.MAX_VALUE;\n+                    tig.setCyclic(true);\n+                    if ( tig == contig ) break;\n+                    tig = deque.removeFirst();\n+                }\n+            }\n+        }\n+        return cutData;\n+    }\n+\n+    @VisibleForTesting\n+    static boolean fillGaps( final KmerSet<KmerAdjacency> kmerAdjacencySet,\n+                             final List<GATKRead> reads ) {\n+        final Map<String, Integer> gapFillCounts = new HashMap<>();\n+        for ( final GATKRead read : reads ) {\n+            final Path path = new Path(read.getBasesNoCopy(), kmerAdjacencySet);\n+            final List<PathPart> parts = path.getParts();\n+            final int lastIdx = parts.size() - 1;\n+            for ( int idx = 1; idx < lastIdx; ++idx ) {\n+                final PathPart pathPart = parts.get(idx);\n+                if ( pathPart.isGap() ) {\n+                    final char prevCall = parts.get(idx - 1).getLastCall();\n+                    final char nextCall = parts.get(idx + 1).getFirstCall();\n+                    String gapFill = prevCall + pathPart.getSequence().toString() + nextCall;\n+                    final SequenceRC gapFillRC = new SequenceRC(gapFill);\n+                    if ( gapFillRC.compareTo(gapFill) < 0 ) {\n+                        gapFill = gapFillRC.toString();\n+                    }\n+                    gapFillCounts.merge(gapFill, 1, Integer::sum);\n+                }\n+            }\n+        }\n+\n+        boolean newKmers = false;\n+        for ( final Map.Entry<String, Integer> entry : gapFillCounts.entrySet() ) {\n+            final int nObservations = entry.getValue();\n+            if ( nObservations >= MIN_GAPFILL_COUNT ) {\n+                KmerAdjacency.kmerize(entry.getKey(), nObservations, kmerAdjacencySet);\n+                newKmers = true;\n+            }\n+        }\n+\n+        if ( newKmers ) {\n+            for ( final KmerAdjacency kmerAdjacency : kmerAdjacencySet ) {\n+                kmerAdjacency.clearContig();\n+            }\n+        }\n+        return newKmers;\n+    }\n+\n+    @VisibleForTesting\n+    static List<Path> pathReads( final KmerSet<KmerAdjacency> kmerAdjacencySet,\n+                          final List<GATKRead> reads ) {\n+        final List<Path> readPaths = new ArrayList<>(reads.size());\n+        for ( final GATKRead read : reads ) {\n+            readPaths.add(new Path(read.getBasesNoCopy(), kmerAdjacencySet));\n+        }\n+        return readPaths;\n+    }\n+\n+    @VisibleForTesting\n+    static Map<Contig,List<TransitPairCount>> collectTransitPairCounts(\n+            final List<ContigImpl> contigs,\n+            final List<Path> readPaths ) {\n+        final Map<Contig,List<TransitPairCount>> contigTransitsMap =\n+                new HashMap<>(3 * contigs.size());\n+        for ( final Path path : readPaths ) {\n+            final List<PathPart> parts = path.getParts();\n+            final int lastPart = parts.size() - 1;\n+            for ( int partIdx = 1; partIdx < lastPart; ++partIdx ) {\n+                final Contig prevContig = parts.get(partIdx - 1).getContig();\n+                if ( prevContig == null ) continue;\n+                final Contig curContig = parts.get(partIdx).getContig();\n+                if ( curContig == null ) {\n+                    partIdx += 1;\n+                    continue;\n+                }\n+                final Contig nextContig = parts.get(partIdx + 1).getContig();\n+                if ( nextContig == null ) {\n+                    partIdx += 2;\n+                    continue;\n+                }\n+                final TransitPairCount tpc = new TransitPairCount(prevContig, nextContig);\n+                final List<TransitPairCount> tpcList =\n+                        contigTransitsMap.computeIfAbsent(curContig, tig -> new ArrayList<>(4));\n+                final int idx = tpcList.indexOf(tpc);\n+                if ( idx != -1 ) {\n+                    tpcList.get(idx).observe();\n+                } else {\n+                    tpcList.add(tpc);\n+                    contigTransitsMap.computeIfAbsent(curContig.rc(), tig -> new ArrayList<>(4))\n+                            .add(tpc.getRC());\n+                }\n+            }\n+        }\n+        return contigTransitsMap;\n+    }\n+\n+    @VisibleForTesting\n+    static Set<Traversal> traverseAllPaths(\n+            final List<ContigImpl> contigs,\n+            final List<Path> readPaths,\n+            final Map<Contig, List<TransitPairCount>> contigTransitsMap ) {\n+        final Set<Traversal> traversalSet = new HashSet<>();\n+        final List<Contig> contigsList = new ArrayList<>();\n+        for ( final Contig contig : contigs ) {\n+            // untransited contigs are sources, sinks, or large contigs that can't be crossed by a read\n+            // build traversals from these\n+            if ( !contigTransitsMap.containsKey(contig) ) {\n+                boolean done = false;\n+                for ( final Contig successor : contig.getSuccessors() ) {\n+                    traverse(successor, contig,\n+                            contigsList, readPaths, contigTransitsMap, traversalSet);\n+                    done = true;\n+                }\n+                for ( final Contig predecessor : contig.getPredecessors() ) {\n+                    traverse(predecessor.rc(), contig.rc(),\n+                            contigsList, readPaths, contigTransitsMap, traversalSet);\n+                    done = true;\n+                }\n+                if ( !done ) { // if there were no predecessors or successors, it stands alone\n+                    addTraversal(new Traversal(Collections.singletonList(contig)), traversalSet);\n+                }\n+            }\n+        }\n+\n+        // look for transits that haven't been traced\n+        for ( final Map.Entry<Contig, List<TransitPairCount>> entry :\n+                contigTransitsMap.entrySet() ) {\n+            for ( final TransitPairCount tpc : entry.getValue() ) {\n+                if ( tpc.getCount() > 0 ) {\n+                    tpc.resetCount();\n+                    final Contig contig = entry.getKey();\n+                    final Set<Traversal> fwdTraversalSet = new HashSet<>();\n+                    traverse(tpc.getNextContig(), contig,\n+                            contigsList, readPaths, contigTransitsMap, fwdTraversalSet);\n+                    final Set<Traversal> revTraversalSet = new HashSet<>();\n+                    traverse(tpc.getPrevContig().rc(), contig.rc(),\n+                            contigsList, readPaths, contigTransitsMap, revTraversalSet);\n+                    for ( final Traversal revTraversal : revTraversalSet ) {\n+                        final Traversal revTraversalRC = revTraversal.rc();\n+                        for ( final Traversal fwdTraversal : fwdTraversalSet ) {\n+                            final int overlap =\n+                                    findMaxOverlap(revTraversalRC.getContigs(), fwdTraversal.getContigs());\n+                            final Traversal combo =\n+                                    Traversal.combineOverlappers(revTraversalRC, fwdTraversal, overlap);\n+                            addTraversal(combo, traversalSet);\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+\n+        return traversalSet;\n+    }\n+\n+    private static int findMaxOverlap( final List<Contig> prefixes, final List<Contig> suffixes ) {\n+        final int nPrefixes = prefixes.size();\n+        final Contig firstSuffix = suffixes.get(0);\n+        if ( !firstSuffix.isCyclic() ) {\n+            return prefixes.get(nPrefixes - 1) == firstSuffix ? 1 : 0;\n+        }\n+        final int nSuffixes = suffixes.size();\n+        for ( int prefixIdx = Math.max(0, nPrefixes - nSuffixes); prefixIdx != nPrefixes; ++prefixIdx ) {\n+            if ( prefixes.get(prefixIdx) == firstSuffix ) {\n+                int suffixIdx = 1;\n+                boolean match = true;\n+                for ( int prefixIdx2 = prefixIdx + 1; prefixIdx2 != nPrefixes; ++prefixIdx2 ) {\n+                    if ( prefixes.get(prefixIdx2) != suffixes.get(suffixIdx++) ) {\n+                        match = false;\n+                        break;\n+                    }\n+                }\n+                if ( match ) {\n+                    return nPrefixes - prefixIdx;\n+                }\n+            }\n+        }\n+        return 0;\n+    }\n+\n+    private static void traverse( final Contig contig,\n+                                  final Contig predecessor,\n+                                  final List<Contig> contigsList,\n+                                  final List<Path> readPaths,\n+                                  final Map<Contig, List<TransitPairCount>> contigTransitsMap,\n+                                  final Set<Traversal> traversalSet ) {\n+        contigsList.add(predecessor);\n+        if ( contig.isCyclic() ) {\n+            traverseCycle(contig, contigsList, readPaths, contigTransitsMap, traversalSet);\n+            contigsList.remove(contigsList.size() - 1);\n+            return;\n+        }\n+        final List<TransitPairCount> transits = contigTransitsMap.get(contig);\n+        boolean done = false;\n+        if ( transits != null ) {\n+            for ( final TransitPairCount tpc : transits ) {\n+                if ( tpc.getPrevContig() == predecessor ) {\n+                    final Contig successor = tpc.getNextContig();\n+                    if ( predecessor == contig.rc() ) {\n+                        final int nContigs = contigsList.size();\n+                        if ( nContigs > 1 ) {\n+                            if ( successor.rc() == contigsList.get(nContigs - 2) ) {\n+                                continue;\n+                            }\n+                        }\n+                    }\n+                    tpc.resetCount();\n+                    traverse(successor, contig, contigsList, readPaths, contigTransitsMap, traversalSet);\n+                    done = true;\n+                }\n+            }\n+        }\n+        if ( !done ) {\n+            contigsList.add(contig);\n+            addTraversal(new Traversal(contigsList), traversalSet);\n+            contigsList.remove(contigsList.size() - 1);\n+        }\n+        contigsList.remove(contigsList.size() - 1);\n+    }\n+\n+    private static void traverseCycle( final Contig contig,\n+                                       final List<Contig> contigsList,\n+                                       final List<Path> readPaths,\n+                                       final Map<Contig, List<TransitPairCount>> contigTransitsMap,\n+                                       final Set<Traversal> traversalSet ) {\n+        contigsList.add(contig);\n+        final int nContigs = contigsList.size();\n+        // the final element of the list is cyclic, if there's a previous element it will be\n+        // non-cyclic, so start there figuring out how far the read paths lead us\n+        final List<List<Contig>> longestPaths =\n+                findLongestPaths(contigsList.subList(Math.max(0, nContigs - 2), nContigs), readPaths);\n+        // didn't get anywhere -- just complete the traversal\n+        if ( longestPaths.isEmpty() ) {\n+            addTraversal(new Traversal(contigsList, true), traversalSet);\n+        } else {\n+            // for each unique extension into the cycle\n+            for ( final List<Contig> path : longestPaths ) {\n+                // don't think this can happen, but still\n+                if ( path.isEmpty() ) {\n+                    addTraversal(new Traversal(contigsList, true), traversalSet);\n+                    continue;\n+                }\n+                final List<Contig> extendedContigsList =\n+                        new ArrayList<>(contigsList.size() + path.size());\n+                extendedContigsList.addAll(contigsList);\n+                // if we didn't get out of the cycle\n+                if ( path.get(path.size() - 1).isCyclic() ) {\n+                    extendedContigsList.addAll(path);\n+                    addTraversal(new Traversal(extendedContigsList, true), traversalSet);\n+                } else {\n+                    // we found a cycle-exiting path, so extend that normally\n+                    for ( final Contig curContig : path ) {\n+                        if ( curContig.isCyclic() ) {\n+                            extendedContigsList.add(curContig);\n+                        } else {\n+                            final Contig prevContig =\n+                                    extendedContigsList.remove(extendedContigsList.size() - 1);\n+                            traverse(curContig, prevContig, extendedContigsList, readPaths,\n+                                    contigTransitsMap, traversalSet);\n+                            extendedContigsList.add(prevContig);\n+                            break;\n+                        }\n+                    }\n+                }\n+                clearTransitPairs(contigTransitsMap, extendedContigsList);\n+            }\n+        }\n+        contigsList.remove(contigsList.size() - 1);\n+    }\n+\n+    private static void clearTransitPairs(\n+            final Map<Contig, List<TransitPairCount>> contigTransitsMap,\n+            final List<Contig> contigsList ) {\n+        final int lastIdx = contigsList.size() - 1;\n+        for ( int idx = 1; idx < lastIdx; ++idx ) {\n+            final List<TransitPairCount> pairCounts = contigTransitsMap.get(contigsList.get(idx));\n+            if ( pairCounts != null ) {\n+                final Contig predecessor = contigsList.get(idx - 1);\n+                final Contig successor = contigsList.get(idx + 1);\n+                for ( final TransitPairCount tpc : pairCounts ) {\n+                    if ( tpc.getPrevContig() == predecessor && tpc.getNextContig() == successor ) {\n+                        tpc.resetCount();\n+                        break;\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    private static void addTraversal( final Traversal traversal,\n+                                      final Set<Traversal> traversalSet ) {\n+        if ( !traversalSet.contains(traversal.rc()) ) {\n+            traversalSet.add(traversal);\n+            if ( traversalSet.size() >= TOO_MANY_TRAVERSALS ) {\n+                throw new AssemblyTooComplexException();\n+            }\n+        }\n+    }\n+\n+    private static List<List<Contig>> findLongestPaths( final List<Contig> toMatch,\n+                                                        final List<Path> readPaths ) {\n+        final List<List<Contig>> results = new ArrayList<>();\n+        for ( final Path path : readPaths ) {\n+            testPath(path, toMatch, results);\n+            testPath(path.rc(), toMatch, results);\n+        }\n+        return results;\n+    }\n+\n+    private static void testPath( final Path path,\n+                                  final List<Contig> toMatch,\n+                                  final List<List<Contig>> results ) {\n+        final List<PathPart> pathParts = path.getParts();\n+        final int nPathParts = pathParts.size();\n+        final List<Contig> pathContigs = new ArrayList<>(nPathParts);\n+        pathParts.forEach(pp -> pathContigs.add(pp.getContig()));\n+        final int matchIdx = Collections.indexOfSubList(pathContigs, toMatch);\n+        if ( matchIdx != -1 ) {\n+            final int suffixIdx = matchIdx + toMatch.size();\n+            if ( suffixIdx < nPathParts ) {\n+                resolveResult(grabParts(pathContigs, suffixIdx), results);\n+            }\n+        }\n+    }\n+\n+    private static List<Contig> grabParts( final List<Contig> pathContigs, final int suffixIdx ) {\n+        final int nPathContigs = pathContigs.size();\n+        Contig prev = pathContigs.get(suffixIdx - 1);\n+        final List<Contig> result = new ArrayList<>(nPathContigs - suffixIdx);\n+        for ( int idx = suffixIdx; idx != nPathContigs; ++idx ) {\n+            final Contig tig = pathContigs.get(idx);\n+            if ( tig == null || !prev.getSuccessors().contains(tig) ) break;\n+            result.add(tig);\n+            prev = tig;\n+        }\n+        return result;\n+    }\n+\n+    private static void resolveResult( final List<Contig> result,\n+                                       final List<List<Contig>> results ) {\n+        final int nResults = results.size();\n+        for ( int idx = 0; idx != nResults; ++idx ) {\n+            final List<Contig> test = results.get(idx);\n+            if ( isPrefix(result, test) ) return;\n+            if ( isPrefix(test, result) ) {\n+                results.set(idx, result);\n+                return;\n+            }\n+        }\n+        results.add(result);\n+    }\n+\n+    private static boolean isPrefix( final List<Contig> list1, final List<Contig> list2 ) {\n+        final int list1Size = list1.size();\n+        final int list2Size = list2.size();\n+        if ( list1Size > list2Size ) return false;\n+        for ( int idx = 0; idx != list1Size; ++idx ) {\n+            if ( list1.get(idx) != list2.get(idx) ) return false;\n+        }\n+        return true;\n+    }\n+\n+    @VisibleForTesting\n+    static Collection<Traversal> createScaffolds( final List<Traversal> allTraversals ) {\n+        removeTriviallyDifferentTraversals(allTraversals);\n+\n+        final int nTraversals = allTraversals.size();\n+        final Map<Contig, List<Integer>> traversalsByFirstContig = new HashMap<>(3 * nTraversals);\n+        for ( int idx = 0; idx != nTraversals; ++idx ) {\n+            final Traversal traversal = allTraversals.get(idx);\n+            traversalsByFirstContig.compute(traversal.getFirstContig(),\n+                    ( k, v ) -> v == null ? new ArrayList<>(3) : v).add(idx);\n+            final Traversal rcTraversal = traversal.rc();\n+            traversalsByFirstContig.compute(rcTraversal.getFirstContig(),\n+                    ( k, v ) -> v == null ? new ArrayList<>(3) : v).add(~idx);\n+        }\n+\n+        final List<Traversal> scaffolds = new ArrayList<>(nTraversals);\n+        final boolean[] touched = new boolean[nTraversals];\n+        for ( int idx = 0; idx != nTraversals; ++idx ) {\n+            if ( !touched[idx] ) {\n+                expandTraversal(idx, touched, traversalsByFirstContig, allTraversals, scaffolds);\n+            }\n+        }\n+        return scaffolds;\n+    }\n+\n+    private static void expandTraversal( final int traversalIdx,\n+                                         final boolean[] touched,\n+                                         final Map<Contig, List<Integer>> traversalsByFirstContig,\n+                                         final List<Traversal> allTraversals,\n+                                         final List<Traversal> scaffolds ) {\n+        final Traversal traversal = allTraversals.get(traversalIdx);\n+        touched[traversalIdx] = true;\n+        final List<Traversal> downExtensions = new ArrayList<>();\n+        final Set<Contig> startingContigSet = new HashSet<>();\n+        walkTraversals(traversal, touched, startingContigSet, traversalsByFirstContig,\n+                        allTraversals, downExtensions);\n+        final List<Traversal> upExtensions = new ArrayList<>();\n+        walkTraversals(traversal.rc(), touched, startingContigSet, traversalsByFirstContig,\n+                        allTraversals, upExtensions);\n+        for ( final Traversal down : downExtensions ) {\n+            for ( final Traversal up : upExtensions ) {\n+                if ( scaffolds.size() >= TOO_MANY_SCAFFOLDS ) {\n+                    throw new AssemblyTooComplexException();\n+                }\n+                scaffolds.add(Traversal.combineOverlappers(up.rc(), down, traversal.getContigs().size()));\n+            }\n+        }\n+    }\n+\n+    private static void walkTraversals( final Traversal traversal,\n+                                        final boolean[] touched,\n+                                        final Set<Contig> startingContigSet,\n+                                        final Map<Contig, List<Integer>> traversalsByFirstContig,\n+                                        final List<Traversal> allTraversals,\n+                                        final List<Traversal> extensions ) {\n+        final Contig firstContig = traversal.getFirstContig();\n+        final List<Integer> indexList;\n+        if ( startingContigSet.contains(firstContig) ||\n+                traversal.isInextensible() ||\n+                (indexList = traversalsByFirstContig.get(traversal.getLastContig())) == null ) {\n+            extensions.add(traversal);\n+            return;\n+        }\n+        startingContigSet.add(firstContig);\n+        for ( int idx : indexList ) {\n+            final Traversal extension;\n+            if ( idx >= 0 ) {\n+                extension = allTraversals.get(idx);\n+                touched[idx] = true;\n+            } else {\n+                final int rcIdx = ~idx;\n+                extension = allTraversals.get(rcIdx).rc();\n+                touched[rcIdx] = true;\n+            }\n+            walkTraversals(Traversal.combine(traversal, extension), touched, startingContigSet,\n+                            traversalsByFirstContig, allTraversals, extensions );\n+        }\n+        startingContigSet.remove(firstContig);\n+    }\n+\n+    private static void removeTriviallyDifferentTraversals(\n+                                            final Collection<Traversal> allTraversals ) {\n+        if ( allTraversals.isEmpty() ) {\n+            return;\n+        }\n+        final TreeSet<Traversal> sortedTraversals = new TreeSet<>(new TraversalEndpointComparator());\n+        for ( final Traversal traversal : allTraversals ) {\n+            sortedTraversals.add(traversal);\n+            sortedTraversals.add(traversal.rc());\n+        }\n+        final Iterator<Traversal> traversalIterator = sortedTraversals.iterator();\n+        Traversal prevTraversal = traversalIterator.next();\n+        while ( traversalIterator.hasNext() ) {\n+            final Traversal curTraversal = traversalIterator.next();\n+            if ( isTriviallyDifferent(prevTraversal, curTraversal) ) {\n+                traversalIterator.remove();\n+            } else {\n+                prevTraversal = curTraversal;\n+            }\n+        }\n+        sortedTraversals.removeIf(Traversal::isRC);\n+        allTraversals.clear();\n+        allTraversals.addAll(sortedTraversals);\n+    }\n+\n+    private static boolean isTriviallyDifferent( final Traversal traversal1,\n+                                                 final Traversal traversal2 ) {\n+        final Contig firstContig1 = traversal1.getFirstContig();\n+        final Contig lastContig1 = traversal1.getLastContig();\n+        final Contig firstContig2 = traversal2.getFirstContig();\n+        final Contig lastContig2 = traversal2.getLastContig();\n+        if ( firstContig1 != firstContig2 || lastContig1 != lastContig2 ) {\n+            return false;\n+        }\n+        final int interiorSize1 = traversal1.getSequenceLength() - firstContig1.size() - lastContig1.size();\n+        final int interiorSize2 = traversal2.getSequenceLength() - firstContig2.size() - lastContig2.size();\n+\n+        // if the path lengths are so different that one could harbor an SV, they're not trivially different\n+        if ( Math.abs(interiorSize1 - interiorSize2) >= MIN_SV_SIZE ) {\n+            return false;\n+        }\n+\n+        // if the paths are small enough that there can't be an SV's worth of differences, they're trivially different\n+        final int maxInteriorSize = Math.max(interiorSize1, interiorSize2);\n+        if ( maxInteriorSize < MIN_SV_SIZE ) {\n+            return true;\n+        }\n+\n+        // dang, maybe there's enough material in common that there can't be an SV's worth of differences\n+        // run a longest common subsequence algorithm to figure out the length of the common material\n+        // DP matrix holds length of common material\n+        final List<Contig> contigs1 = traversal1.getContigs();\n+        final int rowLen = contigs1.size() - 1;\n+        final int[][] rowPair = new int[2][];\n+        rowPair[0] = new int[rowLen];\n+        rowPair[1] = new int[rowLen];\n+        int pairIdx = 0;\n+        final List<Contig> contigs2 = traversal2.getContigs();\n+        final int nRows = contigs2.size() - 1;\n+        for ( int idx2 = 1; idx2 != nRows; ++idx2 ) {\n+            final int[] curRow = rowPair[pairIdx];\n+            final int[] prevRow = rowPair[pairIdx ^ 1];\n+            pairIdx ^= 1;\n+\n+            final int id2 = contigs2.get(idx2).getId();\n+            for ( int idx1 = 1; idx1 != rowLen; ++idx1 ) {\n+                final Contig tig1 = contigs1.get(idx1);\n+                if ( tig1.getId() == id2 ) {\n+                    // if the previous cells also contain a match we've already removed the K-1 bases upstream\n+                    final boolean extendMatch =\n+                            contigs1.get(idx1 -1).getId() == contigs2.get(idx2 - 1).getId();\n+                    curRow[idx1] = prevRow[idx1 - 1] + (extendMatch ? tig1.getNKmers() : tig1.size());\n+                } else {\n+                    curRow[idx1] = Math.max(curRow[idx1 - 1], prevRow[idx1]);\n+                }\n+            }\n+        }\n+        final int commonLen = rowPair[pairIdx ^ 1][rowLen - 1];\n+        return (maxInteriorSize - commonLen) < MIN_SV_SIZE;\n+    }\n+\n+    private static class TraversalEndpointComparator implements Comparator<Traversal> {\n+        @Override\n+        public int compare( final Traversal traversal1, final Traversal traversal2 ) {\n+            int cmp = Integer.compare(traversal1.contigs.get(0).getId(),\n+                                      traversal2.contigs.get(0).getId());\n+            if ( cmp != 0 ) {\n+                return cmp;\n+            }\n+            final int last1 = traversal1.contigs.size() - 1;\n+            final int last2 = traversal2.contigs.size() - 1;\n+            cmp = Integer.compare(traversal1.contigs.get(last1).getId(),\n+                                  traversal2.contigs.get(last2).getId());\n+            if ( cmp != 0 ) {\n+                return cmp;\n+            }\n+            // among those starting and ending at the same place, sort least observed last\n+            return -Integer.compare(traversal1.getMinMaxObservations(), traversal2.getMinMaxObservations());\n+        }\n+    }\n+\n+    private static void writeDOT( final List<ContigImpl> contigs, final String fileName ) {\n+        try ( final BufferedWriter writer = new BufferedWriter(new FileWriter(fileName)) ) {\n+            writer.write(\"digraph {\\n\");\n+            for ( final Contig contig : contigs ) {\n+                final double width = contig.getSequence().length() / 100.;\n+                writer.write(contig + \" [width=\" + width + \"]\\n\");\n+                writer.write( contig.rc() + \" [width=\" + width + \"]\\n\");\n+            }\n+            for ( final Contig contig : contigs ) {\n+                for ( final Contig predecessor : contig.getPredecessors() ) {\n+                    final String predecessorName = predecessor.rc().toString();\n+                    writer.write(contig.rc() + \" -> \" + predecessorName + \"\\n\");\n+                }\n+                for ( final Contig successor : contig.getSuccessors() ) {\n+                    final String successorName = successor.toString();\n+                    writer.write(contig + \" -> \" + successorName + \"\\n\");\n+                }\n+            }\n+            writer.write(\"}\\n\");\n+        } catch ( final IOException ioe ) {\n+            throw new GATKException(\"Failed to write assembly DOT file.\", ioe);\n+        }\n+    }\n+\n+    private static BufferedWriter makeGZFile( final String fileName ) throws IOException {\n+        final GZIPOutputStream gzOS = new GZIPOutputStream(BucketUtils.createFile(fileName));\n+        return new BufferedWriter(new OutputStreamWriter(gzOS));\n+    }\n+\n+    private static void writeContigs( final List<ContigImpl> contigs, final String fileName ) {\n+        try ( final BufferedWriter writer = makeGZFile(fileName) ) {\n+            for ( final Contig contig : contigs ) {\n+                final List<Contig> predecessors = contig.getPredecessors();\n+                final String predecessorDescription;\n+                if ( predecessors.size() == 0 ) {\n+                    predecessorDescription = \"\\tnone\";\n+                } else {\n+                    final StringBuilder sb = new StringBuilder();\n+                    char prefix = '\\t';\n+                    for ( final Contig predecessor : predecessors ) {\n+                        sb.append(prefix);\n+                        prefix = ',';\n+                        sb.append(predecessor);\n+                    }\n+                    predecessorDescription = sb.toString();\n+                }\n+\n+                final List<Contig> successors = contig.getSuccessors();\n+                final String successorDescription;\n+                if ( successors.size() == 0 ) {\n+                    successorDescription = \"\\tnone\";\n+                } else {\n+                    final StringBuilder sb = new StringBuilder();\n+                    char prefix = '\\t';\n+                    for ( final Contig successor : successors ) {\n+                        sb.append(prefix);\n+                        prefix = ',';\n+                        sb.append(successor);\n+                    }\n+                    successorDescription = sb.toString();\n+                }\n+\n+                final String contigName = contig.toString();\n+                final String component =\n+                        (contig.isCyclic() ? \"(C)\\t\" : \"\\t\") + contig.getComponentId();\n+                writer.write(contigName + component + predecessorDescription +\n+                        successorDescription + \"\\t\" +\n+                        contig.getMaxObservations() + \"\\t\" +\n+                        contig.getFirstKmer().getNObservations() + \"\\t\" +\n+                        contig.getLastKmer().getNObservations() + \"\\t\" +\n+                        contig.size() + \"\\t\" +\n+                        contig.getSequence() + \"\\n\");\n+            }\n+        } catch ( final IOException ioe ) {\n+            throw new GATKException(\"Failed to write contigs file.\", ioe);\n+        }\n+    }\n+\n+    private static void writePaths( final List<Path> readPaths, final String fileName ) {\n+        try ( final BufferedWriter writer = makeGZFile(fileName) ) {\n+            final int nReads = readPaths.size();\n+            for ( int readId = 0; readId != nReads; ++readId ) {\n+                final Path path = readPaths.get(readId);\n+                final String pathDesc = path.toString();\n+                writer.write((readId + 1) + \": \" + pathDesc + \"\\n\");\n+            }\n+        } catch ( final IOException ioe ) {\n+            throw new GATKException(\"Failed to write paths file.\", ioe);\n+        }\n+    }\n+\n+    private static void writeReads( final List<GATKRead> reads, final String fileName ) {\n+        try ( final BufferedWriter writer = makeGZFile(fileName) ) {\n+            for ( final GATKRead read : reads ) {\n+                writer.write(\"@\" + read.getName());\n+                writer.write('\\n');\n+                writer.write(new String(read.getBasesNoCopy()));\n+                writer.write(\"\\n+\\n\");\n+                final byte[] quals = read.getBaseQualitiesNoCopy();\n+                final int nQuals = quals.length;\n+                final byte[] fastqQuals = new byte[nQuals];\n+                for ( int idx = 0; idx != nQuals; ++idx ) {\n+                    fastqQuals[idx] = (byte)SAMUtils.phredToFastq(quals[idx]);\n+                }\n+                writer.write(new String(fastqQuals));\n+                writer.write('\\n');\n+            }\n+        } catch ( final IOException ioe ) {\n+            throw new GATKException(\"Failed to write assembly sam file.\", ioe);\n+        }\n+    }\n+\n+    private static void writeTraversals( final Collection<Traversal> traversals,\n+                                         final String fileName ) {\n+        try ( final BufferedWriter writer = makeGZFile(fileName) ) {\n+            int traversalNo = 0;\n+            for ( final Traversal traversal : traversals ) {\n+                writer.write(\">\");\n+                if ( assemblyName != null ) {\n+                    writer.write(assemblyName);\n+                    writer.write(\"_\");\n+                }\n+                writer.write(\"t\");\n+                writer.write(Integer.toString(++traversalNo));\n+                writer.write(\" \");\n+                writer.write(traversal.getName());\n+                writer.newLine();\n+                writer.write(traversal.getSequence());\n+                writer.newLine();\n+            }\n+        } catch ( final IOException ioe ) {\n+            throw new GATKException(\"Failed to write assembly sam file.\", ioe);\n+        }\n+    }\n+\n+    /** fixed-size, immutable kmer.  usual 2-bit encoding: ACGT->0123.  low order bits are final call. **/\n+    public static class Kmer {\n+        public static final int KSIZE = 31; // must be odd number less than 32\n+        public static final long KMASK = (1L << 2*KSIZE) - 1L;\n+        private final long kVal;\n+\n+        public Kmer( final long kVal ) { this.kVal = kVal; }\n+\n+        public long getKVal() { return kVal; }\n+        public boolean isCanonical() { return isCanonical(kVal); }\n+        public int getInitialCall() { return (int)(kVal >> (KSIZE*2 - 2)) & 3; }\n+        public int getFinalCall() { return (int)kVal & 3; }\n+\n+        public long getPredecessorVal( final int call ) {\n+            return (kVal >> 2) | ((long)call << (2 * (KSIZE - 1)));\n+        }\n+        public long getSuccessorVal( final int call ) { return ((kVal << 2) & KMASK) | call; }\n+\n+        public static boolean isCanonical( final long val ) {\n+            return (val & (1L << KSIZE)) == 0L;\n+        }\n+\n+        @Override public boolean equals( final Object obj ) {\n+            return obj instanceof Kmer && kVal == ((Kmer)obj).kVal;\n+        }\n+\n+        @Override public int hashCode() {\n+            return (int)(kVal ^ (kVal >>> 32));\n+        }\n+    }\n+\n+    /** Set of Kmers.  Uses HopscotchSet, customized to find correct starting bin for Kmers and derivatives. **/\n+    public static final class KmerSet<KMER extends Kmer> extends HopscotchSet<KMER> {\n+        public KmerSet( final int capacity ) { super(capacity); }\n+\n+        @Override\n+        protected int hashToIndex( final Object kmer ) {\n+            return (int)(((HopscotchSet.SPREADER * ((Kmer)kmer).getKVal()) & Long.MAX_VALUE) % capacity());\n+        }\n+    }\n+\n+    /**\n+     *  A Kmer that remembers its predecessors and successors, and the number of times it's been observed\n+     *  in the assembly's input set of reads.\n+     *  The masks are bit-wise (1=A, 2=C, 4=G, 8=T) to show which predecessors or successors have been observed.\n+     *  The Kmer's position on a Contig is also tracked (in later phases of the assembly process).\n+     **/\n+    public static abstract class KmerAdjacency extends Kmer {\n+        public KmerAdjacency( final long kVal ) { super(kVal); }\n+\n+        public abstract KmerAdjacency getSolePredecessor(); // returns null if there's 0 or >1 predecessors\n+        public abstract int getPredecessorMask();\n+        public abstract int getPredecessorCount();\n+        public abstract void removePredecessor( final int callToRemove,\n+                                                final KmerSet<KmerAdjacency> kmerAdjacencySet );\n+\n+        public abstract KmerAdjacency getSoleSuccessor(); // returns null if there's 0 or > 1 successors\n+        public abstract int getSuccessorMask();\n+        public abstract int getSuccessorCount();\n+        public abstract void removeSuccessor( final int callToRemove,\n+                                              final KmerSet<KmerAdjacency> kmerAdjacencySet );\n+\n+        public abstract Contig getContig();\n+        public abstract int getContigOffset();\n+        // offset is 0-based measure on the contig sequence of the beginning of the kmer\n+        public abstract void setContigOffset( final Contig contig, final int contigOffset );\n+        public abstract void clearContig();\n+\n+        public abstract int getNObservations();\n+        public abstract KmerAdjacency rc();\n+        public abstract KmerAdjacencyImpl canonical();\n+\n+        public void observe( final KmerAdjacency predecessor, final KmerAdjacency successor ) {\n+            observe(predecessor, successor, 1);\n+        }\n+\n+        public abstract void observe( final KmerAdjacency predecessor,\n+                                      final KmerAdjacency successor,\n+                                      final int count );\n+\n+        @Override public String toString() {\n+            final StringBuilder sb = new StringBuilder(KSIZE);\n+            long currentVal = getKVal();\n+            for ( int idx = 0; idx != KSIZE; ++idx ) {\n+                sb.append(\"ACGT\".charAt((int)currentVal & 3));\n+                currentVal >>= 2;\n+            }\n+            sb.reverse(); // low order bits were loaded into sb first:  fix that now by reversing the sb.\n+            return sb.toString();\n+        }\n+\n+        /**\n+         * Transform a read's calls into KmerAdjacencies, and add them to a KmerSet.\n+         * Skip kmers that include a call with a quality < qMin.\n+         * Skip kmers with non-ACGT calls.\n+         **/\n+        public static void kmerize( final byte[] calls,\n+                                    final byte[] quals,\n+                                    final byte qMin,\n+                                    final KmerSet<KmerAdjacency> kmerAdjacencySet ) {\n+            int currentCount = 0; // number of calls loaded into currentKVal\n+            long currentKVal = 0;\n+            KmerAdjacency prevAdjacency = null;\n+            KmerAdjacency currentAdjacency = null;\n+            for ( int idx = 0; idx < calls.length; ++idx ) {\n+                if ( quals[idx] < qMin ) { // if we encounter a low-quality call\n+                    // take care of the most recent valid KmerAdjacency, if any\n+                    if ( currentAdjacency != null ) {\n+                        currentAdjacency.observe(prevAdjacency, null);\n+                    }\n+                    // ready ourselves to accumulate calls afresh\n+                    currentCount = 0;\n+                    currentAdjacency = prevAdjacency = null;\n+                    continue;\n+                }\n+                currentKVal <<= 2;\n+                switch ( calls[idx] ) {\n+                    case 'A': case 'a': break;\n+                    case 'C': case 'c': currentKVal += 1; break;\n+                    case 'G': case 'g': currentKVal += 2; break;\n+                    case 'T': case 't': currentKVal += 3; break;\n+                    default:\n+                        if ( currentAdjacency != null ) {\n+                            currentAdjacency.observe(prevAdjacency, null);\n+                        }\n+                        currentCount = 0;\n+                        currentAdjacency = prevAdjacency = null;\n+                        continue;\n+                }\n+                if ( ++currentCount >= KSIZE ) { // if we've loaded enough calls to make a complete kmer\n+                    final KmerAdjacency nextAdjacency = findOrAdd(currentKVal, kmerAdjacencySet);\n+                    if ( currentAdjacency != null ) {\n+                        currentAdjacency.observe(prevAdjacency, nextAdjacency);\n+                    }\n+                    prevAdjacency = currentAdjacency;\n+                    currentAdjacency = nextAdjacency;\n+                }\n+            }\n+            if ( currentAdjacency != null ) {\n+                currentAdjacency.observe(prevAdjacency, null);\n+            }\n+        }\n+\n+        /**\n+         * Kmerize a String.  This version is for gap fills.\n+         * The number of observations applies to all kmers except the 1st and last.\n+         **/\n+        public static void kmerize( final String sequence,\n+                                    final int nObservations,\n+                                    final KmerSet<KmerAdjacency> kmerAdjacencySet ) {\n+            int currentCount = 0;\n+            long currentKVal = 0;\n+            int nObs = 0;\n+            KmerAdjacency prevAdjacency = null;\n+            KmerAdjacency currentAdjacency = null;\n+            final int nCalls = sequence.length();\n+            for ( int idx = 0; idx != nCalls; ++idx ) {\n+                currentKVal <<= 2;\n+                switch ( sequence.charAt(idx) ) {\n+                    case 'A': case 'a': break;\n+                    case 'C': case 'c': currentKVal += 1; break;\n+                    case 'G': case 'g': currentKVal += 2; break;\n+                    case 'T': case 't': currentKVal += 3; break;\n+                    default: throw new GATKException(\"unexpected base call in string to kmerize.\");\n+                }\n+                if ( ++currentCount >= KSIZE ) {\n+                    final KmerAdjacency nextAdjacency = findOrAdd(currentKVal, kmerAdjacencySet);\n+                    if ( currentAdjacency != null ) {\n+                        currentAdjacency.observe(prevAdjacency, nextAdjacency, nObs);\n+                        nObs = nObservations;\n+                    }\n+                    prevAdjacency = currentAdjacency;\n+                    currentAdjacency = nextAdjacency;\n+                }\n+            }\n+            if ( currentAdjacency != null ) {\n+                currentAdjacency.observe(prevAdjacency, null, 0);\n+            }\n+        }\n+\n+        // Lookup table for reverse-complementing each possible byte value.\n+        // Each pair of bits represents a base, so you have to reverse bits pairwise and then invert all bits.\n+        // This is most quickly and easily done with a lookup table.\n+        private static final long[] BYTEWISE_REVERSE_COMPLEMENT;\n+        static {\n+            BYTEWISE_REVERSE_COMPLEMENT = new long[256];\n+            for ( int bIn = 0; bIn != 256; ++bIn ) {\n+                BYTEWISE_REVERSE_COMPLEMENT[bIn] =\n+                        ~(((bIn & 3) << 6) | (((bIn >> 2) & 3) << 4) |\n+                                (((bIn >> 4) & 3) << 2) | ((bIn >> 6) & 3)) & 0xffL;\n+            }\n+        }\n+\n+        public static long reverseComplement( long val ) {\n+            // process val one byte at a time\n+            long result = BYTEWISE_REVERSE_COMPLEMENT[(int)val & 0xFF]; // handle the low-order byte\n+            int nBytes = 8;\n+            while ( --nBytes != 0 ) { // pre-decrementing:  we'll go through the loop 7 times\n+                // rotate down by a byte\n+                val >>= 8;\n+                // rotate up by a byte and OR in the reverse complement of the next byte\n+                result = (result << 8) | BYTEWISE_REVERSE_COMPLEMENT[(int)val & 0xFF];\n+            }\n+            return result >>> (Long.SIZE - 2*KSIZE);\n+        }\n+\n+        // Kmer lookup in KmerSet.\n+        // KmerSets holding KmerAdjacencies have only canonical Kmers, so RC non-canonical kmers before lookup.\n+        public static KmerAdjacency find( final long kVal,\n+                                          final KmerSet<KmerAdjacency> kmerAdjacencySet ) {\n+            if ( isCanonical(kVal) ) return kmerAdjacencySet.find(new Kmer(kVal & KMASK));\n+            final KmerAdjacency result = kmerAdjacencySet.find(new Kmer(reverseComplement(kVal)));\n+            return result == null ? null : result.rc();\n+        }\n+\n+        // Kmer lookup in KmerSet.\n+        // KmerSets holding KmerAdjacencies have only canonical Kmers, so RC non-canonical kmers before lookup.\n+        // Add missing Kmers.\n+        public static KmerAdjacency findOrAdd( final long kVal,\n+                                               final KmerSet<KmerAdjacency> kmerAdjacencySet ) {\n+            if ( isCanonical(kVal) ) {\n+                return kmerAdjacencySet.findOrAdd(new Kmer(kVal & KMASK), kmer ->\n+                        new KmerAdjacencyImpl(((Kmer)kmer).getKVal()));\n+            }\n+            return kmerAdjacencySet.findOrAdd(new Kmer(reverseComplement(kVal)), kmer ->\n+                    new KmerAdjacencyImpl(((Kmer)kmer).getKVal())).rc();\n+        }\n+    }\n+\n+    /**\n+     * Class to implement KmerAdjacency for canonical Kmers.\n+     * In particular, a KmerSet created on KmerAdjacency contains only canonical Kmers.\n+     **/\n+    public static final class KmerAdjacencyImpl extends KmerAdjacency {\n+        private KmerAdjacency solePredecessor; // set to null if there are no predecessors, or multiple predecessors\n+        private KmerAdjacency soleSuccessor; // set to null if there are no successors, or multiple successors\n+        private int predecessorMask; // bit mask of observed kmers preceding this one\n+        private int successorMask; // bit mask observed kmers following this one\n+        private Contig contig; // the contig that contains this Kmer\n+        private int contigOffset; // the offset within the contig where this kmer is found\n+        private int nObservations; // the reads in which this kmer was observed\n+        private final KmerAdjacencyRC rc; // the reverse-complement of this kmer\n+        private static final int[] COUNT_FOR_MASK =\n+                //side sum for binary values from 0 -> 15\n+                //0000  0001 0010 0011 0100 0101 0110 0111 1000 1001 1010 1011 1100 1101 1110 1111\n+                {    0,    1,   1,   2,   1,   2,   2,   3,   1,   2,   2,   3,   2,   3,   3,   4 };\n+\n+        public KmerAdjacencyImpl( final long kVal ) {\n+            super(kVal);\n+            this.rc = new KmerAdjacencyRC(this);\n+        }\n+\n+        @Override public KmerAdjacency getSolePredecessor() { return solePredecessor; } // may return null\n+        @Override public int getPredecessorMask() { return predecessorMask; }\n+        @Override public int getPredecessorCount() { return COUNT_FOR_MASK[predecessorMask]; }\n+        @Override\n+        public void removePredecessor( final int callToRemove,\n+                                       final KmerSet<KmerAdjacency> kmerAdjacencySet ) {\n+            predecessorMask &= ~(1 << callToRemove);\n+            solePredecessor = null;\n+            if ( getPredecessorCount() == 1 ) {\n+                for ( int call = 0; call != 4; ++call ) {\n+                    if ( ((1 << call) & predecessorMask) != 0 ) {\n+                        solePredecessor = find(getPredecessorVal(call), kmerAdjacencySet);\n+                        break;\n+                    }\n+                }\n+            }\n+        }\n+\n+        @Override public KmerAdjacency getSoleSuccessor() { return soleSuccessor; } // may return null\n+        @Override public int getSuccessorMask() { return successorMask; }\n+        @Override public int getSuccessorCount() { return COUNT_FOR_MASK[successorMask]; }\n+        @Override\n+        public void removeSuccessor( final int callToRemove,\n+                                     final KmerSet<KmerAdjacency> kmerAdjacencySet ) {\n+            successorMask &= ~(1 << callToRemove);\n+            soleSuccessor = null;\n+            if ( getSuccessorCount() == 1 ) {\n+                for ( int call = 0; call != 4; ++call ) {\n+                    if ( ((1 << call) & successorMask) != 0 ) {\n+                        soleSuccessor = find(getSuccessorVal(call), kmerAdjacencySet);\n+                        break;\n+                    }\n+                }\n+            }\n+        }\n+\n+        @Override public Contig getContig() { return contig; }\n+        @Override public int getContigOffset() { return contigOffset; }\n+        @Override public void setContigOffset( final Contig contig, final int contigOffset ) {\n+            if ( this.contig != null ) {\n+                throw new GATKException(\"Internal error: overwriting kmer contig and offset.\");\n+            }\n+            this.contig = contig;\n+            this.contigOffset = contigOffset;\n+        }\n+        @Override public void clearContig() { contig = null; contigOffset = 0; }\n+\n+        @Override public int getNObservations() { return nObservations; }\n+        @Override public KmerAdjacency rc() { return rc; }\n+        @Override public KmerAdjacencyImpl canonical() { return this; }\n+\n+        @Override public void observe( final KmerAdjacency predecessor,\n+                                       final KmerAdjacency successor,\n+                                       final int count ) {\n+            if ( predecessor != null ) {\n+                if ( predecessor.getSuccessorVal(getFinalCall()) != getKVal() ) {\n+                    throw new GATKException(\"illegal predecessor\");\n+                }\n+                final int initialCall = predecessor.getInitialCall();\n+                final int newPredecessorMask = 1 << initialCall;\n+                if ( (newPredecessorMask & predecessorMask) == 0 ) {\n+                    if ( predecessorMask == 0 ) {\n+                        solePredecessor = predecessor;\n+                        predecessorMask = newPredecessorMask;\n+                    } else {\n+                        solePredecessor = null;\n+                        predecessorMask |= newPredecessorMask;\n+                    }\n+                }\n+            }\n+            if ( successor != null ) {\n+                if ( successor.getPredecessorVal(getInitialCall()) != getKVal() ) {\n+                    throw new GATKException(\"illegal successor\");\n+                }\n+                final int finalCall = successor.getFinalCall();\n+                final int newSuccessorMask = 1 << finalCall;\n+                if ( (newSuccessorMask & successorMask) == 0 ) {\n+                    if ( successorMask == 0 ) {\n+                        soleSuccessor = successor;\n+                        successorMask = newSuccessorMask;\n+                    } else {\n+                        soleSuccessor = null;\n+                        successorMask |= newSuccessorMask;\n+                    }\n+                }\n+            }\n+            nObservations += count;\n+        }\n+    }\n+\n+    /**\n+     * Class to implement KmerAdjacency for Kmers that are the reverse-complement of a canonical Kmer.\n+     * In particular, a KmerSet created on KmerAdjacency contains only canonical Kmers.\n+     * A KmerAdjacencyRC represents the RC of each Kmer in the KmerSet.\n+     **/\n+    public static final class KmerAdjacencyRC extends KmerAdjacency {\n+        private final KmerAdjacencyImpl rc;\n+\n+        // lookup table to bit-reverse nibbles\n+        private static final int[] NIBREV =\n+                // 0000,  0001,  0010,  0011,  0100,  0101,  0110,  0111,  1000,  1001,  1010,  1011,  1100,  1101,  1110,  1111\n+                {0b0000,0b1000,0b0100,0b1100,0b0010,0b1010,0b0110,0b1110,0b0001,0b1001,0b0101,0b1101,0b0011,0b1011,0b0111,0b1111};\n+\n+        public KmerAdjacencyRC( final KmerAdjacencyImpl rc ) {\n+            super(reverseComplement(rc.getKVal()));\n+            this.rc = rc;\n+        }\n+\n+        @Override public KmerAdjacency getSolePredecessor() {\n+            final KmerAdjacency successor = rc.getSoleSuccessor();\n+            return successor == null ? null : successor.rc();\n+        }\n+        @Override public int getPredecessorMask() { return NIBREV[rc.getSuccessorMask()]; }\n+        @Override public int getPredecessorCount() { return rc.getSuccessorCount(); }\n+        @Override\n+        public void removePredecessor( final int callToRemove,\n+                                       final KmerSet<KmerAdjacency> kmerAdjacencySet ) {\n+            rc.removeSuccessor(3 - callToRemove, kmerAdjacencySet);\n+        }\n+\n+        @Override public KmerAdjacency getSoleSuccessor() {\n+            final KmerAdjacency predecessor = rc.getSolePredecessor();\n+            return predecessor == null ? null : predecessor.rc();\n+        }\n+        @Override public int getSuccessorMask() { return NIBREV[rc.getPredecessorMask()]; }\n+        @Override public int getSuccessorCount() { return rc.getPredecessorCount(); }\n+        @Override\n+        public void removeSuccessor( final int callToRemove,\n+                                     final KmerSet<KmerAdjacency> kmerAdjacencySet ) {\n+            rc.removePredecessor(3 - callToRemove, kmerAdjacencySet);\n+        }\n+\n+        @Override public Contig getContig() {\n+            final Contig contig = rc.getContig();\n+            return contig == null ? null : contig.rc();\n+        }\n+        @Override public int getContigOffset() {\n+            final Contig contig = rc.getContig();\n+            return contig == null ? 0 : contig.size() - rc.getContigOffset() - KSIZE;\n+        }\n+        @Override public void setContigOffset( final Contig contig, final int contigOffset ) {\n+            rc.setContigOffset(contig.rc(), contig.size() - contigOffset - KSIZE);\n+        }\n+        @Override public void clearContig() { rc.clearContig(); }\n+\n+        @Override public int getNObservations() { return rc.getNObservations(); }\n+        @Override public KmerAdjacency rc() { return rc; }\n+        @Override public KmerAdjacencyImpl canonical() { return rc; }\n+\n+        @Override public void observe( final KmerAdjacency predecessor,\n+                                       final KmerAdjacency successor,\n+                                       final int count ) {\n+            rc.observe(successor == null ? null : successor.rc(),\n+                    predecessor == null ? null : predecessor.rc(),\n+                    count);\n+        }\n+    }\n+\n+    public enum ContigOrientation {\n+        FWD, // k-mer appears at the 5' end of the contig\n+        REV, // k-mer appears at the 5' end of the reverse-complemented contig\n+        BOTH // k-mer occurs on 5' end of the contig and its RC (can happen when the contig is a palindrome)\n+    }\n+\n+    /** Initial or final Kmer in a Contig. **/\n+    public static final class ContigEndKmer extends Kmer {\n+        private final Contig contig;\n+        private final ContigOrientation contigOrientation;\n+\n+        public ContigEndKmer( final long kVal,\n+                              final Contig contig,\n+                              final ContigOrientation contigEnd ) {\n+            super(kVal);\n+            this.contig = contig;\n+            this.contigOrientation = contigEnd;\n+        }\n+\n+        public Contig getContig() { return contig; }\n+        public ContigOrientation getContigOrientation() { return contigOrientation; }\n+    }\n+\n+    /**\n+     * An unbranched sequence of Kmers.\n+     * Each Kmer (except the last one) has a single successor, which allows enumerating the sequence\n+     * of Kmers in the Contig.  The sequence of base calls in the Contig is just the sequence of kmers\n+     * with the K-1 overlapping calls removed from adjacent kmers.\n+     **/\n+    public interface Contig {\n+        int getId();\n+        CharSequence getSequence();\n+        int getMaxObservations();\n+        KmerAdjacency getFirstKmer();\n+        KmerAdjacency getLastKmer();\n+        List<Contig> getPredecessors();\n+        List<Contig> getSuccessors();\n+        int getComponentId();\n+        int size();\n+        default int getNKmers() { return size() - Kmer.KSIZE + 1; }\n+        Contig rc();\n+        boolean isCyclic();\n+        void setCyclic( final boolean cyclic );\n+        boolean isCut();\n+        void setCut( final boolean cut );\n+        boolean isCanonical();\n+        ContigImpl canonical();\n+    }\n+\n+    /** Simple implementation of Contig interface. **/\n+    public static final class ContigImpl implements Contig {\n+        private final int id;\n+        private final CharSequence sequence;\n+        private final int maxObservations;\n+        private final KmerAdjacency firstKmer;\n+        private final KmerAdjacency lastKmer;\n+        private final List<Contig> predecessors;\n+        private final List<Contig> successors;\n+        private int componentId;\n+        private boolean cyclic;\n+        private boolean cut;\n+        private final Contig rc;\n+\n+        public ContigImpl( final int id, final KmerAdjacency firstKmerAdjacency ) {\n+            this.id = id;\n+            final StringBuilder sb = new StringBuilder(firstKmerAdjacency.toString());\n+            int maxObservations = firstKmerAdjacency.getNObservations();\n+            KmerAdjacency lastKmerAdjacency = firstKmerAdjacency;\n+            for ( KmerAdjacency kmerAdjacency = firstKmerAdjacency.getSoleSuccessor();\n+                  kmerAdjacency != null;\n+                  kmerAdjacency = kmerAdjacency.getSoleSuccessor() ) {\n+                // if we've gone around a circle, or if we're branching backwards, or if we hit a palindrome u-turn\n+                if ( firstKmerAdjacency == kmerAdjacency ||\n+                        kmerAdjacency.getPredecessorCount() != 1 ||\n+                        kmerAdjacency == lastKmerAdjacency.rc() ) {\n+                    break;\n+                }\n+                sb.append(\"ACGT\".charAt(kmerAdjacency.getFinalCall()));\n+                maxObservations = Math.max(maxObservations, kmerAdjacency.getNObservations());\n+                lastKmerAdjacency = kmerAdjacency;\n+            }\n+            this.sequence = sb.toString();\n+            this.maxObservations = maxObservations;\n+            this.firstKmer = firstKmerAdjacency;\n+            this.lastKmer = lastKmerAdjacency;\n+            this.predecessors = new ArrayList<>(firstKmer.getPredecessorCount());\n+            this.successors = new ArrayList<>(lastKmer.getSuccessorCount());\n+            this.rc = new ContigRCImpl(this);\n+\n+            int offset = 0;\n+            for ( KmerAdjacency kmerAdjacency = firstKmerAdjacency;\n+                  kmerAdjacency != lastKmerAdjacency;\n+                  kmerAdjacency = kmerAdjacency.getSoleSuccessor() ) {\n+                kmerAdjacency.setContigOffset(this, offset++);\n+            }\n+            lastKmerAdjacency.setContigOffset(this, offset);\n+        }\n+\n+        // create a new contig by joining two contigs\n+        public ContigImpl( final int id, final Contig predecessor, final Contig successor ) {\n+            if ( predecessor == successor || predecessor == successor.rc() ) {\n+                throw new GATKException(\"can't self-join\");\n+            }\n+            this.id = id;\n+            final StringBuilder sb = new StringBuilder(predecessor.getSequence());\n+            final CharSequence successorSequence = successor.getSequence();\n+            sb.append(successorSequence.subSequence(Kmer.KSIZE - 1, successorSequence.length()));\n+            this.sequence = sb.toString();\n+            this.maxObservations =\n+                    Math.max(predecessor.getMaxObservations(), successor.getMaxObservations());\n+            this.firstKmer = predecessor.getFirstKmer();\n+            this.lastKmer = successor.getLastKmer();\n+            this.predecessors = new ArrayList<>(predecessor.getPredecessors().size());\n+            this.successors = new ArrayList<>(successor.getSuccessors().size());\n+            this.rc = new ContigRCImpl(this);\n+\n+            // fix predecessor linkages to point to new contig\n+            for ( final Contig predPredecessor : predecessor.getPredecessors() ) {\n+                if ( predPredecessor == successor ) {\n+                    predecessors.add(this);\n+                } else if ( predPredecessor == predecessor.rc() ) {\n+                    predecessors.add(rc);\n+                } else {\n+                    predecessors.add(predPredecessor);\n+                    final List<Contig> successors = predPredecessor.getSuccessors();\n+                    successors.set(successors.indexOf(predecessor), this);\n+                }\n+            }\n+\n+            // fix successor linkages to point to new contig\n+            for ( final Contig succSuccessor : successor.getSuccessors() ) {\n+                if ( succSuccessor == predecessor ) {\n+                    successors.add(this);\n+                } else if ( succSuccessor == successor.rc() ) {\n+                    successors.add(rc);\n+                } else {\n+                    successors.add(succSuccessor);\n+                    final List<Contig> predecessors = succSuccessor.getPredecessors();\n+                    predecessors.set(predecessors.indexOf(successor), this);\n+                }\n+            }\n+        }\n+\n+        @Override public int getId() { return id; }\n+        @Override public CharSequence getSequence() { return sequence; }\n+        @Override public int getMaxObservations() { return maxObservations; }\n+        @Override public KmerAdjacency getFirstKmer() { return firstKmer; }\n+        @Override public KmerAdjacency getLastKmer() { return lastKmer; }\n+        @Override public List<Contig> getPredecessors() { return predecessors; }\n+        @Override public List<Contig> getSuccessors() { return successors; }\n+        @Override public int getComponentId() { return componentId; }\n+        public void setComponentId( final int id ) { this.componentId = id; }\n+        @Override public int size() { return sequence.length(); }\n+        @Override public Contig rc() { return rc; }\n+        @Override public boolean isCyclic() { return cyclic; }\n+        @Override public void setCyclic( final boolean cyclic ) { this.cyclic = cyclic; }\n+        @Override public boolean isCut() { return cut; }\n+        @Override public void setCut( final boolean cut ) { this.cut = cut; }\n+        @Override public boolean isCanonical() { return true; }\n+        @Override public ContigImpl canonical() { return this; }\n+        @Override public String toString() { return \"c\" + id; }\n+    }\n+\n+    /**\n+     * Implementation of Contig for the reverse-complement of some other Contig.\n+     * Which one is the \"real\" Contig, and which is the \"RC\" is completely arbitrary, since there\n+     * is no notion of canonical for Contigs.\n+     **/\n+    public static final class ContigRCImpl implements Contig {\n+        private final CharSequence sequence;\n+        private final List<Contig> predecessors;\n+        private final List<Contig> successors;\n+        private final ContigImpl rc;\n+\n+        public ContigRCImpl( final ContigImpl contig ) {\n+            this.sequence = new SequenceRC(contig.getSequence());\n+            this.predecessors = new ContigListRC(contig.getSuccessors());\n+            this.successors = new ContigListRC(contig.getPredecessors());\n+            this.rc = contig;\n+        }\n+\n+        @Override public int getId() { return ~rc.getId(); }\n+        @Override public CharSequence getSequence() { return sequence; }\n+        @Override public int getMaxObservations() { return rc.getMaxObservations(); }\n+        @Override public KmerAdjacency getFirstKmer() { return rc.getLastKmer().rc(); }\n+        @Override public KmerAdjacency getLastKmer() { return rc.getFirstKmer().rc(); }\n+        @Override public List<Contig> getPredecessors() { return predecessors; }\n+        @Override public List<Contig> getSuccessors() { return successors; }\n+        @Override public int getComponentId() { return rc.getComponentId(); }\n+        @Override public int size() { return sequence.length(); }\n+        @Override public Contig rc() { return rc; }\n+        @Override public boolean isCyclic() { return rc.isCyclic(); }\n+        @Override public void setCyclic( final boolean cyclic ) { rc.setCyclic(cyclic); }\n+        @Override public boolean isCut() { return rc.isCut(); }\n+        @Override public void setCut( final boolean cut ) { rc.setCut(cut); }\n+        @Override public boolean isCanonical() { return false; }\n+        @Override public ContigImpl canonical() { return rc; }\n+        @Override public String toString() { return rc.toString() + \"RC\"; }\n+    }\n+\n+    /** A CharSequence that is a view of the reverse-complement of another sequence. **/\n+    public static final class SequenceRC implements CharSequence, Comparable<CharSequence> {\n+        private final int lenLess1;\n+        private final CharSequence sequence;\n+\n+        public SequenceRC( final CharSequence sequence ) {\n+            this.lenLess1 = sequence.length() - 1;\n+            this.sequence = sequence;\n+        }\n+\n+        @Override public int length() { return sequence.length(); }\n+        @Override public char charAt( final int index ) {\n+            final char result;\n+            switch ( Character.toUpperCase(sequence.charAt(lenLess1 - index)) ) {\n+                case 'A': result = 'T'; break;\n+                case 'C': result = 'G'; break;\n+                case 'G': result = 'C'; break;\n+                case 'T': result = 'A'; break;\n+                default: result = 'N'; break;\n+            }\n+            return result;\n+        }\n+        @Override public CharSequence subSequence( final int start, final int end ) {\n+            return new StringBuilder(end - start).append(this, start, end).toString();\n+        }\n+        @Override public String toString() { return new StringBuilder(this).toString(); }\n+\n+        @Override public int compareTo( final CharSequence charSequence ) {\n+            final int len1 = length();\n+            final int len2 = charSequence.length();\n+            final int cmpLen = Math.min(len1, len2);\n+            for ( int idx = 0; idx != cmpLen; ++idx ) {\n+                final char char1 = charAt(idx);\n+                final char char2 = Character.toUpperCase(charSequence.charAt(idx));\n+                if ( char1 > char2 ) return 1;\n+                if ( char1 < char2 ) return -1;\n+            }\n+            return Integer.compare(len1, len2);\n+        }\n+    }\n+\n+    /** A list of Contigs that presents a reverse-complemented view of a List of Contigs. **/\n+    public static final class ContigListRC extends AbstractList<Contig> {\n+        private final List<Contig> contigList;\n+\n+        public ContigListRC( final List<Contig> contigList ) {\n+            this.contigList = contigList;\n+        }\n+\n+        @Override public Contig get( final int index ) {\n+            return contigList.get(reflectIndex(index)).rc();\n+        }\n+        @Override public int size() { return contigList.size(); }\n+        @Override public Contig set( final int index, final Contig contig ) {\n+            return contigList.set(reflectIndex(index), contig.rc()).rc();\n+        }\n+        @Override public void add( final int index, final Contig contig ) {\n+            contigList.add(reflectIndex(index), contig.rc());\n+        }\n+        @Override public Contig remove( final int index ) {\n+            return contigList.remove(reflectIndex(index)).rc();\n+        }\n+\n+        private int reflectIndex( final int index ) { return size() - 1 - index; }\n+    }\n+\n+    /** A single-Contig portion of a path across the assembly graph. **/\n+    public interface PathPart {\n+        Contig getContig(); // will be null for PathParts that depart from the graph (PathPartGap)\n+        CharSequence getSequence(); // will be null for PathParts on the graph (PathPartContig)\n+        void extend( final char call );\n+        int getStart();\n+        int getStop();\n+        boolean isGap();\n+        int getLength();\n+        PathPart rc();\n+        char getFirstCall();\n+        char getLastCall();\n+        default boolean startsAtBeginning() { return getStart() == 0; }\n+        default boolean stopsAtEnd() { return getStop() + Kmer.KSIZE - 1 == getContig().size(); }\n+    }\n+\n+    /** A part of a path that isn't present in the graph. **/\n+    public static final class PathPartGap implements PathPart {\n+        private final StringBuilder sequence = new StringBuilder();\n+\n+        public PathPartGap( final KmerAdjacency kmer ) { sequence.append(kmer.toString()); }\n+        private PathPartGap( final CharSequence sequence ) { this.sequence.append(sequence); }\n+\n+        @Override public Contig getContig() { return null; }\n+        @Override public CharSequence getSequence() { return sequence.toString(); }\n+        @Override public void extend( final char call ) { sequence.append(call); }\n+        @Override public int getStart() { return 0; }\n+        @Override public int getStop() { return sequence.length(); }\n+        @Override public boolean isGap() { return true; }\n+        @Override public int getLength() { return sequence.length() - Kmer.KSIZE + 1; }\n+        @Override public PathPart rc() { return new PathPartGap(new SequenceRC(sequence)); }\n+        @Override public char getFirstCall() { return sequence.charAt(Kmer.KSIZE - 1); }\n+        @Override public char getLastCall() {\n+            return sequence.charAt(sequence.length() - Kmer.KSIZE + 1);\n+        }\n+    }\n+\n+    /** A part of a path that is present as a sub-sequence of some Contig. **/\n+    public static final class PathPartContig implements PathPart {\n+        private final Contig contig;\n+        private final int start;\n+        private int stop;\n+\n+        public PathPartContig( final Contig contig, final int start ) {\n+            this(contig, start, start+1);\n+        }\n+        public PathPartContig( final Contig contig, final int start, final int stop ) {\n+            this.contig = contig;\n+            this.start = start;\n+            this.stop = stop;\n+        }\n+\n+        @Override public Contig getContig() { return contig; }\n+        @Override public String getSequence() { return null; }\n+        @Override public void extend( final char call ) { stop += 1; }\n+        @Override public int getStart() { return start; }\n+        @Override public int getStop() { return stop; }\n+        @Override public boolean isGap() { return false; }\n+        @Override public int getLength() { return stop - start; }\n+        @Override public PathPart rc() {\n+            final int revBase = contig.size() - Kmer.KSIZE + 1;\n+            return new PathPartContig(contig.rc(), revBase - stop, revBase - start);\n+        }\n+        @Override public char getFirstCall() {\n+            return getContig().getSequence().charAt(start + Kmer.KSIZE - 1);\n+        }\n+        @Override public char getLastCall() { return getContig().getSequence().charAt(stop - 1); }\n+    }\n+\n+    /** A path through the assembly graph for something (probably a read). **/\n+    public static final class Path {\n+        private final List<PathPart> parts;\n+\n+        public Path( final byte[] calls,\n+                     final KmerSet<KmerAdjacency> kmerAdjacencySet ) {\n+            parts = new ArrayList<>();\n+            long kVal = 0;\n+            int count = 0;\n+            PathPart currentPathPart = null;\n+            for ( int idx = 0; idx != calls.length; ++idx ) {\n+                final char call = (char)calls[idx];\n+                kVal <<= 2;\n+                switch ( call ) {\n+                    case 'C': case 'c': kVal += 1; break;\n+                    case 'G': case 'g': kVal += 2; break;\n+                    case 'T': case 't': kVal += 3; break;\n+                }\n+                if ( ++count >= Kmer.KSIZE ) {\n+                    final KmerAdjacency kmer = KmerAdjacencyImpl.find(kVal, kmerAdjacencySet);\n+                    // if we fail to look up the kmer\n+                    if ( kmer == null ) {\n+                        if ( currentPathPart == null ) {\n+                            // if there's no current path part, just create the 1st one as a PathPartGap\n+                            currentPathPart = new PathPartGap(new KmerAdjacencyImpl(kVal));\n+                            parts.add(currentPathPart);\n+                        } else if ( currentPathPart.isGap() ) {\n+                            // if the current path part is a PathPartGap, just extend it\n+                            currentPathPart.extend(call);\n+                        } else {\n+                            // new PathPartGap\n+                            currentPathPart = new PathPartGap(new KmerAdjacencyImpl(kVal));\n+                            parts.add(currentPathPart);\n+                        }\n+                    } else {\n+                        // we've found our kmer\n+                        final Contig contig = kmer.getContig();\n+                        if ( currentPathPart == null ) {\n+                            // we've looked up a kmer, but don't have a current path part -- create one\n+                            currentPathPart = new PathPartContig(contig, kmer.getContigOffset());\n+                            parts.add(currentPathPart);\n+                        } else if ( contig == currentPathPart.getContig() ) {\n+                            // our lookup is on the current path part's contig -- extend it\n+                            final int kmerOffset = kmer.getContigOffset();\n+                            final int curStop = currentPathPart.getStop();\n+                            if ( kmerOffset == curStop ) {\n+                                currentPathPart.extend(call);\n+                            } else if ( kmerOffset == 0 && contig.getNKmers() == curStop ) {\n+                                // cycle onto same contig\n+                                currentPathPart = new PathPartContig(contig, 0);\n+                                parts.add(currentPathPart);\n+                            } else {\n+                                // weird:  kmer is non-contiguous.  start a new path part after a zero-length gap\n+                                parts.add(zeroLengthGap(currentPathPart));\n+                                currentPathPart = new PathPartContig(contig, kmerOffset);\n+                                parts.add(currentPathPart);\n+                            }\n+                        } else {\n+                            final int kmerContigOffset = kmer.getContigOffset();\n+                            if ( currentPathPart.isGap() ) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e2201c1ef4f8ba71f17e169f07756cfe2f1ecb49"}, "originalPosition": 2050}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxMjcxNTk0NQ==", "bodyText": "Yes.  Exactly.  I'll sprinkle in some more comments.", "url": "https://github.com/broadinstitute/gatk/pull/6989#discussion_r612715945", "createdAt": "2021-04-13T19:22:28Z", "author": {"login": "tedsharpe"}, "path": "src/main/java/org/broadinstitute/hellbender/tools/LocalAssembler.java", "diffHunk": "@@ -0,0 +1,2306 @@\n+package org.broadinstitute.hellbender.tools;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import htsjdk.samtools.Cigar;\n+import htsjdk.samtools.CigarElement;\n+import htsjdk.samtools.CigarOperator;\n+import htsjdk.samtools.SAMUtils;\n+import org.broadinstitute.barclay.argparser.Argument;\n+import org.broadinstitute.barclay.argparser.BetaFeature;\n+import org.broadinstitute.barclay.argparser.CommandLineProgramProperties;\n+import org.broadinstitute.barclay.help.DocumentedFeature;\n+import org.broadinstitute.hellbender.cmdline.StandardArgumentDefinitions;\n+import org.broadinstitute.hellbender.cmdline.programgroups.CoverageAnalysisProgramGroup;\n+import org.broadinstitute.hellbender.exceptions.GATKException;\n+import org.broadinstitute.hellbender.tools.walkers.PairWalker;\n+import org.broadinstitute.hellbender.utils.SimpleInterval;\n+import org.broadinstitute.hellbender.utils.collections.HopscotchSet;\n+import org.broadinstitute.hellbender.utils.gcs.BucketUtils;\n+import org.broadinstitute.hellbender.utils.read.GATKRead;\n+\n+import java.io.BufferedWriter;\n+import java.io.FileWriter;\n+import java.io.IOException;\n+import java.io.OutputStreamWriter;\n+import java.util.*;\n+import java.util.zip.GZIPOutputStream;\n+\n+@DocumentedFeature\n+@CommandLineProgramProperties(\n+        summary = \"experiment\",\n+        oneLineSummary = \"experiment\",\n+        usageExample = \"gatk LocalAssembler\",\n+        programGroup = CoverageAnalysisProgramGroup.class\n+)\n+@BetaFeature\n+public class LocalAssembler extends PairWalker {\n+    public static final byte QMIN = 25;\n+    public static final int MIN_THIN_OBS = 4;\n+    public static final int MIN_GAPFILL_COUNT = 3;\n+    public static final int TOO_MANY_TRAVERSALS = 100000;\n+    public static final int TOO_MANY_SCAFFOLDS = 50000;\n+    public static final int MIN_SV_SIZE = 50;\n+\n+    @Argument(fullName=StandardArgumentDefinitions.OUTPUT_LONG_NAME,\n+            shortName=StandardArgumentDefinitions.OUTPUT_SHORT_NAME,\n+            doc=\"Write outputs to this file name prefix\", optional = true)\n+    public static String output;\n+\n+    @Argument(fullName=\"assembly-name\", doc=\"name of assembly used as a prefix for traversal names\")\n+    public static String assemblyName;\n+\n+    private final List<GATKRead> reads = new ArrayList<>();\n+\n+    @Override public boolean requiresIntervals() { return true; }\n+\n+    @Override public void apply( final GATKRead read, final GATKRead mate ) {\n+        trimOverruns(read, mate);\n+        reads.add(read);\n+        reads.add(mate);\n+    }\n+\n+    @Override public void applyUnpaired( final GATKRead read ) {\n+        reads.add(read);\n+    }\n+\n+    @Override public Object onTraversalSuccess() {\n+        super.onTraversalSuccess(); // flush any incomplete pairs\n+\n+        final int regionSize = getTraversalIntervals().stream().mapToInt(SimpleInterval::size).sum();\n+        final KmerSet<KmerAdjacency> kmerAdjacencySet = new KmerSet<>(10 * regionSize);\n+        kmerizeReads(reads, kmerAdjacencySet);\n+        List<ContigImpl> contigs = buildContigs(kmerAdjacencySet);\n+        connectContigs(contigs);\n+\n+        removeThinContigs(contigs, kmerAdjacencySet);\n+        weldPipes(contigs);\n+        markComponents(contigs);\n+\n+        if ( fillGaps(kmerAdjacencySet, reads) ) {\n+            contigs = buildContigs(kmerAdjacencySet);\n+            connectContigs(contigs);\n+            removeThinContigs(contigs, kmerAdjacencySet);\n+            weldPipes(contigs);\n+            markComponents(contigs);\n+        }\n+\n+        markCycles(contigs);\n+\n+        final String outputFilePrefix = output != null ? output : assemblyName;\n+        final List<Path> readPaths = pathReads(kmerAdjacencySet, reads);\n+        final Map<Contig,List<TransitPairCount>> contigTransitsMap =\n+                collectTransitPairCounts(contigs, readPaths);\n+        final String traversalsFilename = outputFilePrefix + \".traversals.fa.gz\";\n+        try {\n+            final List<Traversal> allTraversals =\n+                    new ArrayList<>(traverseAllPaths(contigs, readPaths, contigTransitsMap));\n+            writeTraversals(allTraversals, traversalsFilename);\n+            try {\n+                final String scaffoldsFileName = outputFilePrefix + \".scaffolds.fa.gz\";\n+                writeTraversals(createScaffolds(allTraversals), scaffoldsFileName);\n+            } catch ( final AssemblyTooComplexException x ) {\n+                logger.warn(\"Assembly too complex for scaffolding.\");\n+            }\n+        } catch ( final AssemblyTooComplexException x ) {\n+            logger.warn(\"Assembly too complex.  Writing contigs as traversals in \" +\n+                    traversalsFilename + \".\");\n+            final Collection<Traversal> contigTraversals = new ArrayList<>(contigs.size());\n+            for ( final Contig contig : contigs ) {\n+                contigTraversals.add(new Traversal(Collections.singletonList(contig)));\n+            }\n+            writeTraversals(contigTraversals, traversalsFilename);\n+        }\n+\n+        contigs.sort(Comparator.comparingInt(ContigImpl::getId));\n+        writeDOT(contigs, outputFilePrefix + \".assembly.dot\");\n+        writeContigs(contigs, outputFilePrefix + \".contigs.txt.gz\");\n+        writePaths(readPaths, outputFilePrefix + \".paths.txt.gz\");\n+        writeReads(reads, outputFilePrefix + \".reads.fastq.gz\");\n+        return null;\n+    }\n+\n+    /** trim read pairs of base calls that have gone past the end of a short fragment */\n+    private void trimOverruns( final GATKRead read, final GATKRead mate ) {\n+        // if both mapped and they're on different strands\n+        if ( !read.isUnmapped() && !mate.isUnmapped() &&\n+                read.isReverseStrand() != mate.isReverseStrand() ) {\n+            // and both start within 1 base on the ref\n+            if ( Math.abs(read.getStart() - read.getMateStart()) <= 1 ) {\n+                // and both end within 1 base\n+                final int readRefLen = read.getCigar().getReferenceLength();\n+                final int mateRefLen = mate.getCigar().getReferenceLength();\n+                if ( Math.abs(readRefLen - mateRefLen) <= 1 ) {\n+                    if ( mate.isReverseStrand() ) {\n+                        trimClips(read, mate);\n+                    } else {\n+                        trimClips(mate, read);\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    private void trimClips( final GATKRead fwd, final GATKRead rev ) {\n+        final List<CigarElement> fwdElements = fwd.getCigarElements();\n+        final List<CigarElement> revElements = rev.getCigarElements();\n+        final int lastElementIdx = fwdElements.size() - 1;\n+        final CigarElement fwdLastElement = fwdElements.get(lastElementIdx);\n+        final CigarElement revFirstElement = revElements.get(0);\n+        if ( fwdLastElement.getOperator() == CigarOperator.S &&\n+                revFirstElement.getOperator() == CigarOperator.S ) {\n+            final byte[] fwdBases = fwd.getBasesNoCopy();\n+            final int lastElementLen = fwdLastElement.getLength();\n+            fwd.setBases(Arrays.copyOfRange(fwdBases, 0, fwdBases.length - lastElementLen));\n+            final byte[] fwdQuals = fwd.getBaseQualitiesNoCopy();\n+            if ( fwdQuals.length > 0 ) {\n+                final int qualsLen = fwdQuals.length - lastElementLen;\n+                fwd.setBaseQualities(Arrays.copyOfRange(fwdQuals, 0, qualsLen));\n+            }\n+            final List<CigarElement> newFwdElements = new ArrayList<>(fwdElements);\n+            newFwdElements.set(lastElementIdx, new CigarElement(lastElementLen, CigarOperator.H));\n+            fwd.setCigar(new Cigar(newFwdElements));\n+\n+            final byte[] revBases = rev.getBasesNoCopy();\n+            final int firstElementLen = revFirstElement.getLength();\n+            rev.setBases(Arrays.copyOfRange(revBases, firstElementLen, revBases.length));\n+            final byte[] revQuals = rev.getBaseQualitiesNoCopy();\n+            if ( revQuals.length > 0 ) {\n+                rev.setBaseQualities(Arrays.copyOfRange(revQuals, firstElementLen, revQuals.length));\n+            }\n+            final List<CigarElement> newRevElements = new ArrayList<>(revElements);\n+            newRevElements.set(0, new CigarElement(firstElementLen, CigarOperator.H));\n+            rev.setCigar(new Cigar(newRevElements));\n+        }\n+    }\n+\n+    @VisibleForTesting\n+    static void kmerizeReads( final List<GATKRead> reads,\n+                              final KmerSet<KmerAdjacency> kmerAdjacencySet ) {\n+        for ( final GATKRead read : reads ) {\n+            final byte[] calls = read.getBasesNoCopy();\n+            final byte[] quals = read.getBaseQualitiesNoCopy();\n+            KmerAdjacency.kmerize(calls, quals, QMIN, kmerAdjacencySet);\n+        }\n+    }\n+\n+    /** gather unbranched strings of kmers into contigs **/\n+    @VisibleForTesting\n+    static List<ContigImpl> buildContigs( final KmerSet<KmerAdjacency> kmerAdjacencySet ) {\n+        // gather strings of kmers that have a single predecessor and single successor into contigs\n+        final List<ContigImpl> contigs = new ArrayList<>();\n+        int nContigs = 0;\n+        for ( final KmerAdjacency kmerAdjacency : kmerAdjacencySet ) {\n+            if ( kmerAdjacency.getContig() == null ) {\n+                ContigImpl contig = null;\n+                final KmerAdjacency predecessor = kmerAdjacency.getSolePredecessor();\n+                if ( predecessor == null ||\n+                        predecessor.getSuccessorCount() > 1 ||\n+                        predecessor == kmerAdjacency.rc() ) {\n+                    contig = new ContigImpl(++nContigs, kmerAdjacency);\n+                } else {\n+                    final KmerAdjacency successor = kmerAdjacency.getSoleSuccessor();\n+                    if ( successor == null ||\n+                            successor.getPredecessorCount() > 1 ||\n+                            successor == kmerAdjacency.rc() ) {\n+                        contig = new ContigImpl(++nContigs, kmerAdjacency.rc());\n+                    }\n+                }\n+                if ( contig != null ) {\n+                    contigs.add(contig);\n+                }\n+            }\n+        }\n+\n+        // if there are smooth circles like a plasmid, gather them together as a contig, too\n+        for ( final KmerAdjacency kmerAdjacency : kmerAdjacencySet ) {\n+            if ( kmerAdjacency.getContig() == null ) {\n+                contigs.add(new ContigImpl(++nContigs, kmerAdjacency));\n+            }\n+        }\n+\n+        return contigs;\n+    }\n+\n+    /** connect contigs when the final kmer of one contig is adjacent to the inital contig of another **/\n+    @VisibleForTesting\n+    static void connectContigs( final List<ContigImpl> contigs ) {\n+        final int nContigs = contigs.size();\n+        final KmerSet<ContigEndKmer> contigEnds = new KmerSet<>(2*nContigs);\n+        for ( int contigId = 0; contigId != nContigs; ++contigId ) {\n+            final ContigImpl contig = contigs.get(contigId);\n+            final KmerAdjacency fwdKmer = contig.getFirstKmer();\n+            final KmerAdjacency revKmer = contig.getLastKmer().rc();\n+            if ( fwdKmer == revKmer ) {\n+                contigEnds.add(new ContigEndKmer(fwdKmer.getKVal(), contig, ContigOrientation.BOTH));\n+            } else {\n+                contigEnds.add(new ContigEndKmer(fwdKmer.getKVal(), contig, ContigOrientation.FWD));\n+                contigEnds.add(new ContigEndKmer(revKmer.getKVal(), contig, ContigOrientation.REV));\n+            }\n+        }\n+\n+        for ( int contigId = 0; contigId != nContigs; ++contigId ) {\n+            final Contig contig = contigs.get(contigId);\n+\n+            final KmerAdjacency start = contig.getFirstKmer();\n+            final int predecessorCount = start.getPredecessorCount();\n+            if ( predecessorCount > 0 ) {\n+                final List<Contig> predecessors = contig.getPredecessors();\n+                final int mask = start.getPredecessorMask();\n+                for ( int call = 0; call != 4; ++call ) {\n+                    if ( (mask & (1 << call)) != 0 ) {\n+                        final long kVal =\n+                                KmerAdjacency.reverseComplement(start.getPredecessorVal(call));\n+                        final ContigEndKmer contigEndKmer = contigEnds.find(new Kmer(kVal));\n+                        if ( contigEndKmer == null ) {\n+                            throw new GATKException(\"missing contig end kmer\");\n+                        }\n+                        switch ( contigEndKmer.getContigOrientation() ) {\n+                            case FWD:\n+                                predecessors.add(contigEndKmer.getContig().rc());\n+                                break;\n+                            case REV:\n+                                predecessors.add(contigEndKmer.getContig());\n+                                break;\n+                            case BOTH:\n+                                predecessors.add(contigEndKmer.getContig());\n+                                predecessors.add(contigEndKmer.getContig().rc());\n+                                break;\n+                        }\n+                    }\n+                }\n+            }\n+\n+            final KmerAdjacency end = contig.getLastKmer();\n+            final int successorCount = end.getSuccessorCount();\n+            if ( successorCount > 0 ) {\n+                final List<Contig> successors = contig.getSuccessors();\n+                final int mask = end.getSuccessorMask();\n+                for ( int call = 0; call != 4; ++call ) {\n+                    if ( (mask & (1 << call)) != 0 ) {\n+                        final long kVal = end.getSuccessorVal(call);\n+                        final ContigEndKmer contigEndKmer = contigEnds.find(new Kmer(kVal));\n+                        if ( contigEndKmer == null ) {\n+                            throw new GATKException(\"missing contig end kmer\");\n+                        }\n+                        switch ( contigEndKmer.getContigOrientation() ) {\n+                            case FWD:\n+                                successors.add(contigEndKmer.getContig());\n+                                break;\n+                            case REV:\n+                                successors.add(contigEndKmer.getContig().rc());\n+                                break;\n+                            case BOTH:\n+                                successors.add(contigEndKmer.getContig());\n+                                successors.add(contigEndKmer.getContig().rc());\n+                                break;\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    /** remove contigs that have little evidence **/\n+    @VisibleForTesting\n+    static void removeThinContigs( final List<ContigImpl> contigs,\n+                                           final KmerSet<KmerAdjacency> kmerAdjacencySet ) {\n+        contigs.sort(Comparator.comparingInt(ContigImpl::getMaxObservations));\n+        boolean contigRemoved;\n+        do {\n+            // figure out which contigs are cut points\n+            // i.e., those contigs which, if removed, would result in a graph with more connected components\n+            final int nContigs = contigs.size();\n+            final Map<Contig, CutData> cutDataMap = new HashMap<>(nContigs * 3);\n+\n+            for ( final ContigImpl contig : contigs ) {\n+                if ( cutDataMap.containsKey(contig) ) {\n+                    continue;\n+                }\n+\n+                cutDataMap.put(contig, new CutData());\n+                int children = 0;\n+                for ( final Contig nextContig : contig.getSuccessors() ) {\n+                    if ( !cutDataMap.containsKey(nextContig) ) {\n+                        findCuts(nextContig, contig, cutDataMap);\n+                        children += 1;\n+                    }\n+                }\n+                for ( final Contig nextContig : contig.getPredecessors() ) {\n+                    if ( !cutDataMap.containsKey(nextContig) ) {\n+                        findCuts(nextContig, contig, cutDataMap);\n+                        children += 1;\n+                    }\n+                }\n+                if ( children >= 2 ) {\n+                    contig.setCut(true);\n+                }\n+            }\n+\n+            // remove poorly attested (low max observations) contigs, unless they are cut points\n+            contigRemoved = false;\n+            final Iterator<ContigImpl> itr = contigs.iterator();\n+            while ( itr.hasNext() ) {\n+                final Contig contig = itr.next();\n+                if ( contig.getMaxObservations() < MIN_THIN_OBS && !contig.isCut() ) {\n+                    unlinkContig(contig, kmerAdjacencySet);\n+                    itr.remove();\n+                    contigRemoved = true;\n+                    break;\n+                }\n+            }\n+        } while ( contigRemoved );\n+        contigs.sort(Comparator.comparingInt(ContigImpl::getId));\n+    }\n+\n+    private static CutData findCuts( final Contig contig,\n+                                     final Contig parent,\n+                                     final Map<Contig, CutData> cutDataMap ) {\n+        final CutData cutData = new CutData();\n+        cutDataMap.put(contig, cutData);\n+        for ( final Contig nextContig : contig.getSuccessors() ) {\n+            if ( nextContig == parent ) {\n+                continue;\n+            }\n+            CutData nextCutData = cutDataMap.get(nextContig);\n+            if ( nextCutData != null ) {\n+                cutData.minVisitNum = Math.min(cutData.minVisitNum, nextCutData.visitNum);\n+            } else {\n+                nextCutData = findCuts(nextContig, contig, cutDataMap);\n+                cutData.minVisitNum = Math.min(cutData.minVisitNum, nextCutData.minVisitNum);\n+                if ( nextCutData.minVisitNum >= cutData.visitNum ) {\n+                    contig.setCut(true);\n+                }\n+            }\n+        }\n+        for ( final Contig nextContig : contig.getPredecessors() ) {\n+            if ( nextContig == parent ) {\n+                continue;\n+            }\n+            CutData nextCutData = cutDataMap.get(nextContig);\n+            if ( nextCutData != null ) {\n+                cutData.minVisitNum = Math.min(cutData.minVisitNum, nextCutData.visitNum);\n+            } else {\n+                nextCutData = findCuts(nextContig, contig, cutDataMap);\n+                cutData.minVisitNum = Math.min(cutData.minVisitNum, nextCutData.minVisitNum);\n+                if ( nextCutData.minVisitNum >= cutData.visitNum ) {\n+                    contig.setCut(true);\n+                }\n+            }\n+        }\n+        return cutData;\n+    }\n+\n+    @VisibleForTesting\n+    static void unlinkContig( final Contig contig,\n+                                      final KmerSet<KmerAdjacency> kmerAdjacencySet ) {\n+        final KmerAdjacency firstKmer = contig.getFirstKmer();\n+        final int firstKmerFinalCall = firstKmer.getFinalCall();\n+        for ( final Contig predecessor : contig.getPredecessors() ) {\n+            if ( predecessor != contig && predecessor != contig.rc() ) {\n+                predecessor.getLastKmer().removeSuccessor(firstKmerFinalCall, kmerAdjacencySet);\n+                if ( !predecessor.getSuccessors().remove(contig) ) {\n+                    throw new GATKException(\"failed to find predecessor link\");\n+                }\n+            }\n+        }\n+\n+        final KmerAdjacency lastKmer = contig.getLastKmer();\n+        final int lastKmerInitialCall = lastKmer.getInitialCall();\n+        for ( final Contig successor : contig.getSuccessors() ) {\n+            if ( successor != contig && successor != contig.rc() ) {\n+                successor.getFirstKmer().removePredecessor(lastKmerInitialCall, kmerAdjacencySet);\n+                if ( !successor.getPredecessors().remove(contig) ) {\n+                    throw new GATKException(\"failed to find successor link\");\n+                }\n+            }\n+        }\n+\n+        KmerAdjacency nextKmer = firstKmer;\n+        KmerAdjacency kmer;\n+        do {\n+            kmer = nextKmer;\n+            nextKmer = kmer.getSoleSuccessor();\n+            kmerAdjacencySet.remove(kmer.canonical());\n+        } while ( kmer != lastKmer );\n+    }\n+\n+    private static void updateKmerContig( final KmerAdjacency firstKmer,\n+                                          final KmerAdjacency lastKmer,\n+                                          final Contig contig ) {\n+        int offset = 0;\n+        for ( KmerAdjacency kmer = firstKmer; kmer != lastKmer; kmer = kmer.getSoleSuccessor() ) {\n+            if ( kmer == null ) {\n+                throw new GATKException(\"contig does not have a flat pipeline of kmers\");\n+            }\n+            kmer.clearContig();\n+            kmer.setContigOffset(contig, offset++);\n+        }\n+        lastKmer.clearContig();\n+        lastKmer.setContigOffset(contig, offset);\n+        if ( offset + Kmer.KSIZE != contig.size() ) {\n+            throw new GATKException(\"kmer chain length does not equal contig size\");\n+        }\n+    }\n+\n+    /** replace adjacent contigs without branches with a single, larger contig **/\n+    @VisibleForTesting\n+    static void weldPipes( final List<ContigImpl> contigs ) {\n+        for ( int contigIdx = 0; contigIdx != contigs.size(); ++contigIdx ) {\n+            final ContigImpl contig = contigs.get(contigIdx);\n+            if ( contig.getSuccessors().size() == 1 ) {\n+                final Contig successor = contig.getSuccessors().get(0);\n+                if ( successor != contig && successor != contig.rc() &&\n+                        successor.getPredecessors().size() == 1 ) {\n+                    contigs.set(contigIdx, join(contig.getId(), contig, successor));\n+                    if ( !contigs.remove(successor.canonical()) ) {\n+                        throw new GATKException(\"successor linkage is messed up\");\n+                    }\n+                    contigIdx -= 1; // reconsider the new contig -- there might be more joining possible\n+                    continue;\n+                }\n+            }\n+            if ( contig.getPredecessors().size() == 1 ) {\n+                final Contig predecessor = contig.getPredecessors().get(0);\n+                if ( predecessor != contig && predecessor != contig.rc() &&\n+                        predecessor.getSuccessors().size() == 1 ) {\n+                    contigs.set(contigIdx, join(contig.getId(), predecessor, contig));\n+                    if ( !contigs.remove(predecessor.canonical()) ) {\n+                        throw new GATKException(\"predecessor linkage is messed up\");\n+                    }\n+                    contigIdx -= 1; // reconsider\n+                }\n+            }\n+        }\n+    }\n+\n+    private static ContigImpl join( final int id, final Contig predecessor, final Contig successor ) {\n+        if ( !checkOverlap(predecessor.getSequence(), successor.getSequence()) ) {\n+                throw new GATKException(\"sequences can't be joined\");\n+        }\n+        final ContigImpl joinedContig = new ContigImpl(id, predecessor, successor);\n+        updateKmerContig(joinedContig.getFirstKmer(), joinedContig.getLastKmer(), joinedContig);\n+        return joinedContig;\n+    }\n+\n+    private static boolean checkOverlap( final CharSequence seq1, final CharSequence seq2 ) {\n+        final int seq1Len = seq1.length();\n+        final CharSequence seq1SubSeq = seq1.subSequence(seq1Len - Kmer.KSIZE + 1, seq1Len);\n+        final CharSequence seq2SubSeq = seq2.subSequence(0, Kmer.KSIZE - 1);\n+        return seq1SubSeq.equals(seq2SubSeq);\n+    }\n+\n+    /** set a unique componentId for every connected group of contigs **/\n+    @VisibleForTesting\n+    static int markComponents( final List<ContigImpl> contigs ) {\n+        for ( final ContigImpl contig : contigs ) {\n+            contig.setComponentId(0);\n+        }\n+\n+        int componentId = 0;\n+        for ( final ContigImpl contig : contigs ) {\n+            if ( contig.getComponentId() == 0 ) {\n+                contig.setComponentId(++componentId);\n+                markSuccessorComponents(contig);\n+                markSuccessorComponents(contig.rc());\n+            }\n+        }\n+        return componentId;\n+    }\n+\n+    private static void markSuccessorComponents( final Contig contig ) {\n+        final int componentId = contig.getComponentId();\n+        for ( final Contig successor : contig.getSuccessors() ) {\n+            if ( successor.getComponentId() == 0 ) {\n+                successor.canonical().setComponentId(componentId);\n+                markSuccessorComponents(successor);\n+                markSuccessorComponents(successor.rc());\n+            }\n+        }\n+    }\n+\n+    @VisibleForTesting\n+    static void markCycles( final List<ContigImpl> contigs ) {\n+        for ( final Contig contig : contigs ) {\n+            contig.setCyclic(false);\n+        }\n+\n+        final int nContigs = contigs.size();\n+        final Deque<Contig> deque = new ArrayDeque<>(nContigs);\n+        final Map<Contig, CutData> cutDataMap = new HashMap<>(nContigs * 3);\n+        for ( final Contig contig : contigs ) {\n+            if ( !cutDataMap.containsKey(contig) ) {\n+                markCyclesRecursion(contig, deque, cutDataMap);\n+            }\n+        }\n+    }\n+\n+    private static CutData markCyclesRecursion( final Contig contig,\n+                                                final Deque<Contig> deque,\n+                                                final Map<Contig, CutData> cutDataMap ) {\n+        final CutData cutData = new CutData();\n+        cutDataMap.put(contig, cutData);\n+        deque.addFirst(contig);\n+\n+        for ( final Contig successor : contig.getSuccessors() ) {\n+            final CutData successorCutData = cutDataMap.get(successor);\n+            if ( successorCutData == null ) {\n+                final int recursionVisitNum =\n+                        markCyclesRecursion(successor, deque, cutDataMap).minVisitNum;\n+                cutData.minVisitNum = Math.min(cutData.minVisitNum, recursionVisitNum);\n+            } else {\n+                cutData.minVisitNum = Math.min(cutData.minVisitNum, successorCutData.visitNum);\n+            }\n+        }\n+\n+        if ( cutData.visitNum == cutData.minVisitNum ) {\n+            Contig tig = deque.removeFirst();\n+            if ( tig == contig ) {\n+                cutDataMap.get(tig).visitNum = Integer.MAX_VALUE;\n+\n+                // single-vertex component -- cyclic only if self-referential\n+                if ( tig.getSuccessors().contains(tig) ) {\n+                    tig.setCyclic(true);\n+                }\n+            } else {\n+                while ( true ) {\n+                    // kill cross-links\n+                    cutDataMap.get(tig).visitNum = Integer.MAX_VALUE;\n+                    tig.setCyclic(true);\n+                    if ( tig == contig ) break;\n+                    tig = deque.removeFirst();\n+                }\n+            }\n+        }\n+        return cutData;\n+    }\n+\n+    @VisibleForTesting\n+    static boolean fillGaps( final KmerSet<KmerAdjacency> kmerAdjacencySet,\n+                             final List<GATKRead> reads ) {\n+        final Map<String, Integer> gapFillCounts = new HashMap<>();\n+        for ( final GATKRead read : reads ) {\n+            final Path path = new Path(read.getBasesNoCopy(), kmerAdjacencySet);\n+            final List<PathPart> parts = path.getParts();\n+            final int lastIdx = parts.size() - 1;\n+            for ( int idx = 1; idx < lastIdx; ++idx ) {\n+                final PathPart pathPart = parts.get(idx);\n+                if ( pathPart.isGap() ) {\n+                    final char prevCall = parts.get(idx - 1).getLastCall();\n+                    final char nextCall = parts.get(idx + 1).getFirstCall();\n+                    String gapFill = prevCall + pathPart.getSequence().toString() + nextCall;\n+                    final SequenceRC gapFillRC = new SequenceRC(gapFill);\n+                    if ( gapFillRC.compareTo(gapFill) < 0 ) {\n+                        gapFill = gapFillRC.toString();\n+                    }\n+                    gapFillCounts.merge(gapFill, 1, Integer::sum);\n+                }\n+            }\n+        }\n+\n+        boolean newKmers = false;\n+        for ( final Map.Entry<String, Integer> entry : gapFillCounts.entrySet() ) {\n+            final int nObservations = entry.getValue();\n+            if ( nObservations >= MIN_GAPFILL_COUNT ) {\n+                KmerAdjacency.kmerize(entry.getKey(), nObservations, kmerAdjacencySet);\n+                newKmers = true;\n+            }\n+        }\n+\n+        if ( newKmers ) {\n+            for ( final KmerAdjacency kmerAdjacency : kmerAdjacencySet ) {\n+                kmerAdjacency.clearContig();\n+            }\n+        }\n+        return newKmers;\n+    }\n+\n+    @VisibleForTesting\n+    static List<Path> pathReads( final KmerSet<KmerAdjacency> kmerAdjacencySet,\n+                          final List<GATKRead> reads ) {\n+        final List<Path> readPaths = new ArrayList<>(reads.size());\n+        for ( final GATKRead read : reads ) {\n+            readPaths.add(new Path(read.getBasesNoCopy(), kmerAdjacencySet));\n+        }\n+        return readPaths;\n+    }\n+\n+    @VisibleForTesting\n+    static Map<Contig,List<TransitPairCount>> collectTransitPairCounts(\n+            final List<ContigImpl> contigs,\n+            final List<Path> readPaths ) {\n+        final Map<Contig,List<TransitPairCount>> contigTransitsMap =\n+                new HashMap<>(3 * contigs.size());\n+        for ( final Path path : readPaths ) {\n+            final List<PathPart> parts = path.getParts();\n+            final int lastPart = parts.size() - 1;\n+            for ( int partIdx = 1; partIdx < lastPart; ++partIdx ) {\n+                final Contig prevContig = parts.get(partIdx - 1).getContig();\n+                if ( prevContig == null ) continue;\n+                final Contig curContig = parts.get(partIdx).getContig();\n+                if ( curContig == null ) {\n+                    partIdx += 1;\n+                    continue;\n+                }\n+                final Contig nextContig = parts.get(partIdx + 1).getContig();\n+                if ( nextContig == null ) {\n+                    partIdx += 2;\n+                    continue;\n+                }\n+                final TransitPairCount tpc = new TransitPairCount(prevContig, nextContig);\n+                final List<TransitPairCount> tpcList =\n+                        contigTransitsMap.computeIfAbsent(curContig, tig -> new ArrayList<>(4));\n+                final int idx = tpcList.indexOf(tpc);\n+                if ( idx != -1 ) {\n+                    tpcList.get(idx).observe();\n+                } else {\n+                    tpcList.add(tpc);\n+                    contigTransitsMap.computeIfAbsent(curContig.rc(), tig -> new ArrayList<>(4))\n+                            .add(tpc.getRC());\n+                }\n+            }\n+        }\n+        return contigTransitsMap;\n+    }\n+\n+    @VisibleForTesting\n+    static Set<Traversal> traverseAllPaths(\n+            final List<ContigImpl> contigs,\n+            final List<Path> readPaths,\n+            final Map<Contig, List<TransitPairCount>> contigTransitsMap ) {\n+        final Set<Traversal> traversalSet = new HashSet<>();\n+        final List<Contig> contigsList = new ArrayList<>();\n+        for ( final Contig contig : contigs ) {\n+            // untransited contigs are sources, sinks, or large contigs that can't be crossed by a read\n+            // build traversals from these\n+            if ( !contigTransitsMap.containsKey(contig) ) {\n+                boolean done = false;\n+                for ( final Contig successor : contig.getSuccessors() ) {\n+                    traverse(successor, contig,\n+                            contigsList, readPaths, contigTransitsMap, traversalSet);\n+                    done = true;\n+                }\n+                for ( final Contig predecessor : contig.getPredecessors() ) {\n+                    traverse(predecessor.rc(), contig.rc(),\n+                            contigsList, readPaths, contigTransitsMap, traversalSet);\n+                    done = true;\n+                }\n+                if ( !done ) { // if there were no predecessors or successors, it stands alone\n+                    addTraversal(new Traversal(Collections.singletonList(contig)), traversalSet);\n+                }\n+            }\n+        }\n+\n+        // look for transits that haven't been traced\n+        for ( final Map.Entry<Contig, List<TransitPairCount>> entry :\n+                contigTransitsMap.entrySet() ) {\n+            for ( final TransitPairCount tpc : entry.getValue() ) {\n+                if ( tpc.getCount() > 0 ) {\n+                    tpc.resetCount();\n+                    final Contig contig = entry.getKey();\n+                    final Set<Traversal> fwdTraversalSet = new HashSet<>();\n+                    traverse(tpc.getNextContig(), contig,\n+                            contigsList, readPaths, contigTransitsMap, fwdTraversalSet);\n+                    final Set<Traversal> revTraversalSet = new HashSet<>();\n+                    traverse(tpc.getPrevContig().rc(), contig.rc(),\n+                            contigsList, readPaths, contigTransitsMap, revTraversalSet);\n+                    for ( final Traversal revTraversal : revTraversalSet ) {\n+                        final Traversal revTraversalRC = revTraversal.rc();\n+                        for ( final Traversal fwdTraversal : fwdTraversalSet ) {\n+                            final int overlap =\n+                                    findMaxOverlap(revTraversalRC.getContigs(), fwdTraversal.getContigs());\n+                            final Traversal combo =\n+                                    Traversal.combineOverlappers(revTraversalRC, fwdTraversal, overlap);\n+                            addTraversal(combo, traversalSet);\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+\n+        return traversalSet;\n+    }\n+\n+    private static int findMaxOverlap( final List<Contig> prefixes, final List<Contig> suffixes ) {\n+        final int nPrefixes = prefixes.size();\n+        final Contig firstSuffix = suffixes.get(0);\n+        if ( !firstSuffix.isCyclic() ) {\n+            return prefixes.get(nPrefixes - 1) == firstSuffix ? 1 : 0;\n+        }\n+        final int nSuffixes = suffixes.size();\n+        for ( int prefixIdx = Math.max(0, nPrefixes - nSuffixes); prefixIdx != nPrefixes; ++prefixIdx ) {\n+            if ( prefixes.get(prefixIdx) == firstSuffix ) {\n+                int suffixIdx = 1;\n+                boolean match = true;\n+                for ( int prefixIdx2 = prefixIdx + 1; prefixIdx2 != nPrefixes; ++prefixIdx2 ) {\n+                    if ( prefixes.get(prefixIdx2) != suffixes.get(suffixIdx++) ) {\n+                        match = false;\n+                        break;\n+                    }\n+                }\n+                if ( match ) {\n+                    return nPrefixes - prefixIdx;\n+                }\n+            }\n+        }\n+        return 0;\n+    }\n+\n+    private static void traverse( final Contig contig,\n+                                  final Contig predecessor,\n+                                  final List<Contig> contigsList,\n+                                  final List<Path> readPaths,\n+                                  final Map<Contig, List<TransitPairCount>> contigTransitsMap,\n+                                  final Set<Traversal> traversalSet ) {\n+        contigsList.add(predecessor);\n+        if ( contig.isCyclic() ) {\n+            traverseCycle(contig, contigsList, readPaths, contigTransitsMap, traversalSet);\n+            contigsList.remove(contigsList.size() - 1);\n+            return;\n+        }\n+        final List<TransitPairCount> transits = contigTransitsMap.get(contig);\n+        boolean done = false;\n+        if ( transits != null ) {\n+            for ( final TransitPairCount tpc : transits ) {\n+                if ( tpc.getPrevContig() == predecessor ) {\n+                    final Contig successor = tpc.getNextContig();\n+                    if ( predecessor == contig.rc() ) {\n+                        final int nContigs = contigsList.size();\n+                        if ( nContigs > 1 ) {\n+                            if ( successor.rc() == contigsList.get(nContigs - 2) ) {\n+                                continue;\n+                            }\n+                        }\n+                    }\n+                    tpc.resetCount();\n+                    traverse(successor, contig, contigsList, readPaths, contigTransitsMap, traversalSet);\n+                    done = true;\n+                }\n+            }\n+        }\n+        if ( !done ) {\n+            contigsList.add(contig);\n+            addTraversal(new Traversal(contigsList), traversalSet);\n+            contigsList.remove(contigsList.size() - 1);\n+        }\n+        contigsList.remove(contigsList.size() - 1);\n+    }\n+\n+    private static void traverseCycle( final Contig contig,\n+                                       final List<Contig> contigsList,\n+                                       final List<Path> readPaths,\n+                                       final Map<Contig, List<TransitPairCount>> contigTransitsMap,\n+                                       final Set<Traversal> traversalSet ) {\n+        contigsList.add(contig);\n+        final int nContigs = contigsList.size();\n+        // the final element of the list is cyclic, if there's a previous element it will be\n+        // non-cyclic, so start there figuring out how far the read paths lead us\n+        final List<List<Contig>> longestPaths =\n+                findLongestPaths(contigsList.subList(Math.max(0, nContigs - 2), nContigs), readPaths);\n+        // didn't get anywhere -- just complete the traversal\n+        if ( longestPaths.isEmpty() ) {\n+            addTraversal(new Traversal(contigsList, true), traversalSet);\n+        } else {\n+            // for each unique extension into the cycle\n+            for ( final List<Contig> path : longestPaths ) {\n+                // don't think this can happen, but still\n+                if ( path.isEmpty() ) {\n+                    addTraversal(new Traversal(contigsList, true), traversalSet);\n+                    continue;\n+                }\n+                final List<Contig> extendedContigsList =\n+                        new ArrayList<>(contigsList.size() + path.size());\n+                extendedContigsList.addAll(contigsList);\n+                // if we didn't get out of the cycle\n+                if ( path.get(path.size() - 1).isCyclic() ) {\n+                    extendedContigsList.addAll(path);\n+                    addTraversal(new Traversal(extendedContigsList, true), traversalSet);\n+                } else {\n+                    // we found a cycle-exiting path, so extend that normally\n+                    for ( final Contig curContig : path ) {\n+                        if ( curContig.isCyclic() ) {\n+                            extendedContigsList.add(curContig);\n+                        } else {\n+                            final Contig prevContig =\n+                                    extendedContigsList.remove(extendedContigsList.size() - 1);\n+                            traverse(curContig, prevContig, extendedContigsList, readPaths,\n+                                    contigTransitsMap, traversalSet);\n+                            extendedContigsList.add(prevContig);\n+                            break;\n+                        }\n+                    }\n+                }\n+                clearTransitPairs(contigTransitsMap, extendedContigsList);\n+            }\n+        }\n+        contigsList.remove(contigsList.size() - 1);\n+    }\n+\n+    private static void clearTransitPairs(\n+            final Map<Contig, List<TransitPairCount>> contigTransitsMap,\n+            final List<Contig> contigsList ) {\n+        final int lastIdx = contigsList.size() - 1;\n+        for ( int idx = 1; idx < lastIdx; ++idx ) {\n+            final List<TransitPairCount> pairCounts = contigTransitsMap.get(contigsList.get(idx));\n+            if ( pairCounts != null ) {\n+                final Contig predecessor = contigsList.get(idx - 1);\n+                final Contig successor = contigsList.get(idx + 1);\n+                for ( final TransitPairCount tpc : pairCounts ) {\n+                    if ( tpc.getPrevContig() == predecessor && tpc.getNextContig() == successor ) {\n+                        tpc.resetCount();\n+                        break;\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    private static void addTraversal( final Traversal traversal,\n+                                      final Set<Traversal> traversalSet ) {\n+        if ( !traversalSet.contains(traversal.rc()) ) {\n+            traversalSet.add(traversal);\n+            if ( traversalSet.size() >= TOO_MANY_TRAVERSALS ) {\n+                throw new AssemblyTooComplexException();\n+            }\n+        }\n+    }\n+\n+    private static List<List<Contig>> findLongestPaths( final List<Contig> toMatch,\n+                                                        final List<Path> readPaths ) {\n+        final List<List<Contig>> results = new ArrayList<>();\n+        for ( final Path path : readPaths ) {\n+            testPath(path, toMatch, results);\n+            testPath(path.rc(), toMatch, results);\n+        }\n+        return results;\n+    }\n+\n+    private static void testPath( final Path path,\n+                                  final List<Contig> toMatch,\n+                                  final List<List<Contig>> results ) {\n+        final List<PathPart> pathParts = path.getParts();\n+        final int nPathParts = pathParts.size();\n+        final List<Contig> pathContigs = new ArrayList<>(nPathParts);\n+        pathParts.forEach(pp -> pathContigs.add(pp.getContig()));\n+        final int matchIdx = Collections.indexOfSubList(pathContigs, toMatch);\n+        if ( matchIdx != -1 ) {\n+            final int suffixIdx = matchIdx + toMatch.size();\n+            if ( suffixIdx < nPathParts ) {\n+                resolveResult(grabParts(pathContigs, suffixIdx), results);\n+            }\n+        }\n+    }\n+\n+    private static List<Contig> grabParts( final List<Contig> pathContigs, final int suffixIdx ) {\n+        final int nPathContigs = pathContigs.size();\n+        Contig prev = pathContigs.get(suffixIdx - 1);\n+        final List<Contig> result = new ArrayList<>(nPathContigs - suffixIdx);\n+        for ( int idx = suffixIdx; idx != nPathContigs; ++idx ) {\n+            final Contig tig = pathContigs.get(idx);\n+            if ( tig == null || !prev.getSuccessors().contains(tig) ) break;\n+            result.add(tig);\n+            prev = tig;\n+        }\n+        return result;\n+    }\n+\n+    private static void resolveResult( final List<Contig> result,\n+                                       final List<List<Contig>> results ) {\n+        final int nResults = results.size();\n+        for ( int idx = 0; idx != nResults; ++idx ) {\n+            final List<Contig> test = results.get(idx);\n+            if ( isPrefix(result, test) ) return;\n+            if ( isPrefix(test, result) ) {\n+                results.set(idx, result);\n+                return;\n+            }\n+        }\n+        results.add(result);\n+    }\n+\n+    private static boolean isPrefix( final List<Contig> list1, final List<Contig> list2 ) {\n+        final int list1Size = list1.size();\n+        final int list2Size = list2.size();\n+        if ( list1Size > list2Size ) return false;\n+        for ( int idx = 0; idx != list1Size; ++idx ) {\n+            if ( list1.get(idx) != list2.get(idx) ) return false;\n+        }\n+        return true;\n+    }\n+\n+    @VisibleForTesting\n+    static Collection<Traversal> createScaffolds( final List<Traversal> allTraversals ) {\n+        removeTriviallyDifferentTraversals(allTraversals);\n+\n+        final int nTraversals = allTraversals.size();\n+        final Map<Contig, List<Integer>> traversalsByFirstContig = new HashMap<>(3 * nTraversals);\n+        for ( int idx = 0; idx != nTraversals; ++idx ) {\n+            final Traversal traversal = allTraversals.get(idx);\n+            traversalsByFirstContig.compute(traversal.getFirstContig(),\n+                    ( k, v ) -> v == null ? new ArrayList<>(3) : v).add(idx);\n+            final Traversal rcTraversal = traversal.rc();\n+            traversalsByFirstContig.compute(rcTraversal.getFirstContig(),\n+                    ( k, v ) -> v == null ? new ArrayList<>(3) : v).add(~idx);\n+        }\n+\n+        final List<Traversal> scaffolds = new ArrayList<>(nTraversals);\n+        final boolean[] touched = new boolean[nTraversals];\n+        for ( int idx = 0; idx != nTraversals; ++idx ) {\n+            if ( !touched[idx] ) {\n+                expandTraversal(idx, touched, traversalsByFirstContig, allTraversals, scaffolds);\n+            }\n+        }\n+        return scaffolds;\n+    }\n+\n+    private static void expandTraversal( final int traversalIdx,\n+                                         final boolean[] touched,\n+                                         final Map<Contig, List<Integer>> traversalsByFirstContig,\n+                                         final List<Traversal> allTraversals,\n+                                         final List<Traversal> scaffolds ) {\n+        final Traversal traversal = allTraversals.get(traversalIdx);\n+        touched[traversalIdx] = true;\n+        final List<Traversal> downExtensions = new ArrayList<>();\n+        final Set<Contig> startingContigSet = new HashSet<>();\n+        walkTraversals(traversal, touched, startingContigSet, traversalsByFirstContig,\n+                        allTraversals, downExtensions);\n+        final List<Traversal> upExtensions = new ArrayList<>();\n+        walkTraversals(traversal.rc(), touched, startingContigSet, traversalsByFirstContig,\n+                        allTraversals, upExtensions);\n+        for ( final Traversal down : downExtensions ) {\n+            for ( final Traversal up : upExtensions ) {\n+                if ( scaffolds.size() >= TOO_MANY_SCAFFOLDS ) {\n+                    throw new AssemblyTooComplexException();\n+                }\n+                scaffolds.add(Traversal.combineOverlappers(up.rc(), down, traversal.getContigs().size()));\n+            }\n+        }\n+    }\n+\n+    private static void walkTraversals( final Traversal traversal,\n+                                        final boolean[] touched,\n+                                        final Set<Contig> startingContigSet,\n+                                        final Map<Contig, List<Integer>> traversalsByFirstContig,\n+                                        final List<Traversal> allTraversals,\n+                                        final List<Traversal> extensions ) {\n+        final Contig firstContig = traversal.getFirstContig();\n+        final List<Integer> indexList;\n+        if ( startingContigSet.contains(firstContig) ||\n+                traversal.isInextensible() ||\n+                (indexList = traversalsByFirstContig.get(traversal.getLastContig())) == null ) {\n+            extensions.add(traversal);\n+            return;\n+        }\n+        startingContigSet.add(firstContig);\n+        for ( int idx : indexList ) {\n+            final Traversal extension;\n+            if ( idx >= 0 ) {\n+                extension = allTraversals.get(idx);\n+                touched[idx] = true;\n+            } else {\n+                final int rcIdx = ~idx;\n+                extension = allTraversals.get(rcIdx).rc();\n+                touched[rcIdx] = true;\n+            }\n+            walkTraversals(Traversal.combine(traversal, extension), touched, startingContigSet,\n+                            traversalsByFirstContig, allTraversals, extensions );\n+        }\n+        startingContigSet.remove(firstContig);\n+    }\n+\n+    private static void removeTriviallyDifferentTraversals(\n+                                            final Collection<Traversal> allTraversals ) {\n+        if ( allTraversals.isEmpty() ) {\n+            return;\n+        }\n+        final TreeSet<Traversal> sortedTraversals = new TreeSet<>(new TraversalEndpointComparator());\n+        for ( final Traversal traversal : allTraversals ) {\n+            sortedTraversals.add(traversal);\n+            sortedTraversals.add(traversal.rc());\n+        }\n+        final Iterator<Traversal> traversalIterator = sortedTraversals.iterator();\n+        Traversal prevTraversal = traversalIterator.next();\n+        while ( traversalIterator.hasNext() ) {\n+            final Traversal curTraversal = traversalIterator.next();\n+            if ( isTriviallyDifferent(prevTraversal, curTraversal) ) {\n+                traversalIterator.remove();\n+            } else {\n+                prevTraversal = curTraversal;\n+            }\n+        }\n+        sortedTraversals.removeIf(Traversal::isRC);\n+        allTraversals.clear();\n+        allTraversals.addAll(sortedTraversals);\n+    }\n+\n+    private static boolean isTriviallyDifferent( final Traversal traversal1,\n+                                                 final Traversal traversal2 ) {\n+        final Contig firstContig1 = traversal1.getFirstContig();\n+        final Contig lastContig1 = traversal1.getLastContig();\n+        final Contig firstContig2 = traversal2.getFirstContig();\n+        final Contig lastContig2 = traversal2.getLastContig();\n+        if ( firstContig1 != firstContig2 || lastContig1 != lastContig2 ) {\n+            return false;\n+        }\n+        final int interiorSize1 = traversal1.getSequenceLength() - firstContig1.size() - lastContig1.size();\n+        final int interiorSize2 = traversal2.getSequenceLength() - firstContig2.size() - lastContig2.size();\n+\n+        // if the path lengths are so different that one could harbor an SV, they're not trivially different\n+        if ( Math.abs(interiorSize1 - interiorSize2) >= MIN_SV_SIZE ) {\n+            return false;\n+        }\n+\n+        // if the paths are small enough that there can't be an SV's worth of differences, they're trivially different\n+        final int maxInteriorSize = Math.max(interiorSize1, interiorSize2);\n+        if ( maxInteriorSize < MIN_SV_SIZE ) {\n+            return true;\n+        }\n+\n+        // dang, maybe there's enough material in common that there can't be an SV's worth of differences\n+        // run a longest common subsequence algorithm to figure out the length of the common material\n+        // DP matrix holds length of common material\n+        final List<Contig> contigs1 = traversal1.getContigs();\n+        final int rowLen = contigs1.size() - 1;\n+        final int[][] rowPair = new int[2][];\n+        rowPair[0] = new int[rowLen];\n+        rowPair[1] = new int[rowLen];\n+        int pairIdx = 0;\n+        final List<Contig> contigs2 = traversal2.getContigs();\n+        final int nRows = contigs2.size() - 1;\n+        for ( int idx2 = 1; idx2 != nRows; ++idx2 ) {\n+            final int[] curRow = rowPair[pairIdx];\n+            final int[] prevRow = rowPair[pairIdx ^ 1];\n+            pairIdx ^= 1;\n+\n+            final int id2 = contigs2.get(idx2).getId();\n+            for ( int idx1 = 1; idx1 != rowLen; ++idx1 ) {\n+                final Contig tig1 = contigs1.get(idx1);\n+                if ( tig1.getId() == id2 ) {\n+                    // if the previous cells also contain a match we've already removed the K-1 bases upstream\n+                    final boolean extendMatch =\n+                            contigs1.get(idx1 -1).getId() == contigs2.get(idx2 - 1).getId();\n+                    curRow[idx1] = prevRow[idx1 - 1] + (extendMatch ? tig1.getNKmers() : tig1.size());\n+                } else {\n+                    curRow[idx1] = Math.max(curRow[idx1 - 1], prevRow[idx1]);\n+                }\n+            }\n+        }\n+        final int commonLen = rowPair[pairIdx ^ 1][rowLen - 1];\n+        return (maxInteriorSize - commonLen) < MIN_SV_SIZE;\n+    }\n+\n+    private static class TraversalEndpointComparator implements Comparator<Traversal> {\n+        @Override\n+        public int compare( final Traversal traversal1, final Traversal traversal2 ) {\n+            int cmp = Integer.compare(traversal1.contigs.get(0).getId(),\n+                                      traversal2.contigs.get(0).getId());\n+            if ( cmp != 0 ) {\n+                return cmp;\n+            }\n+            final int last1 = traversal1.contigs.size() - 1;\n+            final int last2 = traversal2.contigs.size() - 1;\n+            cmp = Integer.compare(traversal1.contigs.get(last1).getId(),\n+                                  traversal2.contigs.get(last2).getId());\n+            if ( cmp != 0 ) {\n+                return cmp;\n+            }\n+            // among those starting and ending at the same place, sort least observed last\n+            return -Integer.compare(traversal1.getMinMaxObservations(), traversal2.getMinMaxObservations());\n+        }\n+    }\n+\n+    private static void writeDOT( final List<ContigImpl> contigs, final String fileName ) {\n+        try ( final BufferedWriter writer = new BufferedWriter(new FileWriter(fileName)) ) {\n+            writer.write(\"digraph {\\n\");\n+            for ( final Contig contig : contigs ) {\n+                final double width = contig.getSequence().length() / 100.;\n+                writer.write(contig + \" [width=\" + width + \"]\\n\");\n+                writer.write( contig.rc() + \" [width=\" + width + \"]\\n\");\n+            }\n+            for ( final Contig contig : contigs ) {\n+                for ( final Contig predecessor : contig.getPredecessors() ) {\n+                    final String predecessorName = predecessor.rc().toString();\n+                    writer.write(contig.rc() + \" -> \" + predecessorName + \"\\n\");\n+                }\n+                for ( final Contig successor : contig.getSuccessors() ) {\n+                    final String successorName = successor.toString();\n+                    writer.write(contig + \" -> \" + successorName + \"\\n\");\n+                }\n+            }\n+            writer.write(\"}\\n\");\n+        } catch ( final IOException ioe ) {\n+            throw new GATKException(\"Failed to write assembly DOT file.\", ioe);\n+        }\n+    }\n+\n+    private static BufferedWriter makeGZFile( final String fileName ) throws IOException {\n+        final GZIPOutputStream gzOS = new GZIPOutputStream(BucketUtils.createFile(fileName));\n+        return new BufferedWriter(new OutputStreamWriter(gzOS));\n+    }\n+\n+    private static void writeContigs( final List<ContigImpl> contigs, final String fileName ) {\n+        try ( final BufferedWriter writer = makeGZFile(fileName) ) {\n+            for ( final Contig contig : contigs ) {\n+                final List<Contig> predecessors = contig.getPredecessors();\n+                final String predecessorDescription;\n+                if ( predecessors.size() == 0 ) {\n+                    predecessorDescription = \"\\tnone\";\n+                } else {\n+                    final StringBuilder sb = new StringBuilder();\n+                    char prefix = '\\t';\n+                    for ( final Contig predecessor : predecessors ) {\n+                        sb.append(prefix);\n+                        prefix = ',';\n+                        sb.append(predecessor);\n+                    }\n+                    predecessorDescription = sb.toString();\n+                }\n+\n+                final List<Contig> successors = contig.getSuccessors();\n+                final String successorDescription;\n+                if ( successors.size() == 0 ) {\n+                    successorDescription = \"\\tnone\";\n+                } else {\n+                    final StringBuilder sb = new StringBuilder();\n+                    char prefix = '\\t';\n+                    for ( final Contig successor : successors ) {\n+                        sb.append(prefix);\n+                        prefix = ',';\n+                        sb.append(successor);\n+                    }\n+                    successorDescription = sb.toString();\n+                }\n+\n+                final String contigName = contig.toString();\n+                final String component =\n+                        (contig.isCyclic() ? \"(C)\\t\" : \"\\t\") + contig.getComponentId();\n+                writer.write(contigName + component + predecessorDescription +\n+                        successorDescription + \"\\t\" +\n+                        contig.getMaxObservations() + \"\\t\" +\n+                        contig.getFirstKmer().getNObservations() + \"\\t\" +\n+                        contig.getLastKmer().getNObservations() + \"\\t\" +\n+                        contig.size() + \"\\t\" +\n+                        contig.getSequence() + \"\\n\");\n+            }\n+        } catch ( final IOException ioe ) {\n+            throw new GATKException(\"Failed to write contigs file.\", ioe);\n+        }\n+    }\n+\n+    private static void writePaths( final List<Path> readPaths, final String fileName ) {\n+        try ( final BufferedWriter writer = makeGZFile(fileName) ) {\n+            final int nReads = readPaths.size();\n+            for ( int readId = 0; readId != nReads; ++readId ) {\n+                final Path path = readPaths.get(readId);\n+                final String pathDesc = path.toString();\n+                writer.write((readId + 1) + \": \" + pathDesc + \"\\n\");\n+            }\n+        } catch ( final IOException ioe ) {\n+            throw new GATKException(\"Failed to write paths file.\", ioe);\n+        }\n+    }\n+\n+    private static void writeReads( final List<GATKRead> reads, final String fileName ) {\n+        try ( final BufferedWriter writer = makeGZFile(fileName) ) {\n+            for ( final GATKRead read : reads ) {\n+                writer.write(\"@\" + read.getName());\n+                writer.write('\\n');\n+                writer.write(new String(read.getBasesNoCopy()));\n+                writer.write(\"\\n+\\n\");\n+                final byte[] quals = read.getBaseQualitiesNoCopy();\n+                final int nQuals = quals.length;\n+                final byte[] fastqQuals = new byte[nQuals];\n+                for ( int idx = 0; idx != nQuals; ++idx ) {\n+                    fastqQuals[idx] = (byte)SAMUtils.phredToFastq(quals[idx]);\n+                }\n+                writer.write(new String(fastqQuals));\n+                writer.write('\\n');\n+            }\n+        } catch ( final IOException ioe ) {\n+            throw new GATKException(\"Failed to write assembly sam file.\", ioe);\n+        }\n+    }\n+\n+    private static void writeTraversals( final Collection<Traversal> traversals,\n+                                         final String fileName ) {\n+        try ( final BufferedWriter writer = makeGZFile(fileName) ) {\n+            int traversalNo = 0;\n+            for ( final Traversal traversal : traversals ) {\n+                writer.write(\">\");\n+                if ( assemblyName != null ) {\n+                    writer.write(assemblyName);\n+                    writer.write(\"_\");\n+                }\n+                writer.write(\"t\");\n+                writer.write(Integer.toString(++traversalNo));\n+                writer.write(\" \");\n+                writer.write(traversal.getName());\n+                writer.newLine();\n+                writer.write(traversal.getSequence());\n+                writer.newLine();\n+            }\n+        } catch ( final IOException ioe ) {\n+            throw new GATKException(\"Failed to write assembly sam file.\", ioe);\n+        }\n+    }\n+\n+    /** fixed-size, immutable kmer.  usual 2-bit encoding: ACGT->0123.  low order bits are final call. **/\n+    public static class Kmer {\n+        public static final int KSIZE = 31; // must be odd number less than 32\n+        public static final long KMASK = (1L << 2*KSIZE) - 1L;\n+        private final long kVal;\n+\n+        public Kmer( final long kVal ) { this.kVal = kVal; }\n+\n+        public long getKVal() { return kVal; }\n+        public boolean isCanonical() { return isCanonical(kVal); }\n+        public int getInitialCall() { return (int)(kVal >> (KSIZE*2 - 2)) & 3; }\n+        public int getFinalCall() { return (int)kVal & 3; }\n+\n+        public long getPredecessorVal( final int call ) {\n+            return (kVal >> 2) | ((long)call << (2 * (KSIZE - 1)));\n+        }\n+        public long getSuccessorVal( final int call ) { return ((kVal << 2) & KMASK) | call; }\n+\n+        public static boolean isCanonical( final long val ) {\n+            return (val & (1L << KSIZE)) == 0L;\n+        }\n+\n+        @Override public boolean equals( final Object obj ) {\n+            return obj instanceof Kmer && kVal == ((Kmer)obj).kVal;\n+        }\n+\n+        @Override public int hashCode() {\n+            return (int)(kVal ^ (kVal >>> 32));\n+        }\n+    }\n+\n+    /** Set of Kmers.  Uses HopscotchSet, customized to find correct starting bin for Kmers and derivatives. **/\n+    public static final class KmerSet<KMER extends Kmer> extends HopscotchSet<KMER> {\n+        public KmerSet( final int capacity ) { super(capacity); }\n+\n+        @Override\n+        protected int hashToIndex( final Object kmer ) {\n+            return (int)(((HopscotchSet.SPREADER * ((Kmer)kmer).getKVal()) & Long.MAX_VALUE) % capacity());\n+        }\n+    }\n+\n+    /**\n+     *  A Kmer that remembers its predecessors and successors, and the number of times it's been observed\n+     *  in the assembly's input set of reads.\n+     *  The masks are bit-wise (1=A, 2=C, 4=G, 8=T) to show which predecessors or successors have been observed.\n+     *  The Kmer's position on a Contig is also tracked (in later phases of the assembly process).\n+     **/\n+    public static abstract class KmerAdjacency extends Kmer {\n+        public KmerAdjacency( final long kVal ) { super(kVal); }\n+\n+        public abstract KmerAdjacency getSolePredecessor(); // returns null if there's 0 or >1 predecessors\n+        public abstract int getPredecessorMask();\n+        public abstract int getPredecessorCount();\n+        public abstract void removePredecessor( final int callToRemove,\n+                                                final KmerSet<KmerAdjacency> kmerAdjacencySet );\n+\n+        public abstract KmerAdjacency getSoleSuccessor(); // returns null if there's 0 or > 1 successors\n+        public abstract int getSuccessorMask();\n+        public abstract int getSuccessorCount();\n+        public abstract void removeSuccessor( final int callToRemove,\n+                                              final KmerSet<KmerAdjacency> kmerAdjacencySet );\n+\n+        public abstract Contig getContig();\n+        public abstract int getContigOffset();\n+        // offset is 0-based measure on the contig sequence of the beginning of the kmer\n+        public abstract void setContigOffset( final Contig contig, final int contigOffset );\n+        public abstract void clearContig();\n+\n+        public abstract int getNObservations();\n+        public abstract KmerAdjacency rc();\n+        public abstract KmerAdjacencyImpl canonical();\n+\n+        public void observe( final KmerAdjacency predecessor, final KmerAdjacency successor ) {\n+            observe(predecessor, successor, 1);\n+        }\n+\n+        public abstract void observe( final KmerAdjacency predecessor,\n+                                      final KmerAdjacency successor,\n+                                      final int count );\n+\n+        @Override public String toString() {\n+            final StringBuilder sb = new StringBuilder(KSIZE);\n+            long currentVal = getKVal();\n+            for ( int idx = 0; idx != KSIZE; ++idx ) {\n+                sb.append(\"ACGT\".charAt((int)currentVal & 3));\n+                currentVal >>= 2;\n+            }\n+            sb.reverse(); // low order bits were loaded into sb first:  fix that now by reversing the sb.\n+            return sb.toString();\n+        }\n+\n+        /**\n+         * Transform a read's calls into KmerAdjacencies, and add them to a KmerSet.\n+         * Skip kmers that include a call with a quality < qMin.\n+         * Skip kmers with non-ACGT calls.\n+         **/\n+        public static void kmerize( final byte[] calls,\n+                                    final byte[] quals,\n+                                    final byte qMin,\n+                                    final KmerSet<KmerAdjacency> kmerAdjacencySet ) {\n+            int currentCount = 0; // number of calls loaded into currentKVal\n+            long currentKVal = 0;\n+            KmerAdjacency prevAdjacency = null;\n+            KmerAdjacency currentAdjacency = null;\n+            for ( int idx = 0; idx < calls.length; ++idx ) {\n+                if ( quals[idx] < qMin ) { // if we encounter a low-quality call\n+                    // take care of the most recent valid KmerAdjacency, if any\n+                    if ( currentAdjacency != null ) {\n+                        currentAdjacency.observe(prevAdjacency, null);\n+                    }\n+                    // ready ourselves to accumulate calls afresh\n+                    currentCount = 0;\n+                    currentAdjacency = prevAdjacency = null;\n+                    continue;\n+                }\n+                currentKVal <<= 2;\n+                switch ( calls[idx] ) {\n+                    case 'A': case 'a': break;\n+                    case 'C': case 'c': currentKVal += 1; break;\n+                    case 'G': case 'g': currentKVal += 2; break;\n+                    case 'T': case 't': currentKVal += 3; break;\n+                    default:\n+                        if ( currentAdjacency != null ) {\n+                            currentAdjacency.observe(prevAdjacency, null);\n+                        }\n+                        currentCount = 0;\n+                        currentAdjacency = prevAdjacency = null;\n+                        continue;\n+                }\n+                if ( ++currentCount >= KSIZE ) { // if we've loaded enough calls to make a complete kmer\n+                    final KmerAdjacency nextAdjacency = findOrAdd(currentKVal, kmerAdjacencySet);\n+                    if ( currentAdjacency != null ) {\n+                        currentAdjacency.observe(prevAdjacency, nextAdjacency);\n+                    }\n+                    prevAdjacency = currentAdjacency;\n+                    currentAdjacency = nextAdjacency;\n+                }\n+            }\n+            if ( currentAdjacency != null ) {\n+                currentAdjacency.observe(prevAdjacency, null);\n+            }\n+        }\n+\n+        /**\n+         * Kmerize a String.  This version is for gap fills.\n+         * The number of observations applies to all kmers except the 1st and last.\n+         **/\n+        public static void kmerize( final String sequence,\n+                                    final int nObservations,\n+                                    final KmerSet<KmerAdjacency> kmerAdjacencySet ) {\n+            int currentCount = 0;\n+            long currentKVal = 0;\n+            int nObs = 0;\n+            KmerAdjacency prevAdjacency = null;\n+            KmerAdjacency currentAdjacency = null;\n+            final int nCalls = sequence.length();\n+            for ( int idx = 0; idx != nCalls; ++idx ) {\n+                currentKVal <<= 2;\n+                switch ( sequence.charAt(idx) ) {\n+                    case 'A': case 'a': break;\n+                    case 'C': case 'c': currentKVal += 1; break;\n+                    case 'G': case 'g': currentKVal += 2; break;\n+                    case 'T': case 't': currentKVal += 3; break;\n+                    default: throw new GATKException(\"unexpected base call in string to kmerize.\");\n+                }\n+                if ( ++currentCount >= KSIZE ) {\n+                    final KmerAdjacency nextAdjacency = findOrAdd(currentKVal, kmerAdjacencySet);\n+                    if ( currentAdjacency != null ) {\n+                        currentAdjacency.observe(prevAdjacency, nextAdjacency, nObs);\n+                        nObs = nObservations;\n+                    }\n+                    prevAdjacency = currentAdjacency;\n+                    currentAdjacency = nextAdjacency;\n+                }\n+            }\n+            if ( currentAdjacency != null ) {\n+                currentAdjacency.observe(prevAdjacency, null, 0);\n+            }\n+        }\n+\n+        // Lookup table for reverse-complementing each possible byte value.\n+        // Each pair of bits represents a base, so you have to reverse bits pairwise and then invert all bits.\n+        // This is most quickly and easily done with a lookup table.\n+        private static final long[] BYTEWISE_REVERSE_COMPLEMENT;\n+        static {\n+            BYTEWISE_REVERSE_COMPLEMENT = new long[256];\n+            for ( int bIn = 0; bIn != 256; ++bIn ) {\n+                BYTEWISE_REVERSE_COMPLEMENT[bIn] =\n+                        ~(((bIn & 3) << 6) | (((bIn >> 2) & 3) << 4) |\n+                                (((bIn >> 4) & 3) << 2) | ((bIn >> 6) & 3)) & 0xffL;\n+            }\n+        }\n+\n+        public static long reverseComplement( long val ) {\n+            // process val one byte at a time\n+            long result = BYTEWISE_REVERSE_COMPLEMENT[(int)val & 0xFF]; // handle the low-order byte\n+            int nBytes = 8;\n+            while ( --nBytes != 0 ) { // pre-decrementing:  we'll go through the loop 7 times\n+                // rotate down by a byte\n+                val >>= 8;\n+                // rotate up by a byte and OR in the reverse complement of the next byte\n+                result = (result << 8) | BYTEWISE_REVERSE_COMPLEMENT[(int)val & 0xFF];\n+            }\n+            return result >>> (Long.SIZE - 2*KSIZE);\n+        }\n+\n+        // Kmer lookup in KmerSet.\n+        // KmerSets holding KmerAdjacencies have only canonical Kmers, so RC non-canonical kmers before lookup.\n+        public static KmerAdjacency find( final long kVal,\n+                                          final KmerSet<KmerAdjacency> kmerAdjacencySet ) {\n+            if ( isCanonical(kVal) ) return kmerAdjacencySet.find(new Kmer(kVal & KMASK));\n+            final KmerAdjacency result = kmerAdjacencySet.find(new Kmer(reverseComplement(kVal)));\n+            return result == null ? null : result.rc();\n+        }\n+\n+        // Kmer lookup in KmerSet.\n+        // KmerSets holding KmerAdjacencies have only canonical Kmers, so RC non-canonical kmers before lookup.\n+        // Add missing Kmers.\n+        public static KmerAdjacency findOrAdd( final long kVal,\n+                                               final KmerSet<KmerAdjacency> kmerAdjacencySet ) {\n+            if ( isCanonical(kVal) ) {\n+                return kmerAdjacencySet.findOrAdd(new Kmer(kVal & KMASK), kmer ->\n+                        new KmerAdjacencyImpl(((Kmer)kmer).getKVal()));\n+            }\n+            return kmerAdjacencySet.findOrAdd(new Kmer(reverseComplement(kVal)), kmer ->\n+                    new KmerAdjacencyImpl(((Kmer)kmer).getKVal())).rc();\n+        }\n+    }\n+\n+    /**\n+     * Class to implement KmerAdjacency for canonical Kmers.\n+     * In particular, a KmerSet created on KmerAdjacency contains only canonical Kmers.\n+     **/\n+    public static final class KmerAdjacencyImpl extends KmerAdjacency {\n+        private KmerAdjacency solePredecessor; // set to null if there are no predecessors, or multiple predecessors\n+        private KmerAdjacency soleSuccessor; // set to null if there are no successors, or multiple successors\n+        private int predecessorMask; // bit mask of observed kmers preceding this one\n+        private int successorMask; // bit mask observed kmers following this one\n+        private Contig contig; // the contig that contains this Kmer\n+        private int contigOffset; // the offset within the contig where this kmer is found\n+        private int nObservations; // the reads in which this kmer was observed\n+        private final KmerAdjacencyRC rc; // the reverse-complement of this kmer\n+        private static final int[] COUNT_FOR_MASK =\n+                //side sum for binary values from 0 -> 15\n+                //0000  0001 0010 0011 0100 0101 0110 0111 1000 1001 1010 1011 1100 1101 1110 1111\n+                {    0,    1,   1,   2,   1,   2,   2,   3,   1,   2,   2,   3,   2,   3,   3,   4 };\n+\n+        public KmerAdjacencyImpl( final long kVal ) {\n+            super(kVal);\n+            this.rc = new KmerAdjacencyRC(this);\n+        }\n+\n+        @Override public KmerAdjacency getSolePredecessor() { return solePredecessor; } // may return null\n+        @Override public int getPredecessorMask() { return predecessorMask; }\n+        @Override public int getPredecessorCount() { return COUNT_FOR_MASK[predecessorMask]; }\n+        @Override\n+        public void removePredecessor( final int callToRemove,\n+                                       final KmerSet<KmerAdjacency> kmerAdjacencySet ) {\n+            predecessorMask &= ~(1 << callToRemove);\n+            solePredecessor = null;\n+            if ( getPredecessorCount() == 1 ) {\n+                for ( int call = 0; call != 4; ++call ) {\n+                    if ( ((1 << call) & predecessorMask) != 0 ) {\n+                        solePredecessor = find(getPredecessorVal(call), kmerAdjacencySet);\n+                        break;\n+                    }\n+                }\n+            }\n+        }\n+\n+        @Override public KmerAdjacency getSoleSuccessor() { return soleSuccessor; } // may return null\n+        @Override public int getSuccessorMask() { return successorMask; }\n+        @Override public int getSuccessorCount() { return COUNT_FOR_MASK[successorMask]; }\n+        @Override\n+        public void removeSuccessor( final int callToRemove,\n+                                     final KmerSet<KmerAdjacency> kmerAdjacencySet ) {\n+            successorMask &= ~(1 << callToRemove);\n+            soleSuccessor = null;\n+            if ( getSuccessorCount() == 1 ) {\n+                for ( int call = 0; call != 4; ++call ) {\n+                    if ( ((1 << call) & successorMask) != 0 ) {\n+                        soleSuccessor = find(getSuccessorVal(call), kmerAdjacencySet);\n+                        break;\n+                    }\n+                }\n+            }\n+        }\n+\n+        @Override public Contig getContig() { return contig; }\n+        @Override public int getContigOffset() { return contigOffset; }\n+        @Override public void setContigOffset( final Contig contig, final int contigOffset ) {\n+            if ( this.contig != null ) {\n+                throw new GATKException(\"Internal error: overwriting kmer contig and offset.\");\n+            }\n+            this.contig = contig;\n+            this.contigOffset = contigOffset;\n+        }\n+        @Override public void clearContig() { contig = null; contigOffset = 0; }\n+\n+        @Override public int getNObservations() { return nObservations; }\n+        @Override public KmerAdjacency rc() { return rc; }\n+        @Override public KmerAdjacencyImpl canonical() { return this; }\n+\n+        @Override public void observe( final KmerAdjacency predecessor,\n+                                       final KmerAdjacency successor,\n+                                       final int count ) {\n+            if ( predecessor != null ) {\n+                if ( predecessor.getSuccessorVal(getFinalCall()) != getKVal() ) {\n+                    throw new GATKException(\"illegal predecessor\");\n+                }\n+                final int initialCall = predecessor.getInitialCall();\n+                final int newPredecessorMask = 1 << initialCall;\n+                if ( (newPredecessorMask & predecessorMask) == 0 ) {\n+                    if ( predecessorMask == 0 ) {\n+                        solePredecessor = predecessor;\n+                        predecessorMask = newPredecessorMask;\n+                    } else {\n+                        solePredecessor = null;\n+                        predecessorMask |= newPredecessorMask;\n+                    }\n+                }\n+            }\n+            if ( successor != null ) {\n+                if ( successor.getPredecessorVal(getInitialCall()) != getKVal() ) {\n+                    throw new GATKException(\"illegal successor\");\n+                }\n+                final int finalCall = successor.getFinalCall();\n+                final int newSuccessorMask = 1 << finalCall;\n+                if ( (newSuccessorMask & successorMask) == 0 ) {\n+                    if ( successorMask == 0 ) {\n+                        soleSuccessor = successor;\n+                        successorMask = newSuccessorMask;\n+                    } else {\n+                        soleSuccessor = null;\n+                        successorMask |= newSuccessorMask;\n+                    }\n+                }\n+            }\n+            nObservations += count;\n+        }\n+    }\n+\n+    /**\n+     * Class to implement KmerAdjacency for Kmers that are the reverse-complement of a canonical Kmer.\n+     * In particular, a KmerSet created on KmerAdjacency contains only canonical Kmers.\n+     * A KmerAdjacencyRC represents the RC of each Kmer in the KmerSet.\n+     **/\n+    public static final class KmerAdjacencyRC extends KmerAdjacency {\n+        private final KmerAdjacencyImpl rc;\n+\n+        // lookup table to bit-reverse nibbles\n+        private static final int[] NIBREV =\n+                // 0000,  0001,  0010,  0011,  0100,  0101,  0110,  0111,  1000,  1001,  1010,  1011,  1100,  1101,  1110,  1111\n+                {0b0000,0b1000,0b0100,0b1100,0b0010,0b1010,0b0110,0b1110,0b0001,0b1001,0b0101,0b1101,0b0011,0b1011,0b0111,0b1111};\n+\n+        public KmerAdjacencyRC( final KmerAdjacencyImpl rc ) {\n+            super(reverseComplement(rc.getKVal()));\n+            this.rc = rc;\n+        }\n+\n+        @Override public KmerAdjacency getSolePredecessor() {\n+            final KmerAdjacency successor = rc.getSoleSuccessor();\n+            return successor == null ? null : successor.rc();\n+        }\n+        @Override public int getPredecessorMask() { return NIBREV[rc.getSuccessorMask()]; }\n+        @Override public int getPredecessorCount() { return rc.getSuccessorCount(); }\n+        @Override\n+        public void removePredecessor( final int callToRemove,\n+                                       final KmerSet<KmerAdjacency> kmerAdjacencySet ) {\n+            rc.removeSuccessor(3 - callToRemove, kmerAdjacencySet);\n+        }\n+\n+        @Override public KmerAdjacency getSoleSuccessor() {\n+            final KmerAdjacency predecessor = rc.getSolePredecessor();\n+            return predecessor == null ? null : predecessor.rc();\n+        }\n+        @Override public int getSuccessorMask() { return NIBREV[rc.getPredecessorMask()]; }\n+        @Override public int getSuccessorCount() { return rc.getPredecessorCount(); }\n+        @Override\n+        public void removeSuccessor( final int callToRemove,\n+                                     final KmerSet<KmerAdjacency> kmerAdjacencySet ) {\n+            rc.removePredecessor(3 - callToRemove, kmerAdjacencySet);\n+        }\n+\n+        @Override public Contig getContig() {\n+            final Contig contig = rc.getContig();\n+            return contig == null ? null : contig.rc();\n+        }\n+        @Override public int getContigOffset() {\n+            final Contig contig = rc.getContig();\n+            return contig == null ? 0 : contig.size() - rc.getContigOffset() - KSIZE;\n+        }\n+        @Override public void setContigOffset( final Contig contig, final int contigOffset ) {\n+            rc.setContigOffset(contig.rc(), contig.size() - contigOffset - KSIZE);\n+        }\n+        @Override public void clearContig() { rc.clearContig(); }\n+\n+        @Override public int getNObservations() { return rc.getNObservations(); }\n+        @Override public KmerAdjacency rc() { return rc; }\n+        @Override public KmerAdjacencyImpl canonical() { return rc; }\n+\n+        @Override public void observe( final KmerAdjacency predecessor,\n+                                       final KmerAdjacency successor,\n+                                       final int count ) {\n+            rc.observe(successor == null ? null : successor.rc(),\n+                    predecessor == null ? null : predecessor.rc(),\n+                    count);\n+        }\n+    }\n+\n+    public enum ContigOrientation {\n+        FWD, // k-mer appears at the 5' end of the contig\n+        REV, // k-mer appears at the 5' end of the reverse-complemented contig\n+        BOTH // k-mer occurs on 5' end of the contig and its RC (can happen when the contig is a palindrome)\n+    }\n+\n+    /** Initial or final Kmer in a Contig. **/\n+    public static final class ContigEndKmer extends Kmer {\n+        private final Contig contig;\n+        private final ContigOrientation contigOrientation;\n+\n+        public ContigEndKmer( final long kVal,\n+                              final Contig contig,\n+                              final ContigOrientation contigEnd ) {\n+            super(kVal);\n+            this.contig = contig;\n+            this.contigOrientation = contigEnd;\n+        }\n+\n+        public Contig getContig() { return contig; }\n+        public ContigOrientation getContigOrientation() { return contigOrientation; }\n+    }\n+\n+    /**\n+     * An unbranched sequence of Kmers.\n+     * Each Kmer (except the last one) has a single successor, which allows enumerating the sequence\n+     * of Kmers in the Contig.  The sequence of base calls in the Contig is just the sequence of kmers\n+     * with the K-1 overlapping calls removed from adjacent kmers.\n+     **/\n+    public interface Contig {\n+        int getId();\n+        CharSequence getSequence();\n+        int getMaxObservations();\n+        KmerAdjacency getFirstKmer();\n+        KmerAdjacency getLastKmer();\n+        List<Contig> getPredecessors();\n+        List<Contig> getSuccessors();\n+        int getComponentId();\n+        int size();\n+        default int getNKmers() { return size() - Kmer.KSIZE + 1; }\n+        Contig rc();\n+        boolean isCyclic();\n+        void setCyclic( final boolean cyclic );\n+        boolean isCut();\n+        void setCut( final boolean cut );\n+        boolean isCanonical();\n+        ContigImpl canonical();\n+    }\n+\n+    /** Simple implementation of Contig interface. **/\n+    public static final class ContigImpl implements Contig {\n+        private final int id;\n+        private final CharSequence sequence;\n+        private final int maxObservations;\n+        private final KmerAdjacency firstKmer;\n+        private final KmerAdjacency lastKmer;\n+        private final List<Contig> predecessors;\n+        private final List<Contig> successors;\n+        private int componentId;\n+        private boolean cyclic;\n+        private boolean cut;\n+        private final Contig rc;\n+\n+        public ContigImpl( final int id, final KmerAdjacency firstKmerAdjacency ) {\n+            this.id = id;\n+            final StringBuilder sb = new StringBuilder(firstKmerAdjacency.toString());\n+            int maxObservations = firstKmerAdjacency.getNObservations();\n+            KmerAdjacency lastKmerAdjacency = firstKmerAdjacency;\n+            for ( KmerAdjacency kmerAdjacency = firstKmerAdjacency.getSoleSuccessor();\n+                  kmerAdjacency != null;\n+                  kmerAdjacency = kmerAdjacency.getSoleSuccessor() ) {\n+                // if we've gone around a circle, or if we're branching backwards, or if we hit a palindrome u-turn\n+                if ( firstKmerAdjacency == kmerAdjacency ||\n+                        kmerAdjacency.getPredecessorCount() != 1 ||\n+                        kmerAdjacency == lastKmerAdjacency.rc() ) {\n+                    break;\n+                }\n+                sb.append(\"ACGT\".charAt(kmerAdjacency.getFinalCall()));\n+                maxObservations = Math.max(maxObservations, kmerAdjacency.getNObservations());\n+                lastKmerAdjacency = kmerAdjacency;\n+            }\n+            this.sequence = sb.toString();\n+            this.maxObservations = maxObservations;\n+            this.firstKmer = firstKmerAdjacency;\n+            this.lastKmer = lastKmerAdjacency;\n+            this.predecessors = new ArrayList<>(firstKmer.getPredecessorCount());\n+            this.successors = new ArrayList<>(lastKmer.getSuccessorCount());\n+            this.rc = new ContigRCImpl(this);\n+\n+            int offset = 0;\n+            for ( KmerAdjacency kmerAdjacency = firstKmerAdjacency;\n+                  kmerAdjacency != lastKmerAdjacency;\n+                  kmerAdjacency = kmerAdjacency.getSoleSuccessor() ) {\n+                kmerAdjacency.setContigOffset(this, offset++);\n+            }\n+            lastKmerAdjacency.setContigOffset(this, offset);\n+        }\n+\n+        // create a new contig by joining two contigs\n+        public ContigImpl( final int id, final Contig predecessor, final Contig successor ) {\n+            if ( predecessor == successor || predecessor == successor.rc() ) {\n+                throw new GATKException(\"can't self-join\");\n+            }\n+            this.id = id;\n+            final StringBuilder sb = new StringBuilder(predecessor.getSequence());\n+            final CharSequence successorSequence = successor.getSequence();\n+            sb.append(successorSequence.subSequence(Kmer.KSIZE - 1, successorSequence.length()));\n+            this.sequence = sb.toString();\n+            this.maxObservations =\n+                    Math.max(predecessor.getMaxObservations(), successor.getMaxObservations());\n+            this.firstKmer = predecessor.getFirstKmer();\n+            this.lastKmer = successor.getLastKmer();\n+            this.predecessors = new ArrayList<>(predecessor.getPredecessors().size());\n+            this.successors = new ArrayList<>(successor.getSuccessors().size());\n+            this.rc = new ContigRCImpl(this);\n+\n+            // fix predecessor linkages to point to new contig\n+            for ( final Contig predPredecessor : predecessor.getPredecessors() ) {\n+                if ( predPredecessor == successor ) {\n+                    predecessors.add(this);\n+                } else if ( predPredecessor == predecessor.rc() ) {\n+                    predecessors.add(rc);\n+                } else {\n+                    predecessors.add(predPredecessor);\n+                    final List<Contig> successors = predPredecessor.getSuccessors();\n+                    successors.set(successors.indexOf(predecessor), this);\n+                }\n+            }\n+\n+            // fix successor linkages to point to new contig\n+            for ( final Contig succSuccessor : successor.getSuccessors() ) {\n+                if ( succSuccessor == predecessor ) {\n+                    successors.add(this);\n+                } else if ( succSuccessor == successor.rc() ) {\n+                    successors.add(rc);\n+                } else {\n+                    successors.add(succSuccessor);\n+                    final List<Contig> predecessors = succSuccessor.getPredecessors();\n+                    predecessors.set(predecessors.indexOf(successor), this);\n+                }\n+            }\n+        }\n+\n+        @Override public int getId() { return id; }\n+        @Override public CharSequence getSequence() { return sequence; }\n+        @Override public int getMaxObservations() { return maxObservations; }\n+        @Override public KmerAdjacency getFirstKmer() { return firstKmer; }\n+        @Override public KmerAdjacency getLastKmer() { return lastKmer; }\n+        @Override public List<Contig> getPredecessors() { return predecessors; }\n+        @Override public List<Contig> getSuccessors() { return successors; }\n+        @Override public int getComponentId() { return componentId; }\n+        public void setComponentId( final int id ) { this.componentId = id; }\n+        @Override public int size() { return sequence.length(); }\n+        @Override public Contig rc() { return rc; }\n+        @Override public boolean isCyclic() { return cyclic; }\n+        @Override public void setCyclic( final boolean cyclic ) { this.cyclic = cyclic; }\n+        @Override public boolean isCut() { return cut; }\n+        @Override public void setCut( final boolean cut ) { this.cut = cut; }\n+        @Override public boolean isCanonical() { return true; }\n+        @Override public ContigImpl canonical() { return this; }\n+        @Override public String toString() { return \"c\" + id; }\n+    }\n+\n+    /**\n+     * Implementation of Contig for the reverse-complement of some other Contig.\n+     * Which one is the \"real\" Contig, and which is the \"RC\" is completely arbitrary, since there\n+     * is no notion of canonical for Contigs.\n+     **/\n+    public static final class ContigRCImpl implements Contig {\n+        private final CharSequence sequence;\n+        private final List<Contig> predecessors;\n+        private final List<Contig> successors;\n+        private final ContigImpl rc;\n+\n+        public ContigRCImpl( final ContigImpl contig ) {\n+            this.sequence = new SequenceRC(contig.getSequence());\n+            this.predecessors = new ContigListRC(contig.getSuccessors());\n+            this.successors = new ContigListRC(contig.getPredecessors());\n+            this.rc = contig;\n+        }\n+\n+        @Override public int getId() { return ~rc.getId(); }\n+        @Override public CharSequence getSequence() { return sequence; }\n+        @Override public int getMaxObservations() { return rc.getMaxObservations(); }\n+        @Override public KmerAdjacency getFirstKmer() { return rc.getLastKmer().rc(); }\n+        @Override public KmerAdjacency getLastKmer() { return rc.getFirstKmer().rc(); }\n+        @Override public List<Contig> getPredecessors() { return predecessors; }\n+        @Override public List<Contig> getSuccessors() { return successors; }\n+        @Override public int getComponentId() { return rc.getComponentId(); }\n+        @Override public int size() { return sequence.length(); }\n+        @Override public Contig rc() { return rc; }\n+        @Override public boolean isCyclic() { return rc.isCyclic(); }\n+        @Override public void setCyclic( final boolean cyclic ) { rc.setCyclic(cyclic); }\n+        @Override public boolean isCut() { return rc.isCut(); }\n+        @Override public void setCut( final boolean cut ) { rc.setCut(cut); }\n+        @Override public boolean isCanonical() { return false; }\n+        @Override public ContigImpl canonical() { return rc; }\n+        @Override public String toString() { return rc.toString() + \"RC\"; }\n+    }\n+\n+    /** A CharSequence that is a view of the reverse-complement of another sequence. **/\n+    public static final class SequenceRC implements CharSequence, Comparable<CharSequence> {\n+        private final int lenLess1;\n+        private final CharSequence sequence;\n+\n+        public SequenceRC( final CharSequence sequence ) {\n+            this.lenLess1 = sequence.length() - 1;\n+            this.sequence = sequence;\n+        }\n+\n+        @Override public int length() { return sequence.length(); }\n+        @Override public char charAt( final int index ) {\n+            final char result;\n+            switch ( Character.toUpperCase(sequence.charAt(lenLess1 - index)) ) {\n+                case 'A': result = 'T'; break;\n+                case 'C': result = 'G'; break;\n+                case 'G': result = 'C'; break;\n+                case 'T': result = 'A'; break;\n+                default: result = 'N'; break;\n+            }\n+            return result;\n+        }\n+        @Override public CharSequence subSequence( final int start, final int end ) {\n+            return new StringBuilder(end - start).append(this, start, end).toString();\n+        }\n+        @Override public String toString() { return new StringBuilder(this).toString(); }\n+\n+        @Override public int compareTo( final CharSequence charSequence ) {\n+            final int len1 = length();\n+            final int len2 = charSequence.length();\n+            final int cmpLen = Math.min(len1, len2);\n+            for ( int idx = 0; idx != cmpLen; ++idx ) {\n+                final char char1 = charAt(idx);\n+                final char char2 = Character.toUpperCase(charSequence.charAt(idx));\n+                if ( char1 > char2 ) return 1;\n+                if ( char1 < char2 ) return -1;\n+            }\n+            return Integer.compare(len1, len2);\n+        }\n+    }\n+\n+    /** A list of Contigs that presents a reverse-complemented view of a List of Contigs. **/\n+    public static final class ContigListRC extends AbstractList<Contig> {\n+        private final List<Contig> contigList;\n+\n+        public ContigListRC( final List<Contig> contigList ) {\n+            this.contigList = contigList;\n+        }\n+\n+        @Override public Contig get( final int index ) {\n+            return contigList.get(reflectIndex(index)).rc();\n+        }\n+        @Override public int size() { return contigList.size(); }\n+        @Override public Contig set( final int index, final Contig contig ) {\n+            return contigList.set(reflectIndex(index), contig.rc()).rc();\n+        }\n+        @Override public void add( final int index, final Contig contig ) {\n+            contigList.add(reflectIndex(index), contig.rc());\n+        }\n+        @Override public Contig remove( final int index ) {\n+            return contigList.remove(reflectIndex(index)).rc();\n+        }\n+\n+        private int reflectIndex( final int index ) { return size() - 1 - index; }\n+    }\n+\n+    /** A single-Contig portion of a path across the assembly graph. **/\n+    public interface PathPart {\n+        Contig getContig(); // will be null for PathParts that depart from the graph (PathPartGap)\n+        CharSequence getSequence(); // will be null for PathParts on the graph (PathPartContig)\n+        void extend( final char call );\n+        int getStart();\n+        int getStop();\n+        boolean isGap();\n+        int getLength();\n+        PathPart rc();\n+        char getFirstCall();\n+        char getLastCall();\n+        default boolean startsAtBeginning() { return getStart() == 0; }\n+        default boolean stopsAtEnd() { return getStop() + Kmer.KSIZE - 1 == getContig().size(); }\n+    }\n+\n+    /** A part of a path that isn't present in the graph. **/\n+    public static final class PathPartGap implements PathPart {\n+        private final StringBuilder sequence = new StringBuilder();\n+\n+        public PathPartGap( final KmerAdjacency kmer ) { sequence.append(kmer.toString()); }\n+        private PathPartGap( final CharSequence sequence ) { this.sequence.append(sequence); }\n+\n+        @Override public Contig getContig() { return null; }\n+        @Override public CharSequence getSequence() { return sequence.toString(); }\n+        @Override public void extend( final char call ) { sequence.append(call); }\n+        @Override public int getStart() { return 0; }\n+        @Override public int getStop() { return sequence.length(); }\n+        @Override public boolean isGap() { return true; }\n+        @Override public int getLength() { return sequence.length() - Kmer.KSIZE + 1; }\n+        @Override public PathPart rc() { return new PathPartGap(new SequenceRC(sequence)); }\n+        @Override public char getFirstCall() { return sequence.charAt(Kmer.KSIZE - 1); }\n+        @Override public char getLastCall() {\n+            return sequence.charAt(sequence.length() - Kmer.KSIZE + 1);\n+        }\n+    }\n+\n+    /** A part of a path that is present as a sub-sequence of some Contig. **/\n+    public static final class PathPartContig implements PathPart {\n+        private final Contig contig;\n+        private final int start;\n+        private int stop;\n+\n+        public PathPartContig( final Contig contig, final int start ) {\n+            this(contig, start, start+1);\n+        }\n+        public PathPartContig( final Contig contig, final int start, final int stop ) {\n+            this.contig = contig;\n+            this.start = start;\n+            this.stop = stop;\n+        }\n+\n+        @Override public Contig getContig() { return contig; }\n+        @Override public String getSequence() { return null; }\n+        @Override public void extend( final char call ) { stop += 1; }\n+        @Override public int getStart() { return start; }\n+        @Override public int getStop() { return stop; }\n+        @Override public boolean isGap() { return false; }\n+        @Override public int getLength() { return stop - start; }\n+        @Override public PathPart rc() {\n+            final int revBase = contig.size() - Kmer.KSIZE + 1;\n+            return new PathPartContig(contig.rc(), revBase - stop, revBase - start);\n+        }\n+        @Override public char getFirstCall() {\n+            return getContig().getSequence().charAt(start + Kmer.KSIZE - 1);\n+        }\n+        @Override public char getLastCall() { return getContig().getSequence().charAt(stop - 1); }\n+    }\n+\n+    /** A path through the assembly graph for something (probably a read). **/\n+    public static final class Path {\n+        private final List<PathPart> parts;\n+\n+        public Path( final byte[] calls,\n+                     final KmerSet<KmerAdjacency> kmerAdjacencySet ) {\n+            parts = new ArrayList<>();\n+            long kVal = 0;\n+            int count = 0;\n+            PathPart currentPathPart = null;\n+            for ( int idx = 0; idx != calls.length; ++idx ) {\n+                final char call = (char)calls[idx];\n+                kVal <<= 2;\n+                switch ( call ) {\n+                    case 'C': case 'c': kVal += 1; break;\n+                    case 'G': case 'g': kVal += 2; break;\n+                    case 'T': case 't': kVal += 3; break;\n+                }\n+                if ( ++count >= Kmer.KSIZE ) {\n+                    final KmerAdjacency kmer = KmerAdjacencyImpl.find(kVal, kmerAdjacencySet);\n+                    // if we fail to look up the kmer\n+                    if ( kmer == null ) {\n+                        if ( currentPathPart == null ) {\n+                            // if there's no current path part, just create the 1st one as a PathPartGap\n+                            currentPathPart = new PathPartGap(new KmerAdjacencyImpl(kVal));\n+                            parts.add(currentPathPart);\n+                        } else if ( currentPathPart.isGap() ) {\n+                            // if the current path part is a PathPartGap, just extend it\n+                            currentPathPart.extend(call);\n+                        } else {\n+                            // new PathPartGap\n+                            currentPathPart = new PathPartGap(new KmerAdjacencyImpl(kVal));\n+                            parts.add(currentPathPart);\n+                        }\n+                    } else {\n+                        // we've found our kmer\n+                        final Contig contig = kmer.getContig();\n+                        if ( currentPathPart == null ) {\n+                            // we've looked up a kmer, but don't have a current path part -- create one\n+                            currentPathPart = new PathPartContig(contig, kmer.getContigOffset());\n+                            parts.add(currentPathPart);\n+                        } else if ( contig == currentPathPart.getContig() ) {\n+                            // our lookup is on the current path part's contig -- extend it\n+                            final int kmerOffset = kmer.getContigOffset();\n+                            final int curStop = currentPathPart.getStop();\n+                            if ( kmerOffset == curStop ) {\n+                                currentPathPart.extend(call);\n+                            } else if ( kmerOffset == 0 && contig.getNKmers() == curStop ) {\n+                                // cycle onto same contig\n+                                currentPathPart = new PathPartContig(contig, 0);\n+                                parts.add(currentPathPart);\n+                            } else {\n+                                // weird:  kmer is non-contiguous.  start a new path part after a zero-length gap\n+                                parts.add(zeroLengthGap(currentPathPart));\n+                                currentPathPart = new PathPartContig(contig, kmerOffset);\n+                                parts.add(currentPathPart);\n+                            }\n+                        } else {\n+                            final int kmerContigOffset = kmer.getContigOffset();\n+                            if ( currentPathPart.isGap() ) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5Nzk0ODk5NA=="}, "originalCommit": {"oid": "e2201c1ef4f8ba71f17e169f07756cfe2f1ecb49"}, "originalPosition": 2050}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzc3NzAxMDI1OnYy", "diffSide": "RIGHT", "path": "src/test/java/org/broadinstitute/hellbender/tools/walkers/PairWalkerUnitTest.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMy0xOVQyMDoyNTowN1rOI6QRwA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMy0xOVQyMDoyNTowN1rOI6QRwA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5Nzk1NTAwOA==", "bodyText": "You could consider using Mockito for this sort of thing.", "url": "https://github.com/broadinstitute/gatk/pull/6989#discussion_r597955008", "createdAt": "2021-03-19T20:25:07Z", "author": {"login": "cwhelan"}, "path": "src/test/java/org/broadinstitute/hellbender/tools/walkers/PairWalkerUnitTest.java", "diffHunk": "@@ -0,0 +1,136 @@\n+package org.broadinstitute.hellbender.tools.walkers;\n+\n+import htsjdk.samtools.SAMFileHeader;\n+import htsjdk.samtools.SAMSequenceDictionary;\n+import org.broadinstitute.hellbender.exceptions.GATKException;\n+import org.broadinstitute.hellbender.tools.PrintDistantMates;\n+import org.broadinstitute.hellbender.utils.SimpleInterval;\n+import org.broadinstitute.hellbender.utils.read.ArtificialReadUtils;\n+import org.broadinstitute.hellbender.utils.read.GATKRead;\n+import org.testng.Assert;\n+import org.testng.annotations.Test;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Comparator;\n+import java.util.List;\n+\n+public class PairWalkerUnitTest {\n+    final static SAMFileHeader hdr =\n+            ArtificialReadUtils.createArtificialSamHeader(3, 1, 5000);\n+    final static SAMSequenceDictionary dict = hdr.getSequenceDictionary();\n+    final static List<SimpleInterval> intervalList = Arrays.asList(\n+            new SimpleInterval(dict.getSequence(0).getSequenceName(), 1001, 2000),\n+            new SimpleInterval(dict.getSequence(1).getSequenceName(), 1001, 2000),\n+            new SimpleInterval(dict.getSequence(1).getSequenceName(), 3001, 4000),\n+            new SimpleInterval(dict.getSequence(2).getSequenceName(), 1001, 2000)\n+    );\n+\n+    private static GATKRead createRead( final int refIndex, final int alignStart ) {\n+        return ArtificialReadUtils.createArtificialRead(hdr, \"r1\", refIndex, alignStart, 100);\n+    }\n+\n+    @Test\n+    public void testRegionCheckerBasics() {\n+        final PairWalker.RegionChecker regionChecker = new PairWalker.RegionChecker(intervalList, dict);\n+        Assert.assertFalse(regionChecker.isInInterval(createRead(0, 501)));\n+        Assert.assertTrue(regionChecker.isInInterval(createRead(0, 1501)));\n+        Assert.assertFalse(regionChecker.isInInterval(createRead(0, 2501)));\n+        Assert.assertFalse(regionChecker.isInInterval(createRead(1, 501)));\n+        Assert.assertTrue(regionChecker.isInInterval(createRead(1, 1501)));\n+        Assert.assertTrue(regionChecker.isInInterval(createRead(1, 1701)));\n+        Assert.assertTrue(regionChecker.isInInterval(createRead(1, 1901)));\n+        Assert.assertFalse(regionChecker.isInInterval(createRead(1, 2501)));\n+        Assert.assertFalse(regionChecker.isInInterval(createRead(1, 2901)));\n+        Assert.assertTrue(regionChecker.isInInterval(createRead(1, 3501)));\n+        Assert.assertFalse(regionChecker.isInInterval(createRead(1, 4501)));\n+        Assert.assertFalse(regionChecker.isInInterval(createRead(2, 501)));\n+        Assert.assertTrue(regionChecker.isInInterval(createRead(2, 1501)));\n+        Assert.assertFalse(regionChecker.isInInterval(createRead(2, 2501)));\n+    }\n+\n+    @Test\n+    public void testRegionCheckerEdges() {\n+        final PairWalker.RegionChecker regionChecker = new PairWalker.RegionChecker(intervalList, dict);\n+        Assert.assertFalse(regionChecker.isInInterval(createRead(0, 901)));\n+        Assert.assertTrue(regionChecker.isInInterval(createRead(0, 902)));\n+        Assert.assertTrue(regionChecker.isInInterval(createRead(0, 2000)));\n+        Assert.assertFalse(regionChecker.isInInterval(createRead(0, 2001)));\n+    }\n+\n+    @Test\n+    public void testRegionCheckerIntervalSkipping() {\n+        final PairWalker.RegionChecker regionChecker = new PairWalker.RegionChecker(intervalList, dict);\n+        Assert.assertTrue(regionChecker.isInInterval(createRead(1, 1501)));\n+        Assert.assertTrue(regionChecker.isInInterval(createRead(2, 1501)));\n+    }\n+\n+    private final static class PairWalkerTester extends PairWalker {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e2201c1ef4f8ba71f17e169f07756cfe2f1ecb49"}, "originalPosition": 68}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 768, "cost": 1, "resetAt": "2021-11-12T13:16:51Z"}}}