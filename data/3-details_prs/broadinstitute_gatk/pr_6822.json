{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDg3NDkzNDA0", "number": 6822, "title": "ah - use new GT encoding", "bodyText": "change GTs to single character, drop hom ref, add sample metrics to sample metadata tsv", "createdAt": "2020-09-15T18:58:04Z", "url": "https://github.com/broadinstitute/gatk/pull/6822", "merged": true, "mergeCommit": {"oid": "e5fc8ba6be12ec128c80cc96e01a974d3a42650f"}, "closed": true, "closedAt": "2020-09-16T16:02:51Z", "author": {"login": "ahaessly"}, "timelineItems": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdJLb-eAH2gAyNDg3NDkzNDA0OmYxOGE4MGQ5MDE2NWM3Y2ZjZWZkYmY3M2RjMzJmNDgzODVjMGYxNjE=", "endCursor": "Y3Vyc29yOnYyOpPPAAABdJelEuAH2gAyNDg3NDkzNDA0OmIzNmE0ZWFlYzU1YWM1ZjBjMTdlMWIyMTExYWMwMzdjZGM1MGU5MTk=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "f18a80d90165c7cfcefdbf73dc32f48385c0f161", "author": {"user": {"login": "ahaessly", "name": "Andrea Haessly"}}, "url": "https://github.com/broadinstitute/gatk/commit/f18a80d90165c7cfcefdbf73dc32f48385c0f161", "committedDate": "2020-09-15T17:42:04Z", "message": "change GTs to single character, drop hom ref, add sample metrics to sample metadata tsv"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDg5MDA4NTAw", "url": "https://github.com/broadinstitute/gatk/pull/6822#pullrequestreview-489008500", "createdAt": "2020-09-15T19:34:34Z", "commit": {"oid": "f18a80d90165c7cfcefdbf73dc32f48385c0f161"}, "state": "COMMENTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNVQxOTozNDozNFrOHSRa3Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNVQxOTo0Mzo0OVrOHSR5pg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODkyMTgyMQ==", "bodyText": "Is there only one line in the metrics file? If so, can you put in a check for that?", "url": "https://github.com/broadinstitute/gatk/pull/6822#discussion_r488921821", "createdAt": "2020-09-15T19:34:34Z", "author": {"login": "meganshand"}, "path": "src/main/java/org/broadinstitute/hellbender/tools/variantdb/arrays/ArraySampleTsvCreator.java", "diffHunk": "@@ -0,0 +1,98 @@\n+package org.broadinstitute.hellbender.tools.variantdb.arrays;\n+\n+import org.broadinstitute.hellbender.exceptions.UserException;\n+import org.broadinstitute.hellbender.tools.variantdb.IngestConstants;\n+import org.broadinstitute.hellbender.utils.tsv.SimpleXSVWriter;\n+\n+import java.io.*;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+\n+public class ArraySampleTsvCreator {\n+\n+    private SimpleXSVWriter sampleMetadataWriter = null;\n+    private Map<String, String> metricsMap;\n+\n+\n+    public ArraySampleTsvCreator(String metricsFilepath) {\n+        BufferedReader reader = null;\n+        try {\n+            String columns = null;\n+            String values = null;\n+            reader = new BufferedReader(new FileReader(metricsFilepath));\n+            String line = reader.readLine();\n+            while (line != null) {\n+                if (!line.startsWith(\"#\") && !line.trim().isEmpty()) {\n+                    if (columns == null) {\n+                        columns = line;\n+                    } else {\n+                        values = line;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f18a80d90165c7cfcefdbf73dc32f48385c0f161"}, "originalPosition": 33}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODkyOTcwMg==", "bodyText": "Should this comment be deleted too?", "url": "https://github.com/broadinstitute/gatk/pull/6822#discussion_r488929702", "createdAt": "2020-09-15T19:43:49Z", "author": {"login": "meganshand"}, "path": "src/main/java/org/broadinstitute/hellbender/tools/variantdb/arrays/RawArrayFieldEnum.java", "diffHunk": "@@ -30,67 +36,39 @@ public String getColumnValue(VariantContext variant, ProbeInfo probeInfo, String\n \n     // This where the validation step (required vs not) lives  -- fail if there is missing data for a required field", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f18a80d90165c7cfcefdbf73dc32f48385c0f161"}, "originalPosition": 17}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "010c3b6ba0ee16821ba04d680fadd463024f3000", "author": {"user": {"login": "ahaessly", "name": "Andrea Haessly"}}, "url": "https://github.com/broadinstitute/gatk/commit/010c3b6ba0ee16821ba04d680fadd463024f3000", "committedDate": "2020-09-16T13:26:39Z", "message": "update based on PR feedback"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "42063f72a87187a5845d7e4c041ba3ad10e0fdf3", "author": {"user": {"login": "ahaessly", "name": "Andrea Haessly"}}, "url": "https://github.com/broadinstitute/gatk/commit/42063f72a87187a5845d7e4c041ba3ad10e0fdf3", "committedDate": "2020-09-16T13:40:04Z", "message": "fix errors"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDg5NjQ0Nzcx", "url": "https://github.com/broadinstitute/gatk/pull/6822#pullrequestreview-489644771", "createdAt": "2020-09-16T13:48:48Z", "commit": {"oid": "42063f72a87187a5845d7e4c041ba3ad10e0fdf3"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDg5Njc1NTQ3", "url": "https://github.com/broadinstitute/gatk/pull/6822#pullrequestreview-489675547", "createdAt": "2020-09-16T14:19:05Z", "commit": {"oid": "42063f72a87187a5845d7e4c041ba3ad10e0fdf3"}, "state": "APPROVED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNlQxNDoxOTowNlrOHSzKhA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNlQxNDoyMjoxNFrOHSzT1g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTQ3NDY5Mg==", "bodyText": "I'm so surprised this code doesn't exist anywhere?  the VCFWriter must be doing (largely) the same thing?", "url": "https://github.com/broadinstitute/gatk/pull/6822#discussion_r489474692", "createdAt": "2020-09-16T14:19:06Z", "author": {"login": "kcibul"}, "path": "src/main/java/org/broadinstitute/hellbender/tools/variantdb/CommonCode.java", "diffHunk": "@@ -1,29 +1,51 @@\n package org.broadinstitute.hellbender.tools.variantdb;\n \n import htsjdk.samtools.SAMSequenceDictionary;\n+import htsjdk.variant.variantcontext.Allele;\n+import htsjdk.variant.variantcontext.VariantContext;\n import htsjdk.variant.vcf.*;\n+import org.apache.commons.lang.StringUtils;\n+import org.broadinstitute.hellbender.tools.variantdb.arrays.RawArrayTsvCreator;\n+import org.broadinstitute.hellbender.utils.genotyper.IndexedAlleleList;\n import org.broadinstitute.hellbender.utils.variant.GATKVCFConstants;\n import org.broadinstitute.hellbender.utils.variant.GATKVCFHeaderLines;\n \n+import java.util.ArrayList;\n import java.util.HashSet;\n+import java.util.List;\n import java.util.Set;\n \n //TODO rename this or get rid of it. a place holder for now\n public class CommonCode {\n-    public static final String NORMX = \"NORMX\";\n-    public static final String NORMY = \"NORMY\";\n-    public static final String BAF = \"BAF\";\n-    public static final String LRR = \"LRR\";\n \n \n+    public static String getGTString(final VariantContext variant) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "42063f72a87187a5845d7e4c041ba3ad10e0fdf3"}, "originalPosition": 26}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTQ3NjE4Ng==", "bodyText": "what if it's not two?  should we throw an exception?", "url": "https://github.com/broadinstitute/gatk/pull/6822#discussion_r489476186", "createdAt": "2020-09-16T14:21:04Z", "author": {"login": "kcibul"}, "path": "src/main/java/org/broadinstitute/hellbender/tools/variantdb/arrays/RawArrayFieldEnum.java", "diffHunk": "@@ -3,126 +3,96 @@\n import htsjdk.variant.variantcontext.Allele;\n import htsjdk.variant.variantcontext.Genotype;\n import htsjdk.variant.variantcontext.VariantContext;\n+import org.broadinstitute.hellbender.tools.variantdb.CommonCode;\n import org.broadinstitute.hellbender.tools.variantdb.arrays.tables.ProbeInfo;\n \n+import java.util.Arrays;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+\n \n /**\n  * Expected headers for the  uncompressed array table\n- *     sample, // req\n- *     probe_id, // req\n- *     GT_encoded,\n+ *     sample, // required\n+ *     probe_id, // required\n+ *     GT_encoded, // required\n  *     NORMX, // intensity\n  *     NORMY, // intensity\n  *     BAF // b allele fraction --> AD proxy\n  *     LRR // Log R ratio --> intensity value instead of DP\n  * \n- * Headers for the compressed array table\n- *     basic_array_data\n- *     raw_array_data\n  */\n \n public enum RawArrayFieldEnum {\n-    sample_id {\n-        public String getColumnValue(VariantContext variant, ProbeInfo probeInfo, String sampleId) {\n-            return sampleId;\n-        }\n-    },\n-\n-    // This where the validation step (required vs not) lives  -- fail if there is missing data for a required field\n-    // and just leave it empty if not required\n-    basic_array_data {\n-        public String getColumnValue(final VariantContext variant, ProbeInfo probeInfo, String sampleId) {\n-            String gt = GT_encoded.getColumnValue(variant, probeInfo, sampleId);\n-            BasicArrayData.ArrayGenotype agt;\n-            if (\".\".equals(gt)) {\n-                agt = BasicArrayData.ArrayGenotype.NO_CALL;\n-            } else {\n-                agt = BasicArrayData.ArrayGenotype.valueOf(gt);\n-            }\n-            BasicArrayData d = new BasicArrayData(Integer.parseInt(sampleId), (int) probeInfo.probeId, agt);\n-            return String.valueOf(d.encode());\n-        }\n-    },\n-\n-    raw_array_data {\n-        private Float convert(String s) {\n-            if (s == null || \"\".equals(s) || \"null\".equals(s) ) {\n-                return null;\n-            } else {\n-                return Float.parseFloat(s);                \n-            }\n-        }\n+    // fail if there is missing data for a required field\n+    // and return the string \"null\" if there is missing data for an optional field\n \n-        public String getColumnValue(final VariantContext variant, ProbeInfo probeInfo, String sampleId) {\n-            String normx = NORMX.getColumnValue(variant, probeInfo, sampleId);\n-            String normy = NORMY.getColumnValue(variant, probeInfo, sampleId);\n-            String baf = BAF.getColumnValue(variant, probeInfo, sampleId);\n-            String lrr = LRR.getColumnValue(variant, probeInfo, sampleId);\n+    sample_id,\n+    probe_id,\n+    GT_encoded { // Required\n+        public String getColumnValue(final VariantContext variant) {\n+            List<Integer> alleleIndexes = CommonCode.getGTAlleleIndexes(variant);\n \n-            RawArrayData d = new RawArrayData(convert(normx),\n-                                              convert(normy),\n-                                              convert(baf),\n-                                              convert(lrr)\n-                                              );\n-            return String.valueOf(d.encode());\n-        }\n-    },\n-\n-    probe_id { // Required\n-        public String getColumnValue(final VariantContext variant, ProbeInfo probeInfo, String sampleId) {\n-            return String.valueOf(probeInfo.probeId);\n-        }\n-    },\n-\n-    GT_encoded {\n-        public String getColumnValue(final VariantContext variant, ProbeInfo probeInfo, String sampleId) {\n-            Genotype g = variant.getGenotype(0);\n             RawArrayTsvCreator.GT_encoding gt = RawArrayTsvCreator.GT_encoding.MISSING;\n-            if (g.isHomRef() || g.isHomVar()) {\n-                Allele allele = g.getAllele(0);\n-                if (allele.basesMatch(probeInfo.alleleA)) {\n-                    gt = RawArrayTsvCreator.GT_encoding.AA;\n-                } else if (allele.basesMatch(probeInfo.alleleB)) {\n-                    gt = RawArrayTsvCreator.GT_encoding.BB;\n+            if (alleleIndexes.size() == 2) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "42063f72a87187a5845d7e4c041ba3ad10e0fdf3"}, "originalPosition": 101}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTQ3NzA3OA==", "bodyText": "do you mean the string null or an actual null?", "url": "https://github.com/broadinstitute/gatk/pull/6822#discussion_r489477078", "createdAt": "2020-09-16T14:22:14Z", "author": {"login": "kcibul"}, "path": "src/main/java/org/broadinstitute/hellbender/tools/variantdb/arrays/RawArrayFieldEnum.java", "diffHunk": "@@ -3,126 +3,96 @@\n import htsjdk.variant.variantcontext.Allele;\n import htsjdk.variant.variantcontext.Genotype;\n import htsjdk.variant.variantcontext.VariantContext;\n+import org.broadinstitute.hellbender.tools.variantdb.CommonCode;\n import org.broadinstitute.hellbender.tools.variantdb.arrays.tables.ProbeInfo;\n \n+import java.util.Arrays;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+\n \n /**\n  * Expected headers for the  uncompressed array table\n- *     sample, // req\n- *     probe_id, // req\n- *     GT_encoded,\n+ *     sample, // required\n+ *     probe_id, // required\n+ *     GT_encoded, // required\n  *     NORMX, // intensity\n  *     NORMY, // intensity\n  *     BAF // b allele fraction --> AD proxy\n  *     LRR // Log R ratio --> intensity value instead of DP\n  * \n- * Headers for the compressed array table\n- *     basic_array_data\n- *     raw_array_data\n  */\n \n public enum RawArrayFieldEnum {\n-    sample_id {\n-        public String getColumnValue(VariantContext variant, ProbeInfo probeInfo, String sampleId) {\n-            return sampleId;\n-        }\n-    },\n-\n-    // This where the validation step (required vs not) lives  -- fail if there is missing data for a required field\n-    // and just leave it empty if not required\n-    basic_array_data {\n-        public String getColumnValue(final VariantContext variant, ProbeInfo probeInfo, String sampleId) {\n-            String gt = GT_encoded.getColumnValue(variant, probeInfo, sampleId);\n-            BasicArrayData.ArrayGenotype agt;\n-            if (\".\".equals(gt)) {\n-                agt = BasicArrayData.ArrayGenotype.NO_CALL;\n-            } else {\n-                agt = BasicArrayData.ArrayGenotype.valueOf(gt);\n-            }\n-            BasicArrayData d = new BasicArrayData(Integer.parseInt(sampleId), (int) probeInfo.probeId, agt);\n-            return String.valueOf(d.encode());\n-        }\n-    },\n-\n-    raw_array_data {\n-        private Float convert(String s) {\n-            if (s == null || \"\".equals(s) || \"null\".equals(s) ) {\n-                return null;\n-            } else {\n-                return Float.parseFloat(s);                \n-            }\n-        }\n+    // fail if there is missing data for a required field\n+    // and return the string \"null\" if there is missing data for an optional field\n \n-        public String getColumnValue(final VariantContext variant, ProbeInfo probeInfo, String sampleId) {\n-            String normx = NORMX.getColumnValue(variant, probeInfo, sampleId);\n-            String normy = NORMY.getColumnValue(variant, probeInfo, sampleId);\n-            String baf = BAF.getColumnValue(variant, probeInfo, sampleId);\n-            String lrr = LRR.getColumnValue(variant, probeInfo, sampleId);\n+    sample_id,\n+    probe_id,\n+    GT_encoded { // Required\n+        public String getColumnValue(final VariantContext variant) {\n+            List<Integer> alleleIndexes = CommonCode.getGTAlleleIndexes(variant);\n \n-            RawArrayData d = new RawArrayData(convert(normx),\n-                                              convert(normy),\n-                                              convert(baf),\n-                                              convert(lrr)\n-                                              );\n-            return String.valueOf(d.encode());\n-        }\n-    },\n-\n-    probe_id { // Required\n-        public String getColumnValue(final VariantContext variant, ProbeInfo probeInfo, String sampleId) {\n-            return String.valueOf(probeInfo.probeId);\n-        }\n-    },\n-\n-    GT_encoded {\n-        public String getColumnValue(final VariantContext variant, ProbeInfo probeInfo, String sampleId) {\n-            Genotype g = variant.getGenotype(0);\n             RawArrayTsvCreator.GT_encoding gt = RawArrayTsvCreator.GT_encoding.MISSING;\n-            if (g.isHomRef() || g.isHomVar()) {\n-                Allele allele = g.getAllele(0);\n-                if (allele.basesMatch(probeInfo.alleleA)) {\n-                    gt = RawArrayTsvCreator.GT_encoding.AA;\n-                } else if (allele.basesMatch(probeInfo.alleleB)) {\n-                    gt = RawArrayTsvCreator.GT_encoding.BB;\n+            if (alleleIndexes.size() == 2) {\n+                Set<Integer> uniqueAlleleIndexes = new HashSet<>(alleleIndexes);\n+\n+                if (uniqueAlleleIndexes.size() == 1) {\n+                    // we know it's HOM something\n+                    if (uniqueAlleleIndexes.contains(0)) {\n+                        gt = RawArrayTsvCreator.GT_encoding.HOM_REF;\n+                    } else if (uniqueAlleleIndexes.contains(1)) {\n+                        gt = RawArrayTsvCreator.GT_encoding.HOM_VAR;\n+                    } else if (uniqueAlleleIndexes.contains(2)) {\n+                        gt = RawArrayTsvCreator.GT_encoding.HOM_ALT2;\n+                    }\n                 } else {\n-                    throw new IllegalStateException(\"allele: \" + allele + \" must match either A: \" + probeInfo.alleleA + \" or B: \" + probeInfo.alleleB);\n+                    // we know its het\n+                    if (uniqueAlleleIndexes.containsAll(new HashSet<>(Arrays.asList(0, 1)))) {\n+                        gt = RawArrayTsvCreator.GT_encoding.HET0_1;\n+                    } else if (uniqueAlleleIndexes.containsAll(new HashSet<>(Arrays.asList(1, 2))))\n+                        gt = RawArrayTsvCreator.GT_encoding.HET1_2;\n                 }\n-            } else if (g.isHet()) {\n-                gt = RawArrayTsvCreator.GT_encoding.AB;\n             }\n-            return gt.getValue();\n+            return gt == RawArrayTsvCreator.value_to_drop ? \"null\" : gt.getValue();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "42063f72a87187a5845d7e4c041ba3ad10e0fdf3"}, "originalPosition": 125}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b36a4eaec55ac5f0c17e1b2111ac037cdc50e919", "author": {"user": {"login": "ahaessly", "name": "Andrea Haessly"}}, "url": "https://github.com/broadinstitute/gatk/commit/b36a4eaec55ac5f0c17e1b2111ac037cdc50e919", "committedDate": "2020-09-16T16:00:12Z", "message": "add warning"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2475, "cost": 1, "resetAt": "2021-11-01T13:07:16Z"}}}