{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzkxMjQwNjQy", "number": 6512, "title": "Downsample a bam by duplicate sets instead of reads", "bodyText": "@lbergelson we've chatted about this about a month ago. I recall you wanted me to write a \"ReadWalkerBase,\" which would be the parent class of ReadWalker and DuplicateSetWalker. I haven't done that just yet\u2014in this code DuplicateSetWalker is a subclass of ReadWalker. I wanted to show you this code first before embarking on further refactoring.", "createdAt": "2020-03-19T21:14:15Z", "url": "https://github.com/broadinstitute/gatk/pull/6512", "merged": true, "mergeCommit": {"oid": "4ec2a4b11783cd2bcb3c8998fc11d0f4a44171c9"}, "closed": true, "closedAt": "2020-04-23T22:12:13Z", "author": {"login": "takutosato"}, "timelineItems": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcXRKJ0gFqTM5MjI0MzE4MQ==", "endCursor": "Y3Vyc29yOnYyOpPPAAABcakYgoAFqTM5OTUxMzIxOA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzkyMjQzMTgx", "url": "https://github.com/broadinstitute/gatk/pull/6512#pullrequestreview-392243181", "createdAt": "2020-04-13T16:05:49Z", "commit": {"oid": "c14aa1527401cb1b4eaa1d545d1f966754403e4f"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xM1QxNjowNTo0OVrOGEraRg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xM1QxNjowNTo0OVrOGEraRg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzU1ODcyNg==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public File outputBam;\n          \n          \n            \n                public GATKPathSpecifier outputBam;", "url": "https://github.com/broadinstitute/gatk/pull/6512#discussion_r407558726", "createdAt": "2020-04-13T16:05:49Z", "author": {"login": "cmnbroad"}, "path": "src/main/java/org/broadinstitute/hellbender/tools/walkers/consensus/DownsampleByDuplicateSet.java", "diffHunk": "@@ -0,0 +1,114 @@\n+package org.broadinstitute.hellbender.tools.walkers.consensus;\n+\n+import org.apache.commons.math3.random.RandomGenerator;\n+import org.apache.commons.math3.random.RandomGeneratorFactory;\n+import org.broadinstitute.barclay.argparser.Argument;\n+import org.broadinstitute.barclay.argparser.CommandLineProgramProperties;\n+import org.broadinstitute.hellbender.cmdline.StandardArgumentDefinitions;\n+import org.broadinstitute.hellbender.engine.DuplicateSetWalker;\n+import org.broadinstitute.hellbender.engine.FeatureContext;\n+import org.broadinstitute.hellbender.engine.ReferenceContext;\n+import org.broadinstitute.hellbender.tools.walkers.mutect.consensus.DuplicateSet;\n+import org.broadinstitute.hellbender.utils.io.IOUtils;\n+import org.broadinstitute.hellbender.utils.read.SAMFileGATKReadWriter;\n+import picard.cmdline.programgroups.ReadDataManipulationProgramGroup;\n+\n+import java.io.File;\n+import java.util.List;\n+import java.util.Random;\n+\n+@CommandLineProgramProperties(\n+        summary = \"Discard a set fraction of duplicate sets from a UMI-grouped ba\",\n+        oneLineSummary = \"Discard a set fraction of duplicate sets from a UMI-grouped bam\",\n+        programGroup = ReadDataManipulationProgramGroup.class\n+)\n+/**\n+ * Given a bam grouped by the same unique molecular identifier (UMI), this tool drops a fraction of duplicate sets and returns a new bam.\n+ * A duplicate set refers to a group of reads whose fragments start at and end at the same coordinate and share the same UMI.\n+ *\n+ * The input bam must have been sorted by UMI using FGBio GroupReadsByUmi (http://fulcrumgenomics.github.io/fgbio/tools/latest/GroupReadsByUmi.html).\n+ *\n+ * Use this tool to create, for instance, an insilico mixture of duplex-sequenced samples to simulate tumor subclone.\n+ * Suppose you wish to simulate a tumor sample in which 5% cells share a common set of somatic mutations\n+ * in addition to ones common to the entire cell population.\n+ *\n+ * If you randomly drop 5% of reads in sample A and 95% of reads in sample B and merge the reduced bams,\n+ * the resulting mixture skews the family-size distribution to the left. Here the family size refers to the\n+ * number of sequenced duplicate reads that share the same UMI.\n+ *\n+ * To see this, take a cancer sample, in which 5% of cells (i.e. a subclone) share a unique set of somatic mutations,\n+ * that was processed with duplex-UMIs (i.e. UMIs on both adapters) and high rounds of PCR. Suppose we have the sequence-ready\n+ * libraries of this sample attached to and amplified on the flowcell. Now, sort the flowcell lawn such that the\n+ * 5% subclone moves near the top of the flowcell. This subclone must have the same family-size distribution as\n+ * the rest of the flowcell, at about 5% of the library complexity compared to the entire flowcell.\n+ *\n+ * Now imagine replacing this subclone with 5% of the *entire* flowcell from another sample prepared and sequenced similarly.\n+ * The library complexity of these \"graft\" reads is higher than that of the original, and, consequently, with other parameters\n+ * such as the number of PCR cycles and sequencing depth fixed, its family distribution would be skewed left---that is, the family size\n+ * would be smaller than it should be.\n+ *\n+ * This tool address the above problem by dropping a set fraction of _duplicate sets_, rather than reads, at random.\n+ * Implicit in this approach is that a read and its mate are dropped or retained together.\n+ * While trivial when the input bam is sorted by UMI and query name, this is far from trivial when one attempts\n+ * to downsample reads naively with a tool like {@link PrintReads}.\n+ *\n+ **/\n+public class DownsampleByDuplicateSet extends DuplicateSetWalker {\n+    @Argument(fullName = StandardArgumentDefinitions.OUTPUT_LONG_NAME, shortName = StandardArgumentDefinitions.OUTPUT_SHORT_NAME, doc = \"\")\n+    public File outputBam;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c14aa1527401cb1b4eaa1d545d1f966754403e4f"}, "originalPosition": 58}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzkyMjUxMzg5", "url": "https://github.com/broadinstitute/gatk/pull/6512#pullrequestreview-392251389", "createdAt": "2020-04-13T16:18:16Z", "commit": {"oid": "c14aa1527401cb1b4eaa1d545d1f966754403e4f"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xM1QxNjoxODoxNlrOGEr0Qw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xM1QxNjoxODoxNlrOGEr0Qw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzU2NTM3OQ==", "bodyText": "If you use my GATKPathSpecifier suggestion above, you can just call .toPath() on the GATKPathSpecifier instance here.", "url": "https://github.com/broadinstitute/gatk/pull/6512#discussion_r407565379", "createdAt": "2020-04-13T16:18:16Z", "author": {"login": "cmnbroad"}, "path": "src/main/java/org/broadinstitute/hellbender/tools/walkers/consensus/DownsampleByDuplicateSet.java", "diffHunk": "@@ -0,0 +1,114 @@\n+package org.broadinstitute.hellbender.tools.walkers.consensus;\n+\n+import org.apache.commons.math3.random.RandomGenerator;\n+import org.apache.commons.math3.random.RandomGeneratorFactory;\n+import org.broadinstitute.barclay.argparser.Argument;\n+import org.broadinstitute.barclay.argparser.CommandLineProgramProperties;\n+import org.broadinstitute.hellbender.cmdline.StandardArgumentDefinitions;\n+import org.broadinstitute.hellbender.engine.DuplicateSetWalker;\n+import org.broadinstitute.hellbender.engine.FeatureContext;\n+import org.broadinstitute.hellbender.engine.ReferenceContext;\n+import org.broadinstitute.hellbender.tools.walkers.mutect.consensus.DuplicateSet;\n+import org.broadinstitute.hellbender.utils.io.IOUtils;\n+import org.broadinstitute.hellbender.utils.read.SAMFileGATKReadWriter;\n+import picard.cmdline.programgroups.ReadDataManipulationProgramGroup;\n+\n+import java.io.File;\n+import java.util.List;\n+import java.util.Random;\n+\n+@CommandLineProgramProperties(\n+        summary = \"Discard a set fraction of duplicate sets from a UMI-grouped ba\",\n+        oneLineSummary = \"Discard a set fraction of duplicate sets from a UMI-grouped bam\",\n+        programGroup = ReadDataManipulationProgramGroup.class\n+)\n+/**\n+ * Given a bam grouped by the same unique molecular identifier (UMI), this tool drops a fraction of duplicate sets and returns a new bam.\n+ * A duplicate set refers to a group of reads whose fragments start at and end at the same coordinate and share the same UMI.\n+ *\n+ * The input bam must have been sorted by UMI using FGBio GroupReadsByUmi (http://fulcrumgenomics.github.io/fgbio/tools/latest/GroupReadsByUmi.html).\n+ *\n+ * Use this tool to create, for instance, an insilico mixture of duplex-sequenced samples to simulate tumor subclone.\n+ * Suppose you wish to simulate a tumor sample in which 5% cells share a common set of somatic mutations\n+ * in addition to ones common to the entire cell population.\n+ *\n+ * If you randomly drop 5% of reads in sample A and 95% of reads in sample B and merge the reduced bams,\n+ * the resulting mixture skews the family-size distribution to the left. Here the family size refers to the\n+ * number of sequenced duplicate reads that share the same UMI.\n+ *\n+ * To see this, take a cancer sample, in which 5% of cells (i.e. a subclone) share a unique set of somatic mutations,\n+ * that was processed with duplex-UMIs (i.e. UMIs on both adapters) and high rounds of PCR. Suppose we have the sequence-ready\n+ * libraries of this sample attached to and amplified on the flowcell. Now, sort the flowcell lawn such that the\n+ * 5% subclone moves near the top of the flowcell. This subclone must have the same family-size distribution as\n+ * the rest of the flowcell, at about 5% of the library complexity compared to the entire flowcell.\n+ *\n+ * Now imagine replacing this subclone with 5% of the *entire* flowcell from another sample prepared and sequenced similarly.\n+ * The library complexity of these \"graft\" reads is higher than that of the original, and, consequently, with other parameters\n+ * such as the number of PCR cycles and sequencing depth fixed, its family distribution would be skewed left---that is, the family size\n+ * would be smaller than it should be.\n+ *\n+ * This tool address the above problem by dropping a set fraction of _duplicate sets_, rather than reads, at random.\n+ * Implicit in this approach is that a read and its mate are dropped or retained together.\n+ * While trivial when the input bam is sorted by UMI and query name, this is far from trivial when one attempts\n+ * to downsample reads naively with a tool like {@link PrintReads}.\n+ *\n+ **/\n+public class DownsampleByDuplicateSet extends DuplicateSetWalker {\n+    @Argument(fullName = StandardArgumentDefinitions.OUTPUT_LONG_NAME, shortName = StandardArgumentDefinitions.OUTPUT_SHORT_NAME, doc = \"\")\n+    public File outputBam;\n+\n+    @Argument(fullName = \"DS\", doc = \"This fraction of duplicate sets in the input bam will be retained\")\n+    public double downsamplingRate;\n+\n+    @Argument(fullName = \"keep-duplex-only\", doc = \"Discard all duplicate sets that don't have duplex evidence\")\n+    public boolean duplexOnly = false;\n+\n+    private static final int RANDOM_SEED = 142;\n+    private RandomGenerator rng;\n+    private static int numFragments;\n+    private static int numReads;\n+    private SAMFileGATKReadWriter outputWriter;\n+\n+    @Override\n+    public void onTraversalStart() {\n+        super.onTraversalStart();\n+        rng = RandomGeneratorFactory.createRandomGenerator(new Random(RANDOM_SEED));\n+        outputWriter = createSAMWriter(IOUtils.getPath(outputBam.getAbsolutePath()), false);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c14aa1527401cb1b4eaa1d545d1f966754403e4f"}, "originalPosition": 76}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzkxNjkzNzEw", "url": "https://github.com/broadinstitute/gatk/pull/6512#pullrequestreview-391693710", "createdAt": "2020-04-10T22:38:00Z", "commit": {"oid": "c14aa1527401cb1b4eaa1d545d1f966754403e4f"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 42, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xMFQyMjozODowMFrOGEHiUg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xM1QyMToyMzowM1rOGE11wg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjk3MDk2Mg==", "bodyText": "I wouldn't.  I don't think the performance gain is worth the potential confusion if someone does something like try to accumulate duplicate sets during the traversal.", "url": "https://github.com/broadinstitute/gatk/pull/6512#discussion_r406970962", "createdAt": "2020-04-10T22:38:00Z", "author": {"login": "lbergelson"}, "path": "src/main/java/org/broadinstitute/hellbender/engine/DuplicateSetWalker.java", "diffHunk": "@@ -0,0 +1,83 @@\n+package org.broadinstitute.hellbender.engine;\n+\n+import org.broadinstitute.hellbender.tools.walkers.mutect.consensus.DuplicateSet;\n+import org.broadinstitute.hellbender.utils.Utils;\n+import org.broadinstitute.hellbender.utils.read.GATKRead;\n+\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * A walker that processes duplicate reads that share the same UMI as a single unit.\n+ *\n+ * This tool assumes that the input bam has been sorted by UMI with FGBio GroupReadsByUmi:\n+ * http://fulcrumgenomics.github.io/fgbio/tools/latest/GroupReadsByUmi.html\n+ */\n+public abstract class DuplicateSetWalker extends ReadWalker {\n+    DuplicateSet currentDuplicateSet; // TODO: does it make sense to call clear() and recycle the same object?", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c14aa1527401cb1b4eaa1d545d1f966754403e4f"}, "originalPosition": 17}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjk3MTExMg==", "bodyText": "I'm not super happy about that, it makes it less clear if downstream tools are meant to override it.", "url": "https://github.com/broadinstitute/gatk/pull/6512#discussion_r406971112", "createdAt": "2020-04-10T22:38:36Z", "author": {"login": "lbergelson"}, "path": "src/main/java/org/broadinstitute/hellbender/engine/DuplicateSetWalker.java", "diffHunk": "@@ -0,0 +1,83 @@\n+package org.broadinstitute.hellbender.engine;\n+\n+import org.broadinstitute.hellbender.tools.walkers.mutect.consensus.DuplicateSet;\n+import org.broadinstitute.hellbender.utils.Utils;\n+import org.broadinstitute.hellbender.utils.read.GATKRead;\n+\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * A walker that processes duplicate reads that share the same UMI as a single unit.\n+ *\n+ * This tool assumes that the input bam has been sorted by UMI with FGBio GroupReadsByUmi:\n+ * http://fulcrumgenomics.github.io/fgbio/tools/latest/GroupReadsByUmi.html\n+ */\n+public abstract class DuplicateSetWalker extends ReadWalker {\n+    DuplicateSet currentDuplicateSet; // TODO: does it make sense to call clear() and recycle the same object?\n+    public static int INITIAL_MOLECULAR_ID = -1;\n+\n+    @Override\n+    public final void onStartup(){\n+        // TODO: I had to make onStartUp of ReadWalker not final to do this. The right thing to do here is to", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c14aa1527401cb1b4eaa1d545d1f966754403e4f"}, "originalPosition": 22}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjk3MTUwNw==", "bodyText": "Maybe I'm being dense, but couldn't you initialize this in place when you define the variable and not need to do it here?  That would avoid the need for overriding onStartup.  If you can't instantiate a DuplicateSet and set the ID at the same time, I would just change duplicate set.  It would probably be better though if instead of exposing a magic number, DuplicateSet had a function like isEmpty() that would answer the question of if a read has been added to it yet.", "url": "https://github.com/broadinstitute/gatk/pull/6512#discussion_r406971507", "createdAt": "2020-04-10T22:40:11Z", "author": {"login": "lbergelson"}, "path": "src/main/java/org/broadinstitute/hellbender/engine/DuplicateSetWalker.java", "diffHunk": "@@ -0,0 +1,83 @@\n+package org.broadinstitute.hellbender.engine;\n+\n+import org.broadinstitute.hellbender.tools.walkers.mutect.consensus.DuplicateSet;\n+import org.broadinstitute.hellbender.utils.Utils;\n+import org.broadinstitute.hellbender.utils.read.GATKRead;\n+\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * A walker that processes duplicate reads that share the same UMI as a single unit.\n+ *\n+ * This tool assumes that the input bam has been sorted by UMI with FGBio GroupReadsByUmi:\n+ * http://fulcrumgenomics.github.io/fgbio/tools/latest/GroupReadsByUmi.html\n+ */\n+public abstract class DuplicateSetWalker extends ReadWalker {\n+    DuplicateSet currentDuplicateSet; // TODO: does it make sense to call clear() and recycle the same object?\n+    public static int INITIAL_MOLECULAR_ID = -1;\n+\n+    @Override\n+    public final void onStartup(){\n+        // TODO: I had to make onStartUp of ReadWalker not final to do this. The right thing to do here is to\n+        // write a ReadWalkerBase parent class for both ReadWalker and DuplicateSet Walker, as Louis suggested.\n+        super.onStartup();\n+        currentDuplicateSet = new DuplicateSet();\n+        currentDuplicateSet.setMoleduleId(INITIAL_MOLECULAR_ID);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c14aa1527401cb1b4eaa1d545d1f966754403e4f"}, "originalPosition": 26}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjk3MTY4OA==", "bodyText": "Is there any way to tell if the file is sorted in the correct way or not?  It would be good to check that it is somehow.", "url": "https://github.com/broadinstitute/gatk/pull/6512#discussion_r406971688", "createdAt": "2020-04-10T22:40:57Z", "author": {"login": "lbergelson"}, "path": "src/main/java/org/broadinstitute/hellbender/engine/DuplicateSetWalker.java", "diffHunk": "@@ -0,0 +1,83 @@\n+package org.broadinstitute.hellbender.engine;\n+\n+import org.broadinstitute.hellbender.tools.walkers.mutect.consensus.DuplicateSet;\n+import org.broadinstitute.hellbender.utils.Utils;\n+import org.broadinstitute.hellbender.utils.read.GATKRead;\n+\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * A walker that processes duplicate reads that share the same UMI as a single unit.\n+ *\n+ * This tool assumes that the input bam has been sorted by UMI with FGBio GroupReadsByUmi:\n+ * http://fulcrumgenomics.github.io/fgbio/tools/latest/GroupReadsByUmi.html\n+ */\n+public abstract class DuplicateSetWalker extends ReadWalker {\n+    DuplicateSet currentDuplicateSet; // TODO: does it make sense to call clear() and recycle the same object?\n+    public static int INITIAL_MOLECULAR_ID = -1;\n+\n+    @Override\n+    public final void onStartup(){\n+        // TODO: I had to make onStartUp of ReadWalker not final to do this. The right thing to do here is to\n+        // write a ReadWalkerBase parent class for both ReadWalker and DuplicateSet Walker, as Louis suggested.\n+        super.onStartup();\n+        currentDuplicateSet = new DuplicateSet();\n+        currentDuplicateSet.setMoleduleId(INITIAL_MOLECULAR_ID);\n+    }\n+\n+    /***\n+     * FGBio GroupByUMI returns reads sorted by molecular ID: For example, the input bam may look like\n+     * read1: ... MI:Z:0/A ...\n+     * read2: ... MI:Z:0/A ...\n+     * read3: ... MI:Z:0/B ...\n+     * read4: ... MI:Z:0/B ...\n+     * read5: ... MI:Z:1/A ...\n+     * read6: ... MI:Z:1/B ...\n+     * read7: ... MI:Z:1/B ...\n+     *\n+     * Thus it's sufficient to go through the reads in order and collect them in a list until", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c14aa1527401cb1b4eaa1d545d1f966754403e4f"}, "originalPosition": 39}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjk3MTg3Ng==", "bodyText": "You could do something silly like using a bloom filter to track already seen molecules ID's and warn if you see a surplus of collisions.", "url": "https://github.com/broadinstitute/gatk/pull/6512#discussion_r406971876", "createdAt": "2020-04-10T22:41:56Z", "author": {"login": "lbergelson"}, "path": "src/main/java/org/broadinstitute/hellbender/engine/DuplicateSetWalker.java", "diffHunk": "@@ -0,0 +1,83 @@\n+package org.broadinstitute.hellbender.engine;\n+\n+import org.broadinstitute.hellbender.tools.walkers.mutect.consensus.DuplicateSet;\n+import org.broadinstitute.hellbender.utils.Utils;\n+import org.broadinstitute.hellbender.utils.read.GATKRead;\n+\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * A walker that processes duplicate reads that share the same UMI as a single unit.\n+ *\n+ * This tool assumes that the input bam has been sorted by UMI with FGBio GroupReadsByUmi:\n+ * http://fulcrumgenomics.github.io/fgbio/tools/latest/GroupReadsByUmi.html\n+ */\n+public abstract class DuplicateSetWalker extends ReadWalker {\n+    DuplicateSet currentDuplicateSet; // TODO: does it make sense to call clear() and recycle the same object?\n+    public static int INITIAL_MOLECULAR_ID = -1;\n+\n+    @Override\n+    public final void onStartup(){\n+        // TODO: I had to make onStartUp of ReadWalker not final to do this. The right thing to do here is to\n+        // write a ReadWalkerBase parent class for both ReadWalker and DuplicateSet Walker, as Louis suggested.\n+        super.onStartup();\n+        currentDuplicateSet = new DuplicateSet();\n+        currentDuplicateSet.setMoleduleId(INITIAL_MOLECULAR_ID);\n+    }\n+\n+    /***\n+     * FGBio GroupByUMI returns reads sorted by molecular ID: For example, the input bam may look like\n+     * read1: ... MI:Z:0/A ...\n+     * read2: ... MI:Z:0/A ...\n+     * read3: ... MI:Z:0/B ...\n+     * read4: ... MI:Z:0/B ...\n+     * read5: ... MI:Z:1/A ...\n+     * read6: ... MI:Z:1/B ...\n+     * read7: ... MI:Z:1/B ...\n+     *\n+     * Thus it's sufficient to go through the reads in order and collect them in a list until", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjk3MTY4OA=="}, "originalCommit": {"oid": "c14aa1527401cb1b4eaa1d545d1f966754403e4f"}, "originalPosition": 39}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjk3MzA1Ng==", "bodyText": "final", "url": "https://github.com/broadinstitute/gatk/pull/6512#discussion_r406973056", "createdAt": "2020-04-10T22:47:03Z", "author": {"login": "lbergelson"}, "path": "src/main/java/org/broadinstitute/hellbender/engine/DuplicateSetWalker.java", "diffHunk": "@@ -0,0 +1,83 @@\n+package org.broadinstitute.hellbender.engine;\n+\n+import org.broadinstitute.hellbender.tools.walkers.mutect.consensus.DuplicateSet;\n+import org.broadinstitute.hellbender.utils.Utils;\n+import org.broadinstitute.hellbender.utils.read.GATKRead;\n+\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * A walker that processes duplicate reads that share the same UMI as a single unit.\n+ *\n+ * This tool assumes that the input bam has been sorted by UMI with FGBio GroupReadsByUmi:\n+ * http://fulcrumgenomics.github.io/fgbio/tools/latest/GroupReadsByUmi.html\n+ */\n+public abstract class DuplicateSetWalker extends ReadWalker {\n+    DuplicateSet currentDuplicateSet; // TODO: does it make sense to call clear() and recycle the same object?\n+    public static int INITIAL_MOLECULAR_ID = -1;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c14aa1527401cb1b4eaa1d545d1f966754403e4f"}, "originalPosition": 18}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzcwNTcyOQ==", "bodyText": "I would check if the bam have any sorting subkeys specified, it's a thing Nil's and Tim wanted to add to the spec so they might be outputting the.  I don't think htsjdk knows about them yet but if it exists in the bams it would be a good reason to make htsjdk aware of it.", "url": "https://github.com/broadinstitute/gatk/pull/6512#discussion_r407705729", "createdAt": "2020-04-13T20:36:53Z", "author": {"login": "lbergelson"}, "path": "src/main/java/org/broadinstitute/hellbender/engine/DuplicateSetWalker.java", "diffHunk": "@@ -0,0 +1,83 @@\n+package org.broadinstitute.hellbender.engine;\n+\n+import org.broadinstitute.hellbender.tools.walkers.mutect.consensus.DuplicateSet;\n+import org.broadinstitute.hellbender.utils.Utils;\n+import org.broadinstitute.hellbender.utils.read.GATKRead;\n+\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * A walker that processes duplicate reads that share the same UMI as a single unit.\n+ *\n+ * This tool assumes that the input bam has been sorted by UMI with FGBio GroupReadsByUmi:\n+ * http://fulcrumgenomics.github.io/fgbio/tools/latest/GroupReadsByUmi.html\n+ */\n+public abstract class DuplicateSetWalker extends ReadWalker {\n+    DuplicateSet currentDuplicateSet; // TODO: does it make sense to call clear() and recycle the same object?\n+    public static int INITIAL_MOLECULAR_ID = -1;\n+\n+    @Override\n+    public final void onStartup(){\n+        // TODO: I had to make onStartUp of ReadWalker not final to do this. The right thing to do here is to\n+        // write a ReadWalkerBase parent class for both ReadWalker and DuplicateSet Walker, as Louis suggested.\n+        super.onStartup();\n+        currentDuplicateSet = new DuplicateSet();\n+        currentDuplicateSet.setMoleduleId(INITIAL_MOLECULAR_ID);\n+    }\n+\n+    /***\n+     * FGBio GroupByUMI returns reads sorted by molecular ID: For example, the input bam may look like\n+     * read1: ... MI:Z:0/A ...\n+     * read2: ... MI:Z:0/A ...\n+     * read3: ... MI:Z:0/B ...\n+     * read4: ... MI:Z:0/B ...\n+     * read5: ... MI:Z:1/A ...\n+     * read6: ... MI:Z:1/B ...\n+     * read7: ... MI:Z:1/B ...\n+     *\n+     * Thus it's sufficient to go through the reads in order and collect them in a list until", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjk3MTY4OA=="}, "originalCommit": {"oid": "c14aa1527401cb1b4eaa1d545d1f966754403e4f"}, "originalPosition": 39}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzcwNjU2Nw==", "bodyText": "Make this final so downstream tools don't accidentally think they have to override it.  Modify the javadoc to explain that this shouldn't be called by the user and is only public because of prior constraints and point to the new apply they have to implement.", "url": "https://github.com/broadinstitute/gatk/pull/6512#discussion_r407706567", "createdAt": "2020-04-13T20:38:29Z", "author": {"login": "lbergelson"}, "path": "src/main/java/org/broadinstitute/hellbender/engine/DuplicateSetWalker.java", "diffHunk": "@@ -0,0 +1,83 @@\n+package org.broadinstitute.hellbender.engine;\n+\n+import org.broadinstitute.hellbender.tools.walkers.mutect.consensus.DuplicateSet;\n+import org.broadinstitute.hellbender.utils.Utils;\n+import org.broadinstitute.hellbender.utils.read.GATKRead;\n+\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * A walker that processes duplicate reads that share the same UMI as a single unit.\n+ *\n+ * This tool assumes that the input bam has been sorted by UMI with FGBio GroupReadsByUmi:\n+ * http://fulcrumgenomics.github.io/fgbio/tools/latest/GroupReadsByUmi.html\n+ */\n+public abstract class DuplicateSetWalker extends ReadWalker {\n+    DuplicateSet currentDuplicateSet; // TODO: does it make sense to call clear() and recycle the same object?\n+    public static int INITIAL_MOLECULAR_ID = -1;\n+\n+    @Override\n+    public final void onStartup(){\n+        // TODO: I had to make onStartUp of ReadWalker not final to do this. The right thing to do here is to\n+        // write a ReadWalkerBase parent class for both ReadWalker and DuplicateSet Walker, as Louis suggested.\n+        super.onStartup();\n+        currentDuplicateSet = new DuplicateSet();\n+        currentDuplicateSet.setMoleduleId(INITIAL_MOLECULAR_ID);\n+    }\n+\n+    /***\n+     * FGBio GroupByUMI returns reads sorted by molecular ID: For example, the input bam may look like\n+     * read1: ... MI:Z:0/A ...\n+     * read2: ... MI:Z:0/A ...\n+     * read3: ... MI:Z:0/B ...\n+     * read4: ... MI:Z:0/B ...\n+     * read5: ... MI:Z:1/A ...\n+     * read6: ... MI:Z:1/B ...\n+     * read7: ... MI:Z:1/B ...\n+     *\n+     * Thus it's sufficient to go through the reads in order and collect them in a list until\n+     * we encounter the next molecular ID, at which point we pass the list to the {@code apply}\n+     * method of the child class and clear the {@code currentDuplicateSet} variable.\n+     *\n+     */\n+    @Override\n+    public void apply(GATKRead read, ReferenceContext referenceContext, FeatureContext featureContext) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c14aa1527401cb1b4eaa1d545d1f966754403e4f"}, "originalPosition": 45}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzcwNjk4NA==", "bodyText": "This needs javadoc", "url": "https://github.com/broadinstitute/gatk/pull/6512#discussion_r407706984", "createdAt": "2020-04-13T20:39:18Z", "author": {"login": "lbergelson"}, "path": "src/main/java/org/broadinstitute/hellbender/engine/DuplicateSetWalker.java", "diffHunk": "@@ -0,0 +1,83 @@\n+package org.broadinstitute.hellbender.engine;\n+\n+import org.broadinstitute.hellbender.tools.walkers.mutect.consensus.DuplicateSet;\n+import org.broadinstitute.hellbender.utils.Utils;\n+import org.broadinstitute.hellbender.utils.read.GATKRead;\n+\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * A walker that processes duplicate reads that share the same UMI as a single unit.\n+ *\n+ * This tool assumes that the input bam has been sorted by UMI with FGBio GroupReadsByUmi:\n+ * http://fulcrumgenomics.github.io/fgbio/tools/latest/GroupReadsByUmi.html\n+ */\n+public abstract class DuplicateSetWalker extends ReadWalker {\n+    DuplicateSet currentDuplicateSet; // TODO: does it make sense to call clear() and recycle the same object?\n+    public static int INITIAL_MOLECULAR_ID = -1;\n+\n+    @Override\n+    public final void onStartup(){\n+        // TODO: I had to make onStartUp of ReadWalker not final to do this. The right thing to do here is to\n+        // write a ReadWalkerBase parent class for both ReadWalker and DuplicateSet Walker, as Louis suggested.\n+        super.onStartup();\n+        currentDuplicateSet = new DuplicateSet();\n+        currentDuplicateSet.setMoleduleId(INITIAL_MOLECULAR_ID);\n+    }\n+\n+    /***\n+     * FGBio GroupByUMI returns reads sorted by molecular ID: For example, the input bam may look like\n+     * read1: ... MI:Z:0/A ...\n+     * read2: ... MI:Z:0/A ...\n+     * read3: ... MI:Z:0/B ...\n+     * read4: ... MI:Z:0/B ...\n+     * read5: ... MI:Z:1/A ...\n+     * read6: ... MI:Z:1/B ...\n+     * read7: ... MI:Z:1/B ...\n+     *\n+     * Thus it's sufficient to go through the reads in order and collect them in a list until\n+     * we encounter the next molecular ID, at which point we pass the list to the {@code apply}\n+     * method of the child class and clear the {@code currentDuplicateSet} variable.\n+     *\n+     */\n+    @Override\n+    public void apply(GATKRead read, ReferenceContext referenceContext, FeatureContext featureContext) {\n+        if (currentDuplicateSet.getMoleculeId() != DuplicateSet.getMoleculeID(read)) {\n+            if (rejectDuplicateSet(currentDuplicateSet)){\n+                currentDuplicateSet = new DuplicateSet(read);\n+                return;\n+            }\n+\n+            apply(currentDuplicateSet,\n+                    new ReferenceContext(reference, currentDuplicateSet.getDuplicateSetInterval()), // Will create an empty ReferenceContext if reference or readInterval == null\n+                    new FeatureContext(features, currentDuplicateSet.getDuplicateSetInterval()));\n+            currentDuplicateSet = new DuplicateSet(read);\n+        } else {\n+            Utils.validate(currentDuplicateSet.addRead(read), \"Adding a read that doesn't have a matching molecular ID tag\");\n+        }\n+    }\n+\n+    public abstract void apply(DuplicateSet duplicateSet, ReferenceContext referenceContext, FeatureContext featureContext );", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c14aa1527401cb1b4eaa1d545d1f966754403e4f"}, "originalPosition": 61}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzcwNzMyNw==", "bodyText": "This also needs javadoc explaining what it does and if you need to override it.", "url": "https://github.com/broadinstitute/gatk/pull/6512#discussion_r407707327", "createdAt": "2020-04-13T20:39:55Z", "author": {"login": "lbergelson"}, "path": "src/main/java/org/broadinstitute/hellbender/engine/DuplicateSetWalker.java", "diffHunk": "@@ -0,0 +1,83 @@\n+package org.broadinstitute.hellbender.engine;\n+\n+import org.broadinstitute.hellbender.tools.walkers.mutect.consensus.DuplicateSet;\n+import org.broadinstitute.hellbender.utils.Utils;\n+import org.broadinstitute.hellbender.utils.read.GATKRead;\n+\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * A walker that processes duplicate reads that share the same UMI as a single unit.\n+ *\n+ * This tool assumes that the input bam has been sorted by UMI with FGBio GroupReadsByUmi:\n+ * http://fulcrumgenomics.github.io/fgbio/tools/latest/GroupReadsByUmi.html\n+ */\n+public abstract class DuplicateSetWalker extends ReadWalker {\n+    DuplicateSet currentDuplicateSet; // TODO: does it make sense to call clear() and recycle the same object?\n+    public static int INITIAL_MOLECULAR_ID = -1;\n+\n+    @Override\n+    public final void onStartup(){\n+        // TODO: I had to make onStartUp of ReadWalker not final to do this. The right thing to do here is to\n+        // write a ReadWalkerBase parent class for both ReadWalker and DuplicateSet Walker, as Louis suggested.\n+        super.onStartup();\n+        currentDuplicateSet = new DuplicateSet();\n+        currentDuplicateSet.setMoleduleId(INITIAL_MOLECULAR_ID);\n+    }\n+\n+    /***\n+     * FGBio GroupByUMI returns reads sorted by molecular ID: For example, the input bam may look like\n+     * read1: ... MI:Z:0/A ...\n+     * read2: ... MI:Z:0/A ...\n+     * read3: ... MI:Z:0/B ...\n+     * read4: ... MI:Z:0/B ...\n+     * read5: ... MI:Z:1/A ...\n+     * read6: ... MI:Z:1/B ...\n+     * read7: ... MI:Z:1/B ...\n+     *\n+     * Thus it's sufficient to go through the reads in order and collect them in a list until\n+     * we encounter the next molecular ID, at which point we pass the list to the {@code apply}\n+     * method of the child class and clear the {@code currentDuplicateSet} variable.\n+     *\n+     */\n+    @Override\n+    public void apply(GATKRead read, ReferenceContext referenceContext, FeatureContext featureContext) {\n+        if (currentDuplicateSet.getMoleculeId() != DuplicateSet.getMoleculeID(read)) {\n+            if (rejectDuplicateSet(currentDuplicateSet)){\n+                currentDuplicateSet = new DuplicateSet(read);\n+                return;\n+            }\n+\n+            apply(currentDuplicateSet,\n+                    new ReferenceContext(reference, currentDuplicateSet.getDuplicateSetInterval()), // Will create an empty ReferenceContext if reference or readInterval == null\n+                    new FeatureContext(features, currentDuplicateSet.getDuplicateSetInterval()));\n+            currentDuplicateSet = new DuplicateSet(read);\n+        } else {\n+            Utils.validate(currentDuplicateSet.addRead(read), \"Adding a read that doesn't have a matching molecular ID tag\");\n+        }\n+    }\n+\n+    public abstract void apply(DuplicateSet duplicateSet, ReferenceContext referenceContext, FeatureContext featureContext );\n+\n+    protected boolean rejectDuplicateSet(final DuplicateSet duplicateSet){", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c14aa1527401cb1b4eaa1d545d1f966754403e4f"}, "originalPosition": 63}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzcwNzQ3Mw==", "bodyText": "Is this a normal thing that happens or an error condition?", "url": "https://github.com/broadinstitute/gatk/pull/6512#discussion_r407707473", "createdAt": "2020-04-13T20:40:12Z", "author": {"login": "lbergelson"}, "path": "src/main/java/org/broadinstitute/hellbender/engine/DuplicateSetWalker.java", "diffHunk": "@@ -0,0 +1,83 @@\n+package org.broadinstitute.hellbender.engine;\n+\n+import org.broadinstitute.hellbender.tools.walkers.mutect.consensus.DuplicateSet;\n+import org.broadinstitute.hellbender.utils.Utils;\n+import org.broadinstitute.hellbender.utils.read.GATKRead;\n+\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * A walker that processes duplicate reads that share the same UMI as a single unit.\n+ *\n+ * This tool assumes that the input bam has been sorted by UMI with FGBio GroupReadsByUmi:\n+ * http://fulcrumgenomics.github.io/fgbio/tools/latest/GroupReadsByUmi.html\n+ */\n+public abstract class DuplicateSetWalker extends ReadWalker {\n+    DuplicateSet currentDuplicateSet; // TODO: does it make sense to call clear() and recycle the same object?\n+    public static int INITIAL_MOLECULAR_ID = -1;\n+\n+    @Override\n+    public final void onStartup(){\n+        // TODO: I had to make onStartUp of ReadWalker not final to do this. The right thing to do here is to\n+        // write a ReadWalkerBase parent class for both ReadWalker and DuplicateSet Walker, as Louis suggested.\n+        super.onStartup();\n+        currentDuplicateSet = new DuplicateSet();\n+        currentDuplicateSet.setMoleduleId(INITIAL_MOLECULAR_ID);\n+    }\n+\n+    /***\n+     * FGBio GroupByUMI returns reads sorted by molecular ID: For example, the input bam may look like\n+     * read1: ... MI:Z:0/A ...\n+     * read2: ... MI:Z:0/A ...\n+     * read3: ... MI:Z:0/B ...\n+     * read4: ... MI:Z:0/B ...\n+     * read5: ... MI:Z:1/A ...\n+     * read6: ... MI:Z:1/B ...\n+     * read7: ... MI:Z:1/B ...\n+     *\n+     * Thus it's sufficient to go through the reads in order and collect them in a list until\n+     * we encounter the next molecular ID, at which point we pass the list to the {@code apply}\n+     * method of the child class and clear the {@code currentDuplicateSet} variable.\n+     *\n+     */\n+    @Override\n+    public void apply(GATKRead read, ReferenceContext referenceContext, FeatureContext featureContext) {\n+        if (currentDuplicateSet.getMoleculeId() != DuplicateSet.getMoleculeID(read)) {\n+            if (rejectDuplicateSet(currentDuplicateSet)){\n+                currentDuplicateSet = new DuplicateSet(read);\n+                return;\n+            }\n+\n+            apply(currentDuplicateSet,\n+                    new ReferenceContext(reference, currentDuplicateSet.getDuplicateSetInterval()), // Will create an empty ReferenceContext if reference or readInterval == null\n+                    new FeatureContext(features, currentDuplicateSet.getDuplicateSetInterval()));\n+            currentDuplicateSet = new DuplicateSet(read);\n+        } else {\n+            Utils.validate(currentDuplicateSet.addRead(read), \"Adding a read that doesn't have a matching molecular ID tag\");\n+        }\n+    }\n+\n+    public abstract void apply(DuplicateSet duplicateSet, ReferenceContext referenceContext, FeatureContext featureContext );\n+\n+    protected boolean rejectDuplicateSet(final DuplicateSet duplicateSet){\n+        if (!duplicateSet.hasValidInterval()) {\n+            logger.info(\"Duplicate Set with Invalid Intervals\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c14aa1527401cb1b4eaa1d545d1f966754403e4f"}, "originalPosition": 65}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzcwODExNw==", "bodyText": "Lets extract this boolean as variable the first time we compute it.  That way if someone edits the code we can't get a mismatching case between the warning and the return value.", "url": "https://github.com/broadinstitute/gatk/pull/6512#discussion_r407708117", "createdAt": "2020-04-13T20:41:25Z", "author": {"login": "lbergelson"}, "path": "src/main/java/org/broadinstitute/hellbender/engine/DuplicateSetWalker.java", "diffHunk": "@@ -0,0 +1,83 @@\n+package org.broadinstitute.hellbender.engine;\n+\n+import org.broadinstitute.hellbender.tools.walkers.mutect.consensus.DuplicateSet;\n+import org.broadinstitute.hellbender.utils.Utils;\n+import org.broadinstitute.hellbender.utils.read.GATKRead;\n+\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * A walker that processes duplicate reads that share the same UMI as a single unit.\n+ *\n+ * This tool assumes that the input bam has been sorted by UMI with FGBio GroupReadsByUmi:\n+ * http://fulcrumgenomics.github.io/fgbio/tools/latest/GroupReadsByUmi.html\n+ */\n+public abstract class DuplicateSetWalker extends ReadWalker {\n+    DuplicateSet currentDuplicateSet; // TODO: does it make sense to call clear() and recycle the same object?\n+    public static int INITIAL_MOLECULAR_ID = -1;\n+\n+    @Override\n+    public final void onStartup(){\n+        // TODO: I had to make onStartUp of ReadWalker not final to do this. The right thing to do here is to\n+        // write a ReadWalkerBase parent class for both ReadWalker and DuplicateSet Walker, as Louis suggested.\n+        super.onStartup();\n+        currentDuplicateSet = new DuplicateSet();\n+        currentDuplicateSet.setMoleduleId(INITIAL_MOLECULAR_ID);\n+    }\n+\n+    /***\n+     * FGBio GroupByUMI returns reads sorted by molecular ID: For example, the input bam may look like\n+     * read1: ... MI:Z:0/A ...\n+     * read2: ... MI:Z:0/A ...\n+     * read3: ... MI:Z:0/B ...\n+     * read4: ... MI:Z:0/B ...\n+     * read5: ... MI:Z:1/A ...\n+     * read6: ... MI:Z:1/B ...\n+     * read7: ... MI:Z:1/B ...\n+     *\n+     * Thus it's sufficient to go through the reads in order and collect them in a list until\n+     * we encounter the next molecular ID, at which point we pass the list to the {@code apply}\n+     * method of the child class and clear the {@code currentDuplicateSet} variable.\n+     *\n+     */\n+    @Override\n+    public void apply(GATKRead read, ReferenceContext referenceContext, FeatureContext featureContext) {\n+        if (currentDuplicateSet.getMoleculeId() != DuplicateSet.getMoleculeID(read)) {\n+            if (rejectDuplicateSet(currentDuplicateSet)){\n+                currentDuplicateSet = new DuplicateSet(read);\n+                return;\n+            }\n+\n+            apply(currentDuplicateSet,\n+                    new ReferenceContext(reference, currentDuplicateSet.getDuplicateSetInterval()), // Will create an empty ReferenceContext if reference or readInterval == null\n+                    new FeatureContext(features, currentDuplicateSet.getDuplicateSetInterval()));\n+            currentDuplicateSet = new DuplicateSet(read);\n+        } else {\n+            Utils.validate(currentDuplicateSet.addRead(read), \"Adding a read that doesn't have a matching molecular ID tag\");\n+        }\n+    }\n+\n+    public abstract void apply(DuplicateSet duplicateSet, ReferenceContext referenceContext, FeatureContext featureContext );\n+\n+    protected boolean rejectDuplicateSet(final DuplicateSet duplicateSet){\n+        if (!duplicateSet.hasValidInterval()) {\n+            logger.info(\"Duplicate Set with Invalid Intervals\");\n+            logger.info(\"Number of reads:\" + currentDuplicateSet.getReads().size());\n+            if (currentDuplicateSet.getReads().size() > 0) {\n+                logger.info(\"First read: \" + currentDuplicateSet.getReads().get(0));\n+            }\n+        }\n+\n+        return !duplicateSet.hasValidInterval();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c14aa1527401cb1b4eaa1d545d1f966754403e4f"}, "originalPosition": 72}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzcwOTExMg==", "bodyText": "lets see if we can avoid this.  I think we can.", "url": "https://github.com/broadinstitute/gatk/pull/6512#discussion_r407709112", "createdAt": "2020-04-13T20:43:18Z", "author": {"login": "lbergelson"}, "path": "src/main/java/org/broadinstitute/hellbender/engine/ReadWalker.java", "diffHunk": "@@ -46,7 +46,7 @@ public boolean requiresReads() {\n      * Marked final so that tool authors don't override it. Tool authors should override onTraversalStart() instead.\n      */\n     @Override\n-    protected final void onStartup() {\n+    protected void onStartup() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c14aa1527401cb1b4eaa1d545d1f966754403e4f"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzcwOTUxNg==", "bodyText": "Hmn, I think returning null is ok because some tools might want to be able to process empty files without exploding.  Just document clearly that it can return null.", "url": "https://github.com/broadinstitute/gatk/pull/6512#discussion_r407709516", "createdAt": "2020-04-13T20:44:01Z", "author": {"login": "lbergelson"}, "path": "src/main/java/org/broadinstitute/hellbender/engine/ReadWalker.java", "diffHunk": "@@ -167,4 +167,16 @@ protected final void onShutdown() {\n         // Overridden only to make final so that concrete tool implementations don't override\n         super.onShutdown();\n     }\n+\n+    public void postProcess(){\n+        return;\n+    }\n+\n+    public GATKRead peekFirstRead(){\n+        if (reads.iterator().hasNext()){\n+            return reads.iterator().next();\n+        }\n+        // Maybe the correct thing to do is for this to return an error when the user input is empty\n+        return null;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c14aa1527401cb1b4eaa1d545d1f966754403e4f"}, "originalPosition": 32}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzcxMDQxMQ==", "bodyText": "This should be private, protected, or marked visiblefortesting.", "url": "https://github.com/broadinstitute/gatk/pull/6512#discussion_r407710411", "createdAt": "2020-04-13T20:45:45Z", "author": {"login": "lbergelson"}, "path": "src/main/java/org/broadinstitute/hellbender/engine/DuplicateSetWalker.java", "diffHunk": "@@ -0,0 +1,83 @@\n+package org.broadinstitute.hellbender.engine;\n+\n+import org.broadinstitute.hellbender.tools.walkers.mutect.consensus.DuplicateSet;\n+import org.broadinstitute.hellbender.utils.Utils;\n+import org.broadinstitute.hellbender.utils.read.GATKRead;\n+\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * A walker that processes duplicate reads that share the same UMI as a single unit.\n+ *\n+ * This tool assumes that the input bam has been sorted by UMI with FGBio GroupReadsByUmi:\n+ * http://fulcrumgenomics.github.io/fgbio/tools/latest/GroupReadsByUmi.html\n+ */\n+public abstract class DuplicateSetWalker extends ReadWalker {\n+    DuplicateSet currentDuplicateSet; // TODO: does it make sense to call clear() and recycle the same object?", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjk3MDk2Mg=="}, "originalCommit": {"oid": "c14aa1527401cb1b4eaa1d545d1f966754403e4f"}, "originalPosition": 17}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzcxMTE3MA==", "bodyText": "extract this to a variable instead of calling it twice", "url": "https://github.com/broadinstitute/gatk/pull/6512#discussion_r407711170", "createdAt": "2020-04-13T20:47:12Z", "author": {"login": "lbergelson"}, "path": "src/main/java/org/broadinstitute/hellbender/engine/DuplicateSetWalker.java", "diffHunk": "@@ -0,0 +1,83 @@\n+package org.broadinstitute.hellbender.engine;\n+\n+import org.broadinstitute.hellbender.tools.walkers.mutect.consensus.DuplicateSet;\n+import org.broadinstitute.hellbender.utils.Utils;\n+import org.broadinstitute.hellbender.utils.read.GATKRead;\n+\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * A walker that processes duplicate reads that share the same UMI as a single unit.\n+ *\n+ * This tool assumes that the input bam has been sorted by UMI with FGBio GroupReadsByUmi:\n+ * http://fulcrumgenomics.github.io/fgbio/tools/latest/GroupReadsByUmi.html\n+ */\n+public abstract class DuplicateSetWalker extends ReadWalker {\n+    DuplicateSet currentDuplicateSet; // TODO: does it make sense to call clear() and recycle the same object?\n+    public static int INITIAL_MOLECULAR_ID = -1;\n+\n+    @Override\n+    public final void onStartup(){\n+        // TODO: I had to make onStartUp of ReadWalker not final to do this. The right thing to do here is to\n+        // write a ReadWalkerBase parent class for both ReadWalker and DuplicateSet Walker, as Louis suggested.\n+        super.onStartup();\n+        currentDuplicateSet = new DuplicateSet();\n+        currentDuplicateSet.setMoleduleId(INITIAL_MOLECULAR_ID);\n+    }\n+\n+    /***\n+     * FGBio GroupByUMI returns reads sorted by molecular ID: For example, the input bam may look like\n+     * read1: ... MI:Z:0/A ...\n+     * read2: ... MI:Z:0/A ...\n+     * read3: ... MI:Z:0/B ...\n+     * read4: ... MI:Z:0/B ...\n+     * read5: ... MI:Z:1/A ...\n+     * read6: ... MI:Z:1/B ...\n+     * read7: ... MI:Z:1/B ...\n+     *\n+     * Thus it's sufficient to go through the reads in order and collect them in a list until\n+     * we encounter the next molecular ID, at which point we pass the list to the {@code apply}\n+     * method of the child class and clear the {@code currentDuplicateSet} variable.\n+     *\n+     */\n+    @Override\n+    public void apply(GATKRead read, ReferenceContext referenceContext, FeatureContext featureContext) {\n+        if (currentDuplicateSet.getMoleculeId() != DuplicateSet.getMoleculeID(read)) {\n+            if (rejectDuplicateSet(currentDuplicateSet)){\n+                currentDuplicateSet = new DuplicateSet(read);\n+                return;\n+            }\n+\n+            apply(currentDuplicateSet,\n+                    new ReferenceContext(reference, currentDuplicateSet.getDuplicateSetInterval()), // Will create an empty ReferenceContext if reference or readInterval == null", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c14aa1527401cb1b4eaa1d545d1f966754403e4f"}, "originalPosition": 53}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzcxMTc1OA==", "bodyText": "The naming is ok, but it might be better as something like duplicateSetHasValidInterval to make it clear what it's checking.", "url": "https://github.com/broadinstitute/gatk/pull/6512#discussion_r407711758", "createdAt": "2020-04-13T20:48:18Z", "author": {"login": "lbergelson"}, "path": "src/main/java/org/broadinstitute/hellbender/engine/DuplicateSetWalker.java", "diffHunk": "@@ -0,0 +1,83 @@\n+package org.broadinstitute.hellbender.engine;\n+\n+import org.broadinstitute.hellbender.tools.walkers.mutect.consensus.DuplicateSet;\n+import org.broadinstitute.hellbender.utils.Utils;\n+import org.broadinstitute.hellbender.utils.read.GATKRead;\n+\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * A walker that processes duplicate reads that share the same UMI as a single unit.\n+ *\n+ * This tool assumes that the input bam has been sorted by UMI with FGBio GroupReadsByUmi:\n+ * http://fulcrumgenomics.github.io/fgbio/tools/latest/GroupReadsByUmi.html\n+ */\n+public abstract class DuplicateSetWalker extends ReadWalker {\n+    DuplicateSet currentDuplicateSet; // TODO: does it make sense to call clear() and recycle the same object?\n+    public static int INITIAL_MOLECULAR_ID = -1;\n+\n+    @Override\n+    public final void onStartup(){\n+        // TODO: I had to make onStartUp of ReadWalker not final to do this. The right thing to do here is to\n+        // write a ReadWalkerBase parent class for both ReadWalker and DuplicateSet Walker, as Louis suggested.\n+        super.onStartup();\n+        currentDuplicateSet = new DuplicateSet();\n+        currentDuplicateSet.setMoleduleId(INITIAL_MOLECULAR_ID);\n+    }\n+\n+    /***\n+     * FGBio GroupByUMI returns reads sorted by molecular ID: For example, the input bam may look like\n+     * read1: ... MI:Z:0/A ...\n+     * read2: ... MI:Z:0/A ...\n+     * read3: ... MI:Z:0/B ...\n+     * read4: ... MI:Z:0/B ...\n+     * read5: ... MI:Z:1/A ...\n+     * read6: ... MI:Z:1/B ...\n+     * read7: ... MI:Z:1/B ...\n+     *\n+     * Thus it's sufficient to go through the reads in order and collect them in a list until\n+     * we encounter the next molecular ID, at which point we pass the list to the {@code apply}\n+     * method of the child class and clear the {@code currentDuplicateSet} variable.\n+     *\n+     */\n+    @Override\n+    public void apply(GATKRead read, ReferenceContext referenceContext, FeatureContext featureContext) {\n+        if (currentDuplicateSet.getMoleculeId() != DuplicateSet.getMoleculeID(read)) {\n+            if (rejectDuplicateSet(currentDuplicateSet)){\n+                currentDuplicateSet = new DuplicateSet(read);\n+                return;\n+            }\n+\n+            apply(currentDuplicateSet,\n+                    new ReferenceContext(reference, currentDuplicateSet.getDuplicateSetInterval()), // Will create an empty ReferenceContext if reference or readInterval == null\n+                    new FeatureContext(features, currentDuplicateSet.getDuplicateSetInterval()));\n+            currentDuplicateSet = new DuplicateSet(read);\n+        } else {\n+            Utils.validate(currentDuplicateSet.addRead(read), \"Adding a read that doesn't have a matching molecular ID tag\");\n+        }\n+    }\n+\n+    public abstract void apply(DuplicateSet duplicateSet, ReferenceContext referenceContext, FeatureContext featureContext );\n+\n+    protected boolean rejectDuplicateSet(final DuplicateSet duplicateSet){", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzcwNzMyNw=="}, "originalCommit": {"oid": "c14aa1527401cb1b4eaa1d545d1f966754403e4f"}, "originalPosition": 63}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzcxMjY2NA==", "bodyText": "You could change this expression to be something like currentDuplicateSet.moleculeIdsMatch(read) which might read better.", "url": "https://github.com/broadinstitute/gatk/pull/6512#discussion_r407712664", "createdAt": "2020-04-13T20:49:52Z", "author": {"login": "lbergelson"}, "path": "src/main/java/org/broadinstitute/hellbender/engine/DuplicateSetWalker.java", "diffHunk": "@@ -0,0 +1,83 @@\n+package org.broadinstitute.hellbender.engine;\n+\n+import org.broadinstitute.hellbender.tools.walkers.mutect.consensus.DuplicateSet;\n+import org.broadinstitute.hellbender.utils.Utils;\n+import org.broadinstitute.hellbender.utils.read.GATKRead;\n+\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * A walker that processes duplicate reads that share the same UMI as a single unit.\n+ *\n+ * This tool assumes that the input bam has been sorted by UMI with FGBio GroupReadsByUmi:\n+ * http://fulcrumgenomics.github.io/fgbio/tools/latest/GroupReadsByUmi.html\n+ */\n+public abstract class DuplicateSetWalker extends ReadWalker {\n+    DuplicateSet currentDuplicateSet; // TODO: does it make sense to call clear() and recycle the same object?\n+    public static int INITIAL_MOLECULAR_ID = -1;\n+\n+    @Override\n+    public final void onStartup(){\n+        // TODO: I had to make onStartUp of ReadWalker not final to do this. The right thing to do here is to\n+        // write a ReadWalkerBase parent class for both ReadWalker and DuplicateSet Walker, as Louis suggested.\n+        super.onStartup();\n+        currentDuplicateSet = new DuplicateSet();\n+        currentDuplicateSet.setMoleduleId(INITIAL_MOLECULAR_ID);\n+    }\n+\n+    /***\n+     * FGBio GroupByUMI returns reads sorted by molecular ID: For example, the input bam may look like\n+     * read1: ... MI:Z:0/A ...\n+     * read2: ... MI:Z:0/A ...\n+     * read3: ... MI:Z:0/B ...\n+     * read4: ... MI:Z:0/B ...\n+     * read5: ... MI:Z:1/A ...\n+     * read6: ... MI:Z:1/B ...\n+     * read7: ... MI:Z:1/B ...\n+     *\n+     * Thus it's sufficient to go through the reads in order and collect them in a list until\n+     * we encounter the next molecular ID, at which point we pass the list to the {@code apply}\n+     * method of the child class and clear the {@code currentDuplicateSet} variable.\n+     *\n+     */\n+    @Override\n+    public void apply(GATKRead read, ReferenceContext referenceContext, FeatureContext featureContext) {\n+        if (currentDuplicateSet.getMoleculeId() != DuplicateSet.getMoleculeID(read)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c14aa1527401cb1b4eaa1d545d1f966754403e4f"}, "originalPosition": 46}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzcxNzE4MA==", "bodyText": "This seems like a reasonable thing to add to the engine, but it needs documentation and possibly a rename.  Maybe finalizeTraversal would make sense?  Make it clear that it's different from onTraversalSuccess because it's meant to be implemented by framework classes, not actual tools.", "url": "https://github.com/broadinstitute/gatk/pull/6512#discussion_r407717180", "createdAt": "2020-04-13T20:58:30Z", "author": {"login": "lbergelson"}, "path": "src/main/java/org/broadinstitute/hellbender/engine/ReadWalker.java", "diffHunk": "@@ -99,7 +99,7 @@ public void traverse() {\n \n                     progressMeter.update(readInterval);\n                 });\n-\n+        postProcess();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c14aa1527401cb1b4eaa1d545d1f966754403e4f"}, "originalPosition": 14}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzcxNzUwMw==", "bodyText": "@droazen Any thoughts on this?  The other option would be to override traverse in the subclass which is always awkward if unnecessary.", "url": "https://github.com/broadinstitute/gatk/pull/6512#discussion_r407717503", "createdAt": "2020-04-13T20:59:01Z", "author": {"login": "lbergelson"}, "path": "src/main/java/org/broadinstitute/hellbender/engine/ReadWalker.java", "diffHunk": "@@ -99,7 +99,7 @@ public void traverse() {\n \n                     progressMeter.update(readInterval);\n                 });\n-\n+        postProcess();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzcxNzE4MA=="}, "originalCommit": {"oid": "c14aa1527401cb1b4eaa1d545d1f966754403e4f"}, "originalPosition": 14}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzcxNzg2OA==", "bodyText": "I said above, but this needs documentation", "url": "https://github.com/broadinstitute/gatk/pull/6512#discussion_r407717868", "createdAt": "2020-04-13T20:59:42Z", "author": {"login": "lbergelson"}, "path": "src/main/java/org/broadinstitute/hellbender/engine/ReadWalker.java", "diffHunk": "@@ -167,4 +167,16 @@ protected final void onShutdown() {\n         // Overridden only to make final so that concrete tool implementations don't override\n         super.onShutdown();\n     }\n+\n+    public void postProcess(){", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c14aa1527401cb1b4eaa1d545d1f966754403e4f"}, "originalPosition": 23}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzcyMTQzMQ==", "bodyText": "Reference SAMTag.RX.name() here instead of totally redefining it from scratch.  It's ok to still assign it to a named constant since RX.name() isn't super helpful..", "url": "https://github.com/broadinstitute/gatk/pull/6512#discussion_r407721431", "createdAt": "2020-04-13T21:06:37Z", "author": {"login": "lbergelson"}, "path": "src/main/java/org/broadinstitute/hellbender/engine/filters/UMIReadFilter.java", "diffHunk": "@@ -0,0 +1,42 @@\n+package org.broadinstitute.hellbender.engine.filters;\n+\n+import org.broadinstitute.barclay.argparser.Argument;\n+import org.broadinstitute.hellbender.cmdline.ReadFilterArgumentDefinitions;\n+import org.broadinstitute.hellbender.exceptions.UserException;\n+import org.broadinstitute.hellbender.utils.read.GATKRead;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.util.List;\n+\n+public class UMIReadFilter extends ReadFilter {\n+    static final long serialVersionUID = 1L;\n+    public static final String UMI_TAG = \"RX\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c14aa1527401cb1b4eaa1d545d1f966754403e4f"}, "originalPosition": 15}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzcyMTYxNA==", "bodyText": "private is the standard for this for some reason.", "url": "https://github.com/broadinstitute/gatk/pull/6512#discussion_r407721614", "createdAt": "2020-04-13T21:06:58Z", "author": {"login": "lbergelson"}, "path": "src/main/java/org/broadinstitute/hellbender/engine/filters/UMIReadFilter.java", "diffHunk": "@@ -0,0 +1,42 @@\n+package org.broadinstitute.hellbender.engine.filters;\n+\n+import org.broadinstitute.barclay.argparser.Argument;\n+import org.broadinstitute.hellbender.cmdline.ReadFilterArgumentDefinitions;\n+import org.broadinstitute.hellbender.exceptions.UserException;\n+import org.broadinstitute.hellbender.utils.read.GATKRead;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.util.List;\n+\n+public class UMIReadFilter extends ReadFilter {\n+    static final long serialVersionUID = 1L;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c14aa1527401cb1b4eaa1d545d1f966754403e4f"}, "originalPosition": 14}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzcyMzA5OA==", "bodyText": "Split once and save the array into a variable.\nUtils.split(String, char) is substantially faster for non-regex splitting like this.", "url": "https://github.com/broadinstitute/gatk/pull/6512#discussion_r407723098", "createdAt": "2020-04-13T21:09:55Z", "author": {"login": "lbergelson"}, "path": "src/main/java/org/broadinstitute/hellbender/engine/filters/UMIReadFilter.java", "diffHunk": "@@ -0,0 +1,42 @@\n+package org.broadinstitute.hellbender.engine.filters;\n+\n+import org.broadinstitute.barclay.argparser.Argument;\n+import org.broadinstitute.hellbender.cmdline.ReadFilterArgumentDefinitions;\n+import org.broadinstitute.hellbender.exceptions.UserException;\n+import org.broadinstitute.hellbender.utils.read.GATKRead;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.util.List;\n+\n+public class UMIReadFilter extends ReadFilter {\n+    static final long serialVersionUID = 1L;\n+    public static final String UMI_TAG = \"RX\";\n+\n+    @Argument(fullName= ReadFilterArgumentDefinitions.UMI_NAME, doc = \"umi must have the format 'XXX-XXX'\")\n+    public String umi;\n+\n+    public UMIReadFilter() {};\n+\n+    @Override\n+    public boolean test(GATKRead read) {\n+        final String readUMI = read.getAttributeAsString(UMI_TAG);\n+        final String umi1 = readUMI.split(\"-\", 2)[0];", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c14aa1527401cb1b4eaa1d545d1f966754403e4f"}, "originalPosition": 25}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzcyMzg3OA==", "bodyText": "Could you fix UMI.getUMI() while you're at it?  It does the same wasteful thing.    You might consider using that method as well to avoid reimplementing this.", "url": "https://github.com/broadinstitute/gatk/pull/6512#discussion_r407723878", "createdAt": "2020-04-13T21:11:38Z", "author": {"login": "lbergelson"}, "path": "src/main/java/org/broadinstitute/hellbender/engine/filters/UMIReadFilter.java", "diffHunk": "@@ -0,0 +1,42 @@\n+package org.broadinstitute.hellbender.engine.filters;\n+\n+import org.broadinstitute.barclay.argparser.Argument;\n+import org.broadinstitute.hellbender.cmdline.ReadFilterArgumentDefinitions;\n+import org.broadinstitute.hellbender.exceptions.UserException;\n+import org.broadinstitute.hellbender.utils.read.GATKRead;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.util.List;\n+\n+public class UMIReadFilter extends ReadFilter {\n+    static final long serialVersionUID = 1L;\n+    public static final String UMI_TAG = \"RX\";\n+\n+    @Argument(fullName= ReadFilterArgumentDefinitions.UMI_NAME, doc = \"umi must have the format 'XXX-XXX'\")\n+    public String umi;\n+\n+    public UMIReadFilter() {};\n+\n+    @Override\n+    public boolean test(GATKRead read) {\n+        final String readUMI = read.getAttributeAsString(UMI_TAG);\n+        final String umi1 = readUMI.split(\"-\", 2)[0];", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzcyMzA5OA=="}, "originalCommit": {"oid": "c14aa1527401cb1b4eaa1d545d1f966754403e4f"}, "originalPosition": 25}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzcyNDUyNw==", "bodyText": "Should we validate that constraint somewhere?  @cmnbroad is there a way to do validation of the arguments in a readfilter?", "url": "https://github.com/broadinstitute/gatk/pull/6512#discussion_r407724527", "createdAt": "2020-04-13T21:12:54Z", "author": {"login": "lbergelson"}, "path": "src/main/java/org/broadinstitute/hellbender/engine/filters/UMIReadFilter.java", "diffHunk": "@@ -0,0 +1,42 @@\n+package org.broadinstitute.hellbender.engine.filters;\n+\n+import org.broadinstitute.barclay.argparser.Argument;\n+import org.broadinstitute.hellbender.cmdline.ReadFilterArgumentDefinitions;\n+import org.broadinstitute.hellbender.exceptions.UserException;\n+import org.broadinstitute.hellbender.utils.read.GATKRead;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.util.List;\n+\n+public class UMIReadFilter extends ReadFilter {\n+    static final long serialVersionUID = 1L;\n+    public static final String UMI_TAG = \"RX\";\n+\n+    @Argument(fullName= ReadFilterArgumentDefinitions.UMI_NAME, doc = \"umi must have the format 'XXX-XXX'\")\n+    public String umi;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c14aa1527401cb1b4eaa1d545d1f966754403e4f"}, "originalPosition": 18}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzcyNjE4Nw==", "bodyText": "In fact, why not give UMI a string constructor, then make the argument a UMI, and just use UMI.equalsModuloOrder(). It would save reimplementing a bunch of stuff.", "url": "https://github.com/broadinstitute/gatk/pull/6512#discussion_r407726187", "createdAt": "2020-04-13T21:16:07Z", "author": {"login": "lbergelson"}, "path": "src/main/java/org/broadinstitute/hellbender/engine/filters/UMIReadFilter.java", "diffHunk": "@@ -0,0 +1,42 @@\n+package org.broadinstitute.hellbender.engine.filters;\n+\n+import org.broadinstitute.barclay.argparser.Argument;\n+import org.broadinstitute.hellbender.cmdline.ReadFilterArgumentDefinitions;\n+import org.broadinstitute.hellbender.exceptions.UserException;\n+import org.broadinstitute.hellbender.utils.read.GATKRead;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.util.List;\n+\n+public class UMIReadFilter extends ReadFilter {\n+    static final long serialVersionUID = 1L;\n+    public static final String UMI_TAG = \"RX\";\n+\n+    @Argument(fullName= ReadFilterArgumentDefinitions.UMI_NAME, doc = \"umi must have the format 'XXX-XXX'\")\n+    public String umi;\n+\n+    public UMIReadFilter() {};\n+\n+    @Override\n+    public boolean test(GATKRead read) {\n+        final String readUMI = read.getAttributeAsString(UMI_TAG);\n+        final String umi1 = readUMI.split(\"-\", 2)[0];", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzcyMzA5OA=="}, "originalCommit": {"oid": "c14aa1527401cb1b4eaa1d545d1f966754403e4f"}, "originalPosition": 25}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzcyNjIxOA==", "bodyText": "This would be faster if you reworked it to check umi.equals(readUmi) first before deconstructing the string.  In any case, there's no need to rebuild readUMI, only the reversed order one.", "url": "https://github.com/broadinstitute/gatk/pull/6512#discussion_r407726218", "createdAt": "2020-04-13T21:16:10Z", "author": {"login": "lbergelson"}, "path": "src/main/java/org/broadinstitute/hellbender/engine/filters/UMIReadFilter.java", "diffHunk": "@@ -0,0 +1,42 @@\n+package org.broadinstitute.hellbender.engine.filters;\n+\n+import org.broadinstitute.barclay.argparser.Argument;\n+import org.broadinstitute.hellbender.cmdline.ReadFilterArgumentDefinitions;\n+import org.broadinstitute.hellbender.exceptions.UserException;\n+import org.broadinstitute.hellbender.utils.read.GATKRead;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.util.List;\n+\n+public class UMIReadFilter extends ReadFilter {\n+    static final long serialVersionUID = 1L;\n+    public static final String UMI_TAG = \"RX\";\n+\n+    @Argument(fullName= ReadFilterArgumentDefinitions.UMI_NAME, doc = \"umi must have the format 'XXX-XXX'\")\n+    public String umi;\n+\n+    public UMIReadFilter() {};\n+\n+    @Override\n+    public boolean test(GATKRead read) {\n+        final String readUMI = read.getAttributeAsString(UMI_TAG);\n+        final String umi1 = readUMI.split(\"-\", 2)[0];\n+        final String umi2 = readUMI.split(\"-\", 2)[1];\n+\n+        return umi.equals(umi1 + \"-\" + umi2) || umi.equals(umi2 + \"-\" + umi1);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c14aa1527401cb1b4eaa1d545d1f966754403e4f"}, "originalPosition": 28}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzcyNjI4Nw==", "bodyText": "dead code.  Do you want to allow many UMIs?", "url": "https://github.com/broadinstitute/gatk/pull/6512#discussion_r407726287", "createdAt": "2020-04-13T21:16:20Z", "author": {"login": "lbergelson"}, "path": "src/main/java/org/broadinstitute/hellbender/engine/filters/UMIReadFilter.java", "diffHunk": "@@ -0,0 +1,42 @@\n+package org.broadinstitute.hellbender.engine.filters;\n+\n+import org.broadinstitute.barclay.argparser.Argument;\n+import org.broadinstitute.hellbender.cmdline.ReadFilterArgumentDefinitions;\n+import org.broadinstitute.hellbender.exceptions.UserException;\n+import org.broadinstitute.hellbender.utils.read.GATKRead;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.util.List;\n+\n+public class UMIReadFilter extends ReadFilter {\n+    static final long serialVersionUID = 1L;\n+    public static final String UMI_TAG = \"RX\";\n+\n+    @Argument(fullName= ReadFilterArgumentDefinitions.UMI_NAME, doc = \"umi must have the format 'XXX-XXX'\")\n+    public String umi;\n+\n+    public UMIReadFilter() {};\n+\n+    @Override\n+    public boolean test(GATKRead read) {\n+        final String readUMI = read.getAttributeAsString(UMI_TAG);\n+        final String umi1 = readUMI.split(\"-\", 2)[0];\n+        final String umi2 = readUMI.split(\"-\", 2)[1];\n+\n+        return umi.equals(umi1 + \"-\" + umi2) || umi.equals(umi2 + \"-\" + umi1);\n+\n+//        final File umiFile = new File(umi);\n+//        if (umiFile.exists()){", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c14aa1527401cb1b4eaa1d545d1f966754403e4f"}, "originalPosition": 31}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzcyNzIyOQ==", "bodyText": "Needs class javadoc.", "url": "https://github.com/broadinstitute/gatk/pull/6512#discussion_r407727229", "createdAt": "2020-04-13T21:18:11Z", "author": {"login": "lbergelson"}, "path": "src/main/java/org/broadinstitute/hellbender/tools/walkers/mutect/UMI.java", "diffHunk": "@@ -0,0 +1,66 @@\n+package org.broadinstitute.hellbender.tools.walkers.mutect;\n+\n+import org.apache.commons.lang3.tuple.ImmutablePair;\n+import org.apache.commons.lang3.tuple.Pair;\n+import org.broadinstitute.hellbender.engine.filters.UMIReadFilter;\n+import org.broadinstitute.hellbender.utils.read.GATKRead;\n+\n+public class UMI {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c14aa1527401cb1b4eaa1d545d1f966754403e4f"}, "originalPosition": 8}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzcyNzMxNg==", "bodyText": "final final", "url": "https://github.com/broadinstitute/gatk/pull/6512#discussion_r407727316", "createdAt": "2020-04-13T21:18:21Z", "author": {"login": "lbergelson"}, "path": "src/main/java/org/broadinstitute/hellbender/tools/walkers/mutect/UMI.java", "diffHunk": "@@ -0,0 +1,66 @@\n+package org.broadinstitute.hellbender.tools.walkers.mutect;\n+\n+import org.apache.commons.lang3.tuple.ImmutablePair;\n+import org.apache.commons.lang3.tuple.Pair;\n+import org.broadinstitute.hellbender.engine.filters.UMIReadFilter;\n+import org.broadinstitute.hellbender.utils.read.GATKRead;\n+\n+public class UMI {\n+    // The umis are stored here in the order they are stored in the read.\n+    // e.g. if the read UMI is AAT-CGT, then umi1 = AAT, umi2 = CGT\n+    public final String umi1;\n+    public final String umi2;\n+\n+    // Lexicographical ordering of the two (duplex) UMIs;\n+    public String umiSmall;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c14aa1527401cb1b4eaa1d545d1f966754403e4f"}, "originalPosition": 15}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzcyNzQ3Nw==", "bodyText": "save the array instead of splitting twice, mentioned above", "url": "https://github.com/broadinstitute/gatk/pull/6512#discussion_r407727477", "createdAt": "2020-04-13T21:18:38Z", "author": {"login": "lbergelson"}, "path": "src/main/java/org/broadinstitute/hellbender/tools/walkers/mutect/UMI.java", "diffHunk": "@@ -0,0 +1,66 @@\n+package org.broadinstitute.hellbender.tools.walkers.mutect;\n+\n+import org.apache.commons.lang3.tuple.ImmutablePair;\n+import org.apache.commons.lang3.tuple.Pair;\n+import org.broadinstitute.hellbender.engine.filters.UMIReadFilter;\n+import org.broadinstitute.hellbender.utils.read.GATKRead;\n+\n+public class UMI {\n+    // The umis are stored here in the order they are stored in the read.\n+    // e.g. if the read UMI is AAT-CGT, then umi1 = AAT, umi2 = CGT\n+    public final String umi1;\n+    public final String umi2;\n+\n+    // Lexicographical ordering of the two (duplex) UMIs;\n+    public String umiSmall;\n+    public String umiLarge;\n+\n+    public UMI(final GATKRead read){\n+        final String readUMI = read.getAttributeAsString(UMIReadFilter.UMI_TAG);\n+        this.umi1 = readUMI.split(\"-\", 2)[0];", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c14aa1527401cb1b4eaa1d545d1f966754403e4f"}, "originalPosition": 20}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzcyODEzMg==", "bodyText": "Should these things have getters?", "url": "https://github.com/broadinstitute/gatk/pull/6512#discussion_r407728132", "createdAt": "2020-04-13T21:19:56Z", "author": {"login": "lbergelson"}, "path": "src/main/java/org/broadinstitute/hellbender/tools/walkers/mutect/UMI.java", "diffHunk": "@@ -0,0 +1,66 @@\n+package org.broadinstitute.hellbender.tools.walkers.mutect;\n+\n+import org.apache.commons.lang3.tuple.ImmutablePair;\n+import org.apache.commons.lang3.tuple.Pair;\n+import org.broadinstitute.hellbender.engine.filters.UMIReadFilter;\n+import org.broadinstitute.hellbender.utils.read.GATKRead;\n+\n+public class UMI {\n+    // The umis are stored here in the order they are stored in the read.\n+    // e.g. if the read UMI is AAT-CGT, then umi1 = AAT, umi2 = CGT\n+    public final String umi1;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c14aa1527401cb1b4eaa1d545d1f966754403e4f"}, "originalPosition": 11}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzcyODIyOA==", "bodyText": "this seems broken", "url": "https://github.com/broadinstitute/gatk/pull/6512#discussion_r407728228", "createdAt": "2020-04-13T21:20:11Z", "author": {"login": "lbergelson"}, "path": "src/main/java/org/broadinstitute/hellbender/tools/walkers/mutect/UMI.java", "diffHunk": "@@ -0,0 +1,66 @@\n+package org.broadinstitute.hellbender.tools.walkers.mutect;\n+\n+import org.apache.commons.lang3.tuple.ImmutablePair;\n+import org.apache.commons.lang3.tuple.Pair;\n+import org.broadinstitute.hellbender.engine.filters.UMIReadFilter;\n+import org.broadinstitute.hellbender.utils.read.GATKRead;\n+\n+public class UMI {\n+    // The umis are stored here in the order they are stored in the read.\n+    // e.g. if the read UMI is AAT-CGT, then umi1 = AAT, umi2 = CGT\n+    public final String umi1;\n+    public final String umi2;\n+\n+    // Lexicographical ordering of the two (duplex) UMIs;\n+    public String umiSmall;\n+    public String umiLarge;\n+\n+    public UMI(final GATKRead read){\n+        final String readUMI = read.getAttributeAsString(UMIReadFilter.UMI_TAG);\n+        this.umi1 = readUMI.split(\"-\", 2)[0];\n+        this.umi2 = readUMI.split(\"-\", 2)[1];\n+        if (this.umi1.compareTo(this.umi2) > 0) {\n+            umiLarge = this.umi1;\n+            umiSmall = this.umi2;\n+        } else {\n+            umiLarge = this.umi2;\n+            umiSmall = this.umi1;\n+        }\n+\n+    }\n+\n+    public static Pair<String, String> getUMI(final GATKRead read){\n+        final String readUMI = read.getAttributeAsString(UMIReadFilter.UMI_TAG);\n+        final String umi1 = readUMI.split(\"-\", 2)[0];\n+        final String umi2 = readUMI.split(\"-\", 2)[1];\n+\n+        return new ImmutablePair<>(umi1, umi2);\n+    }\n+\n+    public boolean equalsReadUMI(final GATKRead read){\n+        return false;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c14aa1527401cb1b4eaa1d545d1f966754403e4f"}, "originalPosition": 41}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzcyODUzOA==", "bodyText": "Why have this and the constructor?", "url": "https://github.com/broadinstitute/gatk/pull/6512#discussion_r407728538", "createdAt": "2020-04-13T21:20:51Z", "author": {"login": "lbergelson"}, "path": "src/main/java/org/broadinstitute/hellbender/tools/walkers/mutect/UMI.java", "diffHunk": "@@ -0,0 +1,66 @@\n+package org.broadinstitute.hellbender.tools.walkers.mutect;\n+\n+import org.apache.commons.lang3.tuple.ImmutablePair;\n+import org.apache.commons.lang3.tuple.Pair;\n+import org.broadinstitute.hellbender.engine.filters.UMIReadFilter;\n+import org.broadinstitute.hellbender.utils.read.GATKRead;\n+\n+public class UMI {\n+    // The umis are stored here in the order they are stored in the read.\n+    // e.g. if the read UMI is AAT-CGT, then umi1 = AAT, umi2 = CGT\n+    public final String umi1;\n+    public final String umi2;\n+\n+    // Lexicographical ordering of the two (duplex) UMIs;\n+    public String umiSmall;\n+    public String umiLarge;\n+\n+    public UMI(final GATKRead read){\n+        final String readUMI = read.getAttributeAsString(UMIReadFilter.UMI_TAG);\n+        this.umi1 = readUMI.split(\"-\", 2)[0];\n+        this.umi2 = readUMI.split(\"-\", 2)[1];\n+        if (this.umi1.compareTo(this.umi2) > 0) {\n+            umiLarge = this.umi1;\n+            umiSmall = this.umi2;\n+        } else {\n+            umiLarge = this.umi2;\n+            umiSmall = this.umi1;\n+        }\n+\n+    }\n+\n+    public static Pair<String, String> getUMI(final GATKRead read){", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c14aa1527401cb1b4eaa1d545d1f966754403e4f"}, "originalPosition": 32}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzcyODYwOQ==", "bodyText": "This is unused.", "url": "https://github.com/broadinstitute/gatk/pull/6512#discussion_r407728609", "createdAt": "2020-04-13T21:20:59Z", "author": {"login": "lbergelson"}, "path": "src/main/java/org/broadinstitute/hellbender/tools/walkers/mutect/UMI.java", "diffHunk": "@@ -0,0 +1,66 @@\n+package org.broadinstitute.hellbender.tools.walkers.mutect;\n+\n+import org.apache.commons.lang3.tuple.ImmutablePair;\n+import org.apache.commons.lang3.tuple.Pair;\n+import org.broadinstitute.hellbender.engine.filters.UMIReadFilter;\n+import org.broadinstitute.hellbender.utils.read.GATKRead;\n+\n+public class UMI {\n+    // The umis are stored here in the order they are stored in the read.\n+    // e.g. if the read UMI is AAT-CGT, then umi1 = AAT, umi2 = CGT\n+    public final String umi1;\n+    public final String umi2;\n+\n+    // Lexicographical ordering of the two (duplex) UMIs;\n+    public String umiSmall;\n+    public String umiLarge;\n+\n+    public UMI(final GATKRead read){\n+        final String readUMI = read.getAttributeAsString(UMIReadFilter.UMI_TAG);\n+        this.umi1 = readUMI.split(\"-\", 2)[0];\n+        this.umi2 = readUMI.split(\"-\", 2)[1];\n+        if (this.umi1.compareTo(this.umi2) > 0) {\n+            umiLarge = this.umi1;\n+            umiSmall = this.umi2;\n+        } else {\n+            umiLarge = this.umi2;\n+            umiSmall = this.umi1;\n+        }\n+\n+    }\n+\n+    public static Pair<String, String> getUMI(final GATKRead read){", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzcyODUzOA=="}, "originalCommit": {"oid": "c14aa1527401cb1b4eaa1d545d1f966754403e4f"}, "originalPosition": 32}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzcyODg0OQ==", "bodyText": "This should be javadoc.", "url": "https://github.com/broadinstitute/gatk/pull/6512#discussion_r407728849", "createdAt": "2020-04-13T21:21:29Z", "author": {"login": "lbergelson"}, "path": "src/main/java/org/broadinstitute/hellbender/tools/walkers/mutect/UMI.java", "diffHunk": "@@ -0,0 +1,66 @@\n+package org.broadinstitute.hellbender.tools.walkers.mutect;\n+\n+import org.apache.commons.lang3.tuple.ImmutablePair;\n+import org.apache.commons.lang3.tuple.Pair;\n+import org.broadinstitute.hellbender.engine.filters.UMIReadFilter;\n+import org.broadinstitute.hellbender.utils.read.GATKRead;\n+\n+public class UMI {\n+    // The umis are stored here in the order they are stored in the read.\n+    // e.g. if the read UMI is AAT-CGT, then umi1 = AAT, umi2 = CGT\n+    public final String umi1;\n+    public final String umi2;\n+\n+    // Lexicographical ordering of the two (duplex) UMIs;\n+    public String umiSmall;\n+    public String umiLarge;\n+\n+    public UMI(final GATKRead read){\n+        final String readUMI = read.getAttributeAsString(UMIReadFilter.UMI_TAG);\n+        this.umi1 = readUMI.split(\"-\", 2)[0];\n+        this.umi2 = readUMI.split(\"-\", 2)[1];\n+        if (this.umi1.compareTo(this.umi2) > 0) {\n+            umiLarge = this.umi1;\n+            umiSmall = this.umi2;\n+        } else {\n+            umiLarge = this.umi2;\n+            umiSmall = this.umi1;\n+        }\n+\n+    }\n+\n+    public static Pair<String, String> getUMI(final GATKRead read){\n+        final String readUMI = read.getAttributeAsString(UMIReadFilter.UMI_TAG);\n+        final String umi1 = readUMI.split(\"-\", 2)[0];\n+        final String umi2 = readUMI.split(\"-\", 2)[1];\n+\n+        return new ImmutablePair<>(umi1, umi2);\n+    }\n+\n+    public boolean equalsReadUMI(final GATKRead read){\n+        return false;\n+    }\n+\n+    // Strict match e.g. equalsExactly(\"AGT-GCT\", \"GCT-AGT\") returns false\n+    public boolean equalsExactly(final UMI that) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c14aa1527401cb1b4eaa1d545d1f966754403e4f"}, "originalPosition": 45}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzcyODk1MA==", "bodyText": "This should also be javadoc", "url": "https://github.com/broadinstitute/gatk/pull/6512#discussion_r407728950", "createdAt": "2020-04-13T21:21:41Z", "author": {"login": "lbergelson"}, "path": "src/main/java/org/broadinstitute/hellbender/tools/walkers/mutect/UMI.java", "diffHunk": "@@ -0,0 +1,66 @@\n+package org.broadinstitute.hellbender.tools.walkers.mutect;\n+\n+import org.apache.commons.lang3.tuple.ImmutablePair;\n+import org.apache.commons.lang3.tuple.Pair;\n+import org.broadinstitute.hellbender.engine.filters.UMIReadFilter;\n+import org.broadinstitute.hellbender.utils.read.GATKRead;\n+\n+public class UMI {\n+    // The umis are stored here in the order they are stored in the read.\n+    // e.g. if the read UMI is AAT-CGT, then umi1 = AAT, umi2 = CGT\n+    public final String umi1;\n+    public final String umi2;\n+\n+    // Lexicographical ordering of the two (duplex) UMIs;\n+    public String umiSmall;\n+    public String umiLarge;\n+\n+    public UMI(final GATKRead read){\n+        final String readUMI = read.getAttributeAsString(UMIReadFilter.UMI_TAG);\n+        this.umi1 = readUMI.split(\"-\", 2)[0];\n+        this.umi2 = readUMI.split(\"-\", 2)[1];\n+        if (this.umi1.compareTo(this.umi2) > 0) {\n+            umiLarge = this.umi1;\n+            umiSmall = this.umi2;\n+        } else {\n+            umiLarge = this.umi2;\n+            umiSmall = this.umi1;\n+        }\n+\n+    }\n+\n+    public static Pair<String, String> getUMI(final GATKRead read){\n+        final String readUMI = read.getAttributeAsString(UMIReadFilter.UMI_TAG);\n+        final String umi1 = readUMI.split(\"-\", 2)[0];\n+        final String umi2 = readUMI.split(\"-\", 2)[1];\n+\n+        return new ImmutablePair<>(umi1, umi2);\n+    }\n+\n+    public boolean equalsReadUMI(final GATKRead read){\n+        return false;\n+    }\n+\n+    // Strict match e.g. equalsExactly(\"AGT-GCT\", \"GCT-AGT\") returns false\n+    public boolean equalsExactly(final UMI that) {\n+        return that.umi1.equals(this.umi1) && that.umi2.equals(this.umi2);\n+    }\n+\n+    // Check for whether the two umis came from the same molecule\n+    // e.g. equalsModuloOrder(\"AGT-GCT\", \"GCT-AGT\") returns true\n+    //      equalsModuloOrder(\"AGT-GCT\", \"AGT-GCT\") also returns true\n+    public boolean equalsModuloOrder(final UMI that) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c14aa1527401cb1b4eaa1d545d1f966754403e4f"}, "originalPosition": 52}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzcyOTEwMQ==", "bodyText": "Is this post error correction?", "url": "https://github.com/broadinstitute/gatk/pull/6512#discussion_r407729101", "createdAt": "2020-04-13T21:22:01Z", "author": {"login": "lbergelson"}, "path": "src/main/java/org/broadinstitute/hellbender/tools/walkers/mutect/UMI.java", "diffHunk": "@@ -0,0 +1,66 @@\n+package org.broadinstitute.hellbender.tools.walkers.mutect;\n+\n+import org.apache.commons.lang3.tuple.ImmutablePair;\n+import org.apache.commons.lang3.tuple.Pair;\n+import org.broadinstitute.hellbender.engine.filters.UMIReadFilter;\n+import org.broadinstitute.hellbender.utils.read.GATKRead;\n+\n+public class UMI {\n+    // The umis are stored here in the order they are stored in the read.\n+    // e.g. if the read UMI is AAT-CGT, then umi1 = AAT, umi2 = CGT\n+    public final String umi1;\n+    public final String umi2;\n+\n+    // Lexicographical ordering of the two (duplex) UMIs;\n+    public String umiSmall;\n+    public String umiLarge;\n+\n+    public UMI(final GATKRead read){\n+        final String readUMI = read.getAttributeAsString(UMIReadFilter.UMI_TAG);\n+        this.umi1 = readUMI.split(\"-\", 2)[0];\n+        this.umi2 = readUMI.split(\"-\", 2)[1];\n+        if (this.umi1.compareTo(this.umi2) > 0) {\n+            umiLarge = this.umi1;\n+            umiSmall = this.umi2;\n+        } else {\n+            umiLarge = this.umi2;\n+            umiSmall = this.umi1;\n+        }\n+\n+    }\n+\n+    public static Pair<String, String> getUMI(final GATKRead read){\n+        final String readUMI = read.getAttributeAsString(UMIReadFilter.UMI_TAG);\n+        final String umi1 = readUMI.split(\"-\", 2)[0];\n+        final String umi2 = readUMI.split(\"-\", 2)[1];\n+\n+        return new ImmutablePair<>(umi1, umi2);\n+    }\n+\n+    public boolean equalsReadUMI(final GATKRead read){\n+        return false;\n+    }\n+\n+    // Strict match e.g. equalsExactly(\"AGT-GCT\", \"GCT-AGT\") returns false\n+    public boolean equalsExactly(final UMI that) {\n+        return that.umi1.equals(this.umi1) && that.umi2.equals(this.umi2);\n+    }\n+\n+    // Check for whether the two umis came from the same molecule\n+    // e.g. equalsModuloOrder(\"AGT-GCT\", \"GCT-AGT\") returns true\n+    //      equalsModuloOrder(\"AGT-GCT\", \"AGT-GCT\") also returns true\n+    public boolean equalsModuloOrder(final UMI that) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzcyODk1MA=="}, "originalCommit": {"oid": "c14aa1527401cb1b4eaa1d545d1f966754403e4f"}, "originalPosition": 52}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzcyOTE2NA==", "bodyText": "Javadoc", "url": "https://github.com/broadinstitute/gatk/pull/6512#discussion_r407729164", "createdAt": "2020-04-13T21:22:10Z", "author": {"login": "lbergelson"}, "path": "src/main/java/org/broadinstitute/hellbender/tools/walkers/mutect/UMI.java", "diffHunk": "@@ -0,0 +1,66 @@\n+package org.broadinstitute.hellbender.tools.walkers.mutect;\n+\n+import org.apache.commons.lang3.tuple.ImmutablePair;\n+import org.apache.commons.lang3.tuple.Pair;\n+import org.broadinstitute.hellbender.engine.filters.UMIReadFilter;\n+import org.broadinstitute.hellbender.utils.read.GATKRead;\n+\n+public class UMI {\n+    // The umis are stored here in the order they are stored in the read.\n+    // e.g. if the read UMI is AAT-CGT, then umi1 = AAT, umi2 = CGT\n+    public final String umi1;\n+    public final String umi2;\n+\n+    // Lexicographical ordering of the two (duplex) UMIs;\n+    public String umiSmall;\n+    public String umiLarge;\n+\n+    public UMI(final GATKRead read){\n+        final String readUMI = read.getAttributeAsString(UMIReadFilter.UMI_TAG);\n+        this.umi1 = readUMI.split(\"-\", 2)[0];\n+        this.umi2 = readUMI.split(\"-\", 2)[1];\n+        if (this.umi1.compareTo(this.umi2) > 0) {\n+            umiLarge = this.umi1;\n+            umiSmall = this.umi2;\n+        } else {\n+            umiLarge = this.umi2;\n+            umiSmall = this.umi1;\n+        }\n+\n+    }\n+\n+    public static Pair<String, String> getUMI(final GATKRead read){\n+        final String readUMI = read.getAttributeAsString(UMIReadFilter.UMI_TAG);\n+        final String umi1 = readUMI.split(\"-\", 2)[0];\n+        final String umi2 = readUMI.split(\"-\", 2)[1];\n+\n+        return new ImmutablePair<>(umi1, umi2);\n+    }\n+\n+    public boolean equalsReadUMI(final GATKRead read){\n+        return false;\n+    }\n+\n+    // Strict match e.g. equalsExactly(\"AGT-GCT\", \"GCT-AGT\") returns false\n+    public boolean equalsExactly(final UMI that) {\n+        return that.umi1.equals(this.umi1) && that.umi2.equals(this.umi2);\n+    }\n+\n+    // Check for whether the two umis came from the same molecule\n+    // e.g. equalsModuloOrder(\"AGT-GCT\", \"GCT-AGT\") returns true\n+    //      equalsModuloOrder(\"AGT-GCT\", \"AGT-GCT\") also returns true\n+    public boolean equalsModuloOrder(final UMI that) {\n+        // Sort the respective UMIs in lexicographical order and compare\n+        return that.umiSmall.equals(this.umiSmall) && that.umiLarge.equals(this.umiLarge);\n+    }\n+\n+    public String getStandardizedUMI(){", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c14aa1527401cb1b4eaa1d545d1f966754403e4f"}, "originalPosition": 57}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzcyOTI2Ng==", "bodyText": "This is redundant since you sorted them already, just return umiSmall + umiLong, or better yet just save the combination.", "url": "https://github.com/broadinstitute/gatk/pull/6512#discussion_r407729266", "createdAt": "2020-04-13T21:22:22Z", "author": {"login": "lbergelson"}, "path": "src/main/java/org/broadinstitute/hellbender/tools/walkers/mutect/UMI.java", "diffHunk": "@@ -0,0 +1,66 @@\n+package org.broadinstitute.hellbender.tools.walkers.mutect;\n+\n+import org.apache.commons.lang3.tuple.ImmutablePair;\n+import org.apache.commons.lang3.tuple.Pair;\n+import org.broadinstitute.hellbender.engine.filters.UMIReadFilter;\n+import org.broadinstitute.hellbender.utils.read.GATKRead;\n+\n+public class UMI {\n+    // The umis are stored here in the order they are stored in the read.\n+    // e.g. if the read UMI is AAT-CGT, then umi1 = AAT, umi2 = CGT\n+    public final String umi1;\n+    public final String umi2;\n+\n+    // Lexicographical ordering of the two (duplex) UMIs;\n+    public String umiSmall;\n+    public String umiLarge;\n+\n+    public UMI(final GATKRead read){\n+        final String readUMI = read.getAttributeAsString(UMIReadFilter.UMI_TAG);\n+        this.umi1 = readUMI.split(\"-\", 2)[0];\n+        this.umi2 = readUMI.split(\"-\", 2)[1];\n+        if (this.umi1.compareTo(this.umi2) > 0) {\n+            umiLarge = this.umi1;\n+            umiSmall = this.umi2;\n+        } else {\n+            umiLarge = this.umi2;\n+            umiSmall = this.umi1;\n+        }\n+\n+    }\n+\n+    public static Pair<String, String> getUMI(final GATKRead read){\n+        final String readUMI = read.getAttributeAsString(UMIReadFilter.UMI_TAG);\n+        final String umi1 = readUMI.split(\"-\", 2)[0];\n+        final String umi2 = readUMI.split(\"-\", 2)[1];\n+\n+        return new ImmutablePair<>(umi1, umi2);\n+    }\n+\n+    public boolean equalsReadUMI(final GATKRead read){\n+        return false;\n+    }\n+\n+    // Strict match e.g. equalsExactly(\"AGT-GCT\", \"GCT-AGT\") returns false\n+    public boolean equalsExactly(final UMI that) {\n+        return that.umi1.equals(this.umi1) && that.umi2.equals(this.umi2);\n+    }\n+\n+    // Check for whether the two umis came from the same molecule\n+    // e.g. equalsModuloOrder(\"AGT-GCT\", \"GCT-AGT\") returns true\n+    //      equalsModuloOrder(\"AGT-GCT\", \"AGT-GCT\") also returns true\n+    public boolean equalsModuloOrder(final UMI that) {\n+        // Sort the respective UMIs in lexicographical order and compare\n+        return that.umiSmall.equals(this.umiSmall) && that.umiLarge.equals(this.umiLarge);\n+    }\n+\n+    public String getStandardizedUMI(){\n+        if (umi1.compareTo(umi2) > 0){\n+            // umi1 is lexicographically greater e.g. umi1 = TAT, umi2 = AAC", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c14aa1527401cb1b4eaa1d545d1f966754403e4f"}, "originalPosition": 59}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzcyOTYwMg==", "bodyText": "This class has lots of unused/untested stuff that probably should be used / tested.  The umi logic should be implemented here and called from the filter.", "url": "https://github.com/broadinstitute/gatk/pull/6512#discussion_r407729602", "createdAt": "2020-04-13T21:23:03Z", "author": {"login": "lbergelson"}, "path": "src/main/java/org/broadinstitute/hellbender/tools/walkers/mutect/UMI.java", "diffHunk": "@@ -0,0 +1,66 @@\n+package org.broadinstitute.hellbender.tools.walkers.mutect;\n+\n+import org.apache.commons.lang3.tuple.ImmutablePair;\n+import org.apache.commons.lang3.tuple.Pair;\n+import org.broadinstitute.hellbender.engine.filters.UMIReadFilter;\n+import org.broadinstitute.hellbender.utils.read.GATKRead;\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c14aa1527401cb1b4eaa1d545d1f966754403e4f"}, "originalPosition": 7}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzkzMjUyNDk1", "url": "https://github.com/broadinstitute/gatk/pull/6512#pullrequestreview-393252495", "createdAt": "2020-04-14T20:01:35Z", "commit": {"oid": "c14aa1527401cb1b4eaa1d545d1f966754403e4f"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 56, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNFQyMDowMTozNVrOGFew6w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNFQyMTowMDozNlrOGFgusQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQwMDEwNw==", "bodyText": "typo?  tumor subclones", "url": "https://github.com/broadinstitute/gatk/pull/6512#discussion_r408400107", "createdAt": "2020-04-14T20:01:35Z", "author": {"login": "lbergelson"}, "path": "src/main/java/org/broadinstitute/hellbender/tools/walkers/consensus/DownsampleByDuplicateSet.java", "diffHunk": "@@ -0,0 +1,114 @@\n+package org.broadinstitute.hellbender.tools.walkers.consensus;\n+\n+import org.apache.commons.math3.random.RandomGenerator;\n+import org.apache.commons.math3.random.RandomGeneratorFactory;\n+import org.broadinstitute.barclay.argparser.Argument;\n+import org.broadinstitute.barclay.argparser.CommandLineProgramProperties;\n+import org.broadinstitute.hellbender.cmdline.StandardArgumentDefinitions;\n+import org.broadinstitute.hellbender.engine.DuplicateSetWalker;\n+import org.broadinstitute.hellbender.engine.FeatureContext;\n+import org.broadinstitute.hellbender.engine.ReferenceContext;\n+import org.broadinstitute.hellbender.tools.walkers.mutect.consensus.DuplicateSet;\n+import org.broadinstitute.hellbender.utils.io.IOUtils;\n+import org.broadinstitute.hellbender.utils.read.SAMFileGATKReadWriter;\n+import picard.cmdline.programgroups.ReadDataManipulationProgramGroup;\n+\n+import java.io.File;\n+import java.util.List;\n+import java.util.Random;\n+\n+@CommandLineProgramProperties(\n+        summary = \"Discard a set fraction of duplicate sets from a UMI-grouped ba\",\n+        oneLineSummary = \"Discard a set fraction of duplicate sets from a UMI-grouped bam\",\n+        programGroup = ReadDataManipulationProgramGroup.class\n+)\n+/**\n+ * Given a bam grouped by the same unique molecular identifier (UMI), this tool drops a fraction of duplicate sets and returns a new bam.\n+ * A duplicate set refers to a group of reads whose fragments start at and end at the same coordinate and share the same UMI.\n+ *\n+ * The input bam must have been sorted by UMI using FGBio GroupReadsByUmi (http://fulcrumgenomics.github.io/fgbio/tools/latest/GroupReadsByUmi.html).\n+ *\n+ * Use this tool to create, for instance, an insilico mixture of duplex-sequenced samples to simulate tumor subclone.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c14aa1527401cb1b4eaa1d545d1f966754403e4f"}, "originalPosition": 31}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQwMTA0Mw==", "bodyText": "I would probably give this a more descriptive name.  Maybe \"fraction-to-keep\"?", "url": "https://github.com/broadinstitute/gatk/pull/6512#discussion_r408401043", "createdAt": "2020-04-14T20:03:20Z", "author": {"login": "lbergelson"}, "path": "src/main/java/org/broadinstitute/hellbender/tools/walkers/consensus/DownsampleByDuplicateSet.java", "diffHunk": "@@ -0,0 +1,114 @@\n+package org.broadinstitute.hellbender.tools.walkers.consensus;\n+\n+import org.apache.commons.math3.random.RandomGenerator;\n+import org.apache.commons.math3.random.RandomGeneratorFactory;\n+import org.broadinstitute.barclay.argparser.Argument;\n+import org.broadinstitute.barclay.argparser.CommandLineProgramProperties;\n+import org.broadinstitute.hellbender.cmdline.StandardArgumentDefinitions;\n+import org.broadinstitute.hellbender.engine.DuplicateSetWalker;\n+import org.broadinstitute.hellbender.engine.FeatureContext;\n+import org.broadinstitute.hellbender.engine.ReferenceContext;\n+import org.broadinstitute.hellbender.tools.walkers.mutect.consensus.DuplicateSet;\n+import org.broadinstitute.hellbender.utils.io.IOUtils;\n+import org.broadinstitute.hellbender.utils.read.SAMFileGATKReadWriter;\n+import picard.cmdline.programgroups.ReadDataManipulationProgramGroup;\n+\n+import java.io.File;\n+import java.util.List;\n+import java.util.Random;\n+\n+@CommandLineProgramProperties(\n+        summary = \"Discard a set fraction of duplicate sets from a UMI-grouped ba\",\n+        oneLineSummary = \"Discard a set fraction of duplicate sets from a UMI-grouped bam\",\n+        programGroup = ReadDataManipulationProgramGroup.class\n+)\n+/**\n+ * Given a bam grouped by the same unique molecular identifier (UMI), this tool drops a fraction of duplicate sets and returns a new bam.\n+ * A duplicate set refers to a group of reads whose fragments start at and end at the same coordinate and share the same UMI.\n+ *\n+ * The input bam must have been sorted by UMI using FGBio GroupReadsByUmi (http://fulcrumgenomics.github.io/fgbio/tools/latest/GroupReadsByUmi.html).\n+ *\n+ * Use this tool to create, for instance, an insilico mixture of duplex-sequenced samples to simulate tumor subclone.\n+ * Suppose you wish to simulate a tumor sample in which 5% cells share a common set of somatic mutations\n+ * in addition to ones common to the entire cell population.\n+ *\n+ * If you randomly drop 5% of reads in sample A and 95% of reads in sample B and merge the reduced bams,\n+ * the resulting mixture skews the family-size distribution to the left. Here the family size refers to the\n+ * number of sequenced duplicate reads that share the same UMI.\n+ *\n+ * To see this, take a cancer sample, in which 5% of cells (i.e. a subclone) share a unique set of somatic mutations,\n+ * that was processed with duplex-UMIs (i.e. UMIs on both adapters) and high rounds of PCR. Suppose we have the sequence-ready\n+ * libraries of this sample attached to and amplified on the flowcell. Now, sort the flowcell lawn such that the\n+ * 5% subclone moves near the top of the flowcell. This subclone must have the same family-size distribution as\n+ * the rest of the flowcell, at about 5% of the library complexity compared to the entire flowcell.\n+ *\n+ * Now imagine replacing this subclone with 5% of the *entire* flowcell from another sample prepared and sequenced similarly.\n+ * The library complexity of these \"graft\" reads is higher than that of the original, and, consequently, with other parameters\n+ * such as the number of PCR cycles and sequencing depth fixed, its family distribution would be skewed left---that is, the family size\n+ * would be smaller than it should be.\n+ *\n+ * This tool address the above problem by dropping a set fraction of _duplicate sets_, rather than reads, at random.\n+ * Implicit in this approach is that a read and its mate are dropped or retained together.\n+ * While trivial when the input bam is sorted by UMI and query name, this is far from trivial when one attempts\n+ * to downsample reads naively with a tool like {@link PrintReads}.\n+ *\n+ **/\n+public class DownsampleByDuplicateSet extends DuplicateSetWalker {\n+    @Argument(fullName = StandardArgumentDefinitions.OUTPUT_LONG_NAME, shortName = StandardArgumentDefinitions.OUTPUT_SHORT_NAME, doc = \"\")\n+    public File outputBam;\n+\n+    @Argument(fullName = \"DS\", doc = \"This fraction of duplicate sets in the input bam will be retained\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c14aa1527401cb1b4eaa1d545d1f966754403e4f"}, "originalPosition": 60}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQwMTk1OQ==", "bodyText": "I don't think these fields should be static.", "url": "https://github.com/broadinstitute/gatk/pull/6512#discussion_r408401959", "createdAt": "2020-04-14T20:04:54Z", "author": {"login": "lbergelson"}, "path": "src/main/java/org/broadinstitute/hellbender/tools/walkers/consensus/DownsampleByDuplicateSet.java", "diffHunk": "@@ -0,0 +1,114 @@\n+package org.broadinstitute.hellbender.tools.walkers.consensus;\n+\n+import org.apache.commons.math3.random.RandomGenerator;\n+import org.apache.commons.math3.random.RandomGeneratorFactory;\n+import org.broadinstitute.barclay.argparser.Argument;\n+import org.broadinstitute.barclay.argparser.CommandLineProgramProperties;\n+import org.broadinstitute.hellbender.cmdline.StandardArgumentDefinitions;\n+import org.broadinstitute.hellbender.engine.DuplicateSetWalker;\n+import org.broadinstitute.hellbender.engine.FeatureContext;\n+import org.broadinstitute.hellbender.engine.ReferenceContext;\n+import org.broadinstitute.hellbender.tools.walkers.mutect.consensus.DuplicateSet;\n+import org.broadinstitute.hellbender.utils.io.IOUtils;\n+import org.broadinstitute.hellbender.utils.read.SAMFileGATKReadWriter;\n+import picard.cmdline.programgroups.ReadDataManipulationProgramGroup;\n+\n+import java.io.File;\n+import java.util.List;\n+import java.util.Random;\n+\n+@CommandLineProgramProperties(\n+        summary = \"Discard a set fraction of duplicate sets from a UMI-grouped ba\",\n+        oneLineSummary = \"Discard a set fraction of duplicate sets from a UMI-grouped bam\",\n+        programGroup = ReadDataManipulationProgramGroup.class\n+)\n+/**\n+ * Given a bam grouped by the same unique molecular identifier (UMI), this tool drops a fraction of duplicate sets and returns a new bam.\n+ * A duplicate set refers to a group of reads whose fragments start at and end at the same coordinate and share the same UMI.\n+ *\n+ * The input bam must have been sorted by UMI using FGBio GroupReadsByUmi (http://fulcrumgenomics.github.io/fgbio/tools/latest/GroupReadsByUmi.html).\n+ *\n+ * Use this tool to create, for instance, an insilico mixture of duplex-sequenced samples to simulate tumor subclone.\n+ * Suppose you wish to simulate a tumor sample in which 5% cells share a common set of somatic mutations\n+ * in addition to ones common to the entire cell population.\n+ *\n+ * If you randomly drop 5% of reads in sample A and 95% of reads in sample B and merge the reduced bams,\n+ * the resulting mixture skews the family-size distribution to the left. Here the family size refers to the\n+ * number of sequenced duplicate reads that share the same UMI.\n+ *\n+ * To see this, take a cancer sample, in which 5% of cells (i.e. a subclone) share a unique set of somatic mutations,\n+ * that was processed with duplex-UMIs (i.e. UMIs on both adapters) and high rounds of PCR. Suppose we have the sequence-ready\n+ * libraries of this sample attached to and amplified on the flowcell. Now, sort the flowcell lawn such that the\n+ * 5% subclone moves near the top of the flowcell. This subclone must have the same family-size distribution as\n+ * the rest of the flowcell, at about 5% of the library complexity compared to the entire flowcell.\n+ *\n+ * Now imagine replacing this subclone with 5% of the *entire* flowcell from another sample prepared and sequenced similarly.\n+ * The library complexity of these \"graft\" reads is higher than that of the original, and, consequently, with other parameters\n+ * such as the number of PCR cycles and sequencing depth fixed, its family distribution would be skewed left---that is, the family size\n+ * would be smaller than it should be.\n+ *\n+ * This tool address the above problem by dropping a set fraction of _duplicate sets_, rather than reads, at random.\n+ * Implicit in this approach is that a read and its mate are dropped or retained together.\n+ * While trivial when the input bam is sorted by UMI and query name, this is far from trivial when one attempts\n+ * to downsample reads naively with a tool like {@link PrintReads}.\n+ *\n+ **/\n+public class DownsampleByDuplicateSet extends DuplicateSetWalker {\n+    @Argument(fullName = StandardArgumentDefinitions.OUTPUT_LONG_NAME, shortName = StandardArgumentDefinitions.OUTPUT_SHORT_NAME, doc = \"\")\n+    public File outputBam;\n+\n+    @Argument(fullName = \"DS\", doc = \"This fraction of duplicate sets in the input bam will be retained\")\n+    public double downsamplingRate;\n+\n+    @Argument(fullName = \"keep-duplex-only\", doc = \"Discard all duplicate sets that don't have duplex evidence\")\n+    public boolean duplexOnly = false;\n+\n+    private static final int RANDOM_SEED = 142;\n+    private RandomGenerator rng;\n+    private static int numFragments;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c14aa1527401cb1b4eaa1d545d1f966754403e4f"}, "originalPosition": 68}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQwMjMyMA==", "bodyText": "Pre-sorted = false means this will resort the output I believe.  Is that what you want?", "url": "https://github.com/broadinstitute/gatk/pull/6512#discussion_r408402320", "createdAt": "2020-04-14T20:05:34Z", "author": {"login": "lbergelson"}, "path": "src/main/java/org/broadinstitute/hellbender/tools/walkers/consensus/DownsampleByDuplicateSet.java", "diffHunk": "@@ -0,0 +1,114 @@\n+package org.broadinstitute.hellbender.tools.walkers.consensus;\n+\n+import org.apache.commons.math3.random.RandomGenerator;\n+import org.apache.commons.math3.random.RandomGeneratorFactory;\n+import org.broadinstitute.barclay.argparser.Argument;\n+import org.broadinstitute.barclay.argparser.CommandLineProgramProperties;\n+import org.broadinstitute.hellbender.cmdline.StandardArgumentDefinitions;\n+import org.broadinstitute.hellbender.engine.DuplicateSetWalker;\n+import org.broadinstitute.hellbender.engine.FeatureContext;\n+import org.broadinstitute.hellbender.engine.ReferenceContext;\n+import org.broadinstitute.hellbender.tools.walkers.mutect.consensus.DuplicateSet;\n+import org.broadinstitute.hellbender.utils.io.IOUtils;\n+import org.broadinstitute.hellbender.utils.read.SAMFileGATKReadWriter;\n+import picard.cmdline.programgroups.ReadDataManipulationProgramGroup;\n+\n+import java.io.File;\n+import java.util.List;\n+import java.util.Random;\n+\n+@CommandLineProgramProperties(\n+        summary = \"Discard a set fraction of duplicate sets from a UMI-grouped ba\",\n+        oneLineSummary = \"Discard a set fraction of duplicate sets from a UMI-grouped bam\",\n+        programGroup = ReadDataManipulationProgramGroup.class\n+)\n+/**\n+ * Given a bam grouped by the same unique molecular identifier (UMI), this tool drops a fraction of duplicate sets and returns a new bam.\n+ * A duplicate set refers to a group of reads whose fragments start at and end at the same coordinate and share the same UMI.\n+ *\n+ * The input bam must have been sorted by UMI using FGBio GroupReadsByUmi (http://fulcrumgenomics.github.io/fgbio/tools/latest/GroupReadsByUmi.html).\n+ *\n+ * Use this tool to create, for instance, an insilico mixture of duplex-sequenced samples to simulate tumor subclone.\n+ * Suppose you wish to simulate a tumor sample in which 5% cells share a common set of somatic mutations\n+ * in addition to ones common to the entire cell population.\n+ *\n+ * If you randomly drop 5% of reads in sample A and 95% of reads in sample B and merge the reduced bams,\n+ * the resulting mixture skews the family-size distribution to the left. Here the family size refers to the\n+ * number of sequenced duplicate reads that share the same UMI.\n+ *\n+ * To see this, take a cancer sample, in which 5% of cells (i.e. a subclone) share a unique set of somatic mutations,\n+ * that was processed with duplex-UMIs (i.e. UMIs on both adapters) and high rounds of PCR. Suppose we have the sequence-ready\n+ * libraries of this sample attached to and amplified on the flowcell. Now, sort the flowcell lawn such that the\n+ * 5% subclone moves near the top of the flowcell. This subclone must have the same family-size distribution as\n+ * the rest of the flowcell, at about 5% of the library complexity compared to the entire flowcell.\n+ *\n+ * Now imagine replacing this subclone with 5% of the *entire* flowcell from another sample prepared and sequenced similarly.\n+ * The library complexity of these \"graft\" reads is higher than that of the original, and, consequently, with other parameters\n+ * such as the number of PCR cycles and sequencing depth fixed, its family distribution would be skewed left---that is, the family size\n+ * would be smaller than it should be.\n+ *\n+ * This tool address the above problem by dropping a set fraction of _duplicate sets_, rather than reads, at random.\n+ * Implicit in this approach is that a read and its mate are dropped or retained together.\n+ * While trivial when the input bam is sorted by UMI and query name, this is far from trivial when one attempts\n+ * to downsample reads naively with a tool like {@link PrintReads}.\n+ *\n+ **/\n+public class DownsampleByDuplicateSet extends DuplicateSetWalker {\n+    @Argument(fullName = StandardArgumentDefinitions.OUTPUT_LONG_NAME, shortName = StandardArgumentDefinitions.OUTPUT_SHORT_NAME, doc = \"\")\n+    public File outputBam;\n+\n+    @Argument(fullName = \"DS\", doc = \"This fraction of duplicate sets in the input bam will be retained\")\n+    public double downsamplingRate;\n+\n+    @Argument(fullName = \"keep-duplex-only\", doc = \"Discard all duplicate sets that don't have duplex evidence\")\n+    public boolean duplexOnly = false;\n+\n+    private static final int RANDOM_SEED = 142;\n+    private RandomGenerator rng;\n+    private static int numFragments;\n+    private static int numReads;\n+    private SAMFileGATKReadWriter outputWriter;\n+\n+    @Override\n+    public void onTraversalStart() {\n+        super.onTraversalStart();\n+        rng = RandomGeneratorFactory.createRandomGenerator(new Random(RANDOM_SEED));\n+        outputWriter = createSAMWriter(IOUtils.getPath(outputBam.getAbsolutePath()), false);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzU2NTM3OQ=="}, "originalCommit": {"oid": "c14aa1527401cb1b4eaa1d545d1f966754403e4f"}, "originalPosition": 76}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQwMjgwMw==", "bodyText": "This is unnecessary because the walker bases are obligated to NOT implement this.  It's fine to do it anyway though.", "url": "https://github.com/broadinstitute/gatk/pull/6512#discussion_r408402803", "createdAt": "2020-04-14T20:06:33Z", "author": {"login": "lbergelson"}, "path": "src/main/java/org/broadinstitute/hellbender/tools/walkers/consensus/DownsampleByDuplicateSet.java", "diffHunk": "@@ -0,0 +1,114 @@\n+package org.broadinstitute.hellbender.tools.walkers.consensus;\n+\n+import org.apache.commons.math3.random.RandomGenerator;\n+import org.apache.commons.math3.random.RandomGeneratorFactory;\n+import org.broadinstitute.barclay.argparser.Argument;\n+import org.broadinstitute.barclay.argparser.CommandLineProgramProperties;\n+import org.broadinstitute.hellbender.cmdline.StandardArgumentDefinitions;\n+import org.broadinstitute.hellbender.engine.DuplicateSetWalker;\n+import org.broadinstitute.hellbender.engine.FeatureContext;\n+import org.broadinstitute.hellbender.engine.ReferenceContext;\n+import org.broadinstitute.hellbender.tools.walkers.mutect.consensus.DuplicateSet;\n+import org.broadinstitute.hellbender.utils.io.IOUtils;\n+import org.broadinstitute.hellbender.utils.read.SAMFileGATKReadWriter;\n+import picard.cmdline.programgroups.ReadDataManipulationProgramGroup;\n+\n+import java.io.File;\n+import java.util.List;\n+import java.util.Random;\n+\n+@CommandLineProgramProperties(\n+        summary = \"Discard a set fraction of duplicate sets from a UMI-grouped ba\",\n+        oneLineSummary = \"Discard a set fraction of duplicate sets from a UMI-grouped bam\",\n+        programGroup = ReadDataManipulationProgramGroup.class\n+)\n+/**\n+ * Given a bam grouped by the same unique molecular identifier (UMI), this tool drops a fraction of duplicate sets and returns a new bam.\n+ * A duplicate set refers to a group of reads whose fragments start at and end at the same coordinate and share the same UMI.\n+ *\n+ * The input bam must have been sorted by UMI using FGBio GroupReadsByUmi (http://fulcrumgenomics.github.io/fgbio/tools/latest/GroupReadsByUmi.html).\n+ *\n+ * Use this tool to create, for instance, an insilico mixture of duplex-sequenced samples to simulate tumor subclone.\n+ * Suppose you wish to simulate a tumor sample in which 5% cells share a common set of somatic mutations\n+ * in addition to ones common to the entire cell population.\n+ *\n+ * If you randomly drop 5% of reads in sample A and 95% of reads in sample B and merge the reduced bams,\n+ * the resulting mixture skews the family-size distribution to the left. Here the family size refers to the\n+ * number of sequenced duplicate reads that share the same UMI.\n+ *\n+ * To see this, take a cancer sample, in which 5% of cells (i.e. a subclone) share a unique set of somatic mutations,\n+ * that was processed with duplex-UMIs (i.e. UMIs on both adapters) and high rounds of PCR. Suppose we have the sequence-ready\n+ * libraries of this sample attached to and amplified on the flowcell. Now, sort the flowcell lawn such that the\n+ * 5% subclone moves near the top of the flowcell. This subclone must have the same family-size distribution as\n+ * the rest of the flowcell, at about 5% of the library complexity compared to the entire flowcell.\n+ *\n+ * Now imagine replacing this subclone with 5% of the *entire* flowcell from another sample prepared and sequenced similarly.\n+ * The library complexity of these \"graft\" reads is higher than that of the original, and, consequently, with other parameters\n+ * such as the number of PCR cycles and sequencing depth fixed, its family distribution would be skewed left---that is, the family size\n+ * would be smaller than it should be.\n+ *\n+ * This tool address the above problem by dropping a set fraction of _duplicate sets_, rather than reads, at random.\n+ * Implicit in this approach is that a read and its mate are dropped or retained together.\n+ * While trivial when the input bam is sorted by UMI and query name, this is far from trivial when one attempts\n+ * to downsample reads naively with a tool like {@link PrintReads}.\n+ *\n+ **/\n+public class DownsampleByDuplicateSet extends DuplicateSetWalker {\n+    @Argument(fullName = StandardArgumentDefinitions.OUTPUT_LONG_NAME, shortName = StandardArgumentDefinitions.OUTPUT_SHORT_NAME, doc = \"\")\n+    public File outputBam;\n+\n+    @Argument(fullName = \"DS\", doc = \"This fraction of duplicate sets in the input bam will be retained\")\n+    public double downsamplingRate;\n+\n+    @Argument(fullName = \"keep-duplex-only\", doc = \"Discard all duplicate sets that don't have duplex evidence\")\n+    public boolean duplexOnly = false;\n+\n+    private static final int RANDOM_SEED = 142;\n+    private RandomGenerator rng;\n+    private static int numFragments;\n+    private static int numReads;\n+    private SAMFileGATKReadWriter outputWriter;\n+\n+    @Override\n+    public void onTraversalStart() {\n+        super.onTraversalStart();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c14aa1527401cb1b4eaa1d545d1f966754403e4f"}, "originalPosition": 74}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQwNDI1MA==", "bodyText": "Why use the apache3 RandomNumberGenerator and not the built in Random?  If there's no good reason I would just use the java builtin.  I might add a comment if there is a reason to use the apache one.", "url": "https://github.com/broadinstitute/gatk/pull/6512#discussion_r408404250", "createdAt": "2020-04-14T20:09:05Z", "author": {"login": "lbergelson"}, "path": "src/main/java/org/broadinstitute/hellbender/tools/walkers/consensus/DownsampleByDuplicateSet.java", "diffHunk": "@@ -0,0 +1,114 @@\n+package org.broadinstitute.hellbender.tools.walkers.consensus;\n+\n+import org.apache.commons.math3.random.RandomGenerator;\n+import org.apache.commons.math3.random.RandomGeneratorFactory;\n+import org.broadinstitute.barclay.argparser.Argument;\n+import org.broadinstitute.barclay.argparser.CommandLineProgramProperties;\n+import org.broadinstitute.hellbender.cmdline.StandardArgumentDefinitions;\n+import org.broadinstitute.hellbender.engine.DuplicateSetWalker;\n+import org.broadinstitute.hellbender.engine.FeatureContext;\n+import org.broadinstitute.hellbender.engine.ReferenceContext;\n+import org.broadinstitute.hellbender.tools.walkers.mutect.consensus.DuplicateSet;\n+import org.broadinstitute.hellbender.utils.io.IOUtils;\n+import org.broadinstitute.hellbender.utils.read.SAMFileGATKReadWriter;\n+import picard.cmdline.programgroups.ReadDataManipulationProgramGroup;\n+\n+import java.io.File;\n+import java.util.List;\n+import java.util.Random;\n+\n+@CommandLineProgramProperties(\n+        summary = \"Discard a set fraction of duplicate sets from a UMI-grouped ba\",\n+        oneLineSummary = \"Discard a set fraction of duplicate sets from a UMI-grouped bam\",\n+        programGroup = ReadDataManipulationProgramGroup.class\n+)\n+/**\n+ * Given a bam grouped by the same unique molecular identifier (UMI), this tool drops a fraction of duplicate sets and returns a new bam.\n+ * A duplicate set refers to a group of reads whose fragments start at and end at the same coordinate and share the same UMI.\n+ *\n+ * The input bam must have been sorted by UMI using FGBio GroupReadsByUmi (http://fulcrumgenomics.github.io/fgbio/tools/latest/GroupReadsByUmi.html).\n+ *\n+ * Use this tool to create, for instance, an insilico mixture of duplex-sequenced samples to simulate tumor subclone.\n+ * Suppose you wish to simulate a tumor sample in which 5% cells share a common set of somatic mutations\n+ * in addition to ones common to the entire cell population.\n+ *\n+ * If you randomly drop 5% of reads in sample A and 95% of reads in sample B and merge the reduced bams,\n+ * the resulting mixture skews the family-size distribution to the left. Here the family size refers to the\n+ * number of sequenced duplicate reads that share the same UMI.\n+ *\n+ * To see this, take a cancer sample, in which 5% of cells (i.e. a subclone) share a unique set of somatic mutations,\n+ * that was processed with duplex-UMIs (i.e. UMIs on both adapters) and high rounds of PCR. Suppose we have the sequence-ready\n+ * libraries of this sample attached to and amplified on the flowcell. Now, sort the flowcell lawn such that the\n+ * 5% subclone moves near the top of the flowcell. This subclone must have the same family-size distribution as\n+ * the rest of the flowcell, at about 5% of the library complexity compared to the entire flowcell.\n+ *\n+ * Now imagine replacing this subclone with 5% of the *entire* flowcell from another sample prepared and sequenced similarly.\n+ * The library complexity of these \"graft\" reads is higher than that of the original, and, consequently, with other parameters\n+ * such as the number of PCR cycles and sequencing depth fixed, its family distribution would be skewed left---that is, the family size\n+ * would be smaller than it should be.\n+ *\n+ * This tool address the above problem by dropping a set fraction of _duplicate sets_, rather than reads, at random.\n+ * Implicit in this approach is that a read and its mate are dropped or retained together.\n+ * While trivial when the input bam is sorted by UMI and query name, this is far from trivial when one attempts\n+ * to downsample reads naively with a tool like {@link PrintReads}.\n+ *\n+ **/\n+public class DownsampleByDuplicateSet extends DuplicateSetWalker {\n+    @Argument(fullName = StandardArgumentDefinitions.OUTPUT_LONG_NAME, shortName = StandardArgumentDefinitions.OUTPUT_SHORT_NAME, doc = \"\")\n+    public File outputBam;\n+\n+    @Argument(fullName = \"DS\", doc = \"This fraction of duplicate sets in the input bam will be retained\")\n+    public double downsamplingRate;\n+\n+    @Argument(fullName = \"keep-duplex-only\", doc = \"Discard all duplicate sets that don't have duplex evidence\")\n+    public boolean duplexOnly = false;\n+\n+    private static final int RANDOM_SEED = 142;\n+    private RandomGenerator rng;\n+    private static int numFragments;\n+    private static int numReads;\n+    private SAMFileGATKReadWriter outputWriter;\n+\n+    @Override\n+    public void onTraversalStart() {\n+        super.onTraversalStart();\n+        rng = RandomGeneratorFactory.createRandomGenerator(new Random(RANDOM_SEED));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c14aa1527401cb1b4eaa1d545d1f966754403e4f"}, "originalPosition": 75}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQwNTkxNw==", "bodyText": "This should also be closed in closeTool() and you should check for null before doing so there.", "url": "https://github.com/broadinstitute/gatk/pull/6512#discussion_r408405917", "createdAt": "2020-04-14T20:12:10Z", "author": {"login": "lbergelson"}, "path": "src/main/java/org/broadinstitute/hellbender/tools/walkers/consensus/DownsampleByDuplicateSet.java", "diffHunk": "@@ -0,0 +1,114 @@\n+package org.broadinstitute.hellbender.tools.walkers.consensus;\n+\n+import org.apache.commons.math3.random.RandomGenerator;\n+import org.apache.commons.math3.random.RandomGeneratorFactory;\n+import org.broadinstitute.barclay.argparser.Argument;\n+import org.broadinstitute.barclay.argparser.CommandLineProgramProperties;\n+import org.broadinstitute.hellbender.cmdline.StandardArgumentDefinitions;\n+import org.broadinstitute.hellbender.engine.DuplicateSetWalker;\n+import org.broadinstitute.hellbender.engine.FeatureContext;\n+import org.broadinstitute.hellbender.engine.ReferenceContext;\n+import org.broadinstitute.hellbender.tools.walkers.mutect.consensus.DuplicateSet;\n+import org.broadinstitute.hellbender.utils.io.IOUtils;\n+import org.broadinstitute.hellbender.utils.read.SAMFileGATKReadWriter;\n+import picard.cmdline.programgroups.ReadDataManipulationProgramGroup;\n+\n+import java.io.File;\n+import java.util.List;\n+import java.util.Random;\n+\n+@CommandLineProgramProperties(\n+        summary = \"Discard a set fraction of duplicate sets from a UMI-grouped ba\",\n+        oneLineSummary = \"Discard a set fraction of duplicate sets from a UMI-grouped bam\",\n+        programGroup = ReadDataManipulationProgramGroup.class\n+)\n+/**\n+ * Given a bam grouped by the same unique molecular identifier (UMI), this tool drops a fraction of duplicate sets and returns a new bam.\n+ * A duplicate set refers to a group of reads whose fragments start at and end at the same coordinate and share the same UMI.\n+ *\n+ * The input bam must have been sorted by UMI using FGBio GroupReadsByUmi (http://fulcrumgenomics.github.io/fgbio/tools/latest/GroupReadsByUmi.html).\n+ *\n+ * Use this tool to create, for instance, an insilico mixture of duplex-sequenced samples to simulate tumor subclone.\n+ * Suppose you wish to simulate a tumor sample in which 5% cells share a common set of somatic mutations\n+ * in addition to ones common to the entire cell population.\n+ *\n+ * If you randomly drop 5% of reads in sample A and 95% of reads in sample B and merge the reduced bams,\n+ * the resulting mixture skews the family-size distribution to the left. Here the family size refers to the\n+ * number of sequenced duplicate reads that share the same UMI.\n+ *\n+ * To see this, take a cancer sample, in which 5% of cells (i.e. a subclone) share a unique set of somatic mutations,\n+ * that was processed with duplex-UMIs (i.e. UMIs on both adapters) and high rounds of PCR. Suppose we have the sequence-ready\n+ * libraries of this sample attached to and amplified on the flowcell. Now, sort the flowcell lawn such that the\n+ * 5% subclone moves near the top of the flowcell. This subclone must have the same family-size distribution as\n+ * the rest of the flowcell, at about 5% of the library complexity compared to the entire flowcell.\n+ *\n+ * Now imagine replacing this subclone with 5% of the *entire* flowcell from another sample prepared and sequenced similarly.\n+ * The library complexity of these \"graft\" reads is higher than that of the original, and, consequently, with other parameters\n+ * such as the number of PCR cycles and sequencing depth fixed, its family distribution would be skewed left---that is, the family size\n+ * would be smaller than it should be.\n+ *\n+ * This tool address the above problem by dropping a set fraction of _duplicate sets_, rather than reads, at random.\n+ * Implicit in this approach is that a read and its mate are dropped or retained together.\n+ * While trivial when the input bam is sorted by UMI and query name, this is far from trivial when one attempts\n+ * to downsample reads naively with a tool like {@link PrintReads}.\n+ *\n+ **/\n+public class DownsampleByDuplicateSet extends DuplicateSetWalker {\n+    @Argument(fullName = StandardArgumentDefinitions.OUTPUT_LONG_NAME, shortName = StandardArgumentDefinitions.OUTPUT_SHORT_NAME, doc = \"\")\n+    public File outputBam;\n+\n+    @Argument(fullName = \"DS\", doc = \"This fraction of duplicate sets in the input bam will be retained\")\n+    public double downsamplingRate;\n+\n+    @Argument(fullName = \"keep-duplex-only\", doc = \"Discard all duplicate sets that don't have duplex evidence\")\n+    public boolean duplexOnly = false;\n+\n+    private static final int RANDOM_SEED = 142;\n+    private RandomGenerator rng;\n+    private static int numFragments;\n+    private static int numReads;\n+    private SAMFileGATKReadWriter outputWriter;\n+\n+    @Override\n+    public void onTraversalStart() {\n+        super.onTraversalStart();\n+        rng = RandomGeneratorFactory.createRandomGenerator(new Random(RANDOM_SEED));\n+        outputWriter = createSAMWriter(IOUtils.getPath(outputBam.getAbsolutePath()), false);\n+    }\n+\n+    @Override\n+    public void apply(DuplicateSet duplicateSet, ReferenceContext referenceContext, FeatureContext featureContext) {\n+        if (filterDuplicateSet(duplicateSet)){\n+            return;\n+        }\n+        if (rng.nextDouble() < downsamplingRate){\n+            duplicateSet.getReads().forEach(r -> outputWriter.addRead(r));\n+            numReads += duplicateSet.getReads().size();\n+            numFragments += 1;\n+        }\n+    }\n+\n+    @Override\n+    public Object onTraversalSuccess(){\n+        outputWriter.close();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c14aa1527401cb1b4eaa1d545d1f966754403e4f"}, "originalPosition": 93}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQwNzkxNA==", "bodyText": "If this is experimental I would make the argument that enables it @Advanced", "url": "https://github.com/broadinstitute/gatk/pull/6512#discussion_r408407914", "createdAt": "2020-04-14T20:15:53Z", "author": {"login": "lbergelson"}, "path": "src/main/java/org/broadinstitute/hellbender/tools/walkers/consensus/DownsampleByDuplicateSet.java", "diffHunk": "@@ -0,0 +1,114 @@\n+package org.broadinstitute.hellbender.tools.walkers.consensus;\n+\n+import org.apache.commons.math3.random.RandomGenerator;\n+import org.apache.commons.math3.random.RandomGeneratorFactory;\n+import org.broadinstitute.barclay.argparser.Argument;\n+import org.broadinstitute.barclay.argparser.CommandLineProgramProperties;\n+import org.broadinstitute.hellbender.cmdline.StandardArgumentDefinitions;\n+import org.broadinstitute.hellbender.engine.DuplicateSetWalker;\n+import org.broadinstitute.hellbender.engine.FeatureContext;\n+import org.broadinstitute.hellbender.engine.ReferenceContext;\n+import org.broadinstitute.hellbender.tools.walkers.mutect.consensus.DuplicateSet;\n+import org.broadinstitute.hellbender.utils.io.IOUtils;\n+import org.broadinstitute.hellbender.utils.read.SAMFileGATKReadWriter;\n+import picard.cmdline.programgroups.ReadDataManipulationProgramGroup;\n+\n+import java.io.File;\n+import java.util.List;\n+import java.util.Random;\n+\n+@CommandLineProgramProperties(\n+        summary = \"Discard a set fraction of duplicate sets from a UMI-grouped ba\",\n+        oneLineSummary = \"Discard a set fraction of duplicate sets from a UMI-grouped bam\",\n+        programGroup = ReadDataManipulationProgramGroup.class\n+)\n+/**\n+ * Given a bam grouped by the same unique molecular identifier (UMI), this tool drops a fraction of duplicate sets and returns a new bam.\n+ * A duplicate set refers to a group of reads whose fragments start at and end at the same coordinate and share the same UMI.\n+ *\n+ * The input bam must have been sorted by UMI using FGBio GroupReadsByUmi (http://fulcrumgenomics.github.io/fgbio/tools/latest/GroupReadsByUmi.html).\n+ *\n+ * Use this tool to create, for instance, an insilico mixture of duplex-sequenced samples to simulate tumor subclone.\n+ * Suppose you wish to simulate a tumor sample in which 5% cells share a common set of somatic mutations\n+ * in addition to ones common to the entire cell population.\n+ *\n+ * If you randomly drop 5% of reads in sample A and 95% of reads in sample B and merge the reduced bams,\n+ * the resulting mixture skews the family-size distribution to the left. Here the family size refers to the\n+ * number of sequenced duplicate reads that share the same UMI.\n+ *\n+ * To see this, take a cancer sample, in which 5% of cells (i.e. a subclone) share a unique set of somatic mutations,\n+ * that was processed with duplex-UMIs (i.e. UMIs on both adapters) and high rounds of PCR. Suppose we have the sequence-ready\n+ * libraries of this sample attached to and amplified on the flowcell. Now, sort the flowcell lawn such that the\n+ * 5% subclone moves near the top of the flowcell. This subclone must have the same family-size distribution as\n+ * the rest of the flowcell, at about 5% of the library complexity compared to the entire flowcell.\n+ *\n+ * Now imagine replacing this subclone with 5% of the *entire* flowcell from another sample prepared and sequenced similarly.\n+ * The library complexity of these \"graft\" reads is higher than that of the original, and, consequently, with other parameters\n+ * such as the number of PCR cycles and sequencing depth fixed, its family distribution would be skewed left---that is, the family size\n+ * would be smaller than it should be.\n+ *\n+ * This tool address the above problem by dropping a set fraction of _duplicate sets_, rather than reads, at random.\n+ * Implicit in this approach is that a read and its mate are dropped or retained together.\n+ * While trivial when the input bam is sorted by UMI and query name, this is far from trivial when one attempts\n+ * to downsample reads naively with a tool like {@link PrintReads}.\n+ *\n+ **/\n+public class DownsampleByDuplicateSet extends DuplicateSetWalker {\n+    @Argument(fullName = StandardArgumentDefinitions.OUTPUT_LONG_NAME, shortName = StandardArgumentDefinitions.OUTPUT_SHORT_NAME, doc = \"\")\n+    public File outputBam;\n+\n+    @Argument(fullName = \"DS\", doc = \"This fraction of duplicate sets in the input bam will be retained\")\n+    public double downsamplingRate;\n+\n+    @Argument(fullName = \"keep-duplex-only\", doc = \"Discard all duplicate sets that don't have duplex evidence\")\n+    public boolean duplexOnly = false;\n+\n+    private static final int RANDOM_SEED = 142;\n+    private RandomGenerator rng;\n+    private static int numFragments;\n+    private static int numReads;\n+    private SAMFileGATKReadWriter outputWriter;\n+\n+    @Override\n+    public void onTraversalStart() {\n+        super.onTraversalStart();\n+        rng = RandomGeneratorFactory.createRandomGenerator(new Random(RANDOM_SEED));\n+        outputWriter = createSAMWriter(IOUtils.getPath(outputBam.getAbsolutePath()), false);\n+    }\n+\n+    @Override\n+    public void apply(DuplicateSet duplicateSet, ReferenceContext referenceContext, FeatureContext featureContext) {\n+        if (filterDuplicateSet(duplicateSet)){\n+            return;\n+        }\n+        if (rng.nextDouble() < downsamplingRate){\n+            duplicateSet.getReads().forEach(r -> outputWriter.addRead(r));\n+            numReads += duplicateSet.getReads().size();\n+            numFragments += 1;\n+        }\n+    }\n+\n+    @Override\n+    public Object onTraversalSuccess(){\n+        outputWriter.close();\n+        logger.info(String.format(\"Wrote %d reads\", numReads));\n+        logger.info(String.format(\"Wrote %d fragments\", numFragments));\n+        return \"SUCCESS\";\n+    }\n+\n+    private boolean filterDuplicateSet(final DuplicateSet duplicateSet){\n+        if (duplicateSet.getReads().size() % 2 == 1){\n+            // We only keep reads with mates by default, as that's what fgbio GroupByUMI requires.\n+            logger.info(\"Duplicate set that contains an unpaired read discarded: \" + duplicateSet.getReads().get(0));\n+            return true;\n+        }\n+\n+        // Experiment: only keep duplex\n+        if (duplexOnly){", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c14aa1527401cb1b4eaa1d545d1f966754403e4f"}, "originalPosition": 107}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQwOTIxMQ==", "bodyText": "I'm confused about this.  I thought  reads were only added if they had the same molecularID?", "url": "https://github.com/broadinstitute/gatk/pull/6512#discussion_r408409211", "createdAt": "2020-04-14T20:18:13Z", "author": {"login": "lbergelson"}, "path": "src/main/java/org/broadinstitute/hellbender/tools/walkers/consensus/DownsampleByDuplicateSet.java", "diffHunk": "@@ -0,0 +1,114 @@\n+package org.broadinstitute.hellbender.tools.walkers.consensus;\n+\n+import org.apache.commons.math3.random.RandomGenerator;\n+import org.apache.commons.math3.random.RandomGeneratorFactory;\n+import org.broadinstitute.barclay.argparser.Argument;\n+import org.broadinstitute.barclay.argparser.CommandLineProgramProperties;\n+import org.broadinstitute.hellbender.cmdline.StandardArgumentDefinitions;\n+import org.broadinstitute.hellbender.engine.DuplicateSetWalker;\n+import org.broadinstitute.hellbender.engine.FeatureContext;\n+import org.broadinstitute.hellbender.engine.ReferenceContext;\n+import org.broadinstitute.hellbender.tools.walkers.mutect.consensus.DuplicateSet;\n+import org.broadinstitute.hellbender.utils.io.IOUtils;\n+import org.broadinstitute.hellbender.utils.read.SAMFileGATKReadWriter;\n+import picard.cmdline.programgroups.ReadDataManipulationProgramGroup;\n+\n+import java.io.File;\n+import java.util.List;\n+import java.util.Random;\n+\n+@CommandLineProgramProperties(\n+        summary = \"Discard a set fraction of duplicate sets from a UMI-grouped ba\",\n+        oneLineSummary = \"Discard a set fraction of duplicate sets from a UMI-grouped bam\",\n+        programGroup = ReadDataManipulationProgramGroup.class\n+)\n+/**\n+ * Given a bam grouped by the same unique molecular identifier (UMI), this tool drops a fraction of duplicate sets and returns a new bam.\n+ * A duplicate set refers to a group of reads whose fragments start at and end at the same coordinate and share the same UMI.\n+ *\n+ * The input bam must have been sorted by UMI using FGBio GroupReadsByUmi (http://fulcrumgenomics.github.io/fgbio/tools/latest/GroupReadsByUmi.html).\n+ *\n+ * Use this tool to create, for instance, an insilico mixture of duplex-sequenced samples to simulate tumor subclone.\n+ * Suppose you wish to simulate a tumor sample in which 5% cells share a common set of somatic mutations\n+ * in addition to ones common to the entire cell population.\n+ *\n+ * If you randomly drop 5% of reads in sample A and 95% of reads in sample B and merge the reduced bams,\n+ * the resulting mixture skews the family-size distribution to the left. Here the family size refers to the\n+ * number of sequenced duplicate reads that share the same UMI.\n+ *\n+ * To see this, take a cancer sample, in which 5% of cells (i.e. a subclone) share a unique set of somatic mutations,\n+ * that was processed with duplex-UMIs (i.e. UMIs on both adapters) and high rounds of PCR. Suppose we have the sequence-ready\n+ * libraries of this sample attached to and amplified on the flowcell. Now, sort the flowcell lawn such that the\n+ * 5% subclone moves near the top of the flowcell. This subclone must have the same family-size distribution as\n+ * the rest of the flowcell, at about 5% of the library complexity compared to the entire flowcell.\n+ *\n+ * Now imagine replacing this subclone with 5% of the *entire* flowcell from another sample prepared and sequenced similarly.\n+ * The library complexity of these \"graft\" reads is higher than that of the original, and, consequently, with other parameters\n+ * such as the number of PCR cycles and sequencing depth fixed, its family distribution would be skewed left---that is, the family size\n+ * would be smaller than it should be.\n+ *\n+ * This tool address the above problem by dropping a set fraction of _duplicate sets_, rather than reads, at random.\n+ * Implicit in this approach is that a read and its mate are dropped or retained together.\n+ * While trivial when the input bam is sorted by UMI and query name, this is far from trivial when one attempts\n+ * to downsample reads naively with a tool like {@link PrintReads}.\n+ *\n+ **/\n+public class DownsampleByDuplicateSet extends DuplicateSetWalker {\n+    @Argument(fullName = StandardArgumentDefinitions.OUTPUT_LONG_NAME, shortName = StandardArgumentDefinitions.OUTPUT_SHORT_NAME, doc = \"\")\n+    public File outputBam;\n+\n+    @Argument(fullName = \"DS\", doc = \"This fraction of duplicate sets in the input bam will be retained\")\n+    public double downsamplingRate;\n+\n+    @Argument(fullName = \"keep-duplex-only\", doc = \"Discard all duplicate sets that don't have duplex evidence\")\n+    public boolean duplexOnly = false;\n+\n+    private static final int RANDOM_SEED = 142;\n+    private RandomGenerator rng;\n+    private static int numFragments;\n+    private static int numReads;\n+    private SAMFileGATKReadWriter outputWriter;\n+\n+    @Override\n+    public void onTraversalStart() {\n+        super.onTraversalStart();\n+        rng = RandomGeneratorFactory.createRandomGenerator(new Random(RANDOM_SEED));\n+        outputWriter = createSAMWriter(IOUtils.getPath(outputBam.getAbsolutePath()), false);\n+    }\n+\n+    @Override\n+    public void apply(DuplicateSet duplicateSet, ReferenceContext referenceContext, FeatureContext featureContext) {\n+        if (filterDuplicateSet(duplicateSet)){\n+            return;\n+        }\n+        if (rng.nextDouble() < downsamplingRate){\n+            duplicateSet.getReads().forEach(r -> outputWriter.addRead(r));\n+            numReads += duplicateSet.getReads().size();\n+            numFragments += 1;\n+        }\n+    }\n+\n+    @Override\n+    public Object onTraversalSuccess(){\n+        outputWriter.close();\n+        logger.info(String.format(\"Wrote %d reads\", numReads));\n+        logger.info(String.format(\"Wrote %d fragments\", numFragments));\n+        return \"SUCCESS\";\n+    }\n+\n+    private boolean filterDuplicateSet(final DuplicateSet duplicateSet){\n+        if (duplicateSet.getReads().size() % 2 == 1){\n+            // We only keep reads with mates by default, as that's what fgbio GroupByUMI requires.\n+            logger.info(\"Duplicate set that contains an unpaired read discarded: \" + duplicateSet.getReads().get(0));\n+            return true;\n+        }\n+\n+        // Experiment: only keep duplex\n+        if (duplexOnly){\n+            final List<String> molecularIDs = DuplicateSet.getMolecularIDs(duplicateSet.getReads());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c14aa1527401cb1b4eaa1d545d1f966754403e4f"}, "originalPosition": 108}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQxMDA0MA==", "bodyText": "Do you have to take things like secondary/supplementary alignments into account here?", "url": "https://github.com/broadinstitute/gatk/pull/6512#discussion_r408410040", "createdAt": "2020-04-14T20:19:39Z", "author": {"login": "lbergelson"}, "path": "src/main/java/org/broadinstitute/hellbender/tools/walkers/consensus/DownsampleByDuplicateSet.java", "diffHunk": "@@ -0,0 +1,114 @@\n+package org.broadinstitute.hellbender.tools.walkers.consensus;\n+\n+import org.apache.commons.math3.random.RandomGenerator;\n+import org.apache.commons.math3.random.RandomGeneratorFactory;\n+import org.broadinstitute.barclay.argparser.Argument;\n+import org.broadinstitute.barclay.argparser.CommandLineProgramProperties;\n+import org.broadinstitute.hellbender.cmdline.StandardArgumentDefinitions;\n+import org.broadinstitute.hellbender.engine.DuplicateSetWalker;\n+import org.broadinstitute.hellbender.engine.FeatureContext;\n+import org.broadinstitute.hellbender.engine.ReferenceContext;\n+import org.broadinstitute.hellbender.tools.walkers.mutect.consensus.DuplicateSet;\n+import org.broadinstitute.hellbender.utils.io.IOUtils;\n+import org.broadinstitute.hellbender.utils.read.SAMFileGATKReadWriter;\n+import picard.cmdline.programgroups.ReadDataManipulationProgramGroup;\n+\n+import java.io.File;\n+import java.util.List;\n+import java.util.Random;\n+\n+@CommandLineProgramProperties(\n+        summary = \"Discard a set fraction of duplicate sets from a UMI-grouped ba\",\n+        oneLineSummary = \"Discard a set fraction of duplicate sets from a UMI-grouped bam\",\n+        programGroup = ReadDataManipulationProgramGroup.class\n+)\n+/**\n+ * Given a bam grouped by the same unique molecular identifier (UMI), this tool drops a fraction of duplicate sets and returns a new bam.\n+ * A duplicate set refers to a group of reads whose fragments start at and end at the same coordinate and share the same UMI.\n+ *\n+ * The input bam must have been sorted by UMI using FGBio GroupReadsByUmi (http://fulcrumgenomics.github.io/fgbio/tools/latest/GroupReadsByUmi.html).\n+ *\n+ * Use this tool to create, for instance, an insilico mixture of duplex-sequenced samples to simulate tumor subclone.\n+ * Suppose you wish to simulate a tumor sample in which 5% cells share a common set of somatic mutations\n+ * in addition to ones common to the entire cell population.\n+ *\n+ * If you randomly drop 5% of reads in sample A and 95% of reads in sample B and merge the reduced bams,\n+ * the resulting mixture skews the family-size distribution to the left. Here the family size refers to the\n+ * number of sequenced duplicate reads that share the same UMI.\n+ *\n+ * To see this, take a cancer sample, in which 5% of cells (i.e. a subclone) share a unique set of somatic mutations,\n+ * that was processed with duplex-UMIs (i.e. UMIs on both adapters) and high rounds of PCR. Suppose we have the sequence-ready\n+ * libraries of this sample attached to and amplified on the flowcell. Now, sort the flowcell lawn such that the\n+ * 5% subclone moves near the top of the flowcell. This subclone must have the same family-size distribution as\n+ * the rest of the flowcell, at about 5% of the library complexity compared to the entire flowcell.\n+ *\n+ * Now imagine replacing this subclone with 5% of the *entire* flowcell from another sample prepared and sequenced similarly.\n+ * The library complexity of these \"graft\" reads is higher than that of the original, and, consequently, with other parameters\n+ * such as the number of PCR cycles and sequencing depth fixed, its family distribution would be skewed left---that is, the family size\n+ * would be smaller than it should be.\n+ *\n+ * This tool address the above problem by dropping a set fraction of _duplicate sets_, rather than reads, at random.\n+ * Implicit in this approach is that a read and its mate are dropped or retained together.\n+ * While trivial when the input bam is sorted by UMI and query name, this is far from trivial when one attempts\n+ * to downsample reads naively with a tool like {@link PrintReads}.\n+ *\n+ **/\n+public class DownsampleByDuplicateSet extends DuplicateSetWalker {\n+    @Argument(fullName = StandardArgumentDefinitions.OUTPUT_LONG_NAME, shortName = StandardArgumentDefinitions.OUTPUT_SHORT_NAME, doc = \"\")\n+    public File outputBam;\n+\n+    @Argument(fullName = \"DS\", doc = \"This fraction of duplicate sets in the input bam will be retained\")\n+    public double downsamplingRate;\n+\n+    @Argument(fullName = \"keep-duplex-only\", doc = \"Discard all duplicate sets that don't have duplex evidence\")\n+    public boolean duplexOnly = false;\n+\n+    private static final int RANDOM_SEED = 142;\n+    private RandomGenerator rng;\n+    private static int numFragments;\n+    private static int numReads;\n+    private SAMFileGATKReadWriter outputWriter;\n+\n+    @Override\n+    public void onTraversalStart() {\n+        super.onTraversalStart();\n+        rng = RandomGeneratorFactory.createRandomGenerator(new Random(RANDOM_SEED));\n+        outputWriter = createSAMWriter(IOUtils.getPath(outputBam.getAbsolutePath()), false);\n+    }\n+\n+    @Override\n+    public void apply(DuplicateSet duplicateSet, ReferenceContext referenceContext, FeatureContext featureContext) {\n+        if (filterDuplicateSet(duplicateSet)){\n+            return;\n+        }\n+        if (rng.nextDouble() < downsamplingRate){\n+            duplicateSet.getReads().forEach(r -> outputWriter.addRead(r));\n+            numReads += duplicateSet.getReads().size();\n+            numFragments += 1;\n+        }\n+    }\n+\n+    @Override\n+    public Object onTraversalSuccess(){\n+        outputWriter.close();\n+        logger.info(String.format(\"Wrote %d reads\", numReads));\n+        logger.info(String.format(\"Wrote %d fragments\", numFragments));\n+        return \"SUCCESS\";\n+    }\n+\n+    private boolean filterDuplicateSet(final DuplicateSet duplicateSet){\n+        if (duplicateSet.getReads().size() % 2 == 1){", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c14aa1527401cb1b4eaa1d545d1f966754403e4f"}, "originalPosition": 100}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQxMDUxOA==", "bodyText": "Needs javadoc.  This might cause confusion with the existing DuplicateSet from htsjdk.  I don't know if there's a slightly more descriptive name that could be used?  If you think DuplicateSet is the right name then some confusion is ok though.", "url": "https://github.com/broadinstitute/gatk/pull/6512#discussion_r408410518", "createdAt": "2020-04-14T20:20:28Z", "author": {"login": "lbergelson"}, "path": "src/main/java/org/broadinstitute/hellbender/tools/walkers/mutect/consensus/DuplicateSet.java", "diffHunk": "@@ -0,0 +1,122 @@\n+package org.broadinstitute.hellbender.tools.walkers.mutect.consensus;\n+\n+import org.broadinstitute.hellbender.tools.walkers.mutect.UMI;\n+import org.broadinstitute.hellbender.utils.SimpleInterval;\n+import org.broadinstitute.hellbender.utils.Utils;\n+import org.broadinstitute.hellbender.utils.read.GATKRead;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+public class DuplicateSet {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c14aa1527401cb1b4eaa1d545d1f966754403e4f"}, "originalPosition": 12}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQxMTI3MA==", "bodyText": "I think this is standard in the sam spec now.  ReferenceSamTags.MI.name()", "url": "https://github.com/broadinstitute/gatk/pull/6512#discussion_r408411270", "createdAt": "2020-04-14T20:21:53Z", "author": {"login": "lbergelson"}, "path": "src/main/java/org/broadinstitute/hellbender/tools/walkers/mutect/consensus/DuplicateSet.java", "diffHunk": "@@ -0,0 +1,122 @@\n+package org.broadinstitute.hellbender.tools.walkers.mutect.consensus;\n+\n+import org.broadinstitute.hellbender.tools.walkers.mutect.UMI;\n+import org.broadinstitute.hellbender.utils.SimpleInterval;\n+import org.broadinstitute.hellbender.utils.Utils;\n+import org.broadinstitute.hellbender.utils.read.GATKRead;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+public class DuplicateSet {\n+    public static final String FGBIO_MOLECULAR_IDENTIFIER_TAG = \"MI\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c14aa1527401cb1b4eaa1d545d1f966754403e4f"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQxMTY0NQ==", "bodyText": "I'm confused about this, you expose -1 as a constant elsewhere, can all of that be handled internally instead?", "url": "https://github.com/broadinstitute/gatk/pull/6512#discussion_r408411645", "createdAt": "2020-04-14T20:22:34Z", "author": {"login": "lbergelson"}, "path": "src/main/java/org/broadinstitute/hellbender/tools/walkers/mutect/consensus/DuplicateSet.java", "diffHunk": "@@ -0,0 +1,122 @@\n+package org.broadinstitute.hellbender.tools.walkers.mutect.consensus;\n+\n+import org.broadinstitute.hellbender.tools.walkers.mutect.UMI;\n+import org.broadinstitute.hellbender.utils.SimpleInterval;\n+import org.broadinstitute.hellbender.utils.Utils;\n+import org.broadinstitute.hellbender.utils.read.GATKRead;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+public class DuplicateSet {\n+    public static final String FGBIO_MOLECULAR_IDENTIFIER_TAG = \"MI\";\n+    public static final String FGBIO_MI_TAG_DELIMITER = \"/\";\n+    private int moleculeId = -1; // TODO: extract an ID class.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c14aa1527401cb1b4eaa1d545d1f966754403e4f"}, "originalPosition": 15}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQxMTY5OA==", "bodyText": "This is never actually used.", "url": "https://github.com/broadinstitute/gatk/pull/6512#discussion_r408411698", "createdAt": "2020-04-14T20:22:40Z", "author": {"login": "lbergelson"}, "path": "src/main/java/org/broadinstitute/hellbender/tools/walkers/mutect/consensus/DuplicateSet.java", "diffHunk": "@@ -0,0 +1,122 @@\n+package org.broadinstitute.hellbender.tools.walkers.mutect.consensus;\n+\n+import org.broadinstitute.hellbender.tools.walkers.mutect.UMI;\n+import org.broadinstitute.hellbender.utils.SimpleInterval;\n+import org.broadinstitute.hellbender.utils.Utils;\n+import org.broadinstitute.hellbender.utils.read.GATKRead;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+public class DuplicateSet {\n+    public static final String FGBIO_MOLECULAR_IDENTIFIER_TAG = \"MI\";\n+    public static final String FGBIO_MI_TAG_DELIMITER = \"/\";\n+    private int moleculeId = -1; // TODO: extract an ID class.\n+    private UMI umi;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c14aa1527401cb1b4eaa1d545d1f966754403e4f"}, "originalPosition": 16}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQxMjAwMA==", "bodyText": "This should implement Locatable.", "url": "https://github.com/broadinstitute/gatk/pull/6512#discussion_r408412000", "createdAt": "2020-04-14T20:23:11Z", "author": {"login": "lbergelson"}, "path": "src/main/java/org/broadinstitute/hellbender/tools/walkers/mutect/consensus/DuplicateSet.java", "diffHunk": "@@ -0,0 +1,122 @@\n+package org.broadinstitute.hellbender.tools.walkers.mutect.consensus;\n+\n+import org.broadinstitute.hellbender.tools.walkers.mutect.UMI;\n+import org.broadinstitute.hellbender.utils.SimpleInterval;\n+import org.broadinstitute.hellbender.utils.Utils;\n+import org.broadinstitute.hellbender.utils.read.GATKRead;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+public class DuplicateSet {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c14aa1527401cb1b4eaa1d545d1f966754403e4f"}, "originalPosition": 12}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQxMzM5MQ==", "bodyText": "this can be final and initialized here.", "url": "https://github.com/broadinstitute/gatk/pull/6512#discussion_r408413391", "createdAt": "2020-04-14T20:25:43Z", "author": {"login": "lbergelson"}, "path": "src/main/java/org/broadinstitute/hellbender/tools/walkers/mutect/consensus/DuplicateSet.java", "diffHunk": "@@ -0,0 +1,122 @@\n+package org.broadinstitute.hellbender.tools.walkers.mutect.consensus;\n+\n+import org.broadinstitute.hellbender.tools.walkers.mutect.UMI;\n+import org.broadinstitute.hellbender.utils.SimpleInterval;\n+import org.broadinstitute.hellbender.utils.Utils;\n+import org.broadinstitute.hellbender.utils.read.GATKRead;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+public class DuplicateSet {\n+    public static final String FGBIO_MOLECULAR_IDENTIFIER_TAG = \"MI\";\n+    public static final String FGBIO_MI_TAG_DELIMITER = \"/\";\n+    private int moleculeId = -1; // TODO: extract an ID class.\n+    private UMI umi;\n+    private String contig;\n+    private int fragmentStart = -1;\n+    private int fragmentEnd = -1;\n+    private List<GATKRead> reads;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c14aa1527401cb1b4eaa1d545d1f966754403e4f"}, "originalPosition": 20}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQxMzUwOQ==", "bodyText": "You could keep an internal simple interval  / locatable if you didn't want 3 fields.  It's fine to have 3 though if you think that's easier.", "url": "https://github.com/broadinstitute/gatk/pull/6512#discussion_r408413509", "createdAt": "2020-04-14T20:25:58Z", "author": {"login": "lbergelson"}, "path": "src/main/java/org/broadinstitute/hellbender/tools/walkers/mutect/consensus/DuplicateSet.java", "diffHunk": "@@ -0,0 +1,122 @@\n+package org.broadinstitute.hellbender.tools.walkers.mutect.consensus;\n+\n+import org.broadinstitute.hellbender.tools.walkers.mutect.UMI;\n+import org.broadinstitute.hellbender.utils.SimpleInterval;\n+import org.broadinstitute.hellbender.utils.Utils;\n+import org.broadinstitute.hellbender.utils.read.GATKRead;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+public class DuplicateSet {\n+    public static final String FGBIO_MOLECULAR_IDENTIFIER_TAG = \"MI\";\n+    public static final String FGBIO_MI_TAG_DELIMITER = \"/\";\n+    private int moleculeId = -1; // TODO: extract an ID class.\n+    private UMI umi;\n+    private String contig;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c14aa1527401cb1b4eaa1d545d1f966754403e4f"}, "originalPosition": 17}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQxNDQ1MQ==", "bodyText": "This is never set or used", "url": "https://github.com/broadinstitute/gatk/pull/6512#discussion_r408414451", "createdAt": "2020-04-14T20:27:47Z", "author": {"login": "lbergelson"}, "path": "src/main/java/org/broadinstitute/hellbender/tools/walkers/mutect/consensus/DuplicateSet.java", "diffHunk": "@@ -0,0 +1,122 @@\n+package org.broadinstitute.hellbender.tools.walkers.mutect.consensus;\n+\n+import org.broadinstitute.hellbender.tools.walkers.mutect.UMI;\n+import org.broadinstitute.hellbender.utils.SimpleInterval;\n+import org.broadinstitute.hellbender.utils.Utils;\n+import org.broadinstitute.hellbender.utils.read.GATKRead;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+public class DuplicateSet {\n+    public static final String FGBIO_MOLECULAR_IDENTIFIER_TAG = \"MI\";\n+    public static final String FGBIO_MI_TAG_DELIMITER = \"/\";\n+    private int moleculeId = -1; // TODO: extract an ID class.\n+    private UMI umi;\n+    private String contig;\n+    private int fragmentStart = -1;\n+    private int fragmentEnd = -1;\n+    private List<GATKRead> reads;\n+    boolean smallInsert; // if true, the reads read into adaptors", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c14aa1527401cb1b4eaa1d545d1f966754403e4f"}, "originalPosition": 21}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQxNDYxOQ==", "bodyText": "This isn't used either and it's only kind of set.", "url": "https://github.com/broadinstitute/gatk/pull/6512#discussion_r408414619", "createdAt": "2020-04-14T20:28:05Z", "author": {"login": "lbergelson"}, "path": "src/main/java/org/broadinstitute/hellbender/tools/walkers/mutect/consensus/DuplicateSet.java", "diffHunk": "@@ -0,0 +1,122 @@\n+package org.broadinstitute.hellbender.tools.walkers.mutect.consensus;\n+\n+import org.broadinstitute.hellbender.tools.walkers.mutect.UMI;\n+import org.broadinstitute.hellbender.utils.SimpleInterval;\n+import org.broadinstitute.hellbender.utils.Utils;\n+import org.broadinstitute.hellbender.utils.read.GATKRead;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+public class DuplicateSet {\n+    public static final String FGBIO_MOLECULAR_IDENTIFIER_TAG = \"MI\";\n+    public static final String FGBIO_MI_TAG_DELIMITER = \"/\";\n+    private int moleculeId = -1; // TODO: extract an ID class.\n+    private UMI umi;\n+    private String contig;\n+    private int fragmentStart = -1;\n+    private int fragmentEnd = -1;\n+    private List<GATKRead> reads;\n+    boolean smallInsert; // if true, the reads read into adaptors\n+    private boolean paired;  // TODO: is this useful/how can I detect this?", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c14aa1527401cb1b4eaa1d545d1f966754403e4f"}, "originalPosition": 22}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQxNDc0MA==", "bodyText": "This comment needs addressing.", "url": "https://github.com/broadinstitute/gatk/pull/6512#discussion_r408414740", "createdAt": "2020-04-14T20:28:20Z", "author": {"login": "lbergelson"}, "path": "src/main/java/org/broadinstitute/hellbender/tools/walkers/mutect/consensus/DuplicateSet.java", "diffHunk": "@@ -0,0 +1,122 @@\n+package org.broadinstitute.hellbender.tools.walkers.mutect.consensus;\n+\n+import org.broadinstitute.hellbender.tools.walkers.mutect.UMI;\n+import org.broadinstitute.hellbender.utils.SimpleInterval;\n+import org.broadinstitute.hellbender.utils.Utils;\n+import org.broadinstitute.hellbender.utils.read.GATKRead;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+public class DuplicateSet {\n+    public static final String FGBIO_MOLECULAR_IDENTIFIER_TAG = \"MI\";\n+    public static final String FGBIO_MI_TAG_DELIMITER = \"/\";\n+    private int moleculeId = -1; // TODO: extract an ID class.\n+    private UMI umi;\n+    private String contig;\n+    private int fragmentStart = -1;\n+    private int fragmentEnd = -1;\n+    private List<GATKRead> reads;\n+    boolean smallInsert; // if true, the reads read into adaptors\n+    private boolean paired;  // TODO: is this useful/how can I detect this?\n+    // IN FACT, start here, also write tests --- count the number of MI=1's, MI=2's, etc...", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c14aa1527401cb1b4eaa1d545d1f966754403e4f"}, "originalPosition": 23}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQxNTEwMA==", "bodyText": "javadoc", "url": "https://github.com/broadinstitute/gatk/pull/6512#discussion_r408415100", "createdAt": "2020-04-14T20:28:54Z", "author": {"login": "lbergelson"}, "path": "src/main/java/org/broadinstitute/hellbender/tools/walkers/mutect/consensus/DuplicateSet.java", "diffHunk": "@@ -0,0 +1,122 @@\n+package org.broadinstitute.hellbender.tools.walkers.mutect.consensus;\n+\n+import org.broadinstitute.hellbender.tools.walkers.mutect.UMI;\n+import org.broadinstitute.hellbender.utils.SimpleInterval;\n+import org.broadinstitute.hellbender.utils.Utils;\n+import org.broadinstitute.hellbender.utils.read.GATKRead;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+public class DuplicateSet {\n+    public static final String FGBIO_MOLECULAR_IDENTIFIER_TAG = \"MI\";\n+    public static final String FGBIO_MI_TAG_DELIMITER = \"/\";\n+    private int moleculeId = -1; // TODO: extract an ID class.\n+    private UMI umi;\n+    private String contig;\n+    private int fragmentStart = -1;\n+    private int fragmentEnd = -1;\n+    private List<GATKRead> reads;\n+    boolean smallInsert; // if true, the reads read into adaptors\n+    private boolean paired;  // TODO: is this useful/how can I detect this?\n+    // IN FACT, start here, also write tests --- count the number of MI=1's, MI=2's, etc...\n+    public DuplicateSet(){", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c14aa1527401cb1b4eaa1d545d1f966754403e4f"}, "originalPosition": 24}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQxNTU4Mg==", "bodyText": "If your second constructor starts with the same code as the first constructor it's better to just do this();", "url": "https://github.com/broadinstitute/gatk/pull/6512#discussion_r408415582", "createdAt": "2020-04-14T20:29:48Z", "author": {"login": "lbergelson"}, "path": "src/main/java/org/broadinstitute/hellbender/tools/walkers/mutect/consensus/DuplicateSet.java", "diffHunk": "@@ -0,0 +1,122 @@\n+package org.broadinstitute.hellbender.tools.walkers.mutect.consensus;\n+\n+import org.broadinstitute.hellbender.tools.walkers.mutect.UMI;\n+import org.broadinstitute.hellbender.utils.SimpleInterval;\n+import org.broadinstitute.hellbender.utils.Utils;\n+import org.broadinstitute.hellbender.utils.read.GATKRead;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+public class DuplicateSet {\n+    public static final String FGBIO_MOLECULAR_IDENTIFIER_TAG = \"MI\";\n+    public static final String FGBIO_MI_TAG_DELIMITER = \"/\";\n+    private int moleculeId = -1; // TODO: extract an ID class.\n+    private UMI umi;\n+    private String contig;\n+    private int fragmentStart = -1;\n+    private int fragmentEnd = -1;\n+    private List<GATKRead> reads;\n+    boolean smallInsert; // if true, the reads read into adaptors\n+    private boolean paired;  // TODO: is this useful/how can I detect this?\n+    // IN FACT, start here, also write tests --- count the number of MI=1's, MI=2's, etc...\n+    public DuplicateSet(){\n+        reads = new ArrayList<>();\n+    }\n+\n+    public DuplicateSet(final GATKRead read){", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c14aa1527401cb1b4eaa1d545d1f966754403e4f"}, "originalPosition": 28}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQxNTgyOQ==", "bodyText": "This seems like it should be private.", "url": "https://github.com/broadinstitute/gatk/pull/6512#discussion_r408415829", "createdAt": "2020-04-14T20:30:16Z", "author": {"login": "lbergelson"}, "path": "src/main/java/org/broadinstitute/hellbender/tools/walkers/mutect/consensus/DuplicateSet.java", "diffHunk": "@@ -0,0 +1,122 @@\n+package org.broadinstitute.hellbender.tools.walkers.mutect.consensus;\n+\n+import org.broadinstitute.hellbender.tools.walkers.mutect.UMI;\n+import org.broadinstitute.hellbender.utils.SimpleInterval;\n+import org.broadinstitute.hellbender.utils.Utils;\n+import org.broadinstitute.hellbender.utils.read.GATKRead;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+public class DuplicateSet {\n+    public static final String FGBIO_MOLECULAR_IDENTIFIER_TAG = \"MI\";\n+    public static final String FGBIO_MI_TAG_DELIMITER = \"/\";\n+    private int moleculeId = -1; // TODO: extract an ID class.\n+    private UMI umi;\n+    private String contig;\n+    private int fragmentStart = -1;\n+    private int fragmentEnd = -1;\n+    private List<GATKRead> reads;\n+    boolean smallInsert; // if true, the reads read into adaptors\n+    private boolean paired;  // TODO: is this useful/how can I detect this?\n+    // IN FACT, start here, also write tests --- count the number of MI=1's, MI=2's, etc...\n+    public DuplicateSet(){\n+        reads = new ArrayList<>();\n+    }\n+\n+    public DuplicateSet(final GATKRead read){\n+        reads = new ArrayList<>();\n+        init(read);\n+        reads.add(read);\n+    }\n+\n+    public void init(GATKRead read){", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c14aa1527401cb1b4eaa1d545d1f966754403e4f"}, "originalPosition": 34}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQxNjA1OQ==", "bodyText": "typo in Inconsisntent.", "url": "https://github.com/broadinstitute/gatk/pull/6512#discussion_r408416059", "createdAt": "2020-04-14T20:30:41Z", "author": {"login": "lbergelson"}, "path": "src/main/java/org/broadinstitute/hellbender/tools/walkers/mutect/consensus/DuplicateSet.java", "diffHunk": "@@ -0,0 +1,122 @@\n+package org.broadinstitute.hellbender.tools.walkers.mutect.consensus;\n+\n+import org.broadinstitute.hellbender.tools.walkers.mutect.UMI;\n+import org.broadinstitute.hellbender.utils.SimpleInterval;\n+import org.broadinstitute.hellbender.utils.Utils;\n+import org.broadinstitute.hellbender.utils.read.GATKRead;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+public class DuplicateSet {\n+    public static final String FGBIO_MOLECULAR_IDENTIFIER_TAG = \"MI\";\n+    public static final String FGBIO_MI_TAG_DELIMITER = \"/\";\n+    private int moleculeId = -1; // TODO: extract an ID class.\n+    private UMI umi;\n+    private String contig;\n+    private int fragmentStart = -1;\n+    private int fragmentEnd = -1;\n+    private List<GATKRead> reads;\n+    boolean smallInsert; // if true, the reads read into adaptors\n+    private boolean paired;  // TODO: is this useful/how can I detect this?\n+    // IN FACT, start here, also write tests --- count the number of MI=1's, MI=2's, etc...\n+    public DuplicateSet(){\n+        reads = new ArrayList<>();\n+    }\n+\n+    public DuplicateSet(final GATKRead read){\n+        reads = new ArrayList<>();\n+        init(read);\n+        reads.add(read);\n+    }\n+\n+    public void init(GATKRead read){\n+        Utils.validate(moleculeId == -1 || moleculeId == getMoleculeID(read),\n+                String.format(\"Inconsisntent molecule IDs: Duplicate set id = %s, read molecule id = %s\", moleculeId, getMoleculeID(read)));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c14aa1527401cb1b4eaa1d545d1f966754403e4f"}, "originalPosition": 36}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQxNjE4Nw==", "bodyText": "split these onto 2 lines.", "url": "https://github.com/broadinstitute/gatk/pull/6512#discussion_r408416187", "createdAt": "2020-04-14T20:30:54Z", "author": {"login": "lbergelson"}, "path": "src/main/java/org/broadinstitute/hellbender/tools/walkers/mutect/consensus/DuplicateSet.java", "diffHunk": "@@ -0,0 +1,122 @@\n+package org.broadinstitute.hellbender.tools.walkers.mutect.consensus;\n+\n+import org.broadinstitute.hellbender.tools.walkers.mutect.UMI;\n+import org.broadinstitute.hellbender.utils.SimpleInterval;\n+import org.broadinstitute.hellbender.utils.Utils;\n+import org.broadinstitute.hellbender.utils.read.GATKRead;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+public class DuplicateSet {\n+    public static final String FGBIO_MOLECULAR_IDENTIFIER_TAG = \"MI\";\n+    public static final String FGBIO_MI_TAG_DELIMITER = \"/\";\n+    private int moleculeId = -1; // TODO: extract an ID class.\n+    private UMI umi;\n+    private String contig;\n+    private int fragmentStart = -1;\n+    private int fragmentEnd = -1;\n+    private List<GATKRead> reads;\n+    boolean smallInsert; // if true, the reads read into adaptors\n+    private boolean paired;  // TODO: is this useful/how can I detect this?\n+    // IN FACT, start here, also write tests --- count the number of MI=1's, MI=2's, etc...\n+    public DuplicateSet(){\n+        reads = new ArrayList<>();\n+    }\n+\n+    public DuplicateSet(final GATKRead read){\n+        reads = new ArrayList<>();\n+        init(read);\n+        reads.add(read);\n+    }\n+\n+    public void init(GATKRead read){\n+        Utils.validate(moleculeId == -1 || moleculeId == getMoleculeID(read),\n+                String.format(\"Inconsisntent molecule IDs: Duplicate set id = %s, read molecule id = %s\", moleculeId, getMoleculeID(read)));\n+        setMoleduleId(read);umi = new UMI(read);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c14aa1527401cb1b4eaa1d545d1f966754403e4f"}, "originalPosition": 37}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQxNjQ4OQ==", "bodyText": "You probably want to wrap this in an UnmodifiableList to prevent someone from doing something wacky with the output that breaks assumptions about the duplicate set.", "url": "https://github.com/broadinstitute/gatk/pull/6512#discussion_r408416489", "createdAt": "2020-04-14T20:31:26Z", "author": {"login": "lbergelson"}, "path": "src/main/java/org/broadinstitute/hellbender/tools/walkers/mutect/consensus/DuplicateSet.java", "diffHunk": "@@ -0,0 +1,122 @@\n+package org.broadinstitute.hellbender.tools.walkers.mutect.consensus;\n+\n+import org.broadinstitute.hellbender.tools.walkers.mutect.UMI;\n+import org.broadinstitute.hellbender.utils.SimpleInterval;\n+import org.broadinstitute.hellbender.utils.Utils;\n+import org.broadinstitute.hellbender.utils.read.GATKRead;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+public class DuplicateSet {\n+    public static final String FGBIO_MOLECULAR_IDENTIFIER_TAG = \"MI\";\n+    public static final String FGBIO_MI_TAG_DELIMITER = \"/\";\n+    private int moleculeId = -1; // TODO: extract an ID class.\n+    private UMI umi;\n+    private String contig;\n+    private int fragmentStart = -1;\n+    private int fragmentEnd = -1;\n+    private List<GATKRead> reads;\n+    boolean smallInsert; // if true, the reads read into adaptors\n+    private boolean paired;  // TODO: is this useful/how can I detect this?\n+    // IN FACT, start here, also write tests --- count the number of MI=1's, MI=2's, etc...\n+    public DuplicateSet(){\n+        reads = new ArrayList<>();\n+    }\n+\n+    public DuplicateSet(final GATKRead read){\n+        reads = new ArrayList<>();\n+        init(read);\n+        reads.add(read);\n+    }\n+\n+    public void init(GATKRead read){\n+        Utils.validate(moleculeId == -1 || moleculeId == getMoleculeID(read),\n+                String.format(\"Inconsisntent molecule IDs: Duplicate set id = %s, read molecule id = %s\", moleculeId, getMoleculeID(read)));\n+        setMoleduleId(read);umi = new UMI(read);\n+        contig = read.getContig();\n+        fragmentStart = read.getStart();\n+        fragmentEnd = read.getEnd(); // TODO: does this include softclips?\n+        paired = false;\n+    }\n+\n+    public List<GATKRead> getReads(){", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c14aa1527401cb1b4eaa1d545d1f966754403e4f"}, "originalPosition": 44}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQxNzE3MA==", "bodyText": "javadoc", "url": "https://github.com/broadinstitute/gatk/pull/6512#discussion_r408417170", "createdAt": "2020-04-14T20:32:37Z", "author": {"login": "lbergelson"}, "path": "src/main/java/org/broadinstitute/hellbender/tools/walkers/mutect/consensus/DuplicateSet.java", "diffHunk": "@@ -0,0 +1,122 @@\n+package org.broadinstitute.hellbender.tools.walkers.mutect.consensus;\n+\n+import org.broadinstitute.hellbender.tools.walkers.mutect.UMI;\n+import org.broadinstitute.hellbender.utils.SimpleInterval;\n+import org.broadinstitute.hellbender.utils.Utils;\n+import org.broadinstitute.hellbender.utils.read.GATKRead;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+public class DuplicateSet {\n+    public static final String FGBIO_MOLECULAR_IDENTIFIER_TAG = \"MI\";\n+    public static final String FGBIO_MI_TAG_DELIMITER = \"/\";\n+    private int moleculeId = -1; // TODO: extract an ID class.\n+    private UMI umi;\n+    private String contig;\n+    private int fragmentStart = -1;\n+    private int fragmentEnd = -1;\n+    private List<GATKRead> reads;\n+    boolean smallInsert; // if true, the reads read into adaptors\n+    private boolean paired;  // TODO: is this useful/how can I detect this?\n+    // IN FACT, start here, also write tests --- count the number of MI=1's, MI=2's, etc...\n+    public DuplicateSet(){\n+        reads = new ArrayList<>();\n+    }\n+\n+    public DuplicateSet(final GATKRead read){\n+        reads = new ArrayList<>();\n+        init(read);\n+        reads.add(read);\n+    }\n+\n+    public void init(GATKRead read){\n+        Utils.validate(moleculeId == -1 || moleculeId == getMoleculeID(read),\n+                String.format(\"Inconsisntent molecule IDs: Duplicate set id = %s, read molecule id = %s\", moleculeId, getMoleculeID(read)));\n+        setMoleduleId(read);umi = new UMI(read);\n+        contig = read.getContig();\n+        fragmentStart = read.getStart();\n+        fragmentEnd = read.getEnd(); // TODO: does this include softclips?\n+        paired = false;\n+    }\n+\n+    public List<GATKRead> getReads(){\n+        return reads;\n+    }\n+\n+    public boolean sameMolecule(final GATKRead read){", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c14aa1527401cb1b4eaa1d545d1f966754403e4f"}, "originalPosition": 48}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQxNzM0MA==", "bodyText": "typo moledule", "url": "https://github.com/broadinstitute/gatk/pull/6512#discussion_r408417340", "createdAt": "2020-04-14T20:32:58Z", "author": {"login": "lbergelson"}, "path": "src/main/java/org/broadinstitute/hellbender/tools/walkers/mutect/consensus/DuplicateSet.java", "diffHunk": "@@ -0,0 +1,122 @@\n+package org.broadinstitute.hellbender.tools.walkers.mutect.consensus;\n+\n+import org.broadinstitute.hellbender.tools.walkers.mutect.UMI;\n+import org.broadinstitute.hellbender.utils.SimpleInterval;\n+import org.broadinstitute.hellbender.utils.Utils;\n+import org.broadinstitute.hellbender.utils.read.GATKRead;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+public class DuplicateSet {\n+    public static final String FGBIO_MOLECULAR_IDENTIFIER_TAG = \"MI\";\n+    public static final String FGBIO_MI_TAG_DELIMITER = \"/\";\n+    private int moleculeId = -1; // TODO: extract an ID class.\n+    private UMI umi;\n+    private String contig;\n+    private int fragmentStart = -1;\n+    private int fragmentEnd = -1;\n+    private List<GATKRead> reads;\n+    boolean smallInsert; // if true, the reads read into adaptors\n+    private boolean paired;  // TODO: is this useful/how can I detect this?\n+    // IN FACT, start here, also write tests --- count the number of MI=1's, MI=2's, etc...\n+    public DuplicateSet(){\n+        reads = new ArrayList<>();\n+    }\n+\n+    public DuplicateSet(final GATKRead read){\n+        reads = new ArrayList<>();\n+        init(read);\n+        reads.add(read);\n+    }\n+\n+    public void init(GATKRead read){\n+        Utils.validate(moleculeId == -1 || moleculeId == getMoleculeID(read),\n+                String.format(\"Inconsisntent molecule IDs: Duplicate set id = %s, read molecule id = %s\", moleculeId, getMoleculeID(read)));\n+        setMoleduleId(read);umi = new UMI(read);\n+        contig = read.getContig();\n+        fragmentStart = read.getStart();\n+        fragmentEnd = read.getEnd(); // TODO: does this include softclips?\n+        paired = false;\n+    }\n+\n+    public List<GATKRead> getReads(){\n+        return reads;\n+    }\n+\n+    public boolean sameMolecule(final GATKRead read){\n+        return getMoleculeID(read) == moleculeId;\n+    }\n+\n+    public void setMoleduleId(GATKRead read){", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c14aa1527401cb1b4eaa1d545d1f966754403e4f"}, "originalPosition": 52}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQxNzM5Mw==", "bodyText": "typo moledule", "url": "https://github.com/broadinstitute/gatk/pull/6512#discussion_r408417393", "createdAt": "2020-04-14T20:33:06Z", "author": {"login": "lbergelson"}, "path": "src/main/java/org/broadinstitute/hellbender/tools/walkers/mutect/consensus/DuplicateSet.java", "diffHunk": "@@ -0,0 +1,122 @@\n+package org.broadinstitute.hellbender.tools.walkers.mutect.consensus;\n+\n+import org.broadinstitute.hellbender.tools.walkers.mutect.UMI;\n+import org.broadinstitute.hellbender.utils.SimpleInterval;\n+import org.broadinstitute.hellbender.utils.Utils;\n+import org.broadinstitute.hellbender.utils.read.GATKRead;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+public class DuplicateSet {\n+    public static final String FGBIO_MOLECULAR_IDENTIFIER_TAG = \"MI\";\n+    public static final String FGBIO_MI_TAG_DELIMITER = \"/\";\n+    private int moleculeId = -1; // TODO: extract an ID class.\n+    private UMI umi;\n+    private String contig;\n+    private int fragmentStart = -1;\n+    private int fragmentEnd = -1;\n+    private List<GATKRead> reads;\n+    boolean smallInsert; // if true, the reads read into adaptors\n+    private boolean paired;  // TODO: is this useful/how can I detect this?\n+    // IN FACT, start here, also write tests --- count the number of MI=1's, MI=2's, etc...\n+    public DuplicateSet(){\n+        reads = new ArrayList<>();\n+    }\n+\n+    public DuplicateSet(final GATKRead read){\n+        reads = new ArrayList<>();\n+        init(read);\n+        reads.add(read);\n+    }\n+\n+    public void init(GATKRead read){\n+        Utils.validate(moleculeId == -1 || moleculeId == getMoleculeID(read),\n+                String.format(\"Inconsisntent molecule IDs: Duplicate set id = %s, read molecule id = %s\", moleculeId, getMoleculeID(read)));\n+        setMoleduleId(read);umi = new UMI(read);\n+        contig = read.getContig();\n+        fragmentStart = read.getStart();\n+        fragmentEnd = read.getEnd(); // TODO: does this include softclips?\n+        paired = false;\n+    }\n+\n+    public List<GATKRead> getReads(){\n+        return reads;\n+    }\n+\n+    public boolean sameMolecule(final GATKRead read){\n+        return getMoleculeID(read) == moleculeId;\n+    }\n+\n+    public void setMoleduleId(GATKRead read){\n+        moleculeId = getMoleculeID(read);\n+    }\n+\n+    public void setMoleduleId(int id){", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c14aa1527401cb1b4eaa1d545d1f966754403e4f"}, "originalPosition": 56}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQxODE0NA==", "bodyText": "I think this method should probably be removed.  Is there a use case for changing the molecule ID after it's already set?  Seems dangerous.", "url": "https://github.com/broadinstitute/gatk/pull/6512#discussion_r408418144", "createdAt": "2020-04-14T20:34:22Z", "author": {"login": "lbergelson"}, "path": "src/main/java/org/broadinstitute/hellbender/tools/walkers/mutect/consensus/DuplicateSet.java", "diffHunk": "@@ -0,0 +1,122 @@\n+package org.broadinstitute.hellbender.tools.walkers.mutect.consensus;\n+\n+import org.broadinstitute.hellbender.tools.walkers.mutect.UMI;\n+import org.broadinstitute.hellbender.utils.SimpleInterval;\n+import org.broadinstitute.hellbender.utils.Utils;\n+import org.broadinstitute.hellbender.utils.read.GATKRead;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+public class DuplicateSet {\n+    public static final String FGBIO_MOLECULAR_IDENTIFIER_TAG = \"MI\";\n+    public static final String FGBIO_MI_TAG_DELIMITER = \"/\";\n+    private int moleculeId = -1; // TODO: extract an ID class.\n+    private UMI umi;\n+    private String contig;\n+    private int fragmentStart = -1;\n+    private int fragmentEnd = -1;\n+    private List<GATKRead> reads;\n+    boolean smallInsert; // if true, the reads read into adaptors\n+    private boolean paired;  // TODO: is this useful/how can I detect this?\n+    // IN FACT, start here, also write tests --- count the number of MI=1's, MI=2's, etc...\n+    public DuplicateSet(){\n+        reads = new ArrayList<>();\n+    }\n+\n+    public DuplicateSet(final GATKRead read){\n+        reads = new ArrayList<>();\n+        init(read);\n+        reads.add(read);\n+    }\n+\n+    public void init(GATKRead read){\n+        Utils.validate(moleculeId == -1 || moleculeId == getMoleculeID(read),\n+                String.format(\"Inconsisntent molecule IDs: Duplicate set id = %s, read molecule id = %s\", moleculeId, getMoleculeID(read)));\n+        setMoleduleId(read);umi = new UMI(read);\n+        contig = read.getContig();\n+        fragmentStart = read.getStart();\n+        fragmentEnd = read.getEnd(); // TODO: does this include softclips?\n+        paired = false;\n+    }\n+\n+    public List<GATKRead> getReads(){\n+        return reads;\n+    }\n+\n+    public boolean sameMolecule(final GATKRead read){\n+        return getMoleculeID(read) == moleculeId;\n+    }\n+\n+    public void setMoleduleId(GATKRead read){", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQxNzM0MA=="}, "originalCommit": {"oid": "c14aa1527401cb1b4eaa1d545d1f966754403e4f"}, "originalPosition": 52}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQxODI0Nw==", "bodyText": "Similarly, this should probably be removed.", "url": "https://github.com/broadinstitute/gatk/pull/6512#discussion_r408418247", "createdAt": "2020-04-14T20:34:33Z", "author": {"login": "lbergelson"}, "path": "src/main/java/org/broadinstitute/hellbender/tools/walkers/mutect/consensus/DuplicateSet.java", "diffHunk": "@@ -0,0 +1,122 @@\n+package org.broadinstitute.hellbender.tools.walkers.mutect.consensus;\n+\n+import org.broadinstitute.hellbender.tools.walkers.mutect.UMI;\n+import org.broadinstitute.hellbender.utils.SimpleInterval;\n+import org.broadinstitute.hellbender.utils.Utils;\n+import org.broadinstitute.hellbender.utils.read.GATKRead;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+public class DuplicateSet {\n+    public static final String FGBIO_MOLECULAR_IDENTIFIER_TAG = \"MI\";\n+    public static final String FGBIO_MI_TAG_DELIMITER = \"/\";\n+    private int moleculeId = -1; // TODO: extract an ID class.\n+    private UMI umi;\n+    private String contig;\n+    private int fragmentStart = -1;\n+    private int fragmentEnd = -1;\n+    private List<GATKRead> reads;\n+    boolean smallInsert; // if true, the reads read into adaptors\n+    private boolean paired;  // TODO: is this useful/how can I detect this?\n+    // IN FACT, start here, also write tests --- count the number of MI=1's, MI=2's, etc...\n+    public DuplicateSet(){\n+        reads = new ArrayList<>();\n+    }\n+\n+    public DuplicateSet(final GATKRead read){\n+        reads = new ArrayList<>();\n+        init(read);\n+        reads.add(read);\n+    }\n+\n+    public void init(GATKRead read){\n+        Utils.validate(moleculeId == -1 || moleculeId == getMoleculeID(read),\n+                String.format(\"Inconsisntent molecule IDs: Duplicate set id = %s, read molecule id = %s\", moleculeId, getMoleculeID(read)));\n+        setMoleduleId(read);umi = new UMI(read);\n+        contig = read.getContig();\n+        fragmentStart = read.getStart();\n+        fragmentEnd = read.getEnd(); // TODO: does this include softclips?\n+        paired = false;\n+    }\n+\n+    public List<GATKRead> getReads(){\n+        return reads;\n+    }\n+\n+    public boolean sameMolecule(final GATKRead read){\n+        return getMoleculeID(read) == moleculeId;\n+    }\n+\n+    public void setMoleduleId(GATKRead read){\n+        moleculeId = getMoleculeID(read);\n+    }\n+\n+    public void setMoleduleId(int id){", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQxNzM5Mw=="}, "originalCommit": {"oid": "c14aa1527401cb1b4eaa1d545d1f966754403e4f"}, "originalPosition": 56}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQxOTAyOA==", "bodyText": "Is there ever a reason for allowing improper reads in the set?  It seems like this would better if it threw when an incorrect read was added.  That way you never have to check that the set is valid, it just is...", "url": "https://github.com/broadinstitute/gatk/pull/6512#discussion_r408419028", "createdAt": "2020-04-14T20:35:59Z", "author": {"login": "lbergelson"}, "path": "src/main/java/org/broadinstitute/hellbender/tools/walkers/mutect/consensus/DuplicateSet.java", "diffHunk": "@@ -0,0 +1,122 @@\n+package org.broadinstitute.hellbender.tools.walkers.mutect.consensus;\n+\n+import org.broadinstitute.hellbender.tools.walkers.mutect.UMI;\n+import org.broadinstitute.hellbender.utils.SimpleInterval;\n+import org.broadinstitute.hellbender.utils.Utils;\n+import org.broadinstitute.hellbender.utils.read.GATKRead;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+public class DuplicateSet {\n+    public static final String FGBIO_MOLECULAR_IDENTIFIER_TAG = \"MI\";\n+    public static final String FGBIO_MI_TAG_DELIMITER = \"/\";\n+    private int moleculeId = -1; // TODO: extract an ID class.\n+    private UMI umi;\n+    private String contig;\n+    private int fragmentStart = -1;\n+    private int fragmentEnd = -1;\n+    private List<GATKRead> reads;\n+    boolean smallInsert; // if true, the reads read into adaptors\n+    private boolean paired;  // TODO: is this useful/how can I detect this?\n+    // IN FACT, start here, also write tests --- count the number of MI=1's, MI=2's, etc...\n+    public DuplicateSet(){\n+        reads = new ArrayList<>();\n+    }\n+\n+    public DuplicateSet(final GATKRead read){\n+        reads = new ArrayList<>();\n+        init(read);\n+        reads.add(read);\n+    }\n+\n+    public void init(GATKRead read){\n+        Utils.validate(moleculeId == -1 || moleculeId == getMoleculeID(read),\n+                String.format(\"Inconsisntent molecule IDs: Duplicate set id = %s, read molecule id = %s\", moleculeId, getMoleculeID(read)));\n+        setMoleduleId(read);umi = new UMI(read);\n+        contig = read.getContig();\n+        fragmentStart = read.getStart();\n+        fragmentEnd = read.getEnd(); // TODO: does this include softclips?\n+        paired = false;\n+    }\n+\n+    public List<GATKRead> getReads(){\n+        return reads;\n+    }\n+\n+    public boolean sameMolecule(final GATKRead read){\n+        return getMoleculeID(read) == moleculeId;\n+    }\n+\n+    public void setMoleduleId(GATKRead read){\n+        moleculeId = getMoleculeID(read);\n+    }\n+\n+    public void setMoleduleId(int id){\n+        moleculeId = id;\n+    }\n+\n+    /**\n+     * Some examples of molecule IDs (MI tag):\n+     *\n+     * \"0/A\" (The first molecule in the bam, top (A) strand)\n+     * \"0/B\" (The first molecule in the bam, bottom (B) strand)\n+     * \"99/A\" (100th molecule in the bam, top top (A) strand)\n+     *\n+     * Top strand is synonymous to \"F1R2\"\n+     * Bottom strand is synonymous to \"F2R1\"\n+     *\n+     * Thus only the integer component is relevant for identifying reads that originated from the same molecule.\n+     * Should the need arise, we could extend this to distinguish between different strands of the same molecule.\n+     */\n+    public static int getMoleculeID(final GATKRead read) {\n+        final String MITag = read.getAttributeAsString(FGBIO_MOLECULAR_IDENTIFIER_TAG);\n+        return Integer.parseInt(MITag.split(FGBIO_MI_TAG_DELIMITER)[0]);\n+    }\n+\n+    /** Returns true if the read was properly added to the duplicate set **/\n+    public boolean addRead(final GATKRead read){", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c14aa1527401cb1b4eaa1d545d1f966754403e4f"}, "originalPosition": 79}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQyMDEyMg==", "bodyText": "I'm again confused about the use of invalid duplicate sets with different molecules.  Seems like bad news.", "url": "https://github.com/broadinstitute/gatk/pull/6512#discussion_r408420122", "createdAt": "2020-04-14T20:38:07Z", "author": {"login": "lbergelson"}, "path": "src/main/java/org/broadinstitute/hellbender/tools/walkers/mutect/consensus/DuplicateSet.java", "diffHunk": "@@ -0,0 +1,122 @@\n+package org.broadinstitute.hellbender.tools.walkers.mutect.consensus;\n+\n+import org.broadinstitute.hellbender.tools.walkers.mutect.UMI;\n+import org.broadinstitute.hellbender.utils.SimpleInterval;\n+import org.broadinstitute.hellbender.utils.Utils;\n+import org.broadinstitute.hellbender.utils.read.GATKRead;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+public class DuplicateSet {\n+    public static final String FGBIO_MOLECULAR_IDENTIFIER_TAG = \"MI\";\n+    public static final String FGBIO_MI_TAG_DELIMITER = \"/\";\n+    private int moleculeId = -1; // TODO: extract an ID class.\n+    private UMI umi;\n+    private String contig;\n+    private int fragmentStart = -1;\n+    private int fragmentEnd = -1;\n+    private List<GATKRead> reads;\n+    boolean smallInsert; // if true, the reads read into adaptors\n+    private boolean paired;  // TODO: is this useful/how can I detect this?\n+    // IN FACT, start here, also write tests --- count the number of MI=1's, MI=2's, etc...\n+    public DuplicateSet(){\n+        reads = new ArrayList<>();\n+    }\n+\n+    public DuplicateSet(final GATKRead read){\n+        reads = new ArrayList<>();\n+        init(read);\n+        reads.add(read);\n+    }\n+\n+    public void init(GATKRead read){\n+        Utils.validate(moleculeId == -1 || moleculeId == getMoleculeID(read),\n+                String.format(\"Inconsisntent molecule IDs: Duplicate set id = %s, read molecule id = %s\", moleculeId, getMoleculeID(read)));\n+        setMoleduleId(read);umi = new UMI(read);\n+        contig = read.getContig();\n+        fragmentStart = read.getStart();\n+        fragmentEnd = read.getEnd(); // TODO: does this include softclips?\n+        paired = false;\n+    }\n+\n+    public List<GATKRead> getReads(){\n+        return reads;\n+    }\n+\n+    public boolean sameMolecule(final GATKRead read){\n+        return getMoleculeID(read) == moleculeId;\n+    }\n+\n+    public void setMoleduleId(GATKRead read){\n+        moleculeId = getMoleculeID(read);\n+    }\n+\n+    public void setMoleduleId(int id){\n+        moleculeId = id;\n+    }\n+\n+    /**\n+     * Some examples of molecule IDs (MI tag):\n+     *\n+     * \"0/A\" (The first molecule in the bam, top (A) strand)\n+     * \"0/B\" (The first molecule in the bam, bottom (B) strand)\n+     * \"99/A\" (100th molecule in the bam, top top (A) strand)\n+     *\n+     * Top strand is synonymous to \"F1R2\"\n+     * Bottom strand is synonymous to \"F2R1\"\n+     *\n+     * Thus only the integer component is relevant for identifying reads that originated from the same molecule.\n+     * Should the need arise, we could extend this to distinguish between different strands of the same molecule.\n+     */\n+    public static int getMoleculeID(final GATKRead read) {\n+        final String MITag = read.getAttributeAsString(FGBIO_MOLECULAR_IDENTIFIER_TAG);\n+        return Integer.parseInt(MITag.split(FGBIO_MI_TAG_DELIMITER)[0]);\n+    }\n+\n+    /** Returns true if the read was properly added to the duplicate set **/\n+    public boolean addRead(final GATKRead read){\n+        if (reads.isEmpty()){\n+            init(read);\n+            reads.add(read);\n+            return true;\n+        }\n+\n+        if (sameMolecule(read)){", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c14aa1527401cb1b4eaa1d545d1f966754403e4f"}, "originalPosition": 86}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQyMTc3NQ==", "bodyText": "If you are keeping an internal simple interval instead of separate values you could use interval.spanWith(read) instead of this logic.", "url": "https://github.com/broadinstitute/gatk/pull/6512#discussion_r408421775", "createdAt": "2020-04-14T20:41:02Z", "author": {"login": "lbergelson"}, "path": "src/main/java/org/broadinstitute/hellbender/tools/walkers/mutect/consensus/DuplicateSet.java", "diffHunk": "@@ -0,0 +1,122 @@\n+package org.broadinstitute.hellbender.tools.walkers.mutect.consensus;\n+\n+import org.broadinstitute.hellbender.tools.walkers.mutect.UMI;\n+import org.broadinstitute.hellbender.utils.SimpleInterval;\n+import org.broadinstitute.hellbender.utils.Utils;\n+import org.broadinstitute.hellbender.utils.read.GATKRead;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+public class DuplicateSet {\n+    public static final String FGBIO_MOLECULAR_IDENTIFIER_TAG = \"MI\";\n+    public static final String FGBIO_MI_TAG_DELIMITER = \"/\";\n+    private int moleculeId = -1; // TODO: extract an ID class.\n+    private UMI umi;\n+    private String contig;\n+    private int fragmentStart = -1;\n+    private int fragmentEnd = -1;\n+    private List<GATKRead> reads;\n+    boolean smallInsert; // if true, the reads read into adaptors\n+    private boolean paired;  // TODO: is this useful/how can I detect this?\n+    // IN FACT, start here, also write tests --- count the number of MI=1's, MI=2's, etc...\n+    public DuplicateSet(){\n+        reads = new ArrayList<>();\n+    }\n+\n+    public DuplicateSet(final GATKRead read){\n+        reads = new ArrayList<>();\n+        init(read);\n+        reads.add(read);\n+    }\n+\n+    public void init(GATKRead read){\n+        Utils.validate(moleculeId == -1 || moleculeId == getMoleculeID(read),\n+                String.format(\"Inconsisntent molecule IDs: Duplicate set id = %s, read molecule id = %s\", moleculeId, getMoleculeID(read)));\n+        setMoleduleId(read);umi = new UMI(read);\n+        contig = read.getContig();\n+        fragmentStart = read.getStart();\n+        fragmentEnd = read.getEnd(); // TODO: does this include softclips?\n+        paired = false;\n+    }\n+\n+    public List<GATKRead> getReads(){\n+        return reads;\n+    }\n+\n+    public boolean sameMolecule(final GATKRead read){\n+        return getMoleculeID(read) == moleculeId;\n+    }\n+\n+    public void setMoleduleId(GATKRead read){\n+        moleculeId = getMoleculeID(read);\n+    }\n+\n+    public void setMoleduleId(int id){\n+        moleculeId = id;\n+    }\n+\n+    /**\n+     * Some examples of molecule IDs (MI tag):\n+     *\n+     * \"0/A\" (The first molecule in the bam, top (A) strand)\n+     * \"0/B\" (The first molecule in the bam, bottom (B) strand)\n+     * \"99/A\" (100th molecule in the bam, top top (A) strand)\n+     *\n+     * Top strand is synonymous to \"F1R2\"\n+     * Bottom strand is synonymous to \"F2R1\"\n+     *\n+     * Thus only the integer component is relevant for identifying reads that originated from the same molecule.\n+     * Should the need arise, we could extend this to distinguish between different strands of the same molecule.\n+     */\n+    public static int getMoleculeID(final GATKRead read) {\n+        final String MITag = read.getAttributeAsString(FGBIO_MOLECULAR_IDENTIFIER_TAG);\n+        return Integer.parseInt(MITag.split(FGBIO_MI_TAG_DELIMITER)[0]);\n+    }\n+\n+    /** Returns true if the read was properly added to the duplicate set **/\n+    public boolean addRead(final GATKRead read){\n+        if (reads.isEmpty()){\n+            init(read);\n+            reads.add(read);\n+            return true;\n+        }\n+\n+        if (sameMolecule(read)){\n+            reads.add(read);\n+            if (read.getStart() < fragmentStart){", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c14aa1527401cb1b4eaa1d545d1f966754403e4f"}, "originalPosition": 88}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQyMjA5Mw==", "bodyText": "It seems like there will be problems if you have reads from different contigs.  I assume that's possible since they are aligned separately?", "url": "https://github.com/broadinstitute/gatk/pull/6512#discussion_r408422093", "createdAt": "2020-04-14T20:41:38Z", "author": {"login": "lbergelson"}, "path": "src/main/java/org/broadinstitute/hellbender/tools/walkers/mutect/consensus/DuplicateSet.java", "diffHunk": "@@ -0,0 +1,122 @@\n+package org.broadinstitute.hellbender.tools.walkers.mutect.consensus;\n+\n+import org.broadinstitute.hellbender.tools.walkers.mutect.UMI;\n+import org.broadinstitute.hellbender.utils.SimpleInterval;\n+import org.broadinstitute.hellbender.utils.Utils;\n+import org.broadinstitute.hellbender.utils.read.GATKRead;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+public class DuplicateSet {\n+    public static final String FGBIO_MOLECULAR_IDENTIFIER_TAG = \"MI\";\n+    public static final String FGBIO_MI_TAG_DELIMITER = \"/\";\n+    private int moleculeId = -1; // TODO: extract an ID class.\n+    private UMI umi;\n+    private String contig;\n+    private int fragmentStart = -1;\n+    private int fragmentEnd = -1;\n+    private List<GATKRead> reads;\n+    boolean smallInsert; // if true, the reads read into adaptors\n+    private boolean paired;  // TODO: is this useful/how can I detect this?\n+    // IN FACT, start here, also write tests --- count the number of MI=1's, MI=2's, etc...\n+    public DuplicateSet(){\n+        reads = new ArrayList<>();\n+    }\n+\n+    public DuplicateSet(final GATKRead read){\n+        reads = new ArrayList<>();\n+        init(read);\n+        reads.add(read);\n+    }\n+\n+    public void init(GATKRead read){\n+        Utils.validate(moleculeId == -1 || moleculeId == getMoleculeID(read),\n+                String.format(\"Inconsisntent molecule IDs: Duplicate set id = %s, read molecule id = %s\", moleculeId, getMoleculeID(read)));\n+        setMoleduleId(read);umi = new UMI(read);\n+        contig = read.getContig();\n+        fragmentStart = read.getStart();\n+        fragmentEnd = read.getEnd(); // TODO: does this include softclips?\n+        paired = false;\n+    }\n+\n+    public List<GATKRead> getReads(){\n+        return reads;\n+    }\n+\n+    public boolean sameMolecule(final GATKRead read){\n+        return getMoleculeID(read) == moleculeId;\n+    }\n+\n+    public void setMoleduleId(GATKRead read){\n+        moleculeId = getMoleculeID(read);\n+    }\n+\n+    public void setMoleduleId(int id){\n+        moleculeId = id;\n+    }\n+\n+    /**\n+     * Some examples of molecule IDs (MI tag):\n+     *\n+     * \"0/A\" (The first molecule in the bam, top (A) strand)\n+     * \"0/B\" (The first molecule in the bam, bottom (B) strand)\n+     * \"99/A\" (100th molecule in the bam, top top (A) strand)\n+     *\n+     * Top strand is synonymous to \"F1R2\"\n+     * Bottom strand is synonymous to \"F2R1\"\n+     *\n+     * Thus only the integer component is relevant for identifying reads that originated from the same molecule.\n+     * Should the need arise, we could extend this to distinguish between different strands of the same molecule.\n+     */\n+    public static int getMoleculeID(final GATKRead read) {\n+        final String MITag = read.getAttributeAsString(FGBIO_MOLECULAR_IDENTIFIER_TAG);\n+        return Integer.parseInt(MITag.split(FGBIO_MI_TAG_DELIMITER)[0]);\n+    }\n+\n+    /** Returns true if the read was properly added to the duplicate set **/\n+    public boolean addRead(final GATKRead read){\n+        if (reads.isEmpty()){\n+            init(read);\n+            reads.add(read);\n+            return true;\n+        }\n+\n+        if (sameMolecule(read)){\n+            reads.add(read);\n+            if (read.getStart() < fragmentStart){", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQyMTc3NQ=="}, "originalCommit": {"oid": "c14aa1527401cb1b4eaa1d545d1f966754403e4f"}, "originalPosition": 88}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQyMjM5Ng==", "bodyText": "javadoc", "url": "https://github.com/broadinstitute/gatk/pull/6512#discussion_r408422396", "createdAt": "2020-04-14T20:42:12Z", "author": {"login": "lbergelson"}, "path": "src/main/java/org/broadinstitute/hellbender/tools/walkers/mutect/consensus/DuplicateSet.java", "diffHunk": "@@ -0,0 +1,122 @@\n+package org.broadinstitute.hellbender.tools.walkers.mutect.consensus;\n+\n+import org.broadinstitute.hellbender.tools.walkers.mutect.UMI;\n+import org.broadinstitute.hellbender.utils.SimpleInterval;\n+import org.broadinstitute.hellbender.utils.Utils;\n+import org.broadinstitute.hellbender.utils.read.GATKRead;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+public class DuplicateSet {\n+    public static final String FGBIO_MOLECULAR_IDENTIFIER_TAG = \"MI\";\n+    public static final String FGBIO_MI_TAG_DELIMITER = \"/\";\n+    private int moleculeId = -1; // TODO: extract an ID class.\n+    private UMI umi;\n+    private String contig;\n+    private int fragmentStart = -1;\n+    private int fragmentEnd = -1;\n+    private List<GATKRead> reads;\n+    boolean smallInsert; // if true, the reads read into adaptors\n+    private boolean paired;  // TODO: is this useful/how can I detect this?\n+    // IN FACT, start here, also write tests --- count the number of MI=1's, MI=2's, etc...\n+    public DuplicateSet(){\n+        reads = new ArrayList<>();\n+    }\n+\n+    public DuplicateSet(final GATKRead read){\n+        reads = new ArrayList<>();\n+        init(read);\n+        reads.add(read);\n+    }\n+\n+    public void init(GATKRead read){\n+        Utils.validate(moleculeId == -1 || moleculeId == getMoleculeID(read),\n+                String.format(\"Inconsisntent molecule IDs: Duplicate set id = %s, read molecule id = %s\", moleculeId, getMoleculeID(read)));\n+        setMoleduleId(read);umi = new UMI(read);\n+        contig = read.getContig();\n+        fragmentStart = read.getStart();\n+        fragmentEnd = read.getEnd(); // TODO: does this include softclips?\n+        paired = false;\n+    }\n+\n+    public List<GATKRead> getReads(){\n+        return reads;\n+    }\n+\n+    public boolean sameMolecule(final GATKRead read){\n+        return getMoleculeID(read) == moleculeId;\n+    }\n+\n+    public void setMoleduleId(GATKRead read){\n+        moleculeId = getMoleculeID(read);\n+    }\n+\n+    public void setMoleduleId(int id){\n+        moleculeId = id;\n+    }\n+\n+    /**\n+     * Some examples of molecule IDs (MI tag):\n+     *\n+     * \"0/A\" (The first molecule in the bam, top (A) strand)\n+     * \"0/B\" (The first molecule in the bam, bottom (B) strand)\n+     * \"99/A\" (100th molecule in the bam, top top (A) strand)\n+     *\n+     * Top strand is synonymous to \"F1R2\"\n+     * Bottom strand is synonymous to \"F2R1\"\n+     *\n+     * Thus only the integer component is relevant for identifying reads that originated from the same molecule.\n+     * Should the need arise, we could extend this to distinguish between different strands of the same molecule.\n+     */\n+    public static int getMoleculeID(final GATKRead read) {\n+        final String MITag = read.getAttributeAsString(FGBIO_MOLECULAR_IDENTIFIER_TAG);\n+        return Integer.parseInt(MITag.split(FGBIO_MI_TAG_DELIMITER)[0]);\n+    }\n+\n+    /** Returns true if the read was properly added to the duplicate set **/\n+    public boolean addRead(final GATKRead read){\n+        if (reads.isEmpty()){\n+            init(read);\n+            reads.add(read);\n+            return true;\n+        }\n+\n+        if (sameMolecule(read)){\n+            reads.add(read);\n+            if (read.getStart() < fragmentStart){\n+                fragmentStart = read.getStart();\n+            }\n+            if (read.getEnd() > fragmentEnd){\n+                fragmentEnd = read.getEnd();\n+            }\n+            return true;\n+        } else {\n+            return false;\n+        }\n+    }\n+\n+    public int getFragmentStart(){", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c14aa1527401cb1b4eaa1d545d1f966754403e4f"}, "originalPosition": 100}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQyMjQ1MA==", "bodyText": "doc", "url": "https://github.com/broadinstitute/gatk/pull/6512#discussion_r408422450", "createdAt": "2020-04-14T20:42:16Z", "author": {"login": "lbergelson"}, "path": "src/main/java/org/broadinstitute/hellbender/tools/walkers/mutect/consensus/DuplicateSet.java", "diffHunk": "@@ -0,0 +1,122 @@\n+package org.broadinstitute.hellbender.tools.walkers.mutect.consensus;\n+\n+import org.broadinstitute.hellbender.tools.walkers.mutect.UMI;\n+import org.broadinstitute.hellbender.utils.SimpleInterval;\n+import org.broadinstitute.hellbender.utils.Utils;\n+import org.broadinstitute.hellbender.utils.read.GATKRead;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+public class DuplicateSet {\n+    public static final String FGBIO_MOLECULAR_IDENTIFIER_TAG = \"MI\";\n+    public static final String FGBIO_MI_TAG_DELIMITER = \"/\";\n+    private int moleculeId = -1; // TODO: extract an ID class.\n+    private UMI umi;\n+    private String contig;\n+    private int fragmentStart = -1;\n+    private int fragmentEnd = -1;\n+    private List<GATKRead> reads;\n+    boolean smallInsert; // if true, the reads read into adaptors\n+    private boolean paired;  // TODO: is this useful/how can I detect this?\n+    // IN FACT, start here, also write tests --- count the number of MI=1's, MI=2's, etc...\n+    public DuplicateSet(){\n+        reads = new ArrayList<>();\n+    }\n+\n+    public DuplicateSet(final GATKRead read){\n+        reads = new ArrayList<>();\n+        init(read);\n+        reads.add(read);\n+    }\n+\n+    public void init(GATKRead read){\n+        Utils.validate(moleculeId == -1 || moleculeId == getMoleculeID(read),\n+                String.format(\"Inconsisntent molecule IDs: Duplicate set id = %s, read molecule id = %s\", moleculeId, getMoleculeID(read)));\n+        setMoleduleId(read);umi = new UMI(read);\n+        contig = read.getContig();\n+        fragmentStart = read.getStart();\n+        fragmentEnd = read.getEnd(); // TODO: does this include softclips?\n+        paired = false;\n+    }\n+\n+    public List<GATKRead> getReads(){\n+        return reads;\n+    }\n+\n+    public boolean sameMolecule(final GATKRead read){\n+        return getMoleculeID(read) == moleculeId;\n+    }\n+\n+    public void setMoleduleId(GATKRead read){\n+        moleculeId = getMoleculeID(read);\n+    }\n+\n+    public void setMoleduleId(int id){\n+        moleculeId = id;\n+    }\n+\n+    /**\n+     * Some examples of molecule IDs (MI tag):\n+     *\n+     * \"0/A\" (The first molecule in the bam, top (A) strand)\n+     * \"0/B\" (The first molecule in the bam, bottom (B) strand)\n+     * \"99/A\" (100th molecule in the bam, top top (A) strand)\n+     *\n+     * Top strand is synonymous to \"F1R2\"\n+     * Bottom strand is synonymous to \"F2R1\"\n+     *\n+     * Thus only the integer component is relevant for identifying reads that originated from the same molecule.\n+     * Should the need arise, we could extend this to distinguish between different strands of the same molecule.\n+     */\n+    public static int getMoleculeID(final GATKRead read) {\n+        final String MITag = read.getAttributeAsString(FGBIO_MOLECULAR_IDENTIFIER_TAG);\n+        return Integer.parseInt(MITag.split(FGBIO_MI_TAG_DELIMITER)[0]);\n+    }\n+\n+    /** Returns true if the read was properly added to the duplicate set **/\n+    public boolean addRead(final GATKRead read){\n+        if (reads.isEmpty()){\n+            init(read);\n+            reads.add(read);\n+            return true;\n+        }\n+\n+        if (sameMolecule(read)){\n+            reads.add(read);\n+            if (read.getStart() < fragmentStart){\n+                fragmentStart = read.getStart();\n+            }\n+            if (read.getEnd() > fragmentEnd){\n+                fragmentEnd = read.getEnd();\n+            }\n+            return true;\n+        } else {\n+            return false;\n+        }\n+    }\n+\n+    public int getFragmentStart(){\n+        return fragmentStart;\n+    }\n+\n+    public int getFragmentEnd(){", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c14aa1527401cb1b4eaa1d545d1f966754403e4f"}, "originalPosition": 104}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQyMjQ4MQ==", "bodyText": "doc", "url": "https://github.com/broadinstitute/gatk/pull/6512#discussion_r408422481", "createdAt": "2020-04-14T20:42:20Z", "author": {"login": "lbergelson"}, "path": "src/main/java/org/broadinstitute/hellbender/tools/walkers/mutect/consensus/DuplicateSet.java", "diffHunk": "@@ -0,0 +1,122 @@\n+package org.broadinstitute.hellbender.tools.walkers.mutect.consensus;\n+\n+import org.broadinstitute.hellbender.tools.walkers.mutect.UMI;\n+import org.broadinstitute.hellbender.utils.SimpleInterval;\n+import org.broadinstitute.hellbender.utils.Utils;\n+import org.broadinstitute.hellbender.utils.read.GATKRead;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+public class DuplicateSet {\n+    public static final String FGBIO_MOLECULAR_IDENTIFIER_TAG = \"MI\";\n+    public static final String FGBIO_MI_TAG_DELIMITER = \"/\";\n+    private int moleculeId = -1; // TODO: extract an ID class.\n+    private UMI umi;\n+    private String contig;\n+    private int fragmentStart = -1;\n+    private int fragmentEnd = -1;\n+    private List<GATKRead> reads;\n+    boolean smallInsert; // if true, the reads read into adaptors\n+    private boolean paired;  // TODO: is this useful/how can I detect this?\n+    // IN FACT, start here, also write tests --- count the number of MI=1's, MI=2's, etc...\n+    public DuplicateSet(){\n+        reads = new ArrayList<>();\n+    }\n+\n+    public DuplicateSet(final GATKRead read){\n+        reads = new ArrayList<>();\n+        init(read);\n+        reads.add(read);\n+    }\n+\n+    public void init(GATKRead read){\n+        Utils.validate(moleculeId == -1 || moleculeId == getMoleculeID(read),\n+                String.format(\"Inconsisntent molecule IDs: Duplicate set id = %s, read molecule id = %s\", moleculeId, getMoleculeID(read)));\n+        setMoleduleId(read);umi = new UMI(read);\n+        contig = read.getContig();\n+        fragmentStart = read.getStart();\n+        fragmentEnd = read.getEnd(); // TODO: does this include softclips?\n+        paired = false;\n+    }\n+\n+    public List<GATKRead> getReads(){\n+        return reads;\n+    }\n+\n+    public boolean sameMolecule(final GATKRead read){\n+        return getMoleculeID(read) == moleculeId;\n+    }\n+\n+    public void setMoleduleId(GATKRead read){\n+        moleculeId = getMoleculeID(read);\n+    }\n+\n+    public void setMoleduleId(int id){\n+        moleculeId = id;\n+    }\n+\n+    /**\n+     * Some examples of molecule IDs (MI tag):\n+     *\n+     * \"0/A\" (The first molecule in the bam, top (A) strand)\n+     * \"0/B\" (The first molecule in the bam, bottom (B) strand)\n+     * \"99/A\" (100th molecule in the bam, top top (A) strand)\n+     *\n+     * Top strand is synonymous to \"F1R2\"\n+     * Bottom strand is synonymous to \"F2R1\"\n+     *\n+     * Thus only the integer component is relevant for identifying reads that originated from the same molecule.\n+     * Should the need arise, we could extend this to distinguish between different strands of the same molecule.\n+     */\n+    public static int getMoleculeID(final GATKRead read) {\n+        final String MITag = read.getAttributeAsString(FGBIO_MOLECULAR_IDENTIFIER_TAG);\n+        return Integer.parseInt(MITag.split(FGBIO_MI_TAG_DELIMITER)[0]);\n+    }\n+\n+    /** Returns true if the read was properly added to the duplicate set **/\n+    public boolean addRead(final GATKRead read){\n+        if (reads.isEmpty()){\n+            init(read);\n+            reads.add(read);\n+            return true;\n+        }\n+\n+        if (sameMolecule(read)){\n+            reads.add(read);\n+            if (read.getStart() < fragmentStart){\n+                fragmentStart = read.getStart();\n+            }\n+            if (read.getEnd() > fragmentEnd){\n+                fragmentEnd = read.getEnd();\n+            }\n+            return true;\n+        } else {\n+            return false;\n+        }\n+    }\n+\n+    public int getFragmentStart(){\n+        return fragmentStart;\n+    }\n+\n+    public int getFragmentEnd(){\n+        return fragmentEnd;\n+    }\n+\n+    public int getMoleculeId() { return moleculeId; }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c14aa1527401cb1b4eaa1d545d1f966754403e4f"}, "originalPosition": 108}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQyMjg5Nw==", "bodyText": "unnecessary if this is locatable.", "url": "https://github.com/broadinstitute/gatk/pull/6512#discussion_r408422897", "createdAt": "2020-04-14T20:43:05Z", "author": {"login": "lbergelson"}, "path": "src/main/java/org/broadinstitute/hellbender/tools/walkers/mutect/consensus/DuplicateSet.java", "diffHunk": "@@ -0,0 +1,122 @@\n+package org.broadinstitute.hellbender.tools.walkers.mutect.consensus;\n+\n+import org.broadinstitute.hellbender.tools.walkers.mutect.UMI;\n+import org.broadinstitute.hellbender.utils.SimpleInterval;\n+import org.broadinstitute.hellbender.utils.Utils;\n+import org.broadinstitute.hellbender.utils.read.GATKRead;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+public class DuplicateSet {\n+    public static final String FGBIO_MOLECULAR_IDENTIFIER_TAG = \"MI\";\n+    public static final String FGBIO_MI_TAG_DELIMITER = \"/\";\n+    private int moleculeId = -1; // TODO: extract an ID class.\n+    private UMI umi;\n+    private String contig;\n+    private int fragmentStart = -1;\n+    private int fragmentEnd = -1;\n+    private List<GATKRead> reads;\n+    boolean smallInsert; // if true, the reads read into adaptors\n+    private boolean paired;  // TODO: is this useful/how can I detect this?\n+    // IN FACT, start here, also write tests --- count the number of MI=1's, MI=2's, etc...\n+    public DuplicateSet(){\n+        reads = new ArrayList<>();\n+    }\n+\n+    public DuplicateSet(final GATKRead read){\n+        reads = new ArrayList<>();\n+        init(read);\n+        reads.add(read);\n+    }\n+\n+    public void init(GATKRead read){\n+        Utils.validate(moleculeId == -1 || moleculeId == getMoleculeID(read),\n+                String.format(\"Inconsisntent molecule IDs: Duplicate set id = %s, read molecule id = %s\", moleculeId, getMoleculeID(read)));\n+        setMoleduleId(read);umi = new UMI(read);\n+        contig = read.getContig();\n+        fragmentStart = read.getStart();\n+        fragmentEnd = read.getEnd(); // TODO: does this include softclips?\n+        paired = false;\n+    }\n+\n+    public List<GATKRead> getReads(){\n+        return reads;\n+    }\n+\n+    public boolean sameMolecule(final GATKRead read){\n+        return getMoleculeID(read) == moleculeId;\n+    }\n+\n+    public void setMoleduleId(GATKRead read){\n+        moleculeId = getMoleculeID(read);\n+    }\n+\n+    public void setMoleduleId(int id){\n+        moleculeId = id;\n+    }\n+\n+    /**\n+     * Some examples of molecule IDs (MI tag):\n+     *\n+     * \"0/A\" (The first molecule in the bam, top (A) strand)\n+     * \"0/B\" (The first molecule in the bam, bottom (B) strand)\n+     * \"99/A\" (100th molecule in the bam, top top (A) strand)\n+     *\n+     * Top strand is synonymous to \"F1R2\"\n+     * Bottom strand is synonymous to \"F2R1\"\n+     *\n+     * Thus only the integer component is relevant for identifying reads that originated from the same molecule.\n+     * Should the need arise, we could extend this to distinguish between different strands of the same molecule.\n+     */\n+    public static int getMoleculeID(final GATKRead read) {\n+        final String MITag = read.getAttributeAsString(FGBIO_MOLECULAR_IDENTIFIER_TAG);\n+        return Integer.parseInt(MITag.split(FGBIO_MI_TAG_DELIMITER)[0]);\n+    }\n+\n+    /** Returns true if the read was properly added to the duplicate set **/\n+    public boolean addRead(final GATKRead read){\n+        if (reads.isEmpty()){\n+            init(read);\n+            reads.add(read);\n+            return true;\n+        }\n+\n+        if (sameMolecule(read)){\n+            reads.add(read);\n+            if (read.getStart() < fragmentStart){\n+                fragmentStart = read.getStart();\n+            }\n+            if (read.getEnd() > fragmentEnd){\n+                fragmentEnd = read.getEnd();\n+            }\n+            return true;\n+        } else {\n+            return false;\n+        }\n+    }\n+\n+    public int getFragmentStart(){\n+        return fragmentStart;\n+    }\n+\n+    public int getFragmentEnd(){\n+        return fragmentEnd;\n+    }\n+\n+    public int getMoleculeId() { return moleculeId; }\n+\n+    public SimpleInterval getDuplicateSetInterval(){", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c14aa1527401cb1b4eaa1d545d1f966754403e4f"}, "originalPosition": 110}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQyMzg2NA==", "bodyText": "This seems strange.  If you're computing intervals correctly you should never get an invalid one UNLESS you're mixing different contigs, in which case you probably want to test that more aggressively so that you don't sometimes get them by accident.", "url": "https://github.com/broadinstitute/gatk/pull/6512#discussion_r408423864", "createdAt": "2020-04-14T20:44:51Z", "author": {"login": "lbergelson"}, "path": "src/main/java/org/broadinstitute/hellbender/tools/walkers/mutect/consensus/DuplicateSet.java", "diffHunk": "@@ -0,0 +1,122 @@\n+package org.broadinstitute.hellbender.tools.walkers.mutect.consensus;\n+\n+import org.broadinstitute.hellbender.tools.walkers.mutect.UMI;\n+import org.broadinstitute.hellbender.utils.SimpleInterval;\n+import org.broadinstitute.hellbender.utils.Utils;\n+import org.broadinstitute.hellbender.utils.read.GATKRead;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+public class DuplicateSet {\n+    public static final String FGBIO_MOLECULAR_IDENTIFIER_TAG = \"MI\";\n+    public static final String FGBIO_MI_TAG_DELIMITER = \"/\";\n+    private int moleculeId = -1; // TODO: extract an ID class.\n+    private UMI umi;\n+    private String contig;\n+    private int fragmentStart = -1;\n+    private int fragmentEnd = -1;\n+    private List<GATKRead> reads;\n+    boolean smallInsert; // if true, the reads read into adaptors\n+    private boolean paired;  // TODO: is this useful/how can I detect this?\n+    // IN FACT, start here, also write tests --- count the number of MI=1's, MI=2's, etc...\n+    public DuplicateSet(){\n+        reads = new ArrayList<>();\n+    }\n+\n+    public DuplicateSet(final GATKRead read){\n+        reads = new ArrayList<>();\n+        init(read);\n+        reads.add(read);\n+    }\n+\n+    public void init(GATKRead read){\n+        Utils.validate(moleculeId == -1 || moleculeId == getMoleculeID(read),\n+                String.format(\"Inconsisntent molecule IDs: Duplicate set id = %s, read molecule id = %s\", moleculeId, getMoleculeID(read)));\n+        setMoleduleId(read);umi = new UMI(read);\n+        contig = read.getContig();\n+        fragmentStart = read.getStart();\n+        fragmentEnd = read.getEnd(); // TODO: does this include softclips?\n+        paired = false;\n+    }\n+\n+    public List<GATKRead> getReads(){\n+        return reads;\n+    }\n+\n+    public boolean sameMolecule(final GATKRead read){\n+        return getMoleculeID(read) == moleculeId;\n+    }\n+\n+    public void setMoleduleId(GATKRead read){\n+        moleculeId = getMoleculeID(read);\n+    }\n+\n+    public void setMoleduleId(int id){\n+        moleculeId = id;\n+    }\n+\n+    /**\n+     * Some examples of molecule IDs (MI tag):\n+     *\n+     * \"0/A\" (The first molecule in the bam, top (A) strand)\n+     * \"0/B\" (The first molecule in the bam, bottom (B) strand)\n+     * \"99/A\" (100th molecule in the bam, top top (A) strand)\n+     *\n+     * Top strand is synonymous to \"F1R2\"\n+     * Bottom strand is synonymous to \"F2R1\"\n+     *\n+     * Thus only the integer component is relevant for identifying reads that originated from the same molecule.\n+     * Should the need arise, we could extend this to distinguish between different strands of the same molecule.\n+     */\n+    public static int getMoleculeID(final GATKRead read) {\n+        final String MITag = read.getAttributeAsString(FGBIO_MOLECULAR_IDENTIFIER_TAG);\n+        return Integer.parseInt(MITag.split(FGBIO_MI_TAG_DELIMITER)[0]);\n+    }\n+\n+    /** Returns true if the read was properly added to the duplicate set **/\n+    public boolean addRead(final GATKRead read){\n+        if (reads.isEmpty()){\n+            init(read);\n+            reads.add(read);\n+            return true;\n+        }\n+\n+        if (sameMolecule(read)){\n+            reads.add(read);\n+            if (read.getStart() < fragmentStart){\n+                fragmentStart = read.getStart();\n+            }\n+            if (read.getEnd() > fragmentEnd){\n+                fragmentEnd = read.getEnd();\n+            }\n+            return true;\n+        } else {\n+            return false;\n+        }\n+    }\n+\n+    public int getFragmentStart(){\n+        return fragmentStart;\n+    }\n+\n+    public int getFragmentEnd(){\n+        return fragmentEnd;\n+    }\n+\n+    public int getMoleculeId() { return moleculeId; }\n+\n+    public SimpleInterval getDuplicateSetInterval(){\n+        return new SimpleInterval(contig, fragmentStart, fragmentEnd);\n+    }\n+\n+    public boolean hasValidInterval(){\n+        return SimpleInterval.isValid(contig, fragmentStart, fragmentEnd);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c14aa1527401cb1b4eaa1d545d1f966754403e4f"}, "originalPosition": 115}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQyNDIyMQ==", "bodyText": "javadoc, confusing why we want this", "url": "https://github.com/broadinstitute/gatk/pull/6512#discussion_r408424221", "createdAt": "2020-04-14T20:45:32Z", "author": {"login": "lbergelson"}, "path": "src/main/java/org/broadinstitute/hellbender/tools/walkers/mutect/consensus/DuplicateSet.java", "diffHunk": "@@ -0,0 +1,122 @@\n+package org.broadinstitute.hellbender.tools.walkers.mutect.consensus;\n+\n+import org.broadinstitute.hellbender.tools.walkers.mutect.UMI;\n+import org.broadinstitute.hellbender.utils.SimpleInterval;\n+import org.broadinstitute.hellbender.utils.Utils;\n+import org.broadinstitute.hellbender.utils.read.GATKRead;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+public class DuplicateSet {\n+    public static final String FGBIO_MOLECULAR_IDENTIFIER_TAG = \"MI\";\n+    public static final String FGBIO_MI_TAG_DELIMITER = \"/\";\n+    private int moleculeId = -1; // TODO: extract an ID class.\n+    private UMI umi;\n+    private String contig;\n+    private int fragmentStart = -1;\n+    private int fragmentEnd = -1;\n+    private List<GATKRead> reads;\n+    boolean smallInsert; // if true, the reads read into adaptors\n+    private boolean paired;  // TODO: is this useful/how can I detect this?\n+    // IN FACT, start here, also write tests --- count the number of MI=1's, MI=2's, etc...\n+    public DuplicateSet(){\n+        reads = new ArrayList<>();\n+    }\n+\n+    public DuplicateSet(final GATKRead read){\n+        reads = new ArrayList<>();\n+        init(read);\n+        reads.add(read);\n+    }\n+\n+    public void init(GATKRead read){\n+        Utils.validate(moleculeId == -1 || moleculeId == getMoleculeID(read),\n+                String.format(\"Inconsisntent molecule IDs: Duplicate set id = %s, read molecule id = %s\", moleculeId, getMoleculeID(read)));\n+        setMoleduleId(read);umi = new UMI(read);\n+        contig = read.getContig();\n+        fragmentStart = read.getStart();\n+        fragmentEnd = read.getEnd(); // TODO: does this include softclips?\n+        paired = false;\n+    }\n+\n+    public List<GATKRead> getReads(){\n+        return reads;\n+    }\n+\n+    public boolean sameMolecule(final GATKRead read){\n+        return getMoleculeID(read) == moleculeId;\n+    }\n+\n+    public void setMoleduleId(GATKRead read){\n+        moleculeId = getMoleculeID(read);\n+    }\n+\n+    public void setMoleduleId(int id){\n+        moleculeId = id;\n+    }\n+\n+    /**\n+     * Some examples of molecule IDs (MI tag):\n+     *\n+     * \"0/A\" (The first molecule in the bam, top (A) strand)\n+     * \"0/B\" (The first molecule in the bam, bottom (B) strand)\n+     * \"99/A\" (100th molecule in the bam, top top (A) strand)\n+     *\n+     * Top strand is synonymous to \"F1R2\"\n+     * Bottom strand is synonymous to \"F2R1\"\n+     *\n+     * Thus only the integer component is relevant for identifying reads that originated from the same molecule.\n+     * Should the need arise, we could extend this to distinguish between different strands of the same molecule.\n+     */\n+    public static int getMoleculeID(final GATKRead read) {\n+        final String MITag = read.getAttributeAsString(FGBIO_MOLECULAR_IDENTIFIER_TAG);\n+        return Integer.parseInt(MITag.split(FGBIO_MI_TAG_DELIMITER)[0]);\n+    }\n+\n+    /** Returns true if the read was properly added to the duplicate set **/\n+    public boolean addRead(final GATKRead read){\n+        if (reads.isEmpty()){\n+            init(read);\n+            reads.add(read);\n+            return true;\n+        }\n+\n+        if (sameMolecule(read)){\n+            reads.add(read);\n+            if (read.getStart() < fragmentStart){\n+                fragmentStart = read.getStart();\n+            }\n+            if (read.getEnd() > fragmentEnd){\n+                fragmentEnd = read.getEnd();\n+            }\n+            return true;\n+        } else {\n+            return false;\n+        }\n+    }\n+\n+    public int getFragmentStart(){\n+        return fragmentStart;\n+    }\n+\n+    public int getFragmentEnd(){\n+        return fragmentEnd;\n+    }\n+\n+    public int getMoleculeId() { return moleculeId; }\n+\n+    public SimpleInterval getDuplicateSetInterval(){\n+        return new SimpleInterval(contig, fragmentStart, fragmentEnd);\n+    }\n+\n+    public boolean hasValidInterval(){\n+        return SimpleInterval.isValid(contig, fragmentStart, fragmentEnd);\n+    }\n+\n+    public static List<String> getMolecularIDs(final List<GATKRead> reads) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c14aa1527401cb1b4eaa1d545d1f966754403e4f"}, "originalPosition": 118}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQyNDU4OQ==", "bodyText": "Lets copy this to our bucket so we have our own copy and it can't be deleted out from under us", "url": "https://github.com/broadinstitute/gatk/pull/6512#discussion_r408424589", "createdAt": "2020-04-14T20:46:15Z", "author": {"login": "lbergelson"}, "path": "src/test/java/org/broadinstitute/hellbender/tools/walkers/consensus/DownsampleByDuplicateSetTest.java", "diffHunk": "@@ -0,0 +1,129 @@\n+package org.broadinstitute.hellbender.tools.walkers.consensus;\n+\n+import org.apache.commons.lang3.mutable.MutableInt;\n+import org.broadinstitute.hellbender.CommandLineProgramTest;\n+import org.broadinstitute.hellbender.engine.ReadsDataSource;\n+import org.broadinstitute.hellbender.testutils.ArgumentsBuilder;\n+import org.broadinstitute.hellbender.utils.read.GATKRead;\n+import org.testng.Assert;\n+import org.testng.annotations.Test;\n+\n+import java.io.File;\n+import java.nio.file.Paths;\n+import java.util.*;\n+\n+public class DownsampleByDuplicateSetTest extends CommandLineProgramTest {\n+    public static final String NA12878_GROUPED = publicTestDir + \"org/broadinstitute/hellbender/tools/downsampleByDuplicateSet/NA12878.grouped.bam\";\n+\n+    @Test\n+    public void test(){\n+        final String cloud = \"gs://fc-secure-429c9379-aa5e-4884-8c35-7a5b947efc37/4c979e79-ca8e-4703-b8da-95b6da07f693/GenerateDuplexConsensusBams/c4b5b563-8266-4fe2-a653-83b5754679aa/call-FGBioGroupReadsByUmi/NA12878_rep1_A05_rep1_5pct.fgbio.groupByUmi.bam\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c14aa1527401cb1b4eaa1d545d1f966754403e4f"}, "originalPosition": 20}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQyNDgxNw==", "bodyText": "needs to be marked with groups=\"cloud\"", "url": "https://github.com/broadinstitute/gatk/pull/6512#discussion_r408424817", "createdAt": "2020-04-14T20:46:40Z", "author": {"login": "lbergelson"}, "path": "src/test/java/org/broadinstitute/hellbender/tools/walkers/consensus/DownsampleByDuplicateSetTest.java", "diffHunk": "@@ -0,0 +1,129 @@\n+package org.broadinstitute.hellbender.tools.walkers.consensus;\n+\n+import org.apache.commons.lang3.mutable.MutableInt;\n+import org.broadinstitute.hellbender.CommandLineProgramTest;\n+import org.broadinstitute.hellbender.engine.ReadsDataSource;\n+import org.broadinstitute.hellbender.testutils.ArgumentsBuilder;\n+import org.broadinstitute.hellbender.utils.read.GATKRead;\n+import org.testng.Assert;\n+import org.testng.annotations.Test;\n+\n+import java.io.File;\n+import java.nio.file.Paths;\n+import java.util.*;\n+\n+public class DownsampleByDuplicateSetTest extends CommandLineProgramTest {\n+    public static final String NA12878_GROUPED = publicTestDir + \"org/broadinstitute/hellbender/tools/downsampleByDuplicateSet/NA12878.grouped.bam\";\n+\n+    @Test", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c14aa1527401cb1b4eaa1d545d1f966754403e4f"}, "originalPosition": 18}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQyNTE2MQ==", "bodyText": "Specifying the program name should be unnecessary, it should automatic that.", "url": "https://github.com/broadinstitute/gatk/pull/6512#discussion_r408425161", "createdAt": "2020-04-14T20:47:18Z", "author": {"login": "lbergelson"}, "path": "src/test/java/org/broadinstitute/hellbender/tools/walkers/consensus/DownsampleByDuplicateSetTest.java", "diffHunk": "@@ -0,0 +1,129 @@\n+package org.broadinstitute.hellbender.tools.walkers.consensus;\n+\n+import org.apache.commons.lang3.mutable.MutableInt;\n+import org.broadinstitute.hellbender.CommandLineProgramTest;\n+import org.broadinstitute.hellbender.engine.ReadsDataSource;\n+import org.broadinstitute.hellbender.testutils.ArgumentsBuilder;\n+import org.broadinstitute.hellbender.utils.read.GATKRead;\n+import org.testng.Assert;\n+import org.testng.annotations.Test;\n+\n+import java.io.File;\n+import java.nio.file.Paths;\n+import java.util.*;\n+\n+public class DownsampleByDuplicateSetTest extends CommandLineProgramTest {\n+    public static final String NA12878_GROUPED = publicTestDir + \"org/broadinstitute/hellbender/tools/downsampleByDuplicateSet/NA12878.grouped.bam\";\n+\n+    @Test\n+    public void test(){\n+        final String cloud = \"gs://fc-secure-429c9379-aa5e-4884-8c35-7a5b947efc37/4c979e79-ca8e-4703-b8da-95b6da07f693/GenerateDuplexConsensusBams/c4b5b563-8266-4fe2-a653-83b5754679aa/call-FGBioGroupReadsByUmi/NA12878_rep1_A05_rep1_5pct.fgbio.groupByUmi.bam\";\n+        final String out = \"/Users/tsato/workspace/gatk/tmp/duplex.bam\";\n+        final ArgumentsBuilder args = new ArgumentsBuilder()\n+                .add(\"I\", cloud)\n+                .add(\"O\", out)\n+                .add(\"DS\", \"1.0\")\n+                .add(\"keep-duplex-only\", \"true\");\n+        runCommandLine(args, DownsampleByDuplicateSet.class.getSimpleName());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c14aa1527401cb1b4eaa1d545d1f966754403e4f"}, "originalPosition": 27}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQyNTI1Nw==", "bodyText": "this needs to be a temp file", "url": "https://github.com/broadinstitute/gatk/pull/6512#discussion_r408425257", "createdAt": "2020-04-14T20:47:31Z", "author": {"login": "lbergelson"}, "path": "src/test/java/org/broadinstitute/hellbender/tools/walkers/consensus/DownsampleByDuplicateSetTest.java", "diffHunk": "@@ -0,0 +1,129 @@\n+package org.broadinstitute.hellbender.tools.walkers.consensus;\n+\n+import org.apache.commons.lang3.mutable.MutableInt;\n+import org.broadinstitute.hellbender.CommandLineProgramTest;\n+import org.broadinstitute.hellbender.engine.ReadsDataSource;\n+import org.broadinstitute.hellbender.testutils.ArgumentsBuilder;\n+import org.broadinstitute.hellbender.utils.read.GATKRead;\n+import org.testng.Assert;\n+import org.testng.annotations.Test;\n+\n+import java.io.File;\n+import java.nio.file.Paths;\n+import java.util.*;\n+\n+public class DownsampleByDuplicateSetTest extends CommandLineProgramTest {\n+    public static final String NA12878_GROUPED = publicTestDir + \"org/broadinstitute/hellbender/tools/downsampleByDuplicateSet/NA12878.grouped.bam\";\n+\n+    @Test\n+    public void test(){\n+        final String cloud = \"gs://fc-secure-429c9379-aa5e-4884-8c35-7a5b947efc37/4c979e79-ca8e-4703-b8da-95b6da07f693/GenerateDuplexConsensusBams/c4b5b563-8266-4fe2-a653-83b5754679aa/call-FGBioGroupReadsByUmi/NA12878_rep1_A05_rep1_5pct.fgbio.groupByUmi.bam\";\n+        final String out = \"/Users/tsato/workspace/gatk/tmp/duplex.bam\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c14aa1527401cb1b4eaa1d545d1f966754403e4f"}, "originalPosition": 21}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQyNTQzOQ==", "bodyText": "Should this test test something?", "url": "https://github.com/broadinstitute/gatk/pull/6512#discussion_r408425439", "createdAt": "2020-04-14T20:47:50Z", "author": {"login": "lbergelson"}, "path": "src/test/java/org/broadinstitute/hellbender/tools/walkers/consensus/DownsampleByDuplicateSetTest.java", "diffHunk": "@@ -0,0 +1,129 @@\n+package org.broadinstitute.hellbender.tools.walkers.consensus;\n+\n+import org.apache.commons.lang3.mutable.MutableInt;\n+import org.broadinstitute.hellbender.CommandLineProgramTest;\n+import org.broadinstitute.hellbender.engine.ReadsDataSource;\n+import org.broadinstitute.hellbender.testutils.ArgumentsBuilder;\n+import org.broadinstitute.hellbender.utils.read.GATKRead;\n+import org.testng.Assert;\n+import org.testng.annotations.Test;\n+\n+import java.io.File;\n+import java.nio.file.Paths;\n+import java.util.*;\n+\n+public class DownsampleByDuplicateSetTest extends CommandLineProgramTest {\n+    public static final String NA12878_GROUPED = publicTestDir + \"org/broadinstitute/hellbender/tools/downsampleByDuplicateSet/NA12878.grouped.bam\";\n+\n+    @Test\n+    public void test(){\n+        final String cloud = \"gs://fc-secure-429c9379-aa5e-4884-8c35-7a5b947efc37/4c979e79-ca8e-4703-b8da-95b6da07f693/GenerateDuplexConsensusBams/c4b5b563-8266-4fe2-a653-83b5754679aa/call-FGBioGroupReadsByUmi/NA12878_rep1_A05_rep1_5pct.fgbio.groupByUmi.bam\";\n+        final String out = \"/Users/tsato/workspace/gatk/tmp/duplex.bam\";\n+        final ArgumentsBuilder args = new ArgumentsBuilder()\n+                .add(\"I\", cloud)\n+                .add(\"O\", out)\n+                .add(\"DS\", \"1.0\")\n+                .add(\"keep-duplex-only\", \"true\");\n+        runCommandLine(args, DownsampleByDuplicateSet.class.getSimpleName());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQyNTE2MQ=="}, "originalCommit": {"oid": "c14aa1527401cb1b4eaa1d545d1f966754403e4f"}, "originalPosition": 27}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQyNjAzMw==", "bodyText": "This is unused and adds complication, lets remove it.", "url": "https://github.com/broadinstitute/gatk/pull/6512#discussion_r408426033", "createdAt": "2020-04-14T20:48:53Z", "author": {"login": "lbergelson"}, "path": "src/main/java/org/broadinstitute/hellbender/engine/ReadWalker.java", "diffHunk": "@@ -167,4 +167,16 @@ protected final void onShutdown() {\n         // Overridden only to make final so that concrete tool implementations don't override\n         super.onShutdown();\n     }\n+\n+    public void postProcess(){\n+        return;\n+    }\n+\n+    public GATKRead peekFirstRead(){", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c14aa1527401cb1b4eaa1d545d1f966754403e4f"}, "originalPosition": 27}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQyNjU0OQ==", "bodyText": "declare this in a try-with-resources block", "url": "https://github.com/broadinstitute/gatk/pull/6512#discussion_r408426549", "createdAt": "2020-04-14T20:49:47Z", "author": {"login": "lbergelson"}, "path": "src/test/java/org/broadinstitute/hellbender/tools/walkers/consensus/DownsampleByDuplicateSetTest.java", "diffHunk": "@@ -0,0 +1,129 @@\n+package org.broadinstitute.hellbender.tools.walkers.consensus;\n+\n+import org.apache.commons.lang3.mutable.MutableInt;\n+import org.broadinstitute.hellbender.CommandLineProgramTest;\n+import org.broadinstitute.hellbender.engine.ReadsDataSource;\n+import org.broadinstitute.hellbender.testutils.ArgumentsBuilder;\n+import org.broadinstitute.hellbender.utils.read.GATKRead;\n+import org.testng.Assert;\n+import org.testng.annotations.Test;\n+\n+import java.io.File;\n+import java.nio.file.Paths;\n+import java.util.*;\n+\n+public class DownsampleByDuplicateSetTest extends CommandLineProgramTest {\n+    public static final String NA12878_GROUPED = publicTestDir + \"org/broadinstitute/hellbender/tools/downsampleByDuplicateSet/NA12878.grouped.bam\";\n+\n+    @Test\n+    public void test(){\n+        final String cloud = \"gs://fc-secure-429c9379-aa5e-4884-8c35-7a5b947efc37/4c979e79-ca8e-4703-b8da-95b6da07f693/GenerateDuplexConsensusBams/c4b5b563-8266-4fe2-a653-83b5754679aa/call-FGBioGroupReadsByUmi/NA12878_rep1_A05_rep1_5pct.fgbio.groupByUmi.bam\";\n+        final String out = \"/Users/tsato/workspace/gatk/tmp/duplex.bam\";\n+        final ArgumentsBuilder args = new ArgumentsBuilder()\n+                .add(\"I\", cloud)\n+                .add(\"O\", out)\n+                .add(\"DS\", \"1.0\")\n+                .add(\"keep-duplex-only\", \"true\");\n+        runCommandLine(args, DownsampleByDuplicateSet.class.getSimpleName());\n+    }\n+\n+    @Test\n+    public void testMatesAreTogether(){\n+        final File out = createTempFile(\"downsampled\", \"bam\");\n+        final ArgumentsBuilder args = new ArgumentsBuilder()\n+                .add(\"I\", NA12878_GROUPED)\n+                .add(\"O\", out.getAbsolutePath())\n+                .add(\"DS\", \"1.0\");\n+        runCommandLine(args, DownsampleByDuplicateSet.class.getSimpleName());\n+\n+        final ReadsDataSource readsDataSource = new ReadsDataSource(Paths.get(out.getAbsolutePath()));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c14aa1527401cb1b4eaa1d545d1f966754403e4f"}, "originalPosition": 39}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQyNjc0OQ==", "bodyText": "declare datasources in a try-with-resources", "url": "https://github.com/broadinstitute/gatk/pull/6512#discussion_r408426749", "createdAt": "2020-04-14T20:50:10Z", "author": {"login": "lbergelson"}, "path": "src/test/java/org/broadinstitute/hellbender/tools/walkers/consensus/DownsampleByDuplicateSetTest.java", "diffHunk": "@@ -0,0 +1,129 @@\n+package org.broadinstitute.hellbender.tools.walkers.consensus;\n+\n+import org.apache.commons.lang3.mutable.MutableInt;\n+import org.broadinstitute.hellbender.CommandLineProgramTest;\n+import org.broadinstitute.hellbender.engine.ReadsDataSource;\n+import org.broadinstitute.hellbender.testutils.ArgumentsBuilder;\n+import org.broadinstitute.hellbender.utils.read.GATKRead;\n+import org.testng.Assert;\n+import org.testng.annotations.Test;\n+\n+import java.io.File;\n+import java.nio.file.Paths;\n+import java.util.*;\n+\n+public class DownsampleByDuplicateSetTest extends CommandLineProgramTest {\n+    public static final String NA12878_GROUPED = publicTestDir + \"org/broadinstitute/hellbender/tools/downsampleByDuplicateSet/NA12878.grouped.bam\";\n+\n+    @Test\n+    public void test(){\n+        final String cloud = \"gs://fc-secure-429c9379-aa5e-4884-8c35-7a5b947efc37/4c979e79-ca8e-4703-b8da-95b6da07f693/GenerateDuplexConsensusBams/c4b5b563-8266-4fe2-a653-83b5754679aa/call-FGBioGroupReadsByUmi/NA12878_rep1_A05_rep1_5pct.fgbio.groupByUmi.bam\";\n+        final String out = \"/Users/tsato/workspace/gatk/tmp/duplex.bam\";\n+        final ArgumentsBuilder args = new ArgumentsBuilder()\n+                .add(\"I\", cloud)\n+                .add(\"O\", out)\n+                .add(\"DS\", \"1.0\")\n+                .add(\"keep-duplex-only\", \"true\");\n+        runCommandLine(args, DownsampleByDuplicateSet.class.getSimpleName());\n+    }\n+\n+    @Test\n+    public void testMatesAreTogether(){\n+        final File out = createTempFile(\"downsampled\", \"bam\");\n+        final ArgumentsBuilder args = new ArgumentsBuilder()\n+                .add(\"I\", NA12878_GROUPED)\n+                .add(\"O\", out.getAbsolutePath())\n+                .add(\"DS\", \"1.0\");\n+        runCommandLine(args, DownsampleByDuplicateSet.class.getSimpleName());\n+\n+        final ReadsDataSource readsDataSource = new ReadsDataSource(Paths.get(out.getAbsolutePath()));\n+        final Iterator<GATKRead> iterator = readsDataSource.iterator();\n+        while (iterator.hasNext()){\n+            // Make sure that the read and its mate are next to each other in the file\n+            final GATKRead read1 = iterator.next();\n+            final GATKRead read2 = iterator.next();\n+            Assert.assertEquals(read1.getName(), read2.getName());\n+        }\n+    }\n+\n+    /** When down-sampling rate is 1.0, the input file is returned unchanged **/\n+    @Test\n+    public void testNoDownsampling(){\n+        final File out = createTempFile(\"downasampled\", \"bam\");\n+        final double downsampleRate = 1.0;\n+        final ArgumentsBuilder args = new ArgumentsBuilder()\n+                .add(\"I\", NA12878_GROUPED)\n+                .add(\"DS\", Double.toString(downsampleRate))\n+                .add(\"O\", out.getAbsolutePath());\n+        runCommandLine(args, DownsampleByDuplicateSet.class.getSimpleName());\n+\n+        final ReadsDataSource originalBam = new ReadsDataSource(Paths.get(NA12878_GROUPED));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c14aa1527401cb1b4eaa1d545d1f966754403e4f"}, "originalPosition": 60}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQyNzU4NQ==", "bodyText": "use the constant you defined", "url": "https://github.com/broadinstitute/gatk/pull/6512#discussion_r408427585", "createdAt": "2020-04-14T20:51:47Z", "author": {"login": "lbergelson"}, "path": "src/test/java/org/broadinstitute/hellbender/tools/walkers/consensus/DownsampleByDuplicateSetTest.java", "diffHunk": "@@ -0,0 +1,129 @@\n+package org.broadinstitute.hellbender.tools.walkers.consensus;\n+\n+import org.apache.commons.lang3.mutable.MutableInt;\n+import org.broadinstitute.hellbender.CommandLineProgramTest;\n+import org.broadinstitute.hellbender.engine.ReadsDataSource;\n+import org.broadinstitute.hellbender.testutils.ArgumentsBuilder;\n+import org.broadinstitute.hellbender.utils.read.GATKRead;\n+import org.testng.Assert;\n+import org.testng.annotations.Test;\n+\n+import java.io.File;\n+import java.nio.file.Paths;\n+import java.util.*;\n+\n+public class DownsampleByDuplicateSetTest extends CommandLineProgramTest {\n+    public static final String NA12878_GROUPED = publicTestDir + \"org/broadinstitute/hellbender/tools/downsampleByDuplicateSet/NA12878.grouped.bam\";\n+\n+    @Test\n+    public void test(){\n+        final String cloud = \"gs://fc-secure-429c9379-aa5e-4884-8c35-7a5b947efc37/4c979e79-ca8e-4703-b8da-95b6da07f693/GenerateDuplexConsensusBams/c4b5b563-8266-4fe2-a653-83b5754679aa/call-FGBioGroupReadsByUmi/NA12878_rep1_A05_rep1_5pct.fgbio.groupByUmi.bam\";\n+        final String out = \"/Users/tsato/workspace/gatk/tmp/duplex.bam\";\n+        final ArgumentsBuilder args = new ArgumentsBuilder()\n+                .add(\"I\", cloud)\n+                .add(\"O\", out)\n+                .add(\"DS\", \"1.0\")\n+                .add(\"keep-duplex-only\", \"true\");\n+        runCommandLine(args, DownsampleByDuplicateSet.class.getSimpleName());\n+    }\n+\n+    @Test\n+    public void testMatesAreTogether(){\n+        final File out = createTempFile(\"downsampled\", \"bam\");\n+        final ArgumentsBuilder args = new ArgumentsBuilder()\n+                .add(\"I\", NA12878_GROUPED)\n+                .add(\"O\", out.getAbsolutePath())\n+                .add(\"DS\", \"1.0\");\n+        runCommandLine(args, DownsampleByDuplicateSet.class.getSimpleName());\n+\n+        final ReadsDataSource readsDataSource = new ReadsDataSource(Paths.get(out.getAbsolutePath()));\n+        final Iterator<GATKRead> iterator = readsDataSource.iterator();\n+        while (iterator.hasNext()){\n+            // Make sure that the read and its mate are next to each other in the file\n+            final GATKRead read1 = iterator.next();\n+            final GATKRead read2 = iterator.next();\n+            Assert.assertEquals(read1.getName(), read2.getName());\n+        }\n+    }\n+\n+    /** When down-sampling rate is 1.0, the input file is returned unchanged **/\n+    @Test\n+    public void testNoDownsampling(){\n+        final File out = createTempFile(\"downasampled\", \"bam\");\n+        final double downsampleRate = 1.0;\n+        final ArgumentsBuilder args = new ArgumentsBuilder()\n+                .add(\"I\", NA12878_GROUPED)\n+                .add(\"DS\", Double.toString(downsampleRate))\n+                .add(\"O\", out.getAbsolutePath());\n+        runCommandLine(args, DownsampleByDuplicateSet.class.getSimpleName());\n+\n+        final ReadsDataSource originalBam = new ReadsDataSource(Paths.get(NA12878_GROUPED));\n+        final Map<String, MutableInt> originalMoleculeCounts = molecularIDsAndCounts(originalBam);\n+\n+        final ReadsDataSource downsampledBam = new ReadsDataSource(Paths.get(out.getAbsolutePath()));\n+        final Map<String, MutableInt> downsampledMoleculeCounts = molecularIDsAndCounts(downsampledBam);\n+\n+        for (Map.Entry<String, MutableInt> originalIDAndCount : originalMoleculeCounts.entrySet()){\n+            final String originalID = originalIDAndCount.getKey();\n+            final int originalCount = originalIDAndCount.getValue().intValue();\n+            Assert.assertTrue(originalCount == downsampledMoleculeCounts.get(originalID).intValue());\n+        }\n+    }\n+\n+    /**\n+     * Test that the downsampling rate corresponds to the reduction in the number of duplicates in the output\n+     * file up to sampling noise.\n+     */\n+    @Test\n+    public void testDownsampleFraction(){\n+        final File out = createTempFile(\"downasampled\", \"bam\");\n+        for (double downsampleRate : Arrays.asList(0.1, 0.3, 0.5)){\n+            final ArgumentsBuilder args = new ArgumentsBuilder()\n+                    .add(\"I\", NA12878_GROUPED)\n+                    .add(\"DS\", Double.toString(downsampleRate))\n+                    .add(\"O\", out.getAbsolutePath());\n+            runCommandLine(args, DownsampleByDuplicateSet.class.getSimpleName());\n+\n+            final ReadsDataSource originalBam = new ReadsDataSource(Paths.get(NA12878_GROUPED));\n+            final int originalMoleculeCount = countDuplicateSets(originalBam);\n+\n+            final ReadsDataSource downsampledBam = new ReadsDataSource(Paths.get(out.getAbsolutePath()));\n+            final int downsampledMoleculeCount = countDuplicateSets(downsampledBam);\n+\n+            final double noise = 2.0;\n+            final double deviationFromExpected = Math.abs(downsampleRate * originalMoleculeCount - downsampledMoleculeCount);\n+            Assert.assertTrue(deviationFromExpected < noise);\n+        }\n+    }\n+\n+    private int countDuplicateSets(final ReadsDataSource readsDataSource){\n+        int count = 0;\n+        String currentMolecularId = \"\"; // Note we are duplex aware: 12/A different from 12/B\n+        final Iterator<GATKRead> iterator = readsDataSource.iterator();\n+        while (iterator.hasNext()){\n+            final GATKRead read = iterator.next();\n+            final String molecularID = read.getAttributeAsString(\"MI\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c14aa1527401cb1b4eaa1d545d1f966754403e4f"}, "originalPosition": 105}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQyODM3MA==", "bodyText": "You should add bounds to this, i.e. minValue = 0.0 maxValue = 1.0", "url": "https://github.com/broadinstitute/gatk/pull/6512#discussion_r408428370", "createdAt": "2020-04-14T20:53:12Z", "author": {"login": "lbergelson"}, "path": "src/main/java/org/broadinstitute/hellbender/tools/walkers/consensus/DownsampleByDuplicateSet.java", "diffHunk": "@@ -0,0 +1,114 @@\n+package org.broadinstitute.hellbender.tools.walkers.consensus;\n+\n+import org.apache.commons.math3.random.RandomGenerator;\n+import org.apache.commons.math3.random.RandomGeneratorFactory;\n+import org.broadinstitute.barclay.argparser.Argument;\n+import org.broadinstitute.barclay.argparser.CommandLineProgramProperties;\n+import org.broadinstitute.hellbender.cmdline.StandardArgumentDefinitions;\n+import org.broadinstitute.hellbender.engine.DuplicateSetWalker;\n+import org.broadinstitute.hellbender.engine.FeatureContext;\n+import org.broadinstitute.hellbender.engine.ReferenceContext;\n+import org.broadinstitute.hellbender.tools.walkers.mutect.consensus.DuplicateSet;\n+import org.broadinstitute.hellbender.utils.io.IOUtils;\n+import org.broadinstitute.hellbender.utils.read.SAMFileGATKReadWriter;\n+import picard.cmdline.programgroups.ReadDataManipulationProgramGroup;\n+\n+import java.io.File;\n+import java.util.List;\n+import java.util.Random;\n+\n+@CommandLineProgramProperties(\n+        summary = \"Discard a set fraction of duplicate sets from a UMI-grouped ba\",\n+        oneLineSummary = \"Discard a set fraction of duplicate sets from a UMI-grouped bam\",\n+        programGroup = ReadDataManipulationProgramGroup.class\n+)\n+/**\n+ * Given a bam grouped by the same unique molecular identifier (UMI), this tool drops a fraction of duplicate sets and returns a new bam.\n+ * A duplicate set refers to a group of reads whose fragments start at and end at the same coordinate and share the same UMI.\n+ *\n+ * The input bam must have been sorted by UMI using FGBio GroupReadsByUmi (http://fulcrumgenomics.github.io/fgbio/tools/latest/GroupReadsByUmi.html).\n+ *\n+ * Use this tool to create, for instance, an insilico mixture of duplex-sequenced samples to simulate tumor subclone.\n+ * Suppose you wish to simulate a tumor sample in which 5% cells share a common set of somatic mutations\n+ * in addition to ones common to the entire cell population.\n+ *\n+ * If you randomly drop 5% of reads in sample A and 95% of reads in sample B and merge the reduced bams,\n+ * the resulting mixture skews the family-size distribution to the left. Here the family size refers to the\n+ * number of sequenced duplicate reads that share the same UMI.\n+ *\n+ * To see this, take a cancer sample, in which 5% of cells (i.e. a subclone) share a unique set of somatic mutations,\n+ * that was processed with duplex-UMIs (i.e. UMIs on both adapters) and high rounds of PCR. Suppose we have the sequence-ready\n+ * libraries of this sample attached to and amplified on the flowcell. Now, sort the flowcell lawn such that the\n+ * 5% subclone moves near the top of the flowcell. This subclone must have the same family-size distribution as\n+ * the rest of the flowcell, at about 5% of the library complexity compared to the entire flowcell.\n+ *\n+ * Now imagine replacing this subclone with 5% of the *entire* flowcell from another sample prepared and sequenced similarly.\n+ * The library complexity of these \"graft\" reads is higher than that of the original, and, consequently, with other parameters\n+ * such as the number of PCR cycles and sequencing depth fixed, its family distribution would be skewed left---that is, the family size\n+ * would be smaller than it should be.\n+ *\n+ * This tool address the above problem by dropping a set fraction of _duplicate sets_, rather than reads, at random.\n+ * Implicit in this approach is that a read and its mate are dropped or retained together.\n+ * While trivial when the input bam is sorted by UMI and query name, this is far from trivial when one attempts\n+ * to downsample reads naively with a tool like {@link PrintReads}.\n+ *\n+ **/\n+public class DownsampleByDuplicateSet extends DuplicateSetWalker {\n+    @Argument(fullName = StandardArgumentDefinitions.OUTPUT_LONG_NAME, shortName = StandardArgumentDefinitions.OUTPUT_SHORT_NAME, doc = \"\")\n+    public File outputBam;\n+\n+    @Argument(fullName = \"DS\", doc = \"This fraction of duplicate sets in the input bam will be retained\")", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQwMTA0Mw=="}, "originalCommit": {"oid": "c14aa1527401cb1b4eaa1d545d1f966754403e4f"}, "originalPosition": 60}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQyODQ5Ng==", "bodyText": "Can you add a test that shows that DS = 0.0 produces an empty file?", "url": "https://github.com/broadinstitute/gatk/pull/6512#discussion_r408428496", "createdAt": "2020-04-14T20:53:28Z", "author": {"login": "lbergelson"}, "path": "src/test/java/org/broadinstitute/hellbender/tools/walkers/consensus/DownsampleByDuplicateSetTest.java", "diffHunk": "@@ -0,0 +1,129 @@\n+package org.broadinstitute.hellbender.tools.walkers.consensus;\n+\n+import org.apache.commons.lang3.mutable.MutableInt;\n+import org.broadinstitute.hellbender.CommandLineProgramTest;\n+import org.broadinstitute.hellbender.engine.ReadsDataSource;\n+import org.broadinstitute.hellbender.testutils.ArgumentsBuilder;\n+import org.broadinstitute.hellbender.utils.read.GATKRead;\n+import org.testng.Assert;\n+import org.testng.annotations.Test;\n+\n+import java.io.File;\n+import java.nio.file.Paths;\n+import java.util.*;\n+\n+public class DownsampleByDuplicateSetTest extends CommandLineProgramTest {\n+    public static final String NA12878_GROUPED = publicTestDir + \"org/broadinstitute/hellbender/tools/downsampleByDuplicateSet/NA12878.grouped.bam\";\n+\n+    @Test\n+    public void test(){\n+        final String cloud = \"gs://fc-secure-429c9379-aa5e-4884-8c35-7a5b947efc37/4c979e79-ca8e-4703-b8da-95b6da07f693/GenerateDuplexConsensusBams/c4b5b563-8266-4fe2-a653-83b5754679aa/call-FGBioGroupReadsByUmi/NA12878_rep1_A05_rep1_5pct.fgbio.groupByUmi.bam\";\n+        final String out = \"/Users/tsato/workspace/gatk/tmp/duplex.bam\";\n+        final ArgumentsBuilder args = new ArgumentsBuilder()\n+                .add(\"I\", cloud)\n+                .add(\"O\", out)\n+                .add(\"DS\", \"1.0\")\n+                .add(\"keep-duplex-only\", \"true\");\n+        runCommandLine(args, DownsampleByDuplicateSet.class.getSimpleName());\n+    }\n+\n+    @Test\n+    public void testMatesAreTogether(){\n+        final File out = createTempFile(\"downsampled\", \"bam\");\n+        final ArgumentsBuilder args = new ArgumentsBuilder()\n+                .add(\"I\", NA12878_GROUPED)\n+                .add(\"O\", out.getAbsolutePath())\n+                .add(\"DS\", \"1.0\");\n+        runCommandLine(args, DownsampleByDuplicateSet.class.getSimpleName());\n+\n+        final ReadsDataSource readsDataSource = new ReadsDataSource(Paths.get(out.getAbsolutePath()));\n+        final Iterator<GATKRead> iterator = readsDataSource.iterator();\n+        while (iterator.hasNext()){\n+            // Make sure that the read and its mate are next to each other in the file\n+            final GATKRead read1 = iterator.next();\n+            final GATKRead read2 = iterator.next();\n+            Assert.assertEquals(read1.getName(), read2.getName());\n+        }\n+    }\n+\n+    /** When down-sampling rate is 1.0, the input file is returned unchanged **/\n+    @Test\n+    public void testNoDownsampling(){", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c14aa1527401cb1b4eaa1d545d1f966754403e4f"}, "originalPosition": 51}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQzMDQwNQ==", "bodyText": "Should the doc include an example usage?", "url": "https://github.com/broadinstitute/gatk/pull/6512#discussion_r408430405", "createdAt": "2020-04-14T20:57:07Z", "author": {"login": "lbergelson"}, "path": "src/main/java/org/broadinstitute/hellbender/tools/walkers/consensus/DownsampleByDuplicateSet.java", "diffHunk": "@@ -0,0 +1,114 @@\n+package org.broadinstitute.hellbender.tools.walkers.consensus;\n+\n+import org.apache.commons.math3.random.RandomGenerator;\n+import org.apache.commons.math3.random.RandomGeneratorFactory;\n+import org.broadinstitute.barclay.argparser.Argument;\n+import org.broadinstitute.barclay.argparser.CommandLineProgramProperties;\n+import org.broadinstitute.hellbender.cmdline.StandardArgumentDefinitions;\n+import org.broadinstitute.hellbender.engine.DuplicateSetWalker;\n+import org.broadinstitute.hellbender.engine.FeatureContext;\n+import org.broadinstitute.hellbender.engine.ReferenceContext;\n+import org.broadinstitute.hellbender.tools.walkers.mutect.consensus.DuplicateSet;\n+import org.broadinstitute.hellbender.utils.io.IOUtils;\n+import org.broadinstitute.hellbender.utils.read.SAMFileGATKReadWriter;\n+import picard.cmdline.programgroups.ReadDataManipulationProgramGroup;\n+\n+import java.io.File;\n+import java.util.List;\n+import java.util.Random;\n+\n+@CommandLineProgramProperties(\n+        summary = \"Discard a set fraction of duplicate sets from a UMI-grouped ba\",\n+        oneLineSummary = \"Discard a set fraction of duplicate sets from a UMI-grouped bam\",\n+        programGroup = ReadDataManipulationProgramGroup.class\n+)\n+/**\n+ * Given a bam grouped by the same unique molecular identifier (UMI), this tool drops a fraction of duplicate sets and returns a new bam.\n+ * A duplicate set refers to a group of reads whose fragments start at and end at the same coordinate and share the same UMI.\n+ *\n+ * The input bam must have been sorted by UMI using FGBio GroupReadsByUmi (http://fulcrumgenomics.github.io/fgbio/tools/latest/GroupReadsByUmi.html).\n+ *\n+ * Use this tool to create, for instance, an insilico mixture of duplex-sequenced samples to simulate tumor subclone.\n+ * Suppose you wish to simulate a tumor sample in which 5% cells share a common set of somatic mutations\n+ * in addition to ones common to the entire cell population.\n+ *\n+ * If you randomly drop 5% of reads in sample A and 95% of reads in sample B and merge the reduced bams,\n+ * the resulting mixture skews the family-size distribution to the left. Here the family size refers to the\n+ * number of sequenced duplicate reads that share the same UMI.\n+ *\n+ * To see this, take a cancer sample, in which 5% of cells (i.e. a subclone) share a unique set of somatic mutations,\n+ * that was processed with duplex-UMIs (i.e. UMIs on both adapters) and high rounds of PCR. Suppose we have the sequence-ready\n+ * libraries of this sample attached to and amplified on the flowcell. Now, sort the flowcell lawn such that the\n+ * 5% subclone moves near the top of the flowcell. This subclone must have the same family-size distribution as\n+ * the rest of the flowcell, at about 5% of the library complexity compared to the entire flowcell.\n+ *\n+ * Now imagine replacing this subclone with 5% of the *entire* flowcell from another sample prepared and sequenced similarly.\n+ * The library complexity of these \"graft\" reads is higher than that of the original, and, consequently, with other parameters\n+ * such as the number of PCR cycles and sequencing depth fixed, its family distribution would be skewed left---that is, the family size\n+ * would be smaller than it should be.\n+ *\n+ * This tool address the above problem by dropping a set fraction of _duplicate sets_, rather than reads, at random.\n+ * Implicit in this approach is that a read and its mate are dropped or retained together.\n+ * While trivial when the input bam is sorted by UMI and query name, this is far from trivial when one attempts\n+ * to downsample reads naively with a tool like {@link PrintReads}.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c14aa1527401cb1b4eaa1d545d1f966754403e4f"}, "originalPosition": 53}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQzMDUyNQ==", "bodyText": "try-with-resources", "url": "https://github.com/broadinstitute/gatk/pull/6512#discussion_r408430525", "createdAt": "2020-04-14T20:57:22Z", "author": {"login": "lbergelson"}, "path": "src/test/java/org/broadinstitute/hellbender/tools/walkers/consensus/DownsampleByDuplicateSetTest.java", "diffHunk": "@@ -0,0 +1,129 @@\n+package org.broadinstitute.hellbender.tools.walkers.consensus;\n+\n+import org.apache.commons.lang3.mutable.MutableInt;\n+import org.broadinstitute.hellbender.CommandLineProgramTest;\n+import org.broadinstitute.hellbender.engine.ReadsDataSource;\n+import org.broadinstitute.hellbender.testutils.ArgumentsBuilder;\n+import org.broadinstitute.hellbender.utils.read.GATKRead;\n+import org.testng.Assert;\n+import org.testng.annotations.Test;\n+\n+import java.io.File;\n+import java.nio.file.Paths;\n+import java.util.*;\n+\n+public class DownsampleByDuplicateSetTest extends CommandLineProgramTest {\n+    public static final String NA12878_GROUPED = publicTestDir + \"org/broadinstitute/hellbender/tools/downsampleByDuplicateSet/NA12878.grouped.bam\";\n+\n+    @Test\n+    public void test(){\n+        final String cloud = \"gs://fc-secure-429c9379-aa5e-4884-8c35-7a5b947efc37/4c979e79-ca8e-4703-b8da-95b6da07f693/GenerateDuplexConsensusBams/c4b5b563-8266-4fe2-a653-83b5754679aa/call-FGBioGroupReadsByUmi/NA12878_rep1_A05_rep1_5pct.fgbio.groupByUmi.bam\";\n+        final String out = \"/Users/tsato/workspace/gatk/tmp/duplex.bam\";\n+        final ArgumentsBuilder args = new ArgumentsBuilder()\n+                .add(\"I\", cloud)\n+                .add(\"O\", out)\n+                .add(\"DS\", \"1.0\")\n+                .add(\"keep-duplex-only\", \"true\");\n+        runCommandLine(args, DownsampleByDuplicateSet.class.getSimpleName());\n+    }\n+\n+    @Test\n+    public void testMatesAreTogether(){\n+        final File out = createTempFile(\"downsampled\", \"bam\");\n+        final ArgumentsBuilder args = new ArgumentsBuilder()\n+                .add(\"I\", NA12878_GROUPED)\n+                .add(\"O\", out.getAbsolutePath())\n+                .add(\"DS\", \"1.0\");\n+        runCommandLine(args, DownsampleByDuplicateSet.class.getSimpleName());\n+\n+        final ReadsDataSource readsDataSource = new ReadsDataSource(Paths.get(out.getAbsolutePath()));\n+        final Iterator<GATKRead> iterator = readsDataSource.iterator();\n+        while (iterator.hasNext()){\n+            // Make sure that the read and its mate are next to each other in the file\n+            final GATKRead read1 = iterator.next();\n+            final GATKRead read2 = iterator.next();\n+            Assert.assertEquals(read1.getName(), read2.getName());\n+        }\n+    }\n+\n+    /** When down-sampling rate is 1.0, the input file is returned unchanged **/\n+    @Test\n+    public void testNoDownsampling(){\n+        final File out = createTempFile(\"downasampled\", \"bam\");\n+        final double downsampleRate = 1.0;\n+        final ArgumentsBuilder args = new ArgumentsBuilder()\n+                .add(\"I\", NA12878_GROUPED)\n+                .add(\"DS\", Double.toString(downsampleRate))\n+                .add(\"O\", out.getAbsolutePath());\n+        runCommandLine(args, DownsampleByDuplicateSet.class.getSimpleName());\n+\n+        final ReadsDataSource originalBam = new ReadsDataSource(Paths.get(NA12878_GROUPED));\n+        final Map<String, MutableInt> originalMoleculeCounts = molecularIDsAndCounts(originalBam);\n+\n+        final ReadsDataSource downsampledBam = new ReadsDataSource(Paths.get(out.getAbsolutePath()));\n+        final Map<String, MutableInt> downsampledMoleculeCounts = molecularIDsAndCounts(downsampledBam);\n+\n+        for (Map.Entry<String, MutableInt> originalIDAndCount : originalMoleculeCounts.entrySet()){\n+            final String originalID = originalIDAndCount.getKey();\n+            final int originalCount = originalIDAndCount.getValue().intValue();\n+            Assert.assertTrue(originalCount == downsampledMoleculeCounts.get(originalID).intValue());\n+        }\n+    }\n+\n+    /**\n+     * Test that the downsampling rate corresponds to the reduction in the number of duplicates in the output\n+     * file up to sampling noise.\n+     */\n+    @Test\n+    public void testDownsampleFraction(){\n+        final File out = createTempFile(\"downasampled\", \"bam\");\n+        for (double downsampleRate : Arrays.asList(0.1, 0.3, 0.5)){\n+            final ArgumentsBuilder args = new ArgumentsBuilder()\n+                    .add(\"I\", NA12878_GROUPED)\n+                    .add(\"DS\", Double.toString(downsampleRate))\n+                    .add(\"O\", out.getAbsolutePath());\n+            runCommandLine(args, DownsampleByDuplicateSet.class.getSimpleName());\n+\n+            final ReadsDataSource originalBam = new ReadsDataSource(Paths.get(NA12878_GROUPED));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c14aa1527401cb1b4eaa1d545d1f966754403e4f"}, "originalPosition": 87}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQzMTQ0Mw==", "bodyText": "Ooh, there is a difference between the String molecular id's and the int molecular ids.  I would rename stuff because it's confusing as hell.  Maybe something like \"getMolecularIdNumber\" vs \"getCompleteMolecularIds\"?", "url": "https://github.com/broadinstitute/gatk/pull/6512#discussion_r408431443", "createdAt": "2020-04-14T20:59:02Z", "author": {"login": "lbergelson"}, "path": "src/main/java/org/broadinstitute/hellbender/tools/walkers/consensus/DownsampleByDuplicateSet.java", "diffHunk": "@@ -0,0 +1,114 @@\n+package org.broadinstitute.hellbender.tools.walkers.consensus;\n+\n+import org.apache.commons.math3.random.RandomGenerator;\n+import org.apache.commons.math3.random.RandomGeneratorFactory;\n+import org.broadinstitute.barclay.argparser.Argument;\n+import org.broadinstitute.barclay.argparser.CommandLineProgramProperties;\n+import org.broadinstitute.hellbender.cmdline.StandardArgumentDefinitions;\n+import org.broadinstitute.hellbender.engine.DuplicateSetWalker;\n+import org.broadinstitute.hellbender.engine.FeatureContext;\n+import org.broadinstitute.hellbender.engine.ReferenceContext;\n+import org.broadinstitute.hellbender.tools.walkers.mutect.consensus.DuplicateSet;\n+import org.broadinstitute.hellbender.utils.io.IOUtils;\n+import org.broadinstitute.hellbender.utils.read.SAMFileGATKReadWriter;\n+import picard.cmdline.programgroups.ReadDataManipulationProgramGroup;\n+\n+import java.io.File;\n+import java.util.List;\n+import java.util.Random;\n+\n+@CommandLineProgramProperties(\n+        summary = \"Discard a set fraction of duplicate sets from a UMI-grouped ba\",\n+        oneLineSummary = \"Discard a set fraction of duplicate sets from a UMI-grouped bam\",\n+        programGroup = ReadDataManipulationProgramGroup.class\n+)\n+/**\n+ * Given a bam grouped by the same unique molecular identifier (UMI), this tool drops a fraction of duplicate sets and returns a new bam.\n+ * A duplicate set refers to a group of reads whose fragments start at and end at the same coordinate and share the same UMI.\n+ *\n+ * The input bam must have been sorted by UMI using FGBio GroupReadsByUmi (http://fulcrumgenomics.github.io/fgbio/tools/latest/GroupReadsByUmi.html).\n+ *\n+ * Use this tool to create, for instance, an insilico mixture of duplex-sequenced samples to simulate tumor subclone.\n+ * Suppose you wish to simulate a tumor sample in which 5% cells share a common set of somatic mutations\n+ * in addition to ones common to the entire cell population.\n+ *\n+ * If you randomly drop 5% of reads in sample A and 95% of reads in sample B and merge the reduced bams,\n+ * the resulting mixture skews the family-size distribution to the left. Here the family size refers to the\n+ * number of sequenced duplicate reads that share the same UMI.\n+ *\n+ * To see this, take a cancer sample, in which 5% of cells (i.e. a subclone) share a unique set of somatic mutations,\n+ * that was processed with duplex-UMIs (i.e. UMIs on both adapters) and high rounds of PCR. Suppose we have the sequence-ready\n+ * libraries of this sample attached to and amplified on the flowcell. Now, sort the flowcell lawn such that the\n+ * 5% subclone moves near the top of the flowcell. This subclone must have the same family-size distribution as\n+ * the rest of the flowcell, at about 5% of the library complexity compared to the entire flowcell.\n+ *\n+ * Now imagine replacing this subclone with 5% of the *entire* flowcell from another sample prepared and sequenced similarly.\n+ * The library complexity of these \"graft\" reads is higher than that of the original, and, consequently, with other parameters\n+ * such as the number of PCR cycles and sequencing depth fixed, its family distribution would be skewed left---that is, the family size\n+ * would be smaller than it should be.\n+ *\n+ * This tool address the above problem by dropping a set fraction of _duplicate sets_, rather than reads, at random.\n+ * Implicit in this approach is that a read and its mate are dropped or retained together.\n+ * While trivial when the input bam is sorted by UMI and query name, this is far from trivial when one attempts\n+ * to downsample reads naively with a tool like {@link PrintReads}.\n+ *\n+ **/\n+public class DownsampleByDuplicateSet extends DuplicateSetWalker {\n+    @Argument(fullName = StandardArgumentDefinitions.OUTPUT_LONG_NAME, shortName = StandardArgumentDefinitions.OUTPUT_SHORT_NAME, doc = \"\")\n+    public File outputBam;\n+\n+    @Argument(fullName = \"DS\", doc = \"This fraction of duplicate sets in the input bam will be retained\")\n+    public double downsamplingRate;\n+\n+    @Argument(fullName = \"keep-duplex-only\", doc = \"Discard all duplicate sets that don't have duplex evidence\")\n+    public boolean duplexOnly = false;\n+\n+    private static final int RANDOM_SEED = 142;\n+    private RandomGenerator rng;\n+    private static int numFragments;\n+    private static int numReads;\n+    private SAMFileGATKReadWriter outputWriter;\n+\n+    @Override\n+    public void onTraversalStart() {\n+        super.onTraversalStart();\n+        rng = RandomGeneratorFactory.createRandomGenerator(new Random(RANDOM_SEED));\n+        outputWriter = createSAMWriter(IOUtils.getPath(outputBam.getAbsolutePath()), false);\n+    }\n+\n+    @Override\n+    public void apply(DuplicateSet duplicateSet, ReferenceContext referenceContext, FeatureContext featureContext) {\n+        if (filterDuplicateSet(duplicateSet)){\n+            return;\n+        }\n+        if (rng.nextDouble() < downsamplingRate){\n+            duplicateSet.getReads().forEach(r -> outputWriter.addRead(r));\n+            numReads += duplicateSet.getReads().size();\n+            numFragments += 1;\n+        }\n+    }\n+\n+    @Override\n+    public Object onTraversalSuccess(){\n+        outputWriter.close();\n+        logger.info(String.format(\"Wrote %d reads\", numReads));\n+        logger.info(String.format(\"Wrote %d fragments\", numFragments));\n+        return \"SUCCESS\";\n+    }\n+\n+    private boolean filterDuplicateSet(final DuplicateSet duplicateSet){\n+        if (duplicateSet.getReads().size() % 2 == 1){\n+            // We only keep reads with mates by default, as that's what fgbio GroupByUMI requires.\n+            logger.info(\"Duplicate set that contains an unpaired read discarded: \" + duplicateSet.getReads().get(0));\n+            return true;\n+        }\n+\n+        // Experiment: only keep duplex\n+        if (duplexOnly){\n+            final List<String> molecularIDs = DuplicateSet.getMolecularIDs(duplicateSet.getReads());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQwOTIxMQ=="}, "originalCommit": {"oid": "c14aa1527401cb1b4eaa1d545d1f966754403e4f"}, "originalPosition": 108}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQzMjMwNQ==", "bodyText": "Ok, I understand this now... you need clear javadoc and probably to rename this method since it's very strange that getMolecularID on 2 reads can produce the same result but getMolecularIDs then has 2 values.", "url": "https://github.com/broadinstitute/gatk/pull/6512#discussion_r408432305", "createdAt": "2020-04-14T21:00:36Z", "author": {"login": "lbergelson"}, "path": "src/main/java/org/broadinstitute/hellbender/tools/walkers/mutect/consensus/DuplicateSet.java", "diffHunk": "@@ -0,0 +1,122 @@\n+package org.broadinstitute.hellbender.tools.walkers.mutect.consensus;\n+\n+import org.broadinstitute.hellbender.tools.walkers.mutect.UMI;\n+import org.broadinstitute.hellbender.utils.SimpleInterval;\n+import org.broadinstitute.hellbender.utils.Utils;\n+import org.broadinstitute.hellbender.utils.read.GATKRead;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+public class DuplicateSet {\n+    public static final String FGBIO_MOLECULAR_IDENTIFIER_TAG = \"MI\";\n+    public static final String FGBIO_MI_TAG_DELIMITER = \"/\";\n+    private int moleculeId = -1; // TODO: extract an ID class.\n+    private UMI umi;\n+    private String contig;\n+    private int fragmentStart = -1;\n+    private int fragmentEnd = -1;\n+    private List<GATKRead> reads;\n+    boolean smallInsert; // if true, the reads read into adaptors\n+    private boolean paired;  // TODO: is this useful/how can I detect this?\n+    // IN FACT, start here, also write tests --- count the number of MI=1's, MI=2's, etc...\n+    public DuplicateSet(){\n+        reads = new ArrayList<>();\n+    }\n+\n+    public DuplicateSet(final GATKRead read){\n+        reads = new ArrayList<>();\n+        init(read);\n+        reads.add(read);\n+    }\n+\n+    public void init(GATKRead read){\n+        Utils.validate(moleculeId == -1 || moleculeId == getMoleculeID(read),\n+                String.format(\"Inconsisntent molecule IDs: Duplicate set id = %s, read molecule id = %s\", moleculeId, getMoleculeID(read)));\n+        setMoleduleId(read);umi = new UMI(read);\n+        contig = read.getContig();\n+        fragmentStart = read.getStart();\n+        fragmentEnd = read.getEnd(); // TODO: does this include softclips?\n+        paired = false;\n+    }\n+\n+    public List<GATKRead> getReads(){\n+        return reads;\n+    }\n+\n+    public boolean sameMolecule(final GATKRead read){\n+        return getMoleculeID(read) == moleculeId;\n+    }\n+\n+    public void setMoleduleId(GATKRead read){\n+        moleculeId = getMoleculeID(read);\n+    }\n+\n+    public void setMoleduleId(int id){\n+        moleculeId = id;\n+    }\n+\n+    /**\n+     * Some examples of molecule IDs (MI tag):\n+     *\n+     * \"0/A\" (The first molecule in the bam, top (A) strand)\n+     * \"0/B\" (The first molecule in the bam, bottom (B) strand)\n+     * \"99/A\" (100th molecule in the bam, top top (A) strand)\n+     *\n+     * Top strand is synonymous to \"F1R2\"\n+     * Bottom strand is synonymous to \"F2R1\"\n+     *\n+     * Thus only the integer component is relevant for identifying reads that originated from the same molecule.\n+     * Should the need arise, we could extend this to distinguish between different strands of the same molecule.\n+     */\n+    public static int getMoleculeID(final GATKRead read) {\n+        final String MITag = read.getAttributeAsString(FGBIO_MOLECULAR_IDENTIFIER_TAG);\n+        return Integer.parseInt(MITag.split(FGBIO_MI_TAG_DELIMITER)[0]);\n+    }\n+\n+    /** Returns true if the read was properly added to the duplicate set **/\n+    public boolean addRead(final GATKRead read){\n+        if (reads.isEmpty()){\n+            init(read);\n+            reads.add(read);\n+            return true;\n+        }\n+\n+        if (sameMolecule(read)){\n+            reads.add(read);\n+            if (read.getStart() < fragmentStart){\n+                fragmentStart = read.getStart();\n+            }\n+            if (read.getEnd() > fragmentEnd){\n+                fragmentEnd = read.getEnd();\n+            }\n+            return true;\n+        } else {\n+            return false;\n+        }\n+    }\n+\n+    public int getFragmentStart(){\n+        return fragmentStart;\n+    }\n+\n+    public int getFragmentEnd(){\n+        return fragmentEnd;\n+    }\n+\n+    public int getMoleculeId() { return moleculeId; }\n+\n+    public SimpleInterval getDuplicateSetInterval(){\n+        return new SimpleInterval(contig, fragmentStart, fragmentEnd);\n+    }\n+\n+    public boolean hasValidInterval(){\n+        return SimpleInterval.isValid(contig, fragmentStart, fragmentEnd);\n+    }\n+\n+    public static List<String> getMolecularIDs(final List<GATKRead> reads) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQyNDIyMQ=="}, "originalCommit": {"oid": "c14aa1527401cb1b4eaa1d545d1f966754403e4f"}, "originalPosition": 118}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk5MjgxMzU0", "url": "https://github.com/broadinstitute/gatk/pull/6512#pullrequestreview-399281354", "createdAt": "2020-04-23T16:39:21Z", "commit": {"oid": "231aa413502db013f8d3473355e37e2a2d784c1f"}, "state": "APPROVED", "comments": {"totalCount": 13, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yM1QxNjozOToyMlrOGKxpQw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yM1QxNjo1NzoxNFrOGKyauw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzk1MjMyMw==", "bodyText": "Wording.  This would be clearer as \"The user may choose to only keep read sets containing both strands by setting this argument to a positive number.\"\nI misread this at first as the \"read sets containing both strands will be kept ONLY if this is set to a positive number\"", "url": "https://github.com/broadinstitute/gatk/pull/6512#discussion_r413952323", "createdAt": "2020-04-23T16:39:22Z", "author": {"login": "lbergelson"}, "path": "src/main/java/org/broadinstitute/hellbender/engine/DuplicateSetWalker.java", "diffHunk": "@@ -0,0 +1,116 @@\n+package org.broadinstitute.hellbender.engine;\n+\n+import htsjdk.samtools.SAMTag;\n+import org.apache.commons.lang3.tuple.Pair;\n+import org.broadinstitute.barclay.argparser.Argument;\n+import org.broadinstitute.hellbender.exceptions.UserException;\n+import org.broadinstitute.hellbender.tools.walkers.consensus.MoleculeID;\n+import org.broadinstitute.hellbender.tools.walkers.consensus.ReadsWithSameUMI;\n+import org.broadinstitute.hellbender.utils.read.GATKRead;\n+\n+/**\n+ * A walker that processes duplicate reads that share the same Unique molecule Identifier (UMI) as a single unit.\n+ *\n+ * This tool assumes that the input bam has been sorted by UMI (the {@link SAMTag.MI} tag to be specific) with FGBio GroupReadsByUmi:\n+ * http://fulcrumgenomics.github.io/fgbio/tools/latest/GroupReadsByUmi.html\n+ */\n+public abstract class DuplicateSetWalker extends ReadWalker {\n+    public static final String MIN_REQUIRED_READS_NAME = \"min-reads\";\n+    public static final String MIN_REQUIRED_READS_PER_STRAND_NAME = \"min-per-strand-reads\";\n+\n+    private static final int DEFAULT_MINIMUM_READS_PER_SET = 1;\n+    private static final int DEFAULT_MINIMUM_READS_PER_STRAND = 0;\n+\n+    @Argument(fullName = MIN_REQUIRED_READS_NAME, doc = \"The mininum total number of reads required in the set\", optional = true)\n+    private int minimumRequiredReadsPerUMI = DEFAULT_MINIMUM_READS_PER_SET;\n+\n+    // The user may choose to keep read sets containing both strands (i.d. duplex evidence) only by setting this argument to a positive number", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "231aa413502db013f8d3473355e37e2a2d784c1f"}, "originalPosition": 27}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzk1MjcxOA==", "bodyText": "You can add a minValue = 0 here to keep it positive.", "url": "https://github.com/broadinstitute/gatk/pull/6512#discussion_r413952718", "createdAt": "2020-04-23T16:40:00Z", "author": {"login": "lbergelson"}, "path": "src/main/java/org/broadinstitute/hellbender/engine/DuplicateSetWalker.java", "diffHunk": "@@ -0,0 +1,116 @@\n+package org.broadinstitute.hellbender.engine;\n+\n+import htsjdk.samtools.SAMTag;\n+import org.apache.commons.lang3.tuple.Pair;\n+import org.broadinstitute.barclay.argparser.Argument;\n+import org.broadinstitute.hellbender.exceptions.UserException;\n+import org.broadinstitute.hellbender.tools.walkers.consensus.MoleculeID;\n+import org.broadinstitute.hellbender.tools.walkers.consensus.ReadsWithSameUMI;\n+import org.broadinstitute.hellbender.utils.read.GATKRead;\n+\n+/**\n+ * A walker that processes duplicate reads that share the same Unique molecule Identifier (UMI) as a single unit.\n+ *\n+ * This tool assumes that the input bam has been sorted by UMI (the {@link SAMTag.MI} tag to be specific) with FGBio GroupReadsByUmi:\n+ * http://fulcrumgenomics.github.io/fgbio/tools/latest/GroupReadsByUmi.html\n+ */\n+public abstract class DuplicateSetWalker extends ReadWalker {\n+    public static final String MIN_REQUIRED_READS_NAME = \"min-reads\";\n+    public static final String MIN_REQUIRED_READS_PER_STRAND_NAME = \"min-per-strand-reads\";\n+\n+    private static final int DEFAULT_MINIMUM_READS_PER_SET = 1;\n+    private static final int DEFAULT_MINIMUM_READS_PER_STRAND = 0;\n+\n+    @Argument(fullName = MIN_REQUIRED_READS_NAME, doc = \"The mininum total number of reads required in the set\", optional = true)\n+    private int minimumRequiredReadsPerUMI = DEFAULT_MINIMUM_READS_PER_SET;\n+\n+    // The user may choose to keep read sets containing both strands (i.d. duplex evidence) only by setting this argument to a positive number\n+    @Argument(fullName = MIN_REQUIRED_READS_PER_STRAND_NAME, doc = \"The mininum total number of reads in each strand\", optional = true)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "231aa413502db013f8d3473355e37e2a2d784c1f"}, "originalPosition": 28}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzk1MzA4Mg==", "bodyText": "I would add a minValue to the argument to make sure it's positive.", "url": "https://github.com/broadinstitute/gatk/pull/6512#discussion_r413953082", "createdAt": "2020-04-23T16:40:28Z", "author": {"login": "lbergelson"}, "path": "src/main/java/org/broadinstitute/hellbender/engine/DuplicateSetWalker.java", "diffHunk": "@@ -0,0 +1,116 @@\n+package org.broadinstitute.hellbender.engine;\n+\n+import htsjdk.samtools.SAMTag;\n+import org.apache.commons.lang3.tuple.Pair;\n+import org.broadinstitute.barclay.argparser.Argument;\n+import org.broadinstitute.hellbender.exceptions.UserException;\n+import org.broadinstitute.hellbender.tools.walkers.consensus.MoleculeID;\n+import org.broadinstitute.hellbender.tools.walkers.consensus.ReadsWithSameUMI;\n+import org.broadinstitute.hellbender.utils.read.GATKRead;\n+\n+/**\n+ * A walker that processes duplicate reads that share the same Unique molecule Identifier (UMI) as a single unit.\n+ *\n+ * This tool assumes that the input bam has been sorted by UMI (the {@link SAMTag.MI} tag to be specific) with FGBio GroupReadsByUmi:\n+ * http://fulcrumgenomics.github.io/fgbio/tools/latest/GroupReadsByUmi.html\n+ */\n+public abstract class DuplicateSetWalker extends ReadWalker {\n+    public static final String MIN_REQUIRED_READS_NAME = \"min-reads\";\n+    public static final String MIN_REQUIRED_READS_PER_STRAND_NAME = \"min-per-strand-reads\";\n+\n+    private static final int DEFAULT_MINIMUM_READS_PER_SET = 1;\n+    private static final int DEFAULT_MINIMUM_READS_PER_STRAND = 0;\n+\n+    @Argument(fullName = MIN_REQUIRED_READS_NAME, doc = \"The mininum total number of reads required in the set\", optional = true)\n+    private int minimumRequiredReadsPerUMI = DEFAULT_MINIMUM_READS_PER_SET;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "231aa413502db013f8d3473355e37e2a2d784c1f"}, "originalPosition": 25}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzk1NDQxNw==", "bodyText": "this comment should go on the line below, it's not about the rejection stuff", "url": "https://github.com/broadinstitute/gatk/pull/6512#discussion_r413954417", "createdAt": "2020-04-23T16:42:17Z", "author": {"login": "lbergelson"}, "path": "src/main/java/org/broadinstitute/hellbender/engine/DuplicateSetWalker.java", "diffHunk": "@@ -0,0 +1,116 @@\n+package org.broadinstitute.hellbender.engine;\n+\n+import htsjdk.samtools.SAMTag;\n+import org.apache.commons.lang3.tuple.Pair;\n+import org.broadinstitute.barclay.argparser.Argument;\n+import org.broadinstitute.hellbender.exceptions.UserException;\n+import org.broadinstitute.hellbender.tools.walkers.consensus.MoleculeID;\n+import org.broadinstitute.hellbender.tools.walkers.consensus.ReadsWithSameUMI;\n+import org.broadinstitute.hellbender.utils.read.GATKRead;\n+\n+/**\n+ * A walker that processes duplicate reads that share the same Unique molecule Identifier (UMI) as a single unit.\n+ *\n+ * This tool assumes that the input bam has been sorted by UMI (the {@link SAMTag.MI} tag to be specific) with FGBio GroupReadsByUmi:\n+ * http://fulcrumgenomics.github.io/fgbio/tools/latest/GroupReadsByUmi.html\n+ */\n+public abstract class DuplicateSetWalker extends ReadWalker {\n+    public static final String MIN_REQUIRED_READS_NAME = \"min-reads\";\n+    public static final String MIN_REQUIRED_READS_PER_STRAND_NAME = \"min-per-strand-reads\";\n+\n+    private static final int DEFAULT_MINIMUM_READS_PER_SET = 1;\n+    private static final int DEFAULT_MINIMUM_READS_PER_STRAND = 0;\n+\n+    @Argument(fullName = MIN_REQUIRED_READS_NAME, doc = \"The mininum total number of reads required in the set\", optional = true)\n+    private int minimumRequiredReadsPerUMI = DEFAULT_MINIMUM_READS_PER_SET;\n+\n+    // The user may choose to keep read sets containing both strands (i.d. duplex evidence) only by setting this argument to a positive number\n+    @Argument(fullName = MIN_REQUIRED_READS_PER_STRAND_NAME, doc = \"The mininum total number of reads in each strand\", optional = true)\n+    private int minimumRequiredReadsPerStrand = DEFAULT_MINIMUM_READS_PER_STRAND;\n+\n+    protected ReadsWithSameUMI currentReadsWithSameUMI = null;\n+\n+    /***\n+     * FGBio GroupByUMI returns reads sorted by molecule ID: For example, the input bam may look like\n+     * read1: ... MI:Z:0/A ...\n+     * read2: ... MI:Z:0/A ...\n+     * read3: ... MI:Z:0/B ...\n+     * read4: ... MI:Z:0/B ...\n+     * read5: ... MI:Z:1/A ...\n+     * read6: ... MI:Z:1/B ...\n+     * read7: ... MI:Z:1/B ...\n+     *\n+     * Thus it's sufficient to go through the reads in order and collect them in a list until\n+     * we encounter the next molecule ID, at which point we pass the list to the {@code apply} method,\n+     * process the set based on the child class's implementation of the method, and clear the {@code currentDuplicateSet} variable and start collecting reads again.\n+     *\n+     * Notice there are two apply() methods in this class:\n+     * This apply() inherited from ReadWalker is marked final to discourage subclassing.\n+     * A subclass must override the other apply() method that takes in the DuplicateSet.\n+     */\n+    @Override\n+    public final void apply(GATKRead read, ReferenceContext referenceContext, FeatureContext featureContext) {\n+        if (currentReadsWithSameUMI == null){ // evaluates to true for the very first read\n+            currentReadsWithSameUMI = new ReadsWithSameUMI(read);\n+            return;\n+        }\n+\n+        final int readMoleculeNumber = MoleculeID.getMoleculeNumberOfRead(read);\n+        final int duplicateSetMoleculeNumber = currentReadsWithSameUMI.getMoleculeNumber();\n+\n+        // If the incoming read has the molecule id less than that of the currentDuplicateSet,\n+        // the input bam is not sorted properly by the MI tag\n+        if (duplicateSetMoleculeNumber > readMoleculeNumber){\n+            throw new UserException(String.format(\"The input bam must be sorted by the molecule ID (%s) tag.\", SAMTag.MI.name()));\n+        }\n+\n+        if (duplicateSetMoleculeNumber < readMoleculeNumber) {\n+            // The incoming read's molecule ID does not match that of the current duplicate, meaning we've reached the end of the current set.\n+            // Call the apply() method to process the current set and start a new set.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "231aa413502db013f8d3473355e37e2a2d784c1f"}, "originalPosition": 69}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzk1NTI1OA==", "bodyText": "I like to put the exclusive conditions in an else block to make it clear that none of the options above fall down into this, but that's a style point that some people disagree with.", "url": "https://github.com/broadinstitute/gatk/pull/6512#discussion_r413955258", "createdAt": "2020-04-23T16:43:31Z", "author": {"login": "lbergelson"}, "path": "src/main/java/org/broadinstitute/hellbender/engine/DuplicateSetWalker.java", "diffHunk": "@@ -0,0 +1,116 @@\n+package org.broadinstitute.hellbender.engine;\n+\n+import htsjdk.samtools.SAMTag;\n+import org.apache.commons.lang3.tuple.Pair;\n+import org.broadinstitute.barclay.argparser.Argument;\n+import org.broadinstitute.hellbender.exceptions.UserException;\n+import org.broadinstitute.hellbender.tools.walkers.consensus.MoleculeID;\n+import org.broadinstitute.hellbender.tools.walkers.consensus.ReadsWithSameUMI;\n+import org.broadinstitute.hellbender.utils.read.GATKRead;\n+\n+/**\n+ * A walker that processes duplicate reads that share the same Unique molecule Identifier (UMI) as a single unit.\n+ *\n+ * This tool assumes that the input bam has been sorted by UMI (the {@link SAMTag.MI} tag to be specific) with FGBio GroupReadsByUmi:\n+ * http://fulcrumgenomics.github.io/fgbio/tools/latest/GroupReadsByUmi.html\n+ */\n+public abstract class DuplicateSetWalker extends ReadWalker {\n+    public static final String MIN_REQUIRED_READS_NAME = \"min-reads\";\n+    public static final String MIN_REQUIRED_READS_PER_STRAND_NAME = \"min-per-strand-reads\";\n+\n+    private static final int DEFAULT_MINIMUM_READS_PER_SET = 1;\n+    private static final int DEFAULT_MINIMUM_READS_PER_STRAND = 0;\n+\n+    @Argument(fullName = MIN_REQUIRED_READS_NAME, doc = \"The mininum total number of reads required in the set\", optional = true)\n+    private int minimumRequiredReadsPerUMI = DEFAULT_MINIMUM_READS_PER_SET;\n+\n+    // The user may choose to keep read sets containing both strands (i.d. duplex evidence) only by setting this argument to a positive number\n+    @Argument(fullName = MIN_REQUIRED_READS_PER_STRAND_NAME, doc = \"The mininum total number of reads in each strand\", optional = true)\n+    private int minimumRequiredReadsPerStrand = DEFAULT_MINIMUM_READS_PER_STRAND;\n+\n+    protected ReadsWithSameUMI currentReadsWithSameUMI = null;\n+\n+    /***\n+     * FGBio GroupByUMI returns reads sorted by molecule ID: For example, the input bam may look like\n+     * read1: ... MI:Z:0/A ...\n+     * read2: ... MI:Z:0/A ...\n+     * read3: ... MI:Z:0/B ...\n+     * read4: ... MI:Z:0/B ...\n+     * read5: ... MI:Z:1/A ...\n+     * read6: ... MI:Z:1/B ...\n+     * read7: ... MI:Z:1/B ...\n+     *\n+     * Thus it's sufficient to go through the reads in order and collect them in a list until\n+     * we encounter the next molecule ID, at which point we pass the list to the {@code apply} method,\n+     * process the set based on the child class's implementation of the method, and clear the {@code currentDuplicateSet} variable and start collecting reads again.\n+     *\n+     * Notice there are two apply() methods in this class:\n+     * This apply() inherited from ReadWalker is marked final to discourage subclassing.\n+     * A subclass must override the other apply() method that takes in the DuplicateSet.\n+     */\n+    @Override\n+    public final void apply(GATKRead read, ReferenceContext referenceContext, FeatureContext featureContext) {\n+        if (currentReadsWithSameUMI == null){ // evaluates to true for the very first read\n+            currentReadsWithSameUMI = new ReadsWithSameUMI(read);\n+            return;\n+        }\n+\n+        final int readMoleculeNumber = MoleculeID.getMoleculeNumberOfRead(read);\n+        final int duplicateSetMoleculeNumber = currentReadsWithSameUMI.getMoleculeNumber();\n+\n+        // If the incoming read has the molecule id less than that of the currentDuplicateSet,\n+        // the input bam is not sorted properly by the MI tag\n+        if (duplicateSetMoleculeNumber > readMoleculeNumber){\n+            throw new UserException(String.format(\"The input bam must be sorted by the molecule ID (%s) tag.\", SAMTag.MI.name()));\n+        }\n+\n+        if (duplicateSetMoleculeNumber < readMoleculeNumber) {\n+            // The incoming read's molecule ID does not match that of the current duplicate, meaning we've reached the end of the current set.\n+            // Call the apply() method to process the current set and start a new set.\n+            if (rejectSet(currentReadsWithSameUMI)){\n+                currentReadsWithSameUMI = new ReadsWithSameUMI(read);\n+                return;\n+            }\n+\n+            apply(currentReadsWithSameUMI,\n+                    new ReferenceContext(reference, currentReadsWithSameUMI.getInterval()), // Will create an empty ReferenceContext if reference or readInterval == null\n+                    new FeatureContext(features, currentReadsWithSameUMI.getInterval()));\n+            currentReadsWithSameUMI = new ReadsWithSameUMI(read);\n+            return;\n+        }\n+\n+        // The incoming read has the same UMI as the current set; simply add to the current set", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "231aa413502db013f8d3473355e37e2a2d784c1f"}, "originalPosition": 82}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzk1NTc2Mg==", "bodyText": "Is there a todo to make this smarter in the future or is % a good enough check?", "url": "https://github.com/broadinstitute/gatk/pull/6512#discussion_r413955762", "createdAt": "2020-04-23T16:44:16Z", "author": {"login": "lbergelson"}, "path": "src/main/java/org/broadinstitute/hellbender/engine/DuplicateSetWalker.java", "diffHunk": "@@ -0,0 +1,116 @@\n+package org.broadinstitute.hellbender.engine;\n+\n+import htsjdk.samtools.SAMTag;\n+import org.apache.commons.lang3.tuple.Pair;\n+import org.broadinstitute.barclay.argparser.Argument;\n+import org.broadinstitute.hellbender.exceptions.UserException;\n+import org.broadinstitute.hellbender.tools.walkers.consensus.MoleculeID;\n+import org.broadinstitute.hellbender.tools.walkers.consensus.ReadsWithSameUMI;\n+import org.broadinstitute.hellbender.utils.read.GATKRead;\n+\n+/**\n+ * A walker that processes duplicate reads that share the same Unique molecule Identifier (UMI) as a single unit.\n+ *\n+ * This tool assumes that the input bam has been sorted by UMI (the {@link SAMTag.MI} tag to be specific) with FGBio GroupReadsByUmi:\n+ * http://fulcrumgenomics.github.io/fgbio/tools/latest/GroupReadsByUmi.html\n+ */\n+public abstract class DuplicateSetWalker extends ReadWalker {\n+    public static final String MIN_REQUIRED_READS_NAME = \"min-reads\";\n+    public static final String MIN_REQUIRED_READS_PER_STRAND_NAME = \"min-per-strand-reads\";\n+\n+    private static final int DEFAULT_MINIMUM_READS_PER_SET = 1;\n+    private static final int DEFAULT_MINIMUM_READS_PER_STRAND = 0;\n+\n+    @Argument(fullName = MIN_REQUIRED_READS_NAME, doc = \"The mininum total number of reads required in the set\", optional = true)\n+    private int minimumRequiredReadsPerUMI = DEFAULT_MINIMUM_READS_PER_SET;\n+\n+    // The user may choose to keep read sets containing both strands (i.d. duplex evidence) only by setting this argument to a positive number\n+    @Argument(fullName = MIN_REQUIRED_READS_PER_STRAND_NAME, doc = \"The mininum total number of reads in each strand\", optional = true)\n+    private int minimumRequiredReadsPerStrand = DEFAULT_MINIMUM_READS_PER_STRAND;\n+\n+    protected ReadsWithSameUMI currentReadsWithSameUMI = null;\n+\n+    /***\n+     * FGBio GroupByUMI returns reads sorted by molecule ID: For example, the input bam may look like\n+     * read1: ... MI:Z:0/A ...\n+     * read2: ... MI:Z:0/A ...\n+     * read3: ... MI:Z:0/B ...\n+     * read4: ... MI:Z:0/B ...\n+     * read5: ... MI:Z:1/A ...\n+     * read6: ... MI:Z:1/B ...\n+     * read7: ... MI:Z:1/B ...\n+     *\n+     * Thus it's sufficient to go through the reads in order and collect them in a list until\n+     * we encounter the next molecule ID, at which point we pass the list to the {@code apply} method,\n+     * process the set based on the child class's implementation of the method, and clear the {@code currentDuplicateSet} variable and start collecting reads again.\n+     *\n+     * Notice there are two apply() methods in this class:\n+     * This apply() inherited from ReadWalker is marked final to discourage subclassing.\n+     * A subclass must override the other apply() method that takes in the DuplicateSet.\n+     */\n+    @Override\n+    public final void apply(GATKRead read, ReferenceContext referenceContext, FeatureContext featureContext) {\n+        if (currentReadsWithSameUMI == null){ // evaluates to true for the very first read\n+            currentReadsWithSameUMI = new ReadsWithSameUMI(read);\n+            return;\n+        }\n+\n+        final int readMoleculeNumber = MoleculeID.getMoleculeNumberOfRead(read);\n+        final int duplicateSetMoleculeNumber = currentReadsWithSameUMI.getMoleculeNumber();\n+\n+        // If the incoming read has the molecule id less than that of the currentDuplicateSet,\n+        // the input bam is not sorted properly by the MI tag\n+        if (duplicateSetMoleculeNumber > readMoleculeNumber){\n+            throw new UserException(String.format(\"The input bam must be sorted by the molecule ID (%s) tag.\", SAMTag.MI.name()));\n+        }\n+\n+        if (duplicateSetMoleculeNumber < readMoleculeNumber) {\n+            // The incoming read's molecule ID does not match that of the current duplicate, meaning we've reached the end of the current set.\n+            // Call the apply() method to process the current set and start a new set.\n+            if (rejectSet(currentReadsWithSameUMI)){\n+                currentReadsWithSameUMI = new ReadsWithSameUMI(read);\n+                return;\n+            }\n+\n+            apply(currentReadsWithSameUMI,\n+                    new ReferenceContext(reference, currentReadsWithSameUMI.getInterval()), // Will create an empty ReferenceContext if reference or readInterval == null\n+                    new FeatureContext(features, currentReadsWithSameUMI.getInterval()));\n+            currentReadsWithSameUMI = new ReadsWithSameUMI(read);\n+            return;\n+        }\n+\n+        // The incoming read has the same UMI as the current set; simply add to the current set\n+        currentReadsWithSameUMI.addRead(read);\n+    }\n+\n+    /**\n+     * A subclass must specify how to process the duplicate sets by overriding this method.\n+     *\n+     * @param readsWithSameUMI A set of reads with the matching UMIs with the same fragment start and end\n+     * @param referenceContext A reference context object over the intervals determined by the duplicate set.\n+     * @param featureContext Entries from a secondary feature file (e.g. vcf) if provided\n+     *\n+     */\n+    public abstract void apply(ReadsWithSameUMI readsWithSameUMI, ReferenceContext referenceContext, FeatureContext featureContext );\n+\n+\n+    /**\n+     * Returns true for duplicate sets that does not meet required criteria for further processing.\n+     * We encourage the user to override this method to meet their needs.\n+     */\n+    protected boolean rejectSet(final ReadsWithSameUMI readsWithSameUMI){\n+        // Check that the set contains the minimum required number of reads in each strand\n+        final Pair<Integer, Integer> strandCounts = MoleculeID.countStrands(readsWithSameUMI.getReads());\n+        if (Math.min(strandCounts.getLeft(), strandCounts.getRight()) < minimumRequiredReadsPerStrand){\n+            return true;\n+        }\n+\n+        // Check that the read set is paired (this check may not reject some sets that contain unpaired reads)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "231aa413502db013f8d3473355e37e2a2d784c1f"}, "originalPosition": 108}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzk1NjczOA==", "bodyText": "This is a bit inconsistent with the rest of the framework.  Lets consider changing this in a future refactor.", "url": "https://github.com/broadinstitute/gatk/pull/6512#discussion_r413956738", "createdAt": "2020-04-23T16:45:39Z", "author": {"login": "lbergelson"}, "path": "src/main/java/org/broadinstitute/hellbender/engine/DuplicateSetWalker.java", "diffHunk": "@@ -0,0 +1,130 @@\n+package org.broadinstitute.hellbender.engine;\n+\n+import htsjdk.samtools.SAMTag;\n+import org.apache.commons.lang3.tuple.Pair;\n+import org.broadinstitute.barclay.argparser.Argument;\n+import org.broadinstitute.hellbender.exceptions.UserException;\n+import org.broadinstitute.hellbender.tools.walkers.consensus.MoleculeID;\n+import org.broadinstitute.hellbender.tools.walkers.consensus.ReadsWithSameUMI;\n+import org.broadinstitute.hellbender.utils.read.GATKRead;\n+\n+/**\n+ * A walker that processes duplicate reads that share the same Unique molecule Identifier (UMI) as a single unit.\n+ *\n+ * This tool assumes that the input bam has been sorted by UMI (the {@link SAMTag.MI} tag to be specific) with FGBio GroupReadsByUmi:\n+ * http://fulcrumgenomics.github.io/fgbio/tools/latest/GroupReadsByUmi.html\n+ */\n+public abstract class DuplicateSetWalker extends ReadWalker {\n+    public static final String MIN_REQUIRED_READS_NAME = \"min-reads\";\n+    public static final String MIN_REQUIRED_READS_PER_STRAND_NAME = \"min-per-strand-reads\";\n+\n+    private static final int DEFAULT_MINIMUM_READS_PER_SET = 1;\n+    private static final int DEFAULT_MINIMUM_READS_PER_STRAND = 0;\n+\n+    @Argument(fullName = MIN_REQUIRED_READS_NAME, doc = \"The mininum total number of reads required in the set\", optional = true)\n+    private int minimumRequiredReadsPerUMI = DEFAULT_MINIMUM_READS_PER_SET;\n+\n+    // The user may choose to keep read sets containing both strands (i.d. duplex evidence) only by setting this argument to a positive number\n+    @Argument(fullName = MIN_REQUIRED_READS_PER_STRAND_NAME, doc = \"The mininum total number of reads in each strand\", optional = true)\n+    private int minimumRequiredReadsPerStrand = DEFAULT_MINIMUM_READS_PER_STRAND;\n+\n+    protected ReadsWithSameUMI currentReadsWithSameUMI = null;\n+\n+    /***\n+     * FGBio GroupByUMI returns reads sorted by molecule ID: For example, the input bam may look like\n+     * read1: ... MI:Z:0/A ...\n+     * read2: ... MI:Z:0/A ...\n+     * read3: ... MI:Z:0/B ...\n+     * read4: ... MI:Z:0/B ...\n+     * read5: ... MI:Z:1/A ...\n+     * read6: ... MI:Z:1/B ...\n+     * read7: ... MI:Z:1/B ...\n+     *\n+     * Thus it's sufficient to go through the reads in order and collect them in a list until\n+     * we encounter the next molecule ID, at which point we pass the list to the {@code apply} method,\n+     * process the set based on the child class's implementation of the method, and clear the {@code currentDuplicateSet} variable and start collecting reads again.\n+     *\n+     * Notice there are two apply() methods in this class:\n+     * This apply() inherited from ReadWalker is marked final to discourage subclassing.\n+     * A subclass must override the other apply() method that takes in the DuplicateSet.\n+     */\n+    @Override\n+    public final void apply(GATKRead read, ReferenceContext referenceContext, FeatureContext featureContext) {\n+        if (currentReadsWithSameUMI == null){ // evaluates to true for the very first read\n+            currentReadsWithSameUMI = new ReadsWithSameUMI(read);\n+            return;\n+        }\n+\n+        final int readMoleculeNumber = MoleculeID.getMoleculeNumberOfRead(read);\n+        final int duplicateSetMoleculeNumber = currentReadsWithSameUMI.getMoleculeNumber();\n+\n+        // If the incoming read has the molecule id less than that of the currentDuplicateSet,\n+        // the input bam is not sorted properly by the MI tag\n+        if (duplicateSetMoleculeNumber > readMoleculeNumber){\n+            throw new UserException(String.format(\"The input bam must be sorted by the molecule ID (%s) tag.\", SAMTag.MI.name()));\n+        }\n+\n+        if (duplicateSetMoleculeNumber < readMoleculeNumber) {\n+            // The incoming read's molecule ID does not match that of the current duplicate, meaning we've reached the end of the current set.\n+            // Call the apply() method to process the current set and start a new set.\n+            if (rejectSet(currentReadsWithSameUMI)){\n+                currentReadsWithSameUMI = new ReadsWithSameUMI(read);\n+                return;\n+            }\n+\n+            apply(currentReadsWithSameUMI,\n+                    new ReferenceContext(reference, currentReadsWithSameUMI.getInterval()), // Will create an empty ReferenceContext if reference or readInterval == null\n+                    new FeatureContext(features, currentReadsWithSameUMI.getInterval()));\n+            currentReadsWithSameUMI = new ReadsWithSameUMI(read);\n+            return;\n+        }\n+\n+        // The incoming read has the same UMI as the current set; simply add to the current set\n+        currentReadsWithSameUMI.addRead(read);\n+    }\n+\n+    /**\n+     * A subclass must specify how to process the duplicate sets by overriding this method.\n+     *\n+     * @param readsWithSameUMI A set of reads with the matching UMIs with the same fragment start and end\n+     * @param referenceContext A reference context object over the intervals determined by the duplicate set.\n+     * @param featureContext Entries from a secondary feature file (e.g. vcf) if provided\n+     *\n+     */\n+    public abstract void apply(ReadsWithSameUMI readsWithSameUMI, ReferenceContext referenceContext, FeatureContext featureContext );\n+\n+    /**\n+     * A child tool class that override onTraversalSuccess() *must* call super.onTraversalSuccess() in order", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2c29d8cda026a2b54bb2b3ee37eba031bf8cfda0"}, "originalPosition": 97}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzk1NzIyNw==", "bodyText": "Some pointless leftover whitespace changes.", "url": "https://github.com/broadinstitute/gatk/pull/6512#discussion_r413957227", "createdAt": "2020-04-23T16:46:20Z", "author": {"login": "lbergelson"}, "path": "src/main/java/org/broadinstitute/hellbender/engine/ReadWalker.java", "diffHunk": "@@ -99,7 +99,6 @@ public void traverse() {\n \n                     progressMeter.update(readInterval);\n                 });\n-\n         logger.info(countedFilter.getSummaryLine());\n     }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2c29d8cda026a2b54bb2b3ee37eba031bf8cfda0"}, "originalPosition": 6}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzk1ODEwOQ==", "bodyText": "I would just initialize this where you declare rng and make the variable final.", "url": "https://github.com/broadinstitute/gatk/pull/6512#discussion_r413958109", "createdAt": "2020-04-23T16:47:36Z", "author": {"login": "lbergelson"}, "path": "src/main/java/org/broadinstitute/hellbender/tools/walkers/consensus/DownsampleByDuplicateSet.java", "diffHunk": "@@ -0,0 +1,102 @@\n+package org.broadinstitute.hellbender.tools.walkers.consensus;\n+\n+import org.broadinstitute.barclay.argparser.Argument;\n+import org.broadinstitute.barclay.argparser.CommandLineProgramProperties;\n+import org.broadinstitute.hellbender.cmdline.StandardArgumentDefinitions;\n+import org.broadinstitute.hellbender.engine.DuplicateSetWalker;\n+import org.broadinstitute.hellbender.engine.FeatureContext;\n+import org.broadinstitute.hellbender.engine.GATKPathSpecifier;\n+import org.broadinstitute.hellbender.engine.ReferenceContext;\n+import org.broadinstitute.hellbender.utils.read.SAMFileGATKReadWriter;\n+import picard.cmdline.programgroups.ReadDataManipulationProgramGroup;\n+\n+import java.util.Random;\n+\n+@CommandLineProgramProperties(\n+        summary = \"Discard a set fraction of duplicate sets from a UMI-grouped bam\",\n+        oneLineSummary = \"Discard a set fraction of duplicate sets from a UMI-grouped bam\",\n+        programGroup = ReadDataManipulationProgramGroup.class\n+)\n+/**\n+ * Given a bam grouped by the same unique molecular identifier (UMI), this tool drops a specified fraction of duplicate sets and returns a new bam.\n+ * A duplicate set refers to a group of reads whose fragments start and end at the same genomic coordinate _and_ share the same UMI.\n+ *\n+ * The input bam must first be sorted by UMI using FGBio GroupReadsByUmi (http://fulcrumgenomics.github.io/fgbio/tools/latest/GroupReadsByUmi.html).\n+ *\n+ * Use this tool to create, for instance, an insilico mixture of duplex-sequenced samples to simulate tumor subclones.\n+ *\n+ * Suppose you wish to simulate a tumor sample in which 5% cells share a common set of somatic mutations\n+ * in addition to ones common to the entire cell population.\n+ *\n+ * If you randomly drop 5% of reads in sample A and 95% of reads in sample B and merge the reduced bams,\n+ * the resulting mixture skews the family-size distribution to the left. Here the family size refers to the\n+ * number of sequenced duplicate reads that share the same UMI.\n+ *\n+ * To see this, take a cancer sample, in which 5% of cells share a unique set of somatic mutations,\n+ * that was processed with duplex-UMIs (i.e. UMIs on both adapters) and high rounds of PCR. Suppose we have the sequence-ready\n+ * libraries of this sample attached to and amplified on the flowcell. Now, sort the flowcell lawn such that the reads from the above\n+ * 5% of the cell population moves near the top of the flowcell. This population must have the same family-size distribution as\n+ * the rest of the flowcell, at about 5% of the library complexity compared to the entire flowcell.\n+ *\n+ * Now imagine replacing this population with 5% ramdonly chosen from the *entire* flowcell of another sample that was prepared and sequenced similarly.\n+ * The library complexity of these \"graft\" reads is higher than that of the original, and, consequently, with other parameters\n+ * such as the number of PCR cycles and sequencing depth fixed, its family distribution would be skewed left---that is, the family size\n+ * would be smaller than it should be.\n+ *\n+ * This tool will help address the above problem by dropping a set fraction of _molecules_, or duplicate sets, rather than reads, at random.\n+ *\n+ * Example Usage:\n+ *\n+ * Keep 95 percent of the molecules.\n+ *\n+ * gatk DownsampleByDuplicateSet \\ \\\n+ * -I umiGrouped.bam \\\n+ * --fraction-to-keep 0.95 \\\n+ * -O umiGrouped_0.95.bam\n+ **/\n+public class DownsampleByDuplicateSet extends DuplicateSetWalker {\n+    @Argument(fullName = StandardArgumentDefinitions.OUTPUT_LONG_NAME, shortName = StandardArgumentDefinitions.OUTPUT_SHORT_NAME, doc = \"\")\n+    public GATKPathSpecifier outputBam;\n+\n+    public static final String FRACTION_TO_KEEP_NAME = \"fraction-to-keep\";\n+    @Argument(fullName = FRACTION_TO_KEEP_NAME, doc = \"This fraction of molecules in the input bam will be retained\", minValue = 0.0, maxValue = 1.0)\n+    public double fractionToKeep;\n+\n+    private static final int RANDOM_SEED = 142;\n+    private Random rng;\n+    private int numDuplicateReadSets;\n+    private int numReads;\n+    private SAMFileGATKReadWriter outputWriter;\n+\n+    @Override\n+    public void onTraversalStart() {\n+        rng = new Random(RANDOM_SEED);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2c29d8cda026a2b54bb2b3ee37eba031bf8cfda0"}, "originalPosition": 73}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzk1OTEwNg==", "bodyText": "These should probably have javadoc too even though they're pretty self explanatory.", "url": "https://github.com/broadinstitute/gatk/pull/6512#discussion_r413959106", "createdAt": "2020-04-23T16:49:04Z", "author": {"login": "lbergelson"}, "path": "src/main/java/org/broadinstitute/hellbender/tools/walkers/consensus/MoleculeID.java", "diffHunk": "@@ -0,0 +1,65 @@\n+package org.broadinstitute.hellbender.tools.walkers.consensus;\n+\n+import htsjdk.samtools.SAMTag;\n+import org.apache.commons.lang3.tuple.ImmutablePair;\n+import org.apache.commons.lang3.tuple.Pair;\n+import org.broadinstitute.hellbender.utils.read.GATKRead;\n+\n+import java.util.List;\n+\n+/**\n+ * A container class for the molecule ID, which consists of an integer ID and a binary strand.\n+ * For example, Reads with the tags 12/A and 12/B originated from the same DNA fragment before PCR,\n+ * (i.e. from the same library) but they originated from different strands in that library.\n+ * In other words, one read is F1R2 and the other F2R1.\n+ *\n+ * The word \"molecule\" here refers to the original DNA fragment with barcode before undergoing\n+ * PCR and sequencing. We amplify this molecule through PCR and end up with many duplicate _fragments_.\n+ */\n+public class MoleculeID {\n+    private int moleculeNumber;\n+    private String strand;\n+\n+    public MoleculeID(final GATKRead read){\n+        this.moleculeNumber = getMoleculeNumberOfRead(read);\n+        this.strand = getStrandOfRead(read);\n+    }\n+\n+    public MoleculeID(final int moleculeNumber, final String strand){\n+        this.moleculeNumber = moleculeNumber;\n+        this.strand = strand;\n+    }\n+\n+    public int getMoleculeNumber() {\n+        return moleculeNumber;\n+    }\n+\n+    public String getStrand() {\n+        return strand;\n+    }\n+\n+    /** Format the molecule ID as stored in the sam/bam/cram file under the {@link SAMTag.MI} tag **/\n+    public String getSAMField(){\n+        return moleculeNumber + ReadsWithSameUMI.FGBIO_MI_TAG_DELIMITER + strand;\n+    }\n+\n+    public static int getMoleculeNumberOfRead(final GATKRead read){", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2c29d8cda026a2b54bb2b3ee37eba031bf8cfda0"}, "originalPosition": 46}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzk2MTE1OQ==", "bodyText": "There's definitely a more efficient way of doing this that only loops through once but this is fine.", "url": "https://github.com/broadinstitute/gatk/pull/6512#discussion_r413961159", "createdAt": "2020-04-23T16:51:53Z", "author": {"login": "lbergelson"}, "path": "src/main/java/org/broadinstitute/hellbender/tools/walkers/consensus/MoleculeID.java", "diffHunk": "@@ -0,0 +1,65 @@\n+package org.broadinstitute.hellbender.tools.walkers.consensus;\n+\n+import htsjdk.samtools.SAMTag;\n+import org.apache.commons.lang3.tuple.ImmutablePair;\n+import org.apache.commons.lang3.tuple.Pair;\n+import org.broadinstitute.hellbender.utils.read.GATKRead;\n+\n+import java.util.List;\n+\n+/**\n+ * A container class for the molecule ID, which consists of an integer ID and a binary strand.\n+ * For example, Reads with the tags 12/A and 12/B originated from the same DNA fragment before PCR,\n+ * (i.e. from the same library) but they originated from different strands in that library.\n+ * In other words, one read is F1R2 and the other F2R1.\n+ *\n+ * The word \"molecule\" here refers to the original DNA fragment with barcode before undergoing\n+ * PCR and sequencing. We amplify this molecule through PCR and end up with many duplicate _fragments_.\n+ */\n+public class MoleculeID {\n+    private int moleculeNumber;\n+    private String strand;\n+\n+    public MoleculeID(final GATKRead read){\n+        this.moleculeNumber = getMoleculeNumberOfRead(read);\n+        this.strand = getStrandOfRead(read);\n+    }\n+\n+    public MoleculeID(final int moleculeNumber, final String strand){\n+        this.moleculeNumber = moleculeNumber;\n+        this.strand = strand;\n+    }\n+\n+    public int getMoleculeNumber() {\n+        return moleculeNumber;\n+    }\n+\n+    public String getStrand() {\n+        return strand;\n+    }\n+\n+    /** Format the molecule ID as stored in the sam/bam/cram file under the {@link SAMTag.MI} tag **/\n+    public String getSAMField(){\n+        return moleculeNumber + ReadsWithSameUMI.FGBIO_MI_TAG_DELIMITER + strand;\n+    }\n+\n+    public static int getMoleculeNumberOfRead(final GATKRead read){\n+        final String MITag = read.getAttributeAsString(SAMTag.MI.name());\n+        return Integer.parseInt(MITag.split(ReadsWithSameUMI.FGBIO_MI_TAG_DELIMITER)[0]);\n+    }\n+\n+    public static String getStrandOfRead(final GATKRead read){\n+        final String MITag = read.getAttributeAsString(SAMTag.MI.name());\n+        return MITag.split(ReadsWithSameUMI.FGBIO_MI_TAG_DELIMITER)[1];\n+    }\n+\n+    /**\n+     * Assumes that the input reads have the same molecule number in the {@link SAMTag.MI} tag\n+     * @returns Counts of reads from each strand, the first element is always larger than the second\n+     **/\n+    public static Pair<Integer, Integer> countStrands(final List<GATKRead> reads){\n+        final int strandACount = (int) reads.stream().filter(r -> getStrandOfRead(r).equals(\"A\")).count();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2c29d8cda026a2b54bb2b3ee37eba031bf8cfda0"}, "originalPosition": 61}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzk2NDAxOQ==", "bodyText": "There's a interval.contigsMatch(read) method that makes this slightly less verbose (and could be implemented slightly more efficiently than getContig.equals(getContig) in some cases.", "url": "https://github.com/broadinstitute/gatk/pull/6512#discussion_r413964019", "createdAt": "2020-04-23T16:55:59Z", "author": {"login": "lbergelson"}, "path": "src/main/java/org/broadinstitute/hellbender/tools/walkers/consensus/ReadsWithSameUMI.java", "diffHunk": "@@ -0,0 +1,106 @@\n+package org.broadinstitute.hellbender.tools.walkers.consensus;\n+\n+import htsjdk.samtools.SAMTag;\n+import htsjdk.samtools.util.Locatable;\n+import org.broadinstitute.hellbender.utils.SimpleInterval;\n+import org.broadinstitute.hellbender.utils.Utils;\n+import org.broadinstitute.hellbender.utils.read.GATKRead;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * A container class for a set of reads that share the same unique molecular identifier (UMI) as judged by\n+ * FGBio GroupReadsByUmi (http://fulcrumgenomics.github.io/fgbio/tools/latest/GroupReadsByUmi.html)\n+ *\n+ * Examples of molecule IDs (MI tag):\n+ *\n+ * \"0/A\" (The first molecule in the bam, A strand)\n+ * \"0/B\" (The first molecule in the bam, B strand)\n+ * \"99/A\" (100th molecule in the bam, A strand)\n+ *\n+ * For a given set of reads with the same molecule number, the strand with a larger number of reads is defined as the A strand.\n+ * i.e. A and B strand doesn't map to top or bottom strand.\n+ *\n+ * I use \"top strand\" as a synonym for \"F1R2\". \"Bottom strand\" is synonymous to \"F2R1.\"\n+ *\n+ * Thus only the integer component is relevant for identifying reads that originated from the same molecule.\n+ * Should the need arise, we could extend this to distinguish between different strands of the same molecule.\n+ *\n+ * All reads in the set must share the same molecular number; this allows for reads that originated from the same fragment before PCR\n+ * but from the different strands to be grouped in the same set.\n+ * For instance, 1/A and 1/B may be in the same set, as they share the same UMI.\n+ * But 2/A and 3/A may not be in the same set.\n+ */\n+public class ReadsWithSameUMI implements Locatable {\n+    public static final String FGBIO_MI_TAG_DELIMITER = \"/\";\n+    public MoleculeID moleculeID;\n+\n+    private SimpleInterval interval;\n+\n+    private List<GATKRead> reads;\n+\n+    public ReadsWithSameUMI(final GATKRead read){\n+        reads = new ArrayList<>();\n+        init(read);\n+    }\n+\n+    private void init(GATKRead read){\n+        Utils.validate(reads.isEmpty(), String.format(\"Initializing a non-empty set\"));\n+        moleculeID = new MoleculeID(read);\n+        interval = new SimpleInterval(read.getContig(), read.getStart(), read.getEnd());\n+        reads.add(read);\n+    }\n+\n+    public List<GATKRead> getReads(){\n+        return Collections.unmodifiableList(reads);\n+    }\n+\n+    /**\n+     * Add a read to the set. Throws an error if the molecule ID doens't match.\n+     * **/\n+    public void addRead(final GATKRead read){\n+        Utils.validate(reads.isEmpty() || moleculeID.getMoleculeNumber() == MoleculeID.getMoleculeNumberOfRead(read),\n+                String.format(\"Molecule number of the set and that of the new read don't match: set number = %d, read number = %d\", moleculeID.getMoleculeNumber(), MoleculeID.getMoleculeNumberOfRead(read)));\n+        Utils.validate(interval.getContig().equals(read.getContig()),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2c29d8cda026a2b54bb2b3ee37eba031bf8cfda0"}, "originalPosition": 67}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzk2NDk4Nw==", "bodyText": "I think you can just write this as new SimpleInterval(read)", "url": "https://github.com/broadinstitute/gatk/pull/6512#discussion_r413964987", "createdAt": "2020-04-23T16:57:14Z", "author": {"login": "lbergelson"}, "path": "src/main/java/org/broadinstitute/hellbender/tools/walkers/consensus/ReadsWithSameUMI.java", "diffHunk": "@@ -0,0 +1,106 @@\n+package org.broadinstitute.hellbender.tools.walkers.consensus;\n+\n+import htsjdk.samtools.SAMTag;\n+import htsjdk.samtools.util.Locatable;\n+import org.broadinstitute.hellbender.utils.SimpleInterval;\n+import org.broadinstitute.hellbender.utils.Utils;\n+import org.broadinstitute.hellbender.utils.read.GATKRead;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * A container class for a set of reads that share the same unique molecular identifier (UMI) as judged by\n+ * FGBio GroupReadsByUmi (http://fulcrumgenomics.github.io/fgbio/tools/latest/GroupReadsByUmi.html)\n+ *\n+ * Examples of molecule IDs (MI tag):\n+ *\n+ * \"0/A\" (The first molecule in the bam, A strand)\n+ * \"0/B\" (The first molecule in the bam, B strand)\n+ * \"99/A\" (100th molecule in the bam, A strand)\n+ *\n+ * For a given set of reads with the same molecule number, the strand with a larger number of reads is defined as the A strand.\n+ * i.e. A and B strand doesn't map to top or bottom strand.\n+ *\n+ * I use \"top strand\" as a synonym for \"F1R2\". \"Bottom strand\" is synonymous to \"F2R1.\"\n+ *\n+ * Thus only the integer component is relevant for identifying reads that originated from the same molecule.\n+ * Should the need arise, we could extend this to distinguish between different strands of the same molecule.\n+ *\n+ * All reads in the set must share the same molecular number; this allows for reads that originated from the same fragment before PCR\n+ * but from the different strands to be grouped in the same set.\n+ * For instance, 1/A and 1/B may be in the same set, as they share the same UMI.\n+ * But 2/A and 3/A may not be in the same set.\n+ */\n+public class ReadsWithSameUMI implements Locatable {\n+    public static final String FGBIO_MI_TAG_DELIMITER = \"/\";\n+    public MoleculeID moleculeID;\n+\n+    private SimpleInterval interval;\n+\n+    private List<GATKRead> reads;\n+\n+    public ReadsWithSameUMI(final GATKRead read){\n+        reads = new ArrayList<>();\n+        init(read);\n+    }\n+\n+    private void init(GATKRead read){\n+        Utils.validate(reads.isEmpty(), String.format(\"Initializing a non-empty set\"));\n+        moleculeID = new MoleculeID(read);\n+        interval = new SimpleInterval(read.getContig(), read.getStart(), read.getEnd());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2c29d8cda026a2b54bb2b3ee37eba031bf8cfda0"}, "originalPosition": 53}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "44557b96b5c930b9afe281b4f1d626ae4fac14cf", "author": {"user": {"login": "takutosato", "name": "Takuto Sato"}}, "url": "https://github.com/broadinstitute/gatk/commit/44557b96b5c930b9afe281b4f1d626ae4fac14cf", "committedDate": "2020-04-23T20:26:53Z", "message": "A new tool to randomly sample a fraction of an input bam sorted by UMI."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "5ce14120aa02124c17f4eaedf68a5471dce79ecd", "author": {"user": {"login": "takutosato", "name": "Takuto Sato"}}, "url": "https://github.com/broadinstitute/gatk/commit/5ce14120aa02124c17f4eaedf68a5471dce79ecd", "committedDate": "2020-04-23T20:11:21Z", "message": "boy scout rule"}, "afterCommit": {"oid": "44557b96b5c930b9afe281b4f1d626ae4fac14cf", "author": {"user": {"login": "takutosato", "name": "Takuto Sato"}}, "url": "https://github.com/broadinstitute/gatk/commit/44557b96b5c930b9afe281b4f1d626ae4fac14cf", "committedDate": "2020-04-23T20:26:53Z", "message": "A new tool to randomly sample a fraction of an input bam sorted by UMI."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk5NTEzMjE4", "url": "https://github.com/broadinstitute/gatk/pull/6512#pullrequestreview-399513218", "createdAt": "2020-04-23T22:11:28Z", "commit": {"oid": "44557b96b5c930b9afe281b4f1d626ae4fac14cf"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2816, "cost": 1, "resetAt": "2021-11-01T13:07:16Z"}}}