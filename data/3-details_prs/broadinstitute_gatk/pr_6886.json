{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTAzNTM0Mzky", "number": 6886, "title": "Added functionality to better handle indels/spanning deletions in the cigar base quality adjustment code.", "bodyText": "I have observed the method adjustQualsOfOverlappingPairedFragments() has a tendency to penalize reads that might have indels relative to each-other. This branch aims to better handle the edge cases that come up when mates have mismatching numbers of bases at the start or end of the reads relative to each-other. As part of #6634 I fixed this behavior somewhat and I am pulling this out into a separate branch in order to ease the comparison for that PR.", "createdAt": "2020-10-14T17:35:54Z", "url": "https://github.com/broadinstitute/gatk/pull/6886", "merged": true, "mergeCommit": {"oid": "1dadcc6064d0e8cd14fe20d68a1281b1383cf0c7"}, "closed": true, "closedAt": "2020-10-15T18:19:00Z", "author": {"login": "jamesemery"}, "timelineItems": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdSgrhHAH2gAyNTAzNTM0MzkyOmNjN2EyMWMwOGIxNDkzN2I1NDAwZmY4ZmUwZTU4ZDRjZmZhOTQwYzg=", "endCursor": "Y3Vyc29yOnYyOpPPAAABdS0xFegFqTUwOTU4NDQ0NQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "cc7a21c08b14937b5400ff8fe0e58d4cffa940c8", "author": {"user": {"login": "jamesemery", "name": null}}, "url": "https://github.com/broadinstitute/gatk/commit/cc7a21c08b14937b5400ff8fe0e58d4cffa940c8", "committedDate": "2020-10-14T17:32:22Z", "message": "added funcitonality to better handle indels/spanning deletions in the cigar for overlap bq adjustment code"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA5NDk3MDQy", "url": "https://github.com/broadinstitute/gatk/pull/6886#pullrequestreview-509497042", "createdAt": "2020-10-15T15:19:30Z", "commit": {"oid": "cc7a21c08b14937b5400ff8fe0e58d4cffa940c8"}, "state": "COMMENTED", "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNVQxNToxOTozMFrOHiNMuQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNVQxNTozOToxN1rOHiOFzw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTYyOTg4MQ==", "bodyText": "You can extract the common +1 outside of the Math.min.", "url": "https://github.com/broadinstitute/gatk/pull/6886#discussion_r505629881", "createdAt": "2020-10-15T15:19:30Z", "author": {"login": "davidbenjamin"}, "path": "src/main/java/org/broadinstitute/hellbender/utils/fragments/FragmentUtils.java", "diffHunk": "@@ -47,42 +47,48 @@ public static void adjustQualsOfOverlappingPairedFragments(final Pair<GATKRead,\n         final Pair<Integer, CigarOperator> offsetAndOperator = ReadUtils.getReadIndexForReferenceCoordinate(firstRead, secondRead.getStart());\n         final CigarOperator operator = offsetAndOperator.getRight();\n         final int offset = offsetAndOperator.getLeft();\n-        if (offset == ReadUtils.READ_INDEX_NOT_FOUND) { // no overlap\n+        if (offset == ReadUtils.READ_INDEX_NOT_FOUND || operator.isClipping()) { // no overlap or only overlap in clipped region\n             return;\n         }\n \n+        // Compute the final aligned base indexes for both since there might be right base softclips\n+        final int firstReadEndBase = ReadUtils.getReadIndexForReferenceCoordinate(firstRead, firstRead.getEnd()).getLeft();\n+        final int secondReadEndBase = ReadUtils.getReadIndexForReferenceCoordinate(secondRead, secondRead.getEnd()).getLeft();\n \n         // TODO: we should be careful about the case where {@code operator} is a deletion; that is, when the second read start falls in a deletion of the first read\n         // TODO: however, the issue is bigger than simply getting the start correctly, because the code below assumes that all bases of both reads are aligned in their overlap.\n         // TODO: Any indel that occurs in one read and not the other will spoil things.  Really, the correct thing to do is a Smith-Waterman (or other) alignment of the reads\n         // TODO: in their overlap and correct the double-counting for all aligned bases.\n         // TODO: a cheaper solution would be to cap all quals in the overlap region by half of the PCR qual.\n         final int firstReadStop = offset;\n-        final int numOverlappingBases = Math.min(firstRead.getLength() - firstReadStop, secondRead.getLength());\n+        final int secondOffset = ReadUtils.getReadIndexForReferenceCoordinate(secondRead, secondRead.getStart()).getLeft(); //This operation handles softclipped bases in the qual/base array\n+        final int numOverlappingBases = Math.min(firstReadEndBase + 1 - firstReadStop, secondReadEndBase + 1 - secondOffset); // Add 1 here because if R1 ends on the same base that R2 starts then there is 1 base of overlap not 0", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cc7a21c08b14937b5400ff8fe0e58d4cffa940c8"}, "originalPosition": 21}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTYzNDI5OQ==", "bodyText": "This comment seems detached from its code.", "url": "https://github.com/broadinstitute/gatk/pull/6886#discussion_r505634299", "createdAt": "2020-10-15T15:25:24Z", "author": {"login": "davidbenjamin"}, "path": "src/main/java/org/broadinstitute/hellbender/utils/fragments/FragmentUtils.java", "diffHunk": "@@ -47,42 +47,48 @@ public static void adjustQualsOfOverlappingPairedFragments(final Pair<GATKRead,\n         final Pair<Integer, CigarOperator> offsetAndOperator = ReadUtils.getReadIndexForReferenceCoordinate(firstRead, secondRead.getStart());\n         final CigarOperator operator = offsetAndOperator.getRight();\n         final int offset = offsetAndOperator.getLeft();\n-        if (offset == ReadUtils.READ_INDEX_NOT_FOUND) { // no overlap\n+        if (offset == ReadUtils.READ_INDEX_NOT_FOUND || operator.isClipping()) { // no overlap or only overlap in clipped region\n             return;\n         }\n \n+        // Compute the final aligned base indexes for both since there might be right base softclips\n+        final int firstReadEndBase = ReadUtils.getReadIndexForReferenceCoordinate(firstRead, firstRead.getEnd()).getLeft();\n+        final int secondReadEndBase = ReadUtils.getReadIndexForReferenceCoordinate(secondRead, secondRead.getEnd()).getLeft();\n \n         // TODO: we should be careful about the case where {@code operator} is a deletion; that is, when the second read start falls in a deletion of the first read\n         // TODO: however, the issue is bigger than simply getting the start correctly, because the code below assumes that all bases of both reads are aligned in their overlap.\n         // TODO: Any indel that occurs in one read and not the other will spoil things.  Really, the correct thing to do is a Smith-Waterman (or other) alignment of the reads\n         // TODO: in their overlap and correct the double-counting for all aligned bases.\n         // TODO: a cheaper solution would be to cap all quals in the overlap region by half of the PCR qual.\n         final int firstReadStop = offset;\n-        final int numOverlappingBases = Math.min(firstRead.getLength() - firstReadStop, secondRead.getLength());\n+        final int secondOffset = ReadUtils.getReadIndexForReferenceCoordinate(secondRead, secondRead.getStart()).getLeft(); //This operation handles softclipped bases in the qual/base array\n+        final int numOverlappingBases = Math.min(firstReadEndBase + 1 - firstReadStop, secondReadEndBase + 1 - secondOffset); // Add 1 here because if R1 ends on the same base that R2 starts then there is 1 base of overlap not 0\n \n         final byte[] firstReadBases = firstRead.getBases();\n         final byte[] firstReadQuals = firstRead.getBaseQualities();\n         final byte[] secondReadBases = secondRead.getBases();\n         final byte[] secondReadQuals = secondRead.getBaseQualities();\n+        // adjustments to make to handle softclipping bases", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cc7a21c08b14937b5400ff8fe0e58d4cffa940c8"}, "originalPosition": 27}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTY0MTI3OA==", "bodyText": "Overlaping needs a second 'p', and other needs to be capitalized.", "url": "https://github.com/broadinstitute/gatk/pull/6886#discussion_r505641278", "createdAt": "2020-10-15T15:34:52Z", "author": {"login": "davidbenjamin"}, "path": "src/test/java/org/broadinstitute/hellbender/utils/fragments/FragmentUtilsUnitTest.java", "diffHunk": "@@ -76,4 +76,110 @@ public void testAdjustingTwoReads(final GATKRead read1, final GATKRead read2, fi\n             Assert.assertEquals(read2.getBaseQualities()[i], HIGH_QUALITY);\n         }\n     }\n+\n+\n+    // Generate a bunch of reads with softclips that do not overlap with the other read.\n+    @DataProvider(name = \"AdjustFragmentsTestSoftClipsNotOverlapping\")\n+    public Object[][] createAdjustFragmentsTestSoftClips() throws Exception {\n+        List<Object[]> tests = new ArrayList<>();\n+\n+        final String leftFlank = \"CCC\";\n+        final String rightFlank = \"AAA\";\n+        final String allOverlappingBases = \"ACGTACGTGGAACCTTAG\";\n+        for ( int overlapSize = 1; overlapSize < allOverlappingBases.length(); overlapSize++ ) {\n+            for (int leftSoftclip = 0; leftSoftclip <= leftFlank.length(); leftSoftclip++) {\n+                for (int rightSoftclip = 0; rightSoftclip <= rightFlank.length(); rightSoftclip++) {\n+                    final String overlappingBases = allOverlappingBases.substring(0, overlapSize);\n+                    final byte[] overlappingBaseQuals = new byte[overlapSize];\n+                    for ( int i = 0; i < overlapSize; i++ ) {\n+                        overlappingBaseQuals[i] = HIGH_QUALITY;\n+                    }\n+                    final GATKRead read1  = makeOverlappingRead(leftFlank, HIGH_QUALITY, overlappingBases, overlappingBaseQuals, \"\", HIGH_QUALITY, 1, leftSoftclip, 0);\n+                    final GATKRead read2  = makeOverlappingRead(\"\", HIGH_QUALITY, overlappingBases, overlappingBaseQuals, rightFlank, HIGH_QUALITY, leftFlank.length() + 1, 0, rightSoftclip);\n+                    tests.add(new Object[]{read1, read2, overlapSize});\n+                }\n+            }\n+        }\n+        return tests.toArray(new Object[][]{});\n+    }\n+\n+    // Assert that despite the softclips that the reads are being properly\n+    @Test(dataProvider = \"AdjustFragmentsTestSoftClipsNotOverlapping\")\n+    public void testAdjustingTwoReadsWithSoftClipping(final GATKRead read1, final GATKRead read2, final int overlapSize) {\n+        FragmentUtils.adjustQualsOfOverlappingPairedFragments(ImmutablePair.of(read1, read2), true, OptionalInt.empty(), OptionalInt.empty());\n+\n+        for ( int i = 0; i < read1.getLength() - overlapSize; i++ ) {\n+            Assert.assertEquals(read1.getBaseQualities()[i], HIGH_QUALITY);\n+        }\n+        for ( int i = read1.getLength() - overlapSize; i < read1.getLength(); i++ ) {\n+            Assert.assertEquals(read1.getBaseQualities()[i], OVERLAPPING_QUALITY);\n+        }\n+\n+        for ( int i = 0; i < overlapSize; i++ ) {\n+            Assert.assertEquals(read2.getBaseQualities()[i], OVERLAPPING_QUALITY);\n+        }\n+        for ( int i = overlapSize; i < read2.getLength(); i++ ) {\n+            Assert.assertEquals(read2.getBaseQualities()[i], HIGH_QUALITY);\n+        }\n+    }\n+\n+\n+    // Generate a bunch of reads with softclips that are overlapping with the other read (and allow for reads with no overlap at all except for softclips)\n+    @DataProvider(name = \"AdjustFragmentsTestSoftClipsInOverlapRegion\")\n+    public Object[][] createAdjustFragmentsTestSoftClipsInOverlapRegion() throws Exception {\n+        List<Object[]> tests = new ArrayList<>();\n+\n+        final String leftFlank = \"CCC\";\n+        final String rightFlank = \"AAA\";\n+        final String allOverlappingBases = \"ACGTACGTGGAACCTTAG\";\n+        for ( int overlapSize = 1; overlapSize < allOverlappingBases.length(); overlapSize++ ) {\n+            for (int leftSoftclip = 0; leftSoftclip <= overlapSize; leftSoftclip++) {\n+                for (int rightSoftclip = 0; rightSoftclip <= overlapSize; rightSoftclip++) {\n+                    final String overlappingBases = allOverlappingBases.substring(0, overlapSize);\n+                    final byte[] overlappingBaseQuals = new byte[overlapSize];\n+                    for ( int i = 0; i < overlapSize; i++ ) {\n+                        overlappingBaseQuals[i] = HIGH_QUALITY;\n+                    }\n+                    // Flipped so that the softclips occur in the overlapping region instead\n+                    final GATKRead read1  = makeOverlappingRead(leftFlank, HIGH_QUALITY, overlappingBases, overlappingBaseQuals, \"\", HIGH_QUALITY, 1, 0, rightSoftclip);\n+                    final GATKRead read2  = makeOverlappingRead(\"\", HIGH_QUALITY, overlappingBases, overlappingBaseQuals, rightFlank, HIGH_QUALITY, leftFlank.length() + 1, leftSoftclip, 0);\n+                    tests.add(new Object[]{read1, rightSoftclip, read2, leftSoftclip, overlapSize});\n+                }\n+            }\n+        }\n+        return tests.toArray(new Object[][]{});\n+    }\n+\n+    // Assert that despite the softclips that the reads are being properly\n+    @Test(dataProvider = \"AdjustFragmentsTestSoftClipsInOverlapRegion\")\n+    public void testAdjustingTwoReadsWithSoftClippingOverlapingEachother(final GATKRead read1, final int read1Softclips, final GATKRead read2, final int read2Softclips, final int overlapSize) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cc7a21c08b14937b5400ff8fe0e58d4cffa940c8"}, "originalPosition": 111}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTY0MTY0Nw==", "bodyText": "properly _________?", "url": "https://github.com/broadinstitute/gatk/pull/6886#discussion_r505641647", "createdAt": "2020-10-15T15:35:24Z", "author": {"login": "davidbenjamin"}, "path": "src/test/java/org/broadinstitute/hellbender/utils/fragments/FragmentUtilsUnitTest.java", "diffHunk": "@@ -76,4 +76,110 @@ public void testAdjustingTwoReads(final GATKRead read1, final GATKRead read2, fi\n             Assert.assertEquals(read2.getBaseQualities()[i], HIGH_QUALITY);\n         }\n     }\n+\n+\n+    // Generate a bunch of reads with softclips that do not overlap with the other read.\n+    @DataProvider(name = \"AdjustFragmentsTestSoftClipsNotOverlapping\")\n+    public Object[][] createAdjustFragmentsTestSoftClips() throws Exception {\n+        List<Object[]> tests = new ArrayList<>();\n+\n+        final String leftFlank = \"CCC\";\n+        final String rightFlank = \"AAA\";\n+        final String allOverlappingBases = \"ACGTACGTGGAACCTTAG\";\n+        for ( int overlapSize = 1; overlapSize < allOverlappingBases.length(); overlapSize++ ) {\n+            for (int leftSoftclip = 0; leftSoftclip <= leftFlank.length(); leftSoftclip++) {\n+                for (int rightSoftclip = 0; rightSoftclip <= rightFlank.length(); rightSoftclip++) {\n+                    final String overlappingBases = allOverlappingBases.substring(0, overlapSize);\n+                    final byte[] overlappingBaseQuals = new byte[overlapSize];\n+                    for ( int i = 0; i < overlapSize; i++ ) {\n+                        overlappingBaseQuals[i] = HIGH_QUALITY;\n+                    }\n+                    final GATKRead read1  = makeOverlappingRead(leftFlank, HIGH_QUALITY, overlappingBases, overlappingBaseQuals, \"\", HIGH_QUALITY, 1, leftSoftclip, 0);\n+                    final GATKRead read2  = makeOverlappingRead(\"\", HIGH_QUALITY, overlappingBases, overlappingBaseQuals, rightFlank, HIGH_QUALITY, leftFlank.length() + 1, 0, rightSoftclip);\n+                    tests.add(new Object[]{read1, read2, overlapSize});\n+                }\n+            }\n+        }\n+        return tests.toArray(new Object[][]{});\n+    }\n+\n+    // Assert that despite the softclips that the reads are being properly", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cc7a21c08b14937b5400ff8fe0e58d4cffa940c8"}, "originalPosition": 62}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTY0NDQ5NQ==", "bodyText": "Could you put in a test with indels with a comment that the behavior is not yet ideal?  It would help future efforts by clarifying exactly which cases currently don't work right.", "url": "https://github.com/broadinstitute/gatk/pull/6886#discussion_r505644495", "createdAt": "2020-10-15T15:39:17Z", "author": {"login": "davidbenjamin"}, "path": "src/test/java/org/broadinstitute/hellbender/utils/fragments/FragmentUtilsUnitTest.java", "diffHunk": "@@ -76,4 +76,110 @@ public void testAdjustingTwoReads(final GATKRead read1, final GATKRead read2, fi\n             Assert.assertEquals(read2.getBaseQualities()[i], HIGH_QUALITY);\n         }\n     }\n+\n+\n+    // Generate a bunch of reads with softclips that do not overlap with the other read.\n+    @DataProvider(name = \"AdjustFragmentsTestSoftClipsNotOverlapping\")\n+    public Object[][] createAdjustFragmentsTestSoftClips() throws Exception {\n+        List<Object[]> tests = new ArrayList<>();\n+\n+        final String leftFlank = \"CCC\";\n+        final String rightFlank = \"AAA\";\n+        final String allOverlappingBases = \"ACGTACGTGGAACCTTAG\";\n+        for ( int overlapSize = 1; overlapSize < allOverlappingBases.length(); overlapSize++ ) {\n+            for (int leftSoftclip = 0; leftSoftclip <= leftFlank.length(); leftSoftclip++) {\n+                for (int rightSoftclip = 0; rightSoftclip <= rightFlank.length(); rightSoftclip++) {\n+                    final String overlappingBases = allOverlappingBases.substring(0, overlapSize);\n+                    final byte[] overlappingBaseQuals = new byte[overlapSize];\n+                    for ( int i = 0; i < overlapSize; i++ ) {\n+                        overlappingBaseQuals[i] = HIGH_QUALITY;\n+                    }\n+                    final GATKRead read1  = makeOverlappingRead(leftFlank, HIGH_QUALITY, overlappingBases, overlappingBaseQuals, \"\", HIGH_QUALITY, 1, leftSoftclip, 0);\n+                    final GATKRead read2  = makeOverlappingRead(\"\", HIGH_QUALITY, overlappingBases, overlappingBaseQuals, rightFlank, HIGH_QUALITY, leftFlank.length() + 1, 0, rightSoftclip);\n+                    tests.add(new Object[]{read1, read2, overlapSize});\n+                }\n+            }\n+        }\n+        return tests.toArray(new Object[][]{});\n+    }\n+\n+    // Assert that despite the softclips that the reads are being properly\n+    @Test(dataProvider = \"AdjustFragmentsTestSoftClipsNotOverlapping\")\n+    public void testAdjustingTwoReadsWithSoftClipping(final GATKRead read1, final GATKRead read2, final int overlapSize) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cc7a21c08b14937b5400ff8fe0e58d4cffa940c8"}, "originalPosition": 64}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "baa6e543e5d04fa9441bbbcab8a2f79b18cdf152", "author": {"user": {"login": "jamesemery", "name": null}}, "url": "https://github.com/broadinstitute/gatk/commit/baa6e543e5d04fa9441bbbcab8a2f79b18cdf152", "committedDate": "2020-10-15T16:54:11Z", "message": "Responded to review comments"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA5NTg0NDQ1", "url": "https://github.com/broadinstitute/gatk/pull/6886#pullrequestreview-509584445", "createdAt": "2020-10-15T16:56:33Z", "commit": {"oid": "baa6e543e5d04fa9441bbbcab8a2f79b18cdf152"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2520, "cost": 1, "resetAt": "2021-11-01T13:07:16Z"}}}