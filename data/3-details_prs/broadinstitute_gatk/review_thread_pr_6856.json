{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDk1NTQxMDM4", "number": 6856, "reviewThreads": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNVQyMzoxMzo0MFrOEqgw9w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNlQwMjo0MzozNFrOEqi9rg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEzMDEyNDcxOnYy", "diffSide": "RIGHT", "path": "src/main/java/org/broadinstitute/hellbender/tools/walkers/genotyper/GenotypingEngine.java", "isResolved": false, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNVQyMzoxMzo0MFrOHcww5A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNlQxNDowNDozMFrOHdIehQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTkyMTEyNA==", "bodyText": "This can be simplified a bit.\nAssuming you can write in posterior (I think is the case):\nfinal double[] noVarPosteriors = IntStream.rangeClosed(0, ploidy)\n                 .map(p, gcCalc.alleleCountsToIndex(0, p, spanIndelIdx, ploidy - p))\n                 .mapToDouble(i -> posteriors[i])\n                 .toArray();\nreturn QualUtils.phredSum(noVarPosteriors) - QualUtils.phredSum(posteriors);", "url": "https://github.com/broadinstitute/gatk/pull/6856#discussion_r499921124", "createdAt": "2020-10-05T23:13:40Z", "author": {"login": "vruano"}, "path": "src/main/java/org/broadinstitute/hellbender/tools/walkers/genotyper/GenotypingEngine.java", "diffHunk": "@@ -186,18 +186,41 @@ public VariantContext calculateGenotypes(final VariantContext vc, final Genotype\n         return builder.genotypes(genotypes).attributes(attributes).make();\n     }\n \n-    private double phredNoVariantPosteriorProbability(final GenotypesContext gc) {\n+    protected double phredNoVariantPosteriorProbability(final List<Allele> alleles, final GenotypesContext gc) {\n         return gc.stream()\n-                .map(gt -> VariantContextGetters.getAttributeAsDoubleArray(gt, VCFConstants.GENOTYPE_POSTERIORS_KEY, () -> new double[]{Double.NaN}, Double.NaN))\n-                //TODO reverting the following a change during refactoring, more sound but different to what it was:\n-                //        .mapToDouble(probs -> probs[0] - QualityUtils.phredSum(probs))\n-                .mapToDouble(probs -> probs[0])\n+                .mapToDouble(gt -> extractPNoAlt(alleles, gt))\n                 .filter(d -> !Double.isNaN(d))\n-                // We do not want to return 0 if empty but NaN,\n-                // so rather than simply call .sum() we have a custom reduce\n                 .reduce(Double.NaN, (a, b) -> Double.isNaN(a) ? b : (Double.isNaN(b) ? a : a + b) );\n     }\n \n+    private double extractPNoAlt(final List<Allele> alleles, final Genotype gt) {\n+        final double[] gpArray = VariantContextGetters.getAttributeAsDoubleArray(gt, VCFConstants.GENOTYPE_POSTERIORS_KEY, () -> new double[]{Double.NaN}, Double.NaN);\n+        final double pNoAlt = extractPNoAlt(alleles, gt, gpArray);\n+        return pNoAlt;\n+    }\n+\n+    private static final GenotypeLikelihoodCalculators GL_CALCS = new GenotypeLikelihoodCalculators();\n+\n+    private double extractPNoAlt(final List<Allele> alleles, final Genotype gt, final double[] posteriors) {\n+        if (!alleles.contains(Allele.SPAN_DEL)) {\n+            return posteriors[0] - Math.max(0, QualityUtils.phredSum(posteriors));\n+        } else {\n+            // here we need to get indices of genotypes composed of REF and * alleles\n+            final int ploidy = gt.getPloidy();\n+            final GenotypeLikelihoodCalculator glCalc = GL_CALCS.getInstance(ploidy, alleles.size());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0eadc4a629dfda911b82a0fbc2875ec1d589fd2c"}, "originalPosition": 41}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTkyMTQxMg==", "bodyText": "I don't know why there is a need for the Math.max(0, x) but is trivial to add it to the code above I guess.", "url": "https://github.com/broadinstitute/gatk/pull/6856#discussion_r499921412", "createdAt": "2020-10-05T23:14:27Z", "author": {"login": "vruano"}, "path": "src/main/java/org/broadinstitute/hellbender/tools/walkers/genotyper/GenotypingEngine.java", "diffHunk": "@@ -186,18 +186,41 @@ public VariantContext calculateGenotypes(final VariantContext vc, final Genotype\n         return builder.genotypes(genotypes).attributes(attributes).make();\n     }\n \n-    private double phredNoVariantPosteriorProbability(final GenotypesContext gc) {\n+    protected double phredNoVariantPosteriorProbability(final List<Allele> alleles, final GenotypesContext gc) {\n         return gc.stream()\n-                .map(gt -> VariantContextGetters.getAttributeAsDoubleArray(gt, VCFConstants.GENOTYPE_POSTERIORS_KEY, () -> new double[]{Double.NaN}, Double.NaN))\n-                //TODO reverting the following a change during refactoring, more sound but different to what it was:\n-                //        .mapToDouble(probs -> probs[0] - QualityUtils.phredSum(probs))\n-                .mapToDouble(probs -> probs[0])\n+                .mapToDouble(gt -> extractPNoAlt(alleles, gt))\n                 .filter(d -> !Double.isNaN(d))\n-                // We do not want to return 0 if empty but NaN,\n-                // so rather than simply call .sum() we have a custom reduce\n                 .reduce(Double.NaN, (a, b) -> Double.isNaN(a) ? b : (Double.isNaN(b) ? a : a + b) );\n     }\n \n+    private double extractPNoAlt(final List<Allele> alleles, final Genotype gt) {\n+        final double[] gpArray = VariantContextGetters.getAttributeAsDoubleArray(gt, VCFConstants.GENOTYPE_POSTERIORS_KEY, () -> new double[]{Double.NaN}, Double.NaN);\n+        final double pNoAlt = extractPNoAlt(alleles, gt, gpArray);\n+        return pNoAlt;\n+    }\n+\n+    private static final GenotypeLikelihoodCalculators GL_CALCS = new GenotypeLikelihoodCalculators();\n+\n+    private double extractPNoAlt(final List<Allele> alleles, final Genotype gt, final double[] posteriors) {\n+        if (!alleles.contains(Allele.SPAN_DEL)) {\n+            return posteriors[0] - Math.max(0, QualityUtils.phredSum(posteriors));\n+        } else {\n+            // here we need to get indices of genotypes composed of REF and * alleles\n+            final int ploidy = gt.getPloidy();\n+            final GenotypeLikelihoodCalculator glCalc = GL_CALCS.getInstance(ploidy, alleles.size());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTkyMTEyNA=="}, "originalCommit": {"oid": "0eadc4a629dfda911b82a0fbc2875ec1d589fd2c"}, "originalPosition": 41}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTkyMTYxOA==", "bodyText": "Feel free to use IntRange instead of IntStream if you can get the same functionality from it.", "url": "https://github.com/broadinstitute/gatk/pull/6856#discussion_r499921618", "createdAt": "2020-10-05T23:15:05Z", "author": {"login": "vruano"}, "path": "src/main/java/org/broadinstitute/hellbender/tools/walkers/genotyper/GenotypingEngine.java", "diffHunk": "@@ -186,18 +186,41 @@ public VariantContext calculateGenotypes(final VariantContext vc, final Genotype\n         return builder.genotypes(genotypes).attributes(attributes).make();\n     }\n \n-    private double phredNoVariantPosteriorProbability(final GenotypesContext gc) {\n+    protected double phredNoVariantPosteriorProbability(final List<Allele> alleles, final GenotypesContext gc) {\n         return gc.stream()\n-                .map(gt -> VariantContextGetters.getAttributeAsDoubleArray(gt, VCFConstants.GENOTYPE_POSTERIORS_KEY, () -> new double[]{Double.NaN}, Double.NaN))\n-                //TODO reverting the following a change during refactoring, more sound but different to what it was:\n-                //        .mapToDouble(probs -> probs[0] - QualityUtils.phredSum(probs))\n-                .mapToDouble(probs -> probs[0])\n+                .mapToDouble(gt -> extractPNoAlt(alleles, gt))\n                 .filter(d -> !Double.isNaN(d))\n-                // We do not want to return 0 if empty but NaN,\n-                // so rather than simply call .sum() we have a custom reduce\n                 .reduce(Double.NaN, (a, b) -> Double.isNaN(a) ? b : (Double.isNaN(b) ? a : a + b) );\n     }\n \n+    private double extractPNoAlt(final List<Allele> alleles, final Genotype gt) {\n+        final double[] gpArray = VariantContextGetters.getAttributeAsDoubleArray(gt, VCFConstants.GENOTYPE_POSTERIORS_KEY, () -> new double[]{Double.NaN}, Double.NaN);\n+        final double pNoAlt = extractPNoAlt(alleles, gt, gpArray);\n+        return pNoAlt;\n+    }\n+\n+    private static final GenotypeLikelihoodCalculators GL_CALCS = new GenotypeLikelihoodCalculators();\n+\n+    private double extractPNoAlt(final List<Allele> alleles, final Genotype gt, final double[] posteriors) {\n+        if (!alleles.contains(Allele.SPAN_DEL)) {\n+            return posteriors[0] - Math.max(0, QualityUtils.phredSum(posteriors));\n+        } else {\n+            // here we need to get indices of genotypes composed of REF and * alleles\n+            final int ploidy = gt.getPloidy();\n+            final GenotypeLikelihoodCalculator glCalc = GL_CALCS.getInstance(ploidy, alleles.size());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTkyMTEyNA=="}, "originalCommit": {"oid": "0eadc4a629dfda911b82a0fbc2875ec1d589fd2c"}, "originalPosition": 41}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDMwOTYzNw==", "bodyText": "I don't know why there is a need for the Math.max(0, x) but is trivial to add it to the code above I guess.\n\nEvidently due to floating point error phredSum can sometimes return values < 0; see the comment, which I'd ported over from the similar code in AlleleFrequencyCalculator.", "url": "https://github.com/broadinstitute/gatk/pull/6856#discussion_r500309637", "createdAt": "2020-10-06T14:04:30Z", "author": {"login": "cwhelan"}, "path": "src/main/java/org/broadinstitute/hellbender/tools/walkers/genotyper/GenotypingEngine.java", "diffHunk": "@@ -186,18 +186,41 @@ public VariantContext calculateGenotypes(final VariantContext vc, final Genotype\n         return builder.genotypes(genotypes).attributes(attributes).make();\n     }\n \n-    private double phredNoVariantPosteriorProbability(final GenotypesContext gc) {\n+    protected double phredNoVariantPosteriorProbability(final List<Allele> alleles, final GenotypesContext gc) {\n         return gc.stream()\n-                .map(gt -> VariantContextGetters.getAttributeAsDoubleArray(gt, VCFConstants.GENOTYPE_POSTERIORS_KEY, () -> new double[]{Double.NaN}, Double.NaN))\n-                //TODO reverting the following a change during refactoring, more sound but different to what it was:\n-                //        .mapToDouble(probs -> probs[0] - QualityUtils.phredSum(probs))\n-                .mapToDouble(probs -> probs[0])\n+                .mapToDouble(gt -> extractPNoAlt(alleles, gt))\n                 .filter(d -> !Double.isNaN(d))\n-                // We do not want to return 0 if empty but NaN,\n-                // so rather than simply call .sum() we have a custom reduce\n                 .reduce(Double.NaN, (a, b) -> Double.isNaN(a) ? b : (Double.isNaN(b) ? a : a + b) );\n     }\n \n+    private double extractPNoAlt(final List<Allele> alleles, final Genotype gt) {\n+        final double[] gpArray = VariantContextGetters.getAttributeAsDoubleArray(gt, VCFConstants.GENOTYPE_POSTERIORS_KEY, () -> new double[]{Double.NaN}, Double.NaN);\n+        final double pNoAlt = extractPNoAlt(alleles, gt, gpArray);\n+        return pNoAlt;\n+    }\n+\n+    private static final GenotypeLikelihoodCalculators GL_CALCS = new GenotypeLikelihoodCalculators();\n+\n+    private double extractPNoAlt(final List<Allele> alleles, final Genotype gt, final double[] posteriors) {\n+        if (!alleles.contains(Allele.SPAN_DEL)) {\n+            return posteriors[0] - Math.max(0, QualityUtils.phredSum(posteriors));\n+        } else {\n+            // here we need to get indices of genotypes composed of REF and * alleles\n+            final int ploidy = gt.getPloidy();\n+            final GenotypeLikelihoodCalculator glCalc = GL_CALCS.getInstance(ploidy, alleles.size());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTkyMTEyNA=="}, "originalCommit": {"oid": "0eadc4a629dfda911b82a0fbc2875ec1d589fd2c"}, "originalPosition": 41}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEzMDQ4NDk0OnYy", "diffSide": "RIGHT", "path": "src/main/java/org/broadinstitute/hellbender/tools/walkers/genotyper/GenotypingEngine.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNlQwMjo0MzozNFrOHc0D3w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNlQwMjo0MzozNFrOHc0D3w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTk3NTEzNQ==", "bodyText": "unnecessary local variable.", "url": "https://github.com/broadinstitute/gatk/pull/6856#discussion_r499975135", "createdAt": "2020-10-06T02:43:34Z", "author": {"login": "vruano"}, "path": "src/main/java/org/broadinstitute/hellbender/tools/walkers/genotyper/GenotypingEngine.java", "diffHunk": "@@ -186,18 +186,41 @@ public VariantContext calculateGenotypes(final VariantContext vc, final Genotype\n         return builder.genotypes(genotypes).attributes(attributes).make();\n     }\n \n-    private double phredNoVariantPosteriorProbability(final GenotypesContext gc) {\n+    protected double phredNoVariantPosteriorProbability(final List<Allele> alleles, final GenotypesContext gc) {\n         return gc.stream()\n-                .map(gt -> VariantContextGetters.getAttributeAsDoubleArray(gt, VCFConstants.GENOTYPE_POSTERIORS_KEY, () -> new double[]{Double.NaN}, Double.NaN))\n-                //TODO reverting the following a change during refactoring, more sound but different to what it was:\n-                //        .mapToDouble(probs -> probs[0] - QualityUtils.phredSum(probs))\n-                .mapToDouble(probs -> probs[0])\n+                .mapToDouble(gt -> extractPNoAlt(alleles, gt))\n                 .filter(d -> !Double.isNaN(d))\n-                // We do not want to return 0 if empty but NaN,\n-                // so rather than simply call .sum() we have a custom reduce\n                 .reduce(Double.NaN, (a, b) -> Double.isNaN(a) ? b : (Double.isNaN(b) ? a : a + b) );\n     }\n \n+    private double extractPNoAlt(final List<Allele> alleles, final Genotype gt) {\n+        final double[] gpArray = VariantContextGetters.getAttributeAsDoubleArray(gt, VCFConstants.GENOTYPE_POSTERIORS_KEY, () -> new double[]{Double.NaN}, Double.NaN);\n+        final double pNoAlt = extractPNoAlt(alleles, gt, gpArray);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0eadc4a629dfda911b82a0fbc2875ec1d589fd2c"}, "originalPosition": 29}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 800, "cost": 1, "resetAt": "2021-11-12T13:16:51Z"}}}