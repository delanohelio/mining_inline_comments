{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0Mzk4MzMxNzM1", "number": 6536, "reviewThreads": {"totalCount": 18, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNFQxODo1MjozOFrODxxznw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMlQxMzoyODoxOVrOD-8wjA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUzNTIyODQ3OnYy", "diffSide": "RIGHT", "path": "scripts/pathseq/wdl/README.md", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNFQxODo1MjozOFrOGFcZqA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0zMFQxOTozMTowMVrOGO3YZw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODM2MTM4NA==", "bodyText": "What made you change this from 60 to 31?", "url": "https://github.com/broadinstitute/gatk/pull/6536#discussion_r408361384", "createdAt": "2020-04-14T18:52:38Z", "author": {"login": "ldgauthier"}, "path": "scripts/pathseq/wdl/README.md", "diffHunk": "@@ -5,31 +5,32 @@\n To get started, *copy* the ``pathseq_pipeline_template.json`` for the workflow and modify the parameters accordingly.\n DO NOT commit your json file to this repo. This file has reasonable default parameters.\n \n-PathSeq reference files are available in the [GATK Resource Bundle](https://software.broadinstitute.org/gatk/download/bundle) (located [here](ftp://gsapubftp-anonymous@ftp.broadinstitute.org/bundle/beta/PathSeq)).\n+PathSeq reference files are available in the [GATK Resource Bundle](https://software.broadinstitute.org/gatk/download/bundle).\n \n *Please note that there are optional parameters that do not appear in the template files, since we do not want to specify them by default*\n \n ### Docker image\n-- \"broadinstitute/gatk:4.0.0.0\"\n+- \"broadinstitute/gatk:4.1.1.0\"\n \n ### Parameter descriptions\n \n Recommended default values (where possible) are found in ``pathseq_pipeline_template.json``\n \n - ``PathSeqPipelineWorkflow.sample_name`` -- sample ID\n-- ``PathSeqPipelineWorkflow.input_bam`` -- sample BAM file\n+- ``PathSeqPipelineWorkflow.input_bam_or_cram`` -- sample BAM or CRAM file\n - ``PathSeqPipelineWorkflow.is_host_aligned`` -- Set to true if the input has already been aligned to a host reference. *NOTE: common human references (e.g. GrCh38) contain decoy sequences such as the Epstein-Barr Virus genome. If this flag is set to true, reads aligning to these decoys will be misidentified as \"host\" and filtered out.*\n - ``PathSeqPipelineWorkflow.filter_bwa_image`` -- Path to host BWA index image. This corresponds to `pathseq_host.fa.img` in the Resource Bundle.\n - ``PathSeqPipelineWorkflow.kmer_file`` -- Path to host k-mer file. This corresponds to `pathseq_host.bfi` in the Resource Bundle.\n - ``PathSeqPipelineWorkflow.microbe_bwa_image`` -- Path to microbe BWA index image. This corresponds to `pathseq_microbe.fa.img` in the Resource Bundle.\n-- ``PathSeqPipelineWorkflow.microbe_fasta`` -- Path to microbe reference FASTA file. This corresponds to `pathseq_microbe.fa` in the Resource Bundle.\n-- ``PathSeqPipelineWorkflow.microbe_fasta_dict`` -- Path to microbe reference dictionary file.This corresponds to `pathseq_microbe.dict` in the Resource Bundle.\n+- ``PathSeqPipelineWorkflow.microbe_fasta_dict`` -- Path to microbe reference dictionary file. This corresponds to `pathseq_microbe.dict` in the Resource Bundle.\n - ``PathSeqPipelineWorkflow.taxonomy_file`` -- Path to PathSeq taxonomy file. This corresponds to `pathseq_taxonomy.db` in the Resource Bundle.\n-- ``PathSeqPipelineWorkflow.gatk_docker`` -- GATK docker image\n+- ``PathSeqPipelineWorkflow.gatk_docker`` -- GATK docker image ( >= v4.0.0.0)\n \n Optional parameters:\n \n-- ``PathSeqPipelineWorkflow.min_clipped_read_length`` -- Minimum read length after quality trimming. You may need to reduce this if your input reads are shorter than the default value (default 60)\n+- ``PathSeqPipelineWorkflow.estimate_filter_metrics_with_downsampling`` -- read filter metrics will be estimated using a downsampled bam (highly recommended) (default true)\n+- ``PathSeqPipelineWorkflow.estimate_filter_metrics_reads`` -- number of reads to downsample to for filter metrics estimation, recommended 1M for samples with ~0.1% non-host reads (default 1M)\n+- ``PathSeqPipelineWorkflow.min_clipped_read_length`` -- Minimum read length after quality trimming. Increasing may increase microbial classification specificity but may reduce sensitivity (default 31)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d0c8174e86870f21669206f4b6a6f4954794c8a9"}, "originalPosition": 36}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODI0MDYxNQ==", "bodyText": "Some libraries have very short reads (eg older TCGA data with ~40bp). This makes it less likely for users to get confused when the output comes up empty.", "url": "https://github.com/broadinstitute/gatk/pull/6536#discussion_r418240615", "createdAt": "2020-04-30T19:31:01Z", "author": {"login": "mwalker174"}, "path": "scripts/pathseq/wdl/README.md", "diffHunk": "@@ -5,31 +5,32 @@\n To get started, *copy* the ``pathseq_pipeline_template.json`` for the workflow and modify the parameters accordingly.\n DO NOT commit your json file to this repo. This file has reasonable default parameters.\n \n-PathSeq reference files are available in the [GATK Resource Bundle](https://software.broadinstitute.org/gatk/download/bundle) (located [here](ftp://gsapubftp-anonymous@ftp.broadinstitute.org/bundle/beta/PathSeq)).\n+PathSeq reference files are available in the [GATK Resource Bundle](https://software.broadinstitute.org/gatk/download/bundle).\n \n *Please note that there are optional parameters that do not appear in the template files, since we do not want to specify them by default*\n \n ### Docker image\n-- \"broadinstitute/gatk:4.0.0.0\"\n+- \"broadinstitute/gatk:4.1.1.0\"\n \n ### Parameter descriptions\n \n Recommended default values (where possible) are found in ``pathseq_pipeline_template.json``\n \n - ``PathSeqPipelineWorkflow.sample_name`` -- sample ID\n-- ``PathSeqPipelineWorkflow.input_bam`` -- sample BAM file\n+- ``PathSeqPipelineWorkflow.input_bam_or_cram`` -- sample BAM or CRAM file\n - ``PathSeqPipelineWorkflow.is_host_aligned`` -- Set to true if the input has already been aligned to a host reference. *NOTE: common human references (e.g. GrCh38) contain decoy sequences such as the Epstein-Barr Virus genome. If this flag is set to true, reads aligning to these decoys will be misidentified as \"host\" and filtered out.*\n - ``PathSeqPipelineWorkflow.filter_bwa_image`` -- Path to host BWA index image. This corresponds to `pathseq_host.fa.img` in the Resource Bundle.\n - ``PathSeqPipelineWorkflow.kmer_file`` -- Path to host k-mer file. This corresponds to `pathseq_host.bfi` in the Resource Bundle.\n - ``PathSeqPipelineWorkflow.microbe_bwa_image`` -- Path to microbe BWA index image. This corresponds to `pathseq_microbe.fa.img` in the Resource Bundle.\n-- ``PathSeqPipelineWorkflow.microbe_fasta`` -- Path to microbe reference FASTA file. This corresponds to `pathseq_microbe.fa` in the Resource Bundle.\n-- ``PathSeqPipelineWorkflow.microbe_fasta_dict`` -- Path to microbe reference dictionary file.This corresponds to `pathseq_microbe.dict` in the Resource Bundle.\n+- ``PathSeqPipelineWorkflow.microbe_fasta_dict`` -- Path to microbe reference dictionary file. This corresponds to `pathseq_microbe.dict` in the Resource Bundle.\n - ``PathSeqPipelineWorkflow.taxonomy_file`` -- Path to PathSeq taxonomy file. This corresponds to `pathseq_taxonomy.db` in the Resource Bundle.\n-- ``PathSeqPipelineWorkflow.gatk_docker`` -- GATK docker image\n+- ``PathSeqPipelineWorkflow.gatk_docker`` -- GATK docker image ( >= v4.0.0.0)\n \n Optional parameters:\n \n-- ``PathSeqPipelineWorkflow.min_clipped_read_length`` -- Minimum read length after quality trimming. You may need to reduce this if your input reads are shorter than the default value (default 60)\n+- ``PathSeqPipelineWorkflow.estimate_filter_metrics_with_downsampling`` -- read filter metrics will be estimated using a downsampled bam (highly recommended) (default true)\n+- ``PathSeqPipelineWorkflow.estimate_filter_metrics_reads`` -- number of reads to downsample to for filter metrics estimation, recommended 1M for samples with ~0.1% non-host reads (default 1M)\n+- ``PathSeqPipelineWorkflow.min_clipped_read_length`` -- Minimum read length after quality trimming. Increasing may increase microbial classification specificity but may reduce sensitivity (default 31)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODM2MTM4NA=="}, "originalCommit": {"oid": "d0c8174e86870f21669206f4b6a6f4954794c8a9"}, "originalPosition": 36}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUzNTIzODk1OnYy", "diffSide": "RIGHT", "path": "scripts/pathseq/wdl/pathseq_pipeline_template.json", "isResolved": false, "comments": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNFQxODo1NTowN1rOGFcfyQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNFQxNjoxMTozMVrOGQHd-w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODM2Mjk1Mw==", "bodyText": "Can you talk to @bshifaw about what needs to happen to \"feature\" the PathSeq workspace?  It's likely the only this is to put real (mini) data here.", "url": "https://github.com/broadinstitute/gatk/pull/6536#discussion_r408362953", "createdAt": "2020-04-14T18:55:07Z", "author": {"login": "ldgauthier"}, "path": "scripts/pathseq/wdl/pathseq_pipeline_template.json", "diffHunk": "@@ -1,19 +1,18 @@\n {\n-  \"PathSeqPipelineWorkflow.sample_name\": \"sample\",\n-  \"PathSeqPipelineWorkflow.input_bam\": \"gs://my-bucket/sample.bam\",\n+  \"PathSeqThreeStageWorkflow.sample_name\": \"sample\",\n+  \"PathSeqThreeStageWorkflow.input_bam_or_cram\": \"gs://my-bucket/sample.bam\",", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d0c8174e86870f21669206f4b6a6f4954794c8a9"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODc5NTU5OQ==", "bodyText": "Thats right, mini data would do fine for now. Here is an old json with mini data for pathseq here. Its NA12878_24RG contaminated with chicken reads.", "url": "https://github.com/broadinstitute/gatk/pull/6536#discussion_r408795599", "createdAt": "2020-04-15T12:15:08Z", "author": {"login": "bshifaw"}, "path": "scripts/pathseq/wdl/pathseq_pipeline_template.json", "diffHunk": "@@ -1,19 +1,18 @@\n {\n-  \"PathSeqPipelineWorkflow.sample_name\": \"sample\",\n-  \"PathSeqPipelineWorkflow.input_bam\": \"gs://my-bucket/sample.bam\",\n+  \"PathSeqThreeStageWorkflow.sample_name\": \"sample\",\n+  \"PathSeqThreeStageWorkflow.input_bam_or_cram\": \"gs://my-bucket/sample.bam\",", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODM2Mjk1Mw=="}, "originalCommit": {"oid": "d0c8174e86870f21669206f4b6a6f4954794c8a9"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODI0MjU4Nw==", "bodyText": "@bshifaw Is it SOP to have these json files? I was considering deleting it - it seems like this kind of metadata should be made available on Terra instead, ie through featured workspaces.", "url": "https://github.com/broadinstitute/gatk/pull/6536#discussion_r418242587", "createdAt": "2020-04-30T19:35:04Z", "author": {"login": "mwalker174"}, "path": "scripts/pathseq/wdl/pathseq_pipeline_template.json", "diffHunk": "@@ -1,19 +1,18 @@\n {\n-  \"PathSeqPipelineWorkflow.sample_name\": \"sample\",\n-  \"PathSeqPipelineWorkflow.input_bam\": \"gs://my-bucket/sample.bam\",\n+  \"PathSeqThreeStageWorkflow.sample_name\": \"sample\",\n+  \"PathSeqThreeStageWorkflow.input_bam_or_cram\": \"gs://my-bucket/sample.bam\",", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODM2Mjk1Mw=="}, "originalCommit": {"oid": "d0c8174e86870f21669206f4b6a6f4954794c8a9"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODI0ODYyMQ==", "bodyText": "It's also problematic that I can't provide a docker that would support this workflow until we cut a new release", "url": "https://github.com/broadinstitute/gatk/pull/6536#discussion_r418248621", "createdAt": "2020-04-30T19:46:55Z", "author": {"login": "mwalker174"}, "path": "scripts/pathseq/wdl/pathseq_pipeline_template.json", "diffHunk": "@@ -1,19 +1,18 @@\n {\n-  \"PathSeqPipelineWorkflow.sample_name\": \"sample\",\n-  \"PathSeqPipelineWorkflow.input_bam\": \"gs://my-bucket/sample.bam\",\n+  \"PathSeqThreeStageWorkflow.sample_name\": \"sample\",\n+  \"PathSeqThreeStageWorkflow.input_bam_or_cram\": \"gs://my-bucket/sample.bam\",", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODM2Mjk1Mw=="}, "originalCommit": {"oid": "d0c8174e86870f21669206f4b6a6f4954794c8a9"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODUyMDQzNg==", "bodyText": "Yes, having the JSON along with the WDL is SOP. Correct, the JSON would be available in Terra (which requires a google account) but not everyone will be looking at the workflow via Terra. You may have visitors directly from Dockstore or to this repo looking for an example JSON.\nI can see why not having a docker would be a problem, maybe a place older can be added for the next release or use \":latest\". If both don't seem inappropriate, maybe hold off on the JSON for now but eventually add an example JSON with the WDL.", "url": "https://github.com/broadinstitute/gatk/pull/6536#discussion_r418520436", "createdAt": "2020-05-01T12:24:59Z", "author": {"login": "bshifaw"}, "path": "scripts/pathseq/wdl/pathseq_pipeline_template.json", "diffHunk": "@@ -1,19 +1,18 @@\n {\n-  \"PathSeqPipelineWorkflow.sample_name\": \"sample\",\n-  \"PathSeqPipelineWorkflow.input_bam\": \"gs://my-bucket/sample.bam\",\n+  \"PathSeqThreeStageWorkflow.sample_name\": \"sample\",\n+  \"PathSeqThreeStageWorkflow.input_bam_or_cram\": \"gs://my-bucket/sample.bam\",", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODM2Mjk1Mw=="}, "originalCommit": {"oid": "d0c8174e86870f21669206f4b6a6f4954794c8a9"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODYzMjA3Nw==", "bodyText": "@bshifaw Okay thanks for clarifying, I will update the JSON then. Can we add an index to the chicken sample bam and put it at gs://gatk-best-practices/pathseq/contaminated-bam/NA12878_24RG_med.hg380.7chicken0.3.bam.bai?", "url": "https://github.com/broadinstitute/gatk/pull/6536#discussion_r418632077", "createdAt": "2020-05-01T16:57:31Z", "author": {"login": "mwalker174"}, "path": "scripts/pathseq/wdl/pathseq_pipeline_template.json", "diffHunk": "@@ -1,19 +1,18 @@\n {\n-  \"PathSeqPipelineWorkflow.sample_name\": \"sample\",\n-  \"PathSeqPipelineWorkflow.input_bam\": \"gs://my-bucket/sample.bam\",\n+  \"PathSeqThreeStageWorkflow.sample_name\": \"sample\",\n+  \"PathSeqThreeStageWorkflow.input_bam_or_cram\": \"gs://my-bucket/sample.bam\",", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODM2Mjk1Mw=="}, "originalCommit": {"oid": "d0c8174e86870f21669206f4b6a6f4954794c8a9"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTU1Mjc2Mw==", "bodyText": "Yes, done", "url": "https://github.com/broadinstitute/gatk/pull/6536#discussion_r419552763", "createdAt": "2020-05-04T16:11:31Z", "author": {"login": "bshifaw"}, "path": "scripts/pathseq/wdl/pathseq_pipeline_template.json", "diffHunk": "@@ -1,19 +1,18 @@\n {\n-  \"PathSeqPipelineWorkflow.sample_name\": \"sample\",\n-  \"PathSeqPipelineWorkflow.input_bam\": \"gs://my-bucket/sample.bam\",\n+  \"PathSeqThreeStageWorkflow.sample_name\": \"sample\",\n+  \"PathSeqThreeStageWorkflow.input_bam_or_cram\": \"gs://my-bucket/sample.bam\",", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODM2Mjk1Mw=="}, "originalCommit": {"oid": "d0c8174e86870f21669206f4b6a6f4954794c8a9"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUzNTI0NDU0OnYy", "diffSide": "RIGHT", "path": "src/main/java/org/broadinstitute/hellbender/tools/copynumber/DetermineGermlineContigPloidy.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNFQxODo1NjozMlrOGFcjGw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0zMFQxOTo0MTozM1rOGO3s6A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODM2MzgwMw==", "bodyText": "Does this need a rebase?  I thought I just merged a PR with this change.", "url": "https://github.com/broadinstitute/gatk/pull/6536#discussion_r408363803", "createdAt": "2020-04-14T18:56:32Z", "author": {"login": "ldgauthier"}, "path": "src/main/java/org/broadinstitute/hellbender/tools/copynumber/DetermineGermlineContigPloidy.java", "diffHunk": "@@ -108,7 +108,7 @@\n  *     counts files, and all contigs appearing in the input counts files must have a corresponding entry in the priors\n  *     table. The order of contigs is immaterial in the priors table. The highest ploidy state is determined by the\n  *     prior table (3 in the above example). A ploidy state can be strictly forbidden by setting its prior probability\n- *     to 0. For example, the X contig in the above example can only assume 0 and 1 ploidy states.</p>\n+ *     to 0. For example, the Y contig in the above example can only assume 0 and 1 ploidy states.</p>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d0c8174e86870f21669206f4b6a6f4954794c8a9"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODI0NTg2NA==", "bodyText": "Hm something strange happened here. I rebased but it's still showing up... maybe one of my commits changes it to X then another back to Y. The final result is correct though.", "url": "https://github.com/broadinstitute/gatk/pull/6536#discussion_r418245864", "createdAt": "2020-04-30T19:41:33Z", "author": {"login": "mwalker174"}, "path": "src/main/java/org/broadinstitute/hellbender/tools/copynumber/DetermineGermlineContigPloidy.java", "diffHunk": "@@ -108,7 +108,7 @@\n  *     counts files, and all contigs appearing in the input counts files must have a corresponding entry in the priors\n  *     table. The order of contigs is immaterial in the priors table. The highest ploidy state is determined by the\n  *     prior table (3 in the above example). A ploidy state can be strictly forbidden by setting its prior probability\n- *     to 0. For example, the X contig in the above example can only assume 0 and 1 ploidy states.</p>\n+ *     to 0. For example, the Y contig in the above example can only assume 0 and 1 ploidy states.</p>", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODM2MzgwMw=="}, "originalCommit": {"oid": "d0c8174e86870f21669206f4b6a6f4954794c8a9"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUzNTI2NTc1OnYy", "diffSide": "RIGHT", "path": "src/main/java/org/broadinstitute/hellbender/tools/spark/pathseq/PathSeqBwaSpark.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNFQxOTowMTo1N1rOGFcwDQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0zMFQxOTo0NToxM1rOGO30Mw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODM2NzExNw==", "bodyText": "As in cram files are not supported?", "url": "https://github.com/broadinstitute/gatk/pull/6536#discussion_r408367117", "createdAt": "2020-04-14T19:01:57Z", "author": {"login": "ldgauthier"}, "path": "src/main/java/org/broadinstitute/hellbender/tools/spark/pathseq/PathSeqBwaSpark.java", "diffHunk": "@@ -214,6 +207,7 @@ protected void runTool(final JavaSparkContext ctx) {\n         if (!readArguments.getReadFiles().isEmpty()) {\n             throw new UserException.BadInput(\"Please use --paired-input or --unpaired-input instead of --input\");\n         }\n+        Utils.validateArg(outputPaired == null || (IOUtils.isBamFileName(outputPaired)) && (outputUnpaired == null || IOUtils.isBamFileName(outputUnpaired)), \"Only BAM output is supported\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d0c8174e86870f21669206f4b6a6f4954794c8a9"}, "originalPosition": 95}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODI0NzczMQ==", "bodyText": "CRAMs are not supported, because we truncate the header so that only sequences at least one alignment appear, otherwise the header is huge.", "url": "https://github.com/broadinstitute/gatk/pull/6536#discussion_r418247731", "createdAt": "2020-04-30T19:45:13Z", "author": {"login": "mwalker174"}, "path": "src/main/java/org/broadinstitute/hellbender/tools/spark/pathseq/PathSeqBwaSpark.java", "diffHunk": "@@ -214,6 +207,7 @@ protected void runTool(final JavaSparkContext ctx) {\n         if (!readArguments.getReadFiles().isEmpty()) {\n             throw new UserException.BadInput(\"Please use --paired-input or --unpaired-input instead of --input\");\n         }\n+        Utils.validateArg(outputPaired == null || (IOUtils.isBamFileName(outputPaired)) && (outputUnpaired == null || IOUtils.isBamFileName(outputUnpaired)), \"Only BAM output is supported\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODM2NzExNw=="}, "originalCommit": {"oid": "d0c8174e86870f21669206f4b6a6f4954794c8a9"}, "originalPosition": 95}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUzNTI2NzIyOnYy", "diffSide": "RIGHT", "path": "src/main/java/org/broadinstitute/hellbender/tools/spark/pathseq/PathSeqPipelineSpark.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNFQxOTowMjoxN1rOGFcw5Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNFQxOTowMjoxN1rOGFcw5Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODM2NzMzMw==", "bodyText": "Yay!", "url": "https://github.com/broadinstitute/gatk/pull/6536#discussion_r408367333", "createdAt": "2020-04-14T19:02:17Z", "author": {"login": "ldgauthier"}, "path": "src/main/java/org/broadinstitute/hellbender/tools/spark/pathseq/PathSeqPipelineSpark.java", "diffHunk": "@@ -136,11 +136,12 @@\n  *   --conf spark.executor.memoryOverhead=132000\n  * </pre>\n  *\n- * <p>Note that the host and microbe BWA images must be copied to the same paths on every worker node. The microbe FASTA,\n+ * <p>Note that the host and microbe BWA images must be copied to the same paths on every worker node. The microbe dictionary,\n  * host k-mer file, and taxonomy file may also be copied to a single path on every worker node or to HDFS.</p>\n  *\n  * <h3>References</h3>\n  * <ol>\n+ *     <li>Walker, M. A., Pedamallu, C. S. et al. (2018). GATK PathSeq: a customizable computational tool for the discovery and identification of microbial sequences in libraries from eukaryotic hosts. Bioinformatics. 34, 4287-4289.</li>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d0c8174e86870f21669206f4b6a6f4954794c8a9"}, "originalPosition": 37}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUzNTU4NDI1OnYy", "diffSide": "RIGHT", "path": "scripts/pathseq/wdl/pathseq_pipeline_template.json", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNFQyMDozNDoyN1rOGFf3jw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNFQyMDozNDoyN1rOGFf3jw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQxODE5MQ==", "bodyText": "Does this validate?  The workflow name in the WDL is PathSeqPipeline.", "url": "https://github.com/broadinstitute/gatk/pull/6536#discussion_r408418191", "createdAt": "2020-04-14T20:34:27Z", "author": {"login": "ldgauthier"}, "path": "scripts/pathseq/wdl/pathseq_pipeline_template.json", "diffHunk": "@@ -1,19 +1,18 @@\n {\n-  \"PathSeqPipelineWorkflow.sample_name\": \"sample\",\n-  \"PathSeqPipelineWorkflow.input_bam\": \"gs://my-bucket/sample.bam\",\n+  \"PathSeqThreeStageWorkflow.sample_name\": \"sample\",", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d0c8174e86870f21669206f4b6a6f4954794c8a9"}, "originalPosition": 4}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUzNTU4OTEyOnYy", "diffSide": "RIGHT", "path": "src/main/java/org/broadinstitute/hellbender/tools/spark/pathseq/PathSeqBwaSpark.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNFQyMDozNTo0N1rOGFf6dg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNFQyMDozNTo0N1rOGFf6dg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQxODkzNA==", "bodyText": "Nice.", "url": "https://github.com/broadinstitute/gatk/pull/6536#discussion_r408418934", "createdAt": "2020-04-14T20:35:47Z", "author": {"login": "ldgauthier"}, "path": "src/main/java/org/broadinstitute/hellbender/tools/spark/pathseq/PathSeqBwaSpark.java", "diffHunk": "@@ -35,7 +36,7 @@\n  *     <li>Unaligned queryname-sorted BAM file containing only paired reads (paired-end reads with mates)</li>\n  *     <li>Unaligned BAM file containing only unpaired reads (paired-end reads without mates and/or single-end reads)</li>\n  *     <li>*Microbe reference BWA-MEM index image generated using BwaMemIndexImageCreator</li>\n- *     <li>*Indexed microbe reference FASTA file</li>\n+ *     <li>*Indexed microbe reference dictionary (fasta file NOT required)</li>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d0c8174e86870f21669206f4b6a6f4954794c8a9"}, "originalPosition": 13}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUzNTYwMjk0OnYy", "diffSide": "RIGHT", "path": "scripts/pathseq/wdl/pathseq_pipeline.wdl", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNFQyMDozOTo0OFrOGFgC2w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0zMFQxOTo0ODoyOVrOGO361Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQyMTA4Mw==", "bodyText": "Does this imply that there are samples with a mix of paired and unpaired reads, e.g. 2x150 and 1x300?  Or does unpaired mean \"not properly paired\" as in the SAM flags?", "url": "https://github.com/broadinstitute/gatk/pull/6536#discussion_r408421083", "createdAt": "2020-04-14T20:39:48Z", "author": {"login": "ldgauthier"}, "path": "scripts/pathseq/wdl/pathseq_pipeline.wdl", "diffHunk": "@@ -20,179 +26,712 @@\n ## - - one or more read groups all belong to a single sample (SM)\n ##\n ## Output:\n-## - BAM file containing microbe-mapped reads and reads of unknown sequence\n-## - Tab-separated value (.tsv) file of taxonomic abundance scores\n-## - Picard-style metrics files for the filter and scoring phases of the pipeline\n+## - non_host_paired_bam, non_host_unpaired_bam: BAM files containing quality-filtered non-host paired and unpaired reads", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d0c8174e86870f21669206f4b6a6f4954794c8a9"}, "originalPosition": 31}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODI0OTQyOQ==", "bodyText": "I think the PathSeq filtering step assumes the input is either all paired or unpaired, but many single mates get lost during filtering, so subsequent steps need to handle a mixture of both.", "url": "https://github.com/broadinstitute/gatk/pull/6536#discussion_r418249429", "createdAt": "2020-04-30T19:48:29Z", "author": {"login": "mwalker174"}, "path": "scripts/pathseq/wdl/pathseq_pipeline.wdl", "diffHunk": "@@ -20,179 +26,712 @@\n ## - - one or more read groups all belong to a single sample (SM)\n ##\n ## Output:\n-## - BAM file containing microbe-mapped reads and reads of unknown sequence\n-## - Tab-separated value (.tsv) file of taxonomic abundance scores\n-## - Picard-style metrics files for the filter and scoring phases of the pipeline\n+## - non_host_paired_bam, non_host_unpaired_bam: BAM files containing quality-filtered non-host paired and unpaired reads", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQyMTA4Mw=="}, "originalCommit": {"oid": "d0c8174e86870f21669206f4b6a6f4954794c8a9"}, "originalPosition": 31}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUzNTYxMDYyOnYy", "diffSide": "RIGHT", "path": "scripts/pathseq/wdl/pathseq_pipeline.wdl", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNFQyMDo0MTo1OFrOGFgHkg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0zMFQyMDowMDo0NFrOGO4S-Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQyMjI5MA==", "bodyText": "Since WDL error handling is effectively non-existent, I'd rather require an index for bams than code this as optional for both.", "url": "https://github.com/broadinstitute/gatk/pull/6536#discussion_r408422290", "createdAt": "2020-04-14T20:41:58Z", "author": {"login": "ldgauthier"}, "path": "scripts/pathseq/wdl/pathseq_pipeline.wdl", "diffHunk": "@@ -20,179 +26,712 @@\n ## - - one or more read groups all belong to a single sample (SM)\n ##\n ## Output:\n-## - BAM file containing microbe-mapped reads and reads of unknown sequence\n-## - Tab-separated value (.tsv) file of taxonomic abundance scores\n-## - Picard-style metrics files for the filter and scoring phases of the pipeline\n+## - non_host_paired_bam, non_host_unpaired_bam: BAM files containing quality-filtered non-host paired and unpaired reads\n+## - If filtering_only = false:\n+##   - final_bam : BAM file containing microbe-mapped reads and reads of unknown sequence\n+##   - taxonomy_scores : tab-separated value (.tsv) file of taxonomic abundance scores\n+##   - score_metrics_file : Picard-style metrics file for scoring stage\n+##   - non_host_mapped_reads : number of non-host reads mapped to microbe reference\n+##   - non_host_unmapped_reads : number of non-host reads that did not map to the microbe reference\n+## - If gather_filter_metrics = true:\n+##   - filter_metrics_file : Picard-style metrics file for filtering stage\n+##   - frac_after_prealigned_filter : estimated fraction of reads remaining after filtering prealigned host reads\n+##   - frac_after_qual_cpx_filter : estimated fraction of reads remaining after low-quality and low-complexity filtering\n+##   - frac_after_host_filter : estimated fraction of reads remaining after host read filtering\n+##   - frac_after_dedup : estimated fraction of reads remaining after deduplication\n+##   - frac_final_paired : estimated fraction of reads that were paired in the final output\n+##   - frac_final_unpaired : estimated fraction of reads that were unpaired in the final output\n+##   - frac_final_total : estimated fraction of reads in the final output\n+##   - frac_qual_cpx_filtered : estimated fraction of reads removed by low-quality/low-complexity filtering\n+##   - frac_host_filtered : estimated fraction of reads removed by host filtering\n+##   - frac_dup_filtered : estimated fraction of reads removed by deduplication\n+## - If downsample = true:\n+##   - total_reads_if_avail : total number of reads in the original input BAM\n ##\n ########################################################################################################################\n \n-task PathseqPipeline {\n+workflow PathSeqPipeline {\n \n-  # Inputs for this task\n   String sample_name\n-  File input_bam\n+  File input_bam_or_cram\n+  # Required if a cram\n+  File? input_bam_or_cram_index", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d0c8174e86870f21669206f4b6a6f4954794c8a9"}, "originalPosition": 63}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODI1NTYwOQ==", "bodyText": "This is a good point. On the other hand, I had ease-of-use in mind because this way the BAM does not need to be indexed, which is the case for uBAMs generated with most WDLs I've seen in the wild. I could change this to input_cram_index to make it less confusing, but the BAM index, when available, speeds up the Downsample task.", "url": "https://github.com/broadinstitute/gatk/pull/6536#discussion_r418255609", "createdAt": "2020-04-30T20:00:44Z", "author": {"login": "mwalker174"}, "path": "scripts/pathseq/wdl/pathseq_pipeline.wdl", "diffHunk": "@@ -20,179 +26,712 @@\n ## - - one or more read groups all belong to a single sample (SM)\n ##\n ## Output:\n-## - BAM file containing microbe-mapped reads and reads of unknown sequence\n-## - Tab-separated value (.tsv) file of taxonomic abundance scores\n-## - Picard-style metrics files for the filter and scoring phases of the pipeline\n+## - non_host_paired_bam, non_host_unpaired_bam: BAM files containing quality-filtered non-host paired and unpaired reads\n+## - If filtering_only = false:\n+##   - final_bam : BAM file containing microbe-mapped reads and reads of unknown sequence\n+##   - taxonomy_scores : tab-separated value (.tsv) file of taxonomic abundance scores\n+##   - score_metrics_file : Picard-style metrics file for scoring stage\n+##   - non_host_mapped_reads : number of non-host reads mapped to microbe reference\n+##   - non_host_unmapped_reads : number of non-host reads that did not map to the microbe reference\n+## - If gather_filter_metrics = true:\n+##   - filter_metrics_file : Picard-style metrics file for filtering stage\n+##   - frac_after_prealigned_filter : estimated fraction of reads remaining after filtering prealigned host reads\n+##   - frac_after_qual_cpx_filter : estimated fraction of reads remaining after low-quality and low-complexity filtering\n+##   - frac_after_host_filter : estimated fraction of reads remaining after host read filtering\n+##   - frac_after_dedup : estimated fraction of reads remaining after deduplication\n+##   - frac_final_paired : estimated fraction of reads that were paired in the final output\n+##   - frac_final_unpaired : estimated fraction of reads that were unpaired in the final output\n+##   - frac_final_total : estimated fraction of reads in the final output\n+##   - frac_qual_cpx_filtered : estimated fraction of reads removed by low-quality/low-complexity filtering\n+##   - frac_host_filtered : estimated fraction of reads removed by host filtering\n+##   - frac_dup_filtered : estimated fraction of reads removed by deduplication\n+## - If downsample = true:\n+##   - total_reads_if_avail : total number of reads in the original input BAM\n ##\n ########################################################################################################################\n \n-task PathseqPipeline {\n+workflow PathSeqPipeline {\n \n-  # Inputs for this task\n   String sample_name\n-  File input_bam\n+  File input_bam_or_cram\n+  # Required if a cram\n+  File? input_bam_or_cram_index", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQyMjI5MA=="}, "originalCommit": {"oid": "d0c8174e86870f21669206f4b6a6f4954794c8a9"}, "originalPosition": 63}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUzNTYxNzIzOnYy", "diffSide": "RIGHT", "path": "scripts/pathseq/wdl/pathseq_pipeline.wdl", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNFQyMDo0Mzo1NFrOGFgL1g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0zMFQyMDoyMToyOVrOGO47ig==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQyMzM4Mg==", "bodyText": "I'm hoping to retire this repo.  What do you need out of there that's not in the GATK docker?  I think we have samtools and you should be able to call DownsampleSam via GATK.", "url": "https://github.com/broadinstitute/gatk/pull/6536#discussion_r408423382", "createdAt": "2020-04-14T20:43:54Z", "author": {"login": "ldgauthier"}, "path": "scripts/pathseq/wdl/pathseq_pipeline.wdl", "diffHunk": "@@ -20,179 +26,712 @@\n ## - - one or more read groups all belong to a single sample (SM)\n ##\n ## Output:\n-## - BAM file containing microbe-mapped reads and reads of unknown sequence\n-## - Tab-separated value (.tsv) file of taxonomic abundance scores\n-## - Picard-style metrics files for the filter and scoring phases of the pipeline\n+## - non_host_paired_bam, non_host_unpaired_bam: BAM files containing quality-filtered non-host paired and unpaired reads\n+## - If filtering_only = false:\n+##   - final_bam : BAM file containing microbe-mapped reads and reads of unknown sequence\n+##   - taxonomy_scores : tab-separated value (.tsv) file of taxonomic abundance scores\n+##   - score_metrics_file : Picard-style metrics file for scoring stage\n+##   - non_host_mapped_reads : number of non-host reads mapped to microbe reference\n+##   - non_host_unmapped_reads : number of non-host reads that did not map to the microbe reference\n+## - If gather_filter_metrics = true:\n+##   - filter_metrics_file : Picard-style metrics file for filtering stage\n+##   - frac_after_prealigned_filter : estimated fraction of reads remaining after filtering prealigned host reads\n+##   - frac_after_qual_cpx_filter : estimated fraction of reads remaining after low-quality and low-complexity filtering\n+##   - frac_after_host_filter : estimated fraction of reads remaining after host read filtering\n+##   - frac_after_dedup : estimated fraction of reads remaining after deduplication\n+##   - frac_final_paired : estimated fraction of reads that were paired in the final output\n+##   - frac_final_unpaired : estimated fraction of reads that were unpaired in the final output\n+##   - frac_final_total : estimated fraction of reads in the final output\n+##   - frac_qual_cpx_filtered : estimated fraction of reads removed by low-quality/low-complexity filtering\n+##   - frac_host_filtered : estimated fraction of reads removed by host filtering\n+##   - frac_dup_filtered : estimated fraction of reads removed by deduplication\n+## - If downsample = true:\n+##   - total_reads_if_avail : total number of reads in the original input BAM\n ##\n ########################################################################################################################\n \n-task PathseqPipeline {\n+workflow PathSeqPipeline {\n \n-  # Inputs for this task\n   String sample_name\n-  File input_bam\n+  File input_bam_or_cram\n+  # Required if a cram\n+  File? input_bam_or_cram_index\n \n-  File kmer_file\n-  File filter_bwa_image\n-  File microbe_bwa_image\n-  File microbe_fasta\n-  File microbe_fasta_dict\n-  File taxonomy_file\n+  # Required if the input is a cram\n+  File? cram_reference_fasta\n+  File? cram_reference_fasta_index\n+  File? cram_reference_dict\n \n+  # Set to true if host aligned. WARNING: Results in loss of EBV reads if in the aligned reference.\n   Boolean is_host_aligned\n-  Boolean? skip_quality_filters\n+\n+  File? kmer_file\n+  File? filter_bwa_image\n+  # Required if filtering_only=true\n+  File? microbe_bwa_image\n+  File? microbe_dict\n+  File? taxonomy_file\n+\n+  # If enabled, filter metrics will be estimated using a downsampled bam with this many reads (recommended)\n+  # If disabled, no filter metrics will be generated\n+  Boolean downsample = false\n+  Int downsample_reads = 1000000\n+\n+  # Enable to only perform host filtering\n+  Boolean filtering_only = false\n+\n+  # Only recommended if downsample = true\n+  Boolean gather_filter_metrics = false\n+\n+  # This can be calculated from a downsampled run to help optimize disk allocation during filtering\n+  Float frac_non_host_reads = 1.0\n+\n+  # Filtering options\n   Boolean? filter_duplicates\n+  Boolean? skip_quality_filters\n+  Int? host_min_identity\n+  Int? host_kmer_threshold\n+  Int? filter_bwa_seed_length\n+  Int? min_clipped_read_length\n+  Int? max_masked_bases\n+  Int? min_base_quality\n+  Int? quality_threshold\n+  Int? dust_mask_quality\n+  Int? dust_window\n+  Float? dust_t\n+  Int? max_adapter_mistmatches\n+  Int? min_adapter_length\n+  Int? filter_reads_per_partition\n+  Int? filter_bam_partition_size\n   Boolean? skip_pre_bwa_repartition\n+\n+  # Alignment options\n+  Int? microbe_min_seed_length\n+  Int? max_alternate_hits\n+  Int? bwa_score_threshold\n+\n+  # Taxonomy scoring options\n   Boolean? divide_by_genome_length\n-  Int? filter_bwa_seed_length\n+  Float? min_score_identity\n+  Float? identity_margin\n+  Boolean? not_normalized_by_kingdom\n+  Int? score_reads_per_partition_estimate\n+\n+  # Runtime parameters\n+  String gatk_docker\n+  String samtools_docker = \"biocontainers/samtools:v1.9-4-deb_cv1\"\n+  String genomes_in_the_cloud_docker = \"broadinstitute/genomes-in-the-cloud:2.3.1-1512499786\"", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d0c8174e86870f21669206f4b6a6f4954794c8a9"}, "originalPosition": 136}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODI1NjI0OQ==", "bodyText": "The version of samtools on the GATK docker is ancient and wasn't working for this task.", "url": "https://github.com/broadinstitute/gatk/pull/6536#discussion_r418256249", "createdAt": "2020-04-30T20:02:06Z", "author": {"login": "mwalker174"}, "path": "scripts/pathseq/wdl/pathseq_pipeline.wdl", "diffHunk": "@@ -20,179 +26,712 @@\n ## - - one or more read groups all belong to a single sample (SM)\n ##\n ## Output:\n-## - BAM file containing microbe-mapped reads and reads of unknown sequence\n-## - Tab-separated value (.tsv) file of taxonomic abundance scores\n-## - Picard-style metrics files for the filter and scoring phases of the pipeline\n+## - non_host_paired_bam, non_host_unpaired_bam: BAM files containing quality-filtered non-host paired and unpaired reads\n+## - If filtering_only = false:\n+##   - final_bam : BAM file containing microbe-mapped reads and reads of unknown sequence\n+##   - taxonomy_scores : tab-separated value (.tsv) file of taxonomic abundance scores\n+##   - score_metrics_file : Picard-style metrics file for scoring stage\n+##   - non_host_mapped_reads : number of non-host reads mapped to microbe reference\n+##   - non_host_unmapped_reads : number of non-host reads that did not map to the microbe reference\n+## - If gather_filter_metrics = true:\n+##   - filter_metrics_file : Picard-style metrics file for filtering stage\n+##   - frac_after_prealigned_filter : estimated fraction of reads remaining after filtering prealigned host reads\n+##   - frac_after_qual_cpx_filter : estimated fraction of reads remaining after low-quality and low-complexity filtering\n+##   - frac_after_host_filter : estimated fraction of reads remaining after host read filtering\n+##   - frac_after_dedup : estimated fraction of reads remaining after deduplication\n+##   - frac_final_paired : estimated fraction of reads that were paired in the final output\n+##   - frac_final_unpaired : estimated fraction of reads that were unpaired in the final output\n+##   - frac_final_total : estimated fraction of reads in the final output\n+##   - frac_qual_cpx_filtered : estimated fraction of reads removed by low-quality/low-complexity filtering\n+##   - frac_host_filtered : estimated fraction of reads removed by host filtering\n+##   - frac_dup_filtered : estimated fraction of reads removed by deduplication\n+## - If downsample = true:\n+##   - total_reads_if_avail : total number of reads in the original input BAM\n ##\n ########################################################################################################################\n \n-task PathseqPipeline {\n+workflow PathSeqPipeline {\n \n-  # Inputs for this task\n   String sample_name\n-  File input_bam\n+  File input_bam_or_cram\n+  # Required if a cram\n+  File? input_bam_or_cram_index\n \n-  File kmer_file\n-  File filter_bwa_image\n-  File microbe_bwa_image\n-  File microbe_fasta\n-  File microbe_fasta_dict\n-  File taxonomy_file\n+  # Required if the input is a cram\n+  File? cram_reference_fasta\n+  File? cram_reference_fasta_index\n+  File? cram_reference_dict\n \n+  # Set to true if host aligned. WARNING: Results in loss of EBV reads if in the aligned reference.\n   Boolean is_host_aligned\n-  Boolean? skip_quality_filters\n+\n+  File? kmer_file\n+  File? filter_bwa_image\n+  # Required if filtering_only=true\n+  File? microbe_bwa_image\n+  File? microbe_dict\n+  File? taxonomy_file\n+\n+  # If enabled, filter metrics will be estimated using a downsampled bam with this many reads (recommended)\n+  # If disabled, no filter metrics will be generated\n+  Boolean downsample = false\n+  Int downsample_reads = 1000000\n+\n+  # Enable to only perform host filtering\n+  Boolean filtering_only = false\n+\n+  # Only recommended if downsample = true\n+  Boolean gather_filter_metrics = false\n+\n+  # This can be calculated from a downsampled run to help optimize disk allocation during filtering\n+  Float frac_non_host_reads = 1.0\n+\n+  # Filtering options\n   Boolean? filter_duplicates\n+  Boolean? skip_quality_filters\n+  Int? host_min_identity\n+  Int? host_kmer_threshold\n+  Int? filter_bwa_seed_length\n+  Int? min_clipped_read_length\n+  Int? max_masked_bases\n+  Int? min_base_quality\n+  Int? quality_threshold\n+  Int? dust_mask_quality\n+  Int? dust_window\n+  Float? dust_t\n+  Int? max_adapter_mistmatches\n+  Int? min_adapter_length\n+  Int? filter_reads_per_partition\n+  Int? filter_bam_partition_size\n   Boolean? skip_pre_bwa_repartition\n+\n+  # Alignment options\n+  Int? microbe_min_seed_length\n+  Int? max_alternate_hits\n+  Int? bwa_score_threshold\n+\n+  # Taxonomy scoring options\n   Boolean? divide_by_genome_length\n-  Int? filter_bwa_seed_length\n+  Float? min_score_identity\n+  Float? identity_margin\n+  Boolean? not_normalized_by_kingdom\n+  Int? score_reads_per_partition_estimate\n+\n+  # Runtime parameters\n+  String gatk_docker\n+  String samtools_docker = \"biocontainers/samtools:v1.9-4-deb_cv1\"\n+  String genomes_in_the_cloud_docker = \"broadinstitute/genomes-in-the-cloud:2.3.1-1512499786\"", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQyMzM4Mg=="}, "originalCommit": {"oid": "d0c8174e86870f21669206f4b6a6f4954794c8a9"}, "originalPosition": 136}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODI2NTk5NA==", "bodyText": "@lbergelson any reason we can't rev our samtools?", "url": "https://github.com/broadinstitute/gatk/pull/6536#discussion_r418265994", "createdAt": "2020-04-30T20:21:29Z", "author": {"login": "ldgauthier"}, "path": "scripts/pathseq/wdl/pathseq_pipeline.wdl", "diffHunk": "@@ -20,179 +26,712 @@\n ## - - one or more read groups all belong to a single sample (SM)\n ##\n ## Output:\n-## - BAM file containing microbe-mapped reads and reads of unknown sequence\n-## - Tab-separated value (.tsv) file of taxonomic abundance scores\n-## - Picard-style metrics files for the filter and scoring phases of the pipeline\n+## - non_host_paired_bam, non_host_unpaired_bam: BAM files containing quality-filtered non-host paired and unpaired reads\n+## - If filtering_only = false:\n+##   - final_bam : BAM file containing microbe-mapped reads and reads of unknown sequence\n+##   - taxonomy_scores : tab-separated value (.tsv) file of taxonomic abundance scores\n+##   - score_metrics_file : Picard-style metrics file for scoring stage\n+##   - non_host_mapped_reads : number of non-host reads mapped to microbe reference\n+##   - non_host_unmapped_reads : number of non-host reads that did not map to the microbe reference\n+## - If gather_filter_metrics = true:\n+##   - filter_metrics_file : Picard-style metrics file for filtering stage\n+##   - frac_after_prealigned_filter : estimated fraction of reads remaining after filtering prealigned host reads\n+##   - frac_after_qual_cpx_filter : estimated fraction of reads remaining after low-quality and low-complexity filtering\n+##   - frac_after_host_filter : estimated fraction of reads remaining after host read filtering\n+##   - frac_after_dedup : estimated fraction of reads remaining after deduplication\n+##   - frac_final_paired : estimated fraction of reads that were paired in the final output\n+##   - frac_final_unpaired : estimated fraction of reads that were unpaired in the final output\n+##   - frac_final_total : estimated fraction of reads in the final output\n+##   - frac_qual_cpx_filtered : estimated fraction of reads removed by low-quality/low-complexity filtering\n+##   - frac_host_filtered : estimated fraction of reads removed by host filtering\n+##   - frac_dup_filtered : estimated fraction of reads removed by deduplication\n+## - If downsample = true:\n+##   - total_reads_if_avail : total number of reads in the original input BAM\n ##\n ########################################################################################################################\n \n-task PathseqPipeline {\n+workflow PathSeqPipeline {\n \n-  # Inputs for this task\n   String sample_name\n-  File input_bam\n+  File input_bam_or_cram\n+  # Required if a cram\n+  File? input_bam_or_cram_index\n \n-  File kmer_file\n-  File filter_bwa_image\n-  File microbe_bwa_image\n-  File microbe_fasta\n-  File microbe_fasta_dict\n-  File taxonomy_file\n+  # Required if the input is a cram\n+  File? cram_reference_fasta\n+  File? cram_reference_fasta_index\n+  File? cram_reference_dict\n \n+  # Set to true if host aligned. WARNING: Results in loss of EBV reads if in the aligned reference.\n   Boolean is_host_aligned\n-  Boolean? skip_quality_filters\n+\n+  File? kmer_file\n+  File? filter_bwa_image\n+  # Required if filtering_only=true\n+  File? microbe_bwa_image\n+  File? microbe_dict\n+  File? taxonomy_file\n+\n+  # If enabled, filter metrics will be estimated using a downsampled bam with this many reads (recommended)\n+  # If disabled, no filter metrics will be generated\n+  Boolean downsample = false\n+  Int downsample_reads = 1000000\n+\n+  # Enable to only perform host filtering\n+  Boolean filtering_only = false\n+\n+  # Only recommended if downsample = true\n+  Boolean gather_filter_metrics = false\n+\n+  # This can be calculated from a downsampled run to help optimize disk allocation during filtering\n+  Float frac_non_host_reads = 1.0\n+\n+  # Filtering options\n   Boolean? filter_duplicates\n+  Boolean? skip_quality_filters\n+  Int? host_min_identity\n+  Int? host_kmer_threshold\n+  Int? filter_bwa_seed_length\n+  Int? min_clipped_read_length\n+  Int? max_masked_bases\n+  Int? min_base_quality\n+  Int? quality_threshold\n+  Int? dust_mask_quality\n+  Int? dust_window\n+  Float? dust_t\n+  Int? max_adapter_mistmatches\n+  Int? min_adapter_length\n+  Int? filter_reads_per_partition\n+  Int? filter_bam_partition_size\n   Boolean? skip_pre_bwa_repartition\n+\n+  # Alignment options\n+  Int? microbe_min_seed_length\n+  Int? max_alternate_hits\n+  Int? bwa_score_threshold\n+\n+  # Taxonomy scoring options\n   Boolean? divide_by_genome_length\n-  Int? filter_bwa_seed_length\n+  Float? min_score_identity\n+  Float? identity_margin\n+  Boolean? not_normalized_by_kingdom\n+  Int? score_reads_per_partition_estimate\n+\n+  # Runtime parameters\n+  String gatk_docker\n+  String samtools_docker = \"biocontainers/samtools:v1.9-4-deb_cv1\"\n+  String genomes_in_the_cloud_docker = \"broadinstitute/genomes-in-the-cloud:2.3.1-1512499786\"", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQyMzM4Mg=="}, "originalCommit": {"oid": "d0c8174e86870f21669206f4b6a6f4954794c8a9"}, "originalPosition": 136}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUzNTYzOTIwOnYy", "diffSide": "RIGHT", "path": "scripts/pathseq/wdl/pathseq_pipeline.wdl", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNFQyMDo1MDozOVrOGFgZ-g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNFQyMDo1MDozOVrOGFgZ-g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQyNzAwMg==", "bodyText": "This is a source of deep sorrow.  I may ask you to help the Hellbender team validate the htsjdk cram codec.  Pathseq seems like an application with a fun assortment of weird flags and alignments.", "url": "https://github.com/broadinstitute/gatk/pull/6536#discussion_r408427002", "createdAt": "2020-04-14T20:50:39Z", "author": {"login": "ldgauthier"}, "path": "scripts/pathseq/wdl/pathseq_pipeline.wdl", "diffHunk": "@@ -20,179 +26,712 @@\n ## - - one or more read groups all belong to a single sample (SM)\n ##\n ## Output:\n-## - BAM file containing microbe-mapped reads and reads of unknown sequence\n-## - Tab-separated value (.tsv) file of taxonomic abundance scores\n-## - Picard-style metrics files for the filter and scoring phases of the pipeline\n+## - non_host_paired_bam, non_host_unpaired_bam: BAM files containing quality-filtered non-host paired and unpaired reads\n+## - If filtering_only = false:\n+##   - final_bam : BAM file containing microbe-mapped reads and reads of unknown sequence\n+##   - taxonomy_scores : tab-separated value (.tsv) file of taxonomic abundance scores\n+##   - score_metrics_file : Picard-style metrics file for scoring stage\n+##   - non_host_mapped_reads : number of non-host reads mapped to microbe reference\n+##   - non_host_unmapped_reads : number of non-host reads that did not map to the microbe reference\n+## - If gather_filter_metrics = true:\n+##   - filter_metrics_file : Picard-style metrics file for filtering stage\n+##   - frac_after_prealigned_filter : estimated fraction of reads remaining after filtering prealigned host reads\n+##   - frac_after_qual_cpx_filter : estimated fraction of reads remaining after low-quality and low-complexity filtering\n+##   - frac_after_host_filter : estimated fraction of reads remaining after host read filtering\n+##   - frac_after_dedup : estimated fraction of reads remaining after deduplication\n+##   - frac_final_paired : estimated fraction of reads that were paired in the final output\n+##   - frac_final_unpaired : estimated fraction of reads that were unpaired in the final output\n+##   - frac_final_total : estimated fraction of reads in the final output\n+##   - frac_qual_cpx_filtered : estimated fraction of reads removed by low-quality/low-complexity filtering\n+##   - frac_host_filtered : estimated fraction of reads removed by host filtering\n+##   - frac_dup_filtered : estimated fraction of reads removed by deduplication\n+## - If downsample = true:\n+##   - total_reads_if_avail : total number of reads in the original input BAM\n ##\n ########################################################################################################################\n \n-task PathseqPipeline {\n+workflow PathSeqPipeline {\n \n-  # Inputs for this task\n   String sample_name\n-  File input_bam\n+  File input_bam_or_cram\n+  # Required if a cram\n+  File? input_bam_or_cram_index\n \n-  File kmer_file\n-  File filter_bwa_image\n-  File microbe_bwa_image\n-  File microbe_fasta\n-  File microbe_fasta_dict\n-  File taxonomy_file\n+  # Required if the input is a cram\n+  File? cram_reference_fasta\n+  File? cram_reference_fasta_index\n+  File? cram_reference_dict\n \n+  # Set to true if host aligned. WARNING: Results in loss of EBV reads if in the aligned reference.\n   Boolean is_host_aligned\n-  Boolean? skip_quality_filters\n+\n+  File? kmer_file\n+  File? filter_bwa_image\n+  # Required if filtering_only=true\n+  File? microbe_bwa_image\n+  File? microbe_dict\n+  File? taxonomy_file\n+\n+  # If enabled, filter metrics will be estimated using a downsampled bam with this many reads (recommended)\n+  # If disabled, no filter metrics will be generated\n+  Boolean downsample = false\n+  Int downsample_reads = 1000000\n+\n+  # Enable to only perform host filtering\n+  Boolean filtering_only = false\n+\n+  # Only recommended if downsample = true\n+  Boolean gather_filter_metrics = false\n+\n+  # This can be calculated from a downsampled run to help optimize disk allocation during filtering\n+  Float frac_non_host_reads = 1.0\n+\n+  # Filtering options\n   Boolean? filter_duplicates\n+  Boolean? skip_quality_filters\n+  Int? host_min_identity\n+  Int? host_kmer_threshold\n+  Int? filter_bwa_seed_length\n+  Int? min_clipped_read_length\n+  Int? max_masked_bases\n+  Int? min_base_quality\n+  Int? quality_threshold\n+  Int? dust_mask_quality\n+  Int? dust_window\n+  Float? dust_t\n+  Int? max_adapter_mistmatches\n+  Int? min_adapter_length\n+  Int? filter_reads_per_partition\n+  Int? filter_bam_partition_size\n   Boolean? skip_pre_bwa_repartition\n+\n+  # Alignment options\n+  Int? microbe_min_seed_length\n+  Int? max_alternate_hits\n+  Int? bwa_score_threshold\n+\n+  # Taxonomy scoring options\n   Boolean? divide_by_genome_length\n-  Int? filter_bwa_seed_length\n+  Float? min_score_identity\n+  Float? identity_margin\n+  Boolean? not_normalized_by_kingdom\n+  Int? score_reads_per_partition_estimate\n+\n+  # Runtime parameters\n+  String gatk_docker\n+  String samtools_docker = \"biocontainers/samtools:v1.9-4-deb_cv1\"\n+  String genomes_in_the_cloud_docker = \"broadinstitute/genomes-in-the-cloud:2.3.1-1512499786\"\n+  String linux_docker = \"ubuntu:18.10\"\n+\n+  File? gatk4_jar_override\n+\n+  Int? cram_to_bam_preemptible_attempts\n+  Int? downsample_preemptible_attempts\n+  Int? filter_preemptible_attempts\n+  Int? align_preemptible_attempts\n+  Int? score_preemptible_attempts\n+  Int? process_filter_metrics_preemptible_attempts\n+  Int? process_score_metrics_preemptible_attempts\n+\n+  Int? cram_to_bam_cpu\n+  Int? filter_cpu\n+  Int? align_cpu\n+  Int? score_cpu\n+\n+  Float? cram_to_bam_mem_gb\n+  Int? filter_mem_gb\n+  Int? align_mem_gb\n+  Int? score_mem_gb\n+\n+  Boolean? filter_ssd\n+  Boolean? align_ssd\n+  Boolean? score_ssd\n+\n+  Int? cram_to_bam_max_retries\n+\n+  # Optional input to increase all disk sizes in case of outlier sample with strange size behavior\n+  Int? cram_to_bam_additional_disk_gb\n+  Int? downsample_additional_disk_gb\n+  Int? filter_additional_disk_gb\n+  Int? align_additional_disk_gb\n+  Int? score_additional_disk_gb\n+\n+  Boolean is_bam = basename(input_bam_or_cram, \".bam\") + \".bam\" == basename(input_bam_or_cram)\n+\n+  # Convert to BAM if we have a CRAM\n+  if (!is_bam) {\n+    call CramToBam {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d0c8174e86870f21669206f4b6a6f4954794c8a9"}, "originalPosition": 176}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUzNTY0MjM0OnYy", "diffSide": "RIGHT", "path": "scripts/pathseq/wdl/pathseq_pipeline.wdl", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNFQyMDo1MTozOFrOGFgb6w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNFQyMDo1MTozOFrOGFgb6w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQyNzQ5OQ==", "bodyText": "Although you can't play this trick with a cram.  Pros and cons.", "url": "https://github.com/broadinstitute/gatk/pull/6536#discussion_r408427499", "createdAt": "2020-04-14T20:51:38Z", "author": {"login": "ldgauthier"}, "path": "scripts/pathseq/wdl/pathseq_pipeline.wdl", "diffHunk": "@@ -20,179 +26,712 @@\n ## - - one or more read groups all belong to a single sample (SM)\n ##\n ## Output:\n-## - BAM file containing microbe-mapped reads and reads of unknown sequence\n-## - Tab-separated value (.tsv) file of taxonomic abundance scores\n-## - Picard-style metrics files for the filter and scoring phases of the pipeline\n+## - non_host_paired_bam, non_host_unpaired_bam: BAM files containing quality-filtered non-host paired and unpaired reads\n+## - If filtering_only = false:\n+##   - final_bam : BAM file containing microbe-mapped reads and reads of unknown sequence\n+##   - taxonomy_scores : tab-separated value (.tsv) file of taxonomic abundance scores\n+##   - score_metrics_file : Picard-style metrics file for scoring stage\n+##   - non_host_mapped_reads : number of non-host reads mapped to microbe reference\n+##   - non_host_unmapped_reads : number of non-host reads that did not map to the microbe reference\n+## - If gather_filter_metrics = true:\n+##   - filter_metrics_file : Picard-style metrics file for filtering stage\n+##   - frac_after_prealigned_filter : estimated fraction of reads remaining after filtering prealigned host reads\n+##   - frac_after_qual_cpx_filter : estimated fraction of reads remaining after low-quality and low-complexity filtering\n+##   - frac_after_host_filter : estimated fraction of reads remaining after host read filtering\n+##   - frac_after_dedup : estimated fraction of reads remaining after deduplication\n+##   - frac_final_paired : estimated fraction of reads that were paired in the final output\n+##   - frac_final_unpaired : estimated fraction of reads that were unpaired in the final output\n+##   - frac_final_total : estimated fraction of reads in the final output\n+##   - frac_qual_cpx_filtered : estimated fraction of reads removed by low-quality/low-complexity filtering\n+##   - frac_host_filtered : estimated fraction of reads removed by host filtering\n+##   - frac_dup_filtered : estimated fraction of reads removed by deduplication\n+## - If downsample = true:\n+##   - total_reads_if_avail : total number of reads in the original input BAM\n ##\n ########################################################################################################################\n \n-task PathseqPipeline {\n+workflow PathSeqPipeline {\n \n-  # Inputs for this task\n   String sample_name\n-  File input_bam\n+  File input_bam_or_cram\n+  # Required if a cram\n+  File? input_bam_or_cram_index\n \n-  File kmer_file\n-  File filter_bwa_image\n-  File microbe_bwa_image\n-  File microbe_fasta\n-  File microbe_fasta_dict\n-  File taxonomy_file\n+  # Required if the input is a cram\n+  File? cram_reference_fasta\n+  File? cram_reference_fasta_index\n+  File? cram_reference_dict\n \n+  # Set to true if host aligned. WARNING: Results in loss of EBV reads if in the aligned reference.\n   Boolean is_host_aligned\n-  Boolean? skip_quality_filters\n+\n+  File? kmer_file\n+  File? filter_bwa_image\n+  # Required if filtering_only=true\n+  File? microbe_bwa_image\n+  File? microbe_dict\n+  File? taxonomy_file\n+\n+  # If enabled, filter metrics will be estimated using a downsampled bam with this many reads (recommended)\n+  # If disabled, no filter metrics will be generated\n+  Boolean downsample = false\n+  Int downsample_reads = 1000000\n+\n+  # Enable to only perform host filtering\n+  Boolean filtering_only = false\n+\n+  # Only recommended if downsample = true\n+  Boolean gather_filter_metrics = false\n+\n+  # This can be calculated from a downsampled run to help optimize disk allocation during filtering\n+  Float frac_non_host_reads = 1.0\n+\n+  # Filtering options\n   Boolean? filter_duplicates\n+  Boolean? skip_quality_filters\n+  Int? host_min_identity\n+  Int? host_kmer_threshold\n+  Int? filter_bwa_seed_length\n+  Int? min_clipped_read_length\n+  Int? max_masked_bases\n+  Int? min_base_quality\n+  Int? quality_threshold\n+  Int? dust_mask_quality\n+  Int? dust_window\n+  Float? dust_t\n+  Int? max_adapter_mistmatches\n+  Int? min_adapter_length\n+  Int? filter_reads_per_partition\n+  Int? filter_bam_partition_size\n   Boolean? skip_pre_bwa_repartition\n+\n+  # Alignment options\n+  Int? microbe_min_seed_length\n+  Int? max_alternate_hits\n+  Int? bwa_score_threshold\n+\n+  # Taxonomy scoring options\n   Boolean? divide_by_genome_length\n-  Int? filter_bwa_seed_length\n+  Float? min_score_identity\n+  Float? identity_margin\n+  Boolean? not_normalized_by_kingdom\n+  Int? score_reads_per_partition_estimate\n+\n+  # Runtime parameters\n+  String gatk_docker\n+  String samtools_docker = \"biocontainers/samtools:v1.9-4-deb_cv1\"\n+  String genomes_in_the_cloud_docker = \"broadinstitute/genomes-in-the-cloud:2.3.1-1512499786\"\n+  String linux_docker = \"ubuntu:18.10\"\n+\n+  File? gatk4_jar_override\n+\n+  Int? cram_to_bam_preemptible_attempts\n+  Int? downsample_preemptible_attempts\n+  Int? filter_preemptible_attempts\n+  Int? align_preemptible_attempts\n+  Int? score_preemptible_attempts\n+  Int? process_filter_metrics_preemptible_attempts\n+  Int? process_score_metrics_preemptible_attempts\n+\n+  Int? cram_to_bam_cpu\n+  Int? filter_cpu\n+  Int? align_cpu\n+  Int? score_cpu\n+\n+  Float? cram_to_bam_mem_gb\n+  Int? filter_mem_gb\n+  Int? align_mem_gb\n+  Int? score_mem_gb\n+\n+  Boolean? filter_ssd\n+  Boolean? align_ssd\n+  Boolean? score_ssd\n+\n+  Int? cram_to_bam_max_retries\n+\n+  # Optional input to increase all disk sizes in case of outlier sample with strange size behavior\n+  Int? cram_to_bam_additional_disk_gb\n+  Int? downsample_additional_disk_gb\n+  Int? filter_additional_disk_gb\n+  Int? align_additional_disk_gb\n+  Int? score_additional_disk_gb\n+\n+  Boolean is_bam = basename(input_bam_or_cram, \".bam\") + \".bam\" == basename(input_bam_or_cram)\n+\n+  # Convert to BAM if we have a CRAM\n+  if (!is_bam) {\n+    call CramToBam {\n+      input:\n+        cram_file = input_bam_or_cram,\n+        cram_index = select_first([input_bam_or_cram_index]),\n+        reference_fasta = select_first([cram_reference_fasta]),\n+        reference_index = select_first([cram_reference_fasta_index]),\n+        docker = samtools_docker,\n+        cpu = cram_to_bam_cpu,\n+        mem_gb = cram_to_bam_mem_gb,\n+        extra_disk_gb = cram_to_bam_additional_disk_gb,\n+        preemptible = cram_to_bam_preemptible_attempts,\n+        max_retries = cram_to_bam_max_retries,\n+    }\n+  }\n+\n+  File bam_file = select_first([CramToBam.bam_file, input_bam_or_cram])\n+  File? bam_index = if defined(CramToBam.bam_index) then CramToBam.bam_index else input_bam_or_cram_index\n+\n+  # Downsample bam for filter metrics estimation\n+  if (downsample) {\n+    call Downsample {\n+      input:\n+        input_bam_file=bam_file,\n+        input_bam_index_file=bam_index,\n+        downsampled_bam_filename=\"${sample_name}.downsampled.bam\",\n+        reads_after_downsampling=downsample_reads,\n+        additional_disk_gb=downsample_additional_disk_gb,\n+        preemptible_tries=downsample_preemptible_attempts,\n+        docker=genomes_in_the_cloud_docker\n+    }\n+  }\n+\n+  call PathSeqFilter {\n+    input:\n+      sample_name=sample_name,\n+      input_bam_or_cram=select_first([Downsample.output_bam_file, bam_file]),\n+      kmer_file=kmer_file,\n+      filter_bwa_image=filter_bwa_image,\n+      frac_non_host_reads=frac_non_host_reads,\n+      gather_metrics=gather_filter_metrics,\n+      is_host_aligned=is_host_aligned,\n+      filter_duplicates=filter_duplicates,\n+      skip_quality_filters=skip_quality_filters,\n+      min_clipped_read_length=min_clipped_read_length,\n+      bam_partition_size=filter_bam_partition_size,\n+      host_min_identity=host_min_identity,\n+      filter_bwa_seed_length=filter_bwa_seed_length,\n+      max_masked_bases=max_masked_bases,\n+      min_base_quality=min_base_quality,\n+      quality_threshold=quality_threshold,\n+      dust_mask_quality=dust_mask_quality,\n+      dust_window=dust_window,\n+      dust_t=dust_t,\n+      host_kmer_threshold=host_kmer_threshold,\n+      max_adapter_mistmatches=max_adapter_mistmatches,\n+      min_adapter_length=min_adapter_length,\n+      filter_reads_per_partition=filter_reads_per_partition,\n+      skip_pre_bwa_repartition=skip_pre_bwa_repartition,\n+      gatk4_jar_override=gatk4_jar_override,\n+      mem_gb=filter_mem_gb,\n+      gatk_docker=gatk_docker,\n+      preemptible_attempts=filter_preemptible_attempts,\n+      additional_disk_gb=filter_additional_disk_gb,\n+      cpu=filter_cpu,\n+      use_ssd=filter_ssd\n+  }\n+\n+  if (gather_filter_metrics) {\n+    call ProcessFilterMetrics {\n+      input:\n+        metrics_file=PathSeqFilter.filter_metrics,\n+        preemptible_tries=process_filter_metrics_preemptible_attempts,\n+        docker=linux_docker\n+    }\n+  }\n+\n+  if (!filtering_only) {\n+    call PathSeqAlign {\n+      input:\n+        sample_name=sample_name,\n+        input_paired_bam=PathSeqFilter.paired_bam_out,\n+        input_unpaired_bam=PathSeqFilter.unpaired_bam_out,\n+        microbe_bwa_image=select_first([microbe_bwa_image]),\n+        microbe_dict=select_first([microbe_dict]),\n+        microbe_min_seed_length=microbe_min_seed_length,\n+        max_alternate_hits=max_alternate_hits,\n+        bwa_score_threshold=bwa_score_threshold,\n+        gatk4_jar_override=gatk4_jar_override,\n+        mem_gb=align_mem_gb,\n+        gatk_docker=gatk_docker,\n+        preemptible_attempts=align_preemptible_attempts,\n+        additional_disk_gb=align_additional_disk_gb,\n+        cpu=align_cpu,\n+        use_ssd=align_ssd\n+    }\n+\n+    call PathSeqScore {\n+      input:\n+        sample_name=sample_name,\n+        input_paired_bam=PathSeqAlign.paired_bam_out,\n+        input_unpaired_bam=PathSeqAlign.unpaired_bam_out,\n+        taxonomy_file=select_first([taxonomy_file]),\n+        divide_by_genome_length=divide_by_genome_length,\n+        min_score_identity=min_score_identity,\n+        identity_margin=identity_margin,\n+        not_normalized_by_kingdom=not_normalized_by_kingdom,\n+        score_reads_per_partition_estimate=score_reads_per_partition_estimate,\n+        gatk4_jar_override=gatk4_jar_override,\n+        mem_gb=score_mem_gb,\n+        gatk_docker=gatk_docker,\n+        preemptible_attempts=score_preemptible_attempts,\n+        additional_disk_gb=score_additional_disk_gb,\n+        cpu=score_cpu,\n+        use_ssd=score_ssd\n+    }\n+\n+    call ProcessScoreMetrics {\n+      input:\n+        metrics_file=PathSeqScore.score_metrics,\n+        preemptible_tries=process_score_metrics_preemptible_attempts,\n+        docker=linux_docker\n+    }\n+  }\n+\n+  output {\n+    # Filtered non-host reads\n+    File non_host_paired_bam = PathSeqFilter.paired_bam_out\n+    File non_host_unpaired_bam = PathSeqFilter.unpaired_bam_out\n+\n+    # Only generated if filtering_only=false\n+    File? final_bam = PathSeqScore.bam_out\n+    File? taxonomy_scores = PathSeqScore.scores\n+    File? score_metrics_file = PathSeqScore.score_metrics\n+    Int? non_host_mapped_reads = ProcessScoreMetrics.non_host_mapped_reads\n+    Int? non_host_unmapped_reads = ProcessScoreMetrics.non_host_unmapped_reads\n+\n+    # Only generated if gather_filter_metrics=true\n+    File? filter_metrics_file = ProcessFilterMetrics.metrics_file_out\n+    Float? frac_after_prealigned_filter = ProcessFilterMetrics.frac_after_prealigned_filter\n+    Float? frac_after_qual_cpx_filter = ProcessFilterMetrics.frac_after_qual_cpx_filter\n+    Float? frac_after_host_filter = ProcessFilterMetrics.frac_after_host_filter\n+    Float? frac_after_dedup = ProcessFilterMetrics.frac_after_dedup\n+    Float? frac_non_host_paired = ProcessFilterMetrics.frac_final_paired\n+    Float? frac_non_host_unpaired = ProcessFilterMetrics.frac_final_unpaired\n+    Float? frac_non_host_total =ProcessFilterMetrics.frac_final_total\n+    Float? frac_qual_cpx_filtered = ProcessFilterMetrics.frac_qual_cpx_filtered\n+    Float? frac_host_filtered = ProcessFilterMetrics.frac_host_filtered\n+    Float? frac_dup_filtered = ProcessFilterMetrics.frac_dup_filtered\n+\n+    # Only generated if downsample=true\n+    Int? total_reads = Downsample.total_reads\n+  }\n+}\n+\n+task CramToBam {\n+  File cram_file\n+  File? cram_index\n+  File reference_fasta\n+  File? reference_index\n+\n+  String docker\n+\n+  Int? cpu = 4\n+  Float? mem_gb = 15\n+  Int? extra_disk_gb = 10\n+  Int? preemptible = 3\n+  Int? max_retries = 1\n+\n+  String bam_file_name = basename(cram_file, \".cram\") + \".bam\"\n+\n+  File cram_index_file = select_first([cram_index, cram_file + \".crai\"])\n+  File reference_index_file = select_first([reference_index, reference_fasta + \".fai\"])\n+\n+  Float cram_inflate_ratio = 3.0\n+  Float cram_size = size(cram_file, \"GiB\")\n+  Float cram_index_size = size(cram_index_file, \"GiB\")\n+  Float bam_size = cram_inflate_ratio * cram_size\n+  Float bam_index_size = cram_index_size\n+  Float ref_size = size(reference_fasta, \"GiB\")\n+  Float ref_index_size = size(reference_index_file, \"GiB\")\n+  Int vm_disk_size = ceil(cram_size + cram_index_size + bam_size + bam_index_size + ref_size + ref_index_size + extra_disk_gb)\n+\n+  output {\n+    File bam_file = bam_file_name\n+    File bam_index = bam_file_name + \".bai\"\n+  }\n+  command <<<\n+\n+        set -Eeuo pipefail\n+\n+        # covert cram to bam\n+        samtools view  -@ ${cpu} -h -b -T \"${reference_fasta}\" -o \"${bam_file_name}\" \"${cram_file}\"\n+\n+        # index bam file\n+        samtools index -@ ${cpu} \"${bam_file_name}\"\n+\n+  >>>\n+  runtime {\n+    cpu: 1\n+    memory: mem_gb + \" GiB\"\n+    disks: \"local-disk \" + vm_disk_size + \" HDD\"\n+    bootDiskSizeGb: 10\n+    docker: docker\n+    preemptible: preemptible\n+    maxRetries: max_retries\n+  }\n+}\n+\n+# Downsamples BAM to a specified number of reads\n+task Downsample {\n+  File input_bam_file\n+  File? input_bam_index_file\n+  String downsampled_bam_filename\n+\n+  Int reads_after_downsampling\n+\n+  String docker\n+  Int additional_disk_gb = 20\n+  Int preemptible_tries = 3\n+\n+  Int disk_size = ceil(size(input_bam_file, \"GB\")*2 + additional_disk_gb)\n+\n+  command <<<\n+    set -euo pipefail\n+    if ${defined(input_bam_index_file)}; then\n+      NUM_READS=`samtools idxstats ${input_bam_file} | awk '{s+=$3+$4} END {print s}'`", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d0c8174e86870f21669206f4b6a6f4954794c8a9"}, "originalPosition": 401}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUzNTY0NzM2OnYy", "diffSide": "RIGHT", "path": "scripts/pathseq/wdl/pathseq_pipeline.wdl", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNFQyMDo1MzowMlrOGFge7g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yN1QyMTozOToyN1rOGbeGxw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQyODI3MA==", "bodyText": "To call this from GATK I think the args will go to -I, -O, --VALIDATON_STRINGENCY and maybe --P?", "url": "https://github.com/broadinstitute/gatk/pull/6536#discussion_r408428270", "createdAt": "2020-04-14T20:53:02Z", "author": {"login": "ldgauthier"}, "path": "scripts/pathseq/wdl/pathseq_pipeline.wdl", "diffHunk": "@@ -20,179 +26,712 @@\n ## - - one or more read groups all belong to a single sample (SM)\n ##\n ## Output:\n-## - BAM file containing microbe-mapped reads and reads of unknown sequence\n-## - Tab-separated value (.tsv) file of taxonomic abundance scores\n-## - Picard-style metrics files for the filter and scoring phases of the pipeline\n+## - non_host_paired_bam, non_host_unpaired_bam: BAM files containing quality-filtered non-host paired and unpaired reads\n+## - If filtering_only = false:\n+##   - final_bam : BAM file containing microbe-mapped reads and reads of unknown sequence\n+##   - taxonomy_scores : tab-separated value (.tsv) file of taxonomic abundance scores\n+##   - score_metrics_file : Picard-style metrics file for scoring stage\n+##   - non_host_mapped_reads : number of non-host reads mapped to microbe reference\n+##   - non_host_unmapped_reads : number of non-host reads that did not map to the microbe reference\n+## - If gather_filter_metrics = true:\n+##   - filter_metrics_file : Picard-style metrics file for filtering stage\n+##   - frac_after_prealigned_filter : estimated fraction of reads remaining after filtering prealigned host reads\n+##   - frac_after_qual_cpx_filter : estimated fraction of reads remaining after low-quality and low-complexity filtering\n+##   - frac_after_host_filter : estimated fraction of reads remaining after host read filtering\n+##   - frac_after_dedup : estimated fraction of reads remaining after deduplication\n+##   - frac_final_paired : estimated fraction of reads that were paired in the final output\n+##   - frac_final_unpaired : estimated fraction of reads that were unpaired in the final output\n+##   - frac_final_total : estimated fraction of reads in the final output\n+##   - frac_qual_cpx_filtered : estimated fraction of reads removed by low-quality/low-complexity filtering\n+##   - frac_host_filtered : estimated fraction of reads removed by host filtering\n+##   - frac_dup_filtered : estimated fraction of reads removed by deduplication\n+## - If downsample = true:\n+##   - total_reads_if_avail : total number of reads in the original input BAM\n ##\n ########################################################################################################################\n \n-task PathseqPipeline {\n+workflow PathSeqPipeline {\n \n-  # Inputs for this task\n   String sample_name\n-  File input_bam\n+  File input_bam_or_cram\n+  # Required if a cram\n+  File? input_bam_or_cram_index\n \n-  File kmer_file\n-  File filter_bwa_image\n-  File microbe_bwa_image\n-  File microbe_fasta\n-  File microbe_fasta_dict\n-  File taxonomy_file\n+  # Required if the input is a cram\n+  File? cram_reference_fasta\n+  File? cram_reference_fasta_index\n+  File? cram_reference_dict\n \n+  # Set to true if host aligned. WARNING: Results in loss of EBV reads if in the aligned reference.\n   Boolean is_host_aligned\n-  Boolean? skip_quality_filters\n+\n+  File? kmer_file\n+  File? filter_bwa_image\n+  # Required if filtering_only=true\n+  File? microbe_bwa_image\n+  File? microbe_dict\n+  File? taxonomy_file\n+\n+  # If enabled, filter metrics will be estimated using a downsampled bam with this many reads (recommended)\n+  # If disabled, no filter metrics will be generated\n+  Boolean downsample = false\n+  Int downsample_reads = 1000000\n+\n+  # Enable to only perform host filtering\n+  Boolean filtering_only = false\n+\n+  # Only recommended if downsample = true\n+  Boolean gather_filter_metrics = false\n+\n+  # This can be calculated from a downsampled run to help optimize disk allocation during filtering\n+  Float frac_non_host_reads = 1.0\n+\n+  # Filtering options\n   Boolean? filter_duplicates\n+  Boolean? skip_quality_filters\n+  Int? host_min_identity\n+  Int? host_kmer_threshold\n+  Int? filter_bwa_seed_length\n+  Int? min_clipped_read_length\n+  Int? max_masked_bases\n+  Int? min_base_quality\n+  Int? quality_threshold\n+  Int? dust_mask_quality\n+  Int? dust_window\n+  Float? dust_t\n+  Int? max_adapter_mistmatches\n+  Int? min_adapter_length\n+  Int? filter_reads_per_partition\n+  Int? filter_bam_partition_size\n   Boolean? skip_pre_bwa_repartition\n+\n+  # Alignment options\n+  Int? microbe_min_seed_length\n+  Int? max_alternate_hits\n+  Int? bwa_score_threshold\n+\n+  # Taxonomy scoring options\n   Boolean? divide_by_genome_length\n-  Int? filter_bwa_seed_length\n+  Float? min_score_identity\n+  Float? identity_margin\n+  Boolean? not_normalized_by_kingdom\n+  Int? score_reads_per_partition_estimate\n+\n+  # Runtime parameters\n+  String gatk_docker\n+  String samtools_docker = \"biocontainers/samtools:v1.9-4-deb_cv1\"\n+  String genomes_in_the_cloud_docker = \"broadinstitute/genomes-in-the-cloud:2.3.1-1512499786\"\n+  String linux_docker = \"ubuntu:18.10\"\n+\n+  File? gatk4_jar_override\n+\n+  Int? cram_to_bam_preemptible_attempts\n+  Int? downsample_preemptible_attempts\n+  Int? filter_preemptible_attempts\n+  Int? align_preemptible_attempts\n+  Int? score_preemptible_attempts\n+  Int? process_filter_metrics_preemptible_attempts\n+  Int? process_score_metrics_preemptible_attempts\n+\n+  Int? cram_to_bam_cpu\n+  Int? filter_cpu\n+  Int? align_cpu\n+  Int? score_cpu\n+\n+  Float? cram_to_bam_mem_gb\n+  Int? filter_mem_gb\n+  Int? align_mem_gb\n+  Int? score_mem_gb\n+\n+  Boolean? filter_ssd\n+  Boolean? align_ssd\n+  Boolean? score_ssd\n+\n+  Int? cram_to_bam_max_retries\n+\n+  # Optional input to increase all disk sizes in case of outlier sample with strange size behavior\n+  Int? cram_to_bam_additional_disk_gb\n+  Int? downsample_additional_disk_gb\n+  Int? filter_additional_disk_gb\n+  Int? align_additional_disk_gb\n+  Int? score_additional_disk_gb\n+\n+  Boolean is_bam = basename(input_bam_or_cram, \".bam\") + \".bam\" == basename(input_bam_or_cram)\n+\n+  # Convert to BAM if we have a CRAM\n+  if (!is_bam) {\n+    call CramToBam {\n+      input:\n+        cram_file = input_bam_or_cram,\n+        cram_index = select_first([input_bam_or_cram_index]),\n+        reference_fasta = select_first([cram_reference_fasta]),\n+        reference_index = select_first([cram_reference_fasta_index]),\n+        docker = samtools_docker,\n+        cpu = cram_to_bam_cpu,\n+        mem_gb = cram_to_bam_mem_gb,\n+        extra_disk_gb = cram_to_bam_additional_disk_gb,\n+        preemptible = cram_to_bam_preemptible_attempts,\n+        max_retries = cram_to_bam_max_retries,\n+    }\n+  }\n+\n+  File bam_file = select_first([CramToBam.bam_file, input_bam_or_cram])\n+  File? bam_index = if defined(CramToBam.bam_index) then CramToBam.bam_index else input_bam_or_cram_index\n+\n+  # Downsample bam for filter metrics estimation\n+  if (downsample) {\n+    call Downsample {\n+      input:\n+        input_bam_file=bam_file,\n+        input_bam_index_file=bam_index,\n+        downsampled_bam_filename=\"${sample_name}.downsampled.bam\",\n+        reads_after_downsampling=downsample_reads,\n+        additional_disk_gb=downsample_additional_disk_gb,\n+        preemptible_tries=downsample_preemptible_attempts,\n+        docker=genomes_in_the_cloud_docker\n+    }\n+  }\n+\n+  call PathSeqFilter {\n+    input:\n+      sample_name=sample_name,\n+      input_bam_or_cram=select_first([Downsample.output_bam_file, bam_file]),\n+      kmer_file=kmer_file,\n+      filter_bwa_image=filter_bwa_image,\n+      frac_non_host_reads=frac_non_host_reads,\n+      gather_metrics=gather_filter_metrics,\n+      is_host_aligned=is_host_aligned,\n+      filter_duplicates=filter_duplicates,\n+      skip_quality_filters=skip_quality_filters,\n+      min_clipped_read_length=min_clipped_read_length,\n+      bam_partition_size=filter_bam_partition_size,\n+      host_min_identity=host_min_identity,\n+      filter_bwa_seed_length=filter_bwa_seed_length,\n+      max_masked_bases=max_masked_bases,\n+      min_base_quality=min_base_quality,\n+      quality_threshold=quality_threshold,\n+      dust_mask_quality=dust_mask_quality,\n+      dust_window=dust_window,\n+      dust_t=dust_t,\n+      host_kmer_threshold=host_kmer_threshold,\n+      max_adapter_mistmatches=max_adapter_mistmatches,\n+      min_adapter_length=min_adapter_length,\n+      filter_reads_per_partition=filter_reads_per_partition,\n+      skip_pre_bwa_repartition=skip_pre_bwa_repartition,\n+      gatk4_jar_override=gatk4_jar_override,\n+      mem_gb=filter_mem_gb,\n+      gatk_docker=gatk_docker,\n+      preemptible_attempts=filter_preemptible_attempts,\n+      additional_disk_gb=filter_additional_disk_gb,\n+      cpu=filter_cpu,\n+      use_ssd=filter_ssd\n+  }\n+\n+  if (gather_filter_metrics) {\n+    call ProcessFilterMetrics {\n+      input:\n+        metrics_file=PathSeqFilter.filter_metrics,\n+        preemptible_tries=process_filter_metrics_preemptible_attempts,\n+        docker=linux_docker\n+    }\n+  }\n+\n+  if (!filtering_only) {\n+    call PathSeqAlign {\n+      input:\n+        sample_name=sample_name,\n+        input_paired_bam=PathSeqFilter.paired_bam_out,\n+        input_unpaired_bam=PathSeqFilter.unpaired_bam_out,\n+        microbe_bwa_image=select_first([microbe_bwa_image]),\n+        microbe_dict=select_first([microbe_dict]),\n+        microbe_min_seed_length=microbe_min_seed_length,\n+        max_alternate_hits=max_alternate_hits,\n+        bwa_score_threshold=bwa_score_threshold,\n+        gatk4_jar_override=gatk4_jar_override,\n+        mem_gb=align_mem_gb,\n+        gatk_docker=gatk_docker,\n+        preemptible_attempts=align_preemptible_attempts,\n+        additional_disk_gb=align_additional_disk_gb,\n+        cpu=align_cpu,\n+        use_ssd=align_ssd\n+    }\n+\n+    call PathSeqScore {\n+      input:\n+        sample_name=sample_name,\n+        input_paired_bam=PathSeqAlign.paired_bam_out,\n+        input_unpaired_bam=PathSeqAlign.unpaired_bam_out,\n+        taxonomy_file=select_first([taxonomy_file]),\n+        divide_by_genome_length=divide_by_genome_length,\n+        min_score_identity=min_score_identity,\n+        identity_margin=identity_margin,\n+        not_normalized_by_kingdom=not_normalized_by_kingdom,\n+        score_reads_per_partition_estimate=score_reads_per_partition_estimate,\n+        gatk4_jar_override=gatk4_jar_override,\n+        mem_gb=score_mem_gb,\n+        gatk_docker=gatk_docker,\n+        preemptible_attempts=score_preemptible_attempts,\n+        additional_disk_gb=score_additional_disk_gb,\n+        cpu=score_cpu,\n+        use_ssd=score_ssd\n+    }\n+\n+    call ProcessScoreMetrics {\n+      input:\n+        metrics_file=PathSeqScore.score_metrics,\n+        preemptible_tries=process_score_metrics_preemptible_attempts,\n+        docker=linux_docker\n+    }\n+  }\n+\n+  output {\n+    # Filtered non-host reads\n+    File non_host_paired_bam = PathSeqFilter.paired_bam_out\n+    File non_host_unpaired_bam = PathSeqFilter.unpaired_bam_out\n+\n+    # Only generated if filtering_only=false\n+    File? final_bam = PathSeqScore.bam_out\n+    File? taxonomy_scores = PathSeqScore.scores\n+    File? score_metrics_file = PathSeqScore.score_metrics\n+    Int? non_host_mapped_reads = ProcessScoreMetrics.non_host_mapped_reads\n+    Int? non_host_unmapped_reads = ProcessScoreMetrics.non_host_unmapped_reads\n+\n+    # Only generated if gather_filter_metrics=true\n+    File? filter_metrics_file = ProcessFilterMetrics.metrics_file_out\n+    Float? frac_after_prealigned_filter = ProcessFilterMetrics.frac_after_prealigned_filter\n+    Float? frac_after_qual_cpx_filter = ProcessFilterMetrics.frac_after_qual_cpx_filter\n+    Float? frac_after_host_filter = ProcessFilterMetrics.frac_after_host_filter\n+    Float? frac_after_dedup = ProcessFilterMetrics.frac_after_dedup\n+    Float? frac_non_host_paired = ProcessFilterMetrics.frac_final_paired\n+    Float? frac_non_host_unpaired = ProcessFilterMetrics.frac_final_unpaired\n+    Float? frac_non_host_total =ProcessFilterMetrics.frac_final_total\n+    Float? frac_qual_cpx_filtered = ProcessFilterMetrics.frac_qual_cpx_filtered\n+    Float? frac_host_filtered = ProcessFilterMetrics.frac_host_filtered\n+    Float? frac_dup_filtered = ProcessFilterMetrics.frac_dup_filtered\n+\n+    # Only generated if downsample=true\n+    Int? total_reads = Downsample.total_reads\n+  }\n+}\n+\n+task CramToBam {\n+  File cram_file\n+  File? cram_index\n+  File reference_fasta\n+  File? reference_index\n+\n+  String docker\n+\n+  Int? cpu = 4\n+  Float? mem_gb = 15\n+  Int? extra_disk_gb = 10\n+  Int? preemptible = 3\n+  Int? max_retries = 1\n+\n+  String bam_file_name = basename(cram_file, \".cram\") + \".bam\"\n+\n+  File cram_index_file = select_first([cram_index, cram_file + \".crai\"])\n+  File reference_index_file = select_first([reference_index, reference_fasta + \".fai\"])\n+\n+  Float cram_inflate_ratio = 3.0\n+  Float cram_size = size(cram_file, \"GiB\")\n+  Float cram_index_size = size(cram_index_file, \"GiB\")\n+  Float bam_size = cram_inflate_ratio * cram_size\n+  Float bam_index_size = cram_index_size\n+  Float ref_size = size(reference_fasta, \"GiB\")\n+  Float ref_index_size = size(reference_index_file, \"GiB\")\n+  Int vm_disk_size = ceil(cram_size + cram_index_size + bam_size + bam_index_size + ref_size + ref_index_size + extra_disk_gb)\n+\n+  output {\n+    File bam_file = bam_file_name\n+    File bam_index = bam_file_name + \".bai\"\n+  }\n+  command <<<\n+\n+        set -Eeuo pipefail\n+\n+        # covert cram to bam\n+        samtools view  -@ ${cpu} -h -b -T \"${reference_fasta}\" -o \"${bam_file_name}\" \"${cram_file}\"\n+\n+        # index bam file\n+        samtools index -@ ${cpu} \"${bam_file_name}\"\n+\n+  >>>\n+  runtime {\n+    cpu: 1\n+    memory: mem_gb + \" GiB\"\n+    disks: \"local-disk \" + vm_disk_size + \" HDD\"\n+    bootDiskSizeGb: 10\n+    docker: docker\n+    preemptible: preemptible\n+    maxRetries: max_retries\n+  }\n+}\n+\n+# Downsamples BAM to a specified number of reads\n+task Downsample {\n+  File input_bam_file\n+  File? input_bam_index_file\n+  String downsampled_bam_filename\n+\n+  Int reads_after_downsampling\n+\n+  String docker\n+  Int additional_disk_gb = 20\n+  Int preemptible_tries = 3\n+\n+  Int disk_size = ceil(size(input_bam_file, \"GB\")*2 + additional_disk_gb)\n+\n+  command <<<\n+    set -euo pipefail\n+    if ${defined(input_bam_index_file)}; then\n+      NUM_READS=`samtools idxstats ${input_bam_file} | awk '{s+=$3+$4} END {print s}'`\n+    else\n+      NUM_READS=`samtools view -c ${input_bam_file}`\n+    fi\n+    P_DOWNSAMPLE=`python -c \"print ${reads_after_downsampling}/float($NUM_READS)\"`\n+    RESULT=`python -c \"print $P_DOWNSAMPLE > 1\"`\n+    if [ \"$RESULT\" == \"True\" ]\n+    then\n+        P_DOWNSAMPLE=\"1\"\n+    fi\n+    echo $NUM_READS > num_reads.txt\n+    java -Xmx2000m -jar /usr/gitc/picard.jar \\\n+      DownsampleSam \\\n+      INPUT=${input_bam_file} \\", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d0c8174e86870f21669206f4b6a6f4954794c8a9"}, "originalPosition": 414}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTQ1Nzk5MQ==", "bodyText": "Changed this to use GATK instead of Picard", "url": "https://github.com/broadinstitute/gatk/pull/6536#discussion_r431457991", "createdAt": "2020-05-27T21:39:27Z", "author": {"login": "mwalker174"}, "path": "scripts/pathseq/wdl/pathseq_pipeline.wdl", "diffHunk": "@@ -20,179 +26,712 @@\n ## - - one or more read groups all belong to a single sample (SM)\n ##\n ## Output:\n-## - BAM file containing microbe-mapped reads and reads of unknown sequence\n-## - Tab-separated value (.tsv) file of taxonomic abundance scores\n-## - Picard-style metrics files for the filter and scoring phases of the pipeline\n+## - non_host_paired_bam, non_host_unpaired_bam: BAM files containing quality-filtered non-host paired and unpaired reads\n+## - If filtering_only = false:\n+##   - final_bam : BAM file containing microbe-mapped reads and reads of unknown sequence\n+##   - taxonomy_scores : tab-separated value (.tsv) file of taxonomic abundance scores\n+##   - score_metrics_file : Picard-style metrics file for scoring stage\n+##   - non_host_mapped_reads : number of non-host reads mapped to microbe reference\n+##   - non_host_unmapped_reads : number of non-host reads that did not map to the microbe reference\n+## - If gather_filter_metrics = true:\n+##   - filter_metrics_file : Picard-style metrics file for filtering stage\n+##   - frac_after_prealigned_filter : estimated fraction of reads remaining after filtering prealigned host reads\n+##   - frac_after_qual_cpx_filter : estimated fraction of reads remaining after low-quality and low-complexity filtering\n+##   - frac_after_host_filter : estimated fraction of reads remaining after host read filtering\n+##   - frac_after_dedup : estimated fraction of reads remaining after deduplication\n+##   - frac_final_paired : estimated fraction of reads that were paired in the final output\n+##   - frac_final_unpaired : estimated fraction of reads that were unpaired in the final output\n+##   - frac_final_total : estimated fraction of reads in the final output\n+##   - frac_qual_cpx_filtered : estimated fraction of reads removed by low-quality/low-complexity filtering\n+##   - frac_host_filtered : estimated fraction of reads removed by host filtering\n+##   - frac_dup_filtered : estimated fraction of reads removed by deduplication\n+## - If downsample = true:\n+##   - total_reads_if_avail : total number of reads in the original input BAM\n ##\n ########################################################################################################################\n \n-task PathseqPipeline {\n+workflow PathSeqPipeline {\n \n-  # Inputs for this task\n   String sample_name\n-  File input_bam\n+  File input_bam_or_cram\n+  # Required if a cram\n+  File? input_bam_or_cram_index\n \n-  File kmer_file\n-  File filter_bwa_image\n-  File microbe_bwa_image\n-  File microbe_fasta\n-  File microbe_fasta_dict\n-  File taxonomy_file\n+  # Required if the input is a cram\n+  File? cram_reference_fasta\n+  File? cram_reference_fasta_index\n+  File? cram_reference_dict\n \n+  # Set to true if host aligned. WARNING: Results in loss of EBV reads if in the aligned reference.\n   Boolean is_host_aligned\n-  Boolean? skip_quality_filters\n+\n+  File? kmer_file\n+  File? filter_bwa_image\n+  # Required if filtering_only=true\n+  File? microbe_bwa_image\n+  File? microbe_dict\n+  File? taxonomy_file\n+\n+  # If enabled, filter metrics will be estimated using a downsampled bam with this many reads (recommended)\n+  # If disabled, no filter metrics will be generated\n+  Boolean downsample = false\n+  Int downsample_reads = 1000000\n+\n+  # Enable to only perform host filtering\n+  Boolean filtering_only = false\n+\n+  # Only recommended if downsample = true\n+  Boolean gather_filter_metrics = false\n+\n+  # This can be calculated from a downsampled run to help optimize disk allocation during filtering\n+  Float frac_non_host_reads = 1.0\n+\n+  # Filtering options\n   Boolean? filter_duplicates\n+  Boolean? skip_quality_filters\n+  Int? host_min_identity\n+  Int? host_kmer_threshold\n+  Int? filter_bwa_seed_length\n+  Int? min_clipped_read_length\n+  Int? max_masked_bases\n+  Int? min_base_quality\n+  Int? quality_threshold\n+  Int? dust_mask_quality\n+  Int? dust_window\n+  Float? dust_t\n+  Int? max_adapter_mistmatches\n+  Int? min_adapter_length\n+  Int? filter_reads_per_partition\n+  Int? filter_bam_partition_size\n   Boolean? skip_pre_bwa_repartition\n+\n+  # Alignment options\n+  Int? microbe_min_seed_length\n+  Int? max_alternate_hits\n+  Int? bwa_score_threshold\n+\n+  # Taxonomy scoring options\n   Boolean? divide_by_genome_length\n-  Int? filter_bwa_seed_length\n+  Float? min_score_identity\n+  Float? identity_margin\n+  Boolean? not_normalized_by_kingdom\n+  Int? score_reads_per_partition_estimate\n+\n+  # Runtime parameters\n+  String gatk_docker\n+  String samtools_docker = \"biocontainers/samtools:v1.9-4-deb_cv1\"\n+  String genomes_in_the_cloud_docker = \"broadinstitute/genomes-in-the-cloud:2.3.1-1512499786\"\n+  String linux_docker = \"ubuntu:18.10\"\n+\n+  File? gatk4_jar_override\n+\n+  Int? cram_to_bam_preemptible_attempts\n+  Int? downsample_preemptible_attempts\n+  Int? filter_preemptible_attempts\n+  Int? align_preemptible_attempts\n+  Int? score_preemptible_attempts\n+  Int? process_filter_metrics_preemptible_attempts\n+  Int? process_score_metrics_preemptible_attempts\n+\n+  Int? cram_to_bam_cpu\n+  Int? filter_cpu\n+  Int? align_cpu\n+  Int? score_cpu\n+\n+  Float? cram_to_bam_mem_gb\n+  Int? filter_mem_gb\n+  Int? align_mem_gb\n+  Int? score_mem_gb\n+\n+  Boolean? filter_ssd\n+  Boolean? align_ssd\n+  Boolean? score_ssd\n+\n+  Int? cram_to_bam_max_retries\n+\n+  # Optional input to increase all disk sizes in case of outlier sample with strange size behavior\n+  Int? cram_to_bam_additional_disk_gb\n+  Int? downsample_additional_disk_gb\n+  Int? filter_additional_disk_gb\n+  Int? align_additional_disk_gb\n+  Int? score_additional_disk_gb\n+\n+  Boolean is_bam = basename(input_bam_or_cram, \".bam\") + \".bam\" == basename(input_bam_or_cram)\n+\n+  # Convert to BAM if we have a CRAM\n+  if (!is_bam) {\n+    call CramToBam {\n+      input:\n+        cram_file = input_bam_or_cram,\n+        cram_index = select_first([input_bam_or_cram_index]),\n+        reference_fasta = select_first([cram_reference_fasta]),\n+        reference_index = select_first([cram_reference_fasta_index]),\n+        docker = samtools_docker,\n+        cpu = cram_to_bam_cpu,\n+        mem_gb = cram_to_bam_mem_gb,\n+        extra_disk_gb = cram_to_bam_additional_disk_gb,\n+        preemptible = cram_to_bam_preemptible_attempts,\n+        max_retries = cram_to_bam_max_retries,\n+    }\n+  }\n+\n+  File bam_file = select_first([CramToBam.bam_file, input_bam_or_cram])\n+  File? bam_index = if defined(CramToBam.bam_index) then CramToBam.bam_index else input_bam_or_cram_index\n+\n+  # Downsample bam for filter metrics estimation\n+  if (downsample) {\n+    call Downsample {\n+      input:\n+        input_bam_file=bam_file,\n+        input_bam_index_file=bam_index,\n+        downsampled_bam_filename=\"${sample_name}.downsampled.bam\",\n+        reads_after_downsampling=downsample_reads,\n+        additional_disk_gb=downsample_additional_disk_gb,\n+        preemptible_tries=downsample_preemptible_attempts,\n+        docker=genomes_in_the_cloud_docker\n+    }\n+  }\n+\n+  call PathSeqFilter {\n+    input:\n+      sample_name=sample_name,\n+      input_bam_or_cram=select_first([Downsample.output_bam_file, bam_file]),\n+      kmer_file=kmer_file,\n+      filter_bwa_image=filter_bwa_image,\n+      frac_non_host_reads=frac_non_host_reads,\n+      gather_metrics=gather_filter_metrics,\n+      is_host_aligned=is_host_aligned,\n+      filter_duplicates=filter_duplicates,\n+      skip_quality_filters=skip_quality_filters,\n+      min_clipped_read_length=min_clipped_read_length,\n+      bam_partition_size=filter_bam_partition_size,\n+      host_min_identity=host_min_identity,\n+      filter_bwa_seed_length=filter_bwa_seed_length,\n+      max_masked_bases=max_masked_bases,\n+      min_base_quality=min_base_quality,\n+      quality_threshold=quality_threshold,\n+      dust_mask_quality=dust_mask_quality,\n+      dust_window=dust_window,\n+      dust_t=dust_t,\n+      host_kmer_threshold=host_kmer_threshold,\n+      max_adapter_mistmatches=max_adapter_mistmatches,\n+      min_adapter_length=min_adapter_length,\n+      filter_reads_per_partition=filter_reads_per_partition,\n+      skip_pre_bwa_repartition=skip_pre_bwa_repartition,\n+      gatk4_jar_override=gatk4_jar_override,\n+      mem_gb=filter_mem_gb,\n+      gatk_docker=gatk_docker,\n+      preemptible_attempts=filter_preemptible_attempts,\n+      additional_disk_gb=filter_additional_disk_gb,\n+      cpu=filter_cpu,\n+      use_ssd=filter_ssd\n+  }\n+\n+  if (gather_filter_metrics) {\n+    call ProcessFilterMetrics {\n+      input:\n+        metrics_file=PathSeqFilter.filter_metrics,\n+        preemptible_tries=process_filter_metrics_preemptible_attempts,\n+        docker=linux_docker\n+    }\n+  }\n+\n+  if (!filtering_only) {\n+    call PathSeqAlign {\n+      input:\n+        sample_name=sample_name,\n+        input_paired_bam=PathSeqFilter.paired_bam_out,\n+        input_unpaired_bam=PathSeqFilter.unpaired_bam_out,\n+        microbe_bwa_image=select_first([microbe_bwa_image]),\n+        microbe_dict=select_first([microbe_dict]),\n+        microbe_min_seed_length=microbe_min_seed_length,\n+        max_alternate_hits=max_alternate_hits,\n+        bwa_score_threshold=bwa_score_threshold,\n+        gatk4_jar_override=gatk4_jar_override,\n+        mem_gb=align_mem_gb,\n+        gatk_docker=gatk_docker,\n+        preemptible_attempts=align_preemptible_attempts,\n+        additional_disk_gb=align_additional_disk_gb,\n+        cpu=align_cpu,\n+        use_ssd=align_ssd\n+    }\n+\n+    call PathSeqScore {\n+      input:\n+        sample_name=sample_name,\n+        input_paired_bam=PathSeqAlign.paired_bam_out,\n+        input_unpaired_bam=PathSeqAlign.unpaired_bam_out,\n+        taxonomy_file=select_first([taxonomy_file]),\n+        divide_by_genome_length=divide_by_genome_length,\n+        min_score_identity=min_score_identity,\n+        identity_margin=identity_margin,\n+        not_normalized_by_kingdom=not_normalized_by_kingdom,\n+        score_reads_per_partition_estimate=score_reads_per_partition_estimate,\n+        gatk4_jar_override=gatk4_jar_override,\n+        mem_gb=score_mem_gb,\n+        gatk_docker=gatk_docker,\n+        preemptible_attempts=score_preemptible_attempts,\n+        additional_disk_gb=score_additional_disk_gb,\n+        cpu=score_cpu,\n+        use_ssd=score_ssd\n+    }\n+\n+    call ProcessScoreMetrics {\n+      input:\n+        metrics_file=PathSeqScore.score_metrics,\n+        preemptible_tries=process_score_metrics_preemptible_attempts,\n+        docker=linux_docker\n+    }\n+  }\n+\n+  output {\n+    # Filtered non-host reads\n+    File non_host_paired_bam = PathSeqFilter.paired_bam_out\n+    File non_host_unpaired_bam = PathSeqFilter.unpaired_bam_out\n+\n+    # Only generated if filtering_only=false\n+    File? final_bam = PathSeqScore.bam_out\n+    File? taxonomy_scores = PathSeqScore.scores\n+    File? score_metrics_file = PathSeqScore.score_metrics\n+    Int? non_host_mapped_reads = ProcessScoreMetrics.non_host_mapped_reads\n+    Int? non_host_unmapped_reads = ProcessScoreMetrics.non_host_unmapped_reads\n+\n+    # Only generated if gather_filter_metrics=true\n+    File? filter_metrics_file = ProcessFilterMetrics.metrics_file_out\n+    Float? frac_after_prealigned_filter = ProcessFilterMetrics.frac_after_prealigned_filter\n+    Float? frac_after_qual_cpx_filter = ProcessFilterMetrics.frac_after_qual_cpx_filter\n+    Float? frac_after_host_filter = ProcessFilterMetrics.frac_after_host_filter\n+    Float? frac_after_dedup = ProcessFilterMetrics.frac_after_dedup\n+    Float? frac_non_host_paired = ProcessFilterMetrics.frac_final_paired\n+    Float? frac_non_host_unpaired = ProcessFilterMetrics.frac_final_unpaired\n+    Float? frac_non_host_total =ProcessFilterMetrics.frac_final_total\n+    Float? frac_qual_cpx_filtered = ProcessFilterMetrics.frac_qual_cpx_filtered\n+    Float? frac_host_filtered = ProcessFilterMetrics.frac_host_filtered\n+    Float? frac_dup_filtered = ProcessFilterMetrics.frac_dup_filtered\n+\n+    # Only generated if downsample=true\n+    Int? total_reads = Downsample.total_reads\n+  }\n+}\n+\n+task CramToBam {\n+  File cram_file\n+  File? cram_index\n+  File reference_fasta\n+  File? reference_index\n+\n+  String docker\n+\n+  Int? cpu = 4\n+  Float? mem_gb = 15\n+  Int? extra_disk_gb = 10\n+  Int? preemptible = 3\n+  Int? max_retries = 1\n+\n+  String bam_file_name = basename(cram_file, \".cram\") + \".bam\"\n+\n+  File cram_index_file = select_first([cram_index, cram_file + \".crai\"])\n+  File reference_index_file = select_first([reference_index, reference_fasta + \".fai\"])\n+\n+  Float cram_inflate_ratio = 3.0\n+  Float cram_size = size(cram_file, \"GiB\")\n+  Float cram_index_size = size(cram_index_file, \"GiB\")\n+  Float bam_size = cram_inflate_ratio * cram_size\n+  Float bam_index_size = cram_index_size\n+  Float ref_size = size(reference_fasta, \"GiB\")\n+  Float ref_index_size = size(reference_index_file, \"GiB\")\n+  Int vm_disk_size = ceil(cram_size + cram_index_size + bam_size + bam_index_size + ref_size + ref_index_size + extra_disk_gb)\n+\n+  output {\n+    File bam_file = bam_file_name\n+    File bam_index = bam_file_name + \".bai\"\n+  }\n+  command <<<\n+\n+        set -Eeuo pipefail\n+\n+        # covert cram to bam\n+        samtools view  -@ ${cpu} -h -b -T \"${reference_fasta}\" -o \"${bam_file_name}\" \"${cram_file}\"\n+\n+        # index bam file\n+        samtools index -@ ${cpu} \"${bam_file_name}\"\n+\n+  >>>\n+  runtime {\n+    cpu: 1\n+    memory: mem_gb + \" GiB\"\n+    disks: \"local-disk \" + vm_disk_size + \" HDD\"\n+    bootDiskSizeGb: 10\n+    docker: docker\n+    preemptible: preemptible\n+    maxRetries: max_retries\n+  }\n+}\n+\n+# Downsamples BAM to a specified number of reads\n+task Downsample {\n+  File input_bam_file\n+  File? input_bam_index_file\n+  String downsampled_bam_filename\n+\n+  Int reads_after_downsampling\n+\n+  String docker\n+  Int additional_disk_gb = 20\n+  Int preemptible_tries = 3\n+\n+  Int disk_size = ceil(size(input_bam_file, \"GB\")*2 + additional_disk_gb)\n+\n+  command <<<\n+    set -euo pipefail\n+    if ${defined(input_bam_index_file)}; then\n+      NUM_READS=`samtools idxstats ${input_bam_file} | awk '{s+=$3+$4} END {print s}'`\n+    else\n+      NUM_READS=`samtools view -c ${input_bam_file}`\n+    fi\n+    P_DOWNSAMPLE=`python -c \"print ${reads_after_downsampling}/float($NUM_READS)\"`\n+    RESULT=`python -c \"print $P_DOWNSAMPLE > 1\"`\n+    if [ \"$RESULT\" == \"True\" ]\n+    then\n+        P_DOWNSAMPLE=\"1\"\n+    fi\n+    echo $NUM_READS > num_reads.txt\n+    java -Xmx2000m -jar /usr/gitc/picard.jar \\\n+      DownsampleSam \\\n+      INPUT=${input_bam_file} \\", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQyODI3MA=="}, "originalCommit": {"oid": "d0c8174e86870f21669206f4b6a6f4954794c8a9"}, "originalPosition": 414}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUzNTY1NjYwOnYy", "diffSide": "RIGHT", "path": "scripts/pathseq/wdl/pathseq_pipeline.wdl", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNFQyMDo1NTo0NFrOGFgkqQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMVQxODozMToyMlrOGY-GLQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQyOTczNw==", "bodyText": "While you're here, it would be great to rev this to WDL 1.0.", "url": "https://github.com/broadinstitute/gatk/pull/6536#discussion_r408429737", "createdAt": "2020-04-14T20:55:44Z", "author": {"login": "ldgauthier"}, "path": "scripts/pathseq/wdl/pathseq_pipeline.wdl", "diffHunk": "@@ -20,179 +26,712 @@\n ## - - one or more read groups all belong to a single sample (SM)\n ##\n ## Output:\n-## - BAM file containing microbe-mapped reads and reads of unknown sequence\n-## - Tab-separated value (.tsv) file of taxonomic abundance scores\n-## - Picard-style metrics files for the filter and scoring phases of the pipeline\n+## - non_host_paired_bam, non_host_unpaired_bam: BAM files containing quality-filtered non-host paired and unpaired reads\n+## - If filtering_only = false:\n+##   - final_bam : BAM file containing microbe-mapped reads and reads of unknown sequence\n+##   - taxonomy_scores : tab-separated value (.tsv) file of taxonomic abundance scores\n+##   - score_metrics_file : Picard-style metrics file for scoring stage\n+##   - non_host_mapped_reads : number of non-host reads mapped to microbe reference\n+##   - non_host_unmapped_reads : number of non-host reads that did not map to the microbe reference\n+## - If gather_filter_metrics = true:\n+##   - filter_metrics_file : Picard-style metrics file for filtering stage\n+##   - frac_after_prealigned_filter : estimated fraction of reads remaining after filtering prealigned host reads\n+##   - frac_after_qual_cpx_filter : estimated fraction of reads remaining after low-quality and low-complexity filtering\n+##   - frac_after_host_filter : estimated fraction of reads remaining after host read filtering\n+##   - frac_after_dedup : estimated fraction of reads remaining after deduplication\n+##   - frac_final_paired : estimated fraction of reads that were paired in the final output\n+##   - frac_final_unpaired : estimated fraction of reads that were unpaired in the final output\n+##   - frac_final_total : estimated fraction of reads in the final output\n+##   - frac_qual_cpx_filtered : estimated fraction of reads removed by low-quality/low-complexity filtering\n+##   - frac_host_filtered : estimated fraction of reads removed by host filtering\n+##   - frac_dup_filtered : estimated fraction of reads removed by deduplication\n+## - If downsample = true:\n+##   - total_reads_if_avail : total number of reads in the original input BAM\n ##\n ########################################################################################################################\n \n-task PathseqPipeline {\n+workflow PathSeqPipeline {\n \n-  # Inputs for this task\n   String sample_name\n-  File input_bam\n+  File input_bam_or_cram\n+  # Required if a cram\n+  File? input_bam_or_cram_index\n \n-  File kmer_file\n-  File filter_bwa_image\n-  File microbe_bwa_image\n-  File microbe_fasta\n-  File microbe_fasta_dict\n-  File taxonomy_file\n+  # Required if the input is a cram\n+  File? cram_reference_fasta\n+  File? cram_reference_fasta_index\n+  File? cram_reference_dict\n \n+  # Set to true if host aligned. WARNING: Results in loss of EBV reads if in the aligned reference.\n   Boolean is_host_aligned\n-  Boolean? skip_quality_filters\n+\n+  File? kmer_file\n+  File? filter_bwa_image\n+  # Required if filtering_only=true\n+  File? microbe_bwa_image\n+  File? microbe_dict\n+  File? taxonomy_file\n+\n+  # If enabled, filter metrics will be estimated using a downsampled bam with this many reads (recommended)\n+  # If disabled, no filter metrics will be generated\n+  Boolean downsample = false\n+  Int downsample_reads = 1000000\n+\n+  # Enable to only perform host filtering\n+  Boolean filtering_only = false\n+\n+  # Only recommended if downsample = true\n+  Boolean gather_filter_metrics = false\n+\n+  # This can be calculated from a downsampled run to help optimize disk allocation during filtering\n+  Float frac_non_host_reads = 1.0\n+\n+  # Filtering options\n   Boolean? filter_duplicates\n+  Boolean? skip_quality_filters\n+  Int? host_min_identity\n+  Int? host_kmer_threshold\n+  Int? filter_bwa_seed_length\n+  Int? min_clipped_read_length\n+  Int? max_masked_bases\n+  Int? min_base_quality\n+  Int? quality_threshold\n+  Int? dust_mask_quality\n+  Int? dust_window\n+  Float? dust_t\n+  Int? max_adapter_mistmatches\n+  Int? min_adapter_length\n+  Int? filter_reads_per_partition\n+  Int? filter_bam_partition_size\n   Boolean? skip_pre_bwa_repartition\n+\n+  # Alignment options\n+  Int? microbe_min_seed_length\n+  Int? max_alternate_hits\n+  Int? bwa_score_threshold\n+\n+  # Taxonomy scoring options\n   Boolean? divide_by_genome_length\n-  Int? filter_bwa_seed_length\n+  Float? min_score_identity\n+  Float? identity_margin\n+  Boolean? not_normalized_by_kingdom\n+  Int? score_reads_per_partition_estimate\n+\n+  # Runtime parameters\n+  String gatk_docker\n+  String samtools_docker = \"biocontainers/samtools:v1.9-4-deb_cv1\"\n+  String genomes_in_the_cloud_docker = \"broadinstitute/genomes-in-the-cloud:2.3.1-1512499786\"\n+  String linux_docker = \"ubuntu:18.10\"\n+\n+  File? gatk4_jar_override\n+\n+  Int? cram_to_bam_preemptible_attempts\n+  Int? downsample_preemptible_attempts\n+  Int? filter_preemptible_attempts\n+  Int? align_preemptible_attempts\n+  Int? score_preemptible_attempts\n+  Int? process_filter_metrics_preemptible_attempts\n+  Int? process_score_metrics_preemptible_attempts\n+\n+  Int? cram_to_bam_cpu\n+  Int? filter_cpu\n+  Int? align_cpu\n+  Int? score_cpu\n+\n+  Float? cram_to_bam_mem_gb\n+  Int? filter_mem_gb\n+  Int? align_mem_gb\n+  Int? score_mem_gb\n+\n+  Boolean? filter_ssd\n+  Boolean? align_ssd\n+  Boolean? score_ssd\n+\n+  Int? cram_to_bam_max_retries\n+\n+  # Optional input to increase all disk sizes in case of outlier sample with strange size behavior\n+  Int? cram_to_bam_additional_disk_gb\n+  Int? downsample_additional_disk_gb\n+  Int? filter_additional_disk_gb\n+  Int? align_additional_disk_gb\n+  Int? score_additional_disk_gb\n+\n+  Boolean is_bam = basename(input_bam_or_cram, \".bam\") + \".bam\" == basename(input_bam_or_cram)\n+\n+  # Convert to BAM if we have a CRAM\n+  if (!is_bam) {\n+    call CramToBam {\n+      input:\n+        cram_file = input_bam_or_cram,\n+        cram_index = select_first([input_bam_or_cram_index]),\n+        reference_fasta = select_first([cram_reference_fasta]),\n+        reference_index = select_first([cram_reference_fasta_index]),\n+        docker = samtools_docker,\n+        cpu = cram_to_bam_cpu,\n+        mem_gb = cram_to_bam_mem_gb,\n+        extra_disk_gb = cram_to_bam_additional_disk_gb,\n+        preemptible = cram_to_bam_preemptible_attempts,\n+        max_retries = cram_to_bam_max_retries,\n+    }\n+  }\n+\n+  File bam_file = select_first([CramToBam.bam_file, input_bam_or_cram])\n+  File? bam_index = if defined(CramToBam.bam_index) then CramToBam.bam_index else input_bam_or_cram_index\n+\n+  # Downsample bam for filter metrics estimation\n+  if (downsample) {\n+    call Downsample {\n+      input:\n+        input_bam_file=bam_file,\n+        input_bam_index_file=bam_index,\n+        downsampled_bam_filename=\"${sample_name}.downsampled.bam\",", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d0c8174e86870f21669206f4b6a6f4954794c8a9"}, "originalPosition": 200}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODgzNjM5Nw==", "bodyText": "Done", "url": "https://github.com/broadinstitute/gatk/pull/6536#discussion_r428836397", "createdAt": "2020-05-21T18:31:22Z", "author": {"login": "mwalker174"}, "path": "scripts/pathseq/wdl/pathseq_pipeline.wdl", "diffHunk": "@@ -20,179 +26,712 @@\n ## - - one or more read groups all belong to a single sample (SM)\n ##\n ## Output:\n-## - BAM file containing microbe-mapped reads and reads of unknown sequence\n-## - Tab-separated value (.tsv) file of taxonomic abundance scores\n-## - Picard-style metrics files for the filter and scoring phases of the pipeline\n+## - non_host_paired_bam, non_host_unpaired_bam: BAM files containing quality-filtered non-host paired and unpaired reads\n+## - If filtering_only = false:\n+##   - final_bam : BAM file containing microbe-mapped reads and reads of unknown sequence\n+##   - taxonomy_scores : tab-separated value (.tsv) file of taxonomic abundance scores\n+##   - score_metrics_file : Picard-style metrics file for scoring stage\n+##   - non_host_mapped_reads : number of non-host reads mapped to microbe reference\n+##   - non_host_unmapped_reads : number of non-host reads that did not map to the microbe reference\n+## - If gather_filter_metrics = true:\n+##   - filter_metrics_file : Picard-style metrics file for filtering stage\n+##   - frac_after_prealigned_filter : estimated fraction of reads remaining after filtering prealigned host reads\n+##   - frac_after_qual_cpx_filter : estimated fraction of reads remaining after low-quality and low-complexity filtering\n+##   - frac_after_host_filter : estimated fraction of reads remaining after host read filtering\n+##   - frac_after_dedup : estimated fraction of reads remaining after deduplication\n+##   - frac_final_paired : estimated fraction of reads that were paired in the final output\n+##   - frac_final_unpaired : estimated fraction of reads that were unpaired in the final output\n+##   - frac_final_total : estimated fraction of reads in the final output\n+##   - frac_qual_cpx_filtered : estimated fraction of reads removed by low-quality/low-complexity filtering\n+##   - frac_host_filtered : estimated fraction of reads removed by host filtering\n+##   - frac_dup_filtered : estimated fraction of reads removed by deduplication\n+## - If downsample = true:\n+##   - total_reads_if_avail : total number of reads in the original input BAM\n ##\n ########################################################################################################################\n \n-task PathseqPipeline {\n+workflow PathSeqPipeline {\n \n-  # Inputs for this task\n   String sample_name\n-  File input_bam\n+  File input_bam_or_cram\n+  # Required if a cram\n+  File? input_bam_or_cram_index\n \n-  File kmer_file\n-  File filter_bwa_image\n-  File microbe_bwa_image\n-  File microbe_fasta\n-  File microbe_fasta_dict\n-  File taxonomy_file\n+  # Required if the input is a cram\n+  File? cram_reference_fasta\n+  File? cram_reference_fasta_index\n+  File? cram_reference_dict\n \n+  # Set to true if host aligned. WARNING: Results in loss of EBV reads if in the aligned reference.\n   Boolean is_host_aligned\n-  Boolean? skip_quality_filters\n+\n+  File? kmer_file\n+  File? filter_bwa_image\n+  # Required if filtering_only=true\n+  File? microbe_bwa_image\n+  File? microbe_dict\n+  File? taxonomy_file\n+\n+  # If enabled, filter metrics will be estimated using a downsampled bam with this many reads (recommended)\n+  # If disabled, no filter metrics will be generated\n+  Boolean downsample = false\n+  Int downsample_reads = 1000000\n+\n+  # Enable to only perform host filtering\n+  Boolean filtering_only = false\n+\n+  # Only recommended if downsample = true\n+  Boolean gather_filter_metrics = false\n+\n+  # This can be calculated from a downsampled run to help optimize disk allocation during filtering\n+  Float frac_non_host_reads = 1.0\n+\n+  # Filtering options\n   Boolean? filter_duplicates\n+  Boolean? skip_quality_filters\n+  Int? host_min_identity\n+  Int? host_kmer_threshold\n+  Int? filter_bwa_seed_length\n+  Int? min_clipped_read_length\n+  Int? max_masked_bases\n+  Int? min_base_quality\n+  Int? quality_threshold\n+  Int? dust_mask_quality\n+  Int? dust_window\n+  Float? dust_t\n+  Int? max_adapter_mistmatches\n+  Int? min_adapter_length\n+  Int? filter_reads_per_partition\n+  Int? filter_bam_partition_size\n   Boolean? skip_pre_bwa_repartition\n+\n+  # Alignment options\n+  Int? microbe_min_seed_length\n+  Int? max_alternate_hits\n+  Int? bwa_score_threshold\n+\n+  # Taxonomy scoring options\n   Boolean? divide_by_genome_length\n-  Int? filter_bwa_seed_length\n+  Float? min_score_identity\n+  Float? identity_margin\n+  Boolean? not_normalized_by_kingdom\n+  Int? score_reads_per_partition_estimate\n+\n+  # Runtime parameters\n+  String gatk_docker\n+  String samtools_docker = \"biocontainers/samtools:v1.9-4-deb_cv1\"\n+  String genomes_in_the_cloud_docker = \"broadinstitute/genomes-in-the-cloud:2.3.1-1512499786\"\n+  String linux_docker = \"ubuntu:18.10\"\n+\n+  File? gatk4_jar_override\n+\n+  Int? cram_to_bam_preemptible_attempts\n+  Int? downsample_preemptible_attempts\n+  Int? filter_preemptible_attempts\n+  Int? align_preemptible_attempts\n+  Int? score_preemptible_attempts\n+  Int? process_filter_metrics_preemptible_attempts\n+  Int? process_score_metrics_preemptible_attempts\n+\n+  Int? cram_to_bam_cpu\n+  Int? filter_cpu\n+  Int? align_cpu\n+  Int? score_cpu\n+\n+  Float? cram_to_bam_mem_gb\n+  Int? filter_mem_gb\n+  Int? align_mem_gb\n+  Int? score_mem_gb\n+\n+  Boolean? filter_ssd\n+  Boolean? align_ssd\n+  Boolean? score_ssd\n+\n+  Int? cram_to_bam_max_retries\n+\n+  # Optional input to increase all disk sizes in case of outlier sample with strange size behavior\n+  Int? cram_to_bam_additional_disk_gb\n+  Int? downsample_additional_disk_gb\n+  Int? filter_additional_disk_gb\n+  Int? align_additional_disk_gb\n+  Int? score_additional_disk_gb\n+\n+  Boolean is_bam = basename(input_bam_or_cram, \".bam\") + \".bam\" == basename(input_bam_or_cram)\n+\n+  # Convert to BAM if we have a CRAM\n+  if (!is_bam) {\n+    call CramToBam {\n+      input:\n+        cram_file = input_bam_or_cram,\n+        cram_index = select_first([input_bam_or_cram_index]),\n+        reference_fasta = select_first([cram_reference_fasta]),\n+        reference_index = select_first([cram_reference_fasta_index]),\n+        docker = samtools_docker,\n+        cpu = cram_to_bam_cpu,\n+        mem_gb = cram_to_bam_mem_gb,\n+        extra_disk_gb = cram_to_bam_additional_disk_gb,\n+        preemptible = cram_to_bam_preemptible_attempts,\n+        max_retries = cram_to_bam_max_retries,\n+    }\n+  }\n+\n+  File bam_file = select_first([CramToBam.bam_file, input_bam_or_cram])\n+  File? bam_index = if defined(CramToBam.bam_index) then CramToBam.bam_index else input_bam_or_cram_index\n+\n+  # Downsample bam for filter metrics estimation\n+  if (downsample) {\n+    call Downsample {\n+      input:\n+        input_bam_file=bam_file,\n+        input_bam_index_file=bam_index,\n+        downsampled_bam_filename=\"${sample_name}.downsampled.bam\",", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQyOTczNw=="}, "originalCommit": {"oid": "d0c8174e86870f21669206f4b6a6f4954794c8a9"}, "originalPosition": 200}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUzNTY1ODg1OnYy", "diffSide": "RIGHT", "path": "scripts/pathseq/wdl/pathseq_pipeline.wdl", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNFQyMDo1NjozM1rOGFgmKg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wMVQxNjozNTo0NFrOGPOsFA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQzMDEyMg==", "bodyText": "Why do you prefer to create an empty BAM rather than have a default output path?", "url": "https://github.com/broadinstitute/gatk/pull/6536#discussion_r408430122", "createdAt": "2020-04-14T20:56:33Z", "author": {"login": "ldgauthier"}, "path": "scripts/pathseq/wdl/pathseq_pipeline.wdl", "diffHunk": "@@ -20,179 +26,712 @@\n ## - - one or more read groups all belong to a single sample (SM)\n ##\n ## Output:\n-## - BAM file containing microbe-mapped reads and reads of unknown sequence\n-## - Tab-separated value (.tsv) file of taxonomic abundance scores\n-## - Picard-style metrics files for the filter and scoring phases of the pipeline\n+## - non_host_paired_bam, non_host_unpaired_bam: BAM files containing quality-filtered non-host paired and unpaired reads\n+## - If filtering_only = false:\n+##   - final_bam : BAM file containing microbe-mapped reads and reads of unknown sequence\n+##   - taxonomy_scores : tab-separated value (.tsv) file of taxonomic abundance scores\n+##   - score_metrics_file : Picard-style metrics file for scoring stage\n+##   - non_host_mapped_reads : number of non-host reads mapped to microbe reference\n+##   - non_host_unmapped_reads : number of non-host reads that did not map to the microbe reference\n+## - If gather_filter_metrics = true:\n+##   - filter_metrics_file : Picard-style metrics file for filtering stage\n+##   - frac_after_prealigned_filter : estimated fraction of reads remaining after filtering prealigned host reads\n+##   - frac_after_qual_cpx_filter : estimated fraction of reads remaining after low-quality and low-complexity filtering\n+##   - frac_after_host_filter : estimated fraction of reads remaining after host read filtering\n+##   - frac_after_dedup : estimated fraction of reads remaining after deduplication\n+##   - frac_final_paired : estimated fraction of reads that were paired in the final output\n+##   - frac_final_unpaired : estimated fraction of reads that were unpaired in the final output\n+##   - frac_final_total : estimated fraction of reads in the final output\n+##   - frac_qual_cpx_filtered : estimated fraction of reads removed by low-quality/low-complexity filtering\n+##   - frac_host_filtered : estimated fraction of reads removed by host filtering\n+##   - frac_dup_filtered : estimated fraction of reads removed by deduplication\n+## - If downsample = true:\n+##   - total_reads_if_avail : total number of reads in the original input BAM\n ##\n ########################################################################################################################\n \n-task PathseqPipeline {\n+workflow PathSeqPipeline {\n \n-  # Inputs for this task\n   String sample_name\n-  File input_bam\n+  File input_bam_or_cram\n+  # Required if a cram\n+  File? input_bam_or_cram_index\n \n-  File kmer_file\n-  File filter_bwa_image\n-  File microbe_bwa_image\n-  File microbe_fasta\n-  File microbe_fasta_dict\n-  File taxonomy_file\n+  # Required if the input is a cram\n+  File? cram_reference_fasta\n+  File? cram_reference_fasta_index\n+  File? cram_reference_dict\n \n+  # Set to true if host aligned. WARNING: Results in loss of EBV reads if in the aligned reference.\n   Boolean is_host_aligned\n-  Boolean? skip_quality_filters\n+\n+  File? kmer_file\n+  File? filter_bwa_image\n+  # Required if filtering_only=true\n+  File? microbe_bwa_image\n+  File? microbe_dict\n+  File? taxonomy_file\n+\n+  # If enabled, filter metrics will be estimated using a downsampled bam with this many reads (recommended)\n+  # If disabled, no filter metrics will be generated\n+  Boolean downsample = false\n+  Int downsample_reads = 1000000\n+\n+  # Enable to only perform host filtering\n+  Boolean filtering_only = false\n+\n+  # Only recommended if downsample = true\n+  Boolean gather_filter_metrics = false\n+\n+  # This can be calculated from a downsampled run to help optimize disk allocation during filtering\n+  Float frac_non_host_reads = 1.0\n+\n+  # Filtering options\n   Boolean? filter_duplicates\n+  Boolean? skip_quality_filters\n+  Int? host_min_identity\n+  Int? host_kmer_threshold\n+  Int? filter_bwa_seed_length\n+  Int? min_clipped_read_length\n+  Int? max_masked_bases\n+  Int? min_base_quality\n+  Int? quality_threshold\n+  Int? dust_mask_quality\n+  Int? dust_window\n+  Float? dust_t\n+  Int? max_adapter_mistmatches\n+  Int? min_adapter_length\n+  Int? filter_reads_per_partition\n+  Int? filter_bam_partition_size\n   Boolean? skip_pre_bwa_repartition\n+\n+  # Alignment options\n+  Int? microbe_min_seed_length\n+  Int? max_alternate_hits\n+  Int? bwa_score_threshold\n+\n+  # Taxonomy scoring options\n   Boolean? divide_by_genome_length\n-  Int? filter_bwa_seed_length\n+  Float? min_score_identity\n+  Float? identity_margin\n+  Boolean? not_normalized_by_kingdom\n+  Int? score_reads_per_partition_estimate\n+\n+  # Runtime parameters\n+  String gatk_docker\n+  String samtools_docker = \"biocontainers/samtools:v1.9-4-deb_cv1\"\n+  String genomes_in_the_cloud_docker = \"broadinstitute/genomes-in-the-cloud:2.3.1-1512499786\"\n+  String linux_docker = \"ubuntu:18.10\"\n+\n+  File? gatk4_jar_override\n+\n+  Int? cram_to_bam_preemptible_attempts\n+  Int? downsample_preemptible_attempts\n+  Int? filter_preemptible_attempts\n+  Int? align_preemptible_attempts\n+  Int? score_preemptible_attempts\n+  Int? process_filter_metrics_preemptible_attempts\n+  Int? process_score_metrics_preemptible_attempts\n+\n+  Int? cram_to_bam_cpu\n+  Int? filter_cpu\n+  Int? align_cpu\n+  Int? score_cpu\n+\n+  Float? cram_to_bam_mem_gb\n+  Int? filter_mem_gb\n+  Int? align_mem_gb\n+  Int? score_mem_gb\n+\n+  Boolean? filter_ssd\n+  Boolean? align_ssd\n+  Boolean? score_ssd\n+\n+  Int? cram_to_bam_max_retries\n+\n+  # Optional input to increase all disk sizes in case of outlier sample with strange size behavior\n+  Int? cram_to_bam_additional_disk_gb\n+  Int? downsample_additional_disk_gb\n+  Int? filter_additional_disk_gb\n+  Int? align_additional_disk_gb\n+  Int? score_additional_disk_gb\n+\n+  Boolean is_bam = basename(input_bam_or_cram, \".bam\") + \".bam\" == basename(input_bam_or_cram)\n+\n+  # Convert to BAM if we have a CRAM\n+  if (!is_bam) {\n+    call CramToBam {\n+      input:\n+        cram_file = input_bam_or_cram,\n+        cram_index = select_first([input_bam_or_cram_index]),\n+        reference_fasta = select_first([cram_reference_fasta]),\n+        reference_index = select_first([cram_reference_fasta_index]),\n+        docker = samtools_docker,\n+        cpu = cram_to_bam_cpu,\n+        mem_gb = cram_to_bam_mem_gb,\n+        extra_disk_gb = cram_to_bam_additional_disk_gb,\n+        preemptible = cram_to_bam_preemptible_attempts,\n+        max_retries = cram_to_bam_max_retries,\n+    }\n+  }\n+\n+  File bam_file = select_first([CramToBam.bam_file, input_bam_or_cram])\n+  File? bam_index = if defined(CramToBam.bam_index) then CramToBam.bam_index else input_bam_or_cram_index\n+\n+  # Downsample bam for filter metrics estimation\n+  if (downsample) {\n+    call Downsample {\n+      input:\n+        input_bam_file=bam_file,\n+        input_bam_index_file=bam_index,\n+        downsampled_bam_filename=\"${sample_name}.downsampled.bam\",\n+        reads_after_downsampling=downsample_reads,\n+        additional_disk_gb=downsample_additional_disk_gb,\n+        preemptible_tries=downsample_preemptible_attempts,\n+        docker=genomes_in_the_cloud_docker\n+    }\n+  }\n+\n+  call PathSeqFilter {\n+    input:\n+      sample_name=sample_name,\n+      input_bam_or_cram=select_first([Downsample.output_bam_file, bam_file]),\n+      kmer_file=kmer_file,\n+      filter_bwa_image=filter_bwa_image,\n+      frac_non_host_reads=frac_non_host_reads,\n+      gather_metrics=gather_filter_metrics,\n+      is_host_aligned=is_host_aligned,\n+      filter_duplicates=filter_duplicates,\n+      skip_quality_filters=skip_quality_filters,\n+      min_clipped_read_length=min_clipped_read_length,\n+      bam_partition_size=filter_bam_partition_size,\n+      host_min_identity=host_min_identity,\n+      filter_bwa_seed_length=filter_bwa_seed_length,\n+      max_masked_bases=max_masked_bases,\n+      min_base_quality=min_base_quality,\n+      quality_threshold=quality_threshold,\n+      dust_mask_quality=dust_mask_quality,\n+      dust_window=dust_window,\n+      dust_t=dust_t,\n+      host_kmer_threshold=host_kmer_threshold,\n+      max_adapter_mistmatches=max_adapter_mistmatches,\n+      min_adapter_length=min_adapter_length,\n+      filter_reads_per_partition=filter_reads_per_partition,\n+      skip_pre_bwa_repartition=skip_pre_bwa_repartition,\n+      gatk4_jar_override=gatk4_jar_override,\n+      mem_gb=filter_mem_gb,\n+      gatk_docker=gatk_docker,\n+      preemptible_attempts=filter_preemptible_attempts,\n+      additional_disk_gb=filter_additional_disk_gb,\n+      cpu=filter_cpu,\n+      use_ssd=filter_ssd\n+  }\n+\n+  if (gather_filter_metrics) {\n+    call ProcessFilterMetrics {\n+      input:\n+        metrics_file=PathSeqFilter.filter_metrics,\n+        preemptible_tries=process_filter_metrics_preemptible_attempts,\n+        docker=linux_docker\n+    }\n+  }\n+\n+  if (!filtering_only) {\n+    call PathSeqAlign {\n+      input:\n+        sample_name=sample_name,\n+        input_paired_bam=PathSeqFilter.paired_bam_out,\n+        input_unpaired_bam=PathSeqFilter.unpaired_bam_out,\n+        microbe_bwa_image=select_first([microbe_bwa_image]),\n+        microbe_dict=select_first([microbe_dict]),\n+        microbe_min_seed_length=microbe_min_seed_length,\n+        max_alternate_hits=max_alternate_hits,\n+        bwa_score_threshold=bwa_score_threshold,\n+        gatk4_jar_override=gatk4_jar_override,\n+        mem_gb=align_mem_gb,\n+        gatk_docker=gatk_docker,\n+        preemptible_attempts=align_preemptible_attempts,\n+        additional_disk_gb=align_additional_disk_gb,\n+        cpu=align_cpu,\n+        use_ssd=align_ssd\n+    }\n+\n+    call PathSeqScore {\n+      input:\n+        sample_name=sample_name,\n+        input_paired_bam=PathSeqAlign.paired_bam_out,\n+        input_unpaired_bam=PathSeqAlign.unpaired_bam_out,\n+        taxonomy_file=select_first([taxonomy_file]),\n+        divide_by_genome_length=divide_by_genome_length,\n+        min_score_identity=min_score_identity,\n+        identity_margin=identity_margin,\n+        not_normalized_by_kingdom=not_normalized_by_kingdom,\n+        score_reads_per_partition_estimate=score_reads_per_partition_estimate,\n+        gatk4_jar_override=gatk4_jar_override,\n+        mem_gb=score_mem_gb,\n+        gatk_docker=gatk_docker,\n+        preemptible_attempts=score_preemptible_attempts,\n+        additional_disk_gb=score_additional_disk_gb,\n+        cpu=score_cpu,\n+        use_ssd=score_ssd\n+    }\n+\n+    call ProcessScoreMetrics {\n+      input:\n+        metrics_file=PathSeqScore.score_metrics,\n+        preemptible_tries=process_score_metrics_preemptible_attempts,\n+        docker=linux_docker\n+    }\n+  }\n+\n+  output {\n+    # Filtered non-host reads\n+    File non_host_paired_bam = PathSeqFilter.paired_bam_out\n+    File non_host_unpaired_bam = PathSeqFilter.unpaired_bam_out\n+\n+    # Only generated if filtering_only=false\n+    File? final_bam = PathSeqScore.bam_out\n+    File? taxonomy_scores = PathSeqScore.scores\n+    File? score_metrics_file = PathSeqScore.score_metrics\n+    Int? non_host_mapped_reads = ProcessScoreMetrics.non_host_mapped_reads\n+    Int? non_host_unmapped_reads = ProcessScoreMetrics.non_host_unmapped_reads\n+\n+    # Only generated if gather_filter_metrics=true\n+    File? filter_metrics_file = ProcessFilterMetrics.metrics_file_out\n+    Float? frac_after_prealigned_filter = ProcessFilterMetrics.frac_after_prealigned_filter\n+    Float? frac_after_qual_cpx_filter = ProcessFilterMetrics.frac_after_qual_cpx_filter\n+    Float? frac_after_host_filter = ProcessFilterMetrics.frac_after_host_filter\n+    Float? frac_after_dedup = ProcessFilterMetrics.frac_after_dedup\n+    Float? frac_non_host_paired = ProcessFilterMetrics.frac_final_paired\n+    Float? frac_non_host_unpaired = ProcessFilterMetrics.frac_final_unpaired\n+    Float? frac_non_host_total =ProcessFilterMetrics.frac_final_total\n+    Float? frac_qual_cpx_filtered = ProcessFilterMetrics.frac_qual_cpx_filtered\n+    Float? frac_host_filtered = ProcessFilterMetrics.frac_host_filtered\n+    Float? frac_dup_filtered = ProcessFilterMetrics.frac_dup_filtered\n+\n+    # Only generated if downsample=true\n+    Int? total_reads = Downsample.total_reads\n+  }\n+}\n+\n+task CramToBam {\n+  File cram_file\n+  File? cram_index\n+  File reference_fasta\n+  File? reference_index\n+\n+  String docker\n+\n+  Int? cpu = 4\n+  Float? mem_gb = 15\n+  Int? extra_disk_gb = 10\n+  Int? preemptible = 3\n+  Int? max_retries = 1\n+\n+  String bam_file_name = basename(cram_file, \".cram\") + \".bam\"\n+\n+  File cram_index_file = select_first([cram_index, cram_file + \".crai\"])\n+  File reference_index_file = select_first([reference_index, reference_fasta + \".fai\"])\n+\n+  Float cram_inflate_ratio = 3.0\n+  Float cram_size = size(cram_file, \"GiB\")\n+  Float cram_index_size = size(cram_index_file, \"GiB\")\n+  Float bam_size = cram_inflate_ratio * cram_size\n+  Float bam_index_size = cram_index_size\n+  Float ref_size = size(reference_fasta, \"GiB\")\n+  Float ref_index_size = size(reference_index_file, \"GiB\")\n+  Int vm_disk_size = ceil(cram_size + cram_index_size + bam_size + bam_index_size + ref_size + ref_index_size + extra_disk_gb)\n+\n+  output {\n+    File bam_file = bam_file_name\n+    File bam_index = bam_file_name + \".bai\"\n+  }\n+  command <<<\n+\n+        set -Eeuo pipefail\n+\n+        # covert cram to bam\n+        samtools view  -@ ${cpu} -h -b -T \"${reference_fasta}\" -o \"${bam_file_name}\" \"${cram_file}\"\n+\n+        # index bam file\n+        samtools index -@ ${cpu} \"${bam_file_name}\"\n+\n+  >>>\n+  runtime {\n+    cpu: 1\n+    memory: mem_gb + \" GiB\"\n+    disks: \"local-disk \" + vm_disk_size + \" HDD\"\n+    bootDiskSizeGb: 10\n+    docker: docker\n+    preemptible: preemptible\n+    maxRetries: max_retries\n+  }\n+}\n+\n+# Downsamples BAM to a specified number of reads\n+task Downsample {\n+  File input_bam_file\n+  File? input_bam_index_file\n+  String downsampled_bam_filename\n+\n+  Int reads_after_downsampling\n+\n+  String docker\n+  Int additional_disk_gb = 20\n+  Int preemptible_tries = 3\n+\n+  Int disk_size = ceil(size(input_bam_file, \"GB\")*2 + additional_disk_gb)\n+\n+  command <<<\n+    set -euo pipefail\n+    if ${defined(input_bam_index_file)}; then\n+      NUM_READS=`samtools idxstats ${input_bam_file} | awk '{s+=$3+$4} END {print s}'`\n+    else\n+      NUM_READS=`samtools view -c ${input_bam_file}`\n+    fi\n+    P_DOWNSAMPLE=`python -c \"print ${reads_after_downsampling}/float($NUM_READS)\"`\n+    RESULT=`python -c \"print $P_DOWNSAMPLE > 1\"`\n+    if [ \"$RESULT\" == \"True\" ]\n+    then\n+        P_DOWNSAMPLE=\"1\"\n+    fi\n+    echo $NUM_READS > num_reads.txt\n+    java -Xmx2000m -jar /usr/gitc/picard.jar \\\n+      DownsampleSam \\\n+      INPUT=${input_bam_file} \\\n+      OUTPUT=${downsampled_bam_filename} \\\n+      P=$P_DOWNSAMPLE \\\n+      VALIDATION_STRINGENCY=SILENT\n+  >>>\n+  output {\n+    File output_bam_file = \"${downsampled_bam_filename}\"\n+    Int total_reads = read_int(\"num_reads.txt\")\n+  }\n+  runtime {\n+    preemptible: \"${preemptible_tries}\"\n+    docker: docker\n+    memory: \"3.75 GiB\"\n+    cpu: \"1\"\n+    disks: \"local-disk ${disk_size} HDD\"\n+  }\n+}\n+\n+task PathSeqFilter {\n+\n+  # Inputs for this task\n+  String sample_name\n+  File input_bam_or_cram\n+\n+  File? kmer_file\n+  File? filter_bwa_image\n+\n+  Boolean is_host_aligned\n+  Boolean gather_metrics\n+  # Optimizes disk space if provided\n+  Float frac_non_host_reads = 1.0\n+\n+  Boolean? skip_quality_filters\n+  Boolean? skip_pre_bwa_repartition\n+  Boolean? filter_duplicates\n   Int? host_min_identity\n+  Int? filter_bwa_seed_length\n   Int? min_clipped_read_length\n   Int? bam_partition_size\n-  Float? min_score_identity\n-  Float? identity_margin\n+  Int? max_masked_bases\n+  Int? min_base_quality\n+  Int? quality_threshold\n+  Int? dust_mask_quality\n+  Int? dust_window\n+  Float? dust_t\n+  Int? host_kmer_threshold\n+  Int? max_adapter_mistmatches\n+  Int? min_adapter_length\n+  Int? filter_reads_per_partition\n \n-  String bam_output_path = \"${sample_name}.pathseq.bam\"\n-  String scores_output_path = \"${sample_name}.pathseq.tsv\"\n+  String paired_bam_output_path = \"${sample_name}.non_host.paired.bam\"\n+  String unpaired_bam_output_path = \"${sample_name}.non_host.unpaired.bam\"\n   String filter_metrics_output_path = \"${sample_name}.pathseq.filter_metrics\"\n-  String score_metrics_output_path = \"${sample_name}.pathseq.score_metrics\"\n \n   File? gatk4_jar_override\n \n+  # Default to WARNING which will avoid excessive Spark logging\n+  String verbosity = \"WARNING\"\n+\n   # Runtime parameters\n-  Int? mem_gb\n   String gatk_docker\n-  Int? preemptible_attempts\n-  Int? disk_space_gb\n-  Int? cpu\n-  Boolean use_ssd = true\n-\n-  # You may have to change the following two parameter values depending on the task requirements\n-  Int default_ram_mb = 208000\n-  # WARNING: In the workflow, you should calculate the disk space as an input to this task (disk_space_gb).\n-  Int default_disk_space_gb = 400\n+  Int mem_gb = 32\n+  Int preemptible_attempts = 3\n+  Float additional_disk_gb = 50\n+  Int cpu = 8\n+  Boolean use_ssd = false\n+\n+  Int disk_size = ceil(((1.0 + frac_non_host_reads)*size(input_bam_or_cram, \"GB\")) + size(kmer_file, \"GB\") + size(filter_bwa_image, \"GB\") + additional_disk_gb)\n+\n   # Mem is in units of GB but our command and memory runtime values are in MB\n-  Int machine_mem = if defined(mem_gb) then mem_gb *1000 else default_ram_mb\n-  Int command_mem = machine_mem - 4000\n+  Int machine_mem = mem_gb * 1000\n+  Int command_mem = ceil((machine_mem - size(filter_bwa_image, \"MB\")) * 0.8)\n+\n+  command <<<\n+    set -euo pipefail\n+    export GATK_LOCAL_JAR=${default=\"/root/gatk.jar\" gatk4_jar_override}\n+    touch ${filter_metrics_output_path}\n+    gatk --java-options \"-Xmx${command_mem}m\" \\\n+      PathSeqFilterSpark \\\n+      --input ${input_bam_or_cram} \\\n+      --paired-output ${paired_bam_output_path} \\\n+      --unpaired-output ${unpaired_bam_output_path} \\\n+      --is-host-aligned ${is_host_aligned}  \\\n+      --verbosity ${verbosity} \\\n+      ${if gather_metrics then \"--filter-metrics ${filter_metrics_output_path}\" else \"\"} \\\n+      ${if defined(kmer_file) then \"--kmer-file ${kmer_file}\" else \"\"} \\\n+      ${if defined(filter_bwa_image) then \"--filter-bwa-image ${filter_bwa_image}\" else \"\"} \\\n+      ${if defined(bam_partition_size) then \"--bam-partition-size ${bam_partition_size}\" else \"\"} \\\n+      ${if defined(skip_quality_filters) then \"--skip-quality-filters ${skip_quality_filters}\" else \"\"}\\\n+      ${if defined(min_clipped_read_length) then \"--min-clipped-read-length ${min_clipped_read_length}\" else \"\"} \\\n+      ${if defined(max_masked_bases) then \"--max-masked-bases ${max_masked_bases}\" else \"\"} \\\n+      ${if defined(min_base_quality) then \"--min-base-quality ${min_base_quality}\" else \"\"} \\\n+      ${if defined(quality_threshold) then \"--quality-threshold ${quality_threshold}\" else \"\"} \\\n+      ${if defined(dust_mask_quality) then \"--dust-mask-quality ${dust_mask_quality}\" else \"\"} \\\n+      ${if defined(dust_window) then \"--dust-window ${dust_window}\" else \"\"} \\\n+      ${if defined(dust_t) then \"--dust-t ${dust_t}\" else \"\"} \\\n+      ${if defined(host_kmer_threshold) then \"--host-kmer-thresh ${host_kmer_threshold}\" else \"\"} \\\n+      ${if defined(max_adapter_mistmatches) then \"--max-adapter-mismatches ${max_adapter_mistmatches}\" else \"\"} \\\n+      ${if defined(min_adapter_length) then \"--min-adapter-length ${min_adapter_length}\" else \"\"} \\\n+      ${if defined(filter_bwa_seed_length) then \"--filter-bwa-seed-length ${filter_bwa_seed_length}\" else \"\"} \\\n+      ${if defined(host_min_identity) then \"--host-min-identity ${host_min_identity}\" else \"\"} \\\n+      ${if defined(filter_duplicates) then \"--filter-duplicates ${filter_duplicates}\" else \"\"} \\\n+      ${if defined(skip_pre_bwa_repartition) then \"--skip-pre-bwa-repartition ${skip_pre_bwa_repartition}\" else \"\"} \\\n+      ${if defined(filter_reads_per_partition) then \"--filter-reads-per-partition ${filter_reads_per_partition}\" else \"\"}\n+\n+    if [ ! -f \"${paired_bam_output_path}\" ]; then\n+    \techo \"File ${paired_bam_output_path} not found, creating empty BAM\"", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d0c8174e86870f21669206f4b6a6f4954794c8a9"}, "originalPosition": 537}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODYyMjQ4NA==", "bodyText": "If I remember correctly, the BAM will not be written if there are no reads. I believe this is a behavior of Spark tools in general and not something I can change in PathSeq.", "url": "https://github.com/broadinstitute/gatk/pull/6536#discussion_r418622484", "createdAt": "2020-05-01T16:35:44Z", "author": {"login": "mwalker174"}, "path": "scripts/pathseq/wdl/pathseq_pipeline.wdl", "diffHunk": "@@ -20,179 +26,712 @@\n ## - - one or more read groups all belong to a single sample (SM)\n ##\n ## Output:\n-## - BAM file containing microbe-mapped reads and reads of unknown sequence\n-## - Tab-separated value (.tsv) file of taxonomic abundance scores\n-## - Picard-style metrics files for the filter and scoring phases of the pipeline\n+## - non_host_paired_bam, non_host_unpaired_bam: BAM files containing quality-filtered non-host paired and unpaired reads\n+## - If filtering_only = false:\n+##   - final_bam : BAM file containing microbe-mapped reads and reads of unknown sequence\n+##   - taxonomy_scores : tab-separated value (.tsv) file of taxonomic abundance scores\n+##   - score_metrics_file : Picard-style metrics file for scoring stage\n+##   - non_host_mapped_reads : number of non-host reads mapped to microbe reference\n+##   - non_host_unmapped_reads : number of non-host reads that did not map to the microbe reference\n+## - If gather_filter_metrics = true:\n+##   - filter_metrics_file : Picard-style metrics file for filtering stage\n+##   - frac_after_prealigned_filter : estimated fraction of reads remaining after filtering prealigned host reads\n+##   - frac_after_qual_cpx_filter : estimated fraction of reads remaining after low-quality and low-complexity filtering\n+##   - frac_after_host_filter : estimated fraction of reads remaining after host read filtering\n+##   - frac_after_dedup : estimated fraction of reads remaining after deduplication\n+##   - frac_final_paired : estimated fraction of reads that were paired in the final output\n+##   - frac_final_unpaired : estimated fraction of reads that were unpaired in the final output\n+##   - frac_final_total : estimated fraction of reads in the final output\n+##   - frac_qual_cpx_filtered : estimated fraction of reads removed by low-quality/low-complexity filtering\n+##   - frac_host_filtered : estimated fraction of reads removed by host filtering\n+##   - frac_dup_filtered : estimated fraction of reads removed by deduplication\n+## - If downsample = true:\n+##   - total_reads_if_avail : total number of reads in the original input BAM\n ##\n ########################################################################################################################\n \n-task PathseqPipeline {\n+workflow PathSeqPipeline {\n \n-  # Inputs for this task\n   String sample_name\n-  File input_bam\n+  File input_bam_or_cram\n+  # Required if a cram\n+  File? input_bam_or_cram_index\n \n-  File kmer_file\n-  File filter_bwa_image\n-  File microbe_bwa_image\n-  File microbe_fasta\n-  File microbe_fasta_dict\n-  File taxonomy_file\n+  # Required if the input is a cram\n+  File? cram_reference_fasta\n+  File? cram_reference_fasta_index\n+  File? cram_reference_dict\n \n+  # Set to true if host aligned. WARNING: Results in loss of EBV reads if in the aligned reference.\n   Boolean is_host_aligned\n-  Boolean? skip_quality_filters\n+\n+  File? kmer_file\n+  File? filter_bwa_image\n+  # Required if filtering_only=true\n+  File? microbe_bwa_image\n+  File? microbe_dict\n+  File? taxonomy_file\n+\n+  # If enabled, filter metrics will be estimated using a downsampled bam with this many reads (recommended)\n+  # If disabled, no filter metrics will be generated\n+  Boolean downsample = false\n+  Int downsample_reads = 1000000\n+\n+  # Enable to only perform host filtering\n+  Boolean filtering_only = false\n+\n+  # Only recommended if downsample = true\n+  Boolean gather_filter_metrics = false\n+\n+  # This can be calculated from a downsampled run to help optimize disk allocation during filtering\n+  Float frac_non_host_reads = 1.0\n+\n+  # Filtering options\n   Boolean? filter_duplicates\n+  Boolean? skip_quality_filters\n+  Int? host_min_identity\n+  Int? host_kmer_threshold\n+  Int? filter_bwa_seed_length\n+  Int? min_clipped_read_length\n+  Int? max_masked_bases\n+  Int? min_base_quality\n+  Int? quality_threshold\n+  Int? dust_mask_quality\n+  Int? dust_window\n+  Float? dust_t\n+  Int? max_adapter_mistmatches\n+  Int? min_adapter_length\n+  Int? filter_reads_per_partition\n+  Int? filter_bam_partition_size\n   Boolean? skip_pre_bwa_repartition\n+\n+  # Alignment options\n+  Int? microbe_min_seed_length\n+  Int? max_alternate_hits\n+  Int? bwa_score_threshold\n+\n+  # Taxonomy scoring options\n   Boolean? divide_by_genome_length\n-  Int? filter_bwa_seed_length\n+  Float? min_score_identity\n+  Float? identity_margin\n+  Boolean? not_normalized_by_kingdom\n+  Int? score_reads_per_partition_estimate\n+\n+  # Runtime parameters\n+  String gatk_docker\n+  String samtools_docker = \"biocontainers/samtools:v1.9-4-deb_cv1\"\n+  String genomes_in_the_cloud_docker = \"broadinstitute/genomes-in-the-cloud:2.3.1-1512499786\"\n+  String linux_docker = \"ubuntu:18.10\"\n+\n+  File? gatk4_jar_override\n+\n+  Int? cram_to_bam_preemptible_attempts\n+  Int? downsample_preemptible_attempts\n+  Int? filter_preemptible_attempts\n+  Int? align_preemptible_attempts\n+  Int? score_preemptible_attempts\n+  Int? process_filter_metrics_preemptible_attempts\n+  Int? process_score_metrics_preemptible_attempts\n+\n+  Int? cram_to_bam_cpu\n+  Int? filter_cpu\n+  Int? align_cpu\n+  Int? score_cpu\n+\n+  Float? cram_to_bam_mem_gb\n+  Int? filter_mem_gb\n+  Int? align_mem_gb\n+  Int? score_mem_gb\n+\n+  Boolean? filter_ssd\n+  Boolean? align_ssd\n+  Boolean? score_ssd\n+\n+  Int? cram_to_bam_max_retries\n+\n+  # Optional input to increase all disk sizes in case of outlier sample with strange size behavior\n+  Int? cram_to_bam_additional_disk_gb\n+  Int? downsample_additional_disk_gb\n+  Int? filter_additional_disk_gb\n+  Int? align_additional_disk_gb\n+  Int? score_additional_disk_gb\n+\n+  Boolean is_bam = basename(input_bam_or_cram, \".bam\") + \".bam\" == basename(input_bam_or_cram)\n+\n+  # Convert to BAM if we have a CRAM\n+  if (!is_bam) {\n+    call CramToBam {\n+      input:\n+        cram_file = input_bam_or_cram,\n+        cram_index = select_first([input_bam_or_cram_index]),\n+        reference_fasta = select_first([cram_reference_fasta]),\n+        reference_index = select_first([cram_reference_fasta_index]),\n+        docker = samtools_docker,\n+        cpu = cram_to_bam_cpu,\n+        mem_gb = cram_to_bam_mem_gb,\n+        extra_disk_gb = cram_to_bam_additional_disk_gb,\n+        preemptible = cram_to_bam_preemptible_attempts,\n+        max_retries = cram_to_bam_max_retries,\n+    }\n+  }\n+\n+  File bam_file = select_first([CramToBam.bam_file, input_bam_or_cram])\n+  File? bam_index = if defined(CramToBam.bam_index) then CramToBam.bam_index else input_bam_or_cram_index\n+\n+  # Downsample bam for filter metrics estimation\n+  if (downsample) {\n+    call Downsample {\n+      input:\n+        input_bam_file=bam_file,\n+        input_bam_index_file=bam_index,\n+        downsampled_bam_filename=\"${sample_name}.downsampled.bam\",\n+        reads_after_downsampling=downsample_reads,\n+        additional_disk_gb=downsample_additional_disk_gb,\n+        preemptible_tries=downsample_preemptible_attempts,\n+        docker=genomes_in_the_cloud_docker\n+    }\n+  }\n+\n+  call PathSeqFilter {\n+    input:\n+      sample_name=sample_name,\n+      input_bam_or_cram=select_first([Downsample.output_bam_file, bam_file]),\n+      kmer_file=kmer_file,\n+      filter_bwa_image=filter_bwa_image,\n+      frac_non_host_reads=frac_non_host_reads,\n+      gather_metrics=gather_filter_metrics,\n+      is_host_aligned=is_host_aligned,\n+      filter_duplicates=filter_duplicates,\n+      skip_quality_filters=skip_quality_filters,\n+      min_clipped_read_length=min_clipped_read_length,\n+      bam_partition_size=filter_bam_partition_size,\n+      host_min_identity=host_min_identity,\n+      filter_bwa_seed_length=filter_bwa_seed_length,\n+      max_masked_bases=max_masked_bases,\n+      min_base_quality=min_base_quality,\n+      quality_threshold=quality_threshold,\n+      dust_mask_quality=dust_mask_quality,\n+      dust_window=dust_window,\n+      dust_t=dust_t,\n+      host_kmer_threshold=host_kmer_threshold,\n+      max_adapter_mistmatches=max_adapter_mistmatches,\n+      min_adapter_length=min_adapter_length,\n+      filter_reads_per_partition=filter_reads_per_partition,\n+      skip_pre_bwa_repartition=skip_pre_bwa_repartition,\n+      gatk4_jar_override=gatk4_jar_override,\n+      mem_gb=filter_mem_gb,\n+      gatk_docker=gatk_docker,\n+      preemptible_attempts=filter_preemptible_attempts,\n+      additional_disk_gb=filter_additional_disk_gb,\n+      cpu=filter_cpu,\n+      use_ssd=filter_ssd\n+  }\n+\n+  if (gather_filter_metrics) {\n+    call ProcessFilterMetrics {\n+      input:\n+        metrics_file=PathSeqFilter.filter_metrics,\n+        preemptible_tries=process_filter_metrics_preemptible_attempts,\n+        docker=linux_docker\n+    }\n+  }\n+\n+  if (!filtering_only) {\n+    call PathSeqAlign {\n+      input:\n+        sample_name=sample_name,\n+        input_paired_bam=PathSeqFilter.paired_bam_out,\n+        input_unpaired_bam=PathSeqFilter.unpaired_bam_out,\n+        microbe_bwa_image=select_first([microbe_bwa_image]),\n+        microbe_dict=select_first([microbe_dict]),\n+        microbe_min_seed_length=microbe_min_seed_length,\n+        max_alternate_hits=max_alternate_hits,\n+        bwa_score_threshold=bwa_score_threshold,\n+        gatk4_jar_override=gatk4_jar_override,\n+        mem_gb=align_mem_gb,\n+        gatk_docker=gatk_docker,\n+        preemptible_attempts=align_preemptible_attempts,\n+        additional_disk_gb=align_additional_disk_gb,\n+        cpu=align_cpu,\n+        use_ssd=align_ssd\n+    }\n+\n+    call PathSeqScore {\n+      input:\n+        sample_name=sample_name,\n+        input_paired_bam=PathSeqAlign.paired_bam_out,\n+        input_unpaired_bam=PathSeqAlign.unpaired_bam_out,\n+        taxonomy_file=select_first([taxonomy_file]),\n+        divide_by_genome_length=divide_by_genome_length,\n+        min_score_identity=min_score_identity,\n+        identity_margin=identity_margin,\n+        not_normalized_by_kingdom=not_normalized_by_kingdom,\n+        score_reads_per_partition_estimate=score_reads_per_partition_estimate,\n+        gatk4_jar_override=gatk4_jar_override,\n+        mem_gb=score_mem_gb,\n+        gatk_docker=gatk_docker,\n+        preemptible_attempts=score_preemptible_attempts,\n+        additional_disk_gb=score_additional_disk_gb,\n+        cpu=score_cpu,\n+        use_ssd=score_ssd\n+    }\n+\n+    call ProcessScoreMetrics {\n+      input:\n+        metrics_file=PathSeqScore.score_metrics,\n+        preemptible_tries=process_score_metrics_preemptible_attempts,\n+        docker=linux_docker\n+    }\n+  }\n+\n+  output {\n+    # Filtered non-host reads\n+    File non_host_paired_bam = PathSeqFilter.paired_bam_out\n+    File non_host_unpaired_bam = PathSeqFilter.unpaired_bam_out\n+\n+    # Only generated if filtering_only=false\n+    File? final_bam = PathSeqScore.bam_out\n+    File? taxonomy_scores = PathSeqScore.scores\n+    File? score_metrics_file = PathSeqScore.score_metrics\n+    Int? non_host_mapped_reads = ProcessScoreMetrics.non_host_mapped_reads\n+    Int? non_host_unmapped_reads = ProcessScoreMetrics.non_host_unmapped_reads\n+\n+    # Only generated if gather_filter_metrics=true\n+    File? filter_metrics_file = ProcessFilterMetrics.metrics_file_out\n+    Float? frac_after_prealigned_filter = ProcessFilterMetrics.frac_after_prealigned_filter\n+    Float? frac_after_qual_cpx_filter = ProcessFilterMetrics.frac_after_qual_cpx_filter\n+    Float? frac_after_host_filter = ProcessFilterMetrics.frac_after_host_filter\n+    Float? frac_after_dedup = ProcessFilterMetrics.frac_after_dedup\n+    Float? frac_non_host_paired = ProcessFilterMetrics.frac_final_paired\n+    Float? frac_non_host_unpaired = ProcessFilterMetrics.frac_final_unpaired\n+    Float? frac_non_host_total =ProcessFilterMetrics.frac_final_total\n+    Float? frac_qual_cpx_filtered = ProcessFilterMetrics.frac_qual_cpx_filtered\n+    Float? frac_host_filtered = ProcessFilterMetrics.frac_host_filtered\n+    Float? frac_dup_filtered = ProcessFilterMetrics.frac_dup_filtered\n+\n+    # Only generated if downsample=true\n+    Int? total_reads = Downsample.total_reads\n+  }\n+}\n+\n+task CramToBam {\n+  File cram_file\n+  File? cram_index\n+  File reference_fasta\n+  File? reference_index\n+\n+  String docker\n+\n+  Int? cpu = 4\n+  Float? mem_gb = 15\n+  Int? extra_disk_gb = 10\n+  Int? preemptible = 3\n+  Int? max_retries = 1\n+\n+  String bam_file_name = basename(cram_file, \".cram\") + \".bam\"\n+\n+  File cram_index_file = select_first([cram_index, cram_file + \".crai\"])\n+  File reference_index_file = select_first([reference_index, reference_fasta + \".fai\"])\n+\n+  Float cram_inflate_ratio = 3.0\n+  Float cram_size = size(cram_file, \"GiB\")\n+  Float cram_index_size = size(cram_index_file, \"GiB\")\n+  Float bam_size = cram_inflate_ratio * cram_size\n+  Float bam_index_size = cram_index_size\n+  Float ref_size = size(reference_fasta, \"GiB\")\n+  Float ref_index_size = size(reference_index_file, \"GiB\")\n+  Int vm_disk_size = ceil(cram_size + cram_index_size + bam_size + bam_index_size + ref_size + ref_index_size + extra_disk_gb)\n+\n+  output {\n+    File bam_file = bam_file_name\n+    File bam_index = bam_file_name + \".bai\"\n+  }\n+  command <<<\n+\n+        set -Eeuo pipefail\n+\n+        # covert cram to bam\n+        samtools view  -@ ${cpu} -h -b -T \"${reference_fasta}\" -o \"${bam_file_name}\" \"${cram_file}\"\n+\n+        # index bam file\n+        samtools index -@ ${cpu} \"${bam_file_name}\"\n+\n+  >>>\n+  runtime {\n+    cpu: 1\n+    memory: mem_gb + \" GiB\"\n+    disks: \"local-disk \" + vm_disk_size + \" HDD\"\n+    bootDiskSizeGb: 10\n+    docker: docker\n+    preemptible: preemptible\n+    maxRetries: max_retries\n+  }\n+}\n+\n+# Downsamples BAM to a specified number of reads\n+task Downsample {\n+  File input_bam_file\n+  File? input_bam_index_file\n+  String downsampled_bam_filename\n+\n+  Int reads_after_downsampling\n+\n+  String docker\n+  Int additional_disk_gb = 20\n+  Int preemptible_tries = 3\n+\n+  Int disk_size = ceil(size(input_bam_file, \"GB\")*2 + additional_disk_gb)\n+\n+  command <<<\n+    set -euo pipefail\n+    if ${defined(input_bam_index_file)}; then\n+      NUM_READS=`samtools idxstats ${input_bam_file} | awk '{s+=$3+$4} END {print s}'`\n+    else\n+      NUM_READS=`samtools view -c ${input_bam_file}`\n+    fi\n+    P_DOWNSAMPLE=`python -c \"print ${reads_after_downsampling}/float($NUM_READS)\"`\n+    RESULT=`python -c \"print $P_DOWNSAMPLE > 1\"`\n+    if [ \"$RESULT\" == \"True\" ]\n+    then\n+        P_DOWNSAMPLE=\"1\"\n+    fi\n+    echo $NUM_READS > num_reads.txt\n+    java -Xmx2000m -jar /usr/gitc/picard.jar \\\n+      DownsampleSam \\\n+      INPUT=${input_bam_file} \\\n+      OUTPUT=${downsampled_bam_filename} \\\n+      P=$P_DOWNSAMPLE \\\n+      VALIDATION_STRINGENCY=SILENT\n+  >>>\n+  output {\n+    File output_bam_file = \"${downsampled_bam_filename}\"\n+    Int total_reads = read_int(\"num_reads.txt\")\n+  }\n+  runtime {\n+    preemptible: \"${preemptible_tries}\"\n+    docker: docker\n+    memory: \"3.75 GiB\"\n+    cpu: \"1\"\n+    disks: \"local-disk ${disk_size} HDD\"\n+  }\n+}\n+\n+task PathSeqFilter {\n+\n+  # Inputs for this task\n+  String sample_name\n+  File input_bam_or_cram\n+\n+  File? kmer_file\n+  File? filter_bwa_image\n+\n+  Boolean is_host_aligned\n+  Boolean gather_metrics\n+  # Optimizes disk space if provided\n+  Float frac_non_host_reads = 1.0\n+\n+  Boolean? skip_quality_filters\n+  Boolean? skip_pre_bwa_repartition\n+  Boolean? filter_duplicates\n   Int? host_min_identity\n+  Int? filter_bwa_seed_length\n   Int? min_clipped_read_length\n   Int? bam_partition_size\n-  Float? min_score_identity\n-  Float? identity_margin\n+  Int? max_masked_bases\n+  Int? min_base_quality\n+  Int? quality_threshold\n+  Int? dust_mask_quality\n+  Int? dust_window\n+  Float? dust_t\n+  Int? host_kmer_threshold\n+  Int? max_adapter_mistmatches\n+  Int? min_adapter_length\n+  Int? filter_reads_per_partition\n \n-  String bam_output_path = \"${sample_name}.pathseq.bam\"\n-  String scores_output_path = \"${sample_name}.pathseq.tsv\"\n+  String paired_bam_output_path = \"${sample_name}.non_host.paired.bam\"\n+  String unpaired_bam_output_path = \"${sample_name}.non_host.unpaired.bam\"\n   String filter_metrics_output_path = \"${sample_name}.pathseq.filter_metrics\"\n-  String score_metrics_output_path = \"${sample_name}.pathseq.score_metrics\"\n \n   File? gatk4_jar_override\n \n+  # Default to WARNING which will avoid excessive Spark logging\n+  String verbosity = \"WARNING\"\n+\n   # Runtime parameters\n-  Int? mem_gb\n   String gatk_docker\n-  Int? preemptible_attempts\n-  Int? disk_space_gb\n-  Int? cpu\n-  Boolean use_ssd = true\n-\n-  # You may have to change the following two parameter values depending on the task requirements\n-  Int default_ram_mb = 208000\n-  # WARNING: In the workflow, you should calculate the disk space as an input to this task (disk_space_gb).\n-  Int default_disk_space_gb = 400\n+  Int mem_gb = 32\n+  Int preemptible_attempts = 3\n+  Float additional_disk_gb = 50\n+  Int cpu = 8\n+  Boolean use_ssd = false\n+\n+  Int disk_size = ceil(((1.0 + frac_non_host_reads)*size(input_bam_or_cram, \"GB\")) + size(kmer_file, \"GB\") + size(filter_bwa_image, \"GB\") + additional_disk_gb)\n+\n   # Mem is in units of GB but our command and memory runtime values are in MB\n-  Int machine_mem = if defined(mem_gb) then mem_gb *1000 else default_ram_mb\n-  Int command_mem = machine_mem - 4000\n+  Int machine_mem = mem_gb * 1000\n+  Int command_mem = ceil((machine_mem - size(filter_bwa_image, \"MB\")) * 0.8)\n+\n+  command <<<\n+    set -euo pipefail\n+    export GATK_LOCAL_JAR=${default=\"/root/gatk.jar\" gatk4_jar_override}\n+    touch ${filter_metrics_output_path}\n+    gatk --java-options \"-Xmx${command_mem}m\" \\\n+      PathSeqFilterSpark \\\n+      --input ${input_bam_or_cram} \\\n+      --paired-output ${paired_bam_output_path} \\\n+      --unpaired-output ${unpaired_bam_output_path} \\\n+      --is-host-aligned ${is_host_aligned}  \\\n+      --verbosity ${verbosity} \\\n+      ${if gather_metrics then \"--filter-metrics ${filter_metrics_output_path}\" else \"\"} \\\n+      ${if defined(kmer_file) then \"--kmer-file ${kmer_file}\" else \"\"} \\\n+      ${if defined(filter_bwa_image) then \"--filter-bwa-image ${filter_bwa_image}\" else \"\"} \\\n+      ${if defined(bam_partition_size) then \"--bam-partition-size ${bam_partition_size}\" else \"\"} \\\n+      ${if defined(skip_quality_filters) then \"--skip-quality-filters ${skip_quality_filters}\" else \"\"}\\\n+      ${if defined(min_clipped_read_length) then \"--min-clipped-read-length ${min_clipped_read_length}\" else \"\"} \\\n+      ${if defined(max_masked_bases) then \"--max-masked-bases ${max_masked_bases}\" else \"\"} \\\n+      ${if defined(min_base_quality) then \"--min-base-quality ${min_base_quality}\" else \"\"} \\\n+      ${if defined(quality_threshold) then \"--quality-threshold ${quality_threshold}\" else \"\"} \\\n+      ${if defined(dust_mask_quality) then \"--dust-mask-quality ${dust_mask_quality}\" else \"\"} \\\n+      ${if defined(dust_window) then \"--dust-window ${dust_window}\" else \"\"} \\\n+      ${if defined(dust_t) then \"--dust-t ${dust_t}\" else \"\"} \\\n+      ${if defined(host_kmer_threshold) then \"--host-kmer-thresh ${host_kmer_threshold}\" else \"\"} \\\n+      ${if defined(max_adapter_mistmatches) then \"--max-adapter-mismatches ${max_adapter_mistmatches}\" else \"\"} \\\n+      ${if defined(min_adapter_length) then \"--min-adapter-length ${min_adapter_length}\" else \"\"} \\\n+      ${if defined(filter_bwa_seed_length) then \"--filter-bwa-seed-length ${filter_bwa_seed_length}\" else \"\"} \\\n+      ${if defined(host_min_identity) then \"--host-min-identity ${host_min_identity}\" else \"\"} \\\n+      ${if defined(filter_duplicates) then \"--filter-duplicates ${filter_duplicates}\" else \"\"} \\\n+      ${if defined(skip_pre_bwa_repartition) then \"--skip-pre-bwa-repartition ${skip_pre_bwa_repartition}\" else \"\"} \\\n+      ${if defined(filter_reads_per_partition) then \"--filter-reads-per-partition ${filter_reads_per_partition}\" else \"\"}\n+\n+    if [ ! -f \"${paired_bam_output_path}\" ]; then\n+    \techo \"File ${paired_bam_output_path} not found, creating empty BAM\"", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQzMDEyMg=="}, "originalCommit": {"oid": "d0c8174e86870f21669206f4b6a6f4954794c8a9"}, "originalPosition": 537}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUzNTY2NTY1OnYy", "diffSide": "RIGHT", "path": "scripts/pathseq/wdl/pathseq_pipeline.wdl", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNFQyMDo1ODo0OFrOGFgqlQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNFQyMDo1ODo0OFrOGFgqlQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQzMTI1Mw==", "bodyText": "These floats are nice for Terra data model output.  Thanks.", "url": "https://github.com/broadinstitute/gatk/pull/6536#discussion_r408431253", "createdAt": "2020-04-14T20:58:48Z", "author": {"login": "ldgauthier"}, "path": "scripts/pathseq/wdl/pathseq_pipeline.wdl", "diffHunk": "@@ -20,179 +26,712 @@\n ## - - one or more read groups all belong to a single sample (SM)\n ##\n ## Output:\n-## - BAM file containing microbe-mapped reads and reads of unknown sequence\n-## - Tab-separated value (.tsv) file of taxonomic abundance scores\n-## - Picard-style metrics files for the filter and scoring phases of the pipeline\n+## - non_host_paired_bam, non_host_unpaired_bam: BAM files containing quality-filtered non-host paired and unpaired reads\n+## - If filtering_only = false:\n+##   - final_bam : BAM file containing microbe-mapped reads and reads of unknown sequence\n+##   - taxonomy_scores : tab-separated value (.tsv) file of taxonomic abundance scores\n+##   - score_metrics_file : Picard-style metrics file for scoring stage\n+##   - non_host_mapped_reads : number of non-host reads mapped to microbe reference\n+##   - non_host_unmapped_reads : number of non-host reads that did not map to the microbe reference\n+## - If gather_filter_metrics = true:\n+##   - filter_metrics_file : Picard-style metrics file for filtering stage\n+##   - frac_after_prealigned_filter : estimated fraction of reads remaining after filtering prealigned host reads\n+##   - frac_after_qual_cpx_filter : estimated fraction of reads remaining after low-quality and low-complexity filtering\n+##   - frac_after_host_filter : estimated fraction of reads remaining after host read filtering\n+##   - frac_after_dedup : estimated fraction of reads remaining after deduplication\n+##   - frac_final_paired : estimated fraction of reads that were paired in the final output\n+##   - frac_final_unpaired : estimated fraction of reads that were unpaired in the final output\n+##   - frac_final_total : estimated fraction of reads in the final output\n+##   - frac_qual_cpx_filtered : estimated fraction of reads removed by low-quality/low-complexity filtering\n+##   - frac_host_filtered : estimated fraction of reads removed by host filtering\n+##   - frac_dup_filtered : estimated fraction of reads removed by deduplication\n+## - If downsample = true:\n+##   - total_reads_if_avail : total number of reads in the original input BAM\n ##\n ########################################################################################################################\n \n-task PathseqPipeline {\n+workflow PathSeqPipeline {\n \n-  # Inputs for this task\n   String sample_name\n-  File input_bam\n+  File input_bam_or_cram\n+  # Required if a cram\n+  File? input_bam_or_cram_index\n \n-  File kmer_file\n-  File filter_bwa_image\n-  File microbe_bwa_image\n-  File microbe_fasta\n-  File microbe_fasta_dict\n-  File taxonomy_file\n+  # Required if the input is a cram\n+  File? cram_reference_fasta\n+  File? cram_reference_fasta_index\n+  File? cram_reference_dict\n \n+  # Set to true if host aligned. WARNING: Results in loss of EBV reads if in the aligned reference.\n   Boolean is_host_aligned\n-  Boolean? skip_quality_filters\n+\n+  File? kmer_file\n+  File? filter_bwa_image\n+  # Required if filtering_only=true\n+  File? microbe_bwa_image\n+  File? microbe_dict\n+  File? taxonomy_file\n+\n+  # If enabled, filter metrics will be estimated using a downsampled bam with this many reads (recommended)\n+  # If disabled, no filter metrics will be generated\n+  Boolean downsample = false\n+  Int downsample_reads = 1000000\n+\n+  # Enable to only perform host filtering\n+  Boolean filtering_only = false\n+\n+  # Only recommended if downsample = true\n+  Boolean gather_filter_metrics = false\n+\n+  # This can be calculated from a downsampled run to help optimize disk allocation during filtering\n+  Float frac_non_host_reads = 1.0\n+\n+  # Filtering options\n   Boolean? filter_duplicates\n+  Boolean? skip_quality_filters\n+  Int? host_min_identity\n+  Int? host_kmer_threshold\n+  Int? filter_bwa_seed_length\n+  Int? min_clipped_read_length\n+  Int? max_masked_bases\n+  Int? min_base_quality\n+  Int? quality_threshold\n+  Int? dust_mask_quality\n+  Int? dust_window\n+  Float? dust_t\n+  Int? max_adapter_mistmatches\n+  Int? min_adapter_length\n+  Int? filter_reads_per_partition\n+  Int? filter_bam_partition_size\n   Boolean? skip_pre_bwa_repartition\n+\n+  # Alignment options\n+  Int? microbe_min_seed_length\n+  Int? max_alternate_hits\n+  Int? bwa_score_threshold\n+\n+  # Taxonomy scoring options\n   Boolean? divide_by_genome_length\n-  Int? filter_bwa_seed_length\n+  Float? min_score_identity\n+  Float? identity_margin\n+  Boolean? not_normalized_by_kingdom\n+  Int? score_reads_per_partition_estimate\n+\n+  # Runtime parameters\n+  String gatk_docker\n+  String samtools_docker = \"biocontainers/samtools:v1.9-4-deb_cv1\"\n+  String genomes_in_the_cloud_docker = \"broadinstitute/genomes-in-the-cloud:2.3.1-1512499786\"\n+  String linux_docker = \"ubuntu:18.10\"\n+\n+  File? gatk4_jar_override\n+\n+  Int? cram_to_bam_preemptible_attempts\n+  Int? downsample_preemptible_attempts\n+  Int? filter_preemptible_attempts\n+  Int? align_preemptible_attempts\n+  Int? score_preemptible_attempts\n+  Int? process_filter_metrics_preemptible_attempts\n+  Int? process_score_metrics_preemptible_attempts\n+\n+  Int? cram_to_bam_cpu\n+  Int? filter_cpu\n+  Int? align_cpu\n+  Int? score_cpu\n+\n+  Float? cram_to_bam_mem_gb\n+  Int? filter_mem_gb\n+  Int? align_mem_gb\n+  Int? score_mem_gb\n+\n+  Boolean? filter_ssd\n+  Boolean? align_ssd\n+  Boolean? score_ssd\n+\n+  Int? cram_to_bam_max_retries\n+\n+  # Optional input to increase all disk sizes in case of outlier sample with strange size behavior\n+  Int? cram_to_bam_additional_disk_gb\n+  Int? downsample_additional_disk_gb\n+  Int? filter_additional_disk_gb\n+  Int? align_additional_disk_gb\n+  Int? score_additional_disk_gb\n+\n+  Boolean is_bam = basename(input_bam_or_cram, \".bam\") + \".bam\" == basename(input_bam_or_cram)\n+\n+  # Convert to BAM if we have a CRAM\n+  if (!is_bam) {\n+    call CramToBam {\n+      input:\n+        cram_file = input_bam_or_cram,\n+        cram_index = select_first([input_bam_or_cram_index]),\n+        reference_fasta = select_first([cram_reference_fasta]),\n+        reference_index = select_first([cram_reference_fasta_index]),\n+        docker = samtools_docker,\n+        cpu = cram_to_bam_cpu,\n+        mem_gb = cram_to_bam_mem_gb,\n+        extra_disk_gb = cram_to_bam_additional_disk_gb,\n+        preemptible = cram_to_bam_preemptible_attempts,\n+        max_retries = cram_to_bam_max_retries,\n+    }\n+  }\n+\n+  File bam_file = select_first([CramToBam.bam_file, input_bam_or_cram])\n+  File? bam_index = if defined(CramToBam.bam_index) then CramToBam.bam_index else input_bam_or_cram_index\n+\n+  # Downsample bam for filter metrics estimation\n+  if (downsample) {\n+    call Downsample {\n+      input:\n+        input_bam_file=bam_file,\n+        input_bam_index_file=bam_index,\n+        downsampled_bam_filename=\"${sample_name}.downsampled.bam\",\n+        reads_after_downsampling=downsample_reads,\n+        additional_disk_gb=downsample_additional_disk_gb,\n+        preemptible_tries=downsample_preemptible_attempts,\n+        docker=genomes_in_the_cloud_docker\n+    }\n+  }\n+\n+  call PathSeqFilter {\n+    input:\n+      sample_name=sample_name,\n+      input_bam_or_cram=select_first([Downsample.output_bam_file, bam_file]),\n+      kmer_file=kmer_file,\n+      filter_bwa_image=filter_bwa_image,\n+      frac_non_host_reads=frac_non_host_reads,\n+      gather_metrics=gather_filter_metrics,\n+      is_host_aligned=is_host_aligned,\n+      filter_duplicates=filter_duplicates,\n+      skip_quality_filters=skip_quality_filters,\n+      min_clipped_read_length=min_clipped_read_length,\n+      bam_partition_size=filter_bam_partition_size,\n+      host_min_identity=host_min_identity,\n+      filter_bwa_seed_length=filter_bwa_seed_length,\n+      max_masked_bases=max_masked_bases,\n+      min_base_quality=min_base_quality,\n+      quality_threshold=quality_threshold,\n+      dust_mask_quality=dust_mask_quality,\n+      dust_window=dust_window,\n+      dust_t=dust_t,\n+      host_kmer_threshold=host_kmer_threshold,\n+      max_adapter_mistmatches=max_adapter_mistmatches,\n+      min_adapter_length=min_adapter_length,\n+      filter_reads_per_partition=filter_reads_per_partition,\n+      skip_pre_bwa_repartition=skip_pre_bwa_repartition,\n+      gatk4_jar_override=gatk4_jar_override,\n+      mem_gb=filter_mem_gb,\n+      gatk_docker=gatk_docker,\n+      preemptible_attempts=filter_preemptible_attempts,\n+      additional_disk_gb=filter_additional_disk_gb,\n+      cpu=filter_cpu,\n+      use_ssd=filter_ssd\n+  }\n+\n+  if (gather_filter_metrics) {\n+    call ProcessFilterMetrics {\n+      input:\n+        metrics_file=PathSeqFilter.filter_metrics,\n+        preemptible_tries=process_filter_metrics_preemptible_attempts,\n+        docker=linux_docker\n+    }\n+  }\n+\n+  if (!filtering_only) {\n+    call PathSeqAlign {\n+      input:\n+        sample_name=sample_name,\n+        input_paired_bam=PathSeqFilter.paired_bam_out,\n+        input_unpaired_bam=PathSeqFilter.unpaired_bam_out,\n+        microbe_bwa_image=select_first([microbe_bwa_image]),\n+        microbe_dict=select_first([microbe_dict]),\n+        microbe_min_seed_length=microbe_min_seed_length,\n+        max_alternate_hits=max_alternate_hits,\n+        bwa_score_threshold=bwa_score_threshold,\n+        gatk4_jar_override=gatk4_jar_override,\n+        mem_gb=align_mem_gb,\n+        gatk_docker=gatk_docker,\n+        preemptible_attempts=align_preemptible_attempts,\n+        additional_disk_gb=align_additional_disk_gb,\n+        cpu=align_cpu,\n+        use_ssd=align_ssd\n+    }\n+\n+    call PathSeqScore {\n+      input:\n+        sample_name=sample_name,\n+        input_paired_bam=PathSeqAlign.paired_bam_out,\n+        input_unpaired_bam=PathSeqAlign.unpaired_bam_out,\n+        taxonomy_file=select_first([taxonomy_file]),\n+        divide_by_genome_length=divide_by_genome_length,\n+        min_score_identity=min_score_identity,\n+        identity_margin=identity_margin,\n+        not_normalized_by_kingdom=not_normalized_by_kingdom,\n+        score_reads_per_partition_estimate=score_reads_per_partition_estimate,\n+        gatk4_jar_override=gatk4_jar_override,\n+        mem_gb=score_mem_gb,\n+        gatk_docker=gatk_docker,\n+        preemptible_attempts=score_preemptible_attempts,\n+        additional_disk_gb=score_additional_disk_gb,\n+        cpu=score_cpu,\n+        use_ssd=score_ssd\n+    }\n+\n+    call ProcessScoreMetrics {\n+      input:\n+        metrics_file=PathSeqScore.score_metrics,\n+        preemptible_tries=process_score_metrics_preemptible_attempts,\n+        docker=linux_docker\n+    }\n+  }\n+\n+  output {\n+    # Filtered non-host reads\n+    File non_host_paired_bam = PathSeqFilter.paired_bam_out\n+    File non_host_unpaired_bam = PathSeqFilter.unpaired_bam_out\n+\n+    # Only generated if filtering_only=false\n+    File? final_bam = PathSeqScore.bam_out\n+    File? taxonomy_scores = PathSeqScore.scores\n+    File? score_metrics_file = PathSeqScore.score_metrics\n+    Int? non_host_mapped_reads = ProcessScoreMetrics.non_host_mapped_reads\n+    Int? non_host_unmapped_reads = ProcessScoreMetrics.non_host_unmapped_reads\n+\n+    # Only generated if gather_filter_metrics=true\n+    File? filter_metrics_file = ProcessFilterMetrics.metrics_file_out\n+    Float? frac_after_prealigned_filter = ProcessFilterMetrics.frac_after_prealigned_filter\n+    Float? frac_after_qual_cpx_filter = ProcessFilterMetrics.frac_after_qual_cpx_filter\n+    Float? frac_after_host_filter = ProcessFilterMetrics.frac_after_host_filter\n+    Float? frac_after_dedup = ProcessFilterMetrics.frac_after_dedup\n+    Float? frac_non_host_paired = ProcessFilterMetrics.frac_final_paired\n+    Float? frac_non_host_unpaired = ProcessFilterMetrics.frac_final_unpaired\n+    Float? frac_non_host_total =ProcessFilterMetrics.frac_final_total\n+    Float? frac_qual_cpx_filtered = ProcessFilterMetrics.frac_qual_cpx_filtered\n+    Float? frac_host_filtered = ProcessFilterMetrics.frac_host_filtered\n+    Float? frac_dup_filtered = ProcessFilterMetrics.frac_dup_filtered\n+\n+    # Only generated if downsample=true\n+    Int? total_reads = Downsample.total_reads\n+  }\n+}\n+\n+task CramToBam {\n+  File cram_file\n+  File? cram_index\n+  File reference_fasta\n+  File? reference_index\n+\n+  String docker\n+\n+  Int? cpu = 4\n+  Float? mem_gb = 15\n+  Int? extra_disk_gb = 10\n+  Int? preemptible = 3\n+  Int? max_retries = 1\n+\n+  String bam_file_name = basename(cram_file, \".cram\") + \".bam\"\n+\n+  File cram_index_file = select_first([cram_index, cram_file + \".crai\"])\n+  File reference_index_file = select_first([reference_index, reference_fasta + \".fai\"])\n+\n+  Float cram_inflate_ratio = 3.0\n+  Float cram_size = size(cram_file, \"GiB\")\n+  Float cram_index_size = size(cram_index_file, \"GiB\")\n+  Float bam_size = cram_inflate_ratio * cram_size\n+  Float bam_index_size = cram_index_size\n+  Float ref_size = size(reference_fasta, \"GiB\")\n+  Float ref_index_size = size(reference_index_file, \"GiB\")\n+  Int vm_disk_size = ceil(cram_size + cram_index_size + bam_size + bam_index_size + ref_size + ref_index_size + extra_disk_gb)\n+\n+  output {\n+    File bam_file = bam_file_name\n+    File bam_index = bam_file_name + \".bai\"\n+  }\n+  command <<<\n+\n+        set -Eeuo pipefail\n+\n+        # covert cram to bam\n+        samtools view  -@ ${cpu} -h -b -T \"${reference_fasta}\" -o \"${bam_file_name}\" \"${cram_file}\"\n+\n+        # index bam file\n+        samtools index -@ ${cpu} \"${bam_file_name}\"\n+\n+  >>>\n+  runtime {\n+    cpu: 1\n+    memory: mem_gb + \" GiB\"\n+    disks: \"local-disk \" + vm_disk_size + \" HDD\"\n+    bootDiskSizeGb: 10\n+    docker: docker\n+    preemptible: preemptible\n+    maxRetries: max_retries\n+  }\n+}\n+\n+# Downsamples BAM to a specified number of reads\n+task Downsample {\n+  File input_bam_file\n+  File? input_bam_index_file\n+  String downsampled_bam_filename\n+\n+  Int reads_after_downsampling\n+\n+  String docker\n+  Int additional_disk_gb = 20\n+  Int preemptible_tries = 3\n+\n+  Int disk_size = ceil(size(input_bam_file, \"GB\")*2 + additional_disk_gb)\n+\n+  command <<<\n+    set -euo pipefail\n+    if ${defined(input_bam_index_file)}; then\n+      NUM_READS=`samtools idxstats ${input_bam_file} | awk '{s+=$3+$4} END {print s}'`\n+    else\n+      NUM_READS=`samtools view -c ${input_bam_file}`\n+    fi\n+    P_DOWNSAMPLE=`python -c \"print ${reads_after_downsampling}/float($NUM_READS)\"`\n+    RESULT=`python -c \"print $P_DOWNSAMPLE > 1\"`\n+    if [ \"$RESULT\" == \"True\" ]\n+    then\n+        P_DOWNSAMPLE=\"1\"\n+    fi\n+    echo $NUM_READS > num_reads.txt\n+    java -Xmx2000m -jar /usr/gitc/picard.jar \\\n+      DownsampleSam \\\n+      INPUT=${input_bam_file} \\\n+      OUTPUT=${downsampled_bam_filename} \\\n+      P=$P_DOWNSAMPLE \\\n+      VALIDATION_STRINGENCY=SILENT\n+  >>>\n+  output {\n+    File output_bam_file = \"${downsampled_bam_filename}\"\n+    Int total_reads = read_int(\"num_reads.txt\")\n+  }\n+  runtime {\n+    preemptible: \"${preemptible_tries}\"\n+    docker: docker\n+    memory: \"3.75 GiB\"\n+    cpu: \"1\"\n+    disks: \"local-disk ${disk_size} HDD\"\n+  }\n+}\n+\n+task PathSeqFilter {\n+\n+  # Inputs for this task\n+  String sample_name\n+  File input_bam_or_cram\n+\n+  File? kmer_file\n+  File? filter_bwa_image\n+\n+  Boolean is_host_aligned\n+  Boolean gather_metrics\n+  # Optimizes disk space if provided\n+  Float frac_non_host_reads = 1.0\n+\n+  Boolean? skip_quality_filters\n+  Boolean? skip_pre_bwa_repartition\n+  Boolean? filter_duplicates\n   Int? host_min_identity\n+  Int? filter_bwa_seed_length\n   Int? min_clipped_read_length\n   Int? bam_partition_size\n-  Float? min_score_identity\n-  Float? identity_margin\n+  Int? max_masked_bases\n+  Int? min_base_quality\n+  Int? quality_threshold\n+  Int? dust_mask_quality\n+  Int? dust_window\n+  Float? dust_t\n+  Int? host_kmer_threshold\n+  Int? max_adapter_mistmatches\n+  Int? min_adapter_length\n+  Int? filter_reads_per_partition\n \n-  String bam_output_path = \"${sample_name}.pathseq.bam\"\n-  String scores_output_path = \"${sample_name}.pathseq.tsv\"\n+  String paired_bam_output_path = \"${sample_name}.non_host.paired.bam\"\n+  String unpaired_bam_output_path = \"${sample_name}.non_host.unpaired.bam\"\n   String filter_metrics_output_path = \"${sample_name}.pathseq.filter_metrics\"\n-  String score_metrics_output_path = \"${sample_name}.pathseq.score_metrics\"\n \n   File? gatk4_jar_override\n \n+  # Default to WARNING which will avoid excessive Spark logging\n+  String verbosity = \"WARNING\"\n+\n   # Runtime parameters\n-  Int? mem_gb\n   String gatk_docker\n-  Int? preemptible_attempts\n-  Int? disk_space_gb\n-  Int? cpu\n-  Boolean use_ssd = true\n-\n-  # You may have to change the following two parameter values depending on the task requirements\n-  Int default_ram_mb = 208000\n-  # WARNING: In the workflow, you should calculate the disk space as an input to this task (disk_space_gb).\n-  Int default_disk_space_gb = 400\n+  Int mem_gb = 32\n+  Int preemptible_attempts = 3\n+  Float additional_disk_gb = 50\n+  Int cpu = 8\n+  Boolean use_ssd = false\n+\n+  Int disk_size = ceil(((1.0 + frac_non_host_reads)*size(input_bam_or_cram, \"GB\")) + size(kmer_file, \"GB\") + size(filter_bwa_image, \"GB\") + additional_disk_gb)\n+\n   # Mem is in units of GB but our command and memory runtime values are in MB\n-  Int machine_mem = if defined(mem_gb) then mem_gb *1000 else default_ram_mb\n-  Int command_mem = machine_mem - 4000\n+  Int machine_mem = mem_gb * 1000\n+  Int command_mem = ceil((machine_mem - size(filter_bwa_image, \"MB\")) * 0.8)\n+\n+  command <<<\n+    set -euo pipefail\n+    export GATK_LOCAL_JAR=${default=\"/root/gatk.jar\" gatk4_jar_override}\n+    touch ${filter_metrics_output_path}\n+    gatk --java-options \"-Xmx${command_mem}m\" \\\n+      PathSeqFilterSpark \\\n+      --input ${input_bam_or_cram} \\\n+      --paired-output ${paired_bam_output_path} \\\n+      --unpaired-output ${unpaired_bam_output_path} \\\n+      --is-host-aligned ${is_host_aligned}  \\\n+      --verbosity ${verbosity} \\\n+      ${if gather_metrics then \"--filter-metrics ${filter_metrics_output_path}\" else \"\"} \\\n+      ${if defined(kmer_file) then \"--kmer-file ${kmer_file}\" else \"\"} \\\n+      ${if defined(filter_bwa_image) then \"--filter-bwa-image ${filter_bwa_image}\" else \"\"} \\\n+      ${if defined(bam_partition_size) then \"--bam-partition-size ${bam_partition_size}\" else \"\"} \\\n+      ${if defined(skip_quality_filters) then \"--skip-quality-filters ${skip_quality_filters}\" else \"\"}\\\n+      ${if defined(min_clipped_read_length) then \"--min-clipped-read-length ${min_clipped_read_length}\" else \"\"} \\\n+      ${if defined(max_masked_bases) then \"--max-masked-bases ${max_masked_bases}\" else \"\"} \\\n+      ${if defined(min_base_quality) then \"--min-base-quality ${min_base_quality}\" else \"\"} \\\n+      ${if defined(quality_threshold) then \"--quality-threshold ${quality_threshold}\" else \"\"} \\\n+      ${if defined(dust_mask_quality) then \"--dust-mask-quality ${dust_mask_quality}\" else \"\"} \\\n+      ${if defined(dust_window) then \"--dust-window ${dust_window}\" else \"\"} \\\n+      ${if defined(dust_t) then \"--dust-t ${dust_t}\" else \"\"} \\\n+      ${if defined(host_kmer_threshold) then \"--host-kmer-thresh ${host_kmer_threshold}\" else \"\"} \\\n+      ${if defined(max_adapter_mistmatches) then \"--max-adapter-mismatches ${max_adapter_mistmatches}\" else \"\"} \\\n+      ${if defined(min_adapter_length) then \"--min-adapter-length ${min_adapter_length}\" else \"\"} \\\n+      ${if defined(filter_bwa_seed_length) then \"--filter-bwa-seed-length ${filter_bwa_seed_length}\" else \"\"} \\\n+      ${if defined(host_min_identity) then \"--host-min-identity ${host_min_identity}\" else \"\"} \\\n+      ${if defined(filter_duplicates) then \"--filter-duplicates ${filter_duplicates}\" else \"\"} \\\n+      ${if defined(skip_pre_bwa_repartition) then \"--skip-pre-bwa-repartition ${skip_pre_bwa_repartition}\" else \"\"} \\\n+      ${if defined(filter_reads_per_partition) then \"--filter-reads-per-partition ${filter_reads_per_partition}\" else \"\"}\n+\n+    if [ ! -f \"${paired_bam_output_path}\" ]; then\n+    \techo \"File ${paired_bam_output_path} not found, creating empty BAM\"\n+    \tprintf \"@HD     VN:1.5  SO:queryname\\n@RG     ID:A    SM:${sample_name}\\n\" | samtools view -hb - > ${paired_bam_output_path}\n+    fi\n+\n+    if [ ! -f \"${unpaired_bam_output_path}\" ]; then\n+    \techo \"File ${unpaired_bam_output_path} not found, creating empty BAM\"\n+    \tprintf \"@HD     VN:1.5  SO:queryname\\n@RG     ID:A    SM:${sample_name}\\n\" | samtools view -hb - > ${unpaired_bam_output_path}\n+    fi\n+  >>>\n+  runtime {\n+    docker: gatk_docker\n+    memory: machine_mem + \" MB\"\n+    # Note that the space before SSD and HDD should be included.\n+    disks: \"local-disk \" + disk_size + if use_ssd then \" SSD\" else \" HDD\"\n+    preemptible: preemptible_attempts\n+    cpu: cpu\n+  }\n+  output {\n+    File paired_bam_out = \"${paired_bam_output_path}\"\n+    File unpaired_bam_out = \"${unpaired_bam_output_path}\"\n+    File filter_metrics = \"${sample_name}.pathseq.filter_metrics\"\n+  }\n+}\n+\n+task PathSeqAlign {\n \n-  Float default_min_score_identity = 0.9\n-  Float default_identity_margin = 0.02\n+  # Inputs for this task\n+  String sample_name\n+  File input_paired_bam\n+  File input_unpaired_bam\n+\n+  File microbe_bwa_image\n+  File microbe_dict\n+\n+  Int? microbe_min_seed_length\n+  Int? max_alternate_hits\n+  Int? bwa_score_threshold\n+\n+  String paired_bam_output_path = \"${sample_name}.microbe_aligned.paired.bam\"\n+  String unpaired_bam_output_path = \"${sample_name}.microbe_aligned.unpaired.bam\"\n+\n+  File? gatk4_jar_override\n+\n+  # Default to WARNING which will avoid excessive Spark logging\n+  String verbosity = \"WARNING\"\n+\n+  # Runtime parameters\n+  String gatk_docker\n+  Int mem_gb = 140\n+  Int preemptible_attempts = 3\n+  Float additional_disk_gb = 50\n+  Int cpu = 8\n+  Boolean use_ssd = false\n+\n+  Int disk_size = ceil((2.5*size(input_paired_bam, \"GB\")) + (2.5*size(input_unpaired_bam, \"GB\")) + size(microbe_bwa_image, \"GB\") + additional_disk_gb)\n+\n+  # Mem is in units of GB but our command and memory runtime values are in MB\n+  Int machine_mem = mem_gb * 1000\n+  Int command_mem = ceil((machine_mem - size(microbe_bwa_image, \"MB\")) * 0.8)\n \n   command <<<\n     set -e\n     export GATK_LOCAL_JAR=${default=\"/root/gatk.jar\" gatk4_jar_override}\n-      gatk --java-options \"-Xmx${command_mem}m\" \\\n-      PathSeqPipelineSpark \\\n-      --input ${input_bam} \\\n-      --output ${bam_output_path} \\\n-      --scores-output ${scores_output_path} \\\n-      --filter-metrics ${filter_metrics_output_path} \\\n-      --score-metrics ${score_metrics_output_path} \\\n-      --kmer-file ${kmer_file} \\\n-      --filter-bwa-image ${filter_bwa_image} \\\n+    gatk --java-options \"-Xmx${command_mem}m\" \\\n+      PathSeqBwaSpark \\\n+      --paired-input ${input_paired_bam} \\\n+      --unpaired-input ${input_unpaired_bam} \\\n+      --paired-output ${paired_bam_output_path} \\\n+      --unpaired-output ${unpaired_bam_output_path} \\\n       --microbe-bwa-image ${microbe_bwa_image} \\\n-      --microbe-fasta ${microbe_fasta} \\\n-      --taxonomy-file ${taxonomy_file} \\\n-      --bam-partition-size ${select_first([bam_partition_size, 4000000])} \\\n-      --is-host-aligned ${is_host_aligned} \\\n-      --skip-quality-filters ${select_first([skip_quality_filters, false])} \\\n-      --min-clipped-read-length ${select_first([min_clipped_read_length, 60])} \\\n-      --filter-bwa-seed-length ${select_first([filter_bwa_seed_length, 19])} \\\n-      --host-min-identity ${select_first([host_min_identity, 30])} \\\n-      --filter-duplicates ${select_first([filter_duplicates, true])} \\\n-      --skip-pre-bwa-repartition ${select_first([skip_pre_bwa_repartition, false])} \\\n-      --min-score-identity ${select_first([min_score_identity, default_min_score_identity])} \\\n-      --identity-margin ${select_first([identity_margin, default_identity_margin])} \\\n-      --divide-by-genome-length ${select_first([divide_by_genome_length, true])}\n+      --microbe-dict ${microbe_dict} \\\n+      --verbosity ${verbosity} \\\n+      ${if defined(microbe_min_seed_length) then \"--microbe-min-seed-length ${microbe_min_seed_length}\" else \"\"} \\\n+      ${if defined(max_alternate_hits) then \"--max-alternate-hits ${max_alternate_hits}\" else \"\"} \\\n+      ${if defined(bwa_score_threshold) then \"--bwa-score-threshold ${bwa_score_threshold}\" else \"\"}\n   >>>\n   runtime {\n     docker: gatk_docker\n     memory: machine_mem + \" MB\"\n     # Note that the space before SSD and HDD should be included.\n-    disks: \"local-disk \" + select_first([disk_space_gb, default_disk_space_gb]) + if use_ssd then \" SSD\" else \" HDD\"\n-    preemptible: select_first([preemptible_attempts, 3])\n-    cpu: select_first([cpu, 32])\n+    disks: \"local-disk \" + disk_size + if use_ssd then \" SSD\" else \" HDD\"\n+    preemptible: preemptible_attempts\n+    cpu: cpu\n   }\n   output {\n-    File bam_output_pathFile = \"${sample_name}.pathseq.bam\"\n-    File outputScoresFile = \"${sample_name}.pathseq.tsv\"\n-    File outputFilterMetricsFile = \"${sample_name}.pathseq.filter_metrics\"\n-    File outputScoreMetricsFile = \"${sample_name}.pathseq.score_metrics\"\n+    File paired_bam_out = \"${paired_bam_output_path}\"\n+    File unpaired_bam_out = \"${unpaired_bam_output_path}\"\n   }\n }\n \n-workflow PathSeqPipelineWorkflow {\n+task PathSeqScore {\n \n+  # Inputs for this task\n   String sample_name\n-  File input_bam\n+  File input_paired_bam\n+  File input_unpaired_bam\n \n-  File kmer_file\n-  File filter_bwa_image\n-  File microbe_bwa_image\n-  File microbe_fasta\n-  File microbe_fasta_dict\n   File taxonomy_file\n \n-  Boolean is_host_aligned\n-  Boolean? filter_duplicates\n-  Boolean? skip_pre_bwa_repartition\n   Boolean? divide_by_genome_length\n-  Int? filter_bwa_seed_length\n-  Int? host_min_identity\n-  Int? min_clipped_read_length\n-  Int? bam_partition_size\n   Float? min_score_identity\n   Float? identity_margin\n+  Boolean? not_normalized_by_kingdom\n+  Int? score_reads_per_partition_estimate\n+\n+  String bam_output_path = \"${sample_name}.pathseq.bam\"\n+  String scores_output_path = \"${sample_name}.pathseq.tsv\"\n+  String score_metrics_output_path = \"${sample_name}.pathseq.score_metrics\"\n \n   File? gatk4_jar_override\n \n   # Runtime parameters\n-  Int? mem_gb\n   String gatk_docker\n-  Int? preemptible_attempts\n-  Int? cpu\n+  Int mem_gb = 8\n+  Int preemptible_attempts = 3\n+  Float additional_disk_gb = 10\n+  Int cpu = 2\n+  Boolean use_ssd = false\n \n-  # Optional input to increase all disk sizes in case of outlier sample with strange size behavior\n-  Int? increase_disk_size\n+  Int disk_size = ceil(size(input_paired_bam, \"GB\") + size(input_unpaired_bam, \"GB\") + additional_disk_gb)\n \n-  # Some tasks need wiggle room, and we also need to add a small amount of disk to prevent getting a\n-  # Cromwell error from asking for 0 disk when the input is less than 1GB.\n-  # Also Spark requires some temporary storage.\n-  Int additional_disk = select_first([increase_disk_size, 20])\n+  # Mem is in units of GB but our command and memory runtime values are in MB\n+  Int machine_mem = mem_gb * 1000\n+  Int command_mem = ceil(machine_mem * 0.8)\n \n-  # Disk sizes for Downsample and PathSeq tasks\n-  Float disk_space_gb = size(input_bam, \"GB\") + size(kmer_file, \"GB\") + size(filter_bwa_image, \"GB\") + size(microbe_bwa_image, \"GB\") + size(microbe_fasta, \"GB\") + additional_disk\n+  command <<<\n+    set -e\n+    export GATK_LOCAL_JAR=${default=\"/root/gatk.jar\" gatk4_jar_override}\n+    gatk --java-options \"-Xmx${command_mem}m\" \\\n+      PathSeqScoreSpark \\\n+      --paired-input ${input_paired_bam} \\\n+      --unpaired-input ${input_unpaired_bam} \\\n+      --output ${bam_output_path} \\\n+      --scores-output ${scores_output_path} \\\n+      --score-metrics ${score_metrics_output_path} \\\n+      --taxonomy-file ${taxonomy_file} \\\n+      ${if defined(min_score_identity) then \"--min-score-identity ${min_score_identity}\" else \"\"} \\\n+      ${if defined(identity_margin) then \"--identity-margin ${identity_margin}\" else \"\"} \\\n+      ${if defined(divide_by_genome_length) then \"--divide-by-genome-length ${divide_by_genome_length}\" else \"\"} \\\n+      ${if defined(not_normalized_by_kingdom) then \"--not-normalized-by-kingdom ${not_normalized_by_kingdom}\" else \"\"} \\\n+      ${if defined(score_reads_per_partition_estimate) then \"--score-reads-per-partition-estimate ${score_reads_per_partition_estimate}\" else \"\"}\n+  >>>\n+  runtime {\n+    docker: gatk_docker\n+    memory: machine_mem + \" MB\"\n+    # Note that the space before SSD and HDD should be included.\n+    disks: \"local-disk \" + disk_size + if use_ssd then \" SSD\" else \" HDD\"\n+    preemptible: preemptible_attempts\n+    cpu: cpu\n+  }\n+  output {\n+    File bam_out = \"${sample_name}.pathseq.bam\"\n+    File scores = \"${sample_name}.pathseq.tsv\"\n+    File score_metrics = \"${sample_name}.pathseq.score_metrics\"\n+  }\n+}\n \n-  call PathseqPipeline {\n-    input:\n-      sample_name=sample_name,\n-      input_bam=input_bam,\n-      kmer_file=kmer_file,\n-      filter_bwa_image=filter_bwa_image,\n-      microbe_bwa_image=microbe_bwa_image,\n-      microbe_fasta=microbe_fasta,\n-      microbe_fasta_dict=microbe_fasta_dict,\n-      taxonomy_file=taxonomy_file,\n-      is_host_aligned=is_host_aligned,\n-      filter_duplicates=filter_duplicates,\n-      skip_pre_bwa_repartition=skip_pre_bwa_repartition,\n-      divide_by_genome_length=divide_by_genome_length,\n-      min_clipped_read_length=min_clipped_read_length,\n-      bam_partition_size=bam_partition_size,\n-      min_score_identity=min_score_identity,\n-      identity_margin=identity_margin,\n-      host_min_identity=host_min_identity,\n-      filter_bwa_seed_length=filter_bwa_seed_length,\n-      gatk4_jar_override=gatk4_jar_override,\n-      mem_gb=mem_gb,\n-      gatk_docker=gatk_docker,\n-      preemptible_attempts=preemptible_attempts,\n-      disk_space_gb=disk_space_gb,\n-      cpu=cpu\n+# Extracts filter metrics as fraction of total reads\n+task ProcessFilterMetrics {\n+  File metrics_file\n+  String docker\n+  Int preemptible_tries = 3\n+\n+  String dollar = \"$\"\n+\n+  command <<<\n+    set -euo pipefail\n+    if [ ! -s ${metrics_file} ]; then\n+      echo \"\" | awk -v OFS=\"\\t\" '{print 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}'\n+    else\n+      sed -n '8p' ${metrics_file} \\\n+        | awk -F\"\\t\" -v OFS=\"\\t\" '{if (${dollar}1 > 0) {print ${dollar}2/${dollar}1, ${dollar}3/${dollar}1, ${dollar}4/${dollar}1, ${dollar}5/${dollar}1, ${dollar}6/${dollar}1, ${dollar}7/${dollar}1, ${dollar}8/${dollar}1, ${dollar}9/${dollar}1, ${dollar}0/${dollar}1, ${dollar}11/${dollar}1} else {print 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}}'\n+    fi > metrics.txt\n+\n+    cut -f1 metrics.txt > frac_after_prealigned_filter.txt\n+    cut -f2 metrics.txt> frac_after_qual_cpx_filter.txt\n+    cut -f3 metrics.txt > frac_after_host_filter.txt\n+    cut -f4 metrics.txt > frac_after_dedup.txt\n+    cut -f5 metrics.txt > frac_final_paired.txt\n+    cut -f6 metrics.txt > frac_final_unpaired.txt\n+    cut -f7 metrics.txt > frac_final_total.txt\n+    cut -f8 metrics.txt > frac_qual_cpx_filtered.txt\n+    cut -f9 metrics.txt > frac_host_filtered.txt\n+    cut -f10 metrics.txt > frac_dup_filtered.txt\n+  >>>\n+  output {\n+    File metrics_file_out = metrics_file\n+    Float frac_after_prealigned_filter = read_float(\"frac_after_prealigned_filter.txt\")\n+    Float frac_after_qual_cpx_filter = read_float(\"frac_after_qual_cpx_filter.txt\")\n+    Float frac_after_host_filter = read_float(\"frac_after_host_filter.txt\")\n+    Float frac_after_dedup = read_float(\"frac_after_dedup.txt\")\n+    Float frac_final_paired = read_float(\"frac_final_paired.txt\")\n+    Float frac_final_unpaired = read_float(\"frac_final_unpaired.txt\")\n+    Float frac_final_total = read_float(\"frac_final_total.txt\")\n+    Float frac_qual_cpx_filtered = read_float(\"frac_qual_cpx_filtered.txt\")\n+    Float frac_host_filtered = read_float(\"frac_host_filtered.txt\")\n+    Float frac_dup_filtered = read_float(\"frac_dup_filtered.txt\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d0c8174e86870f21669206f4b6a6f4954794c8a9"}, "originalPosition": 815}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY3MzMyNzM2OnYy", "diffSide": "RIGHT", "path": "scripts/pathseq/wdl/pathseq_pipeline_template.json", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMlQxMzoyNToxMVrOGZW9HA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOFQxOTowMToyMFrOGcCjnQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTI0MzY3Ng==", "bodyText": "Can you pin this version please?  The provenance is easier to figure out if the docker is fixed in the input json.", "url": "https://github.com/broadinstitute/gatk/pull/6536#discussion_r429243676", "createdAt": "2020-05-22T13:25:11Z", "author": {"login": "ldgauthier"}, "path": "scripts/pathseq/wdl/pathseq_pipeline_template.json", "diffHunk": "@@ -1,19 +1,22 @@\n {\n-  \"PathSeqPipelineWorkflow.sample_name\": \"sample\",\n-  \"PathSeqPipelineWorkflow.input_bam\": \"gs://my-bucket/sample.bam\",\n+  \"PathSeqPipeline.sample_name\": \"NA12878_24RG_med.hg380.7chicken0.3\",\n+  \"PathSeqPipeline.input_bam_or_cram\": \"gs://gatk-best-practices/pathseq/contaminated-bam/NA12878_24RG_med.hg380.7chicken0.3.bam\",\n+  \"PathSeqPipeline.input_bam_or_cram_index\": \"gs://gatk-best-practices/pathseq/contaminated-bam/NA12878_24RG_med.hg380.7chicken0.3.bam.bai\",\n+  \"PathSeqPipeline.downsample\": false,\n+  \"PathSeqPipeline.gather_filter_metrics\": true,\n+  \"PathSeqPipeline.PathSeqFilter.is_host_aligned\": false,\n \n-  \"PathSeqPipelineWorkflow.is_host_aligned\": false,\n-  \"PathSeqPipelineWorkflow.min_clipped_read_length\": 60,\n-  \"PathSeqPipelineWorkflow.filter_duplicates\": true,\n-  \"PathSeqPipelineWorkflow.min_score_identity\": 0.90,\n-  \"PathSeqPipelineWorkflow.identity_margin\": 0.02,\n-  \"PathSeqPipelineWorkflow.divide_by_genome_length\": true,\n+  \"PathSeqPipeline.PathSeqFilter.min_clipped_read_length\": 60,\n+  \"PathSeqPipeline.PathSeqFilter.filter_duplicates\": true,\n+  \"PathSeqPipeline.PathSeqScore.min_score_identity\": 0.90,\n+  \"PathSeqPipeline.PathSeqScore.identity_margin\": 0.02,\n+  \"PathSeqPipeline.PathSeqScore.divide_by_genome_length\": true,\n \n-  \"PathSeqPipelineWorkflow.filter_bwa_image\": \"gs://my-bucket/references/pathseq_host.fa.img\",\n-  \"PathSeqPipelineWorkflow.kmer_file\": \"gs://my-bucket/references/pathseq_host.bfi\",\n-  \"PathSeqPipelineWorkflow.microbe_bwa_image\": \"gs://my-bucket/references/pathseq_microbe.fa.img\",\n-  \"PathSeqPipelineWorkflow.microbe_fasta\": \"gs://my-bucket/references/pathseq_microbe.fa\",\n-  \"PathSeqPipelineWorkflow.microbe_fasta_dict\": \"gs://my-bucket/references/pathseq_microbe.dict\",\n-  \"PathSeqPipelineWorkflow.taxonomy_file\": \"gs://my-bucket/references/pathseq_taxonomy.db\",\n-  \"PathSeqPipelineWorkflow.gatk_docker\": \"broadinstitute/gatk:4.0.0.0\"\n+  \"PathSeqPipeline.PathSeqFilter.kmer_file\": \"gs://gatk-best-practices/pathseq/resources/pathseq_host.bfi\",\n+  \"PathSeqPipeline.PathSeqAlign.microbe_bwa_image\": \"gs://gatk-best-practices/pathseq/resources/meats.fa.img\",\n+  \"PathSeqPipeline.PathSeqAlign.microbe_dict\": \"gs://gatk-best-practices/pathseq/resources/meats.dict\",\n+  \"PathSeqPipeline.PathSeqFilter.filter_bwa_image\": \"gs://gatk-best-practices/pathseq/resources/pathseq_host.fa.img\",\n+  \"PathSeqPipeline.PathSeqScore.taxonomy_file\": \"gs://gatk-best-practices/pathseq/resources/meats.min2k.db\",\n+\n+  \"PathSeqPipeline.gatk_docker\": \"broadinstitute/gatk:latest\"", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3ea26906623750cbd006cdc8e754b2688add8902"}, "originalPosition": 36}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjA1NTE5Nw==", "bodyText": "Done", "url": "https://github.com/broadinstitute/gatk/pull/6536#discussion_r432055197", "createdAt": "2020-05-28T19:01:20Z", "author": {"login": "mwalker174"}, "path": "scripts/pathseq/wdl/pathseq_pipeline_template.json", "diffHunk": "@@ -1,19 +1,22 @@\n {\n-  \"PathSeqPipelineWorkflow.sample_name\": \"sample\",\n-  \"PathSeqPipelineWorkflow.input_bam\": \"gs://my-bucket/sample.bam\",\n+  \"PathSeqPipeline.sample_name\": \"NA12878_24RG_med.hg380.7chicken0.3\",\n+  \"PathSeqPipeline.input_bam_or_cram\": \"gs://gatk-best-practices/pathseq/contaminated-bam/NA12878_24RG_med.hg380.7chicken0.3.bam\",\n+  \"PathSeqPipeline.input_bam_or_cram_index\": \"gs://gatk-best-practices/pathseq/contaminated-bam/NA12878_24RG_med.hg380.7chicken0.3.bam.bai\",\n+  \"PathSeqPipeline.downsample\": false,\n+  \"PathSeqPipeline.gather_filter_metrics\": true,\n+  \"PathSeqPipeline.PathSeqFilter.is_host_aligned\": false,\n \n-  \"PathSeqPipelineWorkflow.is_host_aligned\": false,\n-  \"PathSeqPipelineWorkflow.min_clipped_read_length\": 60,\n-  \"PathSeqPipelineWorkflow.filter_duplicates\": true,\n-  \"PathSeqPipelineWorkflow.min_score_identity\": 0.90,\n-  \"PathSeqPipelineWorkflow.identity_margin\": 0.02,\n-  \"PathSeqPipelineWorkflow.divide_by_genome_length\": true,\n+  \"PathSeqPipeline.PathSeqFilter.min_clipped_read_length\": 60,\n+  \"PathSeqPipeline.PathSeqFilter.filter_duplicates\": true,\n+  \"PathSeqPipeline.PathSeqScore.min_score_identity\": 0.90,\n+  \"PathSeqPipeline.PathSeqScore.identity_margin\": 0.02,\n+  \"PathSeqPipeline.PathSeqScore.divide_by_genome_length\": true,\n \n-  \"PathSeqPipelineWorkflow.filter_bwa_image\": \"gs://my-bucket/references/pathseq_host.fa.img\",\n-  \"PathSeqPipelineWorkflow.kmer_file\": \"gs://my-bucket/references/pathseq_host.bfi\",\n-  \"PathSeqPipelineWorkflow.microbe_bwa_image\": \"gs://my-bucket/references/pathseq_microbe.fa.img\",\n-  \"PathSeqPipelineWorkflow.microbe_fasta\": \"gs://my-bucket/references/pathseq_microbe.fa\",\n-  \"PathSeqPipelineWorkflow.microbe_fasta_dict\": \"gs://my-bucket/references/pathseq_microbe.dict\",\n-  \"PathSeqPipelineWorkflow.taxonomy_file\": \"gs://my-bucket/references/pathseq_taxonomy.db\",\n-  \"PathSeqPipelineWorkflow.gatk_docker\": \"broadinstitute/gatk:4.0.0.0\"\n+  \"PathSeqPipeline.PathSeqFilter.kmer_file\": \"gs://gatk-best-practices/pathseq/resources/pathseq_host.bfi\",\n+  \"PathSeqPipeline.PathSeqAlign.microbe_bwa_image\": \"gs://gatk-best-practices/pathseq/resources/meats.fa.img\",\n+  \"PathSeqPipeline.PathSeqAlign.microbe_dict\": \"gs://gatk-best-practices/pathseq/resources/meats.dict\",\n+  \"PathSeqPipeline.PathSeqFilter.filter_bwa_image\": \"gs://gatk-best-practices/pathseq/resources/pathseq_host.fa.img\",\n+  \"PathSeqPipeline.PathSeqScore.taxonomy_file\": \"gs://gatk-best-practices/pathseq/resources/meats.min2k.db\",\n+\n+  \"PathSeqPipeline.gatk_docker\": \"broadinstitute/gatk:latest\"", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTI0MzY3Ng=="}, "originalCommit": {"oid": "3ea26906623750cbd006cdc8e754b2688add8902"}, "originalPosition": 36}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY3MzMzNzcyOnYy", "diffSide": "RIGHT", "path": "scripts/pathseq/wdl/README.md", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMlQxMzoyODoxOVrOGZXDdA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOFQxOTowMToxMlrOGcCjUw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTI0NTMwMA==", "bodyText": "That broad link is giving me a 404.  Maybe just take it out?", "url": "https://github.com/broadinstitute/gatk/pull/6536#discussion_r429245300", "createdAt": "2020-05-22T13:28:19Z", "author": {"login": "ldgauthier"}, "path": "scripts/pathseq/wdl/README.md", "diffHunk": "@@ -3,43 +3,44 @@\n ### Setting up parameter json file for a run\n \n To get started, *copy* the ``pathseq_pipeline_template.json`` for the workflow and modify the parameters accordingly.\n-DO NOT commit your json file to this repo. This file has reasonable default parameters.\n+DO NOT commit your json file to this repo.\n \n-PathSeq reference files are available in the [GATK Resource Bundle](https://software.broadinstitute.org/gatk/download/bundle) (located [here](ftp://gsapubftp-anonymous@ftp.broadinstitute.org/bundle/beta/PathSeq)).\n+PathSeq reference files are available in the [GATK Resource Bundle](https://software.broadinstitute.org/gatk/download/bundle) at `gs://gatk-best-practices/pathseq`.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3ea26906623750cbd006cdc8e754b2688add8902"}, "originalPosition": 8}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjA1NTEyMw==", "bodyText": "Looks like they moved it to https://gatk.broadinstitute.org/hc/en-us/articles/360035890811-Resource-bundle", "url": "https://github.com/broadinstitute/gatk/pull/6536#discussion_r432055123", "createdAt": "2020-05-28T19:01:12Z", "author": {"login": "mwalker174"}, "path": "scripts/pathseq/wdl/README.md", "diffHunk": "@@ -3,43 +3,44 @@\n ### Setting up parameter json file for a run\n \n To get started, *copy* the ``pathseq_pipeline_template.json`` for the workflow and modify the parameters accordingly.\n-DO NOT commit your json file to this repo. This file has reasonable default parameters.\n+DO NOT commit your json file to this repo.\n \n-PathSeq reference files are available in the [GATK Resource Bundle](https://software.broadinstitute.org/gatk/download/bundle) (located [here](ftp://gsapubftp-anonymous@ftp.broadinstitute.org/bundle/beta/PathSeq)).\n+PathSeq reference files are available in the [GATK Resource Bundle](https://software.broadinstitute.org/gatk/download/bundle) at `gs://gatk-best-practices/pathseq`.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTI0NTMwMA=="}, "originalCommit": {"oid": "3ea26906623750cbd006cdc8e754b2688add8902"}, "originalPosition": 8}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1164, "cost": 1, "resetAt": "2021-11-12T13:16:51Z"}}}