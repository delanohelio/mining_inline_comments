{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTIwOTI1MDg2", "number": 6959, "reviewThreads": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOVQyMjowNzo0NFrOE7Q6jQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOVQyMjoxMToyOVrOE7Q_WA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMwNTc4NTczOnYy", "diffSide": "RIGHT", "path": "src/main/java/org/broadinstitute/hellbender/utils/variant/writers/ShardingVCFWriter.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOVQyMjowNzo0NFrOH2z2Mw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yMFQwNDoxODo0MlrOH288yQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzIzNDYxMQ==", "bodyText": "I know we can't predict how many shards there will be, but it would be nice to zero pad this to four digits so the shards (almost) always sort nicely.", "url": "https://github.com/broadinstitute/gatk/pull/6959#discussion_r527234611", "createdAt": "2020-11-19T22:07:44Z", "author": {"login": "ldgauthier"}, "path": "src/main/java/org/broadinstitute/hellbender/utils/variant/writers/ShardingVCFWriter.java", "diffHunk": "@@ -0,0 +1,161 @@\n+package org.broadinstitute.hellbender.utils.variant.writers;\n+\n+import htsjdk.samtools.SAMSequenceDictionary;\n+import htsjdk.samtools.util.FileExtensions;\n+import htsjdk.variant.variantcontext.VariantContext;\n+import htsjdk.variant.variantcontext.writer.Options;\n+import htsjdk.variant.variantcontext.writer.VariantContextWriter;\n+import htsjdk.variant.vcf.VCFHeader;\n+import org.broadinstitute.hellbender.utils.Utils;\n+import org.broadinstitute.hellbender.utils.io.IOUtils;\n+import org.broadinstitute.hellbender.utils.variant.GATKVariantContextUtils;\n+\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+\n+/**\n+ * Variant writer tha splits output to multiple VCFs given the maximum records per file. Before using {@link #add},\n+ * the header should be set using either {@link #setHeader} or {@link #writeHeader}, which may only be called once\n+ * and will determine whether headers are written to all shards.\n+ *\n+ * @author Mark Walker &lt;markw@broadinstitute.org&gt;\n+ */\n+public class ShardingVCFWriter implements VariantContextWriter {\n+\n+    public static final String SHARD_INDEX_PREFIX = \".shard_\";\n+    public static final String SHARD_INDEX_SUFFIX = FileExtensions.COMPRESSED_VCF;\n+\n+    private VariantContextWriter writer;\n+    private VCFHeader header;\n+    private final int maxVariantsPerShard;\n+    private final Path basePath;\n+    private final SAMSequenceDictionary dictionary;\n+    private final boolean createMD5;\n+    private final Options[] options;\n+\n+    /** Current shard  */\n+    private int shardIndex;\n+    /** Number of records written to current shard  */\n+    private int shardSize;\n+     /** Whether to write header, or null if header is undefined */\n+    private Boolean enableWriteHeader;\n+\n+    /**\n+     * Create a new sharding VCF writer\n+     *\n+     * @param basePath              base path of the output VCFs. The shard designation and file extension will be added.\n+     * @param maxVariantsPerShard   max number of records per file (last shard may have less)\n+     * @param dictionary            sequence dictionary for this writer\n+     * @param createMD5             enable MD5 file creation\n+     * @param options               vcf writer options\n+     */\n+    public ShardingVCFWriter(final Path basePath,\n+                             final int maxVariantsPerShard,\n+                             final SAMSequenceDictionary dictionary,\n+                             final boolean createMD5,\n+                             final Options... options) {\n+        Utils.nonNull(basePath);\n+        Utils.validateArg(maxVariantsPerShard > 0, \"maxVariantsPerShard must be positive\");\n+        this.basePath = IOUtils.removeExtension(basePath, FileExtensions.VCF_LIST);\n+        this.maxVariantsPerShard = maxVariantsPerShard;\n+        this.dictionary = dictionary;\n+        this.createMD5 = createMD5;\n+        this.options = options;\n+\n+        // Initialize first shard\n+        this.shardIndex = 0;\n+        this.shardSize = 0;\n+        this.writer = createNewWriter();\n+    }\n+\n+    /**\n+     * Initializes a new sharded file.\n+     */\n+    protected void createNextShard() {\n+        writer.close();\n+        shardIndex++;\n+        shardSize = 0;\n+        writer = createNewWriter();\n+        Utils.nonNull(header, \"Attempted to create new shard before header has been set\");\n+        initializeShardHeader();\n+    }\n+\n+    /**\n+     * Initializes shard header depending on which header function (set or write) was used\n+     */\n+    protected void initializeShardHeader() {\n+        if (enableWriteHeader != null) {\n+            if (enableWriteHeader.booleanValue()) {\n+                writer.writeHeader(header);\n+            } else {\n+                writer.setHeader(header);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Creates a writer for a new shard\n+     *\n+     * @return the new writer\n+     */\n+    protected VariantContextWriter createNewWriter() {\n+        final Path outPath = Paths.get(basePath + SHARD_INDEX_PREFIX + shardIndex + SHARD_INDEX_SUFFIX);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e0c1a8074bdaf303efff53efe28345db6b55a214"}, "originalPosition": 102}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzM4Mzc1Mw==", "bodyText": "Done (went to 5 zeros)", "url": "https://github.com/broadinstitute/gatk/pull/6959#discussion_r527383753", "createdAt": "2020-11-20T04:18:42Z", "author": {"login": "mwalker174"}, "path": "src/main/java/org/broadinstitute/hellbender/utils/variant/writers/ShardingVCFWriter.java", "diffHunk": "@@ -0,0 +1,161 @@\n+package org.broadinstitute.hellbender.utils.variant.writers;\n+\n+import htsjdk.samtools.SAMSequenceDictionary;\n+import htsjdk.samtools.util.FileExtensions;\n+import htsjdk.variant.variantcontext.VariantContext;\n+import htsjdk.variant.variantcontext.writer.Options;\n+import htsjdk.variant.variantcontext.writer.VariantContextWriter;\n+import htsjdk.variant.vcf.VCFHeader;\n+import org.broadinstitute.hellbender.utils.Utils;\n+import org.broadinstitute.hellbender.utils.io.IOUtils;\n+import org.broadinstitute.hellbender.utils.variant.GATKVariantContextUtils;\n+\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+\n+/**\n+ * Variant writer tha splits output to multiple VCFs given the maximum records per file. Before using {@link #add},\n+ * the header should be set using either {@link #setHeader} or {@link #writeHeader}, which may only be called once\n+ * and will determine whether headers are written to all shards.\n+ *\n+ * @author Mark Walker &lt;markw@broadinstitute.org&gt;\n+ */\n+public class ShardingVCFWriter implements VariantContextWriter {\n+\n+    public static final String SHARD_INDEX_PREFIX = \".shard_\";\n+    public static final String SHARD_INDEX_SUFFIX = FileExtensions.COMPRESSED_VCF;\n+\n+    private VariantContextWriter writer;\n+    private VCFHeader header;\n+    private final int maxVariantsPerShard;\n+    private final Path basePath;\n+    private final SAMSequenceDictionary dictionary;\n+    private final boolean createMD5;\n+    private final Options[] options;\n+\n+    /** Current shard  */\n+    private int shardIndex;\n+    /** Number of records written to current shard  */\n+    private int shardSize;\n+     /** Whether to write header, or null if header is undefined */\n+    private Boolean enableWriteHeader;\n+\n+    /**\n+     * Create a new sharding VCF writer\n+     *\n+     * @param basePath              base path of the output VCFs. The shard designation and file extension will be added.\n+     * @param maxVariantsPerShard   max number of records per file (last shard may have less)\n+     * @param dictionary            sequence dictionary for this writer\n+     * @param createMD5             enable MD5 file creation\n+     * @param options               vcf writer options\n+     */\n+    public ShardingVCFWriter(final Path basePath,\n+                             final int maxVariantsPerShard,\n+                             final SAMSequenceDictionary dictionary,\n+                             final boolean createMD5,\n+                             final Options... options) {\n+        Utils.nonNull(basePath);\n+        Utils.validateArg(maxVariantsPerShard > 0, \"maxVariantsPerShard must be positive\");\n+        this.basePath = IOUtils.removeExtension(basePath, FileExtensions.VCF_LIST);\n+        this.maxVariantsPerShard = maxVariantsPerShard;\n+        this.dictionary = dictionary;\n+        this.createMD5 = createMD5;\n+        this.options = options;\n+\n+        // Initialize first shard\n+        this.shardIndex = 0;\n+        this.shardSize = 0;\n+        this.writer = createNewWriter();\n+    }\n+\n+    /**\n+     * Initializes a new sharded file.\n+     */\n+    protected void createNextShard() {\n+        writer.close();\n+        shardIndex++;\n+        shardSize = 0;\n+        writer = createNewWriter();\n+        Utils.nonNull(header, \"Attempted to create new shard before header has been set\");\n+        initializeShardHeader();\n+    }\n+\n+    /**\n+     * Initializes shard header depending on which header function (set or write) was used\n+     */\n+    protected void initializeShardHeader() {\n+        if (enableWriteHeader != null) {\n+            if (enableWriteHeader.booleanValue()) {\n+                writer.writeHeader(header);\n+            } else {\n+                writer.setHeader(header);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Creates a writer for a new shard\n+     *\n+     * @return the new writer\n+     */\n+    protected VariantContextWriter createNewWriter() {\n+        final Path outPath = Paths.get(basePath + SHARD_INDEX_PREFIX + shardIndex + SHARD_INDEX_SUFFIX);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzIzNDYxMQ=="}, "originalCommit": {"oid": "e0c1a8074bdaf303efff53efe28345db6b55a214"}, "originalPosition": 102}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMwNTc5MzY3OnYy", "diffSide": "RIGHT", "path": "src/main/java/org/broadinstitute/hellbender/utils/variant/writers/ShardingVCFWriter.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOVQyMjoxMDowNlrOH2z61Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yMFQwMzo0NjoyOFrOH28bpw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzIzNTc5Nw==", "bodyText": "Is this going to index as well?", "url": "https://github.com/broadinstitute/gatk/pull/6959#discussion_r527235797", "createdAt": "2020-11-19T22:10:06Z", "author": {"login": "ldgauthier"}, "path": "src/main/java/org/broadinstitute/hellbender/utils/variant/writers/ShardingVCFWriter.java", "diffHunk": "@@ -0,0 +1,161 @@\n+package org.broadinstitute.hellbender.utils.variant.writers;\n+\n+import htsjdk.samtools.SAMSequenceDictionary;\n+import htsjdk.samtools.util.FileExtensions;\n+import htsjdk.variant.variantcontext.VariantContext;\n+import htsjdk.variant.variantcontext.writer.Options;\n+import htsjdk.variant.variantcontext.writer.VariantContextWriter;\n+import htsjdk.variant.vcf.VCFHeader;\n+import org.broadinstitute.hellbender.utils.Utils;\n+import org.broadinstitute.hellbender.utils.io.IOUtils;\n+import org.broadinstitute.hellbender.utils.variant.GATKVariantContextUtils;\n+\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+\n+/**\n+ * Variant writer tha splits output to multiple VCFs given the maximum records per file. Before using {@link #add},\n+ * the header should be set using either {@link #setHeader} or {@link #writeHeader}, which may only be called once\n+ * and will determine whether headers are written to all shards.\n+ *\n+ * @author Mark Walker &lt;markw@broadinstitute.org&gt;\n+ */\n+public class ShardingVCFWriter implements VariantContextWriter {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e0c1a8074bdaf303efff53efe28345db6b55a214"}, "originalPosition": 23}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzM3NTI3MQ==", "bodyText": "Yes, that is specified through the options parameter", "url": "https://github.com/broadinstitute/gatk/pull/6959#discussion_r527375271", "createdAt": "2020-11-20T03:46:28Z", "author": {"login": "mwalker174"}, "path": "src/main/java/org/broadinstitute/hellbender/utils/variant/writers/ShardingVCFWriter.java", "diffHunk": "@@ -0,0 +1,161 @@\n+package org.broadinstitute.hellbender.utils.variant.writers;\n+\n+import htsjdk.samtools.SAMSequenceDictionary;\n+import htsjdk.samtools.util.FileExtensions;\n+import htsjdk.variant.variantcontext.VariantContext;\n+import htsjdk.variant.variantcontext.writer.Options;\n+import htsjdk.variant.variantcontext.writer.VariantContextWriter;\n+import htsjdk.variant.vcf.VCFHeader;\n+import org.broadinstitute.hellbender.utils.Utils;\n+import org.broadinstitute.hellbender.utils.io.IOUtils;\n+import org.broadinstitute.hellbender.utils.variant.GATKVariantContextUtils;\n+\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+\n+/**\n+ * Variant writer tha splits output to multiple VCFs given the maximum records per file. Before using {@link #add},\n+ * the header should be set using either {@link #setHeader} or {@link #writeHeader}, which may only be called once\n+ * and will determine whether headers are written to all shards.\n+ *\n+ * @author Mark Walker &lt;markw@broadinstitute.org&gt;\n+ */\n+public class ShardingVCFWriter implements VariantContextWriter {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzIzNTc5Nw=="}, "originalCommit": {"oid": "e0c1a8074bdaf303efff53efe28345db6b55a214"}, "originalPosition": 23}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMwNTc5NjU5OnYy", "diffSide": "RIGHT", "path": "src/test/java/org/broadinstitute/hellbender/engine/GatkToolIntegrationTest.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOVQyMjoxMTowNFrOH2z8wQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yMFQwNDoyNDoyOFrOH29Jww==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzIzNjI4OQ==", "bodyText": "11 doesn't jive with the 10 and 2 below", "url": "https://github.com/broadinstitute/gatk/pull/6959#discussion_r527236289", "createdAt": "2020-11-19T22:11:04Z", "author": {"login": "ldgauthier"}, "path": "src/test/java/org/broadinstitute/hellbender/engine/GatkToolIntegrationTest.java", "diffHunk": "@@ -64,4 +67,25 @@ public void testBrokenReferenceDictionaryErrorMessage() throws IOException {\n \n         runCommandLine(Arrays.asList(args), Mutect2.class.getSimpleName());\n     }\n+\n+    @Test\n+    public void testSharding() {\n+        final String outDir = createTempDir(\"GTShardedOutput\").getAbsolutePath();\n+        final String fileBase = \"test\";\n+        final String out = Paths.get(outDir, fileBase + FileExtensions.COMPRESSED_VCF).toString();\n+        final String[] args = new String[] {\n+                \"-V\",  TEST_DIRECTORY + \"example_variants_withSequenceDict.vcf\",\n+                \"-R\", hg19MiniReference,\n+                \"--\" + StandardArgumentDefinitions.MAX_VARIANTS_PER_SHARD_LONG_NAME, \"10\",\n+                \"-O\", out};\n+        runCommandLine(Arrays.asList(args), SelectVariants.class.getSimpleName());\n+\n+        // 11 total records in the test input should create 2 vcf shards with 10 and 1 records", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e0c1a8074bdaf303efff53efe28345db6b55a214"}, "originalPosition": 44}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzM4NzA3NQ==", "bodyText": "Fixed", "url": "https://github.com/broadinstitute/gatk/pull/6959#discussion_r527387075", "createdAt": "2020-11-20T04:24:28Z", "author": {"login": "mwalker174"}, "path": "src/test/java/org/broadinstitute/hellbender/engine/GatkToolIntegrationTest.java", "diffHunk": "@@ -64,4 +67,25 @@ public void testBrokenReferenceDictionaryErrorMessage() throws IOException {\n \n         runCommandLine(Arrays.asList(args), Mutect2.class.getSimpleName());\n     }\n+\n+    @Test\n+    public void testSharding() {\n+        final String outDir = createTempDir(\"GTShardedOutput\").getAbsolutePath();\n+        final String fileBase = \"test\";\n+        final String out = Paths.get(outDir, fileBase + FileExtensions.COMPRESSED_VCF).toString();\n+        final String[] args = new String[] {\n+                \"-V\",  TEST_DIRECTORY + \"example_variants_withSequenceDict.vcf\",\n+                \"-R\", hg19MiniReference,\n+                \"--\" + StandardArgumentDefinitions.MAX_VARIANTS_PER_SHARD_LONG_NAME, \"10\",\n+                \"-O\", out};\n+        runCommandLine(Arrays.asList(args), SelectVariants.class.getSimpleName());\n+\n+        // 11 total records in the test input should create 2 vcf shards with 10 and 1 records", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzIzNjI4OQ=="}, "originalCommit": {"oid": "e0c1a8074bdaf303efff53efe28345db6b55a214"}, "originalPosition": 44}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMwNTc5ODAwOnYy", "diffSide": "RIGHT", "path": "src/test/java/org/broadinstitute/hellbender/engine/GatkToolIntegrationTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOVQyMjoxMToyOVrOH2z9kw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yMFQwNDozMDoxNFrOH29Yqg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzIzNjQ5OQ==", "bodyText": "Having experienced a lot of pain from lack of indexes, let's check for those too.", "url": "https://github.com/broadinstitute/gatk/pull/6959#discussion_r527236499", "createdAt": "2020-11-19T22:11:29Z", "author": {"login": "ldgauthier"}, "path": "src/test/java/org/broadinstitute/hellbender/engine/GatkToolIntegrationTest.java", "diffHunk": "@@ -64,4 +67,25 @@ public void testBrokenReferenceDictionaryErrorMessage() throws IOException {\n \n         runCommandLine(Arrays.asList(args), Mutect2.class.getSimpleName());\n     }\n+\n+    @Test\n+    public void testSharding() {\n+        final String outDir = createTempDir(\"GTShardedOutput\").getAbsolutePath();\n+        final String fileBase = \"test\";\n+        final String out = Paths.get(outDir, fileBase + FileExtensions.COMPRESSED_VCF).toString();\n+        final String[] args = new String[] {\n+                \"-V\",  TEST_DIRECTORY + \"example_variants_withSequenceDict.vcf\",\n+                \"-R\", hg19MiniReference,\n+                \"--\" + StandardArgumentDefinitions.MAX_VARIANTS_PER_SHARD_LONG_NAME, \"10\",\n+                \"-O\", out};\n+        runCommandLine(Arrays.asList(args), SelectVariants.class.getSimpleName());\n+\n+        // 11 total records in the test input should create 2 vcf shards with 10 and 1 records\n+        final String firstShard = Paths.get(outDir, fileBase + ShardingVCFWriter.SHARD_INDEX_PREFIX + \"0\" + ShardingVCFWriter.SHARD_INDEX_SUFFIX).toString();\n+        final String secondShard = Paths.get(outDir, fileBase + ShardingVCFWriter.SHARD_INDEX_PREFIX + \"1\" + ShardingVCFWriter.SHARD_INDEX_SUFFIX).toString();\n+        final Pair<VCFHeader, List<VariantContext>> firstResults = VariantContextTestUtils.readEntireVCFIntoMemory(firstShard);\n+        final Pair<VCFHeader, List<VariantContext>> secondResults = VariantContextTestUtils.readEntireVCFIntoMemory(secondShard);\n+        Assert.assertEquals(firstResults.getValue().size(), 10, \"First shard has wrong number of records\");\n+        Assert.assertEquals(secondResults.getValue().size(), 2, \"Second shard has wrong number of records\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e0c1a8074bdaf303efff53efe28345db6b55a214"}, "originalPosition": 50}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzM5MDg5MA==", "bodyText": "Done", "url": "https://github.com/broadinstitute/gatk/pull/6959#discussion_r527390890", "createdAt": "2020-11-20T04:30:14Z", "author": {"login": "mwalker174"}, "path": "src/test/java/org/broadinstitute/hellbender/engine/GatkToolIntegrationTest.java", "diffHunk": "@@ -64,4 +67,25 @@ public void testBrokenReferenceDictionaryErrorMessage() throws IOException {\n \n         runCommandLine(Arrays.asList(args), Mutect2.class.getSimpleName());\n     }\n+\n+    @Test\n+    public void testSharding() {\n+        final String outDir = createTempDir(\"GTShardedOutput\").getAbsolutePath();\n+        final String fileBase = \"test\";\n+        final String out = Paths.get(outDir, fileBase + FileExtensions.COMPRESSED_VCF).toString();\n+        final String[] args = new String[] {\n+                \"-V\",  TEST_DIRECTORY + \"example_variants_withSequenceDict.vcf\",\n+                \"-R\", hg19MiniReference,\n+                \"--\" + StandardArgumentDefinitions.MAX_VARIANTS_PER_SHARD_LONG_NAME, \"10\",\n+                \"-O\", out};\n+        runCommandLine(Arrays.asList(args), SelectVariants.class.getSimpleName());\n+\n+        // 11 total records in the test input should create 2 vcf shards with 10 and 1 records\n+        final String firstShard = Paths.get(outDir, fileBase + ShardingVCFWriter.SHARD_INDEX_PREFIX + \"0\" + ShardingVCFWriter.SHARD_INDEX_SUFFIX).toString();\n+        final String secondShard = Paths.get(outDir, fileBase + ShardingVCFWriter.SHARD_INDEX_PREFIX + \"1\" + ShardingVCFWriter.SHARD_INDEX_SUFFIX).toString();\n+        final Pair<VCFHeader, List<VariantContext>> firstResults = VariantContextTestUtils.readEntireVCFIntoMemory(firstShard);\n+        final Pair<VCFHeader, List<VariantContext>> secondResults = VariantContextTestUtils.readEntireVCFIntoMemory(secondShard);\n+        Assert.assertEquals(firstResults.getValue().size(), 10, \"First shard has wrong number of records\");\n+        Assert.assertEquals(secondResults.getValue().size(), 2, \"Second shard has wrong number of records\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzIzNjQ5OQ=="}, "originalCommit": {"oid": "e0c1a8074bdaf303efff53efe28345db6b55a214"}, "originalPosition": 50}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 855, "cost": 1, "resetAt": "2021-11-12T13:16:51Z"}}}