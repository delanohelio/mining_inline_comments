{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDA2OTIwNTU5", "number": 6561, "reviewThreads": {"totalCount": 24, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNlQxOToxOTowOFrOD59dHA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMFQyMTowNToyNFrOD-ZB7g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYyMTAyMzAwOnYy", "diffSide": "RIGHT", "path": "src/main/java/org/broadinstitute/hellbender/cmdline/argumentcollections/ReadInputArgumentCollection.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNlQxOToxOTowOFrOGRh1Iw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOFQyMDoyMjoxMFrOGXGPNA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTAzMzI1MQ==", "bodyText": "This mention of Paths being the preferred form is no longer true with this PR.", "url": "https://github.com/broadinstitute/gatk/pull/6561#discussion_r421033251", "createdAt": "2020-05-06T19:19:08Z", "author": {"login": "lbergelson"}, "path": "src/main/java/org/broadinstitute/hellbender/cmdline/argumentcollections/ReadInputArgumentCollection.java", "diffHunk": "@@ -30,18 +31,27 @@\n     protected ValidationStringency readValidationStringency = ReadConstants.DEFAULT_READ_VALIDATION_STRINGENCY;\n \n     @Argument(fullName = StandardArgumentDefinitions.READ_INDEX_LONG_NAME, shortName = StandardArgumentDefinitions.READ_INDEX_SHORT_NAME,\n-              doc = \"Indices to use for the read inputs. If specified, an index must be provided for every read input \" +\n+            doc = \"Indices to use for the read inputs. If specified, an index must be provided for every read input \" +\n                     \"and in the same order as the read inputs. If this argument is not specified, the path to the index \" +\n                     \"for each input will be inferred automatically.\",\n-              common = true,\n-              optional = true)\n-    protected List<String> readIndices;\n+            common = true,\n+            optional = true)\n+    protected List<GATKPathSpecifier> readIndices;\n \n     /**\n      * Get the list of BAM/SAM/CRAM files specified at the command line.\n      * Paths are the preferred format, as this can handle both local disk and NIO direct access to cloud storage.\n      */\n-    public abstract List<Path> getReadPaths();\n+    public abstract List<GATKPathSpecifier> getReadPathSpecifiers();\n+\n+    /**\n+     * Get the list of BAM/SAM/CRAM files specified at the command line.\n+     * Paths are the preferred format, as this can handle both local disk and NIO direct access to cloud storage.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "921e051ca633b9282340864620806d950532c8c7"}, "originalPosition": 32}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjg3MjYyOA==", "bodyText": "Fixed.", "url": "https://github.com/broadinstitute/gatk/pull/6561#discussion_r426872628", "createdAt": "2020-05-18T20:22:10Z", "author": {"login": "cmnbroad"}, "path": "src/main/java/org/broadinstitute/hellbender/cmdline/argumentcollections/ReadInputArgumentCollection.java", "diffHunk": "@@ -30,18 +31,27 @@\n     protected ValidationStringency readValidationStringency = ReadConstants.DEFAULT_READ_VALIDATION_STRINGENCY;\n \n     @Argument(fullName = StandardArgumentDefinitions.READ_INDEX_LONG_NAME, shortName = StandardArgumentDefinitions.READ_INDEX_SHORT_NAME,\n-              doc = \"Indices to use for the read inputs. If specified, an index must be provided for every read input \" +\n+            doc = \"Indices to use for the read inputs. If specified, an index must be provided for every read input \" +\n                     \"and in the same order as the read inputs. If this argument is not specified, the path to the index \" +\n                     \"for each input will be inferred automatically.\",\n-              common = true,\n-              optional = true)\n-    protected List<String> readIndices;\n+            common = true,\n+            optional = true)\n+    protected List<GATKPathSpecifier> readIndices;\n \n     /**\n      * Get the list of BAM/SAM/CRAM files specified at the command line.\n      * Paths are the preferred format, as this can handle both local disk and NIO direct access to cloud storage.\n      */\n-    public abstract List<Path> getReadPaths();\n+    public abstract List<GATKPathSpecifier> getReadPathSpecifiers();\n+\n+    /**\n+     * Get the list of BAM/SAM/CRAM files specified at the command line.\n+     * Paths are the preferred format, as this can handle both local disk and NIO direct access to cloud storage.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTAzMzI1MQ=="}, "originalCommit": {"oid": "921e051ca633b9282340864620806d950532c8c7"}, "originalPosition": 32}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYyMTAyNDI2OnYy", "diffSide": "RIGHT", "path": "src/main/java/org/broadinstitute/hellbender/cmdline/argumentcollections/ReadInputArgumentCollection.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNlQxOToxOTozMlrOGRh18Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOFQyMDoyMjoxOFrOGXGPeA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTAzMzQ1Nw==", "bodyText": "The comment about Paths isn't accurate anymore.", "url": "https://github.com/broadinstitute/gatk/pull/6561#discussion_r421033457", "createdAt": "2020-05-06T19:19:32Z", "author": {"login": "lbergelson"}, "path": "src/main/java/org/broadinstitute/hellbender/cmdline/argumentcollections/ReadInputArgumentCollection.java", "diffHunk": "@@ -30,18 +31,27 @@\n     protected ValidationStringency readValidationStringency = ReadConstants.DEFAULT_READ_VALIDATION_STRINGENCY;\n \n     @Argument(fullName = StandardArgumentDefinitions.READ_INDEX_LONG_NAME, shortName = StandardArgumentDefinitions.READ_INDEX_SHORT_NAME,\n-              doc = \"Indices to use for the read inputs. If specified, an index must be provided for every read input \" +\n+            doc = \"Indices to use for the read inputs. If specified, an index must be provided for every read input \" +\n                     \"and in the same order as the read inputs. If this argument is not specified, the path to the index \" +\n                     \"for each input will be inferred automatically.\",\n-              common = true,\n-              optional = true)\n-    protected List<String> readIndices;\n+            common = true,\n+            optional = true)\n+    protected List<GATKPathSpecifier> readIndices;\n \n     /**\n      * Get the list of BAM/SAM/CRAM files specified at the command line.\n      * Paths are the preferred format, as this can handle both local disk and NIO direct access to cloud storage.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "921e051ca633b9282340864620806d950532c8c7"}, "originalPosition": 25}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjg3MjY5Ng==", "bodyText": "Fixed.", "url": "https://github.com/broadinstitute/gatk/pull/6561#discussion_r426872696", "createdAt": "2020-05-18T20:22:18Z", "author": {"login": "cmnbroad"}, "path": "src/main/java/org/broadinstitute/hellbender/cmdline/argumentcollections/ReadInputArgumentCollection.java", "diffHunk": "@@ -30,18 +31,27 @@\n     protected ValidationStringency readValidationStringency = ReadConstants.DEFAULT_READ_VALIDATION_STRINGENCY;\n \n     @Argument(fullName = StandardArgumentDefinitions.READ_INDEX_LONG_NAME, shortName = StandardArgumentDefinitions.READ_INDEX_SHORT_NAME,\n-              doc = \"Indices to use for the read inputs. If specified, an index must be provided for every read input \" +\n+            doc = \"Indices to use for the read inputs. If specified, an index must be provided for every read input \" +\n                     \"and in the same order as the read inputs. If this argument is not specified, the path to the index \" +\n                     \"for each input will be inferred automatically.\",\n-              common = true,\n-              optional = true)\n-    protected List<String> readIndices;\n+            common = true,\n+            optional = true)\n+    protected List<GATKPathSpecifier> readIndices;\n \n     /**\n      * Get the list of BAM/SAM/CRAM files specified at the command line.\n      * Paths are the preferred format, as this can handle both local disk and NIO direct access to cloud storage.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTAzMzQ1Nw=="}, "originalCommit": {"oid": "921e051ca633b9282340864620806d950532c8c7"}, "originalPosition": 25}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYyMTAyNjMxOnYy", "diffSide": "RIGHT", "path": "src/main/java/org/broadinstitute/hellbender/cmdline/argumentcollections/RequiredReadInputArgumentCollection.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNlQxOToyMDowM1rOGRh3IQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOFQyMDoyMjoyMVrOGXGPmw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTAzMzc2MQ==", "bodyText": "comment is out of date", "url": "https://github.com/broadinstitute/gatk/pull/6561#discussion_r421033761", "createdAt": "2020-05-06T19:20:03Z", "author": {"login": "lbergelson"}, "path": "src/main/java/org/broadinstitute/hellbender/cmdline/argumentcollections/RequiredReadInputArgumentCollection.java", "diffHunk": "@@ -16,28 +17,11 @@\n public final class RequiredReadInputArgumentCollection extends ReadInputArgumentCollection {\n     private static final long serialVersionUID = 1L;\n     @Argument(fullName = StandardArgumentDefinitions.INPUT_LONG_NAME, shortName = StandardArgumentDefinitions.INPUT_SHORT_NAME, doc = \"BAM/SAM/CRAM file containing reads\", optional = false, common = true)\n-    public List<String> readFilesNames;\n+    public List<GATKPathSpecifier> readFilesNames;\n \n-    @Override\n-    public List<File> getReadFiles() {\n-        ArrayList<File> ret = new ArrayList<>();\n-        for (String fn : readFilesNames) {\n-            ret.add(new File(fn));\n-        }\n-        return ret;\n-    }\n-\n-    @Override\n-    public List<Path> getReadPaths() {\n-        ArrayList<Path> ret = new ArrayList<>();\n-        for (String fn : readFilesNames) {\n-            ret.add(IOUtils.getPath(fn));\n-        }\n-        return ret;\n-    }\n-\n-    @Override\n-    public List<String> getReadFilesNames() {\n-        return new ArrayList<>(readFilesNames);\n-    }\n+    /**\n+     * Get the list of BAM/SAM/CRAM files specified at the command line.\n+     * Paths are the preferred format, as this can handle both local disk and NIO direct access to cloud storage.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "921e051ca633b9282340864620806d950532c8c7"}, "originalPosition": 47}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjg3MjczMQ==", "bodyText": "Fixed.", "url": "https://github.com/broadinstitute/gatk/pull/6561#discussion_r426872731", "createdAt": "2020-05-18T20:22:21Z", "author": {"login": "cmnbroad"}, "path": "src/main/java/org/broadinstitute/hellbender/cmdline/argumentcollections/RequiredReadInputArgumentCollection.java", "diffHunk": "@@ -16,28 +17,11 @@\n public final class RequiredReadInputArgumentCollection extends ReadInputArgumentCollection {\n     private static final long serialVersionUID = 1L;\n     @Argument(fullName = StandardArgumentDefinitions.INPUT_LONG_NAME, shortName = StandardArgumentDefinitions.INPUT_SHORT_NAME, doc = \"BAM/SAM/CRAM file containing reads\", optional = false, common = true)\n-    public List<String> readFilesNames;\n+    public List<GATKPathSpecifier> readFilesNames;\n \n-    @Override\n-    public List<File> getReadFiles() {\n-        ArrayList<File> ret = new ArrayList<>();\n-        for (String fn : readFilesNames) {\n-            ret.add(new File(fn));\n-        }\n-        return ret;\n-    }\n-\n-    @Override\n-    public List<Path> getReadPaths() {\n-        ArrayList<Path> ret = new ArrayList<>();\n-        for (String fn : readFilesNames) {\n-            ret.add(IOUtils.getPath(fn));\n-        }\n-        return ret;\n-    }\n-\n-    @Override\n-    public List<String> getReadFilesNames() {\n-        return new ArrayList<>(readFilesNames);\n-    }\n+    /**\n+     * Get the list of BAM/SAM/CRAM files specified at the command line.\n+     * Paths are the preferred format, as this can handle both local disk and NIO direct access to cloud storage.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTAzMzc2MQ=="}, "originalCommit": {"oid": "921e051ca633b9282340864620806d950532c8c7"}, "originalPosition": 47}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYyMTAyODQyOnYy", "diffSide": "RIGHT", "path": "src/main/java/org/broadinstitute/hellbender/engine/GATKTool.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNlQxOToyMDo0M1rOGRh4lQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNlQxOToyMDo0M1rOGRh4lQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTAzNDEzMw==", "bodyText": "Ah, thanks for updating this.", "url": "https://github.com/broadinstitute/gatk/pull/6561#discussion_r421034133", "createdAt": "2020-05-06T19:20:43Z", "author": {"login": "lbergelson"}, "path": "src/main/java/org/broadinstitute/hellbender/engine/GATKTool.java", "diffHunk": "@@ -277,7 +281,7 @@ public CountingReadFilter makeReadFilter(){\n \n     /**\n      * Must be overridden in order to add annotation arguments to the engine. If this is set to true the engine will\n-     * dynamically discover all {@link Annotation}s in the package defined by {@link org.broadinstitute.hellbender.cmdline.GATKPlugin.GATKAnnotationPluginDescriptor#pluginPackageName} and automatically\n+     * dynamically discover all {@link Annotation}s in the packages defined by {@link GATKAnnotationPluginDescriptor#getPackageNames()} and automatically", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "921e051ca633b9282340864620806d950532c8c7"}, "originalPosition": 16}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYyMTA0MTIxOnYy", "diffSide": "RIGHT", "path": "src/main/java/org/broadinstitute/hellbender/engine/spark/GATKSparkTool.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNlQxOToyNDowNVrOGRiAeA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOFQyMDoyMjoyOVrOGXGP2w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTAzNjE1Mg==", "bodyText": "This doesn't deal correctly with http path ending weirdness.  I think we should add a \"getExtension\" or 'getFilename\" method to avoid making this mistake.", "url": "https://github.com/broadinstitute/gatk/pull/6561#discussion_r421036152", "createdAt": "2020-05-06T19:24:05Z", "author": {"login": "lbergelson"}, "path": "src/main/java/org/broadinstitute/hellbender/engine/spark/GATKSparkTool.java", "diffHunk": "@@ -323,31 +323,31 @@ public SAMFileHeader getHeaderForReads() {\n \n         JavaRDD<GATKRead> output = null;\n         ReadsSparkSource source = readsSource;\n-        for (String input : readInputs.keySet()) {\n+        for (final GATKPathSpecifier inputPathSpecifier : readInputs.keySet()) {\n             if (output == null) {\n-                output = getGatkReadJavaRDD(traversalParameters, source, input);\n+                output = getGatkReadJavaRDD(traversalParameters, source, inputPathSpecifier);\n             } else {\n-                output = output.union(getGatkReadJavaRDD(traversalParameters, source, input));\n+                output = output.union(getGatkReadJavaRDD(traversalParameters, source, inputPathSpecifier));\n             }\n         }\n         return output;\n     }\n \n-    protected JavaRDD<GATKRead> getGatkReadJavaRDD(TraversalParameters traversalParameters, ReadsSparkSource source, String input) {\n+    protected JavaRDD<GATKRead> getGatkReadJavaRDD(TraversalParameters traversalParameters, ReadsSparkSource source, GATKPathSpecifier inputSpecifier) {\n         JavaRDD<GATKRead> output;\n         // TODO: This if statement is a temporary hack until #959 gets resolve\n-        if (input.endsWith(\".adam\")) {\n+        if (inputSpecifier.getURIString().endsWith(\".adam\")) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "921e051ca633b9282340864620806d950532c8c7"}, "originalPosition": 31}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjg3Mjc5NQ==", "bodyText": "Fixed.", "url": "https://github.com/broadinstitute/gatk/pull/6561#discussion_r426872795", "createdAt": "2020-05-18T20:22:29Z", "author": {"login": "cmnbroad"}, "path": "src/main/java/org/broadinstitute/hellbender/engine/spark/GATKSparkTool.java", "diffHunk": "@@ -323,31 +323,31 @@ public SAMFileHeader getHeaderForReads() {\n \n         JavaRDD<GATKRead> output = null;\n         ReadsSparkSource source = readsSource;\n-        for (String input : readInputs.keySet()) {\n+        for (final GATKPathSpecifier inputPathSpecifier : readInputs.keySet()) {\n             if (output == null) {\n-                output = getGatkReadJavaRDD(traversalParameters, source, input);\n+                output = getGatkReadJavaRDD(traversalParameters, source, inputPathSpecifier);\n             } else {\n-                output = output.union(getGatkReadJavaRDD(traversalParameters, source, input));\n+                output = output.union(getGatkReadJavaRDD(traversalParameters, source, inputPathSpecifier));\n             }\n         }\n         return output;\n     }\n \n-    protected JavaRDD<GATKRead> getGatkReadJavaRDD(TraversalParameters traversalParameters, ReadsSparkSource source, String input) {\n+    protected JavaRDD<GATKRead> getGatkReadJavaRDD(TraversalParameters traversalParameters, ReadsSparkSource source, GATKPathSpecifier inputSpecifier) {\n         JavaRDD<GATKRead> output;\n         // TODO: This if statement is a temporary hack until #959 gets resolve\n-        if (input.endsWith(\".adam\")) {\n+        if (inputSpecifier.getURIString().endsWith(\".adam\")) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTAzNjE1Mg=="}, "originalCommit": {"oid": "921e051ca633b9282340864620806d950532c8c7"}, "originalPosition": 31}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYyMTA1MjEyOnYy", "diffSide": "RIGHT", "path": "src/main/java/org/broadinstitute/hellbender/engine/spark/GATKSparkTool.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNlQxOToyNzoxNVrOGRiHUg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOFQyMDoyMzowNVrOGXGREA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTAzNzkwNg==", "bodyText": "A good improvement would be to add spark ReadInputArgument collections which only takes a single bam. Maybe we can do that in a separate pr.", "url": "https://github.com/broadinstitute/gatk/pull/6561#discussion_r421037906", "createdAt": "2020-05-06T19:27:15Z", "author": {"login": "lbergelson"}, "path": "src/main/java/org/broadinstitute/hellbender/engine/spark/GATKSparkTool.java", "diffHunk": "@@ -504,20 +504,25 @@ public boolean useVariantAnnotations() {\n     }\n \n     /**\n-     * Returns the name of the source of reads data. It can be a file name or URL.\n+     * Returns the name of the source of reads data. It can be a file name or URL. Throws if the tool has more", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "921e051ca633b9282340864620806d950532c8c7"}, "originalPosition": 63}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjg3MzEwNA==", "bodyText": "Yes, but lets do that in a separate PR.", "url": "https://github.com/broadinstitute/gatk/pull/6561#discussion_r426873104", "createdAt": "2020-05-18T20:23:05Z", "author": {"login": "cmnbroad"}, "path": "src/main/java/org/broadinstitute/hellbender/engine/spark/GATKSparkTool.java", "diffHunk": "@@ -504,20 +504,25 @@ public boolean useVariantAnnotations() {\n     }\n \n     /**\n-     * Returns the name of the source of reads data. It can be a file name or URL.\n+     * Returns the name of the source of reads data. It can be a file name or URL. Throws if the tool has more", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTAzNzkwNg=="}, "originalCommit": {"oid": "921e051ca633b9282340864620806d950532c8c7"}, "originalPosition": 63}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYyMTA1NDQ3OnYy", "diffSide": "RIGHT", "path": "src/main/java/org/broadinstitute/hellbender/engine/spark/GATKSparkTool.java", "isResolved": false, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNlQxOToyNzo1OVrOGRiIzA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yN1QxODo0MjoxOVrOGbYUQA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTAzODI4NA==", "bodyText": "maybe getHeaderForReadsInput would be better.", "url": "https://github.com/broadinstitute/gatk/pull/6561#discussion_r421038284", "createdAt": "2020-05-06T19:27:59Z", "author": {"login": "lbergelson"}, "path": "src/main/java/org/broadinstitute/hellbender/engine/spark/GATKSparkTool.java", "diffHunk": "@@ -504,20 +504,25 @@ public boolean useVariantAnnotations() {\n     }\n \n     /**\n-     * Returns the name of the source of reads data. It can be a file name or URL.\n+     * Returns the name of the source of reads data. It can be a file name or URL. Throws if the tool has more\n+     * than one source.\n      */\n-    protected List<String> getReadSourceName(){\n+    protected String getReadSourceName(){\n         if (readInputs.size() > 1) {\n-            throw new GATKException(\"Multiple ReadsDataSources specificed but a single source requested by the tool\");\n+            throw new GATKException(\"Multiple ReadsDataSources specified but a single source requested by the tool\");\n         }\n-        return new ArrayList<>(readInputs.keySet());\n+        return readInputs.keySet().stream().findFirst().get().toString();\n     }\n \n     /**\n-     * Returns a map of read input to header.\n+     * Returns the header for a given input.\n      */\n-    protected LinkedHashMap<String, SAMFileHeader> getReadSourceHeaderMap(){\n-        return readInputs;\n+    protected SAMFileHeader getHeaderForInputPath(final GATKPathSpecifier inputPathSpecifier){", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "921e051ca633b9282340864620806d950532c8c7"}, "originalPosition": 82}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTAzOTI3NA==", "bodyText": "If we're changing other stuff to single read inputs maybe we should just change the underlying map into a single field.  I think that plan had been to support multiple inputs later but we never got to it.", "url": "https://github.com/broadinstitute/gatk/pull/6561#discussion_r421039274", "createdAt": "2020-05-06T19:29:38Z", "author": {"login": "lbergelson"}, "path": "src/main/java/org/broadinstitute/hellbender/engine/spark/GATKSparkTool.java", "diffHunk": "@@ -504,20 +504,25 @@ public boolean useVariantAnnotations() {\n     }\n \n     /**\n-     * Returns the name of the source of reads data. It can be a file name or URL.\n+     * Returns the name of the source of reads data. It can be a file name or URL. Throws if the tool has more\n+     * than one source.\n      */\n-    protected List<String> getReadSourceName(){\n+    protected String getReadSourceName(){\n         if (readInputs.size() > 1) {\n-            throw new GATKException(\"Multiple ReadsDataSources specificed but a single source requested by the tool\");\n+            throw new GATKException(\"Multiple ReadsDataSources specified but a single source requested by the tool\");\n         }\n-        return new ArrayList<>(readInputs.keySet());\n+        return readInputs.keySet().stream().findFirst().get().toString();\n     }\n \n     /**\n-     * Returns a map of read input to header.\n+     * Returns the header for a given input.\n      */\n-    protected LinkedHashMap<String, SAMFileHeader> getReadSourceHeaderMap(){\n-        return readInputs;\n+    protected SAMFileHeader getHeaderForInputPath(final GATKPathSpecifier inputPathSpecifier){", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTAzODI4NA=="}, "originalCommit": {"oid": "921e051ca633b9282340864620806d950532c8c7"}, "originalPosition": 82}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjg3NDM2Mw==", "bodyText": "All I did here was to change the signature of the method so that we don't have to hand out the map. Instead the caller just queries it. So I think this change is orthogonal to the number of inputs.", "url": "https://github.com/broadinstitute/gatk/pull/6561#discussion_r426874363", "createdAt": "2020-05-18T20:25:43Z", "author": {"login": "cmnbroad"}, "path": "src/main/java/org/broadinstitute/hellbender/engine/spark/GATKSparkTool.java", "diffHunk": "@@ -504,20 +504,25 @@ public boolean useVariantAnnotations() {\n     }\n \n     /**\n-     * Returns the name of the source of reads data. It can be a file name or URL.\n+     * Returns the name of the source of reads data. It can be a file name or URL. Throws if the tool has more\n+     * than one source.\n      */\n-    protected List<String> getReadSourceName(){\n+    protected String getReadSourceName(){\n         if (readInputs.size() > 1) {\n-            throw new GATKException(\"Multiple ReadsDataSources specificed but a single source requested by the tool\");\n+            throw new GATKException(\"Multiple ReadsDataSources specified but a single source requested by the tool\");\n         }\n-        return new ArrayList<>(readInputs.keySet());\n+        return readInputs.keySet().stream().findFirst().get().toString();\n     }\n \n     /**\n-     * Returns a map of read input to header.\n+     * Returns the header for a given input.\n      */\n-    protected LinkedHashMap<String, SAMFileHeader> getReadSourceHeaderMap(){\n-        return readInputs;\n+    protected SAMFileHeader getHeaderForInputPath(final GATKPathSpecifier inputPathSpecifier){", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTAzODI4NA=="}, "originalCommit": {"oid": "921e051ca633b9282340864620806d950532c8c7"}, "originalPosition": 82}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTM2MzEzNg==", "bodyText": "Changed the name to getHeaderForReadsInput.", "url": "https://github.com/broadinstitute/gatk/pull/6561#discussion_r431363136", "createdAt": "2020-05-27T18:42:19Z", "author": {"login": "cmnbroad"}, "path": "src/main/java/org/broadinstitute/hellbender/engine/spark/GATKSparkTool.java", "diffHunk": "@@ -504,20 +504,25 @@ public boolean useVariantAnnotations() {\n     }\n \n     /**\n-     * Returns the name of the source of reads data. It can be a file name or URL.\n+     * Returns the name of the source of reads data. It can be a file name or URL. Throws if the tool has more\n+     * than one source.\n      */\n-    protected List<String> getReadSourceName(){\n+    protected String getReadSourceName(){\n         if (readInputs.size() > 1) {\n-            throw new GATKException(\"Multiple ReadsDataSources specificed but a single source requested by the tool\");\n+            throw new GATKException(\"Multiple ReadsDataSources specified but a single source requested by the tool\");\n         }\n-        return new ArrayList<>(readInputs.keySet());\n+        return readInputs.keySet().stream().findFirst().get().toString();\n     }\n \n     /**\n-     * Returns a map of read input to header.\n+     * Returns the header for a given input.\n      */\n-    protected LinkedHashMap<String, SAMFileHeader> getReadSourceHeaderMap(){\n-        return readInputs;\n+    protected SAMFileHeader getHeaderForInputPath(final GATKPathSpecifier inputPathSpecifier){", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTAzODI4NA=="}, "originalCommit": {"oid": "921e051ca633b9282340864620806d950532c8c7"}, "originalPosition": 82}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYyMTA4MTY0OnYy", "diffSide": "RIGHT", "path": "src/main/java/org/broadinstitute/hellbender/tools/SplitReads.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNlQxOTozNTozMVrOGRiZeg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOFQyMDoyNTo1MFrOGXGWKg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTA0MjU1NA==", "bodyText": "As mentioned above, lets add methods for these to GATKPathSpecifier", "url": "https://github.com/broadinstitute/gatk/pull/6561#discussion_r421042554", "createdAt": "2020-05-06T19:35:31Z", "author": {"login": "lbergelson"}, "path": "src/main/java/org/broadinstitute/hellbender/tools/SplitReads.java", "diffHunk": "@@ -156,9 +157,9 @@ private SAMFileGATKReadWriter prepareSAMFileWriter(\n             SAMFileWriterFactory samFileWriterFactory,\n             SAMFileHeader samFileHeaderIn,\n             final String keyName) {\n-        final String base = FilenameUtils.getBaseName(readArguments.getReadFiles().get(0).getName());\n-        final String extension = \".\" + FilenameUtils.getExtension(readArguments.getReadFiles().get(0).getName());\n-        final File outFile = new File(OUTPUT_DIRECTORY, base + keyName + extension);\n+        final String base = FilenameUtils.getBaseName(readArguments.getReadPathSpecifiers().get(0).getURI().getSchemeSpecificPart());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "921e051ca633b9282340864620806d950532c8c7"}, "originalPosition": 24}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjg3NDQxMA==", "bodyText": "Done.", "url": "https://github.com/broadinstitute/gatk/pull/6561#discussion_r426874410", "createdAt": "2020-05-18T20:25:50Z", "author": {"login": "cmnbroad"}, "path": "src/main/java/org/broadinstitute/hellbender/tools/SplitReads.java", "diffHunk": "@@ -156,9 +157,9 @@ private SAMFileGATKReadWriter prepareSAMFileWriter(\n             SAMFileWriterFactory samFileWriterFactory,\n             SAMFileHeader samFileHeaderIn,\n             final String keyName) {\n-        final String base = FilenameUtils.getBaseName(readArguments.getReadFiles().get(0).getName());\n-        final String extension = \".\" + FilenameUtils.getExtension(readArguments.getReadFiles().get(0).getName());\n-        final File outFile = new File(OUTPUT_DIRECTORY, base + keyName + extension);\n+        final String base = FilenameUtils.getBaseName(readArguments.getReadPathSpecifiers().get(0).getURI().getSchemeSpecificPart());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTA0MjU1NA=="}, "originalCommit": {"oid": "921e051ca633b9282340864620806d950532c8c7"}, "originalPosition": 24}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYyMTM2MDE1OnYy", "diffSide": "RIGHT", "path": "src/main/java/org/broadinstitute/hellbender/tools/SplitReads.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNlQyMDo1NjowM1rOGRlFHw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQxMzo0NTo0MlrOGXhMgw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTA4NjQ5NQ==", "bodyText": "While we're here can we make OUTPUT_DIRECTORY a GATKPathSpecifier too and avoid going through File here.", "url": "https://github.com/broadinstitute/gatk/pull/6561#discussion_r421086495", "createdAt": "2020-05-06T20:56:03Z", "author": {"login": "lbergelson"}, "path": "src/main/java/org/broadinstitute/hellbender/tools/SplitReads.java", "diffHunk": "@@ -156,9 +157,9 @@ private SAMFileGATKReadWriter prepareSAMFileWriter(\n             SAMFileWriterFactory samFileWriterFactory,\n             SAMFileHeader samFileHeaderIn,\n             final String keyName) {\n-        final String base = FilenameUtils.getBaseName(readArguments.getReadFiles().get(0).getName());\n-        final String extension = \".\" + FilenameUtils.getExtension(readArguments.getReadFiles().get(0).getName());\n-        final File outFile = new File(OUTPUT_DIRECTORY, base + keyName + extension);\n+        final String base = FilenameUtils.getBaseName(readArguments.getReadPathSpecifiers().get(0).getURI().getSchemeSpecificPart());\n+        final String extension = \".\" + FilenameUtils.getExtension(readArguments.getReadPathSpecifiers().get(0).getURI().getSchemeSpecificPart());\n+        final GATKPathSpecifier outFile = new GATKPathSpecifier(new File(OUTPUT_DIRECTORY, base + keyName + extension).getAbsolutePath());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "921e051ca633b9282340864620806d950532c8c7"}, "originalPosition": 26}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzMxNDMwNw==", "bodyText": "Done.", "url": "https://github.com/broadinstitute/gatk/pull/6561#discussion_r427314307", "createdAt": "2020-05-19T13:45:42Z", "author": {"login": "cmnbroad"}, "path": "src/main/java/org/broadinstitute/hellbender/tools/SplitReads.java", "diffHunk": "@@ -156,9 +157,9 @@ private SAMFileGATKReadWriter prepareSAMFileWriter(\n             SAMFileWriterFactory samFileWriterFactory,\n             SAMFileHeader samFileHeaderIn,\n             final String keyName) {\n-        final String base = FilenameUtils.getBaseName(readArguments.getReadFiles().get(0).getName());\n-        final String extension = \".\" + FilenameUtils.getExtension(readArguments.getReadFiles().get(0).getName());\n-        final File outFile = new File(OUTPUT_DIRECTORY, base + keyName + extension);\n+        final String base = FilenameUtils.getBaseName(readArguments.getReadPathSpecifiers().get(0).getURI().getSchemeSpecificPart());\n+        final String extension = \".\" + FilenameUtils.getExtension(readArguments.getReadPathSpecifiers().get(0).getURI().getSchemeSpecificPart());\n+        final GATKPathSpecifier outFile = new GATKPathSpecifier(new File(OUTPUT_DIRECTORY, base + keyName + extension).getAbsolutePath());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTA4NjQ5NQ=="}, "originalCommit": {"oid": "921e051ca633b9282340864620806d950532c8c7"}, "originalPosition": 26}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYyMTM3MDc4OnYy", "diffSide": "RIGHT", "path": "src/main/java/org/broadinstitute/hellbender/tools/spark/RevertSamSpark.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNlQyMDo1OTowMlrOGRlLdw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQxMzo0NTo1NVrOGXhNKA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTA4ODExOQ==", "bodyText": "might have weirdness with http paths with cruft after them", "url": "https://github.com/broadinstitute/gatk/pull/6561#discussion_r421088119", "createdAt": "2020-05-06T20:59:02Z", "author": {"login": "lbergelson"}, "path": "src/main/java/org/broadinstitute/hellbender/tools/spark/RevertSamSpark.java", "diffHunk": "@@ -269,7 +269,7 @@ protected void runTool(JavaSparkContext ctx) {\n         ////////////////////////////////////////////////////////////////////////////\n         Map<String, Path> writerMap = getOutputMap(outputMap,\n                                                   output,\n-                                                  getDefaultExtension(readArguments.getReadFiles().get(0).toString(), outputByReadgroupFileFormat),\n+                                                  getDefaultExtension(readArguments.getReadPathSpecifiers().get(0).getRawInputString(), outputByReadgroupFileFormat),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "921e051ca633b9282340864620806d950532c8c7"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzMxNDQ3Mg==", "bodyText": "Done.", "url": "https://github.com/broadinstitute/gatk/pull/6561#discussion_r427314472", "createdAt": "2020-05-19T13:45:55Z", "author": {"login": "cmnbroad"}, "path": "src/main/java/org/broadinstitute/hellbender/tools/spark/RevertSamSpark.java", "diffHunk": "@@ -269,7 +269,7 @@ protected void runTool(JavaSparkContext ctx) {\n         ////////////////////////////////////////////////////////////////////////////\n         Map<String, Path> writerMap = getOutputMap(outputMap,\n                                                   output,\n-                                                  getDefaultExtension(readArguments.getReadFiles().get(0).toString(), outputByReadgroupFileFormat),\n+                                                  getDefaultExtension(readArguments.getReadPathSpecifiers().get(0).getRawInputString(), outputByReadgroupFileFormat),", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTA4ODExOQ=="}, "originalCommit": {"oid": "921e051ca633b9282340864620806d950532c8c7"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYyMTM3NDkzOnYy", "diffSide": "RIGHT", "path": "src/main/java/org/broadinstitute/hellbender/tools/spark/pathseq/PSUtils.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNlQyMDo1OTo1OVrOGRlN1A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQxNzoxNTo0MVrOGXqfsw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTA4ODcyNA==", "bodyText": "Can we lift the GATKPathSpecifier higher here and get rid of the string or is that difficult?", "url": "https://github.com/broadinstitute/gatk/pull/6561#discussion_r421088724", "createdAt": "2020-05-06T20:59:59Z", "author": {"login": "lbergelson"}, "path": "src/main/java/org/broadinstitute/hellbender/tools/spark/pathseq/PSUtils.java", "diffHunk": "@@ -57,12 +58,13 @@ public static void logItemizedWarning(final Logger logger, final Collection<?> i\n     /**\n      * Same as GATKSparkTool's getRecommendedNumReducers(), but can specify input BAM path (for when --input is not used)\n      */\n+    //TODO: fix this", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "921e051ca633b9282340864620806d950532c8c7"}, "originalPosition": 12}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzQ2NjY3NQ==", "bodyText": "It starts a cascade so it will be in a different pr.", "url": "https://github.com/broadinstitute/gatk/pull/6561#discussion_r427466675", "createdAt": "2020-05-19T17:15:41Z", "author": {"login": "cmnbroad"}, "path": "src/main/java/org/broadinstitute/hellbender/tools/spark/pathseq/PSUtils.java", "diffHunk": "@@ -57,12 +58,13 @@ public static void logItemizedWarning(final Logger logger, final Collection<?> i\n     /**\n      * Same as GATKSparkTool's getRecommendedNumReducers(), but can specify input BAM path (for when --input is not used)\n      */\n+    //TODO: fix this", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTA4ODcyNA=="}, "originalCommit": {"oid": "921e051ca633b9282340864620806d950532c8c7"}, "originalPosition": 12}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYyMTM3ODIyOnYy", "diffSide": "RIGHT", "path": "src/main/java/org/broadinstitute/hellbender/tools/spark/pathseq/PathSeqBwaSpark.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNlQyMTowMDo1NFrOGRlP5g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQxNToxMDo1OVrOGXlPnA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTA4OTI1NA==", "bodyText": "Can these paths be input as Path specifiers instead of strings here?", "url": "https://github.com/broadinstitute/gatk/pull/6561#discussion_r421089254", "createdAt": "2020-05-06T21:00:54Z", "author": {"login": "lbergelson"}, "path": "src/main/java/org/broadinstitute/hellbender/tools/spark/pathseq/PathSeqBwaSpark.java", "diffHunk": "@@ -152,12 +153,12 @@\n                                                              final ReadsSparkSource readsSource) {\n         if (path == null) return null;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "921e051ca633b9282340864620806d950532c8c7"}, "originalPosition": 10}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzM4MDYzNg==", "bodyText": "Yes, but it pulls on a longer thread. The pathseq package needs its own PR.", "url": "https://github.com/broadinstitute/gatk/pull/6561#discussion_r427380636", "createdAt": "2020-05-19T15:10:59Z", "author": {"login": "cmnbroad"}, "path": "src/main/java/org/broadinstitute/hellbender/tools/spark/pathseq/PathSeqBwaSpark.java", "diffHunk": "@@ -152,12 +153,12 @@\n                                                              final ReadsSparkSource readsSource) {\n         if (path == null) return null;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTA4OTI1NA=="}, "originalCommit": {"oid": "921e051ca633b9282340864620806d950532c8c7"}, "originalPosition": 10}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYyMTM4MDUyOnYy", "diffSide": "RIGHT", "path": "src/main/java/org/broadinstitute/hellbender/tools/spark/pathseq/PathSeqScoreSpark.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNlQyMTowMTozM1rOGRlRMQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQxNToyNjozNlrOGXl-fA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTA4OTU4NQ==", "bodyText": "looks like the same thread as above, I assume the todos mean we should hit them later instead of in this PR?  Should we open an issue?", "url": "https://github.com/broadinstitute/gatk/pull/6561#discussion_r421089585", "createdAt": "2020-05-06T21:01:33Z", "author": {"login": "lbergelson"}, "path": "src/main/java/org/broadinstitute/hellbender/tools/spark/pathseq/PathSeqScoreSpark.java", "diffHunk": "@@ -136,13 +137,15 @@\n \n     private int recommendedNumReducers = 0;\n \n+    //TODO: fix this", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "921e051ca633b9282340864620806d950532c8c7"}, "originalPosition": 12}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzM5MjYzNg==", "bodyText": "Replaced these with #6610 to track remaining todos.", "url": "https://github.com/broadinstitute/gatk/pull/6561#discussion_r427392636", "createdAt": "2020-05-19T15:26:36Z", "author": {"login": "cmnbroad"}, "path": "src/main/java/org/broadinstitute/hellbender/tools/spark/pathseq/PathSeqScoreSpark.java", "diffHunk": "@@ -136,13 +137,15 @@\n \n     private int recommendedNumReducers = 0;\n \n+    //TODO: fix this", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTA4OTU4NQ=="}, "originalCommit": {"oid": "921e051ca633b9282340864620806d950532c8c7"}, "originalPosition": 12}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYyMTM5Mzg0OnYy", "diffSide": "RIGHT", "path": "src/main/java/org/broadinstitute/hellbender/utils/gcs/BucketUtils.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNlQyMTowNDo1OFrOGRlY7Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQxNzoxNjowMlrOGXqgyA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTA5MTU2NQ==", "bodyText": "Let's burn this whole class with fire.", "url": "https://github.com/broadinstitute/gatk/pull/6561#discussion_r421091565", "createdAt": "2020-05-06T21:04:58Z", "author": {"login": "lbergelson"}, "path": "src/main/java/org/broadinstitute/hellbender/utils/gcs/BucketUtils.java", "diffHunk": "@@ -122,6 +132,7 @@ public static boolean isRemoteStorageUrl(String path) {\n      * @param path the path\n      * @return an absolute file path if the original path was a relative file path, otherwise the original path\n      */\n+    //TODO: get rid of this..", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "921e051ca633b9282340864620806d950532c8c7"}, "originalPosition": 21}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzQ2Njk1Mg==", "bodyText": "Yes, but still more work to do to get there.", "url": "https://github.com/broadinstitute/gatk/pull/6561#discussion_r427466952", "createdAt": "2020-05-19T17:16:02Z", "author": {"login": "cmnbroad"}, "path": "src/main/java/org/broadinstitute/hellbender/utils/gcs/BucketUtils.java", "diffHunk": "@@ -122,6 +132,7 @@ public static boolean isRemoteStorageUrl(String path) {\n      * @param path the path\n      * @return an absolute file path if the original path was a relative file path, otherwise the original path\n      */\n+    //TODO: get rid of this..", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTA5MTU2NQ=="}, "originalCommit": {"oid": "921e051ca633b9282340864620806d950532c8c7"}, "originalPosition": 21}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYyMTM5NTc4OnYy", "diffSide": "RIGHT", "path": "src/main/java/org/broadinstitute/hellbender/utils/io/IOUtils.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNlQyMTowNTozM1rOGRlaGg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOFQyMDoyNjoxNVrOGXGW0w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTA5MTg2Ng==", "bodyText": "this needs a convenience method", "url": "https://github.com/broadinstitute/gatk/pull/6561#discussion_r421091866", "createdAt": "2020-05-06T21:05:33Z", "author": {"login": "lbergelson"}, "path": "src/main/java/org/broadinstitute/hellbender/utils/io/IOUtils.java", "diffHunk": "@@ -57,10 +57,10 @@\n     private static final Pattern GENOMICSDB_URI_PATTERN = Pattern.compile(\"^\" + GENOMIC_DB_URI_SCHEME + \"(\\\\.?)(.*)(://)(.*)\");\n \n     /**\n-     * Returns true if the file's extension is CRAM.\n+     * Returns true if the GATKPathSpecifier's extension is CRAM.\n      */\n-    public static boolean isCramFile(final File inputFile) {\n-        return isCramFileName(inputFile.getName());\n+    public static boolean isCramFile(final GATKPathSpecifier pathSpec) {\n+        return pathSpec != null && FileExtensions.CRAM.equalsIgnoreCase(\".\" + FilenameUtils.getExtension(pathSpec.getURI().getPath()));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "921e051ca633b9282340864620806d950532c8c7"}, "originalPosition": 10}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjg3NDU3OQ==", "bodyText": "Done.", "url": "https://github.com/broadinstitute/gatk/pull/6561#discussion_r426874579", "createdAt": "2020-05-18T20:26:15Z", "author": {"login": "cmnbroad"}, "path": "src/main/java/org/broadinstitute/hellbender/utils/io/IOUtils.java", "diffHunk": "@@ -57,10 +57,10 @@\n     private static final Pattern GENOMICSDB_URI_PATTERN = Pattern.compile(\"^\" + GENOMIC_DB_URI_SCHEME + \"(\\\\.?)(.*)(://)(.*)\");\n \n     /**\n-     * Returns true if the file's extension is CRAM.\n+     * Returns true if the GATKPathSpecifier's extension is CRAM.\n      */\n-    public static boolean isCramFile(final File inputFile) {\n-        return isCramFileName(inputFile.getName());\n+    public static boolean isCramFile(final GATKPathSpecifier pathSpec) {\n+        return pathSpec != null && FileExtensions.CRAM.equalsIgnoreCase(\".\" + FilenameUtils.getExtension(pathSpec.getURI().getPath()));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTA5MTg2Ng=="}, "originalCommit": {"oid": "921e051ca633b9282340864620806d950532c8c7"}, "originalPosition": 10}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY2NzQxMzE0OnYy", "diffSide": "RIGHT", "path": "src/main/java/org/broadinstitute/hellbender/engine/PathURI.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMFQyMDo0MjoxNFrOGYdEog==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNlQyMToyNDoxM1rOGaw1eg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODI5NTMzMA==", "bodyText": "There needs to be a comment about the different behavior on both methods javadoc. Otherwise people will accidentally interchange file.getExtension().equals(\".fasta.gz\") and file.hasExtension(\".fasta.gz\")", "url": "https://github.com/broadinstitute/gatk/pull/6561#discussion_r428295330", "createdAt": "2020-05-20T20:42:14Z", "author": {"login": "lbergelson"}, "path": "src/main/java/org/broadinstitute/hellbender/engine/PathURI.java", "diffHunk": "@@ -73,6 +76,100 @@ default String getScheme() {\n         return getURI().getScheme();\n     }\n \n+    /**\n+     * @return the extension of the last component of the hierarchical part of the scheme-specific part of the\n+     * URI, if any, including the \".\". Note that this only returns the part of the last component after the last\n+     * \".\", ie. it will return \".gz\" for a name that ends in \".fasta.gz\".\n+     * @throws IllegalArgumentException if the hierarchical name ends with the default file system separator\n+     * (i.e. \"/\") or \".\", or if the last component does not contain a \".\".\n+     */\n+    default String getExtension() {\n+        final String hierarchicalPath = getURI().getPath();\n+        final int indexOfLastComponent = hierarchicalPath.lastIndexOf(FileSystems.getDefault().getSeparator());\n+        if (indexOfLastComponent != -1 && indexOfLastComponent < hierarchicalPath.length() - 1) {\n+            final String lastComponent = hierarchicalPath.substring(indexOfLastComponent + 1);\n+            if (lastComponent.length() > 0) {\n+                final int indexOfLastDot = lastComponent.lastIndexOf('.');\n+                if (indexOfLastDot != -1 && indexOfLastDot < lastComponent.length() - 1) {\n+                    // return a string that includes the leading \".\" to enable easy comparison with the many\n+                    // internal file extension constants we have that include the leading \".\" (i.e., in htsjdk),\n+                    // and also for API consistency (since hasExtension() requires the candidate extension to\n+                    // include a leading \".\", this allows hasExtension(getExtension()) to always work whenever\n+                    // getExtension() succeeds\n+                    return lastComponent.substring(indexOfLastDot);\n+                }\n+            }\n+        }\n+        throw new IllegalArgumentException(String.format(\"Input path (%s) has no extension\", this));\n+    }\n+\n+    /**\n+     * Return true if the path component (the hierarchical part of the scheme specific part of the underlying URI)\n+     * ends with the provided {@code extension} string.\n+     *\n+     * @param extension the target extension to test, INCLUDING the leading \".\". May not be null.\n+     * @return true if the path component of this specifier ends with the extension, otherwise false\n+     */\n+    default boolean hasExtension(final String extension) {\n+        Utils.nonNull(extension, \"Target extension must not be null\");\n+        Utils.validateArg(extension.length() > 1, \"Target extension must be length > 1\");\n+        Utils.validateArg(extension.charAt(0) == '.', \"Target extension must include the leading '.'\");\n+\n+        // We don't want to use {@code #getExtension} here, since it won't work correctly if we're comparing an\n+        // extension that uses multiple . chars, such as .fasta.gz., and {@code #getExtension} will throw if there", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "89bccf032094478b5db0c3f4f8de9b7f1b3fdb8d"}, "originalPosition": 65}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDcxNjI4Mg==", "bodyText": "Done.", "url": "https://github.com/broadinstitute/gatk/pull/6561#discussion_r430716282", "createdAt": "2020-05-26T21:24:13Z", "author": {"login": "cmnbroad"}, "path": "src/main/java/org/broadinstitute/hellbender/engine/PathURI.java", "diffHunk": "@@ -73,6 +76,100 @@ default String getScheme() {\n         return getURI().getScheme();\n     }\n \n+    /**\n+     * @return the extension of the last component of the hierarchical part of the scheme-specific part of the\n+     * URI, if any, including the \".\". Note that this only returns the part of the last component after the last\n+     * \".\", ie. it will return \".gz\" for a name that ends in \".fasta.gz\".\n+     * @throws IllegalArgumentException if the hierarchical name ends with the default file system separator\n+     * (i.e. \"/\") or \".\", or if the last component does not contain a \".\".\n+     */\n+    default String getExtension() {\n+        final String hierarchicalPath = getURI().getPath();\n+        final int indexOfLastComponent = hierarchicalPath.lastIndexOf(FileSystems.getDefault().getSeparator());\n+        if (indexOfLastComponent != -1 && indexOfLastComponent < hierarchicalPath.length() - 1) {\n+            final String lastComponent = hierarchicalPath.substring(indexOfLastComponent + 1);\n+            if (lastComponent.length() > 0) {\n+                final int indexOfLastDot = lastComponent.lastIndexOf('.');\n+                if (indexOfLastDot != -1 && indexOfLastDot < lastComponent.length() - 1) {\n+                    // return a string that includes the leading \".\" to enable easy comparison with the many\n+                    // internal file extension constants we have that include the leading \".\" (i.e., in htsjdk),\n+                    // and also for API consistency (since hasExtension() requires the candidate extension to\n+                    // include a leading \".\", this allows hasExtension(getExtension()) to always work whenever\n+                    // getExtension() succeeds\n+                    return lastComponent.substring(indexOfLastDot);\n+                }\n+            }\n+        }\n+        throw new IllegalArgumentException(String.format(\"Input path (%s) has no extension\", this));\n+    }\n+\n+    /**\n+     * Return true if the path component (the hierarchical part of the scheme specific part of the underlying URI)\n+     * ends with the provided {@code extension} string.\n+     *\n+     * @param extension the target extension to test, INCLUDING the leading \".\". May not be null.\n+     * @return true if the path component of this specifier ends with the extension, otherwise false\n+     */\n+    default boolean hasExtension(final String extension) {\n+        Utils.nonNull(extension, \"Target extension must not be null\");\n+        Utils.validateArg(extension.length() > 1, \"Target extension must be length > 1\");\n+        Utils.validateArg(extension.charAt(0) == '.', \"Target extension must include the leading '.'\");\n+\n+        // We don't want to use {@code #getExtension} here, since it won't work correctly if we're comparing an\n+        // extension that uses multiple . chars, such as .fasta.gz., and {@code #getExtension} will throw if there", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODI5NTMzMA=="}, "originalCommit": {"oid": "89bccf032094478b5db0c3f4f8de9b7f1b3fdb8d"}, "originalPosition": 65}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY2NzQxNjAwOnYy", "diffSide": "RIGHT", "path": "src/main/java/org/broadinstitute/hellbender/engine/PathURI.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMFQyMDo0MzoxMVrOGYdGcA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNlQyMToyMzozMFrOGaw0LQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODI5NTc5Mg==", "bodyText": "In order to use this safely there probably needs to be a matching hasExtension().  Otherwise people are forced to catch the exception in order to call this safely.", "url": "https://github.com/broadinstitute/gatk/pull/6561#discussion_r428295792", "createdAt": "2020-05-20T20:43:11Z", "author": {"login": "lbergelson"}, "path": "src/main/java/org/broadinstitute/hellbender/engine/PathURI.java", "diffHunk": "@@ -73,6 +76,100 @@ default String getScheme() {\n         return getURI().getScheme();\n     }\n \n+    /**\n+     * @return the extension of the last component of the hierarchical part of the scheme-specific part of the\n+     * URI, if any, including the \".\". Note that this only returns the part of the last component after the last\n+     * \".\", ie. it will return \".gz\" for a name that ends in \".fasta.gz\".\n+     * @throws IllegalArgumentException if the hierarchical name ends with the default file system separator\n+     * (i.e. \"/\") or \".\", or if the last component does not contain a \".\".\n+     */\n+    default String getExtension() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "89bccf032094478b5db0c3f4f8de9b7f1b3fdb8d"}, "originalPosition": 32}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDcxNTk0OQ==", "bodyText": "I modified both getExtension and getBaseName to return \"\" if there is no extension or basename.", "url": "https://github.com/broadinstitute/gatk/pull/6561#discussion_r430715949", "createdAt": "2020-05-26T21:23:30Z", "author": {"login": "cmnbroad"}, "path": "src/main/java/org/broadinstitute/hellbender/engine/PathURI.java", "diffHunk": "@@ -73,6 +76,100 @@ default String getScheme() {\n         return getURI().getScheme();\n     }\n \n+    /**\n+     * @return the extension of the last component of the hierarchical part of the scheme-specific part of the\n+     * URI, if any, including the \".\". Note that this only returns the part of the last component after the last\n+     * \".\", ie. it will return \".gz\" for a name that ends in \".fasta.gz\".\n+     * @throws IllegalArgumentException if the hierarchical name ends with the default file system separator\n+     * (i.e. \"/\") or \".\", or if the last component does not contain a \".\".\n+     */\n+    default String getExtension() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODI5NTc5Mg=="}, "originalCommit": {"oid": "89bccf032094478b5db0c3f4f8de9b7f1b3fdb8d"}, "originalPosition": 32}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY2NzQyMTk0OnYy", "diffSide": "RIGHT", "path": "src/main/java/org/broadinstitute/hellbender/engine/PathURI.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMFQyMDo0NTowNFrOGYdKJw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNlQyMToyNzo0N1rOGaw70A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODI5Njc0Mw==", "bodyText": "This seems like the wrong error message.", "url": "https://github.com/broadinstitute/gatk/pull/6561#discussion_r428296743", "createdAt": "2020-05-20T20:45:04Z", "author": {"login": "lbergelson"}, "path": "src/main/java/org/broadinstitute/hellbender/engine/PathURI.java", "diffHunk": "@@ -73,6 +76,100 @@ default String getScheme() {\n         return getURI().getScheme();\n     }\n \n+    /**\n+     * @return the extension of the last component of the hierarchical part of the scheme-specific part of the\n+     * URI, if any, including the \".\". Note that this only returns the part of the last component after the last\n+     * \".\", ie. it will return \".gz\" for a name that ends in \".fasta.gz\".\n+     * @throws IllegalArgumentException if the hierarchical name ends with the default file system separator\n+     * (i.e. \"/\") or \".\", or if the last component does not contain a \".\".\n+     */\n+    default String getExtension() {\n+        final String hierarchicalPath = getURI().getPath();\n+        final int indexOfLastComponent = hierarchicalPath.lastIndexOf(FileSystems.getDefault().getSeparator());\n+        if (indexOfLastComponent != -1 && indexOfLastComponent < hierarchicalPath.length() - 1) {\n+            final String lastComponent = hierarchicalPath.substring(indexOfLastComponent + 1);\n+            if (lastComponent.length() > 0) {\n+                final int indexOfLastDot = lastComponent.lastIndexOf('.');\n+                if (indexOfLastDot != -1 && indexOfLastDot < lastComponent.length() - 1) {\n+                    // return a string that includes the leading \".\" to enable easy comparison with the many\n+                    // internal file extension constants we have that include the leading \".\" (i.e., in htsjdk),\n+                    // and also for API consistency (since hasExtension() requires the candidate extension to\n+                    // include a leading \".\", this allows hasExtension(getExtension()) to always work whenever\n+                    // getExtension() succeeds\n+                    return lastComponent.substring(indexOfLastDot);\n+                }\n+            }\n+        }\n+        throw new IllegalArgumentException(String.format(\"Input path (%s) has no extension\", this));\n+    }\n+\n+    /**\n+     * Return true if the path component (the hierarchical part of the scheme specific part of the underlying URI)\n+     * ends with the provided {@code extension} string.\n+     *\n+     * @param extension the target extension to test, INCLUDING the leading \".\". May not be null.\n+     * @return true if the path component of this specifier ends with the extension, otherwise false\n+     */\n+    default boolean hasExtension(final String extension) {\n+        Utils.nonNull(extension, \"Target extension must not be null\");\n+        Utils.validateArg(extension.length() > 1, \"Target extension must be length > 1\");\n+        Utils.validateArg(extension.charAt(0) == '.', \"Target extension must include the leading '.'\");\n+\n+        // We don't want to use {@code #getExtension} here, since it won't work correctly if we're comparing an\n+        // extension that uses multiple . chars, such as .fasta.gz., and {@code #getExtension} will throw if there\n+        // is no extension.\n+        return getURI().getPath().toLowerCase().endsWith(extension.toLowerCase());\n+    }\n+\n+    /**\n+     * @return the base name (the last component of the hierarchical part of the scheme-specific part of the URI,\n+     * after the last \"/\"), up to but not including the extension (the last \".\").\n+     * @throws IllegalArgumentException if the last component is empty (ie, the component ends in \"/\"), or the last\n+     * component exists but starts with \".\"\n+     */\n+    default String getBaseName() {\n+        final String hierarchicalPath = getURI().getPath();\n+        final int indexOfLastComponent = hierarchicalPath.lastIndexOf(FileSystems.getDefault().getSeparator());\n+        if (indexOfLastComponent != -1 && indexOfLastComponent < hierarchicalPath.length() - 1) {\n+            final String lastComponent = hierarchicalPath.substring(indexOfLastComponent + 1);\n+            if (lastComponent.length() > 0) {\n+                final int indexOfLastDot = lastComponent.lastIndexOf('.');\n+                if (indexOfLastDot != -1 && indexOfLastDot > 1) {\n+                    return lastComponent.substring(0, indexOfLastDot);\n+                }\n+            }\n+        }\n+        throw new IllegalArgumentException(String.format(\"Input path (%s) has no extension\", this));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "89bccf032094478b5db0c3f4f8de9b7f1b3fdb8d"}, "originalPosition": 88}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDcxNzkwNA==", "bodyText": "Removed the throw and now returns \"\".", "url": "https://github.com/broadinstitute/gatk/pull/6561#discussion_r430717904", "createdAt": "2020-05-26T21:27:47Z", "author": {"login": "cmnbroad"}, "path": "src/main/java/org/broadinstitute/hellbender/engine/PathURI.java", "diffHunk": "@@ -73,6 +76,100 @@ default String getScheme() {\n         return getURI().getScheme();\n     }\n \n+    /**\n+     * @return the extension of the last component of the hierarchical part of the scheme-specific part of the\n+     * URI, if any, including the \".\". Note that this only returns the part of the last component after the last\n+     * \".\", ie. it will return \".gz\" for a name that ends in \".fasta.gz\".\n+     * @throws IllegalArgumentException if the hierarchical name ends with the default file system separator\n+     * (i.e. \"/\") or \".\", or if the last component does not contain a \".\".\n+     */\n+    default String getExtension() {\n+        final String hierarchicalPath = getURI().getPath();\n+        final int indexOfLastComponent = hierarchicalPath.lastIndexOf(FileSystems.getDefault().getSeparator());\n+        if (indexOfLastComponent != -1 && indexOfLastComponent < hierarchicalPath.length() - 1) {\n+            final String lastComponent = hierarchicalPath.substring(indexOfLastComponent + 1);\n+            if (lastComponent.length() > 0) {\n+                final int indexOfLastDot = lastComponent.lastIndexOf('.');\n+                if (indexOfLastDot != -1 && indexOfLastDot < lastComponent.length() - 1) {\n+                    // return a string that includes the leading \".\" to enable easy comparison with the many\n+                    // internal file extension constants we have that include the leading \".\" (i.e., in htsjdk),\n+                    // and also for API consistency (since hasExtension() requires the candidate extension to\n+                    // include a leading \".\", this allows hasExtension(getExtension()) to always work whenever\n+                    // getExtension() succeeds\n+                    return lastComponent.substring(indexOfLastDot);\n+                }\n+            }\n+        }\n+        throw new IllegalArgumentException(String.format(\"Input path (%s) has no extension\", this));\n+    }\n+\n+    /**\n+     * Return true if the path component (the hierarchical part of the scheme specific part of the underlying URI)\n+     * ends with the provided {@code extension} string.\n+     *\n+     * @param extension the target extension to test, INCLUDING the leading \".\". May not be null.\n+     * @return true if the path component of this specifier ends with the extension, otherwise false\n+     */\n+    default boolean hasExtension(final String extension) {\n+        Utils.nonNull(extension, \"Target extension must not be null\");\n+        Utils.validateArg(extension.length() > 1, \"Target extension must be length > 1\");\n+        Utils.validateArg(extension.charAt(0) == '.', \"Target extension must include the leading '.'\");\n+\n+        // We don't want to use {@code #getExtension} here, since it won't work correctly if we're comparing an\n+        // extension that uses multiple . chars, such as .fasta.gz., and {@code #getExtension} will throw if there\n+        // is no extension.\n+        return getURI().getPath().toLowerCase().endsWith(extension.toLowerCase());\n+    }\n+\n+    /**\n+     * @return the base name (the last component of the hierarchical part of the scheme-specific part of the URI,\n+     * after the last \"/\"), up to but not including the extension (the last \".\").\n+     * @throws IllegalArgumentException if the last component is empty (ie, the component ends in \"/\"), or the last\n+     * component exists but starts with \".\"\n+     */\n+    default String getBaseName() {\n+        final String hierarchicalPath = getURI().getPath();\n+        final int indexOfLastComponent = hierarchicalPath.lastIndexOf(FileSystems.getDefault().getSeparator());\n+        if (indexOfLastComponent != -1 && indexOfLastComponent < hierarchicalPath.length() - 1) {\n+            final String lastComponent = hierarchicalPath.substring(indexOfLastComponent + 1);\n+            if (lastComponent.length() > 0) {\n+                final int indexOfLastDot = lastComponent.lastIndexOf('.');\n+                if (indexOfLastDot != -1 && indexOfLastDot > 1) {\n+                    return lastComponent.substring(0, indexOfLastDot);\n+                }\n+            }\n+        }\n+        throw new IllegalArgumentException(String.format(\"Input path (%s) has no extension\", this));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODI5Njc0Mw=="}, "originalCommit": {"oid": "89bccf032094478b5db0c3f4f8de9b7f1b3fdb8d"}, "originalPosition": 88}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY2NzQzNzgyOnYy", "diffSide": "RIGHT", "path": "src/main/java/org/broadinstitute/hellbender/engine/PathURI.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMFQyMDo1MDoxN1rOGYdUUw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMFQyMTowNDo0OVrOGYdw_Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODI5OTM0Nw==", "bodyText": "I think it might be better to be greedy about the extension and include everything after the first . as the extension? fasta.gz and bam.bai seem more common than \"my.filename.has.random.dots.fasta\".  Maybe I'm wrong about that though.\nTypically when people call baseName it's because they want to create a similarly name file with a different extension, so stripping all the extensions makes sense.\nI think the comment about the componentExisting but starting with \".\" doesn't match the tests where you have \".fasta.gz\".baseName() == \".fasta\".", "url": "https://github.com/broadinstitute/gatk/pull/6561#discussion_r428299347", "createdAt": "2020-05-20T20:50:17Z", "author": {"login": "lbergelson"}, "path": "src/main/java/org/broadinstitute/hellbender/engine/PathURI.java", "diffHunk": "@@ -73,6 +76,100 @@ default String getScheme() {\n         return getURI().getScheme();\n     }\n \n+    /**\n+     * @return the extension of the last component of the hierarchical part of the scheme-specific part of the\n+     * URI, if any, including the \".\". Note that this only returns the part of the last component after the last\n+     * \".\", ie. it will return \".gz\" for a name that ends in \".fasta.gz\".\n+     * @throws IllegalArgumentException if the hierarchical name ends with the default file system separator\n+     * (i.e. \"/\") or \".\", or if the last component does not contain a \".\".\n+     */\n+    default String getExtension() {\n+        final String hierarchicalPath = getURI().getPath();\n+        final int indexOfLastComponent = hierarchicalPath.lastIndexOf(FileSystems.getDefault().getSeparator());\n+        if (indexOfLastComponent != -1 && indexOfLastComponent < hierarchicalPath.length() - 1) {\n+            final String lastComponent = hierarchicalPath.substring(indexOfLastComponent + 1);\n+            if (lastComponent.length() > 0) {\n+                final int indexOfLastDot = lastComponent.lastIndexOf('.');\n+                if (indexOfLastDot != -1 && indexOfLastDot < lastComponent.length() - 1) {\n+                    // return a string that includes the leading \".\" to enable easy comparison with the many\n+                    // internal file extension constants we have that include the leading \".\" (i.e., in htsjdk),\n+                    // and also for API consistency (since hasExtension() requires the candidate extension to\n+                    // include a leading \".\", this allows hasExtension(getExtension()) to always work whenever\n+                    // getExtension() succeeds\n+                    return lastComponent.substring(indexOfLastDot);\n+                }\n+            }\n+        }\n+        throw new IllegalArgumentException(String.format(\"Input path (%s) has no extension\", this));\n+    }\n+\n+    /**\n+     * Return true if the path component (the hierarchical part of the scheme specific part of the underlying URI)\n+     * ends with the provided {@code extension} string.\n+     *\n+     * @param extension the target extension to test, INCLUDING the leading \".\". May not be null.\n+     * @return true if the path component of this specifier ends with the extension, otherwise false\n+     */\n+    default boolean hasExtension(final String extension) {\n+        Utils.nonNull(extension, \"Target extension must not be null\");\n+        Utils.validateArg(extension.length() > 1, \"Target extension must be length > 1\");\n+        Utils.validateArg(extension.charAt(0) == '.', \"Target extension must include the leading '.'\");\n+\n+        // We don't want to use {@code #getExtension} here, since it won't work correctly if we're comparing an\n+        // extension that uses multiple . chars, such as .fasta.gz., and {@code #getExtension} will throw if there\n+        // is no extension.\n+        return getURI().getPath().toLowerCase().endsWith(extension.toLowerCase());\n+    }\n+\n+    /**\n+     * @return the base name (the last component of the hierarchical part of the scheme-specific part of the URI,\n+     * after the last \"/\"), up to but not including the extension (the last \".\").\n+     * @throws IllegalArgumentException if the last component is empty (ie, the component ends in \"/\"), or the last\n+     * component exists but starts with \".\"\n+     */\n+    default String getBaseName() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "89bccf032094478b5db0c3f4f8de9b7f1b3fdb8d"}, "originalPosition": 76}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODMwNjY4NQ==", "bodyText": "We might want to prefer returning empty string when the base name/ extension are empty.   (not when they're missing because the file ends in \"/\" though...).", "url": "https://github.com/broadinstitute/gatk/pull/6561#discussion_r428306685", "createdAt": "2020-05-20T21:04:49Z", "author": {"login": "lbergelson"}, "path": "src/main/java/org/broadinstitute/hellbender/engine/PathURI.java", "diffHunk": "@@ -73,6 +76,100 @@ default String getScheme() {\n         return getURI().getScheme();\n     }\n \n+    /**\n+     * @return the extension of the last component of the hierarchical part of the scheme-specific part of the\n+     * URI, if any, including the \".\". Note that this only returns the part of the last component after the last\n+     * \".\", ie. it will return \".gz\" for a name that ends in \".fasta.gz\".\n+     * @throws IllegalArgumentException if the hierarchical name ends with the default file system separator\n+     * (i.e. \"/\") or \".\", or if the last component does not contain a \".\".\n+     */\n+    default String getExtension() {\n+        final String hierarchicalPath = getURI().getPath();\n+        final int indexOfLastComponent = hierarchicalPath.lastIndexOf(FileSystems.getDefault().getSeparator());\n+        if (indexOfLastComponent != -1 && indexOfLastComponent < hierarchicalPath.length() - 1) {\n+            final String lastComponent = hierarchicalPath.substring(indexOfLastComponent + 1);\n+            if (lastComponent.length() > 0) {\n+                final int indexOfLastDot = lastComponent.lastIndexOf('.');\n+                if (indexOfLastDot != -1 && indexOfLastDot < lastComponent.length() - 1) {\n+                    // return a string that includes the leading \".\" to enable easy comparison with the many\n+                    // internal file extension constants we have that include the leading \".\" (i.e., in htsjdk),\n+                    // and also for API consistency (since hasExtension() requires the candidate extension to\n+                    // include a leading \".\", this allows hasExtension(getExtension()) to always work whenever\n+                    // getExtension() succeeds\n+                    return lastComponent.substring(indexOfLastDot);\n+                }\n+            }\n+        }\n+        throw new IllegalArgumentException(String.format(\"Input path (%s) has no extension\", this));\n+    }\n+\n+    /**\n+     * Return true if the path component (the hierarchical part of the scheme specific part of the underlying URI)\n+     * ends with the provided {@code extension} string.\n+     *\n+     * @param extension the target extension to test, INCLUDING the leading \".\". May not be null.\n+     * @return true if the path component of this specifier ends with the extension, otherwise false\n+     */\n+    default boolean hasExtension(final String extension) {\n+        Utils.nonNull(extension, \"Target extension must not be null\");\n+        Utils.validateArg(extension.length() > 1, \"Target extension must be length > 1\");\n+        Utils.validateArg(extension.charAt(0) == '.', \"Target extension must include the leading '.'\");\n+\n+        // We don't want to use {@code #getExtension} here, since it won't work correctly if we're comparing an\n+        // extension that uses multiple . chars, such as .fasta.gz., and {@code #getExtension} will throw if there\n+        // is no extension.\n+        return getURI().getPath().toLowerCase().endsWith(extension.toLowerCase());\n+    }\n+\n+    /**\n+     * @return the base name (the last component of the hierarchical part of the scheme-specific part of the URI,\n+     * after the last \"/\"), up to but not including the extension (the last \".\").\n+     * @throws IllegalArgumentException if the last component is empty (ie, the component ends in \"/\"), or the last\n+     * component exists but starts with \".\"\n+     */\n+    default String getBaseName() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODI5OTM0Nw=="}, "originalCommit": {"oid": "89bccf032094478b5db0c3f4f8de9b7f1b3fdb8d"}, "originalPosition": 76}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY2NzQ0MTkzOnYy", "diffSide": "RIGHT", "path": "src/main/java/org/broadinstitute/hellbender/engine/PathURI.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMFQyMDo1MTozN1rOGYdW-w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yN1QxOToxNTo1M1rOGbZmXA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODMwMDAyNw==", "bodyText": "Is this problematic with files that are at the root of the directory structure or with relative paths that don't include any path above the filename?", "url": "https://github.com/broadinstitute/gatk/pull/6561#discussion_r428300027", "createdAt": "2020-05-20T20:51:37Z", "author": {"login": "lbergelson"}, "path": "src/main/java/org/broadinstitute/hellbender/engine/PathURI.java", "diffHunk": "@@ -73,6 +76,100 @@ default String getScheme() {\n         return getURI().getScheme();\n     }\n \n+    /**\n+     * @return the extension of the last component of the hierarchical part of the scheme-specific part of the\n+     * URI, if any, including the \".\". Note that this only returns the part of the last component after the last\n+     * \".\", ie. it will return \".gz\" for a name that ends in \".fasta.gz\".\n+     * @throws IllegalArgumentException if the hierarchical name ends with the default file system separator\n+     * (i.e. \"/\") or \".\", or if the last component does not contain a \".\".\n+     */\n+    default String getExtension() {\n+        final String hierarchicalPath = getURI().getPath();\n+        final int indexOfLastComponent = hierarchicalPath.lastIndexOf(FileSystems.getDefault().getSeparator());\n+        if (indexOfLastComponent != -1 && indexOfLastComponent < hierarchicalPath.length() - 1) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "89bccf032094478b5db0c3f4f8de9b7f1b3fdb8d"}, "originalPosition": 35}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTM4NDE1Ng==", "bodyText": "I don't think it is. The underlying URI always has a scheme with an (possibly empty) auth, and if the scheme is file, the path component is always an absolute path from the root, even if the input string was a relative path. There are tests for such cases, i.e., localFile.bam and /localFile.bam, so I think its ok.", "url": "https://github.com/broadinstitute/gatk/pull/6561#discussion_r431384156", "createdAt": "2020-05-27T19:15:53Z", "author": {"login": "cmnbroad"}, "path": "src/main/java/org/broadinstitute/hellbender/engine/PathURI.java", "diffHunk": "@@ -73,6 +76,100 @@ default String getScheme() {\n         return getURI().getScheme();\n     }\n \n+    /**\n+     * @return the extension of the last component of the hierarchical part of the scheme-specific part of the\n+     * URI, if any, including the \".\". Note that this only returns the part of the last component after the last\n+     * \".\", ie. it will return \".gz\" for a name that ends in \".fasta.gz\".\n+     * @throws IllegalArgumentException if the hierarchical name ends with the default file system separator\n+     * (i.e. \"/\") or \".\", or if the last component does not contain a \".\".\n+     */\n+    default String getExtension() {\n+        final String hierarchicalPath = getURI().getPath();\n+        final int indexOfLastComponent = hierarchicalPath.lastIndexOf(FileSystems.getDefault().getSeparator());\n+        if (indexOfLastComponent != -1 && indexOfLastComponent < hierarchicalPath.length() - 1) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODMwMDAyNw=="}, "originalCommit": {"oid": "89bccf032094478b5db0c3f4f8de9b7f1b3fdb8d"}, "originalPosition": 35}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY2NzQ0ODE4OnYy", "diffSide": "RIGHT", "path": "src/main/java/org/broadinstitute/hellbender/tools/SplitReads.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMFQyMDo1MzozN1rOGYdbDA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yN1QxOToxOToxOFrOGbZzOw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODMwMTA2OA==", "bodyText": "Should we mark this as a todo when we get resolve methods on GATKPathSpecifier directly?", "url": "https://github.com/broadinstitute/gatk/pull/6561#discussion_r428301068", "createdAt": "2020-05-20T20:53:37Z", "author": {"login": "lbergelson"}, "path": "src/main/java/org/broadinstitute/hellbender/tools/SplitReads.java", "diffHunk": "@@ -146,20 +143,15 @@ private SAMFileGATKReadWriter createUnknownOutOnDemand(String attributeValue) {\n             // attribute for which a given read/group has no value; anything else indicates a coding error\n             throw new GATKException.ShouldNeverReachHereException(\"Unrecognized attribute value found: \" + attributeValue);\n         }\n-        final SAMFileWriterFactory samFileWriterFactory = new SAMFileWriterFactory();\n-        final SAMFileHeader samFileHeaderIn = getHeaderForReads();\n-\n-        return prepareSAMFileWriter(samFileWriterFactory, samFileHeaderIn, attributeValue);\n+        return prepareSAMFileWriter(attributeValue);\n     }\n \n     //  Create a new output file and prepare and return the corresponding SAMFileGATKReadWriter.\n-    private SAMFileGATKReadWriter prepareSAMFileWriter(\n-            SAMFileWriterFactory samFileWriterFactory,\n-            SAMFileHeader samFileHeaderIn,\n-            final String keyName) {\n-        final String base = FilenameUtils.getBaseName(readArguments.getReadPathSpecifiers().get(0).getURI().getSchemeSpecificPart());\n-        final String extension = \".\" + FilenameUtils.getExtension(readArguments.getReadPathSpecifiers().get(0).getURI().getSchemeSpecificPart());\n-        final GATKPathSpecifier outFile = new GATKPathSpecifier(new File(OUTPUT_DIRECTORY, base + keyName + extension).getAbsolutePath());\n+    private SAMFileGATKReadWriter prepareSAMFileWriter(final String keyName) {\n+        final GATKPathSpecifier pathSpec = readArguments.getReadPathSpecifiers().get(0);\n+        final GATKPathSpecifier outFile = new GATKPathSpecifier(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "89bccf032094478b5db0c3f4f8de9b7f1b3fdb8d"}, "originalPosition": 57}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTM4NzQ1MQ==", "bodyText": "Added to #6610.", "url": "https://github.com/broadinstitute/gatk/pull/6561#discussion_r431387451", "createdAt": "2020-05-27T19:19:18Z", "author": {"login": "cmnbroad"}, "path": "src/main/java/org/broadinstitute/hellbender/tools/SplitReads.java", "diffHunk": "@@ -146,20 +143,15 @@ private SAMFileGATKReadWriter createUnknownOutOnDemand(String attributeValue) {\n             // attribute for which a given read/group has no value; anything else indicates a coding error\n             throw new GATKException.ShouldNeverReachHereException(\"Unrecognized attribute value found: \" + attributeValue);\n         }\n-        final SAMFileWriterFactory samFileWriterFactory = new SAMFileWriterFactory();\n-        final SAMFileHeader samFileHeaderIn = getHeaderForReads();\n-\n-        return prepareSAMFileWriter(samFileWriterFactory, samFileHeaderIn, attributeValue);\n+        return prepareSAMFileWriter(attributeValue);\n     }\n \n     //  Create a new output file and prepare and return the corresponding SAMFileGATKReadWriter.\n-    private SAMFileGATKReadWriter prepareSAMFileWriter(\n-            SAMFileWriterFactory samFileWriterFactory,\n-            SAMFileHeader samFileHeaderIn,\n-            final String keyName) {\n-        final String base = FilenameUtils.getBaseName(readArguments.getReadPathSpecifiers().get(0).getURI().getSchemeSpecificPart());\n-        final String extension = \".\" + FilenameUtils.getExtension(readArguments.getReadPathSpecifiers().get(0).getURI().getSchemeSpecificPart());\n-        final GATKPathSpecifier outFile = new GATKPathSpecifier(new File(OUTPUT_DIRECTORY, base + keyName + extension).getAbsolutePath());\n+    private SAMFileGATKReadWriter prepareSAMFileWriter(final String keyName) {\n+        final GATKPathSpecifier pathSpec = readArguments.getReadPathSpecifiers().get(0);\n+        final GATKPathSpecifier outFile = new GATKPathSpecifier(", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODMwMTA2OA=="}, "originalCommit": {"oid": "89bccf032094478b5db0c3f4f8de9b7f1b3fdb8d"}, "originalPosition": 57}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY2NzQ2MzY1OnYy", "diffSide": "RIGHT", "path": "src/test/java/org/broadinstitute/hellbender/engine/GATKPathSpecifierUnitTest.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMFQyMDo1ODozMFrOGYdk9A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNlQyMTo0Njo1MlrOGaxcYQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODMwMzYwNA==", "bodyText": "Maybe this is inconsistent, but we should allow a basename to not have an extension.  localFile's base name is just \"localFile\" I think.", "url": "https://github.com/broadinstitute/gatk/pull/6561#discussion_r428303604", "createdAt": "2020-05-20T20:58:30Z", "author": {"login": "lbergelson"}, "path": "src/test/java/org/broadinstitute/hellbender/engine/GATKPathSpecifierUnitTest.java", "diffHunk": "@@ -286,6 +287,173 @@ public void testStdOut() throws IOException {\n         }\n     }\n \n+    @DataProvider(name = \"getExtensionTestCases\")\n+    public Object[][] getExtensionTestCases() {\n+        return new Object[][] {\n+                // input, extension\n+                {\"localFile.bam\", \".bam\"},\n+                {\"localFile.BAM\", \".BAM\"},\n+                {\"/localFile.bam\", \".bam\"},\n+                {\"gs://bucket/aFile.bam\", \".bam\"},\n+                {\"gs://hellbender/test/resources/aFile.adam\", \".adam\"},\n+                {\"gs://hellbender/test/resources/aFile.fasta\", \".fasta\"},\n+                {\"http://bucket/aFile.bam?query=param\", \".bam\"},\n+\n+                // getExtension() returns \".gz\", but this case also satisfies hasExtension(\".fasta.gz\")\n+                {\"aFile.fasta.gz\", \".gz\"},\n+                // basename is \".fasta\"!\n+                {\".fasta.gz\", \".gz\"},\n+        };\n+    }\n+\n+    @Test(dataProvider = \"getExtensionTestCases\")\n+    public void testGetExtension(final String spec, final String expectedExtension) {\n+        final GATKPathSpecifier pathSpec = new GATKPathSpecifier(spec);\n+        final String actualExtension = pathSpec.getExtension();\n+\n+        Assert.assertEquals(actualExtension, expectedExtension);\n+        // verify that hasExtension(getExtension()) is always true\n+        Assert.assertTrue(pathSpec.hasExtension(actualExtension));\n+    }\n+\n+    @DataProvider(name=\"negativeGetExtensionTestCases\")\n+    public Object[][] negativeGetExtensionTestCases() {\n+        return new Object[][]{\n+                // no extensions\n+                {\"\"},\n+                {\"/\"},\n+                {\".\"},\n+                {\"localFile\"},\n+                {\"localFile.\"},\n+                {\"/localFile.\"},\n+                {\"gs://hellbender/test/resources\"},\n+                {\"gs://hellbender/test/resources?query=param\"},\n+                {\"gs://hellbender/test/resources/\"},\n+                {\"gs://hellbender/test/resources/?query=param\"},\n+        };\n+    }\n+\n+    @Test(dataProvider = \"negativeGetExtensionTestCases\", expectedExceptions={IllegalArgumentException.class})\n+    public void testNegativeGetExtension(final String spec) {\n+        new GATKPathSpecifier(spec).getExtension();\n+    }\n+\n+    @DataProvider(name = \"hasExtensionTestCases\")\n+    public Object[][] hasExtensionTestCases() {\n+        return new Object[][]{\n+                // input, extension satisfies \"hasExtension\"\n+                {\"localFile.bam\", \".bam\", true },\n+                {\"localFile.BAM\", \".BAM\", true },\n+                {\"localFile.BAM\", \".bam\", true },\n+                {\"localFile.bam\", \".BAM\", true },\n+                {\"/localFile.bam\", \".bam\", true },\n+                {\"gs://bucket/aFile.bam\", \".bam\", true },\n+                {\"gs://hellbender/test/resources/aFile.adam\", \".adam\", true },\n+                {\"gs://hellbender/test/resources/aFile.fasta\", \".fasta\", true },\n+                {\"http://bucket/aFile.bam?query=param\", \".bam\", true },\n+\n+                {\"aFile.fasta.gz\", \".gz\", true },\n+                {\"aFile.fasta.gz\", \".fasta.gz\", true },\n+                // basename is \".fasta\"!\n+                {\".fasta.gz\", \".gz\", true },\n+                {\".fasta.gz\", \".fasta.gz\", true },\n+\n+                // no extensions\n+                {\"/\", \".ext\", false },\n+                {\".\", \".ext\", false },\n+                {\"localFile\", \".a\", false }, // extension must have length > 1\n+                {\"localFile.\", \".a\", false },\n+                {\"gs://hellbender/test/resources\", \".fasta\", false },\n+                {\"gs://hellbender/test/resources?query=param\", \".fasta\", false },\n+                {\"gs://hellbender/test/resources/\", \".fasta\", false },\n+                {\"gs://hellbender/test/resources/?query=param\", \".fasta\", false },\n+        };\n+    }\n+\n+    @Test(dataProvider = \"hasExtensionTestCases\")\n+    public void testHasExtension(final String spec, final String extension, final boolean expectedResult) {\n+        Assert.assertEquals(new GATKPathSpecifier(spec).hasExtension(extension), expectedResult);\n+    }\n+\n+    @DataProvider(name = \"getBaseNameTestCases\")\n+    public Object[][] getBaseNameTestCases() {\n+        return new Object[][] {\n+                // input, baseName\n+                {\"localFile.bam\", \"localFile\"},\n+                {\"localFile.BAM\", \"localFile\"},\n+                {\"/localFile.bam\", \"localFile\"},\n+                {\"gs://bucket/aFile.bam\", \"aFile\"},\n+                {\"gs://hellbender/test/resources/aFile.adam\", \"aFile\"},\n+                {\"gs://hellbender/test/resources/aFile.fasta\", \"aFile\"},\n+                {\"http://bucket/aFile.bam?query=param\", \"aFile\"},\n+\n+                // This case satisfies hasExtension(\".fasta.gz\"), but getExtension() returns \".gz\".\n+                {\"aFile.fasta.gz\", \"aFile.fasta\"},\n+                // basename is \".fasta\"!\n+                {\".fasta.gz\", \".fasta\",},\n+        };\n+    }\n+\n+    @Test(dataProvider = \"getBaseNameTestCases\")\n+    public void testGetBaseName(final String spec, final String baseName) {\n+        Assert.assertEquals(new GATKPathSpecifier(spec).getBaseName(), baseName);\n+    }\n+\n+    @DataProvider(name=\"negativeGetBaseNameTestCases\")\n+    public Object[][] negativeGetBaseNameTestCases() {\n+        return new Object[][]{\n+                // no extensions\n+                {\"/\"},\n+                {\".\"},\n+                {\"/.\"},\n+                {\"/name/.fasta\"},\n+                {\"localFile\"},\n+                {\"gs://hellbender/test/resources\"},", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "89bccf032094478b5db0c3f4f8de9b7f1b3fdb8d"}, "originalPosition": 160}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDcyNjI0MQ==", "bodyText": "Makes sense. Done.", "url": "https://github.com/broadinstitute/gatk/pull/6561#discussion_r430726241", "createdAt": "2020-05-26T21:46:52Z", "author": {"login": "cmnbroad"}, "path": "src/test/java/org/broadinstitute/hellbender/engine/GATKPathSpecifierUnitTest.java", "diffHunk": "@@ -286,6 +287,173 @@ public void testStdOut() throws IOException {\n         }\n     }\n \n+    @DataProvider(name = \"getExtensionTestCases\")\n+    public Object[][] getExtensionTestCases() {\n+        return new Object[][] {\n+                // input, extension\n+                {\"localFile.bam\", \".bam\"},\n+                {\"localFile.BAM\", \".BAM\"},\n+                {\"/localFile.bam\", \".bam\"},\n+                {\"gs://bucket/aFile.bam\", \".bam\"},\n+                {\"gs://hellbender/test/resources/aFile.adam\", \".adam\"},\n+                {\"gs://hellbender/test/resources/aFile.fasta\", \".fasta\"},\n+                {\"http://bucket/aFile.bam?query=param\", \".bam\"},\n+\n+                // getExtension() returns \".gz\", but this case also satisfies hasExtension(\".fasta.gz\")\n+                {\"aFile.fasta.gz\", \".gz\"},\n+                // basename is \".fasta\"!\n+                {\".fasta.gz\", \".gz\"},\n+        };\n+    }\n+\n+    @Test(dataProvider = \"getExtensionTestCases\")\n+    public void testGetExtension(final String spec, final String expectedExtension) {\n+        final GATKPathSpecifier pathSpec = new GATKPathSpecifier(spec);\n+        final String actualExtension = pathSpec.getExtension();\n+\n+        Assert.assertEquals(actualExtension, expectedExtension);\n+        // verify that hasExtension(getExtension()) is always true\n+        Assert.assertTrue(pathSpec.hasExtension(actualExtension));\n+    }\n+\n+    @DataProvider(name=\"negativeGetExtensionTestCases\")\n+    public Object[][] negativeGetExtensionTestCases() {\n+        return new Object[][]{\n+                // no extensions\n+                {\"\"},\n+                {\"/\"},\n+                {\".\"},\n+                {\"localFile\"},\n+                {\"localFile.\"},\n+                {\"/localFile.\"},\n+                {\"gs://hellbender/test/resources\"},\n+                {\"gs://hellbender/test/resources?query=param\"},\n+                {\"gs://hellbender/test/resources/\"},\n+                {\"gs://hellbender/test/resources/?query=param\"},\n+        };\n+    }\n+\n+    @Test(dataProvider = \"negativeGetExtensionTestCases\", expectedExceptions={IllegalArgumentException.class})\n+    public void testNegativeGetExtension(final String spec) {\n+        new GATKPathSpecifier(spec).getExtension();\n+    }\n+\n+    @DataProvider(name = \"hasExtensionTestCases\")\n+    public Object[][] hasExtensionTestCases() {\n+        return new Object[][]{\n+                // input, extension satisfies \"hasExtension\"\n+                {\"localFile.bam\", \".bam\", true },\n+                {\"localFile.BAM\", \".BAM\", true },\n+                {\"localFile.BAM\", \".bam\", true },\n+                {\"localFile.bam\", \".BAM\", true },\n+                {\"/localFile.bam\", \".bam\", true },\n+                {\"gs://bucket/aFile.bam\", \".bam\", true },\n+                {\"gs://hellbender/test/resources/aFile.adam\", \".adam\", true },\n+                {\"gs://hellbender/test/resources/aFile.fasta\", \".fasta\", true },\n+                {\"http://bucket/aFile.bam?query=param\", \".bam\", true },\n+\n+                {\"aFile.fasta.gz\", \".gz\", true },\n+                {\"aFile.fasta.gz\", \".fasta.gz\", true },\n+                // basename is \".fasta\"!\n+                {\".fasta.gz\", \".gz\", true },\n+                {\".fasta.gz\", \".fasta.gz\", true },\n+\n+                // no extensions\n+                {\"/\", \".ext\", false },\n+                {\".\", \".ext\", false },\n+                {\"localFile\", \".a\", false }, // extension must have length > 1\n+                {\"localFile.\", \".a\", false },\n+                {\"gs://hellbender/test/resources\", \".fasta\", false },\n+                {\"gs://hellbender/test/resources?query=param\", \".fasta\", false },\n+                {\"gs://hellbender/test/resources/\", \".fasta\", false },\n+                {\"gs://hellbender/test/resources/?query=param\", \".fasta\", false },\n+        };\n+    }\n+\n+    @Test(dataProvider = \"hasExtensionTestCases\")\n+    public void testHasExtension(final String spec, final String extension, final boolean expectedResult) {\n+        Assert.assertEquals(new GATKPathSpecifier(spec).hasExtension(extension), expectedResult);\n+    }\n+\n+    @DataProvider(name = \"getBaseNameTestCases\")\n+    public Object[][] getBaseNameTestCases() {\n+        return new Object[][] {\n+                // input, baseName\n+                {\"localFile.bam\", \"localFile\"},\n+                {\"localFile.BAM\", \"localFile\"},\n+                {\"/localFile.bam\", \"localFile\"},\n+                {\"gs://bucket/aFile.bam\", \"aFile\"},\n+                {\"gs://hellbender/test/resources/aFile.adam\", \"aFile\"},\n+                {\"gs://hellbender/test/resources/aFile.fasta\", \"aFile\"},\n+                {\"http://bucket/aFile.bam?query=param\", \"aFile\"},\n+\n+                // This case satisfies hasExtension(\".fasta.gz\"), but getExtension() returns \".gz\".\n+                {\"aFile.fasta.gz\", \"aFile.fasta\"},\n+                // basename is \".fasta\"!\n+                {\".fasta.gz\", \".fasta\",},\n+        };\n+    }\n+\n+    @Test(dataProvider = \"getBaseNameTestCases\")\n+    public void testGetBaseName(final String spec, final String baseName) {\n+        Assert.assertEquals(new GATKPathSpecifier(spec).getBaseName(), baseName);\n+    }\n+\n+    @DataProvider(name=\"negativeGetBaseNameTestCases\")\n+    public Object[][] negativeGetBaseNameTestCases() {\n+        return new Object[][]{\n+                // no extensions\n+                {\"/\"},\n+                {\".\"},\n+                {\"/.\"},\n+                {\"/name/.fasta\"},\n+                {\"localFile\"},\n+                {\"gs://hellbender/test/resources\"},", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODMwMzYwNA=="}, "originalCommit": {"oid": "89bccf032094478b5db0c3f4f8de9b7f1b3fdb8d"}, "originalPosition": 160}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY2NzQ4MjYzOnYy", "diffSide": "RIGHT", "path": "src/test/java/org/broadinstitute/hellbender/engine/GATKPathSpecifierUnitTest.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMFQyMTowNDo1OFrOGYdxLw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNlQyMTozNToyOFrOGaxI9w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODMwNjczNQ==", "bodyText": "Could you add a test for the case \".\".hasExtension(\".\") ?", "url": "https://github.com/broadinstitute/gatk/pull/6561#discussion_r428306735", "createdAt": "2020-05-20T21:04:58Z", "author": {"login": "lbergelson"}, "path": "src/test/java/org/broadinstitute/hellbender/engine/GATKPathSpecifierUnitTest.java", "diffHunk": "@@ -286,6 +287,173 @@ public void testStdOut() throws IOException {\n         }\n     }\n \n+    @DataProvider(name = \"getExtensionTestCases\")\n+    public Object[][] getExtensionTestCases() {\n+        return new Object[][] {\n+                // input, extension\n+                {\"localFile.bam\", \".bam\"},\n+                {\"localFile.BAM\", \".BAM\"},\n+                {\"/localFile.bam\", \".bam\"},\n+                {\"gs://bucket/aFile.bam\", \".bam\"},\n+                {\"gs://hellbender/test/resources/aFile.adam\", \".adam\"},\n+                {\"gs://hellbender/test/resources/aFile.fasta\", \".fasta\"},\n+                {\"http://bucket/aFile.bam?query=param\", \".bam\"},\n+\n+                // getExtension() returns \".gz\", but this case also satisfies hasExtension(\".fasta.gz\")\n+                {\"aFile.fasta.gz\", \".gz\"},\n+                // basename is \".fasta\"!\n+                {\".fasta.gz\", \".gz\"},\n+        };\n+    }\n+\n+    @Test(dataProvider = \"getExtensionTestCases\")\n+    public void testGetExtension(final String spec, final String expectedExtension) {\n+        final GATKPathSpecifier pathSpec = new GATKPathSpecifier(spec);\n+        final String actualExtension = pathSpec.getExtension();\n+\n+        Assert.assertEquals(actualExtension, expectedExtension);\n+        // verify that hasExtension(getExtension()) is always true\n+        Assert.assertTrue(pathSpec.hasExtension(actualExtension));\n+    }\n+\n+    @DataProvider(name=\"negativeGetExtensionTestCases\")\n+    public Object[][] negativeGetExtensionTestCases() {\n+        return new Object[][]{\n+                // no extensions\n+                {\"\"},\n+                {\"/\"},\n+                {\".\"},\n+                {\"localFile\"},\n+                {\"localFile.\"},\n+                {\"/localFile.\"},\n+                {\"gs://hellbender/test/resources\"},\n+                {\"gs://hellbender/test/resources?query=param\"},\n+                {\"gs://hellbender/test/resources/\"},\n+                {\"gs://hellbender/test/resources/?query=param\"},\n+        };\n+    }\n+\n+    @Test(dataProvider = \"negativeGetExtensionTestCases\", expectedExceptions={IllegalArgumentException.class})\n+    public void testNegativeGetExtension(final String spec) {\n+        new GATKPathSpecifier(spec).getExtension();\n+    }\n+\n+    @DataProvider(name = \"hasExtensionTestCases\")\n+    public Object[][] hasExtensionTestCases() {\n+        return new Object[][]{\n+                // input, extension satisfies \"hasExtension\"\n+                {\"localFile.bam\", \".bam\", true },\n+                {\"localFile.BAM\", \".BAM\", true },\n+                {\"localFile.BAM\", \".bam\", true },\n+                {\"localFile.bam\", \".BAM\", true },\n+                {\"/localFile.bam\", \".bam\", true },\n+                {\"gs://bucket/aFile.bam\", \".bam\", true },\n+                {\"gs://hellbender/test/resources/aFile.adam\", \".adam\", true },\n+                {\"gs://hellbender/test/resources/aFile.fasta\", \".fasta\", true },\n+                {\"http://bucket/aFile.bam?query=param\", \".bam\", true },\n+\n+                {\"aFile.fasta.gz\", \".gz\", true },\n+                {\"aFile.fasta.gz\", \".fasta.gz\", true },\n+                // basename is \".fasta\"!\n+                {\".fasta.gz\", \".gz\", true },\n+                {\".fasta.gz\", \".fasta.gz\", true },\n+\n+                // no extensions\n+                {\"/\", \".ext\", false },\n+                {\".\", \".ext\", false },", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "89bccf032094478b5db0c3f4f8de9b7f1b3fdb8d"}, "originalPosition": 112}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDcyMTI3MQ==", "bodyText": "Hm, it doesn't. \".\" gets turned into a URI with an absolute path that ends in \"/./\".", "url": "https://github.com/broadinstitute/gatk/pull/6561#discussion_r430721271", "createdAt": "2020-05-26T21:35:28Z", "author": {"login": "cmnbroad"}, "path": "src/test/java/org/broadinstitute/hellbender/engine/GATKPathSpecifierUnitTest.java", "diffHunk": "@@ -286,6 +287,173 @@ public void testStdOut() throws IOException {\n         }\n     }\n \n+    @DataProvider(name = \"getExtensionTestCases\")\n+    public Object[][] getExtensionTestCases() {\n+        return new Object[][] {\n+                // input, extension\n+                {\"localFile.bam\", \".bam\"},\n+                {\"localFile.BAM\", \".BAM\"},\n+                {\"/localFile.bam\", \".bam\"},\n+                {\"gs://bucket/aFile.bam\", \".bam\"},\n+                {\"gs://hellbender/test/resources/aFile.adam\", \".adam\"},\n+                {\"gs://hellbender/test/resources/aFile.fasta\", \".fasta\"},\n+                {\"http://bucket/aFile.bam?query=param\", \".bam\"},\n+\n+                // getExtension() returns \".gz\", but this case also satisfies hasExtension(\".fasta.gz\")\n+                {\"aFile.fasta.gz\", \".gz\"},\n+                // basename is \".fasta\"!\n+                {\".fasta.gz\", \".gz\"},\n+        };\n+    }\n+\n+    @Test(dataProvider = \"getExtensionTestCases\")\n+    public void testGetExtension(final String spec, final String expectedExtension) {\n+        final GATKPathSpecifier pathSpec = new GATKPathSpecifier(spec);\n+        final String actualExtension = pathSpec.getExtension();\n+\n+        Assert.assertEquals(actualExtension, expectedExtension);\n+        // verify that hasExtension(getExtension()) is always true\n+        Assert.assertTrue(pathSpec.hasExtension(actualExtension));\n+    }\n+\n+    @DataProvider(name=\"negativeGetExtensionTestCases\")\n+    public Object[][] negativeGetExtensionTestCases() {\n+        return new Object[][]{\n+                // no extensions\n+                {\"\"},\n+                {\"/\"},\n+                {\".\"},\n+                {\"localFile\"},\n+                {\"localFile.\"},\n+                {\"/localFile.\"},\n+                {\"gs://hellbender/test/resources\"},\n+                {\"gs://hellbender/test/resources?query=param\"},\n+                {\"gs://hellbender/test/resources/\"},\n+                {\"gs://hellbender/test/resources/?query=param\"},\n+        };\n+    }\n+\n+    @Test(dataProvider = \"negativeGetExtensionTestCases\", expectedExceptions={IllegalArgumentException.class})\n+    public void testNegativeGetExtension(final String spec) {\n+        new GATKPathSpecifier(spec).getExtension();\n+    }\n+\n+    @DataProvider(name = \"hasExtensionTestCases\")\n+    public Object[][] hasExtensionTestCases() {\n+        return new Object[][]{\n+                // input, extension satisfies \"hasExtension\"\n+                {\"localFile.bam\", \".bam\", true },\n+                {\"localFile.BAM\", \".BAM\", true },\n+                {\"localFile.BAM\", \".bam\", true },\n+                {\"localFile.bam\", \".BAM\", true },\n+                {\"/localFile.bam\", \".bam\", true },\n+                {\"gs://bucket/aFile.bam\", \".bam\", true },\n+                {\"gs://hellbender/test/resources/aFile.adam\", \".adam\", true },\n+                {\"gs://hellbender/test/resources/aFile.fasta\", \".fasta\", true },\n+                {\"http://bucket/aFile.bam?query=param\", \".bam\", true },\n+\n+                {\"aFile.fasta.gz\", \".gz\", true },\n+                {\"aFile.fasta.gz\", \".fasta.gz\", true },\n+                // basename is \".fasta\"!\n+                {\".fasta.gz\", \".gz\", true },\n+                {\".fasta.gz\", \".fasta.gz\", true },\n+\n+                // no extensions\n+                {\"/\", \".ext\", false },\n+                {\".\", \".ext\", false },", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODMwNjczNQ=="}, "originalCommit": {"oid": "89bccf032094478b5db0c3f4f8de9b7f1b3fdb8d"}, "originalPosition": 112}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY2NzQ4Mzk4OnYy", "diffSide": "RIGHT", "path": "src/test/java/org/broadinstitute/hellbender/engine/GATKPathSpecifierUnitTest.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMFQyMTowNToyNFrOGYdx-Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNlQyMTo1MzowNFrOGaxmWA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODMwNjkzNw==", "bodyText": "Should we simple tests for isSam, isBam, is Cram ?", "url": "https://github.com/broadinstitute/gatk/pull/6561#discussion_r428306937", "createdAt": "2020-05-20T21:05:24Z", "author": {"login": "lbergelson"}, "path": "src/test/java/org/broadinstitute/hellbender/engine/GATKPathSpecifierUnitTest.java", "diffHunk": "@@ -286,6 +287,173 @@ public void testStdOut() throws IOException {\n         }\n     }\n \n+    @DataProvider(name = \"getExtensionTestCases\")\n+    public Object[][] getExtensionTestCases() {\n+        return new Object[][] {\n+                // input, extension\n+                {\"localFile.bam\", \".bam\"},\n+                {\"localFile.BAM\", \".BAM\"},\n+                {\"/localFile.bam\", \".bam\"},\n+                {\"gs://bucket/aFile.bam\", \".bam\"},\n+                {\"gs://hellbender/test/resources/aFile.adam\", \".adam\"},\n+                {\"gs://hellbender/test/resources/aFile.fasta\", \".fasta\"},\n+                {\"http://bucket/aFile.bam?query=param\", \".bam\"},\n+\n+                // getExtension() returns \".gz\", but this case also satisfies hasExtension(\".fasta.gz\")\n+                {\"aFile.fasta.gz\", \".gz\"},\n+                // basename is \".fasta\"!\n+                {\".fasta.gz\", \".gz\"},\n+        };\n+    }\n+\n+    @Test(dataProvider = \"getExtensionTestCases\")\n+    public void testGetExtension(final String spec, final String expectedExtension) {\n+        final GATKPathSpecifier pathSpec = new GATKPathSpecifier(spec);\n+        final String actualExtension = pathSpec.getExtension();\n+\n+        Assert.assertEquals(actualExtension, expectedExtension);\n+        // verify that hasExtension(getExtension()) is always true\n+        Assert.assertTrue(pathSpec.hasExtension(actualExtension));\n+    }\n+\n+    @DataProvider(name=\"negativeGetExtensionTestCases\")\n+    public Object[][] negativeGetExtensionTestCases() {\n+        return new Object[][]{\n+                // no extensions\n+                {\"\"},\n+                {\"/\"},\n+                {\".\"},\n+                {\"localFile\"},\n+                {\"localFile.\"},\n+                {\"/localFile.\"},\n+                {\"gs://hellbender/test/resources\"},\n+                {\"gs://hellbender/test/resources?query=param\"},\n+                {\"gs://hellbender/test/resources/\"},\n+                {\"gs://hellbender/test/resources/?query=param\"},\n+        };\n+    }\n+\n+    @Test(dataProvider = \"negativeGetExtensionTestCases\", expectedExceptions={IllegalArgumentException.class})\n+    public void testNegativeGetExtension(final String spec) {\n+        new GATKPathSpecifier(spec).getExtension();\n+    }\n+\n+    @DataProvider(name = \"hasExtensionTestCases\")\n+    public Object[][] hasExtensionTestCases() {\n+        return new Object[][]{\n+                // input, extension satisfies \"hasExtension\"\n+                {\"localFile.bam\", \".bam\", true },\n+                {\"localFile.BAM\", \".BAM\", true },\n+                {\"localFile.BAM\", \".bam\", true },\n+                {\"localFile.bam\", \".BAM\", true },\n+                {\"/localFile.bam\", \".bam\", true },\n+                {\"gs://bucket/aFile.bam\", \".bam\", true },\n+                {\"gs://hellbender/test/resources/aFile.adam\", \".adam\", true },\n+                {\"gs://hellbender/test/resources/aFile.fasta\", \".fasta\", true },\n+                {\"http://bucket/aFile.bam?query=param\", \".bam\", true },\n+\n+                {\"aFile.fasta.gz\", \".gz\", true },\n+                {\"aFile.fasta.gz\", \".fasta.gz\", true },\n+                // basename is \".fasta\"!\n+                {\".fasta.gz\", \".gz\", true },\n+                {\".fasta.gz\", \".fasta.gz\", true },\n+\n+                // no extensions\n+                {\"/\", \".ext\", false },\n+                {\".\", \".ext\", false },\n+                {\"localFile\", \".a\", false }, // extension must have length > 1\n+                {\"localFile.\", \".a\", false },\n+                {\"gs://hellbender/test/resources\", \".fasta\", false },\n+                {\"gs://hellbender/test/resources?query=param\", \".fasta\", false },\n+                {\"gs://hellbender/test/resources/\", \".fasta\", false },\n+                {\"gs://hellbender/test/resources/?query=param\", \".fasta\", false },\n+        };\n+    }\n+\n+    @Test(dataProvider = \"hasExtensionTestCases\")\n+    public void testHasExtension(final String spec, final String extension, final boolean expectedResult) {\n+        Assert.assertEquals(new GATKPathSpecifier(spec).hasExtension(extension), expectedResult);\n+    }\n+\n+    @DataProvider(name = \"getBaseNameTestCases\")\n+    public Object[][] getBaseNameTestCases() {\n+        return new Object[][] {\n+                // input, baseName\n+                {\"localFile.bam\", \"localFile\"},\n+                {\"localFile.BAM\", \"localFile\"},\n+                {\"/localFile.bam\", \"localFile\"},\n+                {\"gs://bucket/aFile.bam\", \"aFile\"},\n+                {\"gs://hellbender/test/resources/aFile.adam\", \"aFile\"},\n+                {\"gs://hellbender/test/resources/aFile.fasta\", \"aFile\"},\n+                {\"http://bucket/aFile.bam?query=param\", \"aFile\"},\n+\n+                // This case satisfies hasExtension(\".fasta.gz\"), but getExtension() returns \".gz\".\n+                {\"aFile.fasta.gz\", \"aFile.fasta\"},\n+                // basename is \".fasta\"!\n+                {\".fasta.gz\", \".fasta\",},\n+        };\n+    }\n+\n+    @Test(dataProvider = \"getBaseNameTestCases\")\n+    public void testGetBaseName(final String spec, final String baseName) {\n+        Assert.assertEquals(new GATKPathSpecifier(spec).getBaseName(), baseName);\n+    }\n+\n+    @DataProvider(name=\"negativeGetBaseNameTestCases\")\n+    public Object[][] negativeGetBaseNameTestCases() {\n+        return new Object[][]{\n+                // no extensions\n+                {\"/\"},\n+                {\".\"},\n+                {\"/.\"},\n+                {\"/name/.fasta\"},\n+                {\"localFile\"},\n+                {\"gs://hellbender/test/resources\"},\n+                {\"gs://hellbender/test/resources?query=param\"},\n+                {\"gs://hellbender/test/resources/\"},\n+                {\"gs://hellbender/test/resources/?query=param\"},\n+        };\n+    }\n+\n+    @Test(dataProvider = \"negativeGetBaseNameTestCases\", expectedExceptions = {IllegalArgumentException.class})\n+    public void testNegativeGetBaseName(final String spec) {\n+        new GATKPathSpecifier(spec).getBaseName();\n+    }\n+\n+    @DataProvider(name=\"isFastaTestCases\")\n+    public Object[][] isFastaTestCases() {\n+        final String twoBitRefURL = publicTestDir + \"large/human_g1k_v37.20.21.2bit\";\n+        return new Object[][] {\n+                { twoBitRefURL, false },\n+                { \"file://\" + twoBitRefURL, false },\n+                { hg38Reference, true }, // gzipped\n+                { \"file://\" + hg38Reference, true }, // gzipped\n+                { GCS_b37_CHR20_21_REFERENCE_2BIT, false },\n+                { GCS_b37_CHR20_21_REFERENCE, true },\n+                // dummy query params at the end to make sure URI.getPath does the right thing\n+                { GCS_b37_CHR20_21_REFERENCE + \"?query=param\", true}\n+        };\n+    }\n+\n+    @Test(dataProvider = \"isFastaTestCases\")\n+    public void testIsFasta(final String referenceSpec, final boolean expectedIsFasta) {\n+        Assert.assertEquals(new GATKPathSpecifier(referenceSpec).isFasta(), expectedIsFasta);\n+    }\n+\n+    @DataProvider(name=\"isHadoopURLTestCases\")\n+    public Object[][] isHadoopURLTestCases() {\n+        return new Object[][] {\n+                { GATKPathSpecifier.HDFS_SCHEME + \"://someFile\", true },\n+                { \"file://someFile.bam\", false },\n+                { \"someFile.bam\", false },\n+        };\n+    }\n+\n+    @Test(dataProvider = \"isHadoopURLTestCases\")\n+    public void testIsHadoopURL(final String referenceSpec, final boolean expectedIsHadoop) {\n+        Assert.assertEquals(new GATKPathSpecifier(referenceSpec).isHadoopURL(), expectedIsHadoop);\n+    }\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "89bccf032094478b5db0c3f4f8de9b7f1b3fdb8d"}, "originalPosition": 205}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDcyODc5Mg==", "bodyText": "We've come this far so, yes.", "url": "https://github.com/broadinstitute/gatk/pull/6561#discussion_r430728792", "createdAt": "2020-05-26T21:53:04Z", "author": {"login": "cmnbroad"}, "path": "src/test/java/org/broadinstitute/hellbender/engine/GATKPathSpecifierUnitTest.java", "diffHunk": "@@ -286,6 +287,173 @@ public void testStdOut() throws IOException {\n         }\n     }\n \n+    @DataProvider(name = \"getExtensionTestCases\")\n+    public Object[][] getExtensionTestCases() {\n+        return new Object[][] {\n+                // input, extension\n+                {\"localFile.bam\", \".bam\"},\n+                {\"localFile.BAM\", \".BAM\"},\n+                {\"/localFile.bam\", \".bam\"},\n+                {\"gs://bucket/aFile.bam\", \".bam\"},\n+                {\"gs://hellbender/test/resources/aFile.adam\", \".adam\"},\n+                {\"gs://hellbender/test/resources/aFile.fasta\", \".fasta\"},\n+                {\"http://bucket/aFile.bam?query=param\", \".bam\"},\n+\n+                // getExtension() returns \".gz\", but this case also satisfies hasExtension(\".fasta.gz\")\n+                {\"aFile.fasta.gz\", \".gz\"},\n+                // basename is \".fasta\"!\n+                {\".fasta.gz\", \".gz\"},\n+        };\n+    }\n+\n+    @Test(dataProvider = \"getExtensionTestCases\")\n+    public void testGetExtension(final String spec, final String expectedExtension) {\n+        final GATKPathSpecifier pathSpec = new GATKPathSpecifier(spec);\n+        final String actualExtension = pathSpec.getExtension();\n+\n+        Assert.assertEquals(actualExtension, expectedExtension);\n+        // verify that hasExtension(getExtension()) is always true\n+        Assert.assertTrue(pathSpec.hasExtension(actualExtension));\n+    }\n+\n+    @DataProvider(name=\"negativeGetExtensionTestCases\")\n+    public Object[][] negativeGetExtensionTestCases() {\n+        return new Object[][]{\n+                // no extensions\n+                {\"\"},\n+                {\"/\"},\n+                {\".\"},\n+                {\"localFile\"},\n+                {\"localFile.\"},\n+                {\"/localFile.\"},\n+                {\"gs://hellbender/test/resources\"},\n+                {\"gs://hellbender/test/resources?query=param\"},\n+                {\"gs://hellbender/test/resources/\"},\n+                {\"gs://hellbender/test/resources/?query=param\"},\n+        };\n+    }\n+\n+    @Test(dataProvider = \"negativeGetExtensionTestCases\", expectedExceptions={IllegalArgumentException.class})\n+    public void testNegativeGetExtension(final String spec) {\n+        new GATKPathSpecifier(spec).getExtension();\n+    }\n+\n+    @DataProvider(name = \"hasExtensionTestCases\")\n+    public Object[][] hasExtensionTestCases() {\n+        return new Object[][]{\n+                // input, extension satisfies \"hasExtension\"\n+                {\"localFile.bam\", \".bam\", true },\n+                {\"localFile.BAM\", \".BAM\", true },\n+                {\"localFile.BAM\", \".bam\", true },\n+                {\"localFile.bam\", \".BAM\", true },\n+                {\"/localFile.bam\", \".bam\", true },\n+                {\"gs://bucket/aFile.bam\", \".bam\", true },\n+                {\"gs://hellbender/test/resources/aFile.adam\", \".adam\", true },\n+                {\"gs://hellbender/test/resources/aFile.fasta\", \".fasta\", true },\n+                {\"http://bucket/aFile.bam?query=param\", \".bam\", true },\n+\n+                {\"aFile.fasta.gz\", \".gz\", true },\n+                {\"aFile.fasta.gz\", \".fasta.gz\", true },\n+                // basename is \".fasta\"!\n+                {\".fasta.gz\", \".gz\", true },\n+                {\".fasta.gz\", \".fasta.gz\", true },\n+\n+                // no extensions\n+                {\"/\", \".ext\", false },\n+                {\".\", \".ext\", false },\n+                {\"localFile\", \".a\", false }, // extension must have length > 1\n+                {\"localFile.\", \".a\", false },\n+                {\"gs://hellbender/test/resources\", \".fasta\", false },\n+                {\"gs://hellbender/test/resources?query=param\", \".fasta\", false },\n+                {\"gs://hellbender/test/resources/\", \".fasta\", false },\n+                {\"gs://hellbender/test/resources/?query=param\", \".fasta\", false },\n+        };\n+    }\n+\n+    @Test(dataProvider = \"hasExtensionTestCases\")\n+    public void testHasExtension(final String spec, final String extension, final boolean expectedResult) {\n+        Assert.assertEquals(new GATKPathSpecifier(spec).hasExtension(extension), expectedResult);\n+    }\n+\n+    @DataProvider(name = \"getBaseNameTestCases\")\n+    public Object[][] getBaseNameTestCases() {\n+        return new Object[][] {\n+                // input, baseName\n+                {\"localFile.bam\", \"localFile\"},\n+                {\"localFile.BAM\", \"localFile\"},\n+                {\"/localFile.bam\", \"localFile\"},\n+                {\"gs://bucket/aFile.bam\", \"aFile\"},\n+                {\"gs://hellbender/test/resources/aFile.adam\", \"aFile\"},\n+                {\"gs://hellbender/test/resources/aFile.fasta\", \"aFile\"},\n+                {\"http://bucket/aFile.bam?query=param\", \"aFile\"},\n+\n+                // This case satisfies hasExtension(\".fasta.gz\"), but getExtension() returns \".gz\".\n+                {\"aFile.fasta.gz\", \"aFile.fasta\"},\n+                // basename is \".fasta\"!\n+                {\".fasta.gz\", \".fasta\",},\n+        };\n+    }\n+\n+    @Test(dataProvider = \"getBaseNameTestCases\")\n+    public void testGetBaseName(final String spec, final String baseName) {\n+        Assert.assertEquals(new GATKPathSpecifier(spec).getBaseName(), baseName);\n+    }\n+\n+    @DataProvider(name=\"negativeGetBaseNameTestCases\")\n+    public Object[][] negativeGetBaseNameTestCases() {\n+        return new Object[][]{\n+                // no extensions\n+                {\"/\"},\n+                {\".\"},\n+                {\"/.\"},\n+                {\"/name/.fasta\"},\n+                {\"localFile\"},\n+                {\"gs://hellbender/test/resources\"},\n+                {\"gs://hellbender/test/resources?query=param\"},\n+                {\"gs://hellbender/test/resources/\"},\n+                {\"gs://hellbender/test/resources/?query=param\"},\n+        };\n+    }\n+\n+    @Test(dataProvider = \"negativeGetBaseNameTestCases\", expectedExceptions = {IllegalArgumentException.class})\n+    public void testNegativeGetBaseName(final String spec) {\n+        new GATKPathSpecifier(spec).getBaseName();\n+    }\n+\n+    @DataProvider(name=\"isFastaTestCases\")\n+    public Object[][] isFastaTestCases() {\n+        final String twoBitRefURL = publicTestDir + \"large/human_g1k_v37.20.21.2bit\";\n+        return new Object[][] {\n+                { twoBitRefURL, false },\n+                { \"file://\" + twoBitRefURL, false },\n+                { hg38Reference, true }, // gzipped\n+                { \"file://\" + hg38Reference, true }, // gzipped\n+                { GCS_b37_CHR20_21_REFERENCE_2BIT, false },\n+                { GCS_b37_CHR20_21_REFERENCE, true },\n+                // dummy query params at the end to make sure URI.getPath does the right thing\n+                { GCS_b37_CHR20_21_REFERENCE + \"?query=param\", true}\n+        };\n+    }\n+\n+    @Test(dataProvider = \"isFastaTestCases\")\n+    public void testIsFasta(final String referenceSpec, final boolean expectedIsFasta) {\n+        Assert.assertEquals(new GATKPathSpecifier(referenceSpec).isFasta(), expectedIsFasta);\n+    }\n+\n+    @DataProvider(name=\"isHadoopURLTestCases\")\n+    public Object[][] isHadoopURLTestCases() {\n+        return new Object[][] {\n+                { GATKPathSpecifier.HDFS_SCHEME + \"://someFile\", true },\n+                { \"file://someFile.bam\", false },\n+                { \"someFile.bam\", false },\n+        };\n+    }\n+\n+    @Test(dataProvider = \"isHadoopURLTestCases\")\n+    public void testIsHadoopURL(final String referenceSpec, final boolean expectedIsHadoop) {\n+        Assert.assertEquals(new GATKPathSpecifier(referenceSpec).isHadoopURL(), expectedIsHadoop);\n+    }\n+", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODMwNjkzNw=="}, "originalCommit": {"oid": "89bccf032094478b5db0c3f4f8de9b7f1b3fdb8d"}, "originalPosition": 205}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1186, "cost": 1, "resetAt": "2021-11-12T13:16:51Z"}}}