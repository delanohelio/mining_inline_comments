{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTE2OTE0MDUy", "number": 6943, "title": "Fixed a bug where overlapping reads in subsequent regions can have invalid base qualities", "bodyText": "This fixes the test that was accidentally disabled (when we added a flag for overlapping read adjustment we forgot to set it correctly for the test) and reinstated something like the code from #4926. It should now necessarily be the case that the finalize() method calls read.copy() at least once for every read (though many multiples of once are still quite possible).\nFixes #6882", "createdAt": "2020-11-06T18:36:16Z", "url": "https://github.com/broadinstitute/gatk/pull/6943", "merged": true, "mergeCommit": {"oid": "3be2f38740544dc11b20217245619a31430e9d08"}, "closed": true, "closedAt": "2020-11-24T20:33:55Z", "author": {"login": "jamesemery"}, "timelineItems": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdZ7VtNgH2gAyNTE2OTE0MDUyOjdjMzgyNDJkYzczODQyOGNlYjYzZmQ3Y2I5N2JlNTZiYmMzZjExNjU=", "endCursor": "Y3Vyc29yOnYyOpPPAAABdfv1iPAFqTUzNzg4MTU1OA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "7c38242dc738428ceb63fd7cb97be56bbc3f1165", "author": {"user": {"login": "jamesemery", "name": null}}, "url": "https://github.com/broadinstitute/gatk/commit/7c38242dc738428ceb63fd7cb97be56bbc3f1165", "committedDate": "2020-11-06T18:33:27Z", "message": "Added a hack involving transient attributes to make sure everything gets coppied without doing it again for every read"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTI1NDA2NzM0", "url": "https://github.com/broadinstitute/gatk/pull/6943#pullrequestreview-525406734", "createdAt": "2020-11-06T18:46:42Z", "commit": {"oid": "7c38242dc738428ceb63fd7cb97be56bbc3f1165"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNlQxODo0Njo0MlrOHu5f5A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNlQxODo0Njo0MlrOHu5f5A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODkzODU5Ng==", "bodyText": "Instead of relying on transient attributes (which, in my opinion, is brittle and a recipe for future problems), compare the memory address of the read pre/post clipping, and make a copy only if the address hasn't changed, as in the original patch in #4926. Rewrite this method to use a loop instead of streaming, if necessary.", "url": "https://github.com/broadinstitute/gatk/pull/6943#discussion_r518938596", "createdAt": "2020-11-06T18:46:42Z", "author": {"login": "droazen"}, "path": "src/main/java/org/broadinstitute/hellbender/tools/walkers/haplotypecaller/AssemblyBasedCallerUtils.java", "diffHunk": "@@ -114,6 +118,9 @@ public static void finalizeRegion(final AssemblyRegion region,\n                 .filter(read ->  !read.isEmpty() && read.getCigar().getReadLength() > 0)\n                 .map(read -> ReadClipper.hardClipToRegion(read, region.getPaddedSpan().getStart(), region.getPaddedSpan().getEnd() ))\n                 .filter(read -> read.getStart() <= read.getEnd() && read.getLength() > 0 && read.overlaps(region.getPaddedSpan()))\n+                // The transient attribute is preserved across copy operations and all of the previous alterations make copies, this simple ensures\n+                // that any reads that have not been copied along the way are copied here for safety.\n+                .map(read -> (read.getTransientAttribute(\"Original\") != read? read : read.copy()))", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7c38242dc738428ceb63fd7cb97be56bbc3f1165"}, "originalPosition": 17}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a55a266569dce93ecf0024ee962ca25fbd6fc3c3", "author": {"user": {"login": "jamesemery", "name": null}}, "url": "https://github.com/broadinstitute/gatk/commit/a55a266569dce93ecf0024ee962ca25fbd6fc3c3", "committedDate": "2020-11-06T19:50:13Z", "message": "no more transient attributes..."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTM0Njk1NjEw", "url": "https://github.com/broadinstitute/gatk/pull/6943#pullrequestreview-534695610", "createdAt": "2020-11-19T17:42:15Z", "commit": {"oid": "a55a266569dce93ecf0024ee962ca25fbd6fc3c3"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOVQxNzo0MjoxNVrOH2qP_Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOVQxNzo0Mjo0MFrOH2qRFA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzA3NzM3Mw==", "bodyText": "The copy() method performs a shallow copy -- it ends up calling SAMRecord.clone(), which copies all fields in the SAMRecord as if by assignment (the exception is the attributes array, which is explicitly copied). So the byte[] arrays for the bases and quals point to the same memory location in the copy as in the original. Is this a problem? Do we later modify the bases/quals in-place somewhere, or do we always copy the bases/quals arrays due to the defensive copies in SAMRecordToGATKReadAdapter?", "url": "https://github.com/broadinstitute/gatk/pull/6943#discussion_r527077373", "createdAt": "2020-11-19T17:42:15Z", "author": {"login": "droazen"}, "path": "src/main/java/org/broadinstitute/hellbender/tools/walkers/haplotypecaller/AssemblyBasedCallerUtils.java", "diffHunk": "@@ -102,20 +102,31 @@ public static void finalizeRegion(final AssemblyRegion region,\n         }\n \n         final byte minTailQualityToUse = errorCorrectReads ? HaplotypeCallerEngine.MIN_TAIL_QUALITY_WITH_ERROR_CORRECTION : minTailQuality;\n-        final List<GATKRead> readsToUse = region.getReads().stream()\n-                // TODO unclipping soft clips may introduce bases that aren't in the extended region if the unclipped bases\n-                // TODO include a deletion w.r.t. the reference.  We must remove kmers that occur before the reference haplotype start\n-                .map(read -> dontUseSoftClippedBases || ! ReadUtils.hasWellDefinedFragmentSize(read) ?\n-                    ReadClipper.hardClipSoftClippedBases(read) : ReadClipper.revertSoftClippedBases(read))\n-                .map(read -> softClipLowQualityEnds ? ReadClipper.softClipLowQualEnds(read, minTailQualityToUse) :\n-                        ReadClipper.hardClipLowQualEnds(read, minTailQualityToUse))\n-                .filter(read -> read.getStart() <= read.getEnd())\n-                .map(read -> read.isUnmapped() ? read : ReadClipper.hardClipAdaptorSequence(read))\n-                .filter(read ->  !read.isEmpty() && read.getCigar().getReadLength() > 0)\n-                .map(read -> ReadClipper.hardClipToRegion(read, region.getPaddedSpan().getStart(), region.getPaddedSpan().getEnd() ))\n-                .filter(read -> read.getStart() <= read.getEnd() && read.getLength() > 0 && read.overlaps(region.getPaddedSpan()))\n-                .sorted(new ReadCoordinateComparator(readsHeader)) // TODO: sort may be unnecessary here\n-                .collect(Collectors.toList());\n+\n+        final List<GATKRead> readsToUse = new ArrayList<>();\n+        for (GATKRead originalRead : region.getReads()) {\n+            // TODO unclipping soft clips may introduce bases that aren't in the extended region if the unclipped bases\n+            // TODO include a deletion w.r.t. the reference.  We must remove kmers that occur before the reference haplotype start\n+            GATKRead read = (dontUseSoftClippedBases || ! ReadUtils.hasWellDefinedFragmentSize(originalRead) ?\n+                    ReadClipper.hardClipSoftClippedBases(originalRead) : ReadClipper.revertSoftClippedBases(originalRead));\n+            read = (softClipLowQualityEnds ? ReadClipper.softClipLowQualEnds(read, minTailQualityToUse) :\n+                    ReadClipper.hardClipLowQualEnds(read, minTailQualityToUse));\n+\n+            if (read.getStart() <= read.getEnd()) {\n+                read = (read.isUnmapped() ? read : ReadClipper.hardClipAdaptorSequence(read));\n+\n+                if (!read.isEmpty() && read.getCigar().getReadLength() > 0) {\n+                    read = ReadClipper.hardClipToRegion(read, region.getPaddedSpan().getStart(), region.getPaddedSpan().getEnd() );\n+\n+                    if (read.getStart() <= read.getEnd() && read.getLength() > 0 && read.overlaps(region.getPaddedSpan())) {\n+                        // NOTE: here we make a defensive copy of the read if it has not been modified by the above operations\n+                        // which might only make copies in the case that the read is actually clipped\n+                        readsToUse.add(read == originalRead? read.copy() : read);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a55a266569dce93ecf0024ee962ca25fbd6fc3c3"}, "originalPosition": 37}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzA3NzY1Mg==", "bodyText": "Can you confirm that the modified version of this test fails without the copy() call you added above?", "url": "https://github.com/broadinstitute/gatk/pull/6943#discussion_r527077652", "createdAt": "2020-11-19T17:42:40Z", "author": {"login": "droazen"}, "path": "src/test/java/org/broadinstitute/hellbender/tools/walkers/haplotypecaller/AssemblyBasedCallerUtilsUnitTest.java", "diffHunk": "@@ -64,7 +64,7 @@ public void testfinalizeRegion() {\n         activeRegion.addAll(reads);\n         SampleList sampleList = SampleList.singletonSampleList(\"tumor\");\n         Byte minbq = 9;\n-        AssemblyBasedCallerUtils.finalizeRegion(activeRegion, false, false, minbq, header, sampleList, false, false);\n+        AssemblyBasedCallerUtils.finalizeRegion(activeRegion, false, false, minbq, header, sampleList, true, false);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a55a266569dce93ecf0024ee962ca25fbd6fc3c3"}, "originalPosition": 5}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "62ddfcf02de25aeab3d508c96e044f53f1e76bf2", "author": {"user": {"login": "jamesemery", "name": null}}, "url": "https://github.com/broadinstitute/gatk/commit/62ddfcf02de25aeab3d508c96e044f53f1e76bf2", "committedDate": "2020-11-19T19:21:05Z", "message": "responding to comments by clarifying the tests"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTM3ODgxNTU4", "url": "https://github.com/broadinstitute/gatk/pull/6943#pullrequestreview-537881558", "createdAt": "2020-11-24T20:32:54Z", "commit": {"oid": "62ddfcf02de25aeab3d508c96e044f53f1e76bf2"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2536, "cost": 1, "resetAt": "2021-11-01T13:07:16Z"}}}