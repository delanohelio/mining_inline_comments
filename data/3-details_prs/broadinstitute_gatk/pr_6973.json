{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTI0MjIwNDA4", "number": 6973, "title": "Switch VariantEval to MultiVariantWalkerGroupedOnStart", "bodyText": "@cmnbroad This is related to discussion on issue 5439. This is not a final product yet. I'm opening the PR to see how it works on travis and to push discussion here.\nThis PR is not trying to fix all issues with VariantEval. It's trying to address these:\n\n\nSwitch to MultiVariantWalkerGroupedOnStart, primarily to avoid the constant re-querying of variants per site that took place in VariantEvalUtils.bindVariantContexts(). I believe this will substantially reduce the number of instance in which featureContext.getValues() is called.\n\n\nI tried to move, but not full fix, some of the tight linkage between the VariantEval Walker class and the plugin classes. I also made a VariantEvalArgumentCollection to start separating these. Toward this objective, this PR does: a) makes a VariantEvalContext class, which is what gets passed to the VariantStratifier classes, and b) I try to reduce exposing the walker class directly to VariantStratifier and VariantEvaluator. The latter is not completely done, but I think this is moving it in that direction. At several points I stopped for the sake of keeping changes in one PR manageable.", "createdAt": "2020-11-19T20:42:34Z", "url": "https://github.com/broadinstitute/gatk/pull/6973", "merged": true, "mergeCommit": {"oid": "528ad2a1839f7252b8fa90ae9176a59a442fa4ac"}, "closed": true, "closedAt": "2021-04-30T11:34:11Z", "author": {"login": "bbimber"}, "timelineItems": {"totalCount": 26, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdi_EG7ABqjQwNzQ2NDMwNzA=", "endCursor": "Y3Vyc29yOnYyOpPPAAABeSKObTAFqTY0OTEyNjcxNQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "a0778b8c37a6591d2a422be3f391584a89ca7c92", "author": {"user": {"login": "bbimber", "name": null}}, "url": "https://github.com/broadinstitute/gatk/commit/a0778b8c37a6591d2a422be3f391584a89ca7c92", "committedDate": "2020-11-23T23:08:28Z", "message": "Update test expectations: this test was switch from using a truncated genome to the full genome, since the input data includes variants on other chromosomes. The previous code probably should have errored"}, "afterCommit": {"oid": "a4433f3d7b779a94137b190d309a7a66cd507d1a", "author": {"user": {"login": "bbimber", "name": null}}, "url": "https://github.com/broadinstitute/gatk/commit/a4433f3d7b779a94137b190d309a7a66cd507d1a", "committedDate": "2020-12-04T21:58:33Z", "message": "Switch VariantEval to MultiVariantWalkerGroupedOnStart\n\nAdditional removal of reference to walker\n\nFixes NPE and adds debugging code\n\nIdentify behavior difference between MultiVariantWalkerGroupedOnStart as compared to the old behavior of setting up a whitelist of start sites and then re-querying variants based on those sites.\n\n- Remove debugging code\n- Since MultiVariantWalkerGroupedOnStart requires a reference, make VariantEval require a reference and remove tests related to failing without one\n\nUpdate test expectations related to comp overlaps\n\nUpdate test expectations: this test was switch from using a truncated genome to the full genome, since the input data includes variants on other chromosomes. The previous code probably should have errored"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTU3MDg1MTUz", "url": "https://github.com/broadinstitute/gatk/pull/6973#pullrequestreview-557085153", "createdAt": "2020-12-22T13:39:35Z", "commit": {"oid": "21bb7bfe27232b64a683657d6d046ce8e3f8ead9"}, "state": "COMMENTED", "comments": {"totalCount": 14, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yMlQxMzozOTozNlrOIJ7fuQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yMlQxNjowNDo1MFrOIKAUEw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzI4Mjg3Mw==", "bodyText": "This is somewhat more idiomatic, and only creates ArrayLists when they're needed:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    Map<FeatureInput<VariantContext>, List<VariantContext>> ret = new HashMap<>();\n          \n          \n            \n                    variants.forEach(vc -> {\n          \n          \n            \n                        FeatureInput<VariantContext> fi = sourceMap.get(vc.getSource());\n          \n          \n            \n                        if (fi == null) {\n          \n          \n            \n                            throw new GATKException.ShouldNeverReachHereException(\"Variant could not be mapped to a source: \" + vc);\n          \n          \n            \n                        }\n          \n          \n            \n            \n          \n          \n            \n                        List<VariantContext> l = ret.getOrDefault(fi, new ArrayList<>());\n          \n          \n            \n                        l.add(vc);\n          \n          \n            \n                        ret.put(fi, l);\n          \n          \n            \n                    });\n          \n          \n            \n            \n          \n          \n            \n                    return ret;\n          \n          \n            \n                    final Map<FeatureInput<VariantContext>, List<VariantContext>> byFeatureInput = new HashMap<>();\n          \n          \n            \n                    variants.forEach(vc -> byFeatureInput.compute(sourceMap.get(vc.getSource()),\n          \n          \n            \n                            (k, v) -> {\n          \n          \n            \n                                final List<VariantContext> variantList = v == null ? new ArrayList<>() : v;\n          \n          \n            \n                                variantList.add(vc);\n          \n          \n            \n                                return variantList;\n          \n          \n            \n                            }\n          \n          \n            \n                        ));\n          \n          \n            \n            \n          \n          \n            \n                    return byFeatureInput;", "url": "https://github.com/broadinstitute/gatk/pull/6973#discussion_r547282873", "createdAt": "2020-12-22T13:39:36Z", "author": {"login": "cmnbroad"}, "path": "src/main/java/org/broadinstitute/hellbender/engine/MultiVariantWalkerGroupedOnStart.java", "diffHunk": "@@ -114,6 +116,25 @@ public final void apply(VariantContext variant, ReadsContext readsContext, Refer\n         lastCurrentVariantStart = variant.getStart();\n     }\n \n+    protected Map<FeatureInput<VariantContext>, List<VariantContext>> groupVariantsByFeatureInput(List<VariantContext> variants) {\n+        Map<String, FeatureInput<VariantContext>> sourceMap = new HashMap<>();\n+        getDrivingVariantsFeatureInputs().forEach(x -> sourceMap.put(x.getName(), x));\n+\n+        Map<FeatureInput<VariantContext>, List<VariantContext>> ret = new HashMap<>();\n+        variants.forEach(vc -> {\n+            FeatureInput<VariantContext> fi = sourceMap.get(vc.getSource());\n+            if (fi == null) {\n+                throw new GATKException.ShouldNeverReachHereException(\"Variant could not be mapped to a source: \" + vc);\n+            }\n+\n+            List<VariantContext> l = ret.getOrDefault(fi, new ArrayList<>());\n+            l.add(vc);\n+            ret.put(fi, l);\n+        });\n+\n+        return ret;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "21bb7bfe27232b64a683657d6d046ce8e3f8ead9"}, "originalPosition": 40}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzI4NDE5Nw==", "bodyText": "variants param should be final", "url": "https://github.com/broadinstitute/gatk/pull/6973#discussion_r547284197", "createdAt": "2020-12-22T13:42:25Z", "author": {"login": "cmnbroad"}, "path": "src/main/java/org/broadinstitute/hellbender/engine/MultiVariantWalkerGroupedOnStart.java", "diffHunk": "@@ -114,6 +116,25 @@ public final void apply(VariantContext variant, ReadsContext readsContext, Refer\n         lastCurrentVariantStart = variant.getStart();\n     }\n \n+    protected Map<FeatureInput<VariantContext>, List<VariantContext>> groupVariantsByFeatureInput(List<VariantContext> variants) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "21bb7bfe27232b64a683657d6d046ce8e3f8ead9"}, "originalPosition": 24}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzI4NDI0OA==", "bodyText": "This (return) type should be replaced with a class that can be used in its place. If as you indicated in your comments you can't do that for some reason, then this method should be pushed down as private into VariantEval so it doesn't proliferate as part of MultiVariantWalkerGroupedOnStart.", "url": "https://github.com/broadinstitute/gatk/pull/6973#discussion_r547284248", "createdAt": "2020-12-22T13:42:32Z", "author": {"login": "cmnbroad"}, "path": "src/main/java/org/broadinstitute/hellbender/engine/MultiVariantWalkerGroupedOnStart.java", "diffHunk": "@@ -114,6 +116,25 @@ public final void apply(VariantContext variant, ReadsContext readsContext, Refer\n         lastCurrentVariantStart = variant.getStart();\n     }\n \n+    protected Map<FeatureInput<VariantContext>, List<VariantContext>> groupVariantsByFeatureInput(List<VariantContext> variants) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzI4NDE5Nw=="}, "originalCommit": {"oid": "21bb7bfe27232b64a683657d6d046ce8e3f8ead9"}, "originalPosition": 24}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzI4NTk5OA==", "bodyText": "This map should be precomputed once on start, and cached.", "url": "https://github.com/broadinstitute/gatk/pull/6973#discussion_r547285998", "createdAt": "2020-12-22T13:46:08Z", "author": {"login": "cmnbroad"}, "path": "src/main/java/org/broadinstitute/hellbender/engine/MultiVariantWalkerGroupedOnStart.java", "diffHunk": "@@ -114,6 +116,25 @@ public final void apply(VariantContext variant, ReadsContext readsContext, Refer\n         lastCurrentVariantStart = variant.getStart();\n     }\n \n+    protected Map<FeatureInput<VariantContext>, List<VariantContext>> groupVariantsByFeatureInput(List<VariantContext> variants) {\n+        Map<String, FeatureInput<VariantContext>> sourceMap = new HashMap<>();\n+        getDrivingVariantsFeatureInputs().forEach(x -> sourceMap.put(x.getName(), x));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "21bb7bfe27232b64a683657d6d046ce8e3f8ead9"}, "originalPosition": 26}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzMzMTIyMg==", "bodyText": "Argument collection classes are intended to be standalone containers for argument declarations that can be used in other tools/contexts. These tool inputs (evals, comps, goldStandard, knowns) depend on code in VariantEval that prevents them from being treated as driving variants. Is moving these into the arg collection, necessary or can that be deferred to a subsequent PR when we have an VariantEvalEngine class ?", "url": "https://github.com/broadinstitute/gatk/pull/6973#discussion_r547331222", "createdAt": "2020-12-22T15:10:22Z", "author": {"login": "cmnbroad"}, "path": "src/main/java/org/broadinstitute/hellbender/tools/walkers/varianteval/VariantEval.java", "diffHunk": "@@ -126,125 +123,27 @@\n )\n @DocumentedFeature\n @BetaFeature\n-public class VariantEval extends MultiVariantWalker {\n+public class VariantEval extends MultiVariantWalkerGroupedOnStart {\n     public static final String IS_SINGLETON_KEY = \"ISSINGLETON\";\n \n     @Argument(fullName = StandardArgumentDefinitions.OUTPUT_LONG_NAME,\n             shortName = StandardArgumentDefinitions.OUTPUT_SHORT_NAME,\n             doc=\"File to which variants should be written\")\n     protected File outFile;\n \n-    /**\n-     * The variant file(s) to evaluate.\n-     */\n-    @Argument(fullName=\"eval\", shortName = \"eval\", doc=\"Input evaluation file(s)\", optional=false)\n-    public List<FeatureInput<VariantContext>> evals;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "21bb7bfe27232b64a683657d6d046ce8e3f8ead9"}, "originalPosition": 62}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzMzNzk1MA==", "bodyText": "This needs an access modifier; private if possible. This one also has a getter now, though thats hopefully temporary.", "url": "https://github.com/broadinstitute/gatk/pull/6973#discussion_r547337950", "createdAt": "2020-12-22T15:22:42Z", "author": {"login": "cmnbroad"}, "path": "src/main/java/org/broadinstitute/hellbender/tools/walkers/varianteval/VariantEval.java", "diffHunk": "@@ -126,125 +123,27 @@\n )\n @DocumentedFeature\n @BetaFeature\n-public class VariantEval extends MultiVariantWalker {\n+public class VariantEval extends MultiVariantWalkerGroupedOnStart {\n     public static final String IS_SINGLETON_KEY = \"ISSINGLETON\";\n \n     @Argument(fullName = StandardArgumentDefinitions.OUTPUT_LONG_NAME,\n             shortName = StandardArgumentDefinitions.OUTPUT_SHORT_NAME,\n             doc=\"File to which variants should be written\")\n     protected File outFile;\n \n-    /**\n-     * The variant file(s) to evaluate.\n-     */\n-    @Argument(fullName=\"eval\", shortName = \"eval\", doc=\"Input evaluation file(s)\", optional=false)\n-    public List<FeatureInput<VariantContext>> evals;\n-\n-    /**\n-     * The variant file(s) to compare against.\n-     */\n-    @Argument(fullName = StandardArgumentDefinitions.COMPARISON_LONG_NAME, shortName = StandardArgumentDefinitions.COMPARISON_SHORT_NAME, doc=\"Input comparison file(s)\", optional=true)\n-    public List<FeatureInput<VariantContext>> compsProvided = new ArrayList<>();\n-    private List<FeatureInput<VariantContext>> comps = new ArrayList<>();\n-\n-    /**\n-     * dbSNP comparison VCF.  By default, the dbSNP file is used to specify the set of \"known\" variants.\n-     * Other sets can be specified with the -known-name (--known_names) argument.\n-     */\n     @ArgumentCollection\n-    protected DbsnpArgumentCollection dbsnp = new DbsnpArgumentCollection();\n-\n-    /**\n-     * Some analyses want to count overlap not with dbSNP (which is in general very open) but\n-     * actually want to itemize their overlap specifically with a set of gold standard sites\n-     * such as HapMap, OMNI, or the gold standard indels.  This argument provides a mechanism\n-     * for communicating which file to use\n-     */\n-    @Argument(fullName=\"gold-standard\", shortName = \"gold\", doc=\"Evaluations that count calls at sites of true variation (e.g., indel calls) will use this argument as their gold standard for comparison\", optional=true)\n-    public FeatureInput<VariantContext> goldStandard = null;\n+    VariantEvalArgumentCollection variantEvalArgs = new VariantEvalArgumentCollection();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "21bb7bfe27232b64a683657d6d046ce8e3f8ead9"}, "originalPosition": 86}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzM0ODgxNg==", "bodyText": "Where we're changing code anyway, we might as well use a symbolic name for these lambda args.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    variantEvalArgs.compsProvided.forEach(x -> inputToNameMap.put(x, x.hasUserSuppliedName() ? x.getName() : StandardArgumentDefinitions.COMPARISON_SHORT_NAME));\n          \n          \n            \n                    variantEvalArgs.compsProvided.forEach(comp -> inputToNameMap.put(comp, comp.hasUserSuppliedName() ? comp.getName() : StandardArgumentDefinitions.COMPARISON_SHORT_NAME));", "url": "https://github.com/broadinstitute/gatk/pull/6973#discussion_r547348816", "createdAt": "2020-12-22T15:41:30Z", "author": {"login": "cmnbroad"}, "path": "src/main/java/org/broadinstitute/hellbender/tools/walkers/varianteval/VariantEval.java", "diffHunk": "@@ -318,60 +213,60 @@ public void onTraversalStart() {\n \n         sampleDB = initializeSampleDB();\n \n-        comps.addAll(compsProvided);\n-        compsProvided.forEach(x -> inputToNameMap.put(x, x.hasUserSuppliedName() ? x.getName() : StandardArgumentDefinitions.COMPARISON_SHORT_NAME));\n-        if ( dbsnp.dbsnp != null ) {\n-            comps.add(dbsnp.dbsnp);\n-            inputToNameMap.put(dbsnp.dbsnp, \"dbsnp\");\n-            knowns.add(dbsnp.dbsnp);\n+        variantEvalArgs.comps.addAll(variantEvalArgs.compsProvided);\n+        variantEvalArgs.compsProvided.forEach(x -> inputToNameMap.put(x, x.hasUserSuppliedName() ? x.getName() : StandardArgumentDefinitions.COMPARISON_SHORT_NAME));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "21bb7bfe27232b64a683657d6d046ce8e3f8ead9"}, "originalPosition": 237}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzM0OTY3NA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    variantEvalArgs.evals.forEach(x -> inputToNameMap.put(x, x.hasUserSuppliedName() ? x.getName() : \"eval\"));\n          \n          \n            \n                    variantEvalArgs.evals.forEach(eval -> inputToNameMap.put(eval, eval.hasUserSuppliedName() ? eval.getName() : \"eval\"));```", "url": "https://github.com/broadinstitute/gatk/pull/6973#discussion_r547349674", "createdAt": "2020-12-22T15:43:04Z", "author": {"login": "cmnbroad"}, "path": "src/main/java/org/broadinstitute/hellbender/tools/walkers/varianteval/VariantEval.java", "diffHunk": "@@ -318,60 +213,60 @@ public void onTraversalStart() {\n \n         sampleDB = initializeSampleDB();\n \n-        comps.addAll(compsProvided);\n-        compsProvided.forEach(x -> inputToNameMap.put(x, x.hasUserSuppliedName() ? x.getName() : StandardArgumentDefinitions.COMPARISON_SHORT_NAME));\n-        if ( dbsnp.dbsnp != null ) {\n-            comps.add(dbsnp.dbsnp);\n-            inputToNameMap.put(dbsnp.dbsnp, \"dbsnp\");\n-            knowns.add(dbsnp.dbsnp);\n+        variantEvalArgs.comps.addAll(variantEvalArgs.compsProvided);\n+        variantEvalArgs.compsProvided.forEach(x -> inputToNameMap.put(x, x.hasUserSuppliedName() ? x.getName() : StandardArgumentDefinitions.COMPARISON_SHORT_NAME));\n+        if ( variantEvalArgs.dbsnp.dbsnp != null ) {\n+            variantEvalArgs.comps.add(variantEvalArgs.dbsnp.dbsnp);\n+            inputToNameMap.put(variantEvalArgs.dbsnp.dbsnp, \"dbsnp\");\n+            variantEvalArgs.knowns.add(variantEvalArgs.dbsnp.dbsnp);\n         }\n \n-        evals.forEach(x -> inputToNameMap.put(x, x.hasUserSuppliedName() ? x.getName() : \"eval\"));\n+        variantEvalArgs.evals.forEach(x -> inputToNameMap.put(x, x.hasUserSuppliedName() ? x.getName() : \"eval\"));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "21bb7bfe27232b64a683657d6d046ce8e3f8ead9"}, "originalPosition": 245}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzM1MDIyNg==", "bodyText": "Same here.", "url": "https://github.com/broadinstitute/gatk/pull/6973#discussion_r547350226", "createdAt": "2020-12-22T15:44:00Z", "author": {"login": "cmnbroad"}, "path": "src/main/java/org/broadinstitute/hellbender/tools/walkers/varianteval/VariantEval.java", "diffHunk": "@@ -318,60 +213,60 @@ public void onTraversalStart() {\n \n         sampleDB = initializeSampleDB();\n \n-        comps.addAll(compsProvided);\n-        compsProvided.forEach(x -> inputToNameMap.put(x, x.hasUserSuppliedName() ? x.getName() : StandardArgumentDefinitions.COMPARISON_SHORT_NAME));\n-        if ( dbsnp.dbsnp != null ) {\n-            comps.add(dbsnp.dbsnp);\n-            inputToNameMap.put(dbsnp.dbsnp, \"dbsnp\");\n-            knowns.add(dbsnp.dbsnp);\n+        variantEvalArgs.comps.addAll(variantEvalArgs.compsProvided);\n+        variantEvalArgs.compsProvided.forEach(x -> inputToNameMap.put(x, x.hasUserSuppliedName() ? x.getName() : StandardArgumentDefinitions.COMPARISON_SHORT_NAME));\n+        if ( variantEvalArgs.dbsnp.dbsnp != null ) {\n+            variantEvalArgs.comps.add(variantEvalArgs.dbsnp.dbsnp);\n+            inputToNameMap.put(variantEvalArgs.dbsnp.dbsnp, \"dbsnp\");\n+            variantEvalArgs.knowns.add(variantEvalArgs.dbsnp.dbsnp);\n         }\n \n-        evals.forEach(x -> inputToNameMap.put(x, x.hasUserSuppliedName() ? x.getName() : \"eval\"));\n+        variantEvalArgs.evals.forEach(x -> inputToNameMap.put(x, x.hasUserSuppliedName() ? x.getName() : \"eval\"));\n \n-        // Set up set of additional knowns\n-        for ( FeatureInput<VariantContext> compInput : comps ) {\n-            if ( KNOWN_NAMES.contains(getNameForInput(compInput)))\n-                knowns.add(compInput);\n+        // Set up set of additional knowns. dbSNP was addressed above, so use compsProvided, not comps\n+        for ( FeatureInput<VariantContext> compInput : variantEvalArgs.compsProvided ) {\n+            if (variantEvalArgs.KNOWN_NAMES.contains(getNameForInput(compInput)))\n+                variantEvalArgs.knowns.add(compInput);\n         }\n \n         // Now that we have all the inputs categorized, determine the sample list from the eval inputs.\n         Map<String, VCFHeader> vcfInputs = new HashMap<>();\n-        evals.forEach(x -> vcfInputs.put(x.getName(), (VCFHeader)getHeaderForFeatures(x)));\n+        variantEvalArgs.evals.forEach(x -> vcfInputs.put(x.getName(), (VCFHeader)getHeaderForFeatures(x)));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "21bb7bfe27232b64a683657d6d046ce8e3f8ead9"}, "originalPosition": 260}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzM1MjcwMQ==", "bodyText": "So long, PositionAggregator.", "url": "https://github.com/broadinstitute/gatk/pull/6973#discussion_r547352701", "createdAt": "2020-12-22T15:48:32Z", "author": {"login": "cmnbroad"}, "path": "src/main/java/org/broadinstitute/hellbender/tools/walkers/varianteval/VariantEval.java", "diffHunk": "@@ -466,66 +361,41 @@ protected EvaluationContext createEvaluationContext(final Set<Class<? extends Va\n         return new EvaluationContext(this, evaluationObjects);\n     }\n \n-    private class PositionAggregator {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "21bb7bfe27232b64a683657d6d046ce8e3f8ead9"}, "originalPosition": 335}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzM1MjkwNA==", "bodyText": "final", "url": "https://github.com/broadinstitute/gatk/pull/6973#discussion_r547352904", "createdAt": "2020-12-22T15:48:50Z", "author": {"login": "cmnbroad"}, "path": "src/main/java/org/broadinstitute/hellbender/tools/walkers/varianteval/VariantEval.java", "diffHunk": "@@ -466,66 +361,41 @@ protected EvaluationContext createEvaluationContext(final Set<Class<? extends Va\n         return new EvaluationContext(this, evaluationObjects);\n     }\n \n-    private class PositionAggregator {\n-        private SimpleInterval i = null;\n-\n-        private ReadsContext readsContext;\n-        private ReferenceContext referenceContext;\n-        private FeatureContext featureContext;\n-\n-        private void addVariant(VariantContext vc, ReadsContext readsContext, ReferenceContext referenceContext, FeatureContext featureContext) {\n-            if (i == null || !vc.getContig().equals(i.getContig()) || vc.getStart() != i.getStart()) {\n-                callDoApply();\n+    public String getNameForInput(FeatureInput<VariantContext> input) {\n+        return inputToNameMap.get(input);\n+    }\n \n-                i = new SimpleInterval(vc.getContig(), vc.getStart(), vc.getEnd());\n-                this.readsContext = readsContext;\n-                this.referenceContext = referenceContext;\n-                this.featureContext = featureContext;\n-            }\n-            else if (vc.getEnd() > i.getEnd()) {\n-                //expand region\n-                i = new SimpleInterval(i.getContig(), i.getStart(), vc.getEnd());\n+    @Override\n+    public void apply(List<VariantContext> variantContexts, ReferenceContext referenceContext, List<ReadsContext> readsContexts) {\n+        Map<FeatureInput<VariantContext>, List<VariantContext>> variantMap = groupVariantsByFeatureInput(variantContexts);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "21bb7bfe27232b64a683657d6d046ce8e3f8ead9"}, "originalPosition": 359}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzM1NDkxMQ==", "bodyText": "The comment doesn't match the declaration. These should just be public statics, without the getter, and the comment should be fixed.", "url": "https://github.com/broadinstitute/gatk/pull/6973#discussion_r547354911", "createdAt": "2020-12-22T15:52:28Z", "author": {"login": "cmnbroad"}, "path": "src/main/java/org/broadinstitute/hellbender/tools/walkers/varianteval/VariantEvalArgumentCollection.java", "diffHunk": "@@ -0,0 +1,149 @@\n+package org.broadinstitute.hellbender.tools.walkers.varianteval;\n+\n+import htsjdk.tribble.Feature;\n+import htsjdk.variant.variantcontext.VariantContext;\n+import org.broadinstitute.barclay.argparser.Argument;\n+import org.broadinstitute.barclay.argparser.ArgumentCollection;\n+import org.broadinstitute.hellbender.cmdline.StandardArgumentDefinitions;\n+import org.broadinstitute.hellbender.cmdline.argumentcollections.DbsnpArgumentCollection;\n+import org.broadinstitute.hellbender.engine.FeatureInput;\n+import org.broadinstitute.hellbender.engine.GATKPath;\n+import org.broadinstitute.hellbender.utils.variant.GATKVariantContextUtils;\n+\n+import java.io.File;\n+import java.util.*;\n+\n+/**\n+ * The collection of arguments for VariantEval\n+ */\n+public class VariantEvalArgumentCollection {\n+\n+    // Public constants\n+    final protected static String ALL_SAMPLE_NAME = \"all\";\n+    final protected static String ALL_FAMILY_NAME = \"all\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "21bb7bfe27232b64a683657d6d046ce8e3f8ead9"}, "originalPosition": 23}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzM1OTM2Mg==", "bodyText": "The access modifiers for all of the args in this class should be made consistent (there seems to be a mix of protected, package protected, and public access, and some are public with public getters). I'd suggest just using public with no getters.", "url": "https://github.com/broadinstitute/gatk/pull/6973#discussion_r547359362", "createdAt": "2020-12-22T16:00:15Z", "author": {"login": "cmnbroad"}, "path": "src/main/java/org/broadinstitute/hellbender/tools/walkers/varianteval/VariantEvalArgumentCollection.java", "diffHunk": "@@ -0,0 +1,149 @@\n+package org.broadinstitute.hellbender.tools.walkers.varianteval;\n+\n+import htsjdk.tribble.Feature;\n+import htsjdk.variant.variantcontext.VariantContext;\n+import org.broadinstitute.barclay.argparser.Argument;\n+import org.broadinstitute.barclay.argparser.ArgumentCollection;\n+import org.broadinstitute.hellbender.cmdline.StandardArgumentDefinitions;\n+import org.broadinstitute.hellbender.cmdline.argumentcollections.DbsnpArgumentCollection;\n+import org.broadinstitute.hellbender.engine.FeatureInput;\n+import org.broadinstitute.hellbender.engine.GATKPath;\n+import org.broadinstitute.hellbender.utils.variant.GATKVariantContextUtils;\n+\n+import java.io.File;\n+import java.util.*;\n+\n+/**\n+ * The collection of arguments for VariantEval\n+ */\n+public class VariantEvalArgumentCollection {\n+\n+    // Public constants\n+    final protected static String ALL_SAMPLE_NAME = \"all\";\n+    final protected static String ALL_FAMILY_NAME = \"all\";\n+\n+    /**\n+     * The variant file(s) to evaluate.\n+     */\n+    @Argument(fullName=\"eval\", shortName = \"eval\", doc=\"Input evaluation file(s)\", optional=false)\n+    public List<FeatureInput<VariantContext>> evals;\n+\n+    /**\n+     * The variant file(s) to compare against.\n+     */\n+    @Argument(fullName = StandardArgumentDefinitions.COMPARISON_LONG_NAME, shortName = StandardArgumentDefinitions.COMPARISON_SHORT_NAME, doc=\"Input comparison file(s)\", optional=true)\n+    public List<FeatureInput<VariantContext>> compsProvided = new ArrayList<>();\n+    public List<FeatureInput<VariantContext>> comps = new ArrayList<>();\n+\n+    /**\n+     * dbSNP comparison VCF.  By default, the dbSNP file is used to specify the set of \"known\" variants.\n+     * Other sets can be specified with the -known-name (--known_names) argument.\n+     */\n+    @ArgumentCollection\n+    protected DbsnpArgumentCollection dbsnp = new DbsnpArgumentCollection();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "21bb7bfe27232b64a683657d6d046ce8e3f8ead9"}, "originalPosition": 43}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzM2MTgxMQ==", "bodyText": "All of the all caps variable names in this file should be changed to camel case (IntelliJ will change all call sites automatically for you: right click -> refactor -> rename).", "url": "https://github.com/broadinstitute/gatk/pull/6973#discussion_r547361811", "createdAt": "2020-12-22T16:04:50Z", "author": {"login": "cmnbroad"}, "path": "src/main/java/org/broadinstitute/hellbender/tools/walkers/varianteval/VariantEvalArgumentCollection.java", "diffHunk": "@@ -0,0 +1,149 @@\n+package org.broadinstitute.hellbender.tools.walkers.varianteval;\n+\n+import htsjdk.tribble.Feature;\n+import htsjdk.variant.variantcontext.VariantContext;\n+import org.broadinstitute.barclay.argparser.Argument;\n+import org.broadinstitute.barclay.argparser.ArgumentCollection;\n+import org.broadinstitute.hellbender.cmdline.StandardArgumentDefinitions;\n+import org.broadinstitute.hellbender.cmdline.argumentcollections.DbsnpArgumentCollection;\n+import org.broadinstitute.hellbender.engine.FeatureInput;\n+import org.broadinstitute.hellbender.engine.GATKPath;\n+import org.broadinstitute.hellbender.utils.variant.GATKVariantContextUtils;\n+\n+import java.io.File;\n+import java.util.*;\n+\n+/**\n+ * The collection of arguments for VariantEval\n+ */\n+public class VariantEvalArgumentCollection {\n+\n+    // Public constants\n+    final protected static String ALL_SAMPLE_NAME = \"all\";\n+    final protected static String ALL_FAMILY_NAME = \"all\";\n+\n+    /**\n+     * The variant file(s) to evaluate.\n+     */\n+    @Argument(fullName=\"eval\", shortName = \"eval\", doc=\"Input evaluation file(s)\", optional=false)\n+    public List<FeatureInput<VariantContext>> evals;\n+\n+    /**\n+     * The variant file(s) to compare against.\n+     */\n+    @Argument(fullName = StandardArgumentDefinitions.COMPARISON_LONG_NAME, shortName = StandardArgumentDefinitions.COMPARISON_SHORT_NAME, doc=\"Input comparison file(s)\", optional=true)\n+    public List<FeatureInput<VariantContext>> compsProvided = new ArrayList<>();\n+    public List<FeatureInput<VariantContext>> comps = new ArrayList<>();\n+\n+    /**\n+     * dbSNP comparison VCF.  By default, the dbSNP file is used to specify the set of \"known\" variants.\n+     * Other sets can be specified with the -known-name (--known_names) argument.\n+     */\n+    @ArgumentCollection\n+    protected DbsnpArgumentCollection dbsnp = new DbsnpArgumentCollection();\n+\n+    /**\n+     * Some analyses want to count overlap not with dbSNP (which is in general very open) but\n+     * actually want to itemize their overlap specifically with a set of gold standard sites\n+     * such as HapMap, OMNI, or the gold standard indels.  This argument provides a mechanism\n+     * for communicating which file to use\n+     */\n+    @Argument(fullName=\"gold-standard\", shortName = \"gold\", doc=\"Evaluations that count calls at sites of true variation (e.g., indel calls) will use this argument as their gold standard for comparison\", optional=true)\n+    public FeatureInput<VariantContext> goldStandard = null;\n+\n+    // Partitioning the data arguments\n+    @Argument(shortName=\"select\", doc=\"One or more stratifications to use when evaluating the data\", optional=true)\n+    protected ArrayList<String> SELECT_EXPS = new ArrayList<String>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "21bb7bfe27232b64a683657d6d046ce8e3f8ead9"}, "originalPosition": 56}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "9c1eee5fe262d69e9d6d9d60ce629c64947fc9c7", "author": {"user": {"login": "bbimber", "name": null}}, "url": "https://github.com/broadinstitute/gatk/commit/9c1eee5fe262d69e9d6d9d60ce629c64947fc9c7", "committedDate": "2020-12-23T18:17:33Z", "message": "Refactor VariantEval to create a standalone VariantEvalEngine class"}, "afterCommit": {"oid": "c41c5a740ac9813a2ca3ddde7cb0fd0cb040b6bd", "author": {"user": {"login": "bbimber", "name": null}}, "url": "https://github.com/broadinstitute/gatk/commit/c41c5a740ac9813a2ca3ddde7cb0fd0cb040b6bd", "committedDate": "2020-12-23T18:36:56Z", "message": "Switch VariantEval to MultiVariantWalkerGroupedOnStart\n\nRefactor VariantEval to create a standalone VariantEvalEngine class"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "c41c5a740ac9813a2ca3ddde7cb0fd0cb040b6bd", "author": {"user": {"login": "bbimber", "name": null}}, "url": "https://github.com/broadinstitute/gatk/commit/c41c5a740ac9813a2ca3ddde7cb0fd0cb040b6bd", "committedDate": "2020-12-23T18:36:56Z", "message": "Switch VariantEval to MultiVariantWalkerGroupedOnStart\n\nRefactor VariantEval to create a standalone VariantEvalEngine class"}, "afterCommit": {"oid": "35b969d0158466e6a6ac4130d46f8192136860ee", "author": {"user": {"login": "bbimber", "name": null}}, "url": "https://github.com/broadinstitute/gatk/commit/35b969d0158466e6a6ac4130d46f8192136860ee", "committedDate": "2020-12-23T18:41:08Z", "message": "Switch VariantEval to MultiVariantWalkerGroupedOnStart\n\nRefactor VariantEval to create a standalone VariantEvalEngine class"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "064d84761a46823368c2ceae66cab880d2ead408", "author": {"user": {"login": "bbimber", "name": null}}, "url": "https://github.com/broadinstitute/gatk/commit/064d84761a46823368c2ceae66cab880d2ead408", "committedDate": "2020-12-24T01:39:14Z", "message": "Back out changes to GATKTool since hasReads() is not always accurate during startup and this causes failures for other code"}, "afterCommit": {"oid": "48d87916e7739526294ee39a72c6a1f32694bfde", "author": {"user": {"login": "bbimber", "name": null}}, "url": "https://github.com/broadinstitute/gatk/commit/48d87916e7739526294ee39a72c6a1f32694bfde", "committedDate": "2021-01-04T14:50:52Z", "message": "Switch VariantEval to MultiVariantWalkerGroupedOnStart\n\nRefactor VariantEval to create a standalone VariantEvalEngine class"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTYxMzY0ODMw", "url": "https://github.com/broadinstitute/gatk/pull/6973#pullrequestreview-561364830", "createdAt": "2021-01-04T21:40:59Z", "commit": {"oid": "48d87916e7739526294ee39a72c6a1f32694bfde"}, "state": "COMMENTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNFQyMTo0MTowMFrOIOCDjw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNFQyMTo1OTozOVrOIOCrIw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTU4NDY1NQ==", "bodyText": "This method can be a (non static instance) method on VariantEvalArgumentCollection.", "url": "https://github.com/broadinstitute/gatk/pull/6973#discussion_r551584655", "createdAt": "2021-01-04T21:41:00Z", "author": {"login": "cmnbroad"}, "path": "src/main/java/org/broadinstitute/hellbender/tools/walkers/varianteval/VariantEvalEngine.java", "diffHunk": "@@ -0,0 +1,940 @@\n+package org.broadinstitute.hellbender.tools.walkers.varianteval;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import htsjdk.samtools.SAMSequenceDictionary;\n+import htsjdk.samtools.reference.IndexedFastaSequenceFile;\n+import htsjdk.samtools.reference.ReferenceSequenceFile;\n+import htsjdk.tribble.Feature;\n+import htsjdk.variant.variantcontext.Allele;\n+import htsjdk.variant.variantcontext.VariantContext;\n+import htsjdk.variant.variantcontext.VariantContextBuilder;\n+import htsjdk.variant.variantcontext.VariantContextUtils;\n+import htsjdk.variant.vcf.VCFConstants;\n+import htsjdk.variant.vcf.VCFHeader;\n+import org.apache.logging.log4j.Logger;\n+import org.broadinstitute.barclay.argparser.CommandLineException;\n+import org.broadinstitute.hellbender.cmdline.StandardArgumentDefinitions;\n+import org.broadinstitute.hellbender.engine.*;\n+import org.broadinstitute.hellbender.exceptions.GATKException;\n+import org.broadinstitute.hellbender.exceptions.UserException;\n+import org.broadinstitute.hellbender.tools.walkers.varianteval.evaluators.*;\n+import org.broadinstitute.hellbender.tools.walkers.varianteval.stratifications.*;\n+import org.broadinstitute.hellbender.tools.walkers.varianteval.stratifications.manager.StratificationManager;\n+import org.broadinstitute.hellbender.tools.walkers.varianteval.util.EvaluationContext;\n+import org.broadinstitute.hellbender.tools.walkers.varianteval.util.SortableJexlVCMatchExp;\n+import org.broadinstitute.hellbender.tools.walkers.varianteval.util.VariantEvalContext;\n+import org.broadinstitute.hellbender.utils.ClassUtils;\n+import org.broadinstitute.hellbender.utils.SimpleInterval;\n+import org.broadinstitute.hellbender.utils.Utils;\n+import org.broadinstitute.hellbender.utils.io.IOUtils;\n+import org.broadinstitute.hellbender.utils.samples.PedigreeValidationType;\n+import org.broadinstitute.hellbender.utils.samples.Sample;\n+import org.broadinstitute.hellbender.utils.samples.SampleDB;\n+import org.reflections.Reflections;\n+\n+import javax.annotation.Nullable;\n+import java.io.File;\n+import java.io.FileNotFoundException;\n+import java.io.IOException;\n+import java.io.PrintStream;\n+import java.util.*;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * This class allows other classes to replicate the behavior of VariantEval\n+ *\n+ * Usage:\n+ * -Pass the genotype args into the constructor, which will the initialize the engine completely\n+ */\n+public class VariantEvalEngine {\n+    public static final String IS_SINGLETON_KEY = \"ISSINGLETON\";\n+\n+    private final VariantEvalArgumentCollection variantEvalArgs;\n+    private final GATKTool owner;\n+    private final Logger logger;\n+    private final SAMSequenceDictionary samSequenceDictionaryForDrivingVariants;\n+\n+    private final static Map<String, Class<? extends VariantStratifier>> stratifierClasses;\n+    private final static Set<String> standardStratificationNames;\n+    private final static Set<String> requiredStratificationNames;\n+\n+    private final static Map<String, Class<? extends VariantEvaluator>> evaluatorClasses;\n+    private final static Set<String> standardEvaluatorNames;\n+\n+    static {\n+        stratifierClasses = new HashMap<>();\n+        standardStratificationNames = new HashSet<>();\n+        requiredStratificationNames = new HashSet<>();\n+\n+        Reflections reflectionsStrat = new Reflections(VariantStratifier.class.getPackage().getName());\n+        Set<Class<? extends VariantStratifier>> allClasses = reflectionsStrat.getSubTypesOf(VariantStratifier.class);\n+        for (Class<? extends VariantStratifier> clazz : allClasses) {\n+            stratifierClasses.put(clazz.getSimpleName(), clazz);\n+\n+            if (StandardStratification.class.isAssignableFrom(clazz)) {\n+                standardStratificationNames.add(clazz.getSimpleName());\n+            }\n+\n+            if (RequiredStratification.class.isAssignableFrom(clazz)) {\n+                requiredStratificationNames.add(clazz.getSimpleName());\n+            }\n+        }\n+\n+        evaluatorClasses = new HashMap<>();\n+        standardEvaluatorNames= new HashSet<>();\n+\n+        Reflections reflectionsEval = new Reflections(VariantEvaluator.class.getPackage().getName());\n+        Set<Class<? extends VariantEvaluator>> allEvalClasses = reflectionsEval.getSubTypesOf(VariantEvaluator.class);\n+        for (Class<? extends VariantEvaluator> clazz : allEvalClasses) {\n+            evaluatorClasses.put(clazz.getSimpleName(), clazz);\n+\n+            if (StandardEval.class.isAssignableFrom(clazz)) {\n+                standardEvaluatorNames.add(clazz.getSimpleName());\n+            }\n+        }\n+    }\n+\n+    // Ancestral alignments\n+    private ReferenceSequenceFile ancestralAlignments = null;\n+\n+    // The set of all possible evaluation contexts\n+    StratificationManager<VariantStratifier, EvaluationContext> stratManager;\n+\n+    private SampleDB sampleDB = null;\n+\n+    private List<FeatureInput<VariantContext>> knowns = new ArrayList<>();\n+\n+    // maintain the mapping of FeatureInput to name used in output file\n+    private Map<FeatureInput<VariantContext>, String> inputToNameMap = new HashMap<>();\n+\n+    // Variables\n+    private Set<SortableJexlVCMatchExp> jexlExpressions = new TreeSet<>();\n+\n+    private boolean isSubsettingSamples;\n+    private Set<String> sampleNamesForEvaluation = new LinkedHashSet<>();\n+    private Set<String> familyNamesForEvaluation = new LinkedHashSet<>();\n+    private Set<String> sampleNamesForStratification = new LinkedHashSet<>();\n+    private Set<String> familyNamesForStratification = new LinkedHashSet<>();\n+\n+    // important stratifications\n+    private boolean byFilterIsEnabled = false;\n+    private boolean perSampleIsEnabled = false;\n+    private boolean perFamilyIsEnabled = false;\n+\n+    private AlleleFrequency.StratifyingScale AFScale = AlleleFrequency.StratifyingScale.LINEAR;\n+    private boolean useCompAFStratifier = false;\n+\n+    // maintain the mapping of source name (from VC) to FeatureInput name\n+    private Map<String, FeatureInput<VariantContext>> drivingVariantSourceMap;\n+\n+    // No args constructor for unit testing only\n+    @VisibleForTesting\n+    protected VariantEvalEngine(Logger logger) {\n+        this.variantEvalArgs = new VariantEvalArgumentCollection();\n+        this.owner = null;\n+        this.logger = logger;\n+        this.samSequenceDictionaryForDrivingVariants = null;\n+    }\n+\n+    public VariantEvalEngine(VariantEvalArgumentCollection variantEvalArgs, GATKTool owner, SAMSequenceDictionary samSequenceDictionaryForDrivingVariants, @Nullable Collection<String> samples, Logger logger) {\n+        this.variantEvalArgs = variantEvalArgs;\n+        this.owner = owner;\n+        this.logger = logger;\n+        this.samSequenceDictionaryForDrivingVariants = samSequenceDictionaryForDrivingVariants;\n+\n+        // Cache map of source name -> FeatureInput\n+        drivingVariantSourceMap = new HashMap<>();\n+        VariantEvalEngine.getFeatureInputsForDrivingVariants(variantEvalArgs).forEach(x -> drivingVariantSourceMap.put(x.getName(), x));\n+\n+        validateAndInitialize(samples);\n+    }\n+\n+    /**\n+     * Initialize the stratifications, evaluations, evaluation contexts, and reporting object\n+     */\n+    private void validateAndInitialize(@Nullable Collection<String> samples) {\n+        sampleDB = SampleDB.createSampleDBFromPedigreeAndDataSources(variantEvalArgs.pedigreeFile, samples, PedigreeValidationType.STRICT);\n+\n+        variantEvalArgs.comps.addAll(variantEvalArgs.compsProvided);\n+        variantEvalArgs.compsProvided.forEach(comp -> inputToNameMap.put(comp, comp.hasUserSuppliedName() ? comp.getName() : StandardArgumentDefinitions.COMPARISON_SHORT_NAME));\n+        if ( variantEvalArgs.dbsnp.dbsnp != null ) {\n+            variantEvalArgs.comps.add(variantEvalArgs.dbsnp.dbsnp);\n+            inputToNameMap.put(variantEvalArgs.dbsnp.dbsnp, \"dbsnp\");\n+            knowns.add(variantEvalArgs.dbsnp.dbsnp);\n+        }\n+\n+        variantEvalArgs.evals.forEach(eval -> inputToNameMap.put(eval, eval.hasUserSuppliedName() ? eval.getName() : \"eval\"));\n+\n+        // Set up set of additional knowns. dbSNP was addressed above, so use compsProvided, not comps\n+        for ( FeatureInput<VariantContext> compInput : variantEvalArgs.compsProvided ) {\n+            if (variantEvalArgs.knownNames.contains(getNameForInput(compInput)))\n+                knowns.add(compInput);\n+        }\n+\n+        // Now that we have all the inputs categorized, determine the sample list from the eval inputs.\n+        Map<String, VCFHeader> vcfInputs = new HashMap<>();\n+        variantEvalArgs.evals.forEach(eval -> vcfInputs.put(eval.getName(), (VCFHeader)owner.getHeaderForFeatures(eval)));\n+\n+        Set<String> vcfSamples = new HashSet<>();\n+        vcfInputs.forEach((k,v) -> vcfSamples.addAll(v.getSampleNamesInOrder()));\n+\n+        // Load the sample list, using an intermediate tree set to sort the samples\n+        final Set<String> allSampleNames = new HashSet<>(vcfSamples);\n+        sampleNamesForEvaluation.addAll(new TreeSet<>(variantEvalArgs.sampleExpressions.isEmpty() ? vcfSamples : Utils.filterCollectionByExpressions(vcfSamples, variantEvalArgs.sampleExpressions, false)));\n+\n+        isSubsettingSamples = ! sampleNamesForEvaluation.containsAll(allSampleNames);\n+        familyNamesForEvaluation.addAll(sampleDB.getFamilyIDs());\n+\n+        //If stratifying by sample name, assign a stratification for each sample we're evaluating (based on commandline args)...\n+        if (variantEvalArgs.stratificationsToUse.contains(\"Sample\") ) {\n+            sampleNamesForStratification.addAll(sampleNamesForEvaluation);\n+        }\n+        //...and also a stratification for the sum over all samples\n+        sampleNamesForStratification.add(VariantEvalArgumentCollection.ALL_SAMPLE_NAME);\n+\n+\n+        //If stratifying by sample name, assign a stratification for each family...\n+        if ( variantEvalArgs.stratificationsToUse.contains(\"Family\") ) {\n+            familyNamesForStratification.addAll(familyNamesForEvaluation);\n+        }\n+        //...and also a stratification for the sum over all families\n+        familyNamesForStratification.add(VariantEvalArgumentCollection.ALL_FAMILY_NAME);\n+\n+        // Initialize select expressions\n+        for (VariantContextUtils.JexlVCMatchExp jexl : VariantContextUtils.initializeMatchExps(variantEvalArgs.selectNames, variantEvalArgs.selectExps)) {\n+            SortableJexlVCMatchExp sjexl = new SortableJexlVCMatchExp(jexl.name, jexl.exp);\n+            jexlExpressions.add(sjexl);\n+        }\n+\n+        // Initialize the set of stratifications and evaluations to use\n+        // The list of stratifiers and evaluators to use\n+        final List<VariantStratifier> stratificationObjects = initializeStratificationObjects(variantEvalArgs.noStandardStratifications, variantEvalArgs.stratificationsToUse);\n+        final Set<Class<? extends VariantEvaluator>> evaluationClasses = initializeEvaluationObjects(variantEvalArgs.noStandardModules, variantEvalArgs.modulesToUse);\n+\n+        checkForIncompatibleEvaluatorsAndStratifiers(stratificationObjects, evaluationClasses);\n+\n+\n+        for ( VariantStratifier vs : stratificationObjects ) {\n+            if ( vs.getName().equals(\"Filter\") )\n+                byFilterIsEnabled = true;\n+            else if ( vs.getName().equals(\"Sample\") )\n+                perSampleIsEnabled = true;\n+            else if ( vs.getName().equals(\"Family\"))\n+                perFamilyIsEnabled = true;\n+        }\n+\n+        if (perSampleIsEnabled && perFamilyIsEnabled)\n+            throw new CommandLineException.BadArgumentValue(\"ST\", \"Variants cannot be stratified by sample and family at the same time\");\n+\n+        if (perFamilyIsEnabled && sampleDB.getTrios().isEmpty())\n+            throw new CommandLineException.BadArgumentValue(\"ST\", \"Cannot stratify by family without *.ped file\");\n+\n+\n+        if ( variantEvalArgs.intervalsFile != null ) {\n+            boolean fail = true;\n+            for ( final VariantStratifier vs : stratificationObjects ) {\n+                if ( vs.getClass().equals(IntervalStratification.class) )\n+                    fail = false;\n+            }\n+            if ( fail )\n+                throw new CommandLineException.BadArgumentValue(\"ST\", \"stratIntervals argument provided but -ST IntervalStratification not provided\");\n+        }\n+\n+\n+        // Initialize the evaluation contexts\n+        createStratificationStates(stratificationObjects, evaluationClasses);\n+\n+        // Load ancestral alignments\n+        if (variantEvalArgs.ancestralAlignmentsFile != null) {\n+            try {\n+                ancestralAlignments = new IndexedFastaSequenceFile(variantEvalArgs.ancestralAlignmentsFile.toPath());\n+            } catch (FileNotFoundException e) {\n+                throw new GATKException(String.format(\"The ancestral alignments file, '%s', could not be found\", variantEvalArgs.ancestralAlignmentsFile.getAbsolutePath()));\n+            }\n+        }\n+\n+        assertThatTerritoryIsSpecifiedIfNecessary();\n+    }\n+\n+    public String getNameForInput(FeatureInput<VariantContext> input) {\n+        return inputToNameMap.get(input);\n+    }\n+\n+    private void assertThatTerritoryIsSpecifiedIfNecessary() {\n+        final Set<String> evaluatorsWhichRequireTerritory = stratManager.values()\n+                .stream()\n+                .flatMap(ctx -> ctx.getVariantEvaluators().stream())\n+                .filter(Objects::nonNull)\n+                .filter(VariantEvaluator::requiresTerritoryToBeSpecified)\n+                .map(VariantEvaluator::getSimpleName)\n+                .collect(Collectors.toSet());\n+        if(!evaluatorsWhichRequireTerritory.isEmpty() && owner.getTraversalIntervals() == null){\n+            throw new UserException(\"You specified evaluators which require a covered territory to be specified.  \" +\n+                    \"\\nPlease specify intervals or a reference file or disable all of the following evaluators:\" +\n+                    evaluatorsWhichRequireTerritory.stream()\n+                            .collect(Collectors.joining(\", \")));\n+        }\n+    }\n+\n+    private void checkForIncompatibleEvaluatorsAndStratifiers( final List<VariantStratifier> stratificationObjects,\n+                                                               Set<Class<? extends VariantEvaluator>> evaluationClasses) {\n+        for ( final VariantStratifier vs : stratificationObjects ) {\n+            for ( Class<? extends VariantEvaluator> ec : evaluationClasses )\n+                if ( vs.getIncompatibleEvaluators().contains(ec) )\n+                    throw new CommandLineException.BadArgumentValue(\"ST and ET\",\n+                            \"The selected stratification \" + vs.getName() +\n+                                    \" and evaluator \" + ec.getSimpleName() +\n+                                    \" are incompatible due to combinatorial memory requirements.\" +\n+                                    \" Please disable one\");\n+        }\n+    }\n+\n+    protected void createStratificationStates(final List<VariantStratifier> stratificationObjects, final Set<Class<? extends VariantEvaluator>> evaluationObjects) {\n+        final List<VariantStratifier> strats = new ArrayList<VariantStratifier>(stratificationObjects);\n+        stratManager = new StratificationManager<>(strats);\n+\n+        logger.info(\"Creating \" + stratManager.size() + \" combinatorial stratification states\");\n+        for ( int i = 0; i < stratManager.size(); i++ ) {\n+            EvaluationContext ec = createEvaluationContext(evaluationObjects);\n+            stratManager.set(i, ec);\n+        }\n+    }\n+\n+    public static List<FeatureInput<VariantContext>> getFeatureInputsForDrivingVariants(VariantEvalArgumentCollection variantEvalArgs) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "48d87916e7739526294ee39a72c6a1f32694bfde"}, "originalPosition": 303}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTU5MjkzOA==", "bodyText": "It looks like the main reason you still need the GATK tool is to access user features and user intervals. You should be able to eliminate it by passing both (user intervals and the feature manager) in to the engine constructor instead of the tool.", "url": "https://github.com/broadinstitute/gatk/pull/6973#discussion_r551592938", "createdAt": "2021-01-04T21:57:18Z", "author": {"login": "cmnbroad"}, "path": "src/main/java/org/broadinstitute/hellbender/tools/walkers/varianteval/VariantEvalEngine.java", "diffHunk": "@@ -0,0 +1,940 @@\n+package org.broadinstitute.hellbender.tools.walkers.varianteval;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import htsjdk.samtools.SAMSequenceDictionary;\n+import htsjdk.samtools.reference.IndexedFastaSequenceFile;\n+import htsjdk.samtools.reference.ReferenceSequenceFile;\n+import htsjdk.tribble.Feature;\n+import htsjdk.variant.variantcontext.Allele;\n+import htsjdk.variant.variantcontext.VariantContext;\n+import htsjdk.variant.variantcontext.VariantContextBuilder;\n+import htsjdk.variant.variantcontext.VariantContextUtils;\n+import htsjdk.variant.vcf.VCFConstants;\n+import htsjdk.variant.vcf.VCFHeader;\n+import org.apache.logging.log4j.Logger;\n+import org.broadinstitute.barclay.argparser.CommandLineException;\n+import org.broadinstitute.hellbender.cmdline.StandardArgumentDefinitions;\n+import org.broadinstitute.hellbender.engine.*;\n+import org.broadinstitute.hellbender.exceptions.GATKException;\n+import org.broadinstitute.hellbender.exceptions.UserException;\n+import org.broadinstitute.hellbender.tools.walkers.varianteval.evaluators.*;\n+import org.broadinstitute.hellbender.tools.walkers.varianteval.stratifications.*;\n+import org.broadinstitute.hellbender.tools.walkers.varianteval.stratifications.manager.StratificationManager;\n+import org.broadinstitute.hellbender.tools.walkers.varianteval.util.EvaluationContext;\n+import org.broadinstitute.hellbender.tools.walkers.varianteval.util.SortableJexlVCMatchExp;\n+import org.broadinstitute.hellbender.tools.walkers.varianteval.util.VariantEvalContext;\n+import org.broadinstitute.hellbender.utils.ClassUtils;\n+import org.broadinstitute.hellbender.utils.SimpleInterval;\n+import org.broadinstitute.hellbender.utils.Utils;\n+import org.broadinstitute.hellbender.utils.io.IOUtils;\n+import org.broadinstitute.hellbender.utils.samples.PedigreeValidationType;\n+import org.broadinstitute.hellbender.utils.samples.Sample;\n+import org.broadinstitute.hellbender.utils.samples.SampleDB;\n+import org.reflections.Reflections;\n+\n+import javax.annotation.Nullable;\n+import java.io.File;\n+import java.io.FileNotFoundException;\n+import java.io.IOException;\n+import java.io.PrintStream;\n+import java.util.*;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * This class allows other classes to replicate the behavior of VariantEval\n+ *\n+ * Usage:\n+ * -Pass the genotype args into the constructor, which will the initialize the engine completely\n+ */\n+public class VariantEvalEngine {\n+    public static final String IS_SINGLETON_KEY = \"ISSINGLETON\";\n+\n+    private final VariantEvalArgumentCollection variantEvalArgs;\n+    private final GATKTool owner;\n+    private final Logger logger;\n+    private final SAMSequenceDictionary samSequenceDictionaryForDrivingVariants;\n+\n+    private final static Map<String, Class<? extends VariantStratifier>> stratifierClasses;\n+    private final static Set<String> standardStratificationNames;\n+    private final static Set<String> requiredStratificationNames;\n+\n+    private final static Map<String, Class<? extends VariantEvaluator>> evaluatorClasses;\n+    private final static Set<String> standardEvaluatorNames;\n+\n+    static {\n+        stratifierClasses = new HashMap<>();\n+        standardStratificationNames = new HashSet<>();\n+        requiredStratificationNames = new HashSet<>();\n+\n+        Reflections reflectionsStrat = new Reflections(VariantStratifier.class.getPackage().getName());\n+        Set<Class<? extends VariantStratifier>> allClasses = reflectionsStrat.getSubTypesOf(VariantStratifier.class);\n+        for (Class<? extends VariantStratifier> clazz : allClasses) {\n+            stratifierClasses.put(clazz.getSimpleName(), clazz);\n+\n+            if (StandardStratification.class.isAssignableFrom(clazz)) {\n+                standardStratificationNames.add(clazz.getSimpleName());\n+            }\n+\n+            if (RequiredStratification.class.isAssignableFrom(clazz)) {\n+                requiredStratificationNames.add(clazz.getSimpleName());\n+            }\n+        }\n+\n+        evaluatorClasses = new HashMap<>();\n+        standardEvaluatorNames= new HashSet<>();\n+\n+        Reflections reflectionsEval = new Reflections(VariantEvaluator.class.getPackage().getName());\n+        Set<Class<? extends VariantEvaluator>> allEvalClasses = reflectionsEval.getSubTypesOf(VariantEvaluator.class);\n+        for (Class<? extends VariantEvaluator> clazz : allEvalClasses) {\n+            evaluatorClasses.put(clazz.getSimpleName(), clazz);\n+\n+            if (StandardEval.class.isAssignableFrom(clazz)) {\n+                standardEvaluatorNames.add(clazz.getSimpleName());\n+            }\n+        }\n+    }\n+\n+    // Ancestral alignments\n+    private ReferenceSequenceFile ancestralAlignments = null;\n+\n+    // The set of all possible evaluation contexts\n+    StratificationManager<VariantStratifier, EvaluationContext> stratManager;\n+\n+    private SampleDB sampleDB = null;\n+\n+    private List<FeatureInput<VariantContext>> knowns = new ArrayList<>();\n+\n+    // maintain the mapping of FeatureInput to name used in output file\n+    private Map<FeatureInput<VariantContext>, String> inputToNameMap = new HashMap<>();\n+\n+    // Variables\n+    private Set<SortableJexlVCMatchExp> jexlExpressions = new TreeSet<>();\n+\n+    private boolean isSubsettingSamples;\n+    private Set<String> sampleNamesForEvaluation = new LinkedHashSet<>();\n+    private Set<String> familyNamesForEvaluation = new LinkedHashSet<>();\n+    private Set<String> sampleNamesForStratification = new LinkedHashSet<>();\n+    private Set<String> familyNamesForStratification = new LinkedHashSet<>();\n+\n+    // important stratifications\n+    private boolean byFilterIsEnabled = false;\n+    private boolean perSampleIsEnabled = false;\n+    private boolean perFamilyIsEnabled = false;\n+\n+    private AlleleFrequency.StratifyingScale AFScale = AlleleFrequency.StratifyingScale.LINEAR;\n+    private boolean useCompAFStratifier = false;\n+\n+    // maintain the mapping of source name (from VC) to FeatureInput name\n+    private Map<String, FeatureInput<VariantContext>> drivingVariantSourceMap;\n+\n+    // No args constructor for unit testing only\n+    @VisibleForTesting\n+    protected VariantEvalEngine(Logger logger) {\n+        this.variantEvalArgs = new VariantEvalArgumentCollection();\n+        this.owner = null;\n+        this.logger = logger;\n+        this.samSequenceDictionaryForDrivingVariants = null;\n+    }\n+\n+    public VariantEvalEngine(VariantEvalArgumentCollection variantEvalArgs, GATKTool owner, SAMSequenceDictionary samSequenceDictionaryForDrivingVariants, @Nullable Collection<String> samples, Logger logger) {\n+        this.variantEvalArgs = variantEvalArgs;\n+        this.owner = owner;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "48d87916e7739526294ee39a72c6a1f32694bfde"}, "originalPosition": 141}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTU5NDc4Nw==", "bodyText": "It looks like there are only a couple of tests that access this - can  it be replaced with methods on the engine that delegate to the stratManager so it can be private?", "url": "https://github.com/broadinstitute/gatk/pull/6973#discussion_r551594787", "createdAt": "2021-01-04T21:59:39Z", "author": {"login": "cmnbroad"}, "path": "src/main/java/org/broadinstitute/hellbender/tools/walkers/varianteval/VariantEvalEngine.java", "diffHunk": "@@ -0,0 +1,940 @@\n+package org.broadinstitute.hellbender.tools.walkers.varianteval;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import htsjdk.samtools.SAMSequenceDictionary;\n+import htsjdk.samtools.reference.IndexedFastaSequenceFile;\n+import htsjdk.samtools.reference.ReferenceSequenceFile;\n+import htsjdk.tribble.Feature;\n+import htsjdk.variant.variantcontext.Allele;\n+import htsjdk.variant.variantcontext.VariantContext;\n+import htsjdk.variant.variantcontext.VariantContextBuilder;\n+import htsjdk.variant.variantcontext.VariantContextUtils;\n+import htsjdk.variant.vcf.VCFConstants;\n+import htsjdk.variant.vcf.VCFHeader;\n+import org.apache.logging.log4j.Logger;\n+import org.broadinstitute.barclay.argparser.CommandLineException;\n+import org.broadinstitute.hellbender.cmdline.StandardArgumentDefinitions;\n+import org.broadinstitute.hellbender.engine.*;\n+import org.broadinstitute.hellbender.exceptions.GATKException;\n+import org.broadinstitute.hellbender.exceptions.UserException;\n+import org.broadinstitute.hellbender.tools.walkers.varianteval.evaluators.*;\n+import org.broadinstitute.hellbender.tools.walkers.varianteval.stratifications.*;\n+import org.broadinstitute.hellbender.tools.walkers.varianteval.stratifications.manager.StratificationManager;\n+import org.broadinstitute.hellbender.tools.walkers.varianteval.util.EvaluationContext;\n+import org.broadinstitute.hellbender.tools.walkers.varianteval.util.SortableJexlVCMatchExp;\n+import org.broadinstitute.hellbender.tools.walkers.varianteval.util.VariantEvalContext;\n+import org.broadinstitute.hellbender.utils.ClassUtils;\n+import org.broadinstitute.hellbender.utils.SimpleInterval;\n+import org.broadinstitute.hellbender.utils.Utils;\n+import org.broadinstitute.hellbender.utils.io.IOUtils;\n+import org.broadinstitute.hellbender.utils.samples.PedigreeValidationType;\n+import org.broadinstitute.hellbender.utils.samples.Sample;\n+import org.broadinstitute.hellbender.utils.samples.SampleDB;\n+import org.reflections.Reflections;\n+\n+import javax.annotation.Nullable;\n+import java.io.File;\n+import java.io.FileNotFoundException;\n+import java.io.IOException;\n+import java.io.PrintStream;\n+import java.util.*;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * This class allows other classes to replicate the behavior of VariantEval\n+ *\n+ * Usage:\n+ * -Pass the genotype args into the constructor, which will the initialize the engine completely\n+ */\n+public class VariantEvalEngine {\n+    public static final String IS_SINGLETON_KEY = \"ISSINGLETON\";\n+\n+    private final VariantEvalArgumentCollection variantEvalArgs;\n+    private final GATKTool owner;\n+    private final Logger logger;\n+    private final SAMSequenceDictionary samSequenceDictionaryForDrivingVariants;\n+\n+    private final static Map<String, Class<? extends VariantStratifier>> stratifierClasses;\n+    private final static Set<String> standardStratificationNames;\n+    private final static Set<String> requiredStratificationNames;\n+\n+    private final static Map<String, Class<? extends VariantEvaluator>> evaluatorClasses;\n+    private final static Set<String> standardEvaluatorNames;\n+\n+    static {\n+        stratifierClasses = new HashMap<>();\n+        standardStratificationNames = new HashSet<>();\n+        requiredStratificationNames = new HashSet<>();\n+\n+        Reflections reflectionsStrat = new Reflections(VariantStratifier.class.getPackage().getName());\n+        Set<Class<? extends VariantStratifier>> allClasses = reflectionsStrat.getSubTypesOf(VariantStratifier.class);\n+        for (Class<? extends VariantStratifier> clazz : allClasses) {\n+            stratifierClasses.put(clazz.getSimpleName(), clazz);\n+\n+            if (StandardStratification.class.isAssignableFrom(clazz)) {\n+                standardStratificationNames.add(clazz.getSimpleName());\n+            }\n+\n+            if (RequiredStratification.class.isAssignableFrom(clazz)) {\n+                requiredStratificationNames.add(clazz.getSimpleName());\n+            }\n+        }\n+\n+        evaluatorClasses = new HashMap<>();\n+        standardEvaluatorNames= new HashSet<>();\n+\n+        Reflections reflectionsEval = new Reflections(VariantEvaluator.class.getPackage().getName());\n+        Set<Class<? extends VariantEvaluator>> allEvalClasses = reflectionsEval.getSubTypesOf(VariantEvaluator.class);\n+        for (Class<? extends VariantEvaluator> clazz : allEvalClasses) {\n+            evaluatorClasses.put(clazz.getSimpleName(), clazz);\n+\n+            if (StandardEval.class.isAssignableFrom(clazz)) {\n+                standardEvaluatorNames.add(clazz.getSimpleName());\n+            }\n+        }\n+    }\n+\n+    // Ancestral alignments\n+    private ReferenceSequenceFile ancestralAlignments = null;\n+\n+    // The set of all possible evaluation contexts\n+    StratificationManager<VariantStratifier, EvaluationContext> stratManager;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "48d87916e7739526294ee39a72c6a1f32694bfde"}, "originalPosition": 101}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTY2NzQxNjYx", "url": "https://github.com/broadinstitute/gatk/pull/6973#pullrequestreview-566741661", "createdAt": "2021-01-12T22:08:11Z", "commit": {"oid": "9a8836fdfeb635d275ce71f365bef469718e782a"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xMlQyMjowODoxMlrOISXVOg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xMlQyMjo1MjowNVrOISYq0w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NjEyNzU0Ng==", "bodyText": "Some of the evaluators get the engine as a constructor arg, and some get it in finalizeEvaluation. I think it would make more sense to always pass it to the constructors.", "url": "https://github.com/broadinstitute/gatk/pull/6973#discussion_r556127546", "createdAt": "2021-01-12T22:08:12Z", "author": {"login": "cmnbroad"}, "path": "src/main/java/org/broadinstitute/hellbender/tools/walkers/varianteval/evaluators/IndelLengthHistogram.java", "diffHunk": "@@ -44,7 +43,7 @@ private void initializeCounts(int size) {\n     }\n \n     @Override\n-    public void finalizeEvaluation() {\n+    public void finalizeEvaluation(final VariantEvalEngine engine) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9a8836fdfeb635d275ce71f365bef469718e782a"}, "originalPosition": 20}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NjEyOTkyNA==", "bodyText": "It seems like each subclass should have a constructor that takes an engine, and delegates it here. This can cache the engine and expose a getEngine method so that subclasses can access it.", "url": "https://github.com/broadinstitute/gatk/pull/6973#discussion_r556129924", "createdAt": "2021-01-12T22:12:50Z", "author": {"login": "cmnbroad"}, "path": "src/main/java/org/broadinstitute/hellbender/tools/walkers/varianteval/evaluators/VariantEvaluator.java", "diffHunk": "@@ -19,26 +16,22 @@ protected VariantEvaluator() {\n         this.simpleName = getClass().getSimpleName();\n     }\n \n-    public void initialize(VariantEval walker) {\n-        this.walker = walker;\n-    }\n+    public void initialize(final VariantEvalEngine engine) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9a8836fdfeb635d275ce71f365bef469718e782a"}, "originalPosition": 24}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NjEzMDI2MA==", "bodyText": "This appears to be unused. Is there some compelling use case for it ? Can it be removed ? This should really have only one constructor that takes the engine (see my related comment elsewhere).", "url": "https://github.com/broadinstitute/gatk/pull/6973#discussion_r556130260", "createdAt": "2021-01-12T22:13:34Z", "author": {"login": "cmnbroad"}, "path": "src/main/java/org/broadinstitute/hellbender/tools/walkers/varianteval/evaluators/VariantEvaluator.java", "diffHunk": "@@ -1,14 +1,11 @@\n package org.broadinstitute.hellbender.tools.walkers.varianteval.evaluators;\n \n import htsjdk.variant.variantcontext.VariantContext;\n-import org.broadinstitute.hellbender.engine.FeatureContext;\n-import org.broadinstitute.hellbender.engine.ReadsContext;\n-import org.broadinstitute.hellbender.engine.ReferenceContext;\n import org.broadinstitute.hellbender.exceptions.GATKException;\n-import org.broadinstitute.hellbender.tools.walkers.varianteval.VariantEval;\n+import org.broadinstitute.hellbender.tools.walkers.varianteval.VariantEvalEngine;\n+import org.broadinstitute.hellbender.tools.walkers.varianteval.util.VariantEvalContext;\n \n public abstract class VariantEvaluator implements Comparable<VariantEvaluator> {\n-    private VariantEval walker;\n     private final String simpleName;\n \n     protected VariantEvaluator(String simpleName) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9a8836fdfeb635d275ce71f365bef469718e782a"}, "originalPosition": 16}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NjEzNjkxOA==", "bodyText": "There are quite a few methods here that are just pass-through wrappers to VariantEvalArgs. Instead of exposing them again, just add a VariantEvalArgs getter here, and move the safe methods (preserving the unmodifiable collections) to VariantEvalArgs.", "url": "https://github.com/broadinstitute/gatk/pull/6973#discussion_r556136918", "createdAt": "2021-01-12T22:25:59Z", "author": {"login": "cmnbroad"}, "path": "src/main/java/org/broadinstitute/hellbender/tools/walkers/varianteval/VariantEvalEngine.java", "diffHunk": "@@ -0,0 +1,937 @@\n+package org.broadinstitute.hellbender.tools.walkers.varianteval;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import htsjdk.samtools.SAMSequenceDictionary;\n+import htsjdk.samtools.reference.IndexedFastaSequenceFile;\n+import htsjdk.samtools.reference.ReferenceSequenceFile;\n+import htsjdk.tribble.Feature;\n+import htsjdk.variant.variantcontext.Allele;\n+import htsjdk.variant.variantcontext.VariantContext;\n+import htsjdk.variant.variantcontext.VariantContextBuilder;\n+import htsjdk.variant.variantcontext.VariantContextUtils;\n+import htsjdk.variant.vcf.VCFConstants;\n+import htsjdk.variant.vcf.VCFHeader;\n+import org.apache.logging.log4j.Logger;\n+import org.broadinstitute.barclay.argparser.CommandLineException;\n+import org.broadinstitute.hellbender.cmdline.StandardArgumentDefinitions;\n+import org.broadinstitute.hellbender.engine.*;\n+import org.broadinstitute.hellbender.exceptions.GATKException;\n+import org.broadinstitute.hellbender.exceptions.UserException;\n+import org.broadinstitute.hellbender.tools.walkers.varianteval.evaluators.*;\n+import org.broadinstitute.hellbender.tools.walkers.varianteval.stratifications.*;\n+import org.broadinstitute.hellbender.tools.walkers.varianteval.stratifications.manager.StratificationManager;\n+import org.broadinstitute.hellbender.tools.walkers.varianteval.util.EvaluationContext;\n+import org.broadinstitute.hellbender.tools.walkers.varianteval.util.SortableJexlVCMatchExp;\n+import org.broadinstitute.hellbender.tools.walkers.varianteval.util.VariantEvalContext;\n+import org.broadinstitute.hellbender.utils.ClassUtils;\n+import org.broadinstitute.hellbender.utils.SimpleInterval;\n+import org.broadinstitute.hellbender.utils.Utils;\n+import org.broadinstitute.hellbender.utils.io.IOUtils;\n+import org.broadinstitute.hellbender.utils.samples.PedigreeValidationType;\n+import org.broadinstitute.hellbender.utils.samples.Sample;\n+import org.broadinstitute.hellbender.utils.samples.SampleDB;\n+import org.reflections.Reflections;\n+\n+import javax.annotation.Nullable;\n+import java.io.File;\n+import java.io.FileNotFoundException;\n+import java.io.IOException;\n+import java.io.PrintStream;\n+import java.util.*;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * This class allows other classes to replicate the behavior of VariantEval\n+ *\n+ * Usage:\n+ * -Pass the genotype args into the constructor, which will the initialize the engine completely\n+ */\n+public class VariantEvalEngine {\n+    public static final String IS_SINGLETON_KEY = \"ISSINGLETON\";\n+\n+    private final VariantEvalArgumentCollection variantEvalArgs;\n+\n+    private final Logger logger;\n+    private final SAMSequenceDictionary samSequenceDictionaryForDrivingVariants;\n+    private final List<SimpleInterval> traversalIntervals;\n+    private final FeatureManager features;\n+\n+    private final static Map<String, Class<? extends VariantStratifier>> stratifierClasses;\n+    private final static Set<String> standardStratificationNames;\n+    private final static Set<String> requiredStratificationNames;\n+\n+    private final static Map<String, Class<? extends VariantEvaluator>> evaluatorClasses;\n+    private final static Set<String> standardEvaluatorNames;\n+\n+    static {\n+        stratifierClasses = new HashMap<>();\n+        standardStratificationNames = new HashSet<>();\n+        requiredStratificationNames = new HashSet<>();\n+\n+        Reflections reflectionsStrat = new Reflections(VariantStratifier.class.getPackage().getName());\n+        Set<Class<? extends VariantStratifier>> allClasses = reflectionsStrat.getSubTypesOf(VariantStratifier.class);\n+        for (Class<? extends VariantStratifier> clazz : allClasses) {\n+            stratifierClasses.put(clazz.getSimpleName(), clazz);\n+\n+            if (StandardStratification.class.isAssignableFrom(clazz)) {\n+                standardStratificationNames.add(clazz.getSimpleName());\n+            }\n+\n+            if (RequiredStratification.class.isAssignableFrom(clazz)) {\n+                requiredStratificationNames.add(clazz.getSimpleName());\n+            }\n+        }\n+\n+        evaluatorClasses = new HashMap<>();\n+        standardEvaluatorNames= new HashSet<>();\n+\n+        Reflections reflectionsEval = new Reflections(VariantEvaluator.class.getPackage().getName());\n+        Set<Class<? extends VariantEvaluator>> allEvalClasses = reflectionsEval.getSubTypesOf(VariantEvaluator.class);\n+        for (Class<? extends VariantEvaluator> clazz : allEvalClasses) {\n+            evaluatorClasses.put(clazz.getSimpleName(), clazz);\n+\n+            if (StandardEval.class.isAssignableFrom(clazz)) {\n+                standardEvaluatorNames.add(clazz.getSimpleName());\n+            }\n+        }\n+    }\n+\n+    // Ancestral alignments\n+    private ReferenceSequenceFile ancestralAlignments = null;\n+\n+    // The set of all possible evaluation contexts\n+    private StratificationManager<VariantStratifier, EvaluationContext> stratManager;\n+\n+    private SampleDB sampleDB = null;\n+\n+    private List<FeatureInput<VariantContext>> knowns = new ArrayList<>();\n+\n+    // maintain the mapping of FeatureInput to name used in output file\n+    private Map<FeatureInput<VariantContext>, String> inputToNameMap = new HashMap<>();\n+\n+    // Variables\n+    private Set<SortableJexlVCMatchExp> jexlExpressions = new TreeSet<>();\n+\n+    private boolean isSubsettingSamples;\n+    private Set<String> sampleNamesForEvaluation = new LinkedHashSet<>();\n+    private Set<String> familyNamesForEvaluation = new LinkedHashSet<>();\n+    private Set<String> sampleNamesForStratification = new LinkedHashSet<>();\n+    private Set<String> familyNamesForStratification = new LinkedHashSet<>();\n+\n+    // important stratifications\n+    private boolean byFilterIsEnabled = false;\n+    private boolean perSampleIsEnabled = false;\n+    private boolean perFamilyIsEnabled = false;\n+\n+    private AlleleFrequency.StratifyingScale AFScale = AlleleFrequency.StratifyingScale.LINEAR;\n+    private boolean useCompAFStratifier = false;\n+\n+    // maintain the mapping of source name (from VC) to FeatureInput name\n+    private Map<String, FeatureInput<VariantContext>> drivingVariantSourceMap;\n+\n+    // No args constructor for unit testing only\n+    @VisibleForTesting\n+    protected VariantEvalEngine(Logger logger) {\n+        this.variantEvalArgs = new VariantEvalArgumentCollection();\n+        this.logger = logger;\n+        this.samSequenceDictionaryForDrivingVariants = null;\n+        this.traversalIntervals = null;\n+        this.features = null;\n+    }\n+\n+    public VariantEvalEngine(VariantEvalArgumentCollection variantEvalArgs, FeatureManager features, List<SimpleInterval> traversalIntervals, SAMSequenceDictionary samSequenceDictionaryForDrivingVariants, @Nullable Collection<String> samples, Logger logger) {\n+        this.variantEvalArgs = variantEvalArgs;\n+        this.logger = logger;\n+        this.samSequenceDictionaryForDrivingVariants = samSequenceDictionaryForDrivingVariants;\n+        this.traversalIntervals = traversalIntervals;\n+        this.features = features;\n+\n+        // Cache map of source name -> FeatureInput\n+        drivingVariantSourceMap = new HashMap<>();\n+        variantEvalArgs.getFeatureInputsForDrivingVariants().forEach(x -> drivingVariantSourceMap.put(x.getName(), x));\n+\n+        validateAndInitialize(samples);\n+    }\n+\n+    /**\n+     * Initialize the stratifications, evaluations, evaluation contexts, and reporting object\n+     */\n+    private void validateAndInitialize(@Nullable Collection<String> samples) {\n+        sampleDB = SampleDB.createSampleDBFromPedigreeAndDataSources(variantEvalArgs.pedigreeFile, samples, PedigreeValidationType.STRICT);\n+\n+        variantEvalArgs.comps.addAll(variantEvalArgs.compsProvided);\n+        variantEvalArgs.compsProvided.forEach(comp -> inputToNameMap.put(comp, comp.hasUserSuppliedName() ? comp.getName() : StandardArgumentDefinitions.COMPARISON_SHORT_NAME));\n+        if ( variantEvalArgs.dbsnp.dbsnp != null ) {\n+            variantEvalArgs.comps.add(variantEvalArgs.dbsnp.dbsnp);\n+            inputToNameMap.put(variantEvalArgs.dbsnp.dbsnp, \"dbsnp\");\n+            knowns.add(variantEvalArgs.dbsnp.dbsnp);\n+        }\n+\n+        variantEvalArgs.evals.forEach(eval -> inputToNameMap.put(eval, eval.hasUserSuppliedName() ? eval.getName() : \"eval\"));\n+\n+        // Set up set of additional knowns. dbSNP was addressed above, so use compsProvided, not comps\n+        for ( FeatureInput<VariantContext> compInput : variantEvalArgs.compsProvided ) {\n+            if (variantEvalArgs.knownNames.contains(getNameForInput(compInput)))\n+                knowns.add(compInput);\n+        }\n+\n+        // Now that we have all the inputs categorized, determine the sample list from the eval inputs.\n+        Map<String, VCFHeader> vcfInputs = new HashMap<>();\n+        variantEvalArgs.evals.forEach(eval -> vcfInputs.put(eval.getName(), (VCFHeader)features.getHeader(eval)));\n+\n+        Set<String> vcfSamples = new HashSet<>();\n+        vcfInputs.forEach((k,v) -> vcfSamples.addAll(v.getSampleNamesInOrder()));\n+\n+        // Load the sample list, using an intermediate tree set to sort the samples\n+        final Set<String> allSampleNames = new HashSet<>(vcfSamples);\n+        sampleNamesForEvaluation.addAll(new TreeSet<>(variantEvalArgs.sampleExpressions.isEmpty() ? vcfSamples : Utils.filterCollectionByExpressions(vcfSamples, variantEvalArgs.sampleExpressions, false)));\n+\n+        isSubsettingSamples = ! sampleNamesForEvaluation.containsAll(allSampleNames);\n+        familyNamesForEvaluation.addAll(sampleDB.getFamilyIDs());\n+\n+        //If stratifying by sample name, assign a stratification for each sample we're evaluating (based on commandline args)...\n+        if (variantEvalArgs.stratificationsToUse.contains(\"Sample\") ) {\n+            sampleNamesForStratification.addAll(sampleNamesForEvaluation);\n+        }\n+        //...and also a stratification for the sum over all samples\n+        sampleNamesForStratification.add(VariantEvalArgumentCollection.ALL_SAMPLE_NAME);\n+\n+\n+        //If stratifying by sample name, assign a stratification for each family...\n+        if ( variantEvalArgs.stratificationsToUse.contains(\"Family\") ) {\n+            familyNamesForStratification.addAll(familyNamesForEvaluation);\n+        }\n+        //...and also a stratification for the sum over all families\n+        familyNamesForStratification.add(VariantEvalArgumentCollection.ALL_FAMILY_NAME);\n+\n+        // Initialize select expressions\n+        for (VariantContextUtils.JexlVCMatchExp jexl : VariantContextUtils.initializeMatchExps(variantEvalArgs.selectNames, variantEvalArgs.selectExps)) {\n+            SortableJexlVCMatchExp sjexl = new SortableJexlVCMatchExp(jexl.name, jexl.exp);\n+            jexlExpressions.add(sjexl);\n+        }\n+\n+        // Initialize the set of stratifications and evaluations to use\n+        // The list of stratifiers and evaluators to use\n+        final List<VariantStratifier> stratificationObjects = initializeStratificationObjects(variantEvalArgs.noStandardStratifications, variantEvalArgs.stratificationsToUse);\n+        final Set<Class<? extends VariantEvaluator>> evaluationClasses = initializeEvaluationObjects(variantEvalArgs.noStandardModules, variantEvalArgs.modulesToUse);\n+\n+        checkForIncompatibleEvaluatorsAndStratifiers(stratificationObjects, evaluationClasses);\n+\n+\n+        for ( VariantStratifier vs : stratificationObjects ) {\n+            if ( vs.getName().equals(\"Filter\") )\n+                byFilterIsEnabled = true;\n+            else if ( vs.getName().equals(\"Sample\") )\n+                perSampleIsEnabled = true;\n+            else if ( vs.getName().equals(\"Family\"))\n+                perFamilyIsEnabled = true;\n+        }\n+\n+        if (perSampleIsEnabled && perFamilyIsEnabled)\n+            throw new CommandLineException.BadArgumentValue(\"ST\", \"Variants cannot be stratified by sample and family at the same time\");\n+\n+        if (perFamilyIsEnabled && sampleDB.getTrios().isEmpty())\n+            throw new CommandLineException.BadArgumentValue(\"ST\", \"Cannot stratify by family without *.ped file\");\n+\n+\n+        if ( variantEvalArgs.intervalsFile != null ) {\n+            boolean fail = true;\n+            for ( final VariantStratifier vs : stratificationObjects ) {\n+                if ( vs.getClass().equals(IntervalStratification.class) )\n+                    fail = false;\n+            }\n+            if ( fail )\n+                throw new CommandLineException.BadArgumentValue(\"ST\", \"stratIntervals argument provided but -ST IntervalStratification not provided\");\n+        }\n+\n+\n+        // Initialize the evaluation contexts\n+        createStratificationStates(stratificationObjects, evaluationClasses);\n+\n+        // Load ancestral alignments\n+        if (variantEvalArgs.ancestralAlignmentsFile != null) {\n+            try {\n+                ancestralAlignments = new IndexedFastaSequenceFile(variantEvalArgs.ancestralAlignmentsFile.toPath());\n+            } catch (FileNotFoundException e) {\n+                throw new GATKException(String.format(\"The ancestral alignments file, '%s', could not be found\", variantEvalArgs.ancestralAlignmentsFile.getAbsolutePath()));\n+            }\n+        }\n+\n+        assertThatTerritoryIsSpecifiedIfNecessary();\n+    }\n+\n+    public String getNameForInput(FeatureInput<VariantContext> input) {\n+        return inputToNameMap.get(input);\n+    }\n+\n+    private void assertThatTerritoryIsSpecifiedIfNecessary() {\n+        final Set<String> evaluatorsWhichRequireTerritory = stratManager.values()\n+                .stream()\n+                .flatMap(ctx -> ctx.getVariantEvaluators().stream())\n+                .filter(Objects::nonNull)\n+                .filter(VariantEvaluator::requiresTerritoryToBeSpecified)\n+                .map(VariantEvaluator::getSimpleName)\n+                .collect(Collectors.toSet());\n+        if (!evaluatorsWhichRequireTerritory.isEmpty() && traversalIntervals == null){\n+            throw new UserException(\"You specified evaluators which require a covered territory to be specified.  \" +\n+                    \"\\nPlease specify intervals or a reference file or disable all of the following evaluators:\" +\n+                    evaluatorsWhichRequireTerritory.stream()\n+                            .collect(Collectors.joining(\", \")));\n+        }\n+    }\n+\n+    private void checkForIncompatibleEvaluatorsAndStratifiers( final List<VariantStratifier> stratificationObjects,\n+                                                               Set<Class<? extends VariantEvaluator>> evaluationClasses) {\n+        for ( final VariantStratifier vs : stratificationObjects ) {\n+            for ( Class<? extends VariantEvaluator> ec : evaluationClasses )\n+                if ( vs.getIncompatibleEvaluators().contains(ec) )\n+                    throw new CommandLineException.BadArgumentValue(\"ST and ET\",\n+                            \"The selected stratification \" + vs.getName() +\n+                                    \" and evaluator \" + ec.getSimpleName() +\n+                                    \" are incompatible due to combinatorial memory requirements.\" +\n+                                    \" Please disable one\");\n+        }\n+    }\n+\n+    protected void createStratificationStates(final List<VariantStratifier> stratificationObjects, final Set<Class<? extends VariantEvaluator>> evaluationObjects) {\n+        final List<VariantStratifier> strats = new ArrayList<VariantStratifier>(stratificationObjects);\n+        stratManager = new StratificationManager<>(strats);\n+\n+        logger.info(\"Creating \" + stratManager.size() + \" combinatorial stratification states\");\n+        for ( int i = 0; i < stratManager.size(); i++ ) {\n+            EvaluationContext ec = createEvaluationContext(evaluationObjects);\n+            stratManager.set(i, ec);\n+        }\n+    }\n+\n+    public void finalizeReport(File outFile) {\n+        // go through the evaluations and finalize them\n+        for ( final EvaluationContext nec : stratManager.values() )\n+            for ( final VariantEvaluator ve : nec.getVariantEvaluators() )\n+                ve.finalizeEvaluation(this);\n+\n+        //send data to MetricsCollection\n+        CompOverlap compOverlap = null;\n+        IndelSummary indelSummary = null;\n+        CountVariants countVariants = null;\n+        MultiallelicSummary multiallelicSummary = null;\n+        TiTvVariantEvaluator tiTvVariantEvaluator = null;\n+        MetricsCollection metricsCollection = null;\n+        for (final EvaluationContext nec: stratManager.values()) {\n+            for (final VariantEvaluator ve : nec.getVariantEvaluators()) {\n+                if (ve instanceof CompOverlap)\n+                    compOverlap = (CompOverlap) ve;\n+                else if (ve instanceof IndelSummary)\n+                    indelSummary = (IndelSummary) ve;\n+                else if (ve instanceof CountVariants)\n+                    countVariants = (CountVariants) ve;\n+                else if (ve instanceof MultiallelicSummary)\n+                    multiallelicSummary = (MultiallelicSummary) ve;\n+                else if (ve instanceof TiTvVariantEvaluator)\n+                    tiTvVariantEvaluator = (TiTvVariantEvaluator) ve;\n+                else if (ve instanceof MetricsCollection)\n+                    metricsCollection = (MetricsCollection) ve;\n+            }\n+\n+            if (metricsCollection != null)\n+                metricsCollection.setData(compOverlap.concordantRate, indelSummary.n_SNPs, countVariants.nSNPs, indelSummary.n_indels, multiallelicSummary.nIndels, indelSummary.insertion_to_deletion_ratio, countVariants.insertionDeletionRatio, tiTvVariantEvaluator.tiTvRatio);\n+        }\n+\n+        try (PrintStream out = IOUtils.makePrintStreamMaybeGzipped(new GATKPath(outFile.getAbsolutePath()))) {\n+            VariantEvalReportWriter.writeReport(out, stratManager, stratManager.getStratifiers(), stratManager.get(0).getVariantEvaluators());\n+        }\n+        catch(IOException e) {\n+            throw new UserException.CouldNotCreateOutputFile(e.getMessage(), e);\n+        }\n+    }\n+\n+    private Map<FeatureInput<VariantContext>, List<VariantContext>> groupVariantsByFeatureInput(final List<VariantContext> variants) {\n+        final Map<FeatureInput<VariantContext>, List<VariantContext>> byFeatureInput = new HashMap<>();\n+        variants.forEach(vc -> byFeatureInput.compute(drivingVariantSourceMap.get(vc.getSource()),\n+                (k, v) -> {\n+                    final List<VariantContext> variantList = v == null ? new ArrayList<>() : v;\n+                    variantList.add(vc);\n+                    return variantList;\n+                }\n+        ));\n+        return byFeatureInput;\n+    }\n+\n+    public void apply(final List<VariantContext> variantContexts, final ReferenceContext referenceContext) {\n+        final Map<FeatureInput<VariantContext>, List<VariantContext>> variantMap = groupVariantsByFeatureInput(variantContexts);\n+\n+        final List<VariantContext> allEvals = new ArrayList<>();\n+        for (FeatureInput<VariantContext> eval : variantEvalArgs.evals) {\n+            if (variantMap.containsKey(eval)) {\n+                allEvals.addAll(variantMap.get(eval));\n+            }\n+        }\n+\n+        final List<VariantContext> allComps = new ArrayList<>();\n+        if (variantEvalArgs.comps != null) {\n+            for (FeatureInput<VariantContext> comp : variantEvalArgs.comps) {\n+                if (variantMap.containsKey(comp)) {\n+                    allComps.addAll(variantMap.get(comp));\n+                }\n+            }\n+        }\n+\n+        final SimpleInterval interval = allEvals.isEmpty() ? new SimpleInterval(variantContexts.get(0).getContig(), variantContexts.get(0).getStart(), variantContexts.get(0).getStart()) : generateContextInterval(allEvals);\n+        final FeatureContext featureContext = new FeatureContext(features, interval);\n+\n+        final Map<FeatureInput<VariantContext>, HashMap<String, Collection<VariantContext>>> evalVCs = allEvals.isEmpty() ? Collections.emptyMap() : bindVariantContexts(variantMap, variantEvalArgs.evals, byFilterIsEnabled, true, perSampleIsEnabled, perFamilyIsEnabled, variantEvalArgs.mergeEvals);\n+        final Map<FeatureInput<VariantContext>, HashMap<String, Collection<VariantContext>>> compVCs = allComps.isEmpty() ? Collections.emptyMap() : bindVariantContexts(variantMap, variantEvalArgs.comps, byFilterIsEnabled, false, false, false, false);\n+\n+        final VariantEvalContext variantEvalContext = new VariantEvalContext(referenceContext, featureContext, variantMap, this);\n+\n+        // for each eval track\n+        for ( final FeatureInput<VariantContext> evalInput : variantEvalArgs.evals ) {\n+            final Map<String, Collection<VariantContext>> evalSet = evalVCs.containsKey(evalInput) ? evalVCs.get(evalInput) : Collections.emptyMap();\n+\n+            Set<String> statificationLevels;\n+\n+            // for each sample stratifier\n+            if (perFamilyIsEnabled)\n+                statificationLevels = familyNamesForStratification;\n+            else\n+                statificationLevels = sampleNamesForStratification;\n+            for ( final String stratLevelName : statificationLevels ) {\n+                Collection<VariantContext> evalSetBySample = evalSet.get(stratLevelName);\n+\n+                if ( evalSetBySample == null ) {\n+                    evalSetBySample = new HashSet<>(1);\n+                    evalSetBySample.add(null);\n+                }\n+\n+                // for each eval in the track\n+                for ( VariantContext eval : evalSetBySample ) {\n+                    String aastr = (ancestralAlignments == null) ? null : new String(ancestralAlignments.getSubsequenceAt(eval.getContig(), eval.getStart(), eval.getEnd()).getBases());\n+\n+                    // deal with ancestral alleles if requested\n+                    if ( eval != null && aastr != null ) {\n+                        eval = new VariantContextBuilder(eval).attribute(\"ANCESTRALALLELE\", aastr).make();\n+                    }\n+\n+                    String evalName = getNameForInput(evalInput);\n+\n+                    // for each comp track\n+                    for ( final FeatureInput<VariantContext> compInput : variantEvalArgs.comps ) {\n+                        processComp(variantEvalContext, eval, evalName, compInput, stratLevelName, compVCs, evalSetBySample);\n+                    }\n+\n+                    if (variantEvalArgs.comps.isEmpty()) {\n+                        processComp(variantEvalContext, eval, evalName, null, stratLevelName, compVCs, evalSetBySample);\n+                    }\n+                }\n+            }\n+\n+            if ( variantEvalArgs.mergeEvals ) break; // stop processing the eval tracks\n+        }\n+    }\n+\n+\n+    /**\n+     * Create the EvaluationContext (new instance) for the provided set of VariantEvaluators.\n+     *\n+     * @param evaluationObjects The list of VariantEvaluator classes\n+     * @return The EvaluationContext for this set of VariantEvaluator classes\n+     */\n+    protected EvaluationContext createEvaluationContext(final Set<Class<? extends VariantEvaluator>> evaluationObjects) {\n+        return new EvaluationContext(this, evaluationObjects);\n+    }\n+\n+    public boolean isSubsettingToSpecificSamples() { return isSubsettingSamples; }\n+\n+    public Set<String> getSampleNamesForEvaluation() { return sampleNamesForEvaluation; }\n+\n+    public Set<String> getFamilyNamesForEvaluation() { return familyNamesForEvaluation; }\n+\n+    public int getNumberOfSamplesForEvaluation() {\n+        if (sampleNamesForEvaluation!= null &&  !sampleNamesForEvaluation.isEmpty())\n+            return sampleNamesForEvaluation.size();\n+        else {\n+            return variantEvalArgs.numSamplesFromArgument;\n+        }\n+    }\n+    public Set<String> getSampleNamesForStratification() { return sampleNamesForStratification; }\n+\n+    public Set<String> getFamilyNamesForStratification() { return familyNamesForStratification; }\n+\n+    public Set<SortableJexlVCMatchExp> getJexlExpressions() { return jexlExpressions; }\n+\n+\n+    public AlleleFrequency.StratifyingScale getAFScale() { return AFScale; }\n+    public boolean getCompAFStratifier() { return useCompAFStratifier; }\n+\n+    public SampleDB getSampleDB() {\n+        return sampleDB;\n+    }\n+\n+    public List<FeatureInput<VariantContext>> getKnowns() {\n+        return knowns;\n+    }\n+\n+    /**\n+     * If an evaluator calls this method it must override {@link VariantEvaluator#requiresTerritoryToBeSpecified()} to return true.\n+     * @return either the size of the interval list given to the tool or the size of the reference given to the tool\n+     */\n+    public long getnProcessedLoci() {\n+        if (traversalIntervals == null){\n+            throw new GATKException(\"BUG: One of the evaluators used should have overriden requiresTerritoryToBeSpecified, please report this to the developers.\" +\n+                    \"\\nEvaluators: \" + stratManager.values()\n+                    .stream()\n+                    .flatMap(evaluator -> evaluator.getVariantEvaluators().stream())\n+                    .map(VariantEvaluator::getSimpleName)\n+                    .sorted()\n+                    .distinct()\n+                    .collect(Collectors.joining(\", \")));\n+        }\n+        return traversalIntervals.stream().mapToLong(SimpleInterval::size).sum();\n+    }\n+\n+    private boolean compHasMatchingEval(final VariantContext comp, final Collection<VariantContext> evals) {\n+        // find all of the matching comps\n+        for ( final VariantContext eval : evals ) {\n+            if ( eval != null && doEvalAndCompMatch(comp, eval, variantEvalArgs.requireStrictAlleleMatch) != EvalCompMatchType.NO_MATCH )\n+                return true;\n+        }\n+\n+        // nothing matched\n+        return false;\n+    }\n+\n+    private enum EvalCompMatchType { NO_MATCH, STRICT, LENIENT }\n+\n+    private EvalCompMatchType doEvalAndCompMatch(final VariantContext eval, final VariantContext comp, boolean requireStrictAlleleMatch) {\n+        if ( comp.getType() == VariantContext.Type.NO_VARIATION || eval.getType() == VariantContext.Type.NO_VARIATION )\n+            // if either of these are NO_VARIATION they are LENIENT matches\n+            return EvalCompMatchType.LENIENT;\n+\n+        if ( comp.getType() != eval.getType() )\n+            return EvalCompMatchType.NO_MATCH;\n+\n+        // find the comp which matches both the reference allele and alternate allele from eval\n+        final Allele altEval = eval.getAlternateAlleles().size() == 0 ? null : eval.getAlternateAllele(0);\n+        final Allele altComp = comp.getAlternateAlleles().size() == 0 ? null : comp.getAlternateAllele(0);\n+        if ((altEval == null && altComp == null) || (altEval != null && altEval.equals(altComp) && eval.getReference().equals(comp.getReference())))\n+            return EvalCompMatchType.STRICT;\n+        else\n+            return requireStrictAlleleMatch ? EvalCompMatchType.NO_MATCH : EvalCompMatchType.LENIENT;\n+    }\n+\n+    private VariantContext findMatchingComp(final VariantContext eval, final Collection<VariantContext> comps) {\n+        // if no comps, return null\n+        if ( comps == null || comps.isEmpty() )\n+            return null;\n+\n+        // if no eval, return any comp\n+        if ( eval == null )\n+            return comps.iterator().next();\n+\n+        // find all of the matching comps\n+        VariantContext lenientMatch = null;\n+        for ( final VariantContext comp : comps ) {\n+            switch ( doEvalAndCompMatch(comp, eval, variantEvalArgs.requireStrictAlleleMatch) ) {\n+                case STRICT:\n+                    return comp;\n+                case LENIENT:\n+                    if ( lenientMatch == null ) lenientMatch = comp;\n+                    break;\n+                case NO_MATCH:\n+                    // do nothing\n+            }\n+        }\n+\n+        // nothing matched, just return lenientMatch, which might be null\n+        return lenientMatch;\n+    }\n+\n+    private SimpleInterval generateContextInterval(List<VariantContext> variantContexts) {\n+        final int maxEnd = variantContexts.stream().map(VariantContext::getEnd).max(Integer::compareTo).get();\n+\n+        return new SimpleInterval(variantContexts.get(0).getContig(), variantContexts.get(0).getStart(), maxEnd);\n+    }\n+\n+    private void processComp(VariantEvalContext vec, VariantContext eval, String evalName, FeatureInput<VariantContext> compInput, String stratLevelName, Map<FeatureInput<VariantContext>, HashMap<String, Collection<VariantContext>>> compVCs, Collection<VariantContext> evalSetBySample) {\n+        String compName = getNameForInput(compInput);\n+\n+        // no sample stratification for comps\n+        final HashMap<String, Collection<VariantContext>> compSetHash = compInput == null ? null : compVCs.get(compInput);\n+        final Collection<VariantContext> compSet = (compSetHash == null || compSetHash.isEmpty()) ? Collections.<VariantContext>emptyList() : compVCs.get(compInput).values().iterator().next();\n+\n+        // find the comp\n+        final VariantContext comp = findMatchingComp(eval, compSet);\n+\n+        Collection<EvaluationContext> contextsForStratification;\n+        if (perFamilyIsEnabled)\n+            contextsForStratification = getEvaluationContexts(vec, eval, evalName, comp, compName, null, stratLevelName);\n+        else {\n+            String familyID;\n+            if (stratLevelName.equals(\"all\"))\n+                familyID = \"all\";\n+            else\n+                familyID = sampleDB.getSample(stratLevelName).getFamilyID();\n+            contextsForStratification = getEvaluationContexts(vec, eval, evalName, comp, compName, stratLevelName, familyID);\n+        }\n+        for ( EvaluationContext nec : contextsForStratification ) {\n+\n+            // eval against the comp\n+            synchronized (nec) {\n+                nec.apply(vec, comp, eval);\n+            }\n+\n+            // eval=null against all comps of different type that aren't bound to another eval\n+            for ( VariantContext otherComp : compSet ) {\n+                if ( otherComp != comp && ! compHasMatchingEval(otherComp, evalSetBySample) ) {\n+                    synchronized (nec) {\n+                        nec.apply(vec, otherComp, null);\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Given specific eval and comp VCs and the sample name, return an iterable\n+     * over all of the applicable state keys.\n+     *\n+     * this code isn't structured yet for efficiency.  Here we currently are\n+     * doing the following inefficient algorithm:\n+     *\n+     * for each strat:\n+     *   get list of relevant states that eval and comp according to strat\n+     *   add this list of states to a list of list states\n+     *\n+     * then\n+     *\n+     * ask the strat manager to look up all of the keys associated with the combinations\n+     * of these states.  For example, suppose we have a single variant S.  We have active\n+     * strats EvalFeatureInput, CompFeatureInput, and Novelty.  We produce a list that looks like:\n+     *\n+     *   L = [[Eval], [Comp], [All, Novel]]\n+     *\n+     * We then go through the strat manager tree to produce the keys associated with these states:\n+     *\n+     *   K = [0, 1] where EVAL x COMP x ALL = 0 and EVAL x COMP x NOVEL = 1\n+     *\n+     * It's clear that a better\n+     *\n+     *\n+     * @param vec\n+     * @param eval\n+     * @param evalName\n+     * @param comp\n+     * @param compName\n+     * @param sampleName\n+     * @return\n+     */\n+    protected Collection<EvaluationContext> getEvaluationContexts(final VariantEvalContext vec,\n+                                                                  final VariantContext eval,\n+                                                                  final String evalName,\n+                                                                  final VariantContext comp,\n+                                                                  final String compName,\n+                                                                  final String sampleName,\n+                                                                  final String familyName) {\n+        final List<List<Object>> states = new LinkedList<>();\n+        for ( final VariantStratifier vs : stratManager.getStratifiers() ) {\n+            states.add(vs.getRelevantStates(vec, comp, compName, eval, evalName, sampleName, familyName));\n+        }\n+        return stratManager.values(states);\n+    }\n+\n+    protected List<String> getModulesToUse() {\n+        return Collections.unmodifiableList(variantEvalArgs.modulesToUse);\n+    }\n+\n+    /**\n+     * For a list of track names, bind the variant contexts to a trackName->sampleName->VariantContext mapping.\n+     * Additional variant contexts per sample are automatically generated and added to the map unless the sample name\n+     * matches the ALL_SAMPLE_NAME constant.\n+     *\n+     * @return the mapping of track to VC list that should be populated\n+     */\n+    public HashMap<FeatureInput<VariantContext>, HashMap<String, Collection<VariantContext>>>\n+    bindVariantContexts(Map<FeatureInput<VariantContext>, List<VariantContext>> variantMap,\n+                        List<FeatureInput<VariantContext>> tracks,\n+                        boolean byFilter,\n+                        boolean subsetBySample,\n+                        boolean trackPerSample,\n+                        boolean trackPerFamily,\n+                        boolean mergeTracks) {\n+        HashMap<FeatureInput<VariantContext>, HashMap<String, Collection<VariantContext>>> bindings = new HashMap<>();\n+\n+        FeatureInput<VariantContext> firstTrack = tracks.isEmpty() ? null : tracks.get(0);\n+        for (FeatureInput<VariantContext> track : tracks) {\n+            HashMap<String, Collection<VariantContext>> mapping = new HashMap<>();\n+\n+            if (variantMap.containsKey(track)) {\n+                //Note: these are limiting to only those w/ the same start, as was the GATK3 behavior.\n+                for (VariantContext vc : variantMap.get(track)) {\n+\n+                    // First, filter the VariantContext to represent only the samples for evaluation\n+                    VariantContext vcsub = vc;\n+\n+                    if ((subsetBySample) && vc.hasGenotypes())\n+                        vcsub = getSubsetOfVariantContext(vc, getSampleNamesForEvaluation());\n+\n+                    //always add a mapping for all samples together\n+                    if ((byFilter || !vcsub.isFiltered())) {\n+                        addMapping(mapping, VariantEvalArgumentCollection.ALL_SAMPLE_NAME, vcsub);\n+                    }\n+\n+                    // Now, if stratifying, split the subsetted vc per sample and add each as a new context\n+                    if (vc.hasGenotypes() && trackPerSample) {\n+                        for (String sampleName : getSampleNamesForEvaluation()) {\n+                            final VariantContext samplevc = getSubsetOfVariantContext(vc, sampleName);\n+\n+                            if (byFilter || !samplevc.isFiltered()) {\n+                                addMapping(mapping, sampleName, samplevc);\n+                            }\n+                        }\n+                    } else if (vc.hasGenotypes() && trackPerFamily) {\n+                        for (final String familyName : getFamilyNamesForEvaluation()) {\n+                            Set<String> familyMemberNames;\n+                            //if the current stratification family name is \"all\", then add all the families to the VC for evaluation here\n+                            if (familyName.equals(VariantEvalArgumentCollection.ALL_FAMILY_NAME)) {\n+                                familyMemberNames = getSampleNamesForEvaluation();\n+                            } else {\n+                                familyMemberNames = getSampleDB().getFamily(familyName).stream().map(Sample::getID).collect(Collectors.toSet());\n+                            }\n+                            final VariantContext samplevc = getSubsetOfVariantContext(vc, familyMemberNames);\n+\n+                            if (byFilter || !samplevc.isFiltered()) {\n+                                addMapping(mapping, familyName, samplevc);\n+                            }\n+                        }\n+                    }\n+                }\n+            }\n+\n+            if (mergeTracks && bindings.containsKey(firstTrack)) {\n+                // go through each binding of sample -> value and add all of the bindings from this entry\n+                HashMap<String, Collection<VariantContext>> firstMapping = bindings.get(firstTrack);\n+                for (Map.Entry<String, Collection<VariantContext>> elt : mapping.entrySet()) {\n+                    Collection<VariantContext> firstMappingSet = firstMapping.get(elt.getKey());\n+                    if (firstMappingSet != null) {\n+                        firstMappingSet.addAll(elt.getValue());\n+                    } else {\n+                        firstMapping.put(elt.getKey(), elt.getValue());\n+                    }\n+                }\n+            } else {\n+                bindings.put(track, mapping);\n+            }\n+        }\n+\n+        return bindings;\n+    }\n+\n+    private void addMapping(HashMap<String, Collection<VariantContext>> mappings, String sample, VariantContext vc) {\n+        if (!mappings.containsKey(sample))\n+            mappings.put(sample, new ArrayList<>(1));\n+        mappings.get(sample).add(vc);\n+    }\n+\n+    /**\n+     * Subset a VariantContext to a single sample\n+     *\n+     * @param vc         the VariantContext object containing multiple samples\n+     * @param sampleName the sample to pull out of the VariantContext\n+     * @return a new VariantContext with just the requested sample\n+     */\n+    public VariantContext getSubsetOfVariantContext(VariantContext vc, String sampleName) {\n+        return getSubsetOfVariantContext(vc, Collections.singleton(sampleName));\n+    }\n+\n+    /**\n+     * Subset a VariantContext to a set of samples\n+     *\n+     * @param vc          the VariantContext object containing multiple samples\n+     * @param sampleNames the samples to pull out of the VariantContext\n+     * @return a new VariantContext with just the requested samples\n+     */\n+    public VariantContext getSubsetOfVariantContext(VariantContext vc, Set<String> sampleNames) {\n+        // if we want to preserve AC0 sites as polymorphic we need to not rederive alleles\n+        final boolean deriveAlleles = ignoreAC0Sites();\n+        return ensureAnnotations(vc, vc.subContextFromSamples(sampleNames, deriveAlleles));\n+    }\n+\n+    public VariantContext ensureAnnotations(final VariantContext vc, final VariantContext vcsub) {\n+        final int originalAlleleCount = vc.getHetCount() + 2 * vc.getHomVarCount();\n+        final int newAlleleCount = vcsub.getHetCount() + 2 * vcsub.getHomVarCount();\n+        final boolean isSingleton = originalAlleleCount == newAlleleCount && newAlleleCount == 1;\n+        final boolean hasChrCountAnnotations = vcsub.hasAttribute(VCFConstants.ALLELE_COUNT_KEY) &&\n+                vcsub.hasAttribute(VCFConstants.ALLELE_FREQUENCY_KEY) &&\n+                vcsub.hasAttribute(VCFConstants.ALLELE_NUMBER_KEY);\n+\n+        if ( ! isSingleton && hasChrCountAnnotations ) {\n+            // nothing to update\n+            return vcsub;\n+        } else {\n+            // have to do the work\n+            VariantContextBuilder builder = new VariantContextBuilder(vcsub);\n+\n+            if ( isSingleton )\n+                builder.attribute(IS_SINGLETON_KEY, true);\n+\n+            if ( ! hasChrCountAnnotations )\n+                VariantContextUtils.calculateChromosomeCounts(builder, true);\n+\n+            return builder.make();\n+        }\n+    }\n+\n+    /**\n+     * Initialize required, standard and user-specified stratification objects\n+     *\n+     * @param noStandardStrats  don't use the standard stratifications\n+     * @param modulesToUse      the list of stratification modules to use\n+     * @return set of stratifications to use\n+     */\n+    public List<VariantStratifier> initializeStratificationObjects(boolean noStandardStrats, List<String> modulesToUse) {\n+        TreeSet<VariantStratifier> strats = new TreeSet<>();\n+        Set<String> stratsToUse = new HashSet<>(requiredStratificationNames);\n+\n+        // By default, use standard stratification modules.\n+        if (!noStandardStrats) {\n+            stratsToUse.addAll(standardStratificationNames);\n+        }\n+\n+        // Now add the user-selected modules\n+        stratsToUse.addAll(modulesToUse);\n+\n+        // Instantiate the stratifications\n+        for (String module : stratsToUse) {\n+            if (!stratifierClasses.containsKey(module)) {\n+                throw new CommandLineException(\"Module \" + module + \" could not be found; please check that you have specified the class name correctly\");\n+            }\n+\n+            if (stratifierClasses.containsKey(module)) {\n+                Class<? extends VariantStratifier> c = stratifierClasses.get(module);\n+\n+                VariantStratifier vs = ClassUtils.makeInstanceOf(c);\n+                vs.initialize(this);\n+                strats.add(vs);\n+            }\n+        }\n+\n+        return new ArrayList<>(strats);\n+    }\n+\n+    /**\n+     * Initialize required, standard and user-specified evaluation objects\n+     *\n+     * @param noStandardEvals don't use the standard evaluations\n+     * @param modulesToUse    the list of evaluation modules to use\n+     * @return set of evaluations to use\n+     */\n+    public Set<Class<? extends VariantEvaluator>> initializeEvaluationObjects(boolean noStandardEvals, List<String> modulesToUse) {\n+        Set<String> evalsToUse = new TreeSet<>(modulesToUse);\n+\n+        // By default, use standard eval modules.\n+        if (!noStandardEvals) {\n+            evalsToUse.addAll(standardEvaluatorNames);\n+        }\n+\n+        // Get the specific classes provided.\n+        Set<Class<? extends VariantEvaluator>> evals = new HashSet<>();\n+        for (String module : evalsToUse) {\n+            if (!evaluatorClasses.containsKey(module)) {\n+                throw new CommandLineException(\"Module \" + module + \" could not be found; please check that you have specified the class name correctly\");\n+            }\n+\n+            evals.add(evaluatorClasses.get(module));\n+        }\n+\n+        //add MetricsCollection if required modules are included\n+        if (evals.contains(evaluatorClasses.get(\"CompOverlap\")) && evals.contains(evaluatorClasses.get(\"IndelSummary\")) && evals.contains(evaluatorClasses.get(\"TiTvVariantEvaluator\")) && evals.contains(evaluatorClasses.get(\"CountVariants\")) && evals.contains(evaluatorClasses.get(\"MultiallelicSummary\")) )\n+            evals.add(evaluatorClasses.get(\"MetricsCollection\"));\n+\n+        return evals;\n+    }\n+\n+    public static Map<String, Class<? extends VariantStratifier>> getStratifierClasses() {\n+        return Collections.unmodifiableMap(stratifierClasses);\n+    }\n+\n+    public static Set<String> getStandardStratificationNames() {\n+        return Collections.unmodifiableSet(standardStratificationNames);\n+    }\n+\n+    public static Set<String> getRequiredStratificationNames() {\n+        return Collections.unmodifiableSet(requiredStratificationNames);\n+    }\n+\n+    public static Map<String, Class<? extends VariantEvaluator>> getEvaluatorClasses() {\n+        return Collections.unmodifiableMap(evaluatorClasses);\n+    }\n+\n+    public static Set<String> getStandardEvaluatorNames() {\n+        return Collections.unmodifiableSet(standardEvaluatorNames);\n+    }\n+\n+    public FeatureInput<Feature> getKnownCNVsFile() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9a8836fdfeb635d275ce71f365bef469718e782a"}, "originalPosition": 873}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NjEzODA4Nw==", "bodyText": "This logger sharing no longer makes sense (it was weird before but it was left over from GATK3). Each class should just use its own logger rather than trying to share one.", "url": "https://github.com/broadinstitute/gatk/pull/6973#discussion_r556138087", "createdAt": "2021-01-12T22:28:11Z", "author": {"login": "cmnbroad"}, "path": "src/main/java/org/broadinstitute/hellbender/tools/walkers/varianteval/VariantEvalEngine.java", "diffHunk": "@@ -0,0 +1,937 @@\n+package org.broadinstitute.hellbender.tools.walkers.varianteval;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import htsjdk.samtools.SAMSequenceDictionary;\n+import htsjdk.samtools.reference.IndexedFastaSequenceFile;\n+import htsjdk.samtools.reference.ReferenceSequenceFile;\n+import htsjdk.tribble.Feature;\n+import htsjdk.variant.variantcontext.Allele;\n+import htsjdk.variant.variantcontext.VariantContext;\n+import htsjdk.variant.variantcontext.VariantContextBuilder;\n+import htsjdk.variant.variantcontext.VariantContextUtils;\n+import htsjdk.variant.vcf.VCFConstants;\n+import htsjdk.variant.vcf.VCFHeader;\n+import org.apache.logging.log4j.Logger;\n+import org.broadinstitute.barclay.argparser.CommandLineException;\n+import org.broadinstitute.hellbender.cmdline.StandardArgumentDefinitions;\n+import org.broadinstitute.hellbender.engine.*;\n+import org.broadinstitute.hellbender.exceptions.GATKException;\n+import org.broadinstitute.hellbender.exceptions.UserException;\n+import org.broadinstitute.hellbender.tools.walkers.varianteval.evaluators.*;\n+import org.broadinstitute.hellbender.tools.walkers.varianteval.stratifications.*;\n+import org.broadinstitute.hellbender.tools.walkers.varianteval.stratifications.manager.StratificationManager;\n+import org.broadinstitute.hellbender.tools.walkers.varianteval.util.EvaluationContext;\n+import org.broadinstitute.hellbender.tools.walkers.varianteval.util.SortableJexlVCMatchExp;\n+import org.broadinstitute.hellbender.tools.walkers.varianteval.util.VariantEvalContext;\n+import org.broadinstitute.hellbender.utils.ClassUtils;\n+import org.broadinstitute.hellbender.utils.SimpleInterval;\n+import org.broadinstitute.hellbender.utils.Utils;\n+import org.broadinstitute.hellbender.utils.io.IOUtils;\n+import org.broadinstitute.hellbender.utils.samples.PedigreeValidationType;\n+import org.broadinstitute.hellbender.utils.samples.Sample;\n+import org.broadinstitute.hellbender.utils.samples.SampleDB;\n+import org.reflections.Reflections;\n+\n+import javax.annotation.Nullable;\n+import java.io.File;\n+import java.io.FileNotFoundException;\n+import java.io.IOException;\n+import java.io.PrintStream;\n+import java.util.*;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * This class allows other classes to replicate the behavior of VariantEval\n+ *\n+ * Usage:\n+ * -Pass the genotype args into the constructor, which will the initialize the engine completely\n+ */\n+public class VariantEvalEngine {\n+    public static final String IS_SINGLETON_KEY = \"ISSINGLETON\";\n+\n+    private final VariantEvalArgumentCollection variantEvalArgs;\n+\n+    private final Logger logger;\n+    private final SAMSequenceDictionary samSequenceDictionaryForDrivingVariants;\n+    private final List<SimpleInterval> traversalIntervals;\n+    private final FeatureManager features;\n+\n+    private final static Map<String, Class<? extends VariantStratifier>> stratifierClasses;\n+    private final static Set<String> standardStratificationNames;\n+    private final static Set<String> requiredStratificationNames;\n+\n+    private final static Map<String, Class<? extends VariantEvaluator>> evaluatorClasses;\n+    private final static Set<String> standardEvaluatorNames;\n+\n+    static {\n+        stratifierClasses = new HashMap<>();\n+        standardStratificationNames = new HashSet<>();\n+        requiredStratificationNames = new HashSet<>();\n+\n+        Reflections reflectionsStrat = new Reflections(VariantStratifier.class.getPackage().getName());\n+        Set<Class<? extends VariantStratifier>> allClasses = reflectionsStrat.getSubTypesOf(VariantStratifier.class);\n+        for (Class<? extends VariantStratifier> clazz : allClasses) {\n+            stratifierClasses.put(clazz.getSimpleName(), clazz);\n+\n+            if (StandardStratification.class.isAssignableFrom(clazz)) {\n+                standardStratificationNames.add(clazz.getSimpleName());\n+            }\n+\n+            if (RequiredStratification.class.isAssignableFrom(clazz)) {\n+                requiredStratificationNames.add(clazz.getSimpleName());\n+            }\n+        }\n+\n+        evaluatorClasses = new HashMap<>();\n+        standardEvaluatorNames= new HashSet<>();\n+\n+        Reflections reflectionsEval = new Reflections(VariantEvaluator.class.getPackage().getName());\n+        Set<Class<? extends VariantEvaluator>> allEvalClasses = reflectionsEval.getSubTypesOf(VariantEvaluator.class);\n+        for (Class<? extends VariantEvaluator> clazz : allEvalClasses) {\n+            evaluatorClasses.put(clazz.getSimpleName(), clazz);\n+\n+            if (StandardEval.class.isAssignableFrom(clazz)) {\n+                standardEvaluatorNames.add(clazz.getSimpleName());\n+            }\n+        }\n+    }\n+\n+    // Ancestral alignments\n+    private ReferenceSequenceFile ancestralAlignments = null;\n+\n+    // The set of all possible evaluation contexts\n+    private StratificationManager<VariantStratifier, EvaluationContext> stratManager;\n+\n+    private SampleDB sampleDB = null;\n+\n+    private List<FeatureInput<VariantContext>> knowns = new ArrayList<>();\n+\n+    // maintain the mapping of FeatureInput to name used in output file\n+    private Map<FeatureInput<VariantContext>, String> inputToNameMap = new HashMap<>();\n+\n+    // Variables\n+    private Set<SortableJexlVCMatchExp> jexlExpressions = new TreeSet<>();\n+\n+    private boolean isSubsettingSamples;\n+    private Set<String> sampleNamesForEvaluation = new LinkedHashSet<>();\n+    private Set<String> familyNamesForEvaluation = new LinkedHashSet<>();\n+    private Set<String> sampleNamesForStratification = new LinkedHashSet<>();\n+    private Set<String> familyNamesForStratification = new LinkedHashSet<>();\n+\n+    // important stratifications\n+    private boolean byFilterIsEnabled = false;\n+    private boolean perSampleIsEnabled = false;\n+    private boolean perFamilyIsEnabled = false;\n+\n+    private AlleleFrequency.StratifyingScale AFScale = AlleleFrequency.StratifyingScale.LINEAR;\n+    private boolean useCompAFStratifier = false;\n+\n+    // maintain the mapping of source name (from VC) to FeatureInput name\n+    private Map<String, FeatureInput<VariantContext>> drivingVariantSourceMap;\n+\n+    // No args constructor for unit testing only\n+    @VisibleForTesting\n+    protected VariantEvalEngine(Logger logger) {\n+        this.variantEvalArgs = new VariantEvalArgumentCollection();\n+        this.logger = logger;\n+        this.samSequenceDictionaryForDrivingVariants = null;\n+        this.traversalIntervals = null;\n+        this.features = null;\n+    }\n+\n+    public VariantEvalEngine(VariantEvalArgumentCollection variantEvalArgs, FeatureManager features, List<SimpleInterval> traversalIntervals, SAMSequenceDictionary samSequenceDictionaryForDrivingVariants, @Nullable Collection<String> samples, Logger logger) {\n+        this.variantEvalArgs = variantEvalArgs;\n+        this.logger = logger;\n+        this.samSequenceDictionaryForDrivingVariants = samSequenceDictionaryForDrivingVariants;\n+        this.traversalIntervals = traversalIntervals;\n+        this.features = features;\n+\n+        // Cache map of source name -> FeatureInput\n+        drivingVariantSourceMap = new HashMap<>();\n+        variantEvalArgs.getFeatureInputsForDrivingVariants().forEach(x -> drivingVariantSourceMap.put(x.getName(), x));\n+\n+        validateAndInitialize(samples);\n+    }\n+\n+    /**\n+     * Initialize the stratifications, evaluations, evaluation contexts, and reporting object\n+     */\n+    private void validateAndInitialize(@Nullable Collection<String> samples) {\n+        sampleDB = SampleDB.createSampleDBFromPedigreeAndDataSources(variantEvalArgs.pedigreeFile, samples, PedigreeValidationType.STRICT);\n+\n+        variantEvalArgs.comps.addAll(variantEvalArgs.compsProvided);\n+        variantEvalArgs.compsProvided.forEach(comp -> inputToNameMap.put(comp, comp.hasUserSuppliedName() ? comp.getName() : StandardArgumentDefinitions.COMPARISON_SHORT_NAME));\n+        if ( variantEvalArgs.dbsnp.dbsnp != null ) {\n+            variantEvalArgs.comps.add(variantEvalArgs.dbsnp.dbsnp);\n+            inputToNameMap.put(variantEvalArgs.dbsnp.dbsnp, \"dbsnp\");\n+            knowns.add(variantEvalArgs.dbsnp.dbsnp);\n+        }\n+\n+        variantEvalArgs.evals.forEach(eval -> inputToNameMap.put(eval, eval.hasUserSuppliedName() ? eval.getName() : \"eval\"));\n+\n+        // Set up set of additional knowns. dbSNP was addressed above, so use compsProvided, not comps\n+        for ( FeatureInput<VariantContext> compInput : variantEvalArgs.compsProvided ) {\n+            if (variantEvalArgs.knownNames.contains(getNameForInput(compInput)))\n+                knowns.add(compInput);\n+        }\n+\n+        // Now that we have all the inputs categorized, determine the sample list from the eval inputs.\n+        Map<String, VCFHeader> vcfInputs = new HashMap<>();\n+        variantEvalArgs.evals.forEach(eval -> vcfInputs.put(eval.getName(), (VCFHeader)features.getHeader(eval)));\n+\n+        Set<String> vcfSamples = new HashSet<>();\n+        vcfInputs.forEach((k,v) -> vcfSamples.addAll(v.getSampleNamesInOrder()));\n+\n+        // Load the sample list, using an intermediate tree set to sort the samples\n+        final Set<String> allSampleNames = new HashSet<>(vcfSamples);\n+        sampleNamesForEvaluation.addAll(new TreeSet<>(variantEvalArgs.sampleExpressions.isEmpty() ? vcfSamples : Utils.filterCollectionByExpressions(vcfSamples, variantEvalArgs.sampleExpressions, false)));\n+\n+        isSubsettingSamples = ! sampleNamesForEvaluation.containsAll(allSampleNames);\n+        familyNamesForEvaluation.addAll(sampleDB.getFamilyIDs());\n+\n+        //If stratifying by sample name, assign a stratification for each sample we're evaluating (based on commandline args)...\n+        if (variantEvalArgs.stratificationsToUse.contains(\"Sample\") ) {\n+            sampleNamesForStratification.addAll(sampleNamesForEvaluation);\n+        }\n+        //...and also a stratification for the sum over all samples\n+        sampleNamesForStratification.add(VariantEvalArgumentCollection.ALL_SAMPLE_NAME);\n+\n+\n+        //If stratifying by sample name, assign a stratification for each family...\n+        if ( variantEvalArgs.stratificationsToUse.contains(\"Family\") ) {\n+            familyNamesForStratification.addAll(familyNamesForEvaluation);\n+        }\n+        //...and also a stratification for the sum over all families\n+        familyNamesForStratification.add(VariantEvalArgumentCollection.ALL_FAMILY_NAME);\n+\n+        // Initialize select expressions\n+        for (VariantContextUtils.JexlVCMatchExp jexl : VariantContextUtils.initializeMatchExps(variantEvalArgs.selectNames, variantEvalArgs.selectExps)) {\n+            SortableJexlVCMatchExp sjexl = new SortableJexlVCMatchExp(jexl.name, jexl.exp);\n+            jexlExpressions.add(sjexl);\n+        }\n+\n+        // Initialize the set of stratifications and evaluations to use\n+        // The list of stratifiers and evaluators to use\n+        final List<VariantStratifier> stratificationObjects = initializeStratificationObjects(variantEvalArgs.noStandardStratifications, variantEvalArgs.stratificationsToUse);\n+        final Set<Class<? extends VariantEvaluator>> evaluationClasses = initializeEvaluationObjects(variantEvalArgs.noStandardModules, variantEvalArgs.modulesToUse);\n+\n+        checkForIncompatibleEvaluatorsAndStratifiers(stratificationObjects, evaluationClasses);\n+\n+\n+        for ( VariantStratifier vs : stratificationObjects ) {\n+            if ( vs.getName().equals(\"Filter\") )\n+                byFilterIsEnabled = true;\n+            else if ( vs.getName().equals(\"Sample\") )\n+                perSampleIsEnabled = true;\n+            else if ( vs.getName().equals(\"Family\"))\n+                perFamilyIsEnabled = true;\n+        }\n+\n+        if (perSampleIsEnabled && perFamilyIsEnabled)\n+            throw new CommandLineException.BadArgumentValue(\"ST\", \"Variants cannot be stratified by sample and family at the same time\");\n+\n+        if (perFamilyIsEnabled && sampleDB.getTrios().isEmpty())\n+            throw new CommandLineException.BadArgumentValue(\"ST\", \"Cannot stratify by family without *.ped file\");\n+\n+\n+        if ( variantEvalArgs.intervalsFile != null ) {\n+            boolean fail = true;\n+            for ( final VariantStratifier vs : stratificationObjects ) {\n+                if ( vs.getClass().equals(IntervalStratification.class) )\n+                    fail = false;\n+            }\n+            if ( fail )\n+                throw new CommandLineException.BadArgumentValue(\"ST\", \"stratIntervals argument provided but -ST IntervalStratification not provided\");\n+        }\n+\n+\n+        // Initialize the evaluation contexts\n+        createStratificationStates(stratificationObjects, evaluationClasses);\n+\n+        // Load ancestral alignments\n+        if (variantEvalArgs.ancestralAlignmentsFile != null) {\n+            try {\n+                ancestralAlignments = new IndexedFastaSequenceFile(variantEvalArgs.ancestralAlignmentsFile.toPath());\n+            } catch (FileNotFoundException e) {\n+                throw new GATKException(String.format(\"The ancestral alignments file, '%s', could not be found\", variantEvalArgs.ancestralAlignmentsFile.getAbsolutePath()));\n+            }\n+        }\n+\n+        assertThatTerritoryIsSpecifiedIfNecessary();\n+    }\n+\n+    public String getNameForInput(FeatureInput<VariantContext> input) {\n+        return inputToNameMap.get(input);\n+    }\n+\n+    private void assertThatTerritoryIsSpecifiedIfNecessary() {\n+        final Set<String> evaluatorsWhichRequireTerritory = stratManager.values()\n+                .stream()\n+                .flatMap(ctx -> ctx.getVariantEvaluators().stream())\n+                .filter(Objects::nonNull)\n+                .filter(VariantEvaluator::requiresTerritoryToBeSpecified)\n+                .map(VariantEvaluator::getSimpleName)\n+                .collect(Collectors.toSet());\n+        if (!evaluatorsWhichRequireTerritory.isEmpty() && traversalIntervals == null){\n+            throw new UserException(\"You specified evaluators which require a covered territory to be specified.  \" +\n+                    \"\\nPlease specify intervals or a reference file or disable all of the following evaluators:\" +\n+                    evaluatorsWhichRequireTerritory.stream()\n+                            .collect(Collectors.joining(\", \")));\n+        }\n+    }\n+\n+    private void checkForIncompatibleEvaluatorsAndStratifiers( final List<VariantStratifier> stratificationObjects,\n+                                                               Set<Class<? extends VariantEvaluator>> evaluationClasses) {\n+        for ( final VariantStratifier vs : stratificationObjects ) {\n+            for ( Class<? extends VariantEvaluator> ec : evaluationClasses )\n+                if ( vs.getIncompatibleEvaluators().contains(ec) )\n+                    throw new CommandLineException.BadArgumentValue(\"ST and ET\",\n+                            \"The selected stratification \" + vs.getName() +\n+                                    \" and evaluator \" + ec.getSimpleName() +\n+                                    \" are incompatible due to combinatorial memory requirements.\" +\n+                                    \" Please disable one\");\n+        }\n+    }\n+\n+    protected void createStratificationStates(final List<VariantStratifier> stratificationObjects, final Set<Class<? extends VariantEvaluator>> evaluationObjects) {\n+        final List<VariantStratifier> strats = new ArrayList<VariantStratifier>(stratificationObjects);\n+        stratManager = new StratificationManager<>(strats);\n+\n+        logger.info(\"Creating \" + stratManager.size() + \" combinatorial stratification states\");\n+        for ( int i = 0; i < stratManager.size(); i++ ) {\n+            EvaluationContext ec = createEvaluationContext(evaluationObjects);\n+            stratManager.set(i, ec);\n+        }\n+    }\n+\n+    public void finalizeReport(File outFile) {\n+        // go through the evaluations and finalize them\n+        for ( final EvaluationContext nec : stratManager.values() )\n+            for ( final VariantEvaluator ve : nec.getVariantEvaluators() )\n+                ve.finalizeEvaluation(this);\n+\n+        //send data to MetricsCollection\n+        CompOverlap compOverlap = null;\n+        IndelSummary indelSummary = null;\n+        CountVariants countVariants = null;\n+        MultiallelicSummary multiallelicSummary = null;\n+        TiTvVariantEvaluator tiTvVariantEvaluator = null;\n+        MetricsCollection metricsCollection = null;\n+        for (final EvaluationContext nec: stratManager.values()) {\n+            for (final VariantEvaluator ve : nec.getVariantEvaluators()) {\n+                if (ve instanceof CompOverlap)\n+                    compOverlap = (CompOverlap) ve;\n+                else if (ve instanceof IndelSummary)\n+                    indelSummary = (IndelSummary) ve;\n+                else if (ve instanceof CountVariants)\n+                    countVariants = (CountVariants) ve;\n+                else if (ve instanceof MultiallelicSummary)\n+                    multiallelicSummary = (MultiallelicSummary) ve;\n+                else if (ve instanceof TiTvVariantEvaluator)\n+                    tiTvVariantEvaluator = (TiTvVariantEvaluator) ve;\n+                else if (ve instanceof MetricsCollection)\n+                    metricsCollection = (MetricsCollection) ve;\n+            }\n+\n+            if (metricsCollection != null)\n+                metricsCollection.setData(compOverlap.concordantRate, indelSummary.n_SNPs, countVariants.nSNPs, indelSummary.n_indels, multiallelicSummary.nIndels, indelSummary.insertion_to_deletion_ratio, countVariants.insertionDeletionRatio, tiTvVariantEvaluator.tiTvRatio);\n+        }\n+\n+        try (PrintStream out = IOUtils.makePrintStreamMaybeGzipped(new GATKPath(outFile.getAbsolutePath()))) {\n+            VariantEvalReportWriter.writeReport(out, stratManager, stratManager.getStratifiers(), stratManager.get(0).getVariantEvaluators());\n+        }\n+        catch(IOException e) {\n+            throw new UserException.CouldNotCreateOutputFile(e.getMessage(), e);\n+        }\n+    }\n+\n+    private Map<FeatureInput<VariantContext>, List<VariantContext>> groupVariantsByFeatureInput(final List<VariantContext> variants) {\n+        final Map<FeatureInput<VariantContext>, List<VariantContext>> byFeatureInput = new HashMap<>();\n+        variants.forEach(vc -> byFeatureInput.compute(drivingVariantSourceMap.get(vc.getSource()),\n+                (k, v) -> {\n+                    final List<VariantContext> variantList = v == null ? new ArrayList<>() : v;\n+                    variantList.add(vc);\n+                    return variantList;\n+                }\n+        ));\n+        return byFeatureInput;\n+    }\n+\n+    public void apply(final List<VariantContext> variantContexts, final ReferenceContext referenceContext) {\n+        final Map<FeatureInput<VariantContext>, List<VariantContext>> variantMap = groupVariantsByFeatureInput(variantContexts);\n+\n+        final List<VariantContext> allEvals = new ArrayList<>();\n+        for (FeatureInput<VariantContext> eval : variantEvalArgs.evals) {\n+            if (variantMap.containsKey(eval)) {\n+                allEvals.addAll(variantMap.get(eval));\n+            }\n+        }\n+\n+        final List<VariantContext> allComps = new ArrayList<>();\n+        if (variantEvalArgs.comps != null) {\n+            for (FeatureInput<VariantContext> comp : variantEvalArgs.comps) {\n+                if (variantMap.containsKey(comp)) {\n+                    allComps.addAll(variantMap.get(comp));\n+                }\n+            }\n+        }\n+\n+        final SimpleInterval interval = allEvals.isEmpty() ? new SimpleInterval(variantContexts.get(0).getContig(), variantContexts.get(0).getStart(), variantContexts.get(0).getStart()) : generateContextInterval(allEvals);\n+        final FeatureContext featureContext = new FeatureContext(features, interval);\n+\n+        final Map<FeatureInput<VariantContext>, HashMap<String, Collection<VariantContext>>> evalVCs = allEvals.isEmpty() ? Collections.emptyMap() : bindVariantContexts(variantMap, variantEvalArgs.evals, byFilterIsEnabled, true, perSampleIsEnabled, perFamilyIsEnabled, variantEvalArgs.mergeEvals);\n+        final Map<FeatureInput<VariantContext>, HashMap<String, Collection<VariantContext>>> compVCs = allComps.isEmpty() ? Collections.emptyMap() : bindVariantContexts(variantMap, variantEvalArgs.comps, byFilterIsEnabled, false, false, false, false);\n+\n+        final VariantEvalContext variantEvalContext = new VariantEvalContext(referenceContext, featureContext, variantMap, this);\n+\n+        // for each eval track\n+        for ( final FeatureInput<VariantContext> evalInput : variantEvalArgs.evals ) {\n+            final Map<String, Collection<VariantContext>> evalSet = evalVCs.containsKey(evalInput) ? evalVCs.get(evalInput) : Collections.emptyMap();\n+\n+            Set<String> statificationLevels;\n+\n+            // for each sample stratifier\n+            if (perFamilyIsEnabled)\n+                statificationLevels = familyNamesForStratification;\n+            else\n+                statificationLevels = sampleNamesForStratification;\n+            for ( final String stratLevelName : statificationLevels ) {\n+                Collection<VariantContext> evalSetBySample = evalSet.get(stratLevelName);\n+\n+                if ( evalSetBySample == null ) {\n+                    evalSetBySample = new HashSet<>(1);\n+                    evalSetBySample.add(null);\n+                }\n+\n+                // for each eval in the track\n+                for ( VariantContext eval : evalSetBySample ) {\n+                    String aastr = (ancestralAlignments == null) ? null : new String(ancestralAlignments.getSubsequenceAt(eval.getContig(), eval.getStart(), eval.getEnd()).getBases());\n+\n+                    // deal with ancestral alleles if requested\n+                    if ( eval != null && aastr != null ) {\n+                        eval = new VariantContextBuilder(eval).attribute(\"ANCESTRALALLELE\", aastr).make();\n+                    }\n+\n+                    String evalName = getNameForInput(evalInput);\n+\n+                    // for each comp track\n+                    for ( final FeatureInput<VariantContext> compInput : variantEvalArgs.comps ) {\n+                        processComp(variantEvalContext, eval, evalName, compInput, stratLevelName, compVCs, evalSetBySample);\n+                    }\n+\n+                    if (variantEvalArgs.comps.isEmpty()) {\n+                        processComp(variantEvalContext, eval, evalName, null, stratLevelName, compVCs, evalSetBySample);\n+                    }\n+                }\n+            }\n+\n+            if ( variantEvalArgs.mergeEvals ) break; // stop processing the eval tracks\n+        }\n+    }\n+\n+\n+    /**\n+     * Create the EvaluationContext (new instance) for the provided set of VariantEvaluators.\n+     *\n+     * @param evaluationObjects The list of VariantEvaluator classes\n+     * @return The EvaluationContext for this set of VariantEvaluator classes\n+     */\n+    protected EvaluationContext createEvaluationContext(final Set<Class<? extends VariantEvaluator>> evaluationObjects) {\n+        return new EvaluationContext(this, evaluationObjects);\n+    }\n+\n+    public boolean isSubsettingToSpecificSamples() { return isSubsettingSamples; }\n+\n+    public Set<String> getSampleNamesForEvaluation() { return sampleNamesForEvaluation; }\n+\n+    public Set<String> getFamilyNamesForEvaluation() { return familyNamesForEvaluation; }\n+\n+    public int getNumberOfSamplesForEvaluation() {\n+        if (sampleNamesForEvaluation!= null &&  !sampleNamesForEvaluation.isEmpty())\n+            return sampleNamesForEvaluation.size();\n+        else {\n+            return variantEvalArgs.numSamplesFromArgument;\n+        }\n+    }\n+    public Set<String> getSampleNamesForStratification() { return sampleNamesForStratification; }\n+\n+    public Set<String> getFamilyNamesForStratification() { return familyNamesForStratification; }\n+\n+    public Set<SortableJexlVCMatchExp> getJexlExpressions() { return jexlExpressions; }\n+\n+\n+    public AlleleFrequency.StratifyingScale getAFScale() { return AFScale; }\n+    public boolean getCompAFStratifier() { return useCompAFStratifier; }\n+\n+    public SampleDB getSampleDB() {\n+        return sampleDB;\n+    }\n+\n+    public List<FeatureInput<VariantContext>> getKnowns() {\n+        return knowns;\n+    }\n+\n+    /**\n+     * If an evaluator calls this method it must override {@link VariantEvaluator#requiresTerritoryToBeSpecified()} to return true.\n+     * @return either the size of the interval list given to the tool or the size of the reference given to the tool\n+     */\n+    public long getnProcessedLoci() {\n+        if (traversalIntervals == null){\n+            throw new GATKException(\"BUG: One of the evaluators used should have overriden requiresTerritoryToBeSpecified, please report this to the developers.\" +\n+                    \"\\nEvaluators: \" + stratManager.values()\n+                    .stream()\n+                    .flatMap(evaluator -> evaluator.getVariantEvaluators().stream())\n+                    .map(VariantEvaluator::getSimpleName)\n+                    .sorted()\n+                    .distinct()\n+                    .collect(Collectors.joining(\", \")));\n+        }\n+        return traversalIntervals.stream().mapToLong(SimpleInterval::size).sum();\n+    }\n+\n+    private boolean compHasMatchingEval(final VariantContext comp, final Collection<VariantContext> evals) {\n+        // find all of the matching comps\n+        for ( final VariantContext eval : evals ) {\n+            if ( eval != null && doEvalAndCompMatch(comp, eval, variantEvalArgs.requireStrictAlleleMatch) != EvalCompMatchType.NO_MATCH )\n+                return true;\n+        }\n+\n+        // nothing matched\n+        return false;\n+    }\n+\n+    private enum EvalCompMatchType { NO_MATCH, STRICT, LENIENT }\n+\n+    private EvalCompMatchType doEvalAndCompMatch(final VariantContext eval, final VariantContext comp, boolean requireStrictAlleleMatch) {\n+        if ( comp.getType() == VariantContext.Type.NO_VARIATION || eval.getType() == VariantContext.Type.NO_VARIATION )\n+            // if either of these are NO_VARIATION they are LENIENT matches\n+            return EvalCompMatchType.LENIENT;\n+\n+        if ( comp.getType() != eval.getType() )\n+            return EvalCompMatchType.NO_MATCH;\n+\n+        // find the comp which matches both the reference allele and alternate allele from eval\n+        final Allele altEval = eval.getAlternateAlleles().size() == 0 ? null : eval.getAlternateAllele(0);\n+        final Allele altComp = comp.getAlternateAlleles().size() == 0 ? null : comp.getAlternateAllele(0);\n+        if ((altEval == null && altComp == null) || (altEval != null && altEval.equals(altComp) && eval.getReference().equals(comp.getReference())))\n+            return EvalCompMatchType.STRICT;\n+        else\n+            return requireStrictAlleleMatch ? EvalCompMatchType.NO_MATCH : EvalCompMatchType.LENIENT;\n+    }\n+\n+    private VariantContext findMatchingComp(final VariantContext eval, final Collection<VariantContext> comps) {\n+        // if no comps, return null\n+        if ( comps == null || comps.isEmpty() )\n+            return null;\n+\n+        // if no eval, return any comp\n+        if ( eval == null )\n+            return comps.iterator().next();\n+\n+        // find all of the matching comps\n+        VariantContext lenientMatch = null;\n+        for ( final VariantContext comp : comps ) {\n+            switch ( doEvalAndCompMatch(comp, eval, variantEvalArgs.requireStrictAlleleMatch) ) {\n+                case STRICT:\n+                    return comp;\n+                case LENIENT:\n+                    if ( lenientMatch == null ) lenientMatch = comp;\n+                    break;\n+                case NO_MATCH:\n+                    // do nothing\n+            }\n+        }\n+\n+        // nothing matched, just return lenientMatch, which might be null\n+        return lenientMatch;\n+    }\n+\n+    private SimpleInterval generateContextInterval(List<VariantContext> variantContexts) {\n+        final int maxEnd = variantContexts.stream().map(VariantContext::getEnd).max(Integer::compareTo).get();\n+\n+        return new SimpleInterval(variantContexts.get(0).getContig(), variantContexts.get(0).getStart(), maxEnd);\n+    }\n+\n+    private void processComp(VariantEvalContext vec, VariantContext eval, String evalName, FeatureInput<VariantContext> compInput, String stratLevelName, Map<FeatureInput<VariantContext>, HashMap<String, Collection<VariantContext>>> compVCs, Collection<VariantContext> evalSetBySample) {\n+        String compName = getNameForInput(compInput);\n+\n+        // no sample stratification for comps\n+        final HashMap<String, Collection<VariantContext>> compSetHash = compInput == null ? null : compVCs.get(compInput);\n+        final Collection<VariantContext> compSet = (compSetHash == null || compSetHash.isEmpty()) ? Collections.<VariantContext>emptyList() : compVCs.get(compInput).values().iterator().next();\n+\n+        // find the comp\n+        final VariantContext comp = findMatchingComp(eval, compSet);\n+\n+        Collection<EvaluationContext> contextsForStratification;\n+        if (perFamilyIsEnabled)\n+            contextsForStratification = getEvaluationContexts(vec, eval, evalName, comp, compName, null, stratLevelName);\n+        else {\n+            String familyID;\n+            if (stratLevelName.equals(\"all\"))\n+                familyID = \"all\";\n+            else\n+                familyID = sampleDB.getSample(stratLevelName).getFamilyID();\n+            contextsForStratification = getEvaluationContexts(vec, eval, evalName, comp, compName, stratLevelName, familyID);\n+        }\n+        for ( EvaluationContext nec : contextsForStratification ) {\n+\n+            // eval against the comp\n+            synchronized (nec) {\n+                nec.apply(vec, comp, eval);\n+            }\n+\n+            // eval=null against all comps of different type that aren't bound to another eval\n+            for ( VariantContext otherComp : compSet ) {\n+                if ( otherComp != comp && ! compHasMatchingEval(otherComp, evalSetBySample) ) {\n+                    synchronized (nec) {\n+                        nec.apply(vec, otherComp, null);\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Given specific eval and comp VCs and the sample name, return an iterable\n+     * over all of the applicable state keys.\n+     *\n+     * this code isn't structured yet for efficiency.  Here we currently are\n+     * doing the following inefficient algorithm:\n+     *\n+     * for each strat:\n+     *   get list of relevant states that eval and comp according to strat\n+     *   add this list of states to a list of list states\n+     *\n+     * then\n+     *\n+     * ask the strat manager to look up all of the keys associated with the combinations\n+     * of these states.  For example, suppose we have a single variant S.  We have active\n+     * strats EvalFeatureInput, CompFeatureInput, and Novelty.  We produce a list that looks like:\n+     *\n+     *   L = [[Eval], [Comp], [All, Novel]]\n+     *\n+     * We then go through the strat manager tree to produce the keys associated with these states:\n+     *\n+     *   K = [0, 1] where EVAL x COMP x ALL = 0 and EVAL x COMP x NOVEL = 1\n+     *\n+     * It's clear that a better\n+     *\n+     *\n+     * @param vec\n+     * @param eval\n+     * @param evalName\n+     * @param comp\n+     * @param compName\n+     * @param sampleName\n+     * @return\n+     */\n+    protected Collection<EvaluationContext> getEvaluationContexts(final VariantEvalContext vec,\n+                                                                  final VariantContext eval,\n+                                                                  final String evalName,\n+                                                                  final VariantContext comp,\n+                                                                  final String compName,\n+                                                                  final String sampleName,\n+                                                                  final String familyName) {\n+        final List<List<Object>> states = new LinkedList<>();\n+        for ( final VariantStratifier vs : stratManager.getStratifiers() ) {\n+            states.add(vs.getRelevantStates(vec, comp, compName, eval, evalName, sampleName, familyName));\n+        }\n+        return stratManager.values(states);\n+    }\n+\n+    protected List<String> getModulesToUse() {\n+        return Collections.unmodifiableList(variantEvalArgs.modulesToUse);\n+    }\n+\n+    /**\n+     * For a list of track names, bind the variant contexts to a trackName->sampleName->VariantContext mapping.\n+     * Additional variant contexts per sample are automatically generated and added to the map unless the sample name\n+     * matches the ALL_SAMPLE_NAME constant.\n+     *\n+     * @return the mapping of track to VC list that should be populated\n+     */\n+    public HashMap<FeatureInput<VariantContext>, HashMap<String, Collection<VariantContext>>>\n+    bindVariantContexts(Map<FeatureInput<VariantContext>, List<VariantContext>> variantMap,\n+                        List<FeatureInput<VariantContext>> tracks,\n+                        boolean byFilter,\n+                        boolean subsetBySample,\n+                        boolean trackPerSample,\n+                        boolean trackPerFamily,\n+                        boolean mergeTracks) {\n+        HashMap<FeatureInput<VariantContext>, HashMap<String, Collection<VariantContext>>> bindings = new HashMap<>();\n+\n+        FeatureInput<VariantContext> firstTrack = tracks.isEmpty() ? null : tracks.get(0);\n+        for (FeatureInput<VariantContext> track : tracks) {\n+            HashMap<String, Collection<VariantContext>> mapping = new HashMap<>();\n+\n+            if (variantMap.containsKey(track)) {\n+                //Note: these are limiting to only those w/ the same start, as was the GATK3 behavior.\n+                for (VariantContext vc : variantMap.get(track)) {\n+\n+                    // First, filter the VariantContext to represent only the samples for evaluation\n+                    VariantContext vcsub = vc;\n+\n+                    if ((subsetBySample) && vc.hasGenotypes())\n+                        vcsub = getSubsetOfVariantContext(vc, getSampleNamesForEvaluation());\n+\n+                    //always add a mapping for all samples together\n+                    if ((byFilter || !vcsub.isFiltered())) {\n+                        addMapping(mapping, VariantEvalArgumentCollection.ALL_SAMPLE_NAME, vcsub);\n+                    }\n+\n+                    // Now, if stratifying, split the subsetted vc per sample and add each as a new context\n+                    if (vc.hasGenotypes() && trackPerSample) {\n+                        for (String sampleName : getSampleNamesForEvaluation()) {\n+                            final VariantContext samplevc = getSubsetOfVariantContext(vc, sampleName);\n+\n+                            if (byFilter || !samplevc.isFiltered()) {\n+                                addMapping(mapping, sampleName, samplevc);\n+                            }\n+                        }\n+                    } else if (vc.hasGenotypes() && trackPerFamily) {\n+                        for (final String familyName : getFamilyNamesForEvaluation()) {\n+                            Set<String> familyMemberNames;\n+                            //if the current stratification family name is \"all\", then add all the families to the VC for evaluation here\n+                            if (familyName.equals(VariantEvalArgumentCollection.ALL_FAMILY_NAME)) {\n+                                familyMemberNames = getSampleNamesForEvaluation();\n+                            } else {\n+                                familyMemberNames = getSampleDB().getFamily(familyName).stream().map(Sample::getID).collect(Collectors.toSet());\n+                            }\n+                            final VariantContext samplevc = getSubsetOfVariantContext(vc, familyMemberNames);\n+\n+                            if (byFilter || !samplevc.isFiltered()) {\n+                                addMapping(mapping, familyName, samplevc);\n+                            }\n+                        }\n+                    }\n+                }\n+            }\n+\n+            if (mergeTracks && bindings.containsKey(firstTrack)) {\n+                // go through each binding of sample -> value and add all of the bindings from this entry\n+                HashMap<String, Collection<VariantContext>> firstMapping = bindings.get(firstTrack);\n+                for (Map.Entry<String, Collection<VariantContext>> elt : mapping.entrySet()) {\n+                    Collection<VariantContext> firstMappingSet = firstMapping.get(elt.getKey());\n+                    if (firstMappingSet != null) {\n+                        firstMappingSet.addAll(elt.getValue());\n+                    } else {\n+                        firstMapping.put(elt.getKey(), elt.getValue());\n+                    }\n+                }\n+            } else {\n+                bindings.put(track, mapping);\n+            }\n+        }\n+\n+        return bindings;\n+    }\n+\n+    private void addMapping(HashMap<String, Collection<VariantContext>> mappings, String sample, VariantContext vc) {\n+        if (!mappings.containsKey(sample))\n+            mappings.put(sample, new ArrayList<>(1));\n+        mappings.get(sample).add(vc);\n+    }\n+\n+    /**\n+     * Subset a VariantContext to a single sample\n+     *\n+     * @param vc         the VariantContext object containing multiple samples\n+     * @param sampleName the sample to pull out of the VariantContext\n+     * @return a new VariantContext with just the requested sample\n+     */\n+    public VariantContext getSubsetOfVariantContext(VariantContext vc, String sampleName) {\n+        return getSubsetOfVariantContext(vc, Collections.singleton(sampleName));\n+    }\n+\n+    /**\n+     * Subset a VariantContext to a set of samples\n+     *\n+     * @param vc          the VariantContext object containing multiple samples\n+     * @param sampleNames the samples to pull out of the VariantContext\n+     * @return a new VariantContext with just the requested samples\n+     */\n+    public VariantContext getSubsetOfVariantContext(VariantContext vc, Set<String> sampleNames) {\n+        // if we want to preserve AC0 sites as polymorphic we need to not rederive alleles\n+        final boolean deriveAlleles = ignoreAC0Sites();\n+        return ensureAnnotations(vc, vc.subContextFromSamples(sampleNames, deriveAlleles));\n+    }\n+\n+    public VariantContext ensureAnnotations(final VariantContext vc, final VariantContext vcsub) {\n+        final int originalAlleleCount = vc.getHetCount() + 2 * vc.getHomVarCount();\n+        final int newAlleleCount = vcsub.getHetCount() + 2 * vcsub.getHomVarCount();\n+        final boolean isSingleton = originalAlleleCount == newAlleleCount && newAlleleCount == 1;\n+        final boolean hasChrCountAnnotations = vcsub.hasAttribute(VCFConstants.ALLELE_COUNT_KEY) &&\n+                vcsub.hasAttribute(VCFConstants.ALLELE_FREQUENCY_KEY) &&\n+                vcsub.hasAttribute(VCFConstants.ALLELE_NUMBER_KEY);\n+\n+        if ( ! isSingleton && hasChrCountAnnotations ) {\n+            // nothing to update\n+            return vcsub;\n+        } else {\n+            // have to do the work\n+            VariantContextBuilder builder = new VariantContextBuilder(vcsub);\n+\n+            if ( isSingleton )\n+                builder.attribute(IS_SINGLETON_KEY, true);\n+\n+            if ( ! hasChrCountAnnotations )\n+                VariantContextUtils.calculateChromosomeCounts(builder, true);\n+\n+            return builder.make();\n+        }\n+    }\n+\n+    /**\n+     * Initialize required, standard and user-specified stratification objects\n+     *\n+     * @param noStandardStrats  don't use the standard stratifications\n+     * @param modulesToUse      the list of stratification modules to use\n+     * @return set of stratifications to use\n+     */\n+    public List<VariantStratifier> initializeStratificationObjects(boolean noStandardStrats, List<String> modulesToUse) {\n+        TreeSet<VariantStratifier> strats = new TreeSet<>();\n+        Set<String> stratsToUse = new HashSet<>(requiredStratificationNames);\n+\n+        // By default, use standard stratification modules.\n+        if (!noStandardStrats) {\n+            stratsToUse.addAll(standardStratificationNames);\n+        }\n+\n+        // Now add the user-selected modules\n+        stratsToUse.addAll(modulesToUse);\n+\n+        // Instantiate the stratifications\n+        for (String module : stratsToUse) {\n+            if (!stratifierClasses.containsKey(module)) {\n+                throw new CommandLineException(\"Module \" + module + \" could not be found; please check that you have specified the class name correctly\");\n+            }\n+\n+            if (stratifierClasses.containsKey(module)) {\n+                Class<? extends VariantStratifier> c = stratifierClasses.get(module);\n+\n+                VariantStratifier vs = ClassUtils.makeInstanceOf(c);\n+                vs.initialize(this);\n+                strats.add(vs);\n+            }\n+        }\n+\n+        return new ArrayList<>(strats);\n+    }\n+\n+    /**\n+     * Initialize required, standard and user-specified evaluation objects\n+     *\n+     * @param noStandardEvals don't use the standard evaluations\n+     * @param modulesToUse    the list of evaluation modules to use\n+     * @return set of evaluations to use\n+     */\n+    public Set<Class<? extends VariantEvaluator>> initializeEvaluationObjects(boolean noStandardEvals, List<String> modulesToUse) {\n+        Set<String> evalsToUse = new TreeSet<>(modulesToUse);\n+\n+        // By default, use standard eval modules.\n+        if (!noStandardEvals) {\n+            evalsToUse.addAll(standardEvaluatorNames);\n+        }\n+\n+        // Get the specific classes provided.\n+        Set<Class<? extends VariantEvaluator>> evals = new HashSet<>();\n+        for (String module : evalsToUse) {\n+            if (!evaluatorClasses.containsKey(module)) {\n+                throw new CommandLineException(\"Module \" + module + \" could not be found; please check that you have specified the class name correctly\");\n+            }\n+\n+            evals.add(evaluatorClasses.get(module));\n+        }\n+\n+        //add MetricsCollection if required modules are included\n+        if (evals.contains(evaluatorClasses.get(\"CompOverlap\")) && evals.contains(evaluatorClasses.get(\"IndelSummary\")) && evals.contains(evaluatorClasses.get(\"TiTvVariantEvaluator\")) && evals.contains(evaluatorClasses.get(\"CountVariants\")) && evals.contains(evaluatorClasses.get(\"MultiallelicSummary\")) )\n+            evals.add(evaluatorClasses.get(\"MetricsCollection\"));\n+\n+        return evals;\n+    }\n+\n+    public static Map<String, Class<? extends VariantStratifier>> getStratifierClasses() {\n+        return Collections.unmodifiableMap(stratifierClasses);\n+    }\n+\n+    public static Set<String> getStandardStratificationNames() {\n+        return Collections.unmodifiableSet(standardStratificationNames);\n+    }\n+\n+    public static Set<String> getRequiredStratificationNames() {\n+        return Collections.unmodifiableSet(requiredStratificationNames);\n+    }\n+\n+    public static Map<String, Class<? extends VariantEvaluator>> getEvaluatorClasses() {\n+        return Collections.unmodifiableMap(evaluatorClasses);\n+    }\n+\n+    public static Set<String> getStandardEvaluatorNames() {\n+        return Collections.unmodifiableSet(standardEvaluatorNames);\n+    }\n+\n+    public FeatureInput<Feature> getKnownCNVsFile() {\n+        return variantEvalArgs.knownCNVsFile;\n+    }\n+\n+    public List<FeatureInput<VariantContext>> getEvals() {\n+        return Collections.unmodifiableList(variantEvalArgs.evals);\n+    }\n+\n+    public List<FeatureInput<VariantContext>> getComps() {\n+        return Collections.unmodifiableList(variantEvalArgs.comps);\n+    }\n+\n+    public boolean ignoreAC0Sites() {\n+        return ! variantEvalArgs.keepSitesWithAC0;\n+    }\n+\n+    public FeatureInput<VariantContext> getGoldStand() {\n+        return variantEvalArgs.goldStandard;\n+    }\n+\n+    public List<FeatureInput<VariantContext>> getCompsProvided() {\n+        return Collections.unmodifiableList(variantEvalArgs.compsProvided);\n+    }\n+\n+    public boolean isMergeEvals() {\n+        return variantEvalArgs.mergeEvals;\n+    }\n+\n+    public int getPloidy() {\n+        return variantEvalArgs.ploidy;\n+    }\n+\n+    public Logger getLogger() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9a8836fdfeb635d275ce71f365bef469718e782a"}, "originalPosition": 905}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NjE0OTQ1OQ==", "bodyText": "I know you didn't add this, but carrying this logger around is a leftover gatk3-ism. This arg here and below, and class state can be removed, and each class can use its own logger.", "url": "https://github.com/broadinstitute/gatk/pull/6973#discussion_r556149459", "createdAt": "2021-01-12T22:52:05Z", "author": {"login": "cmnbroad"}, "path": "src/main/java/org/broadinstitute/hellbender/tools/walkers/varianteval/VariantEvalEngine.java", "diffHunk": "@@ -0,0 +1,937 @@\n+package org.broadinstitute.hellbender.tools.walkers.varianteval;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import htsjdk.samtools.SAMSequenceDictionary;\n+import htsjdk.samtools.reference.IndexedFastaSequenceFile;\n+import htsjdk.samtools.reference.ReferenceSequenceFile;\n+import htsjdk.tribble.Feature;\n+import htsjdk.variant.variantcontext.Allele;\n+import htsjdk.variant.variantcontext.VariantContext;\n+import htsjdk.variant.variantcontext.VariantContextBuilder;\n+import htsjdk.variant.variantcontext.VariantContextUtils;\n+import htsjdk.variant.vcf.VCFConstants;\n+import htsjdk.variant.vcf.VCFHeader;\n+import org.apache.logging.log4j.Logger;\n+import org.broadinstitute.barclay.argparser.CommandLineException;\n+import org.broadinstitute.hellbender.cmdline.StandardArgumentDefinitions;\n+import org.broadinstitute.hellbender.engine.*;\n+import org.broadinstitute.hellbender.exceptions.GATKException;\n+import org.broadinstitute.hellbender.exceptions.UserException;\n+import org.broadinstitute.hellbender.tools.walkers.varianteval.evaluators.*;\n+import org.broadinstitute.hellbender.tools.walkers.varianteval.stratifications.*;\n+import org.broadinstitute.hellbender.tools.walkers.varianteval.stratifications.manager.StratificationManager;\n+import org.broadinstitute.hellbender.tools.walkers.varianteval.util.EvaluationContext;\n+import org.broadinstitute.hellbender.tools.walkers.varianteval.util.SortableJexlVCMatchExp;\n+import org.broadinstitute.hellbender.tools.walkers.varianteval.util.VariantEvalContext;\n+import org.broadinstitute.hellbender.utils.ClassUtils;\n+import org.broadinstitute.hellbender.utils.SimpleInterval;\n+import org.broadinstitute.hellbender.utils.Utils;\n+import org.broadinstitute.hellbender.utils.io.IOUtils;\n+import org.broadinstitute.hellbender.utils.samples.PedigreeValidationType;\n+import org.broadinstitute.hellbender.utils.samples.Sample;\n+import org.broadinstitute.hellbender.utils.samples.SampleDB;\n+import org.reflections.Reflections;\n+\n+import javax.annotation.Nullable;\n+import java.io.File;\n+import java.io.FileNotFoundException;\n+import java.io.IOException;\n+import java.io.PrintStream;\n+import java.util.*;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * This class allows other classes to replicate the behavior of VariantEval\n+ *\n+ * Usage:\n+ * -Pass the genotype args into the constructor, which will the initialize the engine completely\n+ */\n+public class VariantEvalEngine {\n+    public static final String IS_SINGLETON_KEY = \"ISSINGLETON\";\n+\n+    private final VariantEvalArgumentCollection variantEvalArgs;\n+\n+    private final Logger logger;\n+    private final SAMSequenceDictionary samSequenceDictionaryForDrivingVariants;\n+    private final List<SimpleInterval> traversalIntervals;\n+    private final FeatureManager features;\n+\n+    private final static Map<String, Class<? extends VariantStratifier>> stratifierClasses;\n+    private final static Set<String> standardStratificationNames;\n+    private final static Set<String> requiredStratificationNames;\n+\n+    private final static Map<String, Class<? extends VariantEvaluator>> evaluatorClasses;\n+    private final static Set<String> standardEvaluatorNames;\n+\n+    static {\n+        stratifierClasses = new HashMap<>();\n+        standardStratificationNames = new HashSet<>();\n+        requiredStratificationNames = new HashSet<>();\n+\n+        Reflections reflectionsStrat = new Reflections(VariantStratifier.class.getPackage().getName());\n+        Set<Class<? extends VariantStratifier>> allClasses = reflectionsStrat.getSubTypesOf(VariantStratifier.class);\n+        for (Class<? extends VariantStratifier> clazz : allClasses) {\n+            stratifierClasses.put(clazz.getSimpleName(), clazz);\n+\n+            if (StandardStratification.class.isAssignableFrom(clazz)) {\n+                standardStratificationNames.add(clazz.getSimpleName());\n+            }\n+\n+            if (RequiredStratification.class.isAssignableFrom(clazz)) {\n+                requiredStratificationNames.add(clazz.getSimpleName());\n+            }\n+        }\n+\n+        evaluatorClasses = new HashMap<>();\n+        standardEvaluatorNames= new HashSet<>();\n+\n+        Reflections reflectionsEval = new Reflections(VariantEvaluator.class.getPackage().getName());\n+        Set<Class<? extends VariantEvaluator>> allEvalClasses = reflectionsEval.getSubTypesOf(VariantEvaluator.class);\n+        for (Class<? extends VariantEvaluator> clazz : allEvalClasses) {\n+            evaluatorClasses.put(clazz.getSimpleName(), clazz);\n+\n+            if (StandardEval.class.isAssignableFrom(clazz)) {\n+                standardEvaluatorNames.add(clazz.getSimpleName());\n+            }\n+        }\n+    }\n+\n+    // Ancestral alignments\n+    private ReferenceSequenceFile ancestralAlignments = null;\n+\n+    // The set of all possible evaluation contexts\n+    private StratificationManager<VariantStratifier, EvaluationContext> stratManager;\n+\n+    private SampleDB sampleDB = null;\n+\n+    private List<FeatureInput<VariantContext>> knowns = new ArrayList<>();\n+\n+    // maintain the mapping of FeatureInput to name used in output file\n+    private Map<FeatureInput<VariantContext>, String> inputToNameMap = new HashMap<>();\n+\n+    // Variables\n+    private Set<SortableJexlVCMatchExp> jexlExpressions = new TreeSet<>();\n+\n+    private boolean isSubsettingSamples;\n+    private Set<String> sampleNamesForEvaluation = new LinkedHashSet<>();\n+    private Set<String> familyNamesForEvaluation = new LinkedHashSet<>();\n+    private Set<String> sampleNamesForStratification = new LinkedHashSet<>();\n+    private Set<String> familyNamesForStratification = new LinkedHashSet<>();\n+\n+    // important stratifications\n+    private boolean byFilterIsEnabled = false;\n+    private boolean perSampleIsEnabled = false;\n+    private boolean perFamilyIsEnabled = false;\n+\n+    private AlleleFrequency.StratifyingScale AFScale = AlleleFrequency.StratifyingScale.LINEAR;\n+    private boolean useCompAFStratifier = false;\n+\n+    // maintain the mapping of source name (from VC) to FeatureInput name\n+    private Map<String, FeatureInput<VariantContext>> drivingVariantSourceMap;\n+\n+    // No args constructor for unit testing only\n+    @VisibleForTesting\n+    protected VariantEvalEngine(Logger logger) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9a8836fdfeb635d275ce71f365bef469718e782a"}, "originalPosition": 134}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTgxODAwMjgz", "url": "https://github.com/broadinstitute/gatk/pull/6973#pullrequestreview-581800283", "createdAt": "2021-02-02T21:44:07Z", "commit": {"oid": "ae50ac009bd7bdad128571fea91f0dd71cf489ff"}, "state": "COMMENTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0wMlQyMTo0NDowN1rOIemDnA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0wMlQyMTo1MTowMFrOIemSbw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2ODk1MTcwOA==", "bodyText": "I thought we were getting close, but this deferred initialization state seems complicating - whats the reason for needing it (both here, and in the evaluators, which still have an \"initialize\" method) ? Is there any alternative ?\nDepending on the answer, we'll need to rationalize these constructors - having one that controls initialization and one that doesn't seems problematic. There are 3 constructors now, each of which leaves the object in a slightly different non-obvious state. We really need to get rid of the boolean if at all possible.", "url": "https://github.com/broadinstitute/gatk/pull/6973#discussion_r568951708", "createdAt": "2021-02-02T21:44:07Z", "author": {"login": "cmnbroad"}, "path": "src/main/java/org/broadinstitute/hellbender/tools/walkers/varianteval/VariantEvalEngine.java", "diffHunk": "@@ -0,0 +1,922 @@\n+package org.broadinstitute.hellbender.tools.walkers.varianteval;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import htsjdk.samtools.SAMSequenceDictionary;\n+import htsjdk.samtools.reference.IndexedFastaSequenceFile;\n+import htsjdk.samtools.reference.ReferenceSequenceFile;\n+import htsjdk.tribble.Feature;\n+import htsjdk.variant.variantcontext.Allele;\n+import htsjdk.variant.variantcontext.VariantContext;\n+import htsjdk.variant.variantcontext.VariantContextBuilder;\n+import htsjdk.variant.variantcontext.VariantContextUtils;\n+import htsjdk.variant.vcf.VCFConstants;\n+import htsjdk.variant.vcf.VCFHeader;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.broadinstitute.barclay.argparser.CommandLineException;\n+import org.broadinstitute.hellbender.cmdline.StandardArgumentDefinitions;\n+import org.broadinstitute.hellbender.engine.*;\n+import org.broadinstitute.hellbender.exceptions.GATKException;\n+import org.broadinstitute.hellbender.exceptions.UserException;\n+import org.broadinstitute.hellbender.tools.walkers.varianteval.evaluators.*;\n+import org.broadinstitute.hellbender.tools.walkers.varianteval.stratifications.*;\n+import org.broadinstitute.hellbender.tools.walkers.varianteval.stratifications.manager.StratificationManager;\n+import org.broadinstitute.hellbender.tools.walkers.varianteval.util.EvaluationContext;\n+import org.broadinstitute.hellbender.tools.walkers.varianteval.util.SortableJexlVCMatchExp;\n+import org.broadinstitute.hellbender.tools.walkers.varianteval.util.VariantEvalContext;\n+import org.broadinstitute.hellbender.utils.ClassUtils;\n+import org.broadinstitute.hellbender.utils.SimpleInterval;\n+import org.broadinstitute.hellbender.utils.Utils;\n+import org.broadinstitute.hellbender.utils.io.IOUtils;\n+import org.broadinstitute.hellbender.utils.samples.PedigreeValidationType;\n+import org.broadinstitute.hellbender.utils.samples.Sample;\n+import org.broadinstitute.hellbender.utils.samples.SampleDB;\n+import org.reflections.Reflections;\n+\n+import javax.annotation.Nullable;\n+import java.io.File;\n+import java.io.FileNotFoundException;\n+import java.io.IOException;\n+import java.io.PrintStream;\n+import java.lang.reflect.InvocationTargetException;\n+import java.util.*;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * This class allows other classes to replicate the behavior of VariantEval\n+ *\n+ * Usage:\n+ * -Pass the genotype args into the constructor, which will the initialize the engine completely\n+ */\n+public class VariantEvalEngine {\n+    public static final String IS_SINGLETON_KEY = \"ISSINGLETON\";\n+\n+    private final VariantEvalArgumentCollection variantEvalArgs;\n+\n+    private final Logger logger = LogManager.getLogger(VariantEvalEngine.class);\n+\n+    private final SAMSequenceDictionary samSequenceDictionaryForDrivingVariants;\n+    private final List<SimpleInterval> traversalIntervals;\n+    private final FeatureManager features;\n+\n+    private final static Map<String, Class<? extends VariantStratifier>> stratifierClasses;\n+    private final static Set<String> standardStratificationNames;\n+    private final static Set<String> requiredStratificationNames;\n+\n+    private final static Map<String, Class<? extends VariantEvaluator>> evaluatorClasses;\n+    private final static Set<String> standardEvaluatorNames;\n+\n+    static {\n+        stratifierClasses = new HashMap<>();\n+        standardStratificationNames = new HashSet<>();\n+        requiredStratificationNames = new HashSet<>();\n+\n+        Reflections reflectionsStrat = new Reflections(VariantStratifier.class.getPackage().getName());\n+        Set<Class<? extends VariantStratifier>> allClasses = reflectionsStrat.getSubTypesOf(VariantStratifier.class);\n+        for (Class<? extends VariantStratifier> clazz : allClasses) {\n+            stratifierClasses.put(clazz.getSimpleName(), clazz);\n+\n+            if (StandardStratification.class.isAssignableFrom(clazz)) {\n+                standardStratificationNames.add(clazz.getSimpleName());\n+            }\n+\n+            if (RequiredStratification.class.isAssignableFrom(clazz)) {\n+                requiredStratificationNames.add(clazz.getSimpleName());\n+            }\n+        }\n+\n+        evaluatorClasses = new HashMap<>();\n+        standardEvaluatorNames= new HashSet<>();\n+\n+        Reflections reflectionsEval = new Reflections(VariantEvaluator.class.getPackage().getName());\n+        Set<Class<? extends VariantEvaluator>> allEvalClasses = reflectionsEval.getSubTypesOf(VariantEvaluator.class);\n+        for (Class<? extends VariantEvaluator> clazz : allEvalClasses) {\n+            evaluatorClasses.put(clazz.getSimpleName(), clazz);\n+\n+            if (StandardEval.class.isAssignableFrom(clazz)) {\n+                standardEvaluatorNames.add(clazz.getSimpleName());\n+            }\n+        }\n+    }\n+\n+    // Ancestral alignments\n+    private ReferenceSequenceFile ancestralAlignments = null;\n+\n+    // The set of all possible evaluation contexts\n+    private StratificationManager<VariantStratifier, EvaluationContext> stratManager;\n+\n+    private SampleDB sampleDB = null;\n+\n+    private List<FeatureInput<VariantContext>> knowns = new ArrayList<>();\n+\n+    // maintain the mapping of FeatureInput to name used in output file\n+    private Map<FeatureInput<VariantContext>, String> inputToNameMap = new HashMap<>();\n+\n+    // Variables\n+    private Set<SortableJexlVCMatchExp> jexlExpressions = new TreeSet<>();\n+\n+    private boolean isSubsettingSamples;\n+    private Set<String> sampleNamesForEvaluation = new LinkedHashSet<>();\n+    private Set<String> familyNamesForEvaluation = new LinkedHashSet<>();\n+    private Set<String> sampleNamesForStratification = new LinkedHashSet<>();\n+    private Set<String> familyNamesForStratification = new LinkedHashSet<>();\n+\n+    // important stratifications\n+    private boolean byFilterIsEnabled = false;\n+    private boolean perSampleIsEnabled = false;\n+    private boolean perFamilyIsEnabled = false;\n+\n+    private AlleleFrequency.StratifyingScale AFScale = AlleleFrequency.StratifyingScale.LINEAR;\n+    private boolean useCompAFStratifier = false;\n+\n+    // maintain the mapping of source name (from VC) to FeatureInput name\n+    private Map<String, FeatureInput<VariantContext>> drivingVariantSourceMap;\n+\n+    // No args constructor for unit testing only\n+    @VisibleForTesting\n+    protected VariantEvalEngine() {\n+        this.variantEvalArgs = new VariantEvalArgumentCollection();\n+        this.samSequenceDictionaryForDrivingVariants = null;\n+        this.traversalIntervals = null;\n+        this.features = null;\n+    }\n+\n+    public VariantEvalEngine(final VariantEvalArgumentCollection variantEvalArgs, final FeatureManager features, final List<SimpleInterval> traversalIntervals, SAMSequenceDictionary samSequenceDictionaryForDrivingVariants, @Nullable final Collection<String> samples) {\n+        this(variantEvalArgs, features, traversalIntervals, samSequenceDictionaryForDrivingVariants, samples, false);\n+    }\n+\n+    // Note: this protected constructor with deferred initialization exists for DISCVR-seq/VariantQC\n+    protected VariantEvalEngine(VariantEvalArgumentCollection variantEvalArgs, FeatureManager features, List<SimpleInterval> traversalIntervals, SAMSequenceDictionary samSequenceDictionaryForDrivingVariants, @Nullable Collection<String> samples, boolean skipInitialize) {\n+        this.variantEvalArgs = variantEvalArgs;\n+        this.samSequenceDictionaryForDrivingVariants = samSequenceDictionaryForDrivingVariants;\n+        this.traversalIntervals = traversalIntervals;\n+        this.features = features;\n+\n+        // Cache map of source name -> FeatureInput\n+        drivingVariantSourceMap = new HashMap<>();\n+        variantEvalArgs.getFeatureInputsForDrivingVariants().forEach(x -> drivingVariantSourceMap.put(x.getName(), x));\n+\n+        if (!skipInitialize) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ae50ac009bd7bdad128571fea91f0dd71cf489ff"}, "originalPosition": 159}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2ODk1NTUwMw==", "bodyText": "I thought passing the engine to constructors would eliminate the need for this initialize method. Can it be removed ?", "url": "https://github.com/broadinstitute/gatk/pull/6973#discussion_r568955503", "createdAt": "2021-02-02T21:51:00Z", "author": {"login": "cmnbroad"}, "path": "src/main/java/org/broadinstitute/hellbender/tools/walkers/varianteval/evaluators/VariantEvaluator.java", "diffHunk": "@@ -1,41 +1,42 @@\n package org.broadinstitute.hellbender.tools.walkers.varianteval.evaluators;\n \n import htsjdk.variant.variantcontext.VariantContext;\n-import org.broadinstitute.hellbender.engine.FeatureContext;\n-import org.broadinstitute.hellbender.engine.ReadsContext;\n-import org.broadinstitute.hellbender.engine.ReferenceContext;\n import org.broadinstitute.hellbender.exceptions.GATKException;\n-import org.broadinstitute.hellbender.tools.walkers.varianteval.VariantEval;\n+import org.broadinstitute.hellbender.tools.walkers.varianteval.VariantEvalEngine;\n+import org.broadinstitute.hellbender.tools.walkers.varianteval.util.VariantEvalContext;\n \n public abstract class VariantEvaluator implements Comparable<VariantEvaluator> {\n-    private VariantEval walker;\n     private final String simpleName;\n+    private final VariantEvalEngine engine;\n \n-    protected VariantEvaluator(String simpleName) {\n-        this.simpleName = simpleName;\n+    public VariantEvaluator(VariantEvalEngine engine) {\n+        this.engine = engine;\n+        this.simpleName = getClass().getSimpleName();\n     }\n \n-    protected VariantEvaluator() {\n-        this.simpleName = getClass().getSimpleName();\n+    //Note: this is used by DISCVR-seq / VariantQC\n+    public VariantEvaluator(VariantEvalEngine engine, final String simpleName) {\n+        this.engine = engine;\n+        this.simpleName = simpleName;\n     }\n \n-    public void initialize(VariantEval walker) {\n-        this.walker = walker;\n+    public void initialize() {\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ae50ac009bd7bdad128571fea91f0dd71cf489ff"}, "originalPosition": 35}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "10782ae957d02c50ebcde89c6d32af7c737cfd80", "author": {"user": {"login": "bbimber", "name": null}}, "url": "https://github.com/broadinstitute/gatk/commit/10782ae957d02c50ebcde89c6d32af7c737cfd80", "committedDate": "2021-02-03T18:09:23Z", "message": "Remove custom constructor and deferred initialization"}, "afterCommit": {"oid": "58fec234a4f95ac93fe370f9ee2439a278425e6d", "author": {"user": {"login": "bbimber", "name": null}}, "url": "https://github.com/broadinstitute/gatk/commit/58fec234a4f95ac93fe370f9ee2439a278425e6d", "committedDate": "2021-02-03T18:12:31Z", "message": "Switch VariantEval to MultiVariantWalkerGroupedOnStart\n\nRefactor VariantEval to create a standalone VariantEvalEngine class\n\nRespond to code review\n\nRespond to code review\n\nRestore alternate constructor used by VariantQC\n\nAllow deferred VariantEvalEngine initialization for VariantQC\n\nNot necessary to track sampleDB internally\n\nRemove custom constructor and deferred initialization"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "8f4b66a1983e53f5511d6801f635c086fff02b3d", "author": {"user": {"login": "bbimber", "name": null}}, "url": "https://github.com/broadinstitute/gatk/commit/8f4b66a1983e53f5511d6801f635c086fff02b3d", "committedDate": "2021-02-08T22:13:10Z", "message": "Remove VariantStratifier.initialize()"}, "afterCommit": {"oid": "94b2c6a24763a88ae8d30ed242e843f9c1399757", "author": {"user": {"login": "bbimber", "name": null}}, "url": "https://github.com/broadinstitute/gatk/commit/94b2c6a24763a88ae8d30ed242e843f9c1399757", "committedDate": "2021-02-09T18:13:35Z", "message": "Switch VariantEval to MultiVariantWalkerGroupedOnStart\n\nRefactor VariantEval to create a standalone VariantEvalEngine class\n\nRespond to code review\n\nRespond to code review\n\nRestore alternate constructor used by VariantQC\n\nAllow deferred VariantEvalEngine initialization for VariantQC\n\nNot necessary to track sampleDB internally\n\nRemove custom constructor and deferred initialization\n\nRemove VariantEvaluator.initialize()\n\nRemove VariantStratifier.initialize()"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "94b2c6a24763a88ae8d30ed242e843f9c1399757", "author": {"user": {"login": "bbimber", "name": null}}, "url": "https://github.com/broadinstitute/gatk/commit/94b2c6a24763a88ae8d30ed242e843f9c1399757", "committedDate": "2021-02-09T18:13:35Z", "message": "Switch VariantEval to MultiVariantWalkerGroupedOnStart\n\nRefactor VariantEval to create a standalone VariantEvalEngine class\n\nRespond to code review\n\nRespond to code review\n\nRestore alternate constructor used by VariantQC\n\nAllow deferred VariantEvalEngine initialization for VariantQC\n\nNot necessary to track sampleDB internally\n\nRemove custom constructor and deferred initialization\n\nRemove VariantEvaluator.initialize()\n\nRemove VariantStratifier.initialize()"}, "afterCommit": {"oid": "c78cdacb6df01b766a50ef198001444aacaa4e29", "author": {"user": {"login": "bbimber", "name": null}}, "url": "https://github.com/broadinstitute/gatk/commit/c78cdacb6df01b766a50ef198001444aacaa4e29", "committedDate": "2021-02-09T18:14:50Z", "message": "Switch VariantEval to MultiVariantWalkerGroupedOnStart\n\nRefactor VariantEval to create a standalone VariantEvalEngine class\n\nRespond to code review\n\nRespond to code review\n\nRestore alternate constructor used by VariantQC\n\nAllow deferred VariantEvalEngine initialization for VariantQC\n\nNot necessary to track sampleDB internally\n\nRemove custom constructor and deferred initialization\n\nRemove VariantEvaluator.initialize()\n\nRemove VariantStratifier.initialize()"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "c78cdacb6df01b766a50ef198001444aacaa4e29", "author": {"user": {"login": "bbimber", "name": null}}, "url": "https://github.com/broadinstitute/gatk/commit/c78cdacb6df01b766a50ef198001444aacaa4e29", "committedDate": "2021-02-09T18:14:50Z", "message": "Switch VariantEval to MultiVariantWalkerGroupedOnStart\n\nRefactor VariantEval to create a standalone VariantEvalEngine class\n\nRespond to code review\n\nRespond to code review\n\nRestore alternate constructor used by VariantQC\n\nAllow deferred VariantEvalEngine initialization for VariantQC\n\nNot necessary to track sampleDB internally\n\nRemove custom constructor and deferred initialization\n\nRemove VariantEvaluator.initialize()\n\nRemove VariantStratifier.initialize()"}, "afterCommit": {"oid": "13bbf0ae8a6938688a2a8c8f92cbfbd2928f337d", "author": {"user": {"login": "bbimber", "name": null}}, "url": "https://github.com/broadinstitute/gatk/commit/13bbf0ae8a6938688a2a8c8f92cbfbd2928f337d", "committedDate": "2021-04-27T17:01:41Z", "message": "Switch VariantEval to MultiVariantWalkerGroupedOnStart\n\nRefactor VariantEval to create a standalone VariantEvalEngine class\n\nRespond to code review\n\nRespond to code review\n\nRestore alternate constructor used by VariantQC\n\nAllow deferred VariantEvalEngine initialization for VariantQC\n\nNot necessary to track sampleDB internally\n\nRemove custom constructor and deferred initialization\n\nRemove VariantEvaluator.initialize()\n\nRemove VariantStratifier.initialize()"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "fafe4d187ea9aa1dd1343990007456096ea1a3d3", "author": {"user": {"login": "bbimber", "name": null}}, "url": "https://github.com/broadinstitute/gatk/commit/fafe4d187ea9aa1dd1343990007456096ea1a3d3", "committedDate": "2021-04-28T12:50:49Z", "message": "Another approach to conditionally store FeatureInput name in VC\n\nFix test\n\nSource is actually always non-null so test specific string\n\nAdd dedicated test"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "965cb75f45623af5c881f46d748a49db953d0fee", "author": {"user": {"login": "bbimber", "name": null}}, "url": "https://github.com/broadinstitute/gatk/commit/965cb75f45623af5c881f46d748a49db953d0fee", "committedDate": "2021-04-28T12:50:50Z", "message": "Code review"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b6b22e21bc3357d2496439376766e0f2d88549bf", "author": {"user": {"login": "bbimber", "name": null}}, "url": "https://github.com/broadinstitute/gatk/commit/b6b22e21bc3357d2496439376766e0f2d88549bf", "committedDate": "2021-04-28T12:50:50Z", "message": "Switch VariantEval to MultiVariantWalkerGroupedOnStart\n\nRefactor VariantEval to create a standalone VariantEvalEngine class\n\nRespond to code review\n\nRespond to code review\n\nRestore alternate constructor used by VariantQC\n\nAllow deferred VariantEvalEngine initialization for VariantQC\n\nNot necessary to track sampleDB internally\n\nRemove custom constructor and deferred initialization\n\nRemove VariantEvaluator.initialize()\n\nRemove VariantStratifier.initialize()"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "996fb5d70de7dc8d1788807960e9ceccff220b27", "author": {"user": {"login": "bbimber", "name": null}}, "url": "https://github.com/broadinstitute/gatk/commit/996fb5d70de7dc8d1788807960e9ceccff220b27", "committedDate": "2021-04-28T12:50:50Z", "message": "Add import missed in merge"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "cf17c7d16825187b341d0d087e4754d763b8146e", "author": {"user": {"login": "bbimber", "name": null}}, "url": "https://github.com/broadinstitute/gatk/commit/cf17c7d16825187b341d0d087e4754d763b8146e", "committedDate": "2021-04-28T12:50:51Z", "message": "Solution for validation error thrown in AlleleCount constructor"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "fedde9dc8ea975643df44659389cda2d0fa36f1f", "author": {"user": {"login": "bbimber", "name": null}}, "url": "https://github.com/broadinstitute/gatk/commit/fedde9dc8ea975643df44659389cda2d0fa36f1f", "committedDate": "2021-04-28T12:50:51Z", "message": "Cleaner method for VariantStratifier classes to validate arguments"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e8d2d72a5c085c90c8715f3e44adba6e6fc8eed1", "author": {"user": {"login": "bbimber", "name": null}}, "url": "https://github.com/broadinstitute/gatk/commit/e8d2d72a5c085c90c8715f3e44adba6e6fc8eed1", "committedDate": "2021-04-28T12:50:51Z", "message": "- Avoid NPE in AlleleFrequencyQC test\n- Also dont store useCompAFStratifier and scale in AlleleFrequency, so we can set their values after instantiation"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "698a9c0fc48abef17c2b7e95959ecffbd75f9853", "author": {"user": {"login": "bbimber", "name": null}}, "url": "https://github.com/broadinstitute/gatk/commit/698a9c0fc48abef17c2b7e95959ecffbd75f9853", "committedDate": "2021-04-28T12:50:51Z", "message": "Revert \"Cleaner method for VariantStratifier classes to validate arguments\"\n\nThis reverts commit 1569a909"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3ec0a0be8e10d03bb5541652408875f1418f0a65", "author": {"user": {"login": "bbimber", "name": null}}, "url": "https://github.com/broadinstitute/gatk/commit/3ec0a0be8e10d03bb5541652408875f1418f0a65", "committedDate": "2021-04-28T12:50:51Z", "message": "Propagate CommandLineException during creation of VariantEvaluator and VariantStratifier"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "de27877a235613f200150502b1106daa773e1aee", "author": {"user": {"login": "bbimber", "name": null}}, "url": "https://github.com/broadinstitute/gatk/commit/de27877a235613f200150502b1106daa773e1aee", "committedDate": "2021-04-28T12:50:51Z", "message": "Exception is now re-thrown as CommandLineException"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4625432ae25cbad59f39266dea897a97ee041f80", "author": {"user": {"login": "bbimber", "name": null}}, "url": "https://github.com/broadinstitute/gatk/commit/4625432ae25cbad59f39266dea897a97ee041f80", "committedDate": "2021-04-28T12:50:52Z", "message": "Move options to VariantEvalArgumentCollection, to allow setting values more easily by AlleleFrequencyQC"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "35995be77bb4adc1430c0f0a05ef9b7f9991193a", "author": {"user": {"login": "bbimber", "name": null}}, "url": "https://github.com/broadinstitute/gatk/commit/35995be77bb4adc1430c0f0a05ef9b7f9991193a", "committedDate": "2021-04-28T12:54:49Z", "message": "Fix merge"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "6961f757cd3c20470f3b42b473aa948593e537b1", "author": {"user": {"login": "bbimber", "name": null}}, "url": "https://github.com/broadinstitute/gatk/commit/6961f757cd3c20470f3b42b473aa948593e537b1", "committedDate": "2021-04-27T23:05:32Z", "message": "Move options to VariantEvalArgumentCollection, to allow setting values more easily by AlleleFrequencyQC"}, "afterCommit": {"oid": "35995be77bb4adc1430c0f0a05ef9b7f9991193a", "author": {"user": {"login": "bbimber", "name": null}}, "url": "https://github.com/broadinstitute/gatk/commit/35995be77bb4adc1430c0f0a05ef9b7f9991193a", "committedDate": "2021-04-28T12:54:49Z", "message": "Fix merge"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjQ5MTI2NzE1", "url": "https://github.com/broadinstitute/gatk/pull/6973#pullrequestreview-649126715", "createdAt": "2021-04-30T11:33:50Z", "commit": {"oid": "35995be77bb4adc1430c0f0a05ef9b7f9991193a"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2555, "cost": 1, "resetAt": "2021-11-01T13:07:16Z"}}}