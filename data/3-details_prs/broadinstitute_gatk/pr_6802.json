{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDgyODI4MTk3", "number": 6802, "title": "ReferenceBlockConcordance - new tool to evaluate concordance of reference block in GVCF files", "bodyText": "Tool creates histograms to reflect differences in the composition reference blocks in GVCF files\nIntegration tests", "createdAt": "2020-09-09T13:02:37Z", "url": "https://github.com/broadinstitute/gatk/pull/6802", "merged": true, "mergeCommit": {"oid": "18f0544490200bc5610a2c023bf02035da709976"}, "closed": true, "closedAt": "2020-10-06T11:45:17Z", "author": {"login": "michaelgatzen"}, "timelineItems": {"totalCount": 9, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdHLx_kAH2gAyNDgyODI4MTk3OjMxNDZkYWJmMzY2MTU2ZDFhZDU3NDNjZTc4NmY0NzVhNTI1ODA0YzQ=", "endCursor": "Y3Vyc29yOnYyOpPPAAABdP1E_RgH2gAyNDgyODI4MTk3OjE1YmVkNTk2MmU1NjdjZjk4M2IyYjg5NTg0MTZlMDU5ZDgxNDMwM2M=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "3146dabf366156d1ad5743ce786f475a525804c4", "author": {"user": {"login": "michaelgatzen", "name": null}}, "url": "https://github.com/broadinstitute/gatk/commit/3146dabf366156d1ad5743ce786f475a525804c4", "committedDate": "2020-09-09T12:58:16Z", "message": "Added new tool ReferenceBlockConcordance to evaluate concordance of GVCF files\n\n- Tool creates histograms to reflect differences in the composition reference blocks in GVCF files\n- Integration tests"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDg0OTkwOTE5", "url": "https://github.com/broadinstitute/gatk/pull/6802#pullrequestreview-484990919", "createdAt": "2020-09-09T13:10:37Z", "commit": {"oid": "3146dabf366156d1ad5743ce786f475a525804c4"}, "state": "COMMENTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOVQxMzoxMDozN1rOHPGkyA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOVQxMzoxMzowM1rOHPGrGQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTU5ODQwOA==", "bodyText": "Writing a MetricsFile histogram works with Pair<Integer, Integer>, however, reading that is currently not supported. I could modify htsjdk (specifically FormatUtil) to add support for reading generic objects, or should we just use a string instead?", "url": "https://github.com/broadinstitute/gatk/pull/6802#discussion_r485598408", "createdAt": "2020-09-09T13:10:37Z", "author": {"login": "michaelgatzen"}, "path": "src/main/java/org/broadinstitute/hellbender/tools/walkers/validation/ReferenceBlockConcordance.java", "diffHunk": "@@ -0,0 +1,215 @@\n+package org.broadinstitute.hellbender.tools.walkers.validation;\n+\n+import htsjdk.samtools.metrics.MetricsFile;\n+import htsjdk.samtools.util.Histogram;\n+import htsjdk.variant.variantcontext.Genotype;\n+import htsjdk.variant.variantcontext.VariantContext;\n+import org.apache.commons.collections4.Predicate;\n+import org.broadinstitute.barclay.argparser.Argument;\n+import org.broadinstitute.barclay.argparser.CommandLineProgramProperties;\n+import org.broadinstitute.hellbender.engine.AbstractConcordanceWalker;\n+import org.broadinstitute.hellbender.engine.ReadsContext;\n+import org.broadinstitute.hellbender.engine.ReferenceContext;\n+import picard.cmdline.programgroups.VariantEvaluationProgramGroup;\n+import picard.sam.util.Pair;\n+\n+import java.io.File;\n+\n+/**\n+ * Evaluate GVCF reference block concordance of an input GVCF against a truth GVCF.\n+ *\n+ * <p>This tool evaluates two GVCF files against each other and produces three histograms:</p>\n+ *\n+ * <ul>\n+ *     <li>Truth block histogram: Indicates the number of occurrence of reference blocks with a given confidence score and length in the truth GVCF</li>\n+ *     <li>Eval block histogram: Indicates the number of occurrence of reference blocks with a given confidence score and length in the eval GVCF</li>\n+ *     <li>Confidence concordance histogram: Reflects the confidence scores of bases in reference blocks in the truth and eval VCF, respectively. An entry of 10 at bin \"80,90\" means that 10 bases in the truth GVCF have a confidence score of 80 while those same bases have a score of 90 in the eval GVCF.</li>\n+ * </ul>\n+ *\n+ * <p>In contrast to the {@link Concordance} tool, this tool considers all variants, regardless of passing or failing filters.</p>\n+ *\n+ * <h3>Usage example</h3>\n+ *\n+ * <pre>\n+ * gatk ReferenceBlockConcordance \\\n+ *   -R reference.fa \\\n+ *   -eval eval.vcf \\\n+ *   --truth truth.vcf \\\n+ *   --truth-block-histogram truth_block_histogram.tsv \\\n+ *   --eval-block-histogram eval_block_histogram.tsv \\\n+ *   --confidence-concordance-histogram confidence_concordance_histogram.tsv\n+ * </pre>\n+ */\n+\n+@CommandLineProgramProperties(\n+        summary = ReferenceBlockConcordance.USAGE_SUMMARY,\n+        oneLineSummary = ReferenceBlockConcordance.USAGE_ONE_LINE_SUMMARY,\n+        programGroup = VariantEvaluationProgramGroup.class\n+)\n+public class ReferenceBlockConcordance extends AbstractConcordanceWalker {\n+    public static final String TRUTH_BLOCK_HISTOGRAM_LONG_NAME = \"truth-block-histogram\";\n+    public static final String TRUTH_BLOCK_HISTOGRAM_SHORT_NAME = \"tbh\";\n+    public static final String EVAL_BLOCK_HISTOGRAM_LONG_NAME = \"eval-block-histogram\";\n+    public static final String EVAL_BLOCK_HISTOGRAM_SHORT_NAME = \"ebh\";\n+    public static final String CONFIDENCE_CONCORDANCE_HISTOGRAM_LONG_NAME = \"confidence-concordance-histogram\";\n+    public static final String CONFIDENCE_CONCORDANCE_HISTOGRAM_SHORT_NAME = \"cch\";\n+\n+    static final String USAGE_ONE_LINE_SUMMARY = \"Evaluate GVCF reference block concordance of an input GVCF against a truth GVCF\";\n+    static final String USAGE_SUMMARY = \"This tool evaluates two GVCF files against each other and produces three histograms:\\n\" +\n+            \"Truth block histogram: Indicates the number of occurrence of reference blocks with a given confidence score and length in the truth GVCF\\n\" +\n+            \"Eval block histogram: Indicates the number of occurrence of reference blocks with a given confidence score and length in the eval GVCF\\n\" +\n+            \"Confidence concordance histogram: Reflects the confidence scores of bases in reference blocks in the truth and eval VCF, respectively. An entry of 10 at bin \\\"80,90\\\" means that 10 bases in the truth GVCF have a confidence score of 80 while those same bases have a score of 90 in the eval GVCF.\\n\" +\n+            \"In contrast to the Concordance tool, this tool considers all variants, regardless of passing or failing filters.\";\n+\n+    @Argument(doc = \"A histogram of block lengths and their associated confidence scores for the truth sample\",\n+            fullName = TRUTH_BLOCK_HISTOGRAM_LONG_NAME,\n+            shortName = TRUTH_BLOCK_HISTOGRAM_SHORT_NAME)\n+    protected File truthBlockHistogramFile;\n+    @Argument(doc = \"A histogram of block lengths and their associated confidence scores for the eval sample\",\n+            fullName = EVAL_BLOCK_HISTOGRAM_LONG_NAME,\n+            shortName = EVAL_BLOCK_HISTOGRAM_SHORT_NAME)\n+    protected File evalBlockHistogramFile;\n+    @Argument(doc = \"Reflects the confidence scores of bases in reference blocks in the truth and eval VCF, respectively. An entry of 10 at bin \\\"80,90\\\" means that 10 bases in the truth GVCF have a confidence score of 80 while those same bases have a score of 90 in the eval GVCF.\",\n+            fullName = CONFIDENCE_CONCORDANCE_HISTOGRAM_LONG_NAME,\n+            shortName = CONFIDENCE_CONCORDANCE_HISTOGRAM_SHORT_NAME)\n+    protected File confidenceConcordanceHistogramFile;\n+\n+    // TODO this should be a Histogram<Pair<Integer, Integer>>, however, the MetricsFile class cannot read\n+    // arbitrary types, therefore, it must be converted to a String, which is probably much slower\n+    private final Histogram<String> truthBlockHistogram = new Histogram<>();\n+    private final Histogram<String> evalBlockHistogram = new Histogram<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3146dabf366156d1ad5743ce786f475a525804c4"}, "originalPosition": 80}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTU5OTg2Mg==", "bodyText": "In every case I have come across the number of genotypes is always 1 for a symbolic variant, otherwise it would be of type \"mixed\". Or is there a case I haven't considered?", "url": "https://github.com/broadinstitute/gatk/pull/6802#discussion_r485599862", "createdAt": "2020-09-09T13:12:48Z", "author": {"login": "michaelgatzen"}, "path": "src/main/java/org/broadinstitute/hellbender/tools/walkers/validation/ReferenceBlockConcordance.java", "diffHunk": "@@ -0,0 +1,215 @@\n+package org.broadinstitute.hellbender.tools.walkers.validation;\n+\n+import htsjdk.samtools.metrics.MetricsFile;\n+import htsjdk.samtools.util.Histogram;\n+import htsjdk.variant.variantcontext.Genotype;\n+import htsjdk.variant.variantcontext.VariantContext;\n+import org.apache.commons.collections4.Predicate;\n+import org.broadinstitute.barclay.argparser.Argument;\n+import org.broadinstitute.barclay.argparser.CommandLineProgramProperties;\n+import org.broadinstitute.hellbender.engine.AbstractConcordanceWalker;\n+import org.broadinstitute.hellbender.engine.ReadsContext;\n+import org.broadinstitute.hellbender.engine.ReferenceContext;\n+import picard.cmdline.programgroups.VariantEvaluationProgramGroup;\n+import picard.sam.util.Pair;\n+\n+import java.io.File;\n+\n+/**\n+ * Evaluate GVCF reference block concordance of an input GVCF against a truth GVCF.\n+ *\n+ * <p>This tool evaluates two GVCF files against each other and produces three histograms:</p>\n+ *\n+ * <ul>\n+ *     <li>Truth block histogram: Indicates the number of occurrence of reference blocks with a given confidence score and length in the truth GVCF</li>\n+ *     <li>Eval block histogram: Indicates the number of occurrence of reference blocks with a given confidence score and length in the eval GVCF</li>\n+ *     <li>Confidence concordance histogram: Reflects the confidence scores of bases in reference blocks in the truth and eval VCF, respectively. An entry of 10 at bin \"80,90\" means that 10 bases in the truth GVCF have a confidence score of 80 while those same bases have a score of 90 in the eval GVCF.</li>\n+ * </ul>\n+ *\n+ * <p>In contrast to the {@link Concordance} tool, this tool considers all variants, regardless of passing or failing filters.</p>\n+ *\n+ * <h3>Usage example</h3>\n+ *\n+ * <pre>\n+ * gatk ReferenceBlockConcordance \\\n+ *   -R reference.fa \\\n+ *   -eval eval.vcf \\\n+ *   --truth truth.vcf \\\n+ *   --truth-block-histogram truth_block_histogram.tsv \\\n+ *   --eval-block-histogram eval_block_histogram.tsv \\\n+ *   --confidence-concordance-histogram confidence_concordance_histogram.tsv\n+ * </pre>\n+ */\n+\n+@CommandLineProgramProperties(\n+        summary = ReferenceBlockConcordance.USAGE_SUMMARY,\n+        oneLineSummary = ReferenceBlockConcordance.USAGE_ONE_LINE_SUMMARY,\n+        programGroup = VariantEvaluationProgramGroup.class\n+)\n+public class ReferenceBlockConcordance extends AbstractConcordanceWalker {\n+    public static final String TRUTH_BLOCK_HISTOGRAM_LONG_NAME = \"truth-block-histogram\";\n+    public static final String TRUTH_BLOCK_HISTOGRAM_SHORT_NAME = \"tbh\";\n+    public static final String EVAL_BLOCK_HISTOGRAM_LONG_NAME = \"eval-block-histogram\";\n+    public static final String EVAL_BLOCK_HISTOGRAM_SHORT_NAME = \"ebh\";\n+    public static final String CONFIDENCE_CONCORDANCE_HISTOGRAM_LONG_NAME = \"confidence-concordance-histogram\";\n+    public static final String CONFIDENCE_CONCORDANCE_HISTOGRAM_SHORT_NAME = \"cch\";\n+\n+    static final String USAGE_ONE_LINE_SUMMARY = \"Evaluate GVCF reference block concordance of an input GVCF against a truth GVCF\";\n+    static final String USAGE_SUMMARY = \"This tool evaluates two GVCF files against each other and produces three histograms:\\n\" +\n+            \"Truth block histogram: Indicates the number of occurrence of reference blocks with a given confidence score and length in the truth GVCF\\n\" +\n+            \"Eval block histogram: Indicates the number of occurrence of reference blocks with a given confidence score and length in the eval GVCF\\n\" +\n+            \"Confidence concordance histogram: Reflects the confidence scores of bases in reference blocks in the truth and eval VCF, respectively. An entry of 10 at bin \\\"80,90\\\" means that 10 bases in the truth GVCF have a confidence score of 80 while those same bases have a score of 90 in the eval GVCF.\\n\" +\n+            \"In contrast to the Concordance tool, this tool considers all variants, regardless of passing or failing filters.\";\n+\n+    @Argument(doc = \"A histogram of block lengths and their associated confidence scores for the truth sample\",\n+            fullName = TRUTH_BLOCK_HISTOGRAM_LONG_NAME,\n+            shortName = TRUTH_BLOCK_HISTOGRAM_SHORT_NAME)\n+    protected File truthBlockHistogramFile;\n+    @Argument(doc = \"A histogram of block lengths and their associated confidence scores for the eval sample\",\n+            fullName = EVAL_BLOCK_HISTOGRAM_LONG_NAME,\n+            shortName = EVAL_BLOCK_HISTOGRAM_SHORT_NAME)\n+    protected File evalBlockHistogramFile;\n+    @Argument(doc = \"Reflects the confidence scores of bases in reference blocks in the truth and eval VCF, respectively. An entry of 10 at bin \\\"80,90\\\" means that 10 bases in the truth GVCF have a confidence score of 80 while those same bases have a score of 90 in the eval GVCF.\",\n+            fullName = CONFIDENCE_CONCORDANCE_HISTOGRAM_LONG_NAME,\n+            shortName = CONFIDENCE_CONCORDANCE_HISTOGRAM_SHORT_NAME)\n+    protected File confidenceConcordanceHistogramFile;\n+\n+    // TODO this should be a Histogram<Pair<Integer, Integer>>, however, the MetricsFile class cannot read\n+    // arbitrary types, therefore, it must be converted to a String, which is probably much slower\n+    private final Histogram<String> truthBlockHistogram = new Histogram<>();\n+    private final Histogram<String> evalBlockHistogram = new Histogram<>();\n+    private final Histogram<String> confidenceConcordanceHistogram = new Histogram<>();\n+\n+    private VariantContext currentTruthVariantContext = null;\n+    private VariantContext currentEvalVariantContext = null;\n+    private String currentContig = null;\n+\n+    @Override\n+    protected Predicate<VariantContext> makeTruthVariantFilter() {\n+        // Explicitly allow symbolic variants\n+        return vc -> !vc.isStructuralIndel();\n+    }\n+\n+    @Override\n+    protected Predicate<VariantContext> makeEvalVariantFilter() {\n+        // Explicitly allow symbolic variants\n+        return vc -> !vc.isStructuralIndel();\n+    }\n+\n+    private boolean isNonRef(VariantContext variantContext) {\n+        return variantContext.isSymbolic() && variantContext.getAlternateAllele(0).isNonRefAllele();\n+    }\n+\n+    private void evaluateEndOfContig() {\n+        if (currentTruthVariantContext != null && currentEvalVariantContext != null) {\n+            int blockStart = Math.max(currentTruthVariantContext.getStart(), currentEvalVariantContext.getStart());\n+            int blockEnd = Math.min(currentTruthVariantContext.getEnd(), currentEvalVariantContext.getEnd());\n+            int jointBlockLength = blockEnd - blockStart + 1;\n+            if (jointBlockLength > 0) {\n+                confidenceConcordanceHistogram.increment(new Pair<>(currentTruthVariantContext.getGenotype(0).getGQ(), currentEvalVariantContext.getGenotype(0).getGQ()).toString(), jointBlockLength);\n+            }\n+        }\n+\n+        currentTruthVariantContext = null;\n+        currentEvalVariantContext = null;\n+        currentContig = null;\n+    }\n+\n+    private void evaluateNewContig(TruthVersusEval truthVersusEval) {\n+        // If not beginning of file\n+        if (currentContig != null) {\n+            evaluateEndOfContig();\n+        }\n+\n+        currentContig = truthVersusEval.getTruthIfPresentElseEval().getContig();\n+    }\n+\n+    @Override\n+    protected void apply(TruthVersusEval truthVersusEval, ReadsContext readsContext, ReferenceContext refContext) {\n+        // New contig or beginning of file\n+        if (!truthVersusEval.getTruthIfPresentElseEval().getContig().equals(currentContig)) {\n+            evaluateNewContig(truthVersusEval);\n+        }\n+\n+        // Evaluate only when currently seeing two NON_REF blocks\n+        if (currentTruthVariantContext != null && currentEvalVariantContext != null) {\n+            int blockStart = Math.max(currentTruthVariantContext.getStart(), currentEvalVariantContext.getStart());\n+            int blockEnd = Math.min(currentTruthVariantContext.getEnd(), currentEvalVariantContext.getEnd());\n+            int jointBlockLength = blockEnd - blockStart + 1;\n+            // It is possible that jointBlockLength is negative if there is a gap in one file and the start of a new block in the other file.\n+            // Since there is no overlap though, we can just skip that case.\n+            if (jointBlockLength > 0) {\n+                confidenceConcordanceHistogram.increment(new Pair<>(currentTruthVariantContext.getGenotype(0).getGQ(), currentEvalVariantContext.getGenotype(0).getGQ()).toString(), blockEnd - blockStart + 1);\n+            }\n+\n+            int currentPosition = truthVersusEval.getTruthIfPresentElseEval().getStart();\n+            if (truthVersusEval.hasTruth() || currentPosition >= currentTruthVariantContext.getEnd()) {\n+                currentTruthVariantContext = null;\n+            }\n+            if (truthVersusEval.hasEval() || currentPosition >= currentEvalVariantContext.getEnd()) {\n+                currentEvalVariantContext = null;\n+            }\n+        }\n+\n+        // Truth\n+        if (truthVersusEval.hasTruth() && isNonRef(truthVersusEval.getTruth())) {\n+            currentTruthVariantContext = truthVersusEval.getTruth();\n+\n+            // The end is inclusive, thus the plus one when calculating the length\n+            int blockLength = truthVersusEval.getTruth().getEnd() - truthVersusEval.getTruth().getStart() + 1;\n+\n+            // TODO can a non_ref block ever have a number of genotypes != 1?\n+            if(truthVersusEval.getTruth().getGenotypes().size() != 1) {\n+                throw new IllegalStateException(String.format(\"The NON_REF block \\\"%s\\\" has more than one genotype, which is not supported.\", truthVersusEval.getTruth().toStringDecodeGenotypes()));\n+            }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3146dabf366156d1ad5743ce786f475a525804c4"}, "originalPosition": 164}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTYwMDAyNQ==", "bodyText": "Is it fine to use a test file from a different tool or should I copy it?", "url": "https://github.com/broadinstitute/gatk/pull/6802#discussion_r485600025", "createdAt": "2020-09-09T13:13:03Z", "author": {"login": "michaelgatzen"}, "path": "src/test/java/org/broadinstitute/hellbender/tools/walkers/validation/ReferenceBlockConcordanceIntegrationTest.java", "diffHunk": "@@ -0,0 +1,436 @@\n+package org.broadinstitute.hellbender.tools.walkers.validation;\n+\n+import htsjdk.samtools.metrics.MetricsFile;\n+import htsjdk.samtools.util.Histogram;\n+import org.broadinstitute.hellbender.CommandLineProgramTest;\n+import org.broadinstitute.hellbender.engine.AbstractConcordanceWalker;\n+import org.testng.Assert;\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+import picard.sam.util.Pair;\n+\n+import java.io.File;\n+import java.io.FileReader;\n+import java.io.FileWriter;\n+import java.nio.file.Path;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+/**\n+ * Created by Michael Gatzen on 9/9/20.\n+ */\n+public class ReferenceBlockConcordanceIntegrationTest extends CommandLineProgramTest{\n+\n+    private static final String CONCORDANCE_TEST_DIR = toolsTestDir + \"concordance/\";\n+    private static final String HAPLOTYPECALLER_TEST_DIR = toolsTestDir + \"haplotypecaller/\";\n+\n+    @Test\n+    public void testIdentical() throws Exception {\n+        // TODO Is it fine to use a test file from a different tool or should I copy it?\n+        final File truthVcf = new File(HAPLOTYPECALLER_TEST_DIR, \"expected.testGVCFMode.gatk4.g.vcf\");\n+        final File evalVcf = new File(HAPLOTYPECALLER_TEST_DIR, \"expected.testGVCFMode.gatk4.g.vcf\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3146dabf366156d1ad5743ce786f475a525804c4"}, "originalPosition": 34}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "df904bc0857d2939326188ce3932e9f3601838fd", "author": {"user": {"login": "michaelgatzen", "name": null}}, "url": "https://github.com/broadinstitute/gatk/commit/df904bc0857d2939326188ce3932e9f3601838fd", "committedDate": "2020-09-11T15:23:37Z", "message": "Update to variant filtering\n\n- Adjusted filtering to only include symbolic variants, as other variants are irrelevant to this tool"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDg2MjQzODc4", "url": "https://github.com/broadinstitute/gatk/pull/6802#pullrequestreview-486243878", "createdAt": "2020-09-10T19:24:29Z", "commit": {"oid": "3146dabf366156d1ad5743ce786f475a525804c4"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 23, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMFQxOToyNDozMFrOHQCnHA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMVQxNzoyODo0MFrOHQnkFw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjU4MjA0NA==", "bodyText": "occurrences", "url": "https://github.com/broadinstitute/gatk/pull/6802#discussion_r486582044", "createdAt": "2020-09-10T19:24:30Z", "author": {"login": "kachulis"}, "path": "src/main/java/org/broadinstitute/hellbender/tools/walkers/validation/ReferenceBlockConcordance.java", "diffHunk": "@@ -0,0 +1,215 @@\n+package org.broadinstitute.hellbender.tools.walkers.validation;\n+\n+import htsjdk.samtools.metrics.MetricsFile;\n+import htsjdk.samtools.util.Histogram;\n+import htsjdk.variant.variantcontext.Genotype;\n+import htsjdk.variant.variantcontext.VariantContext;\n+import org.apache.commons.collections4.Predicate;\n+import org.broadinstitute.barclay.argparser.Argument;\n+import org.broadinstitute.barclay.argparser.CommandLineProgramProperties;\n+import org.broadinstitute.hellbender.engine.AbstractConcordanceWalker;\n+import org.broadinstitute.hellbender.engine.ReadsContext;\n+import org.broadinstitute.hellbender.engine.ReferenceContext;\n+import picard.cmdline.programgroups.VariantEvaluationProgramGroup;\n+import picard.sam.util.Pair;\n+\n+import java.io.File;\n+\n+/**\n+ * Evaluate GVCF reference block concordance of an input GVCF against a truth GVCF.\n+ *\n+ * <p>This tool evaluates two GVCF files against each other and produces three histograms:</p>\n+ *\n+ * <ul>\n+ *     <li>Truth block histogram: Indicates the number of occurrence of reference blocks with a given confidence score and length in the truth GVCF</li>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3146dabf366156d1ad5743ce786f475a525804c4"}, "originalPosition": 24}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjU4MzQwMw==", "bodyText": "could you clarify the only bases in reference blocks in both files are considered", "url": "https://github.com/broadinstitute/gatk/pull/6802#discussion_r486583403", "createdAt": "2020-09-10T19:27:02Z", "author": {"login": "kachulis"}, "path": "src/main/java/org/broadinstitute/hellbender/tools/walkers/validation/ReferenceBlockConcordance.java", "diffHunk": "@@ -0,0 +1,215 @@\n+package org.broadinstitute.hellbender.tools.walkers.validation;\n+\n+import htsjdk.samtools.metrics.MetricsFile;\n+import htsjdk.samtools.util.Histogram;\n+import htsjdk.variant.variantcontext.Genotype;\n+import htsjdk.variant.variantcontext.VariantContext;\n+import org.apache.commons.collections4.Predicate;\n+import org.broadinstitute.barclay.argparser.Argument;\n+import org.broadinstitute.barclay.argparser.CommandLineProgramProperties;\n+import org.broadinstitute.hellbender.engine.AbstractConcordanceWalker;\n+import org.broadinstitute.hellbender.engine.ReadsContext;\n+import org.broadinstitute.hellbender.engine.ReferenceContext;\n+import picard.cmdline.programgroups.VariantEvaluationProgramGroup;\n+import picard.sam.util.Pair;\n+\n+import java.io.File;\n+\n+/**\n+ * Evaluate GVCF reference block concordance of an input GVCF against a truth GVCF.\n+ *\n+ * <p>This tool evaluates two GVCF files against each other and produces three histograms:</p>\n+ *\n+ * <ul>\n+ *     <li>Truth block histogram: Indicates the number of occurrence of reference blocks with a given confidence score and length in the truth GVCF</li>\n+ *     <li>Eval block histogram: Indicates the number of occurrence of reference blocks with a given confidence score and length in the eval GVCF</li>\n+ *     <li>Confidence concordance histogram: Reflects the confidence scores of bases in reference blocks in the truth and eval VCF, respectively. An entry of 10 at bin \"80,90\" means that 10 bases in the truth GVCF have a confidence score of 80 while those same bases have a score of 90 in the eval GVCF.</li>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3146dabf366156d1ad5743ce786f475a525804c4"}, "originalPosition": 26}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjU4NDQzMQ==", "bodyText": "I think this could be slightly clearer.  Something like \"... means that there are 10 bases which sumultaneously have a reference confidence of 80 in the truth GVCF and a reference confidence of 90 in the evalGVCF\"", "url": "https://github.com/broadinstitute/gatk/pull/6802#discussion_r486584431", "createdAt": "2020-09-10T19:29:08Z", "author": {"login": "kachulis"}, "path": "src/main/java/org/broadinstitute/hellbender/tools/walkers/validation/ReferenceBlockConcordance.java", "diffHunk": "@@ -0,0 +1,215 @@\n+package org.broadinstitute.hellbender.tools.walkers.validation;\n+\n+import htsjdk.samtools.metrics.MetricsFile;\n+import htsjdk.samtools.util.Histogram;\n+import htsjdk.variant.variantcontext.Genotype;\n+import htsjdk.variant.variantcontext.VariantContext;\n+import org.apache.commons.collections4.Predicate;\n+import org.broadinstitute.barclay.argparser.Argument;\n+import org.broadinstitute.barclay.argparser.CommandLineProgramProperties;\n+import org.broadinstitute.hellbender.engine.AbstractConcordanceWalker;\n+import org.broadinstitute.hellbender.engine.ReadsContext;\n+import org.broadinstitute.hellbender.engine.ReferenceContext;\n+import picard.cmdline.programgroups.VariantEvaluationProgramGroup;\n+import picard.sam.util.Pair;\n+\n+import java.io.File;\n+\n+/**\n+ * Evaluate GVCF reference block concordance of an input GVCF against a truth GVCF.\n+ *\n+ * <p>This tool evaluates two GVCF files against each other and produces three histograms:</p>\n+ *\n+ * <ul>\n+ *     <li>Truth block histogram: Indicates the number of occurrence of reference blocks with a given confidence score and length in the truth GVCF</li>\n+ *     <li>Eval block histogram: Indicates the number of occurrence of reference blocks with a given confidence score and length in the eval GVCF</li>\n+ *     <li>Confidence concordance histogram: Reflects the confidence scores of bases in reference blocks in the truth and eval VCF, respectively. An entry of 10 at bin \"80,90\" means that 10 bases in the truth GVCF have a confidence score of 80 while those same bases have a score of 90 in the eval GVCF.</li>\n+ * </ul>\n+ *\n+ * <p>In contrast to the {@link Concordance} tool, this tool considers all variants, regardless of passing or failing filters.</p>\n+ *\n+ * <h3>Usage example</h3>\n+ *\n+ * <pre>\n+ * gatk ReferenceBlockConcordance \\\n+ *   -R reference.fa \\\n+ *   -eval eval.vcf \\\n+ *   --truth truth.vcf \\\n+ *   --truth-block-histogram truth_block_histogram.tsv \\\n+ *   --eval-block-histogram eval_block_histogram.tsv \\\n+ *   --confidence-concordance-histogram confidence_concordance_histogram.tsv\n+ * </pre>\n+ */\n+\n+@CommandLineProgramProperties(\n+        summary = ReferenceBlockConcordance.USAGE_SUMMARY,\n+        oneLineSummary = ReferenceBlockConcordance.USAGE_ONE_LINE_SUMMARY,\n+        programGroup = VariantEvaluationProgramGroup.class\n+)\n+public class ReferenceBlockConcordance extends AbstractConcordanceWalker {\n+    public static final String TRUTH_BLOCK_HISTOGRAM_LONG_NAME = \"truth-block-histogram\";\n+    public static final String TRUTH_BLOCK_HISTOGRAM_SHORT_NAME = \"tbh\";\n+    public static final String EVAL_BLOCK_HISTOGRAM_LONG_NAME = \"eval-block-histogram\";\n+    public static final String EVAL_BLOCK_HISTOGRAM_SHORT_NAME = \"ebh\";\n+    public static final String CONFIDENCE_CONCORDANCE_HISTOGRAM_LONG_NAME = \"confidence-concordance-histogram\";\n+    public static final String CONFIDENCE_CONCORDANCE_HISTOGRAM_SHORT_NAME = \"cch\";\n+\n+    static final String USAGE_ONE_LINE_SUMMARY = \"Evaluate GVCF reference block concordance of an input GVCF against a truth GVCF\";\n+    static final String USAGE_SUMMARY = \"This tool evaluates two GVCF files against each other and produces three histograms:\\n\" +\n+            \"Truth block histogram: Indicates the number of occurrence of reference blocks with a given confidence score and length in the truth GVCF\\n\" +\n+            \"Eval block histogram: Indicates the number of occurrence of reference blocks with a given confidence score and length in the eval GVCF\\n\" +\n+            \"Confidence concordance histogram: Reflects the confidence scores of bases in reference blocks in the truth and eval VCF, respectively. An entry of 10 at bin \\\"80,90\\\" means that 10 bases in the truth GVCF have a confidence score of 80 while those same bases have a score of 90 in the eval GVCF.\\n\" +", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3146dabf366156d1ad5743ce786f475a525804c4"}, "originalPosition": 61}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjYzOTkwMQ==", "bodyText": "It's not thrilling that the write -> read cycle will result in a different type than was started with, but I think making this a Histogram<String> instead of a Histogram<Pair<Integer, Integer>> isn't really necessary.  It feels better to have these private fields be clearer even if technically when you read in the metric later (in your tests for example) the type is different.", "url": "https://github.com/broadinstitute/gatk/pull/6802#discussion_r486639901", "createdAt": "2020-09-10T21:19:55Z", "author": {"login": "kachulis"}, "path": "src/main/java/org/broadinstitute/hellbender/tools/walkers/validation/ReferenceBlockConcordance.java", "diffHunk": "@@ -0,0 +1,215 @@\n+package org.broadinstitute.hellbender.tools.walkers.validation;\n+\n+import htsjdk.samtools.metrics.MetricsFile;\n+import htsjdk.samtools.util.Histogram;\n+import htsjdk.variant.variantcontext.Genotype;\n+import htsjdk.variant.variantcontext.VariantContext;\n+import org.apache.commons.collections4.Predicate;\n+import org.broadinstitute.barclay.argparser.Argument;\n+import org.broadinstitute.barclay.argparser.CommandLineProgramProperties;\n+import org.broadinstitute.hellbender.engine.AbstractConcordanceWalker;\n+import org.broadinstitute.hellbender.engine.ReadsContext;\n+import org.broadinstitute.hellbender.engine.ReferenceContext;\n+import picard.cmdline.programgroups.VariantEvaluationProgramGroup;\n+import picard.sam.util.Pair;\n+\n+import java.io.File;\n+\n+/**\n+ * Evaluate GVCF reference block concordance of an input GVCF against a truth GVCF.\n+ *\n+ * <p>This tool evaluates two GVCF files against each other and produces three histograms:</p>\n+ *\n+ * <ul>\n+ *     <li>Truth block histogram: Indicates the number of occurrence of reference blocks with a given confidence score and length in the truth GVCF</li>\n+ *     <li>Eval block histogram: Indicates the number of occurrence of reference blocks with a given confidence score and length in the eval GVCF</li>\n+ *     <li>Confidence concordance histogram: Reflects the confidence scores of bases in reference blocks in the truth and eval VCF, respectively. An entry of 10 at bin \"80,90\" means that 10 bases in the truth GVCF have a confidence score of 80 while those same bases have a score of 90 in the eval GVCF.</li>\n+ * </ul>\n+ *\n+ * <p>In contrast to the {@link Concordance} tool, this tool considers all variants, regardless of passing or failing filters.</p>\n+ *\n+ * <h3>Usage example</h3>\n+ *\n+ * <pre>\n+ * gatk ReferenceBlockConcordance \\\n+ *   -R reference.fa \\\n+ *   -eval eval.vcf \\\n+ *   --truth truth.vcf \\\n+ *   --truth-block-histogram truth_block_histogram.tsv \\\n+ *   --eval-block-histogram eval_block_histogram.tsv \\\n+ *   --confidence-concordance-histogram confidence_concordance_histogram.tsv\n+ * </pre>\n+ */\n+\n+@CommandLineProgramProperties(\n+        summary = ReferenceBlockConcordance.USAGE_SUMMARY,\n+        oneLineSummary = ReferenceBlockConcordance.USAGE_ONE_LINE_SUMMARY,\n+        programGroup = VariantEvaluationProgramGroup.class\n+)\n+public class ReferenceBlockConcordance extends AbstractConcordanceWalker {\n+    public static final String TRUTH_BLOCK_HISTOGRAM_LONG_NAME = \"truth-block-histogram\";\n+    public static final String TRUTH_BLOCK_HISTOGRAM_SHORT_NAME = \"tbh\";\n+    public static final String EVAL_BLOCK_HISTOGRAM_LONG_NAME = \"eval-block-histogram\";\n+    public static final String EVAL_BLOCK_HISTOGRAM_SHORT_NAME = \"ebh\";\n+    public static final String CONFIDENCE_CONCORDANCE_HISTOGRAM_LONG_NAME = \"confidence-concordance-histogram\";\n+    public static final String CONFIDENCE_CONCORDANCE_HISTOGRAM_SHORT_NAME = \"cch\";\n+\n+    static final String USAGE_ONE_LINE_SUMMARY = \"Evaluate GVCF reference block concordance of an input GVCF against a truth GVCF\";\n+    static final String USAGE_SUMMARY = \"This tool evaluates two GVCF files against each other and produces three histograms:\\n\" +\n+            \"Truth block histogram: Indicates the number of occurrence of reference blocks with a given confidence score and length in the truth GVCF\\n\" +\n+            \"Eval block histogram: Indicates the number of occurrence of reference blocks with a given confidence score and length in the eval GVCF\\n\" +\n+            \"Confidence concordance histogram: Reflects the confidence scores of bases in reference blocks in the truth and eval VCF, respectively. An entry of 10 at bin \\\"80,90\\\" means that 10 bases in the truth GVCF have a confidence score of 80 while those same bases have a score of 90 in the eval GVCF.\\n\" +\n+            \"In contrast to the Concordance tool, this tool considers all variants, regardless of passing or failing filters.\";\n+\n+    @Argument(doc = \"A histogram of block lengths and their associated confidence scores for the truth sample\",\n+            fullName = TRUTH_BLOCK_HISTOGRAM_LONG_NAME,\n+            shortName = TRUTH_BLOCK_HISTOGRAM_SHORT_NAME)\n+    protected File truthBlockHistogramFile;\n+    @Argument(doc = \"A histogram of block lengths and their associated confidence scores for the eval sample\",\n+            fullName = EVAL_BLOCK_HISTOGRAM_LONG_NAME,\n+            shortName = EVAL_BLOCK_HISTOGRAM_SHORT_NAME)\n+    protected File evalBlockHistogramFile;\n+    @Argument(doc = \"Reflects the confidence scores of bases in reference blocks in the truth and eval VCF, respectively. An entry of 10 at bin \\\"80,90\\\" means that 10 bases in the truth GVCF have a confidence score of 80 while those same bases have a score of 90 in the eval GVCF.\",\n+            fullName = CONFIDENCE_CONCORDANCE_HISTOGRAM_LONG_NAME,\n+            shortName = CONFIDENCE_CONCORDANCE_HISTOGRAM_SHORT_NAME)\n+    protected File confidenceConcordanceHistogramFile;\n+\n+    // TODO this should be a Histogram<Pair<Integer, Integer>>, however, the MetricsFile class cannot read\n+    // arbitrary types, therefore, it must be converted to a String, which is probably much slower\n+    private final Histogram<String> truthBlockHistogram = new Histogram<>();\n+    private final Histogram<String> evalBlockHistogram = new Histogram<>();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTU5ODQwOA=="}, "originalCommit": {"oid": "3146dabf366156d1ad5743ce786f475a525804c4"}, "originalPosition": 80}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzA3NTE5Mw==", "bodyText": "I think the Truth and Eval code here could be refactored into a single method", "url": "https://github.com/broadinstitute/gatk/pull/6802#discussion_r487075193", "createdAt": "2020-09-11T14:16:31Z", "author": {"login": "kachulis"}, "path": "src/main/java/org/broadinstitute/hellbender/tools/walkers/validation/ReferenceBlockConcordance.java", "diffHunk": "@@ -0,0 +1,215 @@\n+package org.broadinstitute.hellbender.tools.walkers.validation;\n+\n+import htsjdk.samtools.metrics.MetricsFile;\n+import htsjdk.samtools.util.Histogram;\n+import htsjdk.variant.variantcontext.Genotype;\n+import htsjdk.variant.variantcontext.VariantContext;\n+import org.apache.commons.collections4.Predicate;\n+import org.broadinstitute.barclay.argparser.Argument;\n+import org.broadinstitute.barclay.argparser.CommandLineProgramProperties;\n+import org.broadinstitute.hellbender.engine.AbstractConcordanceWalker;\n+import org.broadinstitute.hellbender.engine.ReadsContext;\n+import org.broadinstitute.hellbender.engine.ReferenceContext;\n+import picard.cmdline.programgroups.VariantEvaluationProgramGroup;\n+import picard.sam.util.Pair;\n+\n+import java.io.File;\n+\n+/**\n+ * Evaluate GVCF reference block concordance of an input GVCF against a truth GVCF.\n+ *\n+ * <p>This tool evaluates two GVCF files against each other and produces three histograms:</p>\n+ *\n+ * <ul>\n+ *     <li>Truth block histogram: Indicates the number of occurrence of reference blocks with a given confidence score and length in the truth GVCF</li>\n+ *     <li>Eval block histogram: Indicates the number of occurrence of reference blocks with a given confidence score and length in the eval GVCF</li>\n+ *     <li>Confidence concordance histogram: Reflects the confidence scores of bases in reference blocks in the truth and eval VCF, respectively. An entry of 10 at bin \"80,90\" means that 10 bases in the truth GVCF have a confidence score of 80 while those same bases have a score of 90 in the eval GVCF.</li>\n+ * </ul>\n+ *\n+ * <p>In contrast to the {@link Concordance} tool, this tool considers all variants, regardless of passing or failing filters.</p>\n+ *\n+ * <h3>Usage example</h3>\n+ *\n+ * <pre>\n+ * gatk ReferenceBlockConcordance \\\n+ *   -R reference.fa \\\n+ *   -eval eval.vcf \\\n+ *   --truth truth.vcf \\\n+ *   --truth-block-histogram truth_block_histogram.tsv \\\n+ *   --eval-block-histogram eval_block_histogram.tsv \\\n+ *   --confidence-concordance-histogram confidence_concordance_histogram.tsv\n+ * </pre>\n+ */\n+\n+@CommandLineProgramProperties(\n+        summary = ReferenceBlockConcordance.USAGE_SUMMARY,\n+        oneLineSummary = ReferenceBlockConcordance.USAGE_ONE_LINE_SUMMARY,\n+        programGroup = VariantEvaluationProgramGroup.class\n+)\n+public class ReferenceBlockConcordance extends AbstractConcordanceWalker {\n+    public static final String TRUTH_BLOCK_HISTOGRAM_LONG_NAME = \"truth-block-histogram\";\n+    public static final String TRUTH_BLOCK_HISTOGRAM_SHORT_NAME = \"tbh\";\n+    public static final String EVAL_BLOCK_HISTOGRAM_LONG_NAME = \"eval-block-histogram\";\n+    public static final String EVAL_BLOCK_HISTOGRAM_SHORT_NAME = \"ebh\";\n+    public static final String CONFIDENCE_CONCORDANCE_HISTOGRAM_LONG_NAME = \"confidence-concordance-histogram\";\n+    public static final String CONFIDENCE_CONCORDANCE_HISTOGRAM_SHORT_NAME = \"cch\";\n+\n+    static final String USAGE_ONE_LINE_SUMMARY = \"Evaluate GVCF reference block concordance of an input GVCF against a truth GVCF\";\n+    static final String USAGE_SUMMARY = \"This tool evaluates two GVCF files against each other and produces three histograms:\\n\" +\n+            \"Truth block histogram: Indicates the number of occurrence of reference blocks with a given confidence score and length in the truth GVCF\\n\" +\n+            \"Eval block histogram: Indicates the number of occurrence of reference blocks with a given confidence score and length in the eval GVCF\\n\" +\n+            \"Confidence concordance histogram: Reflects the confidence scores of bases in reference blocks in the truth and eval VCF, respectively. An entry of 10 at bin \\\"80,90\\\" means that 10 bases in the truth GVCF have a confidence score of 80 while those same bases have a score of 90 in the eval GVCF.\\n\" +\n+            \"In contrast to the Concordance tool, this tool considers all variants, regardless of passing or failing filters.\";\n+\n+    @Argument(doc = \"A histogram of block lengths and their associated confidence scores for the truth sample\",\n+            fullName = TRUTH_BLOCK_HISTOGRAM_LONG_NAME,\n+            shortName = TRUTH_BLOCK_HISTOGRAM_SHORT_NAME)\n+    protected File truthBlockHistogramFile;\n+    @Argument(doc = \"A histogram of block lengths and their associated confidence scores for the eval sample\",\n+            fullName = EVAL_BLOCK_HISTOGRAM_LONG_NAME,\n+            shortName = EVAL_BLOCK_HISTOGRAM_SHORT_NAME)\n+    protected File evalBlockHistogramFile;\n+    @Argument(doc = \"Reflects the confidence scores of bases in reference blocks in the truth and eval VCF, respectively. An entry of 10 at bin \\\"80,90\\\" means that 10 bases in the truth GVCF have a confidence score of 80 while those same bases have a score of 90 in the eval GVCF.\",\n+            fullName = CONFIDENCE_CONCORDANCE_HISTOGRAM_LONG_NAME,\n+            shortName = CONFIDENCE_CONCORDANCE_HISTOGRAM_SHORT_NAME)\n+    protected File confidenceConcordanceHistogramFile;\n+\n+    // TODO this should be a Histogram<Pair<Integer, Integer>>, however, the MetricsFile class cannot read\n+    // arbitrary types, therefore, it must be converted to a String, which is probably much slower\n+    private final Histogram<String> truthBlockHistogram = new Histogram<>();\n+    private final Histogram<String> evalBlockHistogram = new Histogram<>();\n+    private final Histogram<String> confidenceConcordanceHistogram = new Histogram<>();\n+\n+    private VariantContext currentTruthVariantContext = null;\n+    private VariantContext currentEvalVariantContext = null;\n+    private String currentContig = null;\n+\n+    @Override\n+    protected Predicate<VariantContext> makeTruthVariantFilter() {\n+        // Explicitly allow symbolic variants\n+        return vc -> !vc.isStructuralIndel();\n+    }\n+\n+    @Override\n+    protected Predicate<VariantContext> makeEvalVariantFilter() {\n+        // Explicitly allow symbolic variants\n+        return vc -> !vc.isStructuralIndel();\n+    }\n+\n+    private boolean isNonRef(VariantContext variantContext) {\n+        return variantContext.isSymbolic() && variantContext.getAlternateAllele(0).isNonRefAllele();\n+    }\n+\n+    private void evaluateEndOfContig() {\n+        if (currentTruthVariantContext != null && currentEvalVariantContext != null) {\n+            int blockStart = Math.max(currentTruthVariantContext.getStart(), currentEvalVariantContext.getStart());\n+            int blockEnd = Math.min(currentTruthVariantContext.getEnd(), currentEvalVariantContext.getEnd());\n+            int jointBlockLength = blockEnd - blockStart + 1;\n+            if (jointBlockLength > 0) {\n+                confidenceConcordanceHistogram.increment(new Pair<>(currentTruthVariantContext.getGenotype(0).getGQ(), currentEvalVariantContext.getGenotype(0).getGQ()).toString(), jointBlockLength);\n+            }\n+        }\n+\n+        currentTruthVariantContext = null;\n+        currentEvalVariantContext = null;\n+        currentContig = null;\n+    }\n+\n+    private void evaluateNewContig(TruthVersusEval truthVersusEval) {\n+        // If not beginning of file\n+        if (currentContig != null) {\n+            evaluateEndOfContig();\n+        }\n+\n+        currentContig = truthVersusEval.getTruthIfPresentElseEval().getContig();\n+    }\n+\n+    @Override\n+    protected void apply(TruthVersusEval truthVersusEval, ReadsContext readsContext, ReferenceContext refContext) {\n+        // New contig or beginning of file\n+        if (!truthVersusEval.getTruthIfPresentElseEval().getContig().equals(currentContig)) {\n+            evaluateNewContig(truthVersusEval);\n+        }\n+\n+        // Evaluate only when currently seeing two NON_REF blocks\n+        if (currentTruthVariantContext != null && currentEvalVariantContext != null) {\n+            int blockStart = Math.max(currentTruthVariantContext.getStart(), currentEvalVariantContext.getStart());\n+            int blockEnd = Math.min(currentTruthVariantContext.getEnd(), currentEvalVariantContext.getEnd());\n+            int jointBlockLength = blockEnd - blockStart + 1;\n+            // It is possible that jointBlockLength is negative if there is a gap in one file and the start of a new block in the other file.\n+            // Since there is no overlap though, we can just skip that case.\n+            if (jointBlockLength > 0) {\n+                confidenceConcordanceHistogram.increment(new Pair<>(currentTruthVariantContext.getGenotype(0).getGQ(), currentEvalVariantContext.getGenotype(0).getGQ()).toString(), blockEnd - blockStart + 1);\n+            }\n+\n+            int currentPosition = truthVersusEval.getTruthIfPresentElseEval().getStart();\n+            if (truthVersusEval.hasTruth() || currentPosition >= currentTruthVariantContext.getEnd()) {\n+                currentTruthVariantContext = null;\n+            }\n+            if (truthVersusEval.hasEval() || currentPosition >= currentEvalVariantContext.getEnd()) {\n+                currentEvalVariantContext = null;\n+            }\n+        }\n+\n+        // Truth", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3146dabf366156d1ad5743ce786f475a525804c4"}, "originalPosition": 154}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzA3NjE1Mg==", "bodyText": "Would be easier to get a SimpleInterval object for each vc, and then use those for intersection/length instead of calculating those yourself", "url": "https://github.com/broadinstitute/gatk/pull/6802#discussion_r487076152", "createdAt": "2020-09-11T14:17:59Z", "author": {"login": "kachulis"}, "path": "src/main/java/org/broadinstitute/hellbender/tools/walkers/validation/ReferenceBlockConcordance.java", "diffHunk": "@@ -0,0 +1,215 @@\n+package org.broadinstitute.hellbender.tools.walkers.validation;\n+\n+import htsjdk.samtools.metrics.MetricsFile;\n+import htsjdk.samtools.util.Histogram;\n+import htsjdk.variant.variantcontext.Genotype;\n+import htsjdk.variant.variantcontext.VariantContext;\n+import org.apache.commons.collections4.Predicate;\n+import org.broadinstitute.barclay.argparser.Argument;\n+import org.broadinstitute.barclay.argparser.CommandLineProgramProperties;\n+import org.broadinstitute.hellbender.engine.AbstractConcordanceWalker;\n+import org.broadinstitute.hellbender.engine.ReadsContext;\n+import org.broadinstitute.hellbender.engine.ReferenceContext;\n+import picard.cmdline.programgroups.VariantEvaluationProgramGroup;\n+import picard.sam.util.Pair;\n+\n+import java.io.File;\n+\n+/**\n+ * Evaluate GVCF reference block concordance of an input GVCF against a truth GVCF.\n+ *\n+ * <p>This tool evaluates two GVCF files against each other and produces three histograms:</p>\n+ *\n+ * <ul>\n+ *     <li>Truth block histogram: Indicates the number of occurrence of reference blocks with a given confidence score and length in the truth GVCF</li>\n+ *     <li>Eval block histogram: Indicates the number of occurrence of reference blocks with a given confidence score and length in the eval GVCF</li>\n+ *     <li>Confidence concordance histogram: Reflects the confidence scores of bases in reference blocks in the truth and eval VCF, respectively. An entry of 10 at bin \"80,90\" means that 10 bases in the truth GVCF have a confidence score of 80 while those same bases have a score of 90 in the eval GVCF.</li>\n+ * </ul>\n+ *\n+ * <p>In contrast to the {@link Concordance} tool, this tool considers all variants, regardless of passing or failing filters.</p>\n+ *\n+ * <h3>Usage example</h3>\n+ *\n+ * <pre>\n+ * gatk ReferenceBlockConcordance \\\n+ *   -R reference.fa \\\n+ *   -eval eval.vcf \\\n+ *   --truth truth.vcf \\\n+ *   --truth-block-histogram truth_block_histogram.tsv \\\n+ *   --eval-block-histogram eval_block_histogram.tsv \\\n+ *   --confidence-concordance-histogram confidence_concordance_histogram.tsv\n+ * </pre>\n+ */\n+\n+@CommandLineProgramProperties(\n+        summary = ReferenceBlockConcordance.USAGE_SUMMARY,\n+        oneLineSummary = ReferenceBlockConcordance.USAGE_ONE_LINE_SUMMARY,\n+        programGroup = VariantEvaluationProgramGroup.class\n+)\n+public class ReferenceBlockConcordance extends AbstractConcordanceWalker {\n+    public static final String TRUTH_BLOCK_HISTOGRAM_LONG_NAME = \"truth-block-histogram\";\n+    public static final String TRUTH_BLOCK_HISTOGRAM_SHORT_NAME = \"tbh\";\n+    public static final String EVAL_BLOCK_HISTOGRAM_LONG_NAME = \"eval-block-histogram\";\n+    public static final String EVAL_BLOCK_HISTOGRAM_SHORT_NAME = \"ebh\";\n+    public static final String CONFIDENCE_CONCORDANCE_HISTOGRAM_LONG_NAME = \"confidence-concordance-histogram\";\n+    public static final String CONFIDENCE_CONCORDANCE_HISTOGRAM_SHORT_NAME = \"cch\";\n+\n+    static final String USAGE_ONE_LINE_SUMMARY = \"Evaluate GVCF reference block concordance of an input GVCF against a truth GVCF\";\n+    static final String USAGE_SUMMARY = \"This tool evaluates two GVCF files against each other and produces three histograms:\\n\" +\n+            \"Truth block histogram: Indicates the number of occurrence of reference blocks with a given confidence score and length in the truth GVCF\\n\" +\n+            \"Eval block histogram: Indicates the number of occurrence of reference blocks with a given confidence score and length in the eval GVCF\\n\" +\n+            \"Confidence concordance histogram: Reflects the confidence scores of bases in reference blocks in the truth and eval VCF, respectively. An entry of 10 at bin \\\"80,90\\\" means that 10 bases in the truth GVCF have a confidence score of 80 while those same bases have a score of 90 in the eval GVCF.\\n\" +\n+            \"In contrast to the Concordance tool, this tool considers all variants, regardless of passing or failing filters.\";\n+\n+    @Argument(doc = \"A histogram of block lengths and their associated confidence scores for the truth sample\",\n+            fullName = TRUTH_BLOCK_HISTOGRAM_LONG_NAME,\n+            shortName = TRUTH_BLOCK_HISTOGRAM_SHORT_NAME)\n+    protected File truthBlockHistogramFile;\n+    @Argument(doc = \"A histogram of block lengths and their associated confidence scores for the eval sample\",\n+            fullName = EVAL_BLOCK_HISTOGRAM_LONG_NAME,\n+            shortName = EVAL_BLOCK_HISTOGRAM_SHORT_NAME)\n+    protected File evalBlockHistogramFile;\n+    @Argument(doc = \"Reflects the confidence scores of bases in reference blocks in the truth and eval VCF, respectively. An entry of 10 at bin \\\"80,90\\\" means that 10 bases in the truth GVCF have a confidence score of 80 while those same bases have a score of 90 in the eval GVCF.\",\n+            fullName = CONFIDENCE_CONCORDANCE_HISTOGRAM_LONG_NAME,\n+            shortName = CONFIDENCE_CONCORDANCE_HISTOGRAM_SHORT_NAME)\n+    protected File confidenceConcordanceHistogramFile;\n+\n+    // TODO this should be a Histogram<Pair<Integer, Integer>>, however, the MetricsFile class cannot read\n+    // arbitrary types, therefore, it must be converted to a String, which is probably much slower\n+    private final Histogram<String> truthBlockHistogram = new Histogram<>();\n+    private final Histogram<String> evalBlockHistogram = new Histogram<>();\n+    private final Histogram<String> confidenceConcordanceHistogram = new Histogram<>();\n+\n+    private VariantContext currentTruthVariantContext = null;\n+    private VariantContext currentEvalVariantContext = null;\n+    private String currentContig = null;\n+\n+    @Override\n+    protected Predicate<VariantContext> makeTruthVariantFilter() {\n+        // Explicitly allow symbolic variants\n+        return vc -> !vc.isStructuralIndel();\n+    }\n+\n+    @Override\n+    protected Predicate<VariantContext> makeEvalVariantFilter() {\n+        // Explicitly allow symbolic variants\n+        return vc -> !vc.isStructuralIndel();\n+    }\n+\n+    private boolean isNonRef(VariantContext variantContext) {\n+        return variantContext.isSymbolic() && variantContext.getAlternateAllele(0).isNonRefAllele();\n+    }\n+\n+    private void evaluateEndOfContig() {\n+        if (currentTruthVariantContext != null && currentEvalVariantContext != null) {\n+            int blockStart = Math.max(currentTruthVariantContext.getStart(), currentEvalVariantContext.getStart());\n+            int blockEnd = Math.min(currentTruthVariantContext.getEnd(), currentEvalVariantContext.getEnd());\n+            int jointBlockLength = blockEnd - blockStart + 1;\n+            if (jointBlockLength > 0) {\n+                confidenceConcordanceHistogram.increment(new Pair<>(currentTruthVariantContext.getGenotype(0).getGQ(), currentEvalVariantContext.getGenotype(0).getGQ()).toString(), jointBlockLength);\n+            }\n+        }\n+\n+        currentTruthVariantContext = null;\n+        currentEvalVariantContext = null;\n+        currentContig = null;\n+    }\n+\n+    private void evaluateNewContig(TruthVersusEval truthVersusEval) {\n+        // If not beginning of file\n+        if (currentContig != null) {\n+            evaluateEndOfContig();\n+        }\n+\n+        currentContig = truthVersusEval.getTruthIfPresentElseEval().getContig();\n+    }\n+\n+    @Override\n+    protected void apply(TruthVersusEval truthVersusEval, ReadsContext readsContext, ReferenceContext refContext) {\n+        // New contig or beginning of file\n+        if (!truthVersusEval.getTruthIfPresentElseEval().getContig().equals(currentContig)) {\n+            evaluateNewContig(truthVersusEval);\n+        }\n+\n+        // Evaluate only when currently seeing two NON_REF blocks\n+        if (currentTruthVariantContext != null && currentEvalVariantContext != null) {\n+            int blockStart = Math.max(currentTruthVariantContext.getStart(), currentEvalVariantContext.getStart());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3146dabf366156d1ad5743ce786f475a525804c4"}, "originalPosition": 136}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzA4NDYwOA==", "bodyText": "input/output files should be GATKPath", "url": "https://github.com/broadinstitute/gatk/pull/6802#discussion_r487084608", "createdAt": "2020-09-11T14:31:20Z", "author": {"login": "kachulis"}, "path": "src/main/java/org/broadinstitute/hellbender/tools/walkers/validation/ReferenceBlockConcordance.java", "diffHunk": "@@ -0,0 +1,215 @@\n+package org.broadinstitute.hellbender.tools.walkers.validation;\n+\n+import htsjdk.samtools.metrics.MetricsFile;\n+import htsjdk.samtools.util.Histogram;\n+import htsjdk.variant.variantcontext.Genotype;\n+import htsjdk.variant.variantcontext.VariantContext;\n+import org.apache.commons.collections4.Predicate;\n+import org.broadinstitute.barclay.argparser.Argument;\n+import org.broadinstitute.barclay.argparser.CommandLineProgramProperties;\n+import org.broadinstitute.hellbender.engine.AbstractConcordanceWalker;\n+import org.broadinstitute.hellbender.engine.ReadsContext;\n+import org.broadinstitute.hellbender.engine.ReferenceContext;\n+import picard.cmdline.programgroups.VariantEvaluationProgramGroup;\n+import picard.sam.util.Pair;\n+\n+import java.io.File;\n+\n+/**\n+ * Evaluate GVCF reference block concordance of an input GVCF against a truth GVCF.\n+ *\n+ * <p>This tool evaluates two GVCF files against each other and produces three histograms:</p>\n+ *\n+ * <ul>\n+ *     <li>Truth block histogram: Indicates the number of occurrence of reference blocks with a given confidence score and length in the truth GVCF</li>\n+ *     <li>Eval block histogram: Indicates the number of occurrence of reference blocks with a given confidence score and length in the eval GVCF</li>\n+ *     <li>Confidence concordance histogram: Reflects the confidence scores of bases in reference blocks in the truth and eval VCF, respectively. An entry of 10 at bin \"80,90\" means that 10 bases in the truth GVCF have a confidence score of 80 while those same bases have a score of 90 in the eval GVCF.</li>\n+ * </ul>\n+ *\n+ * <p>In contrast to the {@link Concordance} tool, this tool considers all variants, regardless of passing or failing filters.</p>\n+ *\n+ * <h3>Usage example</h3>\n+ *\n+ * <pre>\n+ * gatk ReferenceBlockConcordance \\\n+ *   -R reference.fa \\\n+ *   -eval eval.vcf \\\n+ *   --truth truth.vcf \\\n+ *   --truth-block-histogram truth_block_histogram.tsv \\\n+ *   --eval-block-histogram eval_block_histogram.tsv \\\n+ *   --confidence-concordance-histogram confidence_concordance_histogram.tsv\n+ * </pre>\n+ */\n+\n+@CommandLineProgramProperties(\n+        summary = ReferenceBlockConcordance.USAGE_SUMMARY,\n+        oneLineSummary = ReferenceBlockConcordance.USAGE_ONE_LINE_SUMMARY,\n+        programGroup = VariantEvaluationProgramGroup.class\n+)\n+public class ReferenceBlockConcordance extends AbstractConcordanceWalker {\n+    public static final String TRUTH_BLOCK_HISTOGRAM_LONG_NAME = \"truth-block-histogram\";\n+    public static final String TRUTH_BLOCK_HISTOGRAM_SHORT_NAME = \"tbh\";\n+    public static final String EVAL_BLOCK_HISTOGRAM_LONG_NAME = \"eval-block-histogram\";\n+    public static final String EVAL_BLOCK_HISTOGRAM_SHORT_NAME = \"ebh\";\n+    public static final String CONFIDENCE_CONCORDANCE_HISTOGRAM_LONG_NAME = \"confidence-concordance-histogram\";\n+    public static final String CONFIDENCE_CONCORDANCE_HISTOGRAM_SHORT_NAME = \"cch\";\n+\n+    static final String USAGE_ONE_LINE_SUMMARY = \"Evaluate GVCF reference block concordance of an input GVCF against a truth GVCF\";\n+    static final String USAGE_SUMMARY = \"This tool evaluates two GVCF files against each other and produces three histograms:\\n\" +\n+            \"Truth block histogram: Indicates the number of occurrence of reference blocks with a given confidence score and length in the truth GVCF\\n\" +\n+            \"Eval block histogram: Indicates the number of occurrence of reference blocks with a given confidence score and length in the eval GVCF\\n\" +\n+            \"Confidence concordance histogram: Reflects the confidence scores of bases in reference blocks in the truth and eval VCF, respectively. An entry of 10 at bin \\\"80,90\\\" means that 10 bases in the truth GVCF have a confidence score of 80 while those same bases have a score of 90 in the eval GVCF.\\n\" +\n+            \"In contrast to the Concordance tool, this tool considers all variants, regardless of passing or failing filters.\";\n+\n+    @Argument(doc = \"A histogram of block lengths and their associated confidence scores for the truth sample\",\n+            fullName = TRUTH_BLOCK_HISTOGRAM_LONG_NAME,\n+            shortName = TRUTH_BLOCK_HISTOGRAM_SHORT_NAME)\n+    protected File truthBlockHistogramFile;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3146dabf366156d1ad5743ce786f475a525804c4"}, "originalPosition": 67}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzEzNTg4Nw==", "bodyText": "The number of genotypes is actually the number of samples in the gvcf (one genotype per sample).  At the moment I think it's reasonable to focus this tool on single sample gvcfs only, so keeping this check is good (though should adjust the error message to clarify that we have been given a multisample gvcf, which isn't yet supported).  could add support for multisample gvcf in the future if the need arises.", "url": "https://github.com/broadinstitute/gatk/pull/6802#discussion_r487135887", "createdAt": "2020-09-11T15:51:56Z", "author": {"login": "kachulis"}, "path": "src/main/java/org/broadinstitute/hellbender/tools/walkers/validation/ReferenceBlockConcordance.java", "diffHunk": "@@ -0,0 +1,215 @@\n+package org.broadinstitute.hellbender.tools.walkers.validation;\n+\n+import htsjdk.samtools.metrics.MetricsFile;\n+import htsjdk.samtools.util.Histogram;\n+import htsjdk.variant.variantcontext.Genotype;\n+import htsjdk.variant.variantcontext.VariantContext;\n+import org.apache.commons.collections4.Predicate;\n+import org.broadinstitute.barclay.argparser.Argument;\n+import org.broadinstitute.barclay.argparser.CommandLineProgramProperties;\n+import org.broadinstitute.hellbender.engine.AbstractConcordanceWalker;\n+import org.broadinstitute.hellbender.engine.ReadsContext;\n+import org.broadinstitute.hellbender.engine.ReferenceContext;\n+import picard.cmdline.programgroups.VariantEvaluationProgramGroup;\n+import picard.sam.util.Pair;\n+\n+import java.io.File;\n+\n+/**\n+ * Evaluate GVCF reference block concordance of an input GVCF against a truth GVCF.\n+ *\n+ * <p>This tool evaluates two GVCF files against each other and produces three histograms:</p>\n+ *\n+ * <ul>\n+ *     <li>Truth block histogram: Indicates the number of occurrence of reference blocks with a given confidence score and length in the truth GVCF</li>\n+ *     <li>Eval block histogram: Indicates the number of occurrence of reference blocks with a given confidence score and length in the eval GVCF</li>\n+ *     <li>Confidence concordance histogram: Reflects the confidence scores of bases in reference blocks in the truth and eval VCF, respectively. An entry of 10 at bin \"80,90\" means that 10 bases in the truth GVCF have a confidence score of 80 while those same bases have a score of 90 in the eval GVCF.</li>\n+ * </ul>\n+ *\n+ * <p>In contrast to the {@link Concordance} tool, this tool considers all variants, regardless of passing or failing filters.</p>\n+ *\n+ * <h3>Usage example</h3>\n+ *\n+ * <pre>\n+ * gatk ReferenceBlockConcordance \\\n+ *   -R reference.fa \\\n+ *   -eval eval.vcf \\\n+ *   --truth truth.vcf \\\n+ *   --truth-block-histogram truth_block_histogram.tsv \\\n+ *   --eval-block-histogram eval_block_histogram.tsv \\\n+ *   --confidence-concordance-histogram confidence_concordance_histogram.tsv\n+ * </pre>\n+ */\n+\n+@CommandLineProgramProperties(\n+        summary = ReferenceBlockConcordance.USAGE_SUMMARY,\n+        oneLineSummary = ReferenceBlockConcordance.USAGE_ONE_LINE_SUMMARY,\n+        programGroup = VariantEvaluationProgramGroup.class\n+)\n+public class ReferenceBlockConcordance extends AbstractConcordanceWalker {\n+    public static final String TRUTH_BLOCK_HISTOGRAM_LONG_NAME = \"truth-block-histogram\";\n+    public static final String TRUTH_BLOCK_HISTOGRAM_SHORT_NAME = \"tbh\";\n+    public static final String EVAL_BLOCK_HISTOGRAM_LONG_NAME = \"eval-block-histogram\";\n+    public static final String EVAL_BLOCK_HISTOGRAM_SHORT_NAME = \"ebh\";\n+    public static final String CONFIDENCE_CONCORDANCE_HISTOGRAM_LONG_NAME = \"confidence-concordance-histogram\";\n+    public static final String CONFIDENCE_CONCORDANCE_HISTOGRAM_SHORT_NAME = \"cch\";\n+\n+    static final String USAGE_ONE_LINE_SUMMARY = \"Evaluate GVCF reference block concordance of an input GVCF against a truth GVCF\";\n+    static final String USAGE_SUMMARY = \"This tool evaluates two GVCF files against each other and produces three histograms:\\n\" +\n+            \"Truth block histogram: Indicates the number of occurrence of reference blocks with a given confidence score and length in the truth GVCF\\n\" +\n+            \"Eval block histogram: Indicates the number of occurrence of reference blocks with a given confidence score and length in the eval GVCF\\n\" +\n+            \"Confidence concordance histogram: Reflects the confidence scores of bases in reference blocks in the truth and eval VCF, respectively. An entry of 10 at bin \\\"80,90\\\" means that 10 bases in the truth GVCF have a confidence score of 80 while those same bases have a score of 90 in the eval GVCF.\\n\" +\n+            \"In contrast to the Concordance tool, this tool considers all variants, regardless of passing or failing filters.\";\n+\n+    @Argument(doc = \"A histogram of block lengths and their associated confidence scores for the truth sample\",\n+            fullName = TRUTH_BLOCK_HISTOGRAM_LONG_NAME,\n+            shortName = TRUTH_BLOCK_HISTOGRAM_SHORT_NAME)\n+    protected File truthBlockHistogramFile;\n+    @Argument(doc = \"A histogram of block lengths and their associated confidence scores for the eval sample\",\n+            fullName = EVAL_BLOCK_HISTOGRAM_LONG_NAME,\n+            shortName = EVAL_BLOCK_HISTOGRAM_SHORT_NAME)\n+    protected File evalBlockHistogramFile;\n+    @Argument(doc = \"Reflects the confidence scores of bases in reference blocks in the truth and eval VCF, respectively. An entry of 10 at bin \\\"80,90\\\" means that 10 bases in the truth GVCF have a confidence score of 80 while those same bases have a score of 90 in the eval GVCF.\",\n+            fullName = CONFIDENCE_CONCORDANCE_HISTOGRAM_LONG_NAME,\n+            shortName = CONFIDENCE_CONCORDANCE_HISTOGRAM_SHORT_NAME)\n+    protected File confidenceConcordanceHistogramFile;\n+\n+    // TODO this should be a Histogram<Pair<Integer, Integer>>, however, the MetricsFile class cannot read\n+    // arbitrary types, therefore, it must be converted to a String, which is probably much slower\n+    private final Histogram<String> truthBlockHistogram = new Histogram<>();\n+    private final Histogram<String> evalBlockHistogram = new Histogram<>();\n+    private final Histogram<String> confidenceConcordanceHistogram = new Histogram<>();\n+\n+    private VariantContext currentTruthVariantContext = null;\n+    private VariantContext currentEvalVariantContext = null;\n+    private String currentContig = null;\n+\n+    @Override\n+    protected Predicate<VariantContext> makeTruthVariantFilter() {\n+        // Explicitly allow symbolic variants\n+        return vc -> !vc.isStructuralIndel();\n+    }\n+\n+    @Override\n+    protected Predicate<VariantContext> makeEvalVariantFilter() {\n+        // Explicitly allow symbolic variants\n+        return vc -> !vc.isStructuralIndel();\n+    }\n+\n+    private boolean isNonRef(VariantContext variantContext) {\n+        return variantContext.isSymbolic() && variantContext.getAlternateAllele(0).isNonRefAllele();\n+    }\n+\n+    private void evaluateEndOfContig() {\n+        if (currentTruthVariantContext != null && currentEvalVariantContext != null) {\n+            int blockStart = Math.max(currentTruthVariantContext.getStart(), currentEvalVariantContext.getStart());\n+            int blockEnd = Math.min(currentTruthVariantContext.getEnd(), currentEvalVariantContext.getEnd());\n+            int jointBlockLength = blockEnd - blockStart + 1;\n+            if (jointBlockLength > 0) {\n+                confidenceConcordanceHistogram.increment(new Pair<>(currentTruthVariantContext.getGenotype(0).getGQ(), currentEvalVariantContext.getGenotype(0).getGQ()).toString(), jointBlockLength);\n+            }\n+        }\n+\n+        currentTruthVariantContext = null;\n+        currentEvalVariantContext = null;\n+        currentContig = null;\n+    }\n+\n+    private void evaluateNewContig(TruthVersusEval truthVersusEval) {\n+        // If not beginning of file\n+        if (currentContig != null) {\n+            evaluateEndOfContig();\n+        }\n+\n+        currentContig = truthVersusEval.getTruthIfPresentElseEval().getContig();\n+    }\n+\n+    @Override\n+    protected void apply(TruthVersusEval truthVersusEval, ReadsContext readsContext, ReferenceContext refContext) {\n+        // New contig or beginning of file\n+        if (!truthVersusEval.getTruthIfPresentElseEval().getContig().equals(currentContig)) {\n+            evaluateNewContig(truthVersusEval);\n+        }\n+\n+        // Evaluate only when currently seeing two NON_REF blocks\n+        if (currentTruthVariantContext != null && currentEvalVariantContext != null) {\n+            int blockStart = Math.max(currentTruthVariantContext.getStart(), currentEvalVariantContext.getStart());\n+            int blockEnd = Math.min(currentTruthVariantContext.getEnd(), currentEvalVariantContext.getEnd());\n+            int jointBlockLength = blockEnd - blockStart + 1;\n+            // It is possible that jointBlockLength is negative if there is a gap in one file and the start of a new block in the other file.\n+            // Since there is no overlap though, we can just skip that case.\n+            if (jointBlockLength > 0) {\n+                confidenceConcordanceHistogram.increment(new Pair<>(currentTruthVariantContext.getGenotype(0).getGQ(), currentEvalVariantContext.getGenotype(0).getGQ()).toString(), blockEnd - blockStart + 1);\n+            }\n+\n+            int currentPosition = truthVersusEval.getTruthIfPresentElseEval().getStart();\n+            if (truthVersusEval.hasTruth() || currentPosition >= currentTruthVariantContext.getEnd()) {\n+                currentTruthVariantContext = null;\n+            }\n+            if (truthVersusEval.hasEval() || currentPosition >= currentEvalVariantContext.getEnd()) {\n+                currentEvalVariantContext = null;\n+            }\n+        }\n+\n+        // Truth\n+        if (truthVersusEval.hasTruth() && isNonRef(truthVersusEval.getTruth())) {\n+            currentTruthVariantContext = truthVersusEval.getTruth();\n+\n+            // The end is inclusive, thus the plus one when calculating the length\n+            int blockLength = truthVersusEval.getTruth().getEnd() - truthVersusEval.getTruth().getStart() + 1;\n+\n+            // TODO can a non_ref block ever have a number of genotypes != 1?\n+            if(truthVersusEval.getTruth().getGenotypes().size() != 1) {\n+                throw new IllegalStateException(String.format(\"The NON_REF block \\\"%s\\\" has more than one genotype, which is not supported.\", truthVersusEval.getTruth().toStringDecodeGenotypes()));\n+            }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTU5OTg2Mg=="}, "originalCommit": {"oid": "3146dabf366156d1ad5743ce786f475a525804c4"}, "originalPosition": 164}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzE0NTUzOA==", "bodyText": "I think that instead of checking for a symbolic variant you want to instead check that the genotype of the single sample is homref", "url": "https://github.com/broadinstitute/gatk/pull/6802#discussion_r487145538", "createdAt": "2020-09-11T16:08:49Z", "author": {"login": "kachulis"}, "path": "src/main/java/org/broadinstitute/hellbender/tools/walkers/validation/ReferenceBlockConcordance.java", "diffHunk": "@@ -0,0 +1,215 @@\n+package org.broadinstitute.hellbender.tools.walkers.validation;\n+\n+import htsjdk.samtools.metrics.MetricsFile;\n+import htsjdk.samtools.util.Histogram;\n+import htsjdk.variant.variantcontext.Genotype;\n+import htsjdk.variant.variantcontext.VariantContext;\n+import org.apache.commons.collections4.Predicate;\n+import org.broadinstitute.barclay.argparser.Argument;\n+import org.broadinstitute.barclay.argparser.CommandLineProgramProperties;\n+import org.broadinstitute.hellbender.engine.AbstractConcordanceWalker;\n+import org.broadinstitute.hellbender.engine.ReadsContext;\n+import org.broadinstitute.hellbender.engine.ReferenceContext;\n+import picard.cmdline.programgroups.VariantEvaluationProgramGroup;\n+import picard.sam.util.Pair;\n+\n+import java.io.File;\n+\n+/**\n+ * Evaluate GVCF reference block concordance of an input GVCF against a truth GVCF.\n+ *\n+ * <p>This tool evaluates two GVCF files against each other and produces three histograms:</p>\n+ *\n+ * <ul>\n+ *     <li>Truth block histogram: Indicates the number of occurrence of reference blocks with a given confidence score and length in the truth GVCF</li>\n+ *     <li>Eval block histogram: Indicates the number of occurrence of reference blocks with a given confidence score and length in the eval GVCF</li>\n+ *     <li>Confidence concordance histogram: Reflects the confidence scores of bases in reference blocks in the truth and eval VCF, respectively. An entry of 10 at bin \"80,90\" means that 10 bases in the truth GVCF have a confidence score of 80 while those same bases have a score of 90 in the eval GVCF.</li>\n+ * </ul>\n+ *\n+ * <p>In contrast to the {@link Concordance} tool, this tool considers all variants, regardless of passing or failing filters.</p>\n+ *\n+ * <h3>Usage example</h3>\n+ *\n+ * <pre>\n+ * gatk ReferenceBlockConcordance \\\n+ *   -R reference.fa \\\n+ *   -eval eval.vcf \\\n+ *   --truth truth.vcf \\\n+ *   --truth-block-histogram truth_block_histogram.tsv \\\n+ *   --eval-block-histogram eval_block_histogram.tsv \\\n+ *   --confidence-concordance-histogram confidence_concordance_histogram.tsv\n+ * </pre>\n+ */\n+\n+@CommandLineProgramProperties(\n+        summary = ReferenceBlockConcordance.USAGE_SUMMARY,\n+        oneLineSummary = ReferenceBlockConcordance.USAGE_ONE_LINE_SUMMARY,\n+        programGroup = VariantEvaluationProgramGroup.class\n+)\n+public class ReferenceBlockConcordance extends AbstractConcordanceWalker {\n+    public static final String TRUTH_BLOCK_HISTOGRAM_LONG_NAME = \"truth-block-histogram\";\n+    public static final String TRUTH_BLOCK_HISTOGRAM_SHORT_NAME = \"tbh\";\n+    public static final String EVAL_BLOCK_HISTOGRAM_LONG_NAME = \"eval-block-histogram\";\n+    public static final String EVAL_BLOCK_HISTOGRAM_SHORT_NAME = \"ebh\";\n+    public static final String CONFIDENCE_CONCORDANCE_HISTOGRAM_LONG_NAME = \"confidence-concordance-histogram\";\n+    public static final String CONFIDENCE_CONCORDANCE_HISTOGRAM_SHORT_NAME = \"cch\";\n+\n+    static final String USAGE_ONE_LINE_SUMMARY = \"Evaluate GVCF reference block concordance of an input GVCF against a truth GVCF\";\n+    static final String USAGE_SUMMARY = \"This tool evaluates two GVCF files against each other and produces three histograms:\\n\" +\n+            \"Truth block histogram: Indicates the number of occurrence of reference blocks with a given confidence score and length in the truth GVCF\\n\" +\n+            \"Eval block histogram: Indicates the number of occurrence of reference blocks with a given confidence score and length in the eval GVCF\\n\" +\n+            \"Confidence concordance histogram: Reflects the confidence scores of bases in reference blocks in the truth and eval VCF, respectively. An entry of 10 at bin \\\"80,90\\\" means that 10 bases in the truth GVCF have a confidence score of 80 while those same bases have a score of 90 in the eval GVCF.\\n\" +\n+            \"In contrast to the Concordance tool, this tool considers all variants, regardless of passing or failing filters.\";\n+\n+    @Argument(doc = \"A histogram of block lengths and their associated confidence scores for the truth sample\",\n+            fullName = TRUTH_BLOCK_HISTOGRAM_LONG_NAME,\n+            shortName = TRUTH_BLOCK_HISTOGRAM_SHORT_NAME)\n+    protected File truthBlockHistogramFile;\n+    @Argument(doc = \"A histogram of block lengths and their associated confidence scores for the eval sample\",\n+            fullName = EVAL_BLOCK_HISTOGRAM_LONG_NAME,\n+            shortName = EVAL_BLOCK_HISTOGRAM_SHORT_NAME)\n+    protected File evalBlockHistogramFile;\n+    @Argument(doc = \"Reflects the confidence scores of bases in reference blocks in the truth and eval VCF, respectively. An entry of 10 at bin \\\"80,90\\\" means that 10 bases in the truth GVCF have a confidence score of 80 while those same bases have a score of 90 in the eval GVCF.\",\n+            fullName = CONFIDENCE_CONCORDANCE_HISTOGRAM_LONG_NAME,\n+            shortName = CONFIDENCE_CONCORDANCE_HISTOGRAM_SHORT_NAME)\n+    protected File confidenceConcordanceHistogramFile;\n+\n+    // TODO this should be a Histogram<Pair<Integer, Integer>>, however, the MetricsFile class cannot read\n+    // arbitrary types, therefore, it must be converted to a String, which is probably much slower\n+    private final Histogram<String> truthBlockHistogram = new Histogram<>();\n+    private final Histogram<String> evalBlockHistogram = new Histogram<>();\n+    private final Histogram<String> confidenceConcordanceHistogram = new Histogram<>();\n+\n+    private VariantContext currentTruthVariantContext = null;\n+    private VariantContext currentEvalVariantContext = null;\n+    private String currentContig = null;\n+\n+    @Override\n+    protected Predicate<VariantContext> makeTruthVariantFilter() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "df904bc0857d2939326188ce3932e9f3601838fd"}, "originalPosition": 88}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzE0NjA4Mw==", "bodyText": "instead of checking for the <NON_REF> symbolic allele, just check that the called genotype is hom_ref.  would change the name of the method to reflect this as well.", "url": "https://github.com/broadinstitute/gatk/pull/6802#discussion_r487146083", "createdAt": "2020-09-11T16:09:52Z", "author": {"login": "kachulis"}, "path": "src/main/java/org/broadinstitute/hellbender/tools/walkers/validation/ReferenceBlockConcordance.java", "diffHunk": "@@ -0,0 +1,215 @@\n+package org.broadinstitute.hellbender.tools.walkers.validation;\n+\n+import htsjdk.samtools.metrics.MetricsFile;\n+import htsjdk.samtools.util.Histogram;\n+import htsjdk.variant.variantcontext.Genotype;\n+import htsjdk.variant.variantcontext.VariantContext;\n+import org.apache.commons.collections4.Predicate;\n+import org.broadinstitute.barclay.argparser.Argument;\n+import org.broadinstitute.barclay.argparser.CommandLineProgramProperties;\n+import org.broadinstitute.hellbender.engine.AbstractConcordanceWalker;\n+import org.broadinstitute.hellbender.engine.ReadsContext;\n+import org.broadinstitute.hellbender.engine.ReferenceContext;\n+import picard.cmdline.programgroups.VariantEvaluationProgramGroup;\n+import picard.sam.util.Pair;\n+\n+import java.io.File;\n+\n+/**\n+ * Evaluate GVCF reference block concordance of an input GVCF against a truth GVCF.\n+ *\n+ * <p>This tool evaluates two GVCF files against each other and produces three histograms:</p>\n+ *\n+ * <ul>\n+ *     <li>Truth block histogram: Indicates the number of occurrence of reference blocks with a given confidence score and length in the truth GVCF</li>\n+ *     <li>Eval block histogram: Indicates the number of occurrence of reference blocks with a given confidence score and length in the eval GVCF</li>\n+ *     <li>Confidence concordance histogram: Reflects the confidence scores of bases in reference blocks in the truth and eval VCF, respectively. An entry of 10 at bin \"80,90\" means that 10 bases in the truth GVCF have a confidence score of 80 while those same bases have a score of 90 in the eval GVCF.</li>\n+ * </ul>\n+ *\n+ * <p>In contrast to the {@link Concordance} tool, this tool considers all variants, regardless of passing or failing filters.</p>\n+ *\n+ * <h3>Usage example</h3>\n+ *\n+ * <pre>\n+ * gatk ReferenceBlockConcordance \\\n+ *   -R reference.fa \\\n+ *   -eval eval.vcf \\\n+ *   --truth truth.vcf \\\n+ *   --truth-block-histogram truth_block_histogram.tsv \\\n+ *   --eval-block-histogram eval_block_histogram.tsv \\\n+ *   --confidence-concordance-histogram confidence_concordance_histogram.tsv\n+ * </pre>\n+ */\n+\n+@CommandLineProgramProperties(\n+        summary = ReferenceBlockConcordance.USAGE_SUMMARY,\n+        oneLineSummary = ReferenceBlockConcordance.USAGE_ONE_LINE_SUMMARY,\n+        programGroup = VariantEvaluationProgramGroup.class\n+)\n+public class ReferenceBlockConcordance extends AbstractConcordanceWalker {\n+    public static final String TRUTH_BLOCK_HISTOGRAM_LONG_NAME = \"truth-block-histogram\";\n+    public static final String TRUTH_BLOCK_HISTOGRAM_SHORT_NAME = \"tbh\";\n+    public static final String EVAL_BLOCK_HISTOGRAM_LONG_NAME = \"eval-block-histogram\";\n+    public static final String EVAL_BLOCK_HISTOGRAM_SHORT_NAME = \"ebh\";\n+    public static final String CONFIDENCE_CONCORDANCE_HISTOGRAM_LONG_NAME = \"confidence-concordance-histogram\";\n+    public static final String CONFIDENCE_CONCORDANCE_HISTOGRAM_SHORT_NAME = \"cch\";\n+\n+    static final String USAGE_ONE_LINE_SUMMARY = \"Evaluate GVCF reference block concordance of an input GVCF against a truth GVCF\";\n+    static final String USAGE_SUMMARY = \"This tool evaluates two GVCF files against each other and produces three histograms:\\n\" +\n+            \"Truth block histogram: Indicates the number of occurrence of reference blocks with a given confidence score and length in the truth GVCF\\n\" +\n+            \"Eval block histogram: Indicates the number of occurrence of reference blocks with a given confidence score and length in the eval GVCF\\n\" +\n+            \"Confidence concordance histogram: Reflects the confidence scores of bases in reference blocks in the truth and eval VCF, respectively. An entry of 10 at bin \\\"80,90\\\" means that 10 bases in the truth GVCF have a confidence score of 80 while those same bases have a score of 90 in the eval GVCF.\\n\" +\n+            \"In contrast to the Concordance tool, this tool considers all variants, regardless of passing or failing filters.\";\n+\n+    @Argument(doc = \"A histogram of block lengths and their associated confidence scores for the truth sample\",\n+            fullName = TRUTH_BLOCK_HISTOGRAM_LONG_NAME,\n+            shortName = TRUTH_BLOCK_HISTOGRAM_SHORT_NAME)\n+    protected File truthBlockHistogramFile;\n+    @Argument(doc = \"A histogram of block lengths and their associated confidence scores for the eval sample\",\n+            fullName = EVAL_BLOCK_HISTOGRAM_LONG_NAME,\n+            shortName = EVAL_BLOCK_HISTOGRAM_SHORT_NAME)\n+    protected File evalBlockHistogramFile;\n+    @Argument(doc = \"Reflects the confidence scores of bases in reference blocks in the truth and eval VCF, respectively. An entry of 10 at bin \\\"80,90\\\" means that 10 bases in the truth GVCF have a confidence score of 80 while those same bases have a score of 90 in the eval GVCF.\",\n+            fullName = CONFIDENCE_CONCORDANCE_HISTOGRAM_LONG_NAME,\n+            shortName = CONFIDENCE_CONCORDANCE_HISTOGRAM_SHORT_NAME)\n+    protected File confidenceConcordanceHistogramFile;\n+\n+    // TODO this should be a Histogram<Pair<Integer, Integer>>, however, the MetricsFile class cannot read\n+    // arbitrary types, therefore, it must be converted to a String, which is probably much slower\n+    private final Histogram<String> truthBlockHistogram = new Histogram<>();\n+    private final Histogram<String> evalBlockHistogram = new Histogram<>();\n+    private final Histogram<String> confidenceConcordanceHistogram = new Histogram<>();\n+\n+    private VariantContext currentTruthVariantContext = null;\n+    private VariantContext currentEvalVariantContext = null;\n+    private String currentContig = null;\n+\n+    @Override\n+    protected Predicate<VariantContext> makeTruthVariantFilter() {\n+        // Explicitly allow symbolic variants\n+        return VariantContext::isSymbolic;\n+    }\n+\n+    @Override\n+    protected Predicate<VariantContext> makeEvalVariantFilter() {\n+        // Explicitly allow symbolic variants\n+        return VariantContext::isSymbolic;\n+    }\n+\n+    private boolean isNonRef(VariantContext variantContext) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "df904bc0857d2939326188ce3932e9f3601838fd"}, "originalPosition": 99}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzE0NzYyMQ==", "bodyText": "move the isNonRef (or isHomRef) check into the VariantFilters", "url": "https://github.com/broadinstitute/gatk/pull/6802#discussion_r487147621", "createdAt": "2020-09-11T16:12:42Z", "author": {"login": "kachulis"}, "path": "src/main/java/org/broadinstitute/hellbender/tools/walkers/validation/ReferenceBlockConcordance.java", "diffHunk": "@@ -0,0 +1,215 @@\n+package org.broadinstitute.hellbender.tools.walkers.validation;\n+\n+import htsjdk.samtools.metrics.MetricsFile;\n+import htsjdk.samtools.util.Histogram;\n+import htsjdk.variant.variantcontext.Genotype;\n+import htsjdk.variant.variantcontext.VariantContext;\n+import org.apache.commons.collections4.Predicate;\n+import org.broadinstitute.barclay.argparser.Argument;\n+import org.broadinstitute.barclay.argparser.CommandLineProgramProperties;\n+import org.broadinstitute.hellbender.engine.AbstractConcordanceWalker;\n+import org.broadinstitute.hellbender.engine.ReadsContext;\n+import org.broadinstitute.hellbender.engine.ReferenceContext;\n+import picard.cmdline.programgroups.VariantEvaluationProgramGroup;\n+import picard.sam.util.Pair;\n+\n+import java.io.File;\n+\n+/**\n+ * Evaluate GVCF reference block concordance of an input GVCF against a truth GVCF.\n+ *\n+ * <p>This tool evaluates two GVCF files against each other and produces three histograms:</p>\n+ *\n+ * <ul>\n+ *     <li>Truth block histogram: Indicates the number of occurrence of reference blocks with a given confidence score and length in the truth GVCF</li>\n+ *     <li>Eval block histogram: Indicates the number of occurrence of reference blocks with a given confidence score and length in the eval GVCF</li>\n+ *     <li>Confidence concordance histogram: Reflects the confidence scores of bases in reference blocks in the truth and eval VCF, respectively. An entry of 10 at bin \"80,90\" means that 10 bases in the truth GVCF have a confidence score of 80 while those same bases have a score of 90 in the eval GVCF.</li>\n+ * </ul>\n+ *\n+ * <p>In contrast to the {@link Concordance} tool, this tool considers all variants, regardless of passing or failing filters.</p>\n+ *\n+ * <h3>Usage example</h3>\n+ *\n+ * <pre>\n+ * gatk ReferenceBlockConcordance \\\n+ *   -R reference.fa \\\n+ *   -eval eval.vcf \\\n+ *   --truth truth.vcf \\\n+ *   --truth-block-histogram truth_block_histogram.tsv \\\n+ *   --eval-block-histogram eval_block_histogram.tsv \\\n+ *   --confidence-concordance-histogram confidence_concordance_histogram.tsv\n+ * </pre>\n+ */\n+\n+@CommandLineProgramProperties(\n+        summary = ReferenceBlockConcordance.USAGE_SUMMARY,\n+        oneLineSummary = ReferenceBlockConcordance.USAGE_ONE_LINE_SUMMARY,\n+        programGroup = VariantEvaluationProgramGroup.class\n+)\n+public class ReferenceBlockConcordance extends AbstractConcordanceWalker {\n+    public static final String TRUTH_BLOCK_HISTOGRAM_LONG_NAME = \"truth-block-histogram\";\n+    public static final String TRUTH_BLOCK_HISTOGRAM_SHORT_NAME = \"tbh\";\n+    public static final String EVAL_BLOCK_HISTOGRAM_LONG_NAME = \"eval-block-histogram\";\n+    public static final String EVAL_BLOCK_HISTOGRAM_SHORT_NAME = \"ebh\";\n+    public static final String CONFIDENCE_CONCORDANCE_HISTOGRAM_LONG_NAME = \"confidence-concordance-histogram\";\n+    public static final String CONFIDENCE_CONCORDANCE_HISTOGRAM_SHORT_NAME = \"cch\";\n+\n+    static final String USAGE_ONE_LINE_SUMMARY = \"Evaluate GVCF reference block concordance of an input GVCF against a truth GVCF\";\n+    static final String USAGE_SUMMARY = \"This tool evaluates two GVCF files against each other and produces three histograms:\\n\" +\n+            \"Truth block histogram: Indicates the number of occurrence of reference blocks with a given confidence score and length in the truth GVCF\\n\" +\n+            \"Eval block histogram: Indicates the number of occurrence of reference blocks with a given confidence score and length in the eval GVCF\\n\" +\n+            \"Confidence concordance histogram: Reflects the confidence scores of bases in reference blocks in the truth and eval VCF, respectively. An entry of 10 at bin \\\"80,90\\\" means that 10 bases in the truth GVCF have a confidence score of 80 while those same bases have a score of 90 in the eval GVCF.\\n\" +\n+            \"In contrast to the Concordance tool, this tool considers all variants, regardless of passing or failing filters.\";\n+\n+    @Argument(doc = \"A histogram of block lengths and their associated confidence scores for the truth sample\",\n+            fullName = TRUTH_BLOCK_HISTOGRAM_LONG_NAME,\n+            shortName = TRUTH_BLOCK_HISTOGRAM_SHORT_NAME)\n+    protected File truthBlockHistogramFile;\n+    @Argument(doc = \"A histogram of block lengths and their associated confidence scores for the eval sample\",\n+            fullName = EVAL_BLOCK_HISTOGRAM_LONG_NAME,\n+            shortName = EVAL_BLOCK_HISTOGRAM_SHORT_NAME)\n+    protected File evalBlockHistogramFile;\n+    @Argument(doc = \"Reflects the confidence scores of bases in reference blocks in the truth and eval VCF, respectively. An entry of 10 at bin \\\"80,90\\\" means that 10 bases in the truth GVCF have a confidence score of 80 while those same bases have a score of 90 in the eval GVCF.\",\n+            fullName = CONFIDENCE_CONCORDANCE_HISTOGRAM_LONG_NAME,\n+            shortName = CONFIDENCE_CONCORDANCE_HISTOGRAM_SHORT_NAME)\n+    protected File confidenceConcordanceHistogramFile;\n+\n+    // TODO this should be a Histogram<Pair<Integer, Integer>>, however, the MetricsFile class cannot read\n+    // arbitrary types, therefore, it must be converted to a String, which is probably much slower\n+    private final Histogram<String> truthBlockHistogram = new Histogram<>();\n+    private final Histogram<String> evalBlockHistogram = new Histogram<>();\n+    private final Histogram<String> confidenceConcordanceHistogram = new Histogram<>();\n+\n+    private VariantContext currentTruthVariantContext = null;\n+    private VariantContext currentEvalVariantContext = null;\n+    private String currentContig = null;\n+\n+    @Override\n+    protected Predicate<VariantContext> makeTruthVariantFilter() {\n+        // Explicitly allow symbolic variants\n+        return VariantContext::isSymbolic;\n+    }\n+\n+    @Override\n+    protected Predicate<VariantContext> makeEvalVariantFilter() {\n+        // Explicitly allow symbolic variants\n+        return VariantContext::isSymbolic;\n+    }\n+\n+    private boolean isNonRef(VariantContext variantContext) {\n+        return variantContext.isSymbolic() && variantContext.getAlternateAllele(0).isNonRefAllele();\n+    }\n+\n+    private void evaluateEndOfContig() {\n+        if (currentTruthVariantContext != null && currentEvalVariantContext != null) {\n+            int blockStart = Math.max(currentTruthVariantContext.getStart(), currentEvalVariantContext.getStart());\n+            int blockEnd = Math.min(currentTruthVariantContext.getEnd(), currentEvalVariantContext.getEnd());\n+            int jointBlockLength = blockEnd - blockStart + 1;\n+            if (jointBlockLength > 0) {\n+                confidenceConcordanceHistogram.increment(new Pair<>(currentTruthVariantContext.getGenotype(0).getGQ(), currentEvalVariantContext.getGenotype(0).getGQ()).toString(), jointBlockLength);\n+            }\n+        }\n+\n+        currentTruthVariantContext = null;\n+        currentEvalVariantContext = null;\n+        currentContig = null;\n+    }\n+\n+    private void evaluateNewContig(TruthVersusEval truthVersusEval) {\n+        // If not beginning of file\n+        if (currentContig != null) {\n+            evaluateEndOfContig();\n+        }\n+\n+        currentContig = truthVersusEval.getTruthIfPresentElseEval().getContig();\n+    }\n+\n+    @Override\n+    protected void apply(TruthVersusEval truthVersusEval, ReadsContext readsContext, ReferenceContext refContext) {\n+        // New contig or beginning of file\n+        if (!truthVersusEval.getTruthIfPresentElseEval().getContig().equals(currentContig)) {\n+            evaluateNewContig(truthVersusEval);\n+        }\n+\n+        // Evaluate only when currently seeing two NON_REF blocks\n+        if (currentTruthVariantContext != null && currentEvalVariantContext != null) {\n+            int blockStart = Math.max(currentTruthVariantContext.getStart(), currentEvalVariantContext.getStart());\n+            int blockEnd = Math.min(currentTruthVariantContext.getEnd(), currentEvalVariantContext.getEnd());\n+            int jointBlockLength = blockEnd - blockStart + 1;\n+            // It is possible that jointBlockLength is negative if there is a gap in one file and the start of a new block in the other file.\n+            // Since there is no overlap though, we can just skip that case.\n+            if (jointBlockLength > 0) {\n+                confidenceConcordanceHistogram.increment(new Pair<>(currentTruthVariantContext.getGenotype(0).getGQ(), currentEvalVariantContext.getGenotype(0).getGQ()).toString(), blockEnd - blockStart + 1);\n+            }\n+\n+            int currentPosition = truthVersusEval.getTruthIfPresentElseEval().getStart();\n+            if (truthVersusEval.hasTruth() || currentPosition >= currentTruthVariantContext.getEnd()) {\n+                currentTruthVariantContext = null;\n+            }\n+            if (truthVersusEval.hasEval() || currentPosition >= currentEvalVariantContext.getEnd()) {\n+                currentEvalVariantContext = null;\n+            }\n+        }\n+\n+        // Truth\n+        if (truthVersusEval.hasTruth() && isNonRef(truthVersusEval.getTruth())) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "df904bc0857d2939326188ce3932e9f3601838fd"}, "originalPosition": 155}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzE0ODA3Mw==", "bodyText": "final", "url": "https://github.com/broadinstitute/gatk/pull/6802#discussion_r487148073", "createdAt": "2020-09-11T16:13:34Z", "author": {"login": "kachulis"}, "path": "src/main/java/org/broadinstitute/hellbender/tools/walkers/validation/ReferenceBlockConcordance.java", "diffHunk": "@@ -0,0 +1,215 @@\n+package org.broadinstitute.hellbender.tools.walkers.validation;\n+\n+import htsjdk.samtools.metrics.MetricsFile;\n+import htsjdk.samtools.util.Histogram;\n+import htsjdk.variant.variantcontext.Genotype;\n+import htsjdk.variant.variantcontext.VariantContext;\n+import org.apache.commons.collections4.Predicate;\n+import org.broadinstitute.barclay.argparser.Argument;\n+import org.broadinstitute.barclay.argparser.CommandLineProgramProperties;\n+import org.broadinstitute.hellbender.engine.AbstractConcordanceWalker;\n+import org.broadinstitute.hellbender.engine.ReadsContext;\n+import org.broadinstitute.hellbender.engine.ReferenceContext;\n+import picard.cmdline.programgroups.VariantEvaluationProgramGroup;\n+import picard.sam.util.Pair;\n+\n+import java.io.File;\n+\n+/**\n+ * Evaluate GVCF reference block concordance of an input GVCF against a truth GVCF.\n+ *\n+ * <p>This tool evaluates two GVCF files against each other and produces three histograms:</p>\n+ *\n+ * <ul>\n+ *     <li>Truth block histogram: Indicates the number of occurrence of reference blocks with a given confidence score and length in the truth GVCF</li>\n+ *     <li>Eval block histogram: Indicates the number of occurrence of reference blocks with a given confidence score and length in the eval GVCF</li>\n+ *     <li>Confidence concordance histogram: Reflects the confidence scores of bases in reference blocks in the truth and eval VCF, respectively. An entry of 10 at bin \"80,90\" means that 10 bases in the truth GVCF have a confidence score of 80 while those same bases have a score of 90 in the eval GVCF.</li>\n+ * </ul>\n+ *\n+ * <p>In contrast to the {@link Concordance} tool, this tool considers all variants, regardless of passing or failing filters.</p>\n+ *\n+ * <h3>Usage example</h3>\n+ *\n+ * <pre>\n+ * gatk ReferenceBlockConcordance \\\n+ *   -R reference.fa \\\n+ *   -eval eval.vcf \\\n+ *   --truth truth.vcf \\\n+ *   --truth-block-histogram truth_block_histogram.tsv \\\n+ *   --eval-block-histogram eval_block_histogram.tsv \\\n+ *   --confidence-concordance-histogram confidence_concordance_histogram.tsv\n+ * </pre>\n+ */\n+\n+@CommandLineProgramProperties(\n+        summary = ReferenceBlockConcordance.USAGE_SUMMARY,\n+        oneLineSummary = ReferenceBlockConcordance.USAGE_ONE_LINE_SUMMARY,\n+        programGroup = VariantEvaluationProgramGroup.class\n+)\n+public class ReferenceBlockConcordance extends AbstractConcordanceWalker {\n+    public static final String TRUTH_BLOCK_HISTOGRAM_LONG_NAME = \"truth-block-histogram\";\n+    public static final String TRUTH_BLOCK_HISTOGRAM_SHORT_NAME = \"tbh\";\n+    public static final String EVAL_BLOCK_HISTOGRAM_LONG_NAME = \"eval-block-histogram\";\n+    public static final String EVAL_BLOCK_HISTOGRAM_SHORT_NAME = \"ebh\";\n+    public static final String CONFIDENCE_CONCORDANCE_HISTOGRAM_LONG_NAME = \"confidence-concordance-histogram\";\n+    public static final String CONFIDENCE_CONCORDANCE_HISTOGRAM_SHORT_NAME = \"cch\";\n+\n+    static final String USAGE_ONE_LINE_SUMMARY = \"Evaluate GVCF reference block concordance of an input GVCF against a truth GVCF\";\n+    static final String USAGE_SUMMARY = \"This tool evaluates two GVCF files against each other and produces three histograms:\\n\" +\n+            \"Truth block histogram: Indicates the number of occurrence of reference blocks with a given confidence score and length in the truth GVCF\\n\" +\n+            \"Eval block histogram: Indicates the number of occurrence of reference blocks with a given confidence score and length in the eval GVCF\\n\" +\n+            \"Confidence concordance histogram: Reflects the confidence scores of bases in reference blocks in the truth and eval VCF, respectively. An entry of 10 at bin \\\"80,90\\\" means that 10 bases in the truth GVCF have a confidence score of 80 while those same bases have a score of 90 in the eval GVCF.\\n\" +\n+            \"In contrast to the Concordance tool, this tool considers all variants, regardless of passing or failing filters.\";\n+\n+    @Argument(doc = \"A histogram of block lengths and their associated confidence scores for the truth sample\",\n+            fullName = TRUTH_BLOCK_HISTOGRAM_LONG_NAME,\n+            shortName = TRUTH_BLOCK_HISTOGRAM_SHORT_NAME)\n+    protected File truthBlockHistogramFile;\n+    @Argument(doc = \"A histogram of block lengths and their associated confidence scores for the eval sample\",\n+            fullName = EVAL_BLOCK_HISTOGRAM_LONG_NAME,\n+            shortName = EVAL_BLOCK_HISTOGRAM_SHORT_NAME)\n+    protected File evalBlockHistogramFile;\n+    @Argument(doc = \"Reflects the confidence scores of bases in reference blocks in the truth and eval VCF, respectively. An entry of 10 at bin \\\"80,90\\\" means that 10 bases in the truth GVCF have a confidence score of 80 while those same bases have a score of 90 in the eval GVCF.\",\n+            fullName = CONFIDENCE_CONCORDANCE_HISTOGRAM_LONG_NAME,\n+            shortName = CONFIDENCE_CONCORDANCE_HISTOGRAM_SHORT_NAME)\n+    protected File confidenceConcordanceHistogramFile;\n+\n+    // TODO this should be a Histogram<Pair<Integer, Integer>>, however, the MetricsFile class cannot read\n+    // arbitrary types, therefore, it must be converted to a String, which is probably much slower\n+    private final Histogram<String> truthBlockHistogram = new Histogram<>();\n+    private final Histogram<String> evalBlockHistogram = new Histogram<>();\n+    private final Histogram<String> confidenceConcordanceHistogram = new Histogram<>();\n+\n+    private VariantContext currentTruthVariantContext = null;\n+    private VariantContext currentEvalVariantContext = null;\n+    private String currentContig = null;\n+\n+    @Override\n+    protected Predicate<VariantContext> makeTruthVariantFilter() {\n+        // Explicitly allow symbolic variants\n+        return VariantContext::isSymbolic;\n+    }\n+\n+    @Override\n+    protected Predicate<VariantContext> makeEvalVariantFilter() {\n+        // Explicitly allow symbolic variants\n+        return VariantContext::isSymbolic;\n+    }\n+\n+    private boolean isNonRef(VariantContext variantContext) {\n+        return variantContext.isSymbolic() && variantContext.getAlternateAllele(0).isNonRefAllele();\n+    }\n+\n+    private void evaluateEndOfContig() {\n+        if (currentTruthVariantContext != null && currentEvalVariantContext != null) {\n+            int blockStart = Math.max(currentTruthVariantContext.getStart(), currentEvalVariantContext.getStart());\n+            int blockEnd = Math.min(currentTruthVariantContext.getEnd(), currentEvalVariantContext.getEnd());\n+            int jointBlockLength = blockEnd - blockStart + 1;\n+            if (jointBlockLength > 0) {\n+                confidenceConcordanceHistogram.increment(new Pair<>(currentTruthVariantContext.getGenotype(0).getGQ(), currentEvalVariantContext.getGenotype(0).getGQ()).toString(), jointBlockLength);\n+            }\n+        }\n+\n+        currentTruthVariantContext = null;\n+        currentEvalVariantContext = null;\n+        currentContig = null;\n+    }\n+\n+    private void evaluateNewContig(TruthVersusEval truthVersusEval) {\n+        // If not beginning of file\n+        if (currentContig != null) {\n+            evaluateEndOfContig();\n+        }\n+\n+        currentContig = truthVersusEval.getTruthIfPresentElseEval().getContig();\n+    }\n+\n+    @Override\n+    protected void apply(TruthVersusEval truthVersusEval, ReadsContext readsContext, ReferenceContext refContext) {\n+        // New contig or beginning of file\n+        if (!truthVersusEval.getTruthIfPresentElseEval().getContig().equals(currentContig)) {\n+            evaluateNewContig(truthVersusEval);\n+        }\n+\n+        // Evaluate only when currently seeing two NON_REF blocks\n+        if (currentTruthVariantContext != null && currentEvalVariantContext != null) {\n+            int blockStart = Math.max(currentTruthVariantContext.getStart(), currentEvalVariantContext.getStart());\n+            int blockEnd = Math.min(currentTruthVariantContext.getEnd(), currentEvalVariantContext.getEnd());\n+            int jointBlockLength = blockEnd - blockStart + 1;\n+            // It is possible that jointBlockLength is negative if there is a gap in one file and the start of a new block in the other file.\n+            // Since there is no overlap though, we can just skip that case.\n+            if (jointBlockLength > 0) {\n+                confidenceConcordanceHistogram.increment(new Pair<>(currentTruthVariantContext.getGenotype(0).getGQ(), currentEvalVariantContext.getGenotype(0).getGQ()).toString(), blockEnd - blockStart + 1);\n+            }\n+\n+            int currentPosition = truthVersusEval.getTruthIfPresentElseEval().getStart();\n+            if (truthVersusEval.hasTruth() || currentPosition >= currentTruthVariantContext.getEnd()) {\n+                currentTruthVariantContext = null;\n+            }\n+            if (truthVersusEval.hasEval() || currentPosition >= currentEvalVariantContext.getEnd()) {\n+                currentEvalVariantContext = null;\n+            }\n+        }\n+\n+        // Truth\n+        if (truthVersusEval.hasTruth() && isNonRef(truthVersusEval.getTruth())) {\n+            currentTruthVariantContext = truthVersusEval.getTruth();\n+\n+            // The end is inclusive, thus the plus one when calculating the length\n+            int blockLength = truthVersusEval.getTruth().getEnd() - truthVersusEval.getTruth().getStart() + 1;\n+\n+            // TODO can a non_ref block ever have a number of genotypes != 1?\n+            if(truthVersusEval.getTruth().getGenotypes().size() != 1) {\n+                throw new IllegalStateException(String.format(\"The NON_REF block \\\"%s\\\" has more than one genotype, which is not supported.\", truthVersusEval.getTruth().toStringDecodeGenotypes()));\n+            }\n+            Genotype genotype = truthVersusEval.getTruth().getGenotype(0);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "df904bc0857d2939326188ce3932e9f3601838fd"}, "originalPosition": 165}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzE0ODEzOA==", "bodyText": "final (and wherever else possible as well)", "url": "https://github.com/broadinstitute/gatk/pull/6802#discussion_r487148138", "createdAt": "2020-09-11T16:13:41Z", "author": {"login": "kachulis"}, "path": "src/main/java/org/broadinstitute/hellbender/tools/walkers/validation/ReferenceBlockConcordance.java", "diffHunk": "@@ -0,0 +1,215 @@\n+package org.broadinstitute.hellbender.tools.walkers.validation;\n+\n+import htsjdk.samtools.metrics.MetricsFile;\n+import htsjdk.samtools.util.Histogram;\n+import htsjdk.variant.variantcontext.Genotype;\n+import htsjdk.variant.variantcontext.VariantContext;\n+import org.apache.commons.collections4.Predicate;\n+import org.broadinstitute.barclay.argparser.Argument;\n+import org.broadinstitute.barclay.argparser.CommandLineProgramProperties;\n+import org.broadinstitute.hellbender.engine.AbstractConcordanceWalker;\n+import org.broadinstitute.hellbender.engine.ReadsContext;\n+import org.broadinstitute.hellbender.engine.ReferenceContext;\n+import picard.cmdline.programgroups.VariantEvaluationProgramGroup;\n+import picard.sam.util.Pair;\n+\n+import java.io.File;\n+\n+/**\n+ * Evaluate GVCF reference block concordance of an input GVCF against a truth GVCF.\n+ *\n+ * <p>This tool evaluates two GVCF files against each other and produces three histograms:</p>\n+ *\n+ * <ul>\n+ *     <li>Truth block histogram: Indicates the number of occurrence of reference blocks with a given confidence score and length in the truth GVCF</li>\n+ *     <li>Eval block histogram: Indicates the number of occurrence of reference blocks with a given confidence score and length in the eval GVCF</li>\n+ *     <li>Confidence concordance histogram: Reflects the confidence scores of bases in reference blocks in the truth and eval VCF, respectively. An entry of 10 at bin \"80,90\" means that 10 bases in the truth GVCF have a confidence score of 80 while those same bases have a score of 90 in the eval GVCF.</li>\n+ * </ul>\n+ *\n+ * <p>In contrast to the {@link Concordance} tool, this tool considers all variants, regardless of passing or failing filters.</p>\n+ *\n+ * <h3>Usage example</h3>\n+ *\n+ * <pre>\n+ * gatk ReferenceBlockConcordance \\\n+ *   -R reference.fa \\\n+ *   -eval eval.vcf \\\n+ *   --truth truth.vcf \\\n+ *   --truth-block-histogram truth_block_histogram.tsv \\\n+ *   --eval-block-histogram eval_block_histogram.tsv \\\n+ *   --confidence-concordance-histogram confidence_concordance_histogram.tsv\n+ * </pre>\n+ */\n+\n+@CommandLineProgramProperties(\n+        summary = ReferenceBlockConcordance.USAGE_SUMMARY,\n+        oneLineSummary = ReferenceBlockConcordance.USAGE_ONE_LINE_SUMMARY,\n+        programGroup = VariantEvaluationProgramGroup.class\n+)\n+public class ReferenceBlockConcordance extends AbstractConcordanceWalker {\n+    public static final String TRUTH_BLOCK_HISTOGRAM_LONG_NAME = \"truth-block-histogram\";\n+    public static final String TRUTH_BLOCK_HISTOGRAM_SHORT_NAME = \"tbh\";\n+    public static final String EVAL_BLOCK_HISTOGRAM_LONG_NAME = \"eval-block-histogram\";\n+    public static final String EVAL_BLOCK_HISTOGRAM_SHORT_NAME = \"ebh\";\n+    public static final String CONFIDENCE_CONCORDANCE_HISTOGRAM_LONG_NAME = \"confidence-concordance-histogram\";\n+    public static final String CONFIDENCE_CONCORDANCE_HISTOGRAM_SHORT_NAME = \"cch\";\n+\n+    static final String USAGE_ONE_LINE_SUMMARY = \"Evaluate GVCF reference block concordance of an input GVCF against a truth GVCF\";\n+    static final String USAGE_SUMMARY = \"This tool evaluates two GVCF files against each other and produces three histograms:\\n\" +\n+            \"Truth block histogram: Indicates the number of occurrence of reference blocks with a given confidence score and length in the truth GVCF\\n\" +\n+            \"Eval block histogram: Indicates the number of occurrence of reference blocks with a given confidence score and length in the eval GVCF\\n\" +\n+            \"Confidence concordance histogram: Reflects the confidence scores of bases in reference blocks in the truth and eval VCF, respectively. An entry of 10 at bin \\\"80,90\\\" means that 10 bases in the truth GVCF have a confidence score of 80 while those same bases have a score of 90 in the eval GVCF.\\n\" +\n+            \"In contrast to the Concordance tool, this tool considers all variants, regardless of passing or failing filters.\";\n+\n+    @Argument(doc = \"A histogram of block lengths and their associated confidence scores for the truth sample\",\n+            fullName = TRUTH_BLOCK_HISTOGRAM_LONG_NAME,\n+            shortName = TRUTH_BLOCK_HISTOGRAM_SHORT_NAME)\n+    protected File truthBlockHistogramFile;\n+    @Argument(doc = \"A histogram of block lengths and their associated confidence scores for the eval sample\",\n+            fullName = EVAL_BLOCK_HISTOGRAM_LONG_NAME,\n+            shortName = EVAL_BLOCK_HISTOGRAM_SHORT_NAME)\n+    protected File evalBlockHistogramFile;\n+    @Argument(doc = \"Reflects the confidence scores of bases in reference blocks in the truth and eval VCF, respectively. An entry of 10 at bin \\\"80,90\\\" means that 10 bases in the truth GVCF have a confidence score of 80 while those same bases have a score of 90 in the eval GVCF.\",\n+            fullName = CONFIDENCE_CONCORDANCE_HISTOGRAM_LONG_NAME,\n+            shortName = CONFIDENCE_CONCORDANCE_HISTOGRAM_SHORT_NAME)\n+    protected File confidenceConcordanceHistogramFile;\n+\n+    // TODO this should be a Histogram<Pair<Integer, Integer>>, however, the MetricsFile class cannot read\n+    // arbitrary types, therefore, it must be converted to a String, which is probably much slower\n+    private final Histogram<String> truthBlockHistogram = new Histogram<>();\n+    private final Histogram<String> evalBlockHistogram = new Histogram<>();\n+    private final Histogram<String> confidenceConcordanceHistogram = new Histogram<>();\n+\n+    private VariantContext currentTruthVariantContext = null;\n+    private VariantContext currentEvalVariantContext = null;\n+    private String currentContig = null;\n+\n+    @Override\n+    protected Predicate<VariantContext> makeTruthVariantFilter() {\n+        // Explicitly allow symbolic variants\n+        return VariantContext::isSymbolic;\n+    }\n+\n+    @Override\n+    protected Predicate<VariantContext> makeEvalVariantFilter() {\n+        // Explicitly allow symbolic variants\n+        return VariantContext::isSymbolic;\n+    }\n+\n+    private boolean isNonRef(VariantContext variantContext) {\n+        return variantContext.isSymbolic() && variantContext.getAlternateAllele(0).isNonRefAllele();\n+    }\n+\n+    private void evaluateEndOfContig() {\n+        if (currentTruthVariantContext != null && currentEvalVariantContext != null) {\n+            int blockStart = Math.max(currentTruthVariantContext.getStart(), currentEvalVariantContext.getStart());\n+            int blockEnd = Math.min(currentTruthVariantContext.getEnd(), currentEvalVariantContext.getEnd());\n+            int jointBlockLength = blockEnd - blockStart + 1;\n+            if (jointBlockLength > 0) {\n+                confidenceConcordanceHistogram.increment(new Pair<>(currentTruthVariantContext.getGenotype(0).getGQ(), currentEvalVariantContext.getGenotype(0).getGQ()).toString(), jointBlockLength);\n+            }\n+        }\n+\n+        currentTruthVariantContext = null;\n+        currentEvalVariantContext = null;\n+        currentContig = null;\n+    }\n+\n+    private void evaluateNewContig(TruthVersusEval truthVersusEval) {\n+        // If not beginning of file\n+        if (currentContig != null) {\n+            evaluateEndOfContig();\n+        }\n+\n+        currentContig = truthVersusEval.getTruthIfPresentElseEval().getContig();\n+    }\n+\n+    @Override\n+    protected void apply(TruthVersusEval truthVersusEval, ReadsContext readsContext, ReferenceContext refContext) {\n+        // New contig or beginning of file\n+        if (!truthVersusEval.getTruthIfPresentElseEval().getContig().equals(currentContig)) {\n+            evaluateNewContig(truthVersusEval);\n+        }\n+\n+        // Evaluate only when currently seeing two NON_REF blocks\n+        if (currentTruthVariantContext != null && currentEvalVariantContext != null) {\n+            int blockStart = Math.max(currentTruthVariantContext.getStart(), currentEvalVariantContext.getStart());\n+            int blockEnd = Math.min(currentTruthVariantContext.getEnd(), currentEvalVariantContext.getEnd());\n+            int jointBlockLength = blockEnd - blockStart + 1;\n+            // It is possible that jointBlockLength is negative if there is a gap in one file and the start of a new block in the other file.\n+            // Since there is no overlap though, we can just skip that case.\n+            if (jointBlockLength > 0) {\n+                confidenceConcordanceHistogram.increment(new Pair<>(currentTruthVariantContext.getGenotype(0).getGQ(), currentEvalVariantContext.getGenotype(0).getGQ()).toString(), blockEnd - blockStart + 1);\n+            }\n+\n+            int currentPosition = truthVersusEval.getTruthIfPresentElseEval().getStart();\n+            if (truthVersusEval.hasTruth() || currentPosition >= currentTruthVariantContext.getEnd()) {\n+                currentTruthVariantContext = null;\n+            }\n+            if (truthVersusEval.hasEval() || currentPosition >= currentEvalVariantContext.getEnd()) {\n+                currentEvalVariantContext = null;\n+            }\n+        }\n+\n+        // Truth\n+        if (truthVersusEval.hasTruth() && isNonRef(truthVersusEval.getTruth())) {\n+            currentTruthVariantContext = truthVersusEval.getTruth();\n+\n+            // The end is inclusive, thus the plus one when calculating the length\n+            int blockLength = truthVersusEval.getTruth().getEnd() - truthVersusEval.getTruth().getStart() + 1;\n+\n+            // TODO can a non_ref block ever have a number of genotypes != 1?\n+            if(truthVersusEval.getTruth().getGenotypes().size() != 1) {\n+                throw new IllegalStateException(String.format(\"The NON_REF block \\\"%s\\\" has more than one genotype, which is not supported.\", truthVersusEval.getTruth().toStringDecodeGenotypes()));\n+            }\n+            Genotype genotype = truthVersusEval.getTruth().getGenotype(0);\n+            int gq = genotype.getGQ();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "df904bc0857d2939326188ce3932e9f3601838fd"}, "originalPosition": 166}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzE1MDM4OA==", "bodyText": "SimpleInterval instead", "url": "https://github.com/broadinstitute/gatk/pull/6802#discussion_r487150388", "createdAt": "2020-09-11T16:17:46Z", "author": {"login": "kachulis"}, "path": "src/main/java/org/broadinstitute/hellbender/tools/walkers/validation/ReferenceBlockConcordance.java", "diffHunk": "@@ -0,0 +1,215 @@\n+package org.broadinstitute.hellbender.tools.walkers.validation;\n+\n+import htsjdk.samtools.metrics.MetricsFile;\n+import htsjdk.samtools.util.Histogram;\n+import htsjdk.variant.variantcontext.Genotype;\n+import htsjdk.variant.variantcontext.VariantContext;\n+import org.apache.commons.collections4.Predicate;\n+import org.broadinstitute.barclay.argparser.Argument;\n+import org.broadinstitute.barclay.argparser.CommandLineProgramProperties;\n+import org.broadinstitute.hellbender.engine.AbstractConcordanceWalker;\n+import org.broadinstitute.hellbender.engine.ReadsContext;\n+import org.broadinstitute.hellbender.engine.ReferenceContext;\n+import picard.cmdline.programgroups.VariantEvaluationProgramGroup;\n+import picard.sam.util.Pair;\n+\n+import java.io.File;\n+\n+/**\n+ * Evaluate GVCF reference block concordance of an input GVCF against a truth GVCF.\n+ *\n+ * <p>This tool evaluates two GVCF files against each other and produces three histograms:</p>\n+ *\n+ * <ul>\n+ *     <li>Truth block histogram: Indicates the number of occurrence of reference blocks with a given confidence score and length in the truth GVCF</li>\n+ *     <li>Eval block histogram: Indicates the number of occurrence of reference blocks with a given confidence score and length in the eval GVCF</li>\n+ *     <li>Confidence concordance histogram: Reflects the confidence scores of bases in reference blocks in the truth and eval VCF, respectively. An entry of 10 at bin \"80,90\" means that 10 bases in the truth GVCF have a confidence score of 80 while those same bases have a score of 90 in the eval GVCF.</li>\n+ * </ul>\n+ *\n+ * <p>In contrast to the {@link Concordance} tool, this tool considers all variants, regardless of passing or failing filters.</p>\n+ *\n+ * <h3>Usage example</h3>\n+ *\n+ * <pre>\n+ * gatk ReferenceBlockConcordance \\\n+ *   -R reference.fa \\\n+ *   -eval eval.vcf \\\n+ *   --truth truth.vcf \\\n+ *   --truth-block-histogram truth_block_histogram.tsv \\\n+ *   --eval-block-histogram eval_block_histogram.tsv \\\n+ *   --confidence-concordance-histogram confidence_concordance_histogram.tsv\n+ * </pre>\n+ */\n+\n+@CommandLineProgramProperties(\n+        summary = ReferenceBlockConcordance.USAGE_SUMMARY,\n+        oneLineSummary = ReferenceBlockConcordance.USAGE_ONE_LINE_SUMMARY,\n+        programGroup = VariantEvaluationProgramGroup.class\n+)\n+public class ReferenceBlockConcordance extends AbstractConcordanceWalker {\n+    public static final String TRUTH_BLOCK_HISTOGRAM_LONG_NAME = \"truth-block-histogram\";\n+    public static final String TRUTH_BLOCK_HISTOGRAM_SHORT_NAME = \"tbh\";\n+    public static final String EVAL_BLOCK_HISTOGRAM_LONG_NAME = \"eval-block-histogram\";\n+    public static final String EVAL_BLOCK_HISTOGRAM_SHORT_NAME = \"ebh\";\n+    public static final String CONFIDENCE_CONCORDANCE_HISTOGRAM_LONG_NAME = \"confidence-concordance-histogram\";\n+    public static final String CONFIDENCE_CONCORDANCE_HISTOGRAM_SHORT_NAME = \"cch\";\n+\n+    static final String USAGE_ONE_LINE_SUMMARY = \"Evaluate GVCF reference block concordance of an input GVCF against a truth GVCF\";\n+    static final String USAGE_SUMMARY = \"This tool evaluates two GVCF files against each other and produces three histograms:\\n\" +\n+            \"Truth block histogram: Indicates the number of occurrence of reference blocks with a given confidence score and length in the truth GVCF\\n\" +\n+            \"Eval block histogram: Indicates the number of occurrence of reference blocks with a given confidence score and length in the eval GVCF\\n\" +\n+            \"Confidence concordance histogram: Reflects the confidence scores of bases in reference blocks in the truth and eval VCF, respectively. An entry of 10 at bin \\\"80,90\\\" means that 10 bases in the truth GVCF have a confidence score of 80 while those same bases have a score of 90 in the eval GVCF.\\n\" +\n+            \"In contrast to the Concordance tool, this tool considers all variants, regardless of passing or failing filters.\";\n+\n+    @Argument(doc = \"A histogram of block lengths and their associated confidence scores for the truth sample\",\n+            fullName = TRUTH_BLOCK_HISTOGRAM_LONG_NAME,\n+            shortName = TRUTH_BLOCK_HISTOGRAM_SHORT_NAME)\n+    protected File truthBlockHistogramFile;\n+    @Argument(doc = \"A histogram of block lengths and their associated confidence scores for the eval sample\",\n+            fullName = EVAL_BLOCK_HISTOGRAM_LONG_NAME,\n+            shortName = EVAL_BLOCK_HISTOGRAM_SHORT_NAME)\n+    protected File evalBlockHistogramFile;\n+    @Argument(doc = \"Reflects the confidence scores of bases in reference blocks in the truth and eval VCF, respectively. An entry of 10 at bin \\\"80,90\\\" means that 10 bases in the truth GVCF have a confidence score of 80 while those same bases have a score of 90 in the eval GVCF.\",\n+            fullName = CONFIDENCE_CONCORDANCE_HISTOGRAM_LONG_NAME,\n+            shortName = CONFIDENCE_CONCORDANCE_HISTOGRAM_SHORT_NAME)\n+    protected File confidenceConcordanceHistogramFile;\n+\n+    // TODO this should be a Histogram<Pair<Integer, Integer>>, however, the MetricsFile class cannot read\n+    // arbitrary types, therefore, it must be converted to a String, which is probably much slower\n+    private final Histogram<String> truthBlockHistogram = new Histogram<>();\n+    private final Histogram<String> evalBlockHistogram = new Histogram<>();\n+    private final Histogram<String> confidenceConcordanceHistogram = new Histogram<>();\n+\n+    private VariantContext currentTruthVariantContext = null;\n+    private VariantContext currentEvalVariantContext = null;\n+    private String currentContig = null;\n+\n+    @Override\n+    protected Predicate<VariantContext> makeTruthVariantFilter() {\n+        // Explicitly allow symbolic variants\n+        return VariantContext::isSymbolic;\n+    }\n+\n+    @Override\n+    protected Predicate<VariantContext> makeEvalVariantFilter() {\n+        // Explicitly allow symbolic variants\n+        return VariantContext::isSymbolic;\n+    }\n+\n+    private boolean isNonRef(VariantContext variantContext) {\n+        return variantContext.isSymbolic() && variantContext.getAlternateAllele(0).isNonRefAllele();\n+    }\n+\n+    private void evaluateEndOfContig() {\n+        if (currentTruthVariantContext != null && currentEvalVariantContext != null) {\n+            int blockStart = Math.max(currentTruthVariantContext.getStart(), currentEvalVariantContext.getStart());\n+            int blockEnd = Math.min(currentTruthVariantContext.getEnd(), currentEvalVariantContext.getEnd());\n+            int jointBlockLength = blockEnd - blockStart + 1;\n+            if (jointBlockLength > 0) {\n+                confidenceConcordanceHistogram.increment(new Pair<>(currentTruthVariantContext.getGenotype(0).getGQ(), currentEvalVariantContext.getGenotype(0).getGQ()).toString(), jointBlockLength);\n+            }\n+        }\n+\n+        currentTruthVariantContext = null;\n+        currentEvalVariantContext = null;\n+        currentContig = null;\n+    }\n+\n+    private void evaluateNewContig(TruthVersusEval truthVersusEval) {\n+        // If not beginning of file\n+        if (currentContig != null) {\n+            evaluateEndOfContig();\n+        }\n+\n+        currentContig = truthVersusEval.getTruthIfPresentElseEval().getContig();\n+    }\n+\n+    @Override\n+    protected void apply(TruthVersusEval truthVersusEval, ReadsContext readsContext, ReferenceContext refContext) {\n+        // New contig or beginning of file\n+        if (!truthVersusEval.getTruthIfPresentElseEval().getContig().equals(currentContig)) {\n+            evaluateNewContig(truthVersusEval);\n+        }\n+\n+        // Evaluate only when currently seeing two NON_REF blocks\n+        if (currentTruthVariantContext != null && currentEvalVariantContext != null) {\n+            int blockStart = Math.max(currentTruthVariantContext.getStart(), currentEvalVariantContext.getStart());\n+            int blockEnd = Math.min(currentTruthVariantContext.getEnd(), currentEvalVariantContext.getEnd());\n+            int jointBlockLength = blockEnd - blockStart + 1;\n+            // It is possible that jointBlockLength is negative if there is a gap in one file and the start of a new block in the other file.\n+            // Since there is no overlap though, we can just skip that case.\n+            if (jointBlockLength > 0) {\n+                confidenceConcordanceHistogram.increment(new Pair<>(currentTruthVariantContext.getGenotype(0).getGQ(), currentEvalVariantContext.getGenotype(0).getGQ()).toString(), blockEnd - blockStart + 1);\n+            }\n+\n+            int currentPosition = truthVersusEval.getTruthIfPresentElseEval().getStart();\n+            if (truthVersusEval.hasTruth() || currentPosition >= currentTruthVariantContext.getEnd()) {\n+                currentTruthVariantContext = null;\n+            }\n+            if (truthVersusEval.hasEval() || currentPosition >= currentEvalVariantContext.getEnd()) {\n+                currentEvalVariantContext = null;\n+            }\n+        }\n+\n+        // Truth\n+        if (truthVersusEval.hasTruth() && isNonRef(truthVersusEval.getTruth())) {\n+            currentTruthVariantContext = truthVersusEval.getTruth();\n+\n+            // The end is inclusive, thus the plus one when calculating the length\n+            int blockLength = truthVersusEval.getTruth().getEnd() - truthVersusEval.getTruth().getStart() + 1;\n+\n+            // TODO can a non_ref block ever have a number of genotypes != 1?\n+            if(truthVersusEval.getTruth().getGenotypes().size() != 1) {\n+                throw new IllegalStateException(String.format(\"The NON_REF block \\\"%s\\\" has more than one genotype, which is not supported.\", truthVersusEval.getTruth().toStringDecodeGenotypes()));\n+            }\n+            Genotype genotype = truthVersusEval.getTruth().getGenotype(0);\n+            int gq = genotype.getGQ();\n+            truthBlockHistogram.increment(new Pair<>(blockLength, gq).toString());\n+        }\n+\n+        // Eval\n+        if (truthVersusEval.hasEval() && isNonRef(truthVersusEval.getEval())) {\n+            currentEvalVariantContext = truthVersusEval.getEval();\n+\n+            // The end is inclusive, thus the plus one when calculating the length\n+            int blockLength = truthVersusEval.getEval().getEnd() - truthVersusEval.getEval().getStart() + 1;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "df904bc0857d2939326188ce3932e9f3601838fd"}, "originalPosition": 175}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzE1NzY0MQ==", "bodyText": "Seems fine to me, no reason to be duplicating storage", "url": "https://github.com/broadinstitute/gatk/pull/6802#discussion_r487157641", "createdAt": "2020-09-11T16:31:15Z", "author": {"login": "kachulis"}, "path": "src/test/java/org/broadinstitute/hellbender/tools/walkers/validation/ReferenceBlockConcordanceIntegrationTest.java", "diffHunk": "@@ -0,0 +1,436 @@\n+package org.broadinstitute.hellbender.tools.walkers.validation;\n+\n+import htsjdk.samtools.metrics.MetricsFile;\n+import htsjdk.samtools.util.Histogram;\n+import org.broadinstitute.hellbender.CommandLineProgramTest;\n+import org.broadinstitute.hellbender.engine.AbstractConcordanceWalker;\n+import org.testng.Assert;\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+import picard.sam.util.Pair;\n+\n+import java.io.File;\n+import java.io.FileReader;\n+import java.io.FileWriter;\n+import java.nio.file.Path;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+/**\n+ * Created by Michael Gatzen on 9/9/20.\n+ */\n+public class ReferenceBlockConcordanceIntegrationTest extends CommandLineProgramTest{\n+\n+    private static final String CONCORDANCE_TEST_DIR = toolsTestDir + \"concordance/\";\n+    private static final String HAPLOTYPECALLER_TEST_DIR = toolsTestDir + \"haplotypecaller/\";\n+\n+    @Test\n+    public void testIdentical() throws Exception {\n+        // TODO Is it fine to use a test file from a different tool or should I copy it?\n+        final File truthVcf = new File(HAPLOTYPECALLER_TEST_DIR, \"expected.testGVCFMode.gatk4.g.vcf\");\n+        final File evalVcf = new File(HAPLOTYPECALLER_TEST_DIR, \"expected.testGVCFMode.gatk4.g.vcf\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTYwMDAyNQ=="}, "originalCommit": {"oid": "3146dabf366156d1ad5743ce786f475a525804c4"}, "originalPosition": 34}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzE1ODI0NA==", "bodyText": "Use GVCFWriter instead or rolling you own vcf writer here.", "url": "https://github.com/broadinstitute/gatk/pull/6802#discussion_r487158244", "createdAt": "2020-09-11T16:32:23Z", "author": {"login": "kachulis"}, "path": "src/test/java/org/broadinstitute/hellbender/tools/walkers/validation/ReferenceBlockConcordanceIntegrationTest.java", "diffHunk": "@@ -0,0 +1,436 @@\n+package org.broadinstitute.hellbender.tools.walkers.validation;\n+\n+import htsjdk.samtools.metrics.MetricsFile;\n+import htsjdk.samtools.util.Histogram;\n+import org.broadinstitute.hellbender.CommandLineProgramTest;\n+import org.broadinstitute.hellbender.engine.AbstractConcordanceWalker;\n+import org.testng.Assert;\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+import picard.sam.util.Pair;\n+\n+import java.io.File;\n+import java.io.FileReader;\n+import java.io.FileWriter;\n+import java.nio.file.Path;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+/**\n+ * Created by Michael Gatzen on 9/9/20.\n+ */\n+public class ReferenceBlockConcordanceIntegrationTest extends CommandLineProgramTest{\n+\n+    private static final String CONCORDANCE_TEST_DIR = toolsTestDir + \"concordance/\";\n+    private static final String HAPLOTYPECALLER_TEST_DIR = toolsTestDir + \"haplotypecaller/\";\n+\n+    @Test\n+    public void testIdentical() throws Exception {\n+        // TODO Is it fine to use a test file from a different tool or should I copy it?\n+        final File truthVcf = new File(HAPLOTYPECALLER_TEST_DIR, \"expected.testGVCFMode.gatk4.g.vcf\");\n+        final File evalVcf = new File(HAPLOTYPECALLER_TEST_DIR, \"expected.testGVCFMode.gatk4.g.vcf\");\n+        final Path truthBlockHistogramFile = createTempPath(\"truth_block_histogram\", \".tsv\");\n+        final Path evalBlockHistogramFile = createTempPath(\"eval_block_histogram\", \".tsv\");\n+        final Path confidenceConcordanceHistogramFile = createTempPath(\"confidence_concordance_histogram\", \".tsv\");\n+\n+        final String[] args = {\n+                \"--\" + AbstractConcordanceWalker.EVAL_VARIANTS_LONG_NAME, evalVcf.toString(),\n+                \"--\" + AbstractConcordanceWalker.TRUTH_VARIANTS_LONG_NAME, truthVcf.toString(),\n+                \"--\" + ReferenceBlockConcordance.TRUTH_BLOCK_HISTOGRAM_LONG_NAME, truthBlockHistogramFile.toString(),\n+                \"--\" + ReferenceBlockConcordance.EVAL_BLOCK_HISTOGRAM_LONG_NAME, evalBlockHistogramFile.toString(),\n+                \"--\" + ReferenceBlockConcordance.CONFIDENCE_CONCORDANCE_HISTOGRAM_LONG_NAME, confidenceConcordanceHistogramFile.toString(),\n+        };\n+        runCommandLine(args);\n+\n+        MetricsFile<?, String> truthBlockMetrics = new MetricsFile<>();\n+        truthBlockMetrics.read(new FileReader(truthBlockHistogramFile.toFile()));\n+        MetricsFile<?, String> evalBlockMetrics = new MetricsFile<>();\n+        evalBlockMetrics.read(new FileReader(evalBlockHistogramFile.toFile()));\n+\n+        Assert.assertEquals(truthBlockMetrics.getNumHistograms(), 1);\n+        Assert.assertEquals(evalBlockMetrics.getNumHistograms(), 1);\n+\n+        Histogram<String> truthBlockHistogram = truthBlockMetrics.getHistogram();\n+        Histogram<String> evalBlockHistogram = evalBlockMetrics.getHistogram();\n+\n+        // Got this number by counting the <NON_REF> alt alleles in the test GVCF file\n+        Assert.assertEquals(truthBlockHistogram.getSumOfValues(), 1034);\n+        Assert.assertEquals(evalBlockHistogram.getSumOfValues(), 1034);\n+\n+        // Check block histograms both ways, in case one histogram has more entries than the other\n+        truthBlockHistogram.values().forEach(bin -> {\n+            Assert.assertTrue(evalBlockHistogram.containsKey(bin.getId()));\n+            Assert.assertEquals(bin.getValue(), evalBlockHistogram.get(bin.getId()).getValue());\n+        });\n+\n+        evalBlockHistogram.values().forEach(bin -> {\n+            Assert.assertTrue(truthBlockHistogram.containsKey(bin.getId()));\n+            Assert.assertEquals(bin.getValue(), truthBlockHistogram.get(bin.getId()).getValue());\n+        });\n+\n+        MetricsFile<?, String> confidenceConcordanceMetrics = new MetricsFile<>();\n+        confidenceConcordanceMetrics.read(new FileReader(confidenceConcordanceHistogramFile.toFile()));\n+        Assert.assertEquals(confidenceConcordanceMetrics.getNumHistograms(), 1);\n+        Histogram<String> confidenceConcordanceHistogram = confidenceConcordanceMetrics.getHistogram();\n+\n+        confidenceConcordanceHistogram.values().forEach(bin -> {\n+            String[] confidenceValues = bin.getId().split(\",\");\n+            Assert.assertEquals(confidenceValues[0], confidenceValues[1]);\n+        });\n+    }\n+\n+    private Pair<File, File> writeTestGVCFs(List<TestReferenceBlockConcordanceVariant> truthVariants, List<TestReferenceBlockConcordanceVariant> evalVariants) throws Exception {\n+        File truthFile = createTempFile(\"truth\", \".gvcf\");\n+        FileWriter writer = new FileWriter(truthFile);\n+        writer.write(\"##fileformat=VCFv4.2\\n\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "df904bc0857d2939326188ce3932e9f3601838fd"}, "originalPosition": 88}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzE2MTEwMw==", "bodyText": "This looks like something you could just use VariantContext for instead.", "url": "https://github.com/broadinstitute/gatk/pull/6802#discussion_r487161103", "createdAt": "2020-09-11T16:37:55Z", "author": {"login": "kachulis"}, "path": "src/test/java/org/broadinstitute/hellbender/tools/walkers/validation/ReferenceBlockConcordanceIntegrationTest.java", "diffHunk": "@@ -0,0 +1,436 @@\n+package org.broadinstitute.hellbender.tools.walkers.validation;\n+\n+import htsjdk.samtools.metrics.MetricsFile;\n+import htsjdk.samtools.util.Histogram;\n+import org.broadinstitute.hellbender.CommandLineProgramTest;\n+import org.broadinstitute.hellbender.engine.AbstractConcordanceWalker;\n+import org.testng.Assert;\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+import picard.sam.util.Pair;\n+\n+import java.io.File;\n+import java.io.FileReader;\n+import java.io.FileWriter;\n+import java.nio.file.Path;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+/**\n+ * Created by Michael Gatzen on 9/9/20.\n+ */\n+public class ReferenceBlockConcordanceIntegrationTest extends CommandLineProgramTest{\n+\n+    private static final String CONCORDANCE_TEST_DIR = toolsTestDir + \"concordance/\";\n+    private static final String HAPLOTYPECALLER_TEST_DIR = toolsTestDir + \"haplotypecaller/\";\n+\n+    @Test\n+    public void testIdentical() throws Exception {\n+        // TODO Is it fine to use a test file from a different tool or should I copy it?\n+        final File truthVcf = new File(HAPLOTYPECALLER_TEST_DIR, \"expected.testGVCFMode.gatk4.g.vcf\");\n+        final File evalVcf = new File(HAPLOTYPECALLER_TEST_DIR, \"expected.testGVCFMode.gatk4.g.vcf\");\n+        final Path truthBlockHistogramFile = createTempPath(\"truth_block_histogram\", \".tsv\");\n+        final Path evalBlockHistogramFile = createTempPath(\"eval_block_histogram\", \".tsv\");\n+        final Path confidenceConcordanceHistogramFile = createTempPath(\"confidence_concordance_histogram\", \".tsv\");\n+\n+        final String[] args = {\n+                \"--\" + AbstractConcordanceWalker.EVAL_VARIANTS_LONG_NAME, evalVcf.toString(),\n+                \"--\" + AbstractConcordanceWalker.TRUTH_VARIANTS_LONG_NAME, truthVcf.toString(),\n+                \"--\" + ReferenceBlockConcordance.TRUTH_BLOCK_HISTOGRAM_LONG_NAME, truthBlockHistogramFile.toString(),\n+                \"--\" + ReferenceBlockConcordance.EVAL_BLOCK_HISTOGRAM_LONG_NAME, evalBlockHistogramFile.toString(),\n+                \"--\" + ReferenceBlockConcordance.CONFIDENCE_CONCORDANCE_HISTOGRAM_LONG_NAME, confidenceConcordanceHistogramFile.toString(),\n+        };\n+        runCommandLine(args);\n+\n+        MetricsFile<?, String> truthBlockMetrics = new MetricsFile<>();\n+        truthBlockMetrics.read(new FileReader(truthBlockHistogramFile.toFile()));\n+        MetricsFile<?, String> evalBlockMetrics = new MetricsFile<>();\n+        evalBlockMetrics.read(new FileReader(evalBlockHistogramFile.toFile()));\n+\n+        Assert.assertEquals(truthBlockMetrics.getNumHistograms(), 1);\n+        Assert.assertEquals(evalBlockMetrics.getNumHistograms(), 1);\n+\n+        Histogram<String> truthBlockHistogram = truthBlockMetrics.getHistogram();\n+        Histogram<String> evalBlockHistogram = evalBlockMetrics.getHistogram();\n+\n+        // Got this number by counting the <NON_REF> alt alleles in the test GVCF file\n+        Assert.assertEquals(truthBlockHistogram.getSumOfValues(), 1034);\n+        Assert.assertEquals(evalBlockHistogram.getSumOfValues(), 1034);\n+\n+        // Check block histograms both ways, in case one histogram has more entries than the other\n+        truthBlockHistogram.values().forEach(bin -> {\n+            Assert.assertTrue(evalBlockHistogram.containsKey(bin.getId()));\n+            Assert.assertEquals(bin.getValue(), evalBlockHistogram.get(bin.getId()).getValue());\n+        });\n+\n+        evalBlockHistogram.values().forEach(bin -> {\n+            Assert.assertTrue(truthBlockHistogram.containsKey(bin.getId()));\n+            Assert.assertEquals(bin.getValue(), truthBlockHistogram.get(bin.getId()).getValue());\n+        });\n+\n+        MetricsFile<?, String> confidenceConcordanceMetrics = new MetricsFile<>();\n+        confidenceConcordanceMetrics.read(new FileReader(confidenceConcordanceHistogramFile.toFile()));\n+        Assert.assertEquals(confidenceConcordanceMetrics.getNumHistograms(), 1);\n+        Histogram<String> confidenceConcordanceHistogram = confidenceConcordanceMetrics.getHistogram();\n+\n+        confidenceConcordanceHistogram.values().forEach(bin -> {\n+            String[] confidenceValues = bin.getId().split(\",\");\n+            Assert.assertEquals(confidenceValues[0], confidenceValues[1]);\n+        });\n+    }\n+\n+    private Pair<File, File> writeTestGVCFs(List<TestReferenceBlockConcordanceVariant> truthVariants, List<TestReferenceBlockConcordanceVariant> evalVariants) throws Exception {\n+        File truthFile = createTempFile(\"truth\", \".gvcf\");\n+        FileWriter writer = new FileWriter(truthFile);\n+        writer.write(\"##fileformat=VCFv4.2\\n\");\n+        writer.write(\"##contig=<ID=test_contig,length=1000>\\n\");\n+        writer.write(\"#CHROM\\tPOS\\tID\\tREF\\tALT\\tQUAL\\tFILTER\\tINFO\\tFORMAT\\tTESTSAMPLE\\n\");\n+        for (TestReferenceBlockConcordanceVariant variant : truthVariants) {\n+            writer.write(String.format(\"test_contig\\t%s\\t.\\tA\\t%s\\t%s\\t.\\t%s\\tGT:GQ\\t%s:%s\\n\",\n+                    variant.start,\n+                    variant.getAltAllele(),\n+                    variant.getAltAllele().equals(\"<NON_REF>\") ? \".\" : \"1\",\n+                    variant.getAltAllele().equals(\"<NON_REF>\") ? String.format(\"END=%s\", variant.getStop()) : \".\",\n+                    variant.getAltAllele().equals(\"<NON_REF>\") ? \"0/0\" : \"0/1\",\n+                    variant.getConfidence()));\n+        }\n+        writer.close();\n+\n+        File evalFile = createTempFile(\"eval\", \".gvcf\");\n+        writer = new FileWriter(evalFile);\n+        writer.write(\"##fileformat=VCFv4.2\\n\");\n+        writer.write(\"##contig=<ID=test_contig,length=1000>\\n\");\n+        writer.write(\"#CHROM\\tPOS\\tID\\tREF\\tALT\\tQUAL\\tFILTER\\tINFO\\tFORMAT\\tTESTSAMPLE\\n\");\n+        for (TestReferenceBlockConcordanceVariant variant : evalVariants) {\n+            writer.write(String.format(\"test_contig\\t%s\\t.\\tA\\t%s\\t%s\\t.\\t%s\\tGT:GQ\\t%s:%s\\n\",\n+                    variant.start,\n+                    variant.getAltAllele(),\n+                    variant.getAltAllele().equals(\"<NON_REF>\") ? \".\" : \"1\",\n+                    variant.getAltAllele().equals(\"<NON_REF>\") ? String.format(\"END=%s\", variant.getStop()) : \".\",\n+                    variant.getAltAllele().equals(\"<NON_REF>\") ? \"0/0\" : \"0/1\",\n+                    variant.getConfidence()));\n+        }\n+        writer.close();\n+\n+        return new Pair<>(truthFile, evalFile);\n+    }\n+\n+    @DataProvider\n+    public Object[][] provideSyntheticGVCFs() {\n+        return new Object[][] {\n+                // No non_ref blocks\n+                {\n+                        // Truth variants\n+                        Arrays.asList(\n+                                new TestReferenceBlockConcordanceVariant(\"C\", 1, 1, 99)\n+                        ),\n+                        // Eval variants\n+                        Arrays.asList(\n+                                new TestReferenceBlockConcordanceVariant(\"<NON_REF>\", 1, 1, 99)\n+                        ),\n+                        // Truth block histogram\n+                        Stream.of(new Object[][] {\n+\n+                        }).collect(Collectors.toMap(data -> (String) data[0], data -> (Integer) data[1])),\n+                        // Eval block histogram\n+                        Stream.of(new Object[][] {\n+                                { \"1,99\", 1}\n+                        }).collect(Collectors.toMap(data -> (String) data[0], data -> (Integer) data[1])),\n+                        // Confidence concordance\n+                        Stream.of(new Object[][] {\n+\n+                        }).collect(Collectors.toMap(data -> (String) data[0], data -> (Integer) data[1])),\n+                },\n+                // Two non_ref blocks\n+                {\n+                        // Truth variants\n+                        Arrays.asList(\n+                                new TestReferenceBlockConcordanceVariant(\"<NON_REF>\", 1, 1, 99)\n+                        ),\n+                        // Eval variants\n+                        Arrays.asList(\n+                                new TestReferenceBlockConcordanceVariant(\"<NON_REF>\", 1, 1, 99)\n+                        ),\n+                        // Truth block histogram\n+                        Stream.of(new Object[][] {\n+                                { \"1,99\", 1}\n+                        }).collect(Collectors.toMap(data -> (String) data[0], data -> (Integer) data[1])),\n+                        // Eval block histogram\n+                        Stream.of(new Object[][] {\n+                                { \"1,99\", 1}\n+                        }).collect(Collectors.toMap(data -> (String) data[0], data -> (Integer) data[1])),\n+                        // Confidence concordance\n+                        Stream.of(new Object[][] {\n+                                { \"99,99\", 1}\n+                        }).collect(Collectors.toMap(data -> (String) data[0], data -> (Integer) data[1])),\n+                },\n+                // Start with gap then variant\n+                {\n+                        // Truth variants\n+                        Arrays.asList(\n+                                new TestReferenceBlockConcordanceVariant(\"<NON_REF>\", 1, 10, 99)\n+                        ),\n+                        // Eval variants\n+                        Arrays.asList(\n+                                new TestReferenceBlockConcordanceVariant(\"C\", 5, 5, 99),\n+                                new TestReferenceBlockConcordanceVariant(\"<NON_REF>\", 6, 10, 99)\n+                        ),\n+                        // Truth block histogram\n+                        Stream.of(new Object[][] {\n+                                { \"10,99\", 1}\n+                        }).collect(Collectors.toMap(data -> (String) data[0], data -> (Integer) data[1])),\n+                        // Eval block histogram\n+                        Stream.of(new Object[][] {\n+                                { \"5,99\", 1}\n+                        }).collect(Collectors.toMap(data -> (String) data[0], data -> (Integer) data[1])),\n+                        // Confidence concordance\n+                        Stream.of(new Object[][] {\n+                                { \"99,99\", 5}\n+                        }).collect(Collectors.toMap(data -> (String) data[0], data -> (Integer) data[1])),\n+                },\n+                // Start with gap then non_ref\n+                {\n+                        // Truth variants\n+                        Arrays.asList(\n+                                new TestReferenceBlockConcordanceVariant(\"<NON_REF>\", 1, 10, 99)\n+                        ),\n+                        // Eval variants\n+                        Arrays.asList(\n+                                new TestReferenceBlockConcordanceVariant(\"<NON_REF>\", 6, 10, 99)\n+                        ),\n+                        // Truth block histogram\n+                        Stream.of(new Object[][] {\n+                                { \"10,99\", 1}\n+                        }).collect(Collectors.toMap(data -> (String) data[0], data -> (Integer) data[1])),\n+                        // Eval block histogram\n+                        Stream.of(new Object[][] {\n+                                { \"5,99\", 1}\n+                        }).collect(Collectors.toMap(data -> (String) data[0], data -> (Integer) data[1])),\n+                        // Confidence concordance\n+                        Stream.of(new Object[][] {\n+                                { \"99,99\", 5}\n+                        }).collect(Collectors.toMap(data -> (String) data[0], data -> (Integer) data[1])),\n+                },\n+                // Start with single block\n+                {\n+                        // Truth variants\n+                        Arrays.asList(\n+                                new TestReferenceBlockConcordanceVariant(\"<NON_REF>\", 11, 20, 99)\n+                        ),\n+                        // Eval variants\n+                        Arrays.asList(\n+                                new TestReferenceBlockConcordanceVariant(\"<NON_REF>\", 3, 6, 98),\n+                                new TestReferenceBlockConcordanceVariant(\"<NON_REF>\", 11, 20, 99)\n+                        ),\n+                        // Truth block histogram\n+                        Stream.of(new Object[][] {\n+                                { \"10,99\", 1}\n+                        }).collect(Collectors.toMap(data -> (String) data[0], data -> (Integer) data[1])),\n+                        // Eval block histogram\n+                        Stream.of(new Object[][] {\n+                                { \"4,98\", 1},\n+                                { \"10,99\", 1}\n+                        }).collect(Collectors.toMap(data -> (String) data[0], data -> (Integer) data[1])),\n+                        // Confidence concordance\n+                        Stream.of(new Object[][] {\n+                                { \"99,99\", 10}\n+                        }).collect(Collectors.toMap(data -> (String) data[0], data -> (Integer) data[1])),\n+                },\n+                // No overlap at all\n+                {\n+                        // Truth variants\n+                        Arrays.asList(\n+                                new TestReferenceBlockConcordanceVariant(\"<NON_REF>\", 11, 20, 99)\n+                        ),\n+                        // Eval variants\n+                        Arrays.asList(\n+                                new TestReferenceBlockConcordanceVariant(\"<NON_REF>\", 3, 6, 98)\n+                        ),\n+                        // Truth block histogram\n+                        Stream.of(new Object[][] {\n+                                { \"10,99\", 1}\n+                        }).collect(Collectors.toMap(data -> (String) data[0], data -> (Integer) data[1])),\n+                        // Eval block histogram\n+                        Stream.of(new Object[][] {\n+                                { \"4,98\", 1}\n+                        }).collect(Collectors.toMap(data -> (String) data[0], data -> (Integer) data[1])),\n+                        // Confidence concordance\n+                        Stream.of(new Object[][] {\n+                        }).collect(Collectors.toMap(data -> (String) data[0], data -> (Integer) data[1])),\n+                },\n+                // End with var\n+                {\n+                        // Truth variants\n+                        Arrays.asList(\n+                                new TestReferenceBlockConcordanceVariant(\"<NON_REF>\", 1, 10, 99)\n+                        ),\n+                        // Eval variants\n+                        Arrays.asList(\n+                                new TestReferenceBlockConcordanceVariant(\"<NON_REF>\", 1, 9, 99),\n+                                new TestReferenceBlockConcordanceVariant(\"C\", 10, 10, 99)\n+                        ),\n+                        // Truth block histogram\n+                        Stream.of(new Object[][] {\n+                                { \"10,99\", 1}\n+                        }).collect(Collectors.toMap(data -> (String) data[0], data -> (Integer) data[1])),\n+                        // Eval block histogram\n+                        Stream.of(new Object[][] {\n+                                { \"9,99\", 1}\n+                        }).collect(Collectors.toMap(data -> (String) data[0], data -> (Integer) data[1])),\n+                        // Confidence concordance\n+                        Stream.of(new Object[][] {\n+                                { \"99,99\", 9}\n+                        }).collect(Collectors.toMap(data -> (String) data[0], data -> (Integer) data[1])),\n+                },\n+                // End with var then gap\n+                {\n+                        // Truth variants\n+                        Arrays.asList(\n+                                new TestReferenceBlockConcordanceVariant(\"<NON_REF>\", 1, 10, 99)\n+                        ),\n+                        // Eval variants\n+                        Arrays.asList(\n+                                new TestReferenceBlockConcordanceVariant(\"<NON_REF>\", 1, 7, 99),\n+                                new TestReferenceBlockConcordanceVariant(\"C\", 8, 8, 99)\n+                        ),\n+                        // Truth block histogram\n+                        Stream.of(new Object[][] {\n+                                { \"10,99\", 1}\n+                        }).collect(Collectors.toMap(data -> (String) data[0], data -> (Integer) data[1])),\n+                        // Eval block histogram\n+                        Stream.of(new Object[][] {\n+                                { \"7,99\", 1}\n+                        }).collect(Collectors.toMap(data -> (String) data[0], data -> (Integer) data[1])),\n+                        // Confidence concordance\n+                        Stream.of(new Object[][] {\n+                                { \"99,99\", 7}\n+                        }).collect(Collectors.toMap(data -> (String) data[0], data -> (Integer) data[1])),\n+                },\n+                // End with gap then var\n+                {\n+                        // Truth variants\n+                        Arrays.asList(\n+                                new TestReferenceBlockConcordanceVariant(\"<NON_REF>\", 1, 10, 99)\n+                        ),\n+                        // Eval variants\n+                        Arrays.asList(\n+                                new TestReferenceBlockConcordanceVariant(\"<NON_REF>\", 1, 7, 99),\n+                                new TestReferenceBlockConcordanceVariant(\"C\", 10, 10, 99)\n+                        ),\n+                        // Truth block histogram\n+                        Stream.of(new Object[][] {\n+                                { \"10,99\", 1}\n+                        }).collect(Collectors.toMap(data -> (String) data[0], data -> (Integer) data[1])),\n+                        // Eval block histogram\n+                        Stream.of(new Object[][] {\n+                                { \"7,99\", 1}\n+                        }).collect(Collectors.toMap(data -> (String) data[0], data -> (Integer) data[1])),\n+                        // Confidence concordance\n+                        Stream.of(new Object[][] {\n+                                { \"99,99\", 7}\n+                        }).collect(Collectors.toMap(data -> (String) data[0], data -> (Integer) data[1])),\n+                },\n+        };\n+    }\n+\n+    @Test(dataProvider = \"provideSyntheticGVCFs\")\n+    public void testSyntheticGVCFs(final List<TestReferenceBlockConcordanceVariant> truthVariants, final List<TestReferenceBlockConcordanceVariant> evalVariants, final Map<String, Integer> expectedTruthBlockHistogram, final Map<String, Integer> expectedEvalBlockHistogram, final Map<String, Integer> expectedConfidenceConcordance) throws Exception {\n+        Pair<File, File> inputFiles = writeTestGVCFs(truthVariants, evalVariants);\n+\n+        final Path truthBlockHistogramFile = createTempPath(\"truth_block_histogram\", \".tsv\");\n+        final Path evalBlockHistogramFile = createTempPath(\"eval_block_histogram\", \".tsv\");\n+        final Path confidenceConcordanceHistogramFile = createTempPath(\"confidence_concordance_histogram\", \".tsv\");\n+\n+        final String[] args = {\n+                \"--\" + AbstractConcordanceWalker.TRUTH_VARIANTS_LONG_NAME, inputFiles.getLeft().toString(),\n+                \"--\" + AbstractConcordanceWalker.EVAL_VARIANTS_LONG_NAME, inputFiles.getRight().toString(),\n+                \"--\" + ReferenceBlockConcordance.TRUTH_BLOCK_HISTOGRAM_LONG_NAME, truthBlockHistogramFile.toString(),\n+                \"--\" + ReferenceBlockConcordance.EVAL_BLOCK_HISTOGRAM_LONG_NAME, evalBlockHistogramFile.toString(),\n+                \"--\" + ReferenceBlockConcordance.CONFIDENCE_CONCORDANCE_HISTOGRAM_LONG_NAME, confidenceConcordanceHistogramFile.toString(),\n+        };\n+        runCommandLine(args);\n+\n+        MetricsFile<?, String> truthBlockMetrics = new MetricsFile<>();\n+        truthBlockMetrics.read(new FileReader(truthBlockHistogramFile.toFile()));\n+        if (truthBlockMetrics.getNumHistograms() > 0) {\n+            Assert.assertEquals(truthBlockMetrics.getNumHistograms(), 1);\n+            Histogram<String> truthBlockHistogram = truthBlockMetrics.getHistogram();\n+            // Check value and remove entry from expected histogram...\n+            truthBlockHistogram.values().forEach(bin -> {\n+                Assert.assertTrue(expectedTruthBlockHistogram.containsKey(bin.getId()));\n+                Assert.assertEquals(bin.getValue(), (double) expectedTruthBlockHistogram.get(bin.getId()));\n+                expectedTruthBlockHistogram.remove(bin.getId());\n+            });\n+            // ... and make sure it is empty and all values have been visited\n+        }\n+        Assert.assertEquals(expectedTruthBlockHistogram.size(), 0);\n+\n+        MetricsFile<?, String> evalBlockMetrics = new MetricsFile<>();\n+        evalBlockMetrics.read(new FileReader(evalBlockHistogramFile.toFile()));\n+        if (evalBlockMetrics.getNumHistograms() > 0) {\n+            Assert.assertEquals(evalBlockMetrics.getNumHistograms(), 1);\n+            Histogram<String> evalBlockHistogram = evalBlockMetrics.getHistogram();\n+            // Check value and remove entry from expected histogram...\n+            evalBlockHistogram.values().forEach(bin -> {\n+                Assert.assertTrue(expectedEvalBlockHistogram.containsKey(bin.getId()));\n+                Assert.assertEquals(bin.getValue(), (double) expectedEvalBlockHistogram.get(bin.getId()));\n+                expectedEvalBlockHistogram.remove(bin.getId());\n+            });\n+            // ... and make sure it is empty and all values have been visited\n+        }\n+        Assert.assertEquals(expectedEvalBlockHistogram.size(), 0);\n+\n+        MetricsFile<?, String> confidenceConcordanceMetrics = new MetricsFile<>();\n+        confidenceConcordanceMetrics.read(new FileReader(confidenceConcordanceHistogramFile.toFile()));\n+        if (confidenceConcordanceMetrics.getNumHistograms() > 0) {\n+            Assert.assertEquals(confidenceConcordanceMetrics.getNumHistograms(), 1);\n+            Histogram<String> confidenceConcordanceHistogram = confidenceConcordanceMetrics.getHistogram();\n+            // Check value and remove entry from expected histogram...\n+            confidenceConcordanceHistogram.values().forEach(bin -> {\n+                Assert.assertTrue(expectedConfidenceConcordance.containsKey(bin.getId()));\n+                Assert.assertEquals(bin.getValue(), (double) expectedConfidenceConcordance.get(bin.getId()));\n+                expectedConfidenceConcordance.remove(bin.getId());\n+            });\n+            // ... and make sure it is empty and all values have been visited\n+        }\n+        Assert.assertEquals(expectedConfidenceConcordance.size(), 0);\n+    }\n+\n+    @Test\n+    public void testDoesNotCrashWithNO_VARIATIONAlleles() {\n+        final File evalVcf = new File(CONCORDANCE_TEST_DIR, \"noVariationAlleles.vcf\");\n+        final File truthVcf = new File(CONCORDANCE_TEST_DIR, \"noVariationAlleles.vcf\");\n+\n+        final String[] args = {\n+                \"--\" + AbstractConcordanceWalker.EVAL_VARIANTS_LONG_NAME, evalVcf.toString(),\n+                \"--\" + AbstractConcordanceWalker.TRUTH_VARIANTS_LONG_NAME, truthVcf.toString(),\n+                \"--\" + ReferenceBlockConcordance.TRUTH_BLOCK_HISTOGRAM_LONG_NAME, \"/dev/null\",\n+                \"--\" + ReferenceBlockConcordance.EVAL_BLOCK_HISTOGRAM_LONG_NAME, \"/dev/null\",\n+                \"--\" + ReferenceBlockConcordance.CONFIDENCE_CONCORDANCE_HISTOGRAM_LONG_NAME, \"/dev/null\",\n+        };\n+\n+        runCommandLine(args);\n+    }\n+\n+    static class TestReferenceBlockConcordanceVariant {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "df904bc0857d2939326188ce3932e9f3601838fd"}, "originalPosition": 418}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzE2MTQ5Mg==", "bodyText": "Aren't these just VariantContexts?  Is there are reason you need your own class for these?", "url": "https://github.com/broadinstitute/gatk/pull/6802#discussion_r487161492", "createdAt": "2020-09-11T16:38:34Z", "author": {"login": "kachulis"}, "path": "src/test/java/org/broadinstitute/hellbender/tools/walkers/validation/ReferenceBlockConcordanceIntegrationTest.java", "diffHunk": "@@ -0,0 +1,436 @@\n+package org.broadinstitute.hellbender.tools.walkers.validation;\n+\n+import htsjdk.samtools.metrics.MetricsFile;\n+import htsjdk.samtools.util.Histogram;\n+import org.broadinstitute.hellbender.CommandLineProgramTest;\n+import org.broadinstitute.hellbender.engine.AbstractConcordanceWalker;\n+import org.testng.Assert;\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+import picard.sam.util.Pair;\n+\n+import java.io.File;\n+import java.io.FileReader;\n+import java.io.FileWriter;\n+import java.nio.file.Path;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+/**\n+ * Created by Michael Gatzen on 9/9/20.\n+ */\n+public class ReferenceBlockConcordanceIntegrationTest extends CommandLineProgramTest{\n+\n+    private static final String CONCORDANCE_TEST_DIR = toolsTestDir + \"concordance/\";\n+    private static final String HAPLOTYPECALLER_TEST_DIR = toolsTestDir + \"haplotypecaller/\";\n+\n+    @Test\n+    public void testIdentical() throws Exception {\n+        // TODO Is it fine to use a test file from a different tool or should I copy it?\n+        final File truthVcf = new File(HAPLOTYPECALLER_TEST_DIR, \"expected.testGVCFMode.gatk4.g.vcf\");\n+        final File evalVcf = new File(HAPLOTYPECALLER_TEST_DIR, \"expected.testGVCFMode.gatk4.g.vcf\");\n+        final Path truthBlockHistogramFile = createTempPath(\"truth_block_histogram\", \".tsv\");\n+        final Path evalBlockHistogramFile = createTempPath(\"eval_block_histogram\", \".tsv\");\n+        final Path confidenceConcordanceHistogramFile = createTempPath(\"confidence_concordance_histogram\", \".tsv\");\n+\n+        final String[] args = {\n+                \"--\" + AbstractConcordanceWalker.EVAL_VARIANTS_LONG_NAME, evalVcf.toString(),\n+                \"--\" + AbstractConcordanceWalker.TRUTH_VARIANTS_LONG_NAME, truthVcf.toString(),\n+                \"--\" + ReferenceBlockConcordance.TRUTH_BLOCK_HISTOGRAM_LONG_NAME, truthBlockHistogramFile.toString(),\n+                \"--\" + ReferenceBlockConcordance.EVAL_BLOCK_HISTOGRAM_LONG_NAME, evalBlockHistogramFile.toString(),\n+                \"--\" + ReferenceBlockConcordance.CONFIDENCE_CONCORDANCE_HISTOGRAM_LONG_NAME, confidenceConcordanceHistogramFile.toString(),\n+        };\n+        runCommandLine(args);\n+\n+        MetricsFile<?, String> truthBlockMetrics = new MetricsFile<>();\n+        truthBlockMetrics.read(new FileReader(truthBlockHistogramFile.toFile()));\n+        MetricsFile<?, String> evalBlockMetrics = new MetricsFile<>();\n+        evalBlockMetrics.read(new FileReader(evalBlockHistogramFile.toFile()));\n+\n+        Assert.assertEquals(truthBlockMetrics.getNumHistograms(), 1);\n+        Assert.assertEquals(evalBlockMetrics.getNumHistograms(), 1);\n+\n+        Histogram<String> truthBlockHistogram = truthBlockMetrics.getHistogram();\n+        Histogram<String> evalBlockHistogram = evalBlockMetrics.getHistogram();\n+\n+        // Got this number by counting the <NON_REF> alt alleles in the test GVCF file\n+        Assert.assertEquals(truthBlockHistogram.getSumOfValues(), 1034);\n+        Assert.assertEquals(evalBlockHistogram.getSumOfValues(), 1034);\n+\n+        // Check block histograms both ways, in case one histogram has more entries than the other\n+        truthBlockHistogram.values().forEach(bin -> {\n+            Assert.assertTrue(evalBlockHistogram.containsKey(bin.getId()));\n+            Assert.assertEquals(bin.getValue(), evalBlockHistogram.get(bin.getId()).getValue());\n+        });\n+\n+        evalBlockHistogram.values().forEach(bin -> {\n+            Assert.assertTrue(truthBlockHistogram.containsKey(bin.getId()));\n+            Assert.assertEquals(bin.getValue(), truthBlockHistogram.get(bin.getId()).getValue());\n+        });\n+\n+        MetricsFile<?, String> confidenceConcordanceMetrics = new MetricsFile<>();\n+        confidenceConcordanceMetrics.read(new FileReader(confidenceConcordanceHistogramFile.toFile()));\n+        Assert.assertEquals(confidenceConcordanceMetrics.getNumHistograms(), 1);\n+        Histogram<String> confidenceConcordanceHistogram = confidenceConcordanceMetrics.getHistogram();\n+\n+        confidenceConcordanceHistogram.values().forEach(bin -> {\n+            String[] confidenceValues = bin.getId().split(\",\");\n+            Assert.assertEquals(confidenceValues[0], confidenceValues[1]);\n+        });\n+    }\n+\n+    private Pair<File, File> writeTestGVCFs(List<TestReferenceBlockConcordanceVariant> truthVariants, List<TestReferenceBlockConcordanceVariant> evalVariants) throws Exception {\n+        File truthFile = createTempFile(\"truth\", \".gvcf\");\n+        FileWriter writer = new FileWriter(truthFile);\n+        writer.write(\"##fileformat=VCFv4.2\\n\");\n+        writer.write(\"##contig=<ID=test_contig,length=1000>\\n\");\n+        writer.write(\"#CHROM\\tPOS\\tID\\tREF\\tALT\\tQUAL\\tFILTER\\tINFO\\tFORMAT\\tTESTSAMPLE\\n\");\n+        for (TestReferenceBlockConcordanceVariant variant : truthVariants) {\n+            writer.write(String.format(\"test_contig\\t%s\\t.\\tA\\t%s\\t%s\\t.\\t%s\\tGT:GQ\\t%s:%s\\n\",\n+                    variant.start,\n+                    variant.getAltAllele(),\n+                    variant.getAltAllele().equals(\"<NON_REF>\") ? \".\" : \"1\",\n+                    variant.getAltAllele().equals(\"<NON_REF>\") ? String.format(\"END=%s\", variant.getStop()) : \".\",\n+                    variant.getAltAllele().equals(\"<NON_REF>\") ? \"0/0\" : \"0/1\",\n+                    variant.getConfidence()));\n+        }\n+        writer.close();\n+\n+        File evalFile = createTempFile(\"eval\", \".gvcf\");\n+        writer = new FileWriter(evalFile);\n+        writer.write(\"##fileformat=VCFv4.2\\n\");\n+        writer.write(\"##contig=<ID=test_contig,length=1000>\\n\");\n+        writer.write(\"#CHROM\\tPOS\\tID\\tREF\\tALT\\tQUAL\\tFILTER\\tINFO\\tFORMAT\\tTESTSAMPLE\\n\");\n+        for (TestReferenceBlockConcordanceVariant variant : evalVariants) {\n+            writer.write(String.format(\"test_contig\\t%s\\t.\\tA\\t%s\\t%s\\t.\\t%s\\tGT:GQ\\t%s:%s\\n\",\n+                    variant.start,\n+                    variant.getAltAllele(),\n+                    variant.getAltAllele().equals(\"<NON_REF>\") ? \".\" : \"1\",\n+                    variant.getAltAllele().equals(\"<NON_REF>\") ? String.format(\"END=%s\", variant.getStop()) : \".\",\n+                    variant.getAltAllele().equals(\"<NON_REF>\") ? \"0/0\" : \"0/1\",\n+                    variant.getConfidence()));\n+        }\n+        writer.close();\n+\n+        return new Pair<>(truthFile, evalFile);\n+    }\n+\n+    @DataProvider\n+    public Object[][] provideSyntheticGVCFs() {\n+        return new Object[][] {\n+                // No non_ref blocks\n+                {\n+                        // Truth variants\n+                        Arrays.asList(\n+                                new TestReferenceBlockConcordanceVariant(\"C\", 1, 1, 99)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "df904bc0857d2939326188ce3932e9f3601838fd"}, "originalPosition": 128}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzE4MDA5Mw==", "bodyText": "Histogram has an equals method you can use instead", "url": "https://github.com/broadinstitute/gatk/pull/6802#discussion_r487180093", "createdAt": "2020-09-11T17:14:09Z", "author": {"login": "kachulis"}, "path": "src/test/java/org/broadinstitute/hellbender/tools/walkers/validation/ReferenceBlockConcordanceIntegrationTest.java", "diffHunk": "@@ -0,0 +1,436 @@\n+package org.broadinstitute.hellbender.tools.walkers.validation;\n+\n+import htsjdk.samtools.metrics.MetricsFile;\n+import htsjdk.samtools.util.Histogram;\n+import org.broadinstitute.hellbender.CommandLineProgramTest;\n+import org.broadinstitute.hellbender.engine.AbstractConcordanceWalker;\n+import org.testng.Assert;\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+import picard.sam.util.Pair;\n+\n+import java.io.File;\n+import java.io.FileReader;\n+import java.io.FileWriter;\n+import java.nio.file.Path;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+/**\n+ * Created by Michael Gatzen on 9/9/20.\n+ */\n+public class ReferenceBlockConcordanceIntegrationTest extends CommandLineProgramTest{\n+\n+    private static final String CONCORDANCE_TEST_DIR = toolsTestDir + \"concordance/\";\n+    private static final String HAPLOTYPECALLER_TEST_DIR = toolsTestDir + \"haplotypecaller/\";\n+\n+    @Test\n+    public void testIdentical() throws Exception {\n+        // TODO Is it fine to use a test file from a different tool or should I copy it?\n+        final File truthVcf = new File(HAPLOTYPECALLER_TEST_DIR, \"expected.testGVCFMode.gatk4.g.vcf\");\n+        final File evalVcf = new File(HAPLOTYPECALLER_TEST_DIR, \"expected.testGVCFMode.gatk4.g.vcf\");\n+        final Path truthBlockHistogramFile = createTempPath(\"truth_block_histogram\", \".tsv\");\n+        final Path evalBlockHistogramFile = createTempPath(\"eval_block_histogram\", \".tsv\");\n+        final Path confidenceConcordanceHistogramFile = createTempPath(\"confidence_concordance_histogram\", \".tsv\");\n+\n+        final String[] args = {\n+                \"--\" + AbstractConcordanceWalker.EVAL_VARIANTS_LONG_NAME, evalVcf.toString(),\n+                \"--\" + AbstractConcordanceWalker.TRUTH_VARIANTS_LONG_NAME, truthVcf.toString(),\n+                \"--\" + ReferenceBlockConcordance.TRUTH_BLOCK_HISTOGRAM_LONG_NAME, truthBlockHistogramFile.toString(),\n+                \"--\" + ReferenceBlockConcordance.EVAL_BLOCK_HISTOGRAM_LONG_NAME, evalBlockHistogramFile.toString(),\n+                \"--\" + ReferenceBlockConcordance.CONFIDENCE_CONCORDANCE_HISTOGRAM_LONG_NAME, confidenceConcordanceHistogramFile.toString(),\n+        };\n+        runCommandLine(args);\n+\n+        MetricsFile<?, String> truthBlockMetrics = new MetricsFile<>();\n+        truthBlockMetrics.read(new FileReader(truthBlockHistogramFile.toFile()));\n+        MetricsFile<?, String> evalBlockMetrics = new MetricsFile<>();\n+        evalBlockMetrics.read(new FileReader(evalBlockHistogramFile.toFile()));\n+\n+        Assert.assertEquals(truthBlockMetrics.getNumHistograms(), 1);\n+        Assert.assertEquals(evalBlockMetrics.getNumHistograms(), 1);\n+\n+        Histogram<String> truthBlockHistogram = truthBlockMetrics.getHistogram();\n+        Histogram<String> evalBlockHistogram = evalBlockMetrics.getHistogram();\n+\n+        // Got this number by counting the <NON_REF> alt alleles in the test GVCF file\n+        Assert.assertEquals(truthBlockHistogram.getSumOfValues(), 1034);\n+        Assert.assertEquals(evalBlockHistogram.getSumOfValues(), 1034);\n+\n+        // Check block histograms both ways, in case one histogram has more entries than the other\n+        truthBlockHistogram.values().forEach(bin -> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "df904bc0857d2939326188ce3932e9f3601838fd"}, "originalPosition": 64}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzE4MzYwMw==", "bodyText": "if you make the expected histograms actual Histogram objects you can just use the Histogram::equals method.", "url": "https://github.com/broadinstitute/gatk/pull/6802#discussion_r487183603", "createdAt": "2020-09-11T17:20:52Z", "author": {"login": "kachulis"}, "path": "src/test/java/org/broadinstitute/hellbender/tools/walkers/validation/ReferenceBlockConcordanceIntegrationTest.java", "diffHunk": "@@ -0,0 +1,436 @@\n+package org.broadinstitute.hellbender.tools.walkers.validation;\n+\n+import htsjdk.samtools.metrics.MetricsFile;\n+import htsjdk.samtools.util.Histogram;\n+import org.broadinstitute.hellbender.CommandLineProgramTest;\n+import org.broadinstitute.hellbender.engine.AbstractConcordanceWalker;\n+import org.testng.Assert;\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+import picard.sam.util.Pair;\n+\n+import java.io.File;\n+import java.io.FileReader;\n+import java.io.FileWriter;\n+import java.nio.file.Path;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+/**\n+ * Created by Michael Gatzen on 9/9/20.\n+ */\n+public class ReferenceBlockConcordanceIntegrationTest extends CommandLineProgramTest{\n+\n+    private static final String CONCORDANCE_TEST_DIR = toolsTestDir + \"concordance/\";\n+    private static final String HAPLOTYPECALLER_TEST_DIR = toolsTestDir + \"haplotypecaller/\";\n+\n+    @Test\n+    public void testIdentical() throws Exception {\n+        // TODO Is it fine to use a test file from a different tool or should I copy it?\n+        final File truthVcf = new File(HAPLOTYPECALLER_TEST_DIR, \"expected.testGVCFMode.gatk4.g.vcf\");\n+        final File evalVcf = new File(HAPLOTYPECALLER_TEST_DIR, \"expected.testGVCFMode.gatk4.g.vcf\");\n+        final Path truthBlockHistogramFile = createTempPath(\"truth_block_histogram\", \".tsv\");\n+        final Path evalBlockHistogramFile = createTempPath(\"eval_block_histogram\", \".tsv\");\n+        final Path confidenceConcordanceHistogramFile = createTempPath(\"confidence_concordance_histogram\", \".tsv\");\n+\n+        final String[] args = {\n+                \"--\" + AbstractConcordanceWalker.EVAL_VARIANTS_LONG_NAME, evalVcf.toString(),\n+                \"--\" + AbstractConcordanceWalker.TRUTH_VARIANTS_LONG_NAME, truthVcf.toString(),\n+                \"--\" + ReferenceBlockConcordance.TRUTH_BLOCK_HISTOGRAM_LONG_NAME, truthBlockHistogramFile.toString(),\n+                \"--\" + ReferenceBlockConcordance.EVAL_BLOCK_HISTOGRAM_LONG_NAME, evalBlockHistogramFile.toString(),\n+                \"--\" + ReferenceBlockConcordance.CONFIDENCE_CONCORDANCE_HISTOGRAM_LONG_NAME, confidenceConcordanceHistogramFile.toString(),\n+        };\n+        runCommandLine(args);\n+\n+        MetricsFile<?, String> truthBlockMetrics = new MetricsFile<>();\n+        truthBlockMetrics.read(new FileReader(truthBlockHistogramFile.toFile()));\n+        MetricsFile<?, String> evalBlockMetrics = new MetricsFile<>();\n+        evalBlockMetrics.read(new FileReader(evalBlockHistogramFile.toFile()));\n+\n+        Assert.assertEquals(truthBlockMetrics.getNumHistograms(), 1);\n+        Assert.assertEquals(evalBlockMetrics.getNumHistograms(), 1);\n+\n+        Histogram<String> truthBlockHistogram = truthBlockMetrics.getHistogram();\n+        Histogram<String> evalBlockHistogram = evalBlockMetrics.getHistogram();\n+\n+        // Got this number by counting the <NON_REF> alt alleles in the test GVCF file\n+        Assert.assertEquals(truthBlockHistogram.getSumOfValues(), 1034);\n+        Assert.assertEquals(evalBlockHistogram.getSumOfValues(), 1034);\n+\n+        // Check block histograms both ways, in case one histogram has more entries than the other\n+        truthBlockHistogram.values().forEach(bin -> {\n+            Assert.assertTrue(evalBlockHistogram.containsKey(bin.getId()));\n+            Assert.assertEquals(bin.getValue(), evalBlockHistogram.get(bin.getId()).getValue());\n+        });\n+\n+        evalBlockHistogram.values().forEach(bin -> {\n+            Assert.assertTrue(truthBlockHistogram.containsKey(bin.getId()));\n+            Assert.assertEquals(bin.getValue(), truthBlockHistogram.get(bin.getId()).getValue());\n+        });\n+\n+        MetricsFile<?, String> confidenceConcordanceMetrics = new MetricsFile<>();\n+        confidenceConcordanceMetrics.read(new FileReader(confidenceConcordanceHistogramFile.toFile()));\n+        Assert.assertEquals(confidenceConcordanceMetrics.getNumHistograms(), 1);\n+        Histogram<String> confidenceConcordanceHistogram = confidenceConcordanceMetrics.getHistogram();\n+\n+        confidenceConcordanceHistogram.values().forEach(bin -> {\n+            String[] confidenceValues = bin.getId().split(\",\");\n+            Assert.assertEquals(confidenceValues[0], confidenceValues[1]);\n+        });\n+    }\n+\n+    private Pair<File, File> writeTestGVCFs(List<TestReferenceBlockConcordanceVariant> truthVariants, List<TestReferenceBlockConcordanceVariant> evalVariants) throws Exception {\n+        File truthFile = createTempFile(\"truth\", \".gvcf\");\n+        FileWriter writer = new FileWriter(truthFile);\n+        writer.write(\"##fileformat=VCFv4.2\\n\");\n+        writer.write(\"##contig=<ID=test_contig,length=1000>\\n\");\n+        writer.write(\"#CHROM\\tPOS\\tID\\tREF\\tALT\\tQUAL\\tFILTER\\tINFO\\tFORMAT\\tTESTSAMPLE\\n\");\n+        for (TestReferenceBlockConcordanceVariant variant : truthVariants) {\n+            writer.write(String.format(\"test_contig\\t%s\\t.\\tA\\t%s\\t%s\\t.\\t%s\\tGT:GQ\\t%s:%s\\n\",\n+                    variant.start,\n+                    variant.getAltAllele(),\n+                    variant.getAltAllele().equals(\"<NON_REF>\") ? \".\" : \"1\",\n+                    variant.getAltAllele().equals(\"<NON_REF>\") ? String.format(\"END=%s\", variant.getStop()) : \".\",\n+                    variant.getAltAllele().equals(\"<NON_REF>\") ? \"0/0\" : \"0/1\",\n+                    variant.getConfidence()));\n+        }\n+        writer.close();\n+\n+        File evalFile = createTempFile(\"eval\", \".gvcf\");\n+        writer = new FileWriter(evalFile);\n+        writer.write(\"##fileformat=VCFv4.2\\n\");\n+        writer.write(\"##contig=<ID=test_contig,length=1000>\\n\");\n+        writer.write(\"#CHROM\\tPOS\\tID\\tREF\\tALT\\tQUAL\\tFILTER\\tINFO\\tFORMAT\\tTESTSAMPLE\\n\");\n+        for (TestReferenceBlockConcordanceVariant variant : evalVariants) {\n+            writer.write(String.format(\"test_contig\\t%s\\t.\\tA\\t%s\\t%s\\t.\\t%s\\tGT:GQ\\t%s:%s\\n\",\n+                    variant.start,\n+                    variant.getAltAllele(),\n+                    variant.getAltAllele().equals(\"<NON_REF>\") ? \".\" : \"1\",\n+                    variant.getAltAllele().equals(\"<NON_REF>\") ? String.format(\"END=%s\", variant.getStop()) : \".\",\n+                    variant.getAltAllele().equals(\"<NON_REF>\") ? \"0/0\" : \"0/1\",\n+                    variant.getConfidence()));\n+        }\n+        writer.close();\n+\n+        return new Pair<>(truthFile, evalFile);\n+    }\n+\n+    @DataProvider\n+    public Object[][] provideSyntheticGVCFs() {\n+        return new Object[][] {\n+                // No non_ref blocks\n+                {\n+                        // Truth variants\n+                        Arrays.asList(\n+                                new TestReferenceBlockConcordanceVariant(\"C\", 1, 1, 99)\n+                        ),\n+                        // Eval variants\n+                        Arrays.asList(\n+                                new TestReferenceBlockConcordanceVariant(\"<NON_REF>\", 1, 1, 99)\n+                        ),\n+                        // Truth block histogram\n+                        Stream.of(new Object[][] {\n+\n+                        }).collect(Collectors.toMap(data -> (String) data[0], data -> (Integer) data[1])),\n+                        // Eval block histogram\n+                        Stream.of(new Object[][] {\n+                                { \"1,99\", 1}\n+                        }).collect(Collectors.toMap(data -> (String) data[0], data -> (Integer) data[1])),\n+                        // Confidence concordance\n+                        Stream.of(new Object[][] {\n+\n+                        }).collect(Collectors.toMap(data -> (String) data[0], data -> (Integer) data[1])),\n+                },\n+                // Two non_ref blocks\n+                {\n+                        // Truth variants\n+                        Arrays.asList(\n+                                new TestReferenceBlockConcordanceVariant(\"<NON_REF>\", 1, 1, 99)\n+                        ),\n+                        // Eval variants\n+                        Arrays.asList(\n+                                new TestReferenceBlockConcordanceVariant(\"<NON_REF>\", 1, 1, 99)\n+                        ),\n+                        // Truth block histogram\n+                        Stream.of(new Object[][] {\n+                                { \"1,99\", 1}\n+                        }).collect(Collectors.toMap(data -> (String) data[0], data -> (Integer) data[1])),\n+                        // Eval block histogram\n+                        Stream.of(new Object[][] {\n+                                { \"1,99\", 1}\n+                        }).collect(Collectors.toMap(data -> (String) data[0], data -> (Integer) data[1])),\n+                        // Confidence concordance\n+                        Stream.of(new Object[][] {\n+                                { \"99,99\", 1}\n+                        }).collect(Collectors.toMap(data -> (String) data[0], data -> (Integer) data[1])),\n+                },\n+                // Start with gap then variant\n+                {\n+                        // Truth variants\n+                        Arrays.asList(\n+                                new TestReferenceBlockConcordanceVariant(\"<NON_REF>\", 1, 10, 99)\n+                        ),\n+                        // Eval variants\n+                        Arrays.asList(\n+                                new TestReferenceBlockConcordanceVariant(\"C\", 5, 5, 99),\n+                                new TestReferenceBlockConcordanceVariant(\"<NON_REF>\", 6, 10, 99)\n+                        ),\n+                        // Truth block histogram\n+                        Stream.of(new Object[][] {\n+                                { \"10,99\", 1}\n+                        }).collect(Collectors.toMap(data -> (String) data[0], data -> (Integer) data[1])),\n+                        // Eval block histogram\n+                        Stream.of(new Object[][] {\n+                                { \"5,99\", 1}\n+                        }).collect(Collectors.toMap(data -> (String) data[0], data -> (Integer) data[1])),\n+                        // Confidence concordance\n+                        Stream.of(new Object[][] {\n+                                { \"99,99\", 5}\n+                        }).collect(Collectors.toMap(data -> (String) data[0], data -> (Integer) data[1])),\n+                },\n+                // Start with gap then non_ref\n+                {\n+                        // Truth variants\n+                        Arrays.asList(\n+                                new TestReferenceBlockConcordanceVariant(\"<NON_REF>\", 1, 10, 99)\n+                        ),\n+                        // Eval variants\n+                        Arrays.asList(\n+                                new TestReferenceBlockConcordanceVariant(\"<NON_REF>\", 6, 10, 99)\n+                        ),\n+                        // Truth block histogram\n+                        Stream.of(new Object[][] {\n+                                { \"10,99\", 1}\n+                        }).collect(Collectors.toMap(data -> (String) data[0], data -> (Integer) data[1])),\n+                        // Eval block histogram\n+                        Stream.of(new Object[][] {\n+                                { \"5,99\", 1}\n+                        }).collect(Collectors.toMap(data -> (String) data[0], data -> (Integer) data[1])),\n+                        // Confidence concordance\n+                        Stream.of(new Object[][] {\n+                                { \"99,99\", 5}\n+                        }).collect(Collectors.toMap(data -> (String) data[0], data -> (Integer) data[1])),\n+                },\n+                // Start with single block\n+                {\n+                        // Truth variants\n+                        Arrays.asList(\n+                                new TestReferenceBlockConcordanceVariant(\"<NON_REF>\", 11, 20, 99)\n+                        ),\n+                        // Eval variants\n+                        Arrays.asList(\n+                                new TestReferenceBlockConcordanceVariant(\"<NON_REF>\", 3, 6, 98),\n+                                new TestReferenceBlockConcordanceVariant(\"<NON_REF>\", 11, 20, 99)\n+                        ),\n+                        // Truth block histogram\n+                        Stream.of(new Object[][] {\n+                                { \"10,99\", 1}\n+                        }).collect(Collectors.toMap(data -> (String) data[0], data -> (Integer) data[1])),\n+                        // Eval block histogram\n+                        Stream.of(new Object[][] {\n+                                { \"4,98\", 1},\n+                                { \"10,99\", 1}\n+                        }).collect(Collectors.toMap(data -> (String) data[0], data -> (Integer) data[1])),\n+                        // Confidence concordance\n+                        Stream.of(new Object[][] {\n+                                { \"99,99\", 10}\n+                        }).collect(Collectors.toMap(data -> (String) data[0], data -> (Integer) data[1])),\n+                },\n+                // No overlap at all\n+                {\n+                        // Truth variants\n+                        Arrays.asList(\n+                                new TestReferenceBlockConcordanceVariant(\"<NON_REF>\", 11, 20, 99)\n+                        ),\n+                        // Eval variants\n+                        Arrays.asList(\n+                                new TestReferenceBlockConcordanceVariant(\"<NON_REF>\", 3, 6, 98)\n+                        ),\n+                        // Truth block histogram\n+                        Stream.of(new Object[][] {\n+                                { \"10,99\", 1}\n+                        }).collect(Collectors.toMap(data -> (String) data[0], data -> (Integer) data[1])),\n+                        // Eval block histogram\n+                        Stream.of(new Object[][] {\n+                                { \"4,98\", 1}\n+                        }).collect(Collectors.toMap(data -> (String) data[0], data -> (Integer) data[1])),\n+                        // Confidence concordance\n+                        Stream.of(new Object[][] {\n+                        }).collect(Collectors.toMap(data -> (String) data[0], data -> (Integer) data[1])),\n+                },\n+                // End with var\n+                {\n+                        // Truth variants\n+                        Arrays.asList(\n+                                new TestReferenceBlockConcordanceVariant(\"<NON_REF>\", 1, 10, 99)\n+                        ),\n+                        // Eval variants\n+                        Arrays.asList(\n+                                new TestReferenceBlockConcordanceVariant(\"<NON_REF>\", 1, 9, 99),\n+                                new TestReferenceBlockConcordanceVariant(\"C\", 10, 10, 99)\n+                        ),\n+                        // Truth block histogram\n+                        Stream.of(new Object[][] {\n+                                { \"10,99\", 1}\n+                        }).collect(Collectors.toMap(data -> (String) data[0], data -> (Integer) data[1])),\n+                        // Eval block histogram\n+                        Stream.of(new Object[][] {\n+                                { \"9,99\", 1}\n+                        }).collect(Collectors.toMap(data -> (String) data[0], data -> (Integer) data[1])),\n+                        // Confidence concordance\n+                        Stream.of(new Object[][] {\n+                                { \"99,99\", 9}\n+                        }).collect(Collectors.toMap(data -> (String) data[0], data -> (Integer) data[1])),\n+                },\n+                // End with var then gap\n+                {\n+                        // Truth variants\n+                        Arrays.asList(\n+                                new TestReferenceBlockConcordanceVariant(\"<NON_REF>\", 1, 10, 99)\n+                        ),\n+                        // Eval variants\n+                        Arrays.asList(\n+                                new TestReferenceBlockConcordanceVariant(\"<NON_REF>\", 1, 7, 99),\n+                                new TestReferenceBlockConcordanceVariant(\"C\", 8, 8, 99)\n+                        ),\n+                        // Truth block histogram\n+                        Stream.of(new Object[][] {\n+                                { \"10,99\", 1}\n+                        }).collect(Collectors.toMap(data -> (String) data[0], data -> (Integer) data[1])),\n+                        // Eval block histogram\n+                        Stream.of(new Object[][] {\n+                                { \"7,99\", 1}\n+                        }).collect(Collectors.toMap(data -> (String) data[0], data -> (Integer) data[1])),\n+                        // Confidence concordance\n+                        Stream.of(new Object[][] {\n+                                { \"99,99\", 7}\n+                        }).collect(Collectors.toMap(data -> (String) data[0], data -> (Integer) data[1])),\n+                },\n+                // End with gap then var\n+                {\n+                        // Truth variants\n+                        Arrays.asList(\n+                                new TestReferenceBlockConcordanceVariant(\"<NON_REF>\", 1, 10, 99)\n+                        ),\n+                        // Eval variants\n+                        Arrays.asList(\n+                                new TestReferenceBlockConcordanceVariant(\"<NON_REF>\", 1, 7, 99),\n+                                new TestReferenceBlockConcordanceVariant(\"C\", 10, 10, 99)\n+                        ),\n+                        // Truth block histogram\n+                        Stream.of(new Object[][] {\n+                                { \"10,99\", 1}\n+                        }).collect(Collectors.toMap(data -> (String) data[0], data -> (Integer) data[1])),\n+                        // Eval block histogram\n+                        Stream.of(new Object[][] {\n+                                { \"7,99\", 1}\n+                        }).collect(Collectors.toMap(data -> (String) data[0], data -> (Integer) data[1])),\n+                        // Confidence concordance\n+                        Stream.of(new Object[][] {\n+                                { \"99,99\", 7}\n+                        }).collect(Collectors.toMap(data -> (String) data[0], data -> (Integer) data[1])),\n+                },\n+        };\n+    }\n+\n+    @Test(dataProvider = \"provideSyntheticGVCFs\")\n+    public void testSyntheticGVCFs(final List<TestReferenceBlockConcordanceVariant> truthVariants, final List<TestReferenceBlockConcordanceVariant> evalVariants, final Map<String, Integer> expectedTruthBlockHistogram, final Map<String, Integer> expectedEvalBlockHistogram, final Map<String, Integer> expectedConfidenceConcordance) throws Exception {\n+        Pair<File, File> inputFiles = writeTestGVCFs(truthVariants, evalVariants);\n+\n+        final Path truthBlockHistogramFile = createTempPath(\"truth_block_histogram\", \".tsv\");\n+        final Path evalBlockHistogramFile = createTempPath(\"eval_block_histogram\", \".tsv\");\n+        final Path confidenceConcordanceHistogramFile = createTempPath(\"confidence_concordance_histogram\", \".tsv\");\n+\n+        final String[] args = {\n+                \"--\" + AbstractConcordanceWalker.TRUTH_VARIANTS_LONG_NAME, inputFiles.getLeft().toString(),\n+                \"--\" + AbstractConcordanceWalker.EVAL_VARIANTS_LONG_NAME, inputFiles.getRight().toString(),\n+                \"--\" + ReferenceBlockConcordance.TRUTH_BLOCK_HISTOGRAM_LONG_NAME, truthBlockHistogramFile.toString(),\n+                \"--\" + ReferenceBlockConcordance.EVAL_BLOCK_HISTOGRAM_LONG_NAME, evalBlockHistogramFile.toString(),\n+                \"--\" + ReferenceBlockConcordance.CONFIDENCE_CONCORDANCE_HISTOGRAM_LONG_NAME, confidenceConcordanceHistogramFile.toString(),\n+        };\n+        runCommandLine(args);\n+\n+        MetricsFile<?, String> truthBlockMetrics = new MetricsFile<>();\n+        truthBlockMetrics.read(new FileReader(truthBlockHistogramFile.toFile()));\n+        if (truthBlockMetrics.getNumHistograms() > 0) {\n+            Assert.assertEquals(truthBlockMetrics.getNumHistograms(), 1);\n+            Histogram<String> truthBlockHistogram = truthBlockMetrics.getHistogram();\n+            // Check value and remove entry from expected histogram...\n+            truthBlockHistogram.values().forEach(bin -> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "df904bc0857d2939326188ce3932e9f3601838fd"}, "originalPosition": 362}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzE4NDExMg==", "bodyText": "good to see all these different test cases \ud83d\udc4d", "url": "https://github.com/broadinstitute/gatk/pull/6802#discussion_r487184112", "createdAt": "2020-09-11T17:21:53Z", "author": {"login": "kachulis"}, "path": "src/test/java/org/broadinstitute/hellbender/tools/walkers/validation/ReferenceBlockConcordanceIntegrationTest.java", "diffHunk": "@@ -0,0 +1,436 @@\n+package org.broadinstitute.hellbender.tools.walkers.validation;\n+\n+import htsjdk.samtools.metrics.MetricsFile;\n+import htsjdk.samtools.util.Histogram;\n+import org.broadinstitute.hellbender.CommandLineProgramTest;\n+import org.broadinstitute.hellbender.engine.AbstractConcordanceWalker;\n+import org.testng.Assert;\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+import picard.sam.util.Pair;\n+\n+import java.io.File;\n+import java.io.FileReader;\n+import java.io.FileWriter;\n+import java.nio.file.Path;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+/**\n+ * Created by Michael Gatzen on 9/9/20.\n+ */\n+public class ReferenceBlockConcordanceIntegrationTest extends CommandLineProgramTest{\n+\n+    private static final String CONCORDANCE_TEST_DIR = toolsTestDir + \"concordance/\";\n+    private static final String HAPLOTYPECALLER_TEST_DIR = toolsTestDir + \"haplotypecaller/\";\n+\n+    @Test\n+    public void testIdentical() throws Exception {\n+        // TODO Is it fine to use a test file from a different tool or should I copy it?\n+        final File truthVcf = new File(HAPLOTYPECALLER_TEST_DIR, \"expected.testGVCFMode.gatk4.g.vcf\");\n+        final File evalVcf = new File(HAPLOTYPECALLER_TEST_DIR, \"expected.testGVCFMode.gatk4.g.vcf\");\n+        final Path truthBlockHistogramFile = createTempPath(\"truth_block_histogram\", \".tsv\");\n+        final Path evalBlockHistogramFile = createTempPath(\"eval_block_histogram\", \".tsv\");\n+        final Path confidenceConcordanceHistogramFile = createTempPath(\"confidence_concordance_histogram\", \".tsv\");\n+\n+        final String[] args = {\n+                \"--\" + AbstractConcordanceWalker.EVAL_VARIANTS_LONG_NAME, evalVcf.toString(),\n+                \"--\" + AbstractConcordanceWalker.TRUTH_VARIANTS_LONG_NAME, truthVcf.toString(),\n+                \"--\" + ReferenceBlockConcordance.TRUTH_BLOCK_HISTOGRAM_LONG_NAME, truthBlockHistogramFile.toString(),\n+                \"--\" + ReferenceBlockConcordance.EVAL_BLOCK_HISTOGRAM_LONG_NAME, evalBlockHistogramFile.toString(),\n+                \"--\" + ReferenceBlockConcordance.CONFIDENCE_CONCORDANCE_HISTOGRAM_LONG_NAME, confidenceConcordanceHistogramFile.toString(),\n+        };\n+        runCommandLine(args);\n+\n+        MetricsFile<?, String> truthBlockMetrics = new MetricsFile<>();\n+        truthBlockMetrics.read(new FileReader(truthBlockHistogramFile.toFile()));\n+        MetricsFile<?, String> evalBlockMetrics = new MetricsFile<>();\n+        evalBlockMetrics.read(new FileReader(evalBlockHistogramFile.toFile()));\n+\n+        Assert.assertEquals(truthBlockMetrics.getNumHistograms(), 1);\n+        Assert.assertEquals(evalBlockMetrics.getNumHistograms(), 1);\n+\n+        Histogram<String> truthBlockHistogram = truthBlockMetrics.getHistogram();\n+        Histogram<String> evalBlockHistogram = evalBlockMetrics.getHistogram();\n+\n+        // Got this number by counting the <NON_REF> alt alleles in the test GVCF file\n+        Assert.assertEquals(truthBlockHistogram.getSumOfValues(), 1034);\n+        Assert.assertEquals(evalBlockHistogram.getSumOfValues(), 1034);\n+\n+        // Check block histograms both ways, in case one histogram has more entries than the other\n+        truthBlockHistogram.values().forEach(bin -> {\n+            Assert.assertTrue(evalBlockHistogram.containsKey(bin.getId()));\n+            Assert.assertEquals(bin.getValue(), evalBlockHistogram.get(bin.getId()).getValue());\n+        });\n+\n+        evalBlockHistogram.values().forEach(bin -> {\n+            Assert.assertTrue(truthBlockHistogram.containsKey(bin.getId()));\n+            Assert.assertEquals(bin.getValue(), truthBlockHistogram.get(bin.getId()).getValue());\n+        });\n+\n+        MetricsFile<?, String> confidenceConcordanceMetrics = new MetricsFile<>();\n+        confidenceConcordanceMetrics.read(new FileReader(confidenceConcordanceHistogramFile.toFile()));\n+        Assert.assertEquals(confidenceConcordanceMetrics.getNumHistograms(), 1);\n+        Histogram<String> confidenceConcordanceHistogram = confidenceConcordanceMetrics.getHistogram();\n+\n+        confidenceConcordanceHistogram.values().forEach(bin -> {\n+            String[] confidenceValues = bin.getId().split(\",\");\n+            Assert.assertEquals(confidenceValues[0], confidenceValues[1]);\n+        });\n+    }\n+\n+    private Pair<File, File> writeTestGVCFs(List<TestReferenceBlockConcordanceVariant> truthVariants, List<TestReferenceBlockConcordanceVariant> evalVariants) throws Exception {\n+        File truthFile = createTempFile(\"truth\", \".gvcf\");\n+        FileWriter writer = new FileWriter(truthFile);\n+        writer.write(\"##fileformat=VCFv4.2\\n\");\n+        writer.write(\"##contig=<ID=test_contig,length=1000>\\n\");\n+        writer.write(\"#CHROM\\tPOS\\tID\\tREF\\tALT\\tQUAL\\tFILTER\\tINFO\\tFORMAT\\tTESTSAMPLE\\n\");\n+        for (TestReferenceBlockConcordanceVariant variant : truthVariants) {\n+            writer.write(String.format(\"test_contig\\t%s\\t.\\tA\\t%s\\t%s\\t.\\t%s\\tGT:GQ\\t%s:%s\\n\",\n+                    variant.start,\n+                    variant.getAltAllele(),\n+                    variant.getAltAllele().equals(\"<NON_REF>\") ? \".\" : \"1\",\n+                    variant.getAltAllele().equals(\"<NON_REF>\") ? String.format(\"END=%s\", variant.getStop()) : \".\",\n+                    variant.getAltAllele().equals(\"<NON_REF>\") ? \"0/0\" : \"0/1\",\n+                    variant.getConfidence()));\n+        }\n+        writer.close();\n+\n+        File evalFile = createTempFile(\"eval\", \".gvcf\");\n+        writer = new FileWriter(evalFile);\n+        writer.write(\"##fileformat=VCFv4.2\\n\");\n+        writer.write(\"##contig=<ID=test_contig,length=1000>\\n\");\n+        writer.write(\"#CHROM\\tPOS\\tID\\tREF\\tALT\\tQUAL\\tFILTER\\tINFO\\tFORMAT\\tTESTSAMPLE\\n\");\n+        for (TestReferenceBlockConcordanceVariant variant : evalVariants) {\n+            writer.write(String.format(\"test_contig\\t%s\\t.\\tA\\t%s\\t%s\\t.\\t%s\\tGT:GQ\\t%s:%s\\n\",\n+                    variant.start,\n+                    variant.getAltAllele(),\n+                    variant.getAltAllele().equals(\"<NON_REF>\") ? \".\" : \"1\",\n+                    variant.getAltAllele().equals(\"<NON_REF>\") ? String.format(\"END=%s\", variant.getStop()) : \".\",\n+                    variant.getAltAllele().equals(\"<NON_REF>\") ? \"0/0\" : \"0/1\",\n+                    variant.getConfidence()));\n+        }\n+        writer.close();\n+\n+        return new Pair<>(truthFile, evalFile);\n+    }\n+\n+    @DataProvider\n+    public Object[][] provideSyntheticGVCFs() {\n+        return new Object[][] {\n+                // No non_ref blocks\n+                {\n+                        // Truth variants\n+                        Arrays.asList(\n+                                new TestReferenceBlockConcordanceVariant(\"C\", 1, 1, 99)\n+                        ),\n+                        // Eval variants\n+                        Arrays.asList(\n+                                new TestReferenceBlockConcordanceVariant(\"<NON_REF>\", 1, 1, 99)\n+                        ),\n+                        // Truth block histogram\n+                        Stream.of(new Object[][] {\n+\n+                        }).collect(Collectors.toMap(data -> (String) data[0], data -> (Integer) data[1])),\n+                        // Eval block histogram\n+                        Stream.of(new Object[][] {\n+                                { \"1,99\", 1}\n+                        }).collect(Collectors.toMap(data -> (String) data[0], data -> (Integer) data[1])),\n+                        // Confidence concordance\n+                        Stream.of(new Object[][] {\n+\n+                        }).collect(Collectors.toMap(data -> (String) data[0], data -> (Integer) data[1])),\n+                },\n+                // Two non_ref blocks\n+                {\n+                        // Truth variants\n+                        Arrays.asList(\n+                                new TestReferenceBlockConcordanceVariant(\"<NON_REF>\", 1, 1, 99)\n+                        ),\n+                        // Eval variants\n+                        Arrays.asList(\n+                                new TestReferenceBlockConcordanceVariant(\"<NON_REF>\", 1, 1, 99)\n+                        ),\n+                        // Truth block histogram\n+                        Stream.of(new Object[][] {\n+                                { \"1,99\", 1}\n+                        }).collect(Collectors.toMap(data -> (String) data[0], data -> (Integer) data[1])),\n+                        // Eval block histogram\n+                        Stream.of(new Object[][] {\n+                                { \"1,99\", 1}\n+                        }).collect(Collectors.toMap(data -> (String) data[0], data -> (Integer) data[1])),\n+                        // Confidence concordance\n+                        Stream.of(new Object[][] {\n+                                { \"99,99\", 1}\n+                        }).collect(Collectors.toMap(data -> (String) data[0], data -> (Integer) data[1])),\n+                },\n+                // Start with gap then variant\n+                {\n+                        // Truth variants\n+                        Arrays.asList(\n+                                new TestReferenceBlockConcordanceVariant(\"<NON_REF>\", 1, 10, 99)\n+                        ),\n+                        // Eval variants\n+                        Arrays.asList(\n+                                new TestReferenceBlockConcordanceVariant(\"C\", 5, 5, 99),\n+                                new TestReferenceBlockConcordanceVariant(\"<NON_REF>\", 6, 10, 99)\n+                        ),\n+                        // Truth block histogram\n+                        Stream.of(new Object[][] {\n+                                { \"10,99\", 1}\n+                        }).collect(Collectors.toMap(data -> (String) data[0], data -> (Integer) data[1])),\n+                        // Eval block histogram\n+                        Stream.of(new Object[][] {\n+                                { \"5,99\", 1}\n+                        }).collect(Collectors.toMap(data -> (String) data[0], data -> (Integer) data[1])),\n+                        // Confidence concordance\n+                        Stream.of(new Object[][] {\n+                                { \"99,99\", 5}\n+                        }).collect(Collectors.toMap(data -> (String) data[0], data -> (Integer) data[1])),\n+                },\n+                // Start with gap then non_ref\n+                {\n+                        // Truth variants\n+                        Arrays.asList(\n+                                new TestReferenceBlockConcordanceVariant(\"<NON_REF>\", 1, 10, 99)\n+                        ),\n+                        // Eval variants\n+                        Arrays.asList(\n+                                new TestReferenceBlockConcordanceVariant(\"<NON_REF>\", 6, 10, 99)\n+                        ),\n+                        // Truth block histogram\n+                        Stream.of(new Object[][] {\n+                                { \"10,99\", 1}\n+                        }).collect(Collectors.toMap(data -> (String) data[0], data -> (Integer) data[1])),\n+                        // Eval block histogram\n+                        Stream.of(new Object[][] {\n+                                { \"5,99\", 1}\n+                        }).collect(Collectors.toMap(data -> (String) data[0], data -> (Integer) data[1])),\n+                        // Confidence concordance\n+                        Stream.of(new Object[][] {\n+                                { \"99,99\", 5}\n+                        }).collect(Collectors.toMap(data -> (String) data[0], data -> (Integer) data[1])),\n+                },\n+                // Start with single block\n+                {\n+                        // Truth variants\n+                        Arrays.asList(\n+                                new TestReferenceBlockConcordanceVariant(\"<NON_REF>\", 11, 20, 99)\n+                        ),\n+                        // Eval variants\n+                        Arrays.asList(\n+                                new TestReferenceBlockConcordanceVariant(\"<NON_REF>\", 3, 6, 98),\n+                                new TestReferenceBlockConcordanceVariant(\"<NON_REF>\", 11, 20, 99)\n+                        ),\n+                        // Truth block histogram\n+                        Stream.of(new Object[][] {\n+                                { \"10,99\", 1}\n+                        }).collect(Collectors.toMap(data -> (String) data[0], data -> (Integer) data[1])),\n+                        // Eval block histogram\n+                        Stream.of(new Object[][] {\n+                                { \"4,98\", 1},\n+                                { \"10,99\", 1}\n+                        }).collect(Collectors.toMap(data -> (String) data[0], data -> (Integer) data[1])),\n+                        // Confidence concordance\n+                        Stream.of(new Object[][] {\n+                                { \"99,99\", 10}\n+                        }).collect(Collectors.toMap(data -> (String) data[0], data -> (Integer) data[1])),\n+                },\n+                // No overlap at all\n+                {\n+                        // Truth variants\n+                        Arrays.asList(\n+                                new TestReferenceBlockConcordanceVariant(\"<NON_REF>\", 11, 20, 99)\n+                        ),\n+                        // Eval variants\n+                        Arrays.asList(\n+                                new TestReferenceBlockConcordanceVariant(\"<NON_REF>\", 3, 6, 98)\n+                        ),\n+                        // Truth block histogram\n+                        Stream.of(new Object[][] {\n+                                { \"10,99\", 1}\n+                        }).collect(Collectors.toMap(data -> (String) data[0], data -> (Integer) data[1])),\n+                        // Eval block histogram\n+                        Stream.of(new Object[][] {\n+                                { \"4,98\", 1}\n+                        }).collect(Collectors.toMap(data -> (String) data[0], data -> (Integer) data[1])),\n+                        // Confidence concordance\n+                        Stream.of(new Object[][] {\n+                        }).collect(Collectors.toMap(data -> (String) data[0], data -> (Integer) data[1])),\n+                },\n+                // End with var\n+                {\n+                        // Truth variants\n+                        Arrays.asList(\n+                                new TestReferenceBlockConcordanceVariant(\"<NON_REF>\", 1, 10, 99)\n+                        ),\n+                        // Eval variants\n+                        Arrays.asList(\n+                                new TestReferenceBlockConcordanceVariant(\"<NON_REF>\", 1, 9, 99),\n+                                new TestReferenceBlockConcordanceVariant(\"C\", 10, 10, 99)\n+                        ),\n+                        // Truth block histogram\n+                        Stream.of(new Object[][] {\n+                                { \"10,99\", 1}\n+                        }).collect(Collectors.toMap(data -> (String) data[0], data -> (Integer) data[1])),\n+                        // Eval block histogram\n+                        Stream.of(new Object[][] {\n+                                { \"9,99\", 1}\n+                        }).collect(Collectors.toMap(data -> (String) data[0], data -> (Integer) data[1])),\n+                        // Confidence concordance\n+                        Stream.of(new Object[][] {\n+                                { \"99,99\", 9}\n+                        }).collect(Collectors.toMap(data -> (String) data[0], data -> (Integer) data[1])),\n+                },\n+                // End with var then gap\n+                {\n+                        // Truth variants\n+                        Arrays.asList(\n+                                new TestReferenceBlockConcordanceVariant(\"<NON_REF>\", 1, 10, 99)\n+                        ),\n+                        // Eval variants\n+                        Arrays.asList(\n+                                new TestReferenceBlockConcordanceVariant(\"<NON_REF>\", 1, 7, 99),\n+                                new TestReferenceBlockConcordanceVariant(\"C\", 8, 8, 99)\n+                        ),\n+                        // Truth block histogram\n+                        Stream.of(new Object[][] {\n+                                { \"10,99\", 1}\n+                        }).collect(Collectors.toMap(data -> (String) data[0], data -> (Integer) data[1])),\n+                        // Eval block histogram\n+                        Stream.of(new Object[][] {\n+                                { \"7,99\", 1}\n+                        }).collect(Collectors.toMap(data -> (String) data[0], data -> (Integer) data[1])),\n+                        // Confidence concordance\n+                        Stream.of(new Object[][] {\n+                                { \"99,99\", 7}\n+                        }).collect(Collectors.toMap(data -> (String) data[0], data -> (Integer) data[1])),\n+                },\n+                // End with gap then var", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "df904bc0857d2939326188ce3932e9f3601838fd"}, "originalPosition": 312}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzE4NTYyOQ==", "bodyText": "though I could certainly be convinced differently on this", "url": "https://github.com/broadinstitute/gatk/pull/6802#discussion_r487185629", "createdAt": "2020-09-11T17:24:57Z", "author": {"login": "kachulis"}, "path": "src/main/java/org/broadinstitute/hellbender/tools/walkers/validation/ReferenceBlockConcordance.java", "diffHunk": "@@ -0,0 +1,215 @@\n+package org.broadinstitute.hellbender.tools.walkers.validation;\n+\n+import htsjdk.samtools.metrics.MetricsFile;\n+import htsjdk.samtools.util.Histogram;\n+import htsjdk.variant.variantcontext.Genotype;\n+import htsjdk.variant.variantcontext.VariantContext;\n+import org.apache.commons.collections4.Predicate;\n+import org.broadinstitute.barclay.argparser.Argument;\n+import org.broadinstitute.barclay.argparser.CommandLineProgramProperties;\n+import org.broadinstitute.hellbender.engine.AbstractConcordanceWalker;\n+import org.broadinstitute.hellbender.engine.ReadsContext;\n+import org.broadinstitute.hellbender.engine.ReferenceContext;\n+import picard.cmdline.programgroups.VariantEvaluationProgramGroup;\n+import picard.sam.util.Pair;\n+\n+import java.io.File;\n+\n+/**\n+ * Evaluate GVCF reference block concordance of an input GVCF against a truth GVCF.\n+ *\n+ * <p>This tool evaluates two GVCF files against each other and produces three histograms:</p>\n+ *\n+ * <ul>\n+ *     <li>Truth block histogram: Indicates the number of occurrence of reference blocks with a given confidence score and length in the truth GVCF</li>\n+ *     <li>Eval block histogram: Indicates the number of occurrence of reference blocks with a given confidence score and length in the eval GVCF</li>\n+ *     <li>Confidence concordance histogram: Reflects the confidence scores of bases in reference blocks in the truth and eval VCF, respectively. An entry of 10 at bin \"80,90\" means that 10 bases in the truth GVCF have a confidence score of 80 while those same bases have a score of 90 in the eval GVCF.</li>\n+ * </ul>\n+ *\n+ * <p>In contrast to the {@link Concordance} tool, this tool considers all variants, regardless of passing or failing filters.</p>\n+ *\n+ * <h3>Usage example</h3>\n+ *\n+ * <pre>\n+ * gatk ReferenceBlockConcordance \\\n+ *   -R reference.fa \\\n+ *   -eval eval.vcf \\\n+ *   --truth truth.vcf \\\n+ *   --truth-block-histogram truth_block_histogram.tsv \\\n+ *   --eval-block-histogram eval_block_histogram.tsv \\\n+ *   --confidence-concordance-histogram confidence_concordance_histogram.tsv\n+ * </pre>\n+ */\n+\n+@CommandLineProgramProperties(\n+        summary = ReferenceBlockConcordance.USAGE_SUMMARY,\n+        oneLineSummary = ReferenceBlockConcordance.USAGE_ONE_LINE_SUMMARY,\n+        programGroup = VariantEvaluationProgramGroup.class\n+)\n+public class ReferenceBlockConcordance extends AbstractConcordanceWalker {\n+    public static final String TRUTH_BLOCK_HISTOGRAM_LONG_NAME = \"truth-block-histogram\";\n+    public static final String TRUTH_BLOCK_HISTOGRAM_SHORT_NAME = \"tbh\";\n+    public static final String EVAL_BLOCK_HISTOGRAM_LONG_NAME = \"eval-block-histogram\";\n+    public static final String EVAL_BLOCK_HISTOGRAM_SHORT_NAME = \"ebh\";\n+    public static final String CONFIDENCE_CONCORDANCE_HISTOGRAM_LONG_NAME = \"confidence-concordance-histogram\";\n+    public static final String CONFIDENCE_CONCORDANCE_HISTOGRAM_SHORT_NAME = \"cch\";\n+\n+    static final String USAGE_ONE_LINE_SUMMARY = \"Evaluate GVCF reference block concordance of an input GVCF against a truth GVCF\";\n+    static final String USAGE_SUMMARY = \"This tool evaluates two GVCF files against each other and produces three histograms:\\n\" +\n+            \"Truth block histogram: Indicates the number of occurrence of reference blocks with a given confidence score and length in the truth GVCF\\n\" +\n+            \"Eval block histogram: Indicates the number of occurrence of reference blocks with a given confidence score and length in the eval GVCF\\n\" +\n+            \"Confidence concordance histogram: Reflects the confidence scores of bases in reference blocks in the truth and eval VCF, respectively. An entry of 10 at bin \\\"80,90\\\" means that 10 bases in the truth GVCF have a confidence score of 80 while those same bases have a score of 90 in the eval GVCF.\\n\" +\n+            \"In contrast to the Concordance tool, this tool considers all variants, regardless of passing or failing filters.\";\n+\n+    @Argument(doc = \"A histogram of block lengths and their associated confidence scores for the truth sample\",\n+            fullName = TRUTH_BLOCK_HISTOGRAM_LONG_NAME,\n+            shortName = TRUTH_BLOCK_HISTOGRAM_SHORT_NAME)\n+    protected File truthBlockHistogramFile;\n+    @Argument(doc = \"A histogram of block lengths and their associated confidence scores for the eval sample\",\n+            fullName = EVAL_BLOCK_HISTOGRAM_LONG_NAME,\n+            shortName = EVAL_BLOCK_HISTOGRAM_SHORT_NAME)\n+    protected File evalBlockHistogramFile;\n+    @Argument(doc = \"Reflects the confidence scores of bases in reference blocks in the truth and eval VCF, respectively. An entry of 10 at bin \\\"80,90\\\" means that 10 bases in the truth GVCF have a confidence score of 80 while those same bases have a score of 90 in the eval GVCF.\",\n+            fullName = CONFIDENCE_CONCORDANCE_HISTOGRAM_LONG_NAME,\n+            shortName = CONFIDENCE_CONCORDANCE_HISTOGRAM_SHORT_NAME)\n+    protected File confidenceConcordanceHistogramFile;\n+\n+    // TODO this should be a Histogram<Pair<Integer, Integer>>, however, the MetricsFile class cannot read\n+    // arbitrary types, therefore, it must be converted to a String, which is probably much slower\n+    private final Histogram<String> truthBlockHistogram = new Histogram<>();\n+    private final Histogram<String> evalBlockHistogram = new Histogram<>();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTU5ODQwOA=="}, "originalCommit": {"oid": "3146dabf366156d1ad5743ce786f475a525804c4"}, "originalPosition": 80}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzE4NzQ3OQ==", "bodyText": "could the setting of currentTruthVariantContext and currentEvalVariantContext be moved before the incrementing of confidenceConcordanceHistogram.  Then you wouldn't need to additionally increment confidenceConcordanceHistogram in evaluateEndOfContig, or call evaluateEndOfContig from onTraversalSuccess", "url": "https://github.com/broadinstitute/gatk/pull/6802#discussion_r487187479", "createdAt": "2020-09-11T17:28:40Z", "author": {"login": "kachulis"}, "path": "src/main/java/org/broadinstitute/hellbender/tools/walkers/validation/ReferenceBlockConcordance.java", "diffHunk": "@@ -0,0 +1,215 @@\n+package org.broadinstitute.hellbender.tools.walkers.validation;\n+\n+import htsjdk.samtools.metrics.MetricsFile;\n+import htsjdk.samtools.util.Histogram;\n+import htsjdk.variant.variantcontext.Genotype;\n+import htsjdk.variant.variantcontext.VariantContext;\n+import org.apache.commons.collections4.Predicate;\n+import org.broadinstitute.barclay.argparser.Argument;\n+import org.broadinstitute.barclay.argparser.CommandLineProgramProperties;\n+import org.broadinstitute.hellbender.engine.AbstractConcordanceWalker;\n+import org.broadinstitute.hellbender.engine.ReadsContext;\n+import org.broadinstitute.hellbender.engine.ReferenceContext;\n+import picard.cmdline.programgroups.VariantEvaluationProgramGroup;\n+import picard.sam.util.Pair;\n+\n+import java.io.File;\n+\n+/**\n+ * Evaluate GVCF reference block concordance of an input GVCF against a truth GVCF.\n+ *\n+ * <p>This tool evaluates two GVCF files against each other and produces three histograms:</p>\n+ *\n+ * <ul>\n+ *     <li>Truth block histogram: Indicates the number of occurrence of reference blocks with a given confidence score and length in the truth GVCF</li>\n+ *     <li>Eval block histogram: Indicates the number of occurrence of reference blocks with a given confidence score and length in the eval GVCF</li>\n+ *     <li>Confidence concordance histogram: Reflects the confidence scores of bases in reference blocks in the truth and eval VCF, respectively. An entry of 10 at bin \"80,90\" means that 10 bases in the truth GVCF have a confidence score of 80 while those same bases have a score of 90 in the eval GVCF.</li>\n+ * </ul>\n+ *\n+ * <p>In contrast to the {@link Concordance} tool, this tool considers all variants, regardless of passing or failing filters.</p>\n+ *\n+ * <h3>Usage example</h3>\n+ *\n+ * <pre>\n+ * gatk ReferenceBlockConcordance \\\n+ *   -R reference.fa \\\n+ *   -eval eval.vcf \\\n+ *   --truth truth.vcf \\\n+ *   --truth-block-histogram truth_block_histogram.tsv \\\n+ *   --eval-block-histogram eval_block_histogram.tsv \\\n+ *   --confidence-concordance-histogram confidence_concordance_histogram.tsv\n+ * </pre>\n+ */\n+\n+@CommandLineProgramProperties(\n+        summary = ReferenceBlockConcordance.USAGE_SUMMARY,\n+        oneLineSummary = ReferenceBlockConcordance.USAGE_ONE_LINE_SUMMARY,\n+        programGroup = VariantEvaluationProgramGroup.class\n+)\n+public class ReferenceBlockConcordance extends AbstractConcordanceWalker {\n+    public static final String TRUTH_BLOCK_HISTOGRAM_LONG_NAME = \"truth-block-histogram\";\n+    public static final String TRUTH_BLOCK_HISTOGRAM_SHORT_NAME = \"tbh\";\n+    public static final String EVAL_BLOCK_HISTOGRAM_LONG_NAME = \"eval-block-histogram\";\n+    public static final String EVAL_BLOCK_HISTOGRAM_SHORT_NAME = \"ebh\";\n+    public static final String CONFIDENCE_CONCORDANCE_HISTOGRAM_LONG_NAME = \"confidence-concordance-histogram\";\n+    public static final String CONFIDENCE_CONCORDANCE_HISTOGRAM_SHORT_NAME = \"cch\";\n+\n+    static final String USAGE_ONE_LINE_SUMMARY = \"Evaluate GVCF reference block concordance of an input GVCF against a truth GVCF\";\n+    static final String USAGE_SUMMARY = \"This tool evaluates two GVCF files against each other and produces three histograms:\\n\" +\n+            \"Truth block histogram: Indicates the number of occurrence of reference blocks with a given confidence score and length in the truth GVCF\\n\" +\n+            \"Eval block histogram: Indicates the number of occurrence of reference blocks with a given confidence score and length in the eval GVCF\\n\" +\n+            \"Confidence concordance histogram: Reflects the confidence scores of bases in reference blocks in the truth and eval VCF, respectively. An entry of 10 at bin \\\"80,90\\\" means that 10 bases in the truth GVCF have a confidence score of 80 while those same bases have a score of 90 in the eval GVCF.\\n\" +\n+            \"In contrast to the Concordance tool, this tool considers all variants, regardless of passing or failing filters.\";\n+\n+    @Argument(doc = \"A histogram of block lengths and their associated confidence scores for the truth sample\",\n+            fullName = TRUTH_BLOCK_HISTOGRAM_LONG_NAME,\n+            shortName = TRUTH_BLOCK_HISTOGRAM_SHORT_NAME)\n+    protected File truthBlockHistogramFile;\n+    @Argument(doc = \"A histogram of block lengths and their associated confidence scores for the eval sample\",\n+            fullName = EVAL_BLOCK_HISTOGRAM_LONG_NAME,\n+            shortName = EVAL_BLOCK_HISTOGRAM_SHORT_NAME)\n+    protected File evalBlockHistogramFile;\n+    @Argument(doc = \"Reflects the confidence scores of bases in reference blocks in the truth and eval VCF, respectively. An entry of 10 at bin \\\"80,90\\\" means that 10 bases in the truth GVCF have a confidence score of 80 while those same bases have a score of 90 in the eval GVCF.\",\n+            fullName = CONFIDENCE_CONCORDANCE_HISTOGRAM_LONG_NAME,\n+            shortName = CONFIDENCE_CONCORDANCE_HISTOGRAM_SHORT_NAME)\n+    protected File confidenceConcordanceHistogramFile;\n+\n+    // TODO this should be a Histogram<Pair<Integer, Integer>>, however, the MetricsFile class cannot read\n+    // arbitrary types, therefore, it must be converted to a String, which is probably much slower\n+    private final Histogram<String> truthBlockHistogram = new Histogram<>();\n+    private final Histogram<String> evalBlockHistogram = new Histogram<>();\n+    private final Histogram<String> confidenceConcordanceHistogram = new Histogram<>();\n+\n+    private VariantContext currentTruthVariantContext = null;\n+    private VariantContext currentEvalVariantContext = null;\n+    private String currentContig = null;\n+\n+    @Override\n+    protected Predicate<VariantContext> makeTruthVariantFilter() {\n+        // Explicitly allow symbolic variants\n+        return VariantContext::isSymbolic;\n+    }\n+\n+    @Override\n+    protected Predicate<VariantContext> makeEvalVariantFilter() {\n+        // Explicitly allow symbolic variants\n+        return VariantContext::isSymbolic;\n+    }\n+\n+    private boolean isNonRef(VariantContext variantContext) {\n+        return variantContext.isSymbolic() && variantContext.getAlternateAllele(0).isNonRefAllele();\n+    }\n+\n+    private void evaluateEndOfContig() {\n+        if (currentTruthVariantContext != null && currentEvalVariantContext != null) {\n+            int blockStart = Math.max(currentTruthVariantContext.getStart(), currentEvalVariantContext.getStart());\n+            int blockEnd = Math.min(currentTruthVariantContext.getEnd(), currentEvalVariantContext.getEnd());\n+            int jointBlockLength = blockEnd - blockStart + 1;\n+            if (jointBlockLength > 0) {\n+                confidenceConcordanceHistogram.increment(new Pair<>(currentTruthVariantContext.getGenotype(0).getGQ(), currentEvalVariantContext.getGenotype(0).getGQ()).toString(), jointBlockLength);\n+            }\n+        }\n+\n+        currentTruthVariantContext = null;\n+        currentEvalVariantContext = null;\n+        currentContig = null;\n+    }\n+\n+    private void evaluateNewContig(TruthVersusEval truthVersusEval) {\n+        // If not beginning of file\n+        if (currentContig != null) {\n+            evaluateEndOfContig();\n+        }\n+\n+        currentContig = truthVersusEval.getTruthIfPresentElseEval().getContig();\n+    }\n+\n+    @Override\n+    protected void apply(TruthVersusEval truthVersusEval, ReadsContext readsContext, ReferenceContext refContext) {\n+        // New contig or beginning of file\n+        if (!truthVersusEval.getTruthIfPresentElseEval().getContig().equals(currentContig)) {\n+            evaluateNewContig(truthVersusEval);\n+        }\n+\n+        // Evaluate only when currently seeing two NON_REF blocks\n+        if (currentTruthVariantContext != null && currentEvalVariantContext != null) {\n+            int blockStart = Math.max(currentTruthVariantContext.getStart(), currentEvalVariantContext.getStart());\n+            int blockEnd = Math.min(currentTruthVariantContext.getEnd(), currentEvalVariantContext.getEnd());\n+            int jointBlockLength = blockEnd - blockStart + 1;\n+            // It is possible that jointBlockLength is negative if there is a gap in one file and the start of a new block in the other file.\n+            // Since there is no overlap though, we can just skip that case.\n+            if (jointBlockLength > 0) {\n+                confidenceConcordanceHistogram.increment(new Pair<>(currentTruthVariantContext.getGenotype(0).getGQ(), currentEvalVariantContext.getGenotype(0).getGQ()).toString(), blockEnd - blockStart + 1);\n+            }\n+\n+            int currentPosition = truthVersusEval.getTruthIfPresentElseEval().getStart();\n+            if (truthVersusEval.hasTruth() || currentPosition >= currentTruthVariantContext.getEnd()) {\n+                currentTruthVariantContext = null;\n+            }\n+            if (truthVersusEval.hasEval() || currentPosition >= currentEvalVariantContext.getEnd()) {\n+                currentEvalVariantContext = null;\n+            }\n+        }\n+\n+        // Truth\n+        if (truthVersusEval.hasTruth() && isNonRef(truthVersusEval.getTruth())) {\n+            currentTruthVariantContext = truthVersusEval.getTruth();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "df904bc0857d2939326188ce3932e9f3601838fd"}, "originalPosition": 156}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "deb363bc7c7049adadb7d56463c728bcbce57e82", "author": {"user": {"login": "michaelgatzen", "name": null}}, "url": "https://github.com/broadinstitute/gatk/commit/deb363bc7c7049adadb7d56463c728bcbce57e82", "committedDate": "2020-09-24T11:29:38Z", "message": "Incorporated PR comments\n\n- Use of more existing GATK tools, such as GVCFWriter and SimpleInterval throughout the tool and its integration test\n- final correctness\n- Arguments as GATKPath\n- Refactoring of integration tests\n- Correct variant filters for traversal\n- Rearranged and simplified the counting\n- Aligned expected values for integration test to new variant filters"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDk3NDgzMjY5", "url": "https://github.com/broadinstitute/gatk/pull/6802#pullrequestreview-497483269", "createdAt": "2020-09-28T12:58:11Z", "commit": {"oid": "deb363bc7c7049adadb7d56463c728bcbce57e82"}, "state": "COMMENTED", "comments": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOFQxMjo1ODoxMVrOHY8ahA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOFQxMzozMDowM1rOHY9xDA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTkxNzcwMA==", "bodyText": "Don't need to extract currentPosition, can just check that  !currentTruthVariantContext.overlaps(truthVersusEval);\nBy doing this, you also don't need to check yourself that you are still on the same contig, since Locatable::overlaps will check contigs for you.  So you can remove the evaluateNewContig method.", "url": "https://github.com/broadinstitute/gatk/pull/6802#discussion_r495917700", "createdAt": "2020-09-28T12:58:11Z", "author": {"login": "kachulis"}, "path": "src/main/java/org/broadinstitute/hellbender/tools/walkers/validation/ReferenceBlockConcordance.java", "diffHunk": "@@ -131,56 +127,35 @@ protected void apply(TruthVersusEval truthVersusEval, ReadsContext readsContext,\n             evaluateNewContig(truthVersusEval);\n         }\n \n-        // Evaluate only when currently seeing two NON_REF blocks\n-        if (currentTruthVariantContext != null && currentEvalVariantContext != null) {\n-            int blockStart = Math.max(currentTruthVariantContext.getStart(), currentEvalVariantContext.getStart());\n-            int blockEnd = Math.min(currentTruthVariantContext.getEnd(), currentEvalVariantContext.getEnd());\n-            int jointBlockLength = blockEnd - blockStart + 1;\n-            // It is possible that jointBlockLength is negative if there is a gap in one file and the start of a new block in the other file.\n-            // Since there is no overlap though, we can just skip that case.\n-            if (jointBlockLength > 0) {\n-                confidenceConcordanceHistogram.increment(new Pair<>(currentTruthVariantContext.getGenotype(0).getGQ(), currentEvalVariantContext.getGenotype(0).getGQ()).toString(), blockEnd - blockStart + 1);\n-            }\n-\n-            int currentPosition = truthVersusEval.getTruthIfPresentElseEval().getStart();\n-            if (truthVersusEval.hasTruth() || currentPosition >= currentTruthVariantContext.getEnd()) {\n-                currentTruthVariantContext = null;\n-            }\n-            if (truthVersusEval.hasEval() || currentPosition >= currentEvalVariantContext.getEnd()) {\n-                currentEvalVariantContext = null;\n-            }\n-        }\n-\n         // Truth\n-        if (truthVersusEval.hasTruth() && isNonRef(truthVersusEval.getTruth())) {\n+        if (truthVersusEval.hasTruth()) {\n             currentTruthVariantContext = truthVersusEval.getTruth();\n \n-            // The end is inclusive, thus the plus one when calculating the length\n-            int blockLength = truthVersusEval.getTruth().getEnd() - truthVersusEval.getTruth().getStart() + 1;\n-\n-            // TODO can a non_ref block ever have a number of genotypes != 1?\n-            if(truthVersusEval.getTruth().getGenotypes().size() != 1) {\n-                throw new IllegalStateException(String.format(\"The NON_REF block \\\"%s\\\" has more than one genotype, which is not supported.\", truthVersusEval.getTruth().toStringDecodeGenotypes()));\n-            }\n-            Genotype genotype = truthVersusEval.getTruth().getGenotype(0);\n-            int gq = genotype.getGQ();\n-            truthBlockHistogram.increment(new Pair<>(blockLength, gq).toString());\n+            truthBlockHistogram.increment(extractLengthAndGQ(truthVersusEval.getTruth()).toString());\n         }\n \n         // Eval\n-        if (truthVersusEval.hasEval() && isNonRef(truthVersusEval.getEval())) {\n+        if (truthVersusEval.hasEval()) {\n             currentEvalVariantContext = truthVersusEval.getEval();\n \n-            // The end is inclusive, thus the plus one when calculating the length\n-            int blockLength = truthVersusEval.getEval().getEnd() - truthVersusEval.getEval().getStart() + 1;\n+            evalBlockHistogram.increment(extractLengthAndGQ(truthVersusEval.getEval()).toString());\n+        }\n+\n+        final int currentPosition = truthVersusEval.getTruthIfPresentElseEval().getStart();\n+        if (currentTruthVariantContext != null && currentPosition > currentTruthVariantContext.getEnd()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "deb363bc7c7049adadb7d56463c728bcbce57e82"}, "originalPosition": 167}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTkyMTY2MA==", "bodyText": "since you are only using this to get the length on reference, which is a method of Locatable, you don't need to create a SimpleInterval here, since VariantContext is a subclass of Locatable", "url": "https://github.com/broadinstitute/gatk/pull/6802#discussion_r495921660", "createdAt": "2020-09-28T13:03:49Z", "author": {"login": "kachulis"}, "path": "src/main/java/org/broadinstitute/hellbender/tools/walkers/validation/ReferenceBlockConcordance.java", "diffHunk": "@@ -87,41 +89,35 @@\n     @Override\n     protected Predicate<VariantContext> makeTruthVariantFilter() {\n         // Explicitly allow symbolic variants\n-        return VariantContext::isSymbolic;\n+        return this::isHomRef;\n     }\n \n     @Override\n     protected Predicate<VariantContext> makeEvalVariantFilter() {\n         // Explicitly allow symbolic variants\n-        return VariantContext::isSymbolic;\n+        return this::isHomRef;\n     }\n \n-    private boolean isNonRef(VariantContext variantContext) {\n-        return variantContext.isSymbolic() && variantContext.getAlternateAllele(0).isNonRefAllele();\n+    private boolean isHomRef(VariantContext variantContext) {\n+        return variantContext.getGenotypes().get(0).isHomRef();\n     }\n \n-    private void evaluateEndOfContig() {\n-        if (currentTruthVariantContext != null && currentEvalVariantContext != null) {\n-            int blockStart = Math.max(currentTruthVariantContext.getStart(), currentEvalVariantContext.getStart());\n-            int blockEnd = Math.min(currentTruthVariantContext.getEnd(), currentEvalVariantContext.getEnd());\n-            int jointBlockLength = blockEnd - blockStart + 1;\n-            if (jointBlockLength > 0) {\n-                confidenceConcordanceHistogram.increment(new Pair<>(currentTruthVariantContext.getGenotype(0).getGQ(), currentEvalVariantContext.getGenotype(0).getGQ()).toString(), jointBlockLength);\n-            }\n-        }\n-\n+    private void evaluateNewContig(TruthVersusEval truthVersusEval) {\n         currentTruthVariantContext = null;\n         currentEvalVariantContext = null;\n-        currentContig = null;\n+\n+        currentContig = truthVersusEval.getTruthIfPresentElseEval().getContig();\n     }\n \n-    private void evaluateNewContig(TruthVersusEval truthVersusEval) {\n-        // If not beginning of file\n-        if (currentContig != null) {\n-            evaluateEndOfContig();\n-        }\n+    private Pair<Integer, Integer> extractLengthAndGQ(VariantContext variant) {\n+        final SimpleInterval interval = new SimpleInterval(variant);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "deb363bc7c7049adadb7d56463c728bcbce57e82"}, "originalPosition": 102}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTkyMzQ2Ng==", "bodyText": "Do you understand why this number changed from 1034 in the test originally?", "url": "https://github.com/broadinstitute/gatk/pull/6802#discussion_r495923466", "createdAt": "2020-09-28T13:06:30Z", "author": {"login": "kachulis"}, "path": "src/test/java/org/broadinstitute/hellbender/tools/walkers/validation/ReferenceBlockConcordanceIntegrationTest.java", "diffHunk": "@@ -45,91 +49,99 @@ public void testIdentical() throws Exception {\n         };\n         runCommandLine(args);\n \n-        MetricsFile<?, String> truthBlockMetrics = new MetricsFile<>();\n+        final MetricsFile<?, String> truthBlockMetrics = new MetricsFile<>();\n         truthBlockMetrics.read(new FileReader(truthBlockHistogramFile.toFile()));\n-        MetricsFile<?, String> evalBlockMetrics = new MetricsFile<>();\n+        final MetricsFile<?, String> evalBlockMetrics = new MetricsFile<>();\n         evalBlockMetrics.read(new FileReader(evalBlockHistogramFile.toFile()));\n \n         Assert.assertEquals(truthBlockMetrics.getNumHistograms(), 1);\n         Assert.assertEquals(evalBlockMetrics.getNumHistograms(), 1);\n \n-        Histogram<String> truthBlockHistogram = truthBlockMetrics.getHistogram();\n-        Histogram<String> evalBlockHistogram = evalBlockMetrics.getHistogram();\n+        final Histogram<String> truthBlockHistogram = truthBlockMetrics.getHistogram();\n+        final Histogram<String> evalBlockHistogram = evalBlockMetrics.getHistogram();\n \n         // Got this number by counting the <NON_REF> alt alleles in the test GVCF file\n-        Assert.assertEquals(truthBlockHistogram.getSumOfValues(), 1034);\n-        Assert.assertEquals(evalBlockHistogram.getSumOfValues(), 1034);\n+        Assert.assertEquals(truthBlockHistogram.getSumOfValues(), 1038);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "deb363bc7c7049adadb7d56463c728bcbce57e82"}, "originalPosition": 61}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTkzMzIwNw==", "bodyText": "Use static Allele fields and pass as Allele instead of as String", "url": "https://github.com/broadinstitute/gatk/pull/6802#discussion_r495933207", "createdAt": "2020-09-28T13:20:39Z", "author": {"login": "kachulis"}, "path": "src/test/java/org/broadinstitute/hellbender/tools/walkers/validation/ReferenceBlockConcordanceIntegrationTest.java", "diffHunk": "@@ -45,91 +49,99 @@ public void testIdentical() throws Exception {\n         };\n         runCommandLine(args);\n \n-        MetricsFile<?, String> truthBlockMetrics = new MetricsFile<>();\n+        final MetricsFile<?, String> truthBlockMetrics = new MetricsFile<>();\n         truthBlockMetrics.read(new FileReader(truthBlockHistogramFile.toFile()));\n-        MetricsFile<?, String> evalBlockMetrics = new MetricsFile<>();\n+        final MetricsFile<?, String> evalBlockMetrics = new MetricsFile<>();\n         evalBlockMetrics.read(new FileReader(evalBlockHistogramFile.toFile()));\n \n         Assert.assertEquals(truthBlockMetrics.getNumHistograms(), 1);\n         Assert.assertEquals(evalBlockMetrics.getNumHistograms(), 1);\n \n-        Histogram<String> truthBlockHistogram = truthBlockMetrics.getHistogram();\n-        Histogram<String> evalBlockHistogram = evalBlockMetrics.getHistogram();\n+        final Histogram<String> truthBlockHistogram = truthBlockMetrics.getHistogram();\n+        final Histogram<String> evalBlockHistogram = evalBlockMetrics.getHistogram();\n \n         // Got this number by counting the <NON_REF> alt alleles in the test GVCF file\n-        Assert.assertEquals(truthBlockHistogram.getSumOfValues(), 1034);\n-        Assert.assertEquals(evalBlockHistogram.getSumOfValues(), 1034);\n+        Assert.assertEquals(truthBlockHistogram.getSumOfValues(), 1038);\n+        Assert.assertEquals(evalBlockHistogram.getSumOfValues(), 1038);\n \n-        // Check block histograms both ways, in case one histogram has more entries than the other\n-        truthBlockHistogram.values().forEach(bin -> {\n-            Assert.assertTrue(evalBlockHistogram.containsKey(bin.getId()));\n-            Assert.assertEquals(bin.getValue(), evalBlockHistogram.get(bin.getId()).getValue());\n-        });\n-\n-        evalBlockHistogram.values().forEach(bin -> {\n-            Assert.assertTrue(truthBlockHistogram.containsKey(bin.getId()));\n-            Assert.assertEquals(bin.getValue(), truthBlockHistogram.get(bin.getId()).getValue());\n-        });\n+        Assert.assertEquals(truthBlockHistogram, evalBlockHistogram);\n \n-        MetricsFile<?, String> confidenceConcordanceMetrics = new MetricsFile<>();\n+        // For confidence concordance, check that there are only values on the diagonal\n+        final MetricsFile<?, String> confidenceConcordanceMetrics = new MetricsFile<>();\n         confidenceConcordanceMetrics.read(new FileReader(confidenceConcordanceHistogramFile.toFile()));\n         Assert.assertEquals(confidenceConcordanceMetrics.getNumHistograms(), 1);\n-        Histogram<String> confidenceConcordanceHistogram = confidenceConcordanceMetrics.getHistogram();\n-\n+        final Histogram<String> confidenceConcordanceHistogram = confidenceConcordanceMetrics.getHistogram();\n         confidenceConcordanceHistogram.values().forEach(bin -> {\n-            String[] confidenceValues = bin.getId().split(\",\");\n+            final String[] confidenceValues = bin.getId().split(\",\");\n             Assert.assertEquals(confidenceValues[0], confidenceValues[1]);\n         });\n     }\n \n-    private Pair<File, File> writeTestGVCFs(List<TestReferenceBlockConcordanceVariant> truthVariants, List<TestReferenceBlockConcordanceVariant> evalVariants) throws Exception {\n-        File truthFile = createTempFile(\"truth\", \".gvcf\");\n-        FileWriter writer = new FileWriter(truthFile);\n-        writer.write(\"##fileformat=VCFv4.2\\n\");\n-        writer.write(\"##contig=<ID=test_contig,length=1000>\\n\");\n-        writer.write(\"#CHROM\\tPOS\\tID\\tREF\\tALT\\tQUAL\\tFILTER\\tINFO\\tFORMAT\\tTESTSAMPLE\\n\");\n-        for (TestReferenceBlockConcordanceVariant variant : truthVariants) {\n-            writer.write(String.format(\"test_contig\\t%s\\t.\\tA\\t%s\\t%s\\t.\\t%s\\tGT:GQ\\t%s:%s\\n\",\n-                    variant.start,\n-                    variant.getAltAllele(),\n-                    variant.getAltAllele().equals(\"<NON_REF>\") ? \".\" : \"1\",\n-                    variant.getAltAllele().equals(\"<NON_REF>\") ? String.format(\"END=%s\", variant.getStop()) : \".\",\n-                    variant.getAltAllele().equals(\"<NON_REF>\") ? \"0/0\" : \"0/1\",\n-                    variant.getConfidence()));\n-        }\n-        writer.close();\n-\n-        File evalFile = createTempFile(\"eval\", \".gvcf\");\n-        writer = new FileWriter(evalFile);\n-        writer.write(\"##fileformat=VCFv4.2\\n\");\n-        writer.write(\"##contig=<ID=test_contig,length=1000>\\n\");\n-        writer.write(\"#CHROM\\tPOS\\tID\\tREF\\tALT\\tQUAL\\tFILTER\\tINFO\\tFORMAT\\tTESTSAMPLE\\n\");\n-        for (TestReferenceBlockConcordanceVariant variant : evalVariants) {\n-            writer.write(String.format(\"test_contig\\t%s\\t.\\tA\\t%s\\t%s\\t.\\t%s\\tGT:GQ\\t%s:%s\\n\",\n-                    variant.start,\n-                    variant.getAltAllele(),\n-                    variant.getAltAllele().equals(\"<NON_REF>\") ? \".\" : \"1\",\n-                    variant.getAltAllele().equals(\"<NON_REF>\") ? String.format(\"END=%s\", variant.getStop()) : \".\",\n-                    variant.getAltAllele().equals(\"<NON_REF>\") ? \"0/0\" : \"0/1\",\n-                    variant.getConfidence()));\n-        }\n-        writer.close();\n+    private Pair<File, File> writeTestGVCFs(List<VariantContext> truthVariants, List<VariantContext> evalVariants) {\n+        final File truthFile = createTempFile(\"truth\", \".gvcf\");\n+        final GVCFWriter truthWriter = new GVCFWriter(\n+                GATKVariantContextUtils.createVCFWriter(truthFile.toPath(), null, false, Options.ALLOW_MISSING_FIELDS_IN_HEADER),\n+                IntStream.range(1, 100).boxed().collect(Collectors.toList()),\n+                2,\n+                true\n+                );\n+        truthWriter.writeHeader(new VCFHeader(new HashSet<>(Arrays.asList(\n+                new VCFHeaderLine(\"fileformat\", \"VCFv4.2\"),\n+                new VCFHeaderLine(\"contig\", \"<ID=test_contig,length=1000>\")\n+            )), Collections.singletonList(\"TESTSAMPLE\")));\n+\n+        truthVariants.forEach(truthWriter::add);\n+        truthWriter.close();\n+\n+        final File evalFile = createTempFile(\"eval\", \".gvcf\");\n+        final GVCFWriter evalWriter = new GVCFWriter(\n+                GATKVariantContextUtils.createVCFWriter(evalFile.toPath(), null, false, Options.ALLOW_MISSING_FIELDS_IN_HEADER),\n+                IntStream.range(1, 100).boxed().collect(Collectors.toList()),\n+                2,\n+                true\n+        );\n+        evalWriter.writeHeader(new VCFHeader(new HashSet<>(Arrays.asList(\n+                new VCFHeaderLine(\"fileformat\", \"VCFv4.2\"),\n+                new VCFHeaderLine(\"contig\", \"<ID=test_contig,length=1000>\")\n+        )), Collections.singletonList(\"TESTSAMPLE\")));\n+\n+        evalVariants.forEach(evalWriter::add);\n+        evalWriter.close();\n \n         return new Pair<>(truthFile, evalFile);\n     }\n \n+    private static VariantContext constructTestVariantContext(final String altAllele, final int start, final int stop, final int confidence) {\n+        final boolean isNonRef = altAllele.equals(\"<NON_REF>\");\n+        final Allele refAllele = Allele.create(\"A\", true);\n+        final List<Allele> alleles = Arrays.asList(\n+                refAllele,\n+                isNonRef ? Allele.NON_REF_ALLELE : Allele.create(altAllele)\n+        );\n+        final VariantContextBuilder variantContextBuilder = new VariantContextBuilder(\"TEST\", \"test_contig\", start, stop, alleles);\n+        final GenotypeBuilder genotypeBuilder = new GenotypeBuilder(\"TESTSAMPLE\", isNonRef ? GATKVariantContextUtils.homozygousAlleleList(refAllele, 2) : alleles);\n+        if (isNonRef) {\n+            genotypeBuilder.GQ(confidence);\n+            genotypeBuilder.PL(new int[] { 0, 0, 0 });\n+            variantContextBuilder.attribute(VCFConstants.END_KEY, stop);\n+        }\n+        final Genotype gt = genotypeBuilder.DP(30).make();\n+        variantContextBuilder.genotypes(gt);\n+        return variantContextBuilder.make();\n+    }\n+\n     @DataProvider\n     public Object[][] provideSyntheticGVCFs() {\n         return new Object[][] {\n                 // No non_ref blocks\n                 {\n                         // Truth variants\n                         Arrays.asList(\n-                                new TestReferenceBlockConcordanceVariant(\"C\", 1, 1, 99)\n+                                constructTestVariantContext(\"C\", 1, 1, 99)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "deb363bc7c7049adadb7d56463c728bcbce57e82"}, "originalPosition": 184}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTkzNzY3Ng==", "bodyText": "if you pass a SAMSequenceDictionary to the constructor here (like new SAMSequenceDictionary(Collections.singletonList(new SAMSequenceRecord(\"test_contig\", 1000)))) then you don't need to add the dictionary line by hand to the header below.", "url": "https://github.com/broadinstitute/gatk/pull/6802#discussion_r495937676", "createdAt": "2020-09-28T13:26:56Z", "author": {"login": "kachulis"}, "path": "src/test/java/org/broadinstitute/hellbender/tools/walkers/validation/ReferenceBlockConcordanceIntegrationTest.java", "diffHunk": "@@ -45,91 +49,99 @@ public void testIdentical() throws Exception {\n         };\n         runCommandLine(args);\n \n-        MetricsFile<?, String> truthBlockMetrics = new MetricsFile<>();\n+        final MetricsFile<?, String> truthBlockMetrics = new MetricsFile<>();\n         truthBlockMetrics.read(new FileReader(truthBlockHistogramFile.toFile()));\n-        MetricsFile<?, String> evalBlockMetrics = new MetricsFile<>();\n+        final MetricsFile<?, String> evalBlockMetrics = new MetricsFile<>();\n         evalBlockMetrics.read(new FileReader(evalBlockHistogramFile.toFile()));\n \n         Assert.assertEquals(truthBlockMetrics.getNumHistograms(), 1);\n         Assert.assertEquals(evalBlockMetrics.getNumHistograms(), 1);\n \n-        Histogram<String> truthBlockHistogram = truthBlockMetrics.getHistogram();\n-        Histogram<String> evalBlockHistogram = evalBlockMetrics.getHistogram();\n+        final Histogram<String> truthBlockHistogram = truthBlockMetrics.getHistogram();\n+        final Histogram<String> evalBlockHistogram = evalBlockMetrics.getHistogram();\n \n         // Got this number by counting the <NON_REF> alt alleles in the test GVCF file\n-        Assert.assertEquals(truthBlockHistogram.getSumOfValues(), 1034);\n-        Assert.assertEquals(evalBlockHistogram.getSumOfValues(), 1034);\n+        Assert.assertEquals(truthBlockHistogram.getSumOfValues(), 1038);\n+        Assert.assertEquals(evalBlockHistogram.getSumOfValues(), 1038);\n \n-        // Check block histograms both ways, in case one histogram has more entries than the other\n-        truthBlockHistogram.values().forEach(bin -> {\n-            Assert.assertTrue(evalBlockHistogram.containsKey(bin.getId()));\n-            Assert.assertEquals(bin.getValue(), evalBlockHistogram.get(bin.getId()).getValue());\n-        });\n-\n-        evalBlockHistogram.values().forEach(bin -> {\n-            Assert.assertTrue(truthBlockHistogram.containsKey(bin.getId()));\n-            Assert.assertEquals(bin.getValue(), truthBlockHistogram.get(bin.getId()).getValue());\n-        });\n+        Assert.assertEquals(truthBlockHistogram, evalBlockHistogram);\n \n-        MetricsFile<?, String> confidenceConcordanceMetrics = new MetricsFile<>();\n+        // For confidence concordance, check that there are only values on the diagonal\n+        final MetricsFile<?, String> confidenceConcordanceMetrics = new MetricsFile<>();\n         confidenceConcordanceMetrics.read(new FileReader(confidenceConcordanceHistogramFile.toFile()));\n         Assert.assertEquals(confidenceConcordanceMetrics.getNumHistograms(), 1);\n-        Histogram<String> confidenceConcordanceHistogram = confidenceConcordanceMetrics.getHistogram();\n-\n+        final Histogram<String> confidenceConcordanceHistogram = confidenceConcordanceMetrics.getHistogram();\n         confidenceConcordanceHistogram.values().forEach(bin -> {\n-            String[] confidenceValues = bin.getId().split(\",\");\n+            final String[] confidenceValues = bin.getId().split(\",\");\n             Assert.assertEquals(confidenceValues[0], confidenceValues[1]);\n         });\n     }\n \n-    private Pair<File, File> writeTestGVCFs(List<TestReferenceBlockConcordanceVariant> truthVariants, List<TestReferenceBlockConcordanceVariant> evalVariants) throws Exception {\n-        File truthFile = createTempFile(\"truth\", \".gvcf\");\n-        FileWriter writer = new FileWriter(truthFile);\n-        writer.write(\"##fileformat=VCFv4.2\\n\");\n-        writer.write(\"##contig=<ID=test_contig,length=1000>\\n\");\n-        writer.write(\"#CHROM\\tPOS\\tID\\tREF\\tALT\\tQUAL\\tFILTER\\tINFO\\tFORMAT\\tTESTSAMPLE\\n\");\n-        for (TestReferenceBlockConcordanceVariant variant : truthVariants) {\n-            writer.write(String.format(\"test_contig\\t%s\\t.\\tA\\t%s\\t%s\\t.\\t%s\\tGT:GQ\\t%s:%s\\n\",\n-                    variant.start,\n-                    variant.getAltAllele(),\n-                    variant.getAltAllele().equals(\"<NON_REF>\") ? \".\" : \"1\",\n-                    variant.getAltAllele().equals(\"<NON_REF>\") ? String.format(\"END=%s\", variant.getStop()) : \".\",\n-                    variant.getAltAllele().equals(\"<NON_REF>\") ? \"0/0\" : \"0/1\",\n-                    variant.getConfidence()));\n-        }\n-        writer.close();\n-\n-        File evalFile = createTempFile(\"eval\", \".gvcf\");\n-        writer = new FileWriter(evalFile);\n-        writer.write(\"##fileformat=VCFv4.2\\n\");\n-        writer.write(\"##contig=<ID=test_contig,length=1000>\\n\");\n-        writer.write(\"#CHROM\\tPOS\\tID\\tREF\\tALT\\tQUAL\\tFILTER\\tINFO\\tFORMAT\\tTESTSAMPLE\\n\");\n-        for (TestReferenceBlockConcordanceVariant variant : evalVariants) {\n-            writer.write(String.format(\"test_contig\\t%s\\t.\\tA\\t%s\\t%s\\t.\\t%s\\tGT:GQ\\t%s:%s\\n\",\n-                    variant.start,\n-                    variant.getAltAllele(),\n-                    variant.getAltAllele().equals(\"<NON_REF>\") ? \".\" : \"1\",\n-                    variant.getAltAllele().equals(\"<NON_REF>\") ? String.format(\"END=%s\", variant.getStop()) : \".\",\n-                    variant.getAltAllele().equals(\"<NON_REF>\") ? \"0/0\" : \"0/1\",\n-                    variant.getConfidence()));\n-        }\n-        writer.close();\n+    private Pair<File, File> writeTestGVCFs(List<VariantContext> truthVariants, List<VariantContext> evalVariants) {\n+        final File truthFile = createTempFile(\"truth\", \".gvcf\");\n+        final GVCFWriter truthWriter = new GVCFWriter(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "deb363bc7c7049adadb7d56463c728bcbce57e82"}, "originalPosition": 125}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTkzODU2Nw==", "bodyText": "same comment about passing a reference dictionary", "url": "https://github.com/broadinstitute/gatk/pull/6802#discussion_r495938567", "createdAt": "2020-09-28T13:28:14Z", "author": {"login": "kachulis"}, "path": "src/test/java/org/broadinstitute/hellbender/tools/walkers/validation/ReferenceBlockConcordanceIntegrationTest.java", "diffHunk": "@@ -45,91 +49,99 @@ public void testIdentical() throws Exception {\n         };\n         runCommandLine(args);\n \n-        MetricsFile<?, String> truthBlockMetrics = new MetricsFile<>();\n+        final MetricsFile<?, String> truthBlockMetrics = new MetricsFile<>();\n         truthBlockMetrics.read(new FileReader(truthBlockHistogramFile.toFile()));\n-        MetricsFile<?, String> evalBlockMetrics = new MetricsFile<>();\n+        final MetricsFile<?, String> evalBlockMetrics = new MetricsFile<>();\n         evalBlockMetrics.read(new FileReader(evalBlockHistogramFile.toFile()));\n \n         Assert.assertEquals(truthBlockMetrics.getNumHistograms(), 1);\n         Assert.assertEquals(evalBlockMetrics.getNumHistograms(), 1);\n \n-        Histogram<String> truthBlockHistogram = truthBlockMetrics.getHistogram();\n-        Histogram<String> evalBlockHistogram = evalBlockMetrics.getHistogram();\n+        final Histogram<String> truthBlockHistogram = truthBlockMetrics.getHistogram();\n+        final Histogram<String> evalBlockHistogram = evalBlockMetrics.getHistogram();\n \n         // Got this number by counting the <NON_REF> alt alleles in the test GVCF file\n-        Assert.assertEquals(truthBlockHistogram.getSumOfValues(), 1034);\n-        Assert.assertEquals(evalBlockHistogram.getSumOfValues(), 1034);\n+        Assert.assertEquals(truthBlockHistogram.getSumOfValues(), 1038);\n+        Assert.assertEquals(evalBlockHistogram.getSumOfValues(), 1038);\n \n-        // Check block histograms both ways, in case one histogram has more entries than the other\n-        truthBlockHistogram.values().forEach(bin -> {\n-            Assert.assertTrue(evalBlockHistogram.containsKey(bin.getId()));\n-            Assert.assertEquals(bin.getValue(), evalBlockHistogram.get(bin.getId()).getValue());\n-        });\n-\n-        evalBlockHistogram.values().forEach(bin -> {\n-            Assert.assertTrue(truthBlockHistogram.containsKey(bin.getId()));\n-            Assert.assertEquals(bin.getValue(), truthBlockHistogram.get(bin.getId()).getValue());\n-        });\n+        Assert.assertEquals(truthBlockHistogram, evalBlockHistogram);\n \n-        MetricsFile<?, String> confidenceConcordanceMetrics = new MetricsFile<>();\n+        // For confidence concordance, check that there are only values on the diagonal\n+        final MetricsFile<?, String> confidenceConcordanceMetrics = new MetricsFile<>();\n         confidenceConcordanceMetrics.read(new FileReader(confidenceConcordanceHistogramFile.toFile()));\n         Assert.assertEquals(confidenceConcordanceMetrics.getNumHistograms(), 1);\n-        Histogram<String> confidenceConcordanceHistogram = confidenceConcordanceMetrics.getHistogram();\n-\n+        final Histogram<String> confidenceConcordanceHistogram = confidenceConcordanceMetrics.getHistogram();\n         confidenceConcordanceHistogram.values().forEach(bin -> {\n-            String[] confidenceValues = bin.getId().split(\",\");\n+            final String[] confidenceValues = bin.getId().split(\",\");\n             Assert.assertEquals(confidenceValues[0], confidenceValues[1]);\n         });\n     }\n \n-    private Pair<File, File> writeTestGVCFs(List<TestReferenceBlockConcordanceVariant> truthVariants, List<TestReferenceBlockConcordanceVariant> evalVariants) throws Exception {\n-        File truthFile = createTempFile(\"truth\", \".gvcf\");\n-        FileWriter writer = new FileWriter(truthFile);\n-        writer.write(\"##fileformat=VCFv4.2\\n\");\n-        writer.write(\"##contig=<ID=test_contig,length=1000>\\n\");\n-        writer.write(\"#CHROM\\tPOS\\tID\\tREF\\tALT\\tQUAL\\tFILTER\\tINFO\\tFORMAT\\tTESTSAMPLE\\n\");\n-        for (TestReferenceBlockConcordanceVariant variant : truthVariants) {\n-            writer.write(String.format(\"test_contig\\t%s\\t.\\tA\\t%s\\t%s\\t.\\t%s\\tGT:GQ\\t%s:%s\\n\",\n-                    variant.start,\n-                    variant.getAltAllele(),\n-                    variant.getAltAllele().equals(\"<NON_REF>\") ? \".\" : \"1\",\n-                    variant.getAltAllele().equals(\"<NON_REF>\") ? String.format(\"END=%s\", variant.getStop()) : \".\",\n-                    variant.getAltAllele().equals(\"<NON_REF>\") ? \"0/0\" : \"0/1\",\n-                    variant.getConfidence()));\n-        }\n-        writer.close();\n-\n-        File evalFile = createTempFile(\"eval\", \".gvcf\");\n-        writer = new FileWriter(evalFile);\n-        writer.write(\"##fileformat=VCFv4.2\\n\");\n-        writer.write(\"##contig=<ID=test_contig,length=1000>\\n\");\n-        writer.write(\"#CHROM\\tPOS\\tID\\tREF\\tALT\\tQUAL\\tFILTER\\tINFO\\tFORMAT\\tTESTSAMPLE\\n\");\n-        for (TestReferenceBlockConcordanceVariant variant : evalVariants) {\n-            writer.write(String.format(\"test_contig\\t%s\\t.\\tA\\t%s\\t%s\\t.\\t%s\\tGT:GQ\\t%s:%s\\n\",\n-                    variant.start,\n-                    variant.getAltAllele(),\n-                    variant.getAltAllele().equals(\"<NON_REF>\") ? \".\" : \"1\",\n-                    variant.getAltAllele().equals(\"<NON_REF>\") ? String.format(\"END=%s\", variant.getStop()) : \".\",\n-                    variant.getAltAllele().equals(\"<NON_REF>\") ? \"0/0\" : \"0/1\",\n-                    variant.getConfidence()));\n-        }\n-        writer.close();\n+    private Pair<File, File> writeTestGVCFs(List<VariantContext> truthVariants, List<VariantContext> evalVariants) {\n+        final File truthFile = createTempFile(\"truth\", \".gvcf\");\n+        final GVCFWriter truthWriter = new GVCFWriter(\n+                GATKVariantContextUtils.createVCFWriter(truthFile.toPath(), null, false, Options.ALLOW_MISSING_FIELDS_IN_HEADER),\n+                IntStream.range(1, 100).boxed().collect(Collectors.toList()),\n+                2,\n+                true\n+                );\n+        truthWriter.writeHeader(new VCFHeader(new HashSet<>(Arrays.asList(\n+                new VCFHeaderLine(\"fileformat\", \"VCFv4.2\"),\n+                new VCFHeaderLine(\"contig\", \"<ID=test_contig,length=1000>\")\n+            )), Collections.singletonList(\"TESTSAMPLE\")));\n+\n+        truthVariants.forEach(truthWriter::add);\n+        truthWriter.close();\n+\n+        final File evalFile = createTempFile(\"eval\", \".gvcf\");\n+        final GVCFWriter evalWriter = new GVCFWriter(\n+                GATKVariantContextUtils.createVCFWriter(evalFile.toPath(), null, false, Options.ALLOW_MISSING_FIELDS_IN_HEADER),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "deb363bc7c7049adadb7d56463c728bcbce57e82"}, "originalPosition": 141}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTkzOTg1Mg==", "bodyText": "passing an Allele instead of a String will allow you to just use Allele::isNonReference", "url": "https://github.com/broadinstitute/gatk/pull/6802#discussion_r495939852", "createdAt": "2020-09-28T13:30:03Z", "author": {"login": "kachulis"}, "path": "src/test/java/org/broadinstitute/hellbender/tools/walkers/validation/ReferenceBlockConcordanceIntegrationTest.java", "diffHunk": "@@ -45,91 +49,99 @@ public void testIdentical() throws Exception {\n         };\n         runCommandLine(args);\n \n-        MetricsFile<?, String> truthBlockMetrics = new MetricsFile<>();\n+        final MetricsFile<?, String> truthBlockMetrics = new MetricsFile<>();\n         truthBlockMetrics.read(new FileReader(truthBlockHistogramFile.toFile()));\n-        MetricsFile<?, String> evalBlockMetrics = new MetricsFile<>();\n+        final MetricsFile<?, String> evalBlockMetrics = new MetricsFile<>();\n         evalBlockMetrics.read(new FileReader(evalBlockHistogramFile.toFile()));\n \n         Assert.assertEquals(truthBlockMetrics.getNumHistograms(), 1);\n         Assert.assertEquals(evalBlockMetrics.getNumHistograms(), 1);\n \n-        Histogram<String> truthBlockHistogram = truthBlockMetrics.getHistogram();\n-        Histogram<String> evalBlockHistogram = evalBlockMetrics.getHistogram();\n+        final Histogram<String> truthBlockHistogram = truthBlockMetrics.getHistogram();\n+        final Histogram<String> evalBlockHistogram = evalBlockMetrics.getHistogram();\n \n         // Got this number by counting the <NON_REF> alt alleles in the test GVCF file\n-        Assert.assertEquals(truthBlockHistogram.getSumOfValues(), 1034);\n-        Assert.assertEquals(evalBlockHistogram.getSumOfValues(), 1034);\n+        Assert.assertEquals(truthBlockHistogram.getSumOfValues(), 1038);\n+        Assert.assertEquals(evalBlockHistogram.getSumOfValues(), 1038);\n \n-        // Check block histograms both ways, in case one histogram has more entries than the other\n-        truthBlockHistogram.values().forEach(bin -> {\n-            Assert.assertTrue(evalBlockHistogram.containsKey(bin.getId()));\n-            Assert.assertEquals(bin.getValue(), evalBlockHistogram.get(bin.getId()).getValue());\n-        });\n-\n-        evalBlockHistogram.values().forEach(bin -> {\n-            Assert.assertTrue(truthBlockHistogram.containsKey(bin.getId()));\n-            Assert.assertEquals(bin.getValue(), truthBlockHistogram.get(bin.getId()).getValue());\n-        });\n+        Assert.assertEquals(truthBlockHistogram, evalBlockHistogram);\n \n-        MetricsFile<?, String> confidenceConcordanceMetrics = new MetricsFile<>();\n+        // For confidence concordance, check that there are only values on the diagonal\n+        final MetricsFile<?, String> confidenceConcordanceMetrics = new MetricsFile<>();\n         confidenceConcordanceMetrics.read(new FileReader(confidenceConcordanceHistogramFile.toFile()));\n         Assert.assertEquals(confidenceConcordanceMetrics.getNumHistograms(), 1);\n-        Histogram<String> confidenceConcordanceHistogram = confidenceConcordanceMetrics.getHistogram();\n-\n+        final Histogram<String> confidenceConcordanceHistogram = confidenceConcordanceMetrics.getHistogram();\n         confidenceConcordanceHistogram.values().forEach(bin -> {\n-            String[] confidenceValues = bin.getId().split(\",\");\n+            final String[] confidenceValues = bin.getId().split(\",\");\n             Assert.assertEquals(confidenceValues[0], confidenceValues[1]);\n         });\n     }\n \n-    private Pair<File, File> writeTestGVCFs(List<TestReferenceBlockConcordanceVariant> truthVariants, List<TestReferenceBlockConcordanceVariant> evalVariants) throws Exception {\n-        File truthFile = createTempFile(\"truth\", \".gvcf\");\n-        FileWriter writer = new FileWriter(truthFile);\n-        writer.write(\"##fileformat=VCFv4.2\\n\");\n-        writer.write(\"##contig=<ID=test_contig,length=1000>\\n\");\n-        writer.write(\"#CHROM\\tPOS\\tID\\tREF\\tALT\\tQUAL\\tFILTER\\tINFO\\tFORMAT\\tTESTSAMPLE\\n\");\n-        for (TestReferenceBlockConcordanceVariant variant : truthVariants) {\n-            writer.write(String.format(\"test_contig\\t%s\\t.\\tA\\t%s\\t%s\\t.\\t%s\\tGT:GQ\\t%s:%s\\n\",\n-                    variant.start,\n-                    variant.getAltAllele(),\n-                    variant.getAltAllele().equals(\"<NON_REF>\") ? \".\" : \"1\",\n-                    variant.getAltAllele().equals(\"<NON_REF>\") ? String.format(\"END=%s\", variant.getStop()) : \".\",\n-                    variant.getAltAllele().equals(\"<NON_REF>\") ? \"0/0\" : \"0/1\",\n-                    variant.getConfidence()));\n-        }\n-        writer.close();\n-\n-        File evalFile = createTempFile(\"eval\", \".gvcf\");\n-        writer = new FileWriter(evalFile);\n-        writer.write(\"##fileformat=VCFv4.2\\n\");\n-        writer.write(\"##contig=<ID=test_contig,length=1000>\\n\");\n-        writer.write(\"#CHROM\\tPOS\\tID\\tREF\\tALT\\tQUAL\\tFILTER\\tINFO\\tFORMAT\\tTESTSAMPLE\\n\");\n-        for (TestReferenceBlockConcordanceVariant variant : evalVariants) {\n-            writer.write(String.format(\"test_contig\\t%s\\t.\\tA\\t%s\\t%s\\t.\\t%s\\tGT:GQ\\t%s:%s\\n\",\n-                    variant.start,\n-                    variant.getAltAllele(),\n-                    variant.getAltAllele().equals(\"<NON_REF>\") ? \".\" : \"1\",\n-                    variant.getAltAllele().equals(\"<NON_REF>\") ? String.format(\"END=%s\", variant.getStop()) : \".\",\n-                    variant.getAltAllele().equals(\"<NON_REF>\") ? \"0/0\" : \"0/1\",\n-                    variant.getConfidence()));\n-        }\n-        writer.close();\n+    private Pair<File, File> writeTestGVCFs(List<VariantContext> truthVariants, List<VariantContext> evalVariants) {\n+        final File truthFile = createTempFile(\"truth\", \".gvcf\");\n+        final GVCFWriter truthWriter = new GVCFWriter(\n+                GATKVariantContextUtils.createVCFWriter(truthFile.toPath(), null, false, Options.ALLOW_MISSING_FIELDS_IN_HEADER),\n+                IntStream.range(1, 100).boxed().collect(Collectors.toList()),\n+                2,\n+                true\n+                );\n+        truthWriter.writeHeader(new VCFHeader(new HashSet<>(Arrays.asList(\n+                new VCFHeaderLine(\"fileformat\", \"VCFv4.2\"),\n+                new VCFHeaderLine(\"contig\", \"<ID=test_contig,length=1000>\")\n+            )), Collections.singletonList(\"TESTSAMPLE\")));\n+\n+        truthVariants.forEach(truthWriter::add);\n+        truthWriter.close();\n+\n+        final File evalFile = createTempFile(\"eval\", \".gvcf\");\n+        final GVCFWriter evalWriter = new GVCFWriter(\n+                GATKVariantContextUtils.createVCFWriter(evalFile.toPath(), null, false, Options.ALLOW_MISSING_FIELDS_IN_HEADER),\n+                IntStream.range(1, 100).boxed().collect(Collectors.toList()),\n+                2,\n+                true\n+        );\n+        evalWriter.writeHeader(new VCFHeader(new HashSet<>(Arrays.asList(\n+                new VCFHeaderLine(\"fileformat\", \"VCFv4.2\"),\n+                new VCFHeaderLine(\"contig\", \"<ID=test_contig,length=1000>\")\n+        )), Collections.singletonList(\"TESTSAMPLE\")));\n+\n+        evalVariants.forEach(evalWriter::add);\n+        evalWriter.close();\n \n         return new Pair<>(truthFile, evalFile);\n     }\n \n+    private static VariantContext constructTestVariantContext(final String altAllele, final int start, final int stop, final int confidence) {\n+        final boolean isNonRef = altAllele.equals(\"<NON_REF>\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "deb363bc7c7049adadb7d56463c728bcbce57e82"}, "originalPosition": 158}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6c79f60a71a7473d9d069c7a5943b0d8d437c057", "author": {"user": {"login": "michaelgatzen", "name": null}}, "url": "https://github.com/broadinstitute/gatk/commit/6c79f60a71a7473d9d069c7a5943b0d8d437c057", "committedDate": "2020-10-05T09:21:27Z", "message": "Incorporated second round of PR comments\n\n- Also added new integration test to verify functionality when encountering multiple contigs"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTAyMjc4NTM3", "url": "https://github.com/broadinstitute/gatk/pull/6802#pullrequestreview-502278537", "createdAt": "2020-10-05T17:39:45Z", "commit": {"oid": "6c79f60a71a7473d9d069c7a5943b0d8d437c057"}, "state": "APPROVED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNVQxNzozOTo0NlrOHcnN_w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNVQxNzozOTo0NlrOHcnN_w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTc2NDczNQ==", "bodyText": "currentPosition now unused, can be removed", "url": "https://github.com/broadinstitute/gatk/pull/6802#discussion_r499764735", "createdAt": "2020-10-05T17:39:46Z", "author": {"login": "kachulis"}, "path": "src/main/java/org/broadinstitute/hellbender/tools/walkers/validation/ReferenceBlockConcordance.java", "diffHunk": "@@ -142,10 +127,10 @@ protected void apply(TruthVersusEval truthVersusEval, ReadsContext readsContext,\n         }\n \n         final int currentPosition = truthVersusEval.getTruthIfPresentElseEval().getStart();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6c79f60a71a7473d9d069c7a5943b0d8d437c057"}, "originalPosition": 36}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "15bed5962e567cf983b2b8958416e059d814303c", "author": {"user": {"login": "michaelgatzen", "name": null}}, "url": "https://github.com/broadinstitute/gatk/commit/15bed5962e567cf983b2b8958416e059d814303c", "committedDate": "2020-10-06T09:36:31Z", "message": "Final cleanup"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2466, "cost": 1, "resetAt": "2021-11-01T13:07:16Z"}}}