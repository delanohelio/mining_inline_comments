{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTE1NDUwMjM5", "number": 6937, "reviewThreads": {"totalCount": 12, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMFQxNjo1MzowNlrOE3UXjQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOFQxODozNjo1MVrOE6tg3Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI2NDQwODQ1OnYy", "diffSide": "RIGHT", "path": "src/test/resources/org/broadinstitute/hellbender/tools/walkers/CombineGVCFs/newMQcalc.combined.g.vcf", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMFQxNjo1MzowNlrOHwl_IA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMFQxNjo1MzowNlrOHwl_IA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDcxNjA2NA==", "bodyText": "I'm mildly surprised that htsjdk will generate .|., but I don't object.  On the whole the PGT makes this extended combined GVCF format so much easier for me to parse visually.", "url": "https://github.com/broadinstitute/gatk/pull/6937#discussion_r520716064", "createdAt": "2020-11-10T16:53:06Z", "author": {"login": "ldgauthier"}, "path": "src/test/resources/org/broadinstitute/hellbender/tools/walkers/CombineGVCFs/newMQcalc.combined.g.vcf", "diffHunk": "@@ -7792,23 +7792,23 @@\n 20\t10068151\t.\tA\t<NON_REF>\t.\t.\tEND=10068154\tGT:DP:GQ:MIN_DP:PL\t./.:29:63:28:0,63,945\t./.:31:57:30:0,57,855\n 20\t10068155\t.\tA\t<NON_REF>\t.\t.\t.\tGT:DP:GQ:MIN_DP:PL\t./.:29:63:28:0,63,945\t./.:30:47:30:0,47,863\n 20\t10068156\t.\tA\t<NON_REF>\t.\t.\tEND=10068157\tGT:DP:GQ:MIN_DP:PL\t./.:27:57:27:0,57,855\t./.:34:51:33:0,51,765\n-20\t10068158\t.\tGTGTATATATATA\tG,<NON_REF>\t.\t.\tBaseQRankSum=-8.420e-01;DP=59;ExcessHet=3.01;MQRankSum=0.328;RAW_MQandDP=89764,28;ReadPosRankSum=0.524\tGT:AD:DP:GQ:MIN_DP:PL:SB\t./.:3,4,0:7:57:.:105,0,57,114,69,183:0,3,2,2\t./.:.:31:54:31:0,54,810,54,810,810\n-20\t10068159\t.\tT\t*,<NON_REF>\t.\t.\tDP=60\tGT:AD:DP:GQ:MIN_DP:PL:SB\t./.:3,4,0:7:57:.:105,0,57,114,69,183:0,3,2,2\t./.:.:33:45:32:0,45,675,45,675,675\n-20\t10068160\t.\tGTATATATATATGTA\tG,*,<NON_REF>\t.\t.\tDP=64;ExcessHet=3.01;RAW_MQandDP=101405,32\tGT:AD:DP:GQ:MIN_DP:PL:SB\t./.:0,2,4,0:6:53:.:706,158,131,98,0,53,489,171,104,458:0,0,2,4\t./.:.:33:45:32:0,45,675,45,675,675,45,675,675,675\n-20\t10068161\t.\tT\t*,<NON_REF>\t.\t.\tDP=63\tGT:AD:DP:GQ:MIN_DP:PL:SB\t./.:0,4,0:6:53:.:706,98,53,489,104,458:0,0,2,4\t./.:.:32:6:31:0,6,90,6,90,90\n-20\t10068162\t.\tA\t*,<NON_REF>\t.\t.\tDP=63\tGT:AD:DP:GQ:MIN_DP:PL:SB\t./.:0,4,0:6:53:.:706,98,53,489,104,458:0,0,2,4\t./.:.:32:6:31:0,6,90,6,90,90\n-20\t10068163\t.\tT\t*,<NON_REF>\t.\t.\tDP=63\tGT:AD:DP:GQ:MIN_DP:PL:SB\t./.:0,4,0:6:53:.:706,98,53,489,104,458:0,0,2,4\t./.:.:32:6:31:0,6,90,6,90,90\n-20\t10068164\t.\tA\t*,<NON_REF>\t.\t.\tDP=63\tGT:AD:DP:GQ:MIN_DP:PL:SB\t./.:0,4,0:6:53:.:706,98,53,489,104,458:0,0,2,4\t./.:.:32:6:31:0,6,90,6,90,90\n-20\t10068165\t.\tT\t*,<NON_REF>\t.\t.\tDP=63\tGT:AD:DP:GQ:MIN_DP:PL:SB\t./.:0,4,0:6:53:.:706,98,53,489,104,458:0,0,2,4\t./.:.:32:6:31:0,6,90,6,90,90\n-20\t10068166\t.\tATATATG\tA,*,<NON_REF>\t.\t.\tBaseQRankSum=-9.800e-01;ClippingRankSum=0.00;DP=57;ExcessHet=3.01;MQRankSum=0.00;RAW_MQandDP=88000,25;ReadPosRankSum=-6.600e-01\tGT:AD:DP:GQ:PGT:PID:PL:PS:SB\t./.:0,0,4,0:6:53:.:.:706,489,458,98,104,53,489,458,104,458:.:0,0,2,4\t./.:2,9,0,0:11:22:0|1:10068166_ATATATG_A:218,0,22,224,49,273,224,49,273,273:10068166:2,0,3,6\n-20\t10068167\t.\tT\t*,<NON_REF>\t.\t.\tDP=57\tGT:AD:DP:GQ:PGT:PID:PL:PS:SB\t./.:0,4,0:6:53:.:.:706,98,53,489,104,458:.:0,0,2,4\t./.:2,9,0:11:22:0|1:10068166_ATATATG_A:218,0,22,224,49,273:10068166:2,0,3,6\n-20\t10068168\t.\tATATG\tA,*,<NON_REF>\t.\t.\tBaseQRankSum=0.447;ClippingRankSum=0.00;DP=57;ExcessHet=3.01;MQRankSum=0.00;RAW_MQandDP=88000,25;ReadPosRankSum=0.660\tGT:AD:DP:GQ:PGT:PID:PL:PS:SB\t./.:0,0,4,0:6:53:.:.:706,489,458,98,104,53,489,458,104,458:.:0,0,2,4\t./.:9,2,0,0:11:22:1|0:10068166_ATATATG_A:22,0,218,49,224,273,49,224,273,273:10068166:3,6,2,0\n-20\t10068169\t.\tT\t*,<NON_REF>\t.\t.\tDP=57\tGT:AD:DP:GQ:PGT:PID:PL:PS:SB\t./.:0,4,0:6:53:.:.:706,98,53,489,104,458:.:0,0,2,4\t./.:9,2,0:11:22:1|0:10068166_ATATATG_A:22,0,218,49,224,273:10068166:3,6,2,0\n-20\t10068170\t.\tA\t*,<NON_REF>\t.\t.\tDP=57\tGT:AD:DP:GQ:PGT:PID:PL:PS:SB\t./.:0,4,0:6:53:.:.:706,98,53,489,104,458:.:0,0,2,4\t./.:9,2,0:11:22:1|0:10068166_ATATATG_A:22,0,218,49,224,273:10068166:3,6,2,0\n-20\t10068171\t.\tT\t*,<NON_REF>\t.\t.\tDP=57\tGT:AD:DP:GQ:PGT:PID:PL:PS:SB\t./.:0,4,0:6:53:.:.:706,98,53,489,104,458:.:0,0,2,4\t./.:9,2,0:11:22:1|0:10068166_ATATATG_A:22,0,218,49,224,273:10068166:3,6,2,0\n-20\t10068172\t.\tG\t*,<NON_REF>\t.\t.\tDP=57\tGT:AD:DP:GQ:PGT:PID:PL:PS:SB\t./.:0,4,0:6:53:.:.:706,98,53,489,104,458:.:0,0,2,4\t./.:9,2,0:11:22:1|0:10068166_ATATATG_A:22,0,218,49,224,273:10068166:3,6,2,0\n-20\t10068173\t.\tT\t*,<NON_REF>\t.\t.\tDP=61\tGT:AD:DP:GQ:MIN_DP:PL:SB\t./.:0,4,0:6:53:.:706,98,53,489,104,458:0,0,2,4\t./.:.:29:0:29:0,0,115,0,115,115\n-20\t10068174\t.\tA\t*,<NON_REF>\t.\t.\tDP=61\tGT:AD:DP:GQ:MIN_DP:PL:SB\t./.:0,4,0:6:53:.:706,98,53,489,104,458:0,0,2,4\t./.:.:29:39:29:0,39,585,39,585,585\n+20\t10068158\t.\tGTGTATATATATA\tG,<NON_REF>\t.\t.\tBaseQRankSum=-8.420e-01;DP=59;ExcessHet=3.01;MQRankSum=0.328;RAW_MQandDP=89764,28;ReadPosRankSum=0.524\tGT:AD:DP:GQ:MIN_DP:PGT:PID:PL:PS:SB\t.|.:3,4,0:7:57:.:0|1:10068158_GTGTATATATATA_G:105,0,57,114,69,183:10068158:0,3,2,2\t./.:.:31:54:31:.:.:0,54,810,54,810,810\n+20\t10068159\t.\tT\t*,<NON_REF>\t.\t.\tDP=60\tGT:AD:DP:GQ:MIN_DP:PGT:PID:PL:PS:SB\t.|.:3,4,0:7:57:.:0|1:10068158_GTGTATATATATA_G:105,0,57,114,69,183:10068158:0,3,2,2\t./.:.:33:45:32:.:.:0,45,675,45,675,675\n+20\t10068160\t.\tGTATATATATATGTA\tG,*,<NON_REF>\t.\t.\tDP=64;ExcessHet=3.01;RAW_MQandDP=101405,32\tGT:AD:DP:GQ:MIN_DP:PGT:PID:PL:PS:SB\t.|.:0,2,4,0:6:53:.:1|0:10068158_GTGTATATATATA_G:706,158,131,98,0,53,489,171,104,458:10068158:0,0,2,4\t./.:.:33:45:32:.:.:0,45,675,45,675,675,45,675,675,675\n+20\t10068161\t.\tT\t*,<NON_REF>\t.\t.\tDP=63\tGT:AD:DP:GQ:MIN_DP:PGT:PID:PL:PS:SB\t.|.:0,4,0:6:53:.:1|0:10068158_GTGTATATATATA_G:706,98,53,489,104,458:10068158:0,0,2,4\t./.:.:32:6:31:.:.:0,6,90,6,90,90\n+20\t10068162\t.\tA\t*,<NON_REF>\t.\t.\tDP=63\tGT:AD:DP:GQ:MIN_DP:PGT:PID:PL:PS:SB\t.|.:0,4,0:6:53:.:1|0:10068158_GTGTATATATATA_G:706,98,53,489,104,458:10068158:0,0,2,4\t./.:.:32:6:31:.:.:0,6,90,6,90,90\n+20\t10068163\t.\tT\t*,<NON_REF>\t.\t.\tDP=63\tGT:AD:DP:GQ:MIN_DP:PGT:PID:PL:PS:SB\t.|.:0,4,0:6:53:.:1|0:10068158_GTGTATATATATA_G:706,98,53,489,104,458:10068158:0,0,2,4\t./.:.:32:6:31:.:.:0,6,90,6,90,90\n+20\t10068164\t.\tA\t*,<NON_REF>\t.\t.\tDP=63\tGT:AD:DP:GQ:MIN_DP:PGT:PID:PL:PS:SB\t.|.:0,4,0:6:53:.:1|0:10068158_GTGTATATATATA_G:706,98,53,489,104,458:10068158:0,0,2,4\t./.:.:32:6:31:.:.:0,6,90,6,90,90\n+20\t10068165\t.\tT\t*,<NON_REF>\t.\t.\tDP=63\tGT:AD:DP:GQ:MIN_DP:PGT:PID:PL:PS:SB\t.|.:0,4,0:6:53:.:1|0:10068158_GTGTATATATATA_G:706,98,53,489,104,458:10068158:0,0,2,4\t./.:.:32:6:31:.:.:0,6,90,6,90,90\n+20\t10068166\t.\tATATATG\tA,*,<NON_REF>\t.\t.\tBaseQRankSum=-9.800e-01;ClippingRankSum=0.00;DP=57;ExcessHet=3.01;MQRankSum=0.00;RAW_MQandDP=88000,25;ReadPosRankSum=-6.600e-01\tGT:AD:DP:GQ:PGT:PID:PL:PS:SB\t.|.:0,0,4,0:6:53:1|0:10068158_GTGTATATATATA_G:706,489,458,98,104,53,489,458,104,458:10068158:0,0,2,4\t./.:2,9,0,0:11:22:0|1:10068166_ATATATG_A:218,0,22,224,49,273,224,49,273,273:10068166:2,0,3,6\n+20\t10068167\t.\tT\t*,<NON_REF>\t.\t.\tDP=57\tGT:AD:DP:GQ:PGT:PID:PL:PS:SB\t.|.:0,4,0:6:53:1|0:10068158_GTGTATATATATA_G:706,98,53,489,104,458:10068158:0,0,2,4\t./.:2,9,0:11:22:0|1:10068166_ATATATG_A:218,0,22,224,49,273:10068166:2,0,3,6\n+20\t10068168\t.\tATATG\tA,*,<NON_REF>\t.\t.\tBaseQRankSum=0.447;ClippingRankSum=0.00;DP=57;ExcessHet=3.01;MQRankSum=0.00;RAW_MQandDP=88000,25;ReadPosRankSum=0.660\tGT:AD:DP:GQ:PGT:PID:PL:PS:SB\t.|.:0,0,4,0:6:53:1|0:10068158_GTGTATATATATA_G:706,489,458,98,104,53,489,458,104,458:10068158:0,0,2,4\t./.:9,2,0,0:11:22:1|0:10068166_ATATATG_A:22,0,218,49,224,273,49,224,273,273:10068166:3,6,2,0\n+20\t10068169\t.\tT\t*,<NON_REF>\t.\t.\tDP=57\tGT:AD:DP:GQ:PGT:PID:PL:PS:SB\t.|.:0,4,0:6:53:1|0:10068158_GTGTATATATATA_G:706,98,53,489,104,458:10068158:0,0,2,4\t./.:9,2,0:11:22:1|0:10068166_ATATATG_A:22,0,218,49,224,273:10068166:3,6,2,0\n+20\t10068170\t.\tA\t*,<NON_REF>\t.\t.\tDP=57\tGT:AD:DP:GQ:PGT:PID:PL:PS:SB\t.|.:0,4,0:6:53:1|0:10068158_GTGTATATATATA_G:706,98,53,489,104,458:10068158:0,0,2,4\t./.:9,2,0:11:22:1|0:10068166_ATATATG_A:22,0,218,49,224,273:10068166:3,6,2,0\n+20\t10068171\t.\tT\t*,<NON_REF>\t.\t.\tDP=57\tGT:AD:DP:GQ:PGT:PID:PL:PS:SB\t.|.:0,4,0:6:53:1|0:10068158_GTGTATATATATA_G:706,98,53,489,104,458:10068158:0,0,2,4\t./.:9,2,0:11:22:1|0:10068166_ATATATG_A:22,0,218,49,224,273:10068166:3,6,2,0\n+20\t10068172\t.\tG\t*,<NON_REF>\t.\t.\tDP=57\tGT:AD:DP:GQ:PGT:PID:PL:PS:SB\t.|.:0,4,0:6:53:1|0:10068158_GTGTATATATATA_G:706,98,53,489,104,458:10068158:0,0,2,4\t./.:9,2,0:11:22:1|0:10068166_ATATATG_A:22,0,218,49,224,273:10068166:3,6,2,0\n+20\t10068173\t.\tT\t*,<NON_REF>\t.\t.\tDP=61\tGT:AD:DP:GQ:MIN_DP:PGT:PID:PL:PS:SB\t.|.:0,4,0:6:53:.:1|0:10068158_GTGTATATATATA_G:706,98,53,489,104,458:10068158:0,0,2,4\t./.:.:29:0:29:.:.:0,0,115,0,115,115\n+20\t10068174\t.\tA\t*,<NON_REF>\t.\t.\tDP=61\tGT:AD:DP:GQ:MIN_DP:PGT:PID:PL:PS:SB\t.|.:0,4,0:6:53:.:1|0:10068158_GTGTATATATATA_G:706,98,53,489,104,458:10068158:0,0,2,4\t./.:.:29:39:29:.:.:0,39,585,39,585,585", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6d161736d534a3b468e5054a5415c6784d632578"}, "originalPosition": 37}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI2NTM3NTUxOnYy", "diffSide": "RIGHT", "path": "src/test/java/org/broadinstitute/hellbender/tools/walkers/haplotypecaller/AssemblyBasedCallerUtilsUnitTest.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMFQyMDo1OTowNlrOHwvYjQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0zMFQxOTo0MjoyNFrOH8KyDQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDg3MDAyOQ==", "bodyText": "I know this wasn't you, but can we clarify with \"return -1\" or something?  I expected a literal Exception.", "url": "https://github.com/broadinstitute/gatk/pull/6937#discussion_r520870029", "createdAt": "2020-11-10T20:59:06Z", "author": {"login": "ldgauthier"}, "path": "src/test/java/org/broadinstitute/hellbender/tools/walkers/haplotypecaller/AssemblyBasedCallerUtilsUnitTest.java", "diffHunk": "@@ -720,27 +720,60 @@ public void testGetEventMapper(final VariantContext mergedVc,\n \n         // test no phased variants, empty map\n         final Map<VariantContext, Pair<Integer, String>> nonePhased1 = new HashMap<>();\n-        tests.add(new Object[]{calls, nonePhased1, 0, 0, 0});\n+        tests.add(new Object[]{calls, nonePhased1, 0, 0, 0, calls});\n \n         // test no phased variants, full map, exception expected", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6d161736d534a3b468e5054a5415c6784d632578"}, "originalPosition": 7}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjEyNzAzNw==", "bodyText": "I've modified this test to not use the -1 return codes; it seems better to explicitly check for the exception.", "url": "https://github.com/broadinstitute/gatk/pull/6937#discussion_r526127037", "createdAt": "2020-11-18T14:25:34Z", "author": {"login": "cwhelan"}, "path": "src/test/java/org/broadinstitute/hellbender/tools/walkers/haplotypecaller/AssemblyBasedCallerUtilsUnitTest.java", "diffHunk": "@@ -720,27 +720,60 @@ public void testGetEventMapper(final VariantContext mergedVc,\n \n         // test no phased variants, empty map\n         final Map<VariantContext, Pair<Integer, String>> nonePhased1 = new HashMap<>();\n-        tests.add(new Object[]{calls, nonePhased1, 0, 0, 0});\n+        tests.add(new Object[]{calls, nonePhased1, 0, 0, 0, calls});\n \n         // test no phased variants, full map, exception expected", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDg3MDAyOQ=="}, "originalCommit": {"oid": "6d161736d534a3b468e5054a5415c6784d632578"}, "originalPosition": 7}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjg1MzI2MQ==", "bodyText": "Thanks!", "url": "https://github.com/broadinstitute/gatk/pull/6937#discussion_r532853261", "createdAt": "2020-11-30T19:42:24Z", "author": {"login": "ldgauthier"}, "path": "src/test/java/org/broadinstitute/hellbender/tools/walkers/haplotypecaller/AssemblyBasedCallerUtilsUnitTest.java", "diffHunk": "@@ -720,27 +720,60 @@ public void testGetEventMapper(final VariantContext mergedVc,\n \n         // test no phased variants, empty map\n         final Map<VariantContext, Pair<Integer, String>> nonePhased1 = new HashMap<>();\n-        tests.add(new Object[]{calls, nonePhased1, 0, 0, 0});\n+        tests.add(new Object[]{calls, nonePhased1, 0, 0, 0, calls});\n \n         // test no phased variants, full map, exception expected", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDg3MDAyOQ=="}, "originalCommit": {"oid": "6d161736d534a3b468e5054a5415c6784d632578"}, "originalPosition": 7}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI2NTQxNDA4OnYy", "diffSide": "RIGHT", "path": "src/test/java/org/broadinstitute/hellbender/tools/walkers/haplotypecaller/AssemblyBasedCallerUtilsUnitTest.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMFQyMToxMTozN1rOHwvxBQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOFQxNDoyNjowMFrOH1wQ7w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDg3NjI5Mw==", "bodyText": "If the ref for the deletion is AA and the remaining haplotype is AAAA, then isn't the deletion not left aligned?  I don't know if that matters at this point in the code, but I don't want to complicate things.", "url": "https://github.com/broadinstitute/gatk/pull/6937#discussion_r520876293", "createdAt": "2020-11-10T21:11:37Z", "author": {"login": "ldgauthier"}, "path": "src/test/java/org/broadinstitute/hellbender/tools/walkers/haplotypecaller/AssemblyBasedCallerUtilsUnitTest.java", "diffHunk": "@@ -895,6 +934,33 @@ public void testConstructPhaseGroups(final List<VariantContext> calls,\n         haplotypeMap.put(vc4, haplotypes4complete);\n         tests.add(new Object[]{calls, new HashMap<>(haplotypeMap), 0, 0, 0, 0, 0});\n \n+        final Allele refForDel = Allele.create(\"AA\", true);\n+        final Allele altDel = Allele.create(\"A\", false);\n+\n+        final VariantContext delVC = new VariantContextBuilder().chr(\"20\").start(3).stop(4).alleles(Arrays.asList(refForDel, altDel)).make();\n+        final VariantContext spannedSnpVC = new VariantContextBuilder().chr(\"20\").start(4).stop(4).alleles(Arrays.asList(ref, Allele.SPAN_DEL, altT)).make();\n+\n+        final Haplotype spandelHap = new Haplotype(\"AAAA\".getBytes());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6d161736d534a3b468e5054a5415c6784d632578"}, "originalPosition": 112}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjEyNzM0Mw==", "bodyText": "Updated this test data with a more informative and easy-to-follow haplotype that avoids this problem.", "url": "https://github.com/broadinstitute/gatk/pull/6937#discussion_r526127343", "createdAt": "2020-11-18T14:26:00Z", "author": {"login": "cwhelan"}, "path": "src/test/java/org/broadinstitute/hellbender/tools/walkers/haplotypecaller/AssemblyBasedCallerUtilsUnitTest.java", "diffHunk": "@@ -895,6 +934,33 @@ public void testConstructPhaseGroups(final List<VariantContext> calls,\n         haplotypeMap.put(vc4, haplotypes4complete);\n         tests.add(new Object[]{calls, new HashMap<>(haplotypeMap), 0, 0, 0, 0, 0});\n \n+        final Allele refForDel = Allele.create(\"AA\", true);\n+        final Allele altDel = Allele.create(\"A\", false);\n+\n+        final VariantContext delVC = new VariantContextBuilder().chr(\"20\").start(3).stop(4).alleles(Arrays.asList(refForDel, altDel)).make();\n+        final VariantContext spannedSnpVC = new VariantContextBuilder().chr(\"20\").start(4).stop(4).alleles(Arrays.asList(ref, Allele.SPAN_DEL, altT)).make();\n+\n+        final Haplotype spandelHap = new Haplotype(\"AAAA\".getBytes());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDg3NjI5Mw=="}, "originalCommit": {"oid": "6d161736d534a3b468e5054a5415c6784d632578"}, "originalPosition": 112}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI5OTkwNzU0OnYy", "diffSide": "RIGHT", "path": "src/main/java/org/broadinstitute/hellbender/tools/walkers/haplotypecaller/AssemblyBasedCallerUtils.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOFQxODoxNzoyMVrOH177DA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNVQxNjo1NDoxNFrOH58PmQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjMxODM0OA==", "bodyText": "What about mixed hets with no ref allele or span del?  Is there any reason it can't be simply 0: first allele in the VariantContext's allele list, 1: second allele in same list?", "url": "https://github.com/broadinstitute/gatk/pull/6937#discussion_r526318348", "createdAt": "2020-11-18T18:17:21Z", "author": {"login": "davidbenjamin"}, "path": "src/main/java/org/broadinstitute/hellbender/tools/walkers/haplotypecaller/AssemblyBasedCallerUtils.java", "diffHunk": "@@ -65,6 +65,8 @@\n     // get realigned incorrectly.  See https://github.com/broadinstitute/gatk/issues/5060\n     public static final int MINIMUM_READ_LENGTH_AFTER_TRIMMING = 10;\n \n+    // this notation can be interpreted as a representation of the alleles present on the two phased haplotypes at the site:", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "150e9e3af2747153cb78e85872e18d59dbb5b692"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDUxNzkxMw==", "bodyText": "I've left the current functionality as is, in that it only phases sites that are biallelic with a single site-specific alternate allele. Even with this restriction, though, we can't guarantee the order of alternate alleles in the VC's allele list, and in some cases the * allele ends up at index 1 (ie the allele list is REF, *, ALT), in which case the indexing schemes become more confusing.", "url": "https://github.com/broadinstitute/gatk/pull/6937#discussion_r530517913", "createdAt": "2020-11-25T16:54:14Z", "author": {"login": "cwhelan"}, "path": "src/main/java/org/broadinstitute/hellbender/tools/walkers/haplotypecaller/AssemblyBasedCallerUtils.java", "diffHunk": "@@ -65,6 +65,8 @@\n     // get realigned incorrectly.  See https://github.com/broadinstitute/gatk/issues/5060\n     public static final int MINIMUM_READ_LENGTH_AFTER_TRIMMING = 10;\n \n+    // this notation can be interpreted as a representation of the alleles present on the two phased haplotypes at the site:", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjMxODM0OA=="}, "originalCommit": {"oid": "150e9e3af2747153cb78e85872e18d59dbb5b692"}, "originalPosition": 4}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI5OTkyMjU4OnYy", "diffSide": "RIGHT", "path": "src/main/java/org/broadinstitute/hellbender/tools/walkers/haplotypecaller/AssemblyBasedCallerUtils.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOFQxODoyMToxMlrOH18ErQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNVQxNjo1NTo1M1rOH58T7w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjMyMDgxMw==", "bodyText": "If we're going to continue to handle only the case of a single alt allele, then we should modify the code a few lines up to test not just if ( ! isBiallelic(call) ) but rather test for biallelic sites where one allele is ref.", "url": "https://github.com/broadinstitute/gatk/pull/6937#discussion_r526320813", "createdAt": "2020-11-18T18:21:12Z", "author": {"login": "davidbenjamin"}, "path": "src/main/java/org/broadinstitute/hellbender/tools/walkers/haplotypecaller/AssemblyBasedCallerUtils.java", "diffHunk": "@@ -639,9 +641,8 @@ public static void annotateReadLikelihoodsWithSupportedAlleles(final VariantCont\n             }\n \n             // keep track of the haplotypes that contain this particular alternate allele\n-            final Allele alt = call.getAlternateAllele(0);\n-            final Predicate<VariantContext> hasThisAlt = vc -> (vc.getStart() == call.getStart() && vc.getAlternateAlleles().contains(alt)) ||\n-                    (Allele.SPAN_DEL.equals(alt) && vc.getStart() < call.getStart() && vc.getEnd() >= call.getStart());\n+            final Allele alt = getSiteSpecificAlternateAllele(call);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "150e9e3af2747153cb78e85872e18d59dbb5b692"}, "originalPosition": 16}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDUxOTAyMw==", "bodyText": "The isBiallelic method for this class was already testing for that condition (but wasn't aware of * alleles). I've renamed the method to make it clear that it's explicitly testing for the case where the site is biallelic with a single site-specific alt allele.", "url": "https://github.com/broadinstitute/gatk/pull/6937#discussion_r530519023", "createdAt": "2020-11-25T16:55:53Z", "author": {"login": "cwhelan"}, "path": "src/main/java/org/broadinstitute/hellbender/tools/walkers/haplotypecaller/AssemblyBasedCallerUtils.java", "diffHunk": "@@ -639,9 +641,8 @@ public static void annotateReadLikelihoodsWithSupportedAlleles(final VariantCont\n             }\n \n             // keep track of the haplotypes that contain this particular alternate allele\n-            final Allele alt = call.getAlternateAllele(0);\n-            final Predicate<VariantContext> hasThisAlt = vc -> (vc.getStart() == call.getStart() && vc.getAlternateAlleles().contains(alt)) ||\n-                    (Allele.SPAN_DEL.equals(alt) && vc.getStart() < call.getStart() && vc.getEnd() >= call.getStart());\n+            final Allele alt = getSiteSpecificAlternateAllele(call);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjMyMDgxMw=="}, "originalCommit": {"oid": "150e9e3af2747153cb78e85872e18d59dbb5b692"}, "originalPosition": 16}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI5OTkzMDIxOnYy", "diffSide": "RIGHT", "path": "src/main/java/org/broadinstitute/hellbender/tools/walkers/haplotypecaller/AssemblyBasedCallerUtils.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOFQxODoyMzoxNFrOH18Jiw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNVQxNjo1NjozMFrOH58VgQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjMyMjA1OQ==", "bodyText": "return vc.isBiallelic() || vc.getAlternateAlleles().stream().filter(isSiteSpecificAltAllele).count() == 1", "url": "https://github.com/broadinstitute/gatk/pull/6937#discussion_r526322059", "createdAt": "2020-11-18T18:23:14Z", "author": {"login": "davidbenjamin"}, "path": "src/main/java/org/broadinstitute/hellbender/tools/walkers/haplotypecaller/AssemblyBasedCallerUtils.java", "diffHunk": "@@ -801,10 +811,23 @@ else if ( ! phaseSetMapping.containsKey(comp) ){\n      * Is this variant bi-allelic?  This implementation is very much specific to this class so shouldn't be pulled out into a generalized place.\n      *\n      * @param vc the variant context\n-     * @return true if this variant context is bi-allelic, ignoring the NON-REF symbolic allele, false otherwise\n+     * @return true if this variant context is bi-allelic, ignoring the NON-REF symbolic allele and '*' symbolic allele, false otherwise\n      */\n     private static boolean isBiallelic(final VariantContext vc) {\n-        return vc.isBiallelic() || (vc.getNAlleles() == 3 && vc.getAlternateAlleles().contains(Allele.NON_REF_ALLELE));\n+        if (vc.isBiallelic()) return true;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "150e9e3af2747153cb78e85872e18d59dbb5b692"}, "originalPosition": 46}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDUxOTQyNQ==", "bodyText": "Done, but then I realized that the vc.isBiallelic() part is redundant with the second part of the test so I removed it.", "url": "https://github.com/broadinstitute/gatk/pull/6937#discussion_r530519425", "createdAt": "2020-11-25T16:56:30Z", "author": {"login": "cwhelan"}, "path": "src/main/java/org/broadinstitute/hellbender/tools/walkers/haplotypecaller/AssemblyBasedCallerUtils.java", "diffHunk": "@@ -801,10 +811,23 @@ else if ( ! phaseSetMapping.containsKey(comp) ){\n      * Is this variant bi-allelic?  This implementation is very much specific to this class so shouldn't be pulled out into a generalized place.\n      *\n      * @param vc the variant context\n-     * @return true if this variant context is bi-allelic, ignoring the NON-REF symbolic allele, false otherwise\n+     * @return true if this variant context is bi-allelic, ignoring the NON-REF symbolic allele and '*' symbolic allele, false otherwise\n      */\n     private static boolean isBiallelic(final VariantContext vc) {\n-        return vc.isBiallelic() || (vc.getNAlleles() == 3 && vc.getAlternateAlleles().contains(Allele.NON_REF_ALLELE));\n+        if (vc.isBiallelic()) return true;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjMyMjA1OQ=="}, "originalCommit": {"oid": "150e9e3af2747153cb78e85872e18d59dbb5b692"}, "originalPosition": 46}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI5OTk0MzA2OnYy", "diffSide": "RIGHT", "path": "src/main/java/org/broadinstitute/hellbender/tools/walkers/haplotypecaller/AssemblyBasedCallerUtils.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOFQxODoyNjoyNlrOH18RWg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNVQxNjo1NjozNVrOH58Vvw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjMyNDA1OA==", "bodyText": "return !(a.isReference() || a.isNonRefAllele() || Allele.SPAN_DEL.equals(a))", "url": "https://github.com/broadinstitute/gatk/pull/6937#discussion_r526324058", "createdAt": "2020-11-18T18:26:26Z", "author": {"login": "davidbenjamin"}, "path": "src/main/java/org/broadinstitute/hellbender/tools/walkers/haplotypecaller/AssemblyBasedCallerUtils.java", "diffHunk": "@@ -801,10 +811,23 @@ else if ( ! phaseSetMapping.containsKey(comp) ){\n      * Is this variant bi-allelic?  This implementation is very much specific to this class so shouldn't be pulled out into a generalized place.\n      *\n      * @param vc the variant context\n-     * @return true if this variant context is bi-allelic, ignoring the NON-REF symbolic allele, false otherwise\n+     * @return true if this variant context is bi-allelic, ignoring the NON-REF symbolic allele and '*' symbolic allele, false otherwise\n      */\n     private static boolean isBiallelic(final VariantContext vc) {\n-        return vc.isBiallelic() || (vc.getNAlleles() == 3 && vc.getAlternateAlleles().contains(Allele.NON_REF_ALLELE));\n+        if (vc.isBiallelic()) return true;\n+        final long siteSpecificAltAlleles = vc.getAlternateAlleles().stream().filter(a -> isSiteSpecificAltAllele(a)).count();\n+        return siteSpecificAltAlleles == 1L;\n+    }\n+\n+    /**\n+     * A site-specific alternate allele is one that represents concrete (i.e. not NONREF) variation that begins at the\n+     * site (i.e. not '*', which represents a concrete alternate allele that begins upstream of the current site).\n+     */\n+    private static boolean isSiteSpecificAltAllele(final Allele a) {\n+        if(a.isReference()) return false;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "150e9e3af2747153cb78e85872e18d59dbb5b692"}, "originalPosition": 56}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDUxOTQ4Nw==", "bodyText": "Done", "url": "https://github.com/broadinstitute/gatk/pull/6937#discussion_r530519487", "createdAt": "2020-11-25T16:56:35Z", "author": {"login": "cwhelan"}, "path": "src/main/java/org/broadinstitute/hellbender/tools/walkers/haplotypecaller/AssemblyBasedCallerUtils.java", "diffHunk": "@@ -801,10 +811,23 @@ else if ( ! phaseSetMapping.containsKey(comp) ){\n      * Is this variant bi-allelic?  This implementation is very much specific to this class so shouldn't be pulled out into a generalized place.\n      *\n      * @param vc the variant context\n-     * @return true if this variant context is bi-allelic, ignoring the NON-REF symbolic allele, false otherwise\n+     * @return true if this variant context is bi-allelic, ignoring the NON-REF symbolic allele and '*' symbolic allele, false otherwise\n      */\n     private static boolean isBiallelic(final VariantContext vc) {\n-        return vc.isBiallelic() || (vc.getNAlleles() == 3 && vc.getAlternateAlleles().contains(Allele.NON_REF_ALLELE));\n+        if (vc.isBiallelic()) return true;\n+        final long siteSpecificAltAlleles = vc.getAlternateAlleles().stream().filter(a -> isSiteSpecificAltAllele(a)).count();\n+        return siteSpecificAltAlleles == 1L;\n+    }\n+\n+    /**\n+     * A site-specific alternate allele is one that represents concrete (i.e. not NONREF) variation that begins at the\n+     * site (i.e. not '*', which represents a concrete alternate allele that begins upstream of the current site).\n+     */\n+    private static boolean isSiteSpecificAltAllele(final Allele a) {\n+        if(a.isReference()) return false;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjMyNDA1OA=="}, "originalCommit": {"oid": "150e9e3af2747153cb78e85872e18d59dbb5b692"}, "originalPosition": 56}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI5OTk0NjYxOnYy", "diffSide": "RIGHT", "path": "src/main/java/org/broadinstitute/hellbender/tools/walkers/haplotypecaller/AssemblyBasedCallerUtils.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOFQxODoyNzoxNlrOH18TjQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNVQxNjo1NzowNFrOH58W7w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjMyNDYyMQ==", "bodyText": "Let's capitalize these constants: PHASE_01.", "url": "https://github.com/broadinstitute/gatk/pull/6937#discussion_r526324621", "createdAt": "2020-11-18T18:27:16Z", "author": {"login": "davidbenjamin"}, "path": "src/main/java/org/broadinstitute/hellbender/tools/walkers/haplotypecaller/AssemblyBasedCallerUtils.java", "diffHunk": "@@ -65,6 +65,8 @@\n     // get realigned incorrectly.  See https://github.com/broadinstitute/gatk/issues/5060\n     public static final int MINIMUM_READ_LENGTH_AFTER_TRIMMING = 10;\n \n+    // this notation can be interpreted as a representation of the alleles present on the two phased haplotypes at the site:\n+    // \"0\": REF or '*'; \"1\": site-specific alt allele", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "150e9e3af2747153cb78e85872e18d59dbb5b692"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDUxOTc5MQ==", "bodyText": "Done, and converted to enums as per your comment below.", "url": "https://github.com/broadinstitute/gatk/pull/6937#discussion_r530519791", "createdAt": "2020-11-25T16:57:04Z", "author": {"login": "cwhelan"}, "path": "src/main/java/org/broadinstitute/hellbender/tools/walkers/haplotypecaller/AssemblyBasedCallerUtils.java", "diffHunk": "@@ -65,6 +65,8 @@\n     // get realigned incorrectly.  See https://github.com/broadinstitute/gatk/issues/5060\n     public static final int MINIMUM_READ_LENGTH_AFTER_TRIMMING = 10;\n \n+    // this notation can be interpreted as a representation of the alleles present on the two phased haplotypes at the site:\n+    // \"0\": REF or '*'; \"1\": site-specific alt allele", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjMyNDYyMQ=="}, "originalCommit": {"oid": "150e9e3af2747153cb78e85872e18d59dbb5b692"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI5OTk1NDU3OnYy", "diffSide": "RIGHT", "path": "src/main/java/org/broadinstitute/hellbender/tools/walkers/haplotypecaller/AssemblyBasedCallerUtils.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOFQxODoyOToxNVrOH18YaA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNVQxNjo1Njo0N1rOH58WSQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjMyNTg2NA==", "bodyText": "This is truly petty but I would prefer checking g.isHet() first, since the phase genotype string is only relevant if it's a het.", "url": "https://github.com/broadinstitute/gatk/pull/6937#discussion_r526325864", "createdAt": "2020-11-18T18:29:15Z", "author": {"login": "davidbenjamin"}, "path": "src/main/java/org/broadinstitute/hellbender/tools/walkers/haplotypecaller/AssemblyBasedCallerUtils.java", "diffHunk": "@@ -829,9 +852,18 @@ private static VariantContext phaseVC(final VariantContext vc, final String ID,\n         final List<Genotype> phasedGenotypes = new ArrayList<>();\n         for ( final Genotype g : vc.getGenotypes() ) {\n             final List<Allele> alleles = g.getAlleles();\n-            if (phaseGT.equals(phase10) && g.isHet()) Collections.reverse(alleles); // swap the alleles if heterozygous\n+            final List<Allele> newAlleles = new ArrayList<>(alleles);\n+            if (phaseGT.equals(phase10) && g.isHet()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "150e9e3af2747153cb78e85872e18d59dbb5b692"}, "originalPosition": 69}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDUxOTYyNQ==", "bodyText": "done", "url": "https://github.com/broadinstitute/gatk/pull/6937#discussion_r530519625", "createdAt": "2020-11-25T16:56:47Z", "author": {"login": "cwhelan"}, "path": "src/main/java/org/broadinstitute/hellbender/tools/walkers/haplotypecaller/AssemblyBasedCallerUtils.java", "diffHunk": "@@ -829,9 +852,18 @@ private static VariantContext phaseVC(final VariantContext vc, final String ID,\n         final List<Genotype> phasedGenotypes = new ArrayList<>();\n         for ( final Genotype g : vc.getGenotypes() ) {\n             final List<Allele> alleles = g.getAlleles();\n-            if (phaseGT.equals(phase10) && g.isHet()) Collections.reverse(alleles); // swap the alleles if heterozygous\n+            final List<Allele> newAlleles = new ArrayList<>(alleles);\n+            if (phaseGT.equals(phase10) && g.isHet()) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjMyNTg2NA=="}, "originalCommit": {"oid": "150e9e3af2747153cb78e85872e18d59dbb5b692"}, "originalPosition": 69}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI5OTk4MzMyOnYy", "diffSide": "RIGHT", "path": "src/main/java/org/broadinstitute/hellbender/tools/walkers/haplotypecaller/AssemblyBasedCallerUtils.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOFQxODozNjoxNFrOH18pkw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNVQxNjo1NzozMFrOH58X7w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjMzMDI1OQ==", "bodyText": "I think this series of nested conditionals could be simplified as:\nfinal int phasedFirstAlleleIndex = phaseGT.equals(phase10) ? 0 : 1;\nif (g.isHet() && ! isSiteSpecificAltAllele(newAlleles.get(phasedFirstAlleleIndex))) {\n    Collections.reverse(newAlleles);\n}\n\nI would also consider making the phase GTs into an enum instead of hardcoded strings, and giving it a method to extract which index, 0 or 1, is first.", "url": "https://github.com/broadinstitute/gatk/pull/6937#discussion_r526330259", "createdAt": "2020-11-18T18:36:14Z", "author": {"login": "davidbenjamin"}, "path": "src/main/java/org/broadinstitute/hellbender/tools/walkers/haplotypecaller/AssemblyBasedCallerUtils.java", "diffHunk": "@@ -829,9 +852,18 @@ private static VariantContext phaseVC(final VariantContext vc, final String ID,\n         final List<Genotype> phasedGenotypes = new ArrayList<>();\n         for ( final Genotype g : vc.getGenotypes() ) {\n             final List<Allele> alleles = g.getAlleles();\n-            if (phaseGT.equals(phase10) && g.isHet()) Collections.reverse(alleles); // swap the alleles if heterozygous\n+            final List<Allele> newAlleles = new ArrayList<>(alleles);\n+            if (phaseGT.equals(phase10) && g.isHet()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "150e9e3af2747153cb78e85872e18d59dbb5b692"}, "originalPosition": 69}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDUyMDA0Nw==", "bodyText": "Good suggestions, I've implemented these changes.", "url": "https://github.com/broadinstitute/gatk/pull/6937#discussion_r530520047", "createdAt": "2020-11-25T16:57:30Z", "author": {"login": "cwhelan"}, "path": "src/main/java/org/broadinstitute/hellbender/tools/walkers/haplotypecaller/AssemblyBasedCallerUtils.java", "diffHunk": "@@ -829,9 +852,18 @@ private static VariantContext phaseVC(final VariantContext vc, final String ID,\n         final List<Genotype> phasedGenotypes = new ArrayList<>();\n         for ( final Genotype g : vc.getGenotypes() ) {\n             final List<Allele> alleles = g.getAlleles();\n-            if (phaseGT.equals(phase10) && g.isHet()) Collections.reverse(alleles); // swap the alleles if heterozygous\n+            final List<Allele> newAlleles = new ArrayList<>(alleles);\n+            if (phaseGT.equals(phase10) && g.isHet()) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjMzMDI1OQ=="}, "originalCommit": {"oid": "150e9e3af2747153cb78e85872e18d59dbb5b692"}, "originalPosition": 69}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI5OTk4NDg1OnYy", "diffSide": "RIGHT", "path": "src/test/java/org/broadinstitute/hellbender/tools/walkers/haplotypecaller/AssemblyBasedCallerUtilsUnitTest.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOFQxODozNjozOFrOH18qgA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNVQxNjo1NzozNVrOH58YIw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjMzMDQ5Ng==", "bodyText": "Camel case these", "url": "https://github.com/broadinstitute/gatk/pull/6937#discussion_r526330496", "createdAt": "2020-11-18T18:36:38Z", "author": {"login": "davidbenjamin"}, "path": "src/test/java/org/broadinstitute/hellbender/tools/walkers/haplotypecaller/AssemblyBasedCallerUtilsUnitTest.java", "diffHunk": "@@ -720,27 +720,62 @@ public void testGetEventMapper(final VariantContext mergedVc,\n \n         // test no phased variants, empty map\n         final Map<VariantContext, Pair<Integer, String>> nonePhased1 = new HashMap<>();\n-        tests.add(new Object[]{calls, nonePhased1, 0, 0, 0});\n+        tests.add(new Object[]{calls, nonePhased1, 0, 0, 0, calls, null});\n \n         // test no phased variants, full map, exception expected\n+        final IllegalStateException tooSmallPhaseGroupException = new IllegalStateException(\"Somehow we have a group of phased variants that has fewer than 2 members\");\n+\n         final Map<VariantContext, Pair<Integer, String>> nonePhased2 = new HashMap<>();\n-        nonePhased2.put(vc1, Pair.of(0, \"0/1\"));\n-        nonePhased2.put(vc2, Pair.of(1, \"0/1\"));\n-        nonePhased2.put(vc3, Pair.of(2, \"0/1\"));\n-        tests.add(new Object[]{calls, nonePhased2, 3, -1, -1});\n+        nonePhased2.put(vc1, Pair.of(0, \"0|1\"));\n+        nonePhased2.put(vc2, Pair.of(1, \"0|1\"));\n+        nonePhased2.put(vc3, Pair.of(2, \"0|1\"));\n+        tests.add(new Object[]{calls, nonePhased2, 3, -1, -1, calls, tooSmallPhaseGroupException});\n \n         // test 2 phased variants\n+        final Genotype g1P = new GenotypeBuilder().alleles(Arrays.asList(ref, altC)).phased(true).make();\n+        final VariantContext vc1P = new VariantContextBuilder().chr(\"20\").start(1).stop(1).alleles(Arrays.asList(ref, altC)).genotypes(g1P).make();\n+        final Genotype g2P = new GenotypeBuilder().alleles(Arrays.asList(altC, ref)).phased(true).make();\n+        final VariantContext vc2P = new VariantContextBuilder().chr(\"20\").start(2).stop(2).alleles(Arrays.asList(ref, altC)).genotypes(g2P).make();\n+        final List<VariantContext> phasedCalls = Arrays.asList(vc1P, vc2P, vc3);\n+\n         final Map<VariantContext, Pair<Integer, String>> twoPhased = new HashMap<>();\n-        twoPhased.put(vc1, Pair.of(0, \"0/1\"));\n-        twoPhased.put(vc2, Pair.of(0, \"0/1\"));\n-        tests.add(new Object[]{calls, twoPhased, 1, 1, 2});\n+        twoPhased.put(vc1, Pair.of(0, \"0|1\"));\n+        twoPhased.put(vc2, Pair.of(0, \"1|0\"));\n+        tests.add(new Object[]{calls, twoPhased, 1, 1, 2, phasedCalls, null});\n \n         // test all phased variants\n+        final Genotype g3P = new GenotypeBuilder().alleles(Arrays.asList(ref, altC)).phased(true).make();\n+        final VariantContext vc3P = new VariantContextBuilder().chr(\"20\").start(3).stop(3).alleles(Arrays.asList(ref, altC)).genotypes(g3P).make();\n+        final List<VariantContext> phasedCalls2 = Arrays.asList(vc1P, vc2P, vc3P);\n+\n         final Map<VariantContext, Pair<Integer, String>> allPhased = new HashMap<>();\n-        allPhased.put(vc1, Pair.of(0, \"0/1\"));\n-        allPhased.put(vc2, Pair.of(0, \"0/1\"));\n-        allPhased.put(vc3, Pair.of(0, \"0/1\"));\n-        tests.add(new Object[]{calls, allPhased, 1, 1, 3});\n+        allPhased.put(vc1, Pair.of(0, \"0|1\"));\n+        allPhased.put(vc2, Pair.of(0, \"1|0\"));\n+        allPhased.put(vc3, Pair.of(0, \"0|1\"));\n+        tests.add(new Object[]{calls, allPhased, 1, 1, 3, phasedCalls2, null});\n+\n+        // test a spanning deletion case: unphased snp, deletion, spanned snp\n+        final Allele delref = Allele.create(\"AA\", true);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "150e9e3af2747153cb78e85872e18d59dbb5b692"}, "originalPosition": 51}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDUyMDA5OQ==", "bodyText": "done", "url": "https://github.com/broadinstitute/gatk/pull/6937#discussion_r530520099", "createdAt": "2020-11-25T16:57:35Z", "author": {"login": "cwhelan"}, "path": "src/test/java/org/broadinstitute/hellbender/tools/walkers/haplotypecaller/AssemblyBasedCallerUtilsUnitTest.java", "diffHunk": "@@ -720,27 +720,62 @@ public void testGetEventMapper(final VariantContext mergedVc,\n \n         // test no phased variants, empty map\n         final Map<VariantContext, Pair<Integer, String>> nonePhased1 = new HashMap<>();\n-        tests.add(new Object[]{calls, nonePhased1, 0, 0, 0});\n+        tests.add(new Object[]{calls, nonePhased1, 0, 0, 0, calls, null});\n \n         // test no phased variants, full map, exception expected\n+        final IllegalStateException tooSmallPhaseGroupException = new IllegalStateException(\"Somehow we have a group of phased variants that has fewer than 2 members\");\n+\n         final Map<VariantContext, Pair<Integer, String>> nonePhased2 = new HashMap<>();\n-        nonePhased2.put(vc1, Pair.of(0, \"0/1\"));\n-        nonePhased2.put(vc2, Pair.of(1, \"0/1\"));\n-        nonePhased2.put(vc3, Pair.of(2, \"0/1\"));\n-        tests.add(new Object[]{calls, nonePhased2, 3, -1, -1});\n+        nonePhased2.put(vc1, Pair.of(0, \"0|1\"));\n+        nonePhased2.put(vc2, Pair.of(1, \"0|1\"));\n+        nonePhased2.put(vc3, Pair.of(2, \"0|1\"));\n+        tests.add(new Object[]{calls, nonePhased2, 3, -1, -1, calls, tooSmallPhaseGroupException});\n \n         // test 2 phased variants\n+        final Genotype g1P = new GenotypeBuilder().alleles(Arrays.asList(ref, altC)).phased(true).make();\n+        final VariantContext vc1P = new VariantContextBuilder().chr(\"20\").start(1).stop(1).alleles(Arrays.asList(ref, altC)).genotypes(g1P).make();\n+        final Genotype g2P = new GenotypeBuilder().alleles(Arrays.asList(altC, ref)).phased(true).make();\n+        final VariantContext vc2P = new VariantContextBuilder().chr(\"20\").start(2).stop(2).alleles(Arrays.asList(ref, altC)).genotypes(g2P).make();\n+        final List<VariantContext> phasedCalls = Arrays.asList(vc1P, vc2P, vc3);\n+\n         final Map<VariantContext, Pair<Integer, String>> twoPhased = new HashMap<>();\n-        twoPhased.put(vc1, Pair.of(0, \"0/1\"));\n-        twoPhased.put(vc2, Pair.of(0, \"0/1\"));\n-        tests.add(new Object[]{calls, twoPhased, 1, 1, 2});\n+        twoPhased.put(vc1, Pair.of(0, \"0|1\"));\n+        twoPhased.put(vc2, Pair.of(0, \"1|0\"));\n+        tests.add(new Object[]{calls, twoPhased, 1, 1, 2, phasedCalls, null});\n \n         // test all phased variants\n+        final Genotype g3P = new GenotypeBuilder().alleles(Arrays.asList(ref, altC)).phased(true).make();\n+        final VariantContext vc3P = new VariantContextBuilder().chr(\"20\").start(3).stop(3).alleles(Arrays.asList(ref, altC)).genotypes(g3P).make();\n+        final List<VariantContext> phasedCalls2 = Arrays.asList(vc1P, vc2P, vc3P);\n+\n         final Map<VariantContext, Pair<Integer, String>> allPhased = new HashMap<>();\n-        allPhased.put(vc1, Pair.of(0, \"0/1\"));\n-        allPhased.put(vc2, Pair.of(0, \"0/1\"));\n-        allPhased.put(vc3, Pair.of(0, \"0/1\"));\n-        tests.add(new Object[]{calls, allPhased, 1, 1, 3});\n+        allPhased.put(vc1, Pair.of(0, \"0|1\"));\n+        allPhased.put(vc2, Pair.of(0, \"1|0\"));\n+        allPhased.put(vc3, Pair.of(0, \"0|1\"));\n+        tests.add(new Object[]{calls, allPhased, 1, 1, 3, phasedCalls2, null});\n+\n+        // test a spanning deletion case: unphased snp, deletion, spanned snp\n+        final Allele delref = Allele.create(\"AA\", true);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjMzMDQ5Ng=="}, "originalCommit": {"oid": "150e9e3af2747153cb78e85872e18d59dbb5b692"}, "originalPosition": 51}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI5OTk4NTU3OnYy", "diffSide": "RIGHT", "path": "src/test/java/org/broadinstitute/hellbender/tools/walkers/haplotypecaller/AssemblyBasedCallerUtilsUnitTest.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOFQxODozNjo1MVrOH18q9Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNVQxNjo1NzozOVrOH58YTg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjMzMDYxMw==", "bodyText": "camel case", "url": "https://github.com/broadinstitute/gatk/pull/6937#discussion_r526330613", "createdAt": "2020-11-18T18:36:51Z", "author": {"login": "davidbenjamin"}, "path": "src/test/java/org/broadinstitute/hellbender/tools/walkers/haplotypecaller/AssemblyBasedCallerUtilsUnitTest.java", "diffHunk": "@@ -720,27 +720,62 @@ public void testGetEventMapper(final VariantContext mergedVc,\n \n         // test no phased variants, empty map\n         final Map<VariantContext, Pair<Integer, String>> nonePhased1 = new HashMap<>();\n-        tests.add(new Object[]{calls, nonePhased1, 0, 0, 0});\n+        tests.add(new Object[]{calls, nonePhased1, 0, 0, 0, calls, null});\n \n         // test no phased variants, full map, exception expected\n+        final IllegalStateException tooSmallPhaseGroupException = new IllegalStateException(\"Somehow we have a group of phased variants that has fewer than 2 members\");\n+\n         final Map<VariantContext, Pair<Integer, String>> nonePhased2 = new HashMap<>();\n-        nonePhased2.put(vc1, Pair.of(0, \"0/1\"));\n-        nonePhased2.put(vc2, Pair.of(1, \"0/1\"));\n-        nonePhased2.put(vc3, Pair.of(2, \"0/1\"));\n-        tests.add(new Object[]{calls, nonePhased2, 3, -1, -1});\n+        nonePhased2.put(vc1, Pair.of(0, \"0|1\"));\n+        nonePhased2.put(vc2, Pair.of(1, \"0|1\"));\n+        nonePhased2.put(vc3, Pair.of(2, \"0|1\"));\n+        tests.add(new Object[]{calls, nonePhased2, 3, -1, -1, calls, tooSmallPhaseGroupException});\n \n         // test 2 phased variants\n+        final Genotype g1P = new GenotypeBuilder().alleles(Arrays.asList(ref, altC)).phased(true).make();\n+        final VariantContext vc1P = new VariantContextBuilder().chr(\"20\").start(1).stop(1).alleles(Arrays.asList(ref, altC)).genotypes(g1P).make();\n+        final Genotype g2P = new GenotypeBuilder().alleles(Arrays.asList(altC, ref)).phased(true).make();\n+        final VariantContext vc2P = new VariantContextBuilder().chr(\"20\").start(2).stop(2).alleles(Arrays.asList(ref, altC)).genotypes(g2P).make();\n+        final List<VariantContext> phasedCalls = Arrays.asList(vc1P, vc2P, vc3);\n+\n         final Map<VariantContext, Pair<Integer, String>> twoPhased = new HashMap<>();\n-        twoPhased.put(vc1, Pair.of(0, \"0/1\"));\n-        twoPhased.put(vc2, Pair.of(0, \"0/1\"));\n-        tests.add(new Object[]{calls, twoPhased, 1, 1, 2});\n+        twoPhased.put(vc1, Pair.of(0, \"0|1\"));\n+        twoPhased.put(vc2, Pair.of(0, \"1|0\"));\n+        tests.add(new Object[]{calls, twoPhased, 1, 1, 2, phasedCalls, null});\n \n         // test all phased variants\n+        final Genotype g3P = new GenotypeBuilder().alleles(Arrays.asList(ref, altC)).phased(true).make();\n+        final VariantContext vc3P = new VariantContextBuilder().chr(\"20\").start(3).stop(3).alleles(Arrays.asList(ref, altC)).genotypes(g3P).make();\n+        final List<VariantContext> phasedCalls2 = Arrays.asList(vc1P, vc2P, vc3P);\n+\n         final Map<VariantContext, Pair<Integer, String>> allPhased = new HashMap<>();\n-        allPhased.put(vc1, Pair.of(0, \"0/1\"));\n-        allPhased.put(vc2, Pair.of(0, \"0/1\"));\n-        allPhased.put(vc3, Pair.of(0, \"0/1\"));\n-        tests.add(new Object[]{calls, allPhased, 1, 1, 3});\n+        allPhased.put(vc1, Pair.of(0, \"0|1\"));\n+        allPhased.put(vc2, Pair.of(0, \"1|0\"));\n+        allPhased.put(vc3, Pair.of(0, \"0|1\"));\n+        tests.add(new Object[]{calls, allPhased, 1, 1, 3, phasedCalls2, null});\n+\n+        // test a spanning deletion case: unphased snp, deletion, spanned snp\n+        final Allele delref = Allele.create(\"AA\", true);\n+        final Allele delalt = Allele.create(\"A\", false);\n+\n+\n+        final Genotype g4 = new GenotypeBuilder().alleles(Arrays.asList(delref, delalt)).make();\n+        final VariantContext vc4 = new VariantContextBuilder().chr(\"20\").start(3).stop(4).alleles(Arrays.asList(delref, delalt)).genotypes(g4).make();\n+        final Genotype g5 = new GenotypeBuilder().alleles(Arrays.asList(Allele.SPAN_DEL, altC)).make();\n+        final VariantContext vc5 = new VariantContextBuilder().chr(\"20\").start(4).stop(4).alleles(Arrays.asList(ref, Allele.SPAN_DEL, altC)).genotypes(g5).make();\n+\n+        final Genotype g4P = new GenotypeBuilder().alleles(Arrays.asList(delref, delalt)).phased(true).make();\n+        final VariantContext vc4P = new VariantContextBuilder().chr(\"20\").start(3).stop(4).alleles(Arrays.asList(delref, delalt)).genotypes(g4P).make();\n+        final Genotype g5P = new GenotypeBuilder().alleles(Arrays.asList(altC, Allele.SPAN_DEL)).phased(true).make();\n+        final VariantContext vc5P = new VariantContextBuilder().chr(\"20\").start(4).stop(4).alleles(Arrays.asList(ref, Allele.SPAN_DEL, altC)).genotypes(g5P).make();\n+\n+        final List<VariantContext> spandelCalls = Arrays.asList(vc1, vc4, vc5);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "150e9e3af2747153cb78e85872e18d59dbb5b692"}, "originalPosition": 65}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDUyMDE0Mg==", "bodyText": "done", "url": "https://github.com/broadinstitute/gatk/pull/6937#discussion_r530520142", "createdAt": "2020-11-25T16:57:39Z", "author": {"login": "cwhelan"}, "path": "src/test/java/org/broadinstitute/hellbender/tools/walkers/haplotypecaller/AssemblyBasedCallerUtilsUnitTest.java", "diffHunk": "@@ -720,27 +720,62 @@ public void testGetEventMapper(final VariantContext mergedVc,\n \n         // test no phased variants, empty map\n         final Map<VariantContext, Pair<Integer, String>> nonePhased1 = new HashMap<>();\n-        tests.add(new Object[]{calls, nonePhased1, 0, 0, 0});\n+        tests.add(new Object[]{calls, nonePhased1, 0, 0, 0, calls, null});\n \n         // test no phased variants, full map, exception expected\n+        final IllegalStateException tooSmallPhaseGroupException = new IllegalStateException(\"Somehow we have a group of phased variants that has fewer than 2 members\");\n+\n         final Map<VariantContext, Pair<Integer, String>> nonePhased2 = new HashMap<>();\n-        nonePhased2.put(vc1, Pair.of(0, \"0/1\"));\n-        nonePhased2.put(vc2, Pair.of(1, \"0/1\"));\n-        nonePhased2.put(vc3, Pair.of(2, \"0/1\"));\n-        tests.add(new Object[]{calls, nonePhased2, 3, -1, -1});\n+        nonePhased2.put(vc1, Pair.of(0, \"0|1\"));\n+        nonePhased2.put(vc2, Pair.of(1, \"0|1\"));\n+        nonePhased2.put(vc3, Pair.of(2, \"0|1\"));\n+        tests.add(new Object[]{calls, nonePhased2, 3, -1, -1, calls, tooSmallPhaseGroupException});\n \n         // test 2 phased variants\n+        final Genotype g1P = new GenotypeBuilder().alleles(Arrays.asList(ref, altC)).phased(true).make();\n+        final VariantContext vc1P = new VariantContextBuilder().chr(\"20\").start(1).stop(1).alleles(Arrays.asList(ref, altC)).genotypes(g1P).make();\n+        final Genotype g2P = new GenotypeBuilder().alleles(Arrays.asList(altC, ref)).phased(true).make();\n+        final VariantContext vc2P = new VariantContextBuilder().chr(\"20\").start(2).stop(2).alleles(Arrays.asList(ref, altC)).genotypes(g2P).make();\n+        final List<VariantContext> phasedCalls = Arrays.asList(vc1P, vc2P, vc3);\n+\n         final Map<VariantContext, Pair<Integer, String>> twoPhased = new HashMap<>();\n-        twoPhased.put(vc1, Pair.of(0, \"0/1\"));\n-        twoPhased.put(vc2, Pair.of(0, \"0/1\"));\n-        tests.add(new Object[]{calls, twoPhased, 1, 1, 2});\n+        twoPhased.put(vc1, Pair.of(0, \"0|1\"));\n+        twoPhased.put(vc2, Pair.of(0, \"1|0\"));\n+        tests.add(new Object[]{calls, twoPhased, 1, 1, 2, phasedCalls, null});\n \n         // test all phased variants\n+        final Genotype g3P = new GenotypeBuilder().alleles(Arrays.asList(ref, altC)).phased(true).make();\n+        final VariantContext vc3P = new VariantContextBuilder().chr(\"20\").start(3).stop(3).alleles(Arrays.asList(ref, altC)).genotypes(g3P).make();\n+        final List<VariantContext> phasedCalls2 = Arrays.asList(vc1P, vc2P, vc3P);\n+\n         final Map<VariantContext, Pair<Integer, String>> allPhased = new HashMap<>();\n-        allPhased.put(vc1, Pair.of(0, \"0/1\"));\n-        allPhased.put(vc2, Pair.of(0, \"0/1\"));\n-        allPhased.put(vc3, Pair.of(0, \"0/1\"));\n-        tests.add(new Object[]{calls, allPhased, 1, 1, 3});\n+        allPhased.put(vc1, Pair.of(0, \"0|1\"));\n+        allPhased.put(vc2, Pair.of(0, \"1|0\"));\n+        allPhased.put(vc3, Pair.of(0, \"0|1\"));\n+        tests.add(new Object[]{calls, allPhased, 1, 1, 3, phasedCalls2, null});\n+\n+        // test a spanning deletion case: unphased snp, deletion, spanned snp\n+        final Allele delref = Allele.create(\"AA\", true);\n+        final Allele delalt = Allele.create(\"A\", false);\n+\n+\n+        final Genotype g4 = new GenotypeBuilder().alleles(Arrays.asList(delref, delalt)).make();\n+        final VariantContext vc4 = new VariantContextBuilder().chr(\"20\").start(3).stop(4).alleles(Arrays.asList(delref, delalt)).genotypes(g4).make();\n+        final Genotype g5 = new GenotypeBuilder().alleles(Arrays.asList(Allele.SPAN_DEL, altC)).make();\n+        final VariantContext vc5 = new VariantContextBuilder().chr(\"20\").start(4).stop(4).alleles(Arrays.asList(ref, Allele.SPAN_DEL, altC)).genotypes(g5).make();\n+\n+        final Genotype g4P = new GenotypeBuilder().alleles(Arrays.asList(delref, delalt)).phased(true).make();\n+        final VariantContext vc4P = new VariantContextBuilder().chr(\"20\").start(3).stop(4).alleles(Arrays.asList(delref, delalt)).genotypes(g4P).make();\n+        final Genotype g5P = new GenotypeBuilder().alleles(Arrays.asList(altC, Allele.SPAN_DEL)).phased(true).make();\n+        final VariantContext vc5P = new VariantContextBuilder().chr(\"20\").start(4).stop(4).alleles(Arrays.asList(ref, Allele.SPAN_DEL, altC)).genotypes(g5P).make();\n+\n+        final List<VariantContext> spandelCalls = Arrays.asList(vc1, vc4, vc5);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjMzMDYxMw=="}, "originalCommit": {"oid": "150e9e3af2747153cb78e85872e18d59dbb5b692"}, "originalPosition": 65}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 842, "cost": 1, "resetAt": "2021-11-12T13:16:51Z"}}}