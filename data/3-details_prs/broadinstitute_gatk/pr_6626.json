{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDI1MzUyMzgz", "number": 6626, "title": "More flexible matching of dbSNP variants", "bodyText": "Addresses two user requests to more flexibly and accurately match dbSNP variants.\nhttps://gatk.broadinstitute.org/hc/en-us/community/posts/360066006472-gatk-4-1-4-1-HaplotypeCaller-D-parameter-for-MIXED-type\nhttps://gatk.broadinstitute.org/hc/en-us/community/posts/360062537671-GATK-4-1-7-0-does-not-annotate-ID-using-dbSNP-build-153-VCF\nThe first change is to add all dbsnp id's which match a particular variant to the variant's id, instead of just the first one found in the dbsnp vcf.\nThe second change is to be less brittle to variant normalization issues, and match differing variant representations of the same underlying variant.  This is implemented by splitting and trimming multiallelics before checking for a match, which I suspect are the predominant cause of these types of matching failures.", "createdAt": "2020-05-29T22:02:14Z", "url": "https://github.com/broadinstitute/gatk/pull/6626", "merged": true, "mergeCommit": {"oid": "3ad0eca26e0ccf9edfa193f293cdb6bdeaafe21c"}, "closed": true, "closedAt": "2020-06-09T16:48:51Z", "author": {"login": "kachulis"}, "timelineItems": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcnvlZjgFqTQyMzkwMjA3NA==", "endCursor": "Y3Vyc29yOnYyOpPPAAABcoErmpABqjM0MDg3NDEwMjk=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIzOTAyMDc0", "url": "https://github.com/broadinstitute/gatk/pull/6626#pullrequestreview-423902074", "createdAt": "2020-06-03T20:24:38Z", "commit": {"oid": "904afa90cd05689fcf7911840aa5392dffc06d34"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wM1QyMDoyNDozOFrOGesEDw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wM1QyMDozMzo1NVrOGesWkQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDgzMjM5OQ==", "bodyText": "Hmm... splitVariantContextToBiallelics() claims that under some circumstances it results in variants getting pushed forwards on the genome. This is all fine and well but it leaves a hole here where there could be a variant in the input (or the DBSNP) that gets moved and would otherwise match with the next variant in the other file. Not that the old code could handle this case any better... This is a very niche circumstance and probably doesn't warrant worrying about. I do think we should probably document this fact in a comment somewhere.", "url": "https://github.com/broadinstitute/gatk/pull/6626#discussion_r434832399", "createdAt": "2020-06-03T20:24:38Z", "author": {"login": "jamesemery"}, "path": "src/main/java/org/broadinstitute/hellbender/tools/walkers/annotator/VariantOverlapAnnotator.java", "diffHunk": "@@ -156,26 +158,39 @@ public VariantContext annotateOverlap(final List<VariantContext> overlapTestVCs,\n     private static String getRsID(final List<VariantContext> rsIDSourceVCs, final VariantContext vcToAnnotate) {\n         Utils.nonNull(rsIDSourceVCs, \"rsIDSourceVCs cannot be null\");\n         Utils.nonNull(vcToAnnotate, \"vcToAnnotate cannot be null\");\n+        final List<String> rsids = new ArrayList<>();\n \n-        for ( final VariantContext vcComp : rsIDSourceVCs ) {\n-            if ( vcComp.isFiltered() ) {\n+        final List<VariantContext> vcAnnotateList = GATKVariantContextUtils.splitVariantContextToBiallelics(vcToAnnotate, true,\n+                GenotypeAssignmentMethod.SET_TO_NO_CALL_NO_ANNOTATIONS, true);\n+\n+        for ( final VariantContext vcCompSource : rsIDSourceVCs ) {\n+            if ( vcCompSource.isFiltered() ) {\n                 continue; // don't process any failed VCs\n             }\n \n-            if ( ! vcComp.getContig().equals(vcToAnnotate.getContig()) || vcComp.getStart() != vcToAnnotate.getStart() ) {\n-                throw new IllegalArgumentException(\"source rsID VariantContext \" + vcComp + \" doesn't start at the same position as vcToAnnotate \" + vcToAnnotate);\n+            if (!vcCompSource.getContig().equals(vcToAnnotate.getContig())) {\n+                throw new IllegalArgumentException(\"source rsID VariantContext \" + vcCompSource + \" is not on same chromosome as vcToAnnotate \" + vcToAnnotate);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "904afa90cd05689fcf7911840aa5392dffc06d34"}, "originalPosition": 48}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDgzNDI2NQ==", "bodyText": "Wait a minute.... is vcToAnnotateBi.getAlternateAlleles() really adequate here? This means that two deletions of different lengths are exactly the same as far as our DBSNP annotations are concerned? That doesn't seem right...", "url": "https://github.com/broadinstitute/gatk/pull/6626#discussion_r434834265", "createdAt": "2020-06-03T20:28:07Z", "author": {"login": "jamesemery"}, "path": "src/main/java/org/broadinstitute/hellbender/tools/walkers/annotator/VariantOverlapAnnotator.java", "diffHunk": "@@ -156,26 +158,39 @@ public VariantContext annotateOverlap(final List<VariantContext> overlapTestVCs,\n     private static String getRsID(final List<VariantContext> rsIDSourceVCs, final VariantContext vcToAnnotate) {\n         Utils.nonNull(rsIDSourceVCs, \"rsIDSourceVCs cannot be null\");\n         Utils.nonNull(vcToAnnotate, \"vcToAnnotate cannot be null\");\n+        final List<String> rsids = new ArrayList<>();\n \n-        for ( final VariantContext vcComp : rsIDSourceVCs ) {\n-            if ( vcComp.isFiltered() ) {\n+        final List<VariantContext> vcAnnotateList = GATKVariantContextUtils.splitVariantContextToBiallelics(vcToAnnotate, true,\n+                GenotypeAssignmentMethod.SET_TO_NO_CALL_NO_ANNOTATIONS, true);\n+\n+        for ( final VariantContext vcCompSource : rsIDSourceVCs ) {\n+            if ( vcCompSource.isFiltered() ) {\n                 continue; // don't process any failed VCs\n             }\n \n-            if ( ! vcComp.getContig().equals(vcToAnnotate.getContig()) || vcComp.getStart() != vcToAnnotate.getStart() ) {\n-                throw new IllegalArgumentException(\"source rsID VariantContext \" + vcComp + \" doesn't start at the same position as vcToAnnotate \" + vcToAnnotate);\n+            if (!vcCompSource.getContig().equals(vcToAnnotate.getContig())) {\n+                throw new IllegalArgumentException(\"source rsID VariantContext \" + vcCompSource + \" is not on same chromosome as vcToAnnotate \" + vcToAnnotate);\n             }\n \n-            if ( vcToAnnotate.getReference().equals(vcComp.getReference()) ) {\n-                for ( final Allele allele : vcToAnnotate.getAlternateAlleles() ) {\n-                    if ( vcComp.getAlternateAlleles().contains(allele) ) {\n-                        return vcComp.getID();\n+            final List<VariantContext> vcCompList = GATKVariantContextUtils.splitVariantContextToBiallelics(vcCompSource, true,\n+                    GenotypeAssignmentMethod.SET_TO_NO_CALL_NO_ANNOTATIONS, true);\n+            boolean addThisID = false;\n+            for (final VariantContext vcComp : vcCompList) {\n+                for (final VariantContext vcToAnnotateBi : vcAnnotateList) {\n+                    if (vcComp.getStart() == vcToAnnotateBi.getStart() && vcToAnnotateBi.getReference().equals(vcComp.getReference()) && vcComp.getAlternateAlleles().equals(vcToAnnotateBi.getAlternateAlleles())) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "904afa90cd05689fcf7911840aa5392dffc06d34"}, "originalPosition": 60}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDgzNTIyNQ==", "bodyText": "Can you add a test with a DBSNP annotation with a particular length deletion and a variant that is also a deletion but with a different length to the annotation deletion? I have a hunch it will end up adding the annotation erroneously.", "url": "https://github.com/broadinstitute/gatk/pull/6626#discussion_r434835225", "createdAt": "2020-06-03T20:30:00Z", "author": {"login": "jamesemery"}, "path": "src/test/java/org/broadinstitute/hellbender/tools/walkers/annotator/VariantOverlapAnnotatorUnitTest.java", "diffHunk": "@@ -91,6 +91,29 @@ public void testCreateWithSpecialNames() {\n         tests.add(new Object[]{callNoIDAC, Arrays.asList(dbSNP_AC_AG), \"rsID1;rsID3\", true});\n         tests.add(new Object[]{callNoIDAT, Arrays.asList(dbSNP_AC_AG), VCFConstants.EMPTY_ID_FIELD, false});\n \n+        //multiple rsid which match multiallelic site\n+        final VariantContext callNoIDT_C_TAC = makeVC(\"call\", VCFConstants.EMPTY_ID_FIELD, Arrays.asList(\"T\", \"C\", \"TAC\"));\n+\n+        final VariantContext dbSNP_T_TAC_TATAC = makeVC(\"DBSNP\", \"rsID1\", Arrays.asList(\"T\", \"TAC\", \"TATAC\"));\n+        final VariantContext dbSNP_T_C = makeVC(\"DBSNP\", \"rsID2\", Arrays.asList(\"T\", \"C\"));\n+\n+        tests.add(new Object[]{callNoIDT_C_TAC, Arrays.asList(dbSNP_T_TAC_TATAC, dbSNP_T_C), \"rsID1;rsID2\", true});\n+        tests.add(new Object[]{callNoIDT_C_TAC, Arrays.asList(dbSNP_T_C,dbSNP_T_TAC_TATAC), \"rsID2;rsID1\", true});\n+\n+        //mixed multiallelic in dbsnp\n+        final VariantContext callNOID_T_TTCC = makeVC(\"call\", VCFConstants.EMPTY_ID_FIELD, Arrays.asList(\"T\", \"TTCC\"));\n+\n+        final VariantContext dbSNP_complex_mixed_site = makeVC(\"DBSNP\", \"rsID1\", Arrays.asList(\"TTCCTCCTCCTCCTCCTCC\", \"T\", \"TTCCTCCTCCTCCTCCTCCTCC\"));\n+\n+        tests.add(new Object[]{callNOID_T_TTCC, Arrays.asList(dbSNP_complex_mixed_site), \"rsID1\", true});\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "904afa90cd05689fcf7911840aa5392dffc06d34"}, "originalPosition": 19}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDgzNjM1Mw==", "bodyText": "But it would care about insertions being an exact match?", "url": "https://github.com/broadinstitute/gatk/pull/6626#discussion_r434836353", "createdAt": "2020-06-03T20:32:22Z", "author": {"login": "jamesemery"}, "path": "src/main/java/org/broadinstitute/hellbender/tools/walkers/annotator/VariantOverlapAnnotator.java", "diffHunk": "@@ -156,26 +158,39 @@ public VariantContext annotateOverlap(final List<VariantContext> overlapTestVCs,\n     private static String getRsID(final List<VariantContext> rsIDSourceVCs, final VariantContext vcToAnnotate) {\n         Utils.nonNull(rsIDSourceVCs, \"rsIDSourceVCs cannot be null\");\n         Utils.nonNull(vcToAnnotate, \"vcToAnnotate cannot be null\");\n+        final List<String> rsids = new ArrayList<>();\n \n-        for ( final VariantContext vcComp : rsIDSourceVCs ) {\n-            if ( vcComp.isFiltered() ) {\n+        final List<VariantContext> vcAnnotateList = GATKVariantContextUtils.splitVariantContextToBiallelics(vcToAnnotate, true,\n+                GenotypeAssignmentMethod.SET_TO_NO_CALL_NO_ANNOTATIONS, true);\n+\n+        for ( final VariantContext vcCompSource : rsIDSourceVCs ) {\n+            if ( vcCompSource.isFiltered() ) {\n                 continue; // don't process any failed VCs\n             }\n \n-            if ( ! vcComp.getContig().equals(vcToAnnotate.getContig()) || vcComp.getStart() != vcToAnnotate.getStart() ) {\n-                throw new IllegalArgumentException(\"source rsID VariantContext \" + vcComp + \" doesn't start at the same position as vcToAnnotate \" + vcToAnnotate);\n+            if (!vcCompSource.getContig().equals(vcToAnnotate.getContig())) {\n+                throw new IllegalArgumentException(\"source rsID VariantContext \" + vcCompSource + \" is not on same chromosome as vcToAnnotate \" + vcToAnnotate);\n             }\n \n-            if ( vcToAnnotate.getReference().equals(vcComp.getReference()) ) {\n-                for ( final Allele allele : vcToAnnotate.getAlternateAlleles() ) {\n-                    if ( vcComp.getAlternateAlleles().contains(allele) ) {\n-                        return vcComp.getID();\n+            final List<VariantContext> vcCompList = GATKVariantContextUtils.splitVariantContextToBiallelics(vcCompSource, true,\n+                    GenotypeAssignmentMethod.SET_TO_NO_CALL_NO_ANNOTATIONS, true);\n+            boolean addThisID = false;\n+            for (final VariantContext vcComp : vcCompList) {\n+                for (final VariantContext vcToAnnotateBi : vcAnnotateList) {\n+                    if (vcComp.getStart() == vcToAnnotateBi.getStart() && vcToAnnotateBi.getReference().equals(vcComp.getReference()) && vcComp.getAlternateAlleles().equals(vcToAnnotateBi.getAlternateAlleles())) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDgzNDI2NQ=="}, "originalCommit": {"oid": "904afa90cd05689fcf7911840aa5392dffc06d34"}, "originalPosition": 60}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDgzNjY3Mg==", "bodyText": "Also test for insertions of various lengths.", "url": "https://github.com/broadinstitute/gatk/pull/6626#discussion_r434836672", "createdAt": "2020-06-03T20:32:58Z", "author": {"login": "jamesemery"}, "path": "src/test/java/org/broadinstitute/hellbender/tools/walkers/annotator/VariantOverlapAnnotatorUnitTest.java", "diffHunk": "@@ -91,6 +91,29 @@ public void testCreateWithSpecialNames() {\n         tests.add(new Object[]{callNoIDAC, Arrays.asList(dbSNP_AC_AG), \"rsID1;rsID3\", true});\n         tests.add(new Object[]{callNoIDAT, Arrays.asList(dbSNP_AC_AG), VCFConstants.EMPTY_ID_FIELD, false});\n \n+        //multiple rsid which match multiallelic site\n+        final VariantContext callNoIDT_C_TAC = makeVC(\"call\", VCFConstants.EMPTY_ID_FIELD, Arrays.asList(\"T\", \"C\", \"TAC\"));\n+\n+        final VariantContext dbSNP_T_TAC_TATAC = makeVC(\"DBSNP\", \"rsID1\", Arrays.asList(\"T\", \"TAC\", \"TATAC\"));\n+        final VariantContext dbSNP_T_C = makeVC(\"DBSNP\", \"rsID2\", Arrays.asList(\"T\", \"C\"));\n+\n+        tests.add(new Object[]{callNoIDT_C_TAC, Arrays.asList(dbSNP_T_TAC_TATAC, dbSNP_T_C), \"rsID1;rsID2\", true});\n+        tests.add(new Object[]{callNoIDT_C_TAC, Arrays.asList(dbSNP_T_C,dbSNP_T_TAC_TATAC), \"rsID2;rsID1\", true});\n+\n+        //mixed multiallelic in dbsnp\n+        final VariantContext callNOID_T_TTCC = makeVC(\"call\", VCFConstants.EMPTY_ID_FIELD, Arrays.asList(\"T\", \"TTCC\"));\n+\n+        final VariantContext dbSNP_complex_mixed_site = makeVC(\"DBSNP\", \"rsID1\", Arrays.asList(\"TTCCTCCTCCTCCTCCTCC\", \"T\", \"TTCCTCCTCCTCCTCCTCCTCC\"));\n+\n+        tests.add(new Object[]{callNOID_T_TTCC, Arrays.asList(dbSNP_complex_mixed_site), \"rsID1\", true});\n+", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDgzNTIyNQ=="}, "originalCommit": {"oid": "904afa90cd05689fcf7911840aa5392dffc06d34"}, "originalPosition": 19}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDgzNzEzNw==", "bodyText": "Update the @return line of the comments.", "url": "https://github.com/broadinstitute/gatk/pull/6626#discussion_r434837137", "createdAt": "2020-06-03T20:33:55Z", "author": {"login": "jamesemery"}, "path": "src/main/java/org/broadinstitute/hellbender/tools/walkers/annotator/VariantOverlapAnnotator.java", "diffHunk": "@@ -156,26 +158,39 @@ public VariantContext annotateOverlap(final List<VariantContext> overlapTestVCs,\n     private static String getRsID(final List<VariantContext> rsIDSourceVCs, final VariantContext vcToAnnotate) {\n         Utils.nonNull(rsIDSourceVCs, \"rsIDSourceVCs cannot be null\");\n         Utils.nonNull(vcToAnnotate, \"vcToAnnotate cannot be null\");\n+        final List<String> rsids = new ArrayList<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "904afa90cd05689fcf7911840aa5392dffc06d34"}, "originalPosition": 33}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI0Njk5NTM5", "url": "https://github.com/broadinstitute/gatk/pull/6626#pullrequestreview-424699539", "createdAt": "2020-06-04T18:04:35Z", "commit": {"oid": "63155f6e03a4b0dbde28e6e0498900209081cfd9"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0817dea74de62b078dc192420432720215ac4b18", "author": {"user": {"login": "kachulis", "name": null}}, "url": "https://github.com/broadinstitute/gatk/commit/0817dea74de62b078dc192420432720215ac4b18", "committedDate": "2020-06-04T21:02:42Z", "message": "multiple dbsnp annotations"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "52aaac69e18e4dd4b35f33dc9c25d6285cce2bbe", "author": {"user": {"login": "kachulis", "name": null}}, "url": "https://github.com/broadinstitute/gatk/commit/52aaac69e18e4dd4b35f33dc9c25d6285cce2bbe", "committedDate": "2020-06-04T21:02:42Z", "message": "more flexible dbsnp matching"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1f0b73a1bae4533df20ba81d1c110489c3f24e69", "author": {"user": {"login": "kachulis", "name": null}}, "url": "https://github.com/broadinstitute/gatk/commit/1f0b73a1bae4533df20ba81d1c110489c3f24e69", "committedDate": "2020-06-04T21:02:42Z", "message": "review response"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3a7b57afe795387781e371f05a1470f197aa397c", "author": {"user": {"login": "kachulis", "name": null}}, "url": "https://github.com/broadinstitute/gatk/commit/3a7b57afe795387781e371f05a1470f197aa397c", "committedDate": "2020-06-04T21:09:54Z", "message": "updating rsids in expected output to make tests pass"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "63155f6e03a4b0dbde28e6e0498900209081cfd9", "author": {"user": {"login": "kachulis", "name": null}}, "url": "https://github.com/broadinstitute/gatk/commit/63155f6e03a4b0dbde28e6e0498900209081cfd9", "committedDate": "2020-06-04T17:54:13Z", "message": "review response"}, "afterCommit": {"oid": "3a7b57afe795387781e371f05a1470f197aa397c", "author": {"user": {"login": "kachulis", "name": null}}, "url": "https://github.com/broadinstitute/gatk/commit/3a7b57afe795387781e371f05a1470f197aa397c", "committedDate": "2020-06-04T21:09:54Z", "message": "updating rsids in expected output to make tests pass"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2609, "cost": 1, "resetAt": "2021-11-01T13:07:16Z"}}}