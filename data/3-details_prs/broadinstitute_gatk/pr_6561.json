{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDA2OTIwNTU5", "number": 6561, "title": "Migrate read arguments and downstream code to GATKPathSpecifier", "bodyText": "WIP. Some VCF outs are also converted, and probably a few other things as well.", "createdAt": "2020-04-21T21:32:26Z", "url": "https://github.com/broadinstitute/gatk/pull/6561", "merged": true, "mergeCommit": {"oid": "74c0e482309e522edc88cd4e4877ec6b10efc18d"}, "closed": true, "closedAt": "2020-06-02T18:48:18Z", "author": {"login": "cmnbroad"}, "timelineItems": {"totalCount": 22, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcevQ__gFqTQwNjkxNTM1OA==", "endCursor": "Y3Vyc29yOnYyOpPPAAABcnZA1aAFqTQyMjk0MjQxNw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA2OTE1MzU4", "url": "https://github.com/broadinstitute/gatk/pull/6561#pullrequestreview-406915358", "createdAt": "2020-05-06T19:19:08Z", "commit": {"oid": "921e051ca633b9282340864620806d950532c8c7"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 16, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNlQxOToxOTowOFrOGRh1Iw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNlQyMTowNTozM1rOGRlaGg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTAzMzI1MQ==", "bodyText": "This mention of Paths being the preferred form is no longer true with this PR.", "url": "https://github.com/broadinstitute/gatk/pull/6561#discussion_r421033251", "createdAt": "2020-05-06T19:19:08Z", "author": {"login": "lbergelson"}, "path": "src/main/java/org/broadinstitute/hellbender/cmdline/argumentcollections/ReadInputArgumentCollection.java", "diffHunk": "@@ -30,18 +31,27 @@\n     protected ValidationStringency readValidationStringency = ReadConstants.DEFAULT_READ_VALIDATION_STRINGENCY;\n \n     @Argument(fullName = StandardArgumentDefinitions.READ_INDEX_LONG_NAME, shortName = StandardArgumentDefinitions.READ_INDEX_SHORT_NAME,\n-              doc = \"Indices to use for the read inputs. If specified, an index must be provided for every read input \" +\n+            doc = \"Indices to use for the read inputs. If specified, an index must be provided for every read input \" +\n                     \"and in the same order as the read inputs. If this argument is not specified, the path to the index \" +\n                     \"for each input will be inferred automatically.\",\n-              common = true,\n-              optional = true)\n-    protected List<String> readIndices;\n+            common = true,\n+            optional = true)\n+    protected List<GATKPathSpecifier> readIndices;\n \n     /**\n      * Get the list of BAM/SAM/CRAM files specified at the command line.\n      * Paths are the preferred format, as this can handle both local disk and NIO direct access to cloud storage.\n      */\n-    public abstract List<Path> getReadPaths();\n+    public abstract List<GATKPathSpecifier> getReadPathSpecifiers();\n+\n+    /**\n+     * Get the list of BAM/SAM/CRAM files specified at the command line.\n+     * Paths are the preferred format, as this can handle both local disk and NIO direct access to cloud storage.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "921e051ca633b9282340864620806d950532c8c7"}, "originalPosition": 32}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTAzMzQ1Nw==", "bodyText": "The comment about Paths isn't accurate anymore.", "url": "https://github.com/broadinstitute/gatk/pull/6561#discussion_r421033457", "createdAt": "2020-05-06T19:19:32Z", "author": {"login": "lbergelson"}, "path": "src/main/java/org/broadinstitute/hellbender/cmdline/argumentcollections/ReadInputArgumentCollection.java", "diffHunk": "@@ -30,18 +31,27 @@\n     protected ValidationStringency readValidationStringency = ReadConstants.DEFAULT_READ_VALIDATION_STRINGENCY;\n \n     @Argument(fullName = StandardArgumentDefinitions.READ_INDEX_LONG_NAME, shortName = StandardArgumentDefinitions.READ_INDEX_SHORT_NAME,\n-              doc = \"Indices to use for the read inputs. If specified, an index must be provided for every read input \" +\n+            doc = \"Indices to use for the read inputs. If specified, an index must be provided for every read input \" +\n                     \"and in the same order as the read inputs. If this argument is not specified, the path to the index \" +\n                     \"for each input will be inferred automatically.\",\n-              common = true,\n-              optional = true)\n-    protected List<String> readIndices;\n+            common = true,\n+            optional = true)\n+    protected List<GATKPathSpecifier> readIndices;\n \n     /**\n      * Get the list of BAM/SAM/CRAM files specified at the command line.\n      * Paths are the preferred format, as this can handle both local disk and NIO direct access to cloud storage.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "921e051ca633b9282340864620806d950532c8c7"}, "originalPosition": 25}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTAzMzc2MQ==", "bodyText": "comment is out of date", "url": "https://github.com/broadinstitute/gatk/pull/6561#discussion_r421033761", "createdAt": "2020-05-06T19:20:03Z", "author": {"login": "lbergelson"}, "path": "src/main/java/org/broadinstitute/hellbender/cmdline/argumentcollections/RequiredReadInputArgumentCollection.java", "diffHunk": "@@ -16,28 +17,11 @@\n public final class RequiredReadInputArgumentCollection extends ReadInputArgumentCollection {\n     private static final long serialVersionUID = 1L;\n     @Argument(fullName = StandardArgumentDefinitions.INPUT_LONG_NAME, shortName = StandardArgumentDefinitions.INPUT_SHORT_NAME, doc = \"BAM/SAM/CRAM file containing reads\", optional = false, common = true)\n-    public List<String> readFilesNames;\n+    public List<GATKPathSpecifier> readFilesNames;\n \n-    @Override\n-    public List<File> getReadFiles() {\n-        ArrayList<File> ret = new ArrayList<>();\n-        for (String fn : readFilesNames) {\n-            ret.add(new File(fn));\n-        }\n-        return ret;\n-    }\n-\n-    @Override\n-    public List<Path> getReadPaths() {\n-        ArrayList<Path> ret = new ArrayList<>();\n-        for (String fn : readFilesNames) {\n-            ret.add(IOUtils.getPath(fn));\n-        }\n-        return ret;\n-    }\n-\n-    @Override\n-    public List<String> getReadFilesNames() {\n-        return new ArrayList<>(readFilesNames);\n-    }\n+    /**\n+     * Get the list of BAM/SAM/CRAM files specified at the command line.\n+     * Paths are the preferred format, as this can handle both local disk and NIO direct access to cloud storage.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "921e051ca633b9282340864620806d950532c8c7"}, "originalPosition": 47}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTAzNDEzMw==", "bodyText": "Ah, thanks for updating this.", "url": "https://github.com/broadinstitute/gatk/pull/6561#discussion_r421034133", "createdAt": "2020-05-06T19:20:43Z", "author": {"login": "lbergelson"}, "path": "src/main/java/org/broadinstitute/hellbender/engine/GATKTool.java", "diffHunk": "@@ -277,7 +281,7 @@ public CountingReadFilter makeReadFilter(){\n \n     /**\n      * Must be overridden in order to add annotation arguments to the engine. If this is set to true the engine will\n-     * dynamically discover all {@link Annotation}s in the package defined by {@link org.broadinstitute.hellbender.cmdline.GATKPlugin.GATKAnnotationPluginDescriptor#pluginPackageName} and automatically\n+     * dynamically discover all {@link Annotation}s in the packages defined by {@link GATKAnnotationPluginDescriptor#getPackageNames()} and automatically", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "921e051ca633b9282340864620806d950532c8c7"}, "originalPosition": 16}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTAzNjE1Mg==", "bodyText": "This doesn't deal correctly with http path ending weirdness.  I think we should add a \"getExtension\" or 'getFilename\" method to avoid making this mistake.", "url": "https://github.com/broadinstitute/gatk/pull/6561#discussion_r421036152", "createdAt": "2020-05-06T19:24:05Z", "author": {"login": "lbergelson"}, "path": "src/main/java/org/broadinstitute/hellbender/engine/spark/GATKSparkTool.java", "diffHunk": "@@ -323,31 +323,31 @@ public SAMFileHeader getHeaderForReads() {\n \n         JavaRDD<GATKRead> output = null;\n         ReadsSparkSource source = readsSource;\n-        for (String input : readInputs.keySet()) {\n+        for (final GATKPathSpecifier inputPathSpecifier : readInputs.keySet()) {\n             if (output == null) {\n-                output = getGatkReadJavaRDD(traversalParameters, source, input);\n+                output = getGatkReadJavaRDD(traversalParameters, source, inputPathSpecifier);\n             } else {\n-                output = output.union(getGatkReadJavaRDD(traversalParameters, source, input));\n+                output = output.union(getGatkReadJavaRDD(traversalParameters, source, inputPathSpecifier));\n             }\n         }\n         return output;\n     }\n \n-    protected JavaRDD<GATKRead> getGatkReadJavaRDD(TraversalParameters traversalParameters, ReadsSparkSource source, String input) {\n+    protected JavaRDD<GATKRead> getGatkReadJavaRDD(TraversalParameters traversalParameters, ReadsSparkSource source, GATKPathSpecifier inputSpecifier) {\n         JavaRDD<GATKRead> output;\n         // TODO: This if statement is a temporary hack until #959 gets resolve\n-        if (input.endsWith(\".adam\")) {\n+        if (inputSpecifier.getURIString().endsWith(\".adam\")) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "921e051ca633b9282340864620806d950532c8c7"}, "originalPosition": 31}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTAzNzkwNg==", "bodyText": "A good improvement would be to add spark ReadInputArgument collections which only takes a single bam. Maybe we can do that in a separate pr.", "url": "https://github.com/broadinstitute/gatk/pull/6561#discussion_r421037906", "createdAt": "2020-05-06T19:27:15Z", "author": {"login": "lbergelson"}, "path": "src/main/java/org/broadinstitute/hellbender/engine/spark/GATKSparkTool.java", "diffHunk": "@@ -504,20 +504,25 @@ public boolean useVariantAnnotations() {\n     }\n \n     /**\n-     * Returns the name of the source of reads data. It can be a file name or URL.\n+     * Returns the name of the source of reads data. It can be a file name or URL. Throws if the tool has more", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "921e051ca633b9282340864620806d950532c8c7"}, "originalPosition": 63}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTAzODI4NA==", "bodyText": "maybe getHeaderForReadsInput would be better.", "url": "https://github.com/broadinstitute/gatk/pull/6561#discussion_r421038284", "createdAt": "2020-05-06T19:27:59Z", "author": {"login": "lbergelson"}, "path": "src/main/java/org/broadinstitute/hellbender/engine/spark/GATKSparkTool.java", "diffHunk": "@@ -504,20 +504,25 @@ public boolean useVariantAnnotations() {\n     }\n \n     /**\n-     * Returns the name of the source of reads data. It can be a file name or URL.\n+     * Returns the name of the source of reads data. It can be a file name or URL. Throws if the tool has more\n+     * than one source.\n      */\n-    protected List<String> getReadSourceName(){\n+    protected String getReadSourceName(){\n         if (readInputs.size() > 1) {\n-            throw new GATKException(\"Multiple ReadsDataSources specificed but a single source requested by the tool\");\n+            throw new GATKException(\"Multiple ReadsDataSources specified but a single source requested by the tool\");\n         }\n-        return new ArrayList<>(readInputs.keySet());\n+        return readInputs.keySet().stream().findFirst().get().toString();\n     }\n \n     /**\n-     * Returns a map of read input to header.\n+     * Returns the header for a given input.\n      */\n-    protected LinkedHashMap<String, SAMFileHeader> getReadSourceHeaderMap(){\n-        return readInputs;\n+    protected SAMFileHeader getHeaderForInputPath(final GATKPathSpecifier inputPathSpecifier){", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "921e051ca633b9282340864620806d950532c8c7"}, "originalPosition": 82}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTAzOTI3NA==", "bodyText": "If we're changing other stuff to single read inputs maybe we should just change the underlying map into a single field.  I think that plan had been to support multiple inputs later but we never got to it.", "url": "https://github.com/broadinstitute/gatk/pull/6561#discussion_r421039274", "createdAt": "2020-05-06T19:29:38Z", "author": {"login": "lbergelson"}, "path": "src/main/java/org/broadinstitute/hellbender/engine/spark/GATKSparkTool.java", "diffHunk": "@@ -504,20 +504,25 @@ public boolean useVariantAnnotations() {\n     }\n \n     /**\n-     * Returns the name of the source of reads data. It can be a file name or URL.\n+     * Returns the name of the source of reads data. It can be a file name or URL. Throws if the tool has more\n+     * than one source.\n      */\n-    protected List<String> getReadSourceName(){\n+    protected String getReadSourceName(){\n         if (readInputs.size() > 1) {\n-            throw new GATKException(\"Multiple ReadsDataSources specificed but a single source requested by the tool\");\n+            throw new GATKException(\"Multiple ReadsDataSources specified but a single source requested by the tool\");\n         }\n-        return new ArrayList<>(readInputs.keySet());\n+        return readInputs.keySet().stream().findFirst().get().toString();\n     }\n \n     /**\n-     * Returns a map of read input to header.\n+     * Returns the header for a given input.\n      */\n-    protected LinkedHashMap<String, SAMFileHeader> getReadSourceHeaderMap(){\n-        return readInputs;\n+    protected SAMFileHeader getHeaderForInputPath(final GATKPathSpecifier inputPathSpecifier){", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTAzODI4NA=="}, "originalCommit": {"oid": "921e051ca633b9282340864620806d950532c8c7"}, "originalPosition": 82}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTA0MjU1NA==", "bodyText": "As mentioned above, lets add methods for these to GATKPathSpecifier", "url": "https://github.com/broadinstitute/gatk/pull/6561#discussion_r421042554", "createdAt": "2020-05-06T19:35:31Z", "author": {"login": "lbergelson"}, "path": "src/main/java/org/broadinstitute/hellbender/tools/SplitReads.java", "diffHunk": "@@ -156,9 +157,9 @@ private SAMFileGATKReadWriter prepareSAMFileWriter(\n             SAMFileWriterFactory samFileWriterFactory,\n             SAMFileHeader samFileHeaderIn,\n             final String keyName) {\n-        final String base = FilenameUtils.getBaseName(readArguments.getReadFiles().get(0).getName());\n-        final String extension = \".\" + FilenameUtils.getExtension(readArguments.getReadFiles().get(0).getName());\n-        final File outFile = new File(OUTPUT_DIRECTORY, base + keyName + extension);\n+        final String base = FilenameUtils.getBaseName(readArguments.getReadPathSpecifiers().get(0).getURI().getSchemeSpecificPart());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "921e051ca633b9282340864620806d950532c8c7"}, "originalPosition": 24}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTA4NjQ5NQ==", "bodyText": "While we're here can we make OUTPUT_DIRECTORY a GATKPathSpecifier too and avoid going through File here.", "url": "https://github.com/broadinstitute/gatk/pull/6561#discussion_r421086495", "createdAt": "2020-05-06T20:56:03Z", "author": {"login": "lbergelson"}, "path": "src/main/java/org/broadinstitute/hellbender/tools/SplitReads.java", "diffHunk": "@@ -156,9 +157,9 @@ private SAMFileGATKReadWriter prepareSAMFileWriter(\n             SAMFileWriterFactory samFileWriterFactory,\n             SAMFileHeader samFileHeaderIn,\n             final String keyName) {\n-        final String base = FilenameUtils.getBaseName(readArguments.getReadFiles().get(0).getName());\n-        final String extension = \".\" + FilenameUtils.getExtension(readArguments.getReadFiles().get(0).getName());\n-        final File outFile = new File(OUTPUT_DIRECTORY, base + keyName + extension);\n+        final String base = FilenameUtils.getBaseName(readArguments.getReadPathSpecifiers().get(0).getURI().getSchemeSpecificPart());\n+        final String extension = \".\" + FilenameUtils.getExtension(readArguments.getReadPathSpecifiers().get(0).getURI().getSchemeSpecificPart());\n+        final GATKPathSpecifier outFile = new GATKPathSpecifier(new File(OUTPUT_DIRECTORY, base + keyName + extension).getAbsolutePath());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "921e051ca633b9282340864620806d950532c8c7"}, "originalPosition": 26}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTA4ODExOQ==", "bodyText": "might have weirdness with http paths with cruft after them", "url": "https://github.com/broadinstitute/gatk/pull/6561#discussion_r421088119", "createdAt": "2020-05-06T20:59:02Z", "author": {"login": "lbergelson"}, "path": "src/main/java/org/broadinstitute/hellbender/tools/spark/RevertSamSpark.java", "diffHunk": "@@ -269,7 +269,7 @@ protected void runTool(JavaSparkContext ctx) {\n         ////////////////////////////////////////////////////////////////////////////\n         Map<String, Path> writerMap = getOutputMap(outputMap,\n                                                   output,\n-                                                  getDefaultExtension(readArguments.getReadFiles().get(0).toString(), outputByReadgroupFileFormat),\n+                                                  getDefaultExtension(readArguments.getReadPathSpecifiers().get(0).getRawInputString(), outputByReadgroupFileFormat),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "921e051ca633b9282340864620806d950532c8c7"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTA4ODcyNA==", "bodyText": "Can we lift the GATKPathSpecifier higher here and get rid of the string or is that difficult?", "url": "https://github.com/broadinstitute/gatk/pull/6561#discussion_r421088724", "createdAt": "2020-05-06T20:59:59Z", "author": {"login": "lbergelson"}, "path": "src/main/java/org/broadinstitute/hellbender/tools/spark/pathseq/PSUtils.java", "diffHunk": "@@ -57,12 +58,13 @@ public static void logItemizedWarning(final Logger logger, final Collection<?> i\n     /**\n      * Same as GATKSparkTool's getRecommendedNumReducers(), but can specify input BAM path (for when --input is not used)\n      */\n+    //TODO: fix this", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "921e051ca633b9282340864620806d950532c8c7"}, "originalPosition": 12}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTA4OTI1NA==", "bodyText": "Can these paths be input as Path specifiers instead of strings here?", "url": "https://github.com/broadinstitute/gatk/pull/6561#discussion_r421089254", "createdAt": "2020-05-06T21:00:54Z", "author": {"login": "lbergelson"}, "path": "src/main/java/org/broadinstitute/hellbender/tools/spark/pathseq/PathSeqBwaSpark.java", "diffHunk": "@@ -152,12 +153,12 @@\n                                                              final ReadsSparkSource readsSource) {\n         if (path == null) return null;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "921e051ca633b9282340864620806d950532c8c7"}, "originalPosition": 10}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTA4OTU4NQ==", "bodyText": "looks like the same thread as above, I assume the todos mean we should hit them later instead of in this PR?  Should we open an issue?", "url": "https://github.com/broadinstitute/gatk/pull/6561#discussion_r421089585", "createdAt": "2020-05-06T21:01:33Z", "author": {"login": "lbergelson"}, "path": "src/main/java/org/broadinstitute/hellbender/tools/spark/pathseq/PathSeqScoreSpark.java", "diffHunk": "@@ -136,13 +137,15 @@\n \n     private int recommendedNumReducers = 0;\n \n+    //TODO: fix this", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "921e051ca633b9282340864620806d950532c8c7"}, "originalPosition": 12}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTA5MTU2NQ==", "bodyText": "Let's burn this whole class with fire.", "url": "https://github.com/broadinstitute/gatk/pull/6561#discussion_r421091565", "createdAt": "2020-05-06T21:04:58Z", "author": {"login": "lbergelson"}, "path": "src/main/java/org/broadinstitute/hellbender/utils/gcs/BucketUtils.java", "diffHunk": "@@ -122,6 +132,7 @@ public static boolean isRemoteStorageUrl(String path) {\n      * @param path the path\n      * @return an absolute file path if the original path was a relative file path, otherwise the original path\n      */\n+    //TODO: get rid of this..", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "921e051ca633b9282340864620806d950532c8c7"}, "originalPosition": 21}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTA5MTg2Ng==", "bodyText": "this needs a convenience method", "url": "https://github.com/broadinstitute/gatk/pull/6561#discussion_r421091866", "createdAt": "2020-05-06T21:05:33Z", "author": {"login": "lbergelson"}, "path": "src/main/java/org/broadinstitute/hellbender/utils/io/IOUtils.java", "diffHunk": "@@ -57,10 +57,10 @@\n     private static final Pattern GENOMICSDB_URI_PATTERN = Pattern.compile(\"^\" + GENOMIC_DB_URI_SCHEME + \"(\\\\.?)(.*)(://)(.*)\");\n \n     /**\n-     * Returns true if the file's extension is CRAM.\n+     * Returns true if the GATKPathSpecifier's extension is CRAM.\n      */\n-    public static boolean isCramFile(final File inputFile) {\n-        return isCramFileName(inputFile.getName());\n+    public static boolean isCramFile(final GATKPathSpecifier pathSpec) {\n+        return pathSpec != null && FileExtensions.CRAM.equalsIgnoreCase(\".\" + FilenameUtils.getExtension(pathSpec.getURI().getPath()));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "921e051ca633b9282340864620806d950532c8c7"}, "originalPosition": 10}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "cbcb80c209c1cc88982d3010badf352aa5457b92", "author": {"user": {"login": "cmnbroad", "name": "Chris Norman"}}, "url": "https://github.com/broadinstitute/gatk/commit/cbcb80c209c1cc88982d3010badf352aa5457b92", "committedDate": "2020-05-19T14:31:09Z", "message": "Remove TODOs in favor of an issue ticket."}, "afterCommit": {"oid": "c066a803e9e185ab25c87d97a1a0c89432f958cf", "author": {"user": {"login": "cmnbroad", "name": "Chris Norman"}}, "url": "https://github.com/broadinstitute/gatk/commit/c066a803e9e185ab25c87d97a1a0c89432f958cf", "committedDate": "2020-05-19T14:45:33Z", "message": "Rebase and fix code to enable the merge build to compile on travis."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE1Njk4NjE4", "url": "https://github.com/broadinstitute/gatk/pull/6561#pullrequestreview-415698618", "createdAt": "2020-05-20T20:42:14Z", "commit": {"oid": "89bccf032094478b5db0c3f4f8de9b7f1b3fdb8d"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 10, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMFQyMDo0MjoxNFrOGYdEog==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMFQyMTowNToyNFrOGYdx-Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODI5NTMzMA==", "bodyText": "There needs to be a comment about the different behavior on both methods javadoc. Otherwise people will accidentally interchange file.getExtension().equals(\".fasta.gz\") and file.hasExtension(\".fasta.gz\")", "url": "https://github.com/broadinstitute/gatk/pull/6561#discussion_r428295330", "createdAt": "2020-05-20T20:42:14Z", "author": {"login": "lbergelson"}, "path": "src/main/java/org/broadinstitute/hellbender/engine/PathURI.java", "diffHunk": "@@ -73,6 +76,100 @@ default String getScheme() {\n         return getURI().getScheme();\n     }\n \n+    /**\n+     * @return the extension of the last component of the hierarchical part of the scheme-specific part of the\n+     * URI, if any, including the \".\". Note that this only returns the part of the last component after the last\n+     * \".\", ie. it will return \".gz\" for a name that ends in \".fasta.gz\".\n+     * @throws IllegalArgumentException if the hierarchical name ends with the default file system separator\n+     * (i.e. \"/\") or \".\", or if the last component does not contain a \".\".\n+     */\n+    default String getExtension() {\n+        final String hierarchicalPath = getURI().getPath();\n+        final int indexOfLastComponent = hierarchicalPath.lastIndexOf(FileSystems.getDefault().getSeparator());\n+        if (indexOfLastComponent != -1 && indexOfLastComponent < hierarchicalPath.length() - 1) {\n+            final String lastComponent = hierarchicalPath.substring(indexOfLastComponent + 1);\n+            if (lastComponent.length() > 0) {\n+                final int indexOfLastDot = lastComponent.lastIndexOf('.');\n+                if (indexOfLastDot != -1 && indexOfLastDot < lastComponent.length() - 1) {\n+                    // return a string that includes the leading \".\" to enable easy comparison with the many\n+                    // internal file extension constants we have that include the leading \".\" (i.e., in htsjdk),\n+                    // and also for API consistency (since hasExtension() requires the candidate extension to\n+                    // include a leading \".\", this allows hasExtension(getExtension()) to always work whenever\n+                    // getExtension() succeeds\n+                    return lastComponent.substring(indexOfLastDot);\n+                }\n+            }\n+        }\n+        throw new IllegalArgumentException(String.format(\"Input path (%s) has no extension\", this));\n+    }\n+\n+    /**\n+     * Return true if the path component (the hierarchical part of the scheme specific part of the underlying URI)\n+     * ends with the provided {@code extension} string.\n+     *\n+     * @param extension the target extension to test, INCLUDING the leading \".\". May not be null.\n+     * @return true if the path component of this specifier ends with the extension, otherwise false\n+     */\n+    default boolean hasExtension(final String extension) {\n+        Utils.nonNull(extension, \"Target extension must not be null\");\n+        Utils.validateArg(extension.length() > 1, \"Target extension must be length > 1\");\n+        Utils.validateArg(extension.charAt(0) == '.', \"Target extension must include the leading '.'\");\n+\n+        // We don't want to use {@code #getExtension} here, since it won't work correctly if we're comparing an\n+        // extension that uses multiple . chars, such as .fasta.gz., and {@code #getExtension} will throw if there", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "89bccf032094478b5db0c3f4f8de9b7f1b3fdb8d"}, "originalPosition": 65}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODI5NTc5Mg==", "bodyText": "In order to use this safely there probably needs to be a matching hasExtension().  Otherwise people are forced to catch the exception in order to call this safely.", "url": "https://github.com/broadinstitute/gatk/pull/6561#discussion_r428295792", "createdAt": "2020-05-20T20:43:11Z", "author": {"login": "lbergelson"}, "path": "src/main/java/org/broadinstitute/hellbender/engine/PathURI.java", "diffHunk": "@@ -73,6 +76,100 @@ default String getScheme() {\n         return getURI().getScheme();\n     }\n \n+    /**\n+     * @return the extension of the last component of the hierarchical part of the scheme-specific part of the\n+     * URI, if any, including the \".\". Note that this only returns the part of the last component after the last\n+     * \".\", ie. it will return \".gz\" for a name that ends in \".fasta.gz\".\n+     * @throws IllegalArgumentException if the hierarchical name ends with the default file system separator\n+     * (i.e. \"/\") or \".\", or if the last component does not contain a \".\".\n+     */\n+    default String getExtension() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "89bccf032094478b5db0c3f4f8de9b7f1b3fdb8d"}, "originalPosition": 32}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODI5Njc0Mw==", "bodyText": "This seems like the wrong error message.", "url": "https://github.com/broadinstitute/gatk/pull/6561#discussion_r428296743", "createdAt": "2020-05-20T20:45:04Z", "author": {"login": "lbergelson"}, "path": "src/main/java/org/broadinstitute/hellbender/engine/PathURI.java", "diffHunk": "@@ -73,6 +76,100 @@ default String getScheme() {\n         return getURI().getScheme();\n     }\n \n+    /**\n+     * @return the extension of the last component of the hierarchical part of the scheme-specific part of the\n+     * URI, if any, including the \".\". Note that this only returns the part of the last component after the last\n+     * \".\", ie. it will return \".gz\" for a name that ends in \".fasta.gz\".\n+     * @throws IllegalArgumentException if the hierarchical name ends with the default file system separator\n+     * (i.e. \"/\") or \".\", or if the last component does not contain a \".\".\n+     */\n+    default String getExtension() {\n+        final String hierarchicalPath = getURI().getPath();\n+        final int indexOfLastComponent = hierarchicalPath.lastIndexOf(FileSystems.getDefault().getSeparator());\n+        if (indexOfLastComponent != -1 && indexOfLastComponent < hierarchicalPath.length() - 1) {\n+            final String lastComponent = hierarchicalPath.substring(indexOfLastComponent + 1);\n+            if (lastComponent.length() > 0) {\n+                final int indexOfLastDot = lastComponent.lastIndexOf('.');\n+                if (indexOfLastDot != -1 && indexOfLastDot < lastComponent.length() - 1) {\n+                    // return a string that includes the leading \".\" to enable easy comparison with the many\n+                    // internal file extension constants we have that include the leading \".\" (i.e., in htsjdk),\n+                    // and also for API consistency (since hasExtension() requires the candidate extension to\n+                    // include a leading \".\", this allows hasExtension(getExtension()) to always work whenever\n+                    // getExtension() succeeds\n+                    return lastComponent.substring(indexOfLastDot);\n+                }\n+            }\n+        }\n+        throw new IllegalArgumentException(String.format(\"Input path (%s) has no extension\", this));\n+    }\n+\n+    /**\n+     * Return true if the path component (the hierarchical part of the scheme specific part of the underlying URI)\n+     * ends with the provided {@code extension} string.\n+     *\n+     * @param extension the target extension to test, INCLUDING the leading \".\". May not be null.\n+     * @return true if the path component of this specifier ends with the extension, otherwise false\n+     */\n+    default boolean hasExtension(final String extension) {\n+        Utils.nonNull(extension, \"Target extension must not be null\");\n+        Utils.validateArg(extension.length() > 1, \"Target extension must be length > 1\");\n+        Utils.validateArg(extension.charAt(0) == '.', \"Target extension must include the leading '.'\");\n+\n+        // We don't want to use {@code #getExtension} here, since it won't work correctly if we're comparing an\n+        // extension that uses multiple . chars, such as .fasta.gz., and {@code #getExtension} will throw if there\n+        // is no extension.\n+        return getURI().getPath().toLowerCase().endsWith(extension.toLowerCase());\n+    }\n+\n+    /**\n+     * @return the base name (the last component of the hierarchical part of the scheme-specific part of the URI,\n+     * after the last \"/\"), up to but not including the extension (the last \".\").\n+     * @throws IllegalArgumentException if the last component is empty (ie, the component ends in \"/\"), or the last\n+     * component exists but starts with \".\"\n+     */\n+    default String getBaseName() {\n+        final String hierarchicalPath = getURI().getPath();\n+        final int indexOfLastComponent = hierarchicalPath.lastIndexOf(FileSystems.getDefault().getSeparator());\n+        if (indexOfLastComponent != -1 && indexOfLastComponent < hierarchicalPath.length() - 1) {\n+            final String lastComponent = hierarchicalPath.substring(indexOfLastComponent + 1);\n+            if (lastComponent.length() > 0) {\n+                final int indexOfLastDot = lastComponent.lastIndexOf('.');\n+                if (indexOfLastDot != -1 && indexOfLastDot > 1) {\n+                    return lastComponent.substring(0, indexOfLastDot);\n+                }\n+            }\n+        }\n+        throw new IllegalArgumentException(String.format(\"Input path (%s) has no extension\", this));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "89bccf032094478b5db0c3f4f8de9b7f1b3fdb8d"}, "originalPosition": 88}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODI5OTM0Nw==", "bodyText": "I think it might be better to be greedy about the extension and include everything after the first . as the extension? fasta.gz and bam.bai seem more common than \"my.filename.has.random.dots.fasta\".  Maybe I'm wrong about that though.\nTypically when people call baseName it's because they want to create a similarly name file with a different extension, so stripping all the extensions makes sense.\nI think the comment about the componentExisting but starting with \".\" doesn't match the tests where you have \".fasta.gz\".baseName() == \".fasta\".", "url": "https://github.com/broadinstitute/gatk/pull/6561#discussion_r428299347", "createdAt": "2020-05-20T20:50:17Z", "author": {"login": "lbergelson"}, "path": "src/main/java/org/broadinstitute/hellbender/engine/PathURI.java", "diffHunk": "@@ -73,6 +76,100 @@ default String getScheme() {\n         return getURI().getScheme();\n     }\n \n+    /**\n+     * @return the extension of the last component of the hierarchical part of the scheme-specific part of the\n+     * URI, if any, including the \".\". Note that this only returns the part of the last component after the last\n+     * \".\", ie. it will return \".gz\" for a name that ends in \".fasta.gz\".\n+     * @throws IllegalArgumentException if the hierarchical name ends with the default file system separator\n+     * (i.e. \"/\") or \".\", or if the last component does not contain a \".\".\n+     */\n+    default String getExtension() {\n+        final String hierarchicalPath = getURI().getPath();\n+        final int indexOfLastComponent = hierarchicalPath.lastIndexOf(FileSystems.getDefault().getSeparator());\n+        if (indexOfLastComponent != -1 && indexOfLastComponent < hierarchicalPath.length() - 1) {\n+            final String lastComponent = hierarchicalPath.substring(indexOfLastComponent + 1);\n+            if (lastComponent.length() > 0) {\n+                final int indexOfLastDot = lastComponent.lastIndexOf('.');\n+                if (indexOfLastDot != -1 && indexOfLastDot < lastComponent.length() - 1) {\n+                    // return a string that includes the leading \".\" to enable easy comparison with the many\n+                    // internal file extension constants we have that include the leading \".\" (i.e., in htsjdk),\n+                    // and also for API consistency (since hasExtension() requires the candidate extension to\n+                    // include a leading \".\", this allows hasExtension(getExtension()) to always work whenever\n+                    // getExtension() succeeds\n+                    return lastComponent.substring(indexOfLastDot);\n+                }\n+            }\n+        }\n+        throw new IllegalArgumentException(String.format(\"Input path (%s) has no extension\", this));\n+    }\n+\n+    /**\n+     * Return true if the path component (the hierarchical part of the scheme specific part of the underlying URI)\n+     * ends with the provided {@code extension} string.\n+     *\n+     * @param extension the target extension to test, INCLUDING the leading \".\". May not be null.\n+     * @return true if the path component of this specifier ends with the extension, otherwise false\n+     */\n+    default boolean hasExtension(final String extension) {\n+        Utils.nonNull(extension, \"Target extension must not be null\");\n+        Utils.validateArg(extension.length() > 1, \"Target extension must be length > 1\");\n+        Utils.validateArg(extension.charAt(0) == '.', \"Target extension must include the leading '.'\");\n+\n+        // We don't want to use {@code #getExtension} here, since it won't work correctly if we're comparing an\n+        // extension that uses multiple . chars, such as .fasta.gz., and {@code #getExtension} will throw if there\n+        // is no extension.\n+        return getURI().getPath().toLowerCase().endsWith(extension.toLowerCase());\n+    }\n+\n+    /**\n+     * @return the base name (the last component of the hierarchical part of the scheme-specific part of the URI,\n+     * after the last \"/\"), up to but not including the extension (the last \".\").\n+     * @throws IllegalArgumentException if the last component is empty (ie, the component ends in \"/\"), or the last\n+     * component exists but starts with \".\"\n+     */\n+    default String getBaseName() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "89bccf032094478b5db0c3f4f8de9b7f1b3fdb8d"}, "originalPosition": 76}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODMwMDAyNw==", "bodyText": "Is this problematic with files that are at the root of the directory structure or with relative paths that don't include any path above the filename?", "url": "https://github.com/broadinstitute/gatk/pull/6561#discussion_r428300027", "createdAt": "2020-05-20T20:51:37Z", "author": {"login": "lbergelson"}, "path": "src/main/java/org/broadinstitute/hellbender/engine/PathURI.java", "diffHunk": "@@ -73,6 +76,100 @@ default String getScheme() {\n         return getURI().getScheme();\n     }\n \n+    /**\n+     * @return the extension of the last component of the hierarchical part of the scheme-specific part of the\n+     * URI, if any, including the \".\". Note that this only returns the part of the last component after the last\n+     * \".\", ie. it will return \".gz\" for a name that ends in \".fasta.gz\".\n+     * @throws IllegalArgumentException if the hierarchical name ends with the default file system separator\n+     * (i.e. \"/\") or \".\", or if the last component does not contain a \".\".\n+     */\n+    default String getExtension() {\n+        final String hierarchicalPath = getURI().getPath();\n+        final int indexOfLastComponent = hierarchicalPath.lastIndexOf(FileSystems.getDefault().getSeparator());\n+        if (indexOfLastComponent != -1 && indexOfLastComponent < hierarchicalPath.length() - 1) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "89bccf032094478b5db0c3f4f8de9b7f1b3fdb8d"}, "originalPosition": 35}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODMwMTA2OA==", "bodyText": "Should we mark this as a todo when we get resolve methods on GATKPathSpecifier directly?", "url": "https://github.com/broadinstitute/gatk/pull/6561#discussion_r428301068", "createdAt": "2020-05-20T20:53:37Z", "author": {"login": "lbergelson"}, "path": "src/main/java/org/broadinstitute/hellbender/tools/SplitReads.java", "diffHunk": "@@ -146,20 +143,15 @@ private SAMFileGATKReadWriter createUnknownOutOnDemand(String attributeValue) {\n             // attribute for which a given read/group has no value; anything else indicates a coding error\n             throw new GATKException.ShouldNeverReachHereException(\"Unrecognized attribute value found: \" + attributeValue);\n         }\n-        final SAMFileWriterFactory samFileWriterFactory = new SAMFileWriterFactory();\n-        final SAMFileHeader samFileHeaderIn = getHeaderForReads();\n-\n-        return prepareSAMFileWriter(samFileWriterFactory, samFileHeaderIn, attributeValue);\n+        return prepareSAMFileWriter(attributeValue);\n     }\n \n     //  Create a new output file and prepare and return the corresponding SAMFileGATKReadWriter.\n-    private SAMFileGATKReadWriter prepareSAMFileWriter(\n-            SAMFileWriterFactory samFileWriterFactory,\n-            SAMFileHeader samFileHeaderIn,\n-            final String keyName) {\n-        final String base = FilenameUtils.getBaseName(readArguments.getReadPathSpecifiers().get(0).getURI().getSchemeSpecificPart());\n-        final String extension = \".\" + FilenameUtils.getExtension(readArguments.getReadPathSpecifiers().get(0).getURI().getSchemeSpecificPart());\n-        final GATKPathSpecifier outFile = new GATKPathSpecifier(new File(OUTPUT_DIRECTORY, base + keyName + extension).getAbsolutePath());\n+    private SAMFileGATKReadWriter prepareSAMFileWriter(final String keyName) {\n+        final GATKPathSpecifier pathSpec = readArguments.getReadPathSpecifiers().get(0);\n+        final GATKPathSpecifier outFile = new GATKPathSpecifier(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "89bccf032094478b5db0c3f4f8de9b7f1b3fdb8d"}, "originalPosition": 57}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODMwMzYwNA==", "bodyText": "Maybe this is inconsistent, but we should allow a basename to not have an extension.  localFile's base name is just \"localFile\" I think.", "url": "https://github.com/broadinstitute/gatk/pull/6561#discussion_r428303604", "createdAt": "2020-05-20T20:58:30Z", "author": {"login": "lbergelson"}, "path": "src/test/java/org/broadinstitute/hellbender/engine/GATKPathSpecifierUnitTest.java", "diffHunk": "@@ -286,6 +287,173 @@ public void testStdOut() throws IOException {\n         }\n     }\n \n+    @DataProvider(name = \"getExtensionTestCases\")\n+    public Object[][] getExtensionTestCases() {\n+        return new Object[][] {\n+                // input, extension\n+                {\"localFile.bam\", \".bam\"},\n+                {\"localFile.BAM\", \".BAM\"},\n+                {\"/localFile.bam\", \".bam\"},\n+                {\"gs://bucket/aFile.bam\", \".bam\"},\n+                {\"gs://hellbender/test/resources/aFile.adam\", \".adam\"},\n+                {\"gs://hellbender/test/resources/aFile.fasta\", \".fasta\"},\n+                {\"http://bucket/aFile.bam?query=param\", \".bam\"},\n+\n+                // getExtension() returns \".gz\", but this case also satisfies hasExtension(\".fasta.gz\")\n+                {\"aFile.fasta.gz\", \".gz\"},\n+                // basename is \".fasta\"!\n+                {\".fasta.gz\", \".gz\"},\n+        };\n+    }\n+\n+    @Test(dataProvider = \"getExtensionTestCases\")\n+    public void testGetExtension(final String spec, final String expectedExtension) {\n+        final GATKPathSpecifier pathSpec = new GATKPathSpecifier(spec);\n+        final String actualExtension = pathSpec.getExtension();\n+\n+        Assert.assertEquals(actualExtension, expectedExtension);\n+        // verify that hasExtension(getExtension()) is always true\n+        Assert.assertTrue(pathSpec.hasExtension(actualExtension));\n+    }\n+\n+    @DataProvider(name=\"negativeGetExtensionTestCases\")\n+    public Object[][] negativeGetExtensionTestCases() {\n+        return new Object[][]{\n+                // no extensions\n+                {\"\"},\n+                {\"/\"},\n+                {\".\"},\n+                {\"localFile\"},\n+                {\"localFile.\"},\n+                {\"/localFile.\"},\n+                {\"gs://hellbender/test/resources\"},\n+                {\"gs://hellbender/test/resources?query=param\"},\n+                {\"gs://hellbender/test/resources/\"},\n+                {\"gs://hellbender/test/resources/?query=param\"},\n+        };\n+    }\n+\n+    @Test(dataProvider = \"negativeGetExtensionTestCases\", expectedExceptions={IllegalArgumentException.class})\n+    public void testNegativeGetExtension(final String spec) {\n+        new GATKPathSpecifier(spec).getExtension();\n+    }\n+\n+    @DataProvider(name = \"hasExtensionTestCases\")\n+    public Object[][] hasExtensionTestCases() {\n+        return new Object[][]{\n+                // input, extension satisfies \"hasExtension\"\n+                {\"localFile.bam\", \".bam\", true },\n+                {\"localFile.BAM\", \".BAM\", true },\n+                {\"localFile.BAM\", \".bam\", true },\n+                {\"localFile.bam\", \".BAM\", true },\n+                {\"/localFile.bam\", \".bam\", true },\n+                {\"gs://bucket/aFile.bam\", \".bam\", true },\n+                {\"gs://hellbender/test/resources/aFile.adam\", \".adam\", true },\n+                {\"gs://hellbender/test/resources/aFile.fasta\", \".fasta\", true },\n+                {\"http://bucket/aFile.bam?query=param\", \".bam\", true },\n+\n+                {\"aFile.fasta.gz\", \".gz\", true },\n+                {\"aFile.fasta.gz\", \".fasta.gz\", true },\n+                // basename is \".fasta\"!\n+                {\".fasta.gz\", \".gz\", true },\n+                {\".fasta.gz\", \".fasta.gz\", true },\n+\n+                // no extensions\n+                {\"/\", \".ext\", false },\n+                {\".\", \".ext\", false },\n+                {\"localFile\", \".a\", false }, // extension must have length > 1\n+                {\"localFile.\", \".a\", false },\n+                {\"gs://hellbender/test/resources\", \".fasta\", false },\n+                {\"gs://hellbender/test/resources?query=param\", \".fasta\", false },\n+                {\"gs://hellbender/test/resources/\", \".fasta\", false },\n+                {\"gs://hellbender/test/resources/?query=param\", \".fasta\", false },\n+        };\n+    }\n+\n+    @Test(dataProvider = \"hasExtensionTestCases\")\n+    public void testHasExtension(final String spec, final String extension, final boolean expectedResult) {\n+        Assert.assertEquals(new GATKPathSpecifier(spec).hasExtension(extension), expectedResult);\n+    }\n+\n+    @DataProvider(name = \"getBaseNameTestCases\")\n+    public Object[][] getBaseNameTestCases() {\n+        return new Object[][] {\n+                // input, baseName\n+                {\"localFile.bam\", \"localFile\"},\n+                {\"localFile.BAM\", \"localFile\"},\n+                {\"/localFile.bam\", \"localFile\"},\n+                {\"gs://bucket/aFile.bam\", \"aFile\"},\n+                {\"gs://hellbender/test/resources/aFile.adam\", \"aFile\"},\n+                {\"gs://hellbender/test/resources/aFile.fasta\", \"aFile\"},\n+                {\"http://bucket/aFile.bam?query=param\", \"aFile\"},\n+\n+                // This case satisfies hasExtension(\".fasta.gz\"), but getExtension() returns \".gz\".\n+                {\"aFile.fasta.gz\", \"aFile.fasta\"},\n+                // basename is \".fasta\"!\n+                {\".fasta.gz\", \".fasta\",},\n+        };\n+    }\n+\n+    @Test(dataProvider = \"getBaseNameTestCases\")\n+    public void testGetBaseName(final String spec, final String baseName) {\n+        Assert.assertEquals(new GATKPathSpecifier(spec).getBaseName(), baseName);\n+    }\n+\n+    @DataProvider(name=\"negativeGetBaseNameTestCases\")\n+    public Object[][] negativeGetBaseNameTestCases() {\n+        return new Object[][]{\n+                // no extensions\n+                {\"/\"},\n+                {\".\"},\n+                {\"/.\"},\n+                {\"/name/.fasta\"},\n+                {\"localFile\"},\n+                {\"gs://hellbender/test/resources\"},", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "89bccf032094478b5db0c3f4f8de9b7f1b3fdb8d"}, "originalPosition": 160}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODMwNjY4NQ==", "bodyText": "We might want to prefer returning empty string when the base name/ extension are empty.   (not when they're missing because the file ends in \"/\" though...).", "url": "https://github.com/broadinstitute/gatk/pull/6561#discussion_r428306685", "createdAt": "2020-05-20T21:04:49Z", "author": {"login": "lbergelson"}, "path": "src/main/java/org/broadinstitute/hellbender/engine/PathURI.java", "diffHunk": "@@ -73,6 +76,100 @@ default String getScheme() {\n         return getURI().getScheme();\n     }\n \n+    /**\n+     * @return the extension of the last component of the hierarchical part of the scheme-specific part of the\n+     * URI, if any, including the \".\". Note that this only returns the part of the last component after the last\n+     * \".\", ie. it will return \".gz\" for a name that ends in \".fasta.gz\".\n+     * @throws IllegalArgumentException if the hierarchical name ends with the default file system separator\n+     * (i.e. \"/\") or \".\", or if the last component does not contain a \".\".\n+     */\n+    default String getExtension() {\n+        final String hierarchicalPath = getURI().getPath();\n+        final int indexOfLastComponent = hierarchicalPath.lastIndexOf(FileSystems.getDefault().getSeparator());\n+        if (indexOfLastComponent != -1 && indexOfLastComponent < hierarchicalPath.length() - 1) {\n+            final String lastComponent = hierarchicalPath.substring(indexOfLastComponent + 1);\n+            if (lastComponent.length() > 0) {\n+                final int indexOfLastDot = lastComponent.lastIndexOf('.');\n+                if (indexOfLastDot != -1 && indexOfLastDot < lastComponent.length() - 1) {\n+                    // return a string that includes the leading \".\" to enable easy comparison with the many\n+                    // internal file extension constants we have that include the leading \".\" (i.e., in htsjdk),\n+                    // and also for API consistency (since hasExtension() requires the candidate extension to\n+                    // include a leading \".\", this allows hasExtension(getExtension()) to always work whenever\n+                    // getExtension() succeeds\n+                    return lastComponent.substring(indexOfLastDot);\n+                }\n+            }\n+        }\n+        throw new IllegalArgumentException(String.format(\"Input path (%s) has no extension\", this));\n+    }\n+\n+    /**\n+     * Return true if the path component (the hierarchical part of the scheme specific part of the underlying URI)\n+     * ends with the provided {@code extension} string.\n+     *\n+     * @param extension the target extension to test, INCLUDING the leading \".\". May not be null.\n+     * @return true if the path component of this specifier ends with the extension, otherwise false\n+     */\n+    default boolean hasExtension(final String extension) {\n+        Utils.nonNull(extension, \"Target extension must not be null\");\n+        Utils.validateArg(extension.length() > 1, \"Target extension must be length > 1\");\n+        Utils.validateArg(extension.charAt(0) == '.', \"Target extension must include the leading '.'\");\n+\n+        // We don't want to use {@code #getExtension} here, since it won't work correctly if we're comparing an\n+        // extension that uses multiple . chars, such as .fasta.gz., and {@code #getExtension} will throw if there\n+        // is no extension.\n+        return getURI().getPath().toLowerCase().endsWith(extension.toLowerCase());\n+    }\n+\n+    /**\n+     * @return the base name (the last component of the hierarchical part of the scheme-specific part of the URI,\n+     * after the last \"/\"), up to but not including the extension (the last \".\").\n+     * @throws IllegalArgumentException if the last component is empty (ie, the component ends in \"/\"), or the last\n+     * component exists but starts with \".\"\n+     */\n+    default String getBaseName() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODI5OTM0Nw=="}, "originalCommit": {"oid": "89bccf032094478b5db0c3f4f8de9b7f1b3fdb8d"}, "originalPosition": 76}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODMwNjczNQ==", "bodyText": "Could you add a test for the case \".\".hasExtension(\".\") ?", "url": "https://github.com/broadinstitute/gatk/pull/6561#discussion_r428306735", "createdAt": "2020-05-20T21:04:58Z", "author": {"login": "lbergelson"}, "path": "src/test/java/org/broadinstitute/hellbender/engine/GATKPathSpecifierUnitTest.java", "diffHunk": "@@ -286,6 +287,173 @@ public void testStdOut() throws IOException {\n         }\n     }\n \n+    @DataProvider(name = \"getExtensionTestCases\")\n+    public Object[][] getExtensionTestCases() {\n+        return new Object[][] {\n+                // input, extension\n+                {\"localFile.bam\", \".bam\"},\n+                {\"localFile.BAM\", \".BAM\"},\n+                {\"/localFile.bam\", \".bam\"},\n+                {\"gs://bucket/aFile.bam\", \".bam\"},\n+                {\"gs://hellbender/test/resources/aFile.adam\", \".adam\"},\n+                {\"gs://hellbender/test/resources/aFile.fasta\", \".fasta\"},\n+                {\"http://bucket/aFile.bam?query=param\", \".bam\"},\n+\n+                // getExtension() returns \".gz\", but this case also satisfies hasExtension(\".fasta.gz\")\n+                {\"aFile.fasta.gz\", \".gz\"},\n+                // basename is \".fasta\"!\n+                {\".fasta.gz\", \".gz\"},\n+        };\n+    }\n+\n+    @Test(dataProvider = \"getExtensionTestCases\")\n+    public void testGetExtension(final String spec, final String expectedExtension) {\n+        final GATKPathSpecifier pathSpec = new GATKPathSpecifier(spec);\n+        final String actualExtension = pathSpec.getExtension();\n+\n+        Assert.assertEquals(actualExtension, expectedExtension);\n+        // verify that hasExtension(getExtension()) is always true\n+        Assert.assertTrue(pathSpec.hasExtension(actualExtension));\n+    }\n+\n+    @DataProvider(name=\"negativeGetExtensionTestCases\")\n+    public Object[][] negativeGetExtensionTestCases() {\n+        return new Object[][]{\n+                // no extensions\n+                {\"\"},\n+                {\"/\"},\n+                {\".\"},\n+                {\"localFile\"},\n+                {\"localFile.\"},\n+                {\"/localFile.\"},\n+                {\"gs://hellbender/test/resources\"},\n+                {\"gs://hellbender/test/resources?query=param\"},\n+                {\"gs://hellbender/test/resources/\"},\n+                {\"gs://hellbender/test/resources/?query=param\"},\n+        };\n+    }\n+\n+    @Test(dataProvider = \"negativeGetExtensionTestCases\", expectedExceptions={IllegalArgumentException.class})\n+    public void testNegativeGetExtension(final String spec) {\n+        new GATKPathSpecifier(spec).getExtension();\n+    }\n+\n+    @DataProvider(name = \"hasExtensionTestCases\")\n+    public Object[][] hasExtensionTestCases() {\n+        return new Object[][]{\n+                // input, extension satisfies \"hasExtension\"\n+                {\"localFile.bam\", \".bam\", true },\n+                {\"localFile.BAM\", \".BAM\", true },\n+                {\"localFile.BAM\", \".bam\", true },\n+                {\"localFile.bam\", \".BAM\", true },\n+                {\"/localFile.bam\", \".bam\", true },\n+                {\"gs://bucket/aFile.bam\", \".bam\", true },\n+                {\"gs://hellbender/test/resources/aFile.adam\", \".adam\", true },\n+                {\"gs://hellbender/test/resources/aFile.fasta\", \".fasta\", true },\n+                {\"http://bucket/aFile.bam?query=param\", \".bam\", true },\n+\n+                {\"aFile.fasta.gz\", \".gz\", true },\n+                {\"aFile.fasta.gz\", \".fasta.gz\", true },\n+                // basename is \".fasta\"!\n+                {\".fasta.gz\", \".gz\", true },\n+                {\".fasta.gz\", \".fasta.gz\", true },\n+\n+                // no extensions\n+                {\"/\", \".ext\", false },\n+                {\".\", \".ext\", false },", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "89bccf032094478b5db0c3f4f8de9b7f1b3fdb8d"}, "originalPosition": 112}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODMwNjkzNw==", "bodyText": "Should we simple tests for isSam, isBam, is Cram ?", "url": "https://github.com/broadinstitute/gatk/pull/6561#discussion_r428306937", "createdAt": "2020-05-20T21:05:24Z", "author": {"login": "lbergelson"}, "path": "src/test/java/org/broadinstitute/hellbender/engine/GATKPathSpecifierUnitTest.java", "diffHunk": "@@ -286,6 +287,173 @@ public void testStdOut() throws IOException {\n         }\n     }\n \n+    @DataProvider(name = \"getExtensionTestCases\")\n+    public Object[][] getExtensionTestCases() {\n+        return new Object[][] {\n+                // input, extension\n+                {\"localFile.bam\", \".bam\"},\n+                {\"localFile.BAM\", \".BAM\"},\n+                {\"/localFile.bam\", \".bam\"},\n+                {\"gs://bucket/aFile.bam\", \".bam\"},\n+                {\"gs://hellbender/test/resources/aFile.adam\", \".adam\"},\n+                {\"gs://hellbender/test/resources/aFile.fasta\", \".fasta\"},\n+                {\"http://bucket/aFile.bam?query=param\", \".bam\"},\n+\n+                // getExtension() returns \".gz\", but this case also satisfies hasExtension(\".fasta.gz\")\n+                {\"aFile.fasta.gz\", \".gz\"},\n+                // basename is \".fasta\"!\n+                {\".fasta.gz\", \".gz\"},\n+        };\n+    }\n+\n+    @Test(dataProvider = \"getExtensionTestCases\")\n+    public void testGetExtension(final String spec, final String expectedExtension) {\n+        final GATKPathSpecifier pathSpec = new GATKPathSpecifier(spec);\n+        final String actualExtension = pathSpec.getExtension();\n+\n+        Assert.assertEquals(actualExtension, expectedExtension);\n+        // verify that hasExtension(getExtension()) is always true\n+        Assert.assertTrue(pathSpec.hasExtension(actualExtension));\n+    }\n+\n+    @DataProvider(name=\"negativeGetExtensionTestCases\")\n+    public Object[][] negativeGetExtensionTestCases() {\n+        return new Object[][]{\n+                // no extensions\n+                {\"\"},\n+                {\"/\"},\n+                {\".\"},\n+                {\"localFile\"},\n+                {\"localFile.\"},\n+                {\"/localFile.\"},\n+                {\"gs://hellbender/test/resources\"},\n+                {\"gs://hellbender/test/resources?query=param\"},\n+                {\"gs://hellbender/test/resources/\"},\n+                {\"gs://hellbender/test/resources/?query=param\"},\n+        };\n+    }\n+\n+    @Test(dataProvider = \"negativeGetExtensionTestCases\", expectedExceptions={IllegalArgumentException.class})\n+    public void testNegativeGetExtension(final String spec) {\n+        new GATKPathSpecifier(spec).getExtension();\n+    }\n+\n+    @DataProvider(name = \"hasExtensionTestCases\")\n+    public Object[][] hasExtensionTestCases() {\n+        return new Object[][]{\n+                // input, extension satisfies \"hasExtension\"\n+                {\"localFile.bam\", \".bam\", true },\n+                {\"localFile.BAM\", \".BAM\", true },\n+                {\"localFile.BAM\", \".bam\", true },\n+                {\"localFile.bam\", \".BAM\", true },\n+                {\"/localFile.bam\", \".bam\", true },\n+                {\"gs://bucket/aFile.bam\", \".bam\", true },\n+                {\"gs://hellbender/test/resources/aFile.adam\", \".adam\", true },\n+                {\"gs://hellbender/test/resources/aFile.fasta\", \".fasta\", true },\n+                {\"http://bucket/aFile.bam?query=param\", \".bam\", true },\n+\n+                {\"aFile.fasta.gz\", \".gz\", true },\n+                {\"aFile.fasta.gz\", \".fasta.gz\", true },\n+                // basename is \".fasta\"!\n+                {\".fasta.gz\", \".gz\", true },\n+                {\".fasta.gz\", \".fasta.gz\", true },\n+\n+                // no extensions\n+                {\"/\", \".ext\", false },\n+                {\".\", \".ext\", false },\n+                {\"localFile\", \".a\", false }, // extension must have length > 1\n+                {\"localFile.\", \".a\", false },\n+                {\"gs://hellbender/test/resources\", \".fasta\", false },\n+                {\"gs://hellbender/test/resources?query=param\", \".fasta\", false },\n+                {\"gs://hellbender/test/resources/\", \".fasta\", false },\n+                {\"gs://hellbender/test/resources/?query=param\", \".fasta\", false },\n+        };\n+    }\n+\n+    @Test(dataProvider = \"hasExtensionTestCases\")\n+    public void testHasExtension(final String spec, final String extension, final boolean expectedResult) {\n+        Assert.assertEquals(new GATKPathSpecifier(spec).hasExtension(extension), expectedResult);\n+    }\n+\n+    @DataProvider(name = \"getBaseNameTestCases\")\n+    public Object[][] getBaseNameTestCases() {\n+        return new Object[][] {\n+                // input, baseName\n+                {\"localFile.bam\", \"localFile\"},\n+                {\"localFile.BAM\", \"localFile\"},\n+                {\"/localFile.bam\", \"localFile\"},\n+                {\"gs://bucket/aFile.bam\", \"aFile\"},\n+                {\"gs://hellbender/test/resources/aFile.adam\", \"aFile\"},\n+                {\"gs://hellbender/test/resources/aFile.fasta\", \"aFile\"},\n+                {\"http://bucket/aFile.bam?query=param\", \"aFile\"},\n+\n+                // This case satisfies hasExtension(\".fasta.gz\"), but getExtension() returns \".gz\".\n+                {\"aFile.fasta.gz\", \"aFile.fasta\"},\n+                // basename is \".fasta\"!\n+                {\".fasta.gz\", \".fasta\",},\n+        };\n+    }\n+\n+    @Test(dataProvider = \"getBaseNameTestCases\")\n+    public void testGetBaseName(final String spec, final String baseName) {\n+        Assert.assertEquals(new GATKPathSpecifier(spec).getBaseName(), baseName);\n+    }\n+\n+    @DataProvider(name=\"negativeGetBaseNameTestCases\")\n+    public Object[][] negativeGetBaseNameTestCases() {\n+        return new Object[][]{\n+                // no extensions\n+                {\"/\"},\n+                {\".\"},\n+                {\"/.\"},\n+                {\"/name/.fasta\"},\n+                {\"localFile\"},\n+                {\"gs://hellbender/test/resources\"},\n+                {\"gs://hellbender/test/resources?query=param\"},\n+                {\"gs://hellbender/test/resources/\"},\n+                {\"gs://hellbender/test/resources/?query=param\"},\n+        };\n+    }\n+\n+    @Test(dataProvider = \"negativeGetBaseNameTestCases\", expectedExceptions = {IllegalArgumentException.class})\n+    public void testNegativeGetBaseName(final String spec) {\n+        new GATKPathSpecifier(spec).getBaseName();\n+    }\n+\n+    @DataProvider(name=\"isFastaTestCases\")\n+    public Object[][] isFastaTestCases() {\n+        final String twoBitRefURL = publicTestDir + \"large/human_g1k_v37.20.21.2bit\";\n+        return new Object[][] {\n+                { twoBitRefURL, false },\n+                { \"file://\" + twoBitRefURL, false },\n+                { hg38Reference, true }, // gzipped\n+                { \"file://\" + hg38Reference, true }, // gzipped\n+                { GCS_b37_CHR20_21_REFERENCE_2BIT, false },\n+                { GCS_b37_CHR20_21_REFERENCE, true },\n+                // dummy query params at the end to make sure URI.getPath does the right thing\n+                { GCS_b37_CHR20_21_REFERENCE + \"?query=param\", true}\n+        };\n+    }\n+\n+    @Test(dataProvider = \"isFastaTestCases\")\n+    public void testIsFasta(final String referenceSpec, final boolean expectedIsFasta) {\n+        Assert.assertEquals(new GATKPathSpecifier(referenceSpec).isFasta(), expectedIsFasta);\n+    }\n+\n+    @DataProvider(name=\"isHadoopURLTestCases\")\n+    public Object[][] isHadoopURLTestCases() {\n+        return new Object[][] {\n+                { GATKPathSpecifier.HDFS_SCHEME + \"://someFile\", true },\n+                { \"file://someFile.bam\", false },\n+                { \"someFile.bam\", false },\n+        };\n+    }\n+\n+    @Test(dataProvider = \"isHadoopURLTestCases\")\n+    public void testIsHadoopURL(final String referenceSpec, final boolean expectedIsHadoop) {\n+        Assert.assertEquals(new GATKPathSpecifier(referenceSpec).isHadoopURL(), expectedIsHadoop);\n+    }\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "89bccf032094478b5db0c3f4f8de9b7f1b3fdb8d"}, "originalPosition": 205}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "4db2db81c5ccaedfa6127c4d6835b65fa02b5dc6", "author": {"user": {"login": "cmnbroad", "name": "Chris Norman"}}, "url": "https://github.com/broadinstitute/gatk/commit/4db2db81c5ccaedfa6127c4d6835b65fa02b5dc6", "committedDate": "2020-05-26T22:21:27Z", "message": "More code review comments."}, "afterCommit": {"oid": "a7015d2c7fda3220bafa07ee70411e3d95c40fcd", "author": {"user": {"login": "cmnbroad", "name": "Chris Norman"}}, "url": "https://github.com/broadinstitute/gatk/commit/a7015d2c7fda3220bafa07ee70411e3d95c40fcd", "committedDate": "2020-05-27T20:08:21Z", "message": "More code review comments."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "448b180860657a9002cb46e7592fc0b012646074", "author": {"user": {"login": "cmnbroad", "name": "Chris Norman"}}, "url": "https://github.com/broadinstitute/gatk/commit/448b180860657a9002cb46e7592fc0b012646074", "committedDate": "2020-06-01T14:33:48Z", "message": "On second though, use Optional for extension/basename methods. Additional test cases."}, "afterCommit": {"oid": "7aef0fd68077685860512a6d8e530673ec900b21", "author": {"user": {"login": "cmnbroad", "name": "Chris Norman"}}, "url": "https://github.com/broadinstitute/gatk/commit/7aef0fd68077685860512a6d8e530673ec900b21", "committedDate": "2020-06-02T15:42:35Z", "message": "On second though, use Optional for extension/basename methods. Additional test cases."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a074242e86d54362cba10d84b38e233ca13ef934", "author": {"user": {"login": "cmnbroad", "name": "Chris Norman"}}, "url": "https://github.com/broadinstitute/gatk/commit/a074242e86d54362cba10d84b38e233ca13ef934", "committedDate": "2020-06-02T15:42:35Z", "message": "Migrate reads command line arguments, and downstream code, to use GATKPathSpecifier - Phase 1."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9256a13c9e38e99890359e62667501565d4858bc", "author": {"user": {"login": "cmnbroad", "name": "Chris Norman"}}, "url": "https://github.com/broadinstitute/gatk/commit/9256a13c9e38e99890359e62667501565d4858bc", "committedDate": "2020-06-02T15:42:35Z", "message": "Remove confusing getReadSourceName List interconversions."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0eaf1eda8fd2f7f4caeb0bd72b11e99171d411a9", "author": {"user": {"login": "cmnbroad", "name": "Chris Norman"}}, "url": "https://github.com/broadinstitute/gatk/commit/0eaf1eda8fd2f7f4caeb0bd72b11e99171d411a9", "committedDate": "2020-06-02T15:42:35Z", "message": "Migrate read outputs and writers to GATKPathSpecifier."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3b32850fe374435eba770f0fea866f999bb57752", "author": {"user": {"login": "cmnbroad", "name": "Chris Norman"}}, "url": "https://github.com/broadinstitute/gatk/commit/3b32850fe374435eba770f0fea866f999bb57752", "committedDate": "2020-06-02T15:42:35Z", "message": "Move read index inputs to GATKPathSpecifier."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a8a3c2a7f6a96e449c45bad98f71460cbd4f7329", "author": {"user": {"login": "cmnbroad", "name": "Chris Norman"}}, "url": "https://github.com/broadinstitute/gatk/commit/a8a3c2a7f6a96e449c45bad98f71460cbd4f7329", "committedDate": "2020-06-02T15:42:35Z", "message": "Migrate UserExceptions with File type, and some tool output to GATKPathSpecifier."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "31d9ca6ac394451cbd4527383c4d88fdd27ecf96", "author": {"user": {"login": "cmnbroad", "name": "Chris Norman"}}, "url": "https://github.com/broadinstitute/gatk/commit/31d9ca6ac394451cbd4527383c4d88fdd27ecf96", "committedDate": "2020-06-02T15:42:35Z", "message": "Lift getReadPaths up to ReadArgumetnCollection, fix deprecation warning in GATKTool."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "126d045d9caa232862355b2b780a5eb13cf87d26", "author": {"user": {"login": "cmnbroad", "name": "Chris Norman"}}, "url": "https://github.com/broadinstitute/gatk/commit/126d045d9caa232862355b2b780a5eb13cf87d26", "committedDate": "2020-06-02T15:42:35Z", "message": "Code review comments."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ca858641f903060918931f982542435da43b4c37", "author": {"user": {"login": "cmnbroad", "name": "Chris Norman"}}, "url": "https://github.com/broadinstitute/gatk/commit/ca858641f903060918931f982542435da43b4c37", "committedDate": "2020-06-02T15:42:35Z", "message": "SplitReads and RevertSamSpark."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "89720305dc94d09bdb521e63e6a029c89af97f88", "author": {"user": {"login": "cmnbroad", "name": "Chris Norman"}}, "url": "https://github.com/broadinstitute/gatk/commit/89720305dc94d09bdb521e63e6a029c89af97f88", "committedDate": "2020-06-02T15:42:35Z", "message": "Remove TODOs in favor of an issue ticket."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "20361b7a7ce86c089e8cf4aa4e9a555f40fde1a0", "author": {"user": {"login": "cmnbroad", "name": "Chris Norman"}}, "url": "https://github.com/broadinstitute/gatk/commit/20361b7a7ce86c089e8cf4aa4e9a555f40fde1a0", "committedDate": "2020-06-02T15:42:35Z", "message": "Rebase and fix code to enable the merge build to compile on travis."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2af5162331dfb45f1d6548d7fabf49edc0c0bb1b", "author": {"user": {"login": "cmnbroad", "name": "Chris Norman"}}, "url": "https://github.com/broadinstitute/gatk/commit/2af5162331dfb45f1d6548d7fabf49edc0c0bb1b", "committedDate": "2020-06-02T15:42:35Z", "message": "Fix isHadoopURL."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "fa07c551c5164e0438c234fb6633b01191605ffe", "author": {"user": {"login": "cmnbroad", "name": "Chris Norman"}}, "url": "https://github.com/broadinstitute/gatk/commit/fa07c551c5164e0438c234fb6633b01191605ffe", "committedDate": "2020-06-02T15:42:35Z", "message": "More code review comments."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "919336aaeb3ec623956d290127f72dc0e508dc7b", "author": {"user": {"login": "cmnbroad", "name": "Chris Norman"}}, "url": "https://github.com/broadinstitute/gatk/commit/919336aaeb3ec623956d290127f72dc0e508dc7b", "committedDate": "2020-06-02T15:42:35Z", "message": "Fix incorrectly resolved merge conflict."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7aef0fd68077685860512a6d8e530673ec900b21", "author": {"user": {"login": "cmnbroad", "name": "Chris Norman"}}, "url": "https://github.com/broadinstitute/gatk/commit/7aef0fd68077685860512a6d8e530673ec900b21", "committedDate": "2020-06-02T15:42:35Z", "message": "On second though, use Optional for extension/basename methods. Additional test cases."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7b561cb3095793b5edc4dfe26150c1f7fc2d81aa", "author": {"user": {"login": "cmnbroad", "name": "Chris Norman"}}, "url": "https://github.com/broadinstitute/gatk/commit/7b561cb3095793b5edc4dfe26150c1f7fc2d81aa", "committedDate": "2020-06-02T16:12:48Z", "message": "Update changes in PathSeqBwaSpark from master."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "997fa63493e72a2523102f114843fe11e86598f5", "author": {"user": {"login": "cmnbroad", "name": "Chris Norman"}}, "url": "https://github.com/broadinstitute/gatk/commit/997fa63493e72a2523102f114843fe11e86598f5", "committedDate": "2020-06-02T17:27:39Z", "message": "Fix SplitReads to handle Optional returned from getBaseName and getExtension."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIyOTQyNDE3", "url": "https://github.com/broadinstitute/gatk/pull/6561#pullrequestreview-422942417", "createdAt": "2020-06-02T18:17:40Z", "commit": {"oid": "7b561cb3095793b5edc4dfe26150c1f7fc2d81aa"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2864, "cost": 1, "resetAt": "2021-11-01T13:07:16Z"}}}