{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDQ2MDczOTEy", "number": 5030, "reviewThreads": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xM1QxNTowMzoxM1rOEN2_Kg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNVQxMjo0MDo1OFrOEOqonw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgyOTY3ODUwOnYy", "diffSide": "RIGHT", "path": "jetty-websocket/jetty-websocket-tests/src/test/java/org/eclipse/jetty/websocket/tests/client/ConnectFutureAbortTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xM1QxNTowMzoxM1rOGwsoqg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xM1QxNTowMzoxM1rOGwsoqg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzcxNjEzOA==", "bodyText": "Use just 1 second when you test for false.", "url": "https://github.com/eclipse/jetty.project/pull/5030#discussion_r453716138", "createdAt": "2020-07-13T15:03:13Z", "author": {"login": "sbordet"}, "path": "jetty-websocket/jetty-websocket-tests/src/test/java/org/eclipse/jetty/websocket/tests/client/ConnectFutureAbortTest.java", "diffHunk": "@@ -0,0 +1,284 @@\n+//\n+//  ========================================================================\n+//  Copyright (c) 1995-2020 Mort Bay Consulting Pty Ltd and others.\n+//  ------------------------------------------------------------------------\n+//  All rights reserved. This program and the accompanying materials\n+//  are made available under the terms of the Eclipse Public License v1.0\n+//  and Apache License v2.0 which accompanies this distribution.\n+//\n+//      The Eclipse Public License is available at\n+//      http://www.eclipse.org/legal/epl-v10.html\n+//\n+//      The Apache License v2.0 is available at\n+//      http://www.opensource.org/licenses/apache2.0.php\n+//\n+//  You may elect to redistribute this code under either of these licenses.\n+//  ========================================================================\n+//\n+\n+package org.eclipse.jetty.websocket.tests.client;\n+\n+import java.util.EnumSet;\n+import java.util.concurrent.CancellationException;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+import javax.servlet.DispatcherType;\n+\n+import org.eclipse.jetty.server.Server;\n+import org.eclipse.jetty.server.ServerConnector;\n+import org.eclipse.jetty.servlet.ServletContextHandler;\n+import org.eclipse.jetty.websocket.api.Session;\n+import org.eclipse.jetty.websocket.api.StatusCode;\n+import org.eclipse.jetty.websocket.api.UpgradeException;\n+import org.eclipse.jetty.websocket.api.UpgradeRequest;\n+import org.eclipse.jetty.websocket.api.UpgradeResponse;\n+import org.eclipse.jetty.websocket.api.util.WSURI;\n+import org.eclipse.jetty.websocket.client.ClientUpgradeRequest;\n+import org.eclipse.jetty.websocket.client.WebSocketClient;\n+import org.eclipse.jetty.websocket.client.io.UpgradeListener;\n+import org.eclipse.jetty.websocket.common.WebSocketSession;\n+import org.eclipse.jetty.websocket.common.WebSocketSessionListener;\n+import org.eclipse.jetty.websocket.server.NativeWebSocketConfiguration;\n+import org.eclipse.jetty.websocket.server.NativeWebSocketServletContainerInitializer;\n+import org.eclipse.jetty.websocket.server.WebSocketUpgradeFilter;\n+import org.eclipse.jetty.websocket.tests.CloseTrackingEndpoint;\n+import org.eclipse.jetty.websocket.tests.EventSocket;\n+import org.hamcrest.Matchers;\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.Test;\n+\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.instanceOf;\n+import static org.hamcrest.Matchers.is;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertNull;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+public class ConnectFutureAbortTest\n+{\n+    private Server server;\n+    private WebSocketClient client;\n+\n+    @FunctionalInterface\n+    public interface Configuration\n+    {\n+        void configure(NativeWebSocketConfiguration configuration);\n+    }\n+\n+    public void start(Configuration configuration) throws Exception\n+    {\n+        server = new Server();\n+        ServerConnector connector = new ServerConnector(server);\n+        server.addConnector(connector);\n+\n+        ServletContextHandler contextHandler = new ServletContextHandler();\n+        contextHandler.setContextPath(\"/\");\n+        server.setHandler(contextHandler);\n+\n+        NativeWebSocketServletContainerInitializer.configure(contextHandler, (context, container) ->\n+            configuration.configure(container));\n+        contextHandler.addFilter(WebSocketUpgradeFilter.class, \"/\", EnumSet.of(DispatcherType.REQUEST));\n+        server.start();\n+\n+        client = new WebSocketClient();\n+        client.start();\n+    }\n+\n+    @AfterEach\n+    public void stop() throws Exception\n+    {\n+        if (client != null)\n+            client.stop();\n+        if (server != null)\n+            server.stop();\n+    }\n+\n+    @Test\n+    public void testAbortDuringCreator() throws Exception\n+    {\n+        final CountDownLatch enteredCreator = new CountDownLatch(1);\n+        final CountDownLatch exitCreator = new CountDownLatch(1);\n+        start(c ->\n+        {\n+            c.addMapping(\"/\", (req, res) ->\n+            {\n+                try\n+                {\n+                    enteredCreator.countDown();\n+                    exitCreator.await();\n+                    return new EventSocket.EchoSocket();\n+                }\n+                catch (InterruptedException e)\n+                {\n+                    throw new IllegalStateException(e);\n+                }\n+            });\n+        });\n+\n+        CloseTrackingEndpoint clientSocket = new CloseTrackingEndpoint();\n+        Future<Session> connect = client.connect(clientSocket, WSURI.toWebsocket(server.getURI()));\n+\n+        // Cancel the future once we have entered the servers WebSocketCreator (after upgrade request is sent).\n+        assertTrue(enteredCreator.await(5, TimeUnit.SECONDS));\n+        assertTrue(connect.cancel(true));\n+        assertThrows(CancellationException.class, () -> connect.get(5, TimeUnit.SECONDS));\n+        exitCreator.countDown();\n+        assertFalse(clientSocket.openLatch.await(2, TimeUnit.SECONDS));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d7c47f42d6e69c997d5e2178eb8169d456c1c3fa"}, "originalPosition": 128}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgyOTY5Mzc5OnYy", "diffSide": "RIGHT", "path": "jetty-websocket/jetty-websocket-tests/src/test/java/org/eclipse/jetty/websocket/tests/client/ConnectFutureAbortTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xM1QxNTowNjozNFrOGwsyGQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNFQwNzoyMjo0MVrOGxHcgg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzcxODU1Mw==", "bodyText": "Strange comment :)\nWhy would onOpen() even be called, if the connect() has been canceled?", "url": "https://github.com/eclipse/jetty.project/pull/5030#discussion_r453718553", "createdAt": "2020-07-13T15:06:34Z", "author": {"login": "sbordet"}, "path": "jetty-websocket/jetty-websocket-tests/src/test/java/org/eclipse/jetty/websocket/tests/client/ConnectFutureAbortTest.java", "diffHunk": "@@ -0,0 +1,284 @@\n+//\n+//  ========================================================================\n+//  Copyright (c) 1995-2020 Mort Bay Consulting Pty Ltd and others.\n+//  ------------------------------------------------------------------------\n+//  All rights reserved. This program and the accompanying materials\n+//  are made available under the terms of the Eclipse Public License v1.0\n+//  and Apache License v2.0 which accompanies this distribution.\n+//\n+//      The Eclipse Public License is available at\n+//      http://www.eclipse.org/legal/epl-v10.html\n+//\n+//      The Apache License v2.0 is available at\n+//      http://www.opensource.org/licenses/apache2.0.php\n+//\n+//  You may elect to redistribute this code under either of these licenses.\n+//  ========================================================================\n+//\n+\n+package org.eclipse.jetty.websocket.tests.client;\n+\n+import java.util.EnumSet;\n+import java.util.concurrent.CancellationException;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+import javax.servlet.DispatcherType;\n+\n+import org.eclipse.jetty.server.Server;\n+import org.eclipse.jetty.server.ServerConnector;\n+import org.eclipse.jetty.servlet.ServletContextHandler;\n+import org.eclipse.jetty.websocket.api.Session;\n+import org.eclipse.jetty.websocket.api.StatusCode;\n+import org.eclipse.jetty.websocket.api.UpgradeException;\n+import org.eclipse.jetty.websocket.api.UpgradeRequest;\n+import org.eclipse.jetty.websocket.api.UpgradeResponse;\n+import org.eclipse.jetty.websocket.api.util.WSURI;\n+import org.eclipse.jetty.websocket.client.ClientUpgradeRequest;\n+import org.eclipse.jetty.websocket.client.WebSocketClient;\n+import org.eclipse.jetty.websocket.client.io.UpgradeListener;\n+import org.eclipse.jetty.websocket.common.WebSocketSession;\n+import org.eclipse.jetty.websocket.common.WebSocketSessionListener;\n+import org.eclipse.jetty.websocket.server.NativeWebSocketConfiguration;\n+import org.eclipse.jetty.websocket.server.NativeWebSocketServletContainerInitializer;\n+import org.eclipse.jetty.websocket.server.WebSocketUpgradeFilter;\n+import org.eclipse.jetty.websocket.tests.CloseTrackingEndpoint;\n+import org.eclipse.jetty.websocket.tests.EventSocket;\n+import org.hamcrest.Matchers;\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.Test;\n+\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.instanceOf;\n+import static org.hamcrest.Matchers.is;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertNull;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+public class ConnectFutureAbortTest\n+{\n+    private Server server;\n+    private WebSocketClient client;\n+\n+    @FunctionalInterface\n+    public interface Configuration\n+    {\n+        void configure(NativeWebSocketConfiguration configuration);\n+    }\n+\n+    public void start(Configuration configuration) throws Exception\n+    {\n+        server = new Server();\n+        ServerConnector connector = new ServerConnector(server);\n+        server.addConnector(connector);\n+\n+        ServletContextHandler contextHandler = new ServletContextHandler();\n+        contextHandler.setContextPath(\"/\");\n+        server.setHandler(contextHandler);\n+\n+        NativeWebSocketServletContainerInitializer.configure(contextHandler, (context, container) ->\n+            configuration.configure(container));\n+        contextHandler.addFilter(WebSocketUpgradeFilter.class, \"/\", EnumSet.of(DispatcherType.REQUEST));\n+        server.start();\n+\n+        client = new WebSocketClient();\n+        client.start();\n+    }\n+\n+    @AfterEach\n+    public void stop() throws Exception\n+    {\n+        if (client != null)\n+            client.stop();\n+        if (server != null)\n+            server.stop();\n+    }\n+\n+    @Test\n+    public void testAbortDuringCreator() throws Exception\n+    {\n+        final CountDownLatch enteredCreator = new CountDownLatch(1);\n+        final CountDownLatch exitCreator = new CountDownLatch(1);\n+        start(c ->\n+        {\n+            c.addMapping(\"/\", (req, res) ->\n+            {\n+                try\n+                {\n+                    enteredCreator.countDown();\n+                    exitCreator.await();\n+                    return new EventSocket.EchoSocket();\n+                }\n+                catch (InterruptedException e)\n+                {\n+                    throw new IllegalStateException(e);\n+                }\n+            });\n+        });\n+\n+        CloseTrackingEndpoint clientSocket = new CloseTrackingEndpoint();\n+        Future<Session> connect = client.connect(clientSocket, WSURI.toWebsocket(server.getURI()));\n+\n+        // Cancel the future once we have entered the servers WebSocketCreator (after upgrade request is sent).\n+        assertTrue(enteredCreator.await(5, TimeUnit.SECONDS));\n+        assertTrue(connect.cancel(true));\n+        assertThrows(CancellationException.class, () -> connect.get(5, TimeUnit.SECONDS));\n+        exitCreator.countDown();\n+        assertFalse(clientSocket.openLatch.await(2, TimeUnit.SECONDS));\n+\n+        // Strange that onError() is called but onOpen() is never called. (This would not be the case in Jetty-10).", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d7c47f42d6e69c997d5e2178eb8169d456c1c3fa"}, "originalPosition": 130}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDE1NTM5NA==", "bodyText": "I didn't mean that onOpen() should be called, but that onError() should only be called if onOpen() has been called previously. I just wasn't expecting both of them to be notified of the failure, only the future. I will remove the comment.", "url": "https://github.com/eclipse/jetty.project/pull/5030#discussion_r454155394", "createdAt": "2020-07-14T07:22:41Z", "author": {"login": "lachlan-roberts"}, "path": "jetty-websocket/jetty-websocket-tests/src/test/java/org/eclipse/jetty/websocket/tests/client/ConnectFutureAbortTest.java", "diffHunk": "@@ -0,0 +1,284 @@\n+//\n+//  ========================================================================\n+//  Copyright (c) 1995-2020 Mort Bay Consulting Pty Ltd and others.\n+//  ------------------------------------------------------------------------\n+//  All rights reserved. This program and the accompanying materials\n+//  are made available under the terms of the Eclipse Public License v1.0\n+//  and Apache License v2.0 which accompanies this distribution.\n+//\n+//      The Eclipse Public License is available at\n+//      http://www.eclipse.org/legal/epl-v10.html\n+//\n+//      The Apache License v2.0 is available at\n+//      http://www.opensource.org/licenses/apache2.0.php\n+//\n+//  You may elect to redistribute this code under either of these licenses.\n+//  ========================================================================\n+//\n+\n+package org.eclipse.jetty.websocket.tests.client;\n+\n+import java.util.EnumSet;\n+import java.util.concurrent.CancellationException;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+import javax.servlet.DispatcherType;\n+\n+import org.eclipse.jetty.server.Server;\n+import org.eclipse.jetty.server.ServerConnector;\n+import org.eclipse.jetty.servlet.ServletContextHandler;\n+import org.eclipse.jetty.websocket.api.Session;\n+import org.eclipse.jetty.websocket.api.StatusCode;\n+import org.eclipse.jetty.websocket.api.UpgradeException;\n+import org.eclipse.jetty.websocket.api.UpgradeRequest;\n+import org.eclipse.jetty.websocket.api.UpgradeResponse;\n+import org.eclipse.jetty.websocket.api.util.WSURI;\n+import org.eclipse.jetty.websocket.client.ClientUpgradeRequest;\n+import org.eclipse.jetty.websocket.client.WebSocketClient;\n+import org.eclipse.jetty.websocket.client.io.UpgradeListener;\n+import org.eclipse.jetty.websocket.common.WebSocketSession;\n+import org.eclipse.jetty.websocket.common.WebSocketSessionListener;\n+import org.eclipse.jetty.websocket.server.NativeWebSocketConfiguration;\n+import org.eclipse.jetty.websocket.server.NativeWebSocketServletContainerInitializer;\n+import org.eclipse.jetty.websocket.server.WebSocketUpgradeFilter;\n+import org.eclipse.jetty.websocket.tests.CloseTrackingEndpoint;\n+import org.eclipse.jetty.websocket.tests.EventSocket;\n+import org.hamcrest.Matchers;\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.Test;\n+\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.instanceOf;\n+import static org.hamcrest.Matchers.is;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertNull;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+public class ConnectFutureAbortTest\n+{\n+    private Server server;\n+    private WebSocketClient client;\n+\n+    @FunctionalInterface\n+    public interface Configuration\n+    {\n+        void configure(NativeWebSocketConfiguration configuration);\n+    }\n+\n+    public void start(Configuration configuration) throws Exception\n+    {\n+        server = new Server();\n+        ServerConnector connector = new ServerConnector(server);\n+        server.addConnector(connector);\n+\n+        ServletContextHandler contextHandler = new ServletContextHandler();\n+        contextHandler.setContextPath(\"/\");\n+        server.setHandler(contextHandler);\n+\n+        NativeWebSocketServletContainerInitializer.configure(contextHandler, (context, container) ->\n+            configuration.configure(container));\n+        contextHandler.addFilter(WebSocketUpgradeFilter.class, \"/\", EnumSet.of(DispatcherType.REQUEST));\n+        server.start();\n+\n+        client = new WebSocketClient();\n+        client.start();\n+    }\n+\n+    @AfterEach\n+    public void stop() throws Exception\n+    {\n+        if (client != null)\n+            client.stop();\n+        if (server != null)\n+            server.stop();\n+    }\n+\n+    @Test\n+    public void testAbortDuringCreator() throws Exception\n+    {\n+        final CountDownLatch enteredCreator = new CountDownLatch(1);\n+        final CountDownLatch exitCreator = new CountDownLatch(1);\n+        start(c ->\n+        {\n+            c.addMapping(\"/\", (req, res) ->\n+            {\n+                try\n+                {\n+                    enteredCreator.countDown();\n+                    exitCreator.await();\n+                    return new EventSocket.EchoSocket();\n+                }\n+                catch (InterruptedException e)\n+                {\n+                    throw new IllegalStateException(e);\n+                }\n+            });\n+        });\n+\n+        CloseTrackingEndpoint clientSocket = new CloseTrackingEndpoint();\n+        Future<Session> connect = client.connect(clientSocket, WSURI.toWebsocket(server.getURI()));\n+\n+        // Cancel the future once we have entered the servers WebSocketCreator (after upgrade request is sent).\n+        assertTrue(enteredCreator.await(5, TimeUnit.SECONDS));\n+        assertTrue(connect.cancel(true));\n+        assertThrows(CancellationException.class, () -> connect.get(5, TimeUnit.SECONDS));\n+        exitCreator.countDown();\n+        assertFalse(clientSocket.openLatch.await(2, TimeUnit.SECONDS));\n+\n+        // Strange that onError() is called but onOpen() is never called. (This would not be the case in Jetty-10).", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzcxODU1Mw=="}, "originalCommit": {"oid": "d7c47f42d6e69c997d5e2178eb8169d456c1c3fa"}, "originalPosition": 130}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgyOTY5NDk2OnYy", "diffSide": "RIGHT", "path": "jetty-websocket/jetty-websocket-tests/src/test/java/org/eclipse/jetty/websocket/tests/client/ConnectFutureAbortTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xM1QxNTowNjo1MFrOGwsy1Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xM1QxNTowNjo1MFrOGwsy1Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzcxODc0MQ==", "bodyText": "Test also that the nested exception is a CancellationException?", "url": "https://github.com/eclipse/jetty.project/pull/5030#discussion_r453718741", "createdAt": "2020-07-13T15:06:50Z", "author": {"login": "sbordet"}, "path": "jetty-websocket/jetty-websocket-tests/src/test/java/org/eclipse/jetty/websocket/tests/client/ConnectFutureAbortTest.java", "diffHunk": "@@ -0,0 +1,284 @@\n+//\n+//  ========================================================================\n+//  Copyright (c) 1995-2020 Mort Bay Consulting Pty Ltd and others.\n+//  ------------------------------------------------------------------------\n+//  All rights reserved. This program and the accompanying materials\n+//  are made available under the terms of the Eclipse Public License v1.0\n+//  and Apache License v2.0 which accompanies this distribution.\n+//\n+//      The Eclipse Public License is available at\n+//      http://www.eclipse.org/legal/epl-v10.html\n+//\n+//      The Apache License v2.0 is available at\n+//      http://www.opensource.org/licenses/apache2.0.php\n+//\n+//  You may elect to redistribute this code under either of these licenses.\n+//  ========================================================================\n+//\n+\n+package org.eclipse.jetty.websocket.tests.client;\n+\n+import java.util.EnumSet;\n+import java.util.concurrent.CancellationException;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+import javax.servlet.DispatcherType;\n+\n+import org.eclipse.jetty.server.Server;\n+import org.eclipse.jetty.server.ServerConnector;\n+import org.eclipse.jetty.servlet.ServletContextHandler;\n+import org.eclipse.jetty.websocket.api.Session;\n+import org.eclipse.jetty.websocket.api.StatusCode;\n+import org.eclipse.jetty.websocket.api.UpgradeException;\n+import org.eclipse.jetty.websocket.api.UpgradeRequest;\n+import org.eclipse.jetty.websocket.api.UpgradeResponse;\n+import org.eclipse.jetty.websocket.api.util.WSURI;\n+import org.eclipse.jetty.websocket.client.ClientUpgradeRequest;\n+import org.eclipse.jetty.websocket.client.WebSocketClient;\n+import org.eclipse.jetty.websocket.client.io.UpgradeListener;\n+import org.eclipse.jetty.websocket.common.WebSocketSession;\n+import org.eclipse.jetty.websocket.common.WebSocketSessionListener;\n+import org.eclipse.jetty.websocket.server.NativeWebSocketConfiguration;\n+import org.eclipse.jetty.websocket.server.NativeWebSocketServletContainerInitializer;\n+import org.eclipse.jetty.websocket.server.WebSocketUpgradeFilter;\n+import org.eclipse.jetty.websocket.tests.CloseTrackingEndpoint;\n+import org.eclipse.jetty.websocket.tests.EventSocket;\n+import org.hamcrest.Matchers;\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.Test;\n+\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.instanceOf;\n+import static org.hamcrest.Matchers.is;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertNull;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+public class ConnectFutureAbortTest\n+{\n+    private Server server;\n+    private WebSocketClient client;\n+\n+    @FunctionalInterface\n+    public interface Configuration\n+    {\n+        void configure(NativeWebSocketConfiguration configuration);\n+    }\n+\n+    public void start(Configuration configuration) throws Exception\n+    {\n+        server = new Server();\n+        ServerConnector connector = new ServerConnector(server);\n+        server.addConnector(connector);\n+\n+        ServletContextHandler contextHandler = new ServletContextHandler();\n+        contextHandler.setContextPath(\"/\");\n+        server.setHandler(contextHandler);\n+\n+        NativeWebSocketServletContainerInitializer.configure(contextHandler, (context, container) ->\n+            configuration.configure(container));\n+        contextHandler.addFilter(WebSocketUpgradeFilter.class, \"/\", EnumSet.of(DispatcherType.REQUEST));\n+        server.start();\n+\n+        client = new WebSocketClient();\n+        client.start();\n+    }\n+\n+    @AfterEach\n+    public void stop() throws Exception\n+    {\n+        if (client != null)\n+            client.stop();\n+        if (server != null)\n+            server.stop();\n+    }\n+\n+    @Test\n+    public void testAbortDuringCreator() throws Exception\n+    {\n+        final CountDownLatch enteredCreator = new CountDownLatch(1);\n+        final CountDownLatch exitCreator = new CountDownLatch(1);\n+        start(c ->\n+        {\n+            c.addMapping(\"/\", (req, res) ->\n+            {\n+                try\n+                {\n+                    enteredCreator.countDown();\n+                    exitCreator.await();\n+                    return new EventSocket.EchoSocket();\n+                }\n+                catch (InterruptedException e)\n+                {\n+                    throw new IllegalStateException(e);\n+                }\n+            });\n+        });\n+\n+        CloseTrackingEndpoint clientSocket = new CloseTrackingEndpoint();\n+        Future<Session> connect = client.connect(clientSocket, WSURI.toWebsocket(server.getURI()));\n+\n+        // Cancel the future once we have entered the servers WebSocketCreator (after upgrade request is sent).\n+        assertTrue(enteredCreator.await(5, TimeUnit.SECONDS));\n+        assertTrue(connect.cancel(true));\n+        assertThrows(CancellationException.class, () -> connect.get(5, TimeUnit.SECONDS));\n+        exitCreator.countDown();\n+        assertFalse(clientSocket.openLatch.await(2, TimeUnit.SECONDS));\n+\n+        // Strange that onError() is called but onOpen() is never called. (This would not be the case in Jetty-10).\n+        assertThat(clientSocket.error.get(), instanceOf(UpgradeException.class));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d7c47f42d6e69c997d5e2178eb8169d456c1c3fa"}, "originalPosition": 131}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgyOTY5NzA1OnYy", "diffSide": "RIGHT", "path": "jetty-websocket/jetty-websocket-tests/src/test/java/org/eclipse/jetty/websocket/tests/client/ConnectFutureAbortTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xM1QxNTowNzoyMlrOGws0PA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xM1QxNTowNzoyMlrOGws0PA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzcxOTEwMA==", "bodyText": "Remove final modifiers, unnecessary.", "url": "https://github.com/eclipse/jetty.project/pull/5030#discussion_r453719100", "createdAt": "2020-07-13T15:07:22Z", "author": {"login": "sbordet"}, "path": "jetty-websocket/jetty-websocket-tests/src/test/java/org/eclipse/jetty/websocket/tests/client/ConnectFutureAbortTest.java", "diffHunk": "@@ -0,0 +1,284 @@\n+//\n+//  ========================================================================\n+//  Copyright (c) 1995-2020 Mort Bay Consulting Pty Ltd and others.\n+//  ------------------------------------------------------------------------\n+//  All rights reserved. This program and the accompanying materials\n+//  are made available under the terms of the Eclipse Public License v1.0\n+//  and Apache License v2.0 which accompanies this distribution.\n+//\n+//      The Eclipse Public License is available at\n+//      http://www.eclipse.org/legal/epl-v10.html\n+//\n+//      The Apache License v2.0 is available at\n+//      http://www.opensource.org/licenses/apache2.0.php\n+//\n+//  You may elect to redistribute this code under either of these licenses.\n+//  ========================================================================\n+//\n+\n+package org.eclipse.jetty.websocket.tests.client;\n+\n+import java.util.EnumSet;\n+import java.util.concurrent.CancellationException;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+import javax.servlet.DispatcherType;\n+\n+import org.eclipse.jetty.server.Server;\n+import org.eclipse.jetty.server.ServerConnector;\n+import org.eclipse.jetty.servlet.ServletContextHandler;\n+import org.eclipse.jetty.websocket.api.Session;\n+import org.eclipse.jetty.websocket.api.StatusCode;\n+import org.eclipse.jetty.websocket.api.UpgradeException;\n+import org.eclipse.jetty.websocket.api.UpgradeRequest;\n+import org.eclipse.jetty.websocket.api.UpgradeResponse;\n+import org.eclipse.jetty.websocket.api.util.WSURI;\n+import org.eclipse.jetty.websocket.client.ClientUpgradeRequest;\n+import org.eclipse.jetty.websocket.client.WebSocketClient;\n+import org.eclipse.jetty.websocket.client.io.UpgradeListener;\n+import org.eclipse.jetty.websocket.common.WebSocketSession;\n+import org.eclipse.jetty.websocket.common.WebSocketSessionListener;\n+import org.eclipse.jetty.websocket.server.NativeWebSocketConfiguration;\n+import org.eclipse.jetty.websocket.server.NativeWebSocketServletContainerInitializer;\n+import org.eclipse.jetty.websocket.server.WebSocketUpgradeFilter;\n+import org.eclipse.jetty.websocket.tests.CloseTrackingEndpoint;\n+import org.eclipse.jetty.websocket.tests.EventSocket;\n+import org.hamcrest.Matchers;\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.Test;\n+\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.instanceOf;\n+import static org.hamcrest.Matchers.is;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertNull;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+public class ConnectFutureAbortTest\n+{\n+    private Server server;\n+    private WebSocketClient client;\n+\n+    @FunctionalInterface\n+    public interface Configuration\n+    {\n+        void configure(NativeWebSocketConfiguration configuration);\n+    }\n+\n+    public void start(Configuration configuration) throws Exception\n+    {\n+        server = new Server();\n+        ServerConnector connector = new ServerConnector(server);\n+        server.addConnector(connector);\n+\n+        ServletContextHandler contextHandler = new ServletContextHandler();\n+        contextHandler.setContextPath(\"/\");\n+        server.setHandler(contextHandler);\n+\n+        NativeWebSocketServletContainerInitializer.configure(contextHandler, (context, container) ->\n+            configuration.configure(container));\n+        contextHandler.addFilter(WebSocketUpgradeFilter.class, \"/\", EnumSet.of(DispatcherType.REQUEST));\n+        server.start();\n+\n+        client = new WebSocketClient();\n+        client.start();\n+    }\n+\n+    @AfterEach\n+    public void stop() throws Exception\n+    {\n+        if (client != null)\n+            client.stop();\n+        if (server != null)\n+            server.stop();\n+    }\n+\n+    @Test\n+    public void testAbortDuringCreator() throws Exception\n+    {\n+        final CountDownLatch enteredCreator = new CountDownLatch(1);\n+        final CountDownLatch exitCreator = new CountDownLatch(1);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d7c47f42d6e69c997d5e2178eb8169d456c1c3fa"}, "originalPosition": 102}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgyOTcxNDQ4OnYy", "diffSide": "RIGHT", "path": "jetty-websocket/jetty-websocket-tests/src/test/java/org/eclipse/jetty/websocket/tests/client/ConnectFutureAbortTest.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xM1QxNToxMToyMFrOGws_Tg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNFQxMTo1MTozMVrOGxQRiA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzcyMTkzNA==", "bodyText": "This is probably going to fail in Jetty 10 since it's an anonymous endPoint and will fail the method handles permissions. Perhaps make it a proper public inner class now to avoid merge conflicts in the future?", "url": "https://github.com/eclipse/jetty.project/pull/5030#discussion_r453721934", "createdAt": "2020-07-13T15:11:20Z", "author": {"login": "sbordet"}, "path": "jetty-websocket/jetty-websocket-tests/src/test/java/org/eclipse/jetty/websocket/tests/client/ConnectFutureAbortTest.java", "diffHunk": "@@ -0,0 +1,284 @@\n+//\n+//  ========================================================================\n+//  Copyright (c) 1995-2020 Mort Bay Consulting Pty Ltd and others.\n+//  ------------------------------------------------------------------------\n+//  All rights reserved. This program and the accompanying materials\n+//  are made available under the terms of the Eclipse Public License v1.0\n+//  and Apache License v2.0 which accompanies this distribution.\n+//\n+//      The Eclipse Public License is available at\n+//      http://www.eclipse.org/legal/epl-v10.html\n+//\n+//      The Apache License v2.0 is available at\n+//      http://www.opensource.org/licenses/apache2.0.php\n+//\n+//  You may elect to redistribute this code under either of these licenses.\n+//  ========================================================================\n+//\n+\n+package org.eclipse.jetty.websocket.tests.client;\n+\n+import java.util.EnumSet;\n+import java.util.concurrent.CancellationException;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+import javax.servlet.DispatcherType;\n+\n+import org.eclipse.jetty.server.Server;\n+import org.eclipse.jetty.server.ServerConnector;\n+import org.eclipse.jetty.servlet.ServletContextHandler;\n+import org.eclipse.jetty.websocket.api.Session;\n+import org.eclipse.jetty.websocket.api.StatusCode;\n+import org.eclipse.jetty.websocket.api.UpgradeException;\n+import org.eclipse.jetty.websocket.api.UpgradeRequest;\n+import org.eclipse.jetty.websocket.api.UpgradeResponse;\n+import org.eclipse.jetty.websocket.api.util.WSURI;\n+import org.eclipse.jetty.websocket.client.ClientUpgradeRequest;\n+import org.eclipse.jetty.websocket.client.WebSocketClient;\n+import org.eclipse.jetty.websocket.client.io.UpgradeListener;\n+import org.eclipse.jetty.websocket.common.WebSocketSession;\n+import org.eclipse.jetty.websocket.common.WebSocketSessionListener;\n+import org.eclipse.jetty.websocket.server.NativeWebSocketConfiguration;\n+import org.eclipse.jetty.websocket.server.NativeWebSocketServletContainerInitializer;\n+import org.eclipse.jetty.websocket.server.WebSocketUpgradeFilter;\n+import org.eclipse.jetty.websocket.tests.CloseTrackingEndpoint;\n+import org.eclipse.jetty.websocket.tests.EventSocket;\n+import org.hamcrest.Matchers;\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.Test;\n+\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.instanceOf;\n+import static org.hamcrest.Matchers.is;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertNull;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+public class ConnectFutureAbortTest\n+{\n+    private Server server;\n+    private WebSocketClient client;\n+\n+    @FunctionalInterface\n+    public interface Configuration\n+    {\n+        void configure(NativeWebSocketConfiguration configuration);\n+    }\n+\n+    public void start(Configuration configuration) throws Exception\n+    {\n+        server = new Server();\n+        ServerConnector connector = new ServerConnector(server);\n+        server.addConnector(connector);\n+\n+        ServletContextHandler contextHandler = new ServletContextHandler();\n+        contextHandler.setContextPath(\"/\");\n+        server.setHandler(contextHandler);\n+\n+        NativeWebSocketServletContainerInitializer.configure(contextHandler, (context, container) ->\n+            configuration.configure(container));\n+        contextHandler.addFilter(WebSocketUpgradeFilter.class, \"/\", EnumSet.of(DispatcherType.REQUEST));\n+        server.start();\n+\n+        client = new WebSocketClient();\n+        client.start();\n+    }\n+\n+    @AfterEach\n+    public void stop() throws Exception\n+    {\n+        if (client != null)\n+            client.stop();\n+        if (server != null)\n+            server.stop();\n+    }\n+\n+    @Test\n+    public void testAbortDuringCreator() throws Exception\n+    {\n+        final CountDownLatch enteredCreator = new CountDownLatch(1);\n+        final CountDownLatch exitCreator = new CountDownLatch(1);\n+        start(c ->\n+        {\n+            c.addMapping(\"/\", (req, res) ->\n+            {\n+                try\n+                {\n+                    enteredCreator.countDown();\n+                    exitCreator.await();\n+                    return new EventSocket.EchoSocket();\n+                }\n+                catch (InterruptedException e)\n+                {\n+                    throw new IllegalStateException(e);\n+                }\n+            });\n+        });\n+\n+        CloseTrackingEndpoint clientSocket = new CloseTrackingEndpoint();\n+        Future<Session> connect = client.connect(clientSocket, WSURI.toWebsocket(server.getURI()));\n+\n+        // Cancel the future once we have entered the servers WebSocketCreator (after upgrade request is sent).\n+        assertTrue(enteredCreator.await(5, TimeUnit.SECONDS));\n+        assertTrue(connect.cancel(true));\n+        assertThrows(CancellationException.class, () -> connect.get(5, TimeUnit.SECONDS));\n+        exitCreator.countDown();\n+        assertFalse(clientSocket.openLatch.await(2, TimeUnit.SECONDS));\n+\n+        // Strange that onError() is called but onOpen() is never called. (This would not be the case in Jetty-10).\n+        assertThat(clientSocket.error.get(), instanceOf(UpgradeException.class));\n+    }\n+\n+    @Test\n+    public void testAbortSessionOnCreated() throws Exception\n+    {\n+        start(c -> c.addMapping(\"/\", EventSocket.EchoSocket.class));\n+\n+        final CountDownLatch enteredListener = new CountDownLatch(1);\n+        final CountDownLatch exitListener = new CountDownLatch(1);\n+        client.addSessionListener(new WebSocketSessionListener()\n+        {\n+            @Override\n+            public void onSessionCreated(WebSocketSession session)\n+            {\n+                try\n+                {\n+                    enteredListener.countDown();\n+                    exitListener.await();\n+                }\n+                catch (InterruptedException e)\n+                {\n+                    throw new IllegalStateException(e);\n+                }\n+            }\n+        });\n+\n+        CloseTrackingEndpoint clientSocket = new CloseTrackingEndpoint();\n+        Future<Session> connect = client.connect(clientSocket, WSURI.toWebsocket(server.getURI()));\n+\n+        // Abort when session is created, this is before future has been added to session and before the connection upgrade.\n+        assertTrue(enteredListener.await(5, TimeUnit.SECONDS));\n+        assertTrue(connect.cancel(true));\n+        assertThrows(CancellationException.class, () -> connect.get(5, TimeUnit.SECONDS));\n+        exitListener.countDown();\n+        assertFalse(clientSocket.openLatch.await(2, TimeUnit.SECONDS));\n+\n+        // Strange that onError() is called but onOpen() is never called. (This would not be the case in Jetty-10).\n+        assertThat(clientSocket.error.get(), instanceOf(CancellationException.class));\n+    }\n+\n+    @Test\n+    public void testAbortInHandshakeResponse() throws Exception\n+    {\n+        start(c -> c.addMapping(\"/\", EventSocket.EchoSocket.class));\n+\n+        final CountDownLatch enteredListener = new CountDownLatch(1);\n+        final CountDownLatch exitListener = new CountDownLatch(1);\n+        UpgradeListener upgradeListener = new AbstractUpgradeListener()\n+        {\n+            @Override\n+            public void onHandshakeResponse(UpgradeResponse response)\n+            {\n+                try\n+                {\n+                    enteredListener.countDown();\n+                    exitListener.await();\n+                }\n+                catch (InterruptedException e)\n+                {\n+                    throw new IllegalStateException(e);\n+                }\n+            }\n+        };\n+\n+        CloseTrackingEndpoint clientSocket = new CloseTrackingEndpoint();\n+        ClientUpgradeRequest upgradeRequest = new ClientUpgradeRequest();\n+        Future<Session> connect = client.connect(clientSocket, WSURI.toWebsocket(server.getURI()), upgradeRequest, upgradeListener);\n+\n+        // Abort after after handshake response, which is before connection upgrade, but after future has been set on session.\n+        assertTrue(enteredListener.await(5, TimeUnit.SECONDS));\n+        assertTrue(connect.cancel(true));\n+        assertThrows(CancellationException.class, () -> connect.get(5, TimeUnit.SECONDS));\n+        exitListener.countDown();\n+        assertFalse(clientSocket.openLatch.await(2, TimeUnit.SECONDS));\n+\n+        // Strange that onError() is called but onOpen() is never called. (This would not be the case in Jetty-10).\n+        assertThat(clientSocket.error.get(), instanceOf(CancellationException.class));\n+    }\n+\n+    @Test\n+    public void testAbortOnOpened() throws Exception\n+    {\n+        start(c -> c.addMapping(\"/\", EventSocket.EchoSocket.class));\n+\n+        final CountDownLatch exitOnOpen = new CountDownLatch(1);\n+        CloseTrackingEndpoint clientSocket = new CloseTrackingEndpoint()\n+        {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d7c47f42d6e69c997d5e2178eb8169d456c1c3fa"}, "originalPosition": 218}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDE1NTUwNw==", "bodyText": "This shouldn't fail in Jetty 10, this CloseTrackingEndpoint extends the WebSocketListener. I think that issue with the public inner class is only for the annotated version as we need to discover the methods.", "url": "https://github.com/eclipse/jetty.project/pull/5030#discussion_r454155507", "createdAt": "2020-07-14T07:22:55Z", "author": {"login": "lachlan-roberts"}, "path": "jetty-websocket/jetty-websocket-tests/src/test/java/org/eclipse/jetty/websocket/tests/client/ConnectFutureAbortTest.java", "diffHunk": "@@ -0,0 +1,284 @@\n+//\n+//  ========================================================================\n+//  Copyright (c) 1995-2020 Mort Bay Consulting Pty Ltd and others.\n+//  ------------------------------------------------------------------------\n+//  All rights reserved. This program and the accompanying materials\n+//  are made available under the terms of the Eclipse Public License v1.0\n+//  and Apache License v2.0 which accompanies this distribution.\n+//\n+//      The Eclipse Public License is available at\n+//      http://www.eclipse.org/legal/epl-v10.html\n+//\n+//      The Apache License v2.0 is available at\n+//      http://www.opensource.org/licenses/apache2.0.php\n+//\n+//  You may elect to redistribute this code under either of these licenses.\n+//  ========================================================================\n+//\n+\n+package org.eclipse.jetty.websocket.tests.client;\n+\n+import java.util.EnumSet;\n+import java.util.concurrent.CancellationException;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+import javax.servlet.DispatcherType;\n+\n+import org.eclipse.jetty.server.Server;\n+import org.eclipse.jetty.server.ServerConnector;\n+import org.eclipse.jetty.servlet.ServletContextHandler;\n+import org.eclipse.jetty.websocket.api.Session;\n+import org.eclipse.jetty.websocket.api.StatusCode;\n+import org.eclipse.jetty.websocket.api.UpgradeException;\n+import org.eclipse.jetty.websocket.api.UpgradeRequest;\n+import org.eclipse.jetty.websocket.api.UpgradeResponse;\n+import org.eclipse.jetty.websocket.api.util.WSURI;\n+import org.eclipse.jetty.websocket.client.ClientUpgradeRequest;\n+import org.eclipse.jetty.websocket.client.WebSocketClient;\n+import org.eclipse.jetty.websocket.client.io.UpgradeListener;\n+import org.eclipse.jetty.websocket.common.WebSocketSession;\n+import org.eclipse.jetty.websocket.common.WebSocketSessionListener;\n+import org.eclipse.jetty.websocket.server.NativeWebSocketConfiguration;\n+import org.eclipse.jetty.websocket.server.NativeWebSocketServletContainerInitializer;\n+import org.eclipse.jetty.websocket.server.WebSocketUpgradeFilter;\n+import org.eclipse.jetty.websocket.tests.CloseTrackingEndpoint;\n+import org.eclipse.jetty.websocket.tests.EventSocket;\n+import org.hamcrest.Matchers;\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.Test;\n+\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.instanceOf;\n+import static org.hamcrest.Matchers.is;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertNull;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+public class ConnectFutureAbortTest\n+{\n+    private Server server;\n+    private WebSocketClient client;\n+\n+    @FunctionalInterface\n+    public interface Configuration\n+    {\n+        void configure(NativeWebSocketConfiguration configuration);\n+    }\n+\n+    public void start(Configuration configuration) throws Exception\n+    {\n+        server = new Server();\n+        ServerConnector connector = new ServerConnector(server);\n+        server.addConnector(connector);\n+\n+        ServletContextHandler contextHandler = new ServletContextHandler();\n+        contextHandler.setContextPath(\"/\");\n+        server.setHandler(contextHandler);\n+\n+        NativeWebSocketServletContainerInitializer.configure(contextHandler, (context, container) ->\n+            configuration.configure(container));\n+        contextHandler.addFilter(WebSocketUpgradeFilter.class, \"/\", EnumSet.of(DispatcherType.REQUEST));\n+        server.start();\n+\n+        client = new WebSocketClient();\n+        client.start();\n+    }\n+\n+    @AfterEach\n+    public void stop() throws Exception\n+    {\n+        if (client != null)\n+            client.stop();\n+        if (server != null)\n+            server.stop();\n+    }\n+\n+    @Test\n+    public void testAbortDuringCreator() throws Exception\n+    {\n+        final CountDownLatch enteredCreator = new CountDownLatch(1);\n+        final CountDownLatch exitCreator = new CountDownLatch(1);\n+        start(c ->\n+        {\n+            c.addMapping(\"/\", (req, res) ->\n+            {\n+                try\n+                {\n+                    enteredCreator.countDown();\n+                    exitCreator.await();\n+                    return new EventSocket.EchoSocket();\n+                }\n+                catch (InterruptedException e)\n+                {\n+                    throw new IllegalStateException(e);\n+                }\n+            });\n+        });\n+\n+        CloseTrackingEndpoint clientSocket = new CloseTrackingEndpoint();\n+        Future<Session> connect = client.connect(clientSocket, WSURI.toWebsocket(server.getURI()));\n+\n+        // Cancel the future once we have entered the servers WebSocketCreator (after upgrade request is sent).\n+        assertTrue(enteredCreator.await(5, TimeUnit.SECONDS));\n+        assertTrue(connect.cancel(true));\n+        assertThrows(CancellationException.class, () -> connect.get(5, TimeUnit.SECONDS));\n+        exitCreator.countDown();\n+        assertFalse(clientSocket.openLatch.await(2, TimeUnit.SECONDS));\n+\n+        // Strange that onError() is called but onOpen() is never called. (This would not be the case in Jetty-10).\n+        assertThat(clientSocket.error.get(), instanceOf(UpgradeException.class));\n+    }\n+\n+    @Test\n+    public void testAbortSessionOnCreated() throws Exception\n+    {\n+        start(c -> c.addMapping(\"/\", EventSocket.EchoSocket.class));\n+\n+        final CountDownLatch enteredListener = new CountDownLatch(1);\n+        final CountDownLatch exitListener = new CountDownLatch(1);\n+        client.addSessionListener(new WebSocketSessionListener()\n+        {\n+            @Override\n+            public void onSessionCreated(WebSocketSession session)\n+            {\n+                try\n+                {\n+                    enteredListener.countDown();\n+                    exitListener.await();\n+                }\n+                catch (InterruptedException e)\n+                {\n+                    throw new IllegalStateException(e);\n+                }\n+            }\n+        });\n+\n+        CloseTrackingEndpoint clientSocket = new CloseTrackingEndpoint();\n+        Future<Session> connect = client.connect(clientSocket, WSURI.toWebsocket(server.getURI()));\n+\n+        // Abort when session is created, this is before future has been added to session and before the connection upgrade.\n+        assertTrue(enteredListener.await(5, TimeUnit.SECONDS));\n+        assertTrue(connect.cancel(true));\n+        assertThrows(CancellationException.class, () -> connect.get(5, TimeUnit.SECONDS));\n+        exitListener.countDown();\n+        assertFalse(clientSocket.openLatch.await(2, TimeUnit.SECONDS));\n+\n+        // Strange that onError() is called but onOpen() is never called. (This would not be the case in Jetty-10).\n+        assertThat(clientSocket.error.get(), instanceOf(CancellationException.class));\n+    }\n+\n+    @Test\n+    public void testAbortInHandshakeResponse() throws Exception\n+    {\n+        start(c -> c.addMapping(\"/\", EventSocket.EchoSocket.class));\n+\n+        final CountDownLatch enteredListener = new CountDownLatch(1);\n+        final CountDownLatch exitListener = new CountDownLatch(1);\n+        UpgradeListener upgradeListener = new AbstractUpgradeListener()\n+        {\n+            @Override\n+            public void onHandshakeResponse(UpgradeResponse response)\n+            {\n+                try\n+                {\n+                    enteredListener.countDown();\n+                    exitListener.await();\n+                }\n+                catch (InterruptedException e)\n+                {\n+                    throw new IllegalStateException(e);\n+                }\n+            }\n+        };\n+\n+        CloseTrackingEndpoint clientSocket = new CloseTrackingEndpoint();\n+        ClientUpgradeRequest upgradeRequest = new ClientUpgradeRequest();\n+        Future<Session> connect = client.connect(clientSocket, WSURI.toWebsocket(server.getURI()), upgradeRequest, upgradeListener);\n+\n+        // Abort after after handshake response, which is before connection upgrade, but after future has been set on session.\n+        assertTrue(enteredListener.await(5, TimeUnit.SECONDS));\n+        assertTrue(connect.cancel(true));\n+        assertThrows(CancellationException.class, () -> connect.get(5, TimeUnit.SECONDS));\n+        exitListener.countDown();\n+        assertFalse(clientSocket.openLatch.await(2, TimeUnit.SECONDS));\n+\n+        // Strange that onError() is called but onOpen() is never called. (This would not be the case in Jetty-10).\n+        assertThat(clientSocket.error.get(), instanceOf(CancellationException.class));\n+    }\n+\n+    @Test\n+    public void testAbortOnOpened() throws Exception\n+    {\n+        start(c -> c.addMapping(\"/\", EventSocket.EchoSocket.class));\n+\n+        final CountDownLatch exitOnOpen = new CountDownLatch(1);\n+        CloseTrackingEndpoint clientSocket = new CloseTrackingEndpoint()\n+        {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzcyMTkzNA=="}, "originalCommit": {"oid": "d7c47f42d6e69c997d5e2178eb8169d456c1c3fa"}, "originalPosition": 218}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDMwMDA0MA==", "bodyText": "Issue #5043 opened for this.", "url": "https://github.com/eclipse/jetty.project/pull/5030#discussion_r454300040", "createdAt": "2020-07-14T11:51:31Z", "author": {"login": "lachlan-roberts"}, "path": "jetty-websocket/jetty-websocket-tests/src/test/java/org/eclipse/jetty/websocket/tests/client/ConnectFutureAbortTest.java", "diffHunk": "@@ -0,0 +1,284 @@\n+//\n+//  ========================================================================\n+//  Copyright (c) 1995-2020 Mort Bay Consulting Pty Ltd and others.\n+//  ------------------------------------------------------------------------\n+//  All rights reserved. This program and the accompanying materials\n+//  are made available under the terms of the Eclipse Public License v1.0\n+//  and Apache License v2.0 which accompanies this distribution.\n+//\n+//      The Eclipse Public License is available at\n+//      http://www.eclipse.org/legal/epl-v10.html\n+//\n+//      The Apache License v2.0 is available at\n+//      http://www.opensource.org/licenses/apache2.0.php\n+//\n+//  You may elect to redistribute this code under either of these licenses.\n+//  ========================================================================\n+//\n+\n+package org.eclipse.jetty.websocket.tests.client;\n+\n+import java.util.EnumSet;\n+import java.util.concurrent.CancellationException;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+import javax.servlet.DispatcherType;\n+\n+import org.eclipse.jetty.server.Server;\n+import org.eclipse.jetty.server.ServerConnector;\n+import org.eclipse.jetty.servlet.ServletContextHandler;\n+import org.eclipse.jetty.websocket.api.Session;\n+import org.eclipse.jetty.websocket.api.StatusCode;\n+import org.eclipse.jetty.websocket.api.UpgradeException;\n+import org.eclipse.jetty.websocket.api.UpgradeRequest;\n+import org.eclipse.jetty.websocket.api.UpgradeResponse;\n+import org.eclipse.jetty.websocket.api.util.WSURI;\n+import org.eclipse.jetty.websocket.client.ClientUpgradeRequest;\n+import org.eclipse.jetty.websocket.client.WebSocketClient;\n+import org.eclipse.jetty.websocket.client.io.UpgradeListener;\n+import org.eclipse.jetty.websocket.common.WebSocketSession;\n+import org.eclipse.jetty.websocket.common.WebSocketSessionListener;\n+import org.eclipse.jetty.websocket.server.NativeWebSocketConfiguration;\n+import org.eclipse.jetty.websocket.server.NativeWebSocketServletContainerInitializer;\n+import org.eclipse.jetty.websocket.server.WebSocketUpgradeFilter;\n+import org.eclipse.jetty.websocket.tests.CloseTrackingEndpoint;\n+import org.eclipse.jetty.websocket.tests.EventSocket;\n+import org.hamcrest.Matchers;\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.Test;\n+\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.instanceOf;\n+import static org.hamcrest.Matchers.is;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertNull;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+public class ConnectFutureAbortTest\n+{\n+    private Server server;\n+    private WebSocketClient client;\n+\n+    @FunctionalInterface\n+    public interface Configuration\n+    {\n+        void configure(NativeWebSocketConfiguration configuration);\n+    }\n+\n+    public void start(Configuration configuration) throws Exception\n+    {\n+        server = new Server();\n+        ServerConnector connector = new ServerConnector(server);\n+        server.addConnector(connector);\n+\n+        ServletContextHandler contextHandler = new ServletContextHandler();\n+        contextHandler.setContextPath(\"/\");\n+        server.setHandler(contextHandler);\n+\n+        NativeWebSocketServletContainerInitializer.configure(contextHandler, (context, container) ->\n+            configuration.configure(container));\n+        contextHandler.addFilter(WebSocketUpgradeFilter.class, \"/\", EnumSet.of(DispatcherType.REQUEST));\n+        server.start();\n+\n+        client = new WebSocketClient();\n+        client.start();\n+    }\n+\n+    @AfterEach\n+    public void stop() throws Exception\n+    {\n+        if (client != null)\n+            client.stop();\n+        if (server != null)\n+            server.stop();\n+    }\n+\n+    @Test\n+    public void testAbortDuringCreator() throws Exception\n+    {\n+        final CountDownLatch enteredCreator = new CountDownLatch(1);\n+        final CountDownLatch exitCreator = new CountDownLatch(1);\n+        start(c ->\n+        {\n+            c.addMapping(\"/\", (req, res) ->\n+            {\n+                try\n+                {\n+                    enteredCreator.countDown();\n+                    exitCreator.await();\n+                    return new EventSocket.EchoSocket();\n+                }\n+                catch (InterruptedException e)\n+                {\n+                    throw new IllegalStateException(e);\n+                }\n+            });\n+        });\n+\n+        CloseTrackingEndpoint clientSocket = new CloseTrackingEndpoint();\n+        Future<Session> connect = client.connect(clientSocket, WSURI.toWebsocket(server.getURI()));\n+\n+        // Cancel the future once we have entered the servers WebSocketCreator (after upgrade request is sent).\n+        assertTrue(enteredCreator.await(5, TimeUnit.SECONDS));\n+        assertTrue(connect.cancel(true));\n+        assertThrows(CancellationException.class, () -> connect.get(5, TimeUnit.SECONDS));\n+        exitCreator.countDown();\n+        assertFalse(clientSocket.openLatch.await(2, TimeUnit.SECONDS));\n+\n+        // Strange that onError() is called but onOpen() is never called. (This would not be the case in Jetty-10).\n+        assertThat(clientSocket.error.get(), instanceOf(UpgradeException.class));\n+    }\n+\n+    @Test\n+    public void testAbortSessionOnCreated() throws Exception\n+    {\n+        start(c -> c.addMapping(\"/\", EventSocket.EchoSocket.class));\n+\n+        final CountDownLatch enteredListener = new CountDownLatch(1);\n+        final CountDownLatch exitListener = new CountDownLatch(1);\n+        client.addSessionListener(new WebSocketSessionListener()\n+        {\n+            @Override\n+            public void onSessionCreated(WebSocketSession session)\n+            {\n+                try\n+                {\n+                    enteredListener.countDown();\n+                    exitListener.await();\n+                }\n+                catch (InterruptedException e)\n+                {\n+                    throw new IllegalStateException(e);\n+                }\n+            }\n+        });\n+\n+        CloseTrackingEndpoint clientSocket = new CloseTrackingEndpoint();\n+        Future<Session> connect = client.connect(clientSocket, WSURI.toWebsocket(server.getURI()));\n+\n+        // Abort when session is created, this is before future has been added to session and before the connection upgrade.\n+        assertTrue(enteredListener.await(5, TimeUnit.SECONDS));\n+        assertTrue(connect.cancel(true));\n+        assertThrows(CancellationException.class, () -> connect.get(5, TimeUnit.SECONDS));\n+        exitListener.countDown();\n+        assertFalse(clientSocket.openLatch.await(2, TimeUnit.SECONDS));\n+\n+        // Strange that onError() is called but onOpen() is never called. (This would not be the case in Jetty-10).\n+        assertThat(clientSocket.error.get(), instanceOf(CancellationException.class));\n+    }\n+\n+    @Test\n+    public void testAbortInHandshakeResponse() throws Exception\n+    {\n+        start(c -> c.addMapping(\"/\", EventSocket.EchoSocket.class));\n+\n+        final CountDownLatch enteredListener = new CountDownLatch(1);\n+        final CountDownLatch exitListener = new CountDownLatch(1);\n+        UpgradeListener upgradeListener = new AbstractUpgradeListener()\n+        {\n+            @Override\n+            public void onHandshakeResponse(UpgradeResponse response)\n+            {\n+                try\n+                {\n+                    enteredListener.countDown();\n+                    exitListener.await();\n+                }\n+                catch (InterruptedException e)\n+                {\n+                    throw new IllegalStateException(e);\n+                }\n+            }\n+        };\n+\n+        CloseTrackingEndpoint clientSocket = new CloseTrackingEndpoint();\n+        ClientUpgradeRequest upgradeRequest = new ClientUpgradeRequest();\n+        Future<Session> connect = client.connect(clientSocket, WSURI.toWebsocket(server.getURI()), upgradeRequest, upgradeListener);\n+\n+        // Abort after after handshake response, which is before connection upgrade, but after future has been set on session.\n+        assertTrue(enteredListener.await(5, TimeUnit.SECONDS));\n+        assertTrue(connect.cancel(true));\n+        assertThrows(CancellationException.class, () -> connect.get(5, TimeUnit.SECONDS));\n+        exitListener.countDown();\n+        assertFalse(clientSocket.openLatch.await(2, TimeUnit.SECONDS));\n+\n+        // Strange that onError() is called but onOpen() is never called. (This would not be the case in Jetty-10).\n+        assertThat(clientSocket.error.get(), instanceOf(CancellationException.class));\n+    }\n+\n+    @Test\n+    public void testAbortOnOpened() throws Exception\n+    {\n+        start(c -> c.addMapping(\"/\", EventSocket.EchoSocket.class));\n+\n+        final CountDownLatch exitOnOpen = new CountDownLatch(1);\n+        CloseTrackingEndpoint clientSocket = new CloseTrackingEndpoint()\n+        {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzcyMTkzNA=="}, "originalCommit": {"oid": "d7c47f42d6e69c997d5e2178eb8169d456c1c3fa"}, "originalPosition": 218}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgyOTcyOTE0OnYy", "diffSide": "RIGHT", "path": "jetty-websocket/jetty-websocket-tests/src/test/java/org/eclipse/jetty/websocket/tests/client/ConnectFutureAbortTest.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xM1QxNToxNDozM1rOGwtIbA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNFQwOToxMTowNFrOGxLI9w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzcyNDI2OA==", "bodyText": "Please add a test case for the timeout of the future, i.e. calling Future.get(1, SECONDS).\nIt should not fail the connect() since the semantic is just that of \"1 second has passed\" when it returns.\nThe test should then issue a second Future.get() that must succeed.\nAlso add a test that explicitly fails the future with a CancellationException, which should behave exactly like calling Future.cancel().", "url": "https://github.com/eclipse/jetty.project/pull/5030#discussion_r453724268", "createdAt": "2020-07-13T15:14:33Z", "author": {"login": "sbordet"}, "path": "jetty-websocket/jetty-websocket-tests/src/test/java/org/eclipse/jetty/websocket/tests/client/ConnectFutureAbortTest.java", "diffHunk": "@@ -0,0 +1,284 @@\n+//\n+//  ========================================================================\n+//  Copyright (c) 1995-2020 Mort Bay Consulting Pty Ltd and others.\n+//  ------------------------------------------------------------------------\n+//  All rights reserved. This program and the accompanying materials\n+//  are made available under the terms of the Eclipse Public License v1.0\n+//  and Apache License v2.0 which accompanies this distribution.\n+//\n+//      The Eclipse Public License is available at\n+//      http://www.eclipse.org/legal/epl-v10.html\n+//\n+//      The Apache License v2.0 is available at\n+//      http://www.opensource.org/licenses/apache2.0.php\n+//\n+//  You may elect to redistribute this code under either of these licenses.\n+//  ========================================================================\n+//\n+\n+package org.eclipse.jetty.websocket.tests.client;\n+\n+import java.util.EnumSet;\n+import java.util.concurrent.CancellationException;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+import javax.servlet.DispatcherType;\n+\n+import org.eclipse.jetty.server.Server;\n+import org.eclipse.jetty.server.ServerConnector;\n+import org.eclipse.jetty.servlet.ServletContextHandler;\n+import org.eclipse.jetty.websocket.api.Session;\n+import org.eclipse.jetty.websocket.api.StatusCode;\n+import org.eclipse.jetty.websocket.api.UpgradeException;\n+import org.eclipse.jetty.websocket.api.UpgradeRequest;\n+import org.eclipse.jetty.websocket.api.UpgradeResponse;\n+import org.eclipse.jetty.websocket.api.util.WSURI;\n+import org.eclipse.jetty.websocket.client.ClientUpgradeRequest;\n+import org.eclipse.jetty.websocket.client.WebSocketClient;\n+import org.eclipse.jetty.websocket.client.io.UpgradeListener;\n+import org.eclipse.jetty.websocket.common.WebSocketSession;\n+import org.eclipse.jetty.websocket.common.WebSocketSessionListener;\n+import org.eclipse.jetty.websocket.server.NativeWebSocketConfiguration;\n+import org.eclipse.jetty.websocket.server.NativeWebSocketServletContainerInitializer;\n+import org.eclipse.jetty.websocket.server.WebSocketUpgradeFilter;\n+import org.eclipse.jetty.websocket.tests.CloseTrackingEndpoint;\n+import org.eclipse.jetty.websocket.tests.EventSocket;\n+import org.hamcrest.Matchers;\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.Test;\n+\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.instanceOf;\n+import static org.hamcrest.Matchers.is;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertNull;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+public class ConnectFutureAbortTest\n+{\n+    private Server server;\n+    private WebSocketClient client;\n+\n+    @FunctionalInterface\n+    public interface Configuration\n+    {\n+        void configure(NativeWebSocketConfiguration configuration);\n+    }\n+\n+    public void start(Configuration configuration) throws Exception\n+    {\n+        server = new Server();\n+        ServerConnector connector = new ServerConnector(server);\n+        server.addConnector(connector);\n+\n+        ServletContextHandler contextHandler = new ServletContextHandler();\n+        contextHandler.setContextPath(\"/\");\n+        server.setHandler(contextHandler);\n+\n+        NativeWebSocketServletContainerInitializer.configure(contextHandler, (context, container) ->\n+            configuration.configure(container));\n+        contextHandler.addFilter(WebSocketUpgradeFilter.class, \"/\", EnumSet.of(DispatcherType.REQUEST));\n+        server.start();\n+\n+        client = new WebSocketClient();\n+        client.start();\n+    }\n+\n+    @AfterEach\n+    public void stop() throws Exception\n+    {\n+        if (client != null)\n+            client.stop();\n+        if (server != null)\n+            server.stop();\n+    }\n+\n+    @Test\n+    public void testAbortDuringCreator() throws Exception\n+    {\n+        final CountDownLatch enteredCreator = new CountDownLatch(1);\n+        final CountDownLatch exitCreator = new CountDownLatch(1);\n+        start(c ->\n+        {\n+            c.addMapping(\"/\", (req, res) ->\n+            {\n+                try\n+                {\n+                    enteredCreator.countDown();\n+                    exitCreator.await();\n+                    return new EventSocket.EchoSocket();\n+                }\n+                catch (InterruptedException e)\n+                {\n+                    throw new IllegalStateException(e);\n+                }\n+            });\n+        });\n+\n+        CloseTrackingEndpoint clientSocket = new CloseTrackingEndpoint();\n+        Future<Session> connect = client.connect(clientSocket, WSURI.toWebsocket(server.getURI()));\n+\n+        // Cancel the future once we have entered the servers WebSocketCreator (after upgrade request is sent).\n+        assertTrue(enteredCreator.await(5, TimeUnit.SECONDS));\n+        assertTrue(connect.cancel(true));\n+        assertThrows(CancellationException.class, () -> connect.get(5, TimeUnit.SECONDS));\n+        exitCreator.countDown();\n+        assertFalse(clientSocket.openLatch.await(2, TimeUnit.SECONDS));\n+\n+        // Strange that onError() is called but onOpen() is never called. (This would not be the case in Jetty-10).\n+        assertThat(clientSocket.error.get(), instanceOf(UpgradeException.class));\n+    }\n+\n+    @Test\n+    public void testAbortSessionOnCreated() throws Exception\n+    {\n+        start(c -> c.addMapping(\"/\", EventSocket.EchoSocket.class));\n+\n+        final CountDownLatch enteredListener = new CountDownLatch(1);\n+        final CountDownLatch exitListener = new CountDownLatch(1);\n+        client.addSessionListener(new WebSocketSessionListener()\n+        {\n+            @Override\n+            public void onSessionCreated(WebSocketSession session)\n+            {\n+                try\n+                {\n+                    enteredListener.countDown();\n+                    exitListener.await();\n+                }\n+                catch (InterruptedException e)\n+                {\n+                    throw new IllegalStateException(e);\n+                }\n+            }\n+        });\n+\n+        CloseTrackingEndpoint clientSocket = new CloseTrackingEndpoint();\n+        Future<Session> connect = client.connect(clientSocket, WSURI.toWebsocket(server.getURI()));\n+\n+        // Abort when session is created, this is before future has been added to session and before the connection upgrade.\n+        assertTrue(enteredListener.await(5, TimeUnit.SECONDS));\n+        assertTrue(connect.cancel(true));\n+        assertThrows(CancellationException.class, () -> connect.get(5, TimeUnit.SECONDS));\n+        exitListener.countDown();\n+        assertFalse(clientSocket.openLatch.await(2, TimeUnit.SECONDS));\n+\n+        // Strange that onError() is called but onOpen() is never called. (This would not be the case in Jetty-10).\n+        assertThat(clientSocket.error.get(), instanceOf(CancellationException.class));\n+    }\n+\n+    @Test\n+    public void testAbortInHandshakeResponse() throws Exception\n+    {\n+        start(c -> c.addMapping(\"/\", EventSocket.EchoSocket.class));\n+\n+        final CountDownLatch enteredListener = new CountDownLatch(1);\n+        final CountDownLatch exitListener = new CountDownLatch(1);\n+        UpgradeListener upgradeListener = new AbstractUpgradeListener()\n+        {\n+            @Override\n+            public void onHandshakeResponse(UpgradeResponse response)\n+            {\n+                try\n+                {\n+                    enteredListener.countDown();\n+                    exitListener.await();\n+                }\n+                catch (InterruptedException e)\n+                {\n+                    throw new IllegalStateException(e);\n+                }\n+            }\n+        };\n+\n+        CloseTrackingEndpoint clientSocket = new CloseTrackingEndpoint();\n+        ClientUpgradeRequest upgradeRequest = new ClientUpgradeRequest();\n+        Future<Session> connect = client.connect(clientSocket, WSURI.toWebsocket(server.getURI()), upgradeRequest, upgradeListener);\n+\n+        // Abort after after handshake response, which is before connection upgrade, but after future has been set on session.\n+        assertTrue(enteredListener.await(5, TimeUnit.SECONDS));\n+        assertTrue(connect.cancel(true));\n+        assertThrows(CancellationException.class, () -> connect.get(5, TimeUnit.SECONDS));\n+        exitListener.countDown();\n+        assertFalse(clientSocket.openLatch.await(2, TimeUnit.SECONDS));\n+\n+        // Strange that onError() is called but onOpen() is never called. (This would not be the case in Jetty-10).\n+        assertThat(clientSocket.error.get(), instanceOf(CancellationException.class));\n+    }\n+\n+    @Test\n+    public void testAbortOnOpened() throws Exception\n+    {\n+        start(c -> c.addMapping(\"/\", EventSocket.EchoSocket.class));\n+\n+        final CountDownLatch exitOnOpen = new CountDownLatch(1);\n+        CloseTrackingEndpoint clientSocket = new CloseTrackingEndpoint()\n+        {\n+            @Override\n+            public void onWebSocketConnect(Session session)\n+            {\n+                try\n+                {\n+                    super.onWebSocketConnect(session);\n+                    exitOnOpen.await();\n+                }\n+                catch (InterruptedException e)\n+                {\n+                    throw new IllegalStateException(e);\n+                }\n+            }\n+        };\n+\n+        // Abort during the call to onOpened. This is after future has been added to session,\n+        // and after connection has been upgraded, but before future completion.\n+        Future<Session> connect = client.connect(clientSocket, WSURI.toWebsocket(server.getURI()));\n+        assertTrue(clientSocket.openLatch.await(5, TimeUnit.SECONDS));\n+        assertTrue(connect.cancel(true));\n+        exitOnOpen.countDown();\n+\n+        // We got an error on the WebSocket endpoint and an error from the future.\n+        assertTrue(clientSocket.errorLatch.await(5, TimeUnit.SECONDS));\n+        assertThrows(CancellationException.class, () -> connect.get(5, TimeUnit.SECONDS));\n+    }\n+\n+    @Test\n+    public void testAbortAfterCompletion() throws Exception\n+    {\n+        start(c -> c.addMapping(\"/\", EventSocket.EchoSocket.class));\n+\n+        CloseTrackingEndpoint clientSocket = new CloseTrackingEndpoint();\n+        Future<Session> connect = client.connect(clientSocket, WSURI.toWebsocket(server.getURI()));\n+        Session session = connect.get(5, TimeUnit.SECONDS);\n+\n+        // If we can send and receive messages the future has been completed.\n+        assertTrue(clientSocket.openLatch.await(5, TimeUnit.SECONDS));\n+        clientSocket.getSession().getRemote().sendString(\"hello\");\n+        assertThat(clientSocket.messageQueue.poll(5, TimeUnit.SECONDS), Matchers.is(\"hello\"));\n+\n+        // After it has been completed we should not get any errors from cancelling it.\n+        assertFalse(connect.cancel(true));\n+        assertThat(connect.get(5, TimeUnit.SECONDS), instanceOf(Session.class));\n+        assertFalse(clientSocket.closeLatch.await(2, TimeUnit.SECONDS));\n+        assertNull(clientSocket.error.get());\n+\n+        // Close the session properly.\n+        session.close();\n+        assertTrue(clientSocket.closeLatch.await(5, TimeUnit.SECONDS));\n+        assertThat(clientSocket.closeCode, is(StatusCode.NORMAL));\n+    }\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d7c47f42d6e69c997d5e2178eb8169d456c1c3fa"}, "originalPosition": 271}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDE4MDYxNQ==", "bodyText": "I wrote the first test case.\nFor the second one there is no way to fail the future with a specific Exception. Unless we downcast to CompletableFuture<Session>.", "url": "https://github.com/eclipse/jetty.project/pull/5030#discussion_r454180615", "createdAt": "2020-07-14T08:09:59Z", "author": {"login": "lachlan-roberts"}, "path": "jetty-websocket/jetty-websocket-tests/src/test/java/org/eclipse/jetty/websocket/tests/client/ConnectFutureAbortTest.java", "diffHunk": "@@ -0,0 +1,284 @@\n+//\n+//  ========================================================================\n+//  Copyright (c) 1995-2020 Mort Bay Consulting Pty Ltd and others.\n+//  ------------------------------------------------------------------------\n+//  All rights reserved. This program and the accompanying materials\n+//  are made available under the terms of the Eclipse Public License v1.0\n+//  and Apache License v2.0 which accompanies this distribution.\n+//\n+//      The Eclipse Public License is available at\n+//      http://www.eclipse.org/legal/epl-v10.html\n+//\n+//      The Apache License v2.0 is available at\n+//      http://www.opensource.org/licenses/apache2.0.php\n+//\n+//  You may elect to redistribute this code under either of these licenses.\n+//  ========================================================================\n+//\n+\n+package org.eclipse.jetty.websocket.tests.client;\n+\n+import java.util.EnumSet;\n+import java.util.concurrent.CancellationException;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+import javax.servlet.DispatcherType;\n+\n+import org.eclipse.jetty.server.Server;\n+import org.eclipse.jetty.server.ServerConnector;\n+import org.eclipse.jetty.servlet.ServletContextHandler;\n+import org.eclipse.jetty.websocket.api.Session;\n+import org.eclipse.jetty.websocket.api.StatusCode;\n+import org.eclipse.jetty.websocket.api.UpgradeException;\n+import org.eclipse.jetty.websocket.api.UpgradeRequest;\n+import org.eclipse.jetty.websocket.api.UpgradeResponse;\n+import org.eclipse.jetty.websocket.api.util.WSURI;\n+import org.eclipse.jetty.websocket.client.ClientUpgradeRequest;\n+import org.eclipse.jetty.websocket.client.WebSocketClient;\n+import org.eclipse.jetty.websocket.client.io.UpgradeListener;\n+import org.eclipse.jetty.websocket.common.WebSocketSession;\n+import org.eclipse.jetty.websocket.common.WebSocketSessionListener;\n+import org.eclipse.jetty.websocket.server.NativeWebSocketConfiguration;\n+import org.eclipse.jetty.websocket.server.NativeWebSocketServletContainerInitializer;\n+import org.eclipse.jetty.websocket.server.WebSocketUpgradeFilter;\n+import org.eclipse.jetty.websocket.tests.CloseTrackingEndpoint;\n+import org.eclipse.jetty.websocket.tests.EventSocket;\n+import org.hamcrest.Matchers;\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.Test;\n+\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.instanceOf;\n+import static org.hamcrest.Matchers.is;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertNull;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+public class ConnectFutureAbortTest\n+{\n+    private Server server;\n+    private WebSocketClient client;\n+\n+    @FunctionalInterface\n+    public interface Configuration\n+    {\n+        void configure(NativeWebSocketConfiguration configuration);\n+    }\n+\n+    public void start(Configuration configuration) throws Exception\n+    {\n+        server = new Server();\n+        ServerConnector connector = new ServerConnector(server);\n+        server.addConnector(connector);\n+\n+        ServletContextHandler contextHandler = new ServletContextHandler();\n+        contextHandler.setContextPath(\"/\");\n+        server.setHandler(contextHandler);\n+\n+        NativeWebSocketServletContainerInitializer.configure(contextHandler, (context, container) ->\n+            configuration.configure(container));\n+        contextHandler.addFilter(WebSocketUpgradeFilter.class, \"/\", EnumSet.of(DispatcherType.REQUEST));\n+        server.start();\n+\n+        client = new WebSocketClient();\n+        client.start();\n+    }\n+\n+    @AfterEach\n+    public void stop() throws Exception\n+    {\n+        if (client != null)\n+            client.stop();\n+        if (server != null)\n+            server.stop();\n+    }\n+\n+    @Test\n+    public void testAbortDuringCreator() throws Exception\n+    {\n+        final CountDownLatch enteredCreator = new CountDownLatch(1);\n+        final CountDownLatch exitCreator = new CountDownLatch(1);\n+        start(c ->\n+        {\n+            c.addMapping(\"/\", (req, res) ->\n+            {\n+                try\n+                {\n+                    enteredCreator.countDown();\n+                    exitCreator.await();\n+                    return new EventSocket.EchoSocket();\n+                }\n+                catch (InterruptedException e)\n+                {\n+                    throw new IllegalStateException(e);\n+                }\n+            });\n+        });\n+\n+        CloseTrackingEndpoint clientSocket = new CloseTrackingEndpoint();\n+        Future<Session> connect = client.connect(clientSocket, WSURI.toWebsocket(server.getURI()));\n+\n+        // Cancel the future once we have entered the servers WebSocketCreator (after upgrade request is sent).\n+        assertTrue(enteredCreator.await(5, TimeUnit.SECONDS));\n+        assertTrue(connect.cancel(true));\n+        assertThrows(CancellationException.class, () -> connect.get(5, TimeUnit.SECONDS));\n+        exitCreator.countDown();\n+        assertFalse(clientSocket.openLatch.await(2, TimeUnit.SECONDS));\n+\n+        // Strange that onError() is called but onOpen() is never called. (This would not be the case in Jetty-10).\n+        assertThat(clientSocket.error.get(), instanceOf(UpgradeException.class));\n+    }\n+\n+    @Test\n+    public void testAbortSessionOnCreated() throws Exception\n+    {\n+        start(c -> c.addMapping(\"/\", EventSocket.EchoSocket.class));\n+\n+        final CountDownLatch enteredListener = new CountDownLatch(1);\n+        final CountDownLatch exitListener = new CountDownLatch(1);\n+        client.addSessionListener(new WebSocketSessionListener()\n+        {\n+            @Override\n+            public void onSessionCreated(WebSocketSession session)\n+            {\n+                try\n+                {\n+                    enteredListener.countDown();\n+                    exitListener.await();\n+                }\n+                catch (InterruptedException e)\n+                {\n+                    throw new IllegalStateException(e);\n+                }\n+            }\n+        });\n+\n+        CloseTrackingEndpoint clientSocket = new CloseTrackingEndpoint();\n+        Future<Session> connect = client.connect(clientSocket, WSURI.toWebsocket(server.getURI()));\n+\n+        // Abort when session is created, this is before future has been added to session and before the connection upgrade.\n+        assertTrue(enteredListener.await(5, TimeUnit.SECONDS));\n+        assertTrue(connect.cancel(true));\n+        assertThrows(CancellationException.class, () -> connect.get(5, TimeUnit.SECONDS));\n+        exitListener.countDown();\n+        assertFalse(clientSocket.openLatch.await(2, TimeUnit.SECONDS));\n+\n+        // Strange that onError() is called but onOpen() is never called. (This would not be the case in Jetty-10).\n+        assertThat(clientSocket.error.get(), instanceOf(CancellationException.class));\n+    }\n+\n+    @Test\n+    public void testAbortInHandshakeResponse() throws Exception\n+    {\n+        start(c -> c.addMapping(\"/\", EventSocket.EchoSocket.class));\n+\n+        final CountDownLatch enteredListener = new CountDownLatch(1);\n+        final CountDownLatch exitListener = new CountDownLatch(1);\n+        UpgradeListener upgradeListener = new AbstractUpgradeListener()\n+        {\n+            @Override\n+            public void onHandshakeResponse(UpgradeResponse response)\n+            {\n+                try\n+                {\n+                    enteredListener.countDown();\n+                    exitListener.await();\n+                }\n+                catch (InterruptedException e)\n+                {\n+                    throw new IllegalStateException(e);\n+                }\n+            }\n+        };\n+\n+        CloseTrackingEndpoint clientSocket = new CloseTrackingEndpoint();\n+        ClientUpgradeRequest upgradeRequest = new ClientUpgradeRequest();\n+        Future<Session> connect = client.connect(clientSocket, WSURI.toWebsocket(server.getURI()), upgradeRequest, upgradeListener);\n+\n+        // Abort after after handshake response, which is before connection upgrade, but after future has been set on session.\n+        assertTrue(enteredListener.await(5, TimeUnit.SECONDS));\n+        assertTrue(connect.cancel(true));\n+        assertThrows(CancellationException.class, () -> connect.get(5, TimeUnit.SECONDS));\n+        exitListener.countDown();\n+        assertFalse(clientSocket.openLatch.await(2, TimeUnit.SECONDS));\n+\n+        // Strange that onError() is called but onOpen() is never called. (This would not be the case in Jetty-10).\n+        assertThat(clientSocket.error.get(), instanceOf(CancellationException.class));\n+    }\n+\n+    @Test\n+    public void testAbortOnOpened() throws Exception\n+    {\n+        start(c -> c.addMapping(\"/\", EventSocket.EchoSocket.class));\n+\n+        final CountDownLatch exitOnOpen = new CountDownLatch(1);\n+        CloseTrackingEndpoint clientSocket = new CloseTrackingEndpoint()\n+        {\n+            @Override\n+            public void onWebSocketConnect(Session session)\n+            {\n+                try\n+                {\n+                    super.onWebSocketConnect(session);\n+                    exitOnOpen.await();\n+                }\n+                catch (InterruptedException e)\n+                {\n+                    throw new IllegalStateException(e);\n+                }\n+            }\n+        };\n+\n+        // Abort during the call to onOpened. This is after future has been added to session,\n+        // and after connection has been upgraded, but before future completion.\n+        Future<Session> connect = client.connect(clientSocket, WSURI.toWebsocket(server.getURI()));\n+        assertTrue(clientSocket.openLatch.await(5, TimeUnit.SECONDS));\n+        assertTrue(connect.cancel(true));\n+        exitOnOpen.countDown();\n+\n+        // We got an error on the WebSocket endpoint and an error from the future.\n+        assertTrue(clientSocket.errorLatch.await(5, TimeUnit.SECONDS));\n+        assertThrows(CancellationException.class, () -> connect.get(5, TimeUnit.SECONDS));\n+    }\n+\n+    @Test\n+    public void testAbortAfterCompletion() throws Exception\n+    {\n+        start(c -> c.addMapping(\"/\", EventSocket.EchoSocket.class));\n+\n+        CloseTrackingEndpoint clientSocket = new CloseTrackingEndpoint();\n+        Future<Session> connect = client.connect(clientSocket, WSURI.toWebsocket(server.getURI()));\n+        Session session = connect.get(5, TimeUnit.SECONDS);\n+\n+        // If we can send and receive messages the future has been completed.\n+        assertTrue(clientSocket.openLatch.await(5, TimeUnit.SECONDS));\n+        clientSocket.getSession().getRemote().sendString(\"hello\");\n+        assertThat(clientSocket.messageQueue.poll(5, TimeUnit.SECONDS), Matchers.is(\"hello\"));\n+\n+        // After it has been completed we should not get any errors from cancelling it.\n+        assertFalse(connect.cancel(true));\n+        assertThat(connect.get(5, TimeUnit.SECONDS), instanceOf(Session.class));\n+        assertFalse(clientSocket.closeLatch.await(2, TimeUnit.SECONDS));\n+        assertNull(clientSocket.error.get());\n+\n+        // Close the session properly.\n+        session.close();\n+        assertTrue(clientSocket.closeLatch.await(5, TimeUnit.SECONDS));\n+        assertThat(clientSocket.closeCode, is(StatusCode.NORMAL));\n+    }\n+", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzcyNDI2OA=="}, "originalCommit": {"oid": "d7c47f42d6e69c997d5e2178eb8169d456c1c3fa"}, "originalPosition": 271}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDIxNTkyNw==", "bodyText": "Please downcast.", "url": "https://github.com/eclipse/jetty.project/pull/5030#discussion_r454215927", "createdAt": "2020-07-14T09:11:04Z", "author": {"login": "sbordet"}, "path": "jetty-websocket/jetty-websocket-tests/src/test/java/org/eclipse/jetty/websocket/tests/client/ConnectFutureAbortTest.java", "diffHunk": "@@ -0,0 +1,284 @@\n+//\n+//  ========================================================================\n+//  Copyright (c) 1995-2020 Mort Bay Consulting Pty Ltd and others.\n+//  ------------------------------------------------------------------------\n+//  All rights reserved. This program and the accompanying materials\n+//  are made available under the terms of the Eclipse Public License v1.0\n+//  and Apache License v2.0 which accompanies this distribution.\n+//\n+//      The Eclipse Public License is available at\n+//      http://www.eclipse.org/legal/epl-v10.html\n+//\n+//      The Apache License v2.0 is available at\n+//      http://www.opensource.org/licenses/apache2.0.php\n+//\n+//  You may elect to redistribute this code under either of these licenses.\n+//  ========================================================================\n+//\n+\n+package org.eclipse.jetty.websocket.tests.client;\n+\n+import java.util.EnumSet;\n+import java.util.concurrent.CancellationException;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+import javax.servlet.DispatcherType;\n+\n+import org.eclipse.jetty.server.Server;\n+import org.eclipse.jetty.server.ServerConnector;\n+import org.eclipse.jetty.servlet.ServletContextHandler;\n+import org.eclipse.jetty.websocket.api.Session;\n+import org.eclipse.jetty.websocket.api.StatusCode;\n+import org.eclipse.jetty.websocket.api.UpgradeException;\n+import org.eclipse.jetty.websocket.api.UpgradeRequest;\n+import org.eclipse.jetty.websocket.api.UpgradeResponse;\n+import org.eclipse.jetty.websocket.api.util.WSURI;\n+import org.eclipse.jetty.websocket.client.ClientUpgradeRequest;\n+import org.eclipse.jetty.websocket.client.WebSocketClient;\n+import org.eclipse.jetty.websocket.client.io.UpgradeListener;\n+import org.eclipse.jetty.websocket.common.WebSocketSession;\n+import org.eclipse.jetty.websocket.common.WebSocketSessionListener;\n+import org.eclipse.jetty.websocket.server.NativeWebSocketConfiguration;\n+import org.eclipse.jetty.websocket.server.NativeWebSocketServletContainerInitializer;\n+import org.eclipse.jetty.websocket.server.WebSocketUpgradeFilter;\n+import org.eclipse.jetty.websocket.tests.CloseTrackingEndpoint;\n+import org.eclipse.jetty.websocket.tests.EventSocket;\n+import org.hamcrest.Matchers;\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.Test;\n+\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.instanceOf;\n+import static org.hamcrest.Matchers.is;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertNull;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+public class ConnectFutureAbortTest\n+{\n+    private Server server;\n+    private WebSocketClient client;\n+\n+    @FunctionalInterface\n+    public interface Configuration\n+    {\n+        void configure(NativeWebSocketConfiguration configuration);\n+    }\n+\n+    public void start(Configuration configuration) throws Exception\n+    {\n+        server = new Server();\n+        ServerConnector connector = new ServerConnector(server);\n+        server.addConnector(connector);\n+\n+        ServletContextHandler contextHandler = new ServletContextHandler();\n+        contextHandler.setContextPath(\"/\");\n+        server.setHandler(contextHandler);\n+\n+        NativeWebSocketServletContainerInitializer.configure(contextHandler, (context, container) ->\n+            configuration.configure(container));\n+        contextHandler.addFilter(WebSocketUpgradeFilter.class, \"/\", EnumSet.of(DispatcherType.REQUEST));\n+        server.start();\n+\n+        client = new WebSocketClient();\n+        client.start();\n+    }\n+\n+    @AfterEach\n+    public void stop() throws Exception\n+    {\n+        if (client != null)\n+            client.stop();\n+        if (server != null)\n+            server.stop();\n+    }\n+\n+    @Test\n+    public void testAbortDuringCreator() throws Exception\n+    {\n+        final CountDownLatch enteredCreator = new CountDownLatch(1);\n+        final CountDownLatch exitCreator = new CountDownLatch(1);\n+        start(c ->\n+        {\n+            c.addMapping(\"/\", (req, res) ->\n+            {\n+                try\n+                {\n+                    enteredCreator.countDown();\n+                    exitCreator.await();\n+                    return new EventSocket.EchoSocket();\n+                }\n+                catch (InterruptedException e)\n+                {\n+                    throw new IllegalStateException(e);\n+                }\n+            });\n+        });\n+\n+        CloseTrackingEndpoint clientSocket = new CloseTrackingEndpoint();\n+        Future<Session> connect = client.connect(clientSocket, WSURI.toWebsocket(server.getURI()));\n+\n+        // Cancel the future once we have entered the servers WebSocketCreator (after upgrade request is sent).\n+        assertTrue(enteredCreator.await(5, TimeUnit.SECONDS));\n+        assertTrue(connect.cancel(true));\n+        assertThrows(CancellationException.class, () -> connect.get(5, TimeUnit.SECONDS));\n+        exitCreator.countDown();\n+        assertFalse(clientSocket.openLatch.await(2, TimeUnit.SECONDS));\n+\n+        // Strange that onError() is called but onOpen() is never called. (This would not be the case in Jetty-10).\n+        assertThat(clientSocket.error.get(), instanceOf(UpgradeException.class));\n+    }\n+\n+    @Test\n+    public void testAbortSessionOnCreated() throws Exception\n+    {\n+        start(c -> c.addMapping(\"/\", EventSocket.EchoSocket.class));\n+\n+        final CountDownLatch enteredListener = new CountDownLatch(1);\n+        final CountDownLatch exitListener = new CountDownLatch(1);\n+        client.addSessionListener(new WebSocketSessionListener()\n+        {\n+            @Override\n+            public void onSessionCreated(WebSocketSession session)\n+            {\n+                try\n+                {\n+                    enteredListener.countDown();\n+                    exitListener.await();\n+                }\n+                catch (InterruptedException e)\n+                {\n+                    throw new IllegalStateException(e);\n+                }\n+            }\n+        });\n+\n+        CloseTrackingEndpoint clientSocket = new CloseTrackingEndpoint();\n+        Future<Session> connect = client.connect(clientSocket, WSURI.toWebsocket(server.getURI()));\n+\n+        // Abort when session is created, this is before future has been added to session and before the connection upgrade.\n+        assertTrue(enteredListener.await(5, TimeUnit.SECONDS));\n+        assertTrue(connect.cancel(true));\n+        assertThrows(CancellationException.class, () -> connect.get(5, TimeUnit.SECONDS));\n+        exitListener.countDown();\n+        assertFalse(clientSocket.openLatch.await(2, TimeUnit.SECONDS));\n+\n+        // Strange that onError() is called but onOpen() is never called. (This would not be the case in Jetty-10).\n+        assertThat(clientSocket.error.get(), instanceOf(CancellationException.class));\n+    }\n+\n+    @Test\n+    public void testAbortInHandshakeResponse() throws Exception\n+    {\n+        start(c -> c.addMapping(\"/\", EventSocket.EchoSocket.class));\n+\n+        final CountDownLatch enteredListener = new CountDownLatch(1);\n+        final CountDownLatch exitListener = new CountDownLatch(1);\n+        UpgradeListener upgradeListener = new AbstractUpgradeListener()\n+        {\n+            @Override\n+            public void onHandshakeResponse(UpgradeResponse response)\n+            {\n+                try\n+                {\n+                    enteredListener.countDown();\n+                    exitListener.await();\n+                }\n+                catch (InterruptedException e)\n+                {\n+                    throw new IllegalStateException(e);\n+                }\n+            }\n+        };\n+\n+        CloseTrackingEndpoint clientSocket = new CloseTrackingEndpoint();\n+        ClientUpgradeRequest upgradeRequest = new ClientUpgradeRequest();\n+        Future<Session> connect = client.connect(clientSocket, WSURI.toWebsocket(server.getURI()), upgradeRequest, upgradeListener);\n+\n+        // Abort after after handshake response, which is before connection upgrade, but after future has been set on session.\n+        assertTrue(enteredListener.await(5, TimeUnit.SECONDS));\n+        assertTrue(connect.cancel(true));\n+        assertThrows(CancellationException.class, () -> connect.get(5, TimeUnit.SECONDS));\n+        exitListener.countDown();\n+        assertFalse(clientSocket.openLatch.await(2, TimeUnit.SECONDS));\n+\n+        // Strange that onError() is called but onOpen() is never called. (This would not be the case in Jetty-10).\n+        assertThat(clientSocket.error.get(), instanceOf(CancellationException.class));\n+    }\n+\n+    @Test\n+    public void testAbortOnOpened() throws Exception\n+    {\n+        start(c -> c.addMapping(\"/\", EventSocket.EchoSocket.class));\n+\n+        final CountDownLatch exitOnOpen = new CountDownLatch(1);\n+        CloseTrackingEndpoint clientSocket = new CloseTrackingEndpoint()\n+        {\n+            @Override\n+            public void onWebSocketConnect(Session session)\n+            {\n+                try\n+                {\n+                    super.onWebSocketConnect(session);\n+                    exitOnOpen.await();\n+                }\n+                catch (InterruptedException e)\n+                {\n+                    throw new IllegalStateException(e);\n+                }\n+            }\n+        };\n+\n+        // Abort during the call to onOpened. This is after future has been added to session,\n+        // and after connection has been upgraded, but before future completion.\n+        Future<Session> connect = client.connect(clientSocket, WSURI.toWebsocket(server.getURI()));\n+        assertTrue(clientSocket.openLatch.await(5, TimeUnit.SECONDS));\n+        assertTrue(connect.cancel(true));\n+        exitOnOpen.countDown();\n+\n+        // We got an error on the WebSocket endpoint and an error from the future.\n+        assertTrue(clientSocket.errorLatch.await(5, TimeUnit.SECONDS));\n+        assertThrows(CancellationException.class, () -> connect.get(5, TimeUnit.SECONDS));\n+    }\n+\n+    @Test\n+    public void testAbortAfterCompletion() throws Exception\n+    {\n+        start(c -> c.addMapping(\"/\", EventSocket.EchoSocket.class));\n+\n+        CloseTrackingEndpoint clientSocket = new CloseTrackingEndpoint();\n+        Future<Session> connect = client.connect(clientSocket, WSURI.toWebsocket(server.getURI()));\n+        Session session = connect.get(5, TimeUnit.SECONDS);\n+\n+        // If we can send and receive messages the future has been completed.\n+        assertTrue(clientSocket.openLatch.await(5, TimeUnit.SECONDS));\n+        clientSocket.getSession().getRemote().sendString(\"hello\");\n+        assertThat(clientSocket.messageQueue.poll(5, TimeUnit.SECONDS), Matchers.is(\"hello\"));\n+\n+        // After it has been completed we should not get any errors from cancelling it.\n+        assertFalse(connect.cancel(true));\n+        assertThat(connect.get(5, TimeUnit.SECONDS), instanceOf(Session.class));\n+        assertFalse(clientSocket.closeLatch.await(2, TimeUnit.SECONDS));\n+        assertNull(clientSocket.error.get());\n+\n+        // Close the session properly.\n+        session.close();\n+        assertTrue(clientSocket.closeLatch.await(5, TimeUnit.SECONDS));\n+        assertThat(clientSocket.closeCode, is(StatusCode.NORMAL));\n+    }\n+", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzcyNDI2OA=="}, "originalCommit": {"oid": "d7c47f42d6e69c997d5e2178eb8169d456c1c3fa"}, "originalPosition": 271}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgzNzIxMTA4OnYy", "diffSide": "RIGHT", "path": "jetty-websocket/websocket-client/src/main/java/org/eclipse/jetty/websocket/client/WebSocketUpgradeRequest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNVQwODoxNjo1MFrOGxzV6A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNVQwODoxNjo1MFrOGxzV6A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDg3NDYwMA==", "bodyText": "Should not this be if (throwable != null)?", "url": "https://github.com/eclipse/jetty.project/pull/5030#discussion_r454874600", "createdAt": "2020-07-15T08:16:50Z", "author": {"login": "sbordet"}, "path": "jetty-websocket/websocket-client/src/main/java/org/eclipse/jetty/websocket/client/WebSocketUpgradeRequest.java", "diffHunk": "@@ -421,12 +422,17 @@ public WebSocketUpgradeRequest(WebSocketClient wsClient, HttpClient httpClient,\n         }\n         this.localEndpoint = this.wsClient.getEventDriverFactory().wrap(localEndpoint);\n \n-        this.fut = new CompletableFuture<Session>();\n+        this.fut = new CompletableFuture<>();\n+        this.fut.whenComplete((session, throwable) ->\n+        {\n+            if (throwable instanceof CancellationException)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "25a7da263547ab5d7231d94b57b5800318b05d62"}, "originalPosition": 16}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgzODE0MDQ3OnYy", "diffSide": "RIGHT", "path": "jetty-websocket/jetty-websocket-tests/src/test/java/org/eclipse/jetty/websocket/tests/client/ConnectFutureTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNVQxMjo0MDo1OFrOGx8OKg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNVQxMjo0MDo1OFrOGx8OKg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTAyMDA3NA==", "bodyText": "Don't need this interface, use Consumer<NativeWebSocketConfiguration>", "url": "https://github.com/eclipse/jetty.project/pull/5030#discussion_r455020074", "createdAt": "2020-07-15T12:40:58Z", "author": {"login": "sbordet"}, "path": "jetty-websocket/jetty-websocket-tests/src/test/java/org/eclipse/jetty/websocket/tests/client/ConnectFutureTest.java", "diffHunk": "@@ -0,0 +1,401 @@\n+//\n+//  ========================================================================\n+//  Copyright (c) 1995-2020 Mort Bay Consulting Pty Ltd and others.\n+//  ------------------------------------------------------------------------\n+//  All rights reserved. This program and the accompanying materials\n+//  are made available under the terms of the Eclipse Public License v1.0\n+//  and Apache License v2.0 which accompanies this distribution.\n+//\n+//      The Eclipse Public License is available at\n+//      http://www.eclipse.org/legal/epl-v10.html\n+//\n+//      The Apache License v2.0 is available at\n+//      http://www.opensource.org/licenses/apache2.0.php\n+//\n+//  You may elect to redistribute this code under either of these licenses.\n+//  ========================================================================\n+//\n+\n+package org.eclipse.jetty.websocket.tests.client;\n+\n+import java.util.EnumSet;\n+import java.util.concurrent.CancellationException;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import javax.servlet.DispatcherType;\n+\n+import org.eclipse.jetty.server.Server;\n+import org.eclipse.jetty.server.ServerConnector;\n+import org.eclipse.jetty.servlet.ServletContextHandler;\n+import org.eclipse.jetty.websocket.api.Session;\n+import org.eclipse.jetty.websocket.api.StatusCode;\n+import org.eclipse.jetty.websocket.api.UpgradeException;\n+import org.eclipse.jetty.websocket.api.UpgradeRequest;\n+import org.eclipse.jetty.websocket.api.UpgradeResponse;\n+import org.eclipse.jetty.websocket.api.WebSocketException;\n+import org.eclipse.jetty.websocket.api.util.WSURI;\n+import org.eclipse.jetty.websocket.client.ClientUpgradeRequest;\n+import org.eclipse.jetty.websocket.client.WebSocketClient;\n+import org.eclipse.jetty.websocket.client.io.UpgradeListener;\n+import org.eclipse.jetty.websocket.common.WebSocketSession;\n+import org.eclipse.jetty.websocket.common.WebSocketSessionListener;\n+import org.eclipse.jetty.websocket.server.NativeWebSocketConfiguration;\n+import org.eclipse.jetty.websocket.server.NativeWebSocketServletContainerInitializer;\n+import org.eclipse.jetty.websocket.server.WebSocketUpgradeFilter;\n+import org.eclipse.jetty.websocket.tests.CloseTrackingEndpoint;\n+import org.eclipse.jetty.websocket.tests.EchoSocket;\n+import org.hamcrest.Matchers;\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.Test;\n+\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.instanceOf;\n+import static org.hamcrest.Matchers.is;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertNull;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+public class ConnectFutureTest\n+{\n+    private Server server;\n+    private WebSocketClient client;\n+\n+    @FunctionalInterface\n+    public interface Configuration\n+    {\n+        void configure(NativeWebSocketConfiguration configuration);\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f9750c9632553f056563dbd386bd0d2a938ab145"}, "originalPosition": 72}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2414, "cost": 1, "resetAt": "2021-11-12T18:49:56Z"}}}