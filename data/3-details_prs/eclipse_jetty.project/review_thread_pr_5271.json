{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDg3MzcxMTg2", "number": 5271, "reviewThreads": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNVQxNTo0NToxMVrOEjp9ng==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNVQxNTo0NToxMVrOEjp9ng==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA1ODIzMTM0OnYy", "diffSide": "RIGHT", "path": "jetty-servlet/src/main/java/org/eclipse/jetty/servlet/ServletHandler.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNVQxNTo0NToxMVrOHSISaQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNVQxODo0Mjo1NVrOHSPJ_w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODc3MjIwMQ==", "bodyText": "The Servlet Spec requires that the first filters in the chain are the url style mappings, and then the servlet name mappings. This does it the other way around, doesn't it?", "url": "https://github.com/eclipse/jetty.project/pull/5271#discussion_r488772201", "createdAt": "2020-09-15T15:45:11Z", "author": {"login": "janbartel"}, "path": "jetty-servlet/src/main/java/org/eclipse/jetty/servlet/ServletHandler.java", "diffHunk": "@@ -591,69 +592,69 @@ public void doHandle(String target, Request baseRequest, HttpServletRequest requ\n             return _servletPathMap.getMatch(target);\n         }\n \n-        if (_servletNameMap == null)\n-            return null;\n         ServletHolder holder = _servletNameMap.get(target);\n         if (holder == null)\n             return null;\n         return new MappedResource<>(null, holder);\n     }\n \n+    private FilterChain linkFilterChain(ServletHolder servletHolder, FilterHolder filterHolder, FilterChain chain)\n+    {\n+        if (chain == null)\n+            chain = new ServletFilterChain(servletHolder);\n+        FilterChain next = newFilterChain(filterHolder.getFilter(), chain);\n+        return filterHolder.isAsyncSupported() ? next : new NotAsyncFilterChain(filterHolder, chain);\n+    }\n+\n+    /**\n+     * Create a FilterChain that calls the passed filter with the passed chain\n+     * @param filter The filter to invoke\n+     * @param chain The chain to pass to the filter\n+     * @return A FilterChain that invokes the filter with the chain\n+     */\n+    protected FilterChain newFilterChain(Filter filter, FilterChain chain)\n+    {\n+        return new Chain(filter, chain);\n+    }\n+\n     protected FilterChain getFilterChain(Request baseRequest, String pathInContext, ServletHolder servletHolder)\n     {\n         String key = pathInContext == null ? servletHolder.getName() : pathInContext;\n         int dispatch = FilterMapping.dispatch(baseRequest.getDispatcherType());\n \n-        if (_filterChainsCached && _chainCache != null)\n+        if (_filterChainsCached)\n         {\n             FilterChain chain = _chainCache[dispatch].get(key);\n             if (chain != null)\n                 return chain;\n         }\n \n-        // Build list of filters (list of FilterHolder objects)\n-        List<FilterHolder> filters = new ArrayList<>();\n-\n-        // Path filters\n-        if (pathInContext != null && _filterPathMappings != null)\n-        {\n-            for (FilterMapping filterPathMapping : _filterPathMappings)\n-            {\n-                if (filterPathMapping.appliesTo(pathInContext, dispatch))\n-                    filters.add(filterPathMapping.getFilterHolder());\n-            }\n-        }\n+        FilterChain chain = null;\n \n-        // Servlet name filters\n         if (servletHolder != null && _filterNameMappings != null && !_filterNameMappings.isEmpty())", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d21edfcddc276ef158d7e44b0adead61dc6fb53d"}, "originalPosition": 132}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODc3ODI0Ng==", "bodyText": "I would hope we fail some of our unit tests then.\nWe should have basic tests that validate these kinds of requirements from the servlet spec.\nUnless Greg has done some kind of trickery and his \"Reverse mappings\" statement is really \"mappings done in reverse\" making the change he made valid again.", "url": "https://github.com/eclipse/jetty.project/pull/5271#discussion_r488778246", "createdAt": "2020-09-15T15:53:44Z", "author": {"login": "joakime"}, "path": "jetty-servlet/src/main/java/org/eclipse/jetty/servlet/ServletHandler.java", "diffHunk": "@@ -591,69 +592,69 @@ public void doHandle(String target, Request baseRequest, HttpServletRequest requ\n             return _servletPathMap.getMatch(target);\n         }\n \n-        if (_servletNameMap == null)\n-            return null;\n         ServletHolder holder = _servletNameMap.get(target);\n         if (holder == null)\n             return null;\n         return new MappedResource<>(null, holder);\n     }\n \n+    private FilterChain linkFilterChain(ServletHolder servletHolder, FilterHolder filterHolder, FilterChain chain)\n+    {\n+        if (chain == null)\n+            chain = new ServletFilterChain(servletHolder);\n+        FilterChain next = newFilterChain(filterHolder.getFilter(), chain);\n+        return filterHolder.isAsyncSupported() ? next : new NotAsyncFilterChain(filterHolder, chain);\n+    }\n+\n+    /**\n+     * Create a FilterChain that calls the passed filter with the passed chain\n+     * @param filter The filter to invoke\n+     * @param chain The chain to pass to the filter\n+     * @return A FilterChain that invokes the filter with the chain\n+     */\n+    protected FilterChain newFilterChain(Filter filter, FilterChain chain)\n+    {\n+        return new Chain(filter, chain);\n+    }\n+\n     protected FilterChain getFilterChain(Request baseRequest, String pathInContext, ServletHolder servletHolder)\n     {\n         String key = pathInContext == null ? servletHolder.getName() : pathInContext;\n         int dispatch = FilterMapping.dispatch(baseRequest.getDispatcherType());\n \n-        if (_filterChainsCached && _chainCache != null)\n+        if (_filterChainsCached)\n         {\n             FilterChain chain = _chainCache[dispatch].get(key);\n             if (chain != null)\n                 return chain;\n         }\n \n-        // Build list of filters (list of FilterHolder objects)\n-        List<FilterHolder> filters = new ArrayList<>();\n-\n-        // Path filters\n-        if (pathInContext != null && _filterPathMappings != null)\n-        {\n-            for (FilterMapping filterPathMapping : _filterPathMappings)\n-            {\n-                if (filterPathMapping.appliesTo(pathInContext, dispatch))\n-                    filters.add(filterPathMapping.getFilterHolder());\n-            }\n-        }\n+        FilterChain chain = null;\n \n-        // Servlet name filters\n         if (servletHolder != null && _filterNameMappings != null && !_filterNameMappings.isEmpty())", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODc3MjIwMQ=="}, "originalCommit": {"oid": "d21edfcddc276ef158d7e44b0adead61dc6fb53d"}, "originalPosition": 132}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODg4NDczNQ==", "bodyText": "@janbartel The lists are in reverse so we apply the inner onion skin first. The order the filters are executed is not changed.", "url": "https://github.com/eclipse/jetty.project/pull/5271#discussion_r488884735", "createdAt": "2020-09-15T18:42:55Z", "author": {"login": "gregw"}, "path": "jetty-servlet/src/main/java/org/eclipse/jetty/servlet/ServletHandler.java", "diffHunk": "@@ -591,69 +592,69 @@ public void doHandle(String target, Request baseRequest, HttpServletRequest requ\n             return _servletPathMap.getMatch(target);\n         }\n \n-        if (_servletNameMap == null)\n-            return null;\n         ServletHolder holder = _servletNameMap.get(target);\n         if (holder == null)\n             return null;\n         return new MappedResource<>(null, holder);\n     }\n \n+    private FilterChain linkFilterChain(ServletHolder servletHolder, FilterHolder filterHolder, FilterChain chain)\n+    {\n+        if (chain == null)\n+            chain = new ServletFilterChain(servletHolder);\n+        FilterChain next = newFilterChain(filterHolder.getFilter(), chain);\n+        return filterHolder.isAsyncSupported() ? next : new NotAsyncFilterChain(filterHolder, chain);\n+    }\n+\n+    /**\n+     * Create a FilterChain that calls the passed filter with the passed chain\n+     * @param filter The filter to invoke\n+     * @param chain The chain to pass to the filter\n+     * @return A FilterChain that invokes the filter with the chain\n+     */\n+    protected FilterChain newFilterChain(Filter filter, FilterChain chain)\n+    {\n+        return new Chain(filter, chain);\n+    }\n+\n     protected FilterChain getFilterChain(Request baseRequest, String pathInContext, ServletHolder servletHolder)\n     {\n         String key = pathInContext == null ? servletHolder.getName() : pathInContext;\n         int dispatch = FilterMapping.dispatch(baseRequest.getDispatcherType());\n \n-        if (_filterChainsCached && _chainCache != null)\n+        if (_filterChainsCached)\n         {\n             FilterChain chain = _chainCache[dispatch].get(key);\n             if (chain != null)\n                 return chain;\n         }\n \n-        // Build list of filters (list of FilterHolder objects)\n-        List<FilterHolder> filters = new ArrayList<>();\n-\n-        // Path filters\n-        if (pathInContext != null && _filterPathMappings != null)\n-        {\n-            for (FilterMapping filterPathMapping : _filterPathMappings)\n-            {\n-                if (filterPathMapping.appliesTo(pathInContext, dispatch))\n-                    filters.add(filterPathMapping.getFilterHolder());\n-            }\n-        }\n+        FilterChain chain = null;\n \n-        // Servlet name filters\n         if (servletHolder != null && _filterNameMappings != null && !_filterNameMappings.isEmpty())", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODc3MjIwMQ=="}, "originalCommit": {"oid": "d21edfcddc276ef158d7e44b0adead61dc6fb53d"}, "originalPosition": 132}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2388, "cost": 1, "resetAt": "2021-11-12T18:49:56Z"}}}