{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDIwNjYyNzk3", "number": 4893, "title": "Fixes #4892 - Non-blocking JSON parser.", "bodyText": "Implemented non-blocking JSON parser.\nSigned-off-by: Simone Bordet simone.bordet@gmail.com", "createdAt": "2020-05-20T10:36:36Z", "url": "https://github.com/eclipse/jetty.project/pull/4893", "merged": true, "mergeCommit": {"oid": "a54775847e010895661a5abe71a6f67449d08294"}, "closed": true, "closedAt": "2020-05-21T16:20:52Z", "author": {"login": "sbordet"}, "timelineItems": {"totalCount": 15, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcjGm0qAH2gAyNDIwNjYyNzk3OjNlYWQ0Mjk0NzZjYzgyNTY3NjMxZTQwYWE2MjM3NmRlN2UxNzg0Mzk=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcjcx3BAFqTQxNjEwMjE3Nw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "3ead429476cc82567631e40aa62376de7e178439", "author": {"user": {"login": "sbordet", "name": "Simone Bordet"}}, "url": "https://github.com/eclipse/jetty.project/commit/3ead429476cc82567631e40aa62376de7e178439", "committedDate": "2020-05-20T10:35:16Z", "message": "Fixes #4892 - Non-blocking JSON parser.\n\nImplemented non-blocking JSON parser.\n\nSigned-off-by: Simone Bordet <simone.bordet@gmail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "caf2592587d5c2ff2e94091ce6cfb672a861beaa", "author": {"user": {"login": "sbordet", "name": "Simone Bordet"}}, "url": "https://github.com/eclipse/jetty.project/commit/caf2592587d5c2ff2e94091ce6cfb672a861beaa", "committedDate": "2020-05-20T11:00:29Z", "message": "Fixes #4892 - Non-blocking JSON parser.\n\nFixed copyright header.\n\nSigned-off-by: Simone Bordet <simone.bordet@gmail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "bed046f01ce8019b61694ef62de867bed84a7d27", "author": {"user": {"login": "sbordet", "name": "Simone Bordet"}}, "url": "https://github.com/eclipse/jetty.project/commit/bed046f01ce8019b61694ef62de867bed84a7d27", "committedDate": "2020-05-20T11:08:02Z", "message": "Fixes #4892 - Non-blocking JSON parser.\n\nFixed checkstyle.\n\nSigned-off-by: Simone Bordet <simone.bordet@gmail.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE1MjI1MjMw", "url": "https://github.com/eclipse/jetty.project/pull/4893#pullrequestreview-415225230", "createdAt": "2020-05-20T11:07:22Z", "commit": {"oid": "caf2592587d5c2ff2e94091ce6cfb672a861beaa"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMFQxMTowNzoyMlrOGYGfLQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMFQxMToyMjowMVrOGYG8RA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzkyNTI5Mw==", "bodyText": "This will NPE if no convertor was registered", "url": "https://github.com/eclipse/jetty.project/pull/4893#discussion_r427925293", "createdAt": "2020-05-20T11:07:22Z", "author": {"login": "lorban"}, "path": "jetty-util-ajax/src/main/java/org/eclipse/jetty/util/ajax/AsyncJSON.java", "diffHunk": "@@ -0,0 +1,1205 @@\n+//\n+//  ========================================================================\n+//  Copyright (c) 1995-2020 Mort Bay Consulting Pty Ltd and others.\n+//  ------------------------------------------------------------------------\n+//  All rights reserved. This program and the accompanying materials\n+//  are made available under the terms of the Eclipse Public License v1.0\n+//  and Apache License v2.0 which accompanies this distribution.\n+//\n+//      The Eclipse Public License is available at\n+//      http://www.eclipse.org/legal/epl-v10.html\n+//\n+//      The Apache License v2.0 is available at\n+//      http://www.opensource.org/licenses/apache2.0.php\n+//\n+//  You may elect to redistribute this code under either of these licenses.\n+//  ========================================================================\n+//\n+\n+package org.eclipse.jetty.util.ajax;\n+\n+import java.nio.ByteBuffer;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import org.eclipse.jetty.util.ArrayTernaryTrie;\n+import org.eclipse.jetty.util.BufferUtil;\n+import org.eclipse.jetty.util.Loader;\n+import org.eclipse.jetty.util.Trie;\n+import org.eclipse.jetty.util.TypeUtil;\n+import org.eclipse.jetty.util.Utf8StringBuilder;\n+\n+public class AsyncJSON\n+{\n+    public static class Factory\n+    {\n+        private Trie<String> cache;\n+        private Map<String, JSON.Convertor> convertors;\n+        private boolean detailedParseException;\n+\n+        public boolean isDetailedParseException()\n+        {\n+            return detailedParseException;\n+        }\n+\n+        public void setDetailedParseException(boolean detailedParseException)\n+        {\n+            this.detailedParseException = detailedParseException;\n+        }\n+\n+        public void cache(String value)\n+        {\n+            if (cache == null)\n+                cache = new ArrayTernaryTrie.Growing<>(false, 64, 64);\n+            cache.put(\"\\\"\" + value + \"\\\"\", value);\n+        }\n+\n+        public String cached(ByteBuffer buffer)\n+        {\n+            if (cache != null)\n+            {\n+                String result = cache.getBest(buffer, 0, buffer.remaining());\n+                if (result != null)\n+                {\n+                    buffer.position(buffer.position() + result.length() + 2);\n+                    return result;\n+                }\n+            }\n+            return null;\n+        }\n+\n+        public AsyncJSON newAsyncJSON()\n+        {\n+            return new AsyncJSON(this);\n+        }\n+\n+        public void putConvertor(String className, JSON.Convertor convertor)\n+        {\n+            if (convertors == null)\n+                convertors = new ConcurrentHashMap<>();\n+            convertors.put(className, convertor);\n+        }\n+\n+        public JSON.Convertor removeConvertor(String className)\n+        {\n+            if (convertors != null)\n+                return convertors.remove(className);\n+            return null;\n+        }\n+    }\n+\n+    private static final Object UNSET = new Object();\n+\n+    private final Factory factory;\n+    private final FrameStack stack = new FrameStack();\n+    private final Utf8StringBuilder stringBuilder;\n+    private final NumberBuilder numberBuilder;\n+    private List<ByteBuffer> chunks;\n+\n+    public AsyncJSON(Factory factory)\n+    {\n+        this.factory = factory;\n+        this.stringBuilder = new Utf8StringBuilder(32);\n+        this.numberBuilder = new NumberBuilder();\n+    }\n+\n+    // Used by tests only.\n+    boolean isEmpty()\n+    {\n+        return stack.isEmpty();\n+    }\n+\n+    public boolean parse(byte[] bytes)\n+    {\n+        return parse(ByteBuffer.wrap(bytes));\n+    }\n+\n+    public boolean parse(ByteBuffer buffer)\n+    {\n+        try\n+        {\n+            if (factory.isDetailedParseException())\n+            {\n+                if (chunks == null)\n+                    chunks = new ArrayList<>();\n+                ByteBuffer copy = buffer.isDirect()\n+                    ? ByteBuffer.allocateDirect(buffer.remaining())\n+                    : ByteBuffer.allocate(buffer.remaining());\n+                copy.put(buffer).flip();\n+                chunks.add(copy);\n+                buffer.flip();\n+            }\n+\n+            if (stack.isEmpty())\n+                stack.push(State.COMPLETE, UNSET);\n+\n+            while (true)\n+            {\n+                Frame frame = stack.peek();\n+                State state = frame.state;\n+                switch (state)\n+                {\n+                    case COMPLETE:\n+                    {\n+                        if (frame.value == UNSET)\n+                        {\n+                            if (parseAny(buffer))\n+                                break;\n+                            return false;\n+                        }\n+                        else\n+                        {\n+                            while (buffer.hasRemaining())\n+                            {\n+                                int position = buffer.position();\n+                                byte peek = buffer.get(position);\n+                                if (Character.isWhitespace((char)peek))\n+                                    buffer.position(position + 1);\n+                                else\n+                                    throw newInvalidJSON(buffer, \"invalid character after JSON data\");\n+                            }\n+                            return true;\n+                        }\n+                    }\n+                    case NULL:\n+                    {\n+                        if (parseNull(buffer))\n+                            break;\n+                        return false;\n+                    }\n+                    case TRUE:\n+                    {\n+                        if (parseTrue(buffer))\n+                            break;\n+                        return false;\n+                    }\n+                    case FALSE:\n+                    {\n+                        if (parseFalse(buffer))\n+                            break;\n+                        return false;\n+                    }\n+                    case NUMBER:\n+                    {\n+                        if (parseNumber(buffer))\n+                            break;\n+                        return false;\n+                    }\n+                    case STRING:\n+                    {\n+                        if (parseString(buffer))\n+                            break;\n+                        return false;\n+                    }\n+                    case ESCAPE:\n+                    {\n+                        if (parseEscape(buffer))\n+                            break;\n+                        return false;\n+                    }\n+                    case UNICODE:\n+                    {\n+                        if (parseUnicode(buffer))\n+                            break;\n+                        return false;\n+                    }\n+                    case ARRAY:\n+                    {\n+                        if (parseArray(buffer))\n+                            break;\n+                        return false;\n+                    }\n+                    case OBJECT:\n+                    {\n+                        if (parseObject(buffer))\n+                            break;\n+                        return false;\n+                    }\n+                    case OBJECT_FIELD:\n+                    {\n+                        if (parseObjectField(buffer))\n+                            break;\n+                        return false;\n+                    }\n+                    case OBJECT_FIELD_NAME:\n+                    {\n+                        if (parseObjectFieldName(buffer))\n+                            break;\n+                        return false;\n+                    }\n+                    case OBJECT_FIELD_VALUE:\n+                    {\n+                        if (parseObjectFieldValue(buffer))\n+                            break;\n+                        return false;\n+                    }\n+                    default:\n+                    {\n+                        throw new IllegalStateException(\"invalid state \" + state);\n+                    }\n+                }\n+            }\n+        }\n+        catch (Throwable x)\n+        {\n+            reset();\n+            throw x;\n+        }\n+    }\n+\n+    public <R> R eof()\n+    {\n+        try\n+        {\n+            if (stack.isEmpty())\n+                throw new IllegalStateException(\"no JSON parsed\");\n+\n+            while (true)\n+            {\n+                State state = stack.peek().state;\n+                switch (state)\n+                {\n+                    case NUMBER:\n+                    {\n+                        Number value = numberBuilder.value();\n+                        stack.pop();\n+                        stack.peek().value(value);\n+                        break;\n+                    }\n+                    case COMPLETE:\n+                    {\n+                        if (stack.peek().value == UNSET)\n+                            throw new IllegalStateException(\"invalid state \" + state);\n+                        return (R)complete();\n+                    }\n+                    default:\n+                    {\n+                        throw newInvalidJSON(BufferUtil.EMPTY_BUFFER, \"incomplete JSON\");\n+                    }\n+                }\n+            }\n+        }\n+        catch (Throwable x)\n+        {\n+            reset();\n+            throw x;\n+        }\n+    }\n+\n+    protected Map<String, Object> newObject(Context context)\n+    {\n+        return new HashMap<>();\n+    }\n+\n+    protected List<Object> newArray(Context context)\n+    {\n+        return new ArrayList<>();\n+    }\n+\n+    private Object complete()\n+    {\n+        Object result = stack.peek().value;\n+        reset();\n+        return result;\n+    }\n+\n+    private void reset()\n+    {\n+        stack.clear();\n+        chunks = null;\n+    }\n+\n+    private boolean parseAny(ByteBuffer buffer)\n+    {\n+        while (buffer.hasRemaining())\n+        {\n+            byte peek = buffer.get(buffer.position());\n+            switch (peek)\n+            {\n+                case '[':\n+                    if (parseArray(buffer))\n+                        return true;\n+                    break;\n+                case '{':\n+                    if (parseObject(buffer))\n+                        return true;\n+                    break;\n+                case '-':\n+                case '0':\n+                case '1':\n+                case '2':\n+                case '3':\n+                case '4':\n+                case '5':\n+                case '6':\n+                case '7':\n+                case '8':\n+                case '9':\n+                    if (parseNumber(buffer))\n+                        return true;\n+                    break;\n+                case '\"':\n+                    if (parseString(buffer))\n+                        return true;\n+                    break;\n+                case 'f':\n+                    if (parseFalse(buffer))\n+                        return true;\n+                    break;\n+                case 'n':\n+                    if (parseNull(buffer))\n+                        return true;\n+                    break;\n+                case 't':\n+                    if (parseTrue(buffer))\n+                        return true;\n+                    break;\n+                default:\n+                    if (Character.isWhitespace(peek))\n+                    {\n+                        buffer.get();\n+                        break;\n+                    }\n+                    throw newInvalidJSON(buffer, \"unrecognized JSON value\");\n+            }\n+        }\n+        return false;\n+    }\n+\n+    private boolean parseNull(ByteBuffer buffer)\n+    {\n+        while (buffer.hasRemaining())\n+        {\n+            byte currentByte = buffer.get();\n+            switch (currentByte)\n+            {\n+                case 'n':\n+                    if (stack.peek().state != State.NULL)\n+                    {\n+                        stack.push(State.NULL, 0);\n+                        parseNullCharacter(buffer, 0);\n+                        break;\n+                    }\n+                    throw newInvalidJSON(buffer, \"invalid 'null' literal\");\n+                case 'u':\n+                    parseNullCharacter(buffer, 1);\n+                    break;\n+                case 'l':\n+                    int index = (Integer)stack.peek().value;\n+                    if (index == 2 || index == 3)\n+                        parseNullCharacter(buffer, index);\n+                    else\n+                        throw newInvalidJSON(buffer, \"invalid 'null' literal\");\n+                    if (index == 3)\n+                    {\n+                        stack.pop();\n+                        stack.peek().value(null);\n+                        return true;\n+                    }\n+                    break;\n+                default:\n+                    throw newInvalidJSON(buffer, \"invalid 'null' literal\");\n+            }\n+        }\n+        return false;\n+    }\n+\n+    private void parseNullCharacter(ByteBuffer buffer, int index)\n+    {\n+        Frame frame = stack.peek();\n+        int value = (Integer)frame.value;\n+        if (value == index)\n+            frame.value = ++value;\n+        else\n+            throw newInvalidJSON(buffer, \"invalid 'null' literal\");\n+    }\n+\n+    private boolean parseTrue(ByteBuffer buffer)\n+    {\n+        while (buffer.hasRemaining())\n+        {\n+            byte currentByte = buffer.get();\n+            switch (currentByte)\n+            {\n+                case 't':\n+                    if (stack.peek().state != State.TRUE)\n+                    {\n+                        stack.push(State.TRUE, 0);\n+                        parseTrueCharacter(buffer, 0);\n+                        break;\n+                    }\n+                    throw newInvalidJSON(buffer, \"invalid 'true' literal\");\n+                case 'r':\n+                    parseTrueCharacter(buffer, 1);\n+                    break;\n+                case 'u':\n+                    parseTrueCharacter(buffer, 2);\n+                    break;\n+                case 'e':\n+                    parseTrueCharacter(buffer, 3);\n+                    stack.pop();\n+                    stack.peek().value(Boolean.TRUE);\n+                    return true;\n+                default:\n+                    throw newInvalidJSON(buffer, \"invalid 'true' literal\");\n+            }\n+        }\n+        return false;\n+    }\n+\n+    private void parseTrueCharacter(ByteBuffer buffer, int index)\n+    {\n+        Frame frame = stack.peek();\n+        int value = (Integer)frame.value;\n+        if (value == index)\n+            frame.value = ++value;\n+        else\n+            throw newInvalidJSON(buffer, \"invalid 'true' literal\");\n+    }\n+\n+    private boolean parseFalse(ByteBuffer buffer)\n+    {\n+        while (buffer.hasRemaining())\n+        {\n+            byte currentByte = buffer.get();\n+            switch (currentByte)\n+            {\n+                case 'f':\n+                    if (stack.peek().state != State.FALSE)\n+                    {\n+                        stack.push(State.FALSE, 0);\n+                        parseFalseCharacter(buffer, 0);\n+                        break;\n+                    }\n+                    throw newInvalidJSON(buffer, \"invalid 'false' literal\");\n+                case 'a':\n+                    parseFalseCharacter(buffer, 1);\n+                    break;\n+                case 'l':\n+                    parseFalseCharacter(buffer, 2);\n+                    break;\n+                case 's':\n+                    parseFalseCharacter(buffer, 3);\n+                    break;\n+                case 'e':\n+                    parseFalseCharacter(buffer, 4);\n+                    stack.pop();\n+                    stack.peek().value(Boolean.FALSE);\n+                    return true;\n+                default:\n+                    throw newInvalidJSON(buffer, \"invalid 'false' literal\");\n+            }\n+        }\n+        return false;\n+    }\n+\n+    private void parseFalseCharacter(ByteBuffer buffer, int index)\n+    {\n+        Frame frame = stack.peek();\n+        int value = (Integer)frame.value;\n+        if (value == index)\n+            frame.value = ++value;\n+        else\n+            throw newInvalidJSON(buffer, \"invalid 'false' literal\");\n+    }\n+\n+    private boolean parseNumber(ByteBuffer buffer)\n+    {\n+        if (stack.peek().state != State.NUMBER)\n+            stack.push(State.NUMBER, numberBuilder);\n+\n+        while (buffer.hasRemaining())\n+        {\n+            byte currentByte = buffer.get();\n+            switch (currentByte)\n+            {\n+                case '+':\n+                case '-':\n+                    if (numberBuilder.appendSign(currentByte))\n+                        break;\n+                    throw newInvalidJSON(buffer, \"invalid number\");\n+                case '.':\n+                case 'E':\n+                case 'e':\n+                    if (numberBuilder.appendAlpha(currentByte))\n+                        break;\n+                    throw newInvalidJSON(buffer, \"invalid number\");\n+                case '0':\n+                case '1':\n+                case '2':\n+                case '3':\n+                case '4':\n+                case '5':\n+                case '6':\n+                case '7':\n+                case '8':\n+                case '9':\n+                    numberBuilder.appendDigit(currentByte);\n+                    break;\n+                default:\n+                    buffer.position(buffer.position() - 1);\n+                    Number value = numberBuilder.value();\n+                    stack.pop();\n+                    stack.peek().value(value);\n+                    return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    private boolean parseString(ByteBuffer buffer)\n+    {\n+        Frame frame = stack.peek();\n+        if (buffer.hasRemaining() && frame.state != State.STRING)\n+        {\n+            String result = factory.cached(buffer);\n+            if (result != null)\n+            {\n+                frame.value(result);\n+                return true;\n+            }\n+        }\n+\n+        while (buffer.hasRemaining())\n+        {\n+            byte currentByte = buffer.get();\n+            switch (currentByte)\n+            {\n+                // Explicit delimiter, handle push and pop in this method.\n+                case '\"':\n+                {\n+                    if (stack.peek().state != State.STRING)\n+                    {\n+                        stack.push(State.STRING, stringBuilder);\n+                        break;\n+                    }\n+                    else\n+                    {\n+                        String string = stringBuilder.toString();\n+                        stringBuilder.reset();\n+                        stack.pop();\n+                        stack.peek().value(string);\n+                        return true;\n+                    }\n+                }\n+                case '\\\\':\n+                {\n+                    buffer.position(buffer.position() - 1);\n+                    if (parseEscape(buffer))\n+                        break;\n+                    return false;\n+                }\n+                default:\n+                {\n+                    stringBuilder.append(currentByte);\n+                    break;\n+                }\n+            }\n+        }\n+        return false;\n+    }\n+\n+    private boolean parseEscape(ByteBuffer buffer)\n+    {\n+        while (buffer.hasRemaining())\n+        {\n+            byte currentByte = buffer.get();\n+            switch (currentByte)\n+            {\n+                case '\\\\':\n+                    if (stack.peek().state != State.ESCAPE)\n+                    {\n+                        stack.push(State.ESCAPE, stringBuilder);\n+                        break;\n+                    }\n+                    else\n+                    {\n+                        return parseEscapeCharacter((char)currentByte);\n+                    }\n+                case '\"':\n+                case '/':\n+                    return parseEscapeCharacter((char)currentByte);\n+                case 'b':\n+                    return parseEscapeCharacter('\\b');\n+                case 'f':\n+                    return parseEscapeCharacter('\\f');\n+                case 'n':\n+                    return parseEscapeCharacter('\\n');\n+                case 'r':\n+                    return parseEscapeCharacter('\\r');\n+                case 't':\n+                    return parseEscapeCharacter('\\t');\n+                case 'u':\n+                    stack.push(State.UNICODE, ByteBuffer.allocate(4));\n+                    return parseUnicode(buffer);\n+                default:\n+                    throw newInvalidJSON(buffer, \"invalid escape sequence\");\n+            }\n+        }\n+        return false;\n+    }\n+\n+    private boolean parseEscapeCharacter(char escape)\n+    {\n+        stack.pop();\n+        stringBuilder.append(escape);\n+        return true;\n+    }\n+\n+    private boolean parseUnicode(ByteBuffer buffer)\n+    {\n+        // Expect 4 hex digits.\n+        while (buffer.hasRemaining())\n+        {\n+            byte currentByte = buffer.get();\n+            ByteBuffer hex = (ByteBuffer)stack.peek().value;\n+            hex.put(hexToByte(buffer, currentByte));\n+            if (!hex.hasRemaining())\n+            {\n+                int result = (hex.get(0) << 12) +\n+                    (hex.get(1) << 8) +\n+                    (hex.get(2) << 4) +\n+                    (hex.get(3));\n+                stack.pop();\n+                // Also done with escape parsing.\n+                stack.pop();\n+                stringBuilder.append((char)result);\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    private byte hexToByte(ByteBuffer buffer, byte currentByte)\n+    {\n+        try\n+        {\n+            return TypeUtil.convertHexDigit(currentByte);\n+        }\n+        catch (Throwable x)\n+        {\n+            throw newInvalidJSON(buffer, \"invalid hex digit\");\n+        }\n+    }\n+\n+    private boolean parseArray(ByteBuffer buffer)\n+    {\n+        while (buffer.hasRemaining())\n+        {\n+            byte peek = buffer.get(buffer.position());\n+            switch (peek)\n+            {\n+                // Explicit delimiters, handle push and pop in this method.\n+                case '[':\n+                {\n+                    buffer.get();\n+                    stack.push(State.ARRAY, newArray(stack));\n+                    break;\n+                }\n+                case ']':\n+                {\n+                    buffer.get();\n+                    Object array = stack.peek().value;\n+                    stack.pop();\n+                    stack.peek().value(array);\n+                    return true;\n+                }\n+                case ',':\n+                {\n+                    buffer.get();\n+                    break;\n+                }\n+                default:\n+                {\n+                    if (Character.isWhitespace(peek))\n+                    {\n+                        buffer.get();\n+                        break;\n+                    }\n+                    else\n+                    {\n+                        if (parseAny(buffer))\n+                        {\n+                            break;\n+                        }\n+                        return false;\n+                    }\n+                }\n+            }\n+        }\n+        return false;\n+    }\n+\n+    private boolean parseObject(ByteBuffer buffer)\n+    {\n+        while (buffer.hasRemaining())\n+        {\n+            byte currentByte = buffer.get();\n+            switch (currentByte)\n+            {\n+                // Explicit delimiters, handle push and pop in this method.\n+                case '{':\n+                {\n+                    if (stack.peek().state != State.OBJECT)\n+                    {\n+                        stack.push(State.OBJECT, newObject(stack));\n+                        break;\n+                    }\n+                    throw newInvalidJSON(buffer, \"invalid object\");\n+                }\n+                case '}':\n+                {\n+                    @SuppressWarnings(\"unchecked\")\n+                    Map<String, Object> object = (Map<String, Object>)stack.peek().value;\n+                    stack.pop();\n+                    stack.peek().value(convertObject(object));\n+                    return true;\n+                }\n+                case ',':\n+                {\n+                    break;\n+                }\n+                default:\n+                {\n+                    if (Character.isWhitespace(currentByte))\n+                    {\n+                        break;\n+                    }\n+                    else\n+                    {\n+                        buffer.position(buffer.position() - 1);\n+                        if (parseObjectField(buffer))\n+                            break;\n+                        return false;\n+                    }\n+                }\n+            }\n+        }\n+        return false;\n+    }\n+\n+    private boolean parseObjectField(ByteBuffer buffer)\n+    {\n+        while (buffer.hasRemaining())\n+        {\n+            byte peek = buffer.get(buffer.position());\n+            switch (peek)\n+            {\n+                case '\"':\n+                {\n+                    if (stack.peek().state == State.OBJECT)\n+                    {\n+                        stack.push(State.OBJECT_FIELD, UNSET);\n+                        if (parseObjectFieldName(buffer))\n+                        {\n+                            // We are not done yet, parse the value.\n+                            break;\n+                        }\n+                        return false;\n+                    }\n+                    else\n+                    {\n+                        return parseObjectFieldValue(buffer);\n+                    }\n+                }\n+                default:\n+                {\n+                    if (Character.isWhitespace(peek))\n+                    {\n+                        buffer.get();\n+                        break;\n+                    }\n+                    else if (stack.peek().state == State.OBJECT_FIELD_VALUE)\n+                    {\n+                        return parseObjectFieldValue(buffer);\n+                    }\n+                    else\n+                    {\n+                        throw newInvalidJSON(buffer, \"invalid object field\");\n+                    }\n+                }\n+            }\n+        }\n+        return false;\n+    }\n+\n+    private boolean parseObjectFieldName(ByteBuffer buffer)\n+    {\n+        while (buffer.hasRemaining())\n+        {\n+            byte peek = buffer.get(buffer.position());\n+            switch (peek)\n+            {\n+                case '\"':\n+                {\n+                    if (stack.peek().state == State.OBJECT_FIELD)\n+                    {\n+                        stack.push(State.OBJECT_FIELD_NAME, UNSET);\n+                        if (parseString(buffer))\n+                        {\n+                            // We are not done yet, parse until the ':'.\n+                            break;\n+                        }\n+                        return false;\n+                    }\n+                    else\n+                    {\n+                        throw newInvalidJSON(buffer, \"invalid object field\");\n+                    }\n+                }\n+                case ':':\n+                {\n+                    buffer.get();\n+                    // We are done with the field name.\n+                    String fieldName = (String)stack.peek().value;\n+                    stack.pop();\n+                    // Change state to parse the field value.\n+                    stack.push(fieldName, State.OBJECT_FIELD_VALUE, UNSET);\n+                    return true;\n+                }\n+                default:\n+                {\n+                    if (Character.isWhitespace(peek))\n+                    {\n+                        buffer.get();\n+                        break;\n+                    }\n+                    else\n+                    {\n+                        throw newInvalidJSON(buffer, \"invalid object field\");\n+                    }\n+                }\n+            }\n+        }\n+        return false;\n+    }\n+\n+    private boolean parseObjectFieldValue(ByteBuffer buffer)\n+    {\n+        if (stack.peek().value == UNSET)\n+        {\n+            if (!parseAny(buffer))\n+                return false;\n+        }\n+\n+        // We are done with the field value.\n+        Frame frame = stack.peek();\n+        Object value = frame.value;\n+        String name = frame.name;\n+        stack.pop();\n+        // We are done with the field.\n+        stack.pop();\n+        @SuppressWarnings(\"unchecked\")\n+        Map<String, Object> map = (Map<String, Object>)stack.peek().value;\n+        map.put(name, value);\n+\n+        return true;\n+    }\n+\n+    private Object convertObject(Map<String, Object> object)\n+    {\n+        Object result = convertObject(\"x-class\", object);\n+        if (result == null)\n+        {\n+            result = convertObject(\"class\", object);\n+            if (result == null)\n+                return object;\n+        }\n+        return result;\n+    }\n+\n+    private Object convertObject(String fieldName, Map<String, Object> object)\n+    {\n+        String className = (String)object.get(fieldName);\n+        if (className == null)\n+            return null;\n+\n+        JSON.Convertible convertible = toConvertible(className);\n+        if (convertible != null)\n+        {\n+            convertible.fromJSON(object);\n+            return convertible;\n+        }\n+\n+        JSON.Convertor convertor = factory.convertors.get(className);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "caf2592587d5c2ff2e94091ce6cfb672a861beaa"}, "originalPosition": 928}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzkyOTk3NA==", "bodyText": "This constructor is useless as it's only ever called with (null, null)", "url": "https://github.com/eclipse/jetty.project/pull/4893#discussion_r427929974", "createdAt": "2020-05-20T11:16:21Z", "author": {"login": "lorban"}, "path": "jetty-util-ajax/src/main/java/org/eclipse/jetty/util/ajax/AsyncJSON.java", "diffHunk": "@@ -0,0 +1,1205 @@\n+//\n+//  ========================================================================\n+//  Copyright (c) 1995-2020 Mort Bay Consulting Pty Ltd and others.\n+//  ------------------------------------------------------------------------\n+//  All rights reserved. This program and the accompanying materials\n+//  are made available under the terms of the Eclipse Public License v1.0\n+//  and Apache License v2.0 which accompanies this distribution.\n+//\n+//      The Eclipse Public License is available at\n+//      http://www.eclipse.org/legal/epl-v10.html\n+//\n+//      The Apache License v2.0 is available at\n+//      http://www.opensource.org/licenses/apache2.0.php\n+//\n+//  You may elect to redistribute this code under either of these licenses.\n+//  ========================================================================\n+//\n+\n+package org.eclipse.jetty.util.ajax;\n+\n+import java.nio.ByteBuffer;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import org.eclipse.jetty.util.ArrayTernaryTrie;\n+import org.eclipse.jetty.util.BufferUtil;\n+import org.eclipse.jetty.util.Loader;\n+import org.eclipse.jetty.util.Trie;\n+import org.eclipse.jetty.util.TypeUtil;\n+import org.eclipse.jetty.util.Utf8StringBuilder;\n+\n+public class AsyncJSON\n+{\n+    public static class Factory\n+    {\n+        private Trie<String> cache;\n+        private Map<String, JSON.Convertor> convertors;\n+        private boolean detailedParseException;\n+\n+        public boolean isDetailedParseException()\n+        {\n+            return detailedParseException;\n+        }\n+\n+        public void setDetailedParseException(boolean detailedParseException)\n+        {\n+            this.detailedParseException = detailedParseException;\n+        }\n+\n+        public void cache(String value)\n+        {\n+            if (cache == null)\n+                cache = new ArrayTernaryTrie.Growing<>(false, 64, 64);\n+            cache.put(\"\\\"\" + value + \"\\\"\", value);\n+        }\n+\n+        public String cached(ByteBuffer buffer)\n+        {\n+            if (cache != null)\n+            {\n+                String result = cache.getBest(buffer, 0, buffer.remaining());\n+                if (result != null)\n+                {\n+                    buffer.position(buffer.position() + result.length() + 2);\n+                    return result;\n+                }\n+            }\n+            return null;\n+        }\n+\n+        public AsyncJSON newAsyncJSON()\n+        {\n+            return new AsyncJSON(this);\n+        }\n+\n+        public void putConvertor(String className, JSON.Convertor convertor)\n+        {\n+            if (convertors == null)\n+                convertors = new ConcurrentHashMap<>();\n+            convertors.put(className, convertor);\n+        }\n+\n+        public JSON.Convertor removeConvertor(String className)\n+        {\n+            if (convertors != null)\n+                return convertors.remove(className);\n+            return null;\n+        }\n+    }\n+\n+    private static final Object UNSET = new Object();\n+\n+    private final Factory factory;\n+    private final FrameStack stack = new FrameStack();\n+    private final Utf8StringBuilder stringBuilder;\n+    private final NumberBuilder numberBuilder;\n+    private List<ByteBuffer> chunks;\n+\n+    public AsyncJSON(Factory factory)\n+    {\n+        this.factory = factory;\n+        this.stringBuilder = new Utf8StringBuilder(32);\n+        this.numberBuilder = new NumberBuilder();\n+    }\n+\n+    // Used by tests only.\n+    boolean isEmpty()\n+    {\n+        return stack.isEmpty();\n+    }\n+\n+    public boolean parse(byte[] bytes)\n+    {\n+        return parse(ByteBuffer.wrap(bytes));\n+    }\n+\n+    public boolean parse(ByteBuffer buffer)\n+    {\n+        try\n+        {\n+            if (factory.isDetailedParseException())\n+            {\n+                if (chunks == null)\n+                    chunks = new ArrayList<>();\n+                ByteBuffer copy = buffer.isDirect()\n+                    ? ByteBuffer.allocateDirect(buffer.remaining())\n+                    : ByteBuffer.allocate(buffer.remaining());\n+                copy.put(buffer).flip();\n+                chunks.add(copy);\n+                buffer.flip();\n+            }\n+\n+            if (stack.isEmpty())\n+                stack.push(State.COMPLETE, UNSET);\n+\n+            while (true)\n+            {\n+                Frame frame = stack.peek();\n+                State state = frame.state;\n+                switch (state)\n+                {\n+                    case COMPLETE:\n+                    {\n+                        if (frame.value == UNSET)\n+                        {\n+                            if (parseAny(buffer))\n+                                break;\n+                            return false;\n+                        }\n+                        else\n+                        {\n+                            while (buffer.hasRemaining())\n+                            {\n+                                int position = buffer.position();\n+                                byte peek = buffer.get(position);\n+                                if (Character.isWhitespace((char)peek))\n+                                    buffer.position(position + 1);\n+                                else\n+                                    throw newInvalidJSON(buffer, \"invalid character after JSON data\");\n+                            }\n+                            return true;\n+                        }\n+                    }\n+                    case NULL:\n+                    {\n+                        if (parseNull(buffer))\n+                            break;\n+                        return false;\n+                    }\n+                    case TRUE:\n+                    {\n+                        if (parseTrue(buffer))\n+                            break;\n+                        return false;\n+                    }\n+                    case FALSE:\n+                    {\n+                        if (parseFalse(buffer))\n+                            break;\n+                        return false;\n+                    }\n+                    case NUMBER:\n+                    {\n+                        if (parseNumber(buffer))\n+                            break;\n+                        return false;\n+                    }\n+                    case STRING:\n+                    {\n+                        if (parseString(buffer))\n+                            break;\n+                        return false;\n+                    }\n+                    case ESCAPE:\n+                    {\n+                        if (parseEscape(buffer))\n+                            break;\n+                        return false;\n+                    }\n+                    case UNICODE:\n+                    {\n+                        if (parseUnicode(buffer))\n+                            break;\n+                        return false;\n+                    }\n+                    case ARRAY:\n+                    {\n+                        if (parseArray(buffer))\n+                            break;\n+                        return false;\n+                    }\n+                    case OBJECT:\n+                    {\n+                        if (parseObject(buffer))\n+                            break;\n+                        return false;\n+                    }\n+                    case OBJECT_FIELD:\n+                    {\n+                        if (parseObjectField(buffer))\n+                            break;\n+                        return false;\n+                    }\n+                    case OBJECT_FIELD_NAME:\n+                    {\n+                        if (parseObjectFieldName(buffer))\n+                            break;\n+                        return false;\n+                    }\n+                    case OBJECT_FIELD_VALUE:\n+                    {\n+                        if (parseObjectFieldValue(buffer))\n+                            break;\n+                        return false;\n+                    }\n+                    default:\n+                    {\n+                        throw new IllegalStateException(\"invalid state \" + state);\n+                    }\n+                }\n+            }\n+        }\n+        catch (Throwable x)\n+        {\n+            reset();\n+            throw x;\n+        }\n+    }\n+\n+    public <R> R eof()\n+    {\n+        try\n+        {\n+            if (stack.isEmpty())\n+                throw new IllegalStateException(\"no JSON parsed\");\n+\n+            while (true)\n+            {\n+                State state = stack.peek().state;\n+                switch (state)\n+                {\n+                    case NUMBER:\n+                    {\n+                        Number value = numberBuilder.value();\n+                        stack.pop();\n+                        stack.peek().value(value);\n+                        break;\n+                    }\n+                    case COMPLETE:\n+                    {\n+                        if (stack.peek().value == UNSET)\n+                            throw new IllegalStateException(\"invalid state \" + state);\n+                        return (R)complete();\n+                    }\n+                    default:\n+                    {\n+                        throw newInvalidJSON(BufferUtil.EMPTY_BUFFER, \"incomplete JSON\");\n+                    }\n+                }\n+            }\n+        }\n+        catch (Throwable x)\n+        {\n+            reset();\n+            throw x;\n+        }\n+    }\n+\n+    protected Map<String, Object> newObject(Context context)\n+    {\n+        return new HashMap<>();\n+    }\n+\n+    protected List<Object> newArray(Context context)\n+    {\n+        return new ArrayList<>();\n+    }\n+\n+    private Object complete()\n+    {\n+        Object result = stack.peek().value;\n+        reset();\n+        return result;\n+    }\n+\n+    private void reset()\n+    {\n+        stack.clear();\n+        chunks = null;\n+    }\n+\n+    private boolean parseAny(ByteBuffer buffer)\n+    {\n+        while (buffer.hasRemaining())\n+        {\n+            byte peek = buffer.get(buffer.position());\n+            switch (peek)\n+            {\n+                case '[':\n+                    if (parseArray(buffer))\n+                        return true;\n+                    break;\n+                case '{':\n+                    if (parseObject(buffer))\n+                        return true;\n+                    break;\n+                case '-':\n+                case '0':\n+                case '1':\n+                case '2':\n+                case '3':\n+                case '4':\n+                case '5':\n+                case '6':\n+                case '7':\n+                case '8':\n+                case '9':\n+                    if (parseNumber(buffer))\n+                        return true;\n+                    break;\n+                case '\"':\n+                    if (parseString(buffer))\n+                        return true;\n+                    break;\n+                case 'f':\n+                    if (parseFalse(buffer))\n+                        return true;\n+                    break;\n+                case 'n':\n+                    if (parseNull(buffer))\n+                        return true;\n+                    break;\n+                case 't':\n+                    if (parseTrue(buffer))\n+                        return true;\n+                    break;\n+                default:\n+                    if (Character.isWhitespace(peek))\n+                    {\n+                        buffer.get();\n+                        break;\n+                    }\n+                    throw newInvalidJSON(buffer, \"unrecognized JSON value\");\n+            }\n+        }\n+        return false;\n+    }\n+\n+    private boolean parseNull(ByteBuffer buffer)\n+    {\n+        while (buffer.hasRemaining())\n+        {\n+            byte currentByte = buffer.get();\n+            switch (currentByte)\n+            {\n+                case 'n':\n+                    if (stack.peek().state != State.NULL)\n+                    {\n+                        stack.push(State.NULL, 0);\n+                        parseNullCharacter(buffer, 0);\n+                        break;\n+                    }\n+                    throw newInvalidJSON(buffer, \"invalid 'null' literal\");\n+                case 'u':\n+                    parseNullCharacter(buffer, 1);\n+                    break;\n+                case 'l':\n+                    int index = (Integer)stack.peek().value;\n+                    if (index == 2 || index == 3)\n+                        parseNullCharacter(buffer, index);\n+                    else\n+                        throw newInvalidJSON(buffer, \"invalid 'null' literal\");\n+                    if (index == 3)\n+                    {\n+                        stack.pop();\n+                        stack.peek().value(null);\n+                        return true;\n+                    }\n+                    break;\n+                default:\n+                    throw newInvalidJSON(buffer, \"invalid 'null' literal\");\n+            }\n+        }\n+        return false;\n+    }\n+\n+    private void parseNullCharacter(ByteBuffer buffer, int index)\n+    {\n+        Frame frame = stack.peek();\n+        int value = (Integer)frame.value;\n+        if (value == index)\n+            frame.value = ++value;\n+        else\n+            throw newInvalidJSON(buffer, \"invalid 'null' literal\");\n+    }\n+\n+    private boolean parseTrue(ByteBuffer buffer)\n+    {\n+        while (buffer.hasRemaining())\n+        {\n+            byte currentByte = buffer.get();\n+            switch (currentByte)\n+            {\n+                case 't':\n+                    if (stack.peek().state != State.TRUE)\n+                    {\n+                        stack.push(State.TRUE, 0);\n+                        parseTrueCharacter(buffer, 0);\n+                        break;\n+                    }\n+                    throw newInvalidJSON(buffer, \"invalid 'true' literal\");\n+                case 'r':\n+                    parseTrueCharacter(buffer, 1);\n+                    break;\n+                case 'u':\n+                    parseTrueCharacter(buffer, 2);\n+                    break;\n+                case 'e':\n+                    parseTrueCharacter(buffer, 3);\n+                    stack.pop();\n+                    stack.peek().value(Boolean.TRUE);\n+                    return true;\n+                default:\n+                    throw newInvalidJSON(buffer, \"invalid 'true' literal\");\n+            }\n+        }\n+        return false;\n+    }\n+\n+    private void parseTrueCharacter(ByteBuffer buffer, int index)\n+    {\n+        Frame frame = stack.peek();\n+        int value = (Integer)frame.value;\n+        if (value == index)\n+            frame.value = ++value;\n+        else\n+            throw newInvalidJSON(buffer, \"invalid 'true' literal\");\n+    }\n+\n+    private boolean parseFalse(ByteBuffer buffer)\n+    {\n+        while (buffer.hasRemaining())\n+        {\n+            byte currentByte = buffer.get();\n+            switch (currentByte)\n+            {\n+                case 'f':\n+                    if (stack.peek().state != State.FALSE)\n+                    {\n+                        stack.push(State.FALSE, 0);\n+                        parseFalseCharacter(buffer, 0);\n+                        break;\n+                    }\n+                    throw newInvalidJSON(buffer, \"invalid 'false' literal\");\n+                case 'a':\n+                    parseFalseCharacter(buffer, 1);\n+                    break;\n+                case 'l':\n+                    parseFalseCharacter(buffer, 2);\n+                    break;\n+                case 's':\n+                    parseFalseCharacter(buffer, 3);\n+                    break;\n+                case 'e':\n+                    parseFalseCharacter(buffer, 4);\n+                    stack.pop();\n+                    stack.peek().value(Boolean.FALSE);\n+                    return true;\n+                default:\n+                    throw newInvalidJSON(buffer, \"invalid 'false' literal\");\n+            }\n+        }\n+        return false;\n+    }\n+\n+    private void parseFalseCharacter(ByteBuffer buffer, int index)\n+    {\n+        Frame frame = stack.peek();\n+        int value = (Integer)frame.value;\n+        if (value == index)\n+            frame.value = ++value;\n+        else\n+            throw newInvalidJSON(buffer, \"invalid 'false' literal\");\n+    }\n+\n+    private boolean parseNumber(ByteBuffer buffer)\n+    {\n+        if (stack.peek().state != State.NUMBER)\n+            stack.push(State.NUMBER, numberBuilder);\n+\n+        while (buffer.hasRemaining())\n+        {\n+            byte currentByte = buffer.get();\n+            switch (currentByte)\n+            {\n+                case '+':\n+                case '-':\n+                    if (numberBuilder.appendSign(currentByte))\n+                        break;\n+                    throw newInvalidJSON(buffer, \"invalid number\");\n+                case '.':\n+                case 'E':\n+                case 'e':\n+                    if (numberBuilder.appendAlpha(currentByte))\n+                        break;\n+                    throw newInvalidJSON(buffer, \"invalid number\");\n+                case '0':\n+                case '1':\n+                case '2':\n+                case '3':\n+                case '4':\n+                case '5':\n+                case '6':\n+                case '7':\n+                case '8':\n+                case '9':\n+                    numberBuilder.appendDigit(currentByte);\n+                    break;\n+                default:\n+                    buffer.position(buffer.position() - 1);\n+                    Number value = numberBuilder.value();\n+                    stack.pop();\n+                    stack.peek().value(value);\n+                    return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    private boolean parseString(ByteBuffer buffer)\n+    {\n+        Frame frame = stack.peek();\n+        if (buffer.hasRemaining() && frame.state != State.STRING)\n+        {\n+            String result = factory.cached(buffer);\n+            if (result != null)\n+            {\n+                frame.value(result);\n+                return true;\n+            }\n+        }\n+\n+        while (buffer.hasRemaining())\n+        {\n+            byte currentByte = buffer.get();\n+            switch (currentByte)\n+            {\n+                // Explicit delimiter, handle push and pop in this method.\n+                case '\"':\n+                {\n+                    if (stack.peek().state != State.STRING)\n+                    {\n+                        stack.push(State.STRING, stringBuilder);\n+                        break;\n+                    }\n+                    else\n+                    {\n+                        String string = stringBuilder.toString();\n+                        stringBuilder.reset();\n+                        stack.pop();\n+                        stack.peek().value(string);\n+                        return true;\n+                    }\n+                }\n+                case '\\\\':\n+                {\n+                    buffer.position(buffer.position() - 1);\n+                    if (parseEscape(buffer))\n+                        break;\n+                    return false;\n+                }\n+                default:\n+                {\n+                    stringBuilder.append(currentByte);\n+                    break;\n+                }\n+            }\n+        }\n+        return false;\n+    }\n+\n+    private boolean parseEscape(ByteBuffer buffer)\n+    {\n+        while (buffer.hasRemaining())\n+        {\n+            byte currentByte = buffer.get();\n+            switch (currentByte)\n+            {\n+                case '\\\\':\n+                    if (stack.peek().state != State.ESCAPE)\n+                    {\n+                        stack.push(State.ESCAPE, stringBuilder);\n+                        break;\n+                    }\n+                    else\n+                    {\n+                        return parseEscapeCharacter((char)currentByte);\n+                    }\n+                case '\"':\n+                case '/':\n+                    return parseEscapeCharacter((char)currentByte);\n+                case 'b':\n+                    return parseEscapeCharacter('\\b');\n+                case 'f':\n+                    return parseEscapeCharacter('\\f');\n+                case 'n':\n+                    return parseEscapeCharacter('\\n');\n+                case 'r':\n+                    return parseEscapeCharacter('\\r');\n+                case 't':\n+                    return parseEscapeCharacter('\\t');\n+                case 'u':\n+                    stack.push(State.UNICODE, ByteBuffer.allocate(4));\n+                    return parseUnicode(buffer);\n+                default:\n+                    throw newInvalidJSON(buffer, \"invalid escape sequence\");\n+            }\n+        }\n+        return false;\n+    }\n+\n+    private boolean parseEscapeCharacter(char escape)\n+    {\n+        stack.pop();\n+        stringBuilder.append(escape);\n+        return true;\n+    }\n+\n+    private boolean parseUnicode(ByteBuffer buffer)\n+    {\n+        // Expect 4 hex digits.\n+        while (buffer.hasRemaining())\n+        {\n+            byte currentByte = buffer.get();\n+            ByteBuffer hex = (ByteBuffer)stack.peek().value;\n+            hex.put(hexToByte(buffer, currentByte));\n+            if (!hex.hasRemaining())\n+            {\n+                int result = (hex.get(0) << 12) +\n+                    (hex.get(1) << 8) +\n+                    (hex.get(2) << 4) +\n+                    (hex.get(3));\n+                stack.pop();\n+                // Also done with escape parsing.\n+                stack.pop();\n+                stringBuilder.append((char)result);\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    private byte hexToByte(ByteBuffer buffer, byte currentByte)\n+    {\n+        try\n+        {\n+            return TypeUtil.convertHexDigit(currentByte);\n+        }\n+        catch (Throwable x)\n+        {\n+            throw newInvalidJSON(buffer, \"invalid hex digit\");\n+        }\n+    }\n+\n+    private boolean parseArray(ByteBuffer buffer)\n+    {\n+        while (buffer.hasRemaining())\n+        {\n+            byte peek = buffer.get(buffer.position());\n+            switch (peek)\n+            {\n+                // Explicit delimiters, handle push and pop in this method.\n+                case '[':\n+                {\n+                    buffer.get();\n+                    stack.push(State.ARRAY, newArray(stack));\n+                    break;\n+                }\n+                case ']':\n+                {\n+                    buffer.get();\n+                    Object array = stack.peek().value;\n+                    stack.pop();\n+                    stack.peek().value(array);\n+                    return true;\n+                }\n+                case ',':\n+                {\n+                    buffer.get();\n+                    break;\n+                }\n+                default:\n+                {\n+                    if (Character.isWhitespace(peek))\n+                    {\n+                        buffer.get();\n+                        break;\n+                    }\n+                    else\n+                    {\n+                        if (parseAny(buffer))\n+                        {\n+                            break;\n+                        }\n+                        return false;\n+                    }\n+                }\n+            }\n+        }\n+        return false;\n+    }\n+\n+    private boolean parseObject(ByteBuffer buffer)\n+    {\n+        while (buffer.hasRemaining())\n+        {\n+            byte currentByte = buffer.get();\n+            switch (currentByte)\n+            {\n+                // Explicit delimiters, handle push and pop in this method.\n+                case '{':\n+                {\n+                    if (stack.peek().state != State.OBJECT)\n+                    {\n+                        stack.push(State.OBJECT, newObject(stack));\n+                        break;\n+                    }\n+                    throw newInvalidJSON(buffer, \"invalid object\");\n+                }\n+                case '}':\n+                {\n+                    @SuppressWarnings(\"unchecked\")\n+                    Map<String, Object> object = (Map<String, Object>)stack.peek().value;\n+                    stack.pop();\n+                    stack.peek().value(convertObject(object));\n+                    return true;\n+                }\n+                case ',':\n+                {\n+                    break;\n+                }\n+                default:\n+                {\n+                    if (Character.isWhitespace(currentByte))\n+                    {\n+                        break;\n+                    }\n+                    else\n+                    {\n+                        buffer.position(buffer.position() - 1);\n+                        if (parseObjectField(buffer))\n+                            break;\n+                        return false;\n+                    }\n+                }\n+            }\n+        }\n+        return false;\n+    }\n+\n+    private boolean parseObjectField(ByteBuffer buffer)\n+    {\n+        while (buffer.hasRemaining())\n+        {\n+            byte peek = buffer.get(buffer.position());\n+            switch (peek)\n+            {\n+                case '\"':\n+                {\n+                    if (stack.peek().state == State.OBJECT)\n+                    {\n+                        stack.push(State.OBJECT_FIELD, UNSET);\n+                        if (parseObjectFieldName(buffer))\n+                        {\n+                            // We are not done yet, parse the value.\n+                            break;\n+                        }\n+                        return false;\n+                    }\n+                    else\n+                    {\n+                        return parseObjectFieldValue(buffer);\n+                    }\n+                }\n+                default:\n+                {\n+                    if (Character.isWhitespace(peek))\n+                    {\n+                        buffer.get();\n+                        break;\n+                    }\n+                    else if (stack.peek().state == State.OBJECT_FIELD_VALUE)\n+                    {\n+                        return parseObjectFieldValue(buffer);\n+                    }\n+                    else\n+                    {\n+                        throw newInvalidJSON(buffer, \"invalid object field\");\n+                    }\n+                }\n+            }\n+        }\n+        return false;\n+    }\n+\n+    private boolean parseObjectFieldName(ByteBuffer buffer)\n+    {\n+        while (buffer.hasRemaining())\n+        {\n+            byte peek = buffer.get(buffer.position());\n+            switch (peek)\n+            {\n+                case '\"':\n+                {\n+                    if (stack.peek().state == State.OBJECT_FIELD)\n+                    {\n+                        stack.push(State.OBJECT_FIELD_NAME, UNSET);\n+                        if (parseString(buffer))\n+                        {\n+                            // We are not done yet, parse until the ':'.\n+                            break;\n+                        }\n+                        return false;\n+                    }\n+                    else\n+                    {\n+                        throw newInvalidJSON(buffer, \"invalid object field\");\n+                    }\n+                }\n+                case ':':\n+                {\n+                    buffer.get();\n+                    // We are done with the field name.\n+                    String fieldName = (String)stack.peek().value;\n+                    stack.pop();\n+                    // Change state to parse the field value.\n+                    stack.push(fieldName, State.OBJECT_FIELD_VALUE, UNSET);\n+                    return true;\n+                }\n+                default:\n+                {\n+                    if (Character.isWhitespace(peek))\n+                    {\n+                        buffer.get();\n+                        break;\n+                    }\n+                    else\n+                    {\n+                        throw newInvalidJSON(buffer, \"invalid object field\");\n+                    }\n+                }\n+            }\n+        }\n+        return false;\n+    }\n+\n+    private boolean parseObjectFieldValue(ByteBuffer buffer)\n+    {\n+        if (stack.peek().value == UNSET)\n+        {\n+            if (!parseAny(buffer))\n+                return false;\n+        }\n+\n+        // We are done with the field value.\n+        Frame frame = stack.peek();\n+        Object value = frame.value;\n+        String name = frame.name;\n+        stack.pop();\n+        // We are done with the field.\n+        stack.pop();\n+        @SuppressWarnings(\"unchecked\")\n+        Map<String, Object> map = (Map<String, Object>)stack.peek().value;\n+        map.put(name, value);\n+\n+        return true;\n+    }\n+\n+    private Object convertObject(Map<String, Object> object)\n+    {\n+        Object result = convertObject(\"x-class\", object);\n+        if (result == null)\n+        {\n+            result = convertObject(\"class\", object);\n+            if (result == null)\n+                return object;\n+        }\n+        return result;\n+    }\n+\n+    private Object convertObject(String fieldName, Map<String, Object> object)\n+    {\n+        String className = (String)object.get(fieldName);\n+        if (className == null)\n+            return null;\n+\n+        JSON.Convertible convertible = toConvertible(className);\n+        if (convertible != null)\n+        {\n+            convertible.fromJSON(object);\n+            return convertible;\n+        }\n+\n+        JSON.Convertor convertor = factory.convertors.get(className);\n+        if (convertor != null)\n+            return convertor.fromJSON(object);\n+\n+        return null;\n+    }\n+\n+    private JSON.Convertible toConvertible(String className)\n+    {\n+        try\n+        {\n+            Class<?> klass = Loader.loadClass(className);\n+            if (JSON.Convertible.class.isAssignableFrom(klass))\n+                return (JSON.Convertible)klass.getConstructor().newInstance();\n+            return null;\n+        }\n+        catch (Throwable x)\n+        {\n+            throw new IllegalArgumentException(x);\n+        }\n+    }\n+\n+    protected RuntimeException newInvalidJSON(ByteBuffer buffer, String message)\n+    {\n+        Utf8StringBuilder builder = new Utf8StringBuilder();\n+        builder.append(System.lineSeparator());\n+        int position = buffer.position();\n+        if (factory.isDetailedParseException())\n+        {\n+            chunks.forEach(chunk -> builder.append(buffer));\n+        }\n+        else\n+        {\n+            buffer.position(0);\n+            builder.append(buffer);\n+            buffer.position(position);\n+        }\n+        builder.append(System.lineSeparator());\n+        String indent = \"\";\n+        if (position > 1)\n+        {\n+            char[] chars = new char[position - 1];\n+            Arrays.fill(chars, ' ');\n+            indent = new String(chars);\n+        }\n+        builder.append(indent);\n+        builder.append(\"^ \");\n+        builder.append(message);\n+        return new IllegalArgumentException(builder.toString());\n+    }\n+\n+    public interface Context\n+    {\n+        public int depth();\n+    }\n+\n+    private enum State\n+    {\n+        COMPLETE, NULL, TRUE, FALSE, NUMBER, STRING, ESCAPE, UNICODE, ARRAY, OBJECT, OBJECT_FIELD, OBJECT_FIELD_NAME, OBJECT_FIELD_VALUE\n+    }\n+\n+    private static class Frame\n+    {\n+        private String name;\n+        private State state;\n+        private Object value;\n+\n+        private Frame(State state, Object value)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "caf2592587d5c2ff2e94091ce6cfb672a861beaa"}, "originalPosition": 995}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzkzMTk4NQ==", "bodyText": "Shouldn't this constructor be package-private?", "url": "https://github.com/eclipse/jetty.project/pull/4893#discussion_r427931985", "createdAt": "2020-05-20T11:20:27Z", "author": {"login": "lorban"}, "path": "jetty-util-ajax/src/main/java/org/eclipse/jetty/util/ajax/AsyncJSON.java", "diffHunk": "@@ -0,0 +1,1205 @@\n+//\n+//  ========================================================================\n+//  Copyright (c) 1995-2020 Mort Bay Consulting Pty Ltd and others.\n+//  ------------------------------------------------------------------------\n+//  All rights reserved. This program and the accompanying materials\n+//  are made available under the terms of the Eclipse Public License v1.0\n+//  and Apache License v2.0 which accompanies this distribution.\n+//\n+//      The Eclipse Public License is available at\n+//      http://www.eclipse.org/legal/epl-v10.html\n+//\n+//      The Apache License v2.0 is available at\n+//      http://www.opensource.org/licenses/apache2.0.php\n+//\n+//  You may elect to redistribute this code under either of these licenses.\n+//  ========================================================================\n+//\n+\n+package org.eclipse.jetty.util.ajax;\n+\n+import java.nio.ByteBuffer;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import org.eclipse.jetty.util.ArrayTernaryTrie;\n+import org.eclipse.jetty.util.BufferUtil;\n+import org.eclipse.jetty.util.Loader;\n+import org.eclipse.jetty.util.Trie;\n+import org.eclipse.jetty.util.TypeUtil;\n+import org.eclipse.jetty.util.Utf8StringBuilder;\n+\n+public class AsyncJSON\n+{\n+    public static class Factory\n+    {\n+        private Trie<String> cache;\n+        private Map<String, JSON.Convertor> convertors;\n+        private boolean detailedParseException;\n+\n+        public boolean isDetailedParseException()\n+        {\n+            return detailedParseException;\n+        }\n+\n+        public void setDetailedParseException(boolean detailedParseException)\n+        {\n+            this.detailedParseException = detailedParseException;\n+        }\n+\n+        public void cache(String value)\n+        {\n+            if (cache == null)\n+                cache = new ArrayTernaryTrie.Growing<>(false, 64, 64);\n+            cache.put(\"\\\"\" + value + \"\\\"\", value);\n+        }\n+\n+        public String cached(ByteBuffer buffer)\n+        {\n+            if (cache != null)\n+            {\n+                String result = cache.getBest(buffer, 0, buffer.remaining());\n+                if (result != null)\n+                {\n+                    buffer.position(buffer.position() + result.length() + 2);\n+                    return result;\n+                }\n+            }\n+            return null;\n+        }\n+\n+        public AsyncJSON newAsyncJSON()\n+        {\n+            return new AsyncJSON(this);\n+        }\n+\n+        public void putConvertor(String className, JSON.Convertor convertor)\n+        {\n+            if (convertors == null)\n+                convertors = new ConcurrentHashMap<>();\n+            convertors.put(className, convertor);\n+        }\n+\n+        public JSON.Convertor removeConvertor(String className)\n+        {\n+            if (convertors != null)\n+                return convertors.remove(className);\n+            return null;\n+        }\n+    }\n+\n+    private static final Object UNSET = new Object();\n+\n+    private final Factory factory;\n+    private final FrameStack stack = new FrameStack();\n+    private final Utf8StringBuilder stringBuilder;\n+    private final NumberBuilder numberBuilder;\n+    private List<ByteBuffer> chunks;\n+\n+    public AsyncJSON(Factory factory)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "caf2592587d5c2ff2e94091ce6cfb672a861beaa"}, "originalPosition": 103}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzkzMjc0MA==", "bodyText": "You probably want to initialize the stack in the constructor, or remove the initializations of stringBuilder and numberBuilder from the constructor.", "url": "https://github.com/eclipse/jetty.project/pull/4893#discussion_r427932740", "createdAt": "2020-05-20T11:22:01Z", "author": {"login": "lorban"}, "path": "jetty-util-ajax/src/main/java/org/eclipse/jetty/util/ajax/AsyncJSON.java", "diffHunk": "@@ -0,0 +1,1205 @@\n+//\n+//  ========================================================================\n+//  Copyright (c) 1995-2020 Mort Bay Consulting Pty Ltd and others.\n+//  ------------------------------------------------------------------------\n+//  All rights reserved. This program and the accompanying materials\n+//  are made available under the terms of the Eclipse Public License v1.0\n+//  and Apache License v2.0 which accompanies this distribution.\n+//\n+//      The Eclipse Public License is available at\n+//      http://www.eclipse.org/legal/epl-v10.html\n+//\n+//      The Apache License v2.0 is available at\n+//      http://www.opensource.org/licenses/apache2.0.php\n+//\n+//  You may elect to redistribute this code under either of these licenses.\n+//  ========================================================================\n+//\n+\n+package org.eclipse.jetty.util.ajax;\n+\n+import java.nio.ByteBuffer;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import org.eclipse.jetty.util.ArrayTernaryTrie;\n+import org.eclipse.jetty.util.BufferUtil;\n+import org.eclipse.jetty.util.Loader;\n+import org.eclipse.jetty.util.Trie;\n+import org.eclipse.jetty.util.TypeUtil;\n+import org.eclipse.jetty.util.Utf8StringBuilder;\n+\n+public class AsyncJSON\n+{\n+    public static class Factory\n+    {\n+        private Trie<String> cache;\n+        private Map<String, JSON.Convertor> convertors;\n+        private boolean detailedParseException;\n+\n+        public boolean isDetailedParseException()\n+        {\n+            return detailedParseException;\n+        }\n+\n+        public void setDetailedParseException(boolean detailedParseException)\n+        {\n+            this.detailedParseException = detailedParseException;\n+        }\n+\n+        public void cache(String value)\n+        {\n+            if (cache == null)\n+                cache = new ArrayTernaryTrie.Growing<>(false, 64, 64);\n+            cache.put(\"\\\"\" + value + \"\\\"\", value);\n+        }\n+\n+        public String cached(ByteBuffer buffer)\n+        {\n+            if (cache != null)\n+            {\n+                String result = cache.getBest(buffer, 0, buffer.remaining());\n+                if (result != null)\n+                {\n+                    buffer.position(buffer.position() + result.length() + 2);\n+                    return result;\n+                }\n+            }\n+            return null;\n+        }\n+\n+        public AsyncJSON newAsyncJSON()\n+        {\n+            return new AsyncJSON(this);\n+        }\n+\n+        public void putConvertor(String className, JSON.Convertor convertor)\n+        {\n+            if (convertors == null)\n+                convertors = new ConcurrentHashMap<>();\n+            convertors.put(className, convertor);\n+        }\n+\n+        public JSON.Convertor removeConvertor(String className)\n+        {\n+            if (convertors != null)\n+                return convertors.remove(className);\n+            return null;\n+        }\n+    }\n+\n+    private static final Object UNSET = new Object();\n+\n+    private final Factory factory;\n+    private final FrameStack stack = new FrameStack();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "caf2592587d5c2ff2e94091ce6cfb672a861beaa"}, "originalPosition": 98}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f2ef054b289167c98e51f49867eaf32ebdf6dca3", "author": {"user": {"login": "sbordet", "name": "Simone Bordet"}}, "url": "https://github.com/eclipse/jetty.project/commit/f2ef054b289167c98e51f49867eaf32ebdf6dca3", "committedDate": "2020-05-20T12:03:30Z", "message": "Fixes #4892 - Non-blocking JSON parser.\n\nAdded javadocs.\n\nSigned-off-by: Simone Bordet <simone.bordet@gmail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9ad7ff795e5ec5139981ce384303baa14171c687", "author": {"user": {"login": "sbordet", "name": "Simone Bordet"}}, "url": "https://github.com/eclipse/jetty.project/commit/9ad7ff795e5ec5139981ce384303baa14171c687", "committedDate": "2020-05-20T13:12:24Z", "message": "Fixes #4892 - Non-blocking JSON parser.\n\nUpdates after review.\n\nSigned-off-by: Simone Bordet <simone.bordet@gmail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e588a1bd9da8e4cc6131ad2fac672b8feeff750e", "author": {"user": {"login": "sbordet", "name": "Simone Bordet"}}, "url": "https://github.com/eclipse/jetty.project/commit/e588a1bd9da8e4cc6131ad2fac672b8feeff750e", "committedDate": "2020-05-20T14:14:05Z", "message": "Fixes #4892 - Non-blocking JSON parser.\n\nAdded parse(byte[], int, int).\n\nSigned-off-by: Simone Bordet <simone.bordet@gmail.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE1NDE4NzEy", "url": "https://github.com/eclipse/jetty.project/pull/4893#pullrequestreview-415418712", "createdAt": "2020-05-20T14:50:58Z", "commit": {"oid": "e588a1bd9da8e4cc6131ad2fac672b8feeff750e"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE1NzYxNDE3", "url": "https://github.com/eclipse/jetty.project/pull/4893#pullrequestreview-415761417", "createdAt": "2020-05-20T22:35:08Z", "commit": {"oid": "e588a1bd9da8e4cc6131ad2fac672b8feeff750e"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d16ce1234998e5dc29057267b843cd6d57d37fd7", "author": {"user": {"login": "sbordet", "name": "Simone Bordet"}}, "url": "https://github.com/eclipse/jetty.project/commit/d16ce1234998e5dc29057267b843cd6d57d37fd7", "committedDate": "2020-05-20T22:35:31Z", "message": "Fixes #4892 - Non-blocking JSON parser.\n\nUpdates after review.\n\nSigned-off-by: Simone Bordet <simone.bordet@gmail.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE1OTI3MzQ4", "url": "https://github.com/eclipse/jetty.project/pull/4893#pullrequestreview-415927348", "createdAt": "2020-05-21T07:12:14Z", "commit": {"oid": "d16ce1234998e5dc29057267b843cd6d57d37fd7"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMVQwNzoxMjoxNFrOGYon8A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMVQwNzoxMjoxNFrOGYon8A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODQ4NDU5Mg==", "bodyText": "The value needs to be encoded/escaped when used as the key.", "url": "https://github.com/eclipse/jetty.project/pull/4893#discussion_r428484592", "createdAt": "2020-05-21T07:12:14Z", "author": {"login": "gregw"}, "path": "jetty-util-ajax/src/main/java/org/eclipse/jetty/util/ajax/AsyncJSON.java", "diffHunk": "@@ -0,0 +1,1358 @@\n+//\n+//  ========================================================================\n+//  Copyright (c) 1995-2020 Mort Bay Consulting Pty Ltd and others.\n+//  ------------------------------------------------------------------------\n+//  All rights reserved. This program and the accompanying materials\n+//  are made available under the terms of the Eclipse Public License v1.0\n+//  and Apache License v2.0 which accompanies this distribution.\n+//\n+//      The Eclipse Public License is available at\n+//      http://www.eclipse.org/legal/epl-v10.html\n+//\n+//      The Apache License v2.0 is available at\n+//      http://www.opensource.org/licenses/apache2.0.php\n+//\n+//  You may elect to redistribute this code under either of these licenses.\n+//  ========================================================================\n+//\n+\n+package org.eclipse.jetty.util.ajax;\n+\n+import java.nio.ByteBuffer;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import org.eclipse.jetty.util.ArrayTernaryTrie;\n+import org.eclipse.jetty.util.BufferUtil;\n+import org.eclipse.jetty.util.Loader;\n+import org.eclipse.jetty.util.Trie;\n+import org.eclipse.jetty.util.TypeUtil;\n+import org.eclipse.jetty.util.Utf8StringBuilder;\n+import org.eclipse.jetty.util.ajax.JSON.Convertible;\n+import org.eclipse.jetty.util.ajax.JSON.Convertor;\n+\n+/**\n+ * <p>A non-blocking JSON parser that can parse partial JSON strings.</p>\n+ * <p>Usage:</p>\n+ * <pre>\n+ * AsyncJSON parser = new AsyncJSON.Factory().newAsyncJSON();\n+ *\n+ * // Feed the parser with partial JSON string content.\n+ * parser.parse(chunk1);\n+ * parser.parse(chunk2);\n+ *\n+ * // Tell the parser that the JSON string content\n+ * // is terminated and get the JSON object back.\n+ * Map&lt;String, Object&gt; object = parser.complete();\n+ * </pre>\n+ * <p>After the call to {@link #complete()} the parser can be reused to parse\n+ * another JSON string.</p>\n+ * <p>Custom objects can be created by specifying a {@code \"class\"} or\n+ * {@code \"x-class\"} field:</p>\n+ * <pre>\n+ * String json = \"\"\"\n+ * {\n+ *   \"x-class\": \"com.acme.Person\",\n+ *   \"firstName\": \"John\",\n+ *   \"lastName\": \"Doe\",\n+ *   \"age\": 42\n+ * }\n+ * \"\"\"\n+ *\n+ * parser.parse(json);\n+ * com.acme.Person person = parser.complete();\n+ * </pre>\n+ * <p>Class {@code com.acme.Person} must either implement {@link Convertible},\n+ * or be mapped with a {@link Convertor} via {@link Factory#putConvertor(String, Convertor)}.</p>\n+ */\n+public class AsyncJSON\n+{\n+    /**\n+     * <p>The factory that creates AsyncJSON instances.</p>\n+     * <p>The factory can be configured with custom {@link Convertor}s,\n+     * and with cached strings that will not be allocated if they can\n+     * be looked up from the cache.</p>\n+     */\n+    public static class Factory\n+    {\n+        private Trie<String> cache;\n+        private Map<String, Convertor> convertors;\n+        private boolean detailedParseException;\n+\n+        /**\n+         * @return whether a parse failure should report the whole JSON string or just the last chunk\n+         */\n+        public boolean isDetailedParseException()\n+        {\n+            return detailedParseException;\n+        }\n+\n+        /**\n+         * @param detailedParseException whether a parse failure should report the whole JSON string or just the last chunk\n+         */\n+        public void setDetailedParseException(boolean detailedParseException)\n+        {\n+            this.detailedParseException = detailedParseException;\n+        }\n+\n+        /**\n+         * @param value the string to cache\n+         */\n+        public void cache(String value)\n+        {\n+            if (cache == null)\n+                cache = new ArrayTernaryTrie.Growing<>(false, 64, 64);\n+            cache.put(\"\\\"\" + value + \"\\\"\", value);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d16ce1234998e5dc29057267b843cd6d57d37fd7"}, "originalPosition": 109}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b9466823c8b7dc9e4a01b78ee8eec900b24f201b", "author": {"user": {"login": "gregw", "name": "Greg Wilkins"}}, "url": "https://github.com/eclipse/jetty.project/commit/b9466823c8b7dc9e4a01b78ee8eec900b24f201b", "committedDate": "2020-05-21T09:44:30Z", "message": "Issue #4892 Async JSON\n\nHandle encoded cached strings (or not).\n\nSigned-off-by: Greg Wilkins <gregw@webtide.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE2MDY2MDQz", "url": "https://github.com/eclipse/jetty.project/pull/4893#pullrequestreview-416066043", "createdAt": "2020-05-21T11:17:05Z", "commit": {"oid": "d16ce1234998e5dc29057267b843cd6d57d37fd7"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMVQxMToxNzowNVrOGYvKOA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMVQxMToxNzowNVrOGYvKOA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODU5MTY3Mg==", "bodyText": "This whitespace list seems awfully narrow.", "url": "https://github.com/eclipse/jetty.project/pull/4893#discussion_r428591672", "createdAt": "2020-05-21T11:17:05Z", "author": {"login": "joakime"}, "path": "jetty-util-ajax/src/main/java/org/eclipse/jetty/util/ajax/AsyncJSON.java", "diffHunk": "@@ -1115,6 +1115,20 @@ protected RuntimeException newInvalidJSON(ByteBuffer buffer, String message)\n         return new IllegalArgumentException(builder.toString());\n     }\n \n+    private static boolean isWhitespace(byte ws)\n+    {\n+        switch (ws)\n+        {\n+            case ' ':\n+            case '\\n':\n+            case '\\r':\n+            case '\\t':\n+                return true;\n+            default:\n+                return false;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d16ce1234998e5dc29057267b843cd6d57d37fd7"}, "originalPosition": 125}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE2MDcwOTEy", "url": "https://github.com/eclipse/jetty.project/pull/4893#pullrequestreview-416070912", "createdAt": "2020-05-21T11:26:38Z", "commit": {"oid": "b9466823c8b7dc9e4a01b78ee8eec900b24f201b"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMVQxMToyNjozOFrOGYvYqA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMVQxMToyNjozOFrOGYvYqA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODU5NTM2OA==", "bodyText": "If this check is outside of the JSON document, then this version of isWhitespace is too restrictive. right?\nThe isWhitespace(byte) method is valid only for within a JSON document.", "url": "https://github.com/eclipse/jetty.project/pull/4893#discussion_r428595368", "createdAt": "2020-05-21T11:26:38Z", "author": {"login": "joakime"}, "path": "jetty-util-ajax/src/main/java/org/eclipse/jetty/util/ajax/AsyncJSON.java", "diffHunk": "@@ -0,0 +1,1389 @@\n+//\n+//  ========================================================================\n+//  Copyright (c) 1995-2020 Mort Bay Consulting Pty Ltd and others.\n+//  ------------------------------------------------------------------------\n+//  All rights reserved. This program and the accompanying materials\n+//  are made available under the terms of the Eclipse Public License v1.0\n+//  and Apache License v2.0 which accompanies this distribution.\n+//\n+//      The Eclipse Public License is available at\n+//      http://www.eclipse.org/legal/epl-v10.html\n+//\n+//      The Apache License v2.0 is available at\n+//      http://www.opensource.org/licenses/apache2.0.php\n+//\n+//  You may elect to redistribute this code under either of these licenses.\n+//  ========================================================================\n+//\n+\n+package org.eclipse.jetty.util.ajax;\n+\n+import java.nio.ByteBuffer;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import org.eclipse.jetty.util.ArrayTernaryTrie;\n+import org.eclipse.jetty.util.BufferUtil;\n+import org.eclipse.jetty.util.Loader;\n+import org.eclipse.jetty.util.Trie;\n+import org.eclipse.jetty.util.TypeUtil;\n+import org.eclipse.jetty.util.Utf8StringBuilder;\n+import org.eclipse.jetty.util.ajax.JSON.Convertible;\n+import org.eclipse.jetty.util.ajax.JSON.Convertor;\n+\n+/**\n+ * <p>A non-blocking JSON parser that can parse partial JSON strings.</p>\n+ * <p>Usage:</p>\n+ * <pre>\n+ * AsyncJSON parser = new AsyncJSON.Factory().newAsyncJSON();\n+ *\n+ * // Feed the parser with partial JSON string content.\n+ * parser.parse(chunk1);\n+ * parser.parse(chunk2);\n+ *\n+ * // Tell the parser that the JSON string content\n+ * // is terminated and get the JSON object back.\n+ * Map&lt;String, Object&gt; object = parser.complete();\n+ * </pre>\n+ * <p>After the call to {@link #complete()} the parser can be reused to parse\n+ * another JSON string.</p>\n+ * <p>Custom objects can be created by specifying a {@code \"class\"} or\n+ * {@code \"x-class\"} field:</p>\n+ * <pre>\n+ * String json = \"\"\"\n+ * {\n+ *   \"x-class\": \"com.acme.Person\",\n+ *   \"firstName\": \"John\",\n+ *   \"lastName\": \"Doe\",\n+ *   \"age\": 42\n+ * }\n+ * \"\"\"\n+ *\n+ * parser.parse(json);\n+ * com.acme.Person person = parser.complete();\n+ * </pre>\n+ * <p>Class {@code com.acme.Person} must either implement {@link Convertible},\n+ * or be mapped with a {@link Convertor} via {@link Factory#putConvertor(String, Convertor)}.</p>\n+ */\n+public class AsyncJSON\n+{\n+    /**\n+     * <p>The factory that creates AsyncJSON instances.</p>\n+     * <p>The factory can be configured with custom {@link Convertor}s,\n+     * and with cached strings that will not be allocated if they can\n+     * be looked up from the cache.</p>\n+     */\n+    public static class Factory\n+    {\n+        private Trie<CachedString> cache;\n+        private Map<String, Convertor> convertors;\n+        private boolean detailedParseException;\n+\n+        /**\n+         * @return whether a parse failure should report the whole JSON string or just the last chunk\n+         */\n+        public boolean isDetailedParseException()\n+        {\n+            return detailedParseException;\n+        }\n+\n+        /**\n+         * @param detailedParseException whether a parse failure should report the whole JSON string or just the last chunk\n+         */\n+        public void setDetailedParseException(boolean detailedParseException)\n+        {\n+            this.detailedParseException = detailedParseException;\n+        }\n+\n+        /**\n+         * @param value the string to cache\n+         * @return whether the value can be cached\n+         */\n+        public boolean cache(String value)\n+        {\n+            if (cache == null)\n+                cache = new ArrayTernaryTrie.Growing<>(false, 64, 64);\n+\n+            CachedString cached = new CachedString(value);\n+            if (cached.isCacheable())\n+            {\n+                cache.put(cached.encoded, cached);\n+                return true;\n+            }\n+            return false;\n+        }\n+\n+        /**\n+         * <p>Attempts to return a cached string from the buffer bytes.</p>\n+         * <p>In case of a cache hit, the string is returned and the buffer\n+         * position updated.</p>\n+         * <p>In case of cache miss, {@code null} is returned and the buffer\n+         * position is left unaltered.</p>\n+         *\n+         * @param buffer the buffer to lookup the string from\n+         * @return a cached string or {@code null}\n+         */\n+        protected String cached(ByteBuffer buffer)\n+        {\n+            if (cache != null)\n+            {\n+                CachedString result = cache.getBest(buffer, 0, buffer.remaining());\n+                if (result != null)\n+                {\n+                    buffer.position(buffer.position() + result.encoded.length());\n+                    return result.value;\n+                }\n+            }\n+            return null;\n+        }\n+\n+        /**\n+         * @return a new parser instance\n+         */\n+        public AsyncJSON newAsyncJSON()\n+        {\n+            return new AsyncJSON(this);\n+        }\n+\n+        /**\n+         * <p>Associates the given {@link Convertor} to the given class name.</p>\n+         *\n+         * @param className the domain class name such as {@code com.acme.Person}\n+         * @param convertor the {@link Convertor} that converts {@code Map} to domain objects\n+         */\n+        public void putConvertor(String className, Convertor convertor)\n+        {\n+            if (convertors == null)\n+                convertors = new ConcurrentHashMap<>();\n+            convertors.put(className, convertor);\n+        }\n+\n+        /**\n+         * <p>Removes the {@link Convertor} associated with the given class name.</p>\n+         *\n+         * @param className the class name associated with the {@link Convertor}\n+         * @return the {@link Convertor} associated with the class name, or {@code null}\n+         */\n+        public Convertor removeConvertor(String className)\n+        {\n+            if (convertors != null)\n+                return convertors.remove(className);\n+            return null;\n+        }\n+\n+        /**\n+         * <p>Returns the {@link Convertor} associated with the given class name, if any.</p>\n+         *\n+         * @param className the class name associated with the {@link Convertor}\n+         * @return the {@link Convertor} associated with the class name, or {@code null}\n+         */\n+        public Convertor getConvertor(String className)\n+        {\n+            return convertors == null ? null : convertors.get(className);\n+        }\n+\n+        private static class CachedString\n+        {\n+            private final String encoded;\n+            private final String value;\n+\n+            private CachedString(String value)\n+            {\n+                this.encoded = JSON.toString(value);\n+                this.value = value;\n+            }\n+\n+            private boolean isCacheable()\n+            {\n+                for (int i = encoded.length(); i-- > 0;)\n+                {\n+                    char c = encoded.charAt(i);\n+                    if (c > 127)\n+                        return false;\n+                }\n+                return true;\n+            }\n+        }\n+    }\n+\n+    private static final Object UNSET = new Object();\n+\n+    private final FrameStack stack = new FrameStack();\n+    private final NumberBuilder numberBuilder = new NumberBuilder();\n+    private final Utf8StringBuilder stringBuilder = new Utf8StringBuilder(32);\n+    private final Factory factory;\n+    private List<ByteBuffer> chunks;\n+\n+    public AsyncJSON(Factory factory)\n+    {\n+        this.factory = factory;\n+    }\n+\n+    // Used by tests only.\n+    boolean isEmpty()\n+    {\n+        return stack.isEmpty();\n+    }\n+\n+    /**\n+     * <p>Feeds the parser with the given bytes chunk.</p>\n+     *\n+     * @param bytes the bytes to parse\n+     * @return whether the JSON parsing was complete\n+     * @throws IllegalArgumentException if the JSON is malformed\n+     */\n+    public boolean parse(byte[] bytes)\n+    {\n+        return parse(bytes, 0, bytes.length);\n+    }\n+\n+    /**\n+     * <p>Feeds the parser with the given bytes chunk.</p>\n+     *\n+     * @param bytes the bytes to parse\n+     * @param offset the offset to start parsing from\n+     * @param length the number of bytes to parse\n+     * @return whether the JSON parsing was complete\n+     * @throws IllegalArgumentException if the JSON is malformed\n+     */\n+    public boolean parse(byte[] bytes, int offset, int length)\n+    {\n+        return parse(ByteBuffer.wrap(bytes, offset, length));\n+    }\n+\n+    /**\n+     * <p>Feeds the parser with the given buffer chunk.</p>\n+     *\n+     * @param buffer the buffer to parse\n+     * @return whether the JSON parsing was complete\n+     * @throws IllegalArgumentException if the JSON is malformed\n+     */\n+    public boolean parse(ByteBuffer buffer)\n+    {\n+        try\n+        {\n+            if (factory.isDetailedParseException())\n+            {\n+                if (chunks == null)\n+                    chunks = new ArrayList<>();\n+                ByteBuffer copy = buffer.isDirect()\n+                    ? ByteBuffer.allocateDirect(buffer.remaining())\n+                    : ByteBuffer.allocate(buffer.remaining());\n+                copy.put(buffer).flip();\n+                chunks.add(copy);\n+                buffer.flip();\n+            }\n+\n+            if (stack.isEmpty())\n+                stack.push(State.COMPLETE, UNSET);\n+\n+            while (true)\n+            {\n+                Frame frame = stack.peek();\n+                State state = frame.state;\n+                switch (state)\n+                {\n+                    case COMPLETE:\n+                    {\n+                        if (frame.value == UNSET)\n+                        {\n+                            if (parseAny(buffer))\n+                                break;\n+                            return false;\n+                        }\n+                        else\n+                        {\n+                            while (buffer.hasRemaining())\n+                            {\n+                                int position = buffer.position();\n+                                byte peek = buffer.get(position);\n+                                if (isWhitespace(peek))", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b9466823c8b7dc9e4a01b78ee8eec900b24f201b"}, "originalPosition": 304}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE2MTAyMTc3", "url": "https://github.com/eclipse/jetty.project/pull/4893#pullrequestreview-416102177", "createdAt": "2020-05-21T12:25:14Z", "commit": {"oid": "b9466823c8b7dc9e4a01b78ee8eec900b24f201b"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 403, "cost": 1, "resetAt": "2021-11-01T13:51:04Z"}}}