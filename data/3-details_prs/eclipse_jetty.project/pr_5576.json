{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTE1OTEzNDQy", "number": 5576, "title": "Fix #5575 SEARCH method", "bodyText": "Fix #5575 SEARCH and PATCH methods", "createdAt": "2020-11-05T09:14:55Z", "url": "https://github.com/eclipse/jetty.project/pull/5576", "merged": true, "mergeCommit": {"oid": "bb886ad9320c170b9b12a111e00f6671978c8cee"}, "closed": true, "closedAt": "2020-11-11T16:48:08Z", "author": {"login": "gregw"}, "timelineItems": {"totalCount": 17, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdZevVqAH2gAyNTE1OTEzNDQyOjE3Y2VlMmFjNjQ2OTA0OWIyODIwZWMzNGI1MWJhZGI3YWExYzZkYjM=", "endCursor": "Y3Vyc29yOnYyOpPPAAABdbgPVTAFqTUyODMxMjMyNA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "17cee2ac6469049b2820ec34b51badb7aa1c6db3", "author": {"user": {"login": "gregw", "name": "Greg Wilkins"}}, "url": "https://github.com/eclipse/jetty.project/commit/17cee2ac6469049b2820ec34b51badb7aa1c6db3", "committedDate": "2020-11-05T09:14:12Z", "message": "Fix #5575 SEARCH method\n\nFix #5575 SEARCH and PATCH methods"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b8f03e2a8d5d80f4c253ca5234ab2c15608d5cb4", "author": {"user": {"login": "gregw", "name": "Greg Wilkins"}}, "url": "https://github.com/eclipse/jetty.project/commit/b8f03e2a8d5d80f4c253ca5234ab2c15608d5cb4", "committedDate": "2020-11-05T10:33:23Z", "message": "Added REPORT method\nBetter test"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d10b15ccc61afafb3abdcccaf54a8b9f8661edb2", "author": {"user": {"login": "gregw", "name": "Greg Wilkins"}}, "url": "https://github.com/eclipse/jetty.project/commit/d10b15ccc61afafb3abdcccaf54a8b9f8661edb2", "committedDate": "2020-11-05T17:25:34Z", "message": " + Added all IANA methods\n + Used Trie for most lookups\n + Fixed ArrayTernayTrie lookup"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTI0NTMwMTcz", "url": "https://github.com/eclipse/jetty.project/pull/5576#pullrequestreview-524530173", "createdAt": "2020-11-05T18:03:53Z", "commit": {"oid": "d10b15ccc61afafb3abdcccaf54a8b9f8661edb2"}, "state": "COMMENTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNVQxODowMzo1M1rOHuP5OQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNVQxODowNDoxNlrOHuP6PA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODI1Njk1Mw==", "bodyText": "Do we want to document what this means?", "url": "https://github.com/eclipse/jetty.project/pull/5576#discussion_r518256953", "createdAt": "2020-11-05T18:03:53Z", "author": {"login": "joakime"}, "path": "jetty-http/src/main/java/org/eclipse/jetty/http/HttpMethod.java", "diffHunk": "@@ -26,189 +26,161 @@\n import org.eclipse.jetty.util.Trie;\n \n /**\n- *\n+ * Known HTTP Methods\n  */\n public enum HttpMethod\n {\n-    GET,\n-    POST,\n-    HEAD,\n-    PUT,\n-    OPTIONS,\n-    DELETE,\n-    TRACE,\n-    CONNECT,\n-    MOVE,\n-    PROXY,\n-    PRI,\n-    PATCH,\n-    SEARCH,\n-    REPORT;\n+    // From https://www.iana.org/assignments/http-methods/http-methods.xhtml\n+    ACL(false, true),\n+    BASELINE_CONTROL(false, true),\n+    BIND(false, true),\n+    CHECKIN(false, true),\n+    CHECKOUT(false, true),\n+    CONNECT(false, false),\n+    COPY(false, true),\n+    DELETE(false, true),\n+    GET(true, true),\n+    HEAD(true, true),\n+    LABEL(false, true),\n+    LINK(false, true),\n+    LOCK(false, false),\n+    MERGE(false, true),\n+    MKACTIVITY(false, true),\n+    MKCALENDAR(false, true),\n+    MKCOL(false, true),\n+    MKREDIRECTREF(false, true),\n+    MKWORKSPACE(false, true),\n+    MOVE(false, true),\n+    OPTIONS(true, true),\n+    ORDERPATCH(false, true),\n+    PATCH(false, false),\n+    POST(false, false),\n+    PRI(true, true),\n+    PROPFIND(true, true),\n+    PROPPATCH(false, true),\n+    PUT(false, true),\n+    REBIND(false, true),\n+    REPORT(true, true),\n+    SEARCH(true, true),\n+    TRACE(true, true),\n+    UNBIND(false, true),\n+    UNCHECKOUT(false, true),\n+    UNLINK(false, true),\n+    UNLOCK(false, true),\n+    UPDATE(false, true),\n+    UPDATEREDIRECTREF(false, true),\n+    VERSION_CONTROL(false, true),\n+\n+    // Other methods\n+    PROXY(false, false);\n+\n+    private final String _method;\n+    private final byte[] _bytes;\n+    private final ByteBuffer _buffer;\n+    private final boolean _safe;\n+    private final boolean _idempotent;\n \n-    /**\n-     * Optimized lookup to find a method name and trailing space in a byte array.\n-     *\n-     * @param bytes Array containing ISO-8859-1 characters\n-     * @param position The first valid index\n-     * @param limit The first non valid index\n-     * @return An HttpMethod if a match or null if no easy match.\n-     */\n-    public static HttpMethod lookAheadGet(byte[] bytes, final int position, int limit)\n+    HttpMethod(boolean safe, boolean idempotent)\n     {\n-        int length = limit - position;\n-        if (length < 4)\n-            return null;\n-        switch (bytes[position])\n-        {\n-            case 'G':\n-                if (bytes[position + 1] == 'E' && bytes[position + 2] == 'T' && bytes[position + 3] == ' ')\n-                    return GET;\n-                break;\n-            case 'P':\n-                switch (bytes[position + 1])\n-                {\n-                    case 'O':\n-                        if (bytes[position + 2] == 'S' && bytes[position + 3] == 'T' && length >= 5 && bytes[position + 4] == ' ')\n-                            return POST;\n-                        return null;\n-                    case 'R':\n-                        if (bytes[position + 2] == 'I' && bytes[position + 3] == ' ')\n-                            return PRI;\n-                        if (bytes[position + 2] == 'O' && bytes[position + 3] == 'X' && length >= 6 && bytes[position + 4] == 'Y' && bytes[position + 5] == ' ')\n-                            return PROXY;\n-                        return null;\n-                    case 'U':\n-                        if (bytes[position + 2] == 'T' && bytes[position + 3] == ' ')\n-                            return PUT;\n-                        return null;\n-                    case 'A':\n-                        if (bytes[position + 2] == 'T' && bytes[position + 3] == 'C' && length >= 6 && bytes[position + 4] == 'H' && bytes[position + 5] == ' ')\n-                            return PATCH;\n-                        return null;\n-                    default:\n-                        return null;\n-                }\n-\n-            case 'H':\n-                if (bytes[position + 1] == 'E' && bytes[position + 2] == 'A' && bytes[position + 3] == 'D' && length >= 5 && bytes[position + 4] == ' ')\n-                    return HEAD;\n-                break;\n-            case 'O':\n-                if (bytes[position + 1] == 'P' && bytes[position + 2] == 'T' && bytes[position + 3] == 'I' && length >= 8 &&\n-                    bytes[position + 4] == 'O' && bytes[position + 5] == 'N' && bytes[position + 6] == 'S' && bytes[position + 7] == ' ')\n-                    return OPTIONS;\n-                break;\n-            case 'D':\n-                if (bytes[position + 1] == 'E' && bytes[position + 2] == 'L' && bytes[position + 3] == 'E' && length >= 7 &&\n-                    bytes[position + 4] == 'T' && bytes[position + 5] == 'E' && bytes[position + 6] == ' ')\n-                    return DELETE;\n-                break;\n-            case 'T':\n-                if (bytes[position + 1] == 'R' && bytes[position + 2] == 'A' && bytes[position + 3] == 'C' && length >= 6 &&\n-                    bytes[position + 4] == 'E' && bytes[position + 5] == ' ')\n-                    return TRACE;\n-                break;\n-            case 'C':\n-                if (bytes[position + 1] == 'O' && bytes[position + 2] == 'N' && bytes[position + 3] == 'N' && length >= 8 &&\n-                    bytes[position + 4] == 'E' && bytes[position + 5] == 'C' && bytes[position + 6] == 'T' && bytes[position + 7] == ' ')\n-                    return CONNECT;\n-                break;\n-            case 'M':\n-                if (bytes[position + 1] == 'O' && bytes[position + 2] == 'V' && bytes[position + 3] == 'E' && length >= 5 && bytes[position + 4] == ' ')\n-                    return MOVE;\n-                break;\n-            case 'S':\n-                if (bytes[position + 1] == 'E' && bytes[position + 2] == 'A' && bytes[position + 3] == 'R' && length >= 7 &&\n-                    bytes[position + 4] == 'C' && bytes[position + 5] == 'H' && bytes[position + 6] == ' ')\n-                    return SEARCH;\n-                break;\n-            case 'R':\n-                if (bytes[position + 1] == 'E' && bytes[position + 2] == 'P' && bytes[position + 3] == 'O' && length >= 7 &&\n-                    bytes[position + 4] == 'R' && bytes[position + 5] == 'T' && bytes[position + 6] == ' ')\n-                    return REPORT;\n-                break;\n-            default:\n-                break;\n-        }\n-        return null;\n+        _method = toString().replace('_', '-');\n+        _safe = safe;\n+        _idempotent = idempotent;\n+        _bytes = StringUtil.getBytes(_method);\n+        _buffer = ByteBuffer.wrap(_bytes);\n     }\n \n-    /**\n-     * Optimized lookup to find a method name and trailing space in a byte array.\n-     *\n-     * @param buffer buffer containing ISO-8859-1 characters, it is not modified.\n-     * @return An HttpMethod if a match or null if no easy match.\n-     */\n-    public static HttpMethod lookAheadGet(ByteBuffer buffer)\n+    public byte[] getBytes()\n     {\n-        if (buffer.hasArray())\n-            return lookAheadGet(buffer.array(), buffer.arrayOffset() + buffer.position(), buffer.arrayOffset() + buffer.limit());\n-\n-        int l = buffer.remaining();\n-        if (l >= 4)\n-        {\n-            HttpMethod m = CACHE.getBest(buffer, 0, l);\n-            if (m != null)\n-            {\n-                int ml = m.asString().length();\n-                if (l > ml && buffer.get(buffer.position() + ml) == ' ')\n-                    return m;\n-            }\n-        }\n-        return null;\n+        return _bytes;\n     }\n \n-    public static final Trie<HttpMethod> INSENSITIVE_CACHE = new ArrayTrie<>();\n-\n-    static\n+    public boolean is(String s)\n     {\n-        for (HttpMethod method : HttpMethod.values())\n-        {\n-            INSENSITIVE_CACHE.put(method.toString(), method);\n-        }\n+        return toString().equalsIgnoreCase(s);\n     }\n \n-    public static final Trie<HttpMethod> CACHE = new ArrayTernaryTrie<>(false);\n+    public boolean isSafe()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d10b15ccc61afafb3abdcccaf54a8b9f8661edb2"}, "originalPosition": 207}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODI1NzIxMg==", "bodyText": "Do we want to document what this means too?", "url": "https://github.com/eclipse/jetty.project/pull/5576#discussion_r518257212", "createdAt": "2020-11-05T18:04:16Z", "author": {"login": "joakime"}, "path": "jetty-http/src/main/java/org/eclipse/jetty/http/HttpMethod.java", "diffHunk": "@@ -26,189 +26,161 @@\n import org.eclipse.jetty.util.Trie;\n \n /**\n- *\n+ * Known HTTP Methods\n  */\n public enum HttpMethod\n {\n-    GET,\n-    POST,\n-    HEAD,\n-    PUT,\n-    OPTIONS,\n-    DELETE,\n-    TRACE,\n-    CONNECT,\n-    MOVE,\n-    PROXY,\n-    PRI,\n-    PATCH,\n-    SEARCH,\n-    REPORT;\n+    // From https://www.iana.org/assignments/http-methods/http-methods.xhtml\n+    ACL(false, true),\n+    BASELINE_CONTROL(false, true),\n+    BIND(false, true),\n+    CHECKIN(false, true),\n+    CHECKOUT(false, true),\n+    CONNECT(false, false),\n+    COPY(false, true),\n+    DELETE(false, true),\n+    GET(true, true),\n+    HEAD(true, true),\n+    LABEL(false, true),\n+    LINK(false, true),\n+    LOCK(false, false),\n+    MERGE(false, true),\n+    MKACTIVITY(false, true),\n+    MKCALENDAR(false, true),\n+    MKCOL(false, true),\n+    MKREDIRECTREF(false, true),\n+    MKWORKSPACE(false, true),\n+    MOVE(false, true),\n+    OPTIONS(true, true),\n+    ORDERPATCH(false, true),\n+    PATCH(false, false),\n+    POST(false, false),\n+    PRI(true, true),\n+    PROPFIND(true, true),\n+    PROPPATCH(false, true),\n+    PUT(false, true),\n+    REBIND(false, true),\n+    REPORT(true, true),\n+    SEARCH(true, true),\n+    TRACE(true, true),\n+    UNBIND(false, true),\n+    UNCHECKOUT(false, true),\n+    UNLINK(false, true),\n+    UNLOCK(false, true),\n+    UPDATE(false, true),\n+    UPDATEREDIRECTREF(false, true),\n+    VERSION_CONTROL(false, true),\n+\n+    // Other methods\n+    PROXY(false, false);\n+\n+    private final String _method;\n+    private final byte[] _bytes;\n+    private final ByteBuffer _buffer;\n+    private final boolean _safe;\n+    private final boolean _idempotent;\n \n-    /**\n-     * Optimized lookup to find a method name and trailing space in a byte array.\n-     *\n-     * @param bytes Array containing ISO-8859-1 characters\n-     * @param position The first valid index\n-     * @param limit The first non valid index\n-     * @return An HttpMethod if a match or null if no easy match.\n-     */\n-    public static HttpMethod lookAheadGet(byte[] bytes, final int position, int limit)\n+    HttpMethod(boolean safe, boolean idempotent)\n     {\n-        int length = limit - position;\n-        if (length < 4)\n-            return null;\n-        switch (bytes[position])\n-        {\n-            case 'G':\n-                if (bytes[position + 1] == 'E' && bytes[position + 2] == 'T' && bytes[position + 3] == ' ')\n-                    return GET;\n-                break;\n-            case 'P':\n-                switch (bytes[position + 1])\n-                {\n-                    case 'O':\n-                        if (bytes[position + 2] == 'S' && bytes[position + 3] == 'T' && length >= 5 && bytes[position + 4] == ' ')\n-                            return POST;\n-                        return null;\n-                    case 'R':\n-                        if (bytes[position + 2] == 'I' && bytes[position + 3] == ' ')\n-                            return PRI;\n-                        if (bytes[position + 2] == 'O' && bytes[position + 3] == 'X' && length >= 6 && bytes[position + 4] == 'Y' && bytes[position + 5] == ' ')\n-                            return PROXY;\n-                        return null;\n-                    case 'U':\n-                        if (bytes[position + 2] == 'T' && bytes[position + 3] == ' ')\n-                            return PUT;\n-                        return null;\n-                    case 'A':\n-                        if (bytes[position + 2] == 'T' && bytes[position + 3] == 'C' && length >= 6 && bytes[position + 4] == 'H' && bytes[position + 5] == ' ')\n-                            return PATCH;\n-                        return null;\n-                    default:\n-                        return null;\n-                }\n-\n-            case 'H':\n-                if (bytes[position + 1] == 'E' && bytes[position + 2] == 'A' && bytes[position + 3] == 'D' && length >= 5 && bytes[position + 4] == ' ')\n-                    return HEAD;\n-                break;\n-            case 'O':\n-                if (bytes[position + 1] == 'P' && bytes[position + 2] == 'T' && bytes[position + 3] == 'I' && length >= 8 &&\n-                    bytes[position + 4] == 'O' && bytes[position + 5] == 'N' && bytes[position + 6] == 'S' && bytes[position + 7] == ' ')\n-                    return OPTIONS;\n-                break;\n-            case 'D':\n-                if (bytes[position + 1] == 'E' && bytes[position + 2] == 'L' && bytes[position + 3] == 'E' && length >= 7 &&\n-                    bytes[position + 4] == 'T' && bytes[position + 5] == 'E' && bytes[position + 6] == ' ')\n-                    return DELETE;\n-                break;\n-            case 'T':\n-                if (bytes[position + 1] == 'R' && bytes[position + 2] == 'A' && bytes[position + 3] == 'C' && length >= 6 &&\n-                    bytes[position + 4] == 'E' && bytes[position + 5] == ' ')\n-                    return TRACE;\n-                break;\n-            case 'C':\n-                if (bytes[position + 1] == 'O' && bytes[position + 2] == 'N' && bytes[position + 3] == 'N' && length >= 8 &&\n-                    bytes[position + 4] == 'E' && bytes[position + 5] == 'C' && bytes[position + 6] == 'T' && bytes[position + 7] == ' ')\n-                    return CONNECT;\n-                break;\n-            case 'M':\n-                if (bytes[position + 1] == 'O' && bytes[position + 2] == 'V' && bytes[position + 3] == 'E' && length >= 5 && bytes[position + 4] == ' ')\n-                    return MOVE;\n-                break;\n-            case 'S':\n-                if (bytes[position + 1] == 'E' && bytes[position + 2] == 'A' && bytes[position + 3] == 'R' && length >= 7 &&\n-                    bytes[position + 4] == 'C' && bytes[position + 5] == 'H' && bytes[position + 6] == ' ')\n-                    return SEARCH;\n-                break;\n-            case 'R':\n-                if (bytes[position + 1] == 'E' && bytes[position + 2] == 'P' && bytes[position + 3] == 'O' && length >= 7 &&\n-                    bytes[position + 4] == 'R' && bytes[position + 5] == 'T' && bytes[position + 6] == ' ')\n-                    return REPORT;\n-                break;\n-            default:\n-                break;\n-        }\n-        return null;\n+        _method = toString().replace('_', '-');\n+        _safe = safe;\n+        _idempotent = idempotent;\n+        _bytes = StringUtil.getBytes(_method);\n+        _buffer = ByteBuffer.wrap(_bytes);\n     }\n \n-    /**\n-     * Optimized lookup to find a method name and trailing space in a byte array.\n-     *\n-     * @param buffer buffer containing ISO-8859-1 characters, it is not modified.\n-     * @return An HttpMethod if a match or null if no easy match.\n-     */\n-    public static HttpMethod lookAheadGet(ByteBuffer buffer)\n+    public byte[] getBytes()\n     {\n-        if (buffer.hasArray())\n-            return lookAheadGet(buffer.array(), buffer.arrayOffset() + buffer.position(), buffer.arrayOffset() + buffer.limit());\n-\n-        int l = buffer.remaining();\n-        if (l >= 4)\n-        {\n-            HttpMethod m = CACHE.getBest(buffer, 0, l);\n-            if (m != null)\n-            {\n-                int ml = m.asString().length();\n-                if (l > ml && buffer.get(buffer.position() + ml) == ' ')\n-                    return m;\n-            }\n-        }\n-        return null;\n+        return _bytes;\n     }\n \n-    public static final Trie<HttpMethod> INSENSITIVE_CACHE = new ArrayTrie<>();\n-\n-    static\n+    public boolean is(String s)\n     {\n-        for (HttpMethod method : HttpMethod.values())\n-        {\n-            INSENSITIVE_CACHE.put(method.toString(), method);\n-        }\n+        return toString().equalsIgnoreCase(s);\n     }\n \n-    public static final Trie<HttpMethod> CACHE = new ArrayTernaryTrie<>(false);\n+    public boolean isSafe()\n+    {\n+        return _safe;\n+    }\n \n-    static\n+    public boolean isIdempotent()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d10b15ccc61afafb3abdcccaf54a8b9f8661edb2"}, "originalPosition": 213}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f4349fab5668d278476d7b3effaf9baa4a90c601", "author": {"user": {"login": "gregw", "name": "Greg Wilkins"}}, "url": "https://github.com/eclipse/jetty.project/commit/f4349fab5668d278476d7b3effaf9baa4a90c601", "committedDate": "2020-11-06T08:01:16Z", "message": " + Added javadoc for isSafe and isIdempotent"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "064158e3dbcc7d6d8f41f2cc020c80e12a56f49d", "author": {"user": {"login": "gregw", "name": "Greg Wilkins"}}, "url": "https://github.com/eclipse/jetty.project/commit/064158e3dbcc7d6d8f41f2cc020c80e12a56f49d", "committedDate": "2020-11-06T08:28:43Z", "message": " + Use enum to encapsulate fact that all safe methods are idempotent... helps with readability"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "235923acb70825c63c9eabfd94a023b6954b72c8", "author": {"user": {"login": "gregw", "name": "Greg Wilkins"}}, "url": "https://github.com/eclipse/jetty.project/commit/235923acb70825c63c9eabfd94a023b6954b72c8", "committedDate": "2020-11-06T08:32:20Z", "message": " + replaced dodgey call to toString in constructor with explicit method string"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTI0OTg5MTAw", "url": "https://github.com/eclipse/jetty.project/pull/5576#pullrequestreview-524989100", "createdAt": "2020-11-06T09:33:01Z", "commit": {"oid": "235923acb70825c63c9eabfd94a023b6954b72c8"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNlQwOTozMzowMVrOHumkPg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNlQwOTo1MzowM1rOHunR5Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODYyODQxNA==", "bodyText": "This cache is used by HPackContext, and you changed it from case-insensitive to case-sensitive. Was that on purpose?", "url": "https://github.com/eclipse/jetty.project/pull/5576#discussion_r518628414", "createdAt": "2020-11-06T09:33:01Z", "author": {"login": "lorban"}, "path": "jetty-http/src/main/java/org/eclipse/jetty/http/HttpMethod.java", "diffHunk": "@@ -26,162 +26,179 @@\n import org.eclipse.jetty.util.Trie;\n \n /**\n- *\n+ * Known HTTP Methods\n  */\n public enum HttpMethod\n {\n-    GET,\n-    POST,\n-    HEAD,\n-    PUT,\n-    OPTIONS,\n-    DELETE,\n-    TRACE,\n-    CONNECT,\n-    MOVE,\n-    PROXY,\n-    PRI;\n-\n-    /**\n-     * Optimized lookup to find a method name and trailing space in a byte array.\n-     *\n-     * @param bytes Array containing ISO-8859-1 characters\n-     * @param position The first valid index\n-     * @param limit The first non valid index\n-     * @return An HttpMethod if a match or null if no easy match.\n-     */\n-    public static HttpMethod lookAheadGet(byte[] bytes, final int position, int limit)\n+    // From https://www.iana.org/assignments/http-methods/http-methods.xhtml\n+    ACL(\"ACL\", Type.IDEMPOTENT),\n+    BASELINE_CONTROL(\"BASELINE-CONTROL\", Type.IDEMPOTENT),\n+    BIND(\"BIND\", Type.IDEMPOTENT),\n+    CHECKIN(\"CHECKIN\", Type.IDEMPOTENT),\n+    CHECKOUT(\"CHECKOUT\", Type.IDEMPOTENT),\n+    CONNECT(\"CONNECT\", Type.NORMAL),\n+    COPY(\"COPY\", Type.IDEMPOTENT),\n+    DELETE(\"DELETE\", Type.IDEMPOTENT),\n+    GET(\"GET\", Type.SAFE),\n+    HEAD(\"HEAD\", Type.SAFE),\n+    LABEL(\"LABEL\", Type.IDEMPOTENT),\n+    LINK(\"LINK\", Type.IDEMPOTENT),\n+    LOCK(\"LOCK\", Type.NORMAL),\n+    MERGE(\"MERGE\", Type.IDEMPOTENT),\n+    MKACTIVITY(\"MKACTIVITY\", Type.IDEMPOTENT),\n+    MKCALENDAR(\"MKCALENDAR\", Type.IDEMPOTENT),\n+    MKCOL(\"MKCOL\", Type.IDEMPOTENT),\n+    MKREDIRECTREF(\"MKREDIRECTREF\", Type.IDEMPOTENT),\n+    MKWORKSPACE(\"MKWORKSPACE\", Type.IDEMPOTENT),\n+    MOVE(\"MOVE\", Type.IDEMPOTENT),\n+    OPTIONS(\"OPTIONS\", Type.SAFE),\n+    ORDERPATCH(\"ORDERPATCH\", Type.IDEMPOTENT),\n+    PATCH(\"PATCH\", Type.NORMAL),\n+    POST(\"POST\", Type.NORMAL),\n+    PRI(\"PRI\", Type.SAFE),\n+    PROPFIND(\"PROPFIND\", Type.SAFE),\n+    PROPPATCH(\"PROPPATCH\", Type.IDEMPOTENT),\n+    PUT(\"PUT\", Type.IDEMPOTENT),\n+    REBIND(\"REBIND\", Type.IDEMPOTENT),\n+    REPORT(\"REPORT\", Type.SAFE),\n+    SEARCH(\"SEARCH\", Type.SAFE),\n+    TRACE(\"TRACE\", Type.SAFE),\n+    UNBIND(\"UNBIND\", Type.IDEMPOTENT),\n+    UNCHECKOUT(\"UNCHECKOUT\", Type.IDEMPOTENT),\n+    UNLINK(\"UNLINK\", Type.IDEMPOTENT),\n+    UNLOCK(\"UNLOCK\", Type.IDEMPOTENT),\n+    UPDATE(\"UPDATE\", Type.IDEMPOTENT),\n+    UPDATEREDIRECTREF(\"UPDATEREDIRECTREF\", Type.IDEMPOTENT),\n+    VERSION_CONTROL(\"VERSION-CONTROL\", Type.IDEMPOTENT),\n+\n+    // Other methods\n+    PROXY(\"PROXY\", Type.NORMAL);\n+\n+    // The type of the method\n+    private enum Type\n     {\n-        int length = limit - position;\n-        if (length < 4)\n-            return null;\n-        switch (bytes[position])\n-        {\n-            case 'G':\n-                if (bytes[position + 1] == 'E' && bytes[position + 2] == 'T' && bytes[position + 3] == ' ')\n-                    return GET;\n-                break;\n-            case 'P':\n-                if (bytes[position + 1] == 'O' && bytes[position + 2] == 'S' && bytes[position + 3] == 'T' && length >= 5 && bytes[position + 4] == ' ')\n-                    return POST;\n-                if (bytes[position + 1] == 'R' && bytes[position + 2] == 'O' && bytes[position + 3] == 'X' && length >= 6 && bytes[position + 4] == 'Y' && bytes[position + 5] == ' ')\n-                    return PROXY;\n-                if (bytes[position + 1] == 'U' && bytes[position + 2] == 'T' && bytes[position + 3] == ' ')\n-                    return PUT;\n-                if (bytes[position + 1] == 'R' && bytes[position + 2] == 'I' && bytes[position + 3] == ' ')\n-                    return PRI;\n-                break;\n-            case 'H':\n-                if (bytes[position + 1] == 'E' && bytes[position + 2] == 'A' && bytes[position + 3] == 'D' && length >= 5 && bytes[position + 4] == ' ')\n-                    return HEAD;\n-                break;\n-            case 'O':\n-                if (bytes[position + 1] == 'P' && bytes[position + 2] == 'T' && bytes[position + 3] == 'I' && length >= 8 &&\n-                    bytes[position + 4] == 'O' && bytes[position + 5] == 'N' && bytes[position + 6] == 'S' && bytes[position + 7] == ' ')\n-                    return OPTIONS;\n-                break;\n-            case 'D':\n-                if (bytes[position + 1] == 'E' && bytes[position + 2] == 'L' && bytes[position + 3] == 'E' && length >= 7 &&\n-                    bytes[position + 4] == 'T' && bytes[position + 5] == 'E' && bytes[position + 6] == ' ')\n-                    return DELETE;\n-                break;\n-            case 'T':\n-                if (bytes[position + 1] == 'R' && bytes[position + 2] == 'A' && bytes[position + 3] == 'C' && length >= 6 &&\n-                    bytes[position + 4] == 'E' && bytes[position + 5] == ' ')\n-                    return TRACE;\n-                break;\n-            case 'C':\n-                if (bytes[position + 1] == 'O' && bytes[position + 2] == 'N' && bytes[position + 3] == 'N' && length >= 8 &&\n-                    bytes[position + 4] == 'E' && bytes[position + 5] == 'C' && bytes[position + 6] == 'T' && bytes[position + 7] == ' ')\n-                    return CONNECT;\n-                break;\n-            case 'M':\n-                if (bytes[position + 1] == 'O' && bytes[position + 2] == 'V' && bytes[position + 3] == 'E' && length >= 5 && bytes[position + 4] == ' ')\n-                    return MOVE;\n-                break;\n-\n-            default:\n-                break;\n-        }\n-        return null;\n+        NORMAL,\n+        IDEMPOTENT,\n+        SAFE\n     }\n+    \n+    private final String _method;\n+    private final byte[] _bytes;\n+    private final ByteBuffer _buffer;\n+    private final Type _type;\n \n-    /**\n-     * Optimized lookup to find a method name and trailing space in a byte array.\n-     *\n-     * @param buffer buffer containing ISO-8859-1 characters, it is not modified.\n-     * @return An HttpMethod if a match or null if no easy match.\n-     */\n-    public static HttpMethod lookAheadGet(ByteBuffer buffer)\n+    HttpMethod(String method, Type type)\n     {\n-        if (buffer.hasArray())\n-            return lookAheadGet(buffer.array(), buffer.arrayOffset() + buffer.position(), buffer.arrayOffset() + buffer.limit());\n-\n-        int l = buffer.remaining();\n-        if (l >= 4)\n-        {\n-            HttpMethod m = CACHE.getBest(buffer, 0, l);\n-            if (m != null)\n-            {\n-                int ml = m.asString().length();\n-                if (l > ml && buffer.get(buffer.position() + ml) == ' ')\n-                    return m;\n-            }\n-        }\n-        return null;\n+        _method = method;\n+        _type = type;\n+        _bytes = StringUtil.getBytes(_method);\n+        _buffer = ByteBuffer.wrap(_bytes);\n     }\n \n-    public static final Trie<HttpMethod> INSENSITIVE_CACHE = new ArrayTrie<>();\n+    public byte[] getBytes()\n+    {\n+        return _bytes;\n+    }\n \n-    static\n+    public boolean is(String s)\n     {\n-        for (HttpMethod method : HttpMethod.values())\n-        {\n-            INSENSITIVE_CACHE.put(method.toString(), method);\n-        }\n+        return toString().equalsIgnoreCase(s);\n     }\n \n-    public static final Trie<HttpMethod> CACHE = new ArrayTernaryTrie<>(false);\n+    /**\n+     * An HTTP method is safe if it doesn't alter the state of the server.\n+     * In other words, a method is safe if it leads to a read-only operation.\n+     * Several common HTTP methods are safe: GET , HEAD , or OPTIONS .\n+     * All safe methods are also idempotent, but not all idempotent methods are safe\n+     * @return if the method is safe.\n+     */\n+    public boolean isSafe()\n+    {\n+        return _type == Type.SAFE;\n+    }\n \n-    static\n+    /**\n+     * An idempotent HTTP method is an HTTP method that can be called many times without different outcomes.\n+     * It would not matter if the method is called only once, or ten times over. The result should be the same.\n+     * @return true if the method is idempotent.\n+     */\n+    public boolean isIdempotent()\n     {\n-        for (HttpMethod method : HttpMethod.values())\n-        {\n-            CACHE.put(method.toString(), method);\n-        }\n+        return _type.ordinal() >= Type.IDEMPOTENT.ordinal();\n     }\n \n-    private final ByteBuffer _buffer;\n-    private final byte[] _bytes;\n+    public ByteBuffer asBuffer()\n+    {\n+        return _buffer.asReadOnlyBuffer();\n+    }\n \n-    HttpMethod()\n+    public String asString()\n     {\n-        _bytes = StringUtil.getBytes(toString());\n-        _buffer = ByteBuffer.wrap(_bytes);\n+        return _method;\n     }\n \n-    public byte[] getBytes()\n+    public String toString()\n     {\n-        return _bytes;\n+        return _method;\n     }\n \n-    public boolean is(String s)\n+    public static final Trie<HttpMethod> INSENSITIVE_CACHE = new ArrayTrie<>(252);\n+    public static final Trie<HttpMethod> CACHE = new ArrayTernaryTrie<>(false, 300);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "235923acb70825c63c9eabfd94a023b6954b72c8"}, "originalPosition": 237}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODYyOTMyNA==", "bodyText": "It is still used by HttpParser.", "url": "https://github.com/eclipse/jetty.project/pull/5576#discussion_r518629324", "createdAt": "2020-11-06T09:34:33Z", "author": {"login": "lorban"}, "path": "jetty-http/src/main/java/org/eclipse/jetty/http/HttpMethod.java", "diffHunk": "@@ -26,162 +26,179 @@\n import org.eclipse.jetty.util.Trie;\n \n /**\n- *\n+ * Known HTTP Methods\n  */\n public enum HttpMethod\n {\n-    GET,\n-    POST,\n-    HEAD,\n-    PUT,\n-    OPTIONS,\n-    DELETE,\n-    TRACE,\n-    CONNECT,\n-    MOVE,\n-    PROXY,\n-    PRI;\n-\n-    /**\n-     * Optimized lookup to find a method name and trailing space in a byte array.\n-     *\n-     * @param bytes Array containing ISO-8859-1 characters\n-     * @param position The first valid index\n-     * @param limit The first non valid index\n-     * @return An HttpMethod if a match or null if no easy match.\n-     */\n-    public static HttpMethod lookAheadGet(byte[] bytes, final int position, int limit)\n+    // From https://www.iana.org/assignments/http-methods/http-methods.xhtml\n+    ACL(\"ACL\", Type.IDEMPOTENT),\n+    BASELINE_CONTROL(\"BASELINE-CONTROL\", Type.IDEMPOTENT),\n+    BIND(\"BIND\", Type.IDEMPOTENT),\n+    CHECKIN(\"CHECKIN\", Type.IDEMPOTENT),\n+    CHECKOUT(\"CHECKOUT\", Type.IDEMPOTENT),\n+    CONNECT(\"CONNECT\", Type.NORMAL),\n+    COPY(\"COPY\", Type.IDEMPOTENT),\n+    DELETE(\"DELETE\", Type.IDEMPOTENT),\n+    GET(\"GET\", Type.SAFE),\n+    HEAD(\"HEAD\", Type.SAFE),\n+    LABEL(\"LABEL\", Type.IDEMPOTENT),\n+    LINK(\"LINK\", Type.IDEMPOTENT),\n+    LOCK(\"LOCK\", Type.NORMAL),\n+    MERGE(\"MERGE\", Type.IDEMPOTENT),\n+    MKACTIVITY(\"MKACTIVITY\", Type.IDEMPOTENT),\n+    MKCALENDAR(\"MKCALENDAR\", Type.IDEMPOTENT),\n+    MKCOL(\"MKCOL\", Type.IDEMPOTENT),\n+    MKREDIRECTREF(\"MKREDIRECTREF\", Type.IDEMPOTENT),\n+    MKWORKSPACE(\"MKWORKSPACE\", Type.IDEMPOTENT),\n+    MOVE(\"MOVE\", Type.IDEMPOTENT),\n+    OPTIONS(\"OPTIONS\", Type.SAFE),\n+    ORDERPATCH(\"ORDERPATCH\", Type.IDEMPOTENT),\n+    PATCH(\"PATCH\", Type.NORMAL),\n+    POST(\"POST\", Type.NORMAL),\n+    PRI(\"PRI\", Type.SAFE),\n+    PROPFIND(\"PROPFIND\", Type.SAFE),\n+    PROPPATCH(\"PROPPATCH\", Type.IDEMPOTENT),\n+    PUT(\"PUT\", Type.IDEMPOTENT),\n+    REBIND(\"REBIND\", Type.IDEMPOTENT),\n+    REPORT(\"REPORT\", Type.SAFE),\n+    SEARCH(\"SEARCH\", Type.SAFE),\n+    TRACE(\"TRACE\", Type.SAFE),\n+    UNBIND(\"UNBIND\", Type.IDEMPOTENT),\n+    UNCHECKOUT(\"UNCHECKOUT\", Type.IDEMPOTENT),\n+    UNLINK(\"UNLINK\", Type.IDEMPOTENT),\n+    UNLOCK(\"UNLOCK\", Type.IDEMPOTENT),\n+    UPDATE(\"UPDATE\", Type.IDEMPOTENT),\n+    UPDATEREDIRECTREF(\"UPDATEREDIRECTREF\", Type.IDEMPOTENT),\n+    VERSION_CONTROL(\"VERSION-CONTROL\", Type.IDEMPOTENT),\n+\n+    // Other methods\n+    PROXY(\"PROXY\", Type.NORMAL);\n+\n+    // The type of the method\n+    private enum Type\n     {\n-        int length = limit - position;\n-        if (length < 4)\n-            return null;\n-        switch (bytes[position])\n-        {\n-            case 'G':\n-                if (bytes[position + 1] == 'E' && bytes[position + 2] == 'T' && bytes[position + 3] == ' ')\n-                    return GET;\n-                break;\n-            case 'P':\n-                if (bytes[position + 1] == 'O' && bytes[position + 2] == 'S' && bytes[position + 3] == 'T' && length >= 5 && bytes[position + 4] == ' ')\n-                    return POST;\n-                if (bytes[position + 1] == 'R' && bytes[position + 2] == 'O' && bytes[position + 3] == 'X' && length >= 6 && bytes[position + 4] == 'Y' && bytes[position + 5] == ' ')\n-                    return PROXY;\n-                if (bytes[position + 1] == 'U' && bytes[position + 2] == 'T' && bytes[position + 3] == ' ')\n-                    return PUT;\n-                if (bytes[position + 1] == 'R' && bytes[position + 2] == 'I' && bytes[position + 3] == ' ')\n-                    return PRI;\n-                break;\n-            case 'H':\n-                if (bytes[position + 1] == 'E' && bytes[position + 2] == 'A' && bytes[position + 3] == 'D' && length >= 5 && bytes[position + 4] == ' ')\n-                    return HEAD;\n-                break;\n-            case 'O':\n-                if (bytes[position + 1] == 'P' && bytes[position + 2] == 'T' && bytes[position + 3] == 'I' && length >= 8 &&\n-                    bytes[position + 4] == 'O' && bytes[position + 5] == 'N' && bytes[position + 6] == 'S' && bytes[position + 7] == ' ')\n-                    return OPTIONS;\n-                break;\n-            case 'D':\n-                if (bytes[position + 1] == 'E' && bytes[position + 2] == 'L' && bytes[position + 3] == 'E' && length >= 7 &&\n-                    bytes[position + 4] == 'T' && bytes[position + 5] == 'E' && bytes[position + 6] == ' ')\n-                    return DELETE;\n-                break;\n-            case 'T':\n-                if (bytes[position + 1] == 'R' && bytes[position + 2] == 'A' && bytes[position + 3] == 'C' && length >= 6 &&\n-                    bytes[position + 4] == 'E' && bytes[position + 5] == ' ')\n-                    return TRACE;\n-                break;\n-            case 'C':\n-                if (bytes[position + 1] == 'O' && bytes[position + 2] == 'N' && bytes[position + 3] == 'N' && length >= 8 &&\n-                    bytes[position + 4] == 'E' && bytes[position + 5] == 'C' && bytes[position + 6] == 'T' && bytes[position + 7] == ' ')\n-                    return CONNECT;\n-                break;\n-            case 'M':\n-                if (bytes[position + 1] == 'O' && bytes[position + 2] == 'V' && bytes[position + 3] == 'E' && length >= 5 && bytes[position + 4] == ' ')\n-                    return MOVE;\n-                break;\n-\n-            default:\n-                break;\n-        }\n-        return null;\n+        NORMAL,\n+        IDEMPOTENT,\n+        SAFE\n     }\n+    \n+    private final String _method;\n+    private final byte[] _bytes;\n+    private final ByteBuffer _buffer;\n+    private final Type _type;\n \n-    /**\n-     * Optimized lookup to find a method name and trailing space in a byte array.\n-     *\n-     * @param buffer buffer containing ISO-8859-1 characters, it is not modified.\n-     * @return An HttpMethod if a match or null if no easy match.\n-     */\n-    public static HttpMethod lookAheadGet(ByteBuffer buffer)\n+    HttpMethod(String method, Type type)\n     {\n-        if (buffer.hasArray())\n-            return lookAheadGet(buffer.array(), buffer.arrayOffset() + buffer.position(), buffer.arrayOffset() + buffer.limit());\n-\n-        int l = buffer.remaining();\n-        if (l >= 4)\n-        {\n-            HttpMethod m = CACHE.getBest(buffer, 0, l);\n-            if (m != null)\n-            {\n-                int ml = m.asString().length();\n-                if (l > ml && buffer.get(buffer.position() + ml) == ' ')\n-                    return m;\n-            }\n-        }\n-        return null;\n+        _method = method;\n+        _type = type;\n+        _bytes = StringUtil.getBytes(_method);\n+        _buffer = ByteBuffer.wrap(_bytes);\n     }\n \n-    public static final Trie<HttpMethod> INSENSITIVE_CACHE = new ArrayTrie<>();\n+    public byte[] getBytes()\n+    {\n+        return _bytes;\n+    }\n \n-    static\n+    public boolean is(String s)\n     {\n-        for (HttpMethod method : HttpMethod.values())\n-        {\n-            INSENSITIVE_CACHE.put(method.toString(), method);\n-        }\n+        return toString().equalsIgnoreCase(s);\n     }\n \n-    public static final Trie<HttpMethod> CACHE = new ArrayTernaryTrie<>(false);\n+    /**\n+     * An HTTP method is safe if it doesn't alter the state of the server.\n+     * In other words, a method is safe if it leads to a read-only operation.\n+     * Several common HTTP methods are safe: GET , HEAD , or OPTIONS .\n+     * All safe methods are also idempotent, but not all idempotent methods are safe\n+     * @return if the method is safe.\n+     */\n+    public boolean isSafe()\n+    {\n+        return _type == Type.SAFE;\n+    }\n \n-    static\n+    /**\n+     * An idempotent HTTP method is an HTTP method that can be called many times without different outcomes.\n+     * It would not matter if the method is called only once, or ten times over. The result should be the same.\n+     * @return true if the method is idempotent.\n+     */\n+    public boolean isIdempotent()\n     {\n-        for (HttpMethod method : HttpMethod.values())\n-        {\n-            CACHE.put(method.toString(), method);\n-        }\n+        return _type.ordinal() >= Type.IDEMPOTENT.ordinal();\n     }\n \n-    private final ByteBuffer _buffer;\n-    private final byte[] _bytes;\n+    public ByteBuffer asBuffer()\n+    {\n+        return _buffer.asReadOnlyBuffer();\n+    }\n \n-    HttpMethod()\n+    public String asString()\n     {\n-        _bytes = StringUtil.getBytes(toString());\n-        _buffer = ByteBuffer.wrap(_bytes);\n+        return _method;\n     }\n \n-    public byte[] getBytes()\n+    public String toString()\n     {\n-        return _bytes;\n+        return _method;\n     }\n \n-    public boolean is(String s)\n+    public static final Trie<HttpMethod> INSENSITIVE_CACHE = new ArrayTrie<>(252);\n+    public static final Trie<HttpMethod> CACHE = new ArrayTernaryTrie<>(false, 300);\n+    public static final Trie<HttpMethod> LOOK_AHEAD = new ArrayTernaryTrie<>(false, 330);\n+    static\n     {\n-        return toString().equalsIgnoreCase(s);\n+        for (HttpMethod method : HttpMethod.values())\n+        {\n+            if (!INSENSITIVE_CACHE.put(method.asString(), method))\n+                throw new IllegalStateException(\"INSENSITIVE_CACHE too small: \" + method);\n+\n+            if (!CACHE.put(method.asString(), method))\n+                throw new IllegalStateException(\"CACHE too small: \" + method);\n+\n+            if (!LOOK_AHEAD.put(method.asString() + ' ', method))\n+                throw new IllegalStateException(\"LOOK_AHEAD too small: \" + method);\n+        }\n     }\n \n-    public ByteBuffer asBuffer()\n+    /**\n+     * Optimized lookup to find a method name and trailing space in a byte array.\n+     *\n+     * @param bytes Array containing ISO-8859-1 characters\n+     * @param position The first valid index\n+     * @param limit The first non valid index\n+     * @return An HttpMethod if a match or null if no easy match.\n+     */\n+    public static HttpMethod lookAheadGet(byte[] bytes, final int position, int limit)\n     {\n-        return _buffer.asReadOnlyBuffer();\n+        int len = limit - position;\n+        if (limit > 3)\n+        {\n+            // Short cut for GET\n+            if (bytes[position] == 'G' && bytes[position + 1] == 'E' && bytes[position + 2] == 'T' && bytes[position + 3] == ' ')\n+                return GET;\n+            // Otherwise lookup in the Trie\n+            return LOOK_AHEAD.getBest(bytes, position, len);\n+        }\n+        return null;\n     }\n \n-    public String asString()\n+    /**\n+     * Optimized lookup to find a method name and trailing space in a byte array.\n+     *\n+     * @param buffer buffer containing ISO-8859-1 characters, it is not modified.\n+     * @return An HttpMethod if a match or null if no easy match.\n+     * @deprecated Not used", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "235923acb70825c63c9eabfd94a023b6954b72c8"}, "originalPosition": 285}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODY0MDEwMQ==", "bodyText": "Is that extra LOOK_AHEAD trie worth it? Since it is just a copy of the CACHE one with the extra whitespace, wouldn't something like the following be as fast and avoid duplication?\nHttpMethod method = CACHE.getBest(buffer, 0, buffer.remaining());\nif (method == null)\n    return null;\n\nint whitespaceIndex = method.name().length();\nif (buffer.remaining() == whitespaceIndex)\n    return null;\n\nbyte b = buffer.get(whitespaceIndex);\nreturn b == ' ' ? method : null;", "url": "https://github.com/eclipse/jetty.project/pull/5576#discussion_r518640101", "createdAt": "2020-11-06T09:53:03Z", "author": {"login": "lorban"}, "path": "jetty-http/src/main/java/org/eclipse/jetty/http/HttpMethod.java", "diffHunk": "@@ -26,162 +26,179 @@\n import org.eclipse.jetty.util.Trie;\n \n /**\n- *\n+ * Known HTTP Methods\n  */\n public enum HttpMethod\n {\n-    GET,\n-    POST,\n-    HEAD,\n-    PUT,\n-    OPTIONS,\n-    DELETE,\n-    TRACE,\n-    CONNECT,\n-    MOVE,\n-    PROXY,\n-    PRI;\n-\n-    /**\n-     * Optimized lookup to find a method name and trailing space in a byte array.\n-     *\n-     * @param bytes Array containing ISO-8859-1 characters\n-     * @param position The first valid index\n-     * @param limit The first non valid index\n-     * @return An HttpMethod if a match or null if no easy match.\n-     */\n-    public static HttpMethod lookAheadGet(byte[] bytes, final int position, int limit)\n+    // From https://www.iana.org/assignments/http-methods/http-methods.xhtml\n+    ACL(\"ACL\", Type.IDEMPOTENT),\n+    BASELINE_CONTROL(\"BASELINE-CONTROL\", Type.IDEMPOTENT),\n+    BIND(\"BIND\", Type.IDEMPOTENT),\n+    CHECKIN(\"CHECKIN\", Type.IDEMPOTENT),\n+    CHECKOUT(\"CHECKOUT\", Type.IDEMPOTENT),\n+    CONNECT(\"CONNECT\", Type.NORMAL),\n+    COPY(\"COPY\", Type.IDEMPOTENT),\n+    DELETE(\"DELETE\", Type.IDEMPOTENT),\n+    GET(\"GET\", Type.SAFE),\n+    HEAD(\"HEAD\", Type.SAFE),\n+    LABEL(\"LABEL\", Type.IDEMPOTENT),\n+    LINK(\"LINK\", Type.IDEMPOTENT),\n+    LOCK(\"LOCK\", Type.NORMAL),\n+    MERGE(\"MERGE\", Type.IDEMPOTENT),\n+    MKACTIVITY(\"MKACTIVITY\", Type.IDEMPOTENT),\n+    MKCALENDAR(\"MKCALENDAR\", Type.IDEMPOTENT),\n+    MKCOL(\"MKCOL\", Type.IDEMPOTENT),\n+    MKREDIRECTREF(\"MKREDIRECTREF\", Type.IDEMPOTENT),\n+    MKWORKSPACE(\"MKWORKSPACE\", Type.IDEMPOTENT),\n+    MOVE(\"MOVE\", Type.IDEMPOTENT),\n+    OPTIONS(\"OPTIONS\", Type.SAFE),\n+    ORDERPATCH(\"ORDERPATCH\", Type.IDEMPOTENT),\n+    PATCH(\"PATCH\", Type.NORMAL),\n+    POST(\"POST\", Type.NORMAL),\n+    PRI(\"PRI\", Type.SAFE),\n+    PROPFIND(\"PROPFIND\", Type.SAFE),\n+    PROPPATCH(\"PROPPATCH\", Type.IDEMPOTENT),\n+    PUT(\"PUT\", Type.IDEMPOTENT),\n+    REBIND(\"REBIND\", Type.IDEMPOTENT),\n+    REPORT(\"REPORT\", Type.SAFE),\n+    SEARCH(\"SEARCH\", Type.SAFE),\n+    TRACE(\"TRACE\", Type.SAFE),\n+    UNBIND(\"UNBIND\", Type.IDEMPOTENT),\n+    UNCHECKOUT(\"UNCHECKOUT\", Type.IDEMPOTENT),\n+    UNLINK(\"UNLINK\", Type.IDEMPOTENT),\n+    UNLOCK(\"UNLOCK\", Type.IDEMPOTENT),\n+    UPDATE(\"UPDATE\", Type.IDEMPOTENT),\n+    UPDATEREDIRECTREF(\"UPDATEREDIRECTREF\", Type.IDEMPOTENT),\n+    VERSION_CONTROL(\"VERSION-CONTROL\", Type.IDEMPOTENT),\n+\n+    // Other methods\n+    PROXY(\"PROXY\", Type.NORMAL);\n+\n+    // The type of the method\n+    private enum Type\n     {\n-        int length = limit - position;\n-        if (length < 4)\n-            return null;\n-        switch (bytes[position])\n-        {\n-            case 'G':\n-                if (bytes[position + 1] == 'E' && bytes[position + 2] == 'T' && bytes[position + 3] == ' ')\n-                    return GET;\n-                break;\n-            case 'P':\n-                if (bytes[position + 1] == 'O' && bytes[position + 2] == 'S' && bytes[position + 3] == 'T' && length >= 5 && bytes[position + 4] == ' ')\n-                    return POST;\n-                if (bytes[position + 1] == 'R' && bytes[position + 2] == 'O' && bytes[position + 3] == 'X' && length >= 6 && bytes[position + 4] == 'Y' && bytes[position + 5] == ' ')\n-                    return PROXY;\n-                if (bytes[position + 1] == 'U' && bytes[position + 2] == 'T' && bytes[position + 3] == ' ')\n-                    return PUT;\n-                if (bytes[position + 1] == 'R' && bytes[position + 2] == 'I' && bytes[position + 3] == ' ')\n-                    return PRI;\n-                break;\n-            case 'H':\n-                if (bytes[position + 1] == 'E' && bytes[position + 2] == 'A' && bytes[position + 3] == 'D' && length >= 5 && bytes[position + 4] == ' ')\n-                    return HEAD;\n-                break;\n-            case 'O':\n-                if (bytes[position + 1] == 'P' && bytes[position + 2] == 'T' && bytes[position + 3] == 'I' && length >= 8 &&\n-                    bytes[position + 4] == 'O' && bytes[position + 5] == 'N' && bytes[position + 6] == 'S' && bytes[position + 7] == ' ')\n-                    return OPTIONS;\n-                break;\n-            case 'D':\n-                if (bytes[position + 1] == 'E' && bytes[position + 2] == 'L' && bytes[position + 3] == 'E' && length >= 7 &&\n-                    bytes[position + 4] == 'T' && bytes[position + 5] == 'E' && bytes[position + 6] == ' ')\n-                    return DELETE;\n-                break;\n-            case 'T':\n-                if (bytes[position + 1] == 'R' && bytes[position + 2] == 'A' && bytes[position + 3] == 'C' && length >= 6 &&\n-                    bytes[position + 4] == 'E' && bytes[position + 5] == ' ')\n-                    return TRACE;\n-                break;\n-            case 'C':\n-                if (bytes[position + 1] == 'O' && bytes[position + 2] == 'N' && bytes[position + 3] == 'N' && length >= 8 &&\n-                    bytes[position + 4] == 'E' && bytes[position + 5] == 'C' && bytes[position + 6] == 'T' && bytes[position + 7] == ' ')\n-                    return CONNECT;\n-                break;\n-            case 'M':\n-                if (bytes[position + 1] == 'O' && bytes[position + 2] == 'V' && bytes[position + 3] == 'E' && length >= 5 && bytes[position + 4] == ' ')\n-                    return MOVE;\n-                break;\n-\n-            default:\n-                break;\n-        }\n-        return null;\n+        NORMAL,\n+        IDEMPOTENT,\n+        SAFE\n     }\n+    \n+    private final String _method;\n+    private final byte[] _bytes;\n+    private final ByteBuffer _buffer;\n+    private final Type _type;\n \n-    /**\n-     * Optimized lookup to find a method name and trailing space in a byte array.\n-     *\n-     * @param buffer buffer containing ISO-8859-1 characters, it is not modified.\n-     * @return An HttpMethod if a match or null if no easy match.\n-     */\n-    public static HttpMethod lookAheadGet(ByteBuffer buffer)\n+    HttpMethod(String method, Type type)\n     {\n-        if (buffer.hasArray())\n-            return lookAheadGet(buffer.array(), buffer.arrayOffset() + buffer.position(), buffer.arrayOffset() + buffer.limit());\n-\n-        int l = buffer.remaining();\n-        if (l >= 4)\n-        {\n-            HttpMethod m = CACHE.getBest(buffer, 0, l);\n-            if (m != null)\n-            {\n-                int ml = m.asString().length();\n-                if (l > ml && buffer.get(buffer.position() + ml) == ' ')\n-                    return m;\n-            }\n-        }\n-        return null;\n+        _method = method;\n+        _type = type;\n+        _bytes = StringUtil.getBytes(_method);\n+        _buffer = ByteBuffer.wrap(_bytes);\n     }\n \n-    public static final Trie<HttpMethod> INSENSITIVE_CACHE = new ArrayTrie<>();\n+    public byte[] getBytes()\n+    {\n+        return _bytes;\n+    }\n \n-    static\n+    public boolean is(String s)\n     {\n-        for (HttpMethod method : HttpMethod.values())\n-        {\n-            INSENSITIVE_CACHE.put(method.toString(), method);\n-        }\n+        return toString().equalsIgnoreCase(s);\n     }\n \n-    public static final Trie<HttpMethod> CACHE = new ArrayTernaryTrie<>(false);\n+    /**\n+     * An HTTP method is safe if it doesn't alter the state of the server.\n+     * In other words, a method is safe if it leads to a read-only operation.\n+     * Several common HTTP methods are safe: GET , HEAD , or OPTIONS .\n+     * All safe methods are also idempotent, but not all idempotent methods are safe\n+     * @return if the method is safe.\n+     */\n+    public boolean isSafe()\n+    {\n+        return _type == Type.SAFE;\n+    }\n \n-    static\n+    /**\n+     * An idempotent HTTP method is an HTTP method that can be called many times without different outcomes.\n+     * It would not matter if the method is called only once, or ten times over. The result should be the same.\n+     * @return true if the method is idempotent.\n+     */\n+    public boolean isIdempotent()\n     {\n-        for (HttpMethod method : HttpMethod.values())\n-        {\n-            CACHE.put(method.toString(), method);\n-        }\n+        return _type.ordinal() >= Type.IDEMPOTENT.ordinal();\n     }\n \n-    private final ByteBuffer _buffer;\n-    private final byte[] _bytes;\n+    public ByteBuffer asBuffer()\n+    {\n+        return _buffer.asReadOnlyBuffer();\n+    }\n \n-    HttpMethod()\n+    public String asString()\n     {\n-        _bytes = StringUtil.getBytes(toString());\n-        _buffer = ByteBuffer.wrap(_bytes);\n+        return _method;\n     }\n \n-    public byte[] getBytes()\n+    public String toString()\n     {\n-        return _bytes;\n+        return _method;\n     }\n \n-    public boolean is(String s)\n+    public static final Trie<HttpMethod> INSENSITIVE_CACHE = new ArrayTrie<>(252);\n+    public static final Trie<HttpMethod> CACHE = new ArrayTernaryTrie<>(false, 300);\n+    public static final Trie<HttpMethod> LOOK_AHEAD = new ArrayTernaryTrie<>(false, 330);\n+    static\n     {\n-        return toString().equalsIgnoreCase(s);\n+        for (HttpMethod method : HttpMethod.values())\n+        {\n+            if (!INSENSITIVE_CACHE.put(method.asString(), method))\n+                throw new IllegalStateException(\"INSENSITIVE_CACHE too small: \" + method);\n+\n+            if (!CACHE.put(method.asString(), method))\n+                throw new IllegalStateException(\"CACHE too small: \" + method);\n+\n+            if (!LOOK_AHEAD.put(method.asString() + ' ', method))\n+                throw new IllegalStateException(\"LOOK_AHEAD too small: \" + method);\n+        }\n     }\n \n-    public ByteBuffer asBuffer()\n+    /**\n+     * Optimized lookup to find a method name and trailing space in a byte array.\n+     *\n+     * @param bytes Array containing ISO-8859-1 characters\n+     * @param position The first valid index\n+     * @param limit The first non valid index\n+     * @return An HttpMethod if a match or null if no easy match.\n+     */\n+    public static HttpMethod lookAheadGet(byte[] bytes, final int position, int limit)\n     {\n-        return _buffer.asReadOnlyBuffer();\n+        int len = limit - position;\n+        if (limit > 3)\n+        {\n+            // Short cut for GET\n+            if (bytes[position] == 'G' && bytes[position + 1] == 'E' && bytes[position + 2] == 'T' && bytes[position + 3] == ' ')\n+                return GET;\n+            // Otherwise lookup in the Trie\n+            return LOOK_AHEAD.getBest(bytes, position, len);\n+        }\n+        return null;\n     }\n \n-    public String asString()\n+    /**\n+     * Optimized lookup to find a method name and trailing space in a byte array.\n+     *\n+     * @param buffer buffer containing ISO-8859-1 characters, it is not modified.\n+     * @return An HttpMethod if a match or null if no easy match.\n+     * @deprecated Not used\n+     */\n+    @Deprecated\n+    public static HttpMethod lookAheadGet(ByteBuffer buffer)\n     {\n-        return toString();\n+        return LOOK_AHEAD.getBest(buffer, 0, buffer.remaining());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "235923acb70825c63c9eabfd94a023b6954b72c8"}, "originalPosition": 291}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f1802a23eb91c650baf31938ecdada78c69c3b94", "author": {"user": {"login": "gregw", "name": "Greg Wilkins"}}, "url": "https://github.com/eclipse/jetty.project/commit/f1802a23eb91c650baf31938ecdada78c69c3b94", "committedDate": "2020-11-06T15:04:38Z", "message": "Updates from review"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTI1MjQ5ODc1", "url": "https://github.com/eclipse/jetty.project/pull/5576#pullrequestreview-525249875", "createdAt": "2020-11-06T15:20:12Z", "commit": {"oid": "f1802a23eb91c650baf31938ecdada78c69c3b94"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNlQxNToyMDoxMlrOHuyQPQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNlQxNToyMDoxMlrOHuyQPQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODgxOTkwMQ==", "bodyText": "You can get rid of the String method parameter.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    _method = method;\n          \n          \n            \n                    _method = name().replace('_','-');\n          \n      \n    \n    \n  \n\nThat works.", "url": "https://github.com/eclipse/jetty.project/pull/5576#discussion_r518819901", "createdAt": "2020-11-06T15:20:12Z", "author": {"login": "joakime"}, "path": "jetty-http/src/main/java/org/eclipse/jetty/http/HttpMethod.java", "diffHunk": "@@ -26,162 +26,192 @@\n import org.eclipse.jetty.util.Trie;\n \n /**\n- *\n+ * Known HTTP Methods\n  */\n public enum HttpMethod\n {\n-    GET,\n-    POST,\n-    HEAD,\n-    PUT,\n-    OPTIONS,\n-    DELETE,\n-    TRACE,\n-    CONNECT,\n-    MOVE,\n-    PROXY,\n-    PRI;\n-\n-    /**\n-     * Optimized lookup to find a method name and trailing space in a byte array.\n-     *\n-     * @param bytes Array containing ISO-8859-1 characters\n-     * @param position The first valid index\n-     * @param limit The first non valid index\n-     * @return An HttpMethod if a match or null if no easy match.\n-     */\n-    public static HttpMethod lookAheadGet(byte[] bytes, final int position, int limit)\n+    // From https://www.iana.org/assignments/http-methods/http-methods.xhtml\n+    ACL(\"ACL\", Type.IDEMPOTENT),\n+    BASELINE_CONTROL(\"BASELINE-CONTROL\", Type.IDEMPOTENT),\n+    BIND(\"BIND\", Type.IDEMPOTENT),\n+    CHECKIN(\"CHECKIN\", Type.IDEMPOTENT),\n+    CHECKOUT(\"CHECKOUT\", Type.IDEMPOTENT),\n+    CONNECT(\"CONNECT\", Type.NORMAL),\n+    COPY(\"COPY\", Type.IDEMPOTENT),\n+    DELETE(\"DELETE\", Type.IDEMPOTENT),\n+    GET(\"GET\", Type.SAFE),\n+    HEAD(\"HEAD\", Type.SAFE),\n+    LABEL(\"LABEL\", Type.IDEMPOTENT),\n+    LINK(\"LINK\", Type.IDEMPOTENT),\n+    LOCK(\"LOCK\", Type.NORMAL),\n+    MERGE(\"MERGE\", Type.IDEMPOTENT),\n+    MKACTIVITY(\"MKACTIVITY\", Type.IDEMPOTENT),\n+    MKCALENDAR(\"MKCALENDAR\", Type.IDEMPOTENT),\n+    MKCOL(\"MKCOL\", Type.IDEMPOTENT),\n+    MKREDIRECTREF(\"MKREDIRECTREF\", Type.IDEMPOTENT),\n+    MKWORKSPACE(\"MKWORKSPACE\", Type.IDEMPOTENT),\n+    MOVE(\"MOVE\", Type.IDEMPOTENT),\n+    OPTIONS(\"OPTIONS\", Type.SAFE),\n+    ORDERPATCH(\"ORDERPATCH\", Type.IDEMPOTENT),\n+    PATCH(\"PATCH\", Type.NORMAL),\n+    POST(\"POST\", Type.NORMAL),\n+    PRI(\"PRI\", Type.SAFE),\n+    PROPFIND(\"PROPFIND\", Type.SAFE),\n+    PROPPATCH(\"PROPPATCH\", Type.IDEMPOTENT),\n+    PUT(\"PUT\", Type.IDEMPOTENT),\n+    REBIND(\"REBIND\", Type.IDEMPOTENT),\n+    REPORT(\"REPORT\", Type.SAFE),\n+    SEARCH(\"SEARCH\", Type.SAFE),\n+    TRACE(\"TRACE\", Type.SAFE),\n+    UNBIND(\"UNBIND\", Type.IDEMPOTENT),\n+    UNCHECKOUT(\"UNCHECKOUT\", Type.IDEMPOTENT),\n+    UNLINK(\"UNLINK\", Type.IDEMPOTENT),\n+    UNLOCK(\"UNLOCK\", Type.IDEMPOTENT),\n+    UPDATE(\"UPDATE\", Type.IDEMPOTENT),\n+    UPDATEREDIRECTREF(\"UPDATEREDIRECTREF\", Type.IDEMPOTENT),\n+    VERSION_CONTROL(\"VERSION-CONTROL\", Type.IDEMPOTENT),\n+\n+    // Other methods\n+    PROXY(\"PROXY\", Type.NORMAL);\n+\n+    // The type of the method\n+    private enum Type\n     {\n-        int length = limit - position;\n-        if (length < 4)\n-            return null;\n-        switch (bytes[position])\n-        {\n-            case 'G':\n-                if (bytes[position + 1] == 'E' && bytes[position + 2] == 'T' && bytes[position + 3] == ' ')\n-                    return GET;\n-                break;\n-            case 'P':\n-                if (bytes[position + 1] == 'O' && bytes[position + 2] == 'S' && bytes[position + 3] == 'T' && length >= 5 && bytes[position + 4] == ' ')\n-                    return POST;\n-                if (bytes[position + 1] == 'R' && bytes[position + 2] == 'O' && bytes[position + 3] == 'X' && length >= 6 && bytes[position + 4] == 'Y' && bytes[position + 5] == ' ')\n-                    return PROXY;\n-                if (bytes[position + 1] == 'U' && bytes[position + 2] == 'T' && bytes[position + 3] == ' ')\n-                    return PUT;\n-                if (bytes[position + 1] == 'R' && bytes[position + 2] == 'I' && bytes[position + 3] == ' ')\n-                    return PRI;\n-                break;\n-            case 'H':\n-                if (bytes[position + 1] == 'E' && bytes[position + 2] == 'A' && bytes[position + 3] == 'D' && length >= 5 && bytes[position + 4] == ' ')\n-                    return HEAD;\n-                break;\n-            case 'O':\n-                if (bytes[position + 1] == 'P' && bytes[position + 2] == 'T' && bytes[position + 3] == 'I' && length >= 8 &&\n-                    bytes[position + 4] == 'O' && bytes[position + 5] == 'N' && bytes[position + 6] == 'S' && bytes[position + 7] == ' ')\n-                    return OPTIONS;\n-                break;\n-            case 'D':\n-                if (bytes[position + 1] == 'E' && bytes[position + 2] == 'L' && bytes[position + 3] == 'E' && length >= 7 &&\n-                    bytes[position + 4] == 'T' && bytes[position + 5] == 'E' && bytes[position + 6] == ' ')\n-                    return DELETE;\n-                break;\n-            case 'T':\n-                if (bytes[position + 1] == 'R' && bytes[position + 2] == 'A' && bytes[position + 3] == 'C' && length >= 6 &&\n-                    bytes[position + 4] == 'E' && bytes[position + 5] == ' ')\n-                    return TRACE;\n-                break;\n-            case 'C':\n-                if (bytes[position + 1] == 'O' && bytes[position + 2] == 'N' && bytes[position + 3] == 'N' && length >= 8 &&\n-                    bytes[position + 4] == 'E' && bytes[position + 5] == 'C' && bytes[position + 6] == 'T' && bytes[position + 7] == ' ')\n-                    return CONNECT;\n-                break;\n-            case 'M':\n-                if (bytes[position + 1] == 'O' && bytes[position + 2] == 'V' && bytes[position + 3] == 'E' && length >= 5 && bytes[position + 4] == ' ')\n-                    return MOVE;\n-                break;\n-\n-            default:\n-                break;\n-        }\n-        return null;\n+        NORMAL,\n+        IDEMPOTENT,\n+        SAFE\n     }\n+    \n+    private final String _method;\n+    private final byte[] _bytes;\n+    private final ByteBuffer _buffer;\n+    private final Type _type;\n \n-    /**\n-     * Optimized lookup to find a method name and trailing space in a byte array.\n-     *\n-     * @param buffer buffer containing ISO-8859-1 characters, it is not modified.\n-     * @return An HttpMethod if a match or null if no easy match.\n-     */\n-    public static HttpMethod lookAheadGet(ByteBuffer buffer)\n+    HttpMethod(String method, Type type)\n     {\n-        if (buffer.hasArray())\n-            return lookAheadGet(buffer.array(), buffer.arrayOffset() + buffer.position(), buffer.arrayOffset() + buffer.limit());\n-\n-        int l = buffer.remaining();\n-        if (l >= 4)\n-        {\n-            HttpMethod m = CACHE.getBest(buffer, 0, l);\n-            if (m != null)\n-            {\n-                int ml = m.asString().length();\n-                if (l > ml && buffer.get(buffer.position() + ml) == ' ')\n-                    return m;\n-            }\n-        }\n-        return null;\n+        _method = method;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f1802a23eb91c650baf31938ecdada78c69c3b94"}, "originalPosition": 163}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3e94fae5e8c5c3c5e2c19515f8c3c61b5bcb3144", "author": {"user": {"login": "joakime", "name": "Joakim Erdfelt"}}, "url": "https://github.com/eclipse/jetty.project/commit/3e94fae5e8c5c3c5e2c19515f8c3c61b5bcb3144", "committedDate": "2020-11-06T15:26:58Z", "message": "Issue #5575 - simpler HttpMethod enum\n\nSigned-off-by: Joakim Erdfelt <joakim.erdfelt@gmail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5e062b5052ba75e25345cec3af516493d82b44f9", "author": {"user": {"login": "joakime", "name": "Joakim Erdfelt"}}, "url": "https://github.com/eclipse/jetty.project/commit/5e062b5052ba75e25345cec3af516493d82b44f9", "committedDate": "2020-11-06T21:05:42Z", "message": "Merge pull request #5578 from eclipse/jetty-9.4.x-5575-SEARCH-smaller\n\nIssue #5575 - simpler HttpMethod enum"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTI3MTc3MDgx", "url": "https://github.com/eclipse/jetty.project/pull/5576#pullrequestreview-527177081", "createdAt": "2020-11-10T13:01:01Z", "commit": {"oid": "5e062b5052ba75e25345cec3af516493d82b44f9"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMFQxMzowMTowMVrOHwbdXg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMFQxMzowMTowMVrOHwbdXg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDU0MzU4Mg==", "bodyText": "Is this really necessary?\nDoes this really produce any measurable performance improvement? (have you jmh'd this?)", "url": "https://github.com/eclipse/jetty.project/pull/5576#discussion_r520543582", "createdAt": "2020-11-10T13:01:01Z", "author": {"login": "joakime"}, "path": "jetty-http/src/main/java/org/eclipse/jetty/http/HttpMethod.java", "diffHunk": "@@ -26,162 +26,192 @@\n import org.eclipse.jetty.util.Trie;\n \n /**\n- *\n+ * Known HTTP Methods\n  */\n public enum HttpMethod\n {\n-    GET,\n-    POST,\n-    HEAD,\n-    PUT,\n-    OPTIONS,\n-    DELETE,\n-    TRACE,\n-    CONNECT,\n-    MOVE,\n-    PROXY,\n-    PRI;\n-\n-    /**\n-     * Optimized lookup to find a method name and trailing space in a byte array.\n-     *\n-     * @param bytes Array containing ISO-8859-1 characters\n-     * @param position The first valid index\n-     * @param limit The first non valid index\n-     * @return An HttpMethod if a match or null if no easy match.\n-     */\n-    public static HttpMethod lookAheadGet(byte[] bytes, final int position, int limit)\n+    // From https://www.iana.org/assignments/http-methods/http-methods.xhtml\n+    ACL(Type.IDEMPOTENT),\n+    BASELINE_CONTROL(Type.IDEMPOTENT),\n+    BIND(Type.IDEMPOTENT),\n+    CHECKIN(Type.IDEMPOTENT),\n+    CHECKOUT(Type.IDEMPOTENT),\n+    CONNECT(Type.NORMAL),\n+    COPY(Type.IDEMPOTENT),\n+    DELETE(Type.IDEMPOTENT),\n+    GET(Type.SAFE),\n+    HEAD(Type.SAFE),\n+    LABEL(Type.IDEMPOTENT),\n+    LINK(Type.IDEMPOTENT),\n+    LOCK(Type.NORMAL),\n+    MERGE(Type.IDEMPOTENT),\n+    MKACTIVITY(Type.IDEMPOTENT),\n+    MKCALENDAR(Type.IDEMPOTENT),\n+    MKCOL(Type.IDEMPOTENT),\n+    MKREDIRECTREF(Type.IDEMPOTENT),\n+    MKWORKSPACE(Type.IDEMPOTENT),\n+    MOVE(Type.IDEMPOTENT),\n+    OPTIONS(Type.SAFE),\n+    ORDERPATCH(Type.IDEMPOTENT),\n+    PATCH(Type.NORMAL),\n+    POST(Type.NORMAL),\n+    PRI(Type.SAFE),\n+    PROPFIND(Type.SAFE),\n+    PROPPATCH(Type.IDEMPOTENT),\n+    PUT(Type.IDEMPOTENT),\n+    REBIND(Type.IDEMPOTENT),\n+    REPORT(Type.SAFE),\n+    SEARCH(Type.SAFE),\n+    TRACE(Type.SAFE),\n+    UNBIND(Type.IDEMPOTENT),\n+    UNCHECKOUT(Type.IDEMPOTENT),\n+    UNLINK(Type.IDEMPOTENT),\n+    UNLOCK(Type.IDEMPOTENT),\n+    UPDATE(Type.IDEMPOTENT),\n+    UPDATEREDIRECTREF(Type.IDEMPOTENT),\n+    VERSION_CONTROL(Type.IDEMPOTENT),\n+\n+    // Other methods\n+    PROXY(Type.NORMAL);\n+\n+    // The type of the method\n+    private enum Type\n     {\n-        int length = limit - position;\n-        if (length < 4)\n-            return null;\n-        switch (bytes[position])\n-        {\n-            case 'G':\n-                if (bytes[position + 1] == 'E' && bytes[position + 2] == 'T' && bytes[position + 3] == ' ')\n-                    return GET;\n-                break;\n-            case 'P':\n-                if (bytes[position + 1] == 'O' && bytes[position + 2] == 'S' && bytes[position + 3] == 'T' && length >= 5 && bytes[position + 4] == ' ')\n-                    return POST;\n-                if (bytes[position + 1] == 'R' && bytes[position + 2] == 'O' && bytes[position + 3] == 'X' && length >= 6 && bytes[position + 4] == 'Y' && bytes[position + 5] == ' ')\n-                    return PROXY;\n-                if (bytes[position + 1] == 'U' && bytes[position + 2] == 'T' && bytes[position + 3] == ' ')\n-                    return PUT;\n-                if (bytes[position + 1] == 'R' && bytes[position + 2] == 'I' && bytes[position + 3] == ' ')\n-                    return PRI;\n-                break;\n-            case 'H':\n-                if (bytes[position + 1] == 'E' && bytes[position + 2] == 'A' && bytes[position + 3] == 'D' && length >= 5 && bytes[position + 4] == ' ')\n-                    return HEAD;\n-                break;\n-            case 'O':\n-                if (bytes[position + 1] == 'P' && bytes[position + 2] == 'T' && bytes[position + 3] == 'I' && length >= 8 &&\n-                    bytes[position + 4] == 'O' && bytes[position + 5] == 'N' && bytes[position + 6] == 'S' && bytes[position + 7] == ' ')\n-                    return OPTIONS;\n-                break;\n-            case 'D':\n-                if (bytes[position + 1] == 'E' && bytes[position + 2] == 'L' && bytes[position + 3] == 'E' && length >= 7 &&\n-                    bytes[position + 4] == 'T' && bytes[position + 5] == 'E' && bytes[position + 6] == ' ')\n-                    return DELETE;\n-                break;\n-            case 'T':\n-                if (bytes[position + 1] == 'R' && bytes[position + 2] == 'A' && bytes[position + 3] == 'C' && length >= 6 &&\n-                    bytes[position + 4] == 'E' && bytes[position + 5] == ' ')\n-                    return TRACE;\n-                break;\n-            case 'C':\n-                if (bytes[position + 1] == 'O' && bytes[position + 2] == 'N' && bytes[position + 3] == 'N' && length >= 8 &&\n-                    bytes[position + 4] == 'E' && bytes[position + 5] == 'C' && bytes[position + 6] == 'T' && bytes[position + 7] == ' ')\n-                    return CONNECT;\n-                break;\n-            case 'M':\n-                if (bytes[position + 1] == 'O' && bytes[position + 2] == 'V' && bytes[position + 3] == 'E' && length >= 5 && bytes[position + 4] == ' ')\n-                    return MOVE;\n-                break;\n-\n-            default:\n-                break;\n-        }\n-        return null;\n+        NORMAL,\n+        IDEMPOTENT,\n+        SAFE\n     }\n \n-    /**\n-     * Optimized lookup to find a method name and trailing space in a byte array.\n-     *\n-     * @param buffer buffer containing ISO-8859-1 characters, it is not modified.\n-     * @return An HttpMethod if a match or null if no easy match.\n-     */\n-    public static HttpMethod lookAheadGet(ByteBuffer buffer)\n-    {\n-        if (buffer.hasArray())\n-            return lookAheadGet(buffer.array(), buffer.arrayOffset() + buffer.position(), buffer.arrayOffset() + buffer.limit());\n+    private final String _method;\n+    private final byte[] _bytes;\n+    private final ByteBuffer _buffer;\n+    private final Type _type;\n \n-        int l = buffer.remaining();\n-        if (l >= 4)\n-        {\n-            HttpMethod m = CACHE.getBest(buffer, 0, l);\n-            if (m != null)\n-            {\n-                int ml = m.asString().length();\n-                if (l > ml && buffer.get(buffer.position() + ml) == ' ')\n-                    return m;\n-            }\n-        }\n-        return null;\n+    HttpMethod(Type type)\n+    {\n+        _method = name().replace('_', '-');\n+        _type = type;\n+        _bytes = StringUtil.getBytes(_method);\n+        _buffer = ByteBuffer.wrap(_bytes);\n     }\n \n-    public static final Trie<HttpMethod> INSENSITIVE_CACHE = new ArrayTrie<>();\n+    public byte[] getBytes()\n+    {\n+        return _bytes;\n+    }\n \n-    static\n+    public boolean is(String s)\n     {\n-        for (HttpMethod method : HttpMethod.values())\n-        {\n-            INSENSITIVE_CACHE.put(method.toString(), method);\n-        }\n+        return toString().equalsIgnoreCase(s);\n     }\n \n-    public static final Trie<HttpMethod> CACHE = new ArrayTernaryTrie<>(false);\n+    /**\n+     * An HTTP method is safe if it doesn't alter the state of the server.\n+     * In other words, a method is safe if it leads to a read-only operation.\n+     * Several common HTTP methods are safe: GET , HEAD , or OPTIONS .\n+     * All safe methods are also idempotent, but not all idempotent methods are safe\n+     * @return if the method is safe.\n+     */\n+    public boolean isSafe()\n+    {\n+        return _type == Type.SAFE;\n+    }\n \n-    static\n+    /**\n+     * An idempotent HTTP method is an HTTP method that can be called many times without different outcomes.\n+     * It would not matter if the method is called only once, or ten times over. The result should be the same.\n+     * @return true if the method is idempotent.\n+     */\n+    public boolean isIdempotent()\n     {\n-        for (HttpMethod method : HttpMethod.values())\n-        {\n-            CACHE.put(method.toString(), method);\n-        }\n+        return _type.ordinal() >= Type.IDEMPOTENT.ordinal();\n     }\n \n-    private final ByteBuffer _buffer;\n-    private final byte[] _bytes;\n+    public ByteBuffer asBuffer()\n+    {\n+        return _buffer.asReadOnlyBuffer();\n+    }\n \n-    HttpMethod()\n+    public String asString()\n     {\n-        _bytes = StringUtil.getBytes(toString());\n-        _buffer = ByteBuffer.wrap(_bytes);\n+        return _method;\n     }\n \n-    public byte[] getBytes()\n+    public String toString()\n     {\n-        return _bytes;\n+        return _method;\n     }\n \n-    public boolean is(String s)\n+    public static final Trie<HttpMethod> INSENSITIVE_CACHE = new ArrayTrie<>(252);\n+    public static final Trie<HttpMethod> CACHE = new ArrayTernaryTrie<>(false, 300);\n+    public static final Trie<HttpMethod> LOOK_AHEAD = new ArrayTernaryTrie<>(false, 330);\n+    private static final int ACL_AS_INT = ('A' & 0xff) << 24 | ('C' & 0xFF) << 16 | ('L' & 0xFF) << 8 | (' ' & 0xFF);\n+    private static final int GET_AS_INT = ('G' & 0xff) << 24 | ('E' & 0xFF) << 16 | ('T' & 0xFF) << 8 | (' ' & 0xFF);\n+    private static final int PRI_AS_INT = ('P' & 0xff) << 24 | ('R' & 0xFF) << 16 | ('I' & 0xFF) << 8 | (' ' & 0xFF);\n+    private static final int PUT_AS_INT = ('P' & 0xff) << 24 | ('U' & 0xFF) << 16 | ('T' & 0xFF) << 8 | (' ' & 0xFF);\n+    static\n     {\n-        return toString().equalsIgnoreCase(s);\n+        for (HttpMethod method : HttpMethod.values())\n+        {\n+            if (!INSENSITIVE_CACHE.put(method.asString(), method))\n+                throw new IllegalStateException(\"INSENSITIVE_CACHE too small: \" + method);\n+\n+            if (!CACHE.put(method.asString(), method))\n+                throw new IllegalStateException(\"CACHE too small: \" + method);\n+\n+            if (!LOOK_AHEAD.put(method.asString() + ' ', method))\n+                throw new IllegalStateException(\"LOOK_AHEAD too small: \" + method);\n+        }\n     }\n \n-    public ByteBuffer asBuffer()\n+    /**\n+     * Optimized lookup to find a method name and trailing space in a byte array.\n+     *\n+     * @param bytes Array containing ISO-8859-1 characters\n+     * @param position The first valid index\n+     * @param limit The first non valid index\n+     * @return An HttpMethod if a match or null if no easy match.\n+     * @deprecated Not used\n+     */\n+    @Deprecated\n+    public static HttpMethod lookAheadGet(byte[] bytes, final int position, int limit)\n     {\n-        return _buffer.asReadOnlyBuffer();\n+        return LOOK_AHEAD.getBest(bytes, position, limit - position);\n     }\n \n-    public String asString()\n+    /**\n+     * Optimized lookup to find a method name and trailing space in a byte array.\n+     *\n+     * @param buffer buffer containing ISO-8859-1 characters, it is not modified.\n+     * @return An HttpMethod if a match or null if no easy match.\n+     */\n+    public static HttpMethod lookAheadGet(ByteBuffer buffer)\n     {\n-        return toString();\n+        int len = buffer.remaining();\n+        // Short cut for 3 char methods, mostly for GET optimisation\n+        if (len > 3)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5e062b5052ba75e25345cec3af516493d82b44f9"}, "originalPosition": 288}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTI3MjkzNzkx", "url": "https://github.com/eclipse/jetty.project/pull/5576#pullrequestreview-527293791", "createdAt": "2020-11-10T15:03:04Z", "commit": {"oid": "5e062b5052ba75e25345cec3af516493d82b44f9"}, "state": "COMMENTED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "bf98ae26e74c7b166892c24dab0f28cd7221f5cb", "author": {"user": {"login": "gregw", "name": "Greg Wilkins"}}, "url": "https://github.com/eclipse/jetty.project/commit/bf98ae26e74c7b166892c24dab0f28cd7221f5cb", "committedDate": "2020-11-10T17:31:53Z", "message": "Update from review\n\n + added benchmark\n + optimised POST and HEAD"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTI4MDM0MDc4", "url": "https://github.com/eclipse/jetty.project/pull/5576#pullrequestreview-528034078", "createdAt": "2020-11-11T10:09:57Z", "commit": {"oid": "bf98ae26e74c7b166892c24dab0f28cd7221f5cb"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTI4MzEyMzI0", "url": "https://github.com/eclipse/jetty.project/pull/5576#pullrequestreview-528312324", "createdAt": "2020-11-11T16:06:54Z", "commit": {"oid": "bf98ae26e74c7b166892c24dab0f28cd7221f5cb"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3, "cost": 1, "resetAt": "2021-11-01T13:51:04Z"}}}