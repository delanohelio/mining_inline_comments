{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDI4NjE3NzQx", "number": 4946, "title": "Jetty 9.4.x 4855 h2spec failures", "bodyText": "The bulk of the fix is in 8d60636.", "createdAt": "2020-06-05T17:49:02Z", "url": "https://github.com/eclipse/jetty.project/pull/4946", "merged": true, "mergeCommit": {"oid": "56bda1b3aee0cb02fb6031fab64dacd864674547"}, "closed": true, "closedAt": "2020-06-09T11:15:06Z", "author": {"login": "sbordet"}, "timelineItems": {"totalCount": 17, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcoV_j0gH2gAyNDI4NjE3NzQxOmU3MjE3MTdiM2MyNDkyODE5NTU3NzA4Y2FkMjljZThkMDYzODA5Y2Q=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcpiHIGAH2gAyNDI4NjE3NzQxOjI2YWQ1ODU3ZThkNThlYTI4ZWZjOTFiNWUxOTY2ZDAyZTYwZDMzZjY=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "e721717b3c2492819557708cad29ce8d063809cd", "author": {"user": {"login": "sbordet", "name": "Simone Bordet"}}, "url": "https://github.com/eclipse/jetty.project/commit/e721717b3c2492819557708cad29ce8d063809cd", "committedDate": "2020-06-05T17:20:29Z", "message": "Issue #4855 - Occasional h2spec failures on CI\n\nCode cleanups.\n\nSigned-off-by: Simone Bordet <simone.bordet@gmail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "fd053aae0962002000ea994e49005441ec945761", "author": {"user": {"login": "sbordet", "name": "Simone Bordet"}}, "url": "https://github.com/eclipse/jetty.project/commit/fd053aae0962002000ea994e49005441ec945761", "committedDate": "2020-06-05T17:27:48Z", "message": "Issue #4855 - Occasional h2spec failures on CI\n\nIn case of bad usage of the API, we don't want to close()\nthe stream but just fail the callback, because the stream\nmay be performing actions triggered by a legit API usage.\n\nSigned-off-by: Simone Bordet <simone.bordet@gmail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9dec284cc2afeeb49d3f4fce4a0656d8d98c6d48", "author": {"user": {"login": "sbordet", "name": "Simone Bordet"}}, "url": "https://github.com/eclipse/jetty.project/commit/9dec284cc2afeeb49d3f4fce4a0656d8d98c6d48", "committedDate": "2020-06-05T17:31:32Z", "message": "Issue #4855 - Occasional h2spec failures on CI\n\nIn case of a call to `AsyncListener.onError()`, applications may decide to call\nAsyncContext.complete() and that would be a correct usage of the Servlet API.\n\nThis case was not well handled and was wrongly producing a WARN log with an\n`IllegalStateException`.\n\nSigned-off-by: Simone Bordet <simone.bordet@gmail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8d606368297183bb89bd309e38772b6c2a47aa5f", "author": {"user": {"login": "sbordet", "name": "Simone Bordet"}}, "url": "https://github.com/eclipse/jetty.project/commit/8d606368297183bb89bd309e38772b6c2a47aa5f", "committedDate": "2020-06-05T17:46:22Z", "message": "Fixes #4855 - Occasional h2spec failures on CI\n\nCompletely rewritten `HttpTransportOverHTTP2.TransportCallback`.\nThe rewrite handles correctly asynchronous failures that now are executed\nsequentially (and not concurrently) with writes.\nIf a write is in progress, the failure will just change the state and at the\nend of the write a check on the state will determine what actions to take.\n\nA session failure is now handled in HTTP2Session by first failing all the\nstreams - which notifies the Stream.Listeners - and then failing the session\n- which notifies the Session.Listener.\nThe stream failures are executed concurrently by dispatching each one to a\ndifferent thread; this means that the stream failure callbacks are executed\nconcurrently (likely sending RST_STREAM frames).\nThe session failure callback is completed only when all the stream failure\ncallbacks have completed, to ensure that a GOAWAY frame is processed after\nall the RST_STREAM frames.\n\nSigned-off-by: Simone Bordet <simone.bordet@gmail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "82529e614f71fbc36d9212377376a33f2d4220f0", "author": {"user": {"login": "sbordet", "name": "Simone Bordet"}}, "url": "https://github.com/eclipse/jetty.project/commit/82529e614f71fbc36d9212377376a33f2d4220f0", "committedDate": "2020-06-05T20:48:02Z", "message": "Issue #4855 - Occasional h2spec failures on CI\n\nFixed notification of HTTP2Session.abort(), that must fail all the streams\nbefore failing the session.\n\nSigned-off-by: Simone Bordet <simone.bordet@gmail.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI1OTQ3MDYw", "url": "https://github.com/eclipse/jetty.project/pull/4946#pullrequestreview-425947060", "createdAt": "2020-06-08T06:37:03Z", "commit": {"oid": "8d606368297183bb89bd309e38772b6c2a47aa5f"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOFQwNjozNzowM1rOGgQy2Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOFQwNjozNzowM1rOGgQy2Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQ4Mjc3Nw==", "bodyText": "Is this method still required?  It doesn't override any contract?", "url": "https://github.com/eclipse/jetty.project/pull/4946#discussion_r436482777", "createdAt": "2020-06-08T06:37:03Z", "author": {"login": "gregw"}, "path": "jetty-http2/http2-server/src/main/java/org/eclipse/jetty/http2/server/HTTP2ServerConnection.java", "diffHunk": "@@ -245,22 +246,10 @@ public boolean onSessionTimeout(Throwable failure)\n \n     public void onSessionFailure(Throwable failure, Callback callback)\n     {\n-        ISession session = getSession();\n         if (LOG.isDebugEnabled())\n-            LOG.debug(\"Processing failure on {}: {}\", session, failure);\n-        Collection<Stream> streams = session.getStreams();\n-        if (streams.isEmpty())\n-        {\n-            callback.succeeded();\n-        }\n-        else\n-        {\n-            CountingCallback counter = new CountingCallback(callback, streams.size());\n-            for (Stream stream : streams)\n-            {\n-                onStreamFailure((IStream)stream, failure, counter);\n-            }\n-        }\n+            LOG.debug(\"Processing session failure on {}\", getSession(), failure);\n+        // All the streams have already been failed, just succeed the callback.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8d606368297183bb89bd309e38772b6c2a47aa5f"}, "originalPosition": 57}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI1OTQ3OTQz", "url": "https://github.com/eclipse/jetty.project/pull/4946#pullrequestreview-425947943", "createdAt": "2020-06-08T06:38:58Z", "commit": {"oid": "8d606368297183bb89bd309e38772b6c2a47aa5f"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOFQwNjozODo1OVrOGgQ1wQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOFQwNjo0Mzo0NFrOGgQ8bA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQ4MzUyMQ==", "bodyText": "Some comments on how we could get to these states between preSend and postSend would be good.", "url": "https://github.com/eclipse/jetty.project/pull/4946#discussion_r436483521", "createdAt": "2020-06-08T06:38:59Z", "author": {"login": "gregw"}, "path": "jetty-http2/http2-server/src/main/java/org/eclipse/jetty/http2/server/HttpTransportOverHTTP2.java", "diffHunk": "@@ -352,117 +353,259 @@ public void abort(Throwable failure)\n \n     private class TransportCallback implements Callback\n     {\n-        private State state = State.IDLE;\n-        private Callback callback;\n-        private Throwable failure;\n-        private boolean commit;\n+        private State _state = State.IDLE;\n+        private Callback _callback;\n+        private boolean _commit;\n+        private Throwable _failure;\n \n-        public boolean start(Callback callback, boolean commit)\n+        private void reset()\n         {\n-            State state;\n+            assert Thread.holdsLock(this);\n+            _state = State.IDLE;\n+            _callback = null;\n+            _commit = false;\n+            _failure = null;\n+        }\n+\n+        private void send(Callback callback, boolean commit, Consumer<Callback> consumer)\n+        {\n+            Throwable failure = preSend(callback, commit);\n+            if (failure == null)\n+            {\n+                consumer.accept(this);\n+                postSend();\n+            }\n+            else\n+            {\n+                callback.failed(failure);\n+            }\n+        }\n+\n+        private Throwable preSend(Callback callback, boolean commit)\n+        {\n+            synchronized (this)\n+            {\n+                switch (_state)\n+                {\n+                    case IDLE:\n+                    {\n+                        _state = State.PRE_SEND;\n+                        _callback = callback;\n+                        _commit = commit;\n+                        return null;\n+                    }\n+                    default:\n+                    {\n+                        Throwable failure = _failure;\n+                        if (failure == null)\n+                            failure = new IllegalStateException(\"Invalid transport state: \" + _state);\n+                        return failure;\n+                    }\n+                }\n+            }\n+        }\n+\n+        private void postSend()\n+        {\n+            Callback callback;\n+            boolean commit;\n             Throwable failure;\n             synchronized (this)\n             {\n-                state = this.state;\n-                failure = this.failure;\n-                if (state == State.IDLE)\n+                switch (_state)\n                 {\n-                    this.state = State.WRITING;\n-                    this.callback = callback;\n-                    this.commit = commit;\n-                    return true;\n+                    case PRE_SEND:\n+                    {\n+                        _state = State.POST_SEND;\n+                        return;\n+                    }\n+                    case SUCCEED:\n+                    {\n+                        callback = _callback;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8d606368297183bb89bd309e38772b6c2a47aa5f"}, "originalPosition": 202}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQ4NDAxNQ==", "bodyText": "Why does SUCCEED just remember stuff while this one moves the state on? Comments needed", "url": "https://github.com/eclipse/jetty.project/pull/4946#discussion_r436484015", "createdAt": "2020-06-08T06:40:16Z", "author": {"login": "gregw"}, "path": "jetty-http2/http2-server/src/main/java/org/eclipse/jetty/http2/server/HttpTransportOverHTTP2.java", "diffHunk": "@@ -352,117 +353,259 @@ public void abort(Throwable failure)\n \n     private class TransportCallback implements Callback\n     {\n-        private State state = State.IDLE;\n-        private Callback callback;\n-        private Throwable failure;\n-        private boolean commit;\n+        private State _state = State.IDLE;\n+        private Callback _callback;\n+        private boolean _commit;\n+        private Throwable _failure;\n \n-        public boolean start(Callback callback, boolean commit)\n+        private void reset()\n         {\n-            State state;\n+            assert Thread.holdsLock(this);\n+            _state = State.IDLE;\n+            _callback = null;\n+            _commit = false;\n+            _failure = null;\n+        }\n+\n+        private void send(Callback callback, boolean commit, Consumer<Callback> consumer)\n+        {\n+            Throwable failure = preSend(callback, commit);\n+            if (failure == null)\n+            {\n+                consumer.accept(this);\n+                postSend();\n+            }\n+            else\n+            {\n+                callback.failed(failure);\n+            }\n+        }\n+\n+        private Throwable preSend(Callback callback, boolean commit)\n+        {\n+            synchronized (this)\n+            {\n+                switch (_state)\n+                {\n+                    case IDLE:\n+                    {\n+                        _state = State.PRE_SEND;\n+                        _callback = callback;\n+                        _commit = commit;\n+                        return null;\n+                    }\n+                    default:\n+                    {\n+                        Throwable failure = _failure;\n+                        if (failure == null)\n+                            failure = new IllegalStateException(\"Invalid transport state: \" + _state);\n+                        return failure;\n+                    }\n+                }\n+            }\n+        }\n+\n+        private void postSend()\n+        {\n+            Callback callback;\n+            boolean commit;\n             Throwable failure;\n             synchronized (this)\n             {\n-                state = this.state;\n-                failure = this.failure;\n-                if (state == State.IDLE)\n+                switch (_state)\n                 {\n-                    this.state = State.WRITING;\n-                    this.callback = callback;\n-                    this.commit = commit;\n-                    return true;\n+                    case PRE_SEND:\n+                    {\n+                        _state = State.POST_SEND;\n+                        return;\n+                    }\n+                    case SUCCEED:\n+                    {\n+                        callback = _callback;\n+                        commit = _commit;\n+                        failure = null;\n+                        reset();\n+                        break;\n+                    }\n+                    case FAIL:\n+                    {\n+                        _state = State.FAILED;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8d606368297183bb89bd309e38772b6c2a47aa5f"}, "originalPosition": 210}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQ4NDM0OA==", "bodyText": "should _commit be nulled so we know we can only call it once?", "url": "https://github.com/eclipse/jetty.project/pull/4946#discussion_r436484348", "createdAt": "2020-06-08T06:41:15Z", "author": {"login": "gregw"}, "path": "jetty-http2/http2-server/src/main/java/org/eclipse/jetty/http2/server/HttpTransportOverHTTP2.java", "diffHunk": "@@ -352,117 +353,259 @@ public void abort(Throwable failure)\n \n     private class TransportCallback implements Callback\n     {\n-        private State state = State.IDLE;\n-        private Callback callback;\n-        private Throwable failure;\n-        private boolean commit;\n+        private State _state = State.IDLE;\n+        private Callback _callback;\n+        private boolean _commit;\n+        private Throwable _failure;\n \n-        public boolean start(Callback callback, boolean commit)\n+        private void reset()\n         {\n-            State state;\n+            assert Thread.holdsLock(this);\n+            _state = State.IDLE;\n+            _callback = null;\n+            _commit = false;\n+            _failure = null;\n+        }\n+\n+        private void send(Callback callback, boolean commit, Consumer<Callback> consumer)\n+        {\n+            Throwable failure = preSend(callback, commit);\n+            if (failure == null)\n+            {\n+                consumer.accept(this);\n+                postSend();\n+            }\n+            else\n+            {\n+                callback.failed(failure);\n+            }\n+        }\n+\n+        private Throwable preSend(Callback callback, boolean commit)\n+        {\n+            synchronized (this)\n+            {\n+                switch (_state)\n+                {\n+                    case IDLE:\n+                    {\n+                        _state = State.PRE_SEND;\n+                        _callback = callback;\n+                        _commit = commit;\n+                        return null;\n+                    }\n+                    default:\n+                    {\n+                        Throwable failure = _failure;\n+                        if (failure == null)\n+                            failure = new IllegalStateException(\"Invalid transport state: \" + _state);\n+                        return failure;\n+                    }\n+                }\n+            }\n+        }\n+\n+        private void postSend()\n+        {\n+            Callback callback;\n+            boolean commit;\n             Throwable failure;\n             synchronized (this)\n             {\n-                state = this.state;\n-                failure = this.failure;\n-                if (state == State.IDLE)\n+                switch (_state)\n                 {\n-                    this.state = State.WRITING;\n-                    this.callback = callback;\n-                    this.commit = commit;\n-                    return true;\n+                    case PRE_SEND:\n+                    {\n+                        _state = State.POST_SEND;\n+                        return;\n+                    }\n+                    case SUCCEED:\n+                    {\n+                        callback = _callback;\n+                        commit = _commit;\n+                        failure = null;\n+                        reset();\n+                        break;\n+                    }\n+                    case FAIL:\n+                    {\n+                        _state = State.FAILED;\n+                        callback = _callback;\n+                        commit = _commit;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8d606368297183bb89bd309e38772b6c2a47aa5f"}, "originalPosition": 212}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQ4NDY3Ng==", "bodyText": "what if callback is null?  I think it is an ISE, so that should be explicitly thrown", "url": "https://github.com/eclipse/jetty.project/pull/4946#discussion_r436484676", "createdAt": "2020-06-08T06:42:10Z", "author": {"login": "gregw"}, "path": "jetty-http2/http2-server/src/main/java/org/eclipse/jetty/http2/server/HttpTransportOverHTTP2.java", "diffHunk": "@@ -352,117 +353,259 @@ public void abort(Throwable failure)\n \n     private class TransportCallback implements Callback\n     {\n-        private State state = State.IDLE;\n-        private Callback callback;\n-        private Throwable failure;\n-        private boolean commit;\n+        private State _state = State.IDLE;\n+        private Callback _callback;\n+        private boolean _commit;\n+        private Throwable _failure;\n \n-        public boolean start(Callback callback, boolean commit)\n+        private void reset()\n         {\n-            State state;\n+            assert Thread.holdsLock(this);\n+            _state = State.IDLE;\n+            _callback = null;\n+            _commit = false;\n+            _failure = null;\n+        }\n+\n+        private void send(Callback callback, boolean commit, Consumer<Callback> consumer)\n+        {\n+            Throwable failure = preSend(callback, commit);\n+            if (failure == null)\n+            {\n+                consumer.accept(this);\n+                postSend();\n+            }\n+            else\n+            {\n+                callback.failed(failure);\n+            }\n+        }\n+\n+        private Throwable preSend(Callback callback, boolean commit)\n+        {\n+            synchronized (this)\n+            {\n+                switch (_state)\n+                {\n+                    case IDLE:\n+                    {\n+                        _state = State.PRE_SEND;\n+                        _callback = callback;\n+                        _commit = commit;\n+                        return null;\n+                    }\n+                    default:\n+                    {\n+                        Throwable failure = _failure;\n+                        if (failure == null)\n+                            failure = new IllegalStateException(\"Invalid transport state: \" + _state);\n+                        return failure;\n+                    }\n+                }\n+            }\n+        }\n+\n+        private void postSend()\n+        {\n+            Callback callback;\n+            boolean commit;\n             Throwable failure;\n             synchronized (this)\n             {\n-                state = this.state;\n-                failure = this.failure;\n-                if (state == State.IDLE)\n+                switch (_state)\n                 {\n-                    this.state = State.WRITING;\n-                    this.callback = callback;\n-                    this.commit = commit;\n-                    return true;\n+                    case PRE_SEND:\n+                    {\n+                        _state = State.POST_SEND;\n+                        return;\n+                    }\n+                    case SUCCEED:\n+                    {\n+                        callback = _callback;\n+                        commit = _commit;\n+                        failure = null;\n+                        reset();\n+                        break;\n+                    }\n+                    case FAIL:\n+                    {\n+                        _state = State.FAILED;\n+                        callback = _callback;\n+                        commit = _commit;\n+                        failure = _failure;\n+                        break;\n+                    }\n+                    default:\n+                    {\n+                        _state = State.FAILED;\n+                        _failure = new IllegalStateException(\"Invalid transport state: \" + _state);\n+                        callback = _callback;\n+                        commit = _commit;\n+                        failure = _failure;\n+                        break;\n+                    }\n                 }\n             }\n             if (failure == null)\n-                failure = new IllegalStateException(\"Invalid transport state: \" + state);\n-            callback.failed(failure);\n-            return false;\n+                succeed(callback, commit);\n+            else\n+                fail(callback, commit, failure);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8d606368297183bb89bd309e38772b6c2a47aa5f"}, "originalPosition": 233}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQ4NTA4OQ==", "bodyText": "comment", "url": "https://github.com/eclipse/jetty.project/pull/4946#discussion_r436485089", "createdAt": "2020-06-08T06:43:18Z", "author": {"login": "gregw"}, "path": "jetty-http2/http2-server/src/main/java/org/eclipse/jetty/http2/server/HttpTransportOverHTTP2.java", "diffHunk": "@@ -352,117 +353,259 @@ public void abort(Throwable failure)\n \n     private class TransportCallback implements Callback\n     {\n-        private State state = State.IDLE;\n-        private Callback callback;\n-        private Throwable failure;\n-        private boolean commit;\n+        private State _state = State.IDLE;\n+        private Callback _callback;\n+        private boolean _commit;\n+        private Throwable _failure;\n \n-        public boolean start(Callback callback, boolean commit)\n+        private void reset()\n         {\n-            State state;\n+            assert Thread.holdsLock(this);\n+            _state = State.IDLE;\n+            _callback = null;\n+            _commit = false;\n+            _failure = null;\n+        }\n+\n+        private void send(Callback callback, boolean commit, Consumer<Callback> consumer)\n+        {\n+            Throwable failure = preSend(callback, commit);\n+            if (failure == null)\n+            {\n+                consumer.accept(this);\n+                postSend();\n+            }\n+            else\n+            {\n+                callback.failed(failure);\n+            }\n+        }\n+\n+        private Throwable preSend(Callback callback, boolean commit)\n+        {\n+            synchronized (this)\n+            {\n+                switch (_state)\n+                {\n+                    case IDLE:\n+                    {\n+                        _state = State.PRE_SEND;\n+                        _callback = callback;\n+                        _commit = commit;\n+                        return null;\n+                    }\n+                    default:\n+                    {\n+                        Throwable failure = _failure;\n+                        if (failure == null)\n+                            failure = new IllegalStateException(\"Invalid transport state: \" + _state);\n+                        return failure;\n+                    }\n+                }\n+            }\n+        }\n+\n+        private void postSend()\n+        {\n+            Callback callback;\n+            boolean commit;\n             Throwable failure;\n             synchronized (this)\n             {\n-                state = this.state;\n-                failure = this.failure;\n-                if (state == State.IDLE)\n+                switch (_state)\n                 {\n-                    this.state = State.WRITING;\n-                    this.callback = callback;\n-                    this.commit = commit;\n-                    return true;\n+                    case PRE_SEND:\n+                    {\n+                        _state = State.POST_SEND;\n+                        return;\n+                    }\n+                    case SUCCEED:\n+                    {\n+                        callback = _callback;\n+                        commit = _commit;\n+                        failure = null;\n+                        reset();\n+                        break;\n+                    }\n+                    case FAIL:\n+                    {\n+                        _state = State.FAILED;\n+                        callback = _callback;\n+                        commit = _commit;\n+                        failure = _failure;\n+                        break;\n+                    }\n+                    default:\n+                    {\n+                        _state = State.FAILED;\n+                        _failure = new IllegalStateException(\"Invalid transport state: \" + _state);\n+                        callback = _callback;\n+                        commit = _commit;\n+                        failure = _failure;\n+                        break;\n+                    }\n                 }\n             }\n             if (failure == null)\n-                failure = new IllegalStateException(\"Invalid transport state: \" + state);\n-            callback.failed(failure);\n-            return false;\n+                succeed(callback, commit);\n+            else\n+                fail(callback, commit, failure);\n         }\n \n         @Override\n         public void succeeded()\n         {\n+            Callback callback;\n             boolean commit;\n-            Callback callback = null;\n             synchronized (this)\n             {\n-                commit = this.commit;\n-                if (state == State.WRITING)\n+                switch (_state)\n                 {\n-                    this.state = State.IDLE;\n-                    callback = this.callback;\n-                    this.callback = null;\n-                    this.commit = false;\n+                    case PRE_SEND:\n+                    {\n+                        _state = State.SUCCEED;\n+                        // Succeeding the callback will be done in postSend().\n+                        return;\n+                    }\n+                    case POST_SEND:\n+                    {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8d606368297183bb89bd309e38772b6c2a47aa5f"}, "originalPosition": 259}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQ4NTIyOA==", "bodyText": "the race with whom?", "url": "https://github.com/eclipse/jetty.project/pull/4946#discussion_r436485228", "createdAt": "2020-06-08T06:43:44Z", "author": {"login": "gregw"}, "path": "jetty-http2/http2-server/src/main/java/org/eclipse/jetty/http2/server/HttpTransportOverHTTP2.java", "diffHunk": "@@ -352,117 +353,259 @@ public void abort(Throwable failure)\n \n     private class TransportCallback implements Callback\n     {\n-        private State state = State.IDLE;\n-        private Callback callback;\n-        private Throwable failure;\n-        private boolean commit;\n+        private State _state = State.IDLE;\n+        private Callback _callback;\n+        private boolean _commit;\n+        private Throwable _failure;\n \n-        public boolean start(Callback callback, boolean commit)\n+        private void reset()\n         {\n-            State state;\n+            assert Thread.holdsLock(this);\n+            _state = State.IDLE;\n+            _callback = null;\n+            _commit = false;\n+            _failure = null;\n+        }\n+\n+        private void send(Callback callback, boolean commit, Consumer<Callback> consumer)\n+        {\n+            Throwable failure = preSend(callback, commit);\n+            if (failure == null)\n+            {\n+                consumer.accept(this);\n+                postSend();\n+            }\n+            else\n+            {\n+                callback.failed(failure);\n+            }\n+        }\n+\n+        private Throwable preSend(Callback callback, boolean commit)\n+        {\n+            synchronized (this)\n+            {\n+                switch (_state)\n+                {\n+                    case IDLE:\n+                    {\n+                        _state = State.PRE_SEND;\n+                        _callback = callback;\n+                        _commit = commit;\n+                        return null;\n+                    }\n+                    default:\n+                    {\n+                        Throwable failure = _failure;\n+                        if (failure == null)\n+                            failure = new IllegalStateException(\"Invalid transport state: \" + _state);\n+                        return failure;\n+                    }\n+                }\n+            }\n+        }\n+\n+        private void postSend()\n+        {\n+            Callback callback;\n+            boolean commit;\n             Throwable failure;\n             synchronized (this)\n             {\n-                state = this.state;\n-                failure = this.failure;\n-                if (state == State.IDLE)\n+                switch (_state)\n                 {\n-                    this.state = State.WRITING;\n-                    this.callback = callback;\n-                    this.commit = commit;\n-                    return true;\n+                    case PRE_SEND:\n+                    {\n+                        _state = State.POST_SEND;\n+                        return;\n+                    }\n+                    case SUCCEED:\n+                    {\n+                        callback = _callback;\n+                        commit = _commit;\n+                        failure = null;\n+                        reset();\n+                        break;\n+                    }\n+                    case FAIL:\n+                    {\n+                        _state = State.FAILED;\n+                        callback = _callback;\n+                        commit = _commit;\n+                        failure = _failure;\n+                        break;\n+                    }\n+                    default:\n+                    {\n+                        _state = State.FAILED;\n+                        _failure = new IllegalStateException(\"Invalid transport state: \" + _state);\n+                        callback = _callback;\n+                        commit = _commit;\n+                        failure = _failure;\n+                        break;\n+                    }\n                 }\n             }\n             if (failure == null)\n-                failure = new IllegalStateException(\"Invalid transport state: \" + state);\n-            callback.failed(failure);\n-            return false;\n+                succeed(callback, commit);\n+            else\n+                fail(callback, commit, failure);\n         }\n \n         @Override\n         public void succeeded()\n         {\n+            Callback callback;\n             boolean commit;\n-            Callback callback = null;\n             synchronized (this)\n             {\n-                commit = this.commit;\n-                if (state == State.WRITING)\n+                switch (_state)\n                 {\n-                    this.state = State.IDLE;\n-                    callback = this.callback;\n-                    this.callback = null;\n-                    this.commit = false;\n+                    case PRE_SEND:\n+                    {\n+                        _state = State.SUCCEED;\n+                        // Succeeding the callback will be done in postSend().\n+                        return;\n+                    }\n+                    case POST_SEND:\n+                    {\n+                        callback = _callback;\n+                        commit = _commit;\n+                        reset();\n+                        break;\n+                    }\n+                    default:\n+                    {\n+                        // The race to succeed was lost and other states", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8d606368297183bb89bd309e38772b6c2a47aa5f"}, "originalPosition": 267}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "42a5d2785b51f06e3440bbcf4a4d845b5f8bc5e1", "author": {"user": {"login": "sbordet", "name": "Simone Bordet"}}, "url": "https://github.com/eclipse/jetty.project/commit/42a5d2785b51f06e3440bbcf4a4d845b5f8bc5e1", "committedDate": "2020-06-08T08:37:37Z", "message": "Issue #4855 - Occasional h2spec failures on CI\n\nAdded javadocs after review.\n\nSigned-off-by: Simone Bordet <simone.bordet@gmail.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI2MDE1MDgz", "url": "https://github.com/eclipse/jetty.project/pull/4946#pullrequestreview-426015083", "createdAt": "2020-06-08T08:30:42Z", "commit": {"oid": "82529e614f71fbc36d9212377376a33f2d4220f0"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOFQwODozMDo0MlrOGgT8Sg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOFQwODo0MjowOFrOGgUUww==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjUzNDM0Ng==", "bodyText": "Since all lambdas passed to this method are always capturing, I see no point in passing it the Callback. I think changing the signature here to accept a Runnable instead of a Consumer would be slightly more readable.", "url": "https://github.com/eclipse/jetty.project/pull/4946#discussion_r436534346", "createdAt": "2020-06-08T08:30:42Z", "author": {"login": "lorban"}, "path": "jetty-http2/http2-server/src/main/java/org/eclipse/jetty/http2/server/HttpTransportOverHTTP2.java", "diffHunk": "@@ -352,117 +353,259 @@ public void abort(Throwable failure)\n \n     private class TransportCallback implements Callback\n     {\n-        private State state = State.IDLE;\n-        private Callback callback;\n-        private Throwable failure;\n-        private boolean commit;\n+        private State _state = State.IDLE;\n+        private Callback _callback;\n+        private boolean _commit;\n+        private Throwable _failure;\n \n-        public boolean start(Callback callback, boolean commit)\n+        private void reset()\n         {\n-            State state;\n+            assert Thread.holdsLock(this);\n+            _state = State.IDLE;\n+            _callback = null;\n+            _commit = false;\n+            _failure = null;\n+        }\n+\n+        private void send(Callback callback, boolean commit, Consumer<Callback> consumer)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "82529e614f71fbc36d9212377376a33f2d4220f0"}, "originalPosition": 141}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjUzNTEzNg==", "bodyText": "These states and their transitions should be javadoc'ed as it's not easy to grok what the FSM looks like by reading the code.", "url": "https://github.com/eclipse/jetty.project/pull/4946#discussion_r436535136", "createdAt": "2020-06-08T08:32:07Z", "author": {"login": "lorban"}, "path": "jetty-http2/http2-server/src/main/java/org/eclipse/jetty/http2/server/HttpTransportOverHTTP2.java", "diffHunk": "@@ -352,117 +353,259 @@ public void abort(Throwable failure)\n \n     private class TransportCallback implements Callback\n     {\n-        private State state = State.IDLE;\n-        private Callback callback;\n-        private Throwable failure;\n-        private boolean commit;\n+        private State _state = State.IDLE;\n+        private Callback _callback;\n+        private boolean _commit;\n+        private Throwable _failure;\n \n-        public boolean start(Callback callback, boolean commit)\n+        private void reset()\n         {\n-            State state;\n+            assert Thread.holdsLock(this);\n+            _state = State.IDLE;\n+            _callback = null;\n+            _commit = false;\n+            _failure = null;\n+        }\n+\n+        private void send(Callback callback, boolean commit, Consumer<Callback> consumer)\n+        {\n+            Throwable failure = preSend(callback, commit);\n+            if (failure == null)\n+            {\n+                consumer.accept(this);\n+                postSend();\n+            }\n+            else\n+            {\n+                callback.failed(failure);\n+            }\n+        }\n+\n+        private Throwable preSend(Callback callback, boolean commit)\n+        {\n+            synchronized (this)\n+            {\n+                switch (_state)\n+                {\n+                    case IDLE:\n+                    {\n+                        _state = State.PRE_SEND;\n+                        _callback = callback;\n+                        _commit = commit;\n+                        return null;\n+                    }\n+                    default:\n+                    {\n+                        Throwable failure = _failure;\n+                        if (failure == null)\n+                            failure = new IllegalStateException(\"Invalid transport state: \" + _state);\n+                        return failure;\n+                    }\n+                }\n+            }\n+        }\n+\n+        private void postSend()\n+        {\n+            Callback callback;\n+            boolean commit;\n             Throwable failure;\n             synchronized (this)\n             {\n-                state = this.state;\n-                failure = this.failure;\n-                if (state == State.IDLE)\n+                switch (_state)\n                 {\n-                    this.state = State.WRITING;\n-                    this.callback = callback;\n-                    this.commit = commit;\n-                    return true;\n+                    case PRE_SEND:\n+                    {\n+                        _state = State.POST_SEND;\n+                        return;\n+                    }\n+                    case SUCCEED:\n+                    {\n+                        callback = _callback;\n+                        commit = _commit;\n+                        failure = null;\n+                        reset();\n+                        break;\n+                    }\n+                    case FAIL:\n+                    {\n+                        _state = State.FAILED;\n+                        callback = _callback;\n+                        commit = _commit;\n+                        failure = _failure;\n+                        break;\n+                    }\n+                    default:\n+                    {\n+                        _state = State.FAILED;\n+                        _failure = new IllegalStateException(\"Invalid transport state: \" + _state);\n+                        callback = _callback;\n+                        commit = _commit;\n+                        failure = _failure;\n+                        break;\n+                    }\n                 }\n             }\n             if (failure == null)\n-                failure = new IllegalStateException(\"Invalid transport state: \" + state);\n-            callback.failed(failure);\n-            return false;\n+                succeed(callback, commit);\n+            else\n+                fail(callback, commit, failure);\n         }\n \n         @Override\n         public void succeeded()\n         {\n+            Callback callback;\n             boolean commit;\n-            Callback callback = null;\n             synchronized (this)\n             {\n-                commit = this.commit;\n-                if (state == State.WRITING)\n+                switch (_state)\n                 {\n-                    this.state = State.IDLE;\n-                    callback = this.callback;\n-                    this.callback = null;\n-                    this.commit = false;\n+                    case PRE_SEND:\n+                    {\n+                        _state = State.SUCCEED;\n+                        // Succeeding the callback will be done in postSend().\n+                        return;\n+                    }\n+                    case POST_SEND:\n+                    {\n+                        callback = _callback;\n+                        commit = _commit;\n+                        reset();\n+                        break;\n+                    }\n+                    default:\n+                    {\n+                        // The race to succeed was lost and other states\n+                        // have already performed their terminal action.\n+                        return;\n+                    }\n                 }\n             }\n-            if (LOG.isDebugEnabled())\n-                LOG.debug(\"HTTP2 Response #{}/{} {} {}\",\n-                    stream.getId(), Integer.toHexString(stream.getSession().hashCode()),\n-                    commit ? \"commit\" : \"flush\",\n-                    callback == null ? \"failure\" : \"success\");\n-            if (callback != null)\n-                callback.succeeded();\n+            succeed(callback, commit);\n         }\n \n         @Override\n         public void failed(Throwable failure)\n         {\n-            boolean commit;\n             Callback callback;\n+            boolean commit;\n             synchronized (this)\n             {\n-                commit = this.commit;\n-                this.state = State.FAILED;\n-                callback = this.callback;\n-                this.callback = null;\n-                this.failure = failure;\n+                switch (_state)\n+                {\n+                    case PRE_SEND:\n+                    {\n+                        _state = State.FAIL;\n+                        _failure = failure;\n+                        // Failing the callback will be done in postSend().\n+                        return;\n+                    }\n+                    case IDLE:\n+                    case POST_SEND:\n+                    {\n+                        _state = State.FAILED;\n+                        _failure = failure;\n+                        callback = _callback;\n+                        commit = _commit;\n+                        break;\n+                    }\n+                    default:\n+                    {\n+                        // The race to fail was lost and other states\n+                        // have already performed their terminal action.\n+                        return;\n+                    }\n+                }\n             }\n-            if (LOG.isDebugEnabled())\n-                LOG.debug(String.format(\"HTTP2 Response #%d/%h %s %s\", stream.getId(), stream.getSession(),\n-                    commit ? \"commit\" : \"flush\", callback == null ? \"ignored\" : \"failed\"), failure);\n-            if (callback != null)\n-                callback.failed(failure);\n+            fail(callback, commit, failure);\n         }\n \n-        private boolean onIdleTimeout(Throwable failure)\n+        private boolean idleTimeout(Throwable failure)\n         {\n-            boolean result;\n-            Callback callback = null;\n+            Callback callback;\n+            boolean timeout;\n             synchronized (this)\n             {\n-                // Ignore idle timeouts if not writing,\n-                // as the application may be suspended.\n-                result = state == State.WRITING;\n-                if (result)\n+                switch (_state)\n                 {\n-                    this.state = State.TIMEOUT;\n-                    callback = this.callback;\n-                    this.callback = null;\n-                    this.failure = failure;\n+                    case POST_SEND:\n+                    {\n+                        // The send was started but idle timed out, fail it.\n+                        _state = State.FAILED;\n+                        _failure = failure;\n+                        callback = _callback;\n+                        timeout = true;\n+                        break;\n+                    }\n+                    case IDLE:\n+                        // The application may be suspended, ignore the idle timeout.\n+                    case PRE_SEND:\n+                        // A send has been started at the same time of an idle timeout;\n+                        // Ignore the idle timeout and let the write continue normally.\n+                    case SUCCEED:\n+                    case FAIL:\n+                        // An idle timeout during these transient states is ignored.\n+                    case FAILED:\n+                        // Already failed, ignore the idle timeout.\n+                    {\n+                        callback = null;\n+                        timeout = false;\n+                        break;\n+                    }\n+                    default:\n+                    {\n+                        // Should not happen, but just in case.\n+                        _state = State.FAILED;\n+                        _failure = new IllegalStateException(\"Invalid transport state: \" + _state, failure);\n+                        callback = _callback;\n+                        if (callback == null)\n+                            callback = Callback.NOOP;\n+                        timeout = true;\n+                        failure = _failure;\n+                        break;\n+                    }\n                 }\n             }\n+            idleTimeout(callback, timeout, failure);\n+            return timeout;\n+        }\n+\n+        private void succeed(Callback callback, boolean commit)\n+        {\n             if (LOG.isDebugEnabled())\n-                LOG.debug(String.format(\"HTTP2 Response #%d/%h idle timeout %s\", stream.getId(), stream.getSession(), result ? \"expired\" : \"ignored\"), failure);\n-            if (result)\n+                LOG.debug(\"HTTP2 Response #{}/{} {} success\",\n+                    stream.getId(), Integer.toHexString(stream.getSession().hashCode()),\n+                    commit ? \"commit\" : \"flush\");\n+            callback.succeeded();\n+        }\n+\n+        private void fail(Callback callback, boolean commit, Throwable failure)\n+        {\n+            if (LOG.isDebugEnabled())\n+                LOG.debug(\"HTTP2 Response #{}/{} {} failure\",\n+                    stream.getId(), Integer.toHexString(stream.getSession().hashCode()),\n+                    commit ? \"commit\" : \"flush\",\n+                    failure);\n+            if (callback != null)\n                 callback.failed(failure);\n-            return result;\n         }\n \n-        @Override\n-        public InvocationType getInvocationType()\n+        private void idleTimeout(Callback callback, boolean timeout, Throwable failure)\n         {\n-            Callback callback;\n-            synchronized (this)\n-            {\n-                callback = this.callback;\n-            }\n-            return callback != null ? callback.getInvocationType() : Callback.super.getInvocationType();\n+            if (LOG.isDebugEnabled())\n+                LOG.debug(\"HTTP2 Response #{}/{} idle timeout {}\",\n+                    stream.getId(), Integer.toHexString(stream.getSession().hashCode()),\n+                    timeout ? \"expired\" : \"ignored\",\n+                    failure);\n+            if (timeout)\n+                callback.failed(failure);\n         }\n     }\n \n     private enum State\n     {\n-        IDLE, WRITING, FAILED, TIMEOUT\n+        IDLE, PRE_SEND, POST_SEND, SUCCEED, FAIL, FAILED", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "82529e614f71fbc36d9212377376a33f2d4220f0"}, "originalPosition": 437}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjU0MDYxMQ==", "bodyText": "I find this new method's signature and default implementation surprising. I would have expected that the error and reason parameters to go away especially since the overriding implementations just ignore them. Plus the fact that the default implementation drops the failure in favor of calling the deprecated implementation instead of directly succeeding the callback also makes me scratch my head.\nMaybe FailureFrame.getFailure() should return some sort of H2Exception that wraps the original exception as well as containing the reason and error code?", "url": "https://github.com/eclipse/jetty.project/pull/4946#discussion_r436540611", "createdAt": "2020-06-08T08:42:08Z", "author": {"login": "lorban"}, "path": "jetty-http2/http2-common/src/main/java/org/eclipse/jetty/http2/api/Stream.java", "diffHunk": "@@ -227,8 +227,24 @@ default boolean onIdleTimeout(Stream stream, Throwable x)\n          * @param stream the stream\n          * @param error the error code\n          * @param reason the error reason, or null\n+         * @param failure the failure\n          * @param callback the callback to complete when the failure has been handled\n          */\n+        default void onFailure(Stream stream, int error, String reason, Throwable failure, Callback callback)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "82529e614f71fbc36d9212377376a33f2d4220f0"}, "originalPosition": 7}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI2MDU4OTQ1", "url": "https://github.com/eclipse/jetty.project/pull/4946#pullrequestreview-426058945", "createdAt": "2020-06-08T09:29:00Z", "commit": {"oid": "42a5d2785b51f06e3440bbcf4a4d845b5f8bc5e1"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOFQwOToyOTowMFrOGgV-GA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOFQwOTo0Nzo0NVrOGgWmqA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjU2NzU3Ng==", "bodyText": "I don't like the PRE_SEND,  POST_SEND and SUCCEEDnames as they are confusing in that during PRE_SEND sending is happening and in POST_SEND the send is pending.\nHow about: IDLE -> SENDING -> PENDING -> SUCCEEDED -> FAILED\nI think ING and ED names line up better with our practises elsewhere.", "url": "https://github.com/eclipse/jetty.project/pull/4946#discussion_r436567576", "createdAt": "2020-06-08T09:29:00Z", "author": {"login": "gregw"}, "path": "jetty-http2/http2-server/src/main/java/org/eclipse/jetty/http2/server/HttpTransportOverHTTP2.java", "diffHunk": "@@ -350,119 +351,356 @@ public void abort(Throwable failure)\n             stream.reset(new ResetFrame(stream.getId(), ErrorCode.CANCEL_STREAM_ERROR.code), Callback.NOOP);\n     }\n \n+    /**\n+     * <p>Callback that controls sends initiated by the transport, by eventually\n+     * notifying a nested callback.</p>\n+     * <p>There are 3 sources of concurrency after a send is initiated:</p>\n+     * <ul>\n+     *   <li>the completion of the send operation, either success or failure</li>\n+     *   <li>an asynchronous failure coming from the read side such as a stream\n+     *   being reset, or the connection being closed</li>\n+     *   <li>an asynchronous idle timeout</li>\n+     * </ul>\n+     * <p>The last 2 cases may happen <em>during</em> a send, when the frames\n+     * are being generated in the flusher.\n+     * In such cases, this class must avoid that the nested callback is notified\n+     * while the frame generation is in progress, because the nested callback\n+     * may modify other states (such as clearing the {@code HttpOutput._buffer})\n+     * that are accessed during frame generation.</p>\n+     * <p>The solution implemented in this class works by splitting the send\n+     * operation in 3 parts: {@code preSend()}, {@code send()} and {@code postSend()}.\n+     * Asynchronous state changes happening during {@code send()} are stored\n+     * and only executed in {@code postSend()}, therefore never interfering\n+     * with frame generation.</p>\n+     *\n+     * @see State\n+     */\n     private class TransportCallback implements Callback\n     {\n-        private State state = State.IDLE;\n-        private Callback callback;\n-        private Throwable failure;\n-        private boolean commit;\n+        private State _state = State.IDLE;\n+        private Callback _callback;\n+        private boolean _commit;\n+        private Throwable _failure;\n \n-        public boolean start(Callback callback, boolean commit)\n+        private void reset()\n         {\n-            State state;\n+            assert Thread.holdsLock(this);\n+            _state = State.IDLE;\n+            _callback = null;\n+            _commit = false;\n+            _failure = null;\n+        }\n+\n+        private void send(Callback callback, boolean commit, Consumer<Callback> consumer)\n+        {\n+            Throwable failure = preSend(callback, commit);\n+            if (failure == null)\n+            {\n+                consumer.accept(this);\n+                postSend();\n+            }\n+            else\n+            {\n+                callback.failed(failure);\n+            }\n+        }\n+\n+        private Throwable preSend(Callback callback, boolean commit)\n+        {\n+            synchronized (this)\n+            {\n+                switch (_state)\n+                {\n+                    case IDLE:\n+                    {\n+                        _state = State.PRE_SEND;\n+                        _callback = callback;\n+                        _commit = commit;\n+                        return null;\n+                    }\n+                    default:\n+                    {\n+                        Throwable failure = _failure;\n+                        if (failure == null)\n+                            failure = new IllegalStateException(\"Invalid transport state: \" + _state);\n+                        return failure;\n+                    }\n+                }\n+            }\n+        }\n+\n+        private void postSend()\n+        {\n+            Callback callback;\n+            boolean commit;\n             Throwable failure;\n             synchronized (this)\n             {\n-                state = this.state;\n-                failure = this.failure;\n-                if (state == State.IDLE)\n+                switch (_state)\n                 {\n-                    this.state = State.WRITING;\n-                    this.callback = callback;\n-                    this.commit = commit;\n-                    return true;\n+                    case PRE_SEND:\n+                    {\n+                        _state = State.POST_SEND;\n+                        return;\n+                    }\n+                    case SUCCEED:\n+                    {\n+                        callback = _callback;\n+                        commit = _commit;\n+                        failure = null;\n+                        reset();\n+                        break;\n+                    }\n+                    case FAIL:\n+                    {\n+                        _state = State.FAILED;\n+                        callback = _callback;\n+                        commit = _commit;\n+                        failure = _failure;\n+                        break;\n+                    }\n+                    default:\n+                    {\n+                        _state = State.FAILED;\n+                        _failure = new IllegalStateException(\"Invalid transport state: \" + _state);\n+                        callback = _callback;\n+                        commit = _commit;\n+                        failure = _failure;\n+                        break;\n+                    }\n                 }\n             }\n             if (failure == null)\n-                failure = new IllegalStateException(\"Invalid transport state: \" + state);\n-            callback.failed(failure);\n-            return false;\n+                succeed(callback, commit);\n+            else\n+                fail(callback, commit, failure);\n         }\n \n         @Override\n         public void succeeded()\n         {\n+            Callback callback;\n             boolean commit;\n-            Callback callback = null;\n             synchronized (this)\n             {\n-                commit = this.commit;\n-                if (state == State.WRITING)\n+                switch (_state)\n                 {\n-                    this.state = State.IDLE;\n-                    callback = this.callback;\n-                    this.callback = null;\n-                    this.commit = false;\n+                    case PRE_SEND:\n+                    {\n+                        _state = State.SUCCEED;\n+                        // Succeeding the callback will be done in postSend().\n+                        return;\n+                    }\n+                    case POST_SEND:\n+                    {\n+                        callback = _callback;\n+                        commit = _commit;\n+                        reset();\n+                        break;\n+                    }\n+                    default:\n+                    {\n+                        // This thread lost the race to succeed the current\n+                        // send, as other threads likely already failed it.\n+                        return;\n+                    }\n                 }\n             }\n-            if (LOG.isDebugEnabled())\n-                LOG.debug(\"HTTP2 Response #{}/{} {} {}\",\n-                    stream.getId(), Integer.toHexString(stream.getSession().hashCode()),\n-                    commit ? \"commit\" : \"flush\",\n-                    callback == null ? \"failure\" : \"success\");\n-            if (callback != null)\n-                callback.succeeded();\n+            succeed(callback, commit);\n         }\n \n         @Override\n         public void failed(Throwable failure)\n         {\n-            boolean commit;\n             Callback callback;\n+            boolean commit;\n             synchronized (this)\n             {\n-                commit = this.commit;\n-                this.state = State.FAILED;\n-                callback = this.callback;\n-                this.callback = null;\n-                this.failure = failure;\n+                switch (_state)\n+                {\n+                    case PRE_SEND:\n+                    {\n+                        _state = State.FAIL;\n+                        _failure = failure;\n+                        // Failing the callback will be done in postSend().\n+                        return;\n+                    }\n+                    case IDLE:\n+                    case POST_SEND:\n+                    {\n+                        _state = State.FAILED;\n+                        _failure = failure;\n+                        callback = _callback;\n+                        commit = _commit;\n+                        break;\n+                    }\n+                    default:\n+                    {\n+                        // This thread lost the race to fail the current send,\n+                        // as other threads already succeeded or failed it.\n+                        return;\n+                    }\n+                }\n             }\n-            if (LOG.isDebugEnabled())\n-                LOG.debug(String.format(\"HTTP2 Response #%d/%h %s %s\", stream.getId(), stream.getSession(),\n-                    commit ? \"commit\" : \"flush\", callback == null ? \"ignored\" : \"failed\"), failure);\n-            if (callback != null)\n-                callback.failed(failure);\n+            fail(callback, commit, failure);\n         }\n \n-        private boolean onIdleTimeout(Throwable failure)\n+        private boolean idleTimeout(Throwable failure)\n         {\n-            boolean result;\n-            Callback callback = null;\n+            Callback callback;\n+            boolean timeout;\n             synchronized (this)\n             {\n-                // Ignore idle timeouts if not writing,\n-                // as the application may be suspended.\n-                result = state == State.WRITING;\n-                if (result)\n+                switch (_state)\n                 {\n-                    this.state = State.TIMEOUT;\n-                    callback = this.callback;\n-                    this.callback = null;\n-                    this.failure = failure;\n+                    case POST_SEND:\n+                    {\n+                        // The send was started but idle timed out, fail it.\n+                        _state = State.FAILED;\n+                        _failure = failure;\n+                        callback = _callback;\n+                        timeout = true;\n+                        break;\n+                    }\n+                    case IDLE:\n+                        // The application may be suspended, ignore the idle timeout.\n+                    case PRE_SEND:\n+                        // A send has been started at the same time of an idle timeout;\n+                        // Ignore the idle timeout and let the write continue normally.\n+                    case SUCCEED:\n+                    case FAIL:\n+                        // An idle timeout during these transient states is ignored.\n+                    case FAILED:\n+                        // Already failed, ignore the idle timeout.\n+                    {\n+                        callback = null;\n+                        timeout = false;\n+                        break;\n+                    }\n+                    default:\n+                    {\n+                        // Should not happen, but just in case.\n+                        _state = State.FAILED;\n+                        _failure = new IllegalStateException(\"Invalid transport state: \" + _state, failure);\n+                        callback = _callback;\n+                        if (callback == null)\n+                            callback = Callback.NOOP;\n+                        timeout = true;\n+                        failure = _failure;\n+                        break;\n+                    }\n                 }\n             }\n+            idleTimeout(callback, timeout, failure);\n+            return timeout;\n+        }\n+\n+        private void succeed(Callback callback, boolean commit)\n+        {\n             if (LOG.isDebugEnabled())\n-                LOG.debug(String.format(\"HTTP2 Response #%d/%h idle timeout %s\", stream.getId(), stream.getSession(), result ? \"expired\" : \"ignored\"), failure);\n-            if (result)\n+                LOG.debug(\"HTTP2 Response #{}/{} {} success\",\n+                    stream.getId(), Integer.toHexString(stream.getSession().hashCode()),\n+                    commit ? \"commit\" : \"flush\");\n+            callback.succeeded();\n+        }\n+\n+        private void fail(Callback callback, boolean commit, Throwable failure)\n+        {\n+            if (LOG.isDebugEnabled())\n+                LOG.debug(\"HTTP2 Response #{}/{} {} failure\",\n+                    stream.getId(), Integer.toHexString(stream.getSession().hashCode()),\n+                    commit ? \"commit\" : \"flush\",\n+                    failure);\n+            if (callback != null)\n                 callback.failed(failure);\n-            return result;\n         }\n \n-        @Override\n-        public InvocationType getInvocationType()\n+        private void idleTimeout(Callback callback, boolean timeout, Throwable failure)\n         {\n-            Callback callback;\n-            synchronized (this)\n-            {\n-                callback = this.callback;\n-            }\n-            return callback != null ? callback.getInvocationType() : Callback.super.getInvocationType();\n+            if (LOG.isDebugEnabled())\n+                LOG.debug(\"HTTP2 Response #{}/{} idle timeout {}\",\n+                    stream.getId(), Integer.toHexString(stream.getSession().hashCode()),\n+                    timeout ? \"expired\" : \"ignored\",\n+                    failure);\n+            if (timeout)\n+                callback.failed(failure);\n         }\n     }\n \n+    /**\n+     * <p>Send states for {@link TransportCallback}.</p>\n+     *\n+     * @see TransportCallback\n+     */\n     private enum State\n     {\n-        IDLE, WRITING, FAILED, TIMEOUT\n+        /**\n+         * <p>No send initiated or in progress.</p>\n+         * <p>Next states could be:</p>\n+         * <ul>\n+         *   <li>{@link #PRE_SEND}, when {@link TransportCallback#send(Callback, boolean, Consumer)}\n+         *   is called by the transport to initiate a send</li>\n+         *   <li>{@link #FAILED}, when {@link TransportCallback#failed(Throwable)}\n+         *   is called by an asynchronous failure</li>\n+         * </ul>\n+         */\n+        IDLE,\n+        /**\n+         * <p>A send is initiated; the nested callback in {@link TransportCallback}\n+         * cannot be notified while in this state.</p>\n+         * <p>Next states could be:</p>\n+         * <ul>\n+         *   <li>{@link #SUCCEED}, when {@link TransportCallback#succeeded()}\n+         *   is called synchronously because the send succeeded</li>\n+         *   <li>{@link #FAIL}, when {@link TransportCallback#failed(Throwable)}\n+         *   is called synchronously because the send failed</li>\n+         *   <li>{@link #POST_SEND}, when {@link TransportCallback#postSend()}\n+         *   is called before the send completes</li>\n+         * </ul>\n+         */\n+        PRE_SEND,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "42a5d2785b51f06e3440bbcf4a4d845b5f8bc5e1"}, "originalPosition": 492}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjU2OTU0MA==", "bodyText": "rename method to onSending", "url": "https://github.com/eclipse/jetty.project/pull/4946#discussion_r436569540", "createdAt": "2020-06-08T09:32:43Z", "author": {"login": "gregw"}, "path": "jetty-http2/http2-server/src/main/java/org/eclipse/jetty/http2/server/HttpTransportOverHTTP2.java", "diffHunk": "@@ -350,119 +351,356 @@ public void abort(Throwable failure)\n             stream.reset(new ResetFrame(stream.getId(), ErrorCode.CANCEL_STREAM_ERROR.code), Callback.NOOP);\n     }\n \n+    /**\n+     * <p>Callback that controls sends initiated by the transport, by eventually\n+     * notifying a nested callback.</p>\n+     * <p>There are 3 sources of concurrency after a send is initiated:</p>\n+     * <ul>\n+     *   <li>the completion of the send operation, either success or failure</li>\n+     *   <li>an asynchronous failure coming from the read side such as a stream\n+     *   being reset, or the connection being closed</li>\n+     *   <li>an asynchronous idle timeout</li>\n+     * </ul>\n+     * <p>The last 2 cases may happen <em>during</em> a send, when the frames\n+     * are being generated in the flusher.\n+     * In such cases, this class must avoid that the nested callback is notified\n+     * while the frame generation is in progress, because the nested callback\n+     * may modify other states (such as clearing the {@code HttpOutput._buffer})\n+     * that are accessed during frame generation.</p>\n+     * <p>The solution implemented in this class works by splitting the send\n+     * operation in 3 parts: {@code preSend()}, {@code send()} and {@code postSend()}.\n+     * Asynchronous state changes happening during {@code send()} are stored\n+     * and only executed in {@code postSend()}, therefore never interfering\n+     * with frame generation.</p>\n+     *\n+     * @see State\n+     */\n     private class TransportCallback implements Callback\n     {\n-        private State state = State.IDLE;\n-        private Callback callback;\n-        private Throwable failure;\n-        private boolean commit;\n+        private State _state = State.IDLE;\n+        private Callback _callback;\n+        private boolean _commit;\n+        private Throwable _failure;\n \n-        public boolean start(Callback callback, boolean commit)\n+        private void reset()\n         {\n-            State state;\n+            assert Thread.holdsLock(this);\n+            _state = State.IDLE;\n+            _callback = null;\n+            _commit = false;\n+            _failure = null;\n+        }\n+\n+        private void send(Callback callback, boolean commit, Consumer<Callback> consumer)\n+        {\n+            Throwable failure = preSend(callback, commit);\n+            if (failure == null)\n+            {\n+                consumer.accept(this);\n+                postSend();\n+            }\n+            else\n+            {\n+                callback.failed(failure);\n+            }\n+        }\n+\n+        private Throwable preSend(Callback callback, boolean commit)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "42a5d2785b51f06e3440bbcf4a4d845b5f8bc5e1"}, "originalPosition": 181}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjU3MjQ4Ng==", "bodyText": "This is not one case but two. Also needs comments:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                default:\n          \n          \n            \n                                {\n          \n          \n            \n                                    Throwable failure = _failure;\n          \n          \n            \n                                    if (failure == null)\n          \n          \n            \n                                        failure = new IllegalStateException(\"Invalid transport state: \" + _state);\n          \n          \n            \n                                    return failure;\n          \n          \n            \n                                }\n          \n          \n            \n                                case FAIL:\n          \n          \n            \n                                    // better comment that an async failure happened while we were just about to send something\n          \n          \n            \n                                    return _failure;\n          \n          \n            \n                                default:\n          \n          \n            \n                                    return new IllegalStateException(\"Invalid transport state: \" + _state);", "url": "https://github.com/eclipse/jetty.project/pull/4946#discussion_r436572486", "createdAt": "2020-06-08T09:38:00Z", "author": {"login": "gregw"}, "path": "jetty-http2/http2-server/src/main/java/org/eclipse/jetty/http2/server/HttpTransportOverHTTP2.java", "diffHunk": "@@ -350,119 +351,356 @@ public void abort(Throwable failure)\n             stream.reset(new ResetFrame(stream.getId(), ErrorCode.CANCEL_STREAM_ERROR.code), Callback.NOOP);\n     }\n \n+    /**\n+     * <p>Callback that controls sends initiated by the transport, by eventually\n+     * notifying a nested callback.</p>\n+     * <p>There are 3 sources of concurrency after a send is initiated:</p>\n+     * <ul>\n+     *   <li>the completion of the send operation, either success or failure</li>\n+     *   <li>an asynchronous failure coming from the read side such as a stream\n+     *   being reset, or the connection being closed</li>\n+     *   <li>an asynchronous idle timeout</li>\n+     * </ul>\n+     * <p>The last 2 cases may happen <em>during</em> a send, when the frames\n+     * are being generated in the flusher.\n+     * In such cases, this class must avoid that the nested callback is notified\n+     * while the frame generation is in progress, because the nested callback\n+     * may modify other states (such as clearing the {@code HttpOutput._buffer})\n+     * that are accessed during frame generation.</p>\n+     * <p>The solution implemented in this class works by splitting the send\n+     * operation in 3 parts: {@code preSend()}, {@code send()} and {@code postSend()}.\n+     * Asynchronous state changes happening during {@code send()} are stored\n+     * and only executed in {@code postSend()}, therefore never interfering\n+     * with frame generation.</p>\n+     *\n+     * @see State\n+     */\n     private class TransportCallback implements Callback\n     {\n-        private State state = State.IDLE;\n-        private Callback callback;\n-        private Throwable failure;\n-        private boolean commit;\n+        private State _state = State.IDLE;\n+        private Callback _callback;\n+        private boolean _commit;\n+        private Throwable _failure;\n \n-        public boolean start(Callback callback, boolean commit)\n+        private void reset()\n         {\n-            State state;\n+            assert Thread.holdsLock(this);\n+            _state = State.IDLE;\n+            _callback = null;\n+            _commit = false;\n+            _failure = null;\n+        }\n+\n+        private void send(Callback callback, boolean commit, Consumer<Callback> consumer)\n+        {\n+            Throwable failure = preSend(callback, commit);\n+            if (failure == null)\n+            {\n+                consumer.accept(this);\n+                postSend();\n+            }\n+            else\n+            {\n+                callback.failed(failure);\n+            }\n+        }\n+\n+        private Throwable preSend(Callback callback, boolean commit)\n+        {\n+            synchronized (this)\n+            {\n+                switch (_state)\n+                {\n+                    case IDLE:\n+                    {\n+                        _state = State.PRE_SEND;\n+                        _callback = callback;\n+                        _commit = commit;\n+                        return null;\n+                    }\n+                    default:\n+                    {\n+                        Throwable failure = _failure;\n+                        if (failure == null)\n+                            failure = new IllegalStateException(\"Invalid transport state: \" + _state);\n+                        return failure;\n+                    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "42a5d2785b51f06e3440bbcf4a4d845b5f8bc5e1"}, "originalPosition": 200}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjU3Mjc3OQ==", "bodyText": "rename to onSent", "url": "https://github.com/eclipse/jetty.project/pull/4946#discussion_r436572779", "createdAt": "2020-06-08T09:38:34Z", "author": {"login": "gregw"}, "path": "jetty-http2/http2-server/src/main/java/org/eclipse/jetty/http2/server/HttpTransportOverHTTP2.java", "diffHunk": "@@ -350,119 +351,356 @@ public void abort(Throwable failure)\n             stream.reset(new ResetFrame(stream.getId(), ErrorCode.CANCEL_STREAM_ERROR.code), Callback.NOOP);\n     }\n \n+    /**\n+     * <p>Callback that controls sends initiated by the transport, by eventually\n+     * notifying a nested callback.</p>\n+     * <p>There are 3 sources of concurrency after a send is initiated:</p>\n+     * <ul>\n+     *   <li>the completion of the send operation, either success or failure</li>\n+     *   <li>an asynchronous failure coming from the read side such as a stream\n+     *   being reset, or the connection being closed</li>\n+     *   <li>an asynchronous idle timeout</li>\n+     * </ul>\n+     * <p>The last 2 cases may happen <em>during</em> a send, when the frames\n+     * are being generated in the flusher.\n+     * In such cases, this class must avoid that the nested callback is notified\n+     * while the frame generation is in progress, because the nested callback\n+     * may modify other states (such as clearing the {@code HttpOutput._buffer})\n+     * that are accessed during frame generation.</p>\n+     * <p>The solution implemented in this class works by splitting the send\n+     * operation in 3 parts: {@code preSend()}, {@code send()} and {@code postSend()}.\n+     * Asynchronous state changes happening during {@code send()} are stored\n+     * and only executed in {@code postSend()}, therefore never interfering\n+     * with frame generation.</p>\n+     *\n+     * @see State\n+     */\n     private class TransportCallback implements Callback\n     {\n-        private State state = State.IDLE;\n-        private Callback callback;\n-        private Throwable failure;\n-        private boolean commit;\n+        private State _state = State.IDLE;\n+        private Callback _callback;\n+        private boolean _commit;\n+        private Throwable _failure;\n \n-        public boolean start(Callback callback, boolean commit)\n+        private void reset()\n         {\n-            State state;\n+            assert Thread.holdsLock(this);\n+            _state = State.IDLE;\n+            _callback = null;\n+            _commit = false;\n+            _failure = null;\n+        }\n+\n+        private void send(Callback callback, boolean commit, Consumer<Callback> consumer)\n+        {\n+            Throwable failure = preSend(callback, commit);\n+            if (failure == null)\n+            {\n+                consumer.accept(this);\n+                postSend();\n+            }\n+            else\n+            {\n+                callback.failed(failure);\n+            }\n+        }\n+\n+        private Throwable preSend(Callback callback, boolean commit)\n+        {\n+            synchronized (this)\n+            {\n+                switch (_state)\n+                {\n+                    case IDLE:\n+                    {\n+                        _state = State.PRE_SEND;\n+                        _callback = callback;\n+                        _commit = commit;\n+                        return null;\n+                    }\n+                    default:\n+                    {\n+                        Throwable failure = _failure;\n+                        if (failure == null)\n+                            failure = new IllegalStateException(\"Invalid transport state: \" + _state);\n+                        return failure;\n+                    }\n+                }\n+            }\n+        }\n+\n+        private void postSend()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "42a5d2785b51f06e3440bbcf4a4d845b5f8bc5e1"}, "originalPosition": 205}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjU3MzQ0Ng==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                    _state = State.POST_SEND;\n          \n          \n            \n                                    // The send has not yet completed, wait for success or failure\n          \n          \n            \n                                    _state = State.PENDING;", "url": "https://github.com/eclipse/jetty.project/pull/4946#discussion_r436573446", "createdAt": "2020-06-08T09:39:43Z", "author": {"login": "gregw"}, "path": "jetty-http2/http2-server/src/main/java/org/eclipse/jetty/http2/server/HttpTransportOverHTTP2.java", "diffHunk": "@@ -350,119 +351,356 @@ public void abort(Throwable failure)\n             stream.reset(new ResetFrame(stream.getId(), ErrorCode.CANCEL_STREAM_ERROR.code), Callback.NOOP);\n     }\n \n+    /**\n+     * <p>Callback that controls sends initiated by the transport, by eventually\n+     * notifying a nested callback.</p>\n+     * <p>There are 3 sources of concurrency after a send is initiated:</p>\n+     * <ul>\n+     *   <li>the completion of the send operation, either success or failure</li>\n+     *   <li>an asynchronous failure coming from the read side such as a stream\n+     *   being reset, or the connection being closed</li>\n+     *   <li>an asynchronous idle timeout</li>\n+     * </ul>\n+     * <p>The last 2 cases may happen <em>during</em> a send, when the frames\n+     * are being generated in the flusher.\n+     * In such cases, this class must avoid that the nested callback is notified\n+     * while the frame generation is in progress, because the nested callback\n+     * may modify other states (such as clearing the {@code HttpOutput._buffer})\n+     * that are accessed during frame generation.</p>\n+     * <p>The solution implemented in this class works by splitting the send\n+     * operation in 3 parts: {@code preSend()}, {@code send()} and {@code postSend()}.\n+     * Asynchronous state changes happening during {@code send()} are stored\n+     * and only executed in {@code postSend()}, therefore never interfering\n+     * with frame generation.</p>\n+     *\n+     * @see State\n+     */\n     private class TransportCallback implements Callback\n     {\n-        private State state = State.IDLE;\n-        private Callback callback;\n-        private Throwable failure;\n-        private boolean commit;\n+        private State _state = State.IDLE;\n+        private Callback _callback;\n+        private boolean _commit;\n+        private Throwable _failure;\n \n-        public boolean start(Callback callback, boolean commit)\n+        private void reset()\n         {\n-            State state;\n+            assert Thread.holdsLock(this);\n+            _state = State.IDLE;\n+            _callback = null;\n+            _commit = false;\n+            _failure = null;\n+        }\n+\n+        private void send(Callback callback, boolean commit, Consumer<Callback> consumer)\n+        {\n+            Throwable failure = preSend(callback, commit);\n+            if (failure == null)\n+            {\n+                consumer.accept(this);\n+                postSend();\n+            }\n+            else\n+            {\n+                callback.failed(failure);\n+            }\n+        }\n+\n+        private Throwable preSend(Callback callback, boolean commit)\n+        {\n+            synchronized (this)\n+            {\n+                switch (_state)\n+                {\n+                    case IDLE:\n+                    {\n+                        _state = State.PRE_SEND;\n+                        _callback = callback;\n+                        _commit = commit;\n+                        return null;\n+                    }\n+                    default:\n+                    {\n+                        Throwable failure = _failure;\n+                        if (failure == null)\n+                            failure = new IllegalStateException(\"Invalid transport state: \" + _state);\n+                        return failure;\n+                    }\n+                }\n+            }\n+        }\n+\n+        private void postSend()\n+        {\n+            Callback callback;\n+            boolean commit;\n             Throwable failure;\n             synchronized (this)\n             {\n-                state = this.state;\n-                failure = this.failure;\n-                if (state == State.IDLE)\n+                switch (_state)\n                 {\n-                    this.state = State.WRITING;\n-                    this.callback = callback;\n-                    this.commit = commit;\n-                    return true;\n+                    case PRE_SEND:\n+                    {\n+                        _state = State.POST_SEND;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "42a5d2785b51f06e3440bbcf4a4d845b5f8bc5e1"}, "originalPosition": 223}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjU3NDIxMA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                    callback = _callback;\n          \n          \n            \n                                    // The send has already completed successfully but callback not yet called, we can process callback now\n          \n          \n            \n                                    callback = _callback;\n          \n          \n            \n                                    _callback = null;", "url": "https://github.com/eclipse/jetty.project/pull/4946#discussion_r436574210", "createdAt": "2020-06-08T09:41:02Z", "author": {"login": "gregw"}, "path": "jetty-http2/http2-server/src/main/java/org/eclipse/jetty/http2/server/HttpTransportOverHTTP2.java", "diffHunk": "@@ -350,119 +351,356 @@ public void abort(Throwable failure)\n             stream.reset(new ResetFrame(stream.getId(), ErrorCode.CANCEL_STREAM_ERROR.code), Callback.NOOP);\n     }\n \n+    /**\n+     * <p>Callback that controls sends initiated by the transport, by eventually\n+     * notifying a nested callback.</p>\n+     * <p>There are 3 sources of concurrency after a send is initiated:</p>\n+     * <ul>\n+     *   <li>the completion of the send operation, either success or failure</li>\n+     *   <li>an asynchronous failure coming from the read side such as a stream\n+     *   being reset, or the connection being closed</li>\n+     *   <li>an asynchronous idle timeout</li>\n+     * </ul>\n+     * <p>The last 2 cases may happen <em>during</em> a send, when the frames\n+     * are being generated in the flusher.\n+     * In such cases, this class must avoid that the nested callback is notified\n+     * while the frame generation is in progress, because the nested callback\n+     * may modify other states (such as clearing the {@code HttpOutput._buffer})\n+     * that are accessed during frame generation.</p>\n+     * <p>The solution implemented in this class works by splitting the send\n+     * operation in 3 parts: {@code preSend()}, {@code send()} and {@code postSend()}.\n+     * Asynchronous state changes happening during {@code send()} are stored\n+     * and only executed in {@code postSend()}, therefore never interfering\n+     * with frame generation.</p>\n+     *\n+     * @see State\n+     */\n     private class TransportCallback implements Callback\n     {\n-        private State state = State.IDLE;\n-        private Callback callback;\n-        private Throwable failure;\n-        private boolean commit;\n+        private State _state = State.IDLE;\n+        private Callback _callback;\n+        private boolean _commit;\n+        private Throwable _failure;\n \n-        public boolean start(Callback callback, boolean commit)\n+        private void reset()\n         {\n-            State state;\n+            assert Thread.holdsLock(this);\n+            _state = State.IDLE;\n+            _callback = null;\n+            _commit = false;\n+            _failure = null;\n+        }\n+\n+        private void send(Callback callback, boolean commit, Consumer<Callback> consumer)\n+        {\n+            Throwable failure = preSend(callback, commit);\n+            if (failure == null)\n+            {\n+                consumer.accept(this);\n+                postSend();\n+            }\n+            else\n+            {\n+                callback.failed(failure);\n+            }\n+        }\n+\n+        private Throwable preSend(Callback callback, boolean commit)\n+        {\n+            synchronized (this)\n+            {\n+                switch (_state)\n+                {\n+                    case IDLE:\n+                    {\n+                        _state = State.PRE_SEND;\n+                        _callback = callback;\n+                        _commit = commit;\n+                        return null;\n+                    }\n+                    default:\n+                    {\n+                        Throwable failure = _failure;\n+                        if (failure == null)\n+                            failure = new IllegalStateException(\"Invalid transport state: \" + _state);\n+                        return failure;\n+                    }\n+                }\n+            }\n+        }\n+\n+        private void postSend()\n+        {\n+            Callback callback;\n+            boolean commit;\n             Throwable failure;\n             synchronized (this)\n             {\n-                state = this.state;\n-                failure = this.failure;\n-                if (state == State.IDLE)\n+                switch (_state)\n                 {\n-                    this.state = State.WRITING;\n-                    this.callback = callback;\n-                    this.commit = commit;\n-                    return true;\n+                    case PRE_SEND:\n+                    {\n+                        _state = State.POST_SEND;\n+                        return;\n+                    }\n+                    case SUCCEED:\n+                    {\n+                        callback = _callback;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "42a5d2785b51f06e3440bbcf4a4d845b5f8bc5e1"}, "originalPosition": 228}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjU3NjY0Mw==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                case FAIL:\n          \n          \n            \n                                {\n          \n          \n            \n                                    _state = State.FAILED;\n          \n          \n            \n                                    callback = _callback;\n          \n          \n            \n                                    commit = _commit;\n          \n          \n            \n                                    failure = _failure;\n          \n          \n            \n                                    break;\n          \n          \n            \n                                case FAIL:\n          \n          \n            \n                                {\n          \n          \n            \n                                    // The send has already failed (either synchronously or asynchronously), but callback not yet called, so handle now\n          \n          \n            \n                                    _state = State.FAILED;\n          \n          \n            \n                                    callback = _callback;\n          \n          \n            \n                                    _callback = null;\n          \n          \n            \n                                    commit = _commit;\n          \n          \n            \n                                    failure = _failure;\n          \n          \n            \n                                    break;", "url": "https://github.com/eclipse/jetty.project/pull/4946#discussion_r436576643", "createdAt": "2020-06-08T09:45:15Z", "author": {"login": "gregw"}, "path": "jetty-http2/http2-server/src/main/java/org/eclipse/jetty/http2/server/HttpTransportOverHTTP2.java", "diffHunk": "@@ -350,119 +351,356 @@ public void abort(Throwable failure)\n             stream.reset(new ResetFrame(stream.getId(), ErrorCode.CANCEL_STREAM_ERROR.code), Callback.NOOP);\n     }\n \n+    /**\n+     * <p>Callback that controls sends initiated by the transport, by eventually\n+     * notifying a nested callback.</p>\n+     * <p>There are 3 sources of concurrency after a send is initiated:</p>\n+     * <ul>\n+     *   <li>the completion of the send operation, either success or failure</li>\n+     *   <li>an asynchronous failure coming from the read side such as a stream\n+     *   being reset, or the connection being closed</li>\n+     *   <li>an asynchronous idle timeout</li>\n+     * </ul>\n+     * <p>The last 2 cases may happen <em>during</em> a send, when the frames\n+     * are being generated in the flusher.\n+     * In such cases, this class must avoid that the nested callback is notified\n+     * while the frame generation is in progress, because the nested callback\n+     * may modify other states (such as clearing the {@code HttpOutput._buffer})\n+     * that are accessed during frame generation.</p>\n+     * <p>The solution implemented in this class works by splitting the send\n+     * operation in 3 parts: {@code preSend()}, {@code send()} and {@code postSend()}.\n+     * Asynchronous state changes happening during {@code send()} are stored\n+     * and only executed in {@code postSend()}, therefore never interfering\n+     * with frame generation.</p>\n+     *\n+     * @see State\n+     */\n     private class TransportCallback implements Callback\n     {\n-        private State state = State.IDLE;\n-        private Callback callback;\n-        private Throwable failure;\n-        private boolean commit;\n+        private State _state = State.IDLE;\n+        private Callback _callback;\n+        private boolean _commit;\n+        private Throwable _failure;\n \n-        public boolean start(Callback callback, boolean commit)\n+        private void reset()\n         {\n-            State state;\n+            assert Thread.holdsLock(this);\n+            _state = State.IDLE;\n+            _callback = null;\n+            _commit = false;\n+            _failure = null;\n+        }\n+\n+        private void send(Callback callback, boolean commit, Consumer<Callback> consumer)\n+        {\n+            Throwable failure = preSend(callback, commit);\n+            if (failure == null)\n+            {\n+                consumer.accept(this);\n+                postSend();\n+            }\n+            else\n+            {\n+                callback.failed(failure);\n+            }\n+        }\n+\n+        private Throwable preSend(Callback callback, boolean commit)\n+        {\n+            synchronized (this)\n+            {\n+                switch (_state)\n+                {\n+                    case IDLE:\n+                    {\n+                        _state = State.PRE_SEND;\n+                        _callback = callback;\n+                        _commit = commit;\n+                        return null;\n+                    }\n+                    default:\n+                    {\n+                        Throwable failure = _failure;\n+                        if (failure == null)\n+                            failure = new IllegalStateException(\"Invalid transport state: \" + _state);\n+                        return failure;\n+                    }\n+                }\n+            }\n+        }\n+\n+        private void postSend()\n+        {\n+            Callback callback;\n+            boolean commit;\n             Throwable failure;\n             synchronized (this)\n             {\n-                state = this.state;\n-                failure = this.failure;\n-                if (state == State.IDLE)\n+                switch (_state)\n                 {\n-                    this.state = State.WRITING;\n-                    this.callback = callback;\n-                    this.commit = commit;\n-                    return true;\n+                    case PRE_SEND:\n+                    {\n+                        _state = State.POST_SEND;\n+                        return;\n+                    }\n+                    case SUCCEED:\n+                    {\n+                        callback = _callback;\n+                        commit = _commit;\n+                        failure = null;\n+                        reset();\n+                        break;\n+                    }\n+                    case FAIL:\n+                    {\n+                        _state = State.FAILED;\n+                        callback = _callback;\n+                        commit = _commit;\n+                        failure = _failure;\n+                        break;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "42a5d2785b51f06e3440bbcf4a4d845b5f8bc5e1"}, "originalPosition": 240}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjU3Nzk2MA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            succeed(callback, commit);\n          \n          \n            \n                        else\n          \n          \n            \n                            fail(callback, commit, failure);\n          \n          \n            \n                            succeed(callback, commit);\n          \n          \n            \n                        else if (callback != null )\n          \n          \n            \n                            fail(callback, commit, failure);\n          \n          \n            \n                        else\n          \n          \n            \n                            threw new IllegalStateException();", "url": "https://github.com/eclipse/jetty.project/pull/4946#discussion_r436577960", "createdAt": "2020-06-08T09:47:45Z", "author": {"login": "gregw"}, "path": "jetty-http2/http2-server/src/main/java/org/eclipse/jetty/http2/server/HttpTransportOverHTTP2.java", "diffHunk": "@@ -350,119 +351,356 @@ public void abort(Throwable failure)\n             stream.reset(new ResetFrame(stream.getId(), ErrorCode.CANCEL_STREAM_ERROR.code), Callback.NOOP);\n     }\n \n+    /**\n+     * <p>Callback that controls sends initiated by the transport, by eventually\n+     * notifying a nested callback.</p>\n+     * <p>There are 3 sources of concurrency after a send is initiated:</p>\n+     * <ul>\n+     *   <li>the completion of the send operation, either success or failure</li>\n+     *   <li>an asynchronous failure coming from the read side such as a stream\n+     *   being reset, or the connection being closed</li>\n+     *   <li>an asynchronous idle timeout</li>\n+     * </ul>\n+     * <p>The last 2 cases may happen <em>during</em> a send, when the frames\n+     * are being generated in the flusher.\n+     * In such cases, this class must avoid that the nested callback is notified\n+     * while the frame generation is in progress, because the nested callback\n+     * may modify other states (such as clearing the {@code HttpOutput._buffer})\n+     * that are accessed during frame generation.</p>\n+     * <p>The solution implemented in this class works by splitting the send\n+     * operation in 3 parts: {@code preSend()}, {@code send()} and {@code postSend()}.\n+     * Asynchronous state changes happening during {@code send()} are stored\n+     * and only executed in {@code postSend()}, therefore never interfering\n+     * with frame generation.</p>\n+     *\n+     * @see State\n+     */\n     private class TransportCallback implements Callback\n     {\n-        private State state = State.IDLE;\n-        private Callback callback;\n-        private Throwable failure;\n-        private boolean commit;\n+        private State _state = State.IDLE;\n+        private Callback _callback;\n+        private boolean _commit;\n+        private Throwable _failure;\n \n-        public boolean start(Callback callback, boolean commit)\n+        private void reset()\n         {\n-            State state;\n+            assert Thread.holdsLock(this);\n+            _state = State.IDLE;\n+            _callback = null;\n+            _commit = false;\n+            _failure = null;\n+        }\n+\n+        private void send(Callback callback, boolean commit, Consumer<Callback> consumer)\n+        {\n+            Throwable failure = preSend(callback, commit);\n+            if (failure == null)\n+            {\n+                consumer.accept(this);\n+                postSend();\n+            }\n+            else\n+            {\n+                callback.failed(failure);\n+            }\n+        }\n+\n+        private Throwable preSend(Callback callback, boolean commit)\n+        {\n+            synchronized (this)\n+            {\n+                switch (_state)\n+                {\n+                    case IDLE:\n+                    {\n+                        _state = State.PRE_SEND;\n+                        _callback = callback;\n+                        _commit = commit;\n+                        return null;\n+                    }\n+                    default:\n+                    {\n+                        Throwable failure = _failure;\n+                        if (failure == null)\n+                            failure = new IllegalStateException(\"Invalid transport state: \" + _state);\n+                        return failure;\n+                    }\n+                }\n+            }\n+        }\n+\n+        private void postSend()\n+        {\n+            Callback callback;\n+            boolean commit;\n             Throwable failure;\n             synchronized (this)\n             {\n-                state = this.state;\n-                failure = this.failure;\n-                if (state == State.IDLE)\n+                switch (_state)\n                 {\n-                    this.state = State.WRITING;\n-                    this.callback = callback;\n-                    this.commit = commit;\n-                    return true;\n+                    case PRE_SEND:\n+                    {\n+                        _state = State.POST_SEND;\n+                        return;\n+                    }\n+                    case SUCCEED:\n+                    {\n+                        callback = _callback;\n+                        commit = _commit;\n+                        failure = null;\n+                        reset();\n+                        break;\n+                    }\n+                    case FAIL:\n+                    {\n+                        _state = State.FAILED;\n+                        callback = _callback;\n+                        commit = _commit;\n+                        failure = _failure;\n+                        break;\n+                    }\n+                    default:\n+                    {\n+                        _state = State.FAILED;\n+                        _failure = new IllegalStateException(\"Invalid transport state: \" + _state);\n+                        callback = _callback;\n+                        commit = _commit;\n+                        failure = _failure;\n+                        break;\n+                    }\n                 }\n             }\n             if (failure == null)\n-                failure = new IllegalStateException(\"Invalid transport state: \" + state);\n-            callback.failed(failure);\n-            return false;\n+                succeed(callback, commit);\n+            else\n+                fail(callback, commit, failure);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "42a5d2785b51f06e3440bbcf4a4d845b5f8bc5e1"}, "originalPosition": 259}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4c9bd59ae2b720b46d58bf1fc61e8f067993b5fb", "author": {"user": {"login": "sbordet", "name": "Simone Bordet"}}, "url": "https://github.com/eclipse/jetty.project/commit/4c9bd59ae2b720b46d58bf1fc61e8f067993b5fb", "committedDate": "2020-06-08T10:42:47Z", "message": "Issue #4855 - Occasional h2spec failures on CI\n\nMore comments after review.\n\nSigned-off-by: Simone Bordet <simone.bordet@gmail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ee5183906cf9ffcbf4010d13b96857a92b0a8dc0", "author": {"user": {"login": "sbordet", "name": "Simone Bordet"}}, "url": "https://github.com/eclipse/jetty.project/commit/ee5183906cf9ffcbf4010d13b96857a92b0a8dc0", "committedDate": "2020-06-08T11:20:43Z", "message": "Issue #4855 - Occasional h2spec failures on CI\n\nUpdates after review.\n\nSigned-off-by: Simone Bordet <simone.bordet@gmail.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI2MTM4Nzc0", "url": "https://github.com/eclipse/jetty.project/pull/4946#pullrequestreview-426138774", "createdAt": "2020-06-08T11:28:59Z", "commit": {"oid": "ee5183906cf9ffcbf4010d13b96857a92b0a8dc0"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOFQxMToyODo1OVrOGgZoFA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOFQxMTozOTozMlrOGgZ6gA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjYyNzQ3Ng==", "bodyText": "I think we should null _callback whenever we take it.", "url": "https://github.com/eclipse/jetty.project/pull/4946#discussion_r436627476", "createdAt": "2020-06-08T11:28:59Z", "author": {"login": "gregw"}, "path": "jetty-http2/http2-server/src/main/java/org/eclipse/jetty/http2/server/HttpTransportOverHTTP2.java", "diffHunk": "@@ -350,119 +351,363 @@ public void abort(Throwable failure)\n             stream.reset(new ResetFrame(stream.getId(), ErrorCode.CANCEL_STREAM_ERROR.code), Callback.NOOP);\n     }\n \n+    /**\n+     * <p>Callback that controls sends initiated by the transport, by eventually\n+     * notifying a nested callback.</p>\n+     * <p>There are 3 sources of concurrency after a send is initiated:</p>\n+     * <ul>\n+     *   <li>the completion of the send operation, either success or failure</li>\n+     *   <li>an asynchronous failure coming from the read side such as a stream\n+     *   being reset, or the connection being closed</li>\n+     *   <li>an asynchronous idle timeout</li>\n+     * </ul>\n+     * <p>The last 2 cases may happen <em>during</em> a send, when the frames\n+     * are being generated in the flusher.\n+     * In such cases, this class must avoid that the nested callback is notified\n+     * while the frame generation is in progress, because the nested callback\n+     * may modify other states (such as clearing the {@code HttpOutput._buffer})\n+     * that are accessed during frame generation.</p>\n+     * <p>The solution implemented in this class works by splitting the send\n+     * operation in 3 parts: {@code pre-send}, {@code send} and {@code post-send}.\n+     * Asynchronous state changes happening during {@code send} are stored\n+     * and only executed in {@code post-send}, therefore never interfering\n+     * with frame generation.</p>\n+     *\n+     * @see State\n+     */\n     private class TransportCallback implements Callback\n     {\n-        private State state = State.IDLE;\n-        private Callback callback;\n-        private Throwable failure;\n-        private boolean commit;\n+        private State _state = State.IDLE;\n+        private Callback _callback;\n+        private boolean _commit;\n+        private Throwable _failure;\n \n-        public boolean start(Callback callback, boolean commit)\n+        private void reset()\n         {\n-            State state;\n+            assert Thread.holdsLock(this);\n+            _state = State.IDLE;\n+            _callback = null;\n+            _commit = false;\n+            _failure = null;\n+        }\n+\n+        private void send(Callback callback, boolean commit, Consumer<Callback> sendFrame)\n+        {\n+            Throwable failure = sending(callback, commit);\n+            if (failure == null)\n+            {\n+                sendFrame.accept(this);\n+                pending();\n+            }\n+            else\n+            {\n+                callback.failed(failure);\n+            }\n+        }\n+\n+        private Throwable sending(Callback callback, boolean commit)\n+        {\n+            synchronized (this)\n+            {\n+                switch (_state)\n+                {\n+                    case IDLE:\n+                    {\n+                        _state = State.SENDING;\n+                        _callback = callback;\n+                        _commit = commit;\n+                        return null;\n+                    }\n+                    case FAILED:\n+                    {\n+                        return _failure;\n+                    }\n+                    default:\n+                    {\n+                        return new IllegalStateException(\"Invalid transport state: \" + _state);\n+                    }\n+                }\n+            }\n+        }\n+\n+        private void pending()\n+        {\n+            Callback callback;\n+            boolean commit;\n             Throwable failure;\n             synchronized (this)\n             {\n-                state = this.state;\n-                failure = this.failure;\n-                if (state == State.IDLE)\n+                switch (_state)\n                 {\n-                    this.state = State.WRITING;\n-                    this.callback = callback;\n-                    this.commit = commit;\n-                    return true;\n+                    case SENDING:\n+                    {\n+                        // The send has not completed the callback yet,\n+                        // wait for succeeded() or failed() to be called.\n+                        _state = State.PENDING;\n+                        return;\n+                    }\n+                    case SUCCEEDING:\n+                    {\n+                        // The send already completed successfully, but the\n+                        // call to succeeded() was delayed, so call it now.\n+                        callback = _callback;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ee5183906cf9ffcbf4010d13b96857a92b0a8dc0"}, "originalPosition": 233}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjYyNzg4NQ==", "bodyText": "if we null _callback when we take it, we can throw ISE here if it is not null", "url": "https://github.com/eclipse/jetty.project/pull/4946#discussion_r436627885", "createdAt": "2020-06-08T11:29:52Z", "author": {"login": "gregw"}, "path": "jetty-http2/http2-server/src/main/java/org/eclipse/jetty/http2/server/HttpTransportOverHTTP2.java", "diffHunk": "@@ -350,119 +351,363 @@ public void abort(Throwable failure)\n             stream.reset(new ResetFrame(stream.getId(), ErrorCode.CANCEL_STREAM_ERROR.code), Callback.NOOP);\n     }\n \n+    /**\n+     * <p>Callback that controls sends initiated by the transport, by eventually\n+     * notifying a nested callback.</p>\n+     * <p>There are 3 sources of concurrency after a send is initiated:</p>\n+     * <ul>\n+     *   <li>the completion of the send operation, either success or failure</li>\n+     *   <li>an asynchronous failure coming from the read side such as a stream\n+     *   being reset, or the connection being closed</li>\n+     *   <li>an asynchronous idle timeout</li>\n+     * </ul>\n+     * <p>The last 2 cases may happen <em>during</em> a send, when the frames\n+     * are being generated in the flusher.\n+     * In such cases, this class must avoid that the nested callback is notified\n+     * while the frame generation is in progress, because the nested callback\n+     * may modify other states (such as clearing the {@code HttpOutput._buffer})\n+     * that are accessed during frame generation.</p>\n+     * <p>The solution implemented in this class works by splitting the send\n+     * operation in 3 parts: {@code pre-send}, {@code send} and {@code post-send}.\n+     * Asynchronous state changes happening during {@code send} are stored\n+     * and only executed in {@code post-send}, therefore never interfering\n+     * with frame generation.</p>\n+     *\n+     * @see State\n+     */\n     private class TransportCallback implements Callback\n     {\n-        private State state = State.IDLE;\n-        private Callback callback;\n-        private Throwable failure;\n-        private boolean commit;\n+        private State _state = State.IDLE;\n+        private Callback _callback;\n+        private boolean _commit;\n+        private Throwable _failure;\n \n-        public boolean start(Callback callback, boolean commit)\n+        private void reset()\n         {\n-            State state;\n+            assert Thread.holdsLock(this);\n+            _state = State.IDLE;\n+            _callback = null;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ee5183906cf9ffcbf4010d13b96857a92b0a8dc0"}, "originalPosition": 162}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjYyOTQzOA==", "bodyText": "I kind of think the timeout should win this race.  Who knows what else has been closed already by the timeout, plus the timeout might be due to a really slow generation of the frame.", "url": "https://github.com/eclipse/jetty.project/pull/4946#discussion_r436629438", "createdAt": "2020-06-08T11:33:05Z", "author": {"login": "gregw"}, "path": "jetty-http2/http2-server/src/main/java/org/eclipse/jetty/http2/server/HttpTransportOverHTTP2.java", "diffHunk": "@@ -350,119 +351,363 @@ public void abort(Throwable failure)\n             stream.reset(new ResetFrame(stream.getId(), ErrorCode.CANCEL_STREAM_ERROR.code), Callback.NOOP);\n     }\n \n+    /**\n+     * <p>Callback that controls sends initiated by the transport, by eventually\n+     * notifying a nested callback.</p>\n+     * <p>There are 3 sources of concurrency after a send is initiated:</p>\n+     * <ul>\n+     *   <li>the completion of the send operation, either success or failure</li>\n+     *   <li>an asynchronous failure coming from the read side such as a stream\n+     *   being reset, or the connection being closed</li>\n+     *   <li>an asynchronous idle timeout</li>\n+     * </ul>\n+     * <p>The last 2 cases may happen <em>during</em> a send, when the frames\n+     * are being generated in the flusher.\n+     * In such cases, this class must avoid that the nested callback is notified\n+     * while the frame generation is in progress, because the nested callback\n+     * may modify other states (such as clearing the {@code HttpOutput._buffer})\n+     * that are accessed during frame generation.</p>\n+     * <p>The solution implemented in this class works by splitting the send\n+     * operation in 3 parts: {@code pre-send}, {@code send} and {@code post-send}.\n+     * Asynchronous state changes happening during {@code send} are stored\n+     * and only executed in {@code post-send}, therefore never interfering\n+     * with frame generation.</p>\n+     *\n+     * @see State\n+     */\n     private class TransportCallback implements Callback\n     {\n-        private State state = State.IDLE;\n-        private Callback callback;\n-        private Throwable failure;\n-        private boolean commit;\n+        private State _state = State.IDLE;\n+        private Callback _callback;\n+        private boolean _commit;\n+        private Throwable _failure;\n \n-        public boolean start(Callback callback, boolean commit)\n+        private void reset()\n         {\n-            State state;\n+            assert Thread.holdsLock(this);\n+            _state = State.IDLE;\n+            _callback = null;\n+            _commit = false;\n+            _failure = null;\n+        }\n+\n+        private void send(Callback callback, boolean commit, Consumer<Callback> sendFrame)\n+        {\n+            Throwable failure = sending(callback, commit);\n+            if (failure == null)\n+            {\n+                sendFrame.accept(this);\n+                pending();\n+            }\n+            else\n+            {\n+                callback.failed(failure);\n+            }\n+        }\n+\n+        private Throwable sending(Callback callback, boolean commit)\n+        {\n+            synchronized (this)\n+            {\n+                switch (_state)\n+                {\n+                    case IDLE:\n+                    {\n+                        _state = State.SENDING;\n+                        _callback = callback;\n+                        _commit = commit;\n+                        return null;\n+                    }\n+                    case FAILED:\n+                    {\n+                        return _failure;\n+                    }\n+                    default:\n+                    {\n+                        return new IllegalStateException(\"Invalid transport state: \" + _state);\n+                    }\n+                }\n+            }\n+        }\n+\n+        private void pending()\n+        {\n+            Callback callback;\n+            boolean commit;\n             Throwable failure;\n             synchronized (this)\n             {\n-                state = this.state;\n-                failure = this.failure;\n-                if (state == State.IDLE)\n+                switch (_state)\n                 {\n-                    this.state = State.WRITING;\n-                    this.callback = callback;\n-                    this.commit = commit;\n-                    return true;\n+                    case SENDING:\n+                    {\n+                        // The send has not completed the callback yet,\n+                        // wait for succeeded() or failed() to be called.\n+                        _state = State.PENDING;\n+                        return;\n+                    }\n+                    case SUCCEEDING:\n+                    {\n+                        // The send already completed successfully, but the\n+                        // call to succeeded() was delayed, so call it now.\n+                        callback = _callback;\n+                        commit = _commit;\n+                        failure = null;\n+                        reset();\n+                        break;\n+                    }\n+                    case FAILING:\n+                    {\n+                        // The send already completed with a failure, but\n+                        // the call to failed() was delayed, so call it now.\n+                        _state = State.FAILED;\n+                        callback = _callback;\n+                        commit = _commit;\n+                        failure = _failure;\n+                        break;\n+                    }\n+                    default:\n+                    {\n+                        _state = State.FAILED;\n+                        _failure = new IllegalStateException(\"Invalid transport state: \" + _state);\n+                        callback = _callback;\n+                        commit = _commit;\n+                        failure = _failure;\n+                        break;\n+                    }\n                 }\n             }\n             if (failure == null)\n-                failure = new IllegalStateException(\"Invalid transport state: \" + state);\n-            callback.failed(failure);\n-            return false;\n+                succeed(callback, commit);\n+            else\n+                fail(callback, commit, failure);\n         }\n \n         @Override\n         public void succeeded()\n         {\n+            Callback callback;\n             boolean commit;\n-            Callback callback = null;\n             synchronized (this)\n             {\n-                commit = this.commit;\n-                if (state == State.WRITING)\n+                switch (_state)\n                 {\n-                    this.state = State.IDLE;\n-                    callback = this.callback;\n-                    this.callback = null;\n-                    this.commit = false;\n+                    case SENDING:\n+                    {\n+                        _state = State.SUCCEEDING;\n+                        // Succeeding the callback will be done in postSend().\n+                        return;\n+                    }\n+                    case PENDING:\n+                    {\n+                        callback = _callback;\n+                        commit = _commit;\n+                        reset();\n+                        break;\n+                    }\n+                    default:\n+                    {\n+                        // This thread lost the race to succeed the current\n+                        // send, as other threads likely already failed it.\n+                        return;\n+                    }\n                 }\n             }\n-            if (LOG.isDebugEnabled())\n-                LOG.debug(\"HTTP2 Response #{}/{} {} {}\",\n-                    stream.getId(), Integer.toHexString(stream.getSession().hashCode()),\n-                    commit ? \"commit\" : \"flush\",\n-                    callback == null ? \"failure\" : \"success\");\n-            if (callback != null)\n-                callback.succeeded();\n+            succeed(callback, commit);\n         }\n \n         @Override\n         public void failed(Throwable failure)\n         {\n-            boolean commit;\n             Callback callback;\n+            boolean commit;\n             synchronized (this)\n             {\n-                commit = this.commit;\n-                this.state = State.FAILED;\n-                callback = this.callback;\n-                this.callback = null;\n-                this.failure = failure;\n+                switch (_state)\n+                {\n+                    case SENDING:\n+                    {\n+                        _state = State.FAILING;\n+                        _failure = failure;\n+                        // Failing the callback will be done in postSend().\n+                        return;\n+                    }\n+                    case IDLE:\n+                    case PENDING:\n+                    {\n+                        _state = State.FAILED;\n+                        _failure = failure;\n+                        callback = _callback;\n+                        commit = _commit;\n+                        break;\n+                    }\n+                    default:\n+                    {\n+                        // This thread lost the race to fail the current send,\n+                        // as other threads already succeeded or failed it.\n+                        return;\n+                    }\n+                }\n             }\n-            if (LOG.isDebugEnabled())\n-                LOG.debug(String.format(\"HTTP2 Response #%d/%h %s %s\", stream.getId(), stream.getSession(),\n-                    commit ? \"commit\" : \"flush\", callback == null ? \"ignored\" : \"failed\"), failure);\n-            if (callback != null)\n-                callback.failed(failure);\n+            fail(callback, commit, failure);\n         }\n \n-        private boolean onIdleTimeout(Throwable failure)\n+        private boolean idleTimeout(Throwable failure)\n         {\n-            boolean result;\n-            Callback callback = null;\n+            Callback callback;\n+            boolean timeout;\n             synchronized (this)\n             {\n-                // Ignore idle timeouts if not writing,\n-                // as the application may be suspended.\n-                result = state == State.WRITING;\n-                if (result)\n+                switch (_state)\n                 {\n-                    this.state = State.TIMEOUT;\n-                    callback = this.callback;\n-                    this.callback = null;\n-                    this.failure = failure;\n+                    case PENDING:\n+                    {\n+                        // The send was started but idle timed out, fail it.\n+                        _state = State.FAILED;\n+                        _failure = failure;\n+                        callback = _callback;\n+                        timeout = true;\n+                        break;\n+                    }\n+                    case IDLE:\n+                        // The application may be suspended, ignore the idle timeout.\n+                    case SENDING:\n+                        // A send has been started at the same time of an idle timeout;\n+                        // Ignore the idle timeout and let the write continue normally.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ee5183906cf9ffcbf4010d13b96857a92b0a8dc0"}, "originalPosition": 395}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjYyOTg2OQ==", "bodyText": "just inline the idleTimeout method here.", "url": "https://github.com/eclipse/jetty.project/pull/4946#discussion_r436629869", "createdAt": "2020-06-08T11:34:09Z", "author": {"login": "gregw"}, "path": "jetty-http2/http2-server/src/main/java/org/eclipse/jetty/http2/server/HttpTransportOverHTTP2.java", "diffHunk": "@@ -350,119 +351,363 @@ public void abort(Throwable failure)\n             stream.reset(new ResetFrame(stream.getId(), ErrorCode.CANCEL_STREAM_ERROR.code), Callback.NOOP);\n     }\n \n+    /**\n+     * <p>Callback that controls sends initiated by the transport, by eventually\n+     * notifying a nested callback.</p>\n+     * <p>There are 3 sources of concurrency after a send is initiated:</p>\n+     * <ul>\n+     *   <li>the completion of the send operation, either success or failure</li>\n+     *   <li>an asynchronous failure coming from the read side such as a stream\n+     *   being reset, or the connection being closed</li>\n+     *   <li>an asynchronous idle timeout</li>\n+     * </ul>\n+     * <p>The last 2 cases may happen <em>during</em> a send, when the frames\n+     * are being generated in the flusher.\n+     * In such cases, this class must avoid that the nested callback is notified\n+     * while the frame generation is in progress, because the nested callback\n+     * may modify other states (such as clearing the {@code HttpOutput._buffer})\n+     * that are accessed during frame generation.</p>\n+     * <p>The solution implemented in this class works by splitting the send\n+     * operation in 3 parts: {@code pre-send}, {@code send} and {@code post-send}.\n+     * Asynchronous state changes happening during {@code send} are stored\n+     * and only executed in {@code post-send}, therefore never interfering\n+     * with frame generation.</p>\n+     *\n+     * @see State\n+     */\n     private class TransportCallback implements Callback\n     {\n-        private State state = State.IDLE;\n-        private Callback callback;\n-        private Throwable failure;\n-        private boolean commit;\n+        private State _state = State.IDLE;\n+        private Callback _callback;\n+        private boolean _commit;\n+        private Throwable _failure;\n \n-        public boolean start(Callback callback, boolean commit)\n+        private void reset()\n         {\n-            State state;\n+            assert Thread.holdsLock(this);\n+            _state = State.IDLE;\n+            _callback = null;\n+            _commit = false;\n+            _failure = null;\n+        }\n+\n+        private void send(Callback callback, boolean commit, Consumer<Callback> sendFrame)\n+        {\n+            Throwable failure = sending(callback, commit);\n+            if (failure == null)\n+            {\n+                sendFrame.accept(this);\n+                pending();\n+            }\n+            else\n+            {\n+                callback.failed(failure);\n+            }\n+        }\n+\n+        private Throwable sending(Callback callback, boolean commit)\n+        {\n+            synchronized (this)\n+            {\n+                switch (_state)\n+                {\n+                    case IDLE:\n+                    {\n+                        _state = State.SENDING;\n+                        _callback = callback;\n+                        _commit = commit;\n+                        return null;\n+                    }\n+                    case FAILED:\n+                    {\n+                        return _failure;\n+                    }\n+                    default:\n+                    {\n+                        return new IllegalStateException(\"Invalid transport state: \" + _state);\n+                    }\n+                }\n+            }\n+        }\n+\n+        private void pending()\n+        {\n+            Callback callback;\n+            boolean commit;\n             Throwable failure;\n             synchronized (this)\n             {\n-                state = this.state;\n-                failure = this.failure;\n-                if (state == State.IDLE)\n+                switch (_state)\n                 {\n-                    this.state = State.WRITING;\n-                    this.callback = callback;\n-                    this.commit = commit;\n-                    return true;\n+                    case SENDING:\n+                    {\n+                        // The send has not completed the callback yet,\n+                        // wait for succeeded() or failed() to be called.\n+                        _state = State.PENDING;\n+                        return;\n+                    }\n+                    case SUCCEEDING:\n+                    {\n+                        // The send already completed successfully, but the\n+                        // call to succeeded() was delayed, so call it now.\n+                        callback = _callback;\n+                        commit = _commit;\n+                        failure = null;\n+                        reset();\n+                        break;\n+                    }\n+                    case FAILING:\n+                    {\n+                        // The send already completed with a failure, but\n+                        // the call to failed() was delayed, so call it now.\n+                        _state = State.FAILED;\n+                        callback = _callback;\n+                        commit = _commit;\n+                        failure = _failure;\n+                        break;\n+                    }\n+                    default:\n+                    {\n+                        _state = State.FAILED;\n+                        _failure = new IllegalStateException(\"Invalid transport state: \" + _state);\n+                        callback = _callback;\n+                        commit = _commit;\n+                        failure = _failure;\n+                        break;\n+                    }\n                 }\n             }\n             if (failure == null)\n-                failure = new IllegalStateException(\"Invalid transport state: \" + state);\n-            callback.failed(failure);\n-            return false;\n+                succeed(callback, commit);\n+            else\n+                fail(callback, commit, failure);\n         }\n \n         @Override\n         public void succeeded()\n         {\n+            Callback callback;\n             boolean commit;\n-            Callback callback = null;\n             synchronized (this)\n             {\n-                commit = this.commit;\n-                if (state == State.WRITING)\n+                switch (_state)\n                 {\n-                    this.state = State.IDLE;\n-                    callback = this.callback;\n-                    this.callback = null;\n-                    this.commit = false;\n+                    case SENDING:\n+                    {\n+                        _state = State.SUCCEEDING;\n+                        // Succeeding the callback will be done in postSend().\n+                        return;\n+                    }\n+                    case PENDING:\n+                    {\n+                        callback = _callback;\n+                        commit = _commit;\n+                        reset();\n+                        break;\n+                    }\n+                    default:\n+                    {\n+                        // This thread lost the race to succeed the current\n+                        // send, as other threads likely already failed it.\n+                        return;\n+                    }\n                 }\n             }\n-            if (LOG.isDebugEnabled())\n-                LOG.debug(\"HTTP2 Response #{}/{} {} {}\",\n-                    stream.getId(), Integer.toHexString(stream.getSession().hashCode()),\n-                    commit ? \"commit\" : \"flush\",\n-                    callback == null ? \"failure\" : \"success\");\n-            if (callback != null)\n-                callback.succeeded();\n+            succeed(callback, commit);\n         }\n \n         @Override\n         public void failed(Throwable failure)\n         {\n-            boolean commit;\n             Callback callback;\n+            boolean commit;\n             synchronized (this)\n             {\n-                commit = this.commit;\n-                this.state = State.FAILED;\n-                callback = this.callback;\n-                this.callback = null;\n-                this.failure = failure;\n+                switch (_state)\n+                {\n+                    case SENDING:\n+                    {\n+                        _state = State.FAILING;\n+                        _failure = failure;\n+                        // Failing the callback will be done in postSend().\n+                        return;\n+                    }\n+                    case IDLE:\n+                    case PENDING:\n+                    {\n+                        _state = State.FAILED;\n+                        _failure = failure;\n+                        callback = _callback;\n+                        commit = _commit;\n+                        break;\n+                    }\n+                    default:\n+                    {\n+                        // This thread lost the race to fail the current send,\n+                        // as other threads already succeeded or failed it.\n+                        return;\n+                    }\n+                }\n             }\n-            if (LOG.isDebugEnabled())\n-                LOG.debug(String.format(\"HTTP2 Response #%d/%h %s %s\", stream.getId(), stream.getSession(),\n-                    commit ? \"commit\" : \"flush\", callback == null ? \"ignored\" : \"failed\"), failure);\n-            if (callback != null)\n-                callback.failed(failure);\n+            fail(callback, commit, failure);\n         }\n \n-        private boolean onIdleTimeout(Throwable failure)\n+        private boolean idleTimeout(Throwable failure)\n         {\n-            boolean result;\n-            Callback callback = null;\n+            Callback callback;\n+            boolean timeout;\n             synchronized (this)\n             {\n-                // Ignore idle timeouts if not writing,\n-                // as the application may be suspended.\n-                result = state == State.WRITING;\n-                if (result)\n+                switch (_state)\n                 {\n-                    this.state = State.TIMEOUT;\n-                    callback = this.callback;\n-                    this.callback = null;\n-                    this.failure = failure;\n+                    case PENDING:\n+                    {\n+                        // The send was started but idle timed out, fail it.\n+                        _state = State.FAILED;\n+                        _failure = failure;\n+                        callback = _callback;\n+                        timeout = true;\n+                        break;\n+                    }\n+                    case IDLE:\n+                        // The application may be suspended, ignore the idle timeout.\n+                    case SENDING:\n+                        // A send has been started at the same time of an idle timeout;\n+                        // Ignore the idle timeout and let the write continue normally.\n+                    case SUCCEEDING:\n+                    case FAILING:\n+                        // An idle timeout during these transient states is ignored.\n+                    case FAILED:\n+                        // Already failed, ignore the idle timeout.\n+                    {\n+                        callback = null;\n+                        timeout = false;\n+                        break;\n+                    }\n+                    default:\n+                    {\n+                        // Should not happen, but just in case.\n+                        _state = State.FAILED;\n+                        _failure = new IllegalStateException(\"Invalid transport state: \" + _state, failure);\n+                        callback = _callback;\n+                        if (callback == null)\n+                            callback = Callback.NOOP;\n+                        timeout = true;\n+                        failure = _failure;\n+                        break;\n+                    }\n                 }\n             }\n+            idleTimeout(callback, timeout, failure);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ee5183906cf9ffcbf4010d13b96857a92b0a8dc0"}, "originalPosition": 420}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjYzMDk2NQ==", "bodyText": "perhaps onCompleteSuccess  to tie in with common behaviour of IteratingCallback?", "url": "https://github.com/eclipse/jetty.project/pull/4946#discussion_r436630965", "createdAt": "2020-06-08T11:36:25Z", "author": {"login": "gregw"}, "path": "jetty-http2/http2-server/src/main/java/org/eclipse/jetty/http2/server/HttpTransportOverHTTP2.java", "diffHunk": "@@ -350,119 +351,363 @@ public void abort(Throwable failure)\n             stream.reset(new ResetFrame(stream.getId(), ErrorCode.CANCEL_STREAM_ERROR.code), Callback.NOOP);\n     }\n \n+    /**\n+     * <p>Callback that controls sends initiated by the transport, by eventually\n+     * notifying a nested callback.</p>\n+     * <p>There are 3 sources of concurrency after a send is initiated:</p>\n+     * <ul>\n+     *   <li>the completion of the send operation, either success or failure</li>\n+     *   <li>an asynchronous failure coming from the read side such as a stream\n+     *   being reset, or the connection being closed</li>\n+     *   <li>an asynchronous idle timeout</li>\n+     * </ul>\n+     * <p>The last 2 cases may happen <em>during</em> a send, when the frames\n+     * are being generated in the flusher.\n+     * In such cases, this class must avoid that the nested callback is notified\n+     * while the frame generation is in progress, because the nested callback\n+     * may modify other states (such as clearing the {@code HttpOutput._buffer})\n+     * that are accessed during frame generation.</p>\n+     * <p>The solution implemented in this class works by splitting the send\n+     * operation in 3 parts: {@code pre-send}, {@code send} and {@code post-send}.\n+     * Asynchronous state changes happening during {@code send} are stored\n+     * and only executed in {@code post-send}, therefore never interfering\n+     * with frame generation.</p>\n+     *\n+     * @see State\n+     */\n     private class TransportCallback implements Callback\n     {\n-        private State state = State.IDLE;\n-        private Callback callback;\n-        private Throwable failure;\n-        private boolean commit;\n+        private State _state = State.IDLE;\n+        private Callback _callback;\n+        private boolean _commit;\n+        private Throwable _failure;\n \n-        public boolean start(Callback callback, boolean commit)\n+        private void reset()\n         {\n-            State state;\n+            assert Thread.holdsLock(this);\n+            _state = State.IDLE;\n+            _callback = null;\n+            _commit = false;\n+            _failure = null;\n+        }\n+\n+        private void send(Callback callback, boolean commit, Consumer<Callback> sendFrame)\n+        {\n+            Throwable failure = sending(callback, commit);\n+            if (failure == null)\n+            {\n+                sendFrame.accept(this);\n+                pending();\n+            }\n+            else\n+            {\n+                callback.failed(failure);\n+            }\n+        }\n+\n+        private Throwable sending(Callback callback, boolean commit)\n+        {\n+            synchronized (this)\n+            {\n+                switch (_state)\n+                {\n+                    case IDLE:\n+                    {\n+                        _state = State.SENDING;\n+                        _callback = callback;\n+                        _commit = commit;\n+                        return null;\n+                    }\n+                    case FAILED:\n+                    {\n+                        return _failure;\n+                    }\n+                    default:\n+                    {\n+                        return new IllegalStateException(\"Invalid transport state: \" + _state);\n+                    }\n+                }\n+            }\n+        }\n+\n+        private void pending()\n+        {\n+            Callback callback;\n+            boolean commit;\n             Throwable failure;\n             synchronized (this)\n             {\n-                state = this.state;\n-                failure = this.failure;\n-                if (state == State.IDLE)\n+                switch (_state)\n                 {\n-                    this.state = State.WRITING;\n-                    this.callback = callback;\n-                    this.commit = commit;\n-                    return true;\n+                    case SENDING:\n+                    {\n+                        // The send has not completed the callback yet,\n+                        // wait for succeeded() or failed() to be called.\n+                        _state = State.PENDING;\n+                        return;\n+                    }\n+                    case SUCCEEDING:\n+                    {\n+                        // The send already completed successfully, but the\n+                        // call to succeeded() was delayed, so call it now.\n+                        callback = _callback;\n+                        commit = _commit;\n+                        failure = null;\n+                        reset();\n+                        break;\n+                    }\n+                    case FAILING:\n+                    {\n+                        // The send already completed with a failure, but\n+                        // the call to failed() was delayed, so call it now.\n+                        _state = State.FAILED;\n+                        callback = _callback;\n+                        commit = _commit;\n+                        failure = _failure;\n+                        break;\n+                    }\n+                    default:\n+                    {\n+                        _state = State.FAILED;\n+                        _failure = new IllegalStateException(\"Invalid transport state: \" + _state);\n+                        callback = _callback;\n+                        commit = _commit;\n+                        failure = _failure;\n+                        break;\n+                    }\n                 }\n             }\n             if (failure == null)\n-                failure = new IllegalStateException(\"Invalid transport state: \" + state);\n-            callback.failed(failure);\n-            return false;\n+                succeed(callback, commit);\n+            else\n+                fail(callback, commit, failure);\n         }\n \n         @Override\n         public void succeeded()\n         {\n+            Callback callback;\n             boolean commit;\n-            Callback callback = null;\n             synchronized (this)\n             {\n-                commit = this.commit;\n-                if (state == State.WRITING)\n+                switch (_state)\n                 {\n-                    this.state = State.IDLE;\n-                    callback = this.callback;\n-                    this.callback = null;\n-                    this.commit = false;\n+                    case SENDING:\n+                    {\n+                        _state = State.SUCCEEDING;\n+                        // Succeeding the callback will be done in postSend().\n+                        return;\n+                    }\n+                    case PENDING:\n+                    {\n+                        callback = _callback;\n+                        commit = _commit;\n+                        reset();\n+                        break;\n+                    }\n+                    default:\n+                    {\n+                        // This thread lost the race to succeed the current\n+                        // send, as other threads likely already failed it.\n+                        return;\n+                    }\n                 }\n             }\n-            if (LOG.isDebugEnabled())\n-                LOG.debug(\"HTTP2 Response #{}/{} {} {}\",\n-                    stream.getId(), Integer.toHexString(stream.getSession().hashCode()),\n-                    commit ? \"commit\" : \"flush\",\n-                    callback == null ? \"failure\" : \"success\");\n-            if (callback != null)\n-                callback.succeeded();\n+            succeed(callback, commit);\n         }\n \n         @Override\n         public void failed(Throwable failure)\n         {\n-            boolean commit;\n             Callback callback;\n+            boolean commit;\n             synchronized (this)\n             {\n-                commit = this.commit;\n-                this.state = State.FAILED;\n-                callback = this.callback;\n-                this.callback = null;\n-                this.failure = failure;\n+                switch (_state)\n+                {\n+                    case SENDING:\n+                    {\n+                        _state = State.FAILING;\n+                        _failure = failure;\n+                        // Failing the callback will be done in postSend().\n+                        return;\n+                    }\n+                    case IDLE:\n+                    case PENDING:\n+                    {\n+                        _state = State.FAILED;\n+                        _failure = failure;\n+                        callback = _callback;\n+                        commit = _commit;\n+                        break;\n+                    }\n+                    default:\n+                    {\n+                        // This thread lost the race to fail the current send,\n+                        // as other threads already succeeded or failed it.\n+                        return;\n+                    }\n+                }\n             }\n-            if (LOG.isDebugEnabled())\n-                LOG.debug(String.format(\"HTTP2 Response #%d/%h %s %s\", stream.getId(), stream.getSession(),\n-                    commit ? \"commit\" : \"flush\", callback == null ? \"ignored\" : \"failed\"), failure);\n-            if (callback != null)\n-                callback.failed(failure);\n+            fail(callback, commit, failure);\n         }\n \n-        private boolean onIdleTimeout(Throwable failure)\n+        private boolean idleTimeout(Throwable failure)\n         {\n-            boolean result;\n-            Callback callback = null;\n+            Callback callback;\n+            boolean timeout;\n             synchronized (this)\n             {\n-                // Ignore idle timeouts if not writing,\n-                // as the application may be suspended.\n-                result = state == State.WRITING;\n-                if (result)\n+                switch (_state)\n                 {\n-                    this.state = State.TIMEOUT;\n-                    callback = this.callback;\n-                    this.callback = null;\n-                    this.failure = failure;\n+                    case PENDING:\n+                    {\n+                        // The send was started but idle timed out, fail it.\n+                        _state = State.FAILED;\n+                        _failure = failure;\n+                        callback = _callback;\n+                        timeout = true;\n+                        break;\n+                    }\n+                    case IDLE:\n+                        // The application may be suspended, ignore the idle timeout.\n+                    case SENDING:\n+                        // A send has been started at the same time of an idle timeout;\n+                        // Ignore the idle timeout and let the write continue normally.\n+                    case SUCCEEDING:\n+                    case FAILING:\n+                        // An idle timeout during these transient states is ignored.\n+                    case FAILED:\n+                        // Already failed, ignore the idle timeout.\n+                    {\n+                        callback = null;\n+                        timeout = false;\n+                        break;\n+                    }\n+                    default:\n+                    {\n+                        // Should not happen, but just in case.\n+                        _state = State.FAILED;\n+                        _failure = new IllegalStateException(\"Invalid transport state: \" + _state, failure);\n+                        callback = _callback;\n+                        if (callback == null)\n+                            callback = Callback.NOOP;\n+                        timeout = true;\n+                        failure = _failure;\n+                        break;\n+                    }\n                 }\n             }\n+            idleTimeout(callback, timeout, failure);\n+            return timeout;\n+        }\n+\n+        private void succeed(Callback callback, boolean commit)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ee5183906cf9ffcbf4010d13b96857a92b0a8dc0"}, "originalPosition": 424}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjYzMTYwNw==", "bodyText": "Is this an unrelated fix?", "url": "https://github.com/eclipse/jetty.project/pull/4946#discussion_r436631607", "createdAt": "2020-06-08T11:38:04Z", "author": {"login": "gregw"}, "path": "jetty-server/src/main/java/org/eclipse/jetty/server/HttpChannelState.java", "diffHunk": "@@ -819,11 +819,16 @@ protected void onError(Throwable th)\n         {\n             // If we are still async and nobody has called sendError\n             if (_requestState == RequestState.ASYNC && !_sendError)\n+            {\n                 // Then the listeners did not invoke API methods\n                 // and the container must provide a default error dispatch.\n                 sendError(th);\n-            else\n+            }\n+            // Otherwise the listeners have called AsyncContext.complete().\n+            else if (_requestState != RequestState.COMPLETE)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ee5183906cf9ffcbf4010d13b96857a92b0a8dc0"}, "originalPosition": 11}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjYzMjE5Mg==", "bodyText": "this comment comment is outside the if, so should be phrased as a conditional, or moved inside the if body", "url": "https://github.com/eclipse/jetty.project/pull/4946#discussion_r436632192", "createdAt": "2020-06-08T11:39:32Z", "author": {"login": "gregw"}, "path": "jetty-server/src/main/java/org/eclipse/jetty/server/HttpChannelState.java", "diffHunk": "@@ -819,11 +819,16 @@ protected void onError(Throwable th)\n         {\n             // If we are still async and nobody has called sendError\n             if (_requestState == RequestState.ASYNC && !_sendError)\n+            {\n                 // Then the listeners did not invoke API methods\n                 // and the container must provide a default error dispatch.\n                 sendError(th);\n-            else\n+            }\n+            // Otherwise the listeners have called AsyncContext.complete().", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ee5183906cf9ffcbf4010d13b96857a92b0a8dc0"}, "originalPosition": 10}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI2MjY4MzIw", "url": "https://github.com/eclipse/jetty.project/pull/4946#pullrequestreview-426268320", "createdAt": "2020-06-08T13:56:15Z", "commit": {"oid": "ee5183906cf9ffcbf4010d13b96857a92b0a8dc0"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "56d3a6ef5da40438ea25b304563ccc03e1555e5b", "author": {"user": {"login": "sbordet", "name": "Simone Bordet"}}, "url": "https://github.com/eclipse/jetty.project/commit/56d3a6ef5da40438ea25b304563ccc03e1555e5b", "committedDate": "2020-06-08T14:15:41Z", "message": "Issue #4855 - Occasional h2spec failures on CI\n\nUpdates after review.\n\nSigned-off-by: Simone Bordet <simone.bordet@gmail.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI2NDMxNzk5", "url": "https://github.com/eclipse/jetty.project/pull/4946#pullrequestreview-426431799", "createdAt": "2020-06-08T16:54:55Z", "commit": {"oid": "56d3a6ef5da40438ea25b304563ccc03e1555e5b"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "26ad5857e8d58ea28efc91b5e1966d02e60d33f6", "author": {"user": {"login": "sbordet", "name": "Simone Bordet"}}, "url": "https://github.com/eclipse/jetty.project/commit/26ad5857e8d58ea28efc91b5e1966d02e60d33f6", "committedDate": "2020-06-09T10:01:32Z", "message": "Issue #4855 - Occasional h2spec failures on CI\n\nFixed reset() to remember the failure.\n\nSigned-off-by: Simone Bordet <simone.bordet@gmail.com>"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 439, "cost": 1, "resetAt": "2021-11-01T13:51:04Z"}}}