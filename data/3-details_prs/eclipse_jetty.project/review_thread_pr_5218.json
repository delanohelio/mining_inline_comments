{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDc2OTc1ODk1", "number": 5218, "reviewThreads": {"totalCount": 31, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMlQxMjo1MzoxNlrOEfcKfA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNlQwNzozODoxOVrOEj7Xjw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAxNDAyNzQ4OnYy", "diffSide": "RIGHT", "path": "jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMlQxMjo1MzoxNlrOHLtqgA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMlQxMjo1MzoxNlrOHLtqgA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjA0NDU0NA==", "bodyText": "Why a release() inside reserve()?", "url": "https://github.com/eclipse/jetty.project/pull/5218#discussion_r482044544", "createdAt": "2020-09-02T12:53:16Z", "author": {"login": "sbordet"}, "path": "jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java", "diffHunk": "@@ -165,7 +201,8 @@ public Entry reserve(int allotment)\n             pending.incrementAndGet();\n \n             Entry entry = new Entry();\n-            sharedList.add(entry);\n+            entries.add(entry);\n+            strategy.released(entries, entry, true);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6ab7bd726b0e2412a5c1497348473dbac98d64a3"}, "originalPosition": 145}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAxNDA0NDg1OnYy", "diffSide": "RIGHT", "path": "jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMlQxMjo1NzozMVrOHLt1ZQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMlQxMzoxMDozNlrOHLuW6g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjA0NzMzMw==", "bodyText": "Just release() and implementations have to call entry.tryRelease() so that we're symmetric with acquire() above?", "url": "https://github.com/eclipse/jetty.project/pull/5218#discussion_r482047333", "createdAt": "2020-09-02T12:57:31Z", "author": {"login": "sbordet"}, "path": "jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java", "diffHunk": "@@ -559,4 +574,222 @@ public String toString()\n                 pooled);\n         }\n     }\n+\n+    /** A pluggable strategy to optimize pool acquisition\n+     * @param <T> The type of the items in the pool\n+     */\n+    public interface Cache<T>\n+    {\n+        /** Acquire an entry\n+         * @param entries The list of entries known to the pool. This may be concurrently modified.\n+         * @return An acquired entry or null if none can be acquired by this strategy\n+         */\n+        Pool<T>.Entry acquire(List<Pool<T>.Entry> entries);\n+\n+        /**\n+         * Notification an entry has been release.  The notification comes after the entry\n+         * has been put back in the pool and it may already have been reacquired before or during this call.\n+         * @param entries The list of entries known to the pool. This may be concurrently modified.\n+         * @param entry The entry to be release\n+         * @param reusable true if the entry is reusable and will be put back in the pool.\n+         */\n+        default void released(List<Pool<T>.Entry> entries, Pool<T>.Entry entry, boolean reusable)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6ab7bd726b0e2412a5c1497348473dbac98d64a3"}, "originalPosition": 285}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjA1NTkxNA==", "bodyText": "I second @sbordet; and wouldn't the following signature be better?\nvoid release(Pool<T>.Entry entry);\nwithout a list of entries (I can't see why it would be needed) and no default impl?", "url": "https://github.com/eclipse/jetty.project/pull/5218#discussion_r482055914", "createdAt": "2020-09-02T13:10:36Z", "author": {"login": "lorban"}, "path": "jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java", "diffHunk": "@@ -559,4 +574,222 @@ public String toString()\n                 pooled);\n         }\n     }\n+\n+    /** A pluggable strategy to optimize pool acquisition\n+     * @param <T> The type of the items in the pool\n+     */\n+    public interface Cache<T>\n+    {\n+        /** Acquire an entry\n+         * @param entries The list of entries known to the pool. This may be concurrently modified.\n+         * @return An acquired entry or null if none can be acquired by this strategy\n+         */\n+        Pool<T>.Entry acquire(List<Pool<T>.Entry> entries);\n+\n+        /**\n+         * Notification an entry has been release.  The notification comes after the entry\n+         * has been put back in the pool and it may already have been reacquired before or during this call.\n+         * @param entries The list of entries known to the pool. This may be concurrently modified.\n+         * @param entry The entry to be release\n+         * @param reusable true if the entry is reusable and will be put back in the pool.\n+         */\n+        default void released(List<Pool<T>.Entry> entries, Pool<T>.Entry entry, boolean reusable)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjA0NzMzMw=="}, "originalCommit": {"oid": "6ab7bd726b0e2412a5c1497348473dbac98d64a3"}, "originalPosition": 285}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAxNDA0NzI3OnYy", "diffSide": "RIGHT", "path": "jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMlQxMjo1ODowOFrOHLt26g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMlQxMjo1ODowOFrOHLt26g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjA0NzcyMg==", "bodyText": "Is not this class missing a remove() method?", "url": "https://github.com/eclipse/jetty.project/pull/5218#discussion_r482047722", "createdAt": "2020-09-02T12:58:08Z", "author": {"login": "sbordet"}, "path": "jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java", "diffHunk": "@@ -559,4 +574,222 @@ public String toString()\n                 pooled);\n         }\n     }\n+\n+    /** A pluggable strategy to optimize pool acquisition\n+     * @param <T> The type of the items in the pool\n+     */\n+    public interface Cache<T>\n+    {\n+        /** Acquire an entry\n+         * @param entries The list of entries known to the pool. This may be concurrently modified.\n+         * @return An acquired entry or null if none can be acquired by this strategy\n+         */\n+        Pool<T>.Entry acquire(List<Pool<T>.Entry> entries);\n+\n+        /**\n+         * Notification an entry has been release.  The notification comes after the entry\n+         * has been put back in the pool and it may already have been reacquired before or during this call.\n+         * @param entries The list of entries known to the pool. This may be concurrently modified.\n+         * @param entry The entry to be release\n+         * @param reusable true if the entry is reusable and will be put back in the pool.\n+         */\n+        default void released(List<Pool<T>.Entry> entries, Pool<T>.Entry entry, boolean reusable)\n+        {\n+        }\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6ab7bd726b0e2412a5c1497348473dbac98d64a3"}, "originalPosition": 288}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAxNDA3NzE2OnYy", "diffSide": "RIGHT", "path": "jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMlQxMzowNTowN1rOHLuI0g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMlQxMzowNTowN1rOHLuI0g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjA1MjMwNg==", "bodyText": "LinearSearchStrategy?", "url": "https://github.com/eclipse/jetty.project/pull/5218#discussion_r482052306", "createdAt": "2020-09-02T13:05:07Z", "author": {"login": "lorban"}, "path": "jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java", "diffHunk": "@@ -559,4 +574,222 @@ public String toString()\n                 pooled);\n         }\n     }\n+\n+    /** A pluggable strategy to optimize pool acquisition\n+     * @param <T> The type of the items in the pool\n+     */\n+    public interface Cache<T>\n+    {\n+        /** Acquire an entry\n+         * @param entries The list of entries known to the pool. This may be concurrently modified.\n+         * @return An acquired entry or null if none can be acquired by this strategy\n+         */\n+        Pool<T>.Entry acquire(List<Pool<T>.Entry> entries);\n+\n+        /**\n+         * Notification an entry has been release.  The notification comes after the entry\n+         * has been put back in the pool and it may already have been reacquired before or during this call.\n+         * @param entries The list of entries known to the pool. This may be concurrently modified.\n+         * @param entry The entry to be release\n+         * @param reusable true if the entry is reusable and will be put back in the pool.\n+         */\n+        default void released(List<Pool<T>.Entry> entries, Pool<T>.Entry entry, boolean reusable)\n+        {\n+        }\n+    }\n+\n+    public interface Strategy<T> extends Cache<T>\n+    {\n+    }\n+\n+    public static class CacheStrategy<T> implements Strategy<T>\n+    {\n+        final Cache<T> cache;\n+        final Strategy<T> strategy;\n+\n+        public CacheStrategy(Cache<T> cache, Strategy<T> planB)\n+        {\n+            Objects.requireNonNull(cache);\n+            Objects.requireNonNull(planB);\n+            this.cache = cache;\n+            this.strategy = planB;\n+        }\n+\n+        @Override\n+        public Pool<T>.Entry acquire(List<Pool<T>.Entry> entries)\n+        {\n+            Pool<T>.Entry entry = cache.acquire(entries);\n+            return entry == null ? strategy.acquire(entries) : entry;\n+        }\n+\n+        @Override\n+        public void released(List<Pool<T>.Entry> entries, Pool<T>.Entry entry, boolean reusable)\n+        {\n+            cache.released(entries, entry, reusable);\n+            strategy.released(entries, entry, reusable);\n+        }\n+    }\n+\n+    public static class SearchStrategy<T> implements Strategy<T>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6ab7bd726b0e2412a5c1497348473dbac98d64a3"}, "originalPosition": 322}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAxNDA3OTg4OnYy", "diffSide": "RIGHT", "path": "jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMlQxMzowNTo0OVrOHLuKjg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMlQxMzowNTo0OVrOHLuKjg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjA1Mjc1MA==", "bodyText": "private final?", "url": "https://github.com/eclipse/jetty.project/pull/5218#discussion_r482052750", "createdAt": "2020-09-02T13:05:49Z", "author": {"login": "lorban"}, "path": "jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java", "diffHunk": "@@ -559,4 +574,222 @@ public String toString()\n                 pooled);\n         }\n     }\n+\n+    /** A pluggable strategy to optimize pool acquisition\n+     * @param <T> The type of the items in the pool\n+     */\n+    public interface Cache<T>\n+    {\n+        /** Acquire an entry\n+         * @param entries The list of entries known to the pool. This may be concurrently modified.\n+         * @return An acquired entry or null if none can be acquired by this strategy\n+         */\n+        Pool<T>.Entry acquire(List<Pool<T>.Entry> entries);\n+\n+        /**\n+         * Notification an entry has been release.  The notification comes after the entry\n+         * has been put back in the pool and it may already have been reacquired before or during this call.\n+         * @param entries The list of entries known to the pool. This may be concurrently modified.\n+         * @param entry The entry to be release\n+         * @param reusable true if the entry is reusable and will be put back in the pool.\n+         */\n+        default void released(List<Pool<T>.Entry> entries, Pool<T>.Entry entry, boolean reusable)\n+        {\n+        }\n+    }\n+\n+    public interface Strategy<T> extends Cache<T>\n+    {\n+    }\n+\n+    public static class CacheStrategy<T> implements Strategy<T>\n+    {\n+        final Cache<T> cache;\n+        final Strategy<T> strategy;\n+\n+        public CacheStrategy(Cache<T> cache, Strategy<T> planB)\n+        {\n+            Objects.requireNonNull(cache);\n+            Objects.requireNonNull(planB);\n+            this.cache = cache;\n+            this.strategy = planB;\n+        }\n+\n+        @Override\n+        public Pool<T>.Entry acquire(List<Pool<T>.Entry> entries)\n+        {\n+            Pool<T>.Entry entry = cache.acquire(entries);\n+            return entry == null ? strategy.acquire(entries) : entry;\n+        }\n+\n+        @Override\n+        public void released(List<Pool<T>.Entry> entries, Pool<T>.Entry entry, boolean reusable)\n+        {\n+            cache.released(entries, entry, reusable);\n+            strategy.released(entries, entry, reusable);\n+        }\n+    }\n+\n+    public static class SearchStrategy<T> implements Strategy<T>\n+    {\n+        @Override\n+        public Pool<T>.Entry acquire(List<Pool<T>.Entry> entries)\n+        {\n+            for (Pool<T>.Entry e : entries)\n+            {\n+                if (e.tryAcquire())\n+                    return e;\n+            }\n+            return null;\n+        }\n+    }\n+\n+    public static class ThreadLocalCache<T> implements Cache<T>\n+    {\n+        private final ThreadLocal<Pool<T>.Entry> last;\n+\n+        ThreadLocalCache()\n+        {\n+            last = new ThreadLocal<>();\n+        }\n+\n+        @Override\n+        public Pool<T>.Entry acquire(List<Pool<T>.Entry> entries)\n+        {\n+            Pool<T>.Entry entry = last.get();\n+            if (entry != null && entry.tryAcquire())\n+                return entry;\n+            return null;\n+        }\n+\n+        @Override\n+        public void released(List<Pool<T>.Entry> entries, Pool<T>.Entry entry, boolean reusable)\n+        {\n+            if (reusable)\n+                last.set(entry);\n+        }\n+    }\n+\n+    public static class ThreadLocalListCache<T> implements Cache<T>\n+    {\n+        private final ThreadLocal<List<Pool<T>.Entry>> cache;\n+        private final int cacheSize;\n+\n+        ThreadLocalListCache(int size)\n+        {\n+            this.cacheSize = size;\n+            this.cache = ThreadLocal.withInitial(() -> new ArrayList<>(cacheSize));\n+        }\n+\n+        @Override\n+        public Pool<T>.Entry acquire(List<Pool<T>.Entry> entries)\n+        {\n+            List<Pool<T>.Entry> cachedList = cache.get();\n+            while (!cachedList.isEmpty())\n+            {\n+                Pool<T>.Entry cachedEntry = cachedList.remove(cachedList.size() - 1);\n+                if (cachedEntry.tryAcquire())\n+                    return cachedEntry;\n+            }\n+            return null;\n+        }\n+\n+        @Override\n+        public void released(List<Pool<T>.Entry> entries, Pool<T>.Entry entry, boolean reusable)\n+        {\n+            if (reusable)\n+            {\n+                List<Pool<T>.Entry> cachedList = cache.get();\n+                if (cachedList.size() < cacheSize)\n+                    cachedList.add(entry);\n+            }\n+        }\n+    }\n+\n+    private abstract static class IndexedCached<T> implements Cache<T>\n+    {\n+        @Override\n+        public Pool<T>.Entry acquire(List<Pool<T>.Entry> entries)\n+        {\n+            int size = entries.size();\n+            if (size == 0)\n+                return null;\n+            int i = nextIndex(size);\n+            try\n+            {\n+                Pool<T>.Entry entry = entries.get(i);\n+                if (entry != null && entry.tryAcquire())\n+                    return entry;\n+            }\n+            catch (Exception e)\n+            {\n+                // Could be out of bounds\n+                LOGGER.ignore(e);\n+            }\n+            return null;\n+        }\n+\n+        protected abstract int nextIndex(int size);\n+    }\n+\n+    public static class RandomCache<T> extends IndexedCached<T>\n+    {\n+        @Override\n+        protected int nextIndex(int size)\n+        {\n+            return ThreadLocalRandom.current().nextInt(size);\n+        }\n+    }\n+\n+    public static class RoundRobinCache<T> extends IndexedCached<T>\n+    {\n+        AtomicInteger index = new AtomicInteger();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6ab7bd726b0e2412a5c1497348473dbac98d64a3"}, "originalPosition": 435}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAxNDA4MTYzOnYy", "diffSide": "RIGHT", "path": "jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMlQxMzowNjoxM1rOHLuLkQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMlQxODo1ODoyMFrOHL93zw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjA1MzAwOQ==", "bodyText": "do we want to keep this strategy?", "url": "https://github.com/eclipse/jetty.project/pull/5218#discussion_r482053009", "createdAt": "2020-09-02T13:06:13Z", "author": {"login": "lorban"}, "path": "jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java", "diffHunk": "@@ -559,4 +574,222 @@ public String toString()\n                 pooled);\n         }\n     }\n+\n+    /** A pluggable strategy to optimize pool acquisition\n+     * @param <T> The type of the items in the pool\n+     */\n+    public interface Cache<T>\n+    {\n+        /** Acquire an entry\n+         * @param entries The list of entries known to the pool. This may be concurrently modified.\n+         * @return An acquired entry or null if none can be acquired by this strategy\n+         */\n+        Pool<T>.Entry acquire(List<Pool<T>.Entry> entries);\n+\n+        /**\n+         * Notification an entry has been release.  The notification comes after the entry\n+         * has been put back in the pool and it may already have been reacquired before or during this call.\n+         * @param entries The list of entries known to the pool. This may be concurrently modified.\n+         * @param entry The entry to be release\n+         * @param reusable true if the entry is reusable and will be put back in the pool.\n+         */\n+        default void released(List<Pool<T>.Entry> entries, Pool<T>.Entry entry, boolean reusable)\n+        {\n+        }\n+    }\n+\n+    public interface Strategy<T> extends Cache<T>\n+    {\n+    }\n+\n+    public static class CacheStrategy<T> implements Strategy<T>\n+    {\n+        final Cache<T> cache;\n+        final Strategy<T> strategy;\n+\n+        public CacheStrategy(Cache<T> cache, Strategy<T> planB)\n+        {\n+            Objects.requireNonNull(cache);\n+            Objects.requireNonNull(planB);\n+            this.cache = cache;\n+            this.strategy = planB;\n+        }\n+\n+        @Override\n+        public Pool<T>.Entry acquire(List<Pool<T>.Entry> entries)\n+        {\n+            Pool<T>.Entry entry = cache.acquire(entries);\n+            return entry == null ? strategy.acquire(entries) : entry;\n+        }\n+\n+        @Override\n+        public void released(List<Pool<T>.Entry> entries, Pool<T>.Entry entry, boolean reusable)\n+        {\n+            cache.released(entries, entry, reusable);\n+            strategy.released(entries, entry, reusable);\n+        }\n+    }\n+\n+    public static class SearchStrategy<T> implements Strategy<T>\n+    {\n+        @Override\n+        public Pool<T>.Entry acquire(List<Pool<T>.Entry> entries)\n+        {\n+            for (Pool<T>.Entry e : entries)\n+            {\n+                if (e.tryAcquire())\n+                    return e;\n+            }\n+            return null;\n+        }\n+    }\n+\n+    public static class ThreadLocalCache<T> implements Cache<T>\n+    {\n+        private final ThreadLocal<Pool<T>.Entry> last;\n+\n+        ThreadLocalCache()\n+        {\n+            last = new ThreadLocal<>();\n+        }\n+\n+        @Override\n+        public Pool<T>.Entry acquire(List<Pool<T>.Entry> entries)\n+        {\n+            Pool<T>.Entry entry = last.get();\n+            if (entry != null && entry.tryAcquire())\n+                return entry;\n+            return null;\n+        }\n+\n+        @Override\n+        public void released(List<Pool<T>.Entry> entries, Pool<T>.Entry entry, boolean reusable)\n+        {\n+            if (reusable)\n+                last.set(entry);\n+        }\n+    }\n+\n+    public static class ThreadLocalListCache<T> implements Cache<T>\n+    {\n+        private final ThreadLocal<List<Pool<T>.Entry>> cache;\n+        private final int cacheSize;\n+\n+        ThreadLocalListCache(int size)\n+        {\n+            this.cacheSize = size;\n+            this.cache = ThreadLocal.withInitial(() -> new ArrayList<>(cacheSize));\n+        }\n+\n+        @Override\n+        public Pool<T>.Entry acquire(List<Pool<T>.Entry> entries)\n+        {\n+            List<Pool<T>.Entry> cachedList = cache.get();\n+            while (!cachedList.isEmpty())\n+            {\n+                Pool<T>.Entry cachedEntry = cachedList.remove(cachedList.size() - 1);\n+                if (cachedEntry.tryAcquire())\n+                    return cachedEntry;\n+            }\n+            return null;\n+        }\n+\n+        @Override\n+        public void released(List<Pool<T>.Entry> entries, Pool<T>.Entry entry, boolean reusable)\n+        {\n+            if (reusable)\n+            {\n+                List<Pool<T>.Entry> cachedList = cache.get();\n+                if (cachedList.size() < cacheSize)\n+                    cachedList.add(entry);\n+            }\n+        }\n+    }\n+\n+    private abstract static class IndexedCached<T> implements Cache<T>\n+    {\n+        @Override\n+        public Pool<T>.Entry acquire(List<Pool<T>.Entry> entries)\n+        {\n+            int size = entries.size();\n+            if (size == 0)\n+                return null;\n+            int i = nextIndex(size);\n+            try\n+            {\n+                Pool<T>.Entry entry = entries.get(i);\n+                if (entry != null && entry.tryAcquire())\n+                    return entry;\n+            }\n+            catch (Exception e)\n+            {\n+                // Could be out of bounds\n+                LOGGER.ignore(e);\n+            }\n+            return null;\n+        }\n+\n+        protected abstract int nextIndex(int size);\n+    }\n+\n+    public static class RandomCache<T> extends IndexedCached<T>\n+    {\n+        @Override\n+        protected int nextIndex(int size)\n+        {\n+            return ThreadLocalRandom.current().nextInt(size);\n+        }\n+    }\n+\n+    public static class RoundRobinCache<T> extends IndexedCached<T>\n+    {\n+        AtomicInteger index = new AtomicInteger();\n+\n+        @Override\n+        protected int nextIndex(int size)\n+        {\n+            return index.getAndUpdate(c -> Math.max(0, c + 1)) % size;\n+        }\n+    }\n+\n+    public static class RoundRobinStrategy<T> extends RoundRobinCache<T> implements Strategy<T>\n+    {\n+        @Override\n+        public Pool<T>.Entry acquire(List<Pool<T>.Entry> entries)\n+        {\n+            int tries = entries.size();\n+            while (tries-- > 0)\n+            {\n+                Pool<T>.Entry entry = super.acquire(entries);\n+                if (entry != null)\n+                    return entry;\n+            }\n+            return null;\n+        }\n+    }\n+\n+    public static class LeastRecentlyUsedStrategy<T> implements Strategy<T>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6ab7bd726b0e2412a5c1497348473dbac98d64a3"}, "originalPosition": 460}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjMxMDA5NQ==", "bodyText": "I'll keep for now to test API during dev... but don't think we should include it in final merge... actually I might move it to a test to check that an external strategy can be applied without access to protected methods", "url": "https://github.com/eclipse/jetty.project/pull/5218#discussion_r482310095", "createdAt": "2020-09-02T18:58:20Z", "author": {"login": "gregw"}, "path": "jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java", "diffHunk": "@@ -559,4 +574,222 @@ public String toString()\n                 pooled);\n         }\n     }\n+\n+    /** A pluggable strategy to optimize pool acquisition\n+     * @param <T> The type of the items in the pool\n+     */\n+    public interface Cache<T>\n+    {\n+        /** Acquire an entry\n+         * @param entries The list of entries known to the pool. This may be concurrently modified.\n+         * @return An acquired entry or null if none can be acquired by this strategy\n+         */\n+        Pool<T>.Entry acquire(List<Pool<T>.Entry> entries);\n+\n+        /**\n+         * Notification an entry has been release.  The notification comes after the entry\n+         * has been put back in the pool and it may already have been reacquired before or during this call.\n+         * @param entries The list of entries known to the pool. This may be concurrently modified.\n+         * @param entry The entry to be release\n+         * @param reusable true if the entry is reusable and will be put back in the pool.\n+         */\n+        default void released(List<Pool<T>.Entry> entries, Pool<T>.Entry entry, boolean reusable)\n+        {\n+        }\n+    }\n+\n+    public interface Strategy<T> extends Cache<T>\n+    {\n+    }\n+\n+    public static class CacheStrategy<T> implements Strategy<T>\n+    {\n+        final Cache<T> cache;\n+        final Strategy<T> strategy;\n+\n+        public CacheStrategy(Cache<T> cache, Strategy<T> planB)\n+        {\n+            Objects.requireNonNull(cache);\n+            Objects.requireNonNull(planB);\n+            this.cache = cache;\n+            this.strategy = planB;\n+        }\n+\n+        @Override\n+        public Pool<T>.Entry acquire(List<Pool<T>.Entry> entries)\n+        {\n+            Pool<T>.Entry entry = cache.acquire(entries);\n+            return entry == null ? strategy.acquire(entries) : entry;\n+        }\n+\n+        @Override\n+        public void released(List<Pool<T>.Entry> entries, Pool<T>.Entry entry, boolean reusable)\n+        {\n+            cache.released(entries, entry, reusable);\n+            strategy.released(entries, entry, reusable);\n+        }\n+    }\n+\n+    public static class SearchStrategy<T> implements Strategy<T>\n+    {\n+        @Override\n+        public Pool<T>.Entry acquire(List<Pool<T>.Entry> entries)\n+        {\n+            for (Pool<T>.Entry e : entries)\n+            {\n+                if (e.tryAcquire())\n+                    return e;\n+            }\n+            return null;\n+        }\n+    }\n+\n+    public static class ThreadLocalCache<T> implements Cache<T>\n+    {\n+        private final ThreadLocal<Pool<T>.Entry> last;\n+\n+        ThreadLocalCache()\n+        {\n+            last = new ThreadLocal<>();\n+        }\n+\n+        @Override\n+        public Pool<T>.Entry acquire(List<Pool<T>.Entry> entries)\n+        {\n+            Pool<T>.Entry entry = last.get();\n+            if (entry != null && entry.tryAcquire())\n+                return entry;\n+            return null;\n+        }\n+\n+        @Override\n+        public void released(List<Pool<T>.Entry> entries, Pool<T>.Entry entry, boolean reusable)\n+        {\n+            if (reusable)\n+                last.set(entry);\n+        }\n+    }\n+\n+    public static class ThreadLocalListCache<T> implements Cache<T>\n+    {\n+        private final ThreadLocal<List<Pool<T>.Entry>> cache;\n+        private final int cacheSize;\n+\n+        ThreadLocalListCache(int size)\n+        {\n+            this.cacheSize = size;\n+            this.cache = ThreadLocal.withInitial(() -> new ArrayList<>(cacheSize));\n+        }\n+\n+        @Override\n+        public Pool<T>.Entry acquire(List<Pool<T>.Entry> entries)\n+        {\n+            List<Pool<T>.Entry> cachedList = cache.get();\n+            while (!cachedList.isEmpty())\n+            {\n+                Pool<T>.Entry cachedEntry = cachedList.remove(cachedList.size() - 1);\n+                if (cachedEntry.tryAcquire())\n+                    return cachedEntry;\n+            }\n+            return null;\n+        }\n+\n+        @Override\n+        public void released(List<Pool<T>.Entry> entries, Pool<T>.Entry entry, boolean reusable)\n+        {\n+            if (reusable)\n+            {\n+                List<Pool<T>.Entry> cachedList = cache.get();\n+                if (cachedList.size() < cacheSize)\n+                    cachedList.add(entry);\n+            }\n+        }\n+    }\n+\n+    private abstract static class IndexedCached<T> implements Cache<T>\n+    {\n+        @Override\n+        public Pool<T>.Entry acquire(List<Pool<T>.Entry> entries)\n+        {\n+            int size = entries.size();\n+            if (size == 0)\n+                return null;\n+            int i = nextIndex(size);\n+            try\n+            {\n+                Pool<T>.Entry entry = entries.get(i);\n+                if (entry != null && entry.tryAcquire())\n+                    return entry;\n+            }\n+            catch (Exception e)\n+            {\n+                // Could be out of bounds\n+                LOGGER.ignore(e);\n+            }\n+            return null;\n+        }\n+\n+        protected abstract int nextIndex(int size);\n+    }\n+\n+    public static class RandomCache<T> extends IndexedCached<T>\n+    {\n+        @Override\n+        protected int nextIndex(int size)\n+        {\n+            return ThreadLocalRandom.current().nextInt(size);\n+        }\n+    }\n+\n+    public static class RoundRobinCache<T> extends IndexedCached<T>\n+    {\n+        AtomicInteger index = new AtomicInteger();\n+\n+        @Override\n+        protected int nextIndex(int size)\n+        {\n+            return index.getAndUpdate(c -> Math.max(0, c + 1)) % size;\n+        }\n+    }\n+\n+    public static class RoundRobinStrategy<T> extends RoundRobinCache<T> implements Strategy<T>\n+    {\n+        @Override\n+        public Pool<T>.Entry acquire(List<Pool<T>.Entry> entries)\n+        {\n+            int tries = entries.size();\n+            while (tries-- > 0)\n+            {\n+                Pool<T>.Entry entry = super.acquire(entries);\n+                if (entry != null)\n+                    return entry;\n+            }\n+            return null;\n+        }\n+    }\n+\n+    public static class LeastRecentlyUsedStrategy<T> implements Strategy<T>", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjA1MzAwOQ=="}, "originalCommit": {"oid": "6ab7bd726b0e2412a5c1497348473dbac98d64a3"}, "originalPosition": 460}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAxNDEwMzI4OnYy", "diffSide": "RIGHT", "path": "jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMlQxMzoxMToxMlrOHLuYjA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMlQxODo1NjozM1rOHL9xVA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjA1NjMzMg==", "bodyText": "Are both Strategy and Cache needed?", "url": "https://github.com/eclipse/jetty.project/pull/5218#discussion_r482056332", "createdAt": "2020-09-02T13:11:12Z", "author": {"login": "lorban"}, "path": "jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java", "diffHunk": "@@ -559,4 +574,222 @@ public String toString()\n                 pooled);\n         }\n     }\n+\n+    /** A pluggable strategy to optimize pool acquisition\n+     * @param <T> The type of the items in the pool\n+     */\n+    public interface Cache<T>\n+    {\n+        /** Acquire an entry\n+         * @param entries The list of entries known to the pool. This may be concurrently modified.\n+         * @return An acquired entry or null if none can be acquired by this strategy\n+         */\n+        Pool<T>.Entry acquire(List<Pool<T>.Entry> entries);\n+\n+        /**\n+         * Notification an entry has been release.  The notification comes after the entry\n+         * has been put back in the pool and it may already have been reacquired before or during this call.\n+         * @param entries The list of entries known to the pool. This may be concurrently modified.\n+         * @param entry The entry to be release\n+         * @param reusable true if the entry is reusable and will be put back in the pool.\n+         */\n+        default void released(List<Pool<T>.Entry> entries, Pool<T>.Entry entry, boolean reusable)\n+        {\n+        }\n+    }\n+\n+    public interface Strategy<T> extends Cache<T>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6ab7bd726b0e2412a5c1497348473dbac98d64a3"}, "originalPosition": 290}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjMwODQzNg==", "bodyText": "Strategy and Cache are needed if we want to make a distinction between impls that just try to find an entry and then give up (threadlocal, random) and those that do a search  ( linear, round-robin).\nHowever, I too am not convinced the distinction is necessary.", "url": "https://github.com/eclipse/jetty.project/pull/5218#discussion_r482308436", "createdAt": "2020-09-02T18:56:33Z", "author": {"login": "gregw"}, "path": "jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java", "diffHunk": "@@ -559,4 +574,222 @@ public String toString()\n                 pooled);\n         }\n     }\n+\n+    /** A pluggable strategy to optimize pool acquisition\n+     * @param <T> The type of the items in the pool\n+     */\n+    public interface Cache<T>\n+    {\n+        /** Acquire an entry\n+         * @param entries The list of entries known to the pool. This may be concurrently modified.\n+         * @return An acquired entry or null if none can be acquired by this strategy\n+         */\n+        Pool<T>.Entry acquire(List<Pool<T>.Entry> entries);\n+\n+        /**\n+         * Notification an entry has been release.  The notification comes after the entry\n+         * has been put back in the pool and it may already have been reacquired before or during this call.\n+         * @param entries The list of entries known to the pool. This may be concurrently modified.\n+         * @param entry The entry to be release\n+         * @param reusable true if the entry is reusable and will be put back in the pool.\n+         */\n+        default void released(List<Pool<T>.Entry> entries, Pool<T>.Entry entry, boolean reusable)\n+        {\n+        }\n+    }\n+\n+    public interface Strategy<T> extends Cache<T>", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjA1NjMzMg=="}, "originalCommit": {"oid": "6ab7bd726b0e2412a5c1497348473dbac98d64a3"}, "originalPosition": 290}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAxNDEwODk2OnYy", "diffSide": "RIGHT", "path": "jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMlQxMzoxMjoyMlrOHLubqA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMlQxMzoxMjoyMlrOHLubqA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjA1NzEyOA==", "bodyText": "If we go with this design, the RR connection pool should be rewritten to use the RR strategy and this method should be removed.", "url": "https://github.com/eclipse/jetty.project/pull/5218#discussion_r482057128", "createdAt": "2020-09-02T13:12:22Z", "author": {"login": "lorban"}, "path": "jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java", "diffHunk": "@@ -176,14 +213,15 @@ public Entry reserve(int allotment)\n      * @param idx the index of the entry to acquire.\n      * @return the specified entry or null if there is none at the specified index or if it is not available.\n      */\n+    @Deprecated", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6ab7bd726b0e2412a5c1497348473dbac98d64a3"}, "originalPosition": 153}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAxNDExMzYzOnYy", "diffSide": "RIGHT", "path": "jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMlQxMzoxMzozMlrOHLuegg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMlQxMzoxMzozMlrOHLuegg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjA1Nzg1OA==", "bodyText": "this.cache = Objects.requireNonNull(cache);", "url": "https://github.com/eclipse/jetty.project/pull/5218#discussion_r482057858", "createdAt": "2020-09-02T13:13:32Z", "author": {"login": "lorban"}, "path": "jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java", "diffHunk": "@@ -559,4 +574,222 @@ public String toString()\n                 pooled);\n         }\n     }\n+\n+    /** A pluggable strategy to optimize pool acquisition\n+     * @param <T> The type of the items in the pool\n+     */\n+    public interface Cache<T>\n+    {\n+        /** Acquire an entry\n+         * @param entries The list of entries known to the pool. This may be concurrently modified.\n+         * @return An acquired entry or null if none can be acquired by this strategy\n+         */\n+        Pool<T>.Entry acquire(List<Pool<T>.Entry> entries);\n+\n+        /**\n+         * Notification an entry has been release.  The notification comes after the entry\n+         * has been put back in the pool and it may already have been reacquired before or during this call.\n+         * @param entries The list of entries known to the pool. This may be concurrently modified.\n+         * @param entry The entry to be release\n+         * @param reusable true if the entry is reusable and will be put back in the pool.\n+         */\n+        default void released(List<Pool<T>.Entry> entries, Pool<T>.Entry entry, boolean reusable)\n+        {\n+        }\n+    }\n+\n+    public interface Strategy<T> extends Cache<T>\n+    {\n+    }\n+\n+    public static class CacheStrategy<T> implements Strategy<T>\n+    {\n+        final Cache<T> cache;\n+        final Strategy<T> strategy;\n+\n+        public CacheStrategy(Cache<T> cache, Strategy<T> planB)\n+        {\n+            Objects.requireNonNull(cache);\n+            Objects.requireNonNull(planB);\n+            this.cache = cache;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6ab7bd726b0e2412a5c1497348473dbac98d64a3"}, "originalPosition": 303}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAxNDExNDY3OnYy", "diffSide": "RIGHT", "path": "jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMlQxMzoxMzo0OVrOHLufKw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMlQxMzoxMzo0OVrOHLufKw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjA1ODAyNw==", "bodyText": "this.strategy = Objects.requireNonNull(planB);", "url": "https://github.com/eclipse/jetty.project/pull/5218#discussion_r482058027", "createdAt": "2020-09-02T13:13:49Z", "author": {"login": "lorban"}, "path": "jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java", "diffHunk": "@@ -559,4 +574,222 @@ public String toString()\n                 pooled);\n         }\n     }\n+\n+    /** A pluggable strategy to optimize pool acquisition\n+     * @param <T> The type of the items in the pool\n+     */\n+    public interface Cache<T>\n+    {\n+        /** Acquire an entry\n+         * @param entries The list of entries known to the pool. This may be concurrently modified.\n+         * @return An acquired entry or null if none can be acquired by this strategy\n+         */\n+        Pool<T>.Entry acquire(List<Pool<T>.Entry> entries);\n+\n+        /**\n+         * Notification an entry has been release.  The notification comes after the entry\n+         * has been put back in the pool and it may already have been reacquired before or during this call.\n+         * @param entries The list of entries known to the pool. This may be concurrently modified.\n+         * @param entry The entry to be release\n+         * @param reusable true if the entry is reusable and will be put back in the pool.\n+         */\n+        default void released(List<Pool<T>.Entry> entries, Pool<T>.Entry entry, boolean reusable)\n+        {\n+        }\n+    }\n+\n+    public interface Strategy<T> extends Cache<T>\n+    {\n+    }\n+\n+    public static class CacheStrategy<T> implements Strategy<T>\n+    {\n+        final Cache<T> cache;\n+        final Strategy<T> strategy;\n+\n+        public CacheStrategy(Cache<T> cache, Strategy<T> planB)\n+        {\n+            Objects.requireNonNull(cache);\n+            Objects.requireNonNull(planB);\n+            this.cache = cache;\n+            this.strategy = planB;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6ab7bd726b0e2412a5c1497348473dbac98d64a3"}, "originalPosition": 304}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAxNDExODg1OnYy", "diffSide": "RIGHT", "path": "jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMlQxMzoxNDo0M1rOHLuhow==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMlQxMzoxNDo0M1rOHLuhow==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjA1ODY1OQ==", "bodyText": "This comment isn't accurate anymore as the iteration is also part of the strategy.", "url": "https://github.com/eclipse/jetty.project/pull/5218#discussion_r482058659", "createdAt": "2020-09-02T13:14:43Z", "author": {"login": "lorban"}, "path": "jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java", "diffHunk": "@@ -197,32 +235,14 @@ public Entry acquireAt(int idx)\n     /**\n      * Acquire an entry from the pool.\n      * Only enabled entries will be returned from this method and their enable method must not be called.\n+     * The implementation first tries the pool strategy and then a brute force iteration over entries.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6ab7bd726b0e2412a5c1497348473dbac98d64a3"}, "originalPosition": 170}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA0MjkzOTQ4OnYy", "diffSide": "RIGHT", "path": "jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMFQxNjoyNTo0N1rOHP8Glg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMFQxNjoyNTo0N1rOHP8Glg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjQ3NTQxNA==", "bodyText": "You should move this comment around since you also moved the ThreadLocal variable it speaks about.", "url": "https://github.com/eclipse/jetty.project/pull/5218#discussion_r486475414", "createdAt": "2020-09-10T16:25:47Z", "author": {"login": "lorban"}, "path": "jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java", "diffHunk": "@@ -65,29 +75,74 @@\n      * When an entry can't be found in the cache, the global list is iterated\n      * normally so the cache has no visible effect besides performance.\n      */", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "69fe8f669bcf89607c5da6f4a39964585e2dc0b9"}, "originalPosition": 61}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA0Mjk1NTc3OnYy", "diffSide": "RIGHT", "path": "jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMFQxNjoyOTo0NlrOHP8QjQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMFQxNzoxMjo1MFrOHP927g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjQ3Nzk2NQ==", "bodyText": "This method should go and any caller should be replaced with a Pool using the RR strategy.", "url": "https://github.com/eclipse/jetty.project/pull/5218#discussion_r486477965", "createdAt": "2020-09-10T16:29:46Z", "author": {"login": "lorban"}, "path": "jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java", "diffHunk": "@@ -176,14 +231,15 @@ public Entry reserve(int allotment)\n      * @param idx the index of the entry to acquire.\n      * @return the specified entry or null if there is none at the specified index or if it is not available.\n      */\n+    @Deprecated\n     public Entry acquireAt(int idx)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "69fe8f669bcf89607c5da6f4a39964585e2dc0b9"}, "originalPosition": 183}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjUwNDE3NA==", "bodyText": "Yep - waiting for @sbordet to help rework connection pool.", "url": "https://github.com/eclipse/jetty.project/pull/5218#discussion_r486504174", "createdAt": "2020-09-10T17:12:50Z", "author": {"login": "gregw"}, "path": "jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java", "diffHunk": "@@ -176,14 +231,15 @@ public Entry reserve(int allotment)\n      * @param idx the index of the entry to acquire.\n      * @return the specified entry or null if there is none at the specified index or if it is not available.\n      */\n+    @Deprecated\n     public Entry acquireAt(int idx)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjQ3Nzk2NQ=="}, "originalCommit": {"oid": "69fe8f669bcf89607c5da6f4a39964585e2dc0b9"}, "originalPosition": 183}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA0Mjk1OTk4OnYy", "diffSide": "RIGHT", "path": "jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMFQxNjozMDo1NFrOHP8TVw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMFQxNjozMDo1NFrOHP8TVw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjQ3ODY3OQ==", "bodyText": "I'd add a message to the exception, something like\nthrow new IllegalArgumentException(\"Invalid strategy : \" + strategy);", "url": "https://github.com/eclipse/jetty.project/pull/5218#discussion_r486478679", "createdAt": "2020-09-10T16:30:54Z", "author": {"login": "lorban"}, "path": "jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java", "diffHunk": "@@ -204,25 +260,51 @@ public Entry acquire()\n         if (closed)\n             return null;\n \n-        // first check the thread-local cache\n+        int size = entries.size();\n+        if (size == 0)\n+            return null;\n+\n         if (cache != null)\n         {\n-            List<Entry> cachedList = cache.get();\n-            while (!cachedList.isEmpty())\n+            Pool<T>.Entry entry = cache.get();\n+            if (entry != null && entry.tryAcquire())\n+                return entry;\n+        }\n+\n+        int index = startIndex(size);\n+\n+        for (int tries = size; tries-- > 0;)\n+        {\n+            try\n+            {\n+                Pool<T>.Entry entry = entries.get(index);\n+                if (entry != null && entry.tryAcquire())\n+                    return entry;\n+            }\n+            catch (IndexOutOfBoundsException e)\n             {\n-                Entry cachedEntry = cachedList.remove(cachedList.size() - 1);\n-                if (cachedEntry.tryAcquire())\n-                    return cachedEntry;\n+                LOGGER.ignore(e);\n             }\n+            index = (index + 1) % size;\n         }\n+        return null;\n+    }\n \n-        // then iterate the shared list\n-        for (Entry entry : sharedList)\n+    private int startIndex(int size)\n+    {\n+        switch (strategy)\n         {\n-            if (entry.tryAcquire())\n-                return entry;\n+            case LINEAR:\n+                return 0;\n+            case RANDOM:\n+                return ThreadLocalRandom.current().nextInt(size);\n+            case ROUND_ROBIN:\n+                return next.getAndUpdate(c -> Math.max(0, c + 1)) % size;\n+            case THREAD_ID:\n+                return (int)(Thread.currentThread().getId() % size);\n+            default:\n+                throw new IllegalArgumentException();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "69fe8f669bcf89607c5da6f4a39964585e2dc0b9"}, "originalPosition": 252}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA0Mjk2NjIwOnYy", "diffSide": "RIGHT", "path": "jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMFQxNjozMjoyNVrOHP8XKA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNlQwNzozMzoxNFrOHSj5mg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjQ3OTY1Ng==", "bodyText": "This doesn't seem to be used.", "url": "https://github.com/eclipse/jetty.project/pull/5218#discussion_r486479656", "createdAt": "2020-09-10T16:32:25Z", "author": {"login": "lorban"}, "path": "jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java", "diffHunk": "@@ -500,6 +575,13 @@ boolean tryRelease()\n             return !(overUsed && newMultiplexingCount == 0);\n         }\n \n+        public boolean isOverUsed()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "69fe8f669bcf89607c5da6f4a39964585e2dc0b9"}, "originalPosition": 376}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjUwNTI2OQ==", "bodyText": "I did have a use for it.... but can't remember now... was probably some esoteric strategy or perhaps a unit test.\nI still think it is a nice to have along with the isIdle type methods.", "url": "https://github.com/eclipse/jetty.project/pull/5218#discussion_r486505269", "createdAt": "2020-09-10T17:14:43Z", "author": {"login": "gregw"}, "path": "jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java", "diffHunk": "@@ -500,6 +575,13 @@ boolean tryRelease()\n             return !(overUsed && newMultiplexingCount == 0);\n         }\n \n+        public boolean isOverUsed()", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjQ3OTY1Ng=="}, "originalCommit": {"oid": "69fe8f669bcf89607c5da6f4a39964585e2dc0b9"}, "originalPosition": 376}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTIyNDYwMg==", "bodyText": "+1 for keeping the method for JMX and such.", "url": "https://github.com/eclipse/jetty.project/pull/5218#discussion_r489224602", "createdAt": "2020-09-16T07:33:14Z", "author": {"login": "sbordet"}, "path": "jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java", "diffHunk": "@@ -500,6 +575,13 @@ boolean tryRelease()\n             return !(overUsed && newMultiplexingCount == 0);\n         }\n \n+        public boolean isOverUsed()", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjQ3OTY1Ng=="}, "originalCommit": {"oid": "69fe8f669bcf89607c5da6f4a39964585e2dc0b9"}, "originalPosition": 376}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA0Mjk2NzIxOnYy", "diffSide": "RIGHT", "path": "jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMFQxNjozMjo0MFrOHP8X1Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMFQxNzoxNTowOVrOHP98Ww==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjQ3OTgyOQ==", "bodyText": "This doesn't have to be public.", "url": "https://github.com/eclipse/jetty.project/pull/5218#discussion_r486479829", "createdAt": "2020-09-10T16:32:40Z", "author": {"login": "lorban"}, "path": "jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java", "diffHunk": "@@ -452,7 +527,7 @@ public boolean remove()\n          * the multiplex count is maxMultiplex and the entry is not closed,\n          * false otherwise.\n          */\n-        boolean tryAcquire()\n+        public boolean tryAcquire()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "69fe8f669bcf89607c5da6f4a39964585e2dc0b9"}, "originalPosition": 368}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjUwNTU2Mw==", "bodyText": "Ah yes! It needed to be public for strategies... but not now!", "url": "https://github.com/eclipse/jetty.project/pull/5218#discussion_r486505563", "createdAt": "2020-09-10T17:15:09Z", "author": {"login": "gregw"}, "path": "jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java", "diffHunk": "@@ -452,7 +527,7 @@ public boolean remove()\n          * the multiplex count is maxMultiplex and the entry is not closed,\n          * false otherwise.\n          */\n-        boolean tryAcquire()\n+        public boolean tryAcquire()", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjQ3OTgyOQ=="}, "originalCommit": {"oid": "69fe8f669bcf89607c5da6f4a39964585e2dc0b9"}, "originalPosition": 368}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA0Mjk2ODUwOnYy", "diffSide": "RIGHT", "path": "jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMFQxNjozMzowMFrOHP8Ypg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMFQxNzoxNTo1MVrOHP998w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjQ4MDAzOA==", "bodyText": "This index doesn't seem to be used.", "url": "https://github.com/eclipse/jetty.project/pull/5218#discussion_r486480038", "createdAt": "2020-09-10T16:33:00Z", "author": {"login": "lorban"}, "path": "jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java", "diffHunk": "@@ -345,45 +417,48 @@ public void close()\n \n     public int size()\n     {\n-        return sharedList.size();\n+        return entries.size();\n     }\n \n     public Collection<Entry> values()\n     {\n-        return Collections.unmodifiableCollection(sharedList);\n+        return Collections.unmodifiableCollection(entries);\n     }\n \n     @Override\n     public void dump(Appendable out, String indent) throws IOException\n     {\n-        Dumpable.dumpObjects(out, indent, this);\n+        Dumpable.dumpObjects(out, indent, this,\n+            new DumpableCollection(\"entries\", entries));\n     }\n \n     @Override\n     public String toString()\n     {\n-        return String.format(\"%s@%x[size=%d closed=%s entries=%s]\",\n+        return String.format(\"%s@%x[size=%d closed=%s pending=%d]\",\n             getClass().getSimpleName(),\n             hashCode(),\n-            sharedList.size(),\n+            entries.size(),\n             closed,\n-            sharedList);\n+            pending.get());\n     }\n \n     public class Entry\n     {\n         // hi: positive=open/maxUsage counter; negative=closed; MIN_VALUE pending\n         // lo: multiplexing counter\n         private final AtomicBiInteger state;\n+        private final int index;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "69fe8f669bcf89607c5da6f4a39964585e2dc0b9"}, "originalPosition": 348}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjUwNTk3MQ==", "bodyText": "oops yes - that was a broken hack for another esoteric round robin", "url": "https://github.com/eclipse/jetty.project/pull/5218#discussion_r486505971", "createdAt": "2020-09-10T17:15:51Z", "author": {"login": "gregw"}, "path": "jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java", "diffHunk": "@@ -345,45 +417,48 @@ public void close()\n \n     public int size()\n     {\n-        return sharedList.size();\n+        return entries.size();\n     }\n \n     public Collection<Entry> values()\n     {\n-        return Collections.unmodifiableCollection(sharedList);\n+        return Collections.unmodifiableCollection(entries);\n     }\n \n     @Override\n     public void dump(Appendable out, String indent) throws IOException\n     {\n-        Dumpable.dumpObjects(out, indent, this);\n+        Dumpable.dumpObjects(out, indent, this,\n+            new DumpableCollection(\"entries\", entries));\n     }\n \n     @Override\n     public String toString()\n     {\n-        return String.format(\"%s@%x[size=%d closed=%s entries=%s]\",\n+        return String.format(\"%s@%x[size=%d closed=%s pending=%d]\",\n             getClass().getSimpleName(),\n             hashCode(),\n-            sharedList.size(),\n+            entries.size(),\n             closed,\n-            sharedList);\n+            pending.get());\n     }\n \n     public class Entry\n     {\n         // hi: positive=open/maxUsage counter; negative=closed; MIN_VALUE pending\n         // lo: multiplexing counter\n         private final AtomicBiInteger state;\n+        private final int index;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjQ4MDAzOA=="}, "originalCommit": {"oid": "69fe8f669bcf89607c5da6f4a39964585e2dc0b9"}, "originalPosition": 348}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA0Mjk3NDc1OnYy", "diffSide": "RIGHT", "path": "jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMFQxNjozNDozN1rOHP8cmg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMFQxNjozNDozN1rOHP8cmg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjQ4MTA1MA==", "bodyText": "I would rename these variables to the actual name of their value: usageCount and multiplexingCount.", "url": "https://github.com/eclipse/jetty.project/pull/5218#discussion_r486481050", "createdAt": "2020-09-10T16:34:37Z", "author": {"login": "lorban"}, "path": "jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java", "diffHunk": "@@ -549,12 +631,17 @@ public int getUsageCount()\n         public String toString()\n         {\n             long encoded = state.get();\n-            return String.format(\"%s@%x{usage=%d/%d,multiplex=%d/%d,pooled=%s}\",\n+            int hi = AtomicBiInteger.getHi(encoded);\n+            int lo = AtomicBiInteger.getLo(encoded);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "69fe8f669bcf89607c5da6f4a39964585e2dc0b9"}, "originalPosition": 392}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA0Mjk4OTc3OnYy", "diffSide": "RIGHT", "path": "jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMFQxNjozODozN1rOHP8mDg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMFQxNzoyNDo1M1rOHP-Smw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjQ4MzQ3MA==", "bodyText": "Since all the other names of this enum describe the starting index, I'd rename this one to something like INDEX_ZERO.", "url": "https://github.com/eclipse/jetty.project/pull/5218#discussion_r486483470", "createdAt": "2020-09-10T16:38:37Z", "author": {"login": "lorban"}, "path": "jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java", "diffHunk": "@@ -65,29 +75,74 @@\n      * When an entry can't be found in the cache, the global list is iterated\n      * normally so the cache has no visible effect besides performance.\n      */\n-    private final ThreadLocal<List<Entry>> cache;\n+\n     private final Locker locker = new Locker();\n     private final int maxEntries;\n-    private final int cacheSize;\n     private final AtomicInteger pending = new AtomicInteger();\n+    private final Strategy strategy;\n+    private final ThreadLocal<Entry> cache;\n+    private final AtomicInteger next;\n     private volatile boolean closed;\n     private volatile int maxMultiplex = 1;\n     private volatile int maxUsageCount = -1;\n \n+    public enum Strategy\n+    {\n+        /**\n+         * The Linear strategy looks for an entry always starting from the first entry.\n+         * It will favour the early entries in the pool, but may contend on them more.\n+         */\n+        LINEAR,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "69fe8f669bcf89607c5da6f4a39964585e2dc0b9"}, "originalPosition": 81}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjUxMTI1OQ==", "bodyText": "How about FIRST?", "url": "https://github.com/eclipse/jetty.project/pull/5218#discussion_r486511259", "createdAt": "2020-09-10T17:24:53Z", "author": {"login": "gregw"}, "path": "jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java", "diffHunk": "@@ -65,29 +75,74 @@\n      * When an entry can't be found in the cache, the global list is iterated\n      * normally so the cache has no visible effect besides performance.\n      */\n-    private final ThreadLocal<List<Entry>> cache;\n+\n     private final Locker locker = new Locker();\n     private final int maxEntries;\n-    private final int cacheSize;\n     private final AtomicInteger pending = new AtomicInteger();\n+    private final Strategy strategy;\n+    private final ThreadLocal<Entry> cache;\n+    private final AtomicInteger next;\n     private volatile boolean closed;\n     private volatile int maxMultiplex = 1;\n     private volatile int maxUsageCount = -1;\n \n+    public enum Strategy\n+    {\n+        /**\n+         * The Linear strategy looks for an entry always starting from the first entry.\n+         * It will favour the early entries in the pool, but may contend on them more.\n+         */\n+        LINEAR,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjQ4MzQ3MA=="}, "originalCommit": {"oid": "69fe8f669bcf89607c5da6f4a39964585e2dc0b9"}, "originalPosition": 81}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA0Mjk5MzIxOnYy", "diffSide": "RIGHT", "path": "jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMFQxNjozOToyMVrOHP8oFQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMFQxNjozOToyMVrOHP8oFQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjQ4Mzk4OQ==", "bodyText": "AtomicInteger nextIndex?", "url": "https://github.com/eclipse/jetty.project/pull/5218#discussion_r486483989", "createdAt": "2020-09-10T16:39:21Z", "author": {"login": "lorban"}, "path": "jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java", "diffHunk": "@@ -65,29 +75,74 @@\n      * When an entry can't be found in the cache, the global list is iterated\n      * normally so the cache has no visible effect besides performance.\n      */\n-    private final ThreadLocal<List<Entry>> cache;\n+\n     private final Locker locker = new Locker();\n     private final int maxEntries;\n-    private final int cacheSize;\n     private final AtomicInteger pending = new AtomicInteger();\n+    private final Strategy strategy;\n+    private final ThreadLocal<Entry> cache;\n+    private final AtomicInteger next;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "69fe8f669bcf89607c5da6f4a39964585e2dc0b9"}, "originalPosition": 70}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA0Mjk5NjUwOnYy", "diffSide": "RIGHT", "path": "jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMFQxNjo0MDowNlrOHP8qBQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMFQxNzoyMTowMFrOHP-JzQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjQ4NDQ4NQ==", "bodyText": "new ThreadLocal<>()?", "url": "https://github.com/eclipse/jetty.project/pull/5218#discussion_r486484485", "createdAt": "2020-09-10T16:40:06Z", "author": {"login": "lorban"}, "path": "jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java", "diffHunk": "@@ -65,29 +75,74 @@\n      * When an entry can't be found in the cache, the global list is iterated\n      * normally so the cache has no visible effect besides performance.\n      */\n-    private final ThreadLocal<List<Entry>> cache;\n+\n     private final Locker locker = new Locker();\n     private final int maxEntries;\n-    private final int cacheSize;\n     private final AtomicInteger pending = new AtomicInteger();\n+    private final Strategy strategy;\n+    private final ThreadLocal<Entry> cache;\n+    private final AtomicInteger next;\n     private volatile boolean closed;\n     private volatile int maxMultiplex = 1;\n     private volatile int maxUsageCount = -1;\n \n+    public enum Strategy\n+    {\n+        /**\n+         * The Linear strategy looks for an entry always starting from the first entry.\n+         * It will favour the early entries in the pool, but may contend on them more.\n+         */\n+        LINEAR,\n+\n+        /**\n+         * The Random strategy looks for an entry by iterating from a random starting\n+         * index.  No entries are favoured and contention is reduced.\n+         */\n+        RANDOM,\n+\n+        /**\n+         * The Thread ID strategy uses the {@link Thread#getId()} of the current thread\n+         * to select a starting point for an entry search.  Whilst not as performant as\n+         * using the {@link ThreadLocal} cache, it may be suitable when the pool is substantially smaller\n+         * than the number of available threads.\n+         * No entries are favoured and contention is reduced.\n+         */\n+        THREAD_ID,\n+\n+        /**\n+         * The Round Robin strategy looks for an entry by iterating from a starting point\n+         * that is incremented on every search. This gives similar results to the\n+         * random strategy but with more predictable behaviour.\n+         * No entries are favoured and contention is reduced.\n+         */\n+        ROUND_ROBIN,\n+    }\n+\n     /**\n-     * Construct a Pool with the specified thread-local cache size.\n+     * Construct a Pool with a specified lookup strategy and no\n+     * {@link ThreadLocal} cache.\n      *\n+     * @param strategy The strategy to used for looking up entries.\n      * @param maxEntries the maximum amount of entries that the pool will accept.\n-     * @param cacheSize the thread-local cache size. A value less than 1 means the cache is disabled.\n      */\n-    public Pool(int maxEntries, int cacheSize)\n+    public Pool(Strategy strategy, int maxEntries)\n+    {\n+        this(strategy, maxEntries, false);\n+    }\n+\n+    /**\n+     * Construct a Pool with the specified thread-local cache size and\n+     * an optional {@link ThreadLocal} cache.\n+     * @param strategy The strategy to used for looking up entries.\n+     * @param maxEntries the maximum amount of entries that the pool will accept.\n+     * @param cache True if a {@link ThreadLocal} cache should be used to try the most recently released entry.\n+     */\n+    public Pool(Strategy strategy, int maxEntries, boolean cache)\n     {\n         this.maxEntries = maxEntries;\n-        this.cacheSize = cacheSize;\n-        if (cacheSize > 0)\n-            this.cache = ThreadLocal.withInitial(() -> new ArrayList<Entry>(cacheSize));\n-        else\n-            this.cache = null;\n+        this.strategy = strategy;\n+        this.cache = cache ? new ThreadLocal() : null;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "69fe8f669bcf89607c5da6f4a39964585e2dc0b9"}, "originalPosition": 138}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjUwOTAwNQ==", "bodyText": "Don't need the threadlocal if not caching", "url": "https://github.com/eclipse/jetty.project/pull/5218#discussion_r486509005", "createdAt": "2020-09-10T17:21:00Z", "author": {"login": "gregw"}, "path": "jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java", "diffHunk": "@@ -65,29 +75,74 @@\n      * When an entry can't be found in the cache, the global list is iterated\n      * normally so the cache has no visible effect besides performance.\n      */\n-    private final ThreadLocal<List<Entry>> cache;\n+\n     private final Locker locker = new Locker();\n     private final int maxEntries;\n-    private final int cacheSize;\n     private final AtomicInteger pending = new AtomicInteger();\n+    private final Strategy strategy;\n+    private final ThreadLocal<Entry> cache;\n+    private final AtomicInteger next;\n     private volatile boolean closed;\n     private volatile int maxMultiplex = 1;\n     private volatile int maxUsageCount = -1;\n \n+    public enum Strategy\n+    {\n+        /**\n+         * The Linear strategy looks for an entry always starting from the first entry.\n+         * It will favour the early entries in the pool, but may contend on them more.\n+         */\n+        LINEAR,\n+\n+        /**\n+         * The Random strategy looks for an entry by iterating from a random starting\n+         * index.  No entries are favoured and contention is reduced.\n+         */\n+        RANDOM,\n+\n+        /**\n+         * The Thread ID strategy uses the {@link Thread#getId()} of the current thread\n+         * to select a starting point for an entry search.  Whilst not as performant as\n+         * using the {@link ThreadLocal} cache, it may be suitable when the pool is substantially smaller\n+         * than the number of available threads.\n+         * No entries are favoured and contention is reduced.\n+         */\n+        THREAD_ID,\n+\n+        /**\n+         * The Round Robin strategy looks for an entry by iterating from a starting point\n+         * that is incremented on every search. This gives similar results to the\n+         * random strategy but with more predictable behaviour.\n+         * No entries are favoured and contention is reduced.\n+         */\n+        ROUND_ROBIN,\n+    }\n+\n     /**\n-     * Construct a Pool with the specified thread-local cache size.\n+     * Construct a Pool with a specified lookup strategy and no\n+     * {@link ThreadLocal} cache.\n      *\n+     * @param strategy The strategy to used for looking up entries.\n      * @param maxEntries the maximum amount of entries that the pool will accept.\n-     * @param cacheSize the thread-local cache size. A value less than 1 means the cache is disabled.\n      */\n-    public Pool(int maxEntries, int cacheSize)\n+    public Pool(Strategy strategy, int maxEntries)\n+    {\n+        this(strategy, maxEntries, false);\n+    }\n+\n+    /**\n+     * Construct a Pool with the specified thread-local cache size and\n+     * an optional {@link ThreadLocal} cache.\n+     * @param strategy The strategy to used for looking up entries.\n+     * @param maxEntries the maximum amount of entries that the pool will accept.\n+     * @param cache True if a {@link ThreadLocal} cache should be used to try the most recently released entry.\n+     */\n+    public Pool(Strategy strategy, int maxEntries, boolean cache)\n     {\n         this.maxEntries = maxEntries;\n-        this.cacheSize = cacheSize;\n-        if (cacheSize > 0)\n-            this.cache = ThreadLocal.withInitial(() -> new ArrayList<Entry>(cacheSize));\n-        else\n-            this.cache = null;\n+        this.strategy = strategy;\n+        this.cache = cache ? new ThreadLocal() : null;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjQ4NDQ4NQ=="}, "originalCommit": {"oid": "69fe8f669bcf89607c5da6f4a39964585e2dc0b9"}, "originalPosition": 138}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA2MTAyMTk3OnYy", "diffSide": "RIGHT", "path": "VERSION.txt", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNlQwNzoyMToxOFrOHSje1g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNlQwOTo1Njo1OVrOHSpaTw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTIxNzc1MA==", "bodyText": "Revert this, it was a search/replace gone wrong.", "url": "https://github.com/eclipse/jetty.project/pull/5218#discussion_r489217750", "createdAt": "2020-09-16T07:21:18Z", "author": {"login": "sbordet"}, "path": "VERSION.txt", "diffHunk": "@@ -1198,7 +1198,7 @@ jetty-9.4.4.v20170414 - 14 April 2017\n    encoding\n  + 1436 NullPointerException when calling changeSessionId\n  + 1439 Allow UNC paths to function as Resource bases\n- + 1440 Improve lock contention for low resources scheduling strategy\n+ + 1440 Improve lock contention for low resources scheduling strategyType", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1ef761ed10d5d818a7c3e63a0d5769a00e6630af"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTMxNDg5NQ==", "bodyText": "Ah ooops.   That's an IDE being too smart!", "url": "https://github.com/eclipse/jetty.project/pull/5218#discussion_r489314895", "createdAt": "2020-09-16T09:56:59Z", "author": {"login": "gregw"}, "path": "VERSION.txt", "diffHunk": "@@ -1198,7 +1198,7 @@ jetty-9.4.4.v20170414 - 14 April 2017\n    encoding\n  + 1436 NullPointerException when calling changeSessionId\n  + 1439 Allow UNC paths to function as Resource bases\n- + 1440 Improve lock contention for low resources scheduling strategy\n+ + 1440 Improve lock contention for low resources scheduling strategyType", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTIxNzc1MA=="}, "originalCommit": {"oid": "1ef761ed10d5d818a7c3e63a0d5769a00e6630af"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA2MTA0MzY4OnYy", "diffSide": "RIGHT", "path": "jetty-documentation/src/main/asciidoc/administration/logging/jetty-server-dump.adoc", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNlQwNzoyNzoxMVrOHSjsGQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNlQwNzoyNzoxMVrOHSjsGQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTIyMTE0NQ==", "bodyText": "Revert, bad search/replace.", "url": "https://github.com/eclipse/jetty.project/pull/5218#discussion_r489221145", "createdAt": "2020-09-16T07:27:11Z", "author": {"login": "sbordet"}, "path": "jetty-documentation/src/main/asciidoc/administration/logging/jetty-server-dump.adoc", "diffHunk": "@@ -105,10 +105,10 @@ Server@59906517{STARTED}[9.4.32-SNAPSHOT] - STARTED\n |  |  |  +> app//org.eclipse.jetty.io.AbstractConnection$ReadCallback.succeeded(AbstractConnection.java:311)\n |  |  |  +> app//org.eclipse.jetty.io.FillInterest.fillable(FillInterest.java:105)\n |  |  |  +> app//org.eclipse.jetty.io.ChannelEndPoint$1.run(ChannelEndPoint.java:104)\n-|  |  |  +> app//org.eclipse.jetty.util.thread.strategy.EatWhatYouKill.runTask(EatWhatYouKill.java:336)\n-|  |  |  +> app//org.eclipse.jetty.util.thread.strategy.EatWhatYouKill.doProduce(EatWhatYouKill.java:313)\n-|  |  |  +> app//org.eclipse.jetty.util.thread.strategy.EatWhatYouKill.tryProduce(EatWhatYouKill.java:171)\n-|  |  |  +> app//org.eclipse.jetty.util.thread.strategy.EatWhatYouKill.run(EatWhatYouKill.java:129)\n+|  |  |  +> app//org.eclipse.jetty.util.thread.strategyType.EatWhatYouKill.runTask(EatWhatYouKill.java:336)\n+|  |  |  +> app//org.eclipse.jetty.util.thread.strategyType.EatWhatYouKill.doProduce(EatWhatYouKill.java:313)\n+|  |  |  +> app//org.eclipse.jetty.util.thread.strategyType.EatWhatYouKill.tryProduce(EatWhatYouKill.java:171)\n+|  |  |  +> app//org.eclipse.jetty.util.thread.strategyType.EatWhatYouKill.run(EatWhatYouKill.java:129)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1ef761ed10d5d818a7c3e63a0d5769a00e6630af"}, "originalPosition": 11}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA2MTA0NDMxOnYy", "diffSide": "RIGHT", "path": "jetty-documentation/src/main/asciidoc/configuring/jsp/configuring-jsp.adoc", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNlQwNzoyNzoyMlrOHSjseQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNlQwNzoyNzoyMlrOHSjseQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTIyMTI0MQ==", "bodyText": "Revert, bad search/replace.", "url": "https://github.com/eclipse/jetty.project/pull/5218#discussion_r489221241", "createdAt": "2020-09-16T07:27:22Z", "author": {"login": "sbordet"}, "path": "jetty-documentation/src/main/asciidoc/configuring/jsp/configuring-jsp.adoc", "diffHunk": "@@ -163,7 +163,7 @@ Set all parameters on the `org.apache.jasper.servlet.JspServlet` instance define\n \n ____\n [NOTE]\n-Be careful: for all of these parameters, if the value you set doesn't take effect, try using all lower case instead of camel case, or capitalizing only some of the words in the name, as JSP is inconsistent in its parameter naming strategy.\n+Be careful: for all of these parameters, if the value you set doesn't take effect, try using all lower case instead of camel case, or capitalizing only some of the words in the name, as JSP is inconsistent in its parameter naming strategyType.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1ef761ed10d5d818a7c3e63a0d5769a00e6630af"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA2MTA1MDEwOnYy", "diffSide": "RIGHT", "path": "jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNlQwNzoyOTowMlrOHSjwIQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNlQwNzoyOTowMlrOHSjwIQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTIyMjE3Nw==", "bodyText": "Overriding listIterator(int) is not necessary anymore, since we never use it, and we don't leak the entries field.", "url": "https://github.com/eclipse/jetty.project/pull/5218#discussion_r489222177", "createdAt": "2020-09-16T07:29:02Z", "author": {"login": "sbordet"}, "path": "jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java", "diffHunk": "@@ -56,38 +51,98 @@\n {\n     private static final Logger LOGGER = Log.getLogger(Pool.class);\n \n-    private final List<Entry> sharedList = new CopyOnWriteArrayList<>();\n+    private final List<Entry> entries = new CopyOnWriteArrayList<Entry>()\n+    {\n+        @Override\n+        public ListIterator<Entry> listIterator(int index)\n+        {\n+            try\n+            {\n+                return super.listIterator(index);\n+            }\n+            catch (IndexOutOfBoundsException e)\n+            {\n+                return listIterator();\n+            }\n+        }\n+    };", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1ef761ed10d5d818a7c3e63a0d5769a00e6630af"}, "originalPosition": 53}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA2MTA1NjI3OnYy", "diffSide": "RIGHT", "path": "jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNlQwNzozMDozN1rOHSjz7A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNlQwNzozMDozN1rOHSjz7A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTIyMzE0OA==", "bodyText": "There is no \"normal\" strategy, I would rephrase: \"is iterated with the configured StrategyType\".", "url": "https://github.com/eclipse/jetty.project/pull/5218#discussion_r489223148", "createdAt": "2020-09-16T07:30:37Z", "author": {"login": "sbordet"}, "path": "jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java", "diffHunk": "@@ -56,38 +51,98 @@\n {\n     private static final Logger LOGGER = Log.getLogger(Pool.class);\n \n-    private final List<Entry> sharedList = new CopyOnWriteArrayList<>();\n+    private final List<Entry> entries = new CopyOnWriteArrayList<Entry>()\n+    {\n+        @Override\n+        public ListIterator<Entry> listIterator(int index)\n+        {\n+            try\n+            {\n+                return super.listIterator(index);\n+            }\n+            catch (IndexOutOfBoundsException e)\n+            {\n+                return listIterator();\n+            }\n+        }\n+    };\n+\n+    private final int maxEntries;\n+    private final AtomicInteger pending = new AtomicInteger();\n+    private final StrategyType strategyType;\n+\n     /*\n      * The cache is used to avoid hammering on the first index of the entry list.\n      * Caches can become poisoned (i.e.: containing entries that are in use) when\n      * the release isn't done by the acquiring thread or when the entry pool is\n      * undersized compared to the load applied on it.\n      * When an entry can't be found in the cache, the global list is iterated\n-     * normally so the cache has no visible effect besides performance.\n+     * with the normal strategy so the cache has no visible effect besides performance.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1ef761ed10d5d818a7c3e63a0d5769a00e6630af"}, "originalPosition": 66}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA2MTA1NzQyOnYy", "diffSide": "RIGHT", "path": "jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNlQwNzozMDo1OVrOHSj0pQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNlQwNzozMDo1OVrOHSj0pQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTIyMzMzMw==", "bodyText": "Javadocs.", "url": "https://github.com/eclipse/jetty.project/pull/5218#discussion_r489223333", "createdAt": "2020-09-16T07:30:59Z", "author": {"login": "sbordet"}, "path": "jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java", "diffHunk": "@@ -56,38 +51,98 @@\n {\n     private static final Logger LOGGER = Log.getLogger(Pool.class);\n \n-    private final List<Entry> sharedList = new CopyOnWriteArrayList<>();\n+    private final List<Entry> entries = new CopyOnWriteArrayList<Entry>()\n+    {\n+        @Override\n+        public ListIterator<Entry> listIterator(int index)\n+        {\n+            try\n+            {\n+                return super.listIterator(index);\n+            }\n+            catch (IndexOutOfBoundsException e)\n+            {\n+                return listIterator();\n+            }\n+        }\n+    };\n+\n+    private final int maxEntries;\n+    private final AtomicInteger pending = new AtomicInteger();\n+    private final StrategyType strategyType;\n+\n     /*\n      * The cache is used to avoid hammering on the first index of the entry list.\n      * Caches can become poisoned (i.e.: containing entries that are in use) when\n      * the release isn't done by the acquiring thread or when the entry pool is\n      * undersized compared to the load applied on it.\n      * When an entry can't be found in the cache, the global list is iterated\n-     * normally so the cache has no visible effect besides performance.\n+     * with the normal strategy so the cache has no visible effect besides performance.\n      */\n-    private final ThreadLocal<List<Entry>> cache;\n     private final Locker locker = new Locker();\n-    private final int maxEntries;\n-    private final int cacheSize;\n-    private final AtomicInteger pending = new AtomicInteger();\n+    private final ThreadLocal<Entry> cache;\n+    private final AtomicInteger nextIndex;\n     private volatile boolean closed;\n     private volatile int maxMultiplex = 1;\n     private volatile int maxUsageCount = -1;\n \n+    public enum StrategyType", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1ef761ed10d5d818a7c3e63a0d5769a00e6630af"}, "originalPosition": 79}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA2MTA2MTM1OnYy", "diffSide": "RIGHT", "path": "jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNlQwNzozMTo1NlrOHSj24g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNlQxMDowNTozOFrOHSpu7Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTIyMzkwNg==", "bodyText": "Add @deprecated javadoc too.", "url": "https://github.com/eclipse/jetty.project/pull/5218#discussion_r489223906", "createdAt": "2020-09-16T07:31:56Z", "author": {"login": "sbordet"}, "path": "jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java", "diffHunk": "@@ -176,14 +231,15 @@ public Entry reserve(int allotment)\n      * @param idx the index of the entry to acquire.\n      * @return the specified entry or null if there is none at the specified index or if it is not available.\n      */\n+    @Deprecated", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1ef761ed10d5d818a7c3e63a0d5769a00e6630af"}, "originalPosition": 184}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTMyMDE3Mw==", "bodyText": "I guess we can't just remove it... will do in 10", "url": "https://github.com/eclipse/jetty.project/pull/5218#discussion_r489320173", "createdAt": "2020-09-16T10:05:38Z", "author": {"login": "gregw"}, "path": "jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java", "diffHunk": "@@ -176,14 +231,15 @@ public Entry reserve(int allotment)\n      * @param idx the index of the entry to acquire.\n      * @return the specified entry or null if there is none at the specified index or if it is not available.\n      */\n+    @Deprecated", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTIyMzkwNg=="}, "originalCommit": {"oid": "1ef761ed10d5d818a7c3e63a0d5769a00e6630af"}, "originalPosition": 184}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA2MTA3MDc5OnYy", "diffSide": "RIGHT", "path": "jetty-util/src/test/java/org/eclipse/jetty/util/PoolTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNlQwNzozNDozOVrOHSj8nQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNlQwNzozNDozOVrOHSj8nQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTIyNTM3Mw==", "bodyText": "new Pool<>(...) is enough, remove type parameter.", "url": "https://github.com/eclipse/jetty.project/pull/5218#discussion_r489225373", "createdAt": "2020-09-16T07:34:39Z", "author": {"login": "sbordet"}, "path": "jetty-util/src/test/java/org/eclipse/jetty/util/PoolTest.java", "diffHunk": "@@ -40,20 +50,27 @@\n \n public class PoolTest\n {\n-    public static Stream<Object[]> cacheSize()\n+\n+    interface Factory\n+    {\n+        Pool<String> getPool(int maxSize);\n+    }\n+\n+    public static Stream<Object[]> strategy()\n     {\n         List<Object[]> data = new ArrayList<>();\n-        data.add(new Object[]{0});\n-        data.add(new Object[]{1});\n-        data.add(new Object[]{2});\n+        data.add(new Object[]{(Factory)s -> new Pool<String>(FIRST, s)});\n+        data.add(new Object[]{(Factory)s -> new Pool<String>(RANDOM, s)});\n+        data.add(new Object[]{(Factory)s -> new Pool<String>(FIRST, s, true)});\n+        data.add(new Object[]{(Factory)s -> new Pool<String>(ROUND_ROBIN, s)});", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1ef761ed10d5d818a7c3e63a0d5769a00e6630af"}, "originalPosition": 48}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA2MTA3NzE1OnYy", "diffSide": "RIGHT", "path": "jetty-util/src/test/java/org/eclipse/jetty/util/PoolTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNlQwNzozNjozNFrOHSkArw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNlQwNzozNjozNFrOHSkArw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTIyNjQxNQ==", "bodyText": "This test contains an unused e2 variable that I would instead add to the asserts, for example, to confirm that it is in use even after removing e1, or that e2 == e1, etc.", "url": "https://github.com/eclipse/jetty.project/pull/5218#discussion_r489226415", "createdAt": "2020-09-16T07:36:34Z", "author": {"login": "sbordet"}, "path": "jetty-util/src/test/java/org/eclipse/jetty/util/PoolTest.java", "diffHunk": "@@ -331,34 +347,44 @@ public void testMaxUsageCount(int cacheSize)\n     }\n \n     @ParameterizedTest\n-    @MethodSource(value = \"cacheSize\")\n-    public void testMaxMultiplex(int cacheSize)\n+    @MethodSource(value = \"strategy\")\n+    public void testMaxMultiplex(Factory factory)\n     {\n-        Pool<String> pool = new Pool<>(2, cacheSize);\n+        Pool<String> pool = factory.getPool(2);\n         pool.setMaxMultiplex(3);\n-        pool.reserve(-1).enable(\"aaa\", false);\n-        pool.reserve(-1).enable(\"bbb\", false);\n \n-        Pool<String>.Entry e1 = pool.acquire();\n-        Pool<String>.Entry e2 = pool.acquire();\n-        Pool<String>.Entry e3 = pool.acquire();\n-        Pool<String>.Entry e4 = pool.acquire();\n-        assertThat(e1.getPooled(), equalTo(\"aaa\"));\n-        assertThat(e1, sameInstance(e2));\n-        assertThat(e1, sameInstance(e3));\n-        assertThat(e4.getPooled(), equalTo(\"bbb\"));\n-        assertThat(pool.release(e1), is(true));\n-        Pool<String>.Entry e5 = pool.acquire();\n-        assertThat(e2, sameInstance(e5));\n-        Pool<String>.Entry e6 = pool.acquire();\n-        assertThat(e4, sameInstance(e6));\n+        Map<String, AtomicInteger> counts = new HashMap<>();\n+        AtomicInteger a = new AtomicInteger();\n+        AtomicInteger b = new AtomicInteger();\n+        counts.put(\"a\", a);\n+        counts.put(\"b\", b);\n+        pool.reserve(-1).enable(\"a\", false);\n+        pool.reserve(-1).enable(\"b\", false);\n+\n+        counts.get(pool.acquire().getPooled()).incrementAndGet();\n+        counts.get(pool.acquire().getPooled()).incrementAndGet();\n+        counts.get(pool.acquire().getPooled()).incrementAndGet();\n+        counts.get(pool.acquire().getPooled()).incrementAndGet();\n+\n+        assertThat(a.get(), greaterThan(0));\n+        assertThat(a.get(), lessThanOrEqualTo(3));\n+        assertThat(b.get(), greaterThan(0));\n+        assertThat(b.get(), lessThanOrEqualTo(3));\n+\n+        counts.get(pool.acquire().getPooled()).incrementAndGet();\n+        counts.get(pool.acquire().getPooled()).incrementAndGet();\n+\n+        assertThat(a.get(), is(3));\n+        assertThat(b.get(), is(3));\n+\n+        assertNull(pool.acquire());\n     }\n \n     @ParameterizedTest\n-    @MethodSource(value = \"cacheSize\")\n-    public void testRemoveMultiplexed(int cacheSize)\n+    @MethodSource(value = \"strategy\")\n+    public void testRemoveMultiplexed(Factory factory)\n     {\n-        Pool<String> pool = new Pool<>(1, cacheSize);\n+        Pool<String> pool = factory.getPool(1);\n         pool.setMaxMultiplex(2);\n         pool.reserve(-1).enable(\"aaa\", false);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1ef761ed10d5d818a7c3e63a0d5769a00e6630af"}, "originalPosition": 310}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA2MTA4MzAzOnYy", "diffSide": "RIGHT", "path": "jetty-util/src/test/java/org/eclipse/jetty/util/PoolTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNlQwNzozODoxOVrOHSkEXA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNlQwNzozODoxOVrOHSkEXA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTIyNzM1Ng==", "bodyText": "This test contains an unused variable e2 that I would use in asserts, at least to verify that e2 == e1.", "url": "https://github.com/eclipse/jetty.project/pull/5218#discussion_r489227356", "createdAt": "2020-09-16T07:38:19Z", "author": {"login": "sbordet"}, "path": "jetty-util/src/test/java/org/eclipse/jetty/util/PoolTest.java", "diffHunk": "@@ -506,10 +532,10 @@ public void testMultiplexMaxUsageReachedAcquireThenReleaseThenRemove(int cacheSi\n     }\n \n     @ParameterizedTest\n-    @MethodSource(value = \"cacheSize\")\n-    public void testUsageCountAfterReachingMaxMultiplexLimit(int cacheSize)\n+    @MethodSource(value = \"strategy\")\n+    public void testUsageCountAfterReachingMaxMultiplexLimit(Factory factory)\n     {\n-        Pool<String> pool = new Pool<>(1, cacheSize);\n+        Pool<String> pool = factory.getPool(1);\n         pool.setMaxMultiplex(2);\n         pool.setMaxUsageCount(10);\n         pool.reserve(-1).enable(\"aaa\", false);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1ef761ed10d5d818a7c3e63a0d5769a00e6630af"}, "originalPosition": 426}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2356, "cost": 1, "resetAt": "2021-11-12T18:49:56Z"}}}