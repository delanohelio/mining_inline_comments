{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0Mzc2NjI5NzQx", "number": 4587, "reviewThreads": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNFQxMzozMToyN1rODiU5_A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNFQxNDowNDowN1rODiVkKg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM3MzIwNzAwOnYy", "diffSide": "RIGHT", "path": "jetty-annotations/src/main/java/org/eclipse/jetty/annotations/AnnotationIntrospector.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNFQxMzozMToyOFrOFtgqIg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNFQxMzozMToyOFrOFtgqIg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzI2NTMxNA==", "bodyText": "Just a nit, holder = (BasedHolder)metaInfo is better here.", "url": "https://github.com/eclipse/jetty.project/pull/4587#discussion_r383265314", "createdAt": "2020-02-24T13:31:28Z", "author": {"login": "sbordet"}, "path": "jetty-annotations/src/main/java/org/eclipse/jetty/annotations/AnnotationIntrospector.java", "diffHunk": "@@ -75,20 +89,116 @@ public void handle(Class<?> clazz)\n                 c = c.getSuperclass();\n             }\n         }\n+        \n+        public WebAppContext getContext()\n+        {\n+            return _context;\n+        }\n+    }\n+    \n+    public AnnotationIntrospector(WebAppContext context)\n+    {\n+        _context = Objects.requireNonNull(context);\n     }\n \n     public void registerHandler(IntrospectableAnnotationHandler handler)\n     {\n         _handlers.add(handler);\n     }\n+    \n+    /**\n+     * Test if an object should be introspected for some specific types of annotations \n+     * like PostConstruct/PreDestroy/MultiPart etc etc.\n+     * \n+     * According to servlet 4.0, these types of annotations should only be evaluated iff any\n+     * of the following are true:\n+     * <ol>\n+     * <li>the object was created by the javax.servlet.ServletContext.createServlet/Filter/Listener method</li>\n+     * <li>the object comes either from a discovered annotation (WebServlet/Filter/Listener) or a declaration\n+     * in a descriptor AND web.xml is NOT metadata-complete AND any web-fragment.xml associated with the location of\n+     * the class is NOT metadata-complete</li>\n+     * </ol>\n+     * \n+     * We also support evaluations of these types of annotations for objects that were created directly\n+     * by the jetty api.\n+     *  \n+     * @param o the object to check for its ability to be introspected for annotations\n+     * @param metaInfo meta information about the object to be introspected\n+     * @return true if it can be introspected according to servlet 4.0 rules\n+     */\n+    public boolean isIntrospectable(Object o, Object metaInfo)\n+    {\n+        if (o == null)\n+            return false; //nothing to introspect\n+        \n+        if (metaInfo == null)\n+            return true;  //no information about the object to introspect, assume introspectable\n+        \n+        @SuppressWarnings(\"rawtypes\")\n+        BaseHolder holder = null;\n+        \n+        try\n+        {\n+            holder = BaseHolder.class.cast(metaInfo);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "510b99993aa962be5728bd68eadb5dbad0a3d048"}, "originalPosition": 104}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM3MzIxMjc0OnYy", "diffSide": "RIGHT", "path": "jetty-annotations/src/main/java/org/eclipse/jetty/annotations/AnnotationIntrospector.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNFQxMzozMzoxN1rOFtgtiw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNVQxMjowNzoxOVrOFuDqzg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzI2NjE4Nw==", "bodyText": "Add a message such as Log.warn(\"Could not get fragment descriptor {}\", descriptorLocation, e).", "url": "https://github.com/eclipse/jetty.project/pull/4587#discussion_r383266187", "createdAt": "2020-02-24T13:33:17Z", "author": {"login": "sbordet"}, "path": "jetty-annotations/src/main/java/org/eclipse/jetty/annotations/AnnotationIntrospector.java", "diffHunk": "@@ -75,20 +89,116 @@ public void handle(Class<?> clazz)\n                 c = c.getSuperclass();\n             }\n         }\n+        \n+        public WebAppContext getContext()\n+        {\n+            return _context;\n+        }\n+    }\n+    \n+    public AnnotationIntrospector(WebAppContext context)\n+    {\n+        _context = Objects.requireNonNull(context);\n     }\n \n     public void registerHandler(IntrospectableAnnotationHandler handler)\n     {\n         _handlers.add(handler);\n     }\n+    \n+    /**\n+     * Test if an object should be introspected for some specific types of annotations \n+     * like PostConstruct/PreDestroy/MultiPart etc etc.\n+     * \n+     * According to servlet 4.0, these types of annotations should only be evaluated iff any\n+     * of the following are true:\n+     * <ol>\n+     * <li>the object was created by the javax.servlet.ServletContext.createServlet/Filter/Listener method</li>\n+     * <li>the object comes either from a discovered annotation (WebServlet/Filter/Listener) or a declaration\n+     * in a descriptor AND web.xml is NOT metadata-complete AND any web-fragment.xml associated with the location of\n+     * the class is NOT metadata-complete</li>\n+     * </ol>\n+     * \n+     * We also support evaluations of these types of annotations for objects that were created directly\n+     * by the jetty api.\n+     *  \n+     * @param o the object to check for its ability to be introspected for annotations\n+     * @param metaInfo meta information about the object to be introspected\n+     * @return true if it can be introspected according to servlet 4.0 rules\n+     */\n+    public boolean isIntrospectable(Object o, Object metaInfo)\n+    {\n+        if (o == null)\n+            return false; //nothing to introspect\n+        \n+        if (metaInfo == null)\n+            return true;  //no information about the object to introspect, assume introspectable\n+        \n+        @SuppressWarnings(\"rawtypes\")\n+        BaseHolder holder = null;\n+        \n+        try\n+        {\n+            holder = BaseHolder.class.cast(metaInfo);\n+        }\n+        catch (ClassCastException e)\n+        {\n+            LOG.warn(e);\n+            return true; //not the type of information we were expecting, assume introspectable\n+        }\n+        \n+        Origin origin = (holder.getSource() == null ? null : holder.getSource().getOrigin());\n+        if (origin == null)\n+            return true;//assume introspectable\n+        \n+        switch (origin)\n+        {\n+            case EMBEDDED:\n+            case JAVAX_API:\n+            {\n+                return true; //objects created from the jetty or servlet api are always introspectable\n+            }\n+            case ANNOTATION:\n+            {\n+                return true; //we will have discovered annotations only if metadata-complete==false\n+            }\n+            default:\n+            {\n+                //must be from a descriptor. Only introspect if the descriptor with which it was associated\n+                //is not metadata-complete\n+                if (_context.getMetaData().isMetaDataComplete())\n+                    return false;\n+                \n+                String descriptorLocation = holder.getSource().getResource();\n+                if (descriptorLocation == null)\n+                    return true; //no descriptor, can't be metadata-complete\n+                try\n+                {\n+                    return !WebDescriptor.isMetaDataComplete(_context.getMetaData().getFragmentDescriptor(Resource.newResource(descriptorLocation)));\n+                }\n+                catch (IOException e)\n+                {\n+                    LOG.warn(e);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "510b99993aa962be5728bd68eadb5dbad0a3d048"}, "originalPosition": 143}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzgzMzM0Ng==", "bodyText": "Eh, good luck with that formulation. Need to have 2 LOG.warns, one with the message, one with the throwable - the last arg isn't interpreted as a Throwable.", "url": "https://github.com/eclipse/jetty.project/pull/4587#discussion_r383833346", "createdAt": "2020-02-25T11:54:48Z", "author": {"login": "janbartel"}, "path": "jetty-annotations/src/main/java/org/eclipse/jetty/annotations/AnnotationIntrospector.java", "diffHunk": "@@ -75,20 +89,116 @@ public void handle(Class<?> clazz)\n                 c = c.getSuperclass();\n             }\n         }\n+        \n+        public WebAppContext getContext()\n+        {\n+            return _context;\n+        }\n+    }\n+    \n+    public AnnotationIntrospector(WebAppContext context)\n+    {\n+        _context = Objects.requireNonNull(context);\n     }\n \n     public void registerHandler(IntrospectableAnnotationHandler handler)\n     {\n         _handlers.add(handler);\n     }\n+    \n+    /**\n+     * Test if an object should be introspected for some specific types of annotations \n+     * like PostConstruct/PreDestroy/MultiPart etc etc.\n+     * \n+     * According to servlet 4.0, these types of annotations should only be evaluated iff any\n+     * of the following are true:\n+     * <ol>\n+     * <li>the object was created by the javax.servlet.ServletContext.createServlet/Filter/Listener method</li>\n+     * <li>the object comes either from a discovered annotation (WebServlet/Filter/Listener) or a declaration\n+     * in a descriptor AND web.xml is NOT metadata-complete AND any web-fragment.xml associated with the location of\n+     * the class is NOT metadata-complete</li>\n+     * </ol>\n+     * \n+     * We also support evaluations of these types of annotations for objects that were created directly\n+     * by the jetty api.\n+     *  \n+     * @param o the object to check for its ability to be introspected for annotations\n+     * @param metaInfo meta information about the object to be introspected\n+     * @return true if it can be introspected according to servlet 4.0 rules\n+     */\n+    public boolean isIntrospectable(Object o, Object metaInfo)\n+    {\n+        if (o == null)\n+            return false; //nothing to introspect\n+        \n+        if (metaInfo == null)\n+            return true;  //no information about the object to introspect, assume introspectable\n+        \n+        @SuppressWarnings(\"rawtypes\")\n+        BaseHolder holder = null;\n+        \n+        try\n+        {\n+            holder = BaseHolder.class.cast(metaInfo);\n+        }\n+        catch (ClassCastException e)\n+        {\n+            LOG.warn(e);\n+            return true; //not the type of information we were expecting, assume introspectable\n+        }\n+        \n+        Origin origin = (holder.getSource() == null ? null : holder.getSource().getOrigin());\n+        if (origin == null)\n+            return true;//assume introspectable\n+        \n+        switch (origin)\n+        {\n+            case EMBEDDED:\n+            case JAVAX_API:\n+            {\n+                return true; //objects created from the jetty or servlet api are always introspectable\n+            }\n+            case ANNOTATION:\n+            {\n+                return true; //we will have discovered annotations only if metadata-complete==false\n+            }\n+            default:\n+            {\n+                //must be from a descriptor. Only introspect if the descriptor with which it was associated\n+                //is not metadata-complete\n+                if (_context.getMetaData().isMetaDataComplete())\n+                    return false;\n+                \n+                String descriptorLocation = holder.getSource().getResource();\n+                if (descriptorLocation == null)\n+                    return true; //no descriptor, can't be metadata-complete\n+                try\n+                {\n+                    return !WebDescriptor.isMetaDataComplete(_context.getMetaData().getFragmentDescriptor(Resource.newResource(descriptorLocation)));\n+                }\n+                catch (IOException e)\n+                {\n+                    LOG.warn(e);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzI2NjE4Nw=="}, "originalCommit": {"oid": "510b99993aa962be5728bd68eadb5dbad0a3d048"}, "originalPosition": 143}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzgzODkyNg==", "bodyText": "@janbartel all logger frameworks support that, and ours too with a recent PR.", "url": "https://github.com/eclipse/jetty.project/pull/4587#discussion_r383838926", "createdAt": "2020-02-25T12:07:19Z", "author": {"login": "sbordet"}, "path": "jetty-annotations/src/main/java/org/eclipse/jetty/annotations/AnnotationIntrospector.java", "diffHunk": "@@ -75,20 +89,116 @@ public void handle(Class<?> clazz)\n                 c = c.getSuperclass();\n             }\n         }\n+        \n+        public WebAppContext getContext()\n+        {\n+            return _context;\n+        }\n+    }\n+    \n+    public AnnotationIntrospector(WebAppContext context)\n+    {\n+        _context = Objects.requireNonNull(context);\n     }\n \n     public void registerHandler(IntrospectableAnnotationHandler handler)\n     {\n         _handlers.add(handler);\n     }\n+    \n+    /**\n+     * Test if an object should be introspected for some specific types of annotations \n+     * like PostConstruct/PreDestroy/MultiPart etc etc.\n+     * \n+     * According to servlet 4.0, these types of annotations should only be evaluated iff any\n+     * of the following are true:\n+     * <ol>\n+     * <li>the object was created by the javax.servlet.ServletContext.createServlet/Filter/Listener method</li>\n+     * <li>the object comes either from a discovered annotation (WebServlet/Filter/Listener) or a declaration\n+     * in a descriptor AND web.xml is NOT metadata-complete AND any web-fragment.xml associated with the location of\n+     * the class is NOT metadata-complete</li>\n+     * </ol>\n+     * \n+     * We also support evaluations of these types of annotations for objects that were created directly\n+     * by the jetty api.\n+     *  \n+     * @param o the object to check for its ability to be introspected for annotations\n+     * @param metaInfo meta information about the object to be introspected\n+     * @return true if it can be introspected according to servlet 4.0 rules\n+     */\n+    public boolean isIntrospectable(Object o, Object metaInfo)\n+    {\n+        if (o == null)\n+            return false; //nothing to introspect\n+        \n+        if (metaInfo == null)\n+            return true;  //no information about the object to introspect, assume introspectable\n+        \n+        @SuppressWarnings(\"rawtypes\")\n+        BaseHolder holder = null;\n+        \n+        try\n+        {\n+            holder = BaseHolder.class.cast(metaInfo);\n+        }\n+        catch (ClassCastException e)\n+        {\n+            LOG.warn(e);\n+            return true; //not the type of information we were expecting, assume introspectable\n+        }\n+        \n+        Origin origin = (holder.getSource() == null ? null : holder.getSource().getOrigin());\n+        if (origin == null)\n+            return true;//assume introspectable\n+        \n+        switch (origin)\n+        {\n+            case EMBEDDED:\n+            case JAVAX_API:\n+            {\n+                return true; //objects created from the jetty or servlet api are always introspectable\n+            }\n+            case ANNOTATION:\n+            {\n+                return true; //we will have discovered annotations only if metadata-complete==false\n+            }\n+            default:\n+            {\n+                //must be from a descriptor. Only introspect if the descriptor with which it was associated\n+                //is not metadata-complete\n+                if (_context.getMetaData().isMetaDataComplete())\n+                    return false;\n+                \n+                String descriptorLocation = holder.getSource().getResource();\n+                if (descriptorLocation == null)\n+                    return true; //no descriptor, can't be metadata-complete\n+                try\n+                {\n+                    return !WebDescriptor.isMetaDataComplete(_context.getMetaData().getFragmentDescriptor(Resource.newResource(descriptorLocation)));\n+                }\n+                catch (IOException e)\n+                {\n+                    LOG.warn(e);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzI2NjE4Nw=="}, "originalCommit": {"oid": "510b99993aa962be5728bd68eadb5dbad0a3d048"}, "originalPosition": 143}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM3MzIxODEyOnYy", "diffSide": "RIGHT", "path": "jetty-annotations/src/main/java/org/eclipse/jetty/annotations/AnnotationIntrospector.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNFQxMzozNDo1OFrOFtgwpw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNFQxMzozNDo1OFrOFtgwpw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzI2Njk4Mw==", "bodyText": "Add space after semicolon.", "url": "https://github.com/eclipse/jetty.project/pull/4587#discussion_r383266983", "createdAt": "2020-02-24T13:34:58Z", "author": {"login": "sbordet"}, "path": "jetty-annotations/src/main/java/org/eclipse/jetty/annotations/AnnotationIntrospector.java", "diffHunk": "@@ -75,20 +89,116 @@ public void handle(Class<?> clazz)\n                 c = c.getSuperclass();\n             }\n         }\n+        \n+        public WebAppContext getContext()\n+        {\n+            return _context;\n+        }\n+    }\n+    \n+    public AnnotationIntrospector(WebAppContext context)\n+    {\n+        _context = Objects.requireNonNull(context);\n     }\n \n     public void registerHandler(IntrospectableAnnotationHandler handler)\n     {\n         _handlers.add(handler);\n     }\n+    \n+    /**\n+     * Test if an object should be introspected for some specific types of annotations \n+     * like PostConstruct/PreDestroy/MultiPart etc etc.\n+     * \n+     * According to servlet 4.0, these types of annotations should only be evaluated iff any\n+     * of the following are true:\n+     * <ol>\n+     * <li>the object was created by the javax.servlet.ServletContext.createServlet/Filter/Listener method</li>\n+     * <li>the object comes either from a discovered annotation (WebServlet/Filter/Listener) or a declaration\n+     * in a descriptor AND web.xml is NOT metadata-complete AND any web-fragment.xml associated with the location of\n+     * the class is NOT metadata-complete</li>\n+     * </ol>\n+     * \n+     * We also support evaluations of these types of annotations for objects that were created directly\n+     * by the jetty api.\n+     *  \n+     * @param o the object to check for its ability to be introspected for annotations\n+     * @param metaInfo meta information about the object to be introspected\n+     * @return true if it can be introspected according to servlet 4.0 rules\n+     */\n+    public boolean isIntrospectable(Object o, Object metaInfo)\n+    {\n+        if (o == null)\n+            return false; //nothing to introspect\n+        \n+        if (metaInfo == null)\n+            return true;  //no information about the object to introspect, assume introspectable\n+        \n+        @SuppressWarnings(\"rawtypes\")\n+        BaseHolder holder = null;\n+        \n+        try\n+        {\n+            holder = BaseHolder.class.cast(metaInfo);\n+        }\n+        catch (ClassCastException e)\n+        {\n+            LOG.warn(e);\n+            return true; //not the type of information we were expecting, assume introspectable\n+        }\n+        \n+        Origin origin = (holder.getSource() == null ? null : holder.getSource().getOrigin());\n+        if (origin == null)\n+            return true;//assume introspectable", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "510b99993aa962be5728bd68eadb5dbad0a3d048"}, "originalPosition": 114}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM3MzI0MjIyOnYy", "diffSide": "RIGHT", "path": "jetty-servlet/src/main/java/org/eclipse/jetty/servlet/BaseHolder.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNFQxMzo0MjozOVrOFtg_HA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNFQxMzo0MjozOVrOFtg_HA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzI3MDY4NA==", "bodyText": "This catch is duplicated in ServletHolder.newInstance(). Can the diplucation be removed?\nAlso, this method has a quite long list of exceptions being thrown, but they are not really handled: all places that invoke this method just catch Exception and bail out. So perhaps just throws Exception?", "url": "https://github.com/eclipse/jetty.project/pull/4587#discussion_r383270684", "createdAt": "2020-02-24T13:42:39Z", "author": {"login": "sbordet"}, "path": "jetty-servlet/src/main/java/org/eclipse/jetty/servlet/BaseHolder.java", "diffHunk": "@@ -177,6 +181,57 @@ protected synchronized T getInstance()\n         return _instance;\n     }\n \n+    protected synchronized T createInstance() throws ServletException, IllegalAccessException, InstantiationException,\n+        NoSuchMethodException, InvocationTargetException\n+    {\n+        try\n+        {\n+            ServletContext ctx = getServletContext();\n+            if (ctx == null)\n+                return getHeldClass().getDeclaredConstructor().newInstance();\n+\n+            if (ServletContextHandler.Context.class.isAssignableFrom(ctx.getClass()))\n+                return ((ServletContextHandler.Context)ctx).createInstance(this);\n+            \n+            return null;\n+        }\n+        catch (ServletException ex)\n+        {\n+            Throwable cause = ex.getRootCause();\n+            if (cause instanceof InstantiationException)\n+                throw (InstantiationException)cause;\n+            if (cause instanceof IllegalAccessException)\n+                throw (IllegalAccessException)cause;\n+            if (cause instanceof NoSuchMethodException)\n+                throw (NoSuchMethodException)cause;\n+            if (cause instanceof InvocationTargetException)\n+                throw (InvocationTargetException)cause;\n+            throw ex;\n+        }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "510b99993aa962be5728bd68eadb5dbad0a3d048"}, "originalPosition": 45}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM3MzI1MzQxOnYy", "diffSide": "RIGHT", "path": "jetty-annotations/src/main/java/org/eclipse/jetty/annotations/AnnotationIntrospector.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNFQxMzo0NTo1OVrOFthF4Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNFQxMzo0NTo1OVrOFthF4Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzI3MjQxNw==", "bodyText": "_handlers can never be null.", "url": "https://github.com/eclipse/jetty.project/pull/4587#discussion_r383272417", "createdAt": "2020-02-24T13:45:59Z", "author": {"login": "sbordet"}, "path": "jetty-annotations/src/main/java/org/eclipse/jetty/annotations/AnnotationIntrospector.java", "diffHunk": "@@ -75,20 +89,116 @@ public void handle(Class<?> clazz)\n                 c = c.getSuperclass();\n             }\n         }\n+        \n+        public WebAppContext getContext()\n+        {\n+            return _context;\n+        }\n+    }\n+    \n+    public AnnotationIntrospector(WebAppContext context)\n+    {\n+        _context = Objects.requireNonNull(context);\n     }\n \n     public void registerHandler(IntrospectableAnnotationHandler handler)\n     {\n         _handlers.add(handler);\n     }\n+    \n+    /**\n+     * Test if an object should be introspected for some specific types of annotations \n+     * like PostConstruct/PreDestroy/MultiPart etc etc.\n+     * \n+     * According to servlet 4.0, these types of annotations should only be evaluated iff any\n+     * of the following are true:\n+     * <ol>\n+     * <li>the object was created by the javax.servlet.ServletContext.createServlet/Filter/Listener method</li>\n+     * <li>the object comes either from a discovered annotation (WebServlet/Filter/Listener) or a declaration\n+     * in a descriptor AND web.xml is NOT metadata-complete AND any web-fragment.xml associated with the location of\n+     * the class is NOT metadata-complete</li>\n+     * </ol>\n+     * \n+     * We also support evaluations of these types of annotations for objects that were created directly\n+     * by the jetty api.\n+     *  \n+     * @param o the object to check for its ability to be introspected for annotations\n+     * @param metaInfo meta information about the object to be introspected\n+     * @return true if it can be introspected according to servlet 4.0 rules\n+     */\n+    public boolean isIntrospectable(Object o, Object metaInfo)\n+    {\n+        if (o == null)\n+            return false; //nothing to introspect\n+        \n+        if (metaInfo == null)\n+            return true;  //no information about the object to introspect, assume introspectable\n+        \n+        @SuppressWarnings(\"rawtypes\")\n+        BaseHolder holder = null;\n+        \n+        try\n+        {\n+            holder = BaseHolder.class.cast(metaInfo);\n+        }\n+        catch (ClassCastException e)\n+        {\n+            LOG.warn(e);\n+            return true; //not the type of information we were expecting, assume introspectable\n+        }\n+        \n+        Origin origin = (holder.getSource() == null ? null : holder.getSource().getOrigin());\n+        if (origin == null)\n+            return true;//assume introspectable\n+        \n+        switch (origin)\n+        {\n+            case EMBEDDED:\n+            case JAVAX_API:\n+            {\n+                return true; //objects created from the jetty or servlet api are always introspectable\n+            }\n+            case ANNOTATION:\n+            {\n+                return true; //we will have discovered annotations only if metadata-complete==false\n+            }\n+            default:\n+            {\n+                //must be from a descriptor. Only introspect if the descriptor with which it was associated\n+                //is not metadata-complete\n+                if (_context.getMetaData().isMetaDataComplete())\n+                    return false;\n+                \n+                String descriptorLocation = holder.getSource().getResource();\n+                if (descriptorLocation == null)\n+                    return true; //no descriptor, can't be metadata-complete\n+                try\n+                {\n+                    return !WebDescriptor.isMetaDataComplete(_context.getMetaData().getFragmentDescriptor(Resource.newResource(descriptorLocation)));\n+                }\n+                catch (IOException e)\n+                {\n+                    LOG.warn(e);\n+                    return false; //something wrong with the descriptor\n+                }\n+            }\n+        }\n+    }\n \n-    public void introspect(Class<?> clazz)\n+    /**\n+     * @param o\n+     * @param metaInfo\n+     */\n+    public void introspect(Object o, Object metaInfo)\n     {\n         if (_handlers == null)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "510b99993aa962be5728bd68eadb5dbad0a3d048"}, "originalPosition": 157}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM3MzI3NjcxOnYy", "diffSide": "RIGHT", "path": "jetty-util/src/main/java/org/eclipse/jetty/util/resource/PathResource.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNFQxMzo1Mjo1NVrOFthT3g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNFQxMzo1Mjo1NVrOFthT3g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzI3NTk5OA==", "bodyText": "Use a normal case to PathResource and simplify to: return path.startsWith....\nAlso, the method never throws MalformedURLException.", "url": "https://github.com/eclipse/jetty.project/pull/4587#discussion_r383275998", "createdAt": "2020-02-24T13:52:55Z", "author": {"login": "sbordet"}, "path": "jetty-util/src/main/java/org/eclipse/jetty/util/resource/PathResource.java", "diffHunk": "@@ -462,8 +462,18 @@ public int hashCode()\n     @Override\n     public boolean isContainedIn(Resource r) throws MalformedURLException\n     {\n-        // not applicable for FileSystem / path\n-        return false;\n+        try\n+        {\n+            PathResource pr = PathResource.class.cast(r);\n+            if (path.startsWith(pr.getPath()))\n+                return true;\n+\n+            return false;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "510b99993aa962be5728bd68eadb5dbad0a3d048"}, "originalPosition": 12}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM3MzMwMjY2OnYy", "diffSide": "LEFT", "path": "jetty-webapp/src/main/java/org/eclipse/jetty/webapp/StandardDescriptorProcessor.java", "isResolved": false, "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNFQxNDowMDo1MVrOFthjvQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNVQxNToyMDoyN1rOFuKNqQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzI4MDA2MQ==", "bodyText": "The distributable element has been removed in Servlet 4.0?\nEven though it's been removed, I would leave the \"visit\" and eventually write a comment in visitDistributable why we do nothing.\nRemoving it from here seems like a mistake or an overlook (\"hey, they forgot to visit distributable\").", "url": "https://github.com/eclipse/jetty.project/pull/4587#discussion_r383280061", "createdAt": "2020-02-24T14:00:51Z", "author": {"login": "sbordet"}, "path": "jetty-webapp/src/main/java/org/eclipse/jetty/webapp/StandardDescriptorProcessor.java", "diffHunk": "@@ -97,7 +96,6 @@ public StandardDescriptorProcessor()\n             registerVisitor(\"filter\", this.getClass().getMethod(\"visitFilter\", __signature));\n             registerVisitor(\"filter-mapping\", this.getClass().getMethod(\"visitFilterMapping\", __signature));\n             registerVisitor(\"listener\", this.getClass().getMethod(\"visitListener\", __signature));\n-            registerVisitor(\"distributable\", this.getClass().getMethod(\"visitDistributable\", __signature));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "510b99993aa962be5728bd68eadb5dbad0a3d048"}, "originalPosition": 12}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mzg0MzMxMg==", "bodyText": "No, it hasn't been removed. The handling of it has just been refactored to WebDescriptor, where it should have been from the beginning, along with other \"metadata\" about the descriptor (eg is metadata-complete, version etc), not artifacts like servlets/filters etc that is handled by StandardDescriptorProcessor.", "url": "https://github.com/eclipse/jetty.project/pull/4587#discussion_r383843312", "createdAt": "2020-02-25T12:17:17Z", "author": {"login": "janbartel"}, "path": "jetty-webapp/src/main/java/org/eclipse/jetty/webapp/StandardDescriptorProcessor.java", "diffHunk": "@@ -97,7 +96,6 @@ public StandardDescriptorProcessor()\n             registerVisitor(\"filter\", this.getClass().getMethod(\"visitFilter\", __signature));\n             registerVisitor(\"filter-mapping\", this.getClass().getMethod(\"visitFilterMapping\", __signature));\n             registerVisitor(\"listener\", this.getClass().getMethod(\"visitListener\", __signature));\n-            registerVisitor(\"distributable\", this.getClass().getMethod(\"visitDistributable\", __signature));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzI4MDA2MQ=="}, "originalCommit": {"oid": "510b99993aa962be5728bd68eadb5dbad0a3d048"}, "originalPosition": 12}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzkyNjQ4MA==", "bodyText": "@janbartel yes I saw that handling of distributable has been moved to WebDescriptor.\nHowever, I would still keep the registerVisitor(\"distributable\", ...) here because it's the one place where I can verify that all elements of a descriptor are actually visited - it's just for completeness so that when someone else comes here it won't say \"oh, we don't visit distributable\" and has to reverse engineer where is it actually handled. The empty visitDistributable() method can have a comment that says where it is handled.", "url": "https://github.com/eclipse/jetty.project/pull/4587#discussion_r383926480", "createdAt": "2020-02-25T14:51:04Z", "author": {"login": "sbordet"}, "path": "jetty-webapp/src/main/java/org/eclipse/jetty/webapp/StandardDescriptorProcessor.java", "diffHunk": "@@ -97,7 +96,6 @@ public StandardDescriptorProcessor()\n             registerVisitor(\"filter\", this.getClass().getMethod(\"visitFilter\", __signature));\n             registerVisitor(\"filter-mapping\", this.getClass().getMethod(\"visitFilterMapping\", __signature));\n             registerVisitor(\"listener\", this.getClass().getMethod(\"visitListener\", __signature));\n-            registerVisitor(\"distributable\", this.getClass().getMethod(\"visitDistributable\", __signature));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzI4MDA2MQ=="}, "originalCommit": {"oid": "510b99993aa962be5728bd68eadb5dbad0a3d048"}, "originalPosition": 12}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzkzMTkzMQ==", "bodyText": "@janbartel in other words, why is distributable different from the others so that it must be handled differently?\nThe original code of calling ((WebDescriptor)descriptor).setDistributable(true) made sense to me.", "url": "https://github.com/eclipse/jetty.project/pull/4587#discussion_r383931931", "createdAt": "2020-02-25T14:58:46Z", "author": {"login": "sbordet"}, "path": "jetty-webapp/src/main/java/org/eclipse/jetty/webapp/StandardDescriptorProcessor.java", "diffHunk": "@@ -97,7 +96,6 @@ public StandardDescriptorProcessor()\n             registerVisitor(\"filter\", this.getClass().getMethod(\"visitFilter\", __signature));\n             registerVisitor(\"filter-mapping\", this.getClass().getMethod(\"visitFilterMapping\", __signature));\n             registerVisitor(\"listener\", this.getClass().getMethod(\"visitListener\", __signature));\n-            registerVisitor(\"distributable\", this.getClass().getMethod(\"visitDistributable\", __signature));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzI4MDA2MQ=="}, "originalCommit": {"oid": "510b99993aa962be5728bd68eadb5dbad0a3d048"}, "originalPosition": 12}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mzk0NjE1Mw==", "bodyText": "\"Distributable\" is just like the handling of the \"version\" of the webapp, or the \"metadata-complete\" attribute of the webapp: they are meta-data about the descriptor/webapp.  We've never had a visitWebApp method on StandardDescriptorProcessor for example, so it's not and never has been the case that StandardDescriptorProcessor has visited everything in the webapp - some things you have to visit first, before you know what you can visit!\nMoreover, I don't find it correct that the StandardDescriptorProcessor calls setters on the Descriptor:  the Descriptor should be set up with information that is read by the StandardDescriptorProcessor and not vice versa.", "url": "https://github.com/eclipse/jetty.project/pull/4587#discussion_r383946153", "createdAt": "2020-02-25T15:20:27Z", "author": {"login": "janbartel"}, "path": "jetty-webapp/src/main/java/org/eclipse/jetty/webapp/StandardDescriptorProcessor.java", "diffHunk": "@@ -97,7 +96,6 @@ public StandardDescriptorProcessor()\n             registerVisitor(\"filter\", this.getClass().getMethod(\"visitFilter\", __signature));\n             registerVisitor(\"filter-mapping\", this.getClass().getMethod(\"visitFilterMapping\", __signature));\n             registerVisitor(\"listener\", this.getClass().getMethod(\"visitListener\", __signature));\n-            registerVisitor(\"distributable\", this.getClass().getMethod(\"visitDistributable\", __signature));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzI4MDA2MQ=="}, "originalCommit": {"oid": "510b99993aa962be5728bd68eadb5dbad0a3d048"}, "originalPosition": 12}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM3MzMxNDk4OnYy", "diffSide": "RIGHT", "path": "jetty-annotations/src/test/resources/web-fragment4false.xml", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNFQxNDowNDowN1rOFthq3Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNVQxMjoxNzozN1rOFuD8ew==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzI4MTg4NQ==", "bodyText": "This fragment is called ...4false, but IIUC there is a difference between not set and explicitly set to false.\nIf that's the case, do we have tests that differentiate between the two?", "url": "https://github.com/eclipse/jetty.project/pull/4587#discussion_r383281885", "createdAt": "2020-02-24T14:04:07Z", "author": {"login": "sbordet"}, "path": "jetty-annotations/src/test/resources/web-fragment4false.xml", "diffHunk": "@@ -0,0 +1,11 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+\n+<web-fragment \n+   xmlns=\"http://xmlns.jcp.org/xml/ns/javaee\"\n+   xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+   xsi:schemaLocation=\"http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-fragment_4_0.xsd\"\n+   version=\"4.0\"> \n+  <name>ardvaark</name>\n+</web-fragment>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "510b99993aa962be5728bd68eadb5dbad0a3d048"}, "originalPosition": 9}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mzg0MzQ1MQ==", "bodyText": "Nope, missing or false are equivalent according to the spec.", "url": "https://github.com/eclipse/jetty.project/pull/4587#discussion_r383843451", "createdAt": "2020-02-25T12:17:37Z", "author": {"login": "janbartel"}, "path": "jetty-annotations/src/test/resources/web-fragment4false.xml", "diffHunk": "@@ -0,0 +1,11 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+\n+<web-fragment \n+   xmlns=\"http://xmlns.jcp.org/xml/ns/javaee\"\n+   xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+   xsi:schemaLocation=\"http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-fragment_4_0.xsd\"\n+   version=\"4.0\"> \n+  <name>ardvaark</name>\n+</web-fragment>", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzI4MTg4NQ=="}, "originalCommit": {"oid": "510b99993aa962be5728bd68eadb5dbad0a3d048"}, "originalPosition": 9}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2623, "cost": 1, "resetAt": "2021-11-12T18:49:56Z"}}}