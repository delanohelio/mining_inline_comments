{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzY2OTQ2MzA3", "number": 4519, "title": "Composable connection factories", "bodyText": "Issue #4518 - Protocol-detecting connection factories", "createdAt": "2020-01-24T17:46:37Z", "url": "https://github.com/eclipse/jetty.project/pull/4519", "merged": true, "mergeCommit": {"oid": "9f7a82b128cf2bc4136310ab6ee29d5a0561982f"}, "closed": true, "closedAt": "2020-02-16T18:25:05Z", "author": {"login": "lorban"}, "timelineItems": {"totalCount": 36, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABb-X-ssABqjI5ODA3OTQ1NDE=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcBnAOagH2gAyMzY2OTQ2MzA3OjM4NmQ5MzQ4Y2EzZDBmOTVhOTQ1NmRjYWE5Mjc4MmJjMmQxZTczZWM=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "21c21d6de70172fa3f229c80627a9cfd63cfe303", "author": {"user": {"login": "lorban", "name": "Ludovic Orban"}}, "url": "https://github.com/eclipse/jetty.project/commit/21c21d6de70172fa3f229c80627a9cfd63cfe303", "committedDate": "2020-01-27T07:48:17Z", "message": "cleanups\n\nSigned-off-by: Ludovic Orban <lorban@bitronix.be>"}, "afterCommit": {"oid": "0a27e73e0d4b11758bc545dd12d2d48ad60a30f9", "author": {"user": {"login": "lorban", "name": "Ludovic Orban"}}, "url": "https://github.com/eclipse/jetty.project/commit/0a27e73e0d4b11758bc545dd12d2d48ad60a30f9", "committedDate": "2020-01-27T07:54:23Z", "message": "Implement optional and sensing connection factories\n\nSigned-off-by: Ludovic Orban <lorban@bitronix.be>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "b358e5119e08f7e6d933e3b8f51763f2e6e442d5", "author": {"user": {"login": "lorban", "name": "Ludovic Orban"}}, "url": "https://github.com/eclipse/jetty.project/commit/b358e5119e08f7e6d933e3b8f51763f2e6e442d5", "committedDate": "2020-01-27T07:54:55Z", "message": "remove blocking reads\n\nSigned-off-by: Ludovic Orban <lorban@bitronix.be>"}, "afterCommit": {"oid": "aad0223277ecab7eb29d28782e4fa629197ed26b", "author": {"user": {"login": "lorban", "name": "Ludovic Orban"}}, "url": "https://github.com/eclipse/jetty.project/commit/aad0223277ecab7eb29d28782e4fa629197ed26b", "committedDate": "2020-01-27T07:55:26Z", "message": "Implement optional and sensing connection factories\n\nSigned-off-by: Ludovic Orban <lorban@bitronix.be>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "aad0223277ecab7eb29d28782e4fa629197ed26b", "author": {"user": {"login": "lorban", "name": "Ludovic Orban"}}, "url": "https://github.com/eclipse/jetty.project/commit/aad0223277ecab7eb29d28782e4fa629197ed26b", "committedDate": "2020-01-27T07:55:26Z", "message": "Implement optional and sensing connection factories\n\nSigned-off-by: Ludovic Orban <lorban@bitronix.be>"}, "afterCommit": {"oid": "1c48f7bc72659479e584b1621e0bb4c3085e1db7", "author": {"user": {"login": "lorban", "name": "Ludovic Orban"}}, "url": "https://github.com/eclipse/jetty.project/commit/1c48f7bc72659479e584b1621e0bb4c3085e1db7", "committedDate": "2020-01-27T09:14:18Z", "message": "Implement optional and sensing connection factories\n\nSigned-off-by: Ludovic Orban <lorban@bitronix.be>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "1c48f7bc72659479e584b1621e0bb4c3085e1db7", "author": {"user": {"login": "lorban", "name": "Ludovic Orban"}}, "url": "https://github.com/eclipse/jetty.project/commit/1c48f7bc72659479e584b1621e0bb4c3085e1db7", "committedDate": "2020-01-27T09:14:18Z", "message": "Implement optional and sensing connection factories\n\nSigned-off-by: Ludovic Orban <lorban@bitronix.be>"}, "afterCommit": {"oid": "b78249584055f218b9239d1beb2bd1219df16587", "author": {"user": {"login": "lorban", "name": "Ludovic Orban"}}, "url": "https://github.com/eclipse/jetty.project/commit/b78249584055f218b9239d1beb2bd1219df16587", "committedDate": "2020-01-27T09:25:06Z", "message": "Implement optional and sensing connection factories\n\nSigned-off-by: Ludovic Orban <lorban@bitronix.be>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "b78249584055f218b9239d1beb2bd1219df16587", "author": {"user": {"login": "lorban", "name": "Ludovic Orban"}}, "url": "https://github.com/eclipse/jetty.project/commit/b78249584055f218b9239d1beb2bd1219df16587", "committedDate": "2020-01-27T09:25:06Z", "message": "Implement optional and sensing connection factories\n\nSigned-off-by: Ludovic Orban <lorban@bitronix.be>"}, "afterCommit": {"oid": "b6798ed6b529723032732fcf0d5cbdb4cfd67f0f", "author": {"user": {"login": "lorban", "name": "Ludovic Orban"}}, "url": "https://github.com/eclipse/jetty.project/commit/b6798ed6b529723032732fcf0d5cbdb4cfd67f0f", "committedDate": "2020-01-27T09:52:23Z", "message": "Implement optional and sensing connection factories\n\nSigned-off-by: Ludovic Orban <lorban@bitronix.be>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "b6798ed6b529723032732fcf0d5cbdb4cfd67f0f", "author": {"user": {"login": "lorban", "name": "Ludovic Orban"}}, "url": "https://github.com/eclipse/jetty.project/commit/b6798ed6b529723032732fcf0d5cbdb4cfd67f0f", "committedDate": "2020-01-27T09:52:23Z", "message": "Implement optional and sensing connection factories\n\nSigned-off-by: Ludovic Orban <lorban@bitronix.be>"}, "afterCommit": {"oid": "0f11755d945cd7669fbcc687b06a920d7d076faf", "author": {"user": {"login": "lorban", "name": "Ludovic Orban"}}, "url": "https://github.com/eclipse/jetty.project/commit/0f11755d945cd7669fbcc687b06a920d7d076faf", "committedDate": "2020-01-27T11:14:32Z", "message": "Implement optional and sensing connection factories\n\nSigned-off-by: Ludovic Orban <lorban@bitronix.be>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "0f11755d945cd7669fbcc687b06a920d7d076faf", "author": {"user": {"login": "lorban", "name": "Ludovic Orban"}}, "url": "https://github.com/eclipse/jetty.project/commit/0f11755d945cd7669fbcc687b06a920d7d076faf", "committedDate": "2020-01-27T11:14:32Z", "message": "Implement optional and sensing connection factories\n\nSigned-off-by: Ludovic Orban <lorban@bitronix.be>"}, "afterCommit": {"oid": "37009e5f1250021fbfe10058c54dcacd47c0c340", "author": {"user": {"login": "lorban", "name": "Ludovic Orban"}}, "url": "https://github.com/eclipse/jetty.project/commit/37009e5f1250021fbfe10058c54dcacd47c0c340", "committedDate": "2020-01-27T12:15:57Z", "message": "Implement optional and sensing connection factories\n\nSigned-off-by: Ludovic Orban <lorban@bitronix.be>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "37009e5f1250021fbfe10058c54dcacd47c0c340", "author": {"user": {"login": "lorban", "name": "Ludovic Orban"}}, "url": "https://github.com/eclipse/jetty.project/commit/37009e5f1250021fbfe10058c54dcacd47c0c340", "committedDate": "2020-01-27T12:15:57Z", "message": "Implement optional and sensing connection factories\n\nSigned-off-by: Ludovic Orban <lorban@bitronix.be>"}, "afterCommit": {"oid": "8582d01f3bcf6cabd58b9773acb7b9685b5a092a", "author": {"user": {"login": "lorban", "name": "Ludovic Orban"}}, "url": "https://github.com/eclipse/jetty.project/commit/8582d01f3bcf6cabd58b9773acb7b9685b5a092a", "committedDate": "2020-01-27T12:19:39Z", "message": "Implement optional and sensing connection factories\n\nSigned-off-by: Ludovic Orban <lorban@bitronix.be>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "8582d01f3bcf6cabd58b9773acb7b9685b5a092a", "author": {"user": {"login": "lorban", "name": "Ludovic Orban"}}, "url": "https://github.com/eclipse/jetty.project/commit/8582d01f3bcf6cabd58b9773acb7b9685b5a092a", "committedDate": "2020-01-27T12:19:39Z", "message": "Implement optional and sensing connection factories\n\nSigned-off-by: Ludovic Orban <lorban@bitronix.be>"}, "afterCommit": {"oid": "0f3571591d917f43e8602533c69d20afb66478bb", "author": {"user": {"login": "lorban", "name": "Ludovic Orban"}}, "url": "https://github.com/eclipse/jetty.project/commit/0f3571591d917f43e8602533c69d20afb66478bb", "committedDate": "2020-01-27T12:21:10Z", "message": "Implement optional and sensing connection factories\n\nSigned-off-by: Ludovic Orban <lorban@bitronix.be>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "0f3571591d917f43e8602533c69d20afb66478bb", "author": {"user": {"login": "lorban", "name": "Ludovic Orban"}}, "url": "https://github.com/eclipse/jetty.project/commit/0f3571591d917f43e8602533c69d20afb66478bb", "committedDate": "2020-01-27T12:21:10Z", "message": "Implement optional and sensing connection factories\n\nSigned-off-by: Ludovic Orban <lorban@bitronix.be>"}, "afterCommit": {"oid": "7a4802e013b6393f39766bdd94bd182efe2a840e", "author": {"user": {"login": "lorban", "name": "Ludovic Orban"}}, "url": "https://github.com/eclipse/jetty.project/commit/7a4802e013b6393f39766bdd94bd182efe2a840e", "committedDate": "2020-01-27T12:30:43Z", "message": "Implement optional and sensing connection factories\n\nSigned-off-by: Ludovic Orban <lorban@bitronix.be>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "7a4802e013b6393f39766bdd94bd182efe2a840e", "author": {"user": {"login": "lorban", "name": "Ludovic Orban"}}, "url": "https://github.com/eclipse/jetty.project/commit/7a4802e013b6393f39766bdd94bd182efe2a840e", "committedDate": "2020-01-27T12:30:43Z", "message": "Implement optional and sensing connection factories\n\nSigned-off-by: Ludovic Orban <lorban@bitronix.be>"}, "afterCommit": {"oid": "25934950dc51eae678f2538937175bc888f436ae", "author": {"user": {"login": "lorban", "name": "Ludovic Orban"}}, "url": "https://github.com/eclipse/jetty.project/commit/25934950dc51eae678f2538937175bc888f436ae", "committedDate": "2020-01-27T12:33:30Z", "message": "Implement optional and sensing connection factories\n\nSigned-off-by: Ludovic Orban <lorban@bitronix.be>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "25934950dc51eae678f2538937175bc888f436ae", "author": {"user": {"login": "lorban", "name": "Ludovic Orban"}}, "url": "https://github.com/eclipse/jetty.project/commit/25934950dc51eae678f2538937175bc888f436ae", "committedDate": "2020-01-27T12:33:30Z", "message": "Implement optional and sensing connection factories\n\nSigned-off-by: Ludovic Orban <lorban@bitronix.be>"}, "afterCommit": {"oid": "309f3cc6d9ffab47137be45f4f11d8146aee3a5d", "author": {"user": {"login": "lorban", "name": "Ludovic Orban"}}, "url": "https://github.com/eclipse/jetty.project/commit/309f3cc6d9ffab47137be45f4f11d8146aee3a5d", "committedDate": "2020-01-27T12:54:47Z", "message": "Implement optional and sensing connection factories\n\nSigned-off-by: Ludovic Orban <lorban@bitronix.be>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "5e8ec796476833d54db7b9225bdf93fe3553a998", "author": {"user": {"login": "lorban", "name": "Ludovic Orban"}}, "url": "https://github.com/eclipse/jetty.project/commit/5e8ec796476833d54db7b9225bdf93fe3553a998", "committedDate": "2020-01-27T15:53:45Z", "message": "add proxy v1 and v2 tests + fix bugs in proxy v1\n\nSigned-off-by: Ludovic Orban <lorban@bitronix.be>"}, "afterCommit": {"oid": "0f158f7ca2fb44f3048c5e72677f13e212c507c0", "author": {"user": {"login": "lorban", "name": "Ludovic Orban"}}, "url": "https://github.com/eclipse/jetty.project/commit/0f158f7ca2fb44f3048c5e72677f13e212c507c0", "committedDate": "2020-01-27T16:08:11Z", "message": "Implement optional and sensing connection factories\n\nSigned-off-by: Ludovic Orban <lorban@bitronix.be>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "0f158f7ca2fb44f3048c5e72677f13e212c507c0", "author": {"user": {"login": "lorban", "name": "Ludovic Orban"}}, "url": "https://github.com/eclipse/jetty.project/commit/0f158f7ca2fb44f3048c5e72677f13e212c507c0", "committedDate": "2020-01-27T16:08:11Z", "message": "Implement optional and sensing connection factories\n\nSigned-off-by: Ludovic Orban <lorban@bitronix.be>"}, "afterCommit": {"oid": "268c42a0656a0110777d870ad7715d4b68c2a343", "author": {"user": {"login": "lorban", "name": "Ludovic Orban"}}, "url": "https://github.com/eclipse/jetty.project/commit/268c42a0656a0110777d870ad7715d4b68c2a343", "committedDate": "2020-01-27T16:36:03Z", "message": "Implement optional and sensing connection factories\n\nSigned-off-by: Ludovic Orban <lorban@bitronix.be>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ5MTg4NTgz", "url": "https://github.com/eclipse/jetty.project/pull/4519#pullrequestreview-349188583", "createdAt": "2020-01-28T08:15:28Z", "commit": {"oid": "268c42a0656a0110777d870ad7715d4b68c2a343"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 9, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yOFQwODoxNToyOVrOFicHlw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yOFQwODozNDo0NFrOFicjmA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTY1NjU5OQ==", "bodyText": "Breaking change, can you revert?", "url": "https://github.com/eclipse/jetty.project/pull/4519#discussion_r371656599", "createdAt": "2020-01-28T08:15:29Z", "author": {"login": "sbordet"}, "path": "jetty-client/src/test/java/org/eclipse/jetty/client/HttpClientProxyProtocolTest.java", "diffHunk": "@@ -173,8 +174,8 @@ public void testClientProxyProtocolV2WithVectors() throws Exception\n             protected void service(String target, Request jettyRequest, HttpServletRequest request, HttpServletResponse response) throws IOException\n             {\n                 EndPoint endPoint = jettyRequest.getHttpChannel().getEndPoint();\n-                assertTrue(endPoint instanceof ProxyConnectionFactory.ProxyEndPoint);\n-                ProxyConnectionFactory.ProxyEndPoint proxyEndPoint = (ProxyConnectionFactory.ProxyEndPoint)endPoint;\n+                assertTrue(endPoint instanceof ProxyEndPoint);\n+                ProxyEndPoint proxyEndPoint = (ProxyEndPoint)endPoint;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "268c42a0656a0110777d870ad7715d4b68c2a343"}, "originalPosition": 15}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTY1NzA1Ng==", "bodyText": "I was thinking DetectorConnectionFactory as a better name?", "url": "https://github.com/eclipse/jetty.project/pull/4519#discussion_r371657056", "createdAt": "2020-01-28T08:16:40Z", "author": {"login": "sbordet"}, "path": "jetty-server/src/main/java/org/eclipse/jetty/server/OptionalConnectionFactory.java", "diffHunk": "@@ -0,0 +1,225 @@\n+//\n+//  ========================================================================\n+//  Copyright (c) 1995-2020 Mort Bay Consulting Pty Ltd and others.\n+//  ------------------------------------------------------------------------\n+//  All rights reserved. This program and the accompanying materials\n+//  are made available under the terms of the Eclipse Public License v1.0\n+//  and Apache License v2.0 which accompanies this distribution.\n+//\n+//      The Eclipse Public License is available at\n+//      http://www.eclipse.org/legal/epl-v10.html\n+//\n+//      The Apache License v2.0 is available at\n+//      http://www.opensource.org/licenses/apache2.0.php\n+//\n+//  You may elect to redistribute this code under either of these licenses.\n+//  ========================================================================\n+//\n+\n+package org.eclipse.jetty.server;\n+\n+import java.nio.ByteBuffer;\n+import java.util.Arrays;\n+import java.util.List;\n+\n+import org.eclipse.jetty.io.AbstractConnection;\n+import org.eclipse.jetty.io.Connection;\n+import org.eclipse.jetty.io.EndPoint;\n+import org.eclipse.jetty.server.SensingConnectionFactory.SensingOutcome;\n+import org.eclipse.jetty.util.BufferUtil;\n+import org.eclipse.jetty.util.component.LifeCycle;\n+import org.eclipse.jetty.util.log.Log;\n+import org.eclipse.jetty.util.log.Logger;\n+\n+/**\n+ * A {@link ConnectionFactory} combining multiple {@link SensingConnectionFactory} instances that will upgrade to\n+ * the first one recognizing the bytes in the buffer.\n+ */\n+public class OptionalConnectionFactory extends AbstractConnectionFactory", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "268c42a0656a0110777d870ad7715d4b68c2a343"}, "originalPosition": 38}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTY1Nzc5Nw==", "bodyText": "Since AbstractConnectionFactory is-a ContainerLifeCycle, you don't want to manage the lifecycle directly in the way above.\nYou just add the children as beans in the constructor, and ContainerLifeCycle will take care of starting and stopping them.", "url": "https://github.com/eclipse/jetty.project/pull/4519#discussion_r371657797", "createdAt": "2020-01-28T08:18:48Z", "author": {"login": "sbordet"}, "path": "jetty-server/src/main/java/org/eclipse/jetty/server/OptionalConnectionFactory.java", "diffHunk": "@@ -0,0 +1,225 @@\n+//\n+//  ========================================================================\n+//  Copyright (c) 1995-2020 Mort Bay Consulting Pty Ltd and others.\n+//  ------------------------------------------------------------------------\n+//  All rights reserved. This program and the accompanying materials\n+//  are made available under the terms of the Eclipse Public License v1.0\n+//  and Apache License v2.0 which accompanies this distribution.\n+//\n+//      The Eclipse Public License is available at\n+//      http://www.eclipse.org/legal/epl-v10.html\n+//\n+//      The Apache License v2.0 is available at\n+//      http://www.opensource.org/licenses/apache2.0.php\n+//\n+//  You may elect to redistribute this code under either of these licenses.\n+//  ========================================================================\n+//\n+\n+package org.eclipse.jetty.server;\n+\n+import java.nio.ByteBuffer;\n+import java.util.Arrays;\n+import java.util.List;\n+\n+import org.eclipse.jetty.io.AbstractConnection;\n+import org.eclipse.jetty.io.Connection;\n+import org.eclipse.jetty.io.EndPoint;\n+import org.eclipse.jetty.server.SensingConnectionFactory.SensingOutcome;\n+import org.eclipse.jetty.util.BufferUtil;\n+import org.eclipse.jetty.util.component.LifeCycle;\n+import org.eclipse.jetty.util.log.Log;\n+import org.eclipse.jetty.util.log.Logger;\n+\n+/**\n+ * A {@link ConnectionFactory} combining multiple {@link SensingConnectionFactory} instances that will upgrade to\n+ * the first one recognizing the bytes in the buffer.\n+ */\n+public class OptionalConnectionFactory extends AbstractConnectionFactory\n+{\n+    private static final Logger LOG = Log.getLogger(OptionalConnectionFactory.class);\n+\n+    private final String _nextProtocol;\n+    private final List<SensingConnectionFactory> _sensingConnectionFactories;\n+\n+    public OptionalConnectionFactory(SensingConnectionFactory... sensingConnectionFactories)\n+    {\n+        this(null, sensingConnectionFactories);\n+    }\n+\n+    public OptionalConnectionFactory(String nextProtocol, SensingConnectionFactory... sensingConnectionFactories)\n+    {\n+        super(toProtocolString(sensingConnectionFactories));\n+        _nextProtocol = nextProtocol;\n+        _sensingConnectionFactories = Arrays.asList(sensingConnectionFactories);\n+    }\n+\n+    static String toProtocolString(SensingConnectionFactory... sensingConnectionFactories)\n+    {\n+        StringBuilder sb = new StringBuilder();\n+        for (SensingConnectionFactory ccf : sensingConnectionFactories)\n+        {\n+            String protocol = ccf.getProtocol();\n+            sb.append(protocol).append('|');\n+        }\n+        sb.deleteCharAt(sb.length() - 1);\n+        return sb.toString();\n+    }\n+\n+    @Override\n+    protected void doStart() throws Exception\n+    {\n+        super.doStart();\n+\n+        for (SensingConnectionFactory connectionFactory : _sensingConnectionFactories)\n+        {\n+            if (connectionFactory instanceof LifeCycle)\n+                ((LifeCycle)connectionFactory).start();\n+        }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "268c42a0656a0110777d870ad7715d4b68c2a343"}, "originalPosition": 78}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTY1Nzg3MQ==", "bodyText": "Ditto above.", "url": "https://github.com/eclipse/jetty.project/pull/4519#discussion_r371657871", "createdAt": "2020-01-28T08:18:59Z", "author": {"login": "sbordet"}, "path": "jetty-server/src/main/java/org/eclipse/jetty/server/OptionalConnectionFactory.java", "diffHunk": "@@ -0,0 +1,225 @@\n+//\n+//  ========================================================================\n+//  Copyright (c) 1995-2020 Mort Bay Consulting Pty Ltd and others.\n+//  ------------------------------------------------------------------------\n+//  All rights reserved. This program and the accompanying materials\n+//  are made available under the terms of the Eclipse Public License v1.0\n+//  and Apache License v2.0 which accompanies this distribution.\n+//\n+//      The Eclipse Public License is available at\n+//      http://www.eclipse.org/legal/epl-v10.html\n+//\n+//      The Apache License v2.0 is available at\n+//      http://www.opensource.org/licenses/apache2.0.php\n+//\n+//  You may elect to redistribute this code under either of these licenses.\n+//  ========================================================================\n+//\n+\n+package org.eclipse.jetty.server;\n+\n+import java.nio.ByteBuffer;\n+import java.util.Arrays;\n+import java.util.List;\n+\n+import org.eclipse.jetty.io.AbstractConnection;\n+import org.eclipse.jetty.io.Connection;\n+import org.eclipse.jetty.io.EndPoint;\n+import org.eclipse.jetty.server.SensingConnectionFactory.SensingOutcome;\n+import org.eclipse.jetty.util.BufferUtil;\n+import org.eclipse.jetty.util.component.LifeCycle;\n+import org.eclipse.jetty.util.log.Log;\n+import org.eclipse.jetty.util.log.Logger;\n+\n+/**\n+ * A {@link ConnectionFactory} combining multiple {@link SensingConnectionFactory} instances that will upgrade to\n+ * the first one recognizing the bytes in the buffer.\n+ */\n+public class OptionalConnectionFactory extends AbstractConnectionFactory\n+{\n+    private static final Logger LOG = Log.getLogger(OptionalConnectionFactory.class);\n+\n+    private final String _nextProtocol;\n+    private final List<SensingConnectionFactory> _sensingConnectionFactories;\n+\n+    public OptionalConnectionFactory(SensingConnectionFactory... sensingConnectionFactories)\n+    {\n+        this(null, sensingConnectionFactories);\n+    }\n+\n+    public OptionalConnectionFactory(String nextProtocol, SensingConnectionFactory... sensingConnectionFactories)\n+    {\n+        super(toProtocolString(sensingConnectionFactories));\n+        _nextProtocol = nextProtocol;\n+        _sensingConnectionFactories = Arrays.asList(sensingConnectionFactories);\n+    }\n+\n+    static String toProtocolString(SensingConnectionFactory... sensingConnectionFactories)\n+    {\n+        StringBuilder sb = new StringBuilder();\n+        for (SensingConnectionFactory ccf : sensingConnectionFactories)\n+        {\n+            String protocol = ccf.getProtocol();\n+            sb.append(protocol).append('|');\n+        }\n+        sb.deleteCharAt(sb.length() - 1);\n+        return sb.toString();\n+    }\n+\n+    @Override\n+    protected void doStart() throws Exception\n+    {\n+        super.doStart();\n+\n+        for (SensingConnectionFactory connectionFactory : _sensingConnectionFactories)\n+        {\n+            if (connectionFactory instanceof LifeCycle)\n+                ((LifeCycle)connectionFactory).start();\n+        }\n+    }\n+\n+    @Override\n+    protected void doStop() throws Exception\n+    {\n+        super.doStop();\n+\n+        for (SensingConnectionFactory connectionFactory : _sensingConnectionFactories)\n+        {\n+            if (connectionFactory instanceof LifeCycle)\n+                ((LifeCycle)connectionFactory).stop();\n+        }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "268c42a0656a0110777d870ad7715d4b68c2a343"}, "originalPosition": 90}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTY2MDI2Nw==", "bodyText": "Use inputBufferSize from AbstractConnectionFactory. Directness could be hardcoded (to true).", "url": "https://github.com/eclipse/jetty.project/pull/4519#discussion_r371660267", "createdAt": "2020-01-28T08:25:04Z", "author": {"login": "sbordet"}, "path": "jetty-server/src/main/java/org/eclipse/jetty/server/OptionalConnectionFactory.java", "diffHunk": "@@ -0,0 +1,225 @@\n+//\n+//  ========================================================================\n+//  Copyright (c) 1995-2020 Mort Bay Consulting Pty Ltd and others.\n+//  ------------------------------------------------------------------------\n+//  All rights reserved. This program and the accompanying materials\n+//  are made available under the terms of the Eclipse Public License v1.0\n+//  and Apache License v2.0 which accompanies this distribution.\n+//\n+//      The Eclipse Public License is available at\n+//      http://www.eclipse.org/legal/epl-v10.html\n+//\n+//      The Apache License v2.0 is available at\n+//      http://www.opensource.org/licenses/apache2.0.php\n+//\n+//  You may elect to redistribute this code under either of these licenses.\n+//  ========================================================================\n+//\n+\n+package org.eclipse.jetty.server;\n+\n+import java.nio.ByteBuffer;\n+import java.util.Arrays;\n+import java.util.List;\n+\n+import org.eclipse.jetty.io.AbstractConnection;\n+import org.eclipse.jetty.io.Connection;\n+import org.eclipse.jetty.io.EndPoint;\n+import org.eclipse.jetty.server.SensingConnectionFactory.SensingOutcome;\n+import org.eclipse.jetty.util.BufferUtil;\n+import org.eclipse.jetty.util.component.LifeCycle;\n+import org.eclipse.jetty.util.log.Log;\n+import org.eclipse.jetty.util.log.Logger;\n+\n+/**\n+ * A {@link ConnectionFactory} combining multiple {@link SensingConnectionFactory} instances that will upgrade to\n+ * the first one recognizing the bytes in the buffer.\n+ */\n+public class OptionalConnectionFactory extends AbstractConnectionFactory\n+{\n+    private static final Logger LOG = Log.getLogger(OptionalConnectionFactory.class);\n+\n+    private final String _nextProtocol;\n+    private final List<SensingConnectionFactory> _sensingConnectionFactories;\n+\n+    public OptionalConnectionFactory(SensingConnectionFactory... sensingConnectionFactories)\n+    {\n+        this(null, sensingConnectionFactories);\n+    }\n+\n+    public OptionalConnectionFactory(String nextProtocol, SensingConnectionFactory... sensingConnectionFactories)\n+    {\n+        super(toProtocolString(sensingConnectionFactories));\n+        _nextProtocol = nextProtocol;\n+        _sensingConnectionFactories = Arrays.asList(sensingConnectionFactories);\n+    }\n+\n+    static String toProtocolString(SensingConnectionFactory... sensingConnectionFactories)\n+    {\n+        StringBuilder sb = new StringBuilder();\n+        for (SensingConnectionFactory ccf : sensingConnectionFactories)\n+        {\n+            String protocol = ccf.getProtocol();\n+            sb.append(protocol).append('|');\n+        }\n+        sb.deleteCharAt(sb.length() - 1);\n+        return sb.toString();\n+    }\n+\n+    @Override\n+    protected void doStart() throws Exception\n+    {\n+        super.doStart();\n+\n+        for (SensingConnectionFactory connectionFactory : _sensingConnectionFactories)\n+        {\n+            if (connectionFactory instanceof LifeCycle)\n+                ((LifeCycle)connectionFactory).start();\n+        }\n+    }\n+\n+    @Override\n+    protected void doStop() throws Exception\n+    {\n+        super.doStop();\n+\n+        for (SensingConnectionFactory connectionFactory : _sensingConnectionFactories)\n+        {\n+            if (connectionFactory instanceof LifeCycle)\n+                ((LifeCycle)connectionFactory).stop();\n+        }\n+    }\n+\n+    @Override\n+    public Connection newConnection(Connector connector, EndPoint endPoint)\n+    {\n+        ConnectionFactory nextRecognizedConnectionFactory = getRecognizedConnectionFactory(connector, endPoint);\n+        ConnectionFactory nextNotRecognizedConnectionFactory = getNotRecognizedConnectionFactory(connector, endPoint);\n+        LOG.debug(\"Upgrade topology: from {} to {} on recognition, {} on non-recognition\", getProtocol(), nextRecognizedConnectionFactory.getProtocol(), nextNotRecognizedConnectionFactory.getProtocol());\n+        return configure(new OptionalConnection(endPoint, connector, _sensingConnectionFactories, nextRecognizedConnectionFactory, nextNotRecognizedConnectionFactory), connector, endPoint);\n+    }\n+\n+    protected ConnectionFactory getRecognizedConnectionFactory(Connector connector, EndPoint endPoint)\n+    {\n+        String nextProtocol = _nextProtocol;\n+        if (nextProtocol == null)\n+            nextProtocol = SensingConnectionFactory.findNextProtocol(connector, getProtocol());\n+        if (nextProtocol == null)\n+            throw new IllegalStateException(\"No next protocol for \" + endPoint);\n+        return connector.getConnectionFactory(nextProtocol);\n+    }\n+\n+    protected ConnectionFactory getNotRecognizedConnectionFactory(Connector connector, EndPoint endPoint)\n+    {\n+        return getRecognizedConnectionFactory(connector, endPoint);\n+    }\n+\n+    static class OptionalConnection extends AbstractConnection implements Connection.UpgradeFrom\n+    {\n+        private final Connector _connector;\n+        private final List<SensingConnectionFactory> _sensingConnectionFactories;\n+        private final ConnectionFactory _nextRecognizedConnectionFactory;\n+        private final ConnectionFactory _nextNotRecognizedConnectionFactory;\n+        private final ByteBuffer _buffer;\n+\n+        protected OptionalConnection(EndPoint endp, Connector connector, List<SensingConnectionFactory> sensingConnectionFactories, ConnectionFactory nextRecognizedConnectionFactory, ConnectionFactory nextNotRecognizedConnectionFactory)\n+        {\n+            super(endp, connector.getExecutor());\n+            _connector = connector;\n+            _sensingConnectionFactories = sensingConnectionFactories;\n+            _nextRecognizedConnectionFactory = nextRecognizedConnectionFactory;\n+            _nextNotRecognizedConnectionFactory = nextNotRecognizedConnectionFactory;\n+            _buffer = connector.getByteBufferPool().acquire(1024, true); // TODO make the buffer size & directility configurable", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "268c42a0656a0110777d870ad7715d4b68c2a343"}, "originalPosition": 132}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTY2MTk0Mg==", "bodyText": "Perhaps this interface can be embedded as ConnectionFactory.Detecting?", "url": "https://github.com/eclipse/jetty.project/pull/4519#discussion_r371661942", "createdAt": "2020-01-28T08:29:42Z", "author": {"login": "sbordet"}, "path": "jetty-server/src/main/java/org/eclipse/jetty/server/SensingConnectionFactory.java", "diffHunk": "@@ -0,0 +1,55 @@\n+//\n+//  ========================================================================\n+//  Copyright (c) 1995-2020 Mort Bay Consulting Pty Ltd and others.\n+//  ------------------------------------------------------------------------\n+//  All rights reserved. This program and the accompanying materials\n+//  are made available under the terms of the Eclipse Public License v1.0\n+//  and Apache License v2.0 which accompanies this distribution.\n+//\n+//      The Eclipse Public License is available at\n+//      http://www.eclipse.org/legal/epl-v10.html\n+//\n+//      The Apache License v2.0 is available at\n+//      http://www.opensource.org/licenses/apache2.0.php\n+//\n+//  You may elect to redistribute this code under either of these licenses.\n+//  ========================================================================\n+//\n+\n+package org.eclipse.jetty.server;\n+\n+import java.nio.ByteBuffer;\n+import java.util.Iterator;\n+\n+import org.eclipse.jetty.io.Connection;\n+import org.eclipse.jetty.io.EndPoint;\n+\n+public interface SensingConnectionFactory extends ConnectionFactory", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "268c42a0656a0110777d870ad7715d4b68c2a343"}, "originalPosition": 27}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTY2MjEwMA==", "bodyText": "Remove this method, just keep the one from ConnectionFactory.", "url": "https://github.com/eclipse/jetty.project/pull/4519#discussion_r371662100", "createdAt": "2020-01-28T08:30:06Z", "author": {"login": "sbordet"}, "path": "jetty-server/src/main/java/org/eclipse/jetty/server/SensingConnectionFactory.java", "diffHunk": "@@ -0,0 +1,55 @@\n+//\n+//  ========================================================================\n+//  Copyright (c) 1995-2020 Mort Bay Consulting Pty Ltd and others.\n+//  ------------------------------------------------------------------------\n+//  All rights reserved. This program and the accompanying materials\n+//  are made available under the terms of the Eclipse Public License v1.0\n+//  and Apache License v2.0 which accompanies this distribution.\n+//\n+//      The Eclipse Public License is available at\n+//      http://www.eclipse.org/legal/epl-v10.html\n+//\n+//      The Apache License v2.0 is available at\n+//      http://www.opensource.org/licenses/apache2.0.php\n+//\n+//  You may elect to redistribute this code under either of these licenses.\n+//  ========================================================================\n+//\n+\n+package org.eclipse.jetty.server;\n+\n+import java.nio.ByteBuffer;\n+import java.util.Iterator;\n+\n+import org.eclipse.jetty.io.Connection;\n+import org.eclipse.jetty.io.EndPoint;\n+\n+public interface SensingConnectionFactory extends ConnectionFactory\n+{\n+    enum SensingOutcome\n+    {\n+        RECOGNIZED,\n+        NOT_RECOGNIZED,\n+        NEED_MORE_BYTES\n+    }\n+\n+    SensingOutcome sense(ByteBuffer buffer);\n+\n+    Connection newConnection(Connector connector, EndPoint endPoint, ConnectionFactory next);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "268c42a0656a0110777d870ad7715d4b68c2a343"}, "originalPosition": 38}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTY2MjIyNA==", "bodyText": "Do we really need this?", "url": "https://github.com/eclipse/jetty.project/pull/4519#discussion_r371662224", "createdAt": "2020-01-28T08:30:27Z", "author": {"login": "sbordet"}, "path": "jetty-server/src/main/java/org/eclipse/jetty/server/TerminatingConnectionFactory.java", "diffHunk": "@@ -0,0 +1,96 @@\n+//\n+//  ========================================================================\n+//  Copyright (c) 1995-2020 Mort Bay Consulting Pty Ltd and others.\n+//  ------------------------------------------------------------------------\n+//  All rights reserved. This program and the accompanying materials\n+//  are made available under the terms of the Eclipse Public License v1.0\n+//  and Apache License v2.0 which accompanies this distribution.\n+//\n+//      The Eclipse Public License is available at\n+//      http://www.eclipse.org/legal/epl-v10.html\n+//\n+//      The Apache License v2.0 is available at\n+//      http://www.opensource.org/licenses/apache2.0.php\n+//\n+//  You may elect to redistribute this code under either of these licenses.\n+//  ========================================================================\n+//\n+\n+package org.eclipse.jetty.server;\n+\n+import java.nio.ByteBuffer;\n+\n+import org.eclipse.jetty.io.AbstractConnection;\n+import org.eclipse.jetty.io.ByteBufferPool;\n+import org.eclipse.jetty.io.Connection;\n+import org.eclipse.jetty.io.EndPoint;\n+\n+/**\n+ * A connection factory that always closes the connection.\n+ */\n+public class TerminatingConnectionFactory extends AbstractConnectionFactory", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "268c42a0656a0110777d870ad7715d4b68c2a343"}, "originalPosition": 31}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTY2Mzc2OA==", "bodyText": "No helpers for tests, if possible.\nThe tests become hard to read because you have to jump to other source files, and they may introduce bugs, and we don't want to write a test framework - tests should be as simple as possible.", "url": "https://github.com/eclipse/jetty.project/pull/4519#discussion_r371663768", "createdAt": "2020-01-28T08:34:44Z", "author": {"login": "sbordet"}, "path": "jetty-server/src/test/java/org/eclipse/jetty/server/ProxyTestingHelper.java", "diffHunk": "@@ -0,0 +1,140 @@\n+//\n+//  ========================================================================\n+//  Copyright (c) 1995-2020 Mort Bay Consulting Pty Ltd and others.\n+//  ------------------------------------------------------------------------\n+//  All rights reserved. This program and the accompanying materials\n+//  are made available under the terms of the Eclipse Public License v1.0\n+//  and Apache License v2.0 which accompanies this distribution.\n+//\n+//      The Eclipse Public License is available at\n+//      http://www.eclipse.org/legal/epl-v10.html\n+//\n+//      The Apache License v2.0 is available at\n+//      http://www.opensource.org/licenses/apache2.0.php\n+//\n+//  You may elect to redistribute this code under either of these licenses.\n+//  ========================================================================\n+//\n+\n+package org.eclipse.jetty.server;\n+\n+import java.nio.ByteBuffer;\n+import java.nio.charset.StandardCharsets;\n+import java.util.function.Consumer;\n+import java.util.stream.Stream;\n+\n+import org.eclipse.jetty.server.handler.ErrorHandler;\n+import org.junit.jupiter.params.provider.Arguments;\n+\n+public class ProxyTestingHelper", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "268c42a0656a0110777d870ad7715d4b68c2a343"}, "originalPosition": 29}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "d48a6d77e6314b3c7e7238ea0d7e3552ce58092f", "author": {"user": {"login": "lorban", "name": "Ludovic Orban"}}, "url": "https://github.com/eclipse/jetty.project/commit/d48a6d77e6314b3c7e7238ea0d7e3552ce58092f", "committedDate": "2020-01-28T16:02:19Z", "message": "add todo\n\nSigned-off-by: Ludovic Orban <lorban@bitronix.be>"}, "afterCommit": {"oid": "f1971ff8324fea9ef10be9ad5da070ca08ade5c4", "author": {"user": {"login": "lorban", "name": "Ludovic Orban"}}, "url": "https://github.com/eclipse/jetty.project/commit/f1971ff8324fea9ef10be9ad5da070ca08ade5c4", "committedDate": "2020-01-28T16:04:41Z", "message": "add todo\n\nSigned-off-by: Ludovic Orban <lorban@bitronix.be>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "f1971ff8324fea9ef10be9ad5da070ca08ade5c4", "author": {"user": {"login": "lorban", "name": "Ludovic Orban"}}, "url": "https://github.com/eclipse/jetty.project/commit/f1971ff8324fea9ef10be9ad5da070ca08ade5c4", "committedDate": "2020-01-28T16:04:41Z", "message": "add todo\n\nSigned-off-by: Ludovic Orban <lorban@bitronix.be>"}, "afterCommit": {"oid": "420620749673d54917e9850c24ab86cfae133851", "author": {"user": {"login": "lorban", "name": "Ludovic Orban"}}, "url": "https://github.com/eclipse/jetty.project/commit/420620749673d54917e9850c24ab86cfae133851", "committedDate": "2020-01-28T16:08:07Z", "message": "add todo\n\nSigned-off-by: Ludovic Orban <lorban@bitronix.be>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ5NTUyNzU1", "url": "https://github.com/eclipse/jetty.project/pull/4519#pullrequestreview-349552755", "createdAt": "2020-01-28T17:12:04Z", "commit": {"oid": "420620749673d54917e9850c24ab86cfae133851"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yOFQxNzoxMjowNFrOFitYxQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yOFQxNzoxMjowNFrOFitYxQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTkzOTUyNQ==", "bodyText": "Why have this Proxy-or-TLS factory?\nIsn't the idea of composable factories to have a ProxyFactory and a TlsFactory and one or the other will recognise the bytes.", "url": "https://github.com/eclipse/jetty.project/pull/4519#discussion_r371939525", "createdAt": "2020-01-28T17:12:04Z", "author": {"login": "gregw"}, "path": "jetty-server/src/main/java/org/eclipse/jetty/server/OptionalProxySslConnectionFactory.java", "diffHunk": "@@ -0,0 +1,112 @@\n+//\n+//  ========================================================================\n+//  Copyright (c) 1995-2020 Mort Bay Consulting Pty Ltd and others.\n+//  ------------------------------------------------------------------------\n+//  All rights reserved. This program and the accompanying materials\n+//  are made available under the terms of the Eclipse Public License v1.0\n+//  and Apache License v2.0 which accompanies this distribution.\n+//\n+//      The Eclipse Public License is available at\n+//      http://www.eclipse.org/legal/epl-v10.html\n+//\n+//      The Apache License v2.0 is available at\n+//      http://www.opensource.org/licenses/apache2.0.php\n+//\n+//  You may elect to redistribute this code under either of these licenses.\n+//  ========================================================================\n+//\n+\n+package org.eclipse.jetty.server;\n+\n+import java.nio.ByteBuffer;\n+import java.nio.charset.StandardCharsets;\n+\n+import org.eclipse.jetty.io.EndPoint;\n+import org.eclipse.jetty.util.Callback;\n+import org.eclipse.jetty.util.log.Log;\n+import org.eclipse.jetty.util.log.Logger;\n+import org.eclipse.jetty.util.ssl.SslContextFactory;\n+\n+/**\n+ * <p>A ConnectionFactory whose connections detect whether the first bytes are\n+ * proxy or TLS bytes and upgrades to either a TLS connection or to another configurable\n+ * connection.</p>\n+ */\n+public class OptionalProxySslConnectionFactory extends DetectorConnectionFactory", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "420620749673d54917e9850c24ab86cfae133851"}, "originalPosition": 35}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ5OTg3MzE2", "url": "https://github.com/eclipse/jetty.project/pull/4519#pullrequestreview-349987316", "createdAt": "2020-01-29T10:04:21Z", "commit": {"oid": "fc1fabddfdd2342389b3c6b9c0519f5fe94c9ad6"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yOVQxMDowNDoyMVrOFjCxWA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yOVQxMDowNDoyN1rOFjCxhA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjI4OTg4MA==", "bodyText": "I find it a little surprising that we still need OptionalSslConnectionFactory and ProxyConnectionFactory as concrete instances of DetectorConnectionFactory.  If they are needed for backwards compatibility then they should be deprecated.\nI was expecting to see DetectorConnectionFactory directly used, potentially as part of initialising an AbstractConnector that is given some Detecting factories with no way to select between them.\nIs it true that the following are all valid options:\n\nSSL or ProxyV1 or ProxyV2\n(ProxyV1 or ProxyV2) then SSL\n(ProxyV1 or ProxyV2) then optional SSL\nSSL then (ProxyV1 or ProxyV2)\noptional SSL then (ProxyV1 or ProxyV2)", "url": "https://github.com/eclipse/jetty.project/pull/4519#discussion_r372289880", "createdAt": "2020-01-29T10:04:21Z", "author": {"login": "gregw"}, "path": "jetty-server/src/main/java/org/eclipse/jetty/server/OptionalSslConnectionFactory.java", "diffHunk": "@@ -35,191 +31,76 @@\n  * TLS bytes and upgrades to either a TLS connection or to another configurable\n  * connection.</p>\n  */\n-public class OptionalSslConnectionFactory extends AbstractConnectionFactory\n+public class OptionalSslConnectionFactory extends DetectorConnectionFactory", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fc1fabddfdd2342389b3c6b9c0519f5fe94c9ad6"}, "originalPosition": 20}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjI4OTkyNA==", "bodyText": "Could this behaviour be moved out of this factory into a BadHttpRequestConnectionFactory, so tht the normal detecting logic would choose between an SSL factory and a factory that responds to GE with a 400?", "url": "https://github.com/eclipse/jetty.project/pull/4519#discussion_r372289924", "createdAt": "2020-01-29T10:04:27Z", "author": {"login": "gregw"}, "path": "jetty-server/src/main/java/org/eclipse/jetty/server/OptionalSslConnectionFactory.java", "diffHunk": "@@ -35,191 +31,76 @@\n  * TLS bytes and upgrades to either a TLS connection or to another configurable\n  * connection.</p>\n  */\n-public class OptionalSslConnectionFactory extends AbstractConnectionFactory\n+public class OptionalSslConnectionFactory extends DetectorConnectionFactory\n {\n-    private static final Logger LOG = Log.getLogger(OptionalSslConnection.class);\n-    private static final int TLS_ALERT_FRAME_TYPE = 0x15;\n-    private static final int TLS_HANDSHAKE_FRAME_TYPE = 0x16;\n-    private static final int TLS_MAJOR_VERSION = 3;\n+    private static final Logger LOG = Log.getLogger(OptionalSslConnectionFactory.class);\n \n-    private final SslConnectionFactory sslConnectionFactory;\n-    private final String otherProtocol;\n+    private final boolean _terminateWhenNotRecognized;\n \n     /**\n      * <p>Creates a new ConnectionFactory whose connections can upgrade to TLS or another protocol.</p>\n-     * <p>If {@code otherProtocol} is {@code null}, and the first bytes are not TLS, then\n-     * {@link #otherProtocol(ByteBuffer, EndPoint)} is called.</p>\n      *\n      * @param sslConnectionFactory The SslConnectionFactory to use if the first bytes are TLS\n-     * @param otherProtocol the protocol of the ConnectionFactory to use if the first bytes are not TLS,\n+     * @param nextProtocol the protocol of the ConnectionFactory to use if the first bytes are not TLS,\n      * or null to explicitly handle the non-TLS case\n      */\n-    public OptionalSslConnectionFactory(SslConnectionFactory sslConnectionFactory, String otherProtocol)\n+    public OptionalSslConnectionFactory(SslConnectionFactory sslConnectionFactory, String nextProtocol)\n     {\n-        super(\"ssl|other\");\n-        this.sslConnectionFactory = sslConnectionFactory;\n-        this.otherProtocol = otherProtocol;\n-    }\n-\n-    @Override\n-    public Connection newConnection(Connector connector, EndPoint endPoint)\n-    {\n-        return configure(new OptionalSslConnection(endPoint, connector), connector, endPoint);\n-    }\n-\n-    /**\n-     * @param buffer The buffer with the first bytes of the connection\n-     * @return whether the bytes seem TLS bytes\n-     */\n-    protected boolean seemsTLS(ByteBuffer buffer)\n-    {\n-        int tlsFrameType = buffer.get(0) & 0xFF;\n-        int tlsMajorVersion = buffer.get(1) & 0xFF;\n-        return (tlsFrameType == TLS_HANDSHAKE_FRAME_TYPE || tlsFrameType == TLS_ALERT_FRAME_TYPE) && tlsMajorVersion == TLS_MAJOR_VERSION;\n+        super(nextProtocol, sslConnectionFactory);\n+        _terminateWhenNotRecognized = nextProtocol == null;\n     }\n \n     /**\n-     * <p>Callback method invoked when {@code otherProtocol} is {@code null}\n-     * and the first bytes are not TLS.</p>\n+     * <p>Callback method invoked when the detected bytes are not TLS.</p>\n      * <p>This typically happens when a client is trying to connect to a TLS\n      * port using the {@code http} scheme (and not the {@code https} scheme).</p>\n      *\n      * @param buffer The buffer with the first bytes of the connection\n      * @param endPoint The connection EndPoint object\n-     * @see #seemsTLS(ByteBuffer)\n+     * @param connector The connector object\n      */\n-    protected void otherProtocol(ByteBuffer buffer, EndPoint endPoint)\n+    protected void nextProtocol(ByteBuffer buffer, EndPoint endPoint, Connector connector)\n     {\n-        // There are always at least 2 bytes.\n-        int byte1 = buffer.get(0) & 0xFF;\n-        int byte2 = buffer.get(1) & 0xFF;\n-        if (byte1 == 'G' && byte2 == 'E')\n+        if (!_terminateWhenNotRecognized)\n         {\n-            // Plain text HTTP to an HTTPS port,\n-            // write a minimal response.\n-            String body =\n-                \"<!DOCTYPE html>\\r\\n\" +\n-                    \"<html>\\r\\n\" +\n-                    \"<head><title>Bad Request</title></head>\\r\\n\" +\n-                    \"<body>\" +\n-                    \"<h1>Bad Request</h1>\" +\n-                    \"<p>HTTP request to HTTPS port</p>\" +\n-                    \"</body>\\r\\n\" +\n-                    \"</html>\";\n-            String response =\n-                \"HTTP/1.1 400 Bad Request\\r\\n\" +\n-                    \"Content-Type: text/html\\r\\n\" +\n-                    \"Content-Length: \" + body.length() + \"\\r\\n\" +\n-                    \"Connection: close\\r\\n\" +\n-                    \"\\r\\n\" +\n-                    body;\n-            Callback.Completable completable = new Callback.Completable();\n-            endPoint.write(completable, ByteBuffer.wrap(response.getBytes(StandardCharsets.US_ASCII)));\n-            completable.whenComplete((r, x) -> endPoint.close());\n+            // upgrade to the next protocol\n+            super.nextProtocol(buffer, endPoint, connector);\n         }\n         else\n         {\n-            endPoint.close();\n-        }\n-    }\n-\n-    private class OptionalSslConnection extends AbstractConnection implements Connection.UpgradeFrom\n-    {\n-        private final Connector connector;\n-        private final ByteBuffer buffer;\n-\n-        public OptionalSslConnection(EndPoint endPoint, Connector connector)\n-        {\n-            super(endPoint, connector.getExecutor());\n-            this.connector = connector;\n-            this.buffer = BufferUtil.allocateDirect(1536);\n-        }\n-\n-        @Override\n-        public void onOpen()\n-        {\n-            super.onOpen();\n-            fillInterested();\n-        }\n-\n-        @Override\n-        public void onFillable()\n-        {\n-            try\n-            {\n-                while (true)\n-                {\n-                    int filled = getEndPoint().fill(buffer);\n-                    if (filled > 0)\n-                    {\n-                        // Always have at least 2 bytes.\n-                        if (BufferUtil.length(buffer) >= 2)\n-                        {\n-                            upgrade(buffer);\n-                            break;\n-                        }\n-                    }\n-                    else if (filled == 0)\n-                    {\n-                        fillInterested();\n-                        break;\n-                    }\n-                    else\n-                    {\n-                        close();\n-                        break;\n-                    }\n-                }\n-            }\n-            catch (IOException x)\n-            {\n-                LOG.warn(x);\n-                close();\n-            }\n-        }\n-\n-        @Override\n-        public ByteBuffer onUpgradeFrom()\n-        {\n-            return buffer;\n-        }\n-\n-        private void upgrade(ByteBuffer buffer)\n-        {\n-            if (LOG.isDebugEnabled())\n-                LOG.debug(\"Read {}\", BufferUtil.toDetailString(buffer));\n+            LOG.warn(\"Detected non-TLS bytes, but no other protocol to upgrade to for {}\", endPoint);\n \n-            EndPoint endPoint = getEndPoint();\n-            if (seemsTLS(buffer))\n+            // There are always at least 2 bytes.\n+            int byte1 = buffer.get(0) & 0xFF;\n+            int byte2 = buffer.get(1) & 0xFF;\n+            connector.getByteBufferPool().release(buffer);\n+            if (byte1 == 'G' && byte2 == 'E')", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fc1fabddfdd2342389b3c6b9c0519f5fe94c9ad6"}, "originalPosition": 193}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzUxMDUyNTQy", "url": "https://github.com/eclipse/jetty.project/pull/4519#pullrequestreview-351052542", "createdAt": "2020-01-30T18:40:30Z", "commit": {"oid": "3c3795a69a85bdb7814c4d1d45dff5c4c8c7ffd2"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0zMFQxODo0MDozMFrOFj1qCg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0zMFQxOTozMDowM1rOFj3NcQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzEyMzU5NA==", "bodyText": "Remove this, it's not necessary. This interface must only have detect().\nThe abstraction of being able to detect is orthogonal with whether it has a \"next\" protocol, so the 2 must not be mixed.", "url": "https://github.com/eclipse/jetty.project/pull/4519#discussion_r373123594", "createdAt": "2020-01-30T18:40:30Z", "author": {"login": "sbordet"}, "path": "jetty-server/src/main/java/org/eclipse/jetty/server/ConnectionFactory.java", "diffHunk": "@@ -85,4 +86,51 @@\n          */\n         Connection upgradeConnection(Connector connector, EndPoint endPoint, MetaData.Request upgradeRequest, HttpFields responseFields) throws BadMessageException;\n     }\n+\n+    /**\n+     * <p>Connections created by this factory MUST implement {@link Connection.UpgradeTo}.</p>\n+     */\n+    interface Detecting extends ConnectionFactory\n+    {\n+        /**\n+         * The possible outcomes of the {@link #detect(ByteBuffer)} method.\n+         */\n+        enum Detection\n+        {\n+            /**\n+             * A {@link Detecting} can work with the given bytes.\n+             */\n+            RECOGNIZED,\n+            /**\n+             * A {@link Detecting} cannot work with the given bytes.\n+             */\n+            NOT_RECOGNIZED,\n+            /**\n+             * A {@link Detecting} requires more bytes to make a decision.\n+             */\n+            NEED_MORE_BYTES\n+        }\n+\n+        /**\n+         * <p>Check the bytes in the given {@code buffer} to figure out if this {@link Detecting} instance\n+         * can work with them or not.</p>\n+         * <p>The {@code buffer} MUST be left untouched by this method: bytes MUST NOT be consumed and MUST NOT be modified.</p>\n+         * @param buffer the buffer.\n+         * @return One of:\n+         * <ul>\n+         * <li>{@link Detection#RECOGNIZED} if this {@link Detecting} instance can work with the bytes in the buffer</li>\n+         * <li>{@link Detection#NOT_RECOGNIZED} if this {@link Detecting} instance cannot work with the bytes in the buffer</li>\n+         * <li>{@link Detection#NEED_MORE_BYTES} if this {@link Detecting} instance requires more bytes to make a decision</li>\n+         * </ul>\n+         */\n+        Detection detect(ByteBuffer buffer);\n+\n+        /**\n+         * Has this instance been configured with a next protocol? A {@link DetectorConnectionFactory} won't allow\n+         * {@link Detecting} instances that do not have a configured next protocol.\n+         * @return true if a next protocol has been configured, false otherwise.\n+         */\n+        boolean isNextProtocolConfigured();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3c3795a69a85bdb7814c4d1d45dff5c4c8c7ffd2"}, "originalPosition": 56}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzEzODM1OA==", "bodyText": "So the problem is that we cannot pass a function to the constructor that references this, so we need DetectionSuccessful for the function, but then DetectionUnsuccessfulTrampoline to workaround referencing this.\nThis to me means that it's the wrong solution. If we need to reference this, then all of the above should be part of the subclass itself and so an overridable method can do the job.\nThe overridable method will get rid of these 2 interfaces and all the machinery that they require.", "url": "https://github.com/eclipse/jetty.project/pull/4519#discussion_r373138358", "createdAt": "2020-01-30T19:08:57Z", "author": {"login": "sbordet"}, "path": "jetty-server/src/main/java/org/eclipse/jetty/server/DetectorConnectionFactory.java", "diffHunk": "@@ -0,0 +1,322 @@\n+//\n+//  ========================================================================\n+//  Copyright (c) 1995-2020 Mort Bay Consulting Pty Ltd and others.\n+//  ------------------------------------------------------------------------\n+//  All rights reserved. This program and the accompanying materials\n+//  are made available under the terms of the Eclipse Public License v1.0\n+//  and Apache License v2.0 which accompanies this distribution.\n+//\n+//      The Eclipse Public License is available at\n+//      http://www.eclipse.org/legal/epl-v10.html\n+//\n+//      The Apache License v2.0 is available at\n+//      http://www.opensource.org/licenses/apache2.0.php\n+//\n+//  You may elect to redistribute this code under either of these licenses.\n+//  ========================================================================\n+//\n+\n+package org.eclipse.jetty.server;\n+\n+import java.nio.ByteBuffer;\n+import java.util.Arrays;\n+import java.util.LinkedHashSet;\n+import java.util.List;\n+import java.util.Objects;\n+\n+import org.eclipse.jetty.io.AbstractConnection;\n+import org.eclipse.jetty.io.Connection;\n+import org.eclipse.jetty.io.EndPoint;\n+import org.eclipse.jetty.util.BufferUtil;\n+import org.eclipse.jetty.util.log.Log;\n+import org.eclipse.jetty.util.log.Logger;\n+\n+/**\n+ * A {@link ConnectionFactory} combining multiple {@link Detecting} instances that will upgrade to\n+ * the first one recognizing the bytes in the buffer.\n+ */\n+public class DetectorConnectionFactory extends AbstractConnectionFactory\n+{\n+    private static final Logger LOG = Log.getLogger(DetectorConnectionFactory.class);\n+\n+    protected static final DetectionUnsuccessfulTrampoline UPGRADE_TO_NEXT_PROTOCOL_TRAMPOLINE = (connectionFactory, connector, endPoint, buffer) ->\n+    {\n+        String nextProtocol = connectionFactory.findNextProtocol(connector);\n+        if (nextProtocol == null)\n+        {\n+            connector.getByteBufferPool().release(buffer);\n+            endPoint.close();\n+            throw new IllegalStateException(\"No next protocol for \" + endPoint);\n+        }\n+        upgradeToProtocol(nextProtocol, connector, endPoint, buffer);\n+    };\n+\n+    private final DetectionUnsuccessfulTrampoline _detectionUnsuccessful;\n+    protected final List<Detecting> _detectingConnectionFactories;\n+\n+    /**\n+     * <p>When the first bytes are not recognized by the {@code detectingConnectionFactories}, the default behavior is to\n+     * upgrade to the protocol returned by {@link #findNextProtocol(Connector)}.</p>\n+     * @param detectingConnectionFactories the {@link Detecting} instances.\n+     */\n+    public DetectorConnectionFactory(Detecting... detectingConnectionFactories)\n+    {\n+        this(UPGRADE_TO_NEXT_PROTOCOL_TRAMPOLINE, detectingConnectionFactories);\n+    }\n+\n+    /**\n+     * <p>When the first bytes are not recognized by the {@code detectingConnectionFactories}, then\n+     * {@link DetectionUnsuccessful#onDetectionUnsuccessful(Connector, EndPoint, ByteBuffer)} is called.</p>\n+     * @param detectionUnsuccessful A {@link DetectionUnsuccessful} instance that is going to be called back when no {@link Detecting} instance detected its protocol.\n+     * @param detectingConnectionFactories the {@link Detecting} instances.\n+     */\n+    public DetectorConnectionFactory(DetectionUnsuccessful detectionUnsuccessful, Detecting... detectingConnectionFactories)\n+    {\n+        this(detectionUnsuccessful == null ? null : (connectionFactory, connector, endPoint, buffer) -> detectionUnsuccessful.onDetectionUnsuccessful(connector, endPoint, buffer), detectingConnectionFactories);\n+    }\n+\n+    /**\n+     * TODO javadoc\n+     * @param detectionUnsuccessful A {@link DetectionUnsuccessfulTrampoline} instance that is going to be called back when no\n+     * {@link Detecting} instance detected its protocol.\n+     * @param detectingConnectionFactories the {@link Detecting} instances.\n+     */\n+    protected DetectorConnectionFactory(DetectionUnsuccessfulTrampoline detectionUnsuccessful, Detecting... detectingConnectionFactories)\n+    {\n+        super(toProtocolString(detectingConnectionFactories));\n+        _detectingConnectionFactories = Arrays.asList(detectingConnectionFactories);\n+        _detectionUnsuccessful = Objects.requireNonNull(detectionUnsuccessful);\n+        if (!(this instanceof Detecting))\n+        {\n+            // DetectorConnectionFactory subclasses that also implement Detecting can safely bypass this check as only\n+            // their internal Detecting instances need a next protocol.\n+            for (Detecting detectingConnectionFactory : detectingConnectionFactories)\n+            {\n+                if (!detectingConnectionFactory.isNextProtocolConfigured())\n+                    throw new IllegalStateException(\"Detecting connection factories must be explicitly configured with a next protocol\");\n+            }\n+        }\n+        for (Detecting detectingConnectionFactory : detectingConnectionFactories)\n+        {\n+            addBean(detectingConnectionFactory);\n+        }\n+    }\n+\n+    static String toProtocolString(Detecting... detectingConnectionFactories)\n+    {\n+        if (detectingConnectionFactories.length == 0)\n+            throw new IllegalStateException(\"At least one detecting instance is required\");\n+\n+        // remove protocol duplicates while keeping their ordering -> use LinkedHashSet\n+        LinkedHashSet<String> protocols = new LinkedHashSet<>();\n+        for (Detecting dcf : detectingConnectionFactories)\n+        {\n+            protocols.add(dcf.getProtocol());\n+        }\n+\n+        StringBuilder sb = new StringBuilder();\n+        for (String protocol : protocols)\n+        {\n+            sb.append(protocol).append('|');\n+        }\n+        sb.deleteCharAt(sb.length() - 1);\n+        return sb.toString();\n+    }\n+\n+    /**\n+     * Perform a detection using multiple {@code detectingConnectionFactories} and return the aggregated outcome.\n+     * @param buffer the buffer to perform a detection against.\n+     * @param detectingConnectionFactories the {@link Detecting} instances.\n+     * @return A {@link Detecting.Detection} value with the detection outcome of the {@code detectingConnectionFactories}.\n+     */\n+    protected static Detecting.Detection detectUsing(ByteBuffer buffer, Iterable<Detecting> detectingConnectionFactories)\n+    {\n+        boolean allDetectionNotRecognized = true;\n+        for (Detecting detectingConnectionFactory : detectingConnectionFactories)\n+        {\n+            Detecting.Detection detection = detectingConnectionFactory.detect(buffer);\n+            if (detection == Detecting.Detection.RECOGNIZED)\n+                return Detecting.Detection.RECOGNIZED;\n+            allDetectionNotRecognized &= detection == Detecting.Detection.NOT_RECOGNIZED;\n+        }\n+        return allDetectionNotRecognized ? Detecting.Detection.NOT_RECOGNIZED : Detecting.Detection.NEED_MORE_BYTES;\n+    }\n+\n+    /**\n+     * Utility method that performs an upgrade to the specified protocol, disposing of the given resources when needed.\n+     * @param protocol the protocol to upgrade to.\n+     * @param connector the connector.\n+     * @param endPoint the endpoint.\n+     * @param buffer the buffer.\n+     */\n+    protected static void upgradeToProtocol(String protocol, Connector connector, EndPoint endPoint, ByteBuffer buffer)\n+    {\n+        ConnectionFactory nextConnectionFactory = connector.getConnectionFactory(protocol);\n+        Connection nextConnection = nextConnectionFactory.newConnection(connector, endPoint);\n+        if (!(nextConnection instanceof Connection.UpgradeTo))\n+        {\n+            connector.getByteBufferPool().release(buffer);\n+            endPoint.close();\n+            throw new IllegalStateException(\"Cannot upgrade: \" + nextConnection + \" does not implement \" + Connection.UpgradeTo.class.getName());\n+        }\n+\n+        endPoint.upgrade(nextConnection);\n+        connector.getByteBufferPool().release(buffer);\n+    }\n+\n+    @Override\n+    public Connection newConnection(Connector connector, EndPoint endPoint)\n+    {\n+        return configure(new DetectorConnection(endPoint, connector, _detectingConnectionFactories, _detectionUnsuccessful), connector, endPoint);\n+    }\n+\n+    class DetectorConnection extends AbstractConnection implements Connection.UpgradeFrom, Connection.UpgradeTo\n+    {\n+        private final Connector _connector;\n+        private final List<Detecting> _detectingConnectionFactories;\n+        private final DetectionUnsuccessfulTrampoline _detectionUnsuccessful;\n+        private final ByteBuffer _buffer;\n+\n+        protected DetectorConnection(EndPoint endp, Connector connector, List<Detecting> detectingConnectionFactories, DetectionUnsuccessfulTrampoline detectionUnsuccessful)\n+        {\n+            super(endp, connector.getExecutor());\n+            _connector = connector;\n+            _detectingConnectionFactories = detectingConnectionFactories;\n+            _detectionUnsuccessful = detectionUnsuccessful;\n+            _buffer = connector.getByteBufferPool().acquire(getInputBufferSize(), true);\n+        }\n+\n+        @Override\n+        public void onOpen()\n+        {\n+            super.onOpen();\n+\n+            if (!detectAndUpgrade())\n+                fillInterested();\n+        }\n+\n+        @Override\n+        public void onFillable()\n+        {\n+            try\n+            {\n+                while (BufferUtil.space(_buffer) > 0)\n+                {\n+                    // Read data\n+                    int fill = getEndPoint().fill(_buffer);\n+                    if (fill < 0)\n+                    {\n+                        getEndPoint().shutdownOutput();\n+                        return;\n+                    }\n+                    if (fill == 0)\n+                    {\n+                        fillInterested();\n+                        return;\n+                    }\n+\n+                    if (detectAndUpgrade())\n+                        return;\n+                }\n+\n+                // all Detecting instances want more bytes than this buffer can store\n+                LOG.warn(\"Failed to detect upgrade target on {} for {}\", _detectingConnectionFactories, getEndPoint());\n+                releaseAndClose();\n+            }\n+            catch (Throwable x)\n+            {\n+                LOG.warn(\"DetectorConnection error for \" + getEndPoint(), x);\n+                releaseAndClose();\n+            }\n+        }\n+\n+        /**\n+         * @return true when upgrade was performed, false otherwise.\n+         */\n+        private boolean detectAndUpgrade()\n+        {\n+            boolean noMagicFound = true;\n+            for (Detecting detectingConnectionFactory : _detectingConnectionFactories)\n+            {\n+                Detecting.Detection detection = detectingConnectionFactory.detect(_buffer);\n+                if (detection == Detecting.Detection.RECOGNIZED)\n+                {\n+                    // this DetectingConnectionFactory recognized those bytes -> upgrade to the next one\n+                    Connection nextConnection = detectingConnectionFactory.newConnection(_connector, getEndPoint());\n+                    if (!(nextConnection instanceof UpgradeTo))\n+                    {\n+                        releaseAndClose();\n+                        throw new IllegalStateException(\"Cannot upgrade: \" + nextConnection + \" does not implement \" + Connection.UpgradeTo.class.getName());\n+                    }\n+                    getEndPoint().upgrade(nextConnection);\n+                    _connector.getByteBufferPool().release(_buffer);\n+                    return true;\n+                }\n+                noMagicFound &= detection == Detecting.Detection.NOT_RECOGNIZED;\n+            }\n+\n+            if (noMagicFound)\n+            {\n+                // no DetectingConnectionFactory recognized those bytes -> call no recognition callback\n+                _detectionUnsuccessful.onDetectionUnsuccessful(DetectorConnectionFactory.this, _connector, getEndPoint(), _buffer);\n+                return true;\n+            }\n+            return false;\n+        }\n+\n+        private void releaseAndClose()\n+        {\n+            _connector.getByteBufferPool().release(_buffer);\n+            close();\n+        }\n+\n+        @Override\n+        public void onUpgradeTo(ByteBuffer prefilled)\n+        {\n+            if (BufferUtil.hasContent(prefilled))\n+                BufferUtil.append(_buffer, prefilled);\n+        }\n+\n+        @Override\n+        public ByteBuffer onUpgradeFrom()\n+        {\n+            return _buffer;\n+        }\n+    }\n+\n+    /**\n+     * A functional interface whose instances are used as callbacks when protocol detection is unsuccessful.\n+     */\n+    @FunctionalInterface\n+    interface DetectionUnsuccessful\n+    {\n+        /**\n+         * This method is called back when protocol detection is unsuccessful. Instances of this interface are responsible\n+         * for disposing of the {@code buffer} and the {@code endpoint}.\n+         * @param connector the connector.\n+         * @param endPoint the endpoint.\n+         * @param buffer the buffer containing the bytes.\n+         */\n+        void onDetectionUnsuccessful(Connector connector, EndPoint endPoint, ByteBuffer buffer);\n+    }\n+\n+    /**\n+     * Equivalent to {@link DetectionUnsuccessful} but used internally to allow subclasses to pass to {@code super} an instance\n+     * that can callback a member method.\n+     * <p>Only subclasses of {@link DetectorConnectionFactory} who require calling back a member method need this interface.</p>\n+     */\n+    @FunctionalInterface\n+    protected interface DetectionUnsuccessfulTrampoline\n+    {\n+        /**\n+         * This method is called back when protocol detection is unsuccessful. Instances of this interface are responsible\n+         * for disposing of the {@code buffer} and the {@code endpoint}.\n+         * @param connectionFactory the detector that performed the detection.\n+         * @param connector the connector.\n+         * @param endPoint the endpoint.\n+         * @param buffer the buffer containing the bytes.\n+         */\n+        void onDetectionUnsuccessful(DetectorConnectionFactory connectionFactory, Connector connector, EndPoint endPoint, ByteBuffer buffer);\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3c3795a69a85bdb7814c4d1d45dff5c4c8c7ffd2"}, "originalPosition": 320}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzEzOTkzNA==", "bodyText": "Drop \"magic\", you can just use boolean detected = false.", "url": "https://github.com/eclipse/jetty.project/pull/4519#discussion_r373139934", "createdAt": "2020-01-30T19:11:59Z", "author": {"login": "sbordet"}, "path": "jetty-server/src/main/java/org/eclipse/jetty/server/DetectorConnectionFactory.java", "diffHunk": "@@ -0,0 +1,322 @@\n+//\n+//  ========================================================================\n+//  Copyright (c) 1995-2020 Mort Bay Consulting Pty Ltd and others.\n+//  ------------------------------------------------------------------------\n+//  All rights reserved. This program and the accompanying materials\n+//  are made available under the terms of the Eclipse Public License v1.0\n+//  and Apache License v2.0 which accompanies this distribution.\n+//\n+//      The Eclipse Public License is available at\n+//      http://www.eclipse.org/legal/epl-v10.html\n+//\n+//      The Apache License v2.0 is available at\n+//      http://www.opensource.org/licenses/apache2.0.php\n+//\n+//  You may elect to redistribute this code under either of these licenses.\n+//  ========================================================================\n+//\n+\n+package org.eclipse.jetty.server;\n+\n+import java.nio.ByteBuffer;\n+import java.util.Arrays;\n+import java.util.LinkedHashSet;\n+import java.util.List;\n+import java.util.Objects;\n+\n+import org.eclipse.jetty.io.AbstractConnection;\n+import org.eclipse.jetty.io.Connection;\n+import org.eclipse.jetty.io.EndPoint;\n+import org.eclipse.jetty.util.BufferUtil;\n+import org.eclipse.jetty.util.log.Log;\n+import org.eclipse.jetty.util.log.Logger;\n+\n+/**\n+ * A {@link ConnectionFactory} combining multiple {@link Detecting} instances that will upgrade to\n+ * the first one recognizing the bytes in the buffer.\n+ */\n+public class DetectorConnectionFactory extends AbstractConnectionFactory\n+{\n+    private static final Logger LOG = Log.getLogger(DetectorConnectionFactory.class);\n+\n+    protected static final DetectionUnsuccessfulTrampoline UPGRADE_TO_NEXT_PROTOCOL_TRAMPOLINE = (connectionFactory, connector, endPoint, buffer) ->\n+    {\n+        String nextProtocol = connectionFactory.findNextProtocol(connector);\n+        if (nextProtocol == null)\n+        {\n+            connector.getByteBufferPool().release(buffer);\n+            endPoint.close();\n+            throw new IllegalStateException(\"No next protocol for \" + endPoint);\n+        }\n+        upgradeToProtocol(nextProtocol, connector, endPoint, buffer);\n+    };\n+\n+    private final DetectionUnsuccessfulTrampoline _detectionUnsuccessful;\n+    protected final List<Detecting> _detectingConnectionFactories;\n+\n+    /**\n+     * <p>When the first bytes are not recognized by the {@code detectingConnectionFactories}, the default behavior is to\n+     * upgrade to the protocol returned by {@link #findNextProtocol(Connector)}.</p>\n+     * @param detectingConnectionFactories the {@link Detecting} instances.\n+     */\n+    public DetectorConnectionFactory(Detecting... detectingConnectionFactories)\n+    {\n+        this(UPGRADE_TO_NEXT_PROTOCOL_TRAMPOLINE, detectingConnectionFactories);\n+    }\n+\n+    /**\n+     * <p>When the first bytes are not recognized by the {@code detectingConnectionFactories}, then\n+     * {@link DetectionUnsuccessful#onDetectionUnsuccessful(Connector, EndPoint, ByteBuffer)} is called.</p>\n+     * @param detectionUnsuccessful A {@link DetectionUnsuccessful} instance that is going to be called back when no {@link Detecting} instance detected its protocol.\n+     * @param detectingConnectionFactories the {@link Detecting} instances.\n+     */\n+    public DetectorConnectionFactory(DetectionUnsuccessful detectionUnsuccessful, Detecting... detectingConnectionFactories)\n+    {\n+        this(detectionUnsuccessful == null ? null : (connectionFactory, connector, endPoint, buffer) -> detectionUnsuccessful.onDetectionUnsuccessful(connector, endPoint, buffer), detectingConnectionFactories);\n+    }\n+\n+    /**\n+     * TODO javadoc\n+     * @param detectionUnsuccessful A {@link DetectionUnsuccessfulTrampoline} instance that is going to be called back when no\n+     * {@link Detecting} instance detected its protocol.\n+     * @param detectingConnectionFactories the {@link Detecting} instances.\n+     */\n+    protected DetectorConnectionFactory(DetectionUnsuccessfulTrampoline detectionUnsuccessful, Detecting... detectingConnectionFactories)\n+    {\n+        super(toProtocolString(detectingConnectionFactories));\n+        _detectingConnectionFactories = Arrays.asList(detectingConnectionFactories);\n+        _detectionUnsuccessful = Objects.requireNonNull(detectionUnsuccessful);\n+        if (!(this instanceof Detecting))\n+        {\n+            // DetectorConnectionFactory subclasses that also implement Detecting can safely bypass this check as only\n+            // their internal Detecting instances need a next protocol.\n+            for (Detecting detectingConnectionFactory : detectingConnectionFactories)\n+            {\n+                if (!detectingConnectionFactory.isNextProtocolConfigured())\n+                    throw new IllegalStateException(\"Detecting connection factories must be explicitly configured with a next protocol\");\n+            }\n+        }\n+        for (Detecting detectingConnectionFactory : detectingConnectionFactories)\n+        {\n+            addBean(detectingConnectionFactory);\n+        }\n+    }\n+\n+    static String toProtocolString(Detecting... detectingConnectionFactories)\n+    {\n+        if (detectingConnectionFactories.length == 0)\n+            throw new IllegalStateException(\"At least one detecting instance is required\");\n+\n+        // remove protocol duplicates while keeping their ordering -> use LinkedHashSet\n+        LinkedHashSet<String> protocols = new LinkedHashSet<>();\n+        for (Detecting dcf : detectingConnectionFactories)\n+        {\n+            protocols.add(dcf.getProtocol());\n+        }\n+\n+        StringBuilder sb = new StringBuilder();\n+        for (String protocol : protocols)\n+        {\n+            sb.append(protocol).append('|');\n+        }\n+        sb.deleteCharAt(sb.length() - 1);\n+        return sb.toString();\n+    }\n+\n+    /**\n+     * Perform a detection using multiple {@code detectingConnectionFactories} and return the aggregated outcome.\n+     * @param buffer the buffer to perform a detection against.\n+     * @param detectingConnectionFactories the {@link Detecting} instances.\n+     * @return A {@link Detecting.Detection} value with the detection outcome of the {@code detectingConnectionFactories}.\n+     */\n+    protected static Detecting.Detection detectUsing(ByteBuffer buffer, Iterable<Detecting> detectingConnectionFactories)\n+    {\n+        boolean allDetectionNotRecognized = true;\n+        for (Detecting detectingConnectionFactory : detectingConnectionFactories)\n+        {\n+            Detecting.Detection detection = detectingConnectionFactory.detect(buffer);\n+            if (detection == Detecting.Detection.RECOGNIZED)\n+                return Detecting.Detection.RECOGNIZED;\n+            allDetectionNotRecognized &= detection == Detecting.Detection.NOT_RECOGNIZED;\n+        }\n+        return allDetectionNotRecognized ? Detecting.Detection.NOT_RECOGNIZED : Detecting.Detection.NEED_MORE_BYTES;\n+    }\n+\n+    /**\n+     * Utility method that performs an upgrade to the specified protocol, disposing of the given resources when needed.\n+     * @param protocol the protocol to upgrade to.\n+     * @param connector the connector.\n+     * @param endPoint the endpoint.\n+     * @param buffer the buffer.\n+     */\n+    protected static void upgradeToProtocol(String protocol, Connector connector, EndPoint endPoint, ByteBuffer buffer)\n+    {\n+        ConnectionFactory nextConnectionFactory = connector.getConnectionFactory(protocol);\n+        Connection nextConnection = nextConnectionFactory.newConnection(connector, endPoint);\n+        if (!(nextConnection instanceof Connection.UpgradeTo))\n+        {\n+            connector.getByteBufferPool().release(buffer);\n+            endPoint.close();\n+            throw new IllegalStateException(\"Cannot upgrade: \" + nextConnection + \" does not implement \" + Connection.UpgradeTo.class.getName());\n+        }\n+\n+        endPoint.upgrade(nextConnection);\n+        connector.getByteBufferPool().release(buffer);\n+    }\n+\n+    @Override\n+    public Connection newConnection(Connector connector, EndPoint endPoint)\n+    {\n+        return configure(new DetectorConnection(endPoint, connector, _detectingConnectionFactories, _detectionUnsuccessful), connector, endPoint);\n+    }\n+\n+    class DetectorConnection extends AbstractConnection implements Connection.UpgradeFrom, Connection.UpgradeTo\n+    {\n+        private final Connector _connector;\n+        private final List<Detecting> _detectingConnectionFactories;\n+        private final DetectionUnsuccessfulTrampoline _detectionUnsuccessful;\n+        private final ByteBuffer _buffer;\n+\n+        protected DetectorConnection(EndPoint endp, Connector connector, List<Detecting> detectingConnectionFactories, DetectionUnsuccessfulTrampoline detectionUnsuccessful)\n+        {\n+            super(endp, connector.getExecutor());\n+            _connector = connector;\n+            _detectingConnectionFactories = detectingConnectionFactories;\n+            _detectionUnsuccessful = detectionUnsuccessful;\n+            _buffer = connector.getByteBufferPool().acquire(getInputBufferSize(), true);\n+        }\n+\n+        @Override\n+        public void onOpen()\n+        {\n+            super.onOpen();\n+\n+            if (!detectAndUpgrade())\n+                fillInterested();\n+        }\n+\n+        @Override\n+        public void onFillable()\n+        {\n+            try\n+            {\n+                while (BufferUtil.space(_buffer) > 0)\n+                {\n+                    // Read data\n+                    int fill = getEndPoint().fill(_buffer);\n+                    if (fill < 0)\n+                    {\n+                        getEndPoint().shutdownOutput();\n+                        return;\n+                    }\n+                    if (fill == 0)\n+                    {\n+                        fillInterested();\n+                        return;\n+                    }\n+\n+                    if (detectAndUpgrade())\n+                        return;\n+                }\n+\n+                // all Detecting instances want more bytes than this buffer can store\n+                LOG.warn(\"Failed to detect upgrade target on {} for {}\", _detectingConnectionFactories, getEndPoint());\n+                releaseAndClose();\n+            }\n+            catch (Throwable x)\n+            {\n+                LOG.warn(\"DetectorConnection error for \" + getEndPoint(), x);\n+                releaseAndClose();\n+            }\n+        }\n+\n+        /**\n+         * @return true when upgrade was performed, false otherwise.\n+         */\n+        private boolean detectAndUpgrade()\n+        {\n+            boolean noMagicFound = true;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3c3795a69a85bdb7814c4d1d45dff5c4c8c7ffd2"}, "originalPosition": 238}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzE0MjIxOA==", "bodyText": "We have a LeakTrackingByteBufferPool that you can use.", "url": "https://github.com/eclipse/jetty.project/pull/4519#discussion_r373142218", "createdAt": "2020-01-30T19:16:44Z", "author": {"login": "sbordet"}, "path": "jetty-server/src/test/java/org/eclipse/jetty/server/DetectorConnectionFactoryTest.java", "diffHunk": "@@ -0,0 +1,584 @@\n+//\n+//  ========================================================================\n+//  Copyright (c) 1995-2020 Mort Bay Consulting Pty Ltd and others.\n+//  ------------------------------------------------------------------------\n+//  All rights reserved. This program and the accompanying materials\n+//  are made available under the terms of the Eclipse Public License v1.0\n+//  and Apache License v2.0 which accompanies this distribution.\n+//\n+//      The Eclipse Public License is available at\n+//      http://www.eclipse.org/legal/epl-v10.html\n+//\n+//      The Apache License v2.0 is available at\n+//      http://www.opensource.org/licenses/apache2.0.php\n+//\n+//  You may elect to redistribute this code under either of these licenses.\n+//  ========================================================================\n+//\n+\n+package org.eclipse.jetty.server;\n+\n+import java.io.BufferedReader;\n+import java.io.InputStreamReader;\n+import java.io.PrintWriter;\n+import java.io.StringWriter;\n+import java.net.Socket;\n+import java.nio.ByteBuffer;\n+import java.nio.charset.StandardCharsets;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicReference;\n+import javax.net.ssl.SSLSocketFactory;\n+\n+import org.eclipse.jetty.http.HttpVersion;\n+import org.eclipse.jetty.io.ByteBufferPool;\n+import org.eclipse.jetty.io.Connection;\n+import org.eclipse.jetty.io.EndPoint;\n+import org.eclipse.jetty.toolchain.test.MavenTestingUtils;\n+import org.eclipse.jetty.util.BufferUtil;\n+import org.eclipse.jetty.util.Callback;\n+import org.eclipse.jetty.util.ssl.SslContextFactory;\n+import org.hamcrest.Matchers;\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.Test;\n+\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n+public class DetectorConnectionFactoryTest\n+{\n+    private Server _server;\n+    private AssertingByteBufferPool _assertingByteBufferPool;\n+\n+    // use this ByteBuffer leak detector to ensure that the byte buffers are properly disposed of by the detection mechanism.\n+    static class AssertingByteBufferPool implements ByteBufferPool", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3c3795a69a85bdb7814c4d1d45dff5c4c8c7ffd2"}, "originalPosition": 57}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzE0NjE2MA==", "bodyText": "Move http up, and use http.getProtocol() rather than HttpVersion.HTTP_1_1.asString().", "url": "https://github.com/eclipse/jetty.project/pull/4519#discussion_r373146160", "createdAt": "2020-01-30T19:24:25Z", "author": {"login": "sbordet"}, "path": "jetty-server/src/test/java/org/eclipse/jetty/server/DetectorConnectionFactoryTest.java", "diffHunk": "@@ -0,0 +1,584 @@\n+//\n+//  ========================================================================\n+//  Copyright (c) 1995-2020 Mort Bay Consulting Pty Ltd and others.\n+//  ------------------------------------------------------------------------\n+//  All rights reserved. This program and the accompanying materials\n+//  are made available under the terms of the Eclipse Public License v1.0\n+//  and Apache License v2.0 which accompanies this distribution.\n+//\n+//      The Eclipse Public License is available at\n+//      http://www.eclipse.org/legal/epl-v10.html\n+//\n+//      The Apache License v2.0 is available at\n+//      http://www.opensource.org/licenses/apache2.0.php\n+//\n+//  You may elect to redistribute this code under either of these licenses.\n+//  ========================================================================\n+//\n+\n+package org.eclipse.jetty.server;\n+\n+import java.io.BufferedReader;\n+import java.io.InputStreamReader;\n+import java.io.PrintWriter;\n+import java.io.StringWriter;\n+import java.net.Socket;\n+import java.nio.ByteBuffer;\n+import java.nio.charset.StandardCharsets;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicReference;\n+import javax.net.ssl.SSLSocketFactory;\n+\n+import org.eclipse.jetty.http.HttpVersion;\n+import org.eclipse.jetty.io.ByteBufferPool;\n+import org.eclipse.jetty.io.Connection;\n+import org.eclipse.jetty.io.EndPoint;\n+import org.eclipse.jetty.toolchain.test.MavenTestingUtils;\n+import org.eclipse.jetty.util.BufferUtil;\n+import org.eclipse.jetty.util.Callback;\n+import org.eclipse.jetty.util.ssl.SslContextFactory;\n+import org.hamcrest.Matchers;\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.Test;\n+\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n+public class DetectorConnectionFactoryTest\n+{\n+    private Server _server;\n+    private AssertingByteBufferPool _assertingByteBufferPool;\n+\n+    // use this ByteBuffer leak detector to ensure that the byte buffers are properly disposed of by the detection mechanism.\n+    static class AssertingByteBufferPool implements ByteBufferPool\n+    {\n+        private final List<Entry> _bufferPool = new ArrayList<>();\n+\n+        public AssertingByteBufferPool(int poolSize)\n+        {\n+            for (int i = 0; i < poolSize; i++)\n+            {\n+                _bufferPool.add(new Entry(BufferUtil.allocateDirect(32768)));\n+            }\n+        }\n+\n+        @Override\n+        public ByteBuffer acquire(int size, boolean direct)\n+        {\n+            for (Entry entry : _bufferPool)\n+            {\n+                if (entry.acquired.compareAndSet(false, true))\n+                {\n+                    entry.acquisitionStack.set(new Exception(\"acquisition stack\"));\n+                    return entry.byteBuffer;\n+                }\n+            }\n+            throw new AssertionError(\"Could not find an available buffer\");\n+        }\n+\n+        @Override\n+        public void release(ByteBuffer buffer)\n+        {\n+            for (Entry entry : _bufferPool)\n+            {\n+                if (entry.byteBuffer == buffer)\n+                {\n+                    if (!entry.acquired.compareAndSet(true, false))\n+                        throw new AssertionError(\"Detected the release of a buffer that has already been released : \" + buffer);\n+                    entry.acquisitionStack.set(null);\n+                    return;\n+                }\n+            }\n+            throw new AssertionError(\"Detected the release of a buffer that is not part of the pool : \" + buffer);\n+        }\n+\n+        public boolean allBuffersWereReleased()\n+        {\n+            for (Entry entry : _bufferPool)\n+            {\n+                if (entry.acquired.get())\n+                    return false;\n+            }\n+            return true;\n+        }\n+\n+        public void assertAllBuffersWereReleased()\n+        {\n+            List<Entry> unreleasedBuffers = new ArrayList<>();\n+            for (Entry entry : _bufferPool)\n+            {\n+                if (entry.acquired.get())\n+                    unreleasedBuffers.add(entry);\n+            }\n+            if (!unreleasedBuffers.isEmpty())\n+                throw new AssertionError(\"Detected \" + unreleasedBuffers.size() + \" leaked buffers : \" + unreleasedBuffers);\n+        }\n+\n+        static class Entry\n+        {\n+            final AtomicBoolean acquired = new AtomicBoolean(); // true means available, false means acquired\n+            final ByteBuffer byteBuffer;\n+            final AtomicReference<Throwable> acquisitionStack = new AtomicReference<>();\n+\n+            public Entry(ByteBuffer byteBuffer)\n+            {\n+                this.byteBuffer = byteBuffer;\n+            }\n+\n+            @Override\n+            public String toString()\n+            {\n+                StringWriter sw = new StringWriter();\n+                PrintWriter pw = new PrintWriter(sw);\n+                acquisitionStack.get().printStackTrace(pw);\n+                pw.close();\n+                return byteBuffer + \"\\n\" + sw.toString();\n+            }\n+        }\n+    }\n+\n+    @AfterEach\n+    public void destroy() throws Exception\n+    {\n+        if (_server != null)\n+            _server.stop();\n+        if (_assertingByteBufferPool != null)\n+            _assertingByteBufferPool.assertAllBuffersWereReleased();\n+    }\n+\n+    private void start(ConnectionFactory... connectionFactories) throws Exception\n+    {\n+        _server = new Server();\n+        _assertingByteBufferPool = new AssertingByteBufferPool(100);\n+        _server.addBean(_assertingByteBufferPool);\n+        _server.addConnector(new ServerConnector(_server, 1, 1, connectionFactories));\n+        _server.setHandler(new DumpHandler());\n+        _server.start();\n+    }\n+\n+    private String getResponse(String request) throws Exception\n+    {\n+        try (Socket socket = new Socket(_server.getURI().getHost(), _server.getURI().getPort()))\n+        {\n+            socket.getOutputStream().write(request.getBytes(StandardCharsets.US_ASCII));\n+\n+            StringBuilder sb = new StringBuilder();\n+            BufferedReader reader = new BufferedReader(new InputStreamReader(socket.getInputStream(), StandardCharsets.US_ASCII));\n+\n+            while (true)\n+            {\n+                String line = reader.readLine();\n+                if (line == null)\n+                    break;\n+                sb.append(line).append(\"\\n\");\n+            }\n+\n+            return sb.length() == 0 ? null : sb.toString();\n+        }\n+    }\n+\n+    private String getResponseOverSsl(String request) throws Exception\n+    {\n+        String keystore = MavenTestingUtils.getTestResourceFile(\"keystore\").getAbsolutePath();\n+        SslContextFactory sslContextFactory = new SslContextFactory.Server();\n+        sslContextFactory.setKeyStorePath(keystore);\n+        sslContextFactory.setKeyStorePassword(\"storepwd\");\n+        sslContextFactory.setKeyManagerPassword(\"keypwd\");\n+        sslContextFactory.start();\n+\n+        SSLSocketFactory socketFactory = sslContextFactory.getSslContext().getSocketFactory();\n+        try (Socket socket = socketFactory.createSocket(_server.getURI().getHost(), _server.getURI().getPort()))\n+        {\n+            socket.getOutputStream().write(request.getBytes(StandardCharsets.US_ASCII));\n+\n+            StringBuilder sb = new StringBuilder();\n+            BufferedReader reader = new BufferedReader(new InputStreamReader(socket.getInputStream(), StandardCharsets.US_ASCII));\n+\n+            while (true)\n+            {\n+                String line = reader.readLine();\n+                if (line == null)\n+                    break;\n+                sb.append(line).append(\"\\n\");\n+            }\n+\n+            return sb.length() == 0 ? null : sb.toString();\n+        }\n+        finally\n+        {\n+            sslContextFactory.stop();\n+        }\n+    }\n+\n+    @Test\n+    public void testDetectingSslProxyToHttpNoSslNoProxy() throws Exception\n+    {\n+        String keystore = MavenTestingUtils.getTestResourceFile(\"keystore\").getAbsolutePath();\n+        SslContextFactory sslContextFactory = new SslContextFactory.Server();\n+        sslContextFactory.setKeyStorePath(keystore);\n+        sslContextFactory.setKeyStorePassword(\"storepwd\");\n+        sslContextFactory.setKeyManagerPassword(\"keypwd\");\n+\n+        ProxyConnectionFactory proxy = new ProxyConnectionFactory(HttpVersion.HTTP_1_1.asString());\n+        SslConnectionFactory ssl = new SslConnectionFactory(sslContextFactory, HttpVersion.HTTP_1_1.asString());\n+        DetectorConnectionFactory detector = new DetectorConnectionFactory(ssl, proxy);\n+        HttpConnectionFactory http = new HttpConnectionFactory();\n+\n+        start(detector, http);\n+\n+        String request = \"GET /path HTTP/1.1\\n\" +\n+            \"Host: server:80\\n\" +\n+            \"Connection: close\\n\" +\n+            \"\\n\";\n+        String response = getResponse(request);\n+\n+        assertThat(response, Matchers.containsString(\"HTTP/1.1 200\"));\n+    }\n+\n+    @Test\n+    public void testDetectingSslProxyToHttpNoSslWithProxy() throws Exception\n+    {\n+        String keystore = MavenTestingUtils.getTestResourceFile(\"keystore\").getAbsolutePath();\n+        SslContextFactory sslContextFactory = new SslContextFactory.Server();\n+        sslContextFactory.setKeyStorePath(keystore);\n+        sslContextFactory.setKeyStorePassword(\"storepwd\");\n+        sslContextFactory.setKeyManagerPassword(\"keypwd\");\n+\n+        ProxyConnectionFactory proxy = new ProxyConnectionFactory(HttpVersion.HTTP_1_1.asString());\n+        SslConnectionFactory ssl = new SslConnectionFactory(sslContextFactory, HttpVersion.HTTP_1_1.asString());\n+        DetectorConnectionFactory detector = new DetectorConnectionFactory(ssl, proxy);\n+        HttpConnectionFactory http = new HttpConnectionFactory();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3c3795a69a85bdb7814c4d1d45dff5c4c8c7ffd2"}, "originalPosition": 254}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzE0NzA4Nw==", "bodyText": "Better name would be testDetectionUnsuccessfulUpgradesToFirstAfter()?", "url": "https://github.com/eclipse/jetty.project/pull/4519#discussion_r373147087", "createdAt": "2020-01-30T19:26:11Z", "author": {"login": "sbordet"}, "path": "jetty-server/src/test/java/org/eclipse/jetty/server/DetectorConnectionFactoryTest.java", "diffHunk": "@@ -0,0 +1,584 @@\n+//\n+//  ========================================================================\n+//  Copyright (c) 1995-2020 Mort Bay Consulting Pty Ltd and others.\n+//  ------------------------------------------------------------------------\n+//  All rights reserved. This program and the accompanying materials\n+//  are made available under the terms of the Eclipse Public License v1.0\n+//  and Apache License v2.0 which accompanies this distribution.\n+//\n+//      The Eclipse Public License is available at\n+//      http://www.eclipse.org/legal/epl-v10.html\n+//\n+//      The Apache License v2.0 is available at\n+//      http://www.opensource.org/licenses/apache2.0.php\n+//\n+//  You may elect to redistribute this code under either of these licenses.\n+//  ========================================================================\n+//\n+\n+package org.eclipse.jetty.server;\n+\n+import java.io.BufferedReader;\n+import java.io.InputStreamReader;\n+import java.io.PrintWriter;\n+import java.io.StringWriter;\n+import java.net.Socket;\n+import java.nio.ByteBuffer;\n+import java.nio.charset.StandardCharsets;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicReference;\n+import javax.net.ssl.SSLSocketFactory;\n+\n+import org.eclipse.jetty.http.HttpVersion;\n+import org.eclipse.jetty.io.ByteBufferPool;\n+import org.eclipse.jetty.io.Connection;\n+import org.eclipse.jetty.io.EndPoint;\n+import org.eclipse.jetty.toolchain.test.MavenTestingUtils;\n+import org.eclipse.jetty.util.BufferUtil;\n+import org.eclipse.jetty.util.Callback;\n+import org.eclipse.jetty.util.ssl.SslContextFactory;\n+import org.hamcrest.Matchers;\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.Test;\n+\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n+public class DetectorConnectionFactoryTest\n+{\n+    private Server _server;\n+    private AssertingByteBufferPool _assertingByteBufferPool;\n+\n+    // use this ByteBuffer leak detector to ensure that the byte buffers are properly disposed of by the detection mechanism.\n+    static class AssertingByteBufferPool implements ByteBufferPool\n+    {\n+        private final List<Entry> _bufferPool = new ArrayList<>();\n+\n+        public AssertingByteBufferPool(int poolSize)\n+        {\n+            for (int i = 0; i < poolSize; i++)\n+            {\n+                _bufferPool.add(new Entry(BufferUtil.allocateDirect(32768)));\n+            }\n+        }\n+\n+        @Override\n+        public ByteBuffer acquire(int size, boolean direct)\n+        {\n+            for (Entry entry : _bufferPool)\n+            {\n+                if (entry.acquired.compareAndSet(false, true))\n+                {\n+                    entry.acquisitionStack.set(new Exception(\"acquisition stack\"));\n+                    return entry.byteBuffer;\n+                }\n+            }\n+            throw new AssertionError(\"Could not find an available buffer\");\n+        }\n+\n+        @Override\n+        public void release(ByteBuffer buffer)\n+        {\n+            for (Entry entry : _bufferPool)\n+            {\n+                if (entry.byteBuffer == buffer)\n+                {\n+                    if (!entry.acquired.compareAndSet(true, false))\n+                        throw new AssertionError(\"Detected the release of a buffer that has already been released : \" + buffer);\n+                    entry.acquisitionStack.set(null);\n+                    return;\n+                }\n+            }\n+            throw new AssertionError(\"Detected the release of a buffer that is not part of the pool : \" + buffer);\n+        }\n+\n+        public boolean allBuffersWereReleased()\n+        {\n+            for (Entry entry : _bufferPool)\n+            {\n+                if (entry.acquired.get())\n+                    return false;\n+            }\n+            return true;\n+        }\n+\n+        public void assertAllBuffersWereReleased()\n+        {\n+            List<Entry> unreleasedBuffers = new ArrayList<>();\n+            for (Entry entry : _bufferPool)\n+            {\n+                if (entry.acquired.get())\n+                    unreleasedBuffers.add(entry);\n+            }\n+            if (!unreleasedBuffers.isEmpty())\n+                throw new AssertionError(\"Detected \" + unreleasedBuffers.size() + \" leaked buffers : \" + unreleasedBuffers);\n+        }\n+\n+        static class Entry\n+        {\n+            final AtomicBoolean acquired = new AtomicBoolean(); // true means available, false means acquired\n+            final ByteBuffer byteBuffer;\n+            final AtomicReference<Throwable> acquisitionStack = new AtomicReference<>();\n+\n+            public Entry(ByteBuffer byteBuffer)\n+            {\n+                this.byteBuffer = byteBuffer;\n+            }\n+\n+            @Override\n+            public String toString()\n+            {\n+                StringWriter sw = new StringWriter();\n+                PrintWriter pw = new PrintWriter(sw);\n+                acquisitionStack.get().printStackTrace(pw);\n+                pw.close();\n+                return byteBuffer + \"\\n\" + sw.toString();\n+            }\n+        }\n+    }\n+\n+    @AfterEach\n+    public void destroy() throws Exception\n+    {\n+        if (_server != null)\n+            _server.stop();\n+        if (_assertingByteBufferPool != null)\n+            _assertingByteBufferPool.assertAllBuffersWereReleased();\n+    }\n+\n+    private void start(ConnectionFactory... connectionFactories) throws Exception\n+    {\n+        _server = new Server();\n+        _assertingByteBufferPool = new AssertingByteBufferPool(100);\n+        _server.addBean(_assertingByteBufferPool);\n+        _server.addConnector(new ServerConnector(_server, 1, 1, connectionFactories));\n+        _server.setHandler(new DumpHandler());\n+        _server.start();\n+    }\n+\n+    private String getResponse(String request) throws Exception\n+    {\n+        try (Socket socket = new Socket(_server.getURI().getHost(), _server.getURI().getPort()))\n+        {\n+            socket.getOutputStream().write(request.getBytes(StandardCharsets.US_ASCII));\n+\n+            StringBuilder sb = new StringBuilder();\n+            BufferedReader reader = new BufferedReader(new InputStreamReader(socket.getInputStream(), StandardCharsets.US_ASCII));\n+\n+            while (true)\n+            {\n+                String line = reader.readLine();\n+                if (line == null)\n+                    break;\n+                sb.append(line).append(\"\\n\");\n+            }\n+\n+            return sb.length() == 0 ? null : sb.toString();\n+        }\n+    }\n+\n+    private String getResponseOverSsl(String request) throws Exception\n+    {\n+        String keystore = MavenTestingUtils.getTestResourceFile(\"keystore\").getAbsolutePath();\n+        SslContextFactory sslContextFactory = new SslContextFactory.Server();\n+        sslContextFactory.setKeyStorePath(keystore);\n+        sslContextFactory.setKeyStorePassword(\"storepwd\");\n+        sslContextFactory.setKeyManagerPassword(\"keypwd\");\n+        sslContextFactory.start();\n+\n+        SSLSocketFactory socketFactory = sslContextFactory.getSslContext().getSocketFactory();\n+        try (Socket socket = socketFactory.createSocket(_server.getURI().getHost(), _server.getURI().getPort()))\n+        {\n+            socket.getOutputStream().write(request.getBytes(StandardCharsets.US_ASCII));\n+\n+            StringBuilder sb = new StringBuilder();\n+            BufferedReader reader = new BufferedReader(new InputStreamReader(socket.getInputStream(), StandardCharsets.US_ASCII));\n+\n+            while (true)\n+            {\n+                String line = reader.readLine();\n+                if (line == null)\n+                    break;\n+                sb.append(line).append(\"\\n\");\n+            }\n+\n+            return sb.length() == 0 ? null : sb.toString();\n+        }\n+        finally\n+        {\n+            sslContextFactory.stop();\n+        }\n+    }\n+\n+    @Test\n+    public void testDetectingSslProxyToHttpNoSslNoProxy() throws Exception", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3c3795a69a85bdb7814c4d1d45dff5c4c8c7ffd2"}, "originalPosition": 218}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzE0OTA0MQ==", "bodyText": "Why there is an extra \\n at the end?", "url": "https://github.com/eclipse/jetty.project/pull/4519#discussion_r373149041", "createdAt": "2020-01-30T19:30:03Z", "author": {"login": "sbordet"}, "path": "jetty-server/src/test/java/org/eclipse/jetty/server/DetectorConnectionFactoryTest.java", "diffHunk": "@@ -0,0 +1,584 @@\n+//\n+//  ========================================================================\n+//  Copyright (c) 1995-2020 Mort Bay Consulting Pty Ltd and others.\n+//  ------------------------------------------------------------------------\n+//  All rights reserved. This program and the accompanying materials\n+//  are made available under the terms of the Eclipse Public License v1.0\n+//  and Apache License v2.0 which accompanies this distribution.\n+//\n+//      The Eclipse Public License is available at\n+//      http://www.eclipse.org/legal/epl-v10.html\n+//\n+//      The Apache License v2.0 is available at\n+//      http://www.opensource.org/licenses/apache2.0.php\n+//\n+//  You may elect to redistribute this code under either of these licenses.\n+//  ========================================================================\n+//\n+\n+package org.eclipse.jetty.server;\n+\n+import java.io.BufferedReader;\n+import java.io.InputStreamReader;\n+import java.io.PrintWriter;\n+import java.io.StringWriter;\n+import java.net.Socket;\n+import java.nio.ByteBuffer;\n+import java.nio.charset.StandardCharsets;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicReference;\n+import javax.net.ssl.SSLSocketFactory;\n+\n+import org.eclipse.jetty.http.HttpVersion;\n+import org.eclipse.jetty.io.ByteBufferPool;\n+import org.eclipse.jetty.io.Connection;\n+import org.eclipse.jetty.io.EndPoint;\n+import org.eclipse.jetty.toolchain.test.MavenTestingUtils;\n+import org.eclipse.jetty.util.BufferUtil;\n+import org.eclipse.jetty.util.Callback;\n+import org.eclipse.jetty.util.ssl.SslContextFactory;\n+import org.hamcrest.Matchers;\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.Test;\n+\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n+public class DetectorConnectionFactoryTest\n+{\n+    private Server _server;\n+    private AssertingByteBufferPool _assertingByteBufferPool;\n+\n+    // use this ByteBuffer leak detector to ensure that the byte buffers are properly disposed of by the detection mechanism.\n+    static class AssertingByteBufferPool implements ByteBufferPool\n+    {\n+        private final List<Entry> _bufferPool = new ArrayList<>();\n+\n+        public AssertingByteBufferPool(int poolSize)\n+        {\n+            for (int i = 0; i < poolSize; i++)\n+            {\n+                _bufferPool.add(new Entry(BufferUtil.allocateDirect(32768)));\n+            }\n+        }\n+\n+        @Override\n+        public ByteBuffer acquire(int size, boolean direct)\n+        {\n+            for (Entry entry : _bufferPool)\n+            {\n+                if (entry.acquired.compareAndSet(false, true))\n+                {\n+                    entry.acquisitionStack.set(new Exception(\"acquisition stack\"));\n+                    return entry.byteBuffer;\n+                }\n+            }\n+            throw new AssertionError(\"Could not find an available buffer\");\n+        }\n+\n+        @Override\n+        public void release(ByteBuffer buffer)\n+        {\n+            for (Entry entry : _bufferPool)\n+            {\n+                if (entry.byteBuffer == buffer)\n+                {\n+                    if (!entry.acquired.compareAndSet(true, false))\n+                        throw new AssertionError(\"Detected the release of a buffer that has already been released : \" + buffer);\n+                    entry.acquisitionStack.set(null);\n+                    return;\n+                }\n+            }\n+            throw new AssertionError(\"Detected the release of a buffer that is not part of the pool : \" + buffer);\n+        }\n+\n+        public boolean allBuffersWereReleased()\n+        {\n+            for (Entry entry : _bufferPool)\n+            {\n+                if (entry.acquired.get())\n+                    return false;\n+            }\n+            return true;\n+        }\n+\n+        public void assertAllBuffersWereReleased()\n+        {\n+            List<Entry> unreleasedBuffers = new ArrayList<>();\n+            for (Entry entry : _bufferPool)\n+            {\n+                if (entry.acquired.get())\n+                    unreleasedBuffers.add(entry);\n+            }\n+            if (!unreleasedBuffers.isEmpty())\n+                throw new AssertionError(\"Detected \" + unreleasedBuffers.size() + \" leaked buffers : \" + unreleasedBuffers);\n+        }\n+\n+        static class Entry\n+        {\n+            final AtomicBoolean acquired = new AtomicBoolean(); // true means available, false means acquired\n+            final ByteBuffer byteBuffer;\n+            final AtomicReference<Throwable> acquisitionStack = new AtomicReference<>();\n+\n+            public Entry(ByteBuffer byteBuffer)\n+            {\n+                this.byteBuffer = byteBuffer;\n+            }\n+\n+            @Override\n+            public String toString()\n+            {\n+                StringWriter sw = new StringWriter();\n+                PrintWriter pw = new PrintWriter(sw);\n+                acquisitionStack.get().printStackTrace(pw);\n+                pw.close();\n+                return byteBuffer + \"\\n\" + sw.toString();\n+            }\n+        }\n+    }\n+\n+    @AfterEach\n+    public void destroy() throws Exception\n+    {\n+        if (_server != null)\n+            _server.stop();\n+        if (_assertingByteBufferPool != null)\n+            _assertingByteBufferPool.assertAllBuffersWereReleased();\n+    }\n+\n+    private void start(ConnectionFactory... connectionFactories) throws Exception\n+    {\n+        _server = new Server();\n+        _assertingByteBufferPool = new AssertingByteBufferPool(100);\n+        _server.addBean(_assertingByteBufferPool);\n+        _server.addConnector(new ServerConnector(_server, 1, 1, connectionFactories));\n+        _server.setHandler(new DumpHandler());\n+        _server.start();\n+    }\n+\n+    private String getResponse(String request) throws Exception\n+    {\n+        try (Socket socket = new Socket(_server.getURI().getHost(), _server.getURI().getPort()))\n+        {\n+            socket.getOutputStream().write(request.getBytes(StandardCharsets.US_ASCII));\n+\n+            StringBuilder sb = new StringBuilder();\n+            BufferedReader reader = new BufferedReader(new InputStreamReader(socket.getInputStream(), StandardCharsets.US_ASCII));\n+\n+            while (true)\n+            {\n+                String line = reader.readLine();\n+                if (line == null)\n+                    break;\n+                sb.append(line).append(\"\\n\");\n+            }\n+\n+            return sb.length() == 0 ? null : sb.toString();\n+        }\n+    }\n+\n+    private String getResponseOverSsl(String request) throws Exception\n+    {\n+        String keystore = MavenTestingUtils.getTestResourceFile(\"keystore\").getAbsolutePath();\n+        SslContextFactory sslContextFactory = new SslContextFactory.Server();\n+        sslContextFactory.setKeyStorePath(keystore);\n+        sslContextFactory.setKeyStorePassword(\"storepwd\");\n+        sslContextFactory.setKeyManagerPassword(\"keypwd\");\n+        sslContextFactory.start();\n+\n+        SSLSocketFactory socketFactory = sslContextFactory.getSslContext().getSocketFactory();\n+        try (Socket socket = socketFactory.createSocket(_server.getURI().getHost(), _server.getURI().getPort()))\n+        {\n+            socket.getOutputStream().write(request.getBytes(StandardCharsets.US_ASCII));\n+\n+            StringBuilder sb = new StringBuilder();\n+            BufferedReader reader = new BufferedReader(new InputStreamReader(socket.getInputStream(), StandardCharsets.US_ASCII));\n+\n+            while (true)\n+            {\n+                String line = reader.readLine();\n+                if (line == null)\n+                    break;\n+                sb.append(line).append(\"\\n\");\n+            }\n+\n+            return sb.length() == 0 ? null : sb.toString();\n+        }\n+        finally\n+        {\n+            sslContextFactory.stop();\n+        }\n+    }\n+\n+    @Test\n+    public void testDetectingSslProxyToHttpNoSslNoProxy() throws Exception\n+    {\n+        String keystore = MavenTestingUtils.getTestResourceFile(\"keystore\").getAbsolutePath();\n+        SslContextFactory sslContextFactory = new SslContextFactory.Server();\n+        sslContextFactory.setKeyStorePath(keystore);\n+        sslContextFactory.setKeyStorePassword(\"storepwd\");\n+        sslContextFactory.setKeyManagerPassword(\"keypwd\");\n+\n+        ProxyConnectionFactory proxy = new ProxyConnectionFactory(HttpVersion.HTTP_1_1.asString());\n+        SslConnectionFactory ssl = new SslConnectionFactory(sslContextFactory, HttpVersion.HTTP_1_1.asString());\n+        DetectorConnectionFactory detector = new DetectorConnectionFactory(ssl, proxy);\n+        HttpConnectionFactory http = new HttpConnectionFactory();\n+\n+        start(detector, http);\n+\n+        String request = \"GET /path HTTP/1.1\\n\" +\n+            \"Host: server:80\\n\" +\n+            \"Connection: close\\n\" +\n+            \"\\n\";\n+        String response = getResponse(request);\n+\n+        assertThat(response, Matchers.containsString(\"HTTP/1.1 200\"));\n+    }\n+\n+    @Test\n+    public void testDetectingSslProxyToHttpNoSslWithProxy() throws Exception\n+    {\n+        String keystore = MavenTestingUtils.getTestResourceFile(\"keystore\").getAbsolutePath();\n+        SslContextFactory sslContextFactory = new SslContextFactory.Server();\n+        sslContextFactory.setKeyStorePath(keystore);\n+        sslContextFactory.setKeyStorePassword(\"storepwd\");\n+        sslContextFactory.setKeyManagerPassword(\"keypwd\");\n+\n+        ProxyConnectionFactory proxy = new ProxyConnectionFactory(HttpVersion.HTTP_1_1.asString());\n+        SslConnectionFactory ssl = new SslConnectionFactory(sslContextFactory, HttpVersion.HTTP_1_1.asString());\n+        DetectorConnectionFactory detector = new DetectorConnectionFactory(ssl, proxy);\n+        HttpConnectionFactory http = new HttpConnectionFactory();\n+\n+        start(detector, http);\n+\n+        String request = \"PROXY TCP 1.2.3.4 5.6.7.8 111 222\\r\\n\" +\n+            \"GET /path HTTP/1.1\\n\" +\n+            \"Host: server:80\\n\" +\n+            \"Connection: close\\n\" +\n+            \"\\n\";\n+        String response = getResponse(request);\n+\n+        assertThat(response, Matchers.containsString(\"HTTP/1.1 200\"));\n+        assertThat(response, Matchers.containsString(\"pathInfo=/path\"));\n+        assertThat(response, Matchers.containsString(\"local=5.6.7.8:222\"));\n+        assertThat(response, Matchers.containsString(\"remote=1.2.3.4:111\"));\n+    }\n+\n+    @Test\n+    public void testDetectingSslProxyToHttpWithSslNoProxy() throws Exception\n+    {\n+        String keystore = MavenTestingUtils.getTestResourceFile(\"keystore\").getAbsolutePath();\n+        SslContextFactory sslContextFactory = new SslContextFactory.Server();\n+        sslContextFactory.setKeyStorePath(keystore);\n+        sslContextFactory.setKeyStorePassword(\"storepwd\");\n+        sslContextFactory.setKeyManagerPassword(\"keypwd\");\n+\n+        ProxyConnectionFactory proxy = new ProxyConnectionFactory(HttpVersion.HTTP_1_1.asString());\n+        SslConnectionFactory ssl = new SslConnectionFactory(sslContextFactory, HttpVersion.HTTP_1_1.asString());\n+        DetectorConnectionFactory detector = new DetectorConnectionFactory(ssl, proxy);\n+        HttpConnectionFactory http = new HttpConnectionFactory();\n+\n+        start(detector, http);\n+\n+        String request = \"GET /path HTTP/1.1\\n\" +\n+            \"Host: server:80\\n\" +\n+            \"Connection: close\\n\" +\n+            \"\\n\";\n+        String response = getResponseOverSsl(request);\n+\n+        assertThat(response, Matchers.containsString(\"HTTP/1.1 200\"));\n+    }\n+\n+    @Test\n+    public void testDetectingSslProxyToHttpWithSslWithProxy() throws Exception\n+    {\n+        String keystore = MavenTestingUtils.getTestResourceFile(\"keystore\").getAbsolutePath();\n+        SslContextFactory sslContextFactory = new SslContextFactory.Server();\n+        sslContextFactory.setKeyStorePath(keystore);\n+        sslContextFactory.setKeyStorePassword(\"storepwd\");\n+        sslContextFactory.setKeyManagerPassword(\"keypwd\");\n+\n+        ProxyConnectionFactory proxy = new ProxyConnectionFactory(HttpVersion.HTTP_1_1.asString());\n+        SslConnectionFactory ssl = new SslConnectionFactory(sslContextFactory, HttpVersion.HTTP_1_1.asString());\n+        DetectorConnectionFactory detector = new DetectorConnectionFactory(ssl, proxy);\n+        HttpConnectionFactory http = new HttpConnectionFactory();\n+\n+        start(detector, http);\n+\n+        String request = \"PROXY TCP 1.2.3.4 5.6.7.8 111 222\\r\\n\" +\n+            \"GET /path HTTP/1.1\\n\" +\n+            \"Host: server:80\\n\" +\n+            \"Connection: close\\n\" +\n+            \"\\n\";\n+        String response = getResponseOverSsl(request);\n+\n+        // SSL matched, so the upgrade was made to HTTP which does not understand the proxy request\n+        assertThat(response, Matchers.containsString(\"HTTP/1.1 400\"));\n+    }\n+\n+    @Test\n+    void testDetectorToNextDetector() throws Exception\n+    {\n+        String keystore = MavenTestingUtils.getTestResourceFile(\"keystore\").getAbsolutePath();\n+        SslContextFactory sslContextFactory = new SslContextFactory.Server();\n+        sslContextFactory.setKeyStorePath(keystore);\n+        sslContextFactory.setKeyStorePassword(\"storepwd\");\n+        sslContextFactory.setKeyManagerPassword(\"keypwd\");\n+\n+        ProxyConnectionFactory proxy = new ProxyConnectionFactory(HttpVersion.HTTP_1_1.asString());\n+        DetectorConnectionFactory proxyDetector = new DetectorConnectionFactory(proxy);\n+        SslConnectionFactory ssl = new SslConnectionFactory(sslContextFactory, proxyDetector.getProtocol());\n+        DetectorConnectionFactory sslDetector = new DetectorConnectionFactory(ssl);\n+        HttpConnectionFactory http = new HttpConnectionFactory();\n+\n+        start(sslDetector, proxyDetector, http);\n+\n+        String request = \"PROXY TCP 1.2.3.4 5.6.7.8 111 222\\r\\n\" +\n+            \"GET /path HTTP/1.1\\n\" +\n+            \"Host: server:80\\n\" +\n+            \"Connection: close\\n\" +\n+            \"\\n\";\n+        String response = getResponseOverSsl(request);\n+\n+        // SSL matched, so the upgrade was made to proxy which itself upgraded to HTTP\n+        assertThat(response, Matchers.containsString(\"HTTP/1.1 200\"));\n+        assertThat(response, Matchers.containsString(\"pathInfo=/path\"));\n+        assertThat(response, Matchers.containsString(\"local=5.6.7.8:222\"));\n+        assertThat(response, Matchers.containsString(\"remote=1.2.3.4:111\"));\n+    }\n+\n+    @Test\n+    void testDetectorWithDetectionUnsuccessfulLambda() throws Exception\n+    {\n+        AtomicBoolean detectionSuccessful = new AtomicBoolean(true);\n+        ProxyConnectionFactory proxy = new ProxyConnectionFactory(HttpVersion.HTTP_1_1.asString());\n+        DetectorConnectionFactory detector = new DetectorConnectionFactory((connector, endPoint, buffer) ->\n+        {\n+            if (!detectionSuccessful.compareAndSet(true, false))\n+                throw new AssertionError(\"DetectionUnsuccessful callback should only have been called once\");\n+\n+            // omitting this will leak the buffer\n+            connector.getByteBufferPool().release(buffer);\n+\n+            Callback.Completable completable = new Callback.Completable();\n+            endPoint.write(completable, ByteBuffer.wrap(\"No upgrade for you\".getBytes(StandardCharsets.US_ASCII)));\n+            completable.whenComplete((r, x) -> endPoint.close());\n+        }, proxy);\n+        HttpConnectionFactory http = new HttpConnectionFactory();\n+\n+        start(detector, http);\n+\n+        String request = \"GET /path HTTP/1.1\\n\" +\n+            \"Host: server:80\\n\" +\n+            \"Connection: close\\n\" +\n+            \"\\n\";\n+        String response = getResponse(request);\n+\n+        assertEquals(\"No upgrade for you\\n\", response);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3c3795a69a85bdb7814c4d1d45dff5c4c8c7ffd2"}, "originalPosition": 381}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "a601cac8c9093b3356c9a50e9ba2faff937b3395", "author": {"user": {"login": "lorban", "name": "Ludovic Orban"}}, "url": "https://github.com/eclipse/jetty.project/commit/a601cac8c9093b3356c9a50e9ba2faff937b3395", "committedDate": "2020-01-31T10:18:28Z", "message": "refactor ProxyConnectionFactory to make use of upgradeToProtocol() utility\n\nSigned-off-by: Ludovic Orban <lorban@bitronix.be>"}, "afterCommit": {"oid": "559eb525afbd61dba26b8bf63b42e8b44353961e", "author": {"user": {"login": "lorban", "name": "Ludovic Orban"}}, "url": "https://github.com/eclipse/jetty.project/commit/559eb525afbd61dba26b8bf63b42e8b44353961e", "committedDate": "2020-01-31T10:44:58Z", "message": "refactor ProxyConnectionFactory to make use of common upgrade code\n\nSigned-off-by: Ludovic Orban <lorban@bitronix.be>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "290cc3cc98b4005b680745213c4be1e3d9739ed4", "author": {"user": {"login": "lorban", "name": "Ludovic Orban"}}, "url": "https://github.com/eclipse/jetty.project/commit/290cc3cc98b4005b680745213c4be1e3d9739ed4", "committedDate": "2020-01-31T16:05:24Z", "message": "add debug logs\n\nSigned-off-by: Ludovic Orban <lorban@bitronix.be>"}, "afterCommit": {"oid": "6af519bbc641de69dfeff5143e0324a0b83f3372", "author": {"user": {"login": "lorban", "name": "Ludovic Orban"}}, "url": "https://github.com/eclipse/jetty.project/commit/6af519bbc641de69dfeff5143e0324a0b83f3372", "committedDate": "2020-01-31T16:07:34Z", "message": "Implement detector connection factory with protocol detection mechanism\n\nSigned-off-by: Ludovic Orban <lorban@bitronix.be>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzUxODcyNzUx", "url": "https://github.com/eclipse/jetty.project/pull/4519#pullrequestreview-351872751", "createdAt": "2020-02-01T08:23:28Z", "commit": {"oid": "6af519bbc641de69dfeff5143e0324a0b83f3372"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wMVQwODoyMzoyOVrOFkc5Iw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wMVQwODoyNDoyN1rOFkc5Pg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Mzc2NjQzNQ==", "bodyText": "If more than one factory returns RECOGNIZED, should that instead be treated as NEED_MORE_BYTES?  This way an individual factory does not need to know how many bytes are required to disambiguate from other protocols.", "url": "https://github.com/eclipse/jetty.project/pull/4519#discussion_r373766435", "createdAt": "2020-02-01T08:23:29Z", "author": {"login": "gregw"}, "path": "jetty-server/src/main/java/org/eclipse/jetty/server/DetectorConnectionFactory.java", "diffHunk": "@@ -0,0 +1,293 @@\n+//\n+//  ========================================================================\n+//  Copyright (c) 1995-2020 Mort Bay Consulting Pty Ltd and others.\n+//  ------------------------------------------------------------------------\n+//  All rights reserved. This program and the accompanying materials\n+//  are made available under the terms of the Eclipse Public License v1.0\n+//  and Apache License v2.0 which accompanies this distribution.\n+//\n+//      The Eclipse Public License is available at\n+//      http://www.eclipse.org/legal/epl-v10.html\n+//\n+//      The Apache License v2.0 is available at\n+//      http://www.opensource.org/licenses/apache2.0.php\n+//\n+//  You may elect to redistribute this code under either of these licenses.\n+//  ========================================================================\n+//\n+\n+package org.eclipse.jetty.server;\n+\n+import java.nio.ByteBuffer;\n+import java.util.Arrays;\n+import java.util.LinkedHashSet;\n+import java.util.List;\n+\n+import org.eclipse.jetty.io.AbstractConnection;\n+import org.eclipse.jetty.io.Connection;\n+import org.eclipse.jetty.io.EndPoint;\n+import org.eclipse.jetty.util.BufferUtil;\n+import org.eclipse.jetty.util.log.Log;\n+import org.eclipse.jetty.util.log.Logger;\n+\n+/**\n+ * A {@link ConnectionFactory} combining multiple {@link Detecting} instances that will upgrade to\n+ * the first one recognizing the bytes in the buffer.\n+ */\n+public class DetectorConnectionFactory extends AbstractConnectionFactory\n+{\n+    private static final Logger LOG = Log.getLogger(DetectorConnectionFactory.class);\n+\n+    protected final List<Detecting> _detectingConnectionFactories;\n+\n+    /**\n+     * <p>When the first bytes are not recognized by the {@code detectingConnectionFactories}, the default behavior is to\n+     * upgrade to the protocol returned by {@link #findNextProtocol(Connector)}.</p>\n+     * @param detectingConnectionFactories the {@link Detecting} instances.\n+     */\n+    public DetectorConnectionFactory(Detecting... detectingConnectionFactories)\n+    {\n+        super(toProtocolString(detectingConnectionFactories));\n+        _detectingConnectionFactories = Arrays.asList(detectingConnectionFactories);\n+        for (Detecting detectingConnectionFactory : detectingConnectionFactories)\n+        {\n+            addBean(detectingConnectionFactory);\n+        }\n+    }\n+\n+    static String toProtocolString(Detecting... detectingConnectionFactories)\n+    {\n+        if (detectingConnectionFactories.length == 0)\n+            throw new IllegalStateException(\"At least one detecting instance is required\");\n+\n+        // remove protocol duplicates while keeping their ordering -> use LinkedHashSet\n+        LinkedHashSet<String> protocols = new LinkedHashSet<>();\n+        for (Detecting dcf : detectingConnectionFactories)\n+        {\n+            protocols.add(dcf.getProtocol());\n+        }\n+\n+        StringBuilder sb = new StringBuilder();\n+        for (String protocol : protocols)\n+        {\n+            sb.append(protocol).append('|');\n+        }\n+        sb.deleteCharAt(sb.length() - 1);\n+        String protocol = sb.toString();\n+        LOG.debug(\"Detector generated protocol name : {}\", protocol);\n+        return protocol;\n+    }\n+\n+    /**\n+     * Perform a detection using multiple {@code detectingConnectionFactories} and return the aggregated outcome.\n+     * @param buffer the buffer to perform a detection against.\n+     * @param detectingConnectionFactories the {@link Detecting} instances.\n+     * @return A {@link Detecting.Detection} value with the detection outcome of the {@code detectingConnectionFactories}.\n+     */\n+    protected static Detecting.Detection detectUsing(ByteBuffer buffer, Iterable<Detecting> detectingConnectionFactories)\n+    {\n+        LOG.debug(\"Attempting detection from buffer {} using {}\", buffer, detectingConnectionFactories);\n+        boolean allDetectionNotRecognized = true;\n+        for (Detecting detectingConnectionFactory : detectingConnectionFactories)\n+        {\n+            Detecting.Detection detection = detectingConnectionFactory.detect(buffer);\n+            if (detection == Detecting.Detection.RECOGNIZED)\n+            {\n+                LOG.debug(\"Detection recognized bytes from buffer {} using {}\", buffer, detectingConnectionFactories);\n+                return Detecting.Detection.RECOGNIZED;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6af519bbc641de69dfeff5143e0324a0b83f3372"}, "originalPosition": 97}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Mzc2NjQ2Mg==", "bodyText": "Once a factory says not recognized, should it be removed from the list for further iterations?", "url": "https://github.com/eclipse/jetty.project/pull/4519#discussion_r373766462", "createdAt": "2020-02-01T08:24:27Z", "author": {"login": "gregw"}, "path": "jetty-server/src/main/java/org/eclipse/jetty/server/DetectorConnectionFactory.java", "diffHunk": "@@ -0,0 +1,293 @@\n+//\n+//  ========================================================================\n+//  Copyright (c) 1995-2020 Mort Bay Consulting Pty Ltd and others.\n+//  ------------------------------------------------------------------------\n+//  All rights reserved. This program and the accompanying materials\n+//  are made available under the terms of the Eclipse Public License v1.0\n+//  and Apache License v2.0 which accompanies this distribution.\n+//\n+//      The Eclipse Public License is available at\n+//      http://www.eclipse.org/legal/epl-v10.html\n+//\n+//      The Apache License v2.0 is available at\n+//      http://www.opensource.org/licenses/apache2.0.php\n+//\n+//  You may elect to redistribute this code under either of these licenses.\n+//  ========================================================================\n+//\n+\n+package org.eclipse.jetty.server;\n+\n+import java.nio.ByteBuffer;\n+import java.util.Arrays;\n+import java.util.LinkedHashSet;\n+import java.util.List;\n+\n+import org.eclipse.jetty.io.AbstractConnection;\n+import org.eclipse.jetty.io.Connection;\n+import org.eclipse.jetty.io.EndPoint;\n+import org.eclipse.jetty.util.BufferUtil;\n+import org.eclipse.jetty.util.log.Log;\n+import org.eclipse.jetty.util.log.Logger;\n+\n+/**\n+ * A {@link ConnectionFactory} combining multiple {@link Detecting} instances that will upgrade to\n+ * the first one recognizing the bytes in the buffer.\n+ */\n+public class DetectorConnectionFactory extends AbstractConnectionFactory\n+{\n+    private static final Logger LOG = Log.getLogger(DetectorConnectionFactory.class);\n+\n+    protected final List<Detecting> _detectingConnectionFactories;\n+\n+    /**\n+     * <p>When the first bytes are not recognized by the {@code detectingConnectionFactories}, the default behavior is to\n+     * upgrade to the protocol returned by {@link #findNextProtocol(Connector)}.</p>\n+     * @param detectingConnectionFactories the {@link Detecting} instances.\n+     */\n+    public DetectorConnectionFactory(Detecting... detectingConnectionFactories)\n+    {\n+        super(toProtocolString(detectingConnectionFactories));\n+        _detectingConnectionFactories = Arrays.asList(detectingConnectionFactories);\n+        for (Detecting detectingConnectionFactory : detectingConnectionFactories)\n+        {\n+            addBean(detectingConnectionFactory);\n+        }\n+    }\n+\n+    static String toProtocolString(Detecting... detectingConnectionFactories)\n+    {\n+        if (detectingConnectionFactories.length == 0)\n+            throw new IllegalStateException(\"At least one detecting instance is required\");\n+\n+        // remove protocol duplicates while keeping their ordering -> use LinkedHashSet\n+        LinkedHashSet<String> protocols = new LinkedHashSet<>();\n+        for (Detecting dcf : detectingConnectionFactories)\n+        {\n+            protocols.add(dcf.getProtocol());\n+        }\n+\n+        StringBuilder sb = new StringBuilder();\n+        for (String protocol : protocols)\n+        {\n+            sb.append(protocol).append('|');\n+        }\n+        sb.deleteCharAt(sb.length() - 1);\n+        String protocol = sb.toString();\n+        LOG.debug(\"Detector generated protocol name : {}\", protocol);\n+        return protocol;\n+    }\n+\n+    /**\n+     * Perform a detection using multiple {@code detectingConnectionFactories} and return the aggregated outcome.\n+     * @param buffer the buffer to perform a detection against.\n+     * @param detectingConnectionFactories the {@link Detecting} instances.\n+     * @return A {@link Detecting.Detection} value with the detection outcome of the {@code detectingConnectionFactories}.\n+     */\n+    protected static Detecting.Detection detectUsing(ByteBuffer buffer, Iterable<Detecting> detectingConnectionFactories)\n+    {\n+        LOG.debug(\"Attempting detection from buffer {} using {}\", buffer, detectingConnectionFactories);\n+        boolean allDetectionNotRecognized = true;\n+        for (Detecting detectingConnectionFactory : detectingConnectionFactories)\n+        {\n+            Detecting.Detection detection = detectingConnectionFactory.detect(buffer);\n+            if (detection == Detecting.Detection.RECOGNIZED)\n+            {\n+                LOG.debug(\"Detection recognized bytes from buffer {} using {}\", buffer, detectingConnectionFactories);\n+                return Detecting.Detection.RECOGNIZED;\n+            }\n+            allDetectionNotRecognized &= detection == Detecting.Detection.NOT_RECOGNIZED;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6af519bbc641de69dfeff5143e0324a0b83f3372"}, "originalPosition": 99}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "9ffaf7e3b2f5da790e9c3432dc255bb5a39a1222", "author": {"user": {"login": "lorban", "name": "Ludovic Orban"}}, "url": "https://github.com/eclipse/jetty.project/commit/9ffaf7e3b2f5da790e9c3432dc255bb5a39a1222", "committedDate": "2020-02-03T11:37:39Z", "message": "release the buffer when the connection gets closed unexpectedly\n\nSigned-off-by: Ludovic Orban <lorban@bitronix.be>"}, "afterCommit": {"oid": "0fd060c89b19f17071b1666552cf9e7028d00643", "author": {"user": {"login": "lorban", "name": "Ludovic Orban"}}, "url": "https://github.com/eclipse/jetty.project/commit/0fd060c89b19f17071b1666552cf9e7028d00643", "committedDate": "2020-02-03T15:49:23Z", "message": "Implement detector connection factory with protocol detection mechanism\n\nSigned-off-by: Ludovic Orban <lorban@bitronix.be>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "75b47195927b1cf9f2e33dcb1838acfa675714ec", "author": {"user": {"login": "lorban", "name": "Ludovic Orban"}}, "url": "https://github.com/eclipse/jetty.project/commit/75b47195927b1cf9f2e33dcb1838acfa675714ec", "committedDate": "2020-02-03T15:56:53Z", "message": "Implement detector connection factory with protocol detection mechanism\n\nSigned-off-by: Ludovic Orban <lorban@bitronix.be>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "0fd060c89b19f17071b1666552cf9e7028d00643", "author": {"user": {"login": "lorban", "name": "Ludovic Orban"}}, "url": "https://github.com/eclipse/jetty.project/commit/0fd060c89b19f17071b1666552cf9e7028d00643", "committedDate": "2020-02-03T15:49:23Z", "message": "Implement detector connection factory with protocol detection mechanism\n\nSigned-off-by: Ludovic Orban <lorban@bitronix.be>"}, "afterCommit": {"oid": "75b47195927b1cf9f2e33dcb1838acfa675714ec", "author": {"user": {"login": "lorban", "name": "Ludovic Orban"}}, "url": "https://github.com/eclipse/jetty.project/commit/75b47195927b1cf9f2e33dcb1838acfa675714ec", "committedDate": "2020-02-03T15:56:53Z", "message": "Implement detector connection factory with protocol detection mechanism\n\nSigned-off-by: Ludovic Orban <lorban@bitronix.be>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "37edc016d2d3f4c006b5f5835b75fa019080a421", "author": {"user": {"login": "lorban", "name": "Ludovic Orban"}}, "url": "https://github.com/eclipse/jetty.project/commit/37edc016d2d3f4c006b5f5835b75fa019080a421", "committedDate": "2020-02-04T08:21:41Z", "message": "improve debug logs\n\nSigned-off-by: Ludovic Orban <lorban@bitronix.be>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzUyODM1Mzk4", "url": "https://github.com/eclipse/jetty.project/pull/4519#pullrequestreview-352835398", "createdAt": "2020-02-04T09:38:51Z", "commit": {"oid": "75b47195927b1cf9f2e33dcb1838acfa675714ec"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNFQwOTozODo1MVrOFlNhzA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNFQwOTozODo1MVrOFlNhzA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDU2MzI3Ng==", "bodyText": "Please add an early return testing for BufferUtil.isEmpty(_buffer).", "url": "https://github.com/eclipse/jetty.project/pull/4519#discussion_r374563276", "createdAt": "2020-02-04T09:38:51Z", "author": {"login": "sbordet"}, "path": "jetty-server/src/main/java/org/eclipse/jetty/server/DetectorConnectionFactory.java", "diffHunk": "@@ -0,0 +1,294 @@\n+//\n+//  ========================================================================\n+//  Copyright (c) 1995-2020 Mort Bay Consulting Pty Ltd and others.\n+//  ------------------------------------------------------------------------\n+//  All rights reserved. This program and the accompanying materials\n+//  are made available under the terms of the Eclipse Public License v1.0\n+//  and Apache License v2.0 which accompanies this distribution.\n+//\n+//      The Eclipse Public License is available at\n+//      http://www.eclipse.org/legal/epl-v10.html\n+//\n+//      The Apache License v2.0 is available at\n+//      http://www.opensource.org/licenses/apache2.0.php\n+//\n+//  You may elect to redistribute this code under either of these licenses.\n+//  ========================================================================\n+//\n+\n+package org.eclipse.jetty.server;\n+\n+import java.nio.ByteBuffer;\n+import java.util.Arrays;\n+import java.util.LinkedHashSet;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+import org.eclipse.jetty.io.AbstractConnection;\n+import org.eclipse.jetty.io.Connection;\n+import org.eclipse.jetty.io.EndPoint;\n+import org.eclipse.jetty.util.BufferUtil;\n+import org.eclipse.jetty.util.log.Log;\n+import org.eclipse.jetty.util.log.Logger;\n+\n+/**\n+ * A {@link ConnectionFactory} combining multiple {@link Detecting} instances that will upgrade to\n+ * the first one recognizing the bytes in the buffer.\n+ */\n+public class DetectorConnectionFactory extends AbstractConnectionFactory implements ConnectionFactory.Detecting\n+{\n+    private static final Logger LOG = Log.getLogger(DetectorConnectionFactory.class);\n+\n+    private final List<Detecting> _detectingConnectionFactories;\n+\n+    /**\n+     * <p>When the first bytes are not recognized by the {@code detectingConnectionFactories}, the default behavior is to\n+     * upgrade to the protocol returned by {@link #findNextProtocol(Connector)}.</p>\n+     * @param detectingConnectionFactories the {@link Detecting} instances.\n+     */\n+    public DetectorConnectionFactory(Detecting... detectingConnectionFactories)\n+    {\n+        super(toProtocolString(detectingConnectionFactories));\n+        _detectingConnectionFactories = Arrays.asList(detectingConnectionFactories);\n+        for (Detecting detectingConnectionFactory : detectingConnectionFactories)\n+        {\n+            addBean(detectingConnectionFactory);\n+        }\n+    }\n+\n+    private static String toProtocolString(Detecting... detectingConnectionFactories)\n+    {\n+        if (detectingConnectionFactories.length == 0)\n+            throw new IllegalArgumentException(\"At least one detecting instance is required\");\n+\n+        // remove protocol duplicates while keeping their ordering -> use LinkedHashSet\n+        LinkedHashSet<String> protocols = Arrays.stream(detectingConnectionFactories).map(ConnectionFactory::getProtocol).collect(Collectors.toCollection(LinkedHashSet::new));\n+\n+        String protocol = String.join(\"|\", protocols);\n+        if (LOG.isDebugEnabled())\n+            LOG.debug(\"Detector generated protocol name : {}\", protocol);\n+        return protocol;\n+    }\n+\n+    /**\n+     * Performs a detection using multiple {@link ConnectionFactory.Detecting} instances and returns the aggregated outcome.\n+     * @param buffer the buffer to perform a detection against.\n+     * @return A {@link Detecting.Detection} value with the detection outcome of the {@code detectingConnectionFactories}.\n+     */\n+    @Override\n+    public Detecting.Detection detect(ByteBuffer buffer)\n+    {\n+        if (LOG.isDebugEnabled())\n+            LOG.debug(\"Attempting detection from buffer {} using {}\", buffer, _detectingConnectionFactories);\n+        boolean needMoreBytes = true;\n+        for (Detecting detectingConnectionFactory : _detectingConnectionFactories)\n+        {\n+            Detecting.Detection detection = detectingConnectionFactory.detect(buffer);\n+            if (detection == Detecting.Detection.RECOGNIZED)\n+            {\n+                if (LOG.isDebugEnabled())\n+                    LOG.debug(\"Detection recognized bytes from buffer {} using {}\", buffer, _detectingConnectionFactories);\n+                return Detecting.Detection.RECOGNIZED;\n+            }\n+            needMoreBytes &= detection == Detection.NEED_MORE_BYTES;\n+        }\n+        if (LOG.isDebugEnabled())\n+            LOG.debug(\"Detection {} from buffer {} using {}\", (needMoreBytes ? \"requires more bytes\" : \"not recognized\"), buffer, _detectingConnectionFactories);\n+        return needMoreBytes ? Detection.NEED_MORE_BYTES : Detection.NOT_RECOGNIZED;\n+    }\n+\n+    /**\n+     * Utility method that performs an upgrade to the specified connection factory, disposing of the given resources when needed.\n+     * @param connectionFactory the connection factory to upgrade to.\n+     * @param connector the connector.\n+     * @param endPoint the endpoint.\n+     */\n+    protected static void upgradeToConnectionFactory(ConnectionFactory connectionFactory, Connector connector, EndPoint endPoint) throws IllegalStateException\n+    {\n+        if (LOG.isDebugEnabled())\n+            LOG.debug(\"Upgrading to connection factory {}\", connectionFactory);\n+        if (connectionFactory == null)\n+            throw new IllegalStateException(\"Cannot upgrade: connection factory must not be null for \" + endPoint);\n+        Connection nextConnection = connectionFactory.newConnection(connector, endPoint);\n+        if (!(nextConnection instanceof Connection.UpgradeTo))\n+            throw new IllegalStateException(\"Cannot upgrade: \" + nextConnection + \" does not implement \" + Connection.UpgradeTo.class.getName() + \" for \" + endPoint);\n+        endPoint.upgrade(nextConnection);\n+        if (LOG.isDebugEnabled())\n+            LOG.debug(\"Upgraded to connection factory {} and released buffer\", connectionFactory);\n+    }\n+\n+    /**\n+     * <p>Callback method called when detection was unsuccessful.\n+     * This implementation upgrades to the protocol returned by {@link #findNextProtocol(Connector)}.</p>\n+     * @param connector the connector.\n+     * @param endPoint the endpoint.\n+     * @param buffer the buffer.\n+     */\n+    protected void nextProtocol(Connector connector, EndPoint endPoint, ByteBuffer buffer) throws IllegalStateException\n+    {\n+        String nextProtocol = findNextProtocol(connector);\n+        if (LOG.isDebugEnabled())\n+            LOG.debug(\"Detector {} detection unsuccessful, found '{}' as the next protocol to upgrade to\", getProtocol(), nextProtocol);\n+        if (nextProtocol == null)\n+            throw new IllegalStateException(\"Cannot find protocol following '\" + getProtocol() + \"' in connector's protocol list \" + connector.getProtocols() + \" for \" + endPoint);\n+        upgradeToConnectionFactory(connector.getConnectionFactory(nextProtocol), connector, endPoint);\n+    }\n+\n+    @Override\n+    public Connection newConnection(Connector connector, EndPoint endPoint)\n+    {\n+        return configure(new DetectorConnection(endPoint, connector), connector, endPoint);\n+    }\n+\n+    private class DetectorConnection extends AbstractConnection implements Connection.UpgradeFrom, Connection.UpgradeTo\n+    {\n+        private final Connector _connector;\n+        private final ByteBuffer _buffer;\n+\n+        private DetectorConnection(EndPoint endp, Connector connector)\n+        {\n+            super(endp, connector.getExecutor());\n+            _connector = connector;\n+            _buffer = connector.getByteBufferPool().acquire(getInputBufferSize(), true);\n+        }\n+\n+        @Override\n+        public void onUpgradeTo(ByteBuffer prefilled)\n+        {\n+            if (LOG.isDebugEnabled())\n+                LOG.debug(\"Detector {} copying prefilled buffer {}\", getProtocol(), BufferUtil.toDetailString(prefilled));\n+            if (BufferUtil.hasContent(prefilled))\n+                BufferUtil.append(_buffer, prefilled);\n+        }\n+\n+        @Override\n+        public ByteBuffer onUpgradeFrom()\n+        {\n+            return _buffer;\n+        }\n+\n+        @Override\n+        public void onOpen()\n+        {\n+            super.onOpen();\n+            if (!detectAndUpgrade())\n+                fillInterested();\n+        }\n+\n+        @Override\n+        public void onFillable()\n+        {\n+            try\n+            {\n+                while (BufferUtil.space(_buffer) > 0)\n+                {\n+                    // Read data\n+                    int fill = getEndPoint().fill(_buffer);\n+                    if (LOG.isDebugEnabled())\n+                        LOG.debug(\"Detector {} filled buffer with {} bytes\", getProtocol(), fill);\n+                    if (fill < 0)\n+                    {\n+                        _connector.getByteBufferPool().release(_buffer);\n+                        getEndPoint().shutdownOutput();\n+                        return;\n+                    }\n+                    if (fill == 0)\n+                    {\n+                        fillInterested();\n+                        return;\n+                    }\n+\n+                    if (detectAndUpgrade())\n+                        return;\n+                }\n+\n+                // all Detecting instances want more bytes than this buffer can store\n+                LOG.warn(\"Detector {} failed to detect upgrade target on {} for {}\", getProtocol(), _detectingConnectionFactories, getEndPoint());\n+                releaseAndClose();\n+            }\n+            catch (Throwable x)\n+            {\n+                LOG.warn(\"Detector {} error for {}\", getProtocol(), getEndPoint(), x);\n+                releaseAndClose();\n+            }\n+        }\n+\n+        /**\n+         * @return true when upgrade was performed, false otherwise.\n+         */\n+        private boolean detectAndUpgrade()\n+        {\n+            if (LOG.isDebugEnabled())\n+                LOG.debug(\"Detector {} performing detection with {} bytes\", getProtocol(), _buffer.remaining());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "75b47195927b1cf9f2e33dcb1838acfa675714ec"}, "originalPosition": 222}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "58b1db610c96befe7c0d3eca7c57a07eb7be7cc7", "author": {"user": {"login": "lorban", "name": "Ludovic Orban"}}, "url": "https://github.com/eclipse/jetty.project/commit/58b1db610c96befe7c0d3eca7c57a07eb7be7cc7", "committedDate": "2020-02-04T09:49:27Z", "message": "detectAndUpgrade() shortcut on empty buffer\n\nSigned-off-by: Ludovic Orban <lorban@bitronix.be>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzUyODQ3NDc3", "url": "https://github.com/eclipse/jetty.project/pull/4519#pullrequestreview-352847477", "createdAt": "2020-02-04T09:56:29Z", "commit": {"oid": "c113c77e1cc022d54715ebca824955e1928a18f7"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "c113c77e1cc022d54715ebca824955e1928a18f7", "author": {"user": {"login": "lorban", "name": "Ludovic Orban"}}, "url": "https://github.com/eclipse/jetty.project/commit/c113c77e1cc022d54715ebca824955e1928a18f7", "committedDate": "2020-02-04T09:50:24Z", "message": "change the format of detector's generated protocol name\n\nSigned-off-by: Ludovic Orban <lorban@bitronix.be>"}, "afterCommit": {"oid": "c6c84aa453e65e0eb06ca3b8cf728eb584ecbdef", "author": {"user": {"login": "lorban", "name": "Ludovic Orban"}}, "url": "https://github.com/eclipse/jetty.project/commit/c6c84aa453e65e0eb06ca3b8cf728eb584ecbdef", "committedDate": "2020-02-04T11:21:02Z", "message": "change the format of detector's generated protocol name\n\nSigned-off-by: Ludovic Orban <lorban@bitronix.be>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "c6c84aa453e65e0eb06ca3b8cf728eb584ecbdef", "author": {"user": {"login": "lorban", "name": "Ludovic Orban"}}, "url": "https://github.com/eclipse/jetty.project/commit/c6c84aa453e65e0eb06ca3b8cf728eb584ecbdef", "committedDate": "2020-02-04T11:21:02Z", "message": "change the format of detector's generated protocol name\n\nSigned-off-by: Ludovic Orban <lorban@bitronix.be>"}, "afterCommit": {"oid": "943b86b8dd2f034c56038e296920ca825ffbe4ea", "author": {"user": {"login": "lorban", "name": "Ludovic Orban"}}, "url": "https://github.com/eclipse/jetty.project/commit/943b86b8dd2f034c56038e296920ca825ffbe4ea", "committedDate": "2020-02-04T11:36:44Z", "message": "change the format of detector's generated protocol name\n\nSigned-off-by: Ludovic Orban <lorban@bitronix.be>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5df1ad9b6693b86a84aca82f3fc76151bd302ffa", "author": {"user": {"login": "lorban", "name": "Ludovic Orban"}}, "url": "https://github.com/eclipse/jetty.project/commit/5df1ad9b6693b86a84aca82f3fc76151bd302ffa", "committedDate": "2020-02-04T11:42:35Z", "message": "change the format of detector's generated protocol name\n\nSigned-off-by: Ludovic Orban <lorban@bitronix.be>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "943b86b8dd2f034c56038e296920ca825ffbe4ea", "author": {"user": {"login": "lorban", "name": "Ludovic Orban"}}, "url": "https://github.com/eclipse/jetty.project/commit/943b86b8dd2f034c56038e296920ca825ffbe4ea", "committedDate": "2020-02-04T11:36:44Z", "message": "change the format of detector's generated protocol name\n\nSigned-off-by: Ludovic Orban <lorban@bitronix.be>"}, "afterCommit": {"oid": "5df1ad9b6693b86a84aca82f3fc76151bd302ffa", "author": {"user": {"login": "lorban", "name": "Ludovic Orban"}}, "url": "https://github.com/eclipse/jetty.project/commit/5df1ad9b6693b86a84aca82f3fc76151bd302ffa", "committedDate": "2020-02-04T11:42:35Z", "message": "change the format of detector's generated protocol name\n\nSigned-off-by: Ludovic Orban <lorban@bitronix.be>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzU0MjU3MDM2", "url": "https://github.com/eclipse/jetty.project/pull/4519#pullrequestreview-354257036", "createdAt": "2020-02-06T08:03:47Z", "commit": {"oid": "5df1ad9b6693b86a84aca82f3fc76151bd302ffa"}, "state": "APPROVED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNlQwODowMzo0N1rOFmSECQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNlQwODowMzo1MVrOFmSEIw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTY4NjE1Mw==", "bodyText": "again a constant? why 6 not 7 now?", "url": "https://github.com/eclipse/jetty.project/pull/4519#discussion_r375686153", "createdAt": "2020-02-06T08:03:47Z", "author": {"login": "gregw"}, "path": "jetty-server/src/main/java/org/eclipse/jetty/server/ProxyConnectionFactory.java", "diffHunk": "@@ -46,252 +45,281 @@\n  *\n  * @see <a href=\"http://www.haproxy.org/download/1.5/doc/proxy-protocol.txt\">http://www.haproxy.org/download/1.5/doc/proxy-protocol.txt</a>\n  */\n-public class ProxyConnectionFactory extends AbstractConnectionFactory\n+public class ProxyConnectionFactory extends DetectorConnectionFactory\n {\n-    private static final Logger LOG = Log.getLogger(ProxyConnectionFactory.class);\n     public static final String TLS_VERSION = \"TLS_VERSION\";\n+    private static final Logger LOG = Log.getLogger(ProxyConnectionFactory.class);\n \n-    private final String _next;\n-    private int _maxProxyHeader = 1024;\n-\n-    /**\n-     * Proxy Connection Factory that uses the next ConnectionFactory\n-     * on the connector as the next protocol\n-     */\n     public ProxyConnectionFactory()\n     {\n-        super(\"proxy\");\n-        _next = null;\n+        this(null);\n     }\n \n     public ProxyConnectionFactory(String nextProtocol)\n     {\n-        super(\"proxy\");\n-        _next = nextProtocol;\n+        super(new ProxyV1ConnectionFactory(nextProtocol), new ProxyV2ConnectionFactory(nextProtocol));\n     }\n \n-    public int getMaxProxyHeader()\n+    private static ConnectionFactory findNextConnectionFactory(String nextProtocol, Connector connector, String currentProtocol, EndPoint endp)\n     {\n-        return _maxProxyHeader;\n+        currentProtocol = \"[\" + currentProtocol + \"]\";\n+        if (LOG.isDebugEnabled())\n+            LOG.debug(\"finding connection factory following {} for protocol {}\", currentProtocol, nextProtocol);\n+        String nextProtocolToFind = nextProtocol;\n+        if (nextProtocol == null)\n+            nextProtocolToFind = AbstractConnectionFactory.findNextProtocol(connector, currentProtocol);\n+        if (nextProtocolToFind == null)\n+            throw new IllegalStateException(\"Cannot find protocol following '\" + currentProtocol + \"' in connector's protocol list \" + connector.getProtocols() + \" for \" + endp);\n+        ConnectionFactory connectionFactory = connector.getConnectionFactory(nextProtocolToFind);\n+        if (connectionFactory == null)\n+            throw new IllegalStateException(\"Cannot find protocol '\" + nextProtocol + \"' in connector's protocol list \" + connector.getProtocols() + \" for \" + endp);\n+        if (LOG.isDebugEnabled())\n+            LOG.debug(\"found next connection factory {} for protocol {}\", connectionFactory, nextProtocol);\n+        return connectionFactory;\n     }\n \n-    public void setMaxProxyHeader(int maxProxyHeader)\n+    public int getMaxProxyHeader()\n     {\n-        _maxProxyHeader = maxProxyHeader;\n+        ProxyV2ConnectionFactory v2 = getBean(ProxyV2ConnectionFactory.class);\n+        return v2.getMaxProxyHeader();\n     }\n \n-    @Override\n-    public Connection newConnection(Connector connector, EndPoint endp)\n+    public void setMaxProxyHeader(int maxProxyHeader)\n     {\n-        String next = _next;\n-        if (next == null)\n-        {\n-            for (Iterator<String> i = connector.getProtocols().iterator(); i.hasNext(); )\n-            {\n-                String p = i.next();\n-                if (getProtocol().equalsIgnoreCase(p))\n-                {\n-                    next = i.next();\n-                    break;\n-                }\n-            }\n-        }\n-\n-        return new ProxyProtocolV1orV2Connection(endp, connector, next);\n+        ProxyV2ConnectionFactory v2 = getBean(ProxyV2ConnectionFactory.class);\n+        v2.setMaxProxyHeader(maxProxyHeader);\n     }\n \n-    public class ProxyProtocolV1orV2Connection extends AbstractConnection\n+    private static class ProxyV1ConnectionFactory extends AbstractConnectionFactory implements Detecting\n     {\n-        // Only do a tiny read to figure out what PROXY version it is.\n-        private final ByteBuffer _buffer = BufferUtil.allocate(16);\n-        private final Connector _connector;\n-        private final String _next;\n+        private static final byte[] SIGNATURE = \"PROXY\".getBytes(StandardCharsets.US_ASCII);\n \n-        protected ProxyProtocolV1orV2Connection(EndPoint endp, Connector connector, String next)\n-        {\n-            super(endp, connector.getExecutor());\n-            _connector = connector;\n-            _next = next;\n-        }\n+        private final String _nextProtocol;\n \n-        @Override\n-        public void onOpen()\n+        private ProxyV1ConnectionFactory(String nextProtocol)\n         {\n-            super.onOpen();\n-            fillInterested();\n+            super(\"proxy\");\n+            this._nextProtocol = nextProtocol;\n         }\n \n         @Override\n-        public void onFillable()\n+        public Detection detect(ByteBuffer buffer)\n         {\n-            try\n+            if (LOG.isDebugEnabled())\n+                LOG.debug(\"Proxy v1 attempting detection with {} bytes\", buffer.remaining());\n+            if (buffer.remaining() < SIGNATURE.length)\n             {\n-                while (BufferUtil.space(_buffer) > 0)\n-                {\n-                    // Read data\n-                    int fill = getEndPoint().fill(_buffer);\n-                    if (fill < 0)\n-                    {\n-                        getEndPoint().shutdownOutput();\n-                        return;\n-                    }\n-                    if (fill == 0)\n-                    {\n-                        fillInterested();\n-                        return;\n-                    }\n-                }\n+                if (LOG.isDebugEnabled())\n+                    LOG.debug(\"Proxy v1 detection requires more bytes\");\n+                return Detection.NEED_MORE_BYTES;\n+            }\n \n-                // Is it a V1?\n-                switch (_buffer.get(0))\n+            for (int i = 0; i < SIGNATURE.length; i++)\n+            {\n+                byte signatureByte = SIGNATURE[i];\n+                byte byteInBuffer = buffer.get(i);\n+                if (byteInBuffer != signatureByte)\n                 {\n-                    case 'P':\n-                    {\n-                        ProxyProtocolV1Connection v1 = new ProxyProtocolV1Connection(getEndPoint(), _connector, _next, _buffer);\n-                        getEndPoint().upgrade(v1);\n-                        return;\n-                    }\n-                    case 0x0D:\n-                    {\n-                        ProxyProtocolV2Connection v2 = new ProxyProtocolV2Connection(getEndPoint(), _connector, _next, _buffer);\n-                        getEndPoint().upgrade(v2);\n-                        return;\n-                    }\n-                    default:\n-                    {\n-                        LOG.warn(\"Not PROXY protocol for {}\", getEndPoint());\n-                        close();\n-                        break;\n-                    }\n+                    if (LOG.isDebugEnabled())\n+                        LOG.debug(\"Proxy v1 detection unsuccessful\");\n+                    return Detection.NOT_RECOGNIZED;\n                 }\n             }\n-            catch (Throwable x)\n-            {\n-                LOG.warn(\"PROXY error for \" + getEndPoint(), x);\n-                close();\n-            }\n-        }\n-    }\n-\n-    public static class ProxyProtocolV1Connection extends AbstractConnection\n-    {\n-        // 0     1 2       3       4 5 6\n-        // 98765432109876543210987654321\n-        // PROXY P R.R.R.R L.L.L.L R Lrn\n-\n-        private static final int[] SIZE = {29, 23, 21, 13, 5, 3, 1};\n-        private final Connector _connector;\n-        private final String _next;\n-        private final StringBuilder _builder = new StringBuilder();\n-        private final String[] _fields = new String[6];\n-        private int _index;\n-        private int _length;\n \n-        protected ProxyProtocolV1Connection(EndPoint endp, Connector connector, String next, ByteBuffer buffer)\n-        {\n-            super(endp, connector.getExecutor());\n-            _connector = connector;\n-            _next = next;\n-            _length = buffer.remaining();\n-            parse(buffer);\n+            if (LOG.isDebugEnabled())\n+                LOG.debug(\"Proxy v1 detection succeeded\");\n+            return Detection.RECOGNIZED;\n         }\n \n         @Override\n-        public void onOpen()\n+        public Connection newConnection(Connector connector, EndPoint endp)\n         {\n-            super.onOpen();\n-            fillInterested();\n+            ConnectionFactory nextConnectionFactory = findNextConnectionFactory(_nextProtocol, connector, getProtocol(), endp);\n+            return configure(new ProxyProtocolV1Connection(endp, connector, nextConnectionFactory), connector, endp);\n         }\n \n-        private boolean parse(ByteBuffer buffer)\n+        private static class ProxyProtocolV1Connection extends AbstractConnection implements Connection.UpgradeFrom, Connection.UpgradeTo\n         {\n-            // Parse fields\n-            while (buffer.hasRemaining())\n+            // 0     1 2       3       4 5 6\n+            // 98765432109876543210987654321\n+            // PROXY P R.R.R.R L.L.L.L R Lrn\n+\n+            private final Connector _connector;\n+            private final ConnectionFactory _next;\n+            private final ByteBuffer _buffer;\n+            private final StringBuilder _builder = new StringBuilder();\n+            private final String[] _fields = new String[6];\n+            private int _index;\n+            private int _length;\n+\n+            private ProxyProtocolV1Connection(EndPoint endp, Connector connector, ConnectionFactory next)\n             {\n-                byte b = buffer.get();\n-                if (_index < 6)\n+                super(endp, connector.getExecutor());\n+                _connector = connector;\n+                _next = next;\n+                _buffer = _connector.getByteBufferPool().acquire(getInputBufferSize(), true);\n+            }\n+\n+            @Override\n+            public void onFillable()\n+            {\n+                if (LOG.isDebugEnabled())\n+                    LOG.debug(\"Proxy v1 onFillable current index = \", _index);\n+                try\n                 {\n-                    if (b == ' ' || b == '\\r')\n-                    {\n-                        _fields[_index++] = _builder.toString();\n-                        _builder.setLength(0);\n-                        if (b == '\\r')\n-                            _index = 6;\n-                    }\n-                    else if (b < ' ')\n-                    {\n-                        LOG.warn(\"Bad character {} for {}\", b & 0xFF, getEndPoint());\n-                        close();\n-                        return false;\n-                    }\n-                    else\n+                    while (_index < 7)\n                     {\n-                        _builder.append((char)b);\n+                        // Read data\n+                        int fill = getEndPoint().fill(_buffer);\n+                        if (LOG.isDebugEnabled())\n+                            LOG.debug(\"Proxy v1 filled buffer with {} bytes\", fill);\n+                        if (fill < 0)\n+                        {\n+                            _connector.getByteBufferPool().release(_buffer);\n+                            getEndPoint().shutdownOutput();\n+                            return;\n+                        }\n+                        if (fill == 0)\n+                        {\n+                            fillInterested();\n+                            return;\n+                        }\n+\n+                        if (parse())\n+                            break;\n                     }\n+\n+                    if (LOG.isDebugEnabled())\n+                        LOG.debug(\"Proxy v1 onFillable parsing done, now upgrading\");\n+                    upgrade();\n+                }\n+                catch (Throwable x)\n+                {\n+                    LOG.warn(\"Proxy v1 error for {}\", getEndPoint(), x);\n+                    releaseAndClose();\n                 }\n-                else\n+            }\n+\n+            @Override\n+            public void onOpen()\n+            {\n+                super.onOpen();\n+\n+                try\n                 {\n-                    if (b == '\\n')\n+                    while (_index < 7)\n                     {\n-                        _index = 7;\n-                        return true;\n+                        if (!parse())\n+                        {\n+                            if (LOG.isDebugEnabled())\n+                                LOG.debug(\"Proxy v1 onOpen parsing ran out of bytes, marking as fillInterested\");\n+                            fillInterested();\n+                            return;\n+                        }\n                     }\n \n-                    LOG.warn(\"Bad CRLF for {}\", getEndPoint());\n-                    close();\n-                    return false;\n+                    if (LOG.isDebugEnabled())\n+                        LOG.debug(\"Proxy v1 onOpen parsing done, now upgrading\");\n+                    upgrade();\n+                }\n+                catch (Throwable x)\n+                {\n+                    LOG.warn(\"Proxy v1 error for {}\", getEndPoint(), x);\n+                    releaseAndClose();\n                 }\n             }\n-            return true;\n-        }\n \n-        @Override\n-        public void onFillable()\n-        {\n-            try\n+            @Override\n+            public ByteBuffer onUpgradeFrom()\n             {\n-                ByteBuffer buffer = null;\n-                while (_index < 7)\n-                {\n-                    // Create a buffer that will not read too much data\n-                    // since once read it is impossible to push back for the \n-                    // real connection to read it.\n-                    int size = Math.max(1, SIZE[_index] - _builder.length());\n-                    if (buffer == null || buffer.capacity() != size)\n-                        buffer = BufferUtil.allocate(size);\n-                    else\n-                        BufferUtil.clear(buffer);\n+                return _buffer;\n+            }\n \n-                    // Read data\n-                    int fill = getEndPoint().fill(buffer);\n-                    if (fill < 0)\n+            @Override\n+            public void onUpgradeTo(ByteBuffer prefilled)\n+            {\n+                if (LOG.isDebugEnabled())\n+                    LOG.debug(\"Proxy v1 copying prefilled buffer {}\", prefilled);\n+                if (BufferUtil.hasContent(prefilled))\n+                    BufferUtil.append(_buffer, prefilled);\n+            }\n+\n+            /**\n+             * @return true when parsing is done, false when more bytes are needed.\n+             */\n+            private boolean parse() throws IOException\n+            {\n+                if (LOG.isDebugEnabled())\n+                    LOG.debug(\"Proxy v1 parsing {}\", BufferUtil.toDetailString(_buffer));\n+                _length += _buffer.remaining();\n+\n+                // Parse fields\n+                while (_buffer.hasRemaining())\n+                {\n+                    byte b = _buffer.get();\n+                    if (_index < 6)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5df1ad9b6693b86a84aca82f3fc76151bd302ffa"}, "originalPosition": 388}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTY4NjE3OQ==", "bodyText": "maybe avoid hard coded 7.   Use a descriptive constant or is this <=_fields.length?", "url": "https://github.com/eclipse/jetty.project/pull/4519#discussion_r375686179", "createdAt": "2020-02-06T08:03:51Z", "author": {"login": "gregw"}, "path": "jetty-server/src/main/java/org/eclipse/jetty/server/ProxyConnectionFactory.java", "diffHunk": "@@ -46,252 +45,281 @@\n  *\n  * @see <a href=\"http://www.haproxy.org/download/1.5/doc/proxy-protocol.txt\">http://www.haproxy.org/download/1.5/doc/proxy-protocol.txt</a>\n  */\n-public class ProxyConnectionFactory extends AbstractConnectionFactory\n+public class ProxyConnectionFactory extends DetectorConnectionFactory\n {\n-    private static final Logger LOG = Log.getLogger(ProxyConnectionFactory.class);\n     public static final String TLS_VERSION = \"TLS_VERSION\";\n+    private static final Logger LOG = Log.getLogger(ProxyConnectionFactory.class);\n \n-    private final String _next;\n-    private int _maxProxyHeader = 1024;\n-\n-    /**\n-     * Proxy Connection Factory that uses the next ConnectionFactory\n-     * on the connector as the next protocol\n-     */\n     public ProxyConnectionFactory()\n     {\n-        super(\"proxy\");\n-        _next = null;\n+        this(null);\n     }\n \n     public ProxyConnectionFactory(String nextProtocol)\n     {\n-        super(\"proxy\");\n-        _next = nextProtocol;\n+        super(new ProxyV1ConnectionFactory(nextProtocol), new ProxyV2ConnectionFactory(nextProtocol));\n     }\n \n-    public int getMaxProxyHeader()\n+    private static ConnectionFactory findNextConnectionFactory(String nextProtocol, Connector connector, String currentProtocol, EndPoint endp)\n     {\n-        return _maxProxyHeader;\n+        currentProtocol = \"[\" + currentProtocol + \"]\";\n+        if (LOG.isDebugEnabled())\n+            LOG.debug(\"finding connection factory following {} for protocol {}\", currentProtocol, nextProtocol);\n+        String nextProtocolToFind = nextProtocol;\n+        if (nextProtocol == null)\n+            nextProtocolToFind = AbstractConnectionFactory.findNextProtocol(connector, currentProtocol);\n+        if (nextProtocolToFind == null)\n+            throw new IllegalStateException(\"Cannot find protocol following '\" + currentProtocol + \"' in connector's protocol list \" + connector.getProtocols() + \" for \" + endp);\n+        ConnectionFactory connectionFactory = connector.getConnectionFactory(nextProtocolToFind);\n+        if (connectionFactory == null)\n+            throw new IllegalStateException(\"Cannot find protocol '\" + nextProtocol + \"' in connector's protocol list \" + connector.getProtocols() + \" for \" + endp);\n+        if (LOG.isDebugEnabled())\n+            LOG.debug(\"found next connection factory {} for protocol {}\", connectionFactory, nextProtocol);\n+        return connectionFactory;\n     }\n \n-    public void setMaxProxyHeader(int maxProxyHeader)\n+    public int getMaxProxyHeader()\n     {\n-        _maxProxyHeader = maxProxyHeader;\n+        ProxyV2ConnectionFactory v2 = getBean(ProxyV2ConnectionFactory.class);\n+        return v2.getMaxProxyHeader();\n     }\n \n-    @Override\n-    public Connection newConnection(Connector connector, EndPoint endp)\n+    public void setMaxProxyHeader(int maxProxyHeader)\n     {\n-        String next = _next;\n-        if (next == null)\n-        {\n-            for (Iterator<String> i = connector.getProtocols().iterator(); i.hasNext(); )\n-            {\n-                String p = i.next();\n-                if (getProtocol().equalsIgnoreCase(p))\n-                {\n-                    next = i.next();\n-                    break;\n-                }\n-            }\n-        }\n-\n-        return new ProxyProtocolV1orV2Connection(endp, connector, next);\n+        ProxyV2ConnectionFactory v2 = getBean(ProxyV2ConnectionFactory.class);\n+        v2.setMaxProxyHeader(maxProxyHeader);\n     }\n \n-    public class ProxyProtocolV1orV2Connection extends AbstractConnection\n+    private static class ProxyV1ConnectionFactory extends AbstractConnectionFactory implements Detecting\n     {\n-        // Only do a tiny read to figure out what PROXY version it is.\n-        private final ByteBuffer _buffer = BufferUtil.allocate(16);\n-        private final Connector _connector;\n-        private final String _next;\n+        private static final byte[] SIGNATURE = \"PROXY\".getBytes(StandardCharsets.US_ASCII);\n \n-        protected ProxyProtocolV1orV2Connection(EndPoint endp, Connector connector, String next)\n-        {\n-            super(endp, connector.getExecutor());\n-            _connector = connector;\n-            _next = next;\n-        }\n+        private final String _nextProtocol;\n \n-        @Override\n-        public void onOpen()\n+        private ProxyV1ConnectionFactory(String nextProtocol)\n         {\n-            super.onOpen();\n-            fillInterested();\n+            super(\"proxy\");\n+            this._nextProtocol = nextProtocol;\n         }\n \n         @Override\n-        public void onFillable()\n+        public Detection detect(ByteBuffer buffer)\n         {\n-            try\n+            if (LOG.isDebugEnabled())\n+                LOG.debug(\"Proxy v1 attempting detection with {} bytes\", buffer.remaining());\n+            if (buffer.remaining() < SIGNATURE.length)\n             {\n-                while (BufferUtil.space(_buffer) > 0)\n-                {\n-                    // Read data\n-                    int fill = getEndPoint().fill(_buffer);\n-                    if (fill < 0)\n-                    {\n-                        getEndPoint().shutdownOutput();\n-                        return;\n-                    }\n-                    if (fill == 0)\n-                    {\n-                        fillInterested();\n-                        return;\n-                    }\n-                }\n+                if (LOG.isDebugEnabled())\n+                    LOG.debug(\"Proxy v1 detection requires more bytes\");\n+                return Detection.NEED_MORE_BYTES;\n+            }\n \n-                // Is it a V1?\n-                switch (_buffer.get(0))\n+            for (int i = 0; i < SIGNATURE.length; i++)\n+            {\n+                byte signatureByte = SIGNATURE[i];\n+                byte byteInBuffer = buffer.get(i);\n+                if (byteInBuffer != signatureByte)\n                 {\n-                    case 'P':\n-                    {\n-                        ProxyProtocolV1Connection v1 = new ProxyProtocolV1Connection(getEndPoint(), _connector, _next, _buffer);\n-                        getEndPoint().upgrade(v1);\n-                        return;\n-                    }\n-                    case 0x0D:\n-                    {\n-                        ProxyProtocolV2Connection v2 = new ProxyProtocolV2Connection(getEndPoint(), _connector, _next, _buffer);\n-                        getEndPoint().upgrade(v2);\n-                        return;\n-                    }\n-                    default:\n-                    {\n-                        LOG.warn(\"Not PROXY protocol for {}\", getEndPoint());\n-                        close();\n-                        break;\n-                    }\n+                    if (LOG.isDebugEnabled())\n+                        LOG.debug(\"Proxy v1 detection unsuccessful\");\n+                    return Detection.NOT_RECOGNIZED;\n                 }\n             }\n-            catch (Throwable x)\n-            {\n-                LOG.warn(\"PROXY error for \" + getEndPoint(), x);\n-                close();\n-            }\n-        }\n-    }\n-\n-    public static class ProxyProtocolV1Connection extends AbstractConnection\n-    {\n-        // 0     1 2       3       4 5 6\n-        // 98765432109876543210987654321\n-        // PROXY P R.R.R.R L.L.L.L R Lrn\n-\n-        private static final int[] SIZE = {29, 23, 21, 13, 5, 3, 1};\n-        private final Connector _connector;\n-        private final String _next;\n-        private final StringBuilder _builder = new StringBuilder();\n-        private final String[] _fields = new String[6];\n-        private int _index;\n-        private int _length;\n \n-        protected ProxyProtocolV1Connection(EndPoint endp, Connector connector, String next, ByteBuffer buffer)\n-        {\n-            super(endp, connector.getExecutor());\n-            _connector = connector;\n-            _next = next;\n-            _length = buffer.remaining();\n-            parse(buffer);\n+            if (LOG.isDebugEnabled())\n+                LOG.debug(\"Proxy v1 detection succeeded\");\n+            return Detection.RECOGNIZED;\n         }\n \n         @Override\n-        public void onOpen()\n+        public Connection newConnection(Connector connector, EndPoint endp)\n         {\n-            super.onOpen();\n-            fillInterested();\n+            ConnectionFactory nextConnectionFactory = findNextConnectionFactory(_nextProtocol, connector, getProtocol(), endp);\n+            return configure(new ProxyProtocolV1Connection(endp, connector, nextConnectionFactory), connector, endp);\n         }\n \n-        private boolean parse(ByteBuffer buffer)\n+        private static class ProxyProtocolV1Connection extends AbstractConnection implements Connection.UpgradeFrom, Connection.UpgradeTo\n         {\n-            // Parse fields\n-            while (buffer.hasRemaining())\n+            // 0     1 2       3       4 5 6\n+            // 98765432109876543210987654321\n+            // PROXY P R.R.R.R L.L.L.L R Lrn\n+\n+            private final Connector _connector;\n+            private final ConnectionFactory _next;\n+            private final ByteBuffer _buffer;\n+            private final StringBuilder _builder = new StringBuilder();\n+            private final String[] _fields = new String[6];\n+            private int _index;\n+            private int _length;\n+\n+            private ProxyProtocolV1Connection(EndPoint endp, Connector connector, ConnectionFactory next)\n             {\n-                byte b = buffer.get();\n-                if (_index < 6)\n+                super(endp, connector.getExecutor());\n+                _connector = connector;\n+                _next = next;\n+                _buffer = _connector.getByteBufferPool().acquire(getInputBufferSize(), true);\n+            }\n+\n+            @Override\n+            public void onFillable()\n+            {\n+                if (LOG.isDebugEnabled())\n+                    LOG.debug(\"Proxy v1 onFillable current index = \", _index);\n+                try\n                 {\n-                    if (b == ' ' || b == '\\r')\n-                    {\n-                        _fields[_index++] = _builder.toString();\n-                        _builder.setLength(0);\n-                        if (b == '\\r')\n-                            _index = 6;\n-                    }\n-                    else if (b < ' ')\n-                    {\n-                        LOG.warn(\"Bad character {} for {}\", b & 0xFF, getEndPoint());\n-                        close();\n-                        return false;\n-                    }\n-                    else\n+                    while (_index < 7)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5df1ad9b6693b86a84aca82f3fc76151bd302ffa"}, "originalPosition": 270}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "386d9348ca3d0f95a9456dcaa92782bc2d1e73ec", "author": {"user": {"login": "lorban", "name": "Ludovic Orban"}}, "url": "https://github.com/eclipse/jetty.project/commit/386d9348ca3d0f95a9456dcaa92782bc2d1e73ec", "committedDate": "2020-02-06T09:06:33Z", "message": "Use contants for CR and LF fields index\n\nSigned-off-by: Ludovic Orban <lorban@bitronix.be>"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 562, "cost": 1, "resetAt": "2021-11-01T13:51:04Z"}}}