{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDc3MDA1NDMz", "number": 5219, "reviewThreads": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMVQxMzo1MDoxNVrOEe6adA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMVQxNTo0MDo0M1rOEe9wKQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAwODQ5NzgwOnYy", "diffSide": "RIGHT", "path": "jetty-client/src/main/java/org/eclipse/jetty/client/IndexedConnectionPool.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMVQxMzo1MDoxNVrOHK3NRg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMVQxNDo0NDoyNVrOHK5o7A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTE1MjMyNg==", "bodyText": "I think the cache should be forced to false, otherwise you risk reaching a steady state where one thread continuously uses the connection at the same index.", "url": "https://github.com/eclipse/jetty.project/pull/5219#discussion_r481152326", "createdAt": "2020-09-01T13:50:15Z", "author": {"login": "lorban"}, "path": "jetty-client/src/main/java/org/eclipse/jetty/client/IndexedConnectionPool.java", "diffHunk": "@@ -0,0 +1,79 @@\n+//\n+//  ========================================================================\n+//  Copyright (c) 1995-2020 Mort Bay Consulting Pty Ltd and others.\n+//  ------------------------------------------------------------------------\n+//  All rights reserved. This program and the accompanying materials\n+//  are made available under the terms of the Eclipse Public License v1.0\n+//  and Apache License v2.0 which accompanies this distribution.\n+//\n+//      The Eclipse Public License is available at\n+//      http://www.eclipse.org/legal/epl-v10.html\n+//\n+//      The Apache License v2.0 is available at\n+//      http://www.opensource.org/licenses/apache2.0.php\n+//\n+//  You may elect to redistribute this code under either of these licenses.\n+//  ========================================================================\n+//\n+\n+package org.eclipse.jetty.client;\n+\n+import org.eclipse.jetty.client.api.Connection;\n+import org.eclipse.jetty.util.Callback;\n+import org.eclipse.jetty.util.Pool;\n+import org.eclipse.jetty.util.annotation.ManagedObject;\n+import org.eclipse.jetty.util.log.Log;\n+import org.eclipse.jetty.util.log.Logger;\n+\n+/**\n+ * <p>A {@link MultiplexConnectionPool} that picks connections at a particular\n+ * index between {@code 0} and {@link #getMaxConnectionCount()}.</p>\n+ * <p>The algorithm that decides the index value is decided by subclasses.</p>\n+ * <p>To acquire a connection, this class obtains the index value and attempts\n+ * to activate the pool entry at that index.\n+ * If this activation fails, another attempt to activate an alternative pool\n+ * entry is performed, to avoid stalling connection acquisition if there is\n+ * an available entry at a different index.</p>\n+ */\n+@ManagedObject\n+public abstract class IndexedConnectionPool extends MultiplexConnectionPool\n+{\n+    private static final Logger LOG = Log.getLogger(IndexedConnectionPool.class);\n+\n+    private final Pool<Connection> pool;\n+\n+    public IndexedConnectionPool(HttpDestination destination, int maxConnections, boolean cache, Callback requester, int maxMultiplex)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f1a821f0a9dd66d8b24a01b2cdf342ff6a2a12fc"}, "originalPosition": 45}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTE5MjE3Mg==", "bodyText": "I think there shouldn't be a cache and it should be replaced by round robin: see #5218", "url": "https://github.com/eclipse/jetty.project/pull/5219#discussion_r481192172", "createdAt": "2020-09-01T14:44:25Z", "author": {"login": "gregw"}, "path": "jetty-client/src/main/java/org/eclipse/jetty/client/IndexedConnectionPool.java", "diffHunk": "@@ -0,0 +1,79 @@\n+//\n+//  ========================================================================\n+//  Copyright (c) 1995-2020 Mort Bay Consulting Pty Ltd and others.\n+//  ------------------------------------------------------------------------\n+//  All rights reserved. This program and the accompanying materials\n+//  are made available under the terms of the Eclipse Public License v1.0\n+//  and Apache License v2.0 which accompanies this distribution.\n+//\n+//      The Eclipse Public License is available at\n+//      http://www.eclipse.org/legal/epl-v10.html\n+//\n+//      The Apache License v2.0 is available at\n+//      http://www.opensource.org/licenses/apache2.0.php\n+//\n+//  You may elect to redistribute this code under either of these licenses.\n+//  ========================================================================\n+//\n+\n+package org.eclipse.jetty.client;\n+\n+import org.eclipse.jetty.client.api.Connection;\n+import org.eclipse.jetty.util.Callback;\n+import org.eclipse.jetty.util.Pool;\n+import org.eclipse.jetty.util.annotation.ManagedObject;\n+import org.eclipse.jetty.util.log.Log;\n+import org.eclipse.jetty.util.log.Logger;\n+\n+/**\n+ * <p>A {@link MultiplexConnectionPool} that picks connections at a particular\n+ * index between {@code 0} and {@link #getMaxConnectionCount()}.</p>\n+ * <p>The algorithm that decides the index value is decided by subclasses.</p>\n+ * <p>To acquire a connection, this class obtains the index value and attempts\n+ * to activate the pool entry at that index.\n+ * If this activation fails, another attempt to activate an alternative pool\n+ * entry is performed, to avoid stalling connection acquisition if there is\n+ * an available entry at a different index.</p>\n+ */\n+@ManagedObject\n+public abstract class IndexedConnectionPool extends MultiplexConnectionPool\n+{\n+    private static final Logger LOG = Log.getLogger(IndexedConnectionPool.class);\n+\n+    private final Pool<Connection> pool;\n+\n+    public IndexedConnectionPool(HttpDestination destination, int maxConnections, boolean cache, Callback requester, int maxMultiplex)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTE1MjMyNg=="}, "originalCommit": {"oid": "f1a821f0a9dd66d8b24a01b2cdf342ff6a2a12fc"}, "originalPosition": 45}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAwOTA0NDg5OnYy", "diffSide": "RIGHT", "path": "jetty-client/src/main/java/org/eclipse/jetty/client/RoundRobinConnectionPool.java", "isResolved": true, "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMVQxNTo0MDo0M1rOHK8h9Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMlQxMjozNDoyNlrOHLs63A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTIzOTU0MQ==", "bodyText": "When the integer goes overflows, you will start going the opposite way around the the pool", "url": "https://github.com/eclipse/jetty.project/pull/5219#discussion_r481239541", "createdAt": "2020-09-01T15:40:43Z", "author": {"login": "gregw"}, "path": "jetty-client/src/main/java/org/eclipse/jetty/client/RoundRobinConnectionPool.java", "diffHunk": "@@ -43,36 +55,16 @@ public RoundRobinConnectionPool(HttpDestination destination, int maxConnections,\n     public RoundRobinConnectionPool(HttpDestination destination, int maxConnections, Callback requester, int maxMultiplex)\n     {\n         super(destination, maxConnections, false, requester, maxMultiplex);\n-        pool = destination.getBean(Pool.class);\n-    }\n-\n-    @Override\n-    protected Connection acquire(boolean create)\n-    {\n         // If there are queued requests and connections get\n         // closed due to idle timeout or overuse, we want to\n         // aggressively try to open new connections to replace\n         // those that were closed to process queued requests.\n-        return super.acquire(true);\n+        setMaximizeConnections(true);\n     }\n \n     @Override\n-    protected Connection activate()\n+    protected int getIndex(int maxConnections)\n     {\n-        Pool<Connection>.Entry entry;\n-        try (Locker.Lock l = lock.lock())\n-        {\n-            int index = Math.abs(offset % pool.getMaxEntries());\n-            entry = pool.acquireAt(index);\n-            if (LOG.isDebugEnabled())\n-                LOG.debug(\"activated at index={} entry={}\", index, entry);\n-            if (entry != null)\n-                ++offset;\n-        }\n-        if (entry == null)\n-            return null;\n-        Connection connection = entry.getPooled();\n-        acquired(connection);\n-        return connection;\n+        return Math.abs(offset.getAndIncrement() % maxConnections);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f1a821f0a9dd66d8b24a01b2cdf342ff6a2a12fc"}, "originalPosition": 83}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTI0NjQxNQ==", "bodyText": "could always use the overflow throwing behavior of Math.addExact(int, int) to trap that.", "url": "https://github.com/eclipse/jetty.project/pull/5219#discussion_r481246415", "createdAt": "2020-09-01T15:50:40Z", "author": {"login": "joakime"}, "path": "jetty-client/src/main/java/org/eclipse/jetty/client/RoundRobinConnectionPool.java", "diffHunk": "@@ -43,36 +55,16 @@ public RoundRobinConnectionPool(HttpDestination destination, int maxConnections,\n     public RoundRobinConnectionPool(HttpDestination destination, int maxConnections, Callback requester, int maxMultiplex)\n     {\n         super(destination, maxConnections, false, requester, maxMultiplex);\n-        pool = destination.getBean(Pool.class);\n-    }\n-\n-    @Override\n-    protected Connection acquire(boolean create)\n-    {\n         // If there are queued requests and connections get\n         // closed due to idle timeout or overuse, we want to\n         // aggressively try to open new connections to replace\n         // those that were closed to process queued requests.\n-        return super.acquire(true);\n+        setMaximizeConnections(true);\n     }\n \n     @Override\n-    protected Connection activate()\n+    protected int getIndex(int maxConnections)\n     {\n-        Pool<Connection>.Entry entry;\n-        try (Locker.Lock l = lock.lock())\n-        {\n-            int index = Math.abs(offset % pool.getMaxEntries());\n-            entry = pool.acquireAt(index);\n-            if (LOG.isDebugEnabled())\n-                LOG.debug(\"activated at index={} entry={}\", index, entry);\n-            if (entry != null)\n-                ++offset;\n-        }\n-        if (entry == null)\n-            return null;\n-        Connection connection = entry.getPooled();\n-        acquired(connection);\n-        return connection;\n+        return Math.abs(offset.getAndIncrement() % maxConnections);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTIzOTU0MQ=="}, "originalCommit": {"oid": "f1a821f0a9dd66d8b24a01b2cdf342ff6a2a12fc"}, "originalPosition": 83}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTkzNjYxMw==", "bodyText": "Is that a problem?", "url": "https://github.com/eclipse/jetty.project/pull/5219#discussion_r481936613", "createdAt": "2020-09-02T09:35:18Z", "author": {"login": "lorban"}, "path": "jetty-client/src/main/java/org/eclipse/jetty/client/RoundRobinConnectionPool.java", "diffHunk": "@@ -43,36 +55,16 @@ public RoundRobinConnectionPool(HttpDestination destination, int maxConnections,\n     public RoundRobinConnectionPool(HttpDestination destination, int maxConnections, Callback requester, int maxMultiplex)\n     {\n         super(destination, maxConnections, false, requester, maxMultiplex);\n-        pool = destination.getBean(Pool.class);\n-    }\n-\n-    @Override\n-    protected Connection acquire(boolean create)\n-    {\n         // If there are queued requests and connections get\n         // closed due to idle timeout or overuse, we want to\n         // aggressively try to open new connections to replace\n         // those that were closed to process queued requests.\n-        return super.acquire(true);\n+        setMaximizeConnections(true);\n     }\n \n     @Override\n-    protected Connection activate()\n+    protected int getIndex(int maxConnections)\n     {\n-        Pool<Connection>.Entry entry;\n-        try (Locker.Lock l = lock.lock())\n-        {\n-            int index = Math.abs(offset % pool.getMaxEntries());\n-            entry = pool.acquireAt(index);\n-            if (LOG.isDebugEnabled())\n-                LOG.debug(\"activated at index={} entry={}\", index, entry);\n-            if (entry != null)\n-                ++offset;\n-        }\n-        if (entry == null)\n-            return null;\n-        Connection connection = entry.getPooled();\n-        acquired(connection);\n-        return connection;\n+        return Math.abs(offset.getAndIncrement() % maxConnections);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTIzOTU0MQ=="}, "originalCommit": {"oid": "f1a821f0a9dd66d8b24a01b2cdf342ff6a2a12fc"}, "originalPosition": 83}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTk0MDY3Ng==", "bodyText": "It might not be a problem, and unlikely to happen anyway.... but easily fixed with:\n            return index.getAndUpdate(c -> Math.max(0, c + 1)) % maxConnections;", "url": "https://github.com/eclipse/jetty.project/pull/5219#discussion_r481940676", "createdAt": "2020-09-02T09:42:27Z", "author": {"login": "gregw"}, "path": "jetty-client/src/main/java/org/eclipse/jetty/client/RoundRobinConnectionPool.java", "diffHunk": "@@ -43,36 +55,16 @@ public RoundRobinConnectionPool(HttpDestination destination, int maxConnections,\n     public RoundRobinConnectionPool(HttpDestination destination, int maxConnections, Callback requester, int maxMultiplex)\n     {\n         super(destination, maxConnections, false, requester, maxMultiplex);\n-        pool = destination.getBean(Pool.class);\n-    }\n-\n-    @Override\n-    protected Connection acquire(boolean create)\n-    {\n         // If there are queued requests and connections get\n         // closed due to idle timeout or overuse, we want to\n         // aggressively try to open new connections to replace\n         // those that were closed to process queued requests.\n-        return super.acquire(true);\n+        setMaximizeConnections(true);\n     }\n \n     @Override\n-    protected Connection activate()\n+    protected int getIndex(int maxConnections)\n     {\n-        Pool<Connection>.Entry entry;\n-        try (Locker.Lock l = lock.lock())\n-        {\n-            int index = Math.abs(offset % pool.getMaxEntries());\n-            entry = pool.acquireAt(index);\n-            if (LOG.isDebugEnabled())\n-                LOG.debug(\"activated at index={} entry={}\", index, entry);\n-            if (entry != null)\n-                ++offset;\n-        }\n-        if (entry == null)\n-            return null;\n-        Connection connection = entry.getPooled();\n-        acquired(connection);\n-        return connection;\n+        return Math.abs(offset.getAndIncrement() % maxConnections);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTIzOTU0MQ=="}, "originalCommit": {"oid": "f1a821f0a9dd66d8b24a01b2cdf342ff6a2a12fc"}, "originalPosition": 83}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjAzMjM0OA==", "bodyText": "And I have an even better solution in the latest code.", "url": "https://github.com/eclipse/jetty.project/pull/5219#discussion_r482032348", "createdAt": "2020-09-02T12:34:26Z", "author": {"login": "sbordet"}, "path": "jetty-client/src/main/java/org/eclipse/jetty/client/RoundRobinConnectionPool.java", "diffHunk": "@@ -43,36 +55,16 @@ public RoundRobinConnectionPool(HttpDestination destination, int maxConnections,\n     public RoundRobinConnectionPool(HttpDestination destination, int maxConnections, Callback requester, int maxMultiplex)\n     {\n         super(destination, maxConnections, false, requester, maxMultiplex);\n-        pool = destination.getBean(Pool.class);\n-    }\n-\n-    @Override\n-    protected Connection acquire(boolean create)\n-    {\n         // If there are queued requests and connections get\n         // closed due to idle timeout or overuse, we want to\n         // aggressively try to open new connections to replace\n         // those that were closed to process queued requests.\n-        return super.acquire(true);\n+        setMaximizeConnections(true);\n     }\n \n     @Override\n-    protected Connection activate()\n+    protected int getIndex(int maxConnections)\n     {\n-        Pool<Connection>.Entry entry;\n-        try (Locker.Lock l = lock.lock())\n-        {\n-            int index = Math.abs(offset % pool.getMaxEntries());\n-            entry = pool.acquireAt(index);\n-            if (LOG.isDebugEnabled())\n-                LOG.debug(\"activated at index={} entry={}\", index, entry);\n-            if (entry != null)\n-                ++offset;\n-        }\n-        if (entry == null)\n-            return null;\n-        Connection connection = entry.getPooled();\n-        acquired(connection);\n-        return connection;\n+        return Math.abs(offset.getAndIncrement() % maxConnections);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTIzOTU0MQ=="}, "originalCommit": {"oid": "f1a821f0a9dd66d8b24a01b2cdf342ff6a2a12fc"}, "originalPosition": 83}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2358, "cost": 1, "resetAt": "2021-11-12T18:49:56Z"}}}