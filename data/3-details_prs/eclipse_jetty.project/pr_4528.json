{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzY4OTg2MzUy", "number": 4528, "title": "Issue #4520 Reinstate throw of UnreadableSessionDataException", "bodyText": "The fix for issue #3913 accidentally removed the throw of an UnreadableSessionDataException from AbstractSessionCache.get() method (the implementation of get() was changed to eventually use a lambda expression and the throw was therefore omitted).  The missing throw meant that a session that could not be read from the session data store was treated as not existing rather than existing and being unusable.  If the session is unusable the previous behaviour was to invalidate it and delete it in the store across all contexts.\nThis omission came to light in issue #4520, where a flaky database connection was throwing an exception when trying to read existing session data when a request accessed the session. As null was returned rather than an exception, it seemed as if the session merely didn't exist. When application code later in the request handling asked to create a session, normal practise is to be able to use that same id, if that id is already in use (this is part of cross-context dispatch). As the faulty session had not been detected and deleted, it looked like the same id could be re-used causing a primary key clash.\nCloses #4520", "createdAt": "2020-01-30T10:10:06Z", "url": "https://github.com/eclipse/jetty.project/pull/4528", "merged": true, "mergeCommit": {"oid": "ecd0fe97f7bd7dd292325c4cdf5c97b096c0c1e3"}, "closed": true, "closedAt": "2020-02-01T10:13:58Z", "author": {"login": "janbartel"}, "timelineItems": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABb_Xf2nAH2gAyMzY4OTg2MzUyOmMxOTg5OGRlNzEyODZiYzBjYTYwNzAwMTgxMjhmODM3MTE0NmQwNTI=", "endCursor": "Y3Vyc29yOnYyOpPPAAABb_y1wwAH2gAyMzY4OTg2MzUyOjA3MzJhNjllZWFmM2ExNmM4ODIzMTE5Y2M1MzY1ZDYzOWQ1ZGY2ZGE=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "c19898de71286bc0ca6070018128f8371146d052", "author": {"user": {"login": "janbartel", "name": "Jan Bartel"}}, "url": "https://github.com/eclipse/jetty.project/commit/c19898de71286bc0ca6070018128f8371146d052", "committedDate": "2020-01-30T09:54:46Z", "message": "Issue #4520 Reinstate throw of UnreadableSessionDataException\n\nSigned-off-by: Jan Bartel <janb@webtide.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzUxMzY5ODYy", "url": "https://github.com/eclipse/jetty.project/pull/4528#pullrequestreview-351369862", "createdAt": "2020-01-31T09:07:17Z", "commit": {"oid": "c19898de71286bc0ca6070018128f8371146d052"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0zMVQwOTowNzoxOFrOFkFHig==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0zMVQwOToyNjozMFrOFkFmnA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzM3NjkwNg==", "bodyText": "Since now you are rethrowing the exception, you don't want to log it at warn level at 370 - otherwise it will be printed out twice.", "url": "https://github.com/eclipse/jetty.project/pull/4528#discussion_r373376906", "createdAt": "2020-01-31T09:07:18Z", "author": {"login": "sbordet"}, "path": "jetty-server/src/main/java/org/eclipse/jetty/server/session/AbstractSessionCache.java", "diffHunk": "@@ -366,10 +368,15 @@ protected Session getAndEnter(String id, boolean enter) throws Exception\n             catch (Exception e)\n             {\n                 LOG.warn(\"Error loading session {}\", id, e);\n+                exception.set(e);\n                 return null;\n             }\n         });\n \n+        Exception ex = exception.get();\n+        if (ex != null)\n+            throw ex;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c19898de71286bc0ca6070018128f8371146d052"}, "originalPosition": 35}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzM3ODE4MA==", "bodyText": "Remove System.err.", "url": "https://github.com/eclipse/jetty.project/pull/4528#discussion_r373378180", "createdAt": "2020-01-31T09:10:30Z", "author": {"login": "sbordet"}, "path": "tests/test-sessions/test-sessions-common/src/test/java/org/eclipse/jetty/server/session/AbstractSessionCacheTest.java", "diffHunk": "@@ -43,6 +48,62 @@\n  */\n public abstract class AbstractSessionCacheTest\n {\n+    public static class UnreadableSessionDataStore extends AbstractSessionDataStore\n+    {\n+        public Set<String> _deletedIds = ConcurrentHashMap.newKeySet();\n+        int _count;\n+        int _calls;\n+        SessionData _data;\n+\n+        public UnreadableSessionDataStore(int count, SessionData data)\n+        {\n+            _count = count;\n+            _data = data;\n+        }\n+\n+        @Override\n+        public boolean isPassivating()\n+        {\n+            return false;\n+        }\n+\n+        @Override\n+        public boolean exists(String id) throws Exception\n+        {\n+            if (!_deletedIds.contains(id))\n+                return true;\n+            return false;\n+        }\n+\n+        @Override\n+        public boolean delete(String id) throws Exception\n+        {\n+            _deletedIds.add(id);\n+            return true;\n+        }\n+\n+        @Override\n+        public void doStore(String id, SessionData data, long lastSaveTime) throws Exception\n+        {\n+            System.err.println(\"DOSTORE: \" + id + \" lastsave=\" + lastSaveTime);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c19898de71286bc0ca6070018128f8371146d052"}, "originalPosition": 60}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzM3OTY5Mg==", "bodyText": "Replace with assertNotEquals().", "url": "https://github.com/eclipse/jetty.project/pull/4528#discussion_r373379692", "createdAt": "2020-01-31T09:14:12Z", "author": {"login": "sbordet"}, "path": "tests/test-sessions/test-sessions-common/src/test/java/org/eclipse/jetty/server/session/AbstractSessionCacheTest.java", "diffHunk": "@@ -65,7 +126,56 @@ public void sessionDidActivate(HttpSessionEvent se)\n     public abstract AbstractSessionCacheFactory newSessionCacheFactory(int evictionPolicy, boolean saveOnCreate, \n                                                                        boolean saveOnInactiveEvict, boolean removeUnloadableSessions,\n                                                                        boolean flushOnResponseCommit);\n-    \n+\n+    /**\n+     * Test that a session that exists in the datastore, but that cannot be\n+     * read will be invalidated and deleted, and thus a request to re-use that\n+     * same id will not succeed.\n+     * \n+     * @throws Exception\n+     */\n+    @Test\n+    public void testUnreadableSession() throws Exception\n+    {\n+        Server server = new Server();\n+        server.setSessionIdManager(new DefaultSessionIdManager(server));\n+\n+        ServletContextHandler context = new ServletContextHandler(ServletContextHandler.SESSIONS);\n+        context.setContextPath(\"/test\");\n+        context.setServer(server);\n+        server.setHandler(context);\n+\n+        AbstractSessionCacheFactory cacheFactory = newSessionCacheFactory(SessionCache.NEVER_EVICT, false, false, false, false);\n+        SessionCache cache = cacheFactory.getSessionCache(context.getSessionHandler());\n+\n+        //prefill the datastore with a session that will be treated as unreadable\n+        UnreadableSessionDataStore store = new UnreadableSessionDataStore(1, new SessionData(\"1234\", \"/test\", \"0.0.0.0\", System.currentTimeMillis(), 0,0, -1));\n+        cache.setSessionDataStore(store);\n+        context.getSessionHandler().setSessionCache(cache);\n+        server.start();\n+\n+        try (StacklessLogging stackless = new StacklessLogging(Log.getLogger(\"org.eclipse.jetty.server.session\")))\n+        {\n+            //check that session 1234 cannot be read, ie returns null AND\n+            //that it is deleted in the datastore\n+            Session session = context.getSessionHandler().getSession(\"1234\");\n+            assertNull(session);\n+            assertTrue(store._deletedIds.contains(\"1234\"));\n+\n+            //now try to make a session with the same id as if from a request with\n+            //a SESSION_ID cookie set\n+            Request request = new Request(null, null);\n+            request.setRequestedSessionId(\"1234\");\n+            HttpSession newSession = context.getSessionHandler().newHttpSession(request);\n+            assertFalse(\"1234\".equals(newSession.getId()));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c19898de71286bc0ca6070018128f8371146d052"}, "originalPosition": 128}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzM4MDMzNA==", "bodyText": "Simplify into return !....", "url": "https://github.com/eclipse/jetty.project/pull/4528#discussion_r373380334", "createdAt": "2020-01-31T09:15:44Z", "author": {"login": "sbordet"}, "path": "tests/test-sessions/test-sessions-common/src/test/java/org/eclipse/jetty/server/session/AbstractSessionCacheTest.java", "diffHunk": "@@ -43,6 +48,62 @@\n  */\n public abstract class AbstractSessionCacheTest\n {\n+    public static class UnreadableSessionDataStore extends AbstractSessionDataStore\n+    {\n+        public Set<String> _deletedIds = ConcurrentHashMap.newKeySet();\n+        int _count;\n+        int _calls;\n+        SessionData _data;\n+\n+        public UnreadableSessionDataStore(int count, SessionData data)\n+        {\n+            _count = count;\n+            _data = data;\n+        }\n+\n+        @Override\n+        public boolean isPassivating()\n+        {\n+            return false;\n+        }\n+\n+        @Override\n+        public boolean exists(String id) throws Exception\n+        {\n+            if (!_deletedIds.contains(id))\n+                return true;\n+            return false;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c19898de71286bc0ca6070018128f8371146d052"}, "originalPosition": 47}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzM4NDU0OA==", "bodyText": "Unnecessary empty line.", "url": "https://github.com/eclipse/jetty.project/pull/4528#discussion_r373384548", "createdAt": "2020-01-31T09:25:51Z", "author": {"login": "sbordet"}, "path": "tests/test-sessions/test-sessions-common/src/test/java/org/eclipse/jetty/server/session/AbstractSessionCacheTest.java", "diffHunk": "@@ -65,7 +126,56 @@ public void sessionDidActivate(HttpSessionEvent se)\n     public abstract AbstractSessionCacheFactory newSessionCacheFactory(int evictionPolicy, boolean saveOnCreate, \n                                                                        boolean saveOnInactiveEvict, boolean removeUnloadableSessions,\n                                                                        boolean flushOnResponseCommit);\n-    \n+\n+    /**\n+     * Test that a session that exists in the datastore, but that cannot be\n+     * read will be invalidated and deleted, and thus a request to re-use that\n+     * same id will not succeed.\n+     * \n+     * @throws Exception\n+     */\n+    @Test\n+    public void testUnreadableSession() throws Exception\n+    {\n+        Server server = new Server();\n+        server.setSessionIdManager(new DefaultSessionIdManager(server));\n+\n+        ServletContextHandler context = new ServletContextHandler(ServletContextHandler.SESSIONS);\n+        context.setContextPath(\"/test\");\n+        context.setServer(server);\n+        server.setHandler(context);\n+\n+        AbstractSessionCacheFactory cacheFactory = newSessionCacheFactory(SessionCache.NEVER_EVICT, false, false, false, false);\n+        SessionCache cache = cacheFactory.getSessionCache(context.getSessionHandler());\n+\n+        //prefill the datastore with a session that will be treated as unreadable\n+        UnreadableSessionDataStore store = new UnreadableSessionDataStore(1, new SessionData(\"1234\", \"/test\", \"0.0.0.0\", System.currentTimeMillis(), 0,0, -1));\n+        cache.setSessionDataStore(store);\n+        context.getSessionHandler().setSessionCache(cache);\n+        server.start();\n+\n+        try (StacklessLogging stackless = new StacklessLogging(Log.getLogger(\"org.eclipse.jetty.server.session\")))\n+        {\n+            //check that session 1234 cannot be read, ie returns null AND\n+            //that it is deleted in the datastore\n+            Session session = context.getSessionHandler().getSession(\"1234\");\n+            assertNull(session);\n+            assertTrue(store._deletedIds.contains(\"1234\"));\n+\n+            //now try to make a session with the same id as if from a request with\n+            //a SESSION_ID cookie set\n+            Request request = new Request(null, null);\n+            request.setRequestedSessionId(\"1234\");\n+            HttpSession newSession = context.getSessionHandler().newHttpSession(request);\n+            assertFalse(\"1234\".equals(newSession.getId()));\n+        }\n+        finally\n+        {\n+            server.stop();\n+        }\n+    }\n+\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c19898de71286bc0ca6070018128f8371146d052"}, "originalPosition": 136}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzM4NDg2MA==", "bodyText": "No need for final here.", "url": "https://github.com/eclipse/jetty.project/pull/4528#discussion_r373384860", "createdAt": "2020-01-31T09:26:30Z", "author": {"login": "sbordet"}, "path": "jetty-server/src/main/java/org/eclipse/jetty/server/session/AbstractSessionCache.java", "diffHunk": "@@ -334,12 +335,13 @@ public Session get(String id) throws Exception\n      * \n      * @param id The session to retrieve\n      * @param enter if true, the usage count of the session will be incremented\n-     * @return\n-     * @throws Exception\n+     * @return the session if it exists, null otherwise\n+     * @throws Exception if the session cannot be loaded\n      */\n     protected Session getAndEnter(String id, boolean enter) throws Exception\n     {\n         Session session = null;\n+        final AtomicReference<Exception> exception = new AtomicReference<Exception>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c19898de71286bc0ca6070018128f8371146d052"}, "originalPosition": 20}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzUxNDA3NDQy", "url": "https://github.com/eclipse/jetty.project/pull/4528#pullrequestreview-351407442", "createdAt": "2020-01-31T10:15:09Z", "commit": {"oid": "c19898de71286bc0ca6070018128f8371146d052"}, "state": "APPROVED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0zMVQxMDoxNTowOVrOFkG39g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0zMVQxMDoxODowNFrOFkG87g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzQwNTY4Ng==", "bodyText": "Perhaps you can just use _data in the implementation, so you won't need to remember deleted ids.", "url": "https://github.com/eclipse/jetty.project/pull/4528#discussion_r373405686", "createdAt": "2020-01-31T10:15:09Z", "author": {"login": "sbordet"}, "path": "tests/test-sessions/test-sessions-common/src/test/java/org/eclipse/jetty/server/session/AbstractSessionCacheTest.java", "diffHunk": "@@ -43,6 +48,62 @@\n  */\n public abstract class AbstractSessionCacheTest\n {\n+    public static class UnreadableSessionDataStore extends AbstractSessionDataStore\n+    {\n+        public Set<String> _deletedIds = ConcurrentHashMap.newKeySet();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c19898de71286bc0ca6070018128f8371146d052"}, "originalPosition": 25}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzQwNjk1OA==", "bodyText": "Please add a comment here about the fact that since the session has been deleted, its id cannot be reused, and delete the javadoc of the method (which basically says the same, but in the wrong spot - and who reads test javadocs anyway?!? \ud83d\ude04)", "url": "https://github.com/eclipse/jetty.project/pull/4528#discussion_r373406958", "createdAt": "2020-01-31T10:18:04Z", "author": {"login": "sbordet"}, "path": "tests/test-sessions/test-sessions-common/src/test/java/org/eclipse/jetty/server/session/AbstractSessionCacheTest.java", "diffHunk": "@@ -65,7 +126,56 @@ public void sessionDidActivate(HttpSessionEvent se)\n     public abstract AbstractSessionCacheFactory newSessionCacheFactory(int evictionPolicy, boolean saveOnCreate, \n                                                                        boolean saveOnInactiveEvict, boolean removeUnloadableSessions,\n                                                                        boolean flushOnResponseCommit);\n-    \n+\n+    /**\n+     * Test that a session that exists in the datastore, but that cannot be\n+     * read will be invalidated and deleted, and thus a request to re-use that\n+     * same id will not succeed.\n+     * \n+     * @throws Exception\n+     */\n+    @Test\n+    public void testUnreadableSession() throws Exception\n+    {\n+        Server server = new Server();\n+        server.setSessionIdManager(new DefaultSessionIdManager(server));\n+\n+        ServletContextHandler context = new ServletContextHandler(ServletContextHandler.SESSIONS);\n+        context.setContextPath(\"/test\");\n+        context.setServer(server);\n+        server.setHandler(context);\n+\n+        AbstractSessionCacheFactory cacheFactory = newSessionCacheFactory(SessionCache.NEVER_EVICT, false, false, false, false);\n+        SessionCache cache = cacheFactory.getSessionCache(context.getSessionHandler());\n+\n+        //prefill the datastore with a session that will be treated as unreadable\n+        UnreadableSessionDataStore store = new UnreadableSessionDataStore(1, new SessionData(\"1234\", \"/test\", \"0.0.0.0\", System.currentTimeMillis(), 0,0, -1));\n+        cache.setSessionDataStore(store);\n+        context.getSessionHandler().setSessionCache(cache);\n+        server.start();\n+\n+        try (StacklessLogging stackless = new StacklessLogging(Log.getLogger(\"org.eclipse.jetty.server.session\")))\n+        {\n+            //check that session 1234 cannot be read, ie returns null AND\n+            //that it is deleted in the datastore\n+            Session session = context.getSessionHandler().getSession(\"1234\");\n+            assertNull(session);\n+            assertTrue(store._deletedIds.contains(\"1234\"));\n+\n+            //now try to make a session with the same id as if from a request with\n+            //a SESSION_ID cookie set\n+            Request request = new Request(null, null);\n+            request.setRequestedSessionId(\"1234\");\n+            HttpSession newSession = context.getSessionHandler().newHttpSession(request);\n+            assertFalse(\"1234\".equals(newSession.getId()));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzM3OTY5Mg=="}, "originalCommit": {"oid": "c19898de71286bc0ca6070018128f8371146d052"}, "originalPosition": 128}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f6a09077bd4f06f7eca15ff25edd78a565562117", "author": {"user": {"login": "janbartel", "name": "Jan Bartel"}}, "url": "https://github.com/eclipse/jetty.project/commit/f6a09077bd4f06f7eca15ff25edd78a565562117", "committedDate": "2020-01-31T11:52:27Z", "message": "Issue #4520 Updates after review\n\nSigned-off-by: Jan Bartel <janb@webtide.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0732a69eeaf3a16c8823119cc5365d639d5df6da", "author": {"user": {"login": "janbartel", "name": "Jan Bartel"}}, "url": "https://github.com/eclipse/jetty.project/commit/0732a69eeaf3a16c8823119cc5365d639d5df6da", "committedDate": "2020-01-31T17:46:08Z", "message": "Issue #4520 Ensure LOG.warns contain exception\n\nSigned-off-by: Jan Bartel <janb@webtide.com>"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 567, "cost": 1, "resetAt": "2021-11-01T13:51:04Z"}}}