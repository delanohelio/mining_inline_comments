{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDAzNjQ0NDU3", "number": 4777, "title": "Immutable HttpFields and MetaData", "bodyText": "This is an experimental branch to see the impact of making MetaData immutable.  This is currently against 10, but may be for a 10.1 or later version.", "createdAt": "2020-04-15T09:26:33Z", "url": "https://github.com/eclipse/jetty.project/pull/4777", "merged": true, "mergeCommit": {"oid": "8c7e34f37df0b208e14801d70c59f42b218dcd87"}, "closed": true, "closedAt": "2020-04-28T11:36:44Z", "author": {"login": "gregw"}, "timelineItems": {"totalCount": 51, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcX0Pi5gH2gAyNDAzNjQ0NDU3OmUzN2EzNGM5YjgzMWQ0MWY4MmZkZjMxYzIyMTI5OWIyNjM1ZTE4YzQ=", "endCursor": "Y3Vyc29yOnYyOpPPAAABccAB5ZAH2gAyNDAzNjQ0NDU3Ojc5YmI5Zjc1ZWFlNDEwMWYzMWNkZmJkMTM3ZGM1ODdhMWM1YTA4MTM=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "e37a34c9b831d41f82fdf31c221299b2635e18c4", "author": {"user": {"login": "gregw", "name": "Greg Wilkins"}}, "url": "https://github.com/eclipse/jetty.project/commit/e37a34c9b831d41f82fdf31c221299b2635e18c4", "committedDate": "2020-04-15T08:58:23Z", "message": "Immutable version of HttpFields\n\nPreserve API and usage of HttpFields class while providing a read only interface and immutable implementation.\n\nSigned-off-by: Greg Wilkins <gregw@webtide.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "75df043c3f976a1cef73aafc609c5b5169a40487", "author": {"user": {"login": "gregw", "name": "Greg Wilkins"}}, "url": "https://github.com/eclipse/jetty.project/commit/75df043c3f976a1cef73aafc609c5b5169a40487", "committedDate": "2020-04-15T09:20:52Z", "message": "Immutable version of HttpFields\n\nUse an ArrayList in HttpFields. While slightly slower than the array, it will mostly be used as a builder pattern for an Immutable\n\nSigned-off-by: Greg Wilkins <gregw@webtide.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "753e02cf6be03572eb242b826998431993056a79", "author": {"user": {"login": "gregw", "name": "Greg Wilkins"}}, "url": "https://github.com/eclipse/jetty.project/commit/753e02cf6be03572eb242b826998431993056a79", "committedDate": "2020-04-15T11:40:22Z", "message": "Immutable version of HttpFields\n\nFixed exception type.\n\nSigned-off-by: Greg Wilkins <gregw@webtide.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "53bf5a5ca6847702db162c04dcd52b93fbffcecb", "author": {"user": {"login": "gregw", "name": "Greg Wilkins"}}, "url": "https://github.com/eclipse/jetty.project/commit/53bf5a5ca6847702db162c04dcd52b93fbffcecb", "committedDate": "2020-04-15T21:25:05Z", "message": "Immutable version of HttpFields\n\nasImmutable method\n\nSigned-off-by: Greg Wilkins <gregw@webtide.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d9837d93b8ab5103a259250a7052d12a56af44d6", "author": {"user": {"login": "gregw", "name": "Greg Wilkins"}}, "url": "https://github.com/eclipse/jetty.project/commit/d9837d93b8ab5103a259250a7052d12a56af44d6", "committedDate": "2020-04-16T09:25:30Z", "message": "Immutable MetaData\n\nMade HttpURIU immutable with a builder pattern.\nMetaData immutable and working within http module.\n\nSigned-off-by: Greg Wilkins <gregw@webtide.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk0NDcxOTEw", "url": "https://github.com/eclipse/jetty.project/pull/4777#pullrequestreview-394471910", "createdAt": "2020-04-16T09:48:26Z", "commit": {"oid": "d9837d93b8ab5103a259250a7052d12a56af44d6"}, "state": "COMMENTED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNlQwOTo0ODoyNlrOGGdatg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNlQxMDowMDoyNFrOGGd4uQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTQyNjYxNA==", "bodyText": "Equivalent to:\nreturn Stream.of(_fields).iterator();", "url": "https://github.com/eclipse/jetty.project/pull/4777#discussion_r409426614", "createdAt": "2020-04-16T09:48:26Z", "author": {"login": "lorban"}, "path": "jetty-http/src/main/java/org/eclipse/jetty/http/HttpFields.java", "diffHunk": "@@ -724,337 +466,163 @@ public HttpField remove(HttpHeader name)\n     public HttpField remove(String name)\n     {\n         HttpField removed = null;\n-        for (int i = _size; i-- > 0; )\n+        for (ListIterator<HttpField> i = listIterator(); i.hasNext();)\n         {\n-            HttpField f = _fields[i];\n+            HttpField f = i.next();\n             if (f.getName().equalsIgnoreCase(name))\n             {\n                 removed = f;\n-                System.arraycopy(_fields, i + 1, _fields, i, --_size - i);\n+                i.remove();\n             }\n         }\n         return removed;\n     }\n \n-    /**\n-     * Get a header as an long value. Returns the value of an integer field or -1 if not found. The\n-     * case of the field name is ignored.\n-     *\n-     * @param name the case-insensitive field name\n-     * @return the value of the field as a long\n-     * @throws NumberFormatException If bad long found\n-     */\n-    public long getLongField(String name) throws NumberFormatException\n-    {\n-        HttpField field = getField(name);\n-        return field == null ? -1L : field.getLongValue();\n-    }\n-\n-    /**\n-     * Get a header as a date value. Returns the value of a date field, or -1 if not found. The case\n-     * of the field name is ignored.\n-     *\n-     * @param name the case-insensitive field name\n-     * @return the value of the field as a number of milliseconds since unix epoch\n-     */\n-    public long getDateField(String name)\n-    {\n-        HttpField field = getField(name);\n-        if (field == null)\n-            return -1;\n-\n-        String val = valueParameters(field.getValue(), null);\n-        if (val == null)\n-            return -1;\n-\n-        final long date = DateParser.parseDate(val);\n-        if (date == -1)\n-            throw new IllegalArgumentException(\"Cannot convert date: \" + val);\n-        return date;\n-    }\n-\n-    /**\n-     * Sets the value of an long field.\n-     *\n-     * @param name the field name\n-     * @param value the field long value\n-     */\n-    public void putLongField(HttpHeader name, long value)\n-    {\n-        String v = Long.toString(value);\n-        put(name, v);\n-    }\n-\n-    /**\n-     * Sets the value of an long field.\n-     *\n-     * @param name the field name\n-     * @param value the field long value\n-     */\n-    public void putLongField(String name, long value)\n-    {\n-        String v = Long.toString(value);\n-        put(name, v);\n-    }\n-\n-    /**\n-     * Sets the value of a date field.\n-     *\n-     * @param name the field name\n-     * @param date the field date value\n-     */\n-    public void putDateField(HttpHeader name, long date)\n-    {\n-        String d = DateGenerator.formatDate(date);\n-        put(name, d);\n-    }\n-\n-    /**\n-     * Sets the value of a date field.\n-     *\n-     * @param name the field name\n-     * @param date the field date value\n-     */\n-    public void putDateField(String name, long date)\n+    public int size()\n     {\n-        String d = DateGenerator.formatDate(date);\n-        put(name, d);\n+        return _fields.size();\n     }\n \n-    /**\n-     * Sets the value of a date field.\n-     *\n-     * @param name the field name\n-     * @param date the field date value\n-     */\n-    public void addDateField(String name, long date)\n+    @Override\n+    public Stream<HttpField> stream()\n     {\n-        String d = DateGenerator.formatDate(date);\n-        add(name, d);\n+        return _fields.stream();\n     }\n \n     @Override\n-    public int hashCode()\n+    public String toString()\n     {\n-        int hash = 0;\n-        for (HttpField field : _fields)\n-        {\n-            hash += field.hashCode();\n-        }\n-        return hash;\n+        return asString();\n     }\n \n-    @Override\n-    public boolean equals(Object o)\n+    protected String addCSV(QuotedCSV existing, String... values)\n     {\n-        if (this == o)\n-            return true;\n-        if (!(o instanceof HttpFields))\n-            return false;\n-\n-        HttpFields that = (HttpFields)o;\n-\n-        // Order is not important, so we cannot rely on List.equals().\n-        if (size() != that.size())\n-            return false;\n-\n-        loop:\n-        for (HttpField fi : this)\n+        // remove any existing values from the new values\n+        boolean add = true;\n+        if (existing != null && !existing.isEmpty())\n         {\n-            for (HttpField fa : that)\n+            add = false;\n+\n+            for (int i = values.length; i-- > 0; )\n             {\n-                if (fi.equals(fa))\n-                    continue loop;\n+                String unquoted = QuotedCSV.unquote(values[i]);\n+                if (existing.getValues().contains(unquoted))\n+                    values[i] = null;\n+                else\n+                    add = true;\n             }\n-            return false;\n         }\n-        return true;\n-    }\n \n-    @Override\n-    public String toString()\n-    {\n-        try\n+        if (add)\n         {\n-            StringBuilder buffer = new StringBuilder();\n-            for (HttpField field : this)\n+            StringBuilder value = new StringBuilder();\n+            for (String v : values)\n             {\n-                if (field != null)\n-                {\n-                    String tmp = field.getName();\n-                    if (tmp != null)\n-                        buffer.append(tmp);\n-                    buffer.append(\": \");\n-                    tmp = field.getValue();\n-                    if (tmp != null)\n-                        buffer.append(tmp);\n-                    buffer.append(\"\\r\\n\");\n-                }\n+                if (v == null)\n+                    continue;\n+                if (value.length() > 0)\n+                    value.append(\", \");\n+                value.append(v);\n             }\n-            buffer.append(\"\\r\\n\");\n-            return buffer.toString();\n-        }\n-        catch (Exception e)\n-        {\n-            LOG.warn(\"Unable to get fields as String\", e);\n-            return e.toString();\n-        }\n-    }\n-\n-    public void clear()\n-    {\n-        _size = 0;\n-    }\n-\n-    public void addAll(HttpFields fields)\n-    {\n-        for (int i = 0; i < fields._size; i++)\n-        {\n-            add(fields._fields[i]);\n+            if (value.length() > 0)\n+                return value.toString();\n         }\n-    }\n \n-    /**\n-     * Get field value without parameters. Some field values can have parameters. This method separates the\n-     * value from the parameters and optionally populates a map with the parameters. For example:\n-     *\n-     * <PRE>\n-     *\n-     * FieldName : Value ; param1=val1 ; param2=val2\n-     *\n-     * </PRE>\n-     *\n-     * @param value The Field value, possibly with parameters.\n-     * @return The value.\n-     */\n-    public static String stripParameters(String value)\n-    {\n-        if (value == null)\n-            return null;\n-\n-        int i = value.indexOf(';');\n-        if (i < 0)\n-            return value;\n-        return value.substring(0, i).trim();\n+        return null;\n     }\n \n     /**\n-     * Get field value parameters. Some field values can have parameters. This method separates the\n-     * value from the parameters and optionally populates a map with the parameters. For example:\n-     *\n-     * <PRE>\n+     * HTTP Fields. A collection of HTTP header and or Trailer fields.\n      *\n-     * FieldName : Value ; param1=val1 ; param2=val2\n-     *\n-     * </PRE>\n+     * <p>This class is not synchronized as it is expected that modifications will only be performed by a\n+     * single thread.\n      *\n-     * @param value The Field value, possibly with parameters.\n-     * @param parameters A map to populate with the parameters, or null\n-     * @return The value.\n+     * <p>The cookie handling provided by this class is guided by the Servlet specification and RFC6265.\n      */\n-    public static String valueParameters(String value, Map<String, String> parameters)\n+    private static class Immutable implements HttpFieldList\n     {\n-        if (value == null)\n-            return null;\n+        private final HttpField[] _fields;\n \n-        int i = value.indexOf(';');\n-        if (i < 0)\n-            return value;\n-        if (parameters == null)\n-            return value.substring(0, i).trim();\n-\n-        StringTokenizer tok1 = new QuotedStringTokenizer(value.substring(i), \";\", false, true);\n-        while (tok1.hasMoreTokens())\n+        /**\n+         * Initialize HttpFields from copy.\n+         *\n+         * @param fields the fields to copy data from\n+         */\n+        Immutable(HttpField[] fields)\n         {\n-            String token = tok1.nextToken();\n-            StringTokenizer tok2 = new QuotedStringTokenizer(token, \"= \");\n-            if (tok2.hasMoreTokens())\n-            {\n-                String paramName = tok2.nextToken();\n-                String paramVal = null;\n-                if (tok2.hasMoreTokens())\n-                    paramVal = tok2.nextToken();\n-                parameters.put(paramName, paramVal);\n-            }\n+            _fields = fields;\n         }\n \n-        return value.substring(0, i).trim();\n-    }\n-\n-    private class ListItr implements ListIterator<HttpField>\n-    {\n-        int _cursor;       // index of next element to return\n-        int _current = -1;\n-\n         @Override\n-        public boolean hasNext()\n+        public HttpFieldList asImmutable()\n         {\n-            return _cursor != _size;\n+            return this;\n         }\n \n         @Override\n-        public HttpField next()\n+        public boolean equals(Object o)\n         {\n-            if (_cursor == _size)\n-                throw new NoSuchElementException();\n-            _current = _cursor++;\n-            return _fields[_current];\n-        }\n+            if (this == o)\n+                return true;\n+            if (!(o instanceof Immutable))\n+                return false;\n \n-        @Override\n-        public void remove()\n-        {\n-            if (_current < 0)\n-                throw new IllegalStateException();\n-            _size--;\n-            System.arraycopy(_fields, _current + 1, _fields, _current, _size - _current);\n-            _fields[_size] = null;\n-            _cursor = _current;\n-            _current = -1;\n+            return isEqualTo((HttpFieldList)o);\n         }\n \n         @Override\n-        public boolean hasPrevious()\n+        public HttpField getField(int index)\n         {\n-            return _cursor > 0;\n+            if (index >= _fields.length)\n+                throw new NoSuchElementException();\n+            return _fields[index];\n         }\n \n         @Override\n-        public HttpField previous()\n+        public int hashCode()\n         {\n-            if (_cursor == 0)\n-                throw new NoSuchElementException();\n-            _current = --_cursor;\n-            return _fields[_current];\n+            return asHashCode();\n         }\n \n         @Override\n-        public int nextIndex()\n+        public Iterator<HttpField> iterator()\n         {\n-            return _cursor + 1;\n+            return new Iterator<>()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d9837d93b8ab5103a259250a7052d12a56af44d6"}, "originalPosition": 1132}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTQzMTI2Mg==", "bodyText": "Why aren't the above two private?", "url": "https://github.com/eclipse/jetty.project/pull/4777#discussion_r409431262", "createdAt": "2020-04-16T09:55:51Z", "author": {"login": "lorban"}, "path": "jetty-http/src/main/java/org/eclipse/jetty/http/HttpURI.java", "diffHunk": "@@ -50,527 +49,126 @@\n  */\n public class HttpURI\n {\n-    private enum State\n+    private final String _scheme;\n+    private final String _user;\n+    private final String _host;\n+    private final int _port;\n+    private final String _path;\n+    private final String _param;\n+    private final String _query;\n+    private final String _fragment;\n+    private String _uri;\n+    private String _decodedPath;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d9837d93b8ab5103a259250a7052d12a56af44d6"}, "originalPosition": 22}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTQzMzM4OQ==", "bodyText": "This class' immutability is... surprising. I'm not fond of the internal interface TBH.", "url": "https://github.com/eclipse/jetty.project/pull/4777#discussion_r409433389", "createdAt": "2020-04-16T09:59:01Z", "author": {"login": "lorban"}, "path": "jetty-http/src/main/java/org/eclipse/jetty/http/HttpFields.java", "diffHunk": "@@ -45,12 +36,9 @@\n  *\n  * <p>The cookie handling provided by this class is guided by the Servlet specification and RFC6265.\n  */\n-public class HttpFields implements Iterable<HttpField>\n+public class HttpFields implements Iterable<HttpField>, HttpFieldList", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d9837d93b8ab5103a259250a7052d12a56af44d6"}, "originalPosition": 29}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTQzNDI5Nw==", "bodyText": "Why isn't that field immutable?", "url": "https://github.com/eclipse/jetty.project/pull/4777#discussion_r409434297", "createdAt": "2020-04-16T10:00:24Z", "author": {"login": "lorban"}, "path": "jetty-http/src/main/java/org/eclipse/jetty/http/MetaData.java", "diffHunk": "@@ -18,35 +18,44 @@\n \n package org.eclipse.jetty.http;\n \n-import java.util.Collections;\n import java.util.Iterator;\n import java.util.function.Supplier;\n \n public class MetaData implements Iterable<HttpField>\n {\n-    private HttpVersion _httpVersion;\n-    private final HttpFields _fields;\n-    private long _contentLength;\n-    private Supplier<HttpFields> _trailers;\n-\n-    public MetaData(HttpVersion version, HttpFields fields)\n+    private static final Supplier<HttpFieldList> SELF_SUPPLIED_TRAILORS = () -> null;\n+    private static final HttpFieldList SUPPLIED_TRAILERS = new HttpFields().asImmutable();\n+    private final HttpVersion _httpVersion;\n+    private final HttpFieldList _fields;\n+    private final long _contentLengthKnown;\n+    private final long _contentLengthField;\n+    private final Supplier<HttpFieldList> _trailerSupplier;\n+    private HttpFieldList _trailers;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d9837d93b8ab5103a259250a7052d12a56af44d6"}, "originalPosition": 23}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f2f08e50b1f2e43133bc372c0d8297893ebcad45", "author": {"user": {"login": "gregw", "name": "Greg Wilkins"}}, "url": "https://github.com/eclipse/jetty.project/commit/f2f08e50b1f2e43133bc372c0d8297893ebcad45", "committedDate": "2020-04-16T12:55:13Z", "message": "Immutable MetaData\n\nFixes from review\n\nSigned-off-by: Greg Wilkins <gregw@webtide.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8d5b036fe54ae96194ae268895e8f7830672c426", "author": {"user": {"login": "gregw", "name": "Greg Wilkins"}}, "url": "https://github.com/eclipse/jetty.project/commit/8d5b036fe54ae96194ae268895e8f7830672c426", "committedDate": "2020-04-17T11:45:35Z", "message": "Immutable MetaData\n\nPassing tests upto and including jetty-server\n\nSigned-off-by: Greg Wilkins <gregw@webtide.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8de4fb6ed9465a91b3c206f48223b8ce6e9a8834", "author": {"user": {"login": "gregw", "name": "Greg Wilkins"}}, "url": "https://github.com/eclipse/jetty.project/commit/8de4fb6ed9465a91b3c206f48223b8ce6e9a8834", "committedDate": "2020-04-17T13:28:28Z", "message": "Immutable MetaData\n\nCleanup of HttpURI.Builder API as suggested in PR.\n\nSigned-off-by: Greg Wilkins <gregw@webtide.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c1010f3e628dff69f69945915f2b2b244829a73d", "author": {"user": {"login": "gregw", "name": "Greg Wilkins"}}, "url": "https://github.com/eclipse/jetty.project/commit/c1010f3e628dff69f69945915f2b2b244829a73d", "committedDate": "2020-04-17T14:10:58Z", "message": "Immutable MetaData\n\nAdded builder for MetaData.Request\n\nSigned-off-by: Greg Wilkins <gregw@webtide.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1bb6ba471fbd7f3ed7c5984a47498ccf5ded8614", "author": {"user": {"login": "gregw", "name": "Greg Wilkins"}}, "url": "https://github.com/eclipse/jetty.project/commit/1bb6ba471fbd7f3ed7c5984a47498ccf5ded8614", "committedDate": "2020-04-18T06:56:28Z", "message": "Merge remote-tracking branch 'origin/jetty-10.0.x' into jetty-10.0.x-ImmutableMetaData"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c0b98a3b3b4c3c9d8378f3fcb60f69376d6f07cc", "author": {"user": {"login": "gregw", "name": "Greg Wilkins"}}, "url": "https://github.com/eclipse/jetty.project/commit/c0b98a3b3b4c3c9d8378f3fcb60f69376d6f07cc", "committedDate": "2020-04-18T07:13:51Z", "message": "Immutable MetaData\n\nmore api fixes\n\nSigned-off-by: Greg Wilkins <gregw@webtide.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4c334e8611ce8dd894b8fa1bdc795a8cffc95d02", "author": {"user": {"login": "gregw", "name": "Greg Wilkins"}}, "url": "https://github.com/eclipse/jetty.project/commit/4c334e8611ce8dd894b8fa1bdc795a8cffc95d02", "committedDate": "2020-04-18T16:55:47Z", "message": "Immutable MetaData\n\nWIP making HttpFiels itself immutable.  Currently working up to jetty-servlet.\n\nNeed to consider if content-length really is meta data and how much and when can we trust it.\n\nSigned-off-by: Greg Wilkins <gregw@webtide.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "23bcdd205555f292f73b4cd74c05bf9169234df6", "author": {"user": {"login": "gregw", "name": "Greg Wilkins"}}, "url": "https://github.com/eclipse/jetty.project/commit/23bcdd205555f292f73b4cd74c05bf9169234df6", "committedDate": "2020-04-19T15:18:49Z", "message": "Immutable MetaData\n\nWIP\n\nNeed to consider if content-length really is meta data and how much and when can we trust it. Also need to consider difference between h2 and h1 authority in metadata.\n\nSigned-off-by: Greg Wilkins <gregw@webtide.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a953f425bc05b09e543313fba8d22f58c06b354a", "author": {"user": {"login": "gregw", "name": "Greg Wilkins"}}, "url": "https://github.com/eclipse/jetty.project/commit/a953f425bc05b09e543313fba8d22f58c06b354a", "committedDate": "2020-04-19T17:06:39Z", "message": "Immutable MetaData WIP\n\njetty-client and jetty-servlet passing tests.\n\nSigned-off-by: Greg Wilkins <gregw@webtide.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "fb81db19733e7a8d8f872a9e60396dc3108b32d7", "author": {"user": {"login": "gregw", "name": "Greg Wilkins"}}, "url": "https://github.com/eclipse/jetty.project/commit/fb81db19733e7a8d8f872a9e60396dc3108b32d7", "committedDate": "2020-04-20T10:18:02Z", "message": "Immutable MetaData WIP\n\nBetter align the style of immutability between `HttpFields` and `HttpURI`.\nThey both now have static build() and from() methods, plus Builder and Immutable implementations.\nPotentially `Builder` could be renamed as `Mutable`\n\nSigned-off-by: Greg Wilkins <gregw@webtide.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "372455a6cae366b26502ec4a17b48aa0d85cb2da", "author": {"user": {"login": "gregw", "name": "Greg Wilkins"}}, "url": "https://github.com/eclipse/jetty.project/commit/372455a6cae366b26502ec4a17b48aa0d85cb2da", "committedDate": "2020-04-20T10:56:46Z", "message": "Immutable MetaData WIP\n\nhttp2-server tests passed\n\nSigned-off-by: Greg Wilkins <gregw@webtide.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "58e458c0139ed41660aa2b98cd6b063d93230413", "author": {"user": {"login": "gregw", "name": "Greg Wilkins"}}, "url": "https://github.com/eclipse/jetty.project/commit/58e458c0139ed41660aa2b98cd6b063d93230413", "committedDate": "2020-04-20T11:22:02Z", "message": "Immutable MetaData WIP\n\nhttp2-client tests passed\n\nSigned-off-by: Greg Wilkins <gregw@webtide.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0215268bc36e278ed7f2316a45efe0054f3e0466", "author": {"user": {"login": "gregw", "name": "Greg Wilkins"}}, "url": "https://github.com/eclipse/jetty.project/commit/0215268bc36e278ed7f2316a45efe0054f3e0466", "committedDate": "2020-04-20T12:56:10Z", "message": "Immutable MetaData WIP\n\ncleann build?\n\nSigned-off-by: Greg Wilkins <gregw@webtide.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "90aae8b33a327f50728f5d3a6af3845c4840003d", "author": {"user": {"login": "gregw", "name": "Greg Wilkins"}}, "url": "https://github.com/eclipse/jetty.project/commit/90aae8b33a327f50728f5d3a6af3845c4840003d", "committedDate": "2020-04-20T12:57:14Z", "message": "Merge branch 'jetty-10.0.x' into jetty-10.0.x-ImmutableMetaData"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c23ea622b5c803d7f85027c84ad1e1e654bc6465", "author": {"user": {"login": "gregw", "name": "Greg Wilkins"}}, "url": "https://github.com/eclipse/jetty.project/commit/c23ea622b5c803d7f85027c84ad1e1e654bc6465", "committedDate": "2020-04-20T13:34:00Z", "message": "Immutable MetaData WIP\n\nfix\n\nSigned-off-by: Greg Wilkins <gregw@webtide.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "cf6df85cf92d312203f0f78c23ae54fac18e2d19", "author": {"user": {"login": "gregw", "name": "Greg Wilkins"}}, "url": "https://github.com/eclipse/jetty.project/commit/cf6df85cf92d312203f0f78c23ae54fac18e2d19", "committedDate": "2020-04-20T16:33:16Z", "message": "Immutable MetaData WIP\n\nmore test fixes\n\nSigned-off-by: Greg Wilkins <gregw@webtide.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e8617da0f1ce5f06dacd446299568d6d231a750c", "author": {"user": {"login": "gregw", "name": "Greg Wilkins"}}, "url": "https://github.com/eclipse/jetty.project/commit/e8617da0f1ce5f06dacd446299568d6d231a750c", "committedDate": "2020-04-20T17:28:57Z", "message": "Immutable MetaData WIP\n\nCleanups, mostly using EMPTY when appropriate.\n\nSigned-off-by: Greg Wilkins <gregw@webtide.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a2d05a17214cccc1aa88fb9b685ee1f068bc9267", "author": {"user": {"login": "gregw", "name": "Greg Wilkins"}}, "url": "https://github.com/eclipse/jetty.project/commit/a2d05a17214cccc1aa88fb9b685ee1f068bc9267", "committedDate": "2020-04-20T17:33:33Z", "message": "Immutable MetaData WIP\n\nCleanups, use immutable\n\nSigned-off-by: Greg Wilkins <gregw@webtide.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f6387a0ec329564d0d07997337600e92d4ca9247", "author": {"user": {"login": "gregw", "name": "Greg Wilkins"}}, "url": "https://github.com/eclipse/jetty.project/commit/f6387a0ec329564d0d07997337600e92d4ca9247", "committedDate": "2020-04-21T10:43:13Z", "message": "Immutable MetaData WIP\n\nNo trailers for connect\n\nSigned-off-by: Greg Wilkins <gregw@webtide.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d1b62c71753f13ab8f6fad0860d478d8f7781d7b", "author": {"user": {"login": "gregw", "name": "Greg Wilkins"}}, "url": "https://github.com/eclipse/jetty.project/commit/d1b62c71753f13ab8f6fad0860d478d8f7781d7b", "committedDate": "2020-04-21T11:26:20Z", "message": "Immutable MetaData WIP\n\nFix CONNECT path handling\n\nSigned-off-by: Greg Wilkins <gregw@webtide.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "79c453b171168f50e787ec079373e84655b8003d", "author": {"user": {"login": "gregw", "name": "Greg Wilkins"}}, "url": "https://github.com/eclipse/jetty.project/commit/79c453b171168f50e787ec079373e84655b8003d", "committedDate": "2020-04-21T13:29:18Z", "message": "Immutable MetaData WIP\n\nfixed rewrite query handling\n\nSigned-off-by: Greg Wilkins <gregw@webtide.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8943b9b80618ea0e5a6ed7d05b7eecb2a6b188af", "author": {"user": {"login": "gregw", "name": "Greg Wilkins"}}, "url": "https://github.com/eclipse/jetty.project/commit/8943b9b80618ea0e5a6ed7d05b7eecb2a6b188af", "committedDate": "2020-04-21T15:14:51Z", "message": "Immutable MetaData WIP\n\nrename Builders to Muttables\n\nSigned-off-by: Greg Wilkins <gregw@webtide.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "89aa96902e9d1ee67165552fc5a8da1fb3ac32c9", "author": {"user": {"login": "gregw", "name": "Greg Wilkins"}}, "url": "https://github.com/eclipse/jetty.project/commit/89aa96902e9d1ee67165552fc5a8da1fb3ac32c9", "committedDate": "2020-04-21T15:51:26Z", "message": "Immutable MetaData WIP\n\nmisc cleanups\n\nSigned-off-by: Greg Wilkins <gregw@webtide.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0ac9421e7e7dbdcca4d8dea3cff5929ae6780401", "author": {"user": {"login": "gregw", "name": "Greg Wilkins"}}, "url": "https://github.com/eclipse/jetty.project/commit/0ac9421e7e7dbdcca4d8dea3cff5929ae6780401", "committedDate": "2020-04-22T07:53:43Z", "message": "Merge remote-tracking branch 'origin/jetty-10.0.x' into jetty-10.0.x-ImmutableMetaData"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "915f324b581df316a8ed997c7e2a4bf62b13d43a", "author": {"user": {"login": "gregw", "name": "Greg Wilkins"}}, "url": "https://github.com/eclipse/jetty.project/commit/915f324b581df316a8ed997c7e2a4bf62b13d43a", "committedDate": "2020-04-22T14:30:56Z", "message": "Immutable MetaData WIP\n\nRevert to using arrays due to garbage generated by streams and iterators (12% of a simple benchmark!).\nEven if this garbage is an artifact of the JIT being disabled by observation, it can hide other allocations, so best to just use simple arrays!\n\nSigned-off-by: Greg Wilkins <gregw@webtide.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3de51af3fcc2e58bec8af6671856bded1726f495", "author": {"user": {"login": "gregw", "name": "Greg Wilkins"}}, "url": "https://github.com/eclipse/jetty.project/commit/3de51af3fcc2e58bec8af6671856bded1726f495", "committedDate": "2020-04-22T17:37:46Z", "message": "Immutable MetaData WIP\n\nMore optimizations and better test coverage.\n\nSigned-off-by: Greg Wilkins <gregw@webtide.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "dd154dd9a92b7841b8adea5e6b9197d4ed5bb7c3", "author": {"user": {"login": "gregw", "name": "Greg Wilkins"}}, "url": "https://github.com/eclipse/jetty.project/commit/dd154dd9a92b7841b8adea5e6b9197d4ed5bb7c3", "committedDate": "2020-04-22T20:53:05Z", "message": "Immutable Metadata\n\nvarious cleanups\n\nSigned-off-by: Greg Wilkins <gregw@webtide.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3c5e8b644ac87802e1340aa1cc2cc2eaffb001a4", "author": {"user": {"login": "gregw", "name": "Greg Wilkins"}}, "url": "https://github.com/eclipse/jetty.project/commit/3c5e8b644ac87802e1340aa1cc2cc2eaffb001a4", "committedDate": "2020-04-22T21:02:15Z", "message": "Merge branch 'jetty-10.0.x' into jetty-10.0.x-ImmutableMetaData"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3749a5ca5526d8526fc4e4320f158e8a34e097b4", "author": {"user": {"login": "gregw", "name": "Greg Wilkins"}}, "url": "https://github.com/eclipse/jetty.project/commit/3749a5ca5526d8526fc4e4320f158e8a34e097b4", "committedDate": "2020-04-22T21:39:28Z", "message": "Immutable MetaData WIP\n\nMore optimizations\n\nSigned-off-by: Greg Wilkins <gregw@webtide.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5971476d306e012ebd6201c6ef708c470a5a75e9", "author": {"user": {"login": "gregw", "name": "Greg Wilkins"}}, "url": "https://github.com/eclipse/jetty.project/commit/5971476d306e012ebd6201c6ef708c470a5a75e9", "committedDate": "2020-04-23T07:24:41Z", "message": "Merge remote-tracking branch 'origin/jetty-10.0.x' into jetty-10.0.x-ImmutableMetaData\n\nSigned-off-by: Greg Wilkins <gregw@webtide.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "fa86645a99b52390456f0c04bea50f94b890daf5", "author": {"user": {"login": "gregw", "name": "Greg Wilkins"}}, "url": "https://github.com/eclipse/jetty.project/commit/fa86645a99b52390456f0c04bea50f94b890daf5", "committedDate": "2020-04-23T08:18:15Z", "message": "Immutable MetaData WIP\n\nreview changes\n\nSigned-off-by: Greg Wilkins <gregw@webtide.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk4OTU2NTY0", "url": "https://github.com/eclipse/jetty.project/pull/4777#pullrequestreview-398956564", "createdAt": "2020-04-23T10:13:57Z", "commit": {"oid": "fa86645a99b52390456f0c04bea50f94b890daf5"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 55, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yM1QxMDoxMzo1N1rOGKhtdg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yM1QxNTowNzo0OFrOGKtKEQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzY5MTI1NA==", "bodyText": "Please rename this field to WS_VERSION_FIELD (singular).", "url": "https://github.com/eclipse/jetty.project/pull/4777#discussion_r413691254", "createdAt": "2020-04-23T10:13:57Z", "author": {"login": "sbordet"}, "path": "jetty-websocket/websocket-core/src/main/java/org/eclipse/jetty/websocket/core/client/HttpUpgraderOverHTTP.java", "diffHunk": "@@ -30,13 +30,19 @@\n import org.eclipse.jetty.http.HttpHeader;\n import org.eclipse.jetty.http.HttpMethod;\n import org.eclipse.jetty.http.HttpVersion;\n+import org.eclipse.jetty.http.PreEncodedHttpField;\n import org.eclipse.jetty.io.EndPoint;\n import org.eclipse.jetty.util.Callback;\n import org.eclipse.jetty.websocket.core.WebSocketConstants;\n import org.eclipse.jetty.websocket.core.internal.WebSocketCore;\n \n public class HttpUpgraderOverHTTP implements HttpUpgrader\n {\n+    private static final PreEncodedHttpField WS_VERSIONS_FIELD = new PreEncodedHttpField(HttpHeader.SEC_WEBSOCKET_VERSION, WebSocketConstants.SPEC_VERSION_STRING);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fa86645a99b52390456f0c04bea50f94b890daf5"}, "originalPosition": 12}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzY5MTkxOQ==", "bodyText": "This field is the same field that exist in HttpUpgraderOverHTTP.\nCan you please name them the same, i.e. WS_VERSION_FIELD?", "url": "https://github.com/eclipse/jetty.project/pull/4777#discussion_r413691919", "createdAt": "2020-04-23T10:15:01Z", "author": {"login": "sbordet"}, "path": "jetty-websocket/websocket-core/src/main/java/org/eclipse/jetty/websocket/core/client/HttpUpgraderOverHTTP2.java", "diffHunk": "@@ -23,12 +23,14 @@\n import org.eclipse.jetty.client.HttpUpgrader;\n import org.eclipse.jetty.http.HttpHeader;\n import org.eclipse.jetty.http.HttpMethod;\n+import org.eclipse.jetty.http.PreEncodedHttpField;\n import org.eclipse.jetty.io.EndPoint;\n import org.eclipse.jetty.util.Callback;\n import org.eclipse.jetty.websocket.core.WebSocketConstants;\n \n public class HttpUpgraderOverHTTP2 implements HttpUpgrader\n {\n+    public static final PreEncodedHttpField SPEC_VERSION_FIELD = new PreEncodedHttpField(HttpHeader.SEC_WEBSOCKET_VERSION, WebSocketConstants.SPEC_VERSION_STRING);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fa86645a99b52390456f0c04bea50f94b890daf5"}, "originalPosition": 11}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzY5NzgxMg==", "bodyText": "Should not this be just HttpFields as return type?", "url": "https://github.com/eclipse/jetty.project/pull/4777#discussion_r413697812", "createdAt": "2020-04-23T10:24:34Z", "author": {"login": "sbordet"}, "path": "jetty-client/src/main/java/org/eclipse/jetty/client/HttpRequest.java", "diffHunk": "@@ -353,7 +381,7 @@ public Request attribute(String name, Object value)\n     }\n \n     @Override\n-    public HttpFields getHeaders()\n+    public HttpFields.Mutable getHeaders()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fa86645a99b52390456f0c04bea50f94b890daf5"}, "originalPosition": 49}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzY5ODc2Mw==", "bodyText": "Should not this be just HttpFields as return type?", "url": "https://github.com/eclipse/jetty.project/pull/4777#discussion_r413698763", "createdAt": "2020-04-23T10:26:03Z", "author": {"login": "sbordet"}, "path": "jetty-client/src/main/java/org/eclipse/jetty/client/HttpResponse.java", "diffHunk": "@@ -103,15 +108,15 @@ public HttpFields getHeaders()\n         return result;\n     }\n \n-    public HttpFields getTrailers()\n+    public HttpFields.Mutable getTrailers()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fa86645a99b52390456f0c04bea50f94b890daf5"}, "originalPosition": 33}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzY5OTg5NQ==", "bodyText": "I think for now these are fine, although remove() is never used.\nI will file another issue about reviewing the way headers can be set on a request because there is need to explicitly separate the \"add\" semantic from the \"put\" semantic.", "url": "https://github.com/eclipse/jetty.project/pull/4777#discussion_r413699895", "createdAt": "2020-04-23T10:27:53Z", "author": {"login": "sbordet"}, "path": "jetty-client/src/main/java/org/eclipse/jetty/client/api/Request.java", "diffHunk": "@@ -152,6 +153,32 @@\n      */\n     HttpFields getHeaders();\n \n+    /** Set the headers, clearing any existing headers\n+     * @param fields The fields to set\n+     * @return this request object\n+     */\n+    Request set(HttpFields fields);\n+\n+    /**\n+     * @param header the header to remove\n+     * @return this request object\n+     */\n+    Request remove(HttpHeader header);\n+\n+    /**\n+     * @param field the field to add\n+     * @return this request object\n+     * @see #header(HttpHeader, String)\n+     */\n+    Request add(HttpField field);\n+\n+    /**\n+     * @param field the field to put\n+     * @return this request object\n+     * @see #header(HttpHeader, String)\n+     */\n+    Request put(HttpField field);\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fa86645a99b52390456f0c04bea50f94b890daf5"}, "originalPosition": 37}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzcwMDkyOA==", "bodyText": "Remove .Mutable.", "url": "https://github.com/eclipse/jetty.project/pull/4777#discussion_r413700928", "createdAt": "2020-04-23T10:29:34Z", "author": {"login": "sbordet"}, "path": "jetty-client/src/main/java/org/eclipse/jetty/client/util/MultiPartRequestContent.java", "diffHunk": "@@ -145,7 +145,7 @@ public void fail(Throwable failure)\n      * @param content the part content\n      * @param fields the headers associated with this part\n      */\n-    public void addFieldPart(String name, Request.Content content, HttpFields fields)\n+    public void addFieldPart(String name, Request.Content content, HttpFields.Mutable fields)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fa86645a99b52390456f0c04bea50f94b890daf5"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzcwMDk5OQ==", "bodyText": "Remove .Mutable.", "url": "https://github.com/eclipse/jetty.project/pull/4777#discussion_r413700999", "createdAt": "2020-04-23T10:29:40Z", "author": {"login": "sbordet"}, "path": "jetty-client/src/main/java/org/eclipse/jetty/client/util/MultiPartRequestContent.java", "diffHunk": "@@ -164,7 +164,7 @@ public void addFieldPart(String name, Request.Content content, HttpFields fields\n      * @param content the part content\n      * @param fields the headers associated with this part\n      */\n-    public void addFilePart(String name, String fileName, Request.Content content, HttpFields fields)\n+    public void addFilePart(String name, String fileName, Request.Content content, HttpFields.Mutable fields)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fa86645a99b52390456f0c04bea50f94b890daf5"}, "originalPosition": 14}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzcwMzA1Ng==", "bodyText": "This line was the point of the test: verify that even if the server did not send Connection: close, the client closes the connection.\nIt must be restored.", "url": "https://github.com/eclipse/jetty.project/pull/4777#discussion_r413703056", "createdAt": "2020-04-23T10:32:50Z", "author": {"login": "sbordet"}, "path": "jetty-client/src/test/java/org/eclipse/jetty/client/ClientConnectionCloseTest.java", "diffHunk": "@@ -249,8 +249,7 @@ public void handle(String target, Request baseRequest, HttpServletRequest reques\n                 DuplexConnectionPool connectionPool = (DuplexConnectionPool)destination.getConnectionPool();\n                 HttpConnectionOverHTTP connection = (HttpConnectionOverHTTP)connectionPool.getActiveConnections().iterator().next();\n                 assertFalse(connection.getEndPoint().isOutputShutdown());\n-            })\n-            .onResponseHeaders(r -> r.getHeaders().remove(HttpHeader.CONNECTION));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fa86645a99b52390456f0c04bea50f94b890daf5"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzcwNDIyMw==", "bodyText": "Since you have replaced containsKey() with contains(), can you also remove all the .asString() in this class, now that contains() takes a HttpHeader?", "url": "https://github.com/eclipse/jetty.project/pull/4777#discussion_r413704223", "createdAt": "2020-04-23T10:34:45Z", "author": {"login": "sbordet"}, "path": "jetty-client/src/test/java/org/eclipse/jetty/client/HttpClientRedirectTest.java", "diffHunk": "@@ -70,7 +70,7 @@ public void test303(Scenario scenario) throws Exception\n             .send();\n         assertNotNull(response);\n         assertEquals(200, response.getStatus());\n-        assertFalse(response.getHeaders().containsKey(HttpHeader.LOCATION.asString()));\n+        assertFalse(response.getHeaders().contains(HttpHeader.LOCATION.asString()));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fa86645a99b52390456f0c04bea50f94b890daf5"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzcwNjAxOA==", "bodyText": "Remove these fields, this is documentation code, we don't need to optimize.", "url": "https://github.com/eclipse/jetty.project/pull/4777#discussion_r413706018", "createdAt": "2020-04-23T10:37:42Z", "author": {"login": "sbordet"}, "path": "jetty-documentation/src/main/java/embedded/client/http/HTTPClientDocs.java", "diffHunk": "@@ -78,6 +79,11 @@\n @SuppressWarnings(\"unused\")\n public class HTTPClientDocs\n {\n+\n+    public static final PreEncodedHttpField H2C_UPGRADE_FIELD = new PreEncodedHttpField(HttpHeader.UPGRADE, \"h2c\");\n+    public static final PreEncodedHttpField H2_SETTINGS_FIELD = new PreEncodedHttpField(HttpHeader.HTTP2_SETTINGS, \"\");\n+    public static final PreEncodedHttpField H2_UPGRADE_CONNECTION_FIELD = new PreEncodedHttpField(HttpHeader.CONNECTION, \"Upgrade, HTTP2-Settings\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fa86645a99b52390456f0c04bea50f94b890daf5"}, "originalPosition": 15}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzcwNjcxNg==", "bodyText": "Restore this section of the documentation as it was before, no point in optimizing it.", "url": "https://github.com/eclipse/jetty.project/pull/4777#discussion_r413706716", "createdAt": "2020-04-23T10:38:43Z", "author": {"login": "sbordet"}, "path": "jetty-documentation/src/main/java/embedded/client/http/HTTPClientDocs.java", "diffHunk": "@@ -798,9 +804,9 @@ public void dynamicClearText() throws Exception\n         // Make a clear-text upgrade request from HTTP/1.1 to HTTP/2.\n         // The request will start as HTTP/1.1, but the response will be HTTP/2.\n         ContentResponse upgradedResponse = client.newRequest(\"host\", 8080)\n-            .header(HttpHeader.UPGRADE, \"h2c\")\n-            .header(HttpHeader.HTTP2_SETTINGS, \"\")\n-            .header(HttpHeader.CONNECTION, \"Upgrade, HTTP2-Settings\")\n+            .add(H2C_UPGRADE_FIELD)\n+            .add(H2_SETTINGS_FIELD)\n+            .add(H2_UPGRADE_CONNECTION_FIELD)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fa86645a99b52390456f0c04bea50f94b890daf5"}, "originalPosition": 29}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzcwNzEzOQ==", "bodyText": "Remove .Mutable.", "url": "https://github.com/eclipse/jetty.project/pull/4777#discussion_r413707139", "createdAt": "2020-04-23T10:39:28Z", "author": {"login": "sbordet"}, "path": "jetty-documentation/src/main/java/embedded/client/http2/HTTP2ClientDocs.java", "diffHunk": "@@ -172,11 +172,11 @@ public void newStreamWithData() throws Exception\n         Session session = sessionCF.get();\n \n         // Configure the request headers.\n-        HttpFields requestHeaders = new HttpFields();\n-        requestHeaders.put(HttpHeader.CONTENT_TYPE, \"application/json\");\n+        HttpFields.Mutable requestHeaders = HttpFields.build()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fa86645a99b52390456f0c04bea50f94b890daf5"}, "originalPosition": 21}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzcwNzMyNA==", "bodyText": "Remove .Mutable.", "url": "https://github.com/eclipse/jetty.project/pull/4777#discussion_r413707324", "createdAt": "2020-04-23T10:39:42Z", "author": {"login": "sbordet"}, "path": "jetty-documentation/src/main/java/embedded/client/http2/HTTP2ClientDocs.java", "diffHunk": "@@ -213,9 +213,9 @@ public void responseListener() throws Exception\n         CompletableFuture<Session> sessionCF = http2Client.connect(serverAddress, new Session.Listener.Adapter());\n         Session session = sessionCF.get();\n \n-        HttpFields requestHeaders = new HttpFields();\n-        requestHeaders.put(HttpHeader.USER_AGENT, \"Jetty HTTP2Client {version}\");\n-        MetaData.Request request = new MetaData.Request(\"GET\", new HttpURI(\"http://localhost:8080/path\"), HttpVersion.HTTP_2, requestHeaders);\n+        HttpFields.Mutable requestHeaders = HttpFields.build()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fa86645a99b52390456f0c04bea50f94b890daf5"}, "originalPosition": 37}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzcwNzQ3Ng==", "bodyText": "Remove .Mutable.", "url": "https://github.com/eclipse/jetty.project/pull/4777#discussion_r413707476", "createdAt": "2020-04-23T10:39:54Z", "author": {"login": "sbordet"}, "path": "jetty-documentation/src/main/java/embedded/client/http2/HTTP2ClientDocs.java", "diffHunk": "@@ -358,9 +358,9 @@ public void pushReset() throws Exception\n         CompletableFuture<Session> sessionCF = http2Client.connect(serverAddress, new Session.Listener.Adapter());\n         Session session = sessionCF.get();\n \n-        HttpFields requestHeaders = new HttpFields();\n-        requestHeaders.put(HttpHeader.USER_AGENT, \"Jetty HTTP2Client {version}\");\n-        MetaData.Request request = new MetaData.Request(\"GET\", new HttpURI(\"http://localhost:8080/path\"), HttpVersion.HTTP_2, requestHeaders);\n+        HttpFields.Mutable requestHeaders = HttpFields.build()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fa86645a99b52390456f0c04bea50f94b890daf5"}, "originalPosition": 76}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzcwNzk0OQ==", "bodyText": "Restore the local variable newPath for documentation clarity.", "url": "https://github.com/eclipse/jetty.project/pull/4777#discussion_r413707949", "createdAt": "2020-04-23T10:40:44Z", "author": {"login": "sbordet"}, "path": "jetty-documentation/src/main/java/embedded/server/http/HTTPServerDocs.java", "diffHunk": "@@ -464,9 +464,7 @@ public void handle(String target, Request jettyRequest, HttpServletRequest reque\n                 {\n                     // Rewrite old paths to new paths.\n                     HttpURI uri = jettyRequest.getHttpURI();\n-                    HttpURI newURI = new HttpURI(uri);\n-                    String newPath = \"/new_path/\" + path.substring(\"/old_path/\".length());\n-                    newURI.setPath(newPath);\n+                    HttpURI newURI = HttpURI.build(uri).path(\"/new_path/\" + path.substring(\"/old_path/\".length()));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fa86645a99b52390456f0c04bea50f94b890daf5"}, "originalPosition": 7}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzcxNDExNQ==", "bodyText": "I feel better to use remove() field by field, rather than getField() + remove(EnumSet).\nReason being that if there is one more/less header to treat in this way, I will never remember to add/remove it from the EnumSet.", "url": "https://github.com/eclipse/jetty.project/pull/4777#discussion_r413714115", "createdAt": "2020-04-23T10:50:59Z", "author": {"login": "sbordet"}, "path": "jetty-fcgi/fcgi-client/src/main/java/org/eclipse/jetty/fcgi/client/http/HttpSenderOverFCGI.java", "diffHunk": "@@ -74,13 +71,14 @@ protected void sendHeaders(HttpExchange exchange, ByteBuffer contentBuffer, bool\n         fcgiHeaders.put(FCGI.Headers.QUERY_STRING, query == null ? \"\" : query);\n \n         // FastCGI headers based on HTTP headers\n-        HttpField httpField = headers.remove(HttpHeader.AUTHORIZATION);\n+        HttpField httpField = headers.getField(HttpHeader.AUTHORIZATION);\n         if (httpField != null)\n             fcgiHeaders.put(FCGI.Headers.AUTH_TYPE, httpField.getValue());\n-        httpField = headers.remove(HttpHeader.CONTENT_LENGTH);\n+        httpField = headers.getField(HttpHeader.CONTENT_LENGTH);\n         fcgiHeaders.put(FCGI.Headers.CONTENT_LENGTH, httpField == null ? \"\" : httpField.getValue());\n-        httpField = headers.remove(HttpHeader.CONTENT_TYPE);\n+        httpField = headers.getField(HttpHeader.CONTENT_TYPE);\n         fcgiHeaders.put(FCGI.Headers.CONTENT_TYPE, httpField == null ? \"\" : httpField.getValue());\n+        headers.remove(EnumSet.of(HttpHeader.AUTHORIZATION, HttpHeader.CONTENT_LENGTH, HttpHeader.CONTENT_TYPE));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fa86645a99b52390456f0c04bea50f94b890daf5"}, "originalPosition": 37}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzcxNDgyOQ==", "bodyText": "Remove asString().", "url": "https://github.com/eclipse/jetty.project/pull/4777#discussion_r413714829", "createdAt": "2020-04-23T10:52:08Z", "author": {"login": "sbordet"}, "path": "jetty-fcgi/fcgi-server/src/main/java/org/eclipse/jetty/fcgi/server/proxy/FastCGIProxyServlet.java", "diffHunk": "@@ -180,7 +180,7 @@ protected void sendProxyRequest(HttpServletRequest request, HttpServletResponse\n             proxyRequest.attribute(REQUEST_QUERY_ATTRIBUTE, originalQuery);\n \n         // If the Host header is missing, add it.\n-        if (!proxyRequest.getHeaders().containsKey(HttpHeader.HOST.asString()))\n+        if (!proxyRequest.getHeaders().contains(HttpHeader.HOST.asString()))", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fa86645a99b52390456f0c04bea50f94b890daf5"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzcxOTYxNQ==", "bodyText": "Remove .Mutable.", "url": "https://github.com/eclipse/jetty.project/pull/4777#discussion_r413719615", "createdAt": "2020-04-23T10:59:52Z", "author": {"login": "sbordet"}, "path": "jetty-http/src/main/java/org/eclipse/jetty/http/HttpParser.java", "diffHunk": "@@ -72,7 +72,7 @@\n  * is used to lookup common combinations of headers and values\n  * (eg. \"Connection: close\"), or just header names (eg. \"Connection:\" ).\n  * For headers who's value is not known statically (eg. Host, COOKIE) then a\n- * per parser dynamic Trie of {@link HttpFields} from previous parsed messages\n+ * per parser dynamic Trie of {@link HttpFields.Mutable} from previous parsed messages", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fa86645a99b52390456f0c04bea50f94b890daf5"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzcyMDAzOQ==", "bodyText": "Don't refer to HttpFields.", "url": "https://github.com/eclipse/jetty.project/pull/4777#discussion_r413720039", "createdAt": "2020-04-23T11:00:35Z", "author": {"login": "sbordet"}, "path": "jetty-http/src/main/java/org/eclipse/jetty/http/HttpURI.java", "diffHunk": "@@ -18,798 +18,1064 @@\n \n package org.eclipse.jetty.http;\n \n-import java.io.UnsupportedEncodingException;\n import java.net.URI;\n import java.net.URISyntaxException;\n-import java.nio.charset.Charset;\n-import java.nio.charset.StandardCharsets;\n \n-import org.eclipse.jetty.util.MultiMap;\n+import org.eclipse.jetty.util.HostPort;\n+import org.eclipse.jetty.util.StringUtil;\n import org.eclipse.jetty.util.TypeUtil;\n import org.eclipse.jetty.util.URIUtil;\n import org.eclipse.jetty.util.UrlEncoded;\n \n /**\n  * Http URI.\n- * Parse an HTTP URI from a string or byte array.  Given a URI\n- * <code>http://user@host:port/path/info;param?query#fragment</code>\n- * this class will split it into the following undecoded optional elements:<ul>\n+ *\n+ * Both {@link HttpFields.Mutable} and {@link HttpFields.Immutable} implementations are available", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fa86645a99b52390456f0c04bea50f94b890daf5"}, "originalPosition": 23}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzcyMDE4OQ==", "bodyText": "Restore fragments.", "url": "https://github.com/eclipse/jetty.project/pull/4777#discussion_r413720189", "createdAt": "2020-04-23T11:00:51Z", "author": {"login": "sbordet"}, "path": "jetty-http/src/main/java/org/eclipse/jetty/http/HttpURI.java", "diffHunk": "@@ -18,798 +18,1064 @@\n \n package org.eclipse.jetty.http;\n \n-import java.io.UnsupportedEncodingException;\n import java.net.URI;\n import java.net.URISyntaxException;\n-import java.nio.charset.Charset;\n-import java.nio.charset.StandardCharsets;\n \n-import org.eclipse.jetty.util.MultiMap;\n+import org.eclipse.jetty.util.HostPort;\n+import org.eclipse.jetty.util.StringUtil;\n import org.eclipse.jetty.util.TypeUtil;\n import org.eclipse.jetty.util.URIUtil;\n import org.eclipse.jetty.util.UrlEncoded;\n \n /**\n  * Http URI.\n- * Parse an HTTP URI from a string or byte array.  Given a URI\n- * <code>http://user@host:port/path/info;param?query#fragment</code>\n- * this class will split it into the following undecoded optional elements:<ul>\n+ *\n+ * Both {@link HttpFields.Mutable} and {@link HttpFields.Immutable} implementations are available\n+ * via the static methods such as {@link #build()} and {@link #from(String)}.\n+ *\n+ * A URI such as\n+ * <code>http://user@host:port/path;ignored/info;param?query#ignored</code>\n+ * is split into the following undecoded elements:<ul>\n  * <li>{@link #getScheme()} - http:</li>\n  * <li>{@link #getAuthority()} - //name@host:port</li>\n  * <li>{@link #getHost()} - host</li>\n  * <li>{@link #getPort()} - port</li>\n  * <li>{@link #getPath()} - /path/info</li>\n  * <li>{@link #getParam()} - param</li>\n  * <li>{@link #getQuery()} - query</li>\n- * <li>{@link #getFragment()} - fragment</li>\n  * </ul>\n- *\n  * <p>Any parameters will be returned from {@link #getPath()}, but are excluded from the\n  * return value of {@link #getDecodedPath()}.   If there are multiple parameters, the\n- * {@link #getParam()} method returns only the last one.\n+ * {@link #getParam()} method returns only the last one. Fragments are ignored.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fa86645a99b52390456f0c04bea50f94b890daf5"}, "originalPosition": 42}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzcyMTUxOA==", "bodyText": "Please use the same order of the fields declarations, otherwise it's too difficult to say if we forgot to assign a field.", "url": "https://github.com/eclipse/jetty.project/pull/4777#discussion_r413721518", "createdAt": "2020-04-23T11:03:00Z", "author": {"login": "sbordet"}, "path": "jetty-http/src/main/java/org/eclipse/jetty/http/HttpURI.java", "diffHunk": "@@ -18,798 +18,1064 @@\n \n package org.eclipse.jetty.http;\n \n-import java.io.UnsupportedEncodingException;\n import java.net.URI;\n import java.net.URISyntaxException;\n-import java.nio.charset.Charset;\n-import java.nio.charset.StandardCharsets;\n \n-import org.eclipse.jetty.util.MultiMap;\n+import org.eclipse.jetty.util.HostPort;\n+import org.eclipse.jetty.util.StringUtil;\n import org.eclipse.jetty.util.TypeUtil;\n import org.eclipse.jetty.util.URIUtil;\n import org.eclipse.jetty.util.UrlEncoded;\n \n /**\n  * Http URI.\n- * Parse an HTTP URI from a string or byte array.  Given a URI\n- * <code>http://user@host:port/path/info;param?query#fragment</code>\n- * this class will split it into the following undecoded optional elements:<ul>\n+ *\n+ * Both {@link HttpFields.Mutable} and {@link HttpFields.Immutable} implementations are available\n+ * via the static methods such as {@link #build()} and {@link #from(String)}.\n+ *\n+ * A URI such as\n+ * <code>http://user@host:port/path;ignored/info;param?query#ignored</code>\n+ * is split into the following undecoded elements:<ul>\n  * <li>{@link #getScheme()} - http:</li>\n  * <li>{@link #getAuthority()} - //name@host:port</li>\n  * <li>{@link #getHost()} - host</li>\n  * <li>{@link #getPort()} - port</li>\n  * <li>{@link #getPath()} - /path/info</li>\n  * <li>{@link #getParam()} - param</li>\n  * <li>{@link #getQuery()} - query</li>\n- * <li>{@link #getFragment()} - fragment</li>\n  * </ul>\n- *\n  * <p>Any parameters will be returned from {@link #getPath()}, but are excluded from the\n  * return value of {@link #getDecodedPath()}.   If there are multiple parameters, the\n- * {@link #getParam()} method returns only the last one.\n+ * {@link #getParam()} method returns only the last one. Fragments are ignored.\n  */\n-public class HttpURI\n+public interface HttpURI\n {\n-    private enum State\n+    static Mutable build()\n     {\n-        START,\n-        HOST_OR_PATH,\n-        SCHEME_OR_PATH,\n-        HOST,\n-        IPV6,\n-        PORT,\n-        PATH,\n-        PARAM,\n-        QUERY,\n-        FRAGMENT,\n-        ASTERISK\n+        return new Mutable();\n     }\n \n-    ;\n-\n-    private String _scheme;\n-    private String _user;\n-    private String _host;\n-    private int _port;\n-    private String _path;\n-    private String _param;\n-    private String _query;\n-    private String _fragment;\n-\n-    String _uri;\n-    String _decodedPath;\n-\n-    /**\n-     * Construct a normalized URI.\n-     * Port is not set if it is the default port.\n-     *\n-     * @param scheme the URI scheme\n-     * @param host the URI hose\n-     * @param port the URI port\n-     * @param path the URI path\n-     * @param param the URI param\n-     * @param query the URI query\n-     * @param fragment the URI fragment\n-     * @return the normalized URI\n-     */\n-    public static HttpURI createHttpURI(String scheme, String host, int port, String path, String param, String query, String fragment)\n+    static Mutable build(HttpURI uri)\n     {\n-        if (port == 80 && HttpScheme.HTTP.is(scheme))\n-            port = 0;\n-        if (port == 443 && HttpScheme.HTTPS.is(scheme))\n-            port = 0;\n-        return new HttpURI(scheme, host, port, path, param, query, fragment);\n+        return new Mutable(uri);\n     }\n \n-    public HttpURI()\n+    static Mutable build(HttpURI uri, String pathQuery)\n     {\n+        return new Mutable(uri, pathQuery);\n     }\n \n-    public HttpURI(String scheme, String host, int port, String path, String param, String query, String fragment)\n+    static Mutable build(HttpURI uri, String path, String param, String query)\n     {\n-        _scheme = scheme;\n-        _host = host;\n-        _port = port;\n-        _path = path;\n-        _param = param;\n-        _query = query;\n-        _fragment = fragment;\n+        return new Mutable(uri, path, param, query);\n     }\n \n-    public HttpURI(HttpURI uri)\n+    static Mutable build(URI uri)\n     {\n-        this(uri._scheme, uri._host, uri._port, uri._path, uri._param, uri._query, uri._fragment);\n-        _uri = uri._uri;\n+        return new Mutable(uri);\n     }\n \n-    public HttpURI(String uri)\n+    static Mutable build(String uri)\n     {\n-        _port = -1;\n-        parse(State.START, uri);\n+        return new Mutable(uri);\n     }\n \n-    public HttpURI(URI uri)\n+    static Immutable from(URI uri)\n     {\n-        _uri = null;\n-\n-        _scheme = uri.getScheme();\n-        _host = uri.getHost();\n-        if (_host == null && uri.getRawSchemeSpecificPart().startsWith(\"//\"))\n-            _host = \"\";\n-        _port = uri.getPort();\n-        _user = uri.getUserInfo();\n-        _path = uri.getRawPath();\n-\n-        _decodedPath = uri.getPath();\n-        if (_decodedPath != null)\n-        {\n-            int p = _decodedPath.lastIndexOf(';');\n-            if (p >= 0)\n-                _param = _decodedPath.substring(p + 1);\n-        }\n-        _query = uri.getRawQuery();\n-        _fragment = uri.getFragment();\n-\n-        _decodedPath = null;\n+        return new HttpURI.Mutable(uri).asImmutable();\n     }\n \n-    public HttpURI(String scheme, String host, int port, String pathQuery)\n+    static Immutable from(String uri)\n     {\n-        _uri = null;\n-\n-        _scheme = scheme;\n-        _host = host;\n-        _port = port;\n-\n-        if (pathQuery != null)\n-            parse(State.PATH, pathQuery);\n+        return new HttpURI.Mutable(uri).asImmutable();\n     }\n \n-    public void parse(String uri)\n+    static Immutable from(String method, String uri)\n     {\n-        clear();\n-        _uri = uri;\n-        parse(State.START, uri);\n+        if (HttpMethod.CONNECT.is(method))\n+            return new Immutable(uri);\n+        if (uri.startsWith(\"/\"))\n+            return HttpURI.build().pathQuery(uri).asImmutable();\n+        return HttpURI.from(uri);\n     }\n \n-    public void parse(String uri, int offset, int length)\n+    static Immutable from(String scheme, String host, int port, String pathQuery)\n     {\n-        clear();\n-        int end = offset + length;\n-        _uri = uri.substring(offset, end);\n-        parse(State.START, uri);\n+        return new Mutable(scheme, host, port, pathQuery).asImmutable();\n     }\n \n-    private void parse(State state, final String uri)\n-    {\n-        boolean encoded = false;\n-        int end = uri.length();\n-        int mark = 0;\n-        int pathMark = 0;\n-        char last = '/';\n-        for (int i = 0; i < end; i++)\n-        {\n-            char c = uri.charAt(i);\n+    Immutable asImmutable();\n \n-            switch (state)\n-            {\n-                case START:\n-                {\n-                    switch (c)\n-                    {\n-                        case '/':\n-                            mark = i;\n-                            state = State.HOST_OR_PATH;\n-                            break;\n-                        case ';':\n-                            mark = i + 1;\n-                            state = State.PARAM;\n-                            break;\n-                        case '?':\n-                            // assume empty path (if seen at start)\n-                            _path = \"\";\n-                            mark = i + 1;\n-                            state = State.QUERY;\n-                            break;\n-                        case '#':\n-                            mark = i + 1;\n-                            state = State.FRAGMENT;\n-                            break;\n-                        case '*':\n-                            _path = \"*\";\n-                            state = State.ASTERISK;\n-                            break;\n-\n-                        case '.':\n-                            pathMark = i;\n-                            state = State.PATH;\n-                            encoded = true;\n-                            break;\n-\n-                        default:\n-                            mark = i;\n-                            if (_scheme == null)\n-                                state = State.SCHEME_OR_PATH;\n-                            else\n-                            {\n-                                pathMark = i;\n-                                state = State.PATH;\n-                            }\n-                            break;\n-                    }\n+    String getAuthority();\n \n-                    continue;\n-                }\n+    String getDecodedPath();\n \n-                case SCHEME_OR_PATH:\n-                {\n-                    switch (c)\n-                    {\n-                        case ':':\n-                            // must have been a scheme\n-                            _scheme = uri.substring(mark, i);\n-                            // Start again with scheme set\n-                            state = State.START;\n-                            break;\n-\n-                        case '/':\n-                            // must have been in a path and still are\n-                            state = State.PATH;\n-                            break;\n+    String getHost();\n \n-                        case ';':\n-                            // must have been in a path \n-                            mark = i + 1;\n-                            state = State.PARAM;\n-                            break;\n+    String getParam();\n \n-                        case '?':\n-                            // must have been in a path \n-                            _path = uri.substring(mark, i);\n-                            mark = i + 1;\n-                            state = State.QUERY;\n-                            break;\n+    String getPath();\n \n-                        case '%':\n-                            // must have be in an encoded path \n-                            encoded = true;\n-                            state = State.PATH;\n-                            break;\n+    String getPathQuery();\n \n-                        case '#':\n-                            // must have been in a path \n-                            _path = uri.substring(mark, i);\n-                            state = State.FRAGMENT;\n-                            break;\n+    int getPort();\n \n-                        default:\n-                            break;\n-                    }\n-                    continue;\n-                }\n+    String getQuery();\n \n-                case HOST_OR_PATH:\n-                {\n-                    switch (c)\n-                    {\n-                        case '/':\n-                            _host = \"\";\n-                            mark = i + 1;\n-                            state = State.HOST;\n-                            break;\n-\n-                        case '@':\n-                        case ';':\n-                        case '?':\n-                        case '#':\n-                            // was a path, look again\n-                            i--;\n-                            pathMark = mark;\n-                            state = State.PATH;\n-                            break;\n+    String getScheme();\n \n-                        case '.':\n-                            // it is a path\n-                            encoded = true;\n-                            pathMark = mark;\n-                            state = State.PATH;\n-                            break;\n+    String getUser();\n \n-                        default:\n-                            // it is a path\n-                            pathMark = mark;\n-                            state = State.PATH;\n-                    }\n-                    continue;\n-                }\n+    boolean hasAuthority();\n \n-                case HOST:\n-                {\n-                    switch (c)\n-                    {\n-                        case '/':\n-                            _host = uri.substring(mark, i);\n-                            pathMark = mark = i;\n-                            state = State.PATH;\n-                            break;\n-                        case ':':\n-                            if (i > mark)\n-                                _host = uri.substring(mark, i);\n-                            mark = i + 1;\n-                            state = State.PORT;\n-                            break;\n-                        case '@':\n-                            if (_user != null)\n-                                throw new IllegalArgumentException(\"Bad authority\");\n-                            _user = uri.substring(mark, i);\n-                            mark = i + 1;\n-                            break;\n+    boolean isAbsolute();\n \n-                        case '[':\n-                            state = State.IPV6;\n-                            break;\n+    default URI toURI()\n+    {\n+        try\n+        {\n+            String query = getQuery();\n+            return new URI(getScheme(), null, getHost(), getPort(), getPath(), query == null ? null : UrlEncoded.decodeString(query), null);\n+        }\n+        catch (URISyntaxException x)\n+        {\n+            throw new RuntimeException(x);\n+        }\n+    }\n \n-                        default:\n-                            break;\n-                    }\n-                    break;\n-                }\n+    class Immutable implements HttpURI\n+    {\n+        private final String _scheme;\n+        private final String _user;\n+        private final String _host;\n+        private final int _port;\n+        private final String _path;\n+        private final String _param;\n+        private final String _query;\n+        private String _uri;\n+        private String _decodedPath;\n+\n+        private Immutable(Mutable builder)\n+        {\n+            _uri = builder._uri;\n+            _scheme = builder._scheme;\n+            _user = builder._user;\n+            _host = builder._host;\n+            _port = builder._port;\n+            _path = builder._path;\n+            _decodedPath = builder._decodedPath;\n+            _param = builder._param;\n+            _query = builder._query;\n+        }\n \n-                case IPV6:\n-                {\n-                    switch (c)\n-                    {\n-                        case '/':\n-                            throw new IllegalArgumentException(\"No closing ']' for ipv6 in \" + uri);\n-                        case ']':\n-                            c = uri.charAt(++i);\n-                            _host = uri.substring(mark, i);\n-                            if (c == ':')\n-                            {\n-                                mark = i + 1;\n-                                state = State.PORT;\n-                            }\n-                            else\n-                            {\n-                                pathMark = mark = i;\n-                                state = State.PATH;\n-                            }\n-                            break;\n+        private Immutable(String uri)\n+        {\n+            _uri = uri;\n+            _scheme = null;\n+            _user = null;\n+            _host = null;\n+            _port = -1;\n+            _path = uri;\n+            _decodedPath = null;\n+            _param = null;\n+            _query = null;\n+        }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fa86645a99b52390456f0c04bea50f94b890daf5"}, "originalPosition": 456}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzcyMzEyOA==", "bodyText": "Don't this is a good idea to use toString() for equality, since we may modify toString() to include the hashCode and now we are screwed.\nIntroduce an asString() method or toURI() with a clear semantic and use those.", "url": "https://github.com/eclipse/jetty.project/pull/4777#discussion_r413723128", "createdAt": "2020-04-23T11:05:52Z", "author": {"login": "sbordet"}, "path": "jetty-http/src/main/java/org/eclipse/jetty/http/HttpURI.java", "diffHunk": "@@ -18,798 +18,1064 @@\n \n package org.eclipse.jetty.http;\n \n-import java.io.UnsupportedEncodingException;\n import java.net.URI;\n import java.net.URISyntaxException;\n-import java.nio.charset.Charset;\n-import java.nio.charset.StandardCharsets;\n \n-import org.eclipse.jetty.util.MultiMap;\n+import org.eclipse.jetty.util.HostPort;\n+import org.eclipse.jetty.util.StringUtil;\n import org.eclipse.jetty.util.TypeUtil;\n import org.eclipse.jetty.util.URIUtil;\n import org.eclipse.jetty.util.UrlEncoded;\n \n /**\n  * Http URI.\n- * Parse an HTTP URI from a string or byte array.  Given a URI\n- * <code>http://user@host:port/path/info;param?query#fragment</code>\n- * this class will split it into the following undecoded optional elements:<ul>\n+ *\n+ * Both {@link HttpFields.Mutable} and {@link HttpFields.Immutable} implementations are available\n+ * via the static methods such as {@link #build()} and {@link #from(String)}.\n+ *\n+ * A URI such as\n+ * <code>http://user@host:port/path;ignored/info;param?query#ignored</code>\n+ * is split into the following undecoded elements:<ul>\n  * <li>{@link #getScheme()} - http:</li>\n  * <li>{@link #getAuthority()} - //name@host:port</li>\n  * <li>{@link #getHost()} - host</li>\n  * <li>{@link #getPort()} - port</li>\n  * <li>{@link #getPath()} - /path/info</li>\n  * <li>{@link #getParam()} - param</li>\n  * <li>{@link #getQuery()} - query</li>\n- * <li>{@link #getFragment()} - fragment</li>\n  * </ul>\n- *\n  * <p>Any parameters will be returned from {@link #getPath()}, but are excluded from the\n  * return value of {@link #getDecodedPath()}.   If there are multiple parameters, the\n- * {@link #getParam()} method returns only the last one.\n+ * {@link #getParam()} method returns only the last one. Fragments are ignored.\n  */\n-public class HttpURI\n+public interface HttpURI\n {\n-    private enum State\n+    static Mutable build()\n     {\n-        START,\n-        HOST_OR_PATH,\n-        SCHEME_OR_PATH,\n-        HOST,\n-        IPV6,\n-        PORT,\n-        PATH,\n-        PARAM,\n-        QUERY,\n-        FRAGMENT,\n-        ASTERISK\n+        return new Mutable();\n     }\n \n-    ;\n-\n-    private String _scheme;\n-    private String _user;\n-    private String _host;\n-    private int _port;\n-    private String _path;\n-    private String _param;\n-    private String _query;\n-    private String _fragment;\n-\n-    String _uri;\n-    String _decodedPath;\n-\n-    /**\n-     * Construct a normalized URI.\n-     * Port is not set if it is the default port.\n-     *\n-     * @param scheme the URI scheme\n-     * @param host the URI hose\n-     * @param port the URI port\n-     * @param path the URI path\n-     * @param param the URI param\n-     * @param query the URI query\n-     * @param fragment the URI fragment\n-     * @return the normalized URI\n-     */\n-    public static HttpURI createHttpURI(String scheme, String host, int port, String path, String param, String query, String fragment)\n+    static Mutable build(HttpURI uri)\n     {\n-        if (port == 80 && HttpScheme.HTTP.is(scheme))\n-            port = 0;\n-        if (port == 443 && HttpScheme.HTTPS.is(scheme))\n-            port = 0;\n-        return new HttpURI(scheme, host, port, path, param, query, fragment);\n+        return new Mutable(uri);\n     }\n \n-    public HttpURI()\n+    static Mutable build(HttpURI uri, String pathQuery)\n     {\n+        return new Mutable(uri, pathQuery);\n     }\n \n-    public HttpURI(String scheme, String host, int port, String path, String param, String query, String fragment)\n+    static Mutable build(HttpURI uri, String path, String param, String query)\n     {\n-        _scheme = scheme;\n-        _host = host;\n-        _port = port;\n-        _path = path;\n-        _param = param;\n-        _query = query;\n-        _fragment = fragment;\n+        return new Mutable(uri, path, param, query);\n     }\n \n-    public HttpURI(HttpURI uri)\n+    static Mutable build(URI uri)\n     {\n-        this(uri._scheme, uri._host, uri._port, uri._path, uri._param, uri._query, uri._fragment);\n-        _uri = uri._uri;\n+        return new Mutable(uri);\n     }\n \n-    public HttpURI(String uri)\n+    static Mutable build(String uri)\n     {\n-        _port = -1;\n-        parse(State.START, uri);\n+        return new Mutable(uri);\n     }\n \n-    public HttpURI(URI uri)\n+    static Immutable from(URI uri)\n     {\n-        _uri = null;\n-\n-        _scheme = uri.getScheme();\n-        _host = uri.getHost();\n-        if (_host == null && uri.getRawSchemeSpecificPart().startsWith(\"//\"))\n-            _host = \"\";\n-        _port = uri.getPort();\n-        _user = uri.getUserInfo();\n-        _path = uri.getRawPath();\n-\n-        _decodedPath = uri.getPath();\n-        if (_decodedPath != null)\n-        {\n-            int p = _decodedPath.lastIndexOf(';');\n-            if (p >= 0)\n-                _param = _decodedPath.substring(p + 1);\n-        }\n-        _query = uri.getRawQuery();\n-        _fragment = uri.getFragment();\n-\n-        _decodedPath = null;\n+        return new HttpURI.Mutable(uri).asImmutable();\n     }\n \n-    public HttpURI(String scheme, String host, int port, String pathQuery)\n+    static Immutable from(String uri)\n     {\n-        _uri = null;\n-\n-        _scheme = scheme;\n-        _host = host;\n-        _port = port;\n-\n-        if (pathQuery != null)\n-            parse(State.PATH, pathQuery);\n+        return new HttpURI.Mutable(uri).asImmutable();\n     }\n \n-    public void parse(String uri)\n+    static Immutable from(String method, String uri)\n     {\n-        clear();\n-        _uri = uri;\n-        parse(State.START, uri);\n+        if (HttpMethod.CONNECT.is(method))\n+            return new Immutable(uri);\n+        if (uri.startsWith(\"/\"))\n+            return HttpURI.build().pathQuery(uri).asImmutable();\n+        return HttpURI.from(uri);\n     }\n \n-    public void parse(String uri, int offset, int length)\n+    static Immutable from(String scheme, String host, int port, String pathQuery)\n     {\n-        clear();\n-        int end = offset + length;\n-        _uri = uri.substring(offset, end);\n-        parse(State.START, uri);\n+        return new Mutable(scheme, host, port, pathQuery).asImmutable();\n     }\n \n-    private void parse(State state, final String uri)\n-    {\n-        boolean encoded = false;\n-        int end = uri.length();\n-        int mark = 0;\n-        int pathMark = 0;\n-        char last = '/';\n-        for (int i = 0; i < end; i++)\n-        {\n-            char c = uri.charAt(i);\n+    Immutable asImmutable();\n \n-            switch (state)\n-            {\n-                case START:\n-                {\n-                    switch (c)\n-                    {\n-                        case '/':\n-                            mark = i;\n-                            state = State.HOST_OR_PATH;\n-                            break;\n-                        case ';':\n-                            mark = i + 1;\n-                            state = State.PARAM;\n-                            break;\n-                        case '?':\n-                            // assume empty path (if seen at start)\n-                            _path = \"\";\n-                            mark = i + 1;\n-                            state = State.QUERY;\n-                            break;\n-                        case '#':\n-                            mark = i + 1;\n-                            state = State.FRAGMENT;\n-                            break;\n-                        case '*':\n-                            _path = \"*\";\n-                            state = State.ASTERISK;\n-                            break;\n-\n-                        case '.':\n-                            pathMark = i;\n-                            state = State.PATH;\n-                            encoded = true;\n-                            break;\n-\n-                        default:\n-                            mark = i;\n-                            if (_scheme == null)\n-                                state = State.SCHEME_OR_PATH;\n-                            else\n-                            {\n-                                pathMark = i;\n-                                state = State.PATH;\n-                            }\n-                            break;\n-                    }\n+    String getAuthority();\n \n-                    continue;\n-                }\n+    String getDecodedPath();\n \n-                case SCHEME_OR_PATH:\n-                {\n-                    switch (c)\n-                    {\n-                        case ':':\n-                            // must have been a scheme\n-                            _scheme = uri.substring(mark, i);\n-                            // Start again with scheme set\n-                            state = State.START;\n-                            break;\n-\n-                        case '/':\n-                            // must have been in a path and still are\n-                            state = State.PATH;\n-                            break;\n+    String getHost();\n \n-                        case ';':\n-                            // must have been in a path \n-                            mark = i + 1;\n-                            state = State.PARAM;\n-                            break;\n+    String getParam();\n \n-                        case '?':\n-                            // must have been in a path \n-                            _path = uri.substring(mark, i);\n-                            mark = i + 1;\n-                            state = State.QUERY;\n-                            break;\n+    String getPath();\n \n-                        case '%':\n-                            // must have be in an encoded path \n-                            encoded = true;\n-                            state = State.PATH;\n-                            break;\n+    String getPathQuery();\n \n-                        case '#':\n-                            // must have been in a path \n-                            _path = uri.substring(mark, i);\n-                            state = State.FRAGMENT;\n-                            break;\n+    int getPort();\n \n-                        default:\n-                            break;\n-                    }\n-                    continue;\n-                }\n+    String getQuery();\n \n-                case HOST_OR_PATH:\n-                {\n-                    switch (c)\n-                    {\n-                        case '/':\n-                            _host = \"\";\n-                            mark = i + 1;\n-                            state = State.HOST;\n-                            break;\n-\n-                        case '@':\n-                        case ';':\n-                        case '?':\n-                        case '#':\n-                            // was a path, look again\n-                            i--;\n-                            pathMark = mark;\n-                            state = State.PATH;\n-                            break;\n+    String getScheme();\n \n-                        case '.':\n-                            // it is a path\n-                            encoded = true;\n-                            pathMark = mark;\n-                            state = State.PATH;\n-                            break;\n+    String getUser();\n \n-                        default:\n-                            // it is a path\n-                            pathMark = mark;\n-                            state = State.PATH;\n-                    }\n-                    continue;\n-                }\n+    boolean hasAuthority();\n \n-                case HOST:\n-                {\n-                    switch (c)\n-                    {\n-                        case '/':\n-                            _host = uri.substring(mark, i);\n-                            pathMark = mark = i;\n-                            state = State.PATH;\n-                            break;\n-                        case ':':\n-                            if (i > mark)\n-                                _host = uri.substring(mark, i);\n-                            mark = i + 1;\n-                            state = State.PORT;\n-                            break;\n-                        case '@':\n-                            if (_user != null)\n-                                throw new IllegalArgumentException(\"Bad authority\");\n-                            _user = uri.substring(mark, i);\n-                            mark = i + 1;\n-                            break;\n+    boolean isAbsolute();\n \n-                        case '[':\n-                            state = State.IPV6;\n-                            break;\n+    default URI toURI()\n+    {\n+        try\n+        {\n+            String query = getQuery();\n+            return new URI(getScheme(), null, getHost(), getPort(), getPath(), query == null ? null : UrlEncoded.decodeString(query), null);\n+        }\n+        catch (URISyntaxException x)\n+        {\n+            throw new RuntimeException(x);\n+        }\n+    }\n \n-                        default:\n-                            break;\n-                    }\n-                    break;\n-                }\n+    class Immutable implements HttpURI\n+    {\n+        private final String _scheme;\n+        private final String _user;\n+        private final String _host;\n+        private final int _port;\n+        private final String _path;\n+        private final String _param;\n+        private final String _query;\n+        private String _uri;\n+        private String _decodedPath;\n+\n+        private Immutable(Mutable builder)\n+        {\n+            _uri = builder._uri;\n+            _scheme = builder._scheme;\n+            _user = builder._user;\n+            _host = builder._host;\n+            _port = builder._port;\n+            _path = builder._path;\n+            _decodedPath = builder._decodedPath;\n+            _param = builder._param;\n+            _query = builder._query;\n+        }\n \n-                case IPV6:\n-                {\n-                    switch (c)\n-                    {\n-                        case '/':\n-                            throw new IllegalArgumentException(\"No closing ']' for ipv6 in \" + uri);\n-                        case ']':\n-                            c = uri.charAt(++i);\n-                            _host = uri.substring(mark, i);\n-                            if (c == ':')\n-                            {\n-                                mark = i + 1;\n-                                state = State.PORT;\n-                            }\n-                            else\n-                            {\n-                                pathMark = mark = i;\n-                                state = State.PATH;\n-                            }\n-                            break;\n+        private Immutable(String uri)\n+        {\n+            _uri = uri;\n+            _scheme = null;\n+            _user = null;\n+            _host = null;\n+            _port = -1;\n+            _path = uri;\n+            _decodedPath = null;\n+            _param = null;\n+            _query = null;\n+        }\n \n-                        default:\n-                            break;\n-                    }\n+        @Override\n+        public Immutable asImmutable()\n+        {\n+            return this;\n+        }\n \n-                    break;\n-                }\n+        @Override\n+        public boolean equals(Object o)\n+        {\n+            if (o == this)\n+                return true;\n+            if (!(o instanceof HttpURI))\n+                return false;\n+            return toString().equals(o.toString());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fa86645a99b52390456f0c04bea50f94b890daf5"}, "originalPosition": 476}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzcyNDE4OA==", "bodyText": "The implementation of hashCode() is missing! It must be there if equals() is overridden.", "url": "https://github.com/eclipse/jetty.project/pull/4777#discussion_r413724188", "createdAt": "2020-04-23T11:07:38Z", "author": {"login": "sbordet"}, "path": "jetty-http/src/main/java/org/eclipse/jetty/http/HttpURI.java", "diffHunk": "@@ -18,798 +18,1064 @@\n \n package org.eclipse.jetty.http;\n \n-import java.io.UnsupportedEncodingException;\n import java.net.URI;\n import java.net.URISyntaxException;\n-import java.nio.charset.Charset;\n-import java.nio.charset.StandardCharsets;\n \n-import org.eclipse.jetty.util.MultiMap;\n+import org.eclipse.jetty.util.HostPort;\n+import org.eclipse.jetty.util.StringUtil;\n import org.eclipse.jetty.util.TypeUtil;\n import org.eclipse.jetty.util.URIUtil;\n import org.eclipse.jetty.util.UrlEncoded;\n \n /**\n  * Http URI.\n- * Parse an HTTP URI from a string or byte array.  Given a URI\n- * <code>http://user@host:port/path/info;param?query#fragment</code>\n- * this class will split it into the following undecoded optional elements:<ul>\n+ *\n+ * Both {@link HttpFields.Mutable} and {@link HttpFields.Immutable} implementations are available\n+ * via the static methods such as {@link #build()} and {@link #from(String)}.\n+ *\n+ * A URI such as\n+ * <code>http://user@host:port/path;ignored/info;param?query#ignored</code>\n+ * is split into the following undecoded elements:<ul>\n  * <li>{@link #getScheme()} - http:</li>\n  * <li>{@link #getAuthority()} - //name@host:port</li>\n  * <li>{@link #getHost()} - host</li>\n  * <li>{@link #getPort()} - port</li>\n  * <li>{@link #getPath()} - /path/info</li>\n  * <li>{@link #getParam()} - param</li>\n  * <li>{@link #getQuery()} - query</li>\n- * <li>{@link #getFragment()} - fragment</li>\n  * </ul>\n- *\n  * <p>Any parameters will be returned from {@link #getPath()}, but are excluded from the\n  * return value of {@link #getDecodedPath()}.   If there are multiple parameters, the\n- * {@link #getParam()} method returns only the last one.\n+ * {@link #getParam()} method returns only the last one. Fragments are ignored.\n  */\n-public class HttpURI\n+public interface HttpURI\n {\n-    private enum State\n+    static Mutable build()\n     {\n-        START,\n-        HOST_OR_PATH,\n-        SCHEME_OR_PATH,\n-        HOST,\n-        IPV6,\n-        PORT,\n-        PATH,\n-        PARAM,\n-        QUERY,\n-        FRAGMENT,\n-        ASTERISK\n+        return new Mutable();\n     }\n \n-    ;\n-\n-    private String _scheme;\n-    private String _user;\n-    private String _host;\n-    private int _port;\n-    private String _path;\n-    private String _param;\n-    private String _query;\n-    private String _fragment;\n-\n-    String _uri;\n-    String _decodedPath;\n-\n-    /**\n-     * Construct a normalized URI.\n-     * Port is not set if it is the default port.\n-     *\n-     * @param scheme the URI scheme\n-     * @param host the URI hose\n-     * @param port the URI port\n-     * @param path the URI path\n-     * @param param the URI param\n-     * @param query the URI query\n-     * @param fragment the URI fragment\n-     * @return the normalized URI\n-     */\n-    public static HttpURI createHttpURI(String scheme, String host, int port, String path, String param, String query, String fragment)\n+    static Mutable build(HttpURI uri)\n     {\n-        if (port == 80 && HttpScheme.HTTP.is(scheme))\n-            port = 0;\n-        if (port == 443 && HttpScheme.HTTPS.is(scheme))\n-            port = 0;\n-        return new HttpURI(scheme, host, port, path, param, query, fragment);\n+        return new Mutable(uri);\n     }\n \n-    public HttpURI()\n+    static Mutable build(HttpURI uri, String pathQuery)\n     {\n+        return new Mutable(uri, pathQuery);\n     }\n \n-    public HttpURI(String scheme, String host, int port, String path, String param, String query, String fragment)\n+    static Mutable build(HttpURI uri, String path, String param, String query)\n     {\n-        _scheme = scheme;\n-        _host = host;\n-        _port = port;\n-        _path = path;\n-        _param = param;\n-        _query = query;\n-        _fragment = fragment;\n+        return new Mutable(uri, path, param, query);\n     }\n \n-    public HttpURI(HttpURI uri)\n+    static Mutable build(URI uri)\n     {\n-        this(uri._scheme, uri._host, uri._port, uri._path, uri._param, uri._query, uri._fragment);\n-        _uri = uri._uri;\n+        return new Mutable(uri);\n     }\n \n-    public HttpURI(String uri)\n+    static Mutable build(String uri)\n     {\n-        _port = -1;\n-        parse(State.START, uri);\n+        return new Mutable(uri);\n     }\n \n-    public HttpURI(URI uri)\n+    static Immutable from(URI uri)\n     {\n-        _uri = null;\n-\n-        _scheme = uri.getScheme();\n-        _host = uri.getHost();\n-        if (_host == null && uri.getRawSchemeSpecificPart().startsWith(\"//\"))\n-            _host = \"\";\n-        _port = uri.getPort();\n-        _user = uri.getUserInfo();\n-        _path = uri.getRawPath();\n-\n-        _decodedPath = uri.getPath();\n-        if (_decodedPath != null)\n-        {\n-            int p = _decodedPath.lastIndexOf(';');\n-            if (p >= 0)\n-                _param = _decodedPath.substring(p + 1);\n-        }\n-        _query = uri.getRawQuery();\n-        _fragment = uri.getFragment();\n-\n-        _decodedPath = null;\n+        return new HttpURI.Mutable(uri).asImmutable();\n     }\n \n-    public HttpURI(String scheme, String host, int port, String pathQuery)\n+    static Immutable from(String uri)\n     {\n-        _uri = null;\n-\n-        _scheme = scheme;\n-        _host = host;\n-        _port = port;\n-\n-        if (pathQuery != null)\n-            parse(State.PATH, pathQuery);\n+        return new HttpURI.Mutable(uri).asImmutable();\n     }\n \n-    public void parse(String uri)\n+    static Immutable from(String method, String uri)\n     {\n-        clear();\n-        _uri = uri;\n-        parse(State.START, uri);\n+        if (HttpMethod.CONNECT.is(method))\n+            return new Immutable(uri);\n+        if (uri.startsWith(\"/\"))\n+            return HttpURI.build().pathQuery(uri).asImmutable();\n+        return HttpURI.from(uri);\n     }\n \n-    public void parse(String uri, int offset, int length)\n+    static Immutable from(String scheme, String host, int port, String pathQuery)\n     {\n-        clear();\n-        int end = offset + length;\n-        _uri = uri.substring(offset, end);\n-        parse(State.START, uri);\n+        return new Mutable(scheme, host, port, pathQuery).asImmutable();\n     }\n \n-    private void parse(State state, final String uri)\n-    {\n-        boolean encoded = false;\n-        int end = uri.length();\n-        int mark = 0;\n-        int pathMark = 0;\n-        char last = '/';\n-        for (int i = 0; i < end; i++)\n-        {\n-            char c = uri.charAt(i);\n+    Immutable asImmutable();\n \n-            switch (state)\n-            {\n-                case START:\n-                {\n-                    switch (c)\n-                    {\n-                        case '/':\n-                            mark = i;\n-                            state = State.HOST_OR_PATH;\n-                            break;\n-                        case ';':\n-                            mark = i + 1;\n-                            state = State.PARAM;\n-                            break;\n-                        case '?':\n-                            // assume empty path (if seen at start)\n-                            _path = \"\";\n-                            mark = i + 1;\n-                            state = State.QUERY;\n-                            break;\n-                        case '#':\n-                            mark = i + 1;\n-                            state = State.FRAGMENT;\n-                            break;\n-                        case '*':\n-                            _path = \"*\";\n-                            state = State.ASTERISK;\n-                            break;\n-\n-                        case '.':\n-                            pathMark = i;\n-                            state = State.PATH;\n-                            encoded = true;\n-                            break;\n-\n-                        default:\n-                            mark = i;\n-                            if (_scheme == null)\n-                                state = State.SCHEME_OR_PATH;\n-                            else\n-                            {\n-                                pathMark = i;\n-                                state = State.PATH;\n-                            }\n-                            break;\n-                    }\n+    String getAuthority();\n \n-                    continue;\n-                }\n+    String getDecodedPath();\n \n-                case SCHEME_OR_PATH:\n-                {\n-                    switch (c)\n-                    {\n-                        case ':':\n-                            // must have been a scheme\n-                            _scheme = uri.substring(mark, i);\n-                            // Start again with scheme set\n-                            state = State.START;\n-                            break;\n-\n-                        case '/':\n-                            // must have been in a path and still are\n-                            state = State.PATH;\n-                            break;\n+    String getHost();\n \n-                        case ';':\n-                            // must have been in a path \n-                            mark = i + 1;\n-                            state = State.PARAM;\n-                            break;\n+    String getParam();\n \n-                        case '?':\n-                            // must have been in a path \n-                            _path = uri.substring(mark, i);\n-                            mark = i + 1;\n-                            state = State.QUERY;\n-                            break;\n+    String getPath();\n \n-                        case '%':\n-                            // must have be in an encoded path \n-                            encoded = true;\n-                            state = State.PATH;\n-                            break;\n+    String getPathQuery();\n \n-                        case '#':\n-                            // must have been in a path \n-                            _path = uri.substring(mark, i);\n-                            state = State.FRAGMENT;\n-                            break;\n+    int getPort();\n \n-                        default:\n-                            break;\n-                    }\n-                    continue;\n-                }\n+    String getQuery();\n \n-                case HOST_OR_PATH:\n-                {\n-                    switch (c)\n-                    {\n-                        case '/':\n-                            _host = \"\";\n-                            mark = i + 1;\n-                            state = State.HOST;\n-                            break;\n-\n-                        case '@':\n-                        case ';':\n-                        case '?':\n-                        case '#':\n-                            // was a path, look again\n-                            i--;\n-                            pathMark = mark;\n-                            state = State.PATH;\n-                            break;\n+    String getScheme();\n \n-                        case '.':\n-                            // it is a path\n-                            encoded = true;\n-                            pathMark = mark;\n-                            state = State.PATH;\n-                            break;\n+    String getUser();\n \n-                        default:\n-                            // it is a path\n-                            pathMark = mark;\n-                            state = State.PATH;\n-                    }\n-                    continue;\n-                }\n+    boolean hasAuthority();\n \n-                case HOST:\n-                {\n-                    switch (c)\n-                    {\n-                        case '/':\n-                            _host = uri.substring(mark, i);\n-                            pathMark = mark = i;\n-                            state = State.PATH;\n-                            break;\n-                        case ':':\n-                            if (i > mark)\n-                                _host = uri.substring(mark, i);\n-                            mark = i + 1;\n-                            state = State.PORT;\n-                            break;\n-                        case '@':\n-                            if (_user != null)\n-                                throw new IllegalArgumentException(\"Bad authority\");\n-                            _user = uri.substring(mark, i);\n-                            mark = i + 1;\n-                            break;\n+    boolean isAbsolute();\n \n-                        case '[':\n-                            state = State.IPV6;\n-                            break;\n+    default URI toURI()\n+    {\n+        try\n+        {\n+            String query = getQuery();\n+            return new URI(getScheme(), null, getHost(), getPort(), getPath(), query == null ? null : UrlEncoded.decodeString(query), null);\n+        }\n+        catch (URISyntaxException x)\n+        {\n+            throw new RuntimeException(x);\n+        }\n+    }\n \n-                        default:\n-                            break;\n-                    }\n-                    break;\n-                }\n+    class Immutable implements HttpURI\n+    {\n+        private final String _scheme;\n+        private final String _user;\n+        private final String _host;\n+        private final int _port;\n+        private final String _path;\n+        private final String _param;\n+        private final String _query;\n+        private String _uri;\n+        private String _decodedPath;\n+\n+        private Immutable(Mutable builder)\n+        {\n+            _uri = builder._uri;\n+            _scheme = builder._scheme;\n+            _user = builder._user;\n+            _host = builder._host;\n+            _port = builder._port;\n+            _path = builder._path;\n+            _decodedPath = builder._decodedPath;\n+            _param = builder._param;\n+            _query = builder._query;\n+        }\n \n-                case IPV6:\n-                {\n-                    switch (c)\n-                    {\n-                        case '/':\n-                            throw new IllegalArgumentException(\"No closing ']' for ipv6 in \" + uri);\n-                        case ']':\n-                            c = uri.charAt(++i);\n-                            _host = uri.substring(mark, i);\n-                            if (c == ':')\n-                            {\n-                                mark = i + 1;\n-                                state = State.PORT;\n-                            }\n-                            else\n-                            {\n-                                pathMark = mark = i;\n-                                state = State.PATH;\n-                            }\n-                            break;\n+        private Immutable(String uri)\n+        {\n+            _uri = uri;\n+            _scheme = null;\n+            _user = null;\n+            _host = null;\n+            _port = -1;\n+            _path = uri;\n+            _decodedPath = null;\n+            _param = null;\n+            _query = null;\n+        }\n \n-                        default:\n-                            break;\n-                    }\n+        @Override\n+        public Immutable asImmutable()\n+        {\n+            return this;\n+        }\n \n-                    break;\n-                }\n+        @Override\n+        public boolean equals(Object o)\n+        {\n+            if (o == this)\n+                return true;\n+            if (!(o instanceof HttpURI))\n+                return false;\n+            return toString().equals(o.toString());\n+        }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fa86645a99b52390456f0c04bea50f94b890daf5"}, "originalPosition": 477}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzcyNjU2Mw==", "bodyText": "Use same order as the field declarations.", "url": "https://github.com/eclipse/jetty.project/pull/4777#discussion_r413726563", "createdAt": "2020-04-23T11:11:36Z", "author": {"login": "sbordet"}, "path": "jetty-http/src/main/java/org/eclipse/jetty/http/HttpURI.java", "diffHunk": "@@ -18,798 +18,1064 @@\n \n package org.eclipse.jetty.http;\n \n-import java.io.UnsupportedEncodingException;\n import java.net.URI;\n import java.net.URISyntaxException;\n-import java.nio.charset.Charset;\n-import java.nio.charset.StandardCharsets;\n \n-import org.eclipse.jetty.util.MultiMap;\n+import org.eclipse.jetty.util.HostPort;\n+import org.eclipse.jetty.util.StringUtil;\n import org.eclipse.jetty.util.TypeUtil;\n import org.eclipse.jetty.util.URIUtil;\n import org.eclipse.jetty.util.UrlEncoded;\n \n /**\n  * Http URI.\n- * Parse an HTTP URI from a string or byte array.  Given a URI\n- * <code>http://user@host:port/path/info;param?query#fragment</code>\n- * this class will split it into the following undecoded optional elements:<ul>\n+ *\n+ * Both {@link HttpFields.Mutable} and {@link HttpFields.Immutable} implementations are available\n+ * via the static methods such as {@link #build()} and {@link #from(String)}.\n+ *\n+ * A URI such as\n+ * <code>http://user@host:port/path;ignored/info;param?query#ignored</code>\n+ * is split into the following undecoded elements:<ul>\n  * <li>{@link #getScheme()} - http:</li>\n  * <li>{@link #getAuthority()} - //name@host:port</li>\n  * <li>{@link #getHost()} - host</li>\n  * <li>{@link #getPort()} - port</li>\n  * <li>{@link #getPath()} - /path/info</li>\n  * <li>{@link #getParam()} - param</li>\n  * <li>{@link #getQuery()} - query</li>\n- * <li>{@link #getFragment()} - fragment</li>\n  * </ul>\n- *\n  * <p>Any parameters will be returned from {@link #getPath()}, but are excluded from the\n  * return value of {@link #getDecodedPath()}.   If there are multiple parameters, the\n- * {@link #getParam()} method returns only the last one.\n+ * {@link #getParam()} method returns only the last one. Fragments are ignored.\n  */\n-public class HttpURI\n+public interface HttpURI\n {\n-    private enum State\n+    static Mutable build()\n     {\n-        START,\n-        HOST_OR_PATH,\n-        SCHEME_OR_PATH,\n-        HOST,\n-        IPV6,\n-        PORT,\n-        PATH,\n-        PARAM,\n-        QUERY,\n-        FRAGMENT,\n-        ASTERISK\n+        return new Mutable();\n     }\n \n-    ;\n-\n-    private String _scheme;\n-    private String _user;\n-    private String _host;\n-    private int _port;\n-    private String _path;\n-    private String _param;\n-    private String _query;\n-    private String _fragment;\n-\n-    String _uri;\n-    String _decodedPath;\n-\n-    /**\n-     * Construct a normalized URI.\n-     * Port is not set if it is the default port.\n-     *\n-     * @param scheme the URI scheme\n-     * @param host the URI hose\n-     * @param port the URI port\n-     * @param path the URI path\n-     * @param param the URI param\n-     * @param query the URI query\n-     * @param fragment the URI fragment\n-     * @return the normalized URI\n-     */\n-    public static HttpURI createHttpURI(String scheme, String host, int port, String path, String param, String query, String fragment)\n+    static Mutable build(HttpURI uri)\n     {\n-        if (port == 80 && HttpScheme.HTTP.is(scheme))\n-            port = 0;\n-        if (port == 443 && HttpScheme.HTTPS.is(scheme))\n-            port = 0;\n-        return new HttpURI(scheme, host, port, path, param, query, fragment);\n+        return new Mutable(uri);\n     }\n \n-    public HttpURI()\n+    static Mutable build(HttpURI uri, String pathQuery)\n     {\n+        return new Mutable(uri, pathQuery);\n     }\n \n-    public HttpURI(String scheme, String host, int port, String path, String param, String query, String fragment)\n+    static Mutable build(HttpURI uri, String path, String param, String query)\n     {\n-        _scheme = scheme;\n-        _host = host;\n-        _port = port;\n-        _path = path;\n-        _param = param;\n-        _query = query;\n-        _fragment = fragment;\n+        return new Mutable(uri, path, param, query);\n     }\n \n-    public HttpURI(HttpURI uri)\n+    static Mutable build(URI uri)\n     {\n-        this(uri._scheme, uri._host, uri._port, uri._path, uri._param, uri._query, uri._fragment);\n-        _uri = uri._uri;\n+        return new Mutable(uri);\n     }\n \n-    public HttpURI(String uri)\n+    static Mutable build(String uri)\n     {\n-        _port = -1;\n-        parse(State.START, uri);\n+        return new Mutable(uri);\n     }\n \n-    public HttpURI(URI uri)\n+    static Immutable from(URI uri)\n     {\n-        _uri = null;\n-\n-        _scheme = uri.getScheme();\n-        _host = uri.getHost();\n-        if (_host == null && uri.getRawSchemeSpecificPart().startsWith(\"//\"))\n-            _host = \"\";\n-        _port = uri.getPort();\n-        _user = uri.getUserInfo();\n-        _path = uri.getRawPath();\n-\n-        _decodedPath = uri.getPath();\n-        if (_decodedPath != null)\n-        {\n-            int p = _decodedPath.lastIndexOf(';');\n-            if (p >= 0)\n-                _param = _decodedPath.substring(p + 1);\n-        }\n-        _query = uri.getRawQuery();\n-        _fragment = uri.getFragment();\n-\n-        _decodedPath = null;\n+        return new HttpURI.Mutable(uri).asImmutable();\n     }\n \n-    public HttpURI(String scheme, String host, int port, String pathQuery)\n+    static Immutable from(String uri)\n     {\n-        _uri = null;\n-\n-        _scheme = scheme;\n-        _host = host;\n-        _port = port;\n-\n-        if (pathQuery != null)\n-            parse(State.PATH, pathQuery);\n+        return new HttpURI.Mutable(uri).asImmutable();\n     }\n \n-    public void parse(String uri)\n+    static Immutable from(String method, String uri)\n     {\n-        clear();\n-        _uri = uri;\n-        parse(State.START, uri);\n+        if (HttpMethod.CONNECT.is(method))\n+            return new Immutable(uri);\n+        if (uri.startsWith(\"/\"))\n+            return HttpURI.build().pathQuery(uri).asImmutable();\n+        return HttpURI.from(uri);\n     }\n \n-    public void parse(String uri, int offset, int length)\n+    static Immutable from(String scheme, String host, int port, String pathQuery)\n     {\n-        clear();\n-        int end = offset + length;\n-        _uri = uri.substring(offset, end);\n-        parse(State.START, uri);\n+        return new Mutable(scheme, host, port, pathQuery).asImmutable();\n     }\n \n-    private void parse(State state, final String uri)\n-    {\n-        boolean encoded = false;\n-        int end = uri.length();\n-        int mark = 0;\n-        int pathMark = 0;\n-        char last = '/';\n-        for (int i = 0; i < end; i++)\n-        {\n-            char c = uri.charAt(i);\n+    Immutable asImmutable();\n \n-            switch (state)\n-            {\n-                case START:\n-                {\n-                    switch (c)\n-                    {\n-                        case '/':\n-                            mark = i;\n-                            state = State.HOST_OR_PATH;\n-                            break;\n-                        case ';':\n-                            mark = i + 1;\n-                            state = State.PARAM;\n-                            break;\n-                        case '?':\n-                            // assume empty path (if seen at start)\n-                            _path = \"\";\n-                            mark = i + 1;\n-                            state = State.QUERY;\n-                            break;\n-                        case '#':\n-                            mark = i + 1;\n-                            state = State.FRAGMENT;\n-                            break;\n-                        case '*':\n-                            _path = \"*\";\n-                            state = State.ASTERISK;\n-                            break;\n-\n-                        case '.':\n-                            pathMark = i;\n-                            state = State.PATH;\n-                            encoded = true;\n-                            break;\n-\n-                        default:\n-                            mark = i;\n-                            if (_scheme == null)\n-                                state = State.SCHEME_OR_PATH;\n-                            else\n-                            {\n-                                pathMark = i;\n-                                state = State.PATH;\n-                            }\n-                            break;\n-                    }\n+    String getAuthority();\n \n-                    continue;\n-                }\n+    String getDecodedPath();\n \n-                case SCHEME_OR_PATH:\n-                {\n-                    switch (c)\n-                    {\n-                        case ':':\n-                            // must have been a scheme\n-                            _scheme = uri.substring(mark, i);\n-                            // Start again with scheme set\n-                            state = State.START;\n-                            break;\n-\n-                        case '/':\n-                            // must have been in a path and still are\n-                            state = State.PATH;\n-                            break;\n+    String getHost();\n \n-                        case ';':\n-                            // must have been in a path \n-                            mark = i + 1;\n-                            state = State.PARAM;\n-                            break;\n+    String getParam();\n \n-                        case '?':\n-                            // must have been in a path \n-                            _path = uri.substring(mark, i);\n-                            mark = i + 1;\n-                            state = State.QUERY;\n-                            break;\n+    String getPath();\n \n-                        case '%':\n-                            // must have be in an encoded path \n-                            encoded = true;\n-                            state = State.PATH;\n-                            break;\n+    String getPathQuery();\n \n-                        case '#':\n-                            // must have been in a path \n-                            _path = uri.substring(mark, i);\n-                            state = State.FRAGMENT;\n-                            break;\n+    int getPort();\n \n-                        default:\n-                            break;\n-                    }\n-                    continue;\n-                }\n+    String getQuery();\n \n-                case HOST_OR_PATH:\n-                {\n-                    switch (c)\n-                    {\n-                        case '/':\n-                            _host = \"\";\n-                            mark = i + 1;\n-                            state = State.HOST;\n-                            break;\n-\n-                        case '@':\n-                        case ';':\n-                        case '?':\n-                        case '#':\n-                            // was a path, look again\n-                            i--;\n-                            pathMark = mark;\n-                            state = State.PATH;\n-                            break;\n+    String getScheme();\n \n-                        case '.':\n-                            // it is a path\n-                            encoded = true;\n-                            pathMark = mark;\n-                            state = State.PATH;\n-                            break;\n+    String getUser();\n \n-                        default:\n-                            // it is a path\n-                            pathMark = mark;\n-                            state = State.PATH;\n-                    }\n-                    continue;\n-                }\n+    boolean hasAuthority();\n \n-                case HOST:\n-                {\n-                    switch (c)\n-                    {\n-                        case '/':\n-                            _host = uri.substring(mark, i);\n-                            pathMark = mark = i;\n-                            state = State.PATH;\n-                            break;\n-                        case ':':\n-                            if (i > mark)\n-                                _host = uri.substring(mark, i);\n-                            mark = i + 1;\n-                            state = State.PORT;\n-                            break;\n-                        case '@':\n-                            if (_user != null)\n-                                throw new IllegalArgumentException(\"Bad authority\");\n-                            _user = uri.substring(mark, i);\n-                            mark = i + 1;\n-                            break;\n+    boolean isAbsolute();\n \n-                        case '[':\n-                            state = State.IPV6;\n-                            break;\n+    default URI toURI()\n+    {\n+        try\n+        {\n+            String query = getQuery();\n+            return new URI(getScheme(), null, getHost(), getPort(), getPath(), query == null ? null : UrlEncoded.decodeString(query), null);\n+        }\n+        catch (URISyntaxException x)\n+        {\n+            throw new RuntimeException(x);\n+        }\n+    }\n \n-                        default:\n-                            break;\n-                    }\n-                    break;\n-                }\n+    class Immutable implements HttpURI\n+    {\n+        private final String _scheme;\n+        private final String _user;\n+        private final String _host;\n+        private final int _port;\n+        private final String _path;\n+        private final String _param;\n+        private final String _query;\n+        private String _uri;\n+        private String _decodedPath;\n+\n+        private Immutable(Mutable builder)\n+        {\n+            _uri = builder._uri;\n+            _scheme = builder._scheme;\n+            _user = builder._user;\n+            _host = builder._host;\n+            _port = builder._port;\n+            _path = builder._path;\n+            _decodedPath = builder._decodedPath;\n+            _param = builder._param;\n+            _query = builder._query;\n+        }\n \n-                case IPV6:\n-                {\n-                    switch (c)\n-                    {\n-                        case '/':\n-                            throw new IllegalArgumentException(\"No closing ']' for ipv6 in \" + uri);\n-                        case ']':\n-                            c = uri.charAt(++i);\n-                            _host = uri.substring(mark, i);\n-                            if (c == ':')\n-                            {\n-                                mark = i + 1;\n-                                state = State.PORT;\n-                            }\n-                            else\n-                            {\n-                                pathMark = mark = i;\n-                                state = State.PATH;\n-                            }\n-                            break;\n+        private Immutable(String uri)\n+        {\n+            _uri = uri;\n+            _scheme = null;\n+            _user = null;\n+            _host = null;\n+            _port = -1;\n+            _path = uri;\n+            _decodedPath = null;\n+            _param = null;\n+            _query = null;\n+        }\n \n-                        default:\n-                            break;\n-                    }\n+        @Override\n+        public Immutable asImmutable()\n+        {\n+            return this;\n+        }\n \n-                    break;\n-                }\n+        @Override\n+        public boolean equals(Object o)\n+        {\n+            if (o == this)\n+                return true;\n+            if (!(o instanceof HttpURI))\n+                return false;\n+            return toString().equals(o.toString());\n+        }\n \n-                case PORT:\n-                {\n-                    if (c == '@')\n-                    {\n-                        if (_user != null)\n-                            throw new IllegalArgumentException(\"Bad authority\");\n-                        // It wasn't a port, but a password!\n-                        _user = _host + \":\" + uri.substring(mark, i);\n-                        mark = i + 1;\n-                        state = State.HOST;\n-                    }\n-                    else if (c == '/')\n-                    {\n-                        _port = TypeUtil.parseInt(uri, mark, i - mark, 10);\n-                        pathMark = mark = i;\n-                        state = State.PATH;\n-                    }\n-                    break;\n-                }\n+        @Override\n+        public String getAuthority()\n+        {\n+            if (_port > 0)\n+                return _host + \":\" + _port;\n+            return _host;\n+        }\n \n-                case PATH:\n-                {\n-                    switch (c)\n-                    {\n-                        case ';':\n-                            mark = i + 1;\n-                            state = State.PARAM;\n-                            break;\n-                        case '?':\n-                            _path = uri.substring(pathMark, i);\n-                            mark = i + 1;\n-                            state = State.QUERY;\n-                            break;\n-                        case '#':\n-                            _path = uri.substring(pathMark, i);\n-                            mark = i + 1;\n-                            state = State.FRAGMENT;\n-                            break;\n-                        case '%':\n-                            encoded = true;\n-                            break;\n-                        case '.':\n-                            if ('/' == last)\n-                                encoded = true;\n-                            break;\n-                        default:\n-                            break;\n-                    }\n-                    break;\n-                }\n+        @Override\n+        public String getDecodedPath()\n+        {\n+            if (_decodedPath == null && _path != null)\n+                _decodedPath = URIUtil.canonicalPath(URIUtil.decodePath(_path));\n+            return _decodedPath;\n+        }\n \n-                case PARAM:\n-                {\n-                    switch (c)\n-                    {\n-                        case '?':\n-                            _path = uri.substring(pathMark, i);\n-                            _param = uri.substring(mark, i);\n-                            mark = i + 1;\n-                            state = State.QUERY;\n-                            break;\n-                        case '#':\n-                            _path = uri.substring(pathMark, i);\n-                            _param = uri.substring(mark, i);\n-                            mark = i + 1;\n-                            state = State.FRAGMENT;\n-                            break;\n-                        case '/':\n-                            encoded = true;\n-                            // ignore internal params\n-                            state = State.PATH;\n-                            break;\n-                        case ';':\n-                            // multiple parameters\n-                            mark = i + 1;\n-                            break;\n-                        default:\n-                            break;\n-                    }\n-                    break;\n-                }\n+        @Override\n+        public String getHost()\n+        {\n+            // Return null for empty host to retain compatibility with java.net.URI\n+            if (_host != null && _host.isEmpty())\n+                return null;\n+            return _host;\n+        }\n \n-                case QUERY:\n-                {\n-                    if (c == '#')\n-                    {\n-                        _query = uri.substring(mark, i);\n-                        mark = i + 1;\n-                        state = State.FRAGMENT;\n-                    }\n-                    break;\n-                }\n+        @Override\n+        public String getParam()\n+        {\n+            return _param;\n+        }\n \n-                case ASTERISK:\n-                {\n-                    throw new IllegalArgumentException(\"Bad character '*'\");\n-                }\n+        @Override\n+        public String getPath()\n+        {\n+            return _path;\n+        }\n \n-                case FRAGMENT:\n-                {\n-                    _fragment = uri.substring(mark, end);\n-                    i = end;\n-                    break;\n-                }\n+        @Override\n+        public String getPathQuery()\n+        {\n+            if (_query == null)\n+                return _path;\n+            return _path + \"?\" + _query;\n+        }\n \n-                default:\n-                    throw new IllegalStateException(state.toString());\n-            }\n-            last = c;\n+        @Override\n+        public int getPort()\n+        {\n+            return _port;\n         }\n \n-        switch (state)\n+        @Override\n+        public String getQuery()\n         {\n-            case START:\n-                break;\n-            case SCHEME_OR_PATH:\n-                _path = uri.substring(mark, end);\n-                break;\n+            return _query;\n+        }\n \n-            case HOST_OR_PATH:\n-                _path = uri.substring(mark, end);\n-                break;\n+        @Override\n+        public String getScheme()\n+        {\n+            return _scheme;\n+        }\n+\n+        @Override\n+        public String getUser()\n+        {\n+            return _user;\n+        }\n \n-            case HOST:\n-                if (end > mark)\n-                    _host = uri.substring(mark, end);\n-                break;\n+        @Override\n+        public boolean hasAuthority()\n+        {\n+            return _host != null;\n+        }\n \n-            case IPV6:\n-                throw new IllegalArgumentException(\"No closing ']' for ipv6 in \" + uri);\n+        @Override\n+        public boolean isAbsolute()\n+        {\n+            return !StringUtil.isEmpty(_scheme);\n+        }\n \n-            case PORT:\n-                _port = TypeUtil.parseInt(uri, mark, end - mark, 10);\n-                break;\n+        @Override\n+        public String toString()\n+        {\n+            if (_uri == null)\n+            {\n+                StringBuilder out = new StringBuilder();\n \n-            case ASTERISK:\n-                break;\n+                if (_scheme != null)\n+                    out.append(_scheme).append(':');\n \n-            case FRAGMENT:\n-                _fragment = uri.substring(mark, end);\n-                break;\n+                if (_host != null)\n+                {\n+                    out.append(\"//\");\n+                    if (_user != null)\n+                        out.append(_user).append('@');\n+                    out.append(_host);\n+                }\n \n-            case PARAM:\n-                _path = uri.substring(pathMark, end);\n-                _param = uri.substring(mark, end);\n-                break;\n+                if (_port > 0)\n+                    out.append(':').append(_port);\n \n-            case PATH:\n-                _path = uri.substring(pathMark, end);\n-                break;\n+                if (_path != null)\n+                    out.append(_path);\n \n-            case QUERY:\n-                _query = uri.substring(mark, end);\n-                break;\n+                if (_query != null)\n+                    out.append('?').append(_query);\n \n-            default:\n-                throw new IllegalStateException(state.toString());\n+                if (out.length() > 0)\n+                    _uri = out.toString();\n+                else\n+                    _uri = \"\";\n+            }\n+            return _uri;\n         }\n \n-        if (!encoded)\n+        @Override\n+        public URI toURI()\n         {\n-            if (_param == null)\n-                _decodedPath = _path;\n-            else\n-                _decodedPath = _path.substring(0, _path.length() - _param.length() - 1);\n+            try\n+            {\n+                return new URI(_scheme, null, _host, _port, _path, _query == null ? null : UrlEncoded.decodeString(_query), null);\n+            }\n+            catch (URISyntaxException x)\n+            {\n+                throw new RuntimeException(x);\n+            }\n         }\n     }\n \n-    /**\n-     * Parse according to https://tools.ietf.org/html/rfc7230#section-5.3\n-     *\n-     * @param method the request method\n-     * @param uri the request uri\n-     */\n-    public void parseRequestTarget(String method, String uri)\n+    class Mutable implements HttpURI\n     {\n-        clear();\n-        _uri = uri;\n+        private enum State\n+        {\n+            START,\n+            HOST_OR_PATH,\n+            SCHEME_OR_PATH,\n+            HOST,\n+            IPV6,\n+            PORT,\n+            PATH,\n+            PARAM,\n+            QUERY,\n+            FRAGMENT,\n+            ASTERISK\n+        }\n \n-        if (HttpMethod.CONNECT.is(method))\n-            _path = uri;\n-        else\n-            parse(uri.startsWith(\"/\") ? State.PATH : State.START, uri);\n-    }\n+        private String _uri;\n+        private String _decodedPath;\n+        private String _scheme;\n+        private String _user;\n+        private String _host;\n+        private int _port;\n+        private String _path;\n+        private String _param;\n+        private String _query;\n+\n+        private Mutable()\n+        {\n+        }\n \n-    public String getScheme()\n-    {\n-        return _scheme;\n-    }\n+        private Mutable(HttpURI uri)\n+        {\n+            uri(uri);\n+        }\n \n-    public String getHost()\n-    {\n-        // Return null for empty host to retain compatibility with java.net.URI\n-        if (_host != null && _host.isEmpty())\n-            return null;\n-        return _host;\n-    }\n+        private Mutable(HttpURI baseURI, String pathQuery)\n+        {\n+            _uri = null;\n+            _scheme = baseURI.getScheme();\n+            _user = baseURI.getUser();\n+            _host = baseURI.getHost();\n+            _port = baseURI.getPort();\n+            if (pathQuery != null)\n+                parse(State.PATH, pathQuery);\n+        }\n \n-    public int getPort()\n-    {\n-        return _port;\n-    }\n+        private Mutable(HttpURI baseURI, String path, String param, String query)\n+        {\n+            _uri = null;\n+            _scheme = baseURI.getScheme();\n+            _user = baseURI.getUser();\n+            _host = baseURI.getHost();\n+            _port = baseURI.getPort();\n+            _path = path;\n+            _param = param;\n+            _query = query;\n+        }\n \n-    /**\n-     * The parsed Path.\n-     *\n-     * @return the path as parsed on valid URI.  null for invalid URI.\n-     */\n-    public String getPath()\n-    {\n-        return _path;\n-    }\n+        private Mutable(String uri)\n+        {\n+            _port = -1;\n+            parse(State.START, uri);\n+        }\n \n-    public String getDecodedPath()\n-    {\n-        if (_decodedPath == null && _path != null)\n-            _decodedPath = URIUtil.canonicalPath(URIUtil.decodePath(_path));\n-        return _decodedPath;\n-    }\n+        private Mutable(URI uri)\n+        {\n+            _uri = null;\n+\n+            _scheme = uri.getScheme();\n+            _host = uri.getHost();\n+            if (_host == null && uri.getRawSchemeSpecificPart().startsWith(\"//\"))\n+                _host = \"\";\n+            _port = uri.getPort();\n+            _user = uri.getUserInfo();\n+            _path = uri.getRawPath();\n+\n+            String pathParam = uri.getPath();\n+            if (pathParam != null)\n+            {\n+                int p = pathParam.lastIndexOf(';');\n+                if (p >= 0)\n+                    _param = pathParam.substring(p + 1);\n+                else\n+                    _decodedPath = pathParam;\n+            }\n+            _query = uri.getRawQuery();\n+        }\n \n-    public String getParam()\n-    {\n-        return _param;\n-    }\n+        private Mutable(String scheme, String host, int port, String pathQuery)\n+        {\n+            _uri = null;\n \n-    public void setParam(String param)\n-    {\n-        _param = param;\n-        if (_path != null && !_path.contains(_param))\n+            _scheme = scheme;\n+            _host = host;\n+            _port = port;\n+\n+            if (pathQuery != null)\n+                parse(State.PATH, pathQuery);\n+        }\n+\n+        @Override\n+        public Immutable asImmutable()\n         {\n-            _path += \";\" + _param;\n+            return new Immutable(this);\n         }\n-    }\n \n-    public String getQuery()\n-    {\n-        return _query;\n-    }\n+        /**\n+         * @param host the host\n+         * @param port the port\n+         * @return this mutable\n+         */\n+        public Mutable authority(String host, int port)\n+        {\n+            _user = null;\n+            _host = host;\n+            _port = port;\n+            _uri = null;\n+            return this;\n+        }\n \n-    public boolean hasQuery()\n-    {\n-        return _query != null && !_query.isEmpty();\n-    }\n+        /**\n+         * @param hostport the host and port combined\n+         * @return this mutable\n+         */\n+        public Mutable authority(String hostport)\n+        {\n+            HostPort hp = new HostPort(hostport);\n+            _user = null;\n+            _host = hp.getHost();\n+            _port = hp.getPort();\n+            _uri = null;\n+            return this;\n+        }\n \n-    public String getFragment()\n-    {\n-        return _fragment;\n-    }\n+        public Mutable clear()\n+        {\n+            _uri = null;\n+            _scheme = null;\n+            _host = null;\n+            _port = -1;\n+            _path = null;\n+            _param = null;\n+            _query = null;\n+            _decodedPath = null;\n+            _user = null;\n+            return this;\n+        }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fa86645a99b52390456f0c04bea50f94b890daf5"}, "originalPosition": 965}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzcyODM3Mw==", "bodyText": "Typo: TRAILERS.", "url": "https://github.com/eclipse/jetty.project/pull/4777#discussion_r413728373", "createdAt": "2020-04-23T11:14:48Z", "author": {"login": "sbordet"}, "path": "jetty-http/src/main/java/org/eclipse/jetty/http/MetaData.java", "diffHunk": "@@ -24,29 +24,38 @@\n \n public class MetaData implements Iterable<HttpField>\n {\n-    private HttpVersion _httpVersion;\n+    private static final Supplier<HttpFields> SELF_SUPPLIED_TRAILORS = () -> null;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fa86645a99b52390456f0c04bea50f94b890daf5"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzcyODc0Nw==", "bodyText": "Please review whether we really need this.", "url": "https://github.com/eclipse/jetty.project/pull/4777#discussion_r413728747", "createdAt": "2020-04-23T11:15:30Z", "author": {"login": "sbordet"}, "path": "jetty-http/src/main/java/org/eclipse/jetty/http/MetaData.java", "diffHunk": "@@ -83,42 +84,39 @@ public HttpFields getFields()\n         return _fields;\n     }\n \n+    public boolean mayHaveTrailers()\n+    {\n+        return _trailers != null;\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fa86645a99b52390456f0c04bea50f94b890daf5"}, "originalPosition": 73}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzczMDc3Mw==", "bodyText": "Yes, CONNECT has a scheme and a path when it's a WebSocket tunnel over HTTP/2 (RFC8441).", "url": "https://github.com/eclipse/jetty.project/pull/4777#discussion_r413730773", "createdAt": "2020-04-23T11:19:01Z", "author": {"login": "sbordet"}, "path": "jetty-http/src/main/java/org/eclipse/jetty/http/MetaData.java", "diffHunk": "@@ -257,7 +221,10 @@ public ConnectRequest(HttpScheme scheme, HostPortHttpField authority, String pat\n \n         public ConnectRequest(String scheme, HostPortHttpField authority, String path, HttpFields fields, String protocol)\n         {\n-            super(HttpMethod.CONNECT.asString(), scheme, authority, path, HttpVersion.HTTP_2, fields, Long.MIN_VALUE);\n+            // TODO should connect requests have paths?", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fa86645a99b52390456f0c04bea50f94b890daf5"}, "originalPosition": 230}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzczNDk5NA==", "bodyText": "Revert when you have reverted the fragment.", "url": "https://github.com/eclipse/jetty.project/pull/4777#discussion_r413734994", "createdAt": "2020-04-23T11:26:14Z", "author": {"login": "sbordet"}, "path": "jetty-http/src/test/java/org/eclipse/jetty/http/HttpURIParseTest.java", "diffHunk": "@@ -179,7 +179,10 @@ public void testParseString(String input, String scheme, String host, Integer po\n             assertThat(\"[\" + input + \"] .path\", httpUri.getPath(), is(path));\n             assertThat(\"[\" + input + \"] .param\", httpUri.getParam(), is(param));\n             assertThat(\"[\" + input + \"] .query\", httpUri.getQuery(), is(query));\n-            assertThat(\"[\" + input + \"] .fragment\", httpUri.getFragment(), is(fragment));\n+\n+            // We don't retain the fragment\n+            if (input.indexOf('#') >= 0)\n+                input = input.substring(0, input.indexOf('#'));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fa86645a99b52390456f0c04bea50f94b890daf5"}, "originalPosition": 17}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzczNzQ0Ng==", "bodyText": "Remove .Mutable.", "url": "https://github.com/eclipse/jetty.project/pull/4777#discussion_r413737446", "createdAt": "2020-04-23T11:30:27Z", "author": {"login": "sbordet"}, "path": "jetty-http2/http2-client/src/test/java/org/eclipse/jetty/http2/client/HTTP2Test.java", "diffHunk": "@@ -811,8 +806,8 @@ public void testClientInvalidHeader() throws Exception\n \n         // A bad header in the request should fail on the client.\n         Session session = newClient(new Session.Listener.Adapter());\n-        HttpFields requestFields = new HttpFields();\n-        requestFields.put(\":custom\", \"special\");\n+        HttpFields.Mutable requestFields = HttpFields.build()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fa86645a99b52390456f0c04bea50f94b890daf5"}, "originalPosition": 209}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzc0MTU3OQ==", "bodyText": "Why was this logic removed? Seems important to me.", "url": "https://github.com/eclipse/jetty.project/pull/4777#discussion_r413741579", "createdAt": "2020-04-23T11:37:36Z", "author": {"login": "sbordet"}, "path": "jetty-http2/http2-hpack/src/main/java/org/eclipse/jetty/http2/hpack/MetaDataBuilder.java", "diffHunk": "@@ -162,14 +163,6 @@ else if (value != null)\n                     break;\n \n                 case HOST:\n-                    // :authority fields must come first.  If we have one, ignore the host header as far as authority goes.\n-                    if (_authority == null)\n-                    {\n-                        if (field instanceof HostPortHttpField)\n-                            _authority = (HostPortHttpField)field;\n-                        else if (value != null)\n-                            _authority = new AuthorityHttpField(value);\n-                    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fa86645a99b52390456f0c04bea50f94b890daf5"}, "originalPosition": 35}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzc0NjI3OA==", "bodyText": "This is the CONNECT tunnel request, it does not have trailers.", "url": "https://github.com/eclipse/jetty.project/pull/4777#discussion_r413746278", "createdAt": "2020-04-23T11:45:57Z", "author": {"login": "sbordet"}, "path": "jetty-http2/http2-http-client-transport/src/main/java/org/eclipse/jetty/http2/client/http/HttpSenderOverHTTP2.java", "diffHunk": "@@ -64,6 +64,8 @@ protected void sendHeaders(HttpExchange exchange, ByteBuffer contentBuffer, bool\n         MetaData.Request metaData;\n         if (isTunnel)\n         {\n+            // TODO what to do with trailers ??", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fa86645a99b52390456f0c04bea50f94b890daf5"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzc0NjUyMg==", "bodyText": "CONNECT requests may have scheme and path for WebSocket over HTTP/2.", "url": "https://github.com/eclipse/jetty.project/pull/4777#discussion_r413746522", "createdAt": "2020-04-23T11:46:18Z", "author": {"login": "sbordet"}, "path": "jetty-http2/http2-http-client-transport/src/main/java/org/eclipse/jetty/http2/client/http/HttpSenderOverHTTP2.java", "diffHunk": "@@ -64,6 +64,8 @@ protected void sendHeaders(HttpExchange exchange, ByteBuffer contentBuffer, bool\n         MetaData.Request metaData;\n         if (isTunnel)\n         {\n+            // TODO what to do with trailers ??\n+            // TODO should connect requests have paths???", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fa86645a99b52390456f0c04bea50f94b890daf5"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzc5NTQyOQ==", "bodyText": "This code was removed, but seems important that it is there.", "url": "https://github.com/eclipse/jetty.project/pull/4777#discussion_r413795429", "createdAt": "2020-04-23T13:00:51Z", "author": {"login": "sbordet"}, "path": "jetty-http2/http2-server/src/main/java/org/eclipse/jetty/http2/server/HttpChannelOverHTTP2.java", "diffHunk": "@@ -110,21 +110,9 @@ public Runnable onRequest(HeadersFrame frame)\n             MetaData.Request request = (MetaData.Request)frame.getMetaData();\n             HttpFields fields = request.getFields();\n \n-            // HTTP/2 sends the Host header as the :authority\n-            // pseudo-header, so we need to synthesize a Host header.\n-            if (!fields.contains(HttpHeader.HOST))\n-            {\n-                String authority = request.getURI().getAuthority();\n-                if (authority != null)\n-                {\n-                    // Lower-case to be consistent with other HTTP/2 headers.\n-                    fields.put(\"host\", authority);\n-                }\n-            }\n-", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fa86645a99b52390456f0c04bea50f94b890daf5"}, "originalPosition": 15}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzc5OTIxNA==", "bodyText": "Add space before _query.", "url": "https://github.com/eclipse/jetty.project/pull/4777#discussion_r413799214", "createdAt": "2020-04-23T13:06:15Z", "author": {"login": "sbordet"}, "path": "jetty-rewrite/src/main/java/org/eclipse/jetty/rewrite/handler/RewritePatternRule.java", "diffHunk": "@@ -90,20 +91,9 @@ public String apply(String target, HttpServletRequest request, HttpServletRespon\n     @Override\n     public void applyURI(Request request, String oldURI, String newURI) throws IOException\n     {\n-        if (_query == null)\n-        {\n-            request.setURIPathQuery(newURI);\n-        }\n-        else\n-        {\n-            String queryString = request.getQueryString();\n-            if (queryString != null)\n-                queryString = queryString + \"&\" + _query;\n-            else\n-                queryString = _query;\n-            request.setURIPathQuery(newURI);\n-            request.setQueryString(queryString);\n-        }\n+        HttpURI baseURI = request.getHttpURI();\n+        String query = URIUtil.addQueries(baseURI.getQuery(),_query);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fa86645a99b52390456f0c04bea50f94b890daf5"}, "originalPosition": 27}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzgwMTY0NQ==", "bodyText": "Is asImmutable() needed here?", "url": "https://github.com/eclipse/jetty.project/pull/4777#discussion_r413801645", "createdAt": "2020-04-23T13:09:47Z", "author": {"login": "sbordet"}, "path": "jetty-rewrite/src/test/java/org/eclipse/jetty/rewrite/handler/ForwardedSchemeHeaderRuleTest.java", "diffHunk": "@@ -73,13 +72,13 @@ public void testHeaderValue() throws Exception\n         _rule.matchAndApply(\"/\", _request, _response);\n         assertEquals(\"https\", _request.getScheme());\n \n-        _request.setScheme(\"other\");\n+        _request.setHttpURI(HttpURI.build(_request.getRequestURI()).scheme(\"other\").asImmutable());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fa86645a99b52390456f0c04bea50f94b890daf5"}, "originalPosition": 30}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzgwMTc4OQ==", "bodyText": "Is asImmutable() needed here?", "url": "https://github.com/eclipse/jetty.project/pull/4777#discussion_r413801789", "createdAt": "2020-04-23T13:10:00Z", "author": {"login": "sbordet"}, "path": "jetty-rewrite/src/test/java/org/eclipse/jetty/rewrite/handler/ForwardedSchemeHeaderRuleTest.java", "diffHunk": "@@ -73,13 +72,13 @@ public void testHeaderValue() throws Exception\n         _rule.matchAndApply(\"/\", _request, _response);\n         assertEquals(\"https\", _request.getScheme());\n \n-        _request.setScheme(\"other\");\n+        _request.setHttpURI(HttpURI.build(_request.getRequestURI()).scheme(\"other\").asImmutable());\n         // header value doesn't match rule's value\n         setRequestHeader(\"Front-End-Https\", \"off\");\n         _rule.matchAndApply(\"/\", _request, _response);\n         assertEquals(\"other\", _request.getScheme());\n \n-        _request.setScheme(null);\n+        _request.setHttpURI(HttpURI.build(_request.getRequestURI()).scheme((String)null).asImmutable());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fa86645a99b52390456f0c04bea50f94b890daf5"}, "originalPosition": 37}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzgwNDU5Nw==", "bodyText": "Remove all asImmutable() from this test class?", "url": "https://github.com/eclipse/jetty.project/pull/4777#discussion_r413804597", "createdAt": "2020-04-23T13:28:55Z", "author": {"login": "sbordet"}, "path": "jetty-rewrite/src/test/java/org/eclipse/jetty/rewrite/handler/RewriteHandlerTest.java", "diffHunk": "@@ -83,7 +84,7 @@ public void test() throws Exception\n         _handler.setOriginalPathAttribute(\"/before\");\n         _handler.setRewriteRequestURI(true);\n         _handler.setRewritePathInfo(true);\n-        _request.setURIPathQuery(\"/xxx/bar\");\n+        _request.setHttpURI(HttpURI.build(_request.getHttpURI(), \"/xxx/bar\").asImmutable());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fa86645a99b52390456f0c04bea50f94b890daf5"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzgxOTE3OQ==", "bodyText": "Remove all asImmutable() from this test class?", "url": "https://github.com/eclipse/jetty.project/pull/4777#discussion_r413819179", "createdAt": "2020-04-23T14:00:22Z", "author": {"login": "sbordet"}, "path": "jetty-rewrite/src/test/java/org/eclipse/jetty/rewrite/handler/RewritePatternRuleTest.java", "diffHunk": "@@ -87,8 +88,7 @@ public void testRequestWithQueryString() throws IOException\n     {\n         String replacement = \"/replace\";\n         String queryString = \"request=parameter\";\n-        _request.setURIPathQuery(\"/old/context\");\n-        _request.setQueryString(queryString);\n+        _request.setHttpURI(HttpURI.build(_request.getHttpURI(), \"/old/context\", null, queryString).asImmutable());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fa86645a99b52390456f0c04bea50f94b890daf5"}, "originalPosition": 14}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzgxOTMzNA==", "bodyText": "Remove all asImmutable() from this test class?", "url": "https://github.com/eclipse/jetty.project/pull/4777#discussion_r413819334", "createdAt": "2020-04-23T14:00:33Z", "author": {"login": "sbordet"}, "path": "jetty-rewrite/src/test/java/org/eclipse/jetty/rewrite/handler/RewriteRegexRuleTest.java", "diffHunk": "@@ -62,12 +63,12 @@ public void testRequestUriEnabled(Scenario scenario) throws Exception\n         RewriteRegexRule rule = new RewriteRegexRule();\n \n         reset();\n-        _request.setURIPathQuery(null);\n+        _request.setHttpURI(HttpURI.build(_request.getHttpURI()).asImmutable());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fa86645a99b52390456f0c04bea50f94b890daf5"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzgxOTU3MA==", "bodyText": "Remove all asImmutable() from this test class?", "url": "https://github.com/eclipse/jetty.project/pull/4777#discussion_r413819570", "createdAt": "2020-04-23T14:00:46Z", "author": {"login": "sbordet"}, "path": "jetty-rewrite/src/test/java/org/eclipse/jetty/rewrite/handler/ValidUrlRuleTest.java", "diffHunk": "@@ -43,7 +44,7 @@ public void init() throws Exception\n     public void testValidUrl() throws Exception\n     {\n         _rule.setCode(\"404\");\n-        _request.setURIPathQuery(\"/valid/uri.html\");\n+        _request.setHttpURI(HttpURI.build(_request.getHttpURI(), \"/valid/uri.html\").asImmutable());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fa86645a99b52390456f0c04bea50f94b890daf5"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzgxOTk0NQ==", "bodyText": "Remove all asImmutable() from this test class?", "url": "https://github.com/eclipse/jetty.project/pull/4777#discussion_r413819945", "createdAt": "2020-04-23T14:01:14Z", "author": {"login": "sbordet"}, "path": "jetty-rewrite/src/test/java/org/eclipse/jetty/rewrite/handler/VirtualHostRuleContainerTest.java", "diffHunk": "@@ -49,7 +50,7 @@ public void init() throws Exception\n         _fooContainerRule.setRules(new Rule[]{_fooRule});\n \n         start(false);\n-        _request.setURIPathQuery(\"/cheese/bar\");\n+        _request.setHttpURI(HttpURI.build(_request.getHttpURI(), \"/cheese/bar\").asImmutable());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fa86645a99b52390456f0c04bea50f94b890daf5"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzgyMDgwMg==", "bodyText": "Remove all asImmutable() from this test class?", "url": "https://github.com/eclipse/jetty.project/pull/4777#discussion_r413820802", "createdAt": "2020-04-23T14:02:13Z", "author": {"login": "sbordet"}, "path": "jetty-security/src/test/java/org/eclipse/jetty/security/DataConstraintsTest.java", "diffHunk": "@@ -71,7 +72,7 @@ public void startServer()\n             @Override\n             public void customize(Connector connector, HttpConfiguration channelConfig, Request request)\n             {\n-                request.setScheme(HttpScheme.HTTPS.asString());\n+                request.setHttpURI(HttpURI.build(request.getHttpURI()).scheme(HttpScheme.HTTPS).asImmutable());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fa86645a99b52390456f0c04bea50f94b890daf5"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzgyMTIxNw==", "bodyText": "Remove all asImmutable() from this test class?", "url": "https://github.com/eclipse/jetty.project/pull/4777#discussion_r413821217", "createdAt": "2020-04-23T14:02:42Z", "author": {"login": "sbordet"}, "path": "jetty-security/src/test/java/org/eclipse/jetty/security/authentication/SpnegoAuthenticatorTest.java", "diffHunk": "@@ -113,11 +112,11 @@ public void flush() throws IOException {}\n         };\n         Request req = channel.getRequest();\n         Response res = channel.getResponse();\n-        HttpFields httpFields = new HttpFields();\n+\n         // Create a bogus Authorization header. We don't care about the actual credentials.\n-        httpFields.add(HttpHeader.AUTHORIZATION, \"Basic asdf\");\n-        MetaData.Request metadata = new MetaData.Request(httpFields);\n-        metadata.setURI(new HttpURI(\"http://localhost\"));\n+\n+        MetaData.Request metadata = new MetaData.Request(null, HttpURI.build(\"http://localhost\").asImmutable(), null,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fa86645a99b52390456f0c04bea50f94b890daf5"}, "originalPosition": 21}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzgyNTgzNQ==", "bodyText": "Remove asImmutable()?", "url": "https://github.com/eclipse/jetty.project/pull/4777#discussion_r413825835", "createdAt": "2020-04-23T14:07:32Z", "author": {"login": "sbordet"}, "path": "jetty-server/src/main/java/org/eclipse/jetty/server/HttpChannel.java", "diffHunk": "@@ -720,7 +715,7 @@ public void onTrailers(HttpFields trailers)\n     {\n         if (LOG.isDebugEnabled())\n             LOG.debug(\"onTrailers {} {}\", this, trailers);\n-        _trailers = trailers;\n+        _request.getMetaData().setTrailers(trailers.asImmutable());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fa86645a99b52390456f0c04bea50f94b890daf5"}, "originalPosition": 47}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzg0NDY5Nw==", "bodyText": "Should be _queryEncoding.name(), not toString().", "url": "https://github.com/eclipse/jetty.project/pull/4777#discussion_r413844697", "createdAt": "2020-04-23T14:29:00Z", "author": {"login": "sbordet"}, "path": "jetty-server/src/main/java/org/eclipse/jetty/server/Request.java", "diffHunk": "@@ -1163,15 +1119,19 @@ public HttpVersion getHttpVersion()\n     }\n \n     public String getQueryEncoding()\n+    {\n+        return _queryEncoding == null ? null : _queryEncoding.toString();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fa86645a99b52390456f0c04bea50f94b890daf5"}, "originalPosition": 408}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzg0Nzk0NA==", "bodyText": "Space after colon.", "url": "https://github.com/eclipse/jetty.project/pull/4777#discussion_r413847944", "createdAt": "2020-04-23T14:32:47Z", "author": {"login": "sbordet"}, "path": "jetty-server/src/main/java/org/eclipse/jetty/server/ResourceService.java", "diffHunk": "@@ -488,10 +488,8 @@ protected boolean passConditionalHeaders(HttpServletRequest request, HttpServlet\n             if (request instanceof Request)\n             {\n                 // Find multiple fields by iteration as an optimization \n-                HttpFields fields = ((Request)request).getHttpFields();\n-                for (int i = fields.size(); i-- > 0; )\n+                for (HttpField field :  ((Request)request).getHttpFields())", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fa86645a99b52390456f0c04bea50f94b890daf5"}, "originalPosition": 6}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzg1NjA2NQ==", "bodyText": "The if branch is equal to the initial part of the else branch, so perhaps you can remove the duplication?", "url": "https://github.com/eclipse/jetty.project/pull/4777#discussion_r413856065", "createdAt": "2020-04-23T14:42:01Z", "author": {"login": "sbordet"}, "path": "jetty-server/src/main/java/org/eclipse/jetty/server/handler/ContextHandler.java", "diffHunk": "@@ -2142,16 +2140,25 @@ public RequestDispatcher getRequestDispatcher(String uriInContext)\n \n             try\n             {\n-                HttpURI uri = new HttpURI(null, null, 0, uriInContext);\n-\n-                String pathInfo = URIUtil.canonicalPath(uri.getDecodedPath());\n-                if (pathInfo == null)\n-                    return null;\n-\n                 String contextPath = getContextPath();\n-                if (contextPath != null && contextPath.length() > 0)\n-                    uri.setPath(URIUtil.addPaths(contextPath, uri.getPath()));\n-\n+                HttpURI uri;\n+                String pathInfo;\n+                if (StringUtil.isEmpty(contextPath))\n+                {\n+                    uri = HttpURI.from(uriInContext);\n+                    pathInfo = URIUtil.canonicalPath(uri.getDecodedPath());\n+                    if (StringUtil.isEmpty(pathInfo))\n+                        return null;\n+                }\n+                else\n+                {\n+                    HttpURI.Mutable builder = HttpURI.build(uriInContext);\n+                    if (StringUtil.isEmpty(URIUtil.canonicalPath(builder.getDecodedPath())))\n+                        return null;\n+                    builder.path(URIUtil.addPaths(contextPath,builder.getPath()));\n+                    uri = builder.asImmutable();\n+                    pathInfo = uri.getDecodedPath().substring(contextPath.length());\n+                }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fa86645a99b52390456f0c04bea50f94b890daf5"}, "originalPosition": 40}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzg1ODAxNQ==", "bodyText": "Remove .Mutable.", "url": "https://github.com/eclipse/jetty.project/pull/4777#discussion_r413858015", "createdAt": "2020-04-23T14:44:12Z", "author": {"login": "sbordet"}, "path": "jetty-server/src/main/java/org/eclipse/jetty/server/handler/ErrorHandler.java", "diffHunk": "@@ -56,7 +56,7 @@\n  * An ErrorHandler is registered with {@link ContextHandler#setErrorHandler(ErrorHandler)} or\n  * {@link Server#setErrorHandler(ErrorHandler)}.\n  * It is called by the HttpResponse.sendError method to write an error page via {@link #handle(String, Request, HttpServletRequest, HttpServletResponse)}\n- * or via {@link #badMessageError(int, String, HttpFields)} for bad requests for which a dispatch cannot be done.\n+ * or via {@link #badMessageError(int, String, HttpFields.Mutable)} for bad requests for which a dispatch cannot be done.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fa86645a99b52390456f0c04bea50f94b890daf5"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzg1ODExNQ==", "bodyText": "Remove .Mutable.", "url": "https://github.com/eclipse/jetty.project/pull/4777#discussion_r413858115", "createdAt": "2020-04-23T14:44:20Z", "author": {"login": "sbordet"}, "path": "jetty-server/src/main/java/org/eclipse/jetty/server/handler/ErrorHandler.java", "diffHunk": "@@ -521,10 +521,12 @@ protected void writeErrorPageStacks(HttpServletRequest request, Writer writer)\n      * @param fields The header fields that will be sent with the response.\n      * @return The content as a ByteBuffer, or null for no body.\n      */\n-    public ByteBuffer badMessageError(int status, String reason, HttpFields fields)\n+    public ByteBuffer badMessageError(int status, String reason, HttpFields.Mutable fields)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fa86645a99b52390456f0c04bea50f94b890daf5"}, "originalPosition": 14}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzg2NDUwOA==", "bodyText": "Remove .asImmutable().", "url": "https://github.com/eclipse/jetty.project/pull/4777#discussion_r413864508", "createdAt": "2020-04-23T14:51:20Z", "author": {"login": "sbordet"}, "path": "jetty-server/src/test/java/org/eclipse/jetty/server/ResponseTest.java", "diffHunk": "@@ -861,7 +861,7 @@ public void testEncodeRedirect()\n     {\n         Response response = getResponse();\n         Request request = response.getHttpChannel().getRequest();\n-        request.setAuthority(\"myhost\", 8888);\n+        request.setHttpURI(HttpURI.build(request.getHttpURI()).host(\"myhost\").port(8888).asImmutable());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fa86645a99b52390456f0c04bea50f94b890daf5"}, "originalPosition": 14}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzg2NDYzMg==", "bodyText": "Remove .asImmutable().", "url": "https://github.com/eclipse/jetty.project/pull/4777#discussion_r413864632", "createdAt": "2020-04-23T14:51:30Z", "author": {"login": "sbordet"}, "path": "jetty-server/src/test/java/org/eclipse/jetty/server/ResponseTest.java", "diffHunk": "@@ -949,10 +950,12 @@ public void testSendRedirect()\n                     Response response = getResponse();\n                     Request request = response.getHttpChannel().getRequest();\n \n-                    request.setScheme(\"http\");\n+                    HttpURI.Mutable builder = HttpURI.build(request.getHttpURI(),\n+                        \"/path/info;param;jsessionid=12345?query=0&more=1#target\");\n+                    builder.scheme(\"http\");\n                     if (host != null)\n-                        request.setAuthority(host, port);\n-                    request.setURIPathQuery(\"/path/info;param;jsessionid=12345?query=0&more=1#target\");\n+                        builder.host(host).port(port);\n+                    request.setHttpURI(builder.asImmutable());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fa86645a99b52390456f0c04bea50f94b890daf5"}, "originalPosition": 38}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzg3MTc5OQ==", "bodyText": "Likely no need for .Mutable everywhere in this class.", "url": "https://github.com/eclipse/jetty.project/pull/4777#discussion_r413871799", "createdAt": "2020-04-23T14:59:43Z", "author": {"login": "sbordet"}, "path": "jetty-websocket/websocket-core/src/test/java/org/eclipse/jetty/websocket/core/extensions/PerMessageDeflaterBufferSizeTest.java", "diffHunk": "@@ -106,7 +106,7 @@ public void testClientDeflateBufferSize() throws Exception\n         ClientUpgradeRequest upgradeRequest = ClientUpgradeRequest.from(client, serverUri, clientHandler);\n         upgradeRequest.addExtensions(\"permessage-deflate; @deflate_buffer_size=\" + deflateBufferSize);\n \n-        CompletableFuture<HttpFields> futureRequestHeaders = new CompletableFuture<>();\n+        CompletableFuture<HttpFields.Mutable> futureRequestHeaders = new CompletableFuture<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fa86645a99b52390456f0c04bea50f94b890daf5"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzg3NDAzOQ==", "bodyText": "This is the same as the variable fields declared above, so remove the duplication?", "url": "https://github.com/eclipse/jetty.project/pull/4777#discussion_r413874039", "createdAt": "2020-04-23T15:02:07Z", "author": {"login": "sbordet"}, "path": "jetty-websocket/websocket-jetty-client/src/main/java/org/eclipse/jetty/websocket/client/impl/JettyClientUpgradeRequest.java", "diffHunk": "@@ -49,14 +49,14 @@ public JettyClientUpgradeRequest(WebSocketCoreClient coreClient, UpgradeRequest\n         if (request != null)\n         {\n             // Copy request details into actual request\n-            HttpFields fields = getHeaders();\n+            HttpFields.Mutable fields = getHeaders();\n             request.getHeaders().forEach(fields::put);\n \n             // Copy manually created Cookies into place\n             List<HttpCookie> cookies = request.getCookies();\n             if (cookies != null)\n             {\n-                HttpFields headers = getHeaders();\n+                HttpFields.Mutable headers = getHeaders();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fa86645a99b52390456f0c04bea50f94b890daf5"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzg3ODY2OA==", "bodyText": "Use HttpFields.EMPTY.", "url": "https://github.com/eclipse/jetty.project/pull/4777#discussion_r413878668", "createdAt": "2020-04-23T15:07:41Z", "author": {"login": "sbordet"}, "path": "tests/test-http-client-transport/src/test/java/org/eclipse/jetty/http/client/ProxyWithDynamicTransportTest.java", "diffHunk": "@@ -442,7 +442,7 @@ protected void close(Throwable failure)\n         http2Client.connect(new InetSocketAddress(\"localhost\", proxyConnector.getLocalPort()), new Session.Listener.Adapter(), sessionPromise);\n         Session session = sessionPromise.get(5, TimeUnit.SECONDS);\n         String serverAddress = \"localhost:\" + serverConnector.getLocalPort();\n-        MetaData.ConnectRequest connect = new MetaData.ConnectRequest(HttpScheme.HTTP, new AuthorityHttpField(serverAddress), null, new HttpFields(), null);\n+        MetaData.ConnectRequest connect = new MetaData.ConnectRequest(HttpScheme.HTTP, new AuthorityHttpField(serverAddress), null, HttpFields.build(), null);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fa86645a99b52390456f0c04bea50f94b890daf5"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzg3ODgwMQ==", "bodyText": "Use HttpFields.EMPTY.", "url": "https://github.com/eclipse/jetty.project/pull/4777#discussion_r413878801", "createdAt": "2020-04-23T15:07:48Z", "author": {"login": "sbordet"}, "path": "tests/test-http-client-transport/src/test/java/org/eclipse/jetty/http/client/ProxyWithDynamicTransportTest.java", "diffHunk": "@@ -527,7 +527,7 @@ protected void close(Throwable failure)\n         http2Client.connect(new InetSocketAddress(\"localhost\", proxyConnector.getLocalPort()), new Session.Listener.Adapter(), sessionPromise);\n         Session session = sessionPromise.get(5, TimeUnit.SECONDS);\n         String serverAddress = \"localhost:\" + serverConnector.getLocalPort();\n-        MetaData.ConnectRequest connect = new MetaData.ConnectRequest(HttpScheme.HTTP, new AuthorityHttpField(serverAddress), null, new HttpFields(), null);\n+        MetaData.ConnectRequest connect = new MetaData.ConnectRequest(HttpScheme.HTTP, new AuthorityHttpField(serverAddress), null, HttpFields.build(), null);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fa86645a99b52390456f0c04bea50f94b890daf5"}, "originalPosition": 14}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c71cb54a13f9ca2a72a3ba8e4bb7c64ba359b635", "author": {"user": {"login": "gregw", "name": "Greg Wilkins"}}, "url": "https://github.com/eclipse/jetty.project/commit/c71cb54a13f9ca2a72a3ba8e4bb7c64ba359b635", "committedDate": "2020-04-23T17:10:02Z", "message": "Immutable MetaData WIP\n\nchanges after review:\n + less usage of Mutable\n + more usage of EMPTY\n + restored fragment handling\n\nSigned-off-by: Greg Wilkins <gregw@webtide.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1fe41691011c6434ee6c1a894f676fcc83a42739", "author": {"user": {"login": "gregw", "name": "Greg Wilkins"}}, "url": "https://github.com/eclipse/jetty.project/commit/1fe41691011c6434ee6c1a894f676fcc83a42739", "committedDate": "2020-04-23T17:43:23Z", "message": "Immutable MetaData WIP\n\nchanges after review:\n + less usage of Mutable\n + less usage of asImmutable\n\nSigned-off-by: Greg Wilkins <gregw@webtide.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9e9274fece8b9f952e5b5c91c548c7c962ebd7b8", "author": {"user": {"login": "gregw", "name": "Greg Wilkins"}}, "url": "https://github.com/eclipse/jetty.project/commit/9e9274fece8b9f952e5b5c91c548c7c962ebd7b8", "committedDate": "2020-04-24T07:52:24Z", "message": "Immutable MetaData WIP\n\nchanges after review:\n + less usage of Mutable\n\nSigned-off-by: Greg Wilkins <gregw@webtide.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1abe2c79f8b3ab0257b105b095ee67f90b2fb3c3", "author": {"user": {"login": "gregw", "name": "Greg Wilkins"}}, "url": "https://github.com/eclipse/jetty.project/commit/1abe2c79f8b3ab0257b105b095ee67f90b2fb3c3", "committedDate": "2020-04-24T08:11:25Z", "message": "Immutable MetaData\n\nchanges after review:\n + better handling of URI in ContextHandler\n\nSigned-off-by: Greg Wilkins <gregw@webtide.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ad82672e233254cb6e49b7bfe8cc431b2a7a8f5f", "author": {"user": {"login": "gregw", "name": "Greg Wilkins"}}, "url": "https://github.com/eclipse/jetty.project/commit/ad82672e233254cb6e49b7bfe8cc431b2a7a8f5f", "committedDate": "2020-04-24T08:46:38Z", "message": "Immutable MetaData\n\nchanges after review:\n + downcast in test to access mutable response headers.\n\nSigned-off-by: Greg Wilkins <gregw@webtide.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk5NzUyNDU3", "url": "https://github.com/eclipse/jetty.project/pull/4777#pullrequestreview-399752457", "createdAt": "2020-04-24T08:41:14Z", "commit": {"oid": "1abe2c79f8b3ab0257b105b095ee67f90b2fb3c3"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yNFQwODo0MToxNFrOGLNCVQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yNFQwOTowOTowMFrOGLOJIQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDQwMTEwOQ==", "bodyText": "Please use put() since it's not a multiple occurrences header.", "url": "https://github.com/eclipse/jetty.project/pull/4777#discussion_r414401109", "createdAt": "2020-04-24T08:41:14Z", "author": {"login": "sbordet"}, "path": "jetty-documentation/src/main/java/embedded/client/http2/HTTP2ClientDocs.java", "diffHunk": "@@ -266,9 +266,9 @@ public void reset() throws Exception\n         CompletableFuture<Session> sessionCF = http2Client.connect(serverAddress, new Session.Listener.Adapter());\n         Session session = sessionCF.get();\n \n-        HttpFields requestHeaders = new HttpFields();\n-        requestHeaders.put(HttpHeader.USER_AGENT, \"Jetty HTTP2Client {version}\");\n-        MetaData.Request request = new MetaData.Request(\"GET\", new HttpURI(\"http://localhost:8080/path\"), HttpVersion.HTTP_2, requestHeaders);\n+        HttpFields requestHeaders = HttpFields.build()\n+            .add(HttpHeader.USER_AGENT, \"Jetty HTTP2Client {version}\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1abe2c79f8b3ab0257b105b095ee67f90b2fb3c3"}, "originalPosition": 51}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDQwMTE5Ng==", "bodyText": "Please use put() since it's not a multiple occurrences header.", "url": "https://github.com/eclipse/jetty.project/pull/4777#discussion_r414401196", "createdAt": "2020-04-24T08:41:21Z", "author": {"login": "sbordet"}, "path": "jetty-documentation/src/main/java/embedded/client/http2/HTTP2ClientDocs.java", "diffHunk": "@@ -296,9 +296,9 @@ public void push() throws Exception\n         CompletableFuture<Session> sessionCF = http2Client.connect(serverAddress, new Session.Listener.Adapter());\n         Session session = sessionCF.get();\n \n-        HttpFields requestHeaders = new HttpFields();\n-        requestHeaders.put(HttpHeader.USER_AGENT, \"Jetty HTTP2Client {version}\");\n-        MetaData.Request request = new MetaData.Request(\"GET\", new HttpURI(\"http://localhost:8080/path\"), HttpVersion.HTTP_2, requestHeaders);\n+        HttpFields requestHeaders = HttpFields.build()\n+            .add(HttpHeader.USER_AGENT, \"Jetty HTTP2Client {version}\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1abe2c79f8b3ab0257b105b095ee67f90b2fb3c3"}, "originalPosition": 64}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDQxODY4MQ==", "bodyText": "Please rename to singular WS_VERSION_FIELD.", "url": "https://github.com/eclipse/jetty.project/pull/4777#discussion_r414418681", "createdAt": "2020-04-24T09:08:12Z", "author": {"login": "sbordet"}, "path": "jetty-websocket/websocket-core/src/main/java/org/eclipse/jetty/websocket/core/client/HttpUpgraderOverHTTP2.java", "diffHunk": "@@ -23,12 +23,14 @@\n import org.eclipse.jetty.client.HttpUpgrader;\n import org.eclipse.jetty.http.HttpHeader;\n import org.eclipse.jetty.http.HttpMethod;\n+import org.eclipse.jetty.http.PreEncodedHttpField;\n import org.eclipse.jetty.io.EndPoint;\n import org.eclipse.jetty.util.Callback;\n import org.eclipse.jetty.websocket.core.WebSocketConstants;\n \n public class HttpUpgraderOverHTTP2 implements HttpUpgrader\n {\n+    public static final PreEncodedHttpField WS_VERSIONS_FIELD = new PreEncodedHttpField(HttpHeader.SEC_WEBSOCKET_VERSION, WebSocketConstants.SPEC_VERSION_STRING);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ad82672e233254cb6e49b7bfe8cc431b2a7a8f5f"}, "originalPosition": 11}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDQxOTIzMw==", "bodyText": "Checkstyle will complain, as for always requires braces.", "url": "https://github.com/eclipse/jetty.project/pull/4777#discussion_r414419233", "createdAt": "2020-04-24T09:09:00Z", "author": {"login": "sbordet"}, "path": "jetty-websocket/websocket-jetty-client/src/main/java/org/eclipse/jetty/websocket/client/impl/JettyClientUpgradeRequest.java", "diffHunk": "@@ -49,19 +49,16 @@ public JettyClientUpgradeRequest(WebSocketCoreClient coreClient, UpgradeRequest\n         if (request != null)\n         {\n             // Copy request details into actual request\n-            HttpFields fields = getHeaders();\n+            HttpFields.Mutable fields = getHeaders();\n             request.getHeaders().forEach(fields::put);\n \n             // Copy manually created Cookies into place\n             List<HttpCookie> cookies = request.getCookies();\n             if (cookies != null)\n             {\n-                HttpFields headers = getHeaders();\n                 // TODO: remove existing Cookie header (if set)?\n                 for (HttpCookie cookie : cookies)\n-                {\n-                    headers.add(HttpHeader.COOKIE, cookie.toString());\n-                }\n+                    fields.add(HttpHeader.COOKIE, cookie.toString());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ad82672e233254cb6e49b7bfe8cc431b2a7a8f5f"}, "originalPosition": 18}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ec9224d2191468dde347ac2d5e625d01ea4919e4", "author": {"user": {"login": "gregw", "name": "Greg Wilkins"}}, "url": "https://github.com/eclipse/jetty.project/commit/ec9224d2191468dde347ac2d5e625d01ea4919e4", "committedDate": "2020-04-24T16:32:10Z", "message": "Immutable MetaData\n\nchanges after review:\n + use put instead of add for one time headers\n\nSigned-off-by: Greg Wilkins <gregw@webtide.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDAwODI4NTY0", "url": "https://github.com/eclipse/jetty.project/pull/4777#pullrequestreview-400828564", "createdAt": "2020-04-27T10:36:13Z", "commit": {"oid": "ec9224d2191468dde347ac2d5e625d01ea4919e4"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yN1QxMDozNjoxM1rOGMcXuQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yN1QxMDozNjoxM1rOGMcXuQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTcwMDkyMQ==", "bodyText": "Make it private.", "url": "https://github.com/eclipse/jetty.project/pull/4777#discussion_r415700921", "createdAt": "2020-04-27T10:36:13Z", "author": {"login": "sbordet"}, "path": "jetty-websocket/websocket-core/src/main/java/org/eclipse/jetty/websocket/core/client/HttpUpgraderOverHTTP2.java", "diffHunk": "@@ -23,12 +23,14 @@\n import org.eclipse.jetty.client.HttpUpgrader;\n import org.eclipse.jetty.http.HttpHeader;\n import org.eclipse.jetty.http.HttpMethod;\n+import org.eclipse.jetty.http.PreEncodedHttpField;\n import org.eclipse.jetty.io.EndPoint;\n import org.eclipse.jetty.util.Callback;\n import org.eclipse.jetty.websocket.core.WebSocketConstants;\n \n public class HttpUpgraderOverHTTP2 implements HttpUpgrader\n {\n+    public static final PreEncodedHttpField WS_VERSION_FIELD = new PreEncodedHttpField(HttpHeader.SEC_WEBSOCKET_VERSION, WebSocketConstants.SPEC_VERSION_STRING);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ec9224d2191468dde347ac2d5e625d01ea4919e4"}, "originalPosition": 11}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5817a1ab489dfc5d4f5eb1de93e2a4f7d98416a3", "author": {"user": {"login": "gregw", "name": "Greg Wilkins"}}, "url": "https://github.com/eclipse/jetty.project/commit/5817a1ab489dfc5d4f5eb1de93e2a4f7d98416a3", "committedDate": "2020-04-27T10:56:34Z", "message": "private\n\nSigned-off-by: Greg Wilkins <gregw@webtide.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDAwOTMxNDAz", "url": "https://github.com/eclipse/jetty.project/pull/4777#pullrequestreview-400931403", "createdAt": "2020-04-27T13:06:19Z", "commit": {"oid": "5817a1ab489dfc5d4f5eb1de93e2a4f7d98416a3"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDAwOTMzMDUy", "url": "https://github.com/eclipse/jetty.project/pull/4777#pullrequestreview-400933052", "createdAt": "2020-04-27T13:08:23Z", "commit": {"oid": "5817a1ab489dfc5d4f5eb1de93e2a4f7d98416a3"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ac3cb3cf21cf3d50f13368ca3e2688401acc1d81", "author": {"user": {"login": "gregw", "name": "Greg Wilkins"}}, "url": "https://github.com/eclipse/jetty.project/commit/ac3cb3cf21cf3d50f13368ca3e2688401acc1d81", "committedDate": "2020-04-27T13:14:10Z", "message": "Merge remote-tracking branch 'origin/jetty-10.0.x' into jetty-10.0.x-ImmutableMetaData"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "79bb9f75eae4101f31cdfbd137dc587a1c5a0813", "author": {"user": {"login": "gregw", "name": "Greg Wilkins"}}, "url": "https://github.com/eclipse/jetty.project/commit/79bb9f75eae4101f31cdfbd137dc587a1c5a0813", "committedDate": "2020-04-28T08:58:02Z", "message": "Merge branch 'jetty-10.0.x' into jetty-10.0.x-ImmutableMetaData"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 345, "cost": 1, "resetAt": "2021-11-01T13:51:04Z"}}}