{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzcyMzUyNjgy", "number": 4556, "title": "HttpInput refactoring", "bodyText": "This is a work in progress, the PR is only about exercising the code against the full test suite under Jenkins. As a reminder, this work was triggered by #4318.\nOld status:\n\nHTTP 1 and FCGI have been reimplemented and nearly pass the full test suite (Milestone 1)\nHTTP 2 has been reimplemented and nearly passes the full test suite (Milestone 2)\nAll HttpInput* implementations pass the full test suite (Milestone 3)\nHTTP 1, 2 and FCGI implementations share 90% of their code, don't queue and pass the full test suite (Milestone 4)\naddContent() doesn't return a boolean that is used for scheduling. (Milestone 5)\nHTTP 1, 2 and FCGI use the exact same implementation, all differences having been pushed to HttpChannel (Milestone 6).\n\nCurrent status:\n\nGot rid of addContent() by making produceContent() return Content instead.\nMake EOF and errors be special content.\nTransition to a much simplified FSM by using the needContent() / produceContent() model.\nImplement blocking on top of async, this way there is only one FSM.\n\nNext steps:\n\nCode review.", "createdAt": "2020-02-07T10:56:41Z", "url": "https://github.com/eclipse/jetty.project/pull/4556", "merged": true, "mergeCommit": {"oid": "ebea687b5be04a812854f9973caf6732ecb3f8e0"}, "closed": true, "closedAt": "2020-11-03T17:54:24Z", "author": {"login": "lorban"}, "timelineItems": {"totalCount": 105, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdY7x_OgH2gAyMzcyMzUyNjgyOjk4MmRkYzBjNDgyMTcxZTNlMzg2MDgwMTkxZjJhMzA2Nzg2NWE0MmI=", "endCursor": "Y3Vyc29yOnYyOpPPAAABdY7yhaABqjM5NTM3NjM0NDE=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "982ddc0c482171e3e386080191f2a3067865a42b", "author": {"user": {"login": "lorban", "name": "Ludovic Orban"}}, "url": "https://github.com/eclipse/jetty.project/commit/982ddc0c482171e3e386080191f2a3067865a42b", "committedDate": "2020-11-03T16:30:25Z", "message": "FCGI queue and pull model, merge all common code between H1, H2 and FCGI (Milestone 3)\n\nSigned-off-by: Ludovic Orban <lorban@bitronix.be>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d0f04a8eae8bbb550b6f89a888392dde0d5d54b5", "author": {"user": {"login": "lorban", "name": "Ludovic Orban"}}, "url": "https://github.com/eclipse/jetty.project/commit/d0f04a8eae8bbb550b6f89a888392dde0d5d54b5", "committedDate": "2020-11-03T16:30:25Z", "message": "addContent now returns void (Milestone 4)\n\nSigned-off-by: Ludovic Orban <lorban@bitronix.be>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a4258ec9c09ca36e59b9cff26cd2f267838b407a", "author": {"user": {"login": "lorban", "name": "Ludovic Orban"}}, "url": "https://github.com/eclipse/jetty.project/commit/a4258ec9c09ca36e59b9cff26cd2f267838b407a", "committedDate": "2020-11-03T16:30:25Z", "message": "Merge all HttpInput* impls into a single class, push all differences to HttpChannel* impls (Milestone 5)\n\nSigned-off-by: Ludovic Orban <lorban@bitronix.be>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "07c26e66b1ea4a73933b54052a1b4501dbae11b8", "author": {"user": {"login": "lorban", "name": "Ludovic Orban"}}, "url": "https://github.com/eclipse/jetty.project/commit/07c26e66b1ea4a73933b54052a1b4501dbae11b8", "committedDate": "2020-11-03T14:20:15Z", "message": "Get rid of addContent() by making produceContent() return Content instead.\nMake EOF and errors be special content.\nTransition to a much simplified FSM by using the needContent() / produceContent() model.\nImplement blocking on top of async, this way there is only one FSM.\n(Milestone 7)\n\nSigned-off-by: Ludovic Orban <lorban@bitronix.be>"}, "afterCommit": {"oid": "814dc69803f6c218b85c4f98306068e81be83eaa", "author": {"user": {"login": "lorban", "name": "Ludovic Orban"}}, "url": "https://github.com/eclipse/jetty.project/commit/814dc69803f6c218b85c4f98306068e81be83eaa", "committedDate": "2020-11-03T16:30:25Z", "message": "Get rid of addContent() by making produceContent() return Content instead.\nMake EOF and errors be special content.\nTransition to a much simplified FSM by using the needContent() / produceContent() model.\nImplement blocking on top of async, this way there is only one FSM.\n(Milestone 6)\n\nSigned-off-by: Ludovic Orban <lorban@bitronix.be>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "a5c74ad7ad5ce666599818171a0d4788bdc778e6", "author": {"user": {"login": "lorban", "name": "Ludovic Orban"}}, "url": "https://github.com/eclipse/jetty.project/commit/a5c74ad7ad5ce666599818171a0d4788bdc778e6", "committedDate": "2020-02-11T09:04:29Z", "message": "replace lock with semaphore to avoid a race condition in which losing unblocking notifications ends up in a deadlock\n\nThis reverts commit 826bbffd\n\nSigned-off-by: Ludovic Orban <lorban@bitronix.be>"}, "afterCommit": {"oid": "21103d0d8d1774d83e9e6da1bbeb822b7be43a0e", "author": {"user": {"login": "lorban", "name": "Ludovic Orban"}}, "url": "https://github.com/eclipse/jetty.project/commit/21103d0d8d1774d83e9e6da1bbeb822b7be43a0e", "committedDate": "2020-02-11T10:45:32Z", "message": "Milestone 1: HTTP and FCGI pass all tests\n\nSigned-off-by: Ludovic Orban <lorban@bitronix.be>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "21103d0d8d1774d83e9e6da1bbeb822b7be43a0e", "author": {"user": {"login": "lorban", "name": "Ludovic Orban"}}, "url": "https://github.com/eclipse/jetty.project/commit/21103d0d8d1774d83e9e6da1bbeb822b7be43a0e", "committedDate": "2020-02-11T10:45:32Z", "message": "Milestone 1: HTTP and FCGI pass all tests\n\nSigned-off-by: Ludovic Orban <lorban@bitronix.be>"}, "afterCommit": {"oid": "0cd6733e95bb456cb4736b193ef3f8fc9f0ba219", "author": {"user": {"login": "lorban", "name": "Ludovic Orban"}}, "url": "https://github.com/eclipse/jetty.project/commit/0cd6733e95bb456cb4736b193ef3f8fc9f0ba219", "committedDate": "2020-02-11T10:46:36Z", "message": "Milestone 1: HTTP and FCGI pass all tests\n\nSigned-off-by: Ludovic Orban <lorban@bitronix.be>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "f46b8dcaef4cc2c4c7e9d59b0b9cc2180c065660", "author": {"user": {"login": "lorban", "name": "Ludovic Orban"}}, "url": "https://github.com/eclipse/jetty.project/commit/f46b8dcaef4cc2c4c7e9d59b0b9cc2180c065660", "committedDate": "2020-02-12T10:24:09Z", "message": "run must check for transformed content, not raw one\n\nSigned-off-by: Ludovic Orban <lorban@bitronix.be>"}, "afterCommit": {"oid": "dcad5ba1083ce23bddb5f0bde4a35549913b99f1", "author": {"user": {"login": "lorban", "name": "Ludovic Orban"}}, "url": "https://github.com/eclipse/jetty.project/commit/dcad5ba1083ce23bddb5f0bde4a35549913b99f1", "committedDate": "2020-02-12T10:31:16Z", "message": "ContentProducer must check raw content queue in hasRawContent()\n\nSigned-off-by: Ludovic Orban <lorban@bitronix.be>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "42a3f92803fd19585cb8d5a1d5df62afa55ef6d4", "author": {"user": {"login": "lorban", "name": "Ludovic Orban"}}, "url": "https://github.com/eclipse/jetty.project/commit/42a3f92803fd19585cb8d5a1d5df62afa55ef6d4", "committedDate": "2020-02-12T11:36:28Z", "message": "re-implement HTTP 408 rate control\n\nSigned-off-by: Ludovic Orban <lorban@bitronix.be>"}, "afterCommit": {"oid": "d85ad4a424f68bfd91368e1307c2f6a0fe46839f", "author": {"user": {"login": "lorban", "name": "Ludovic Orban"}}, "url": "https://github.com/eclipse/jetty.project/commit/d85ad4a424f68bfd91368e1307c2f6a0fe46839f", "committedDate": "2020-02-12T11:40:24Z", "message": "re-implement HTTP 408 rate control\n\nSigned-off-by: Ludovic Orban <lorban@bitronix.be>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "0c5f88db52c78c0e887db1bce9d916793db0a752", "author": {"user": {"login": "lorban", "name": "Ludovic Orban"}}, "url": "https://github.com/eclipse/jetty.project/commit/0c5f88db52c78c0e887db1bce9d916793db0a752", "committedDate": "2020-02-12T13:00:00Z", "message": "implement HTTP onIdleTimeout\n\nSigned-off-by: Ludovic Orban <lorban@bitronix.be>"}, "afterCommit": {"oid": "188e0141c8d36f5f14831f55866e77cafc1ce93b", "author": {"user": {"login": "lorban", "name": "Ludovic Orban"}}, "url": "https://github.com/eclipse/jetty.project/commit/188e0141c8d36f5f14831f55866e77cafc1ce93b", "committedDate": "2020-02-12T13:54:49Z", "message": "implement HTTP onIdleTimeout\n\nSigned-off-by: Ludovic Orban <lorban@bitronix.be>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "01f7691cef73be6ff5ad1fffefad84cf1eb008c2", "author": {"user": {"login": "lorban", "name": "Ludovic Orban"}}, "url": "https://github.com/eclipse/jetty.project/commit/01f7691cef73be6ff5ad1fffefad84cf1eb008c2", "committedDate": "2020-02-17T15:36:17Z", "message": "fix demand() calls\n\nSigned-off-by: Ludovic Orban <lorban@bitronix.be>"}, "afterCommit": {"oid": "8c15c69abb68bf269e22ed37b10ffda8b040cf08", "author": {"user": {"login": "lorban", "name": "Ludovic Orban"}}, "url": "https://github.com/eclipse/jetty.project/commit/8c15c69abb68bf269e22ed37b10ffda8b040cf08", "committedDate": "2020-02-17T16:22:19Z", "message": "fix demand() calls\n\nSigned-off-by: Ludovic Orban <lorban@bitronix.be>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "f017cbc63d134b784eb84397d3cf2f5dccae8ae0", "author": {"user": {"login": "lorban", "name": "Ludovic Orban"}}, "url": "https://github.com/eclipse/jetty.project/commit/f017cbc63d134b784eb84397d3cf2f5dccae8ae0", "committedDate": "2020-02-18T15:29:14Z", "message": "add missing demand() call in HTTP2StreamEndPoint\n\nSigned-off-by: Ludovic Orban <lorban@bitronix.be>"}, "afterCommit": {"oid": "02c5b1f5c80c387c2e03fe609b1da4213d0b741d", "author": {"user": {"login": "lorban", "name": "Ludovic Orban"}}, "url": "https://github.com/eclipse/jetty.project/commit/02c5b1f5c80c387c2e03fe609b1da4213d0b741d", "committedDate": "2020-02-18T16:17:19Z", "message": "change HTTP2 to a pulling model similar to HTTP1\n\nSigned-off-by: Ludovic Orban <lorban@bitronix.be>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "88bcf53337449498fd72efa11b80b476da580202", "author": {"user": {"login": "lorban", "name": "Ludovic Orban"}}, "url": "https://github.com/eclipse/jetty.project/commit/88bcf53337449498fd72efa11b80b476da580202", "committedDate": "2020-02-19T16:15:37Z", "message": "tentative fix #3\n\nSigned-off-by: Ludovic Orban <lorban@bitronix.be>"}, "afterCommit": {"oid": "e2f5b0daa6c8858a3a83046547e92a64fe237ac0", "author": {"user": {"login": "lorban", "name": "Ludovic Orban"}}, "url": "https://github.com/eclipse/jetty.project/commit/e2f5b0daa6c8858a3a83046547e92a64fe237ac0", "committedDate": "2020-02-19T16:19:27Z", "message": "tentative fix #3\n\nSigned-off-by: Ludovic Orban <lorban@bitronix.be>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "1ce86372f52a41d7cbaf129c0cc117534f6c7bf7", "author": {"user": {"login": "lorban", "name": "Ludovic Orban"}}, "url": "https://github.com/eclipse/jetty.project/commit/1ce86372f52a41d7cbaf129c0cc117534f6c7bf7", "committedDate": "2020-02-24T09:04:21Z", "message": "re-align HTTP 1 and 2 consumeAll()\n\nSigned-off-by: Ludovic Orban <lorban@bitronix.be>"}, "afterCommit": {"oid": "1e441eaae8841d3ad0b900ed7d84baf52b10c415", "author": {"user": {"login": "lorban", "name": "Ludovic Orban"}}, "url": "https://github.com/eclipse/jetty.project/commit/1e441eaae8841d3ad0b900ed7d84baf52b10c415", "committedDate": "2020-02-24T10:25:53Z", "message": "re-align HTTP 1 and 2 consumeAll()\n\nSigned-off-by: Ludovic Orban <lorban@bitronix.be>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "b3fac62b3e4343c99ce80b80b0f93da01ef25519", "author": {"user": {"login": "lorban", "name": "Ludovic Orban"}}, "url": "https://github.com/eclipse/jetty.project/commit/b3fac62b3e4343c99ce80b80b0f93da01ef25519", "committedDate": "2020-02-24T14:21:49Z", "message": "move the producing flag to the enclosing class to better re-align HTTP 1 and 2 impls again\n\nSigned-off-by: Ludovic Orban <lorban@bitronix.be>"}, "afterCommit": {"oid": "11041e06b2b4c39a7b3ad44f6795df8c22a4353b", "author": {"user": {"login": "lorban", "name": "Ludovic Orban"}}, "url": "https://github.com/eclipse/jetty.project/commit/11041e06b2b4c39a7b3ad44f6795df8c22a4353b", "committedDate": "2020-02-24T15:29:18Z", "message": "replace lambdas with enclosing method calls\n\nSigned-off-by: Ludovic Orban <lorban@bitronix.be>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "11041e06b2b4c39a7b3ad44f6795df8c22a4353b", "author": {"user": {"login": "lorban", "name": "Ludovic Orban"}}, "url": "https://github.com/eclipse/jetty.project/commit/11041e06b2b4c39a7b3ad44f6795df8c22a4353b", "committedDate": "2020-02-24T15:29:18Z", "message": "replace lambdas with enclosing method calls\n\nSigned-off-by: Ludovic Orban <lorban@bitronix.be>"}, "afterCommit": {"oid": "57bb838cc1b5fc09c49ee2969973d42a5dd9ea0c", "author": {"user": {"login": "lorban", "name": "Ludovic Orban"}}, "url": "https://github.com/eclipse/jetty.project/commit/57bb838cc1b5fc09c49ee2969973d42a5dd9ea0c", "committedDate": "2020-02-24T16:45:23Z", "message": "replace lambdas with enclosing method calls\n\nSigned-off-by: Ludovic Orban <lorban@bitronix.be>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY0MTMyNTAw", "url": "https://github.com/eclipse/jetty.project/pull/4556#pullrequestreview-364132500", "createdAt": "2020-02-25T13:19:33Z", "commit": {"oid": "c609285694a824207e6f5a0a330bf9942621f524"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNVQxMzoxOTozM1rOFuFt4g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNVQxMzo1MTo0M1rOFuGyrQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mzg3MjQ4Mg==", "bodyText": "Rather than have both AbstractLockedHttpInput and AbstractHttpInput, I think AbstractHttpInput should just be lockable but initialised with a NOOP AutoLock that will be removed by the JIT", "url": "https://github.com/eclipse/jetty.project/pull/4556#discussion_r383872482", "createdAt": "2020-02-25T13:19:33Z", "author": {"login": "gregw"}, "path": "jetty-server/src/main/java/org/eclipse/jetty/server/AbstractLockedHttpInput.java", "diffHunk": "@@ -0,0 +1,236 @@\n+//\n+// ========================================================================\n+// Copyright (c) 1995-2020 Mort Bay Consulting Pty Ltd and others.\n+//\n+// This program and the accompanying materials are made available under\n+// the terms of the Eclipse Public License 2.0 which is available at\n+// https://www.eclipse.org/legal/epl-2.0\n+//\n+// This Source Code may also be made available under the following\n+// Secondary Licenses when the conditions for such availability set\n+// forth in the Eclipse Public License, v. 2.0 are satisfied:\n+// the Apache License v2.0 which is available at\n+// https://www.apache.org/licenses/LICENSE-2.0\n+//\n+// SPDX-License-Identifier: EPL-2.0 OR Apache-2.0\n+// ========================================================================\n+//\n+\n+package org.eclipse.jetty.server;\n+\n+import java.io.IOException;\n+import javax.servlet.ReadListener;\n+\n+import org.eclipse.jetty.util.thread.AutoLock;\n+\n+public abstract class AbstractLockedHttpInput extends AbstractHttpInput", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c609285694a824207e6f5a0a330bf9942621f524"}, "originalPosition": 26}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mzg3NzU5MA==", "bodyText": "It is not immediately obvious why this is always return true here?  So at the very least it needs a comment to explain.\nBut if it is always return true because you have meta knowledge about when/why addContent is called, I'm still struggling to think of why super.addContent might return false and you would want to override.   Specifically if the state is not WAITING, then returning true here might cause a second thread to be dispatched to the channel", "url": "https://github.com/eclipse/jetty.project/pull/4556#discussion_r383877590", "createdAt": "2020-02-25T13:29:40Z", "author": {"login": "gregw"}, "path": "jetty-server/src/main/java/org/eclipse/jetty/server/HttpInputOverHTTP.java", "diffHunk": "@@ -18,18 +18,37 @@\n \n package org.eclipse.jetty.server;\n \n-import java.io.IOException;\n-\n-public class HttpInputOverHTTP extends HttpInput\n+// tests used: RequestTest, PartialRFC2616Test, AsyncRequestReadTest, AsyncIOServletTest, GzipHandlerTest\n+public class HttpInputOverHTTP extends AbstractHttpInput\n {\n     public HttpInputOverHTTP(HttpChannelState state)\n     {\n         super(state);\n     }\n \n     @Override\n-    protected void produceContent() throws IOException\n+    public boolean addContent(Content content)\n+    {\n+        super.addContent(content);\n+        return true;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c609285694a824207e6f5a0a330bf9942621f524"}, "originalPosition": 20}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mzg4NTQ3Ng==", "bodyText": "I think at the very least this needs to be signalAll.\nWhile having two threads read from the same input is going to be highly problematic, the use of AbstractLockedHttpInput does mean that two threads can call read() and be mutually excluded.  If more than two bytes of content then arrive, one of the reads will be woken, but the other one never will.... then the other thread will block forever!", "url": "https://github.com/eclipse/jetty.project/pull/4556#discussion_r383885476", "createdAt": "2020-02-25T13:43:43Z", "author": {"login": "gregw"}, "path": "jetty-server/src/main/java/org/eclipse/jetty/server/AbstractHttpInput.java", "diffHunk": "@@ -0,0 +1,769 @@\n+//\n+// ========================================================================\n+// Copyright (c) 1995-2020 Mort Bay Consulting Pty Ltd and others.\n+//\n+// This program and the accompanying materials are made available under\n+// the terms of the Eclipse Public License 2.0 which is available at\n+// https://www.eclipse.org/legal/epl-2.0\n+//\n+// This Source Code may also be made available under the following\n+// Secondary Licenses when the conditions for such availability set\n+// forth in the Eclipse Public License, v. 2.0 are satisfied:\n+// the Apache License v2.0 which is available at\n+// https://www.apache.org/licenses/LICENSE-2.0\n+//\n+// SPDX-License-Identifier: EPL-2.0 OR Apache-2.0\n+// ========================================================================\n+//\n+\n+package org.eclipse.jetty.server;\n+\n+import java.io.IOException;\n+import java.util.Objects;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.locks.Condition;\n+import javax.servlet.ReadListener;\n+\n+import org.eclipse.jetty.http.BadMessageException;\n+import org.eclipse.jetty.http.HttpStatus;\n+import org.eclipse.jetty.io.EofException;\n+import org.eclipse.jetty.util.component.Destroyable;\n+import org.eclipse.jetty.util.log.Log;\n+import org.eclipse.jetty.util.log.Logger;\n+import org.eclipse.jetty.util.thread.AutoLock;\n+\n+public abstract class AbstractHttpInput extends HttpInput\n+{\n+    private static final Logger LOG = Log.getLogger(AbstractHttpInput.class);\n+\n+    private final byte[] _oneByteBuffer = new byte[1];\n+\n+    protected final HttpChannelState _channelState;\n+    protected final ContentProducer _contentProducer;\n+    protected final AutoLock _contentLock = new AutoLock();\n+    protected final Condition _contentLockCondition = _contentLock.newCondition();\n+\n+    private Eof _eof = Eof.NOT_YET;\n+    private Throwable _error;\n+    private ReadListener _readListener;\n+    private long _firstByteTimeStamp = Long.MIN_VALUE;\n+\n+    public AbstractHttpInput(HttpChannelState state)\n+    {\n+        _channelState = state;\n+        _contentProducer = new ContentProducer(this::produceRawContent);\n+    }\n+\n+    /* HttpInput */\n+\n+    @Override\n+    public void recycle()\n+    {\n+        if (LOG.isDebugEnabled())\n+            LOG.debug(\"recycle\");\n+        _contentProducer.recycle();\n+        _eof = Eof.NOT_YET;\n+        _error = null;\n+        _readListener = null;\n+        _firstByteTimeStamp = Long.MIN_VALUE;\n+    }\n+\n+    @Override\n+    public Interceptor getInterceptor()\n+    {\n+        return _contentProducer.getInterceptor();\n+    }\n+\n+    @Override\n+    public void setInterceptor(Interceptor interceptor)\n+    {\n+        _contentProducer.setInterceptor(interceptor);\n+    }\n+\n+    @Override\n+    public void addInterceptor(Interceptor interceptor)\n+    {\n+        _contentProducer.addInterceptor(interceptor);\n+    }\n+\n+    @Override\n+    public void asyncReadProduce()\n+    {\n+        if (LOG.isDebugEnabled())\n+            LOG.debug(\"asyncReadProduce {}\", _contentProducer);\n+        _contentProducer.produceRawContent();\n+    }\n+\n+    @Override\n+    public boolean addContent(Content content)\n+    {\n+        if (LOG.isDebugEnabled())\n+            LOG.debug(\"addContent {} {}\", content, _contentProducer);\n+        if (_firstByteTimeStamp == Long.MIN_VALUE)\n+        {\n+            _firstByteTimeStamp = System.nanoTime();\n+            if (_firstByteTimeStamp == Long.MIN_VALUE)\n+                _firstByteTimeStamp++;\n+        }\n+        _contentProducer.addContent(content);\n+        if (isAsync())\n+            return _channelState.onContentAdded();\n+        unblock();\n+        return false;\n+    }\n+\n+    @Override\n+    public boolean hasContent()\n+    {\n+        return _contentProducer.hasRawContent();\n+    }\n+\n+    @Override\n+    public void unblock()\n+    {\n+        try (AutoLock lock = _contentLock.lock())\n+        {\n+            if (LOG.isDebugEnabled())\n+                LOG.debug(\"signalling blocked thread to wake up\");\n+            _contentLockCondition.signal();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c609285694a824207e6f5a0a330bf9942621f524"}, "originalPosition": 128}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mzg5MDA5Mw==", "bodyText": "I fail to see the reason for different behaviour between HTTP/1 and HTTP/2 with respect to locking?\nWhy is it OK for 2 applications threads in HTTP/1 to enter read() and content on the internal data structures of raw buffers and producers without any memory barriers etc.  yet we mutually exclude when the same application is run on HTTP/2.\nIt feels like we've not really sorted out what the thread safety of this class should be.  Either we are responsible for thread safety of input or we are not - it should not depend on protocol used... even if only as a side effect of the implementation.", "url": "https://github.com/eclipse/jetty.project/pull/4556#discussion_r383890093", "createdAt": "2020-02-25T13:51:43Z", "author": {"login": "gregw"}, "path": "jetty-server/src/main/java/org/eclipse/jetty/server/AbstractLockedHttpInput.java", "diffHunk": "@@ -0,0 +1,236 @@\n+//\n+// ========================================================================\n+// Copyright (c) 1995-2020 Mort Bay Consulting Pty Ltd and others.\n+//\n+// This program and the accompanying materials are made available under\n+// the terms of the Eclipse Public License 2.0 which is available at\n+// https://www.eclipse.org/legal/epl-2.0\n+//\n+// This Source Code may also be made available under the following\n+// Secondary Licenses when the conditions for such availability set\n+// forth in the Eclipse Public License, v. 2.0 are satisfied:\n+// the Apache License v2.0 which is available at\n+// https://www.apache.org/licenses/LICENSE-2.0\n+//\n+// SPDX-License-Identifier: EPL-2.0 OR Apache-2.0\n+// ========================================================================\n+//\n+\n+package org.eclipse.jetty.server;\n+\n+import java.io.IOException;\n+import javax.servlet.ReadListener;\n+\n+import org.eclipse.jetty.util.thread.AutoLock;\n+\n+public abstract class AbstractLockedHttpInput extends AbstractHttpInput\n+{\n+    public AbstractLockedHttpInput(HttpChannelState state)\n+    {\n+        super(state);\n+    }\n+\n+    /* HttpInput */\n+\n+    @Override\n+    public void recycle()\n+    {\n+        try (AutoLock lock = _contentLock.lock())\n+        {\n+            super.recycle();\n+        }\n+    }\n+\n+    @Override\n+    public Interceptor getInterceptor()\n+    {\n+        try (AutoLock lock = _contentLock.lock())\n+        {\n+            return super.getInterceptor();\n+        }\n+    }\n+\n+    @Override\n+    public void setInterceptor(Interceptor interceptor)\n+    {\n+        try (AutoLock lock = _contentLock.lock())\n+        {\n+            super.setInterceptor(interceptor);\n+        }\n+    }\n+\n+    @Override\n+    public void addInterceptor(Interceptor interceptor)\n+    {\n+        try (AutoLock lock = _contentLock.lock())\n+        {\n+            super.addInterceptor(interceptor);\n+        }\n+    }\n+\n+    @Override\n+    public void asyncReadProduce()\n+    {\n+        try (AutoLock lock = _contentLock.lock())\n+        {\n+            super.asyncReadProduce();\n+        }\n+    }\n+\n+    @Override\n+    public boolean addContent(Content content)\n+    {\n+        try (AutoLock lock = _contentLock.lock())\n+        {\n+            return super.addContent(content);\n+        }\n+    }\n+\n+    @Override\n+    public boolean hasContent()\n+    {\n+        try (AutoLock lock = _contentLock.lock())\n+        {\n+            return super.hasContent();\n+        }\n+    }\n+\n+    @Override\n+    public long getContentLength()\n+    {\n+        try (AutoLock lock = _contentLock.lock())\n+        {\n+            return super.getContentLength();\n+        }\n+    }\n+\n+    @Override\n+    public boolean earlyEOF()\n+    {\n+        try (AutoLock lock = _contentLock.lock())\n+        {\n+            return super.earlyEOF();\n+        }\n+    }\n+\n+    @Override\n+    public boolean eof()\n+    {\n+        try (AutoLock lock = _contentLock.lock())\n+        {\n+            return super.eof();\n+        }\n+    }\n+\n+    @Override\n+    public boolean consumeAll()\n+    {\n+        try (AutoLock lock = _contentLock.lock())\n+        {\n+            return super.consumeAll();\n+        }\n+    }\n+\n+    @Override\n+    public boolean isError()\n+    {\n+        try (AutoLock lock = _contentLock.lock())\n+        {\n+            return super.isError();\n+        }\n+    }\n+\n+    @Override\n+    public boolean isAsync()\n+    {\n+        try (AutoLock lock = _contentLock.lock())\n+        {\n+            return super.isAsync();\n+        }\n+    }\n+\n+    @Override\n+    public boolean onIdleTimeout(Throwable x)\n+    {\n+        try (AutoLock lock = _contentLock.lock())\n+        {\n+            return super.onIdleTimeout(x);\n+        }\n+    }\n+\n+    @Override\n+    public boolean failed(Throwable x)\n+    {\n+        try (AutoLock lock = _contentLock.lock())\n+        {\n+            return super.failed(x);\n+        }\n+    }\n+\n+    /* ServletInputStream */\n+\n+    @Override\n+    public boolean isFinished()\n+    {\n+        try (AutoLock lock = _contentLock.lock())\n+        {\n+            return super.isFinished();\n+        }\n+    }\n+\n+    @Override\n+    public boolean isReady()\n+    {\n+        try (AutoLock lock = _contentLock.lock())\n+        {\n+            return super.isReady();\n+        }\n+    }\n+\n+    @Override\n+    public void setReadListener(ReadListener readListener)\n+    {\n+        try (AutoLock lock = _contentLock.lock())\n+        {\n+            super.setReadListener(readListener);\n+        }\n+    }\n+\n+    @Override\n+    public int read() throws IOException\n+    {\n+        try (AutoLock lock = _contentLock.lock())", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c609285694a824207e6f5a0a330bf9942621f524"}, "originalPosition": 202}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "42f764cc4ffc9b164ecb4e87525510b997476d89", "author": {"user": {"login": "lorban", "name": "Ludovic Orban"}}, "url": "https://github.com/eclipse/jetty.project/commit/42f764cc4ffc9b164ecb4e87525510b997476d89", "committedDate": "2020-02-27T10:30:23Z", "message": "FCGI queue and pull model\n\nSigned-off-by: Ludovic Orban <lorban@bitronix.be>"}, "afterCommit": {"oid": "d4e34d8528dcb0bb684ac87346518d22a625be1f", "author": {"user": {"login": "lorban", "name": "Ludovic Orban"}}, "url": "https://github.com/eclipse/jetty.project/commit/d4e34d8528dcb0bb684ac87346518d22a625be1f", "committedDate": "2020-02-27T10:42:37Z", "message": "FCGI queue and pull model\n\nSigned-off-by: Ludovic Orban <lorban@bitronix.be>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "e120d4ce4170ab4f40cd0a42f43fac0d36a91b7d", "author": {"user": {"login": "lorban", "name": "Ludovic Orban"}}, "url": "https://github.com/eclipse/jetty.project/commit/e120d4ce4170ab4f40cd0a42f43fac0d36a91b7d", "committedDate": "2020-02-27T11:29:43Z", "message": "fix potential race condition between failing content and enqueuing more content\n\nSigned-off-by: Ludovic Orban <lorban@bitronix.be>"}, "afterCommit": {"oid": "a3c751bb6addcbb11fb15698a0e55c6c66761931", "author": {"user": {"login": "lorban", "name": "Ludovic Orban"}}, "url": "https://github.com/eclipse/jetty.project/commit/a3c751bb6addcbb11fb15698a0e55c6c66761931", "committedDate": "2020-03-02T16:43:45Z", "message": "FCGI queue and pull model, merge all common code between H1, H2 and FCGI (Milestone 4)\n\nSigned-off-by: Ludovic Orban <lorban@bitronix.be>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "f05097e13608ecedd21033dad549125db3ac5621", "author": {"user": {"login": "lorban", "name": "Ludovic Orban"}}, "url": "https://github.com/eclipse/jetty.project/commit/f05097e13608ecedd21033dad549125db3ac5621", "committedDate": "2020-03-09T11:21:06Z", "message": "align H2 and H1 addContent mechanisms\n\nSigned-off-by: Ludovic Orban <lorban@bitronix.be>"}, "afterCommit": {"oid": "60727abf3c080925ac2c46c567e5d3648b4d3445", "author": {"user": {"login": "lorban", "name": "Ludovic Orban"}}, "url": "https://github.com/eclipse/jetty.project/commit/60727abf3c080925ac2c46c567e5d3648b4d3445", "committedDate": "2020-03-09T13:26:30Z", "message": "align H2 and H1 addContent mechanisms\n\nSigned-off-by: Ludovic Orban <lorban@bitronix.be>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "60727abf3c080925ac2c46c567e5d3648b4d3445", "author": {"user": {"login": "lorban", "name": "Ludovic Orban"}}, "url": "https://github.com/eclipse/jetty.project/commit/60727abf3c080925ac2c46c567e5d3648b4d3445", "committedDate": "2020-03-09T13:26:30Z", "message": "align H2 and H1 addContent mechanisms\n\nSigned-off-by: Ludovic Orban <lorban@bitronix.be>"}, "afterCommit": {"oid": "d86fc553f7d1fe6a5a4fae701cb8e6d942fa1e86", "author": {"user": {"login": "lorban", "name": "Ludovic Orban"}}, "url": "https://github.com/eclipse/jetty.project/commit/d86fc553f7d1fe6a5a4fae701cb8e6d942fa1e86", "committedDate": "2020-03-09T15:30:21Z", "message": "fix race conditions since HttpInputOverHTTP2 doesn't lock anymore\n\nSigned-off-by: Ludovic Orban <lorban@bitronix.be>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "d86fc553f7d1fe6a5a4fae701cb8e6d942fa1e86", "author": {"user": {"login": "lorban", "name": "Ludovic Orban"}}, "url": "https://github.com/eclipse/jetty.project/commit/d86fc553f7d1fe6a5a4fae701cb8e6d942fa1e86", "committedDate": "2020-03-09T15:30:21Z", "message": "fix race conditions since HttpInputOverHTTP2 doesn't lock anymore\n\nSigned-off-by: Ludovic Orban <lorban@bitronix.be>"}, "afterCommit": {"oid": "fa6df95f923d008fb5ded7138b193ae510eda2be", "author": {"user": {"login": "lorban", "name": "Ludovic Orban"}}, "url": "https://github.com/eclipse/jetty.project/commit/fa6df95f923d008fb5ded7138b193ae510eda2be", "committedDate": "2020-03-09T16:37:22Z", "message": "fix race conditions since HttpInputOverHTTP2 doesn't lock anymore\n\nSigned-off-by: Ludovic Orban <lorban@bitronix.be>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzczNTI5MjA4", "url": "https://github.com/eclipse/jetty.project/pull/4556#pullrequestreview-373529208", "createdAt": "2020-03-12T12:55:54Z", "commit": {"oid": "743877ce7be889862c63f51350d61e5281f42a66"}, "state": "COMMENTED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMlQxMjo1NTo1NVrOF1dbxw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMlQxMzowMjowMFrOF1dokQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTYwMTA5NQ==", "bodyText": "add a comment for this assert, that one and only one thread should call unblock and only if we are blocked.", "url": "https://github.com/eclipse/jetty.project/pull/4556#discussion_r391601095", "createdAt": "2020-03-12T12:55:55Z", "author": {"login": "gregw"}, "path": "jetty-server/src/main/java/org/eclipse/jetty/server/HttpInput.java", "diffHunk": "@@ -190,633 +89,348 @@ public Interceptor getInterceptor()\n      */\n     public void setInterceptor(Interceptor interceptor)\n     {\n-        _interceptor = interceptor;\n+        _contentProducer.setInterceptor(interceptor);\n     }\n \n     /**\n-     * Set the {@link Interceptor}, using a {@link ChainedInterceptor} if\n+     * Set the {@link Interceptor}, chaining it to the existing one if\n      * an {@link Interceptor} is already set.\n      *\n      * @param interceptor the next {@link Interceptor} in a chain\n      */\n     public void addInterceptor(Interceptor interceptor)\n     {\n-        if (_interceptor == null)\n-            _interceptor = interceptor;\n+        Interceptor currentInterceptor = _contentProducer.getInterceptor();\n+        if (currentInterceptor == null)\n+            _contentProducer.setInterceptor(interceptor);\n         else\n-            _interceptor = new ChainedInterceptor(_interceptor, interceptor);\n-    }\n-\n-    @Override\n-    public int available()\n-    {\n-        int available = 0;\n-        boolean woken = false;\n-        synchronized (_inputQ)\n-        {\n-            if (_content == null)\n-                _content = _inputQ.poll();\n-            if (_content == null)\n-            {\n-                try\n-                {\n-                    produceContent();\n-                }\n-                catch (IOException e)\n-                {\n-                    woken = failed(e);\n-                }\n-                if (_content == null)\n-                    _content = _inputQ.poll();\n-            }\n-\n-            if (_content != null)\n-                available = _content.remaining();\n-        }\n-\n-        if (woken)\n-            wake();\n-        return available;\n-    }\n-\n-    protected void wake()\n-    {\n-        HttpChannel channel = _channelState.getHttpChannel();\n-        Executor executor = channel.getConnector().getServer().getThreadPool();\n-        executor.execute(channel);\n-    }\n-\n-    @Override\n-    public int read() throws IOException\n-    {\n-        int read = read(_oneByteBuffer, 0, 1);\n-        if (read == 0)\n-            throw new IllegalStateException(\"unready read=0\");\n-        return read < 0 ? -1 : _oneByteBuffer[0] & 0xFF;\n-    }\n-\n-    @Override\n-    public int read(byte[] b, int off, int len) throws IOException\n-    {\n-        boolean wake = false;\n-        int l;\n-        synchronized (_inputQ)\n-        {\n-            // Calculate minimum request rate for DOS protection\n-            long minRequestDataRate = _channelState.getHttpChannel().getHttpConfiguration().getMinRequestDataRate();\n-            if (minRequestDataRate > 0 && _firstByteTimeStamp != -1)\n-            {\n-                long period = System.nanoTime() - _firstByteTimeStamp;\n-                if (period > 0)\n-                {\n-                    long minimumData = minRequestDataRate * TimeUnit.NANOSECONDS.toMillis(period) / TimeUnit.SECONDS.toMillis(1);\n-                    if (_contentArrived < minimumData)\n-                    {\n-                        BadMessageException bad = new BadMessageException(HttpStatus.REQUEST_TIMEOUT_408,\n-                            String.format(\"Request content data rate < %d B/s\", minRequestDataRate));\n-                        if (_channelState.isResponseCommitted())\n-                            _channelState.getHttpChannel().abort(bad);\n-                        throw bad;\n-                    }\n-                }\n-            }\n-\n-            // Consume content looking for bytes to read\n-            while (true)\n-            {\n-                Content item = nextContent();\n-                if (item != null)\n-                {\n-                    l = get(item, b, off, len);\n-                    if (LOG.isDebugEnabled())\n-                        LOG.debug(\"{} read {} from {}\", this, l, item);\n-\n-                    // Consume any following poison pills\n-                    if (item.isEmpty())\n-                        nextInterceptedContent();\n-                    break;\n-                }\n-\n-                // No content, so should we block?\n-                if (!_state.blockForContent(this))\n-                {\n-                    // Not blocking, so what should we return?\n-                    l = _state.noContent();\n-\n-                    if (l < 0)\n-                        // If EOF do we need to wake for allDataRead callback?\n-                        wake = _channelState.onReadEof();\n-                    break;\n-                }\n-            }\n-        }\n-\n-        if (wake)\n-            wake();\n-        return l;\n+            _contentProducer.setInterceptor(new ChainedInterceptor(currentInterceptor, interceptor));\n     }\n \n     /**\n-     * Called when derived implementations should attempt to produce more Content and add it via {@link #addContent(Content)}. For protocols that are constantly\n-     * producing (eg HTTP2) this can be left as a noop;\n-     *\n-     * @throws IOException if unable to produce content\n+     * Called by channel when asynchronous IO needs to produce more content\n      */\n-    protected void produceContent() throws IOException\n+    public void asyncReadProduce()\n     {\n+        if (LOG.isDebugEnabled())\n+            LOG.debug(\"asyncReadProduce {}\", _contentProducer);\n+        produceRawContent();\n     }\n \n     /**\n-     * Called by channel when asynchronous IO needs to produce more content\n+     * Adds some content to this input stream.\n      *\n-     * @throws IOException if unable to produce content\n+     * @param content the content to add\n      */\n-    public void asyncReadProduce() throws IOException\n+    public void addContent(Content content)\n     {\n-        synchronized (_inputQ)\n+        if (LOG.isDebugEnabled())\n+            LOG.debug(\"addContent {} {}\", content, _contentProducer);\n+        if (_firstByteTimeStamp == Long.MIN_VALUE)\n         {\n-            produceContent();\n+            _firstByteTimeStamp = System.nanoTime();\n+            if (_firstByteTimeStamp == Long.MIN_VALUE)\n+                _firstByteTimeStamp++;\n         }\n+        _contentProducer.addContent(content);\n+        if (isAsync())\n+            _channelState.onContentAdded();\n     }\n \n-    /**\n-     * Get the next content from the inputQ, calling {@link #produceContent()} if need be. EOF is processed and state changed.\n-     *\n-     * @return the content or null if none available.\n-     * @throws IOException if retrieving the content fails\n-     */\n-    protected Content nextContent() throws IOException\n+    public boolean hasContent()\n     {\n-        Content content = nextNonSentinelContent();\n-        if (content == null && !isFinished())\n-        {\n-            produceContent();\n-            content = nextNonSentinelContent();\n-        }\n-        return content;\n+        return _contentProducer.hasRawContent();\n     }\n \n-    /**\n-     * Poll the inputQ for Content. Consumed buffers and {@link SentinelContent}s are removed and EOF state updated if need be.\n-     *\n-     * @return Content or null\n-     */\n-    protected Content nextNonSentinelContent()\n+    public void unblock()\n     {\n-        while (true)\n-        {\n-            // Get the next content (or EOF)\n-            Content content = nextInterceptedContent();\n-\n-            // If it is EOF, consume it here\n-            if (content instanceof SentinelContent)\n-            {\n-                // Consume the EOF content, either if it was original content\n-                // or if it was produced by interception\n-                consume(content);\n-                continue;\n-            }\n+        if (LOG.isDebugEnabled())\n+            LOG.debug(\"signalling blocked thread to wake up\");\n+        if (!isError() && !_eof.isEof() && _semaphore.availablePermits() > 0)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "743877ce7be889862c63f51350d61e5281f42a66"}, "originalPosition": 410}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTYwMTk2NA==", "bodyText": "Is this actually necessary or is it a safety net?", "url": "https://github.com/eclipse/jetty.project/pull/4556#discussion_r391601964", "createdAt": "2020-03-12T12:57:32Z", "author": {"login": "gregw"}, "path": "jetty-server/src/main/java/org/eclipse/jetty/server/HttpInput.java", "diffHunk": "@@ -190,633 +89,348 @@ public Interceptor getInterceptor()\n      */\n     public void setInterceptor(Interceptor interceptor)\n     {\n-        _interceptor = interceptor;\n+        _contentProducer.setInterceptor(interceptor);\n     }\n \n     /**\n-     * Set the {@link Interceptor}, using a {@link ChainedInterceptor} if\n+     * Set the {@link Interceptor}, chaining it to the existing one if\n      * an {@link Interceptor} is already set.\n      *\n      * @param interceptor the next {@link Interceptor} in a chain\n      */\n     public void addInterceptor(Interceptor interceptor)\n     {\n-        if (_interceptor == null)\n-            _interceptor = interceptor;\n+        Interceptor currentInterceptor = _contentProducer.getInterceptor();\n+        if (currentInterceptor == null)\n+            _contentProducer.setInterceptor(interceptor);\n         else\n-            _interceptor = new ChainedInterceptor(_interceptor, interceptor);\n-    }\n-\n-    @Override\n-    public int available()\n-    {\n-        int available = 0;\n-        boolean woken = false;\n-        synchronized (_inputQ)\n-        {\n-            if (_content == null)\n-                _content = _inputQ.poll();\n-            if (_content == null)\n-            {\n-                try\n-                {\n-                    produceContent();\n-                }\n-                catch (IOException e)\n-                {\n-                    woken = failed(e);\n-                }\n-                if (_content == null)\n-                    _content = _inputQ.poll();\n-            }\n-\n-            if (_content != null)\n-                available = _content.remaining();\n-        }\n-\n-        if (woken)\n-            wake();\n-        return available;\n-    }\n-\n-    protected void wake()\n-    {\n-        HttpChannel channel = _channelState.getHttpChannel();\n-        Executor executor = channel.getConnector().getServer().getThreadPool();\n-        executor.execute(channel);\n-    }\n-\n-    @Override\n-    public int read() throws IOException\n-    {\n-        int read = read(_oneByteBuffer, 0, 1);\n-        if (read == 0)\n-            throw new IllegalStateException(\"unready read=0\");\n-        return read < 0 ? -1 : _oneByteBuffer[0] & 0xFF;\n-    }\n-\n-    @Override\n-    public int read(byte[] b, int off, int len) throws IOException\n-    {\n-        boolean wake = false;\n-        int l;\n-        synchronized (_inputQ)\n-        {\n-            // Calculate minimum request rate for DOS protection\n-            long minRequestDataRate = _channelState.getHttpChannel().getHttpConfiguration().getMinRequestDataRate();\n-            if (minRequestDataRate > 0 && _firstByteTimeStamp != -1)\n-            {\n-                long period = System.nanoTime() - _firstByteTimeStamp;\n-                if (period > 0)\n-                {\n-                    long minimumData = minRequestDataRate * TimeUnit.NANOSECONDS.toMillis(period) / TimeUnit.SECONDS.toMillis(1);\n-                    if (_contentArrived < minimumData)\n-                    {\n-                        BadMessageException bad = new BadMessageException(HttpStatus.REQUEST_TIMEOUT_408,\n-                            String.format(\"Request content data rate < %d B/s\", minRequestDataRate));\n-                        if (_channelState.isResponseCommitted())\n-                            _channelState.getHttpChannel().abort(bad);\n-                        throw bad;\n-                    }\n-                }\n-            }\n-\n-            // Consume content looking for bytes to read\n-            while (true)\n-            {\n-                Content item = nextContent();\n-                if (item != null)\n-                {\n-                    l = get(item, b, off, len);\n-                    if (LOG.isDebugEnabled())\n-                        LOG.debug(\"{} read {} from {}\", this, l, item);\n-\n-                    // Consume any following poison pills\n-                    if (item.isEmpty())\n-                        nextInterceptedContent();\n-                    break;\n-                }\n-\n-                // No content, so should we block?\n-                if (!_state.blockForContent(this))\n-                {\n-                    // Not blocking, so what should we return?\n-                    l = _state.noContent();\n-\n-                    if (l < 0)\n-                        // If EOF do we need to wake for allDataRead callback?\n-                        wake = _channelState.onReadEof();\n-                    break;\n-                }\n-            }\n-        }\n-\n-        if (wake)\n-            wake();\n-        return l;\n+            _contentProducer.setInterceptor(new ChainedInterceptor(currentInterceptor, interceptor));\n     }\n \n     /**\n-     * Called when derived implementations should attempt to produce more Content and add it via {@link #addContent(Content)}. For protocols that are constantly\n-     * producing (eg HTTP2) this can be left as a noop;\n-     *\n-     * @throws IOException if unable to produce content\n+     * Called by channel when asynchronous IO needs to produce more content\n      */\n-    protected void produceContent() throws IOException\n+    public void asyncReadProduce()\n     {\n+        if (LOG.isDebugEnabled())\n+            LOG.debug(\"asyncReadProduce {}\", _contentProducer);\n+        produceRawContent();\n     }\n \n     /**\n-     * Called by channel when asynchronous IO needs to produce more content\n+     * Adds some content to this input stream.\n      *\n-     * @throws IOException if unable to produce content\n+     * @param content the content to add\n      */\n-    public void asyncReadProduce() throws IOException\n+    public void addContent(Content content)\n     {\n-        synchronized (_inputQ)\n+        if (LOG.isDebugEnabled())\n+            LOG.debug(\"addContent {} {}\", content, _contentProducer);\n+        if (_firstByteTimeStamp == Long.MIN_VALUE)\n         {\n-            produceContent();\n+            _firstByteTimeStamp = System.nanoTime();\n+            if (_firstByteTimeStamp == Long.MIN_VALUE)\n+                _firstByteTimeStamp++;\n         }\n+        _contentProducer.addContent(content);\n+        if (isAsync())\n+            _channelState.onContentAdded();\n     }\n \n-    /**\n-     * Get the next content from the inputQ, calling {@link #produceContent()} if need be. EOF is processed and state changed.\n-     *\n-     * @return the content or null if none available.\n-     * @throws IOException if retrieving the content fails\n-     */\n-    protected Content nextContent() throws IOException\n+    public boolean hasContent()\n     {\n-        Content content = nextNonSentinelContent();\n-        if (content == null && !isFinished())\n-        {\n-            produceContent();\n-            content = nextNonSentinelContent();\n-        }\n-        return content;\n+        return _contentProducer.hasRawContent();\n     }\n \n-    /**\n-     * Poll the inputQ for Content. Consumed buffers and {@link SentinelContent}s are removed and EOF state updated if need be.\n-     *\n-     * @return Content or null\n-     */\n-    protected Content nextNonSentinelContent()\n+    public void unblock()\n     {\n-        while (true)\n-        {\n-            // Get the next content (or EOF)\n-            Content content = nextInterceptedContent();\n-\n-            // If it is EOF, consume it here\n-            if (content instanceof SentinelContent)\n-            {\n-                // Consume the EOF content, either if it was original content\n-                // or if it was produced by interception\n-                consume(content);\n-                continue;\n-            }\n+        if (LOG.isDebugEnabled())\n+            LOG.debug(\"signalling blocked thread to wake up\");\n+        if (!isError() && !_eof.isEof() && _semaphore.availablePermits() > 0)\n+            throw new AssertionError();\n+        _semaphore.release();\n+    }\n \n-            return content;\n-        }\n+    public long getContentLength()\n+    {\n+        return _contentProducer.getRawContentArrived();\n     }\n \n     /**\n-     * Get the next readable from the inputQ, calling {@link #produceContent()} if need be. EOF is NOT processed and state is not changed.\n+     * This method should be called to signal that an EOF has been detected before all the expected content arrived.\n+     * <p>\n+     * Typically this will result in an EOFException being thrown from a subsequent read rather than a -1 return.\n      *\n-     * @return the content or EOF or null if none available.\n-     * @throws IOException if retrieving the content fails\n+     * @return true if content channel woken for read\n      */\n-    protected Content produceNextContext() throws IOException\n+    public boolean earlyEOF()\n     {\n-        Content content = nextInterceptedContent();\n-        if (content == null && !isFinished())\n-        {\n-            produceContent();\n-            content = nextInterceptedContent();\n-        }\n-        return content;\n+        if (LOG.isDebugEnabled())\n+            LOG.debug(\"received early EOF\");\n+        _eof = Eof.EARLY_EOF;\n+        if (isAsync())\n+            return _channelState.onContentAdded();\n+        unblock();\n+        return false;\n     }\n \n     /**\n-     * Poll the inputQ for Content or EOF. Consumed buffers and non EOF {@link SentinelContent}s are removed. EOF state is not updated.\n-     * Interception is done within this method.\n+     * This method should be called to signal that all the expected content arrived.\n      *\n-     * @return Content with remaining, a {@link SentinelContent},  or null\n+     * @return true if content channel woken for read\n      */\n-    protected Content nextInterceptedContent()\n+    public boolean eof()\n     {\n-        // If we have a chunk produced by interception\n-        if (_intercepted != null)\n-        {\n-            // Use it if it has any remaining content\n-            if (_intercepted.hasContent())\n-                return _intercepted;\n-\n-            // succeed the chunk\n-            _intercepted.succeeded();\n-            _intercepted = null;\n-        }\n-\n-        // If we don't have a Content under consideration, get\n-        // the next one off the input Q.\n-        if (_content == null)\n-            _content = _inputQ.poll();\n-\n-        // While we have content to consider.\n-        while (_content != null)\n-        {\n-            // Are we intercepting?\n-            if (_interceptor != null)\n-            {\n-                // Intercept the current content (may be called several\n-                // times for the same content\n-                _intercepted = _interceptor.readFrom(_content);\n-\n-                // If interception produced new content\n-                if (_intercepted != null && _intercepted != _content)\n-                {\n-                    // if it is not empty use it\n-                    if (_intercepted.hasContent())\n-                        return _intercepted;\n-                    _intercepted.succeeded();\n-                }\n-\n-                // intercepted content consumed\n-                _intercepted = null;\n-\n-                // fall through so that the unintercepted _content is\n-                // considered for any remaining content, for EOF and to\n-                // succeed it if it is entirely consumed.\n-            }\n-\n-            // If the content has content or is an EOF marker, use it\n-            if (_content.hasContent() || _content instanceof SentinelContent)\n-                return _content;\n-\n-            // The content is consumed, so get the next one.  Note that EOF\n-            // content is never consumed here, but in #pollContent\n-            _content.succeeded();\n-            _content = _inputQ.poll();\n-        }\n-\n-        return null;\n+        if (LOG.isDebugEnabled())\n+            LOG.debug(\"received EOF\");\n+        _eof = Eof.EOF;\n+        if (isAsync())\n+            return _channelState.onContentAdded();\n+        unblock();\n+        return false;\n     }\n \n-    private void consume(Content content)\n+    public boolean consumeAll()\n     {\n-        if (!isError() && content instanceof EofContent)\n-        {\n-            if (content == EARLY_EOF_CONTENT)\n-                _state = EARLY_EOF;\n-            else if (_listener == null)\n-                _state = EOF;\n-            else\n-                _state = AEOF;\n-        }\n+        if (LOG.isDebugEnabled())\n+            LOG.debug(\"consume all\");\n+        _contentProducer.consumeTransformedContent(this::failRawContent, new IOException(\"Unconsumed content\"));\n+        if (_eof.isEof())\n+            _eof = Eof.CONSUMED_EOF;\n+\n+        if (isFinished())\n+            return !isError();\n \n-        // Consume the content, either if it was original content\n-        // or if it was produced by interception\n-        content.succeeded();\n-        if (_content == content)\n-            _content = null;\n-        else if (_intercepted == content)\n-            _intercepted = null;\n+        _eof = Eof.EARLY_EOF;\n+        return false;\n     }\n \n-    /**\n-     * Copies the given content into the given byte buffer.\n-     *\n-     * @param content the content to copy from\n-     * @param buffer the buffer to copy into\n-     * @param offset the buffer offset to start copying from\n-     * @param length the space available in the buffer\n-     * @return the number of bytes actually copied\n-     */\n-    protected int get(Content content, byte[] buffer, int offset, int length)\n+    public boolean isError()\n     {\n-        int l = content.get(buffer, offset, length);\n-        _contentConsumed += l;\n-        return l;\n+        return _error != null;\n     }\n \n-    /**\n-     * Consumes the given content. Calls the content succeeded if all content consumed.\n-     *\n-     * @param content the content to consume\n-     * @param length the number of bytes to consume\n-     */\n-    protected void skip(Content content, int length)\n+    public boolean isAsync()\n     {\n-        int l = content.skip(length);\n-\n-        _contentConsumed += l;\n-        if (l > 0 && content.isEmpty())\n-            nextNonSentinelContent(); // hungry succeed\n+        return _readListener != null;\n     }\n \n-    /**\n-     * Blocks until some content or some end-of-file event arrives.\n-     *\n-     * @throws IOException if the wait is interrupted\n-     */\n-    protected void blockForContent() throws IOException\n+    public boolean onIdleTimeout(Throwable x)\n     {\n-        try\n-        {\n-            _waitingForContent = true;\n-            _channelState.getHttpChannel().onBlockWaitForContent();\n-\n-            boolean loop = false;\n-            long timeout = 0;\n-            while (true)\n-            {\n-                // This method is called from a loop, so we just\n-                // need to check the timeout before and after waiting.\n-                if (loop)\n-                    break;\n-\n-                if (LOG.isDebugEnabled())\n-                    LOG.debug(\"{} blocking for content timeout={}\", this, timeout);\n-                if (timeout > 0)\n-                    _inputQ.wait(timeout);\n-                else\n-                    _inputQ.wait();\n-\n-                loop = true;\n-            }\n-        }\n-        catch (Throwable x)\n+        boolean neverDispatched = _channelState.isIdle();\n+        boolean waitingForContent = _contentProducer.available(this::produceRawContent) == 0 && !_eof.isEof();\n+        if ((waitingForContent || neverDispatched) && !isError())\n         {\n-            _channelState.getHttpChannel().onBlockWaitForContentFailure(x);\n+            x.addSuppressed(new Throwable(\"HttpInput idle timeout\"));\n+            _error = x;\n+            if (isAsync())\n+                return _channelState.onContentAdded();\n+            unblock();\n         }\n+        return false;\n     }\n \n-    /**\n-     * Adds some content to this input stream.\n-     *\n-     * @param content the content to add\n-     * @return true if content channel woken for read\n-     */\n-    public boolean addContent(Content content)\n+    public boolean failed(Throwable x)\n     {\n-        synchronized (_inputQ)\n-        {\n-            _waitingForContent = false;\n-            if (_firstByteTimeStamp == -1)\n-                _firstByteTimeStamp = System.nanoTime();\n-\n-            if (isFinished())\n-            {\n-                Throwable failure = isError() ? _state.getError() : new EOFException(\"Content after EOF\");\n-                content.failed(failure);\n-                return false;\n-            }\n-            else\n-            {\n-                _contentArrived += content.remaining();\n-\n-                if (_content == null && _inputQ.isEmpty())\n-                    _content = content;\n-                else\n-                    _inputQ.offer(content);\n-\n-                if (LOG.isDebugEnabled())\n-                    LOG.debug(\"{} addContent {}\", this, content);\n+        if (LOG.isDebugEnabled())\n+            LOG.debug(\"failed \" + x);\n+        if (_error != null && _error != x)\n+            _error.addSuppressed(x);\n+        else\n+            _error = x;\n \n-                if (nextInterceptedContent() != null)\n-                    return wakeup();\n-                else\n-                    return false;\n-            }\n-        }\n+        if (isAsync())\n+            return _channelState.onContentAdded();\n+        unblock();\n+        return false;\n     }\n \n-    public boolean hasContent()\n-    {\n-        synchronized (_inputQ)\n-        {\n-            return _content != null || _inputQ.size() > 0;\n-        }\n-    }\n+    /* ServletInputStream */\n \n-    public void unblock()\n+    @Override\n+    public boolean isFinished()\n     {\n-        synchronized (_inputQ)\n-        {\n-            _inputQ.notify();\n-        }\n+        boolean finished = !_contentProducer.hasRawContent() && _eof.isConsumed();\n+        if (LOG.isDebugEnabled())\n+            LOG.debug(\"isFinished? {}\", finished);\n+        return finished;\n     }\n \n-    public long getContentConsumed()\n+    @Override\n+    public boolean isReady()\n     {\n-        synchronized (_inputQ)\n+        // calling _contentProducer.available() might change the _eof state, so the following test order matters\n+        if (_contentProducer.available(this::produceRawContent) > 0 || _eof.isEof())\n         {\n-            return _contentConsumed;\n+            if (LOG.isDebugEnabled())\n+                LOG.debug(\"isReady? true\");\n+            return true;\n         }\n+        if (LOG.isDebugEnabled())\n+            LOG.debug(\"isReady? false\");\n+        _channelState.onReadUnready();\n+        return false;\n     }\n \n-    /**\n-     * This method should be called to signal that an EOF has been detected before all the expected content arrived.\n-     * <p>\n-     * Typically this will result in an EOFException being thrown from a subsequent read rather than a -1 return.\n-     *\n-     * @return true if content channel woken for read\n-     */\n-    public boolean earlyEOF()\n-    {\n-        return addContent(EARLY_EOF_CONTENT);\n-    }\n-\n-    /**\n-     * This method should be called to signal that all the expected content arrived.\n-     *\n-     * @return true if content channel woken for read\n-     */\n-    public boolean eof()\n+    @Override\n+    public void setReadListener(ReadListener readListener)\n     {\n-        return addContent(EOF_CONTENT);\n-    }\n+        if (_readListener != null)\n+            throw new IllegalStateException(\"ReadListener already set\");\n+        _readListener = Objects.requireNonNull(readListener);\n \n-    public boolean consumeAll()\n-    {\n-        synchronized (_inputQ)\n+        if (LOG.isDebugEnabled())\n+            LOG.debug(\"setReadListener error=\" + _error + \" eof=\" + _eof + \" \" + _contentProducer);\n+        boolean woken;\n+        if (isError())\n         {\n-            try\n+            woken = _channelState.onReadReady();\n+        }\n+        else\n+        {\n+            if (_contentProducer.available(this::produceRawContent) > 0)\n             {\n-                while (true)\n-                {\n-                    Content item = nextContent();\n-                    if (item == null)\n-                        break; // Let's not bother blocking\n-\n-                    skip(item, item.remaining());\n-                }\n-                if (isFinished())\n-                    return !isError();\n-\n-                _state = EARLY_EOF;\n-                return false;\n+                woken = _channelState.onReadReady();\n+            }\n+            else if (_eof.isEof())\n+            {\n+                woken = _channelState.onReadEof();\n             }\n-            catch (Throwable e)\n+            else\n             {\n-                LOG.debug(e);\n-                _state = new ErrorState(e);\n-                return false;\n+                _channelState.onReadUnready();\n+                woken = false;\n             }\n         }\n-    }\n \n-    public boolean isError()\n-    {\n-        synchronized (_inputQ)\n-        {\n-            return _state instanceof ErrorState;\n-        }\n+        if (LOG.isDebugEnabled())\n+            LOG.debug(\"setReadListener woken=\" + woken);\n+        if (woken)\n+            scheduleReadListenerNotification();\n     }\n \n-    public boolean isAsync()\n+    private void scheduleReadListenerNotification()\n     {\n-        synchronized (_inputQ)\n-        {\n-            return _state == ASYNC;\n-        }\n+        HttpChannel channel = _channelState.getHttpChannel();\n+        channel.execute(channel);\n     }\n \n     @Override\n-    public boolean isFinished()\n+    public int read() throws IOException\n     {\n-        synchronized (_inputQ)\n-        {\n-            return _state instanceof EOFState;\n-        }\n+        int read = read(_oneByteBuffer, 0, 1);\n+        if (read == 0)\n+            throw new IOException(\"unready read=0\");\n+        return read < 0 ? -1 : _oneByteBuffer[0] & 0xFF;\n     }\n \n     @Override\n-    public boolean isReady()\n+    public int read(byte[] b, int off, int len) throws IOException\n     {\n-        try\n+        // Calculate minimum request rate for DOS protection\n+        long minRequestDataRate = _channelState.getHttpChannel().getHttpConfiguration().getMinRequestDataRate();\n+        if (minRequestDataRate > 0 && _firstByteTimeStamp != Long.MIN_VALUE)\n         {\n-            synchronized (_inputQ)\n+            long period = System.nanoTime() - _firstByteTimeStamp;\n+            if (period > 0)\n             {\n-                if (_listener == null)\n-                    return true;\n-                if (_state instanceof EOFState)\n-                    return true;\n-                if (_waitingForContent)\n-                    return false;\n-                if (produceNextContext() != null)\n-                    return true;\n-                _channelState.onReadUnready();\n-                _waitingForContent = true;\n+                long minimumData = minRequestDataRate * TimeUnit.NANOSECONDS.toMillis(period) / TimeUnit.SECONDS.toMillis(1);\n+                if (_contentProducer.getRawContentArrived() < minimumData)\n+                {\n+                    BadMessageException bad = new BadMessageException(HttpStatus.REQUEST_TIMEOUT_408,\n+                        String.format(\"Request content data rate < %d B/s\", minRequestDataRate));\n+                    if (_channelState.isResponseCommitted())\n+                        _channelState.getHttpChannel().abort(bad);\n+                    throw bad;\n+                }\n             }\n-            return false;\n         }\n-        catch (IOException e)\n-        {\n-            LOG.ignore(e);\n-            return true;\n-        }\n-    }\n \n-    @Override\n-    public void setReadListener(ReadListener readListener)\n-    {\n-        boolean woken = false;\n-        try\n+        while (true)\n         {\n-            synchronized (_inputQ)\n+            _semaphore.drainPermits();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "743877ce7be889862c63f51350d61e5281f42a66"}, "originalPosition": 893}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTYwNDA0MA==", "bodyText": "Does this still need the rawContentProducer passed in?", "url": "https://github.com/eclipse/jetty.project/pull/4556#discussion_r391604040", "createdAt": "2020-03-12T13:01:21Z", "author": {"login": "gregw"}, "path": "jetty-server/src/main/java/org/eclipse/jetty/server/HttpInput.java", "diffHunk": "@@ -825,314 +439,372 @@ private boolean wakeup()\n     @Override\n     public void run()\n     {\n-        final ReadListener listener;\n-        Throwable error;\n-        boolean aeof = false;\n-\n-        synchronized (_inputQ)\n-        {\n-            listener = _listener;\n-\n-            if (_state == EOF)\n-                return;\n-\n-            if (_state == AEOF)\n-            {\n-                _state = EOF;\n-                aeof = true;\n-            }\n-\n-            error = _state.getError();\n-\n-            if (!aeof && error == null)\n-            {\n-                Content content = nextInterceptedContent();\n-                if (content == null)\n-                    return;\n-\n-                // Consume a directly received EOF without first calling onDataAvailable\n-                // So -1 will never be read and only onAddDataRread or onError will be called\n-                if (content instanceof EofContent)\n-                {\n-                    consume(content);\n-                    if (_state == EARLY_EOF)\n-                        error = _state.getError();\n-                    else if (_state == AEOF)\n-                    {\n-                        aeof = true;\n-                        _state = EOF;\n-                    }\n-                }\n-            }\n-        }\n-\n-        try\n+        if (!_contentProducer.hasRawContent())\n         {\n-            if (error != null)\n+            if (LOG.isDebugEnabled())\n+                LOG.debug(\"running has no raw content; error: {}, EOF = {}\", _error, _eof);\n+            if (_error != null || _eof.isEarly())\n             {\n                 // TODO is this necessary to add here?\n                 _channelState.getHttpChannel().getResponse().getHttpFields().add(HttpConnection.CONNECTION_CLOSE);\n-                listener.onError(error);\n-            }\n-            else if (aeof)\n-            {\n-                listener.onAllDataRead();\n+                if (_error != null)\n+                    _readListener.onError(_error);\n+                else\n+                    _readListener.onError(new EofException(\"Early EOF\"));\n             }\n-            else\n+            else if (_eof.isEof())\n             {\n-                listener.onDataAvailable();\n-                // If -1 was read, then HttpChannelState#onEOF will have been called and a subsequent\n-                // unhandle will call run again so onAllDataRead() can be called.\n+                try\n+                {\n+                    _readListener.onAllDataRead();\n+                }\n+                catch (Throwable x)\n+                {\n+                    if (LOG.isDebugEnabled())\n+                        LOG.debug(\"running failed onAllDataRead\", x);\n+                    _readListener.onError(x);\n+                }\n             }\n+            // else: !hasContent() && !error && !EOF -> no-op\n         }\n-        catch (Throwable e)\n+        else\n         {\n-            LOG.warn(e.toString());\n-            LOG.debug(e);\n+            if (LOG.isDebugEnabled())\n+                LOG.debug(\"running has raw content\");\n             try\n             {\n-                if (aeof || error == null)\n-                {\n-                    _channelState.getHttpChannel().getResponse().getHttpFields().add(HttpConnection.CONNECTION_CLOSE);\n-                    listener.onError(e);\n-                }\n+                _readListener.onDataAvailable();\n             }\n-            catch (Throwable e2)\n+            catch (Throwable x)\n             {\n-                LOG.warn(e2.toString());\n-                LOG.debug(e2);\n-                throw new RuntimeIOException(e2);\n+                if (LOG.isDebugEnabled())\n+                    LOG.debug(\"running failed onDataAvailable\", x);\n+                _readListener.onError(x);\n             }\n         }\n     }\n \n-    @Override\n-    public String toString()\n+    private void produceRawContent()\n     {\n-        State state;\n-        long consumed;\n-        int q;\n-        Content content;\n-        synchronized (_inputQ)\n-        {\n-            state = _state;\n-            consumed = _contentConsumed;\n-            q = _inputQ.size();\n-            content = _inputQ.peekFirst();\n-        }\n-        return String.format(\"%s@%x[c=%d,q=%d,[0]=%s,s=%s]\",\n-            getClass().getSimpleName(),\n-            hashCode(),\n-            consumed,\n-            q,\n-            content,\n-            state);\n+        if (LOG.isDebugEnabled())\n+            LOG.debug(\"produceRawContent {}\", _contentProducer);\n+        _channelState.getHttpChannel().produceContent();\n     }\n \n-    /**\n-     * A Sentinel Content, which has zero length content but\n-     * indicates some other event in the input stream (eg EOF)\n-     */\n-    public static class SentinelContent extends Content\n+    private void failRawContent(Throwable failure)\n+    {\n+        if (LOG.isDebugEnabled())\n+            LOG.debug(\"failRawContent {} - \" + failure, _contentProducer);\n+        _channelState.getHttpChannel().failContent(failure);\n+    }\n+\n+    private enum Eof\n     {\n-        private final String _name;\n+        NOT_YET(false, false, false),\n+        EOF(true, false, false),\n+        CONSUMED_EOF(true, true, false),\n+        EARLY_EOF(true, false, true),\n+        ;\n \n-        public SentinelContent(String name)\n+        private final boolean _eof;\n+        private final boolean _consumed;\n+        private final boolean _early;\n+\n+        Eof(boolean eof, boolean consumed, boolean early)\n         {\n-            super(BufferUtil.EMPTY_BUFFER);\n-            _name = name;\n+            _eof = eof;\n+            _consumed = consumed;\n+            _early = early;\n         }\n \n-        @Override\n-        public String toString()\n+        boolean isEof()\n         {\n-            return _name;\n+            return _eof;\n         }\n-    }\n \n-    public static class EofContent extends SentinelContent\n-    {\n-        EofContent(String name)\n+        boolean isConsumed()\n+        {\n+            return _consumed;\n+        }\n+\n+        boolean isEarly()\n         {\n-            super(name);\n+            return _early;\n         }\n     }\n \n-    public static class Content implements Callback\n+    private static class ContentProducer\n     {\n-        protected final ByteBuffer _content;\n+        // Note: _rawContent can never be null for as long as _transformedContent is not null.\n+        private Content _rawContent;\n+        private Content _transformedContent;\n+        private long _rawContentArrived;\n+        private Interceptor _interceptor;\n+        private Throwable _consumeFailure;\n \n-        public Content(ByteBuffer content)\n+        void recycle()\n         {\n-            _content = content;\n+            if (LOG.isDebugEnabled())\n+                LOG.debug(\"recycle {}\", this);\n+            if (_transformedContent == _rawContent)\n+                _transformedContent = null;\n+            if (_transformedContent != null && !_transformedContent.isEmpty())\n+                _transformedContent.failed(null);\n+            _transformedContent = null;\n+            if (_rawContent != null && !_rawContent.isEmpty())\n+                _rawContent.failed(null);\n+            _rawContent = null;\n+            _rawContentArrived = 0L;\n+            if (_interceptor instanceof Destroyable)\n+                ((Destroyable)_interceptor).destroy();\n+            _interceptor = null;\n+            _consumeFailure = null;\n         }\n \n-        public ByteBuffer getByteBuffer()\n+        long getRawContentArrived()\n         {\n-            return _content;\n+            return _rawContentArrived;\n         }\n \n-        @Override\n-        public InvocationType getInvocationType()\n+        boolean hasRawContent()\n         {\n-            return InvocationType.NON_BLOCKING;\n+            return _rawContent != null;\n         }\n \n-        public int get(byte[] buffer, int offset, int length)\n+        Interceptor getInterceptor()\n         {\n-            length = Math.min(_content.remaining(), length);\n-            _content.get(buffer, offset, length);\n-            return length;\n+            return _interceptor;\n         }\n \n-        public int skip(int length)\n+        void setInterceptor(Interceptor interceptor)\n         {\n-            length = Math.min(_content.remaining(), length);\n-            _content.position(_content.position() + length);\n-            return length;\n+            this._interceptor = interceptor;\n         }\n \n-        public boolean hasContent()\n+        void addContent(Content content)\n         {\n-            return _content.hasRemaining();\n-        }\n+            if (LOG.isDebugEnabled())\n+                LOG.debug(\"{} addContent {}\", this, content);\n+            if (content == null)\n+                throw new AssertionError(\"Cannot add null content\");\n+            if (_consumeFailure != null)\n+            {\n+                content.failed(_consumeFailure);\n+                return;\n+            }\n+            if (_rawContent != null)\n+                throw new AssertionError(\"Cannot add new content while current one hasn't been processed\");\n \n-        public int remaining()\n-        {\n-            return _content.remaining();\n+            _rawContent = content;\n+            _rawContentArrived += content.remaining();\n         }\n \n-        public boolean isEmpty()\n+        void consumeTransformedContent(Consumer<Throwable> failRawContent, Throwable failure)\n         {\n-            return !_content.hasRemaining();\n+            if (LOG.isDebugEnabled())\n+                LOG.debug(\"{} consumeTransformedContent\", this);\n+            // start by depleting the current _transformedContent\n+            if (_transformedContent != null)\n+            {\n+                _transformedContent.skip(_transformedContent.remaining());\n+                if (_transformedContent != _rawContent)\n+                    _transformedContent.succeeded();\n+                _transformedContent = null;\n+            }\n+\n+            // don't bother transforming content, directly deplete the raw one\n+            if (_rawContent != null)\n+            {\n+                _rawContent.skip(_rawContent.remaining());\n+                _rawContent.succeeded();\n+                _rawContent = null;\n+            }\n+\n+            // fail whatever other content the producer may have\n+            _consumeFailure = failure;\n+            failRawContent.accept(failure);\n         }\n \n-        @Override\n-        public String toString()\n+        int available(Runnable rawContentProducer)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "743877ce7be889862c63f51350d61e5281f42a66"}, "originalPosition": 1370}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTYwNDM2OQ==", "bodyText": "Does this still need the rawContentProducer passed in?", "url": "https://github.com/eclipse/jetty.project/pull/4556#discussion_r391604369", "createdAt": "2020-03-12T13:02:00Z", "author": {"login": "gregw"}, "path": "jetty-server/src/main/java/org/eclipse/jetty/server/HttpInput.java", "diffHunk": "@@ -825,314 +439,372 @@ private boolean wakeup()\n     @Override\n     public void run()\n     {\n-        final ReadListener listener;\n-        Throwable error;\n-        boolean aeof = false;\n-\n-        synchronized (_inputQ)\n-        {\n-            listener = _listener;\n-\n-            if (_state == EOF)\n-                return;\n-\n-            if (_state == AEOF)\n-            {\n-                _state = EOF;\n-                aeof = true;\n-            }\n-\n-            error = _state.getError();\n-\n-            if (!aeof && error == null)\n-            {\n-                Content content = nextInterceptedContent();\n-                if (content == null)\n-                    return;\n-\n-                // Consume a directly received EOF without first calling onDataAvailable\n-                // So -1 will never be read and only onAddDataRread or onError will be called\n-                if (content instanceof EofContent)\n-                {\n-                    consume(content);\n-                    if (_state == EARLY_EOF)\n-                        error = _state.getError();\n-                    else if (_state == AEOF)\n-                    {\n-                        aeof = true;\n-                        _state = EOF;\n-                    }\n-                }\n-            }\n-        }\n-\n-        try\n+        if (!_contentProducer.hasRawContent())\n         {\n-            if (error != null)\n+            if (LOG.isDebugEnabled())\n+                LOG.debug(\"running has no raw content; error: {}, EOF = {}\", _error, _eof);\n+            if (_error != null || _eof.isEarly())\n             {\n                 // TODO is this necessary to add here?\n                 _channelState.getHttpChannel().getResponse().getHttpFields().add(HttpConnection.CONNECTION_CLOSE);\n-                listener.onError(error);\n-            }\n-            else if (aeof)\n-            {\n-                listener.onAllDataRead();\n+                if (_error != null)\n+                    _readListener.onError(_error);\n+                else\n+                    _readListener.onError(new EofException(\"Early EOF\"));\n             }\n-            else\n+            else if (_eof.isEof())\n             {\n-                listener.onDataAvailable();\n-                // If -1 was read, then HttpChannelState#onEOF will have been called and a subsequent\n-                // unhandle will call run again so onAllDataRead() can be called.\n+                try\n+                {\n+                    _readListener.onAllDataRead();\n+                }\n+                catch (Throwable x)\n+                {\n+                    if (LOG.isDebugEnabled())\n+                        LOG.debug(\"running failed onAllDataRead\", x);\n+                    _readListener.onError(x);\n+                }\n             }\n+            // else: !hasContent() && !error && !EOF -> no-op\n         }\n-        catch (Throwable e)\n+        else\n         {\n-            LOG.warn(e.toString());\n-            LOG.debug(e);\n+            if (LOG.isDebugEnabled())\n+                LOG.debug(\"running has raw content\");\n             try\n             {\n-                if (aeof || error == null)\n-                {\n-                    _channelState.getHttpChannel().getResponse().getHttpFields().add(HttpConnection.CONNECTION_CLOSE);\n-                    listener.onError(e);\n-                }\n+                _readListener.onDataAvailable();\n             }\n-            catch (Throwable e2)\n+            catch (Throwable x)\n             {\n-                LOG.warn(e2.toString());\n-                LOG.debug(e2);\n-                throw new RuntimeIOException(e2);\n+                if (LOG.isDebugEnabled())\n+                    LOG.debug(\"running failed onDataAvailable\", x);\n+                _readListener.onError(x);\n             }\n         }\n     }\n \n-    @Override\n-    public String toString()\n+    private void produceRawContent()\n     {\n-        State state;\n-        long consumed;\n-        int q;\n-        Content content;\n-        synchronized (_inputQ)\n-        {\n-            state = _state;\n-            consumed = _contentConsumed;\n-            q = _inputQ.size();\n-            content = _inputQ.peekFirst();\n-        }\n-        return String.format(\"%s@%x[c=%d,q=%d,[0]=%s,s=%s]\",\n-            getClass().getSimpleName(),\n-            hashCode(),\n-            consumed,\n-            q,\n-            content,\n-            state);\n+        if (LOG.isDebugEnabled())\n+            LOG.debug(\"produceRawContent {}\", _contentProducer);\n+        _channelState.getHttpChannel().produceContent();\n     }\n \n-    /**\n-     * A Sentinel Content, which has zero length content but\n-     * indicates some other event in the input stream (eg EOF)\n-     */\n-    public static class SentinelContent extends Content\n+    private void failRawContent(Throwable failure)\n+    {\n+        if (LOG.isDebugEnabled())\n+            LOG.debug(\"failRawContent {} - \" + failure, _contentProducer);\n+        _channelState.getHttpChannel().failContent(failure);\n+    }\n+\n+    private enum Eof\n     {\n-        private final String _name;\n+        NOT_YET(false, false, false),\n+        EOF(true, false, false),\n+        CONSUMED_EOF(true, true, false),\n+        EARLY_EOF(true, false, true),\n+        ;\n \n-        public SentinelContent(String name)\n+        private final boolean _eof;\n+        private final boolean _consumed;\n+        private final boolean _early;\n+\n+        Eof(boolean eof, boolean consumed, boolean early)\n         {\n-            super(BufferUtil.EMPTY_BUFFER);\n-            _name = name;\n+            _eof = eof;\n+            _consumed = consumed;\n+            _early = early;\n         }\n \n-        @Override\n-        public String toString()\n+        boolean isEof()\n         {\n-            return _name;\n+            return _eof;\n         }\n-    }\n \n-    public static class EofContent extends SentinelContent\n-    {\n-        EofContent(String name)\n+        boolean isConsumed()\n+        {\n+            return _consumed;\n+        }\n+\n+        boolean isEarly()\n         {\n-            super(name);\n+            return _early;\n         }\n     }\n \n-    public static class Content implements Callback\n+    private static class ContentProducer\n     {\n-        protected final ByteBuffer _content;\n+        // Note: _rawContent can never be null for as long as _transformedContent is not null.\n+        private Content _rawContent;\n+        private Content _transformedContent;\n+        private long _rawContentArrived;\n+        private Interceptor _interceptor;\n+        private Throwable _consumeFailure;\n \n-        public Content(ByteBuffer content)\n+        void recycle()\n         {\n-            _content = content;\n+            if (LOG.isDebugEnabled())\n+                LOG.debug(\"recycle {}\", this);\n+            if (_transformedContent == _rawContent)\n+                _transformedContent = null;\n+            if (_transformedContent != null && !_transformedContent.isEmpty())\n+                _transformedContent.failed(null);\n+            _transformedContent = null;\n+            if (_rawContent != null && !_rawContent.isEmpty())\n+                _rawContent.failed(null);\n+            _rawContent = null;\n+            _rawContentArrived = 0L;\n+            if (_interceptor instanceof Destroyable)\n+                ((Destroyable)_interceptor).destroy();\n+            _interceptor = null;\n+            _consumeFailure = null;\n         }\n \n-        public ByteBuffer getByteBuffer()\n+        long getRawContentArrived()\n         {\n-            return _content;\n+            return _rawContentArrived;\n         }\n \n-        @Override\n-        public InvocationType getInvocationType()\n+        boolean hasRawContent()\n         {\n-            return InvocationType.NON_BLOCKING;\n+            return _rawContent != null;\n         }\n \n-        public int get(byte[] buffer, int offset, int length)\n+        Interceptor getInterceptor()\n         {\n-            length = Math.min(_content.remaining(), length);\n-            _content.get(buffer, offset, length);\n-            return length;\n+            return _interceptor;\n         }\n \n-        public int skip(int length)\n+        void setInterceptor(Interceptor interceptor)\n         {\n-            length = Math.min(_content.remaining(), length);\n-            _content.position(_content.position() + length);\n-            return length;\n+            this._interceptor = interceptor;\n         }\n \n-        public boolean hasContent()\n+        void addContent(Content content)\n         {\n-            return _content.hasRemaining();\n-        }\n+            if (LOG.isDebugEnabled())\n+                LOG.debug(\"{} addContent {}\", this, content);\n+            if (content == null)\n+                throw new AssertionError(\"Cannot add null content\");\n+            if (_consumeFailure != null)\n+            {\n+                content.failed(_consumeFailure);\n+                return;\n+            }\n+            if (_rawContent != null)\n+                throw new AssertionError(\"Cannot add new content while current one hasn't been processed\");\n \n-        public int remaining()\n-        {\n-            return _content.remaining();\n+            _rawContent = content;\n+            _rawContentArrived += content.remaining();\n         }\n \n-        public boolean isEmpty()\n+        void consumeTransformedContent(Consumer<Throwable> failRawContent, Throwable failure)\n         {\n-            return !_content.hasRemaining();\n+            if (LOG.isDebugEnabled())\n+                LOG.debug(\"{} consumeTransformedContent\", this);\n+            // start by depleting the current _transformedContent\n+            if (_transformedContent != null)\n+            {\n+                _transformedContent.skip(_transformedContent.remaining());\n+                if (_transformedContent != _rawContent)\n+                    _transformedContent.succeeded();\n+                _transformedContent = null;\n+            }\n+\n+            // don't bother transforming content, directly deplete the raw one\n+            if (_rawContent != null)\n+            {\n+                _rawContent.skip(_rawContent.remaining());\n+                _rawContent.succeeded();\n+                _rawContent = null;\n+            }\n+\n+            // fail whatever other content the producer may have\n+            _consumeFailure = failure;\n+            failRawContent.accept(failure);\n         }\n \n-        @Override\n-        public String toString()\n+        int available(Runnable rawContentProducer)\n         {\n-            return String.format(\"Content@%x{%s}\", hashCode(), BufferUtil.toDetailString(_content));\n+            Content content = nextNonEmptyContent(rawContentProducer);\n+            return content == null ? 0 : content.remaining();\n         }\n-    }\n \n-    protected abstract static class State\n-    {\n-        public boolean blockForContent(HttpInput in) throws IOException\n+        int read(Runnable rawContentProducer, byte[] b, int off, int len)\n         {\n-            return false;\n+            if (LOG.isDebugEnabled())\n+                LOG.debug(\"{} read\", this);\n+            Content content = nextNonEmptyContent(rawContentProducer);\n+            return content == null ? 0 : content.get(b, off, len);\n         }\n \n-        public int noContent() throws IOException\n+        private Content nextNonEmptyContent(Runnable rawContentProducer)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "743877ce7be889862c63f51350d61e5281f42a66"}, "originalPosition": 1391}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzczNTQyNzQ1", "url": "https://github.com/eclipse/jetty.project/pull/4556#pullrequestreview-373542745", "createdAt": "2020-03-12T13:14:43Z", "commit": {"oid": "743877ce7be889862c63f51350d61e5281f42a66"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMlQxMzoxNDo0NFrOF1eEGQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMlQxMzoxNDo0NFrOF1eEGQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTYxMTQxNw==", "bodyText": "This assignment needs to be done before the scheduleReadListenerNotification to avoid a race.", "url": "https://github.com/eclipse/jetty.project/pull/4556#discussion_r391611417", "createdAt": "2020-03-12T13:14:44Z", "author": {"login": "gregw"}, "path": "jetty-server/src/main/java/org/eclipse/jetty/server/HttpInput.java", "diffHunk": "@@ -190,633 +89,348 @@ public Interceptor getInterceptor()\n      */\n     public void setInterceptor(Interceptor interceptor)\n     {\n-        _interceptor = interceptor;\n+        _contentProducer.setInterceptor(interceptor);\n     }\n \n     /**\n-     * Set the {@link Interceptor}, using a {@link ChainedInterceptor} if\n+     * Set the {@link Interceptor}, chaining it to the existing one if\n      * an {@link Interceptor} is already set.\n      *\n      * @param interceptor the next {@link Interceptor} in a chain\n      */\n     public void addInterceptor(Interceptor interceptor)\n     {\n-        if (_interceptor == null)\n-            _interceptor = interceptor;\n+        Interceptor currentInterceptor = _contentProducer.getInterceptor();\n+        if (currentInterceptor == null)\n+            _contentProducer.setInterceptor(interceptor);\n         else\n-            _interceptor = new ChainedInterceptor(_interceptor, interceptor);\n-    }\n-\n-    @Override\n-    public int available()\n-    {\n-        int available = 0;\n-        boolean woken = false;\n-        synchronized (_inputQ)\n-        {\n-            if (_content == null)\n-                _content = _inputQ.poll();\n-            if (_content == null)\n-            {\n-                try\n-                {\n-                    produceContent();\n-                }\n-                catch (IOException e)\n-                {\n-                    woken = failed(e);\n-                }\n-                if (_content == null)\n-                    _content = _inputQ.poll();\n-            }\n-\n-            if (_content != null)\n-                available = _content.remaining();\n-        }\n-\n-        if (woken)\n-            wake();\n-        return available;\n-    }\n-\n-    protected void wake()\n-    {\n-        HttpChannel channel = _channelState.getHttpChannel();\n-        Executor executor = channel.getConnector().getServer().getThreadPool();\n-        executor.execute(channel);\n-    }\n-\n-    @Override\n-    public int read() throws IOException\n-    {\n-        int read = read(_oneByteBuffer, 0, 1);\n-        if (read == 0)\n-            throw new IllegalStateException(\"unready read=0\");\n-        return read < 0 ? -1 : _oneByteBuffer[0] & 0xFF;\n-    }\n-\n-    @Override\n-    public int read(byte[] b, int off, int len) throws IOException\n-    {\n-        boolean wake = false;\n-        int l;\n-        synchronized (_inputQ)\n-        {\n-            // Calculate minimum request rate for DOS protection\n-            long minRequestDataRate = _channelState.getHttpChannel().getHttpConfiguration().getMinRequestDataRate();\n-            if (minRequestDataRate > 0 && _firstByteTimeStamp != -1)\n-            {\n-                long period = System.nanoTime() - _firstByteTimeStamp;\n-                if (period > 0)\n-                {\n-                    long minimumData = minRequestDataRate * TimeUnit.NANOSECONDS.toMillis(period) / TimeUnit.SECONDS.toMillis(1);\n-                    if (_contentArrived < minimumData)\n-                    {\n-                        BadMessageException bad = new BadMessageException(HttpStatus.REQUEST_TIMEOUT_408,\n-                            String.format(\"Request content data rate < %d B/s\", minRequestDataRate));\n-                        if (_channelState.isResponseCommitted())\n-                            _channelState.getHttpChannel().abort(bad);\n-                        throw bad;\n-                    }\n-                }\n-            }\n-\n-            // Consume content looking for bytes to read\n-            while (true)\n-            {\n-                Content item = nextContent();\n-                if (item != null)\n-                {\n-                    l = get(item, b, off, len);\n-                    if (LOG.isDebugEnabled())\n-                        LOG.debug(\"{} read {} from {}\", this, l, item);\n-\n-                    // Consume any following poison pills\n-                    if (item.isEmpty())\n-                        nextInterceptedContent();\n-                    break;\n-                }\n-\n-                // No content, so should we block?\n-                if (!_state.blockForContent(this))\n-                {\n-                    // Not blocking, so what should we return?\n-                    l = _state.noContent();\n-\n-                    if (l < 0)\n-                        // If EOF do we need to wake for allDataRead callback?\n-                        wake = _channelState.onReadEof();\n-                    break;\n-                }\n-            }\n-        }\n-\n-        if (wake)\n-            wake();\n-        return l;\n+            _contentProducer.setInterceptor(new ChainedInterceptor(currentInterceptor, interceptor));\n     }\n \n     /**\n-     * Called when derived implementations should attempt to produce more Content and add it via {@link #addContent(Content)}. For protocols that are constantly\n-     * producing (eg HTTP2) this can be left as a noop;\n-     *\n-     * @throws IOException if unable to produce content\n+     * Called by channel when asynchronous IO needs to produce more content\n      */\n-    protected void produceContent() throws IOException\n+    public void asyncReadProduce()\n     {\n+        if (LOG.isDebugEnabled())\n+            LOG.debug(\"asyncReadProduce {}\", _contentProducer);\n+        produceRawContent();\n     }\n \n     /**\n-     * Called by channel when asynchronous IO needs to produce more content\n+     * Adds some content to this input stream.\n      *\n-     * @throws IOException if unable to produce content\n+     * @param content the content to add\n      */\n-    public void asyncReadProduce() throws IOException\n+    public void addContent(Content content)\n     {\n-        synchronized (_inputQ)\n+        if (LOG.isDebugEnabled())\n+            LOG.debug(\"addContent {} {}\", content, _contentProducer);\n+        if (_firstByteTimeStamp == Long.MIN_VALUE)\n         {\n-            produceContent();\n+            _firstByteTimeStamp = System.nanoTime();\n+            if (_firstByteTimeStamp == Long.MIN_VALUE)\n+                _firstByteTimeStamp++;\n         }\n+        _contentProducer.addContent(content);\n+        if (isAsync())\n+            _channelState.onContentAdded();\n     }\n \n-    /**\n-     * Get the next content from the inputQ, calling {@link #produceContent()} if need be. EOF is processed and state changed.\n-     *\n-     * @return the content or null if none available.\n-     * @throws IOException if retrieving the content fails\n-     */\n-    protected Content nextContent() throws IOException\n+    public boolean hasContent()\n     {\n-        Content content = nextNonSentinelContent();\n-        if (content == null && !isFinished())\n-        {\n-            produceContent();\n-            content = nextNonSentinelContent();\n-        }\n-        return content;\n+        return _contentProducer.hasRawContent();\n     }\n \n-    /**\n-     * Poll the inputQ for Content. Consumed buffers and {@link SentinelContent}s are removed and EOF state updated if need be.\n-     *\n-     * @return Content or null\n-     */\n-    protected Content nextNonSentinelContent()\n+    public void unblock()\n     {\n-        while (true)\n-        {\n-            // Get the next content (or EOF)\n-            Content content = nextInterceptedContent();\n-\n-            // If it is EOF, consume it here\n-            if (content instanceof SentinelContent)\n-            {\n-                // Consume the EOF content, either if it was original content\n-                // or if it was produced by interception\n-                consume(content);\n-                continue;\n-            }\n+        if (LOG.isDebugEnabled())\n+            LOG.debug(\"signalling blocked thread to wake up\");\n+        if (!isError() && !_eof.isEof() && _semaphore.availablePermits() > 0)\n+            throw new AssertionError();\n+        _semaphore.release();\n+    }\n \n-            return content;\n-        }\n+    public long getContentLength()\n+    {\n+        return _contentProducer.getRawContentArrived();\n     }\n \n     /**\n-     * Get the next readable from the inputQ, calling {@link #produceContent()} if need be. EOF is NOT processed and state is not changed.\n+     * This method should be called to signal that an EOF has been detected before all the expected content arrived.\n+     * <p>\n+     * Typically this will result in an EOFException being thrown from a subsequent read rather than a -1 return.\n      *\n-     * @return the content or EOF or null if none available.\n-     * @throws IOException if retrieving the content fails\n+     * @return true if content channel woken for read\n      */\n-    protected Content produceNextContext() throws IOException\n+    public boolean earlyEOF()\n     {\n-        Content content = nextInterceptedContent();\n-        if (content == null && !isFinished())\n-        {\n-            produceContent();\n-            content = nextInterceptedContent();\n-        }\n-        return content;\n+        if (LOG.isDebugEnabled())\n+            LOG.debug(\"received early EOF\");\n+        _eof = Eof.EARLY_EOF;\n+        if (isAsync())\n+            return _channelState.onContentAdded();\n+        unblock();\n+        return false;\n     }\n \n     /**\n-     * Poll the inputQ for Content or EOF. Consumed buffers and non EOF {@link SentinelContent}s are removed. EOF state is not updated.\n-     * Interception is done within this method.\n+     * This method should be called to signal that all the expected content arrived.\n      *\n-     * @return Content with remaining, a {@link SentinelContent},  or null\n+     * @return true if content channel woken for read\n      */\n-    protected Content nextInterceptedContent()\n+    public boolean eof()\n     {\n-        // If we have a chunk produced by interception\n-        if (_intercepted != null)\n-        {\n-            // Use it if it has any remaining content\n-            if (_intercepted.hasContent())\n-                return _intercepted;\n-\n-            // succeed the chunk\n-            _intercepted.succeeded();\n-            _intercepted = null;\n-        }\n-\n-        // If we don't have a Content under consideration, get\n-        // the next one off the input Q.\n-        if (_content == null)\n-            _content = _inputQ.poll();\n-\n-        // While we have content to consider.\n-        while (_content != null)\n-        {\n-            // Are we intercepting?\n-            if (_interceptor != null)\n-            {\n-                // Intercept the current content (may be called several\n-                // times for the same content\n-                _intercepted = _interceptor.readFrom(_content);\n-\n-                // If interception produced new content\n-                if (_intercepted != null && _intercepted != _content)\n-                {\n-                    // if it is not empty use it\n-                    if (_intercepted.hasContent())\n-                        return _intercepted;\n-                    _intercepted.succeeded();\n-                }\n-\n-                // intercepted content consumed\n-                _intercepted = null;\n-\n-                // fall through so that the unintercepted _content is\n-                // considered for any remaining content, for EOF and to\n-                // succeed it if it is entirely consumed.\n-            }\n-\n-            // If the content has content or is an EOF marker, use it\n-            if (_content.hasContent() || _content instanceof SentinelContent)\n-                return _content;\n-\n-            // The content is consumed, so get the next one.  Note that EOF\n-            // content is never consumed here, but in #pollContent\n-            _content.succeeded();\n-            _content = _inputQ.poll();\n-        }\n-\n-        return null;\n+        if (LOG.isDebugEnabled())\n+            LOG.debug(\"received EOF\");\n+        _eof = Eof.EOF;\n+        if (isAsync())\n+            return _channelState.onContentAdded();\n+        unblock();\n+        return false;\n     }\n \n-    private void consume(Content content)\n+    public boolean consumeAll()\n     {\n-        if (!isError() && content instanceof EofContent)\n-        {\n-            if (content == EARLY_EOF_CONTENT)\n-                _state = EARLY_EOF;\n-            else if (_listener == null)\n-                _state = EOF;\n-            else\n-                _state = AEOF;\n-        }\n+        if (LOG.isDebugEnabled())\n+            LOG.debug(\"consume all\");\n+        _contentProducer.consumeTransformedContent(this::failRawContent, new IOException(\"Unconsumed content\"));\n+        if (_eof.isEof())\n+            _eof = Eof.CONSUMED_EOF;\n+\n+        if (isFinished())\n+            return !isError();\n \n-        // Consume the content, either if it was original content\n-        // or if it was produced by interception\n-        content.succeeded();\n-        if (_content == content)\n-            _content = null;\n-        else if (_intercepted == content)\n-            _intercepted = null;\n+        _eof = Eof.EARLY_EOF;\n+        return false;\n     }\n \n-    /**\n-     * Copies the given content into the given byte buffer.\n-     *\n-     * @param content the content to copy from\n-     * @param buffer the buffer to copy into\n-     * @param offset the buffer offset to start copying from\n-     * @param length the space available in the buffer\n-     * @return the number of bytes actually copied\n-     */\n-    protected int get(Content content, byte[] buffer, int offset, int length)\n+    public boolean isError()\n     {\n-        int l = content.get(buffer, offset, length);\n-        _contentConsumed += l;\n-        return l;\n+        return _error != null;\n     }\n \n-    /**\n-     * Consumes the given content. Calls the content succeeded if all content consumed.\n-     *\n-     * @param content the content to consume\n-     * @param length the number of bytes to consume\n-     */\n-    protected void skip(Content content, int length)\n+    public boolean isAsync()\n     {\n-        int l = content.skip(length);\n-\n-        _contentConsumed += l;\n-        if (l > 0 && content.isEmpty())\n-            nextNonSentinelContent(); // hungry succeed\n+        return _readListener != null;\n     }\n \n-    /**\n-     * Blocks until some content or some end-of-file event arrives.\n-     *\n-     * @throws IOException if the wait is interrupted\n-     */\n-    protected void blockForContent() throws IOException\n+    public boolean onIdleTimeout(Throwable x)\n     {\n-        try\n-        {\n-            _waitingForContent = true;\n-            _channelState.getHttpChannel().onBlockWaitForContent();\n-\n-            boolean loop = false;\n-            long timeout = 0;\n-            while (true)\n-            {\n-                // This method is called from a loop, so we just\n-                // need to check the timeout before and after waiting.\n-                if (loop)\n-                    break;\n-\n-                if (LOG.isDebugEnabled())\n-                    LOG.debug(\"{} blocking for content timeout={}\", this, timeout);\n-                if (timeout > 0)\n-                    _inputQ.wait(timeout);\n-                else\n-                    _inputQ.wait();\n-\n-                loop = true;\n-            }\n-        }\n-        catch (Throwable x)\n+        boolean neverDispatched = _channelState.isIdle();\n+        boolean waitingForContent = _contentProducer.available(this::produceRawContent) == 0 && !_eof.isEof();\n+        if ((waitingForContent || neverDispatched) && !isError())\n         {\n-            _channelState.getHttpChannel().onBlockWaitForContentFailure(x);\n+            x.addSuppressed(new Throwable(\"HttpInput idle timeout\"));\n+            _error = x;\n+            if (isAsync())\n+                return _channelState.onContentAdded();\n+            unblock();\n         }\n+        return false;\n     }\n \n-    /**\n-     * Adds some content to this input stream.\n-     *\n-     * @param content the content to add\n-     * @return true if content channel woken for read\n-     */\n-    public boolean addContent(Content content)\n+    public boolean failed(Throwable x)\n     {\n-        synchronized (_inputQ)\n-        {\n-            _waitingForContent = false;\n-            if (_firstByteTimeStamp == -1)\n-                _firstByteTimeStamp = System.nanoTime();\n-\n-            if (isFinished())\n-            {\n-                Throwable failure = isError() ? _state.getError() : new EOFException(\"Content after EOF\");\n-                content.failed(failure);\n-                return false;\n-            }\n-            else\n-            {\n-                _contentArrived += content.remaining();\n-\n-                if (_content == null && _inputQ.isEmpty())\n-                    _content = content;\n-                else\n-                    _inputQ.offer(content);\n-\n-                if (LOG.isDebugEnabled())\n-                    LOG.debug(\"{} addContent {}\", this, content);\n+        if (LOG.isDebugEnabled())\n+            LOG.debug(\"failed \" + x);\n+        if (_error != null && _error != x)\n+            _error.addSuppressed(x);\n+        else\n+            _error = x;\n \n-                if (nextInterceptedContent() != null)\n-                    return wakeup();\n-                else\n-                    return false;\n-            }\n-        }\n+        if (isAsync())\n+            return _channelState.onContentAdded();\n+        unblock();\n+        return false;\n     }\n \n-    public boolean hasContent()\n-    {\n-        synchronized (_inputQ)\n-        {\n-            return _content != null || _inputQ.size() > 0;\n-        }\n-    }\n+    /* ServletInputStream */\n \n-    public void unblock()\n+    @Override\n+    public boolean isFinished()\n     {\n-        synchronized (_inputQ)\n-        {\n-            _inputQ.notify();\n-        }\n+        boolean finished = !_contentProducer.hasRawContent() && _eof.isConsumed();\n+        if (LOG.isDebugEnabled())\n+            LOG.debug(\"isFinished? {}\", finished);\n+        return finished;\n     }\n \n-    public long getContentConsumed()\n+    @Override\n+    public boolean isReady()\n     {\n-        synchronized (_inputQ)\n+        // calling _contentProducer.available() might change the _eof state, so the following test order matters\n+        if (_contentProducer.available(this::produceRawContent) > 0 || _eof.isEof())\n         {\n-            return _contentConsumed;\n+            if (LOG.isDebugEnabled())\n+                LOG.debug(\"isReady? true\");\n+            return true;\n         }\n+        if (LOG.isDebugEnabled())\n+            LOG.debug(\"isReady? false\");\n+        _channelState.onReadUnready();\n+        return false;\n     }\n \n-    /**\n-     * This method should be called to signal that an EOF has been detected before all the expected content arrived.\n-     * <p>\n-     * Typically this will result in an EOFException being thrown from a subsequent read rather than a -1 return.\n-     *\n-     * @return true if content channel woken for read\n-     */\n-    public boolean earlyEOF()\n-    {\n-        return addContent(EARLY_EOF_CONTENT);\n-    }\n-\n-    /**\n-     * This method should be called to signal that all the expected content arrived.\n-     *\n-     * @return true if content channel woken for read\n-     */\n-    public boolean eof()\n+    @Override\n+    public void setReadListener(ReadListener readListener)\n     {\n-        return addContent(EOF_CONTENT);\n-    }\n+        if (_readListener != null)\n+            throw new IllegalStateException(\"ReadListener already set\");\n+        _readListener = Objects.requireNonNull(readListener);\n \n-    public boolean consumeAll()\n-    {\n-        synchronized (_inputQ)\n+        if (LOG.isDebugEnabled())\n+            LOG.debug(\"setReadListener error=\" + _error + \" eof=\" + _eof + \" \" + _contentProducer);\n+        boolean woken;\n+        if (isError())\n         {\n-            try\n+            woken = _channelState.onReadReady();\n+        }\n+        else\n+        {\n+            if (_contentProducer.available(this::produceRawContent) > 0)\n             {\n-                while (true)\n-                {\n-                    Content item = nextContent();\n-                    if (item == null)\n-                        break; // Let's not bother blocking\n-\n-                    skip(item, item.remaining());\n-                }\n-                if (isFinished())\n-                    return !isError();\n-\n-                _state = EARLY_EOF;\n-                return false;\n+                woken = _channelState.onReadReady();\n+            }\n+            else if (_eof.isEof())\n+            {\n+                woken = _channelState.onReadEof();\n             }\n-            catch (Throwable e)\n+            else\n             {\n-                LOG.debug(e);\n-                _state = new ErrorState(e);\n-                return false;\n+                _channelState.onReadUnready();\n+                woken = false;\n             }\n         }\n-    }\n \n-    public boolean isError()\n-    {\n-        synchronized (_inputQ)\n-        {\n-            return _state instanceof ErrorState;\n-        }\n+        if (LOG.isDebugEnabled())\n+            LOG.debug(\"setReadListener woken=\" + woken);\n+        if (woken)\n+            scheduleReadListenerNotification();\n     }\n \n-    public boolean isAsync()\n+    private void scheduleReadListenerNotification()\n     {\n-        synchronized (_inputQ)\n-        {\n-            return _state == ASYNC;\n-        }\n+        HttpChannel channel = _channelState.getHttpChannel();\n+        channel.execute(channel);\n     }\n \n     @Override\n-    public boolean isFinished()\n+    public int read() throws IOException\n     {\n-        synchronized (_inputQ)\n-        {\n-            return _state instanceof EOFState;\n-        }\n+        int read = read(_oneByteBuffer, 0, 1);\n+        if (read == 0)\n+            throw new IOException(\"unready read=0\");\n+        return read < 0 ? -1 : _oneByteBuffer[0] & 0xFF;\n     }\n \n     @Override\n-    public boolean isReady()\n+    public int read(byte[] b, int off, int len) throws IOException\n     {\n-        try\n+        // Calculate minimum request rate for DOS protection\n+        long minRequestDataRate = _channelState.getHttpChannel().getHttpConfiguration().getMinRequestDataRate();\n+        if (minRequestDataRate > 0 && _firstByteTimeStamp != Long.MIN_VALUE)\n         {\n-            synchronized (_inputQ)\n+            long period = System.nanoTime() - _firstByteTimeStamp;\n+            if (period > 0)\n             {\n-                if (_listener == null)\n-                    return true;\n-                if (_state instanceof EOFState)\n-                    return true;\n-                if (_waitingForContent)\n-                    return false;\n-                if (produceNextContext() != null)\n-                    return true;\n-                _channelState.onReadUnready();\n-                _waitingForContent = true;\n+                long minimumData = minRequestDataRate * TimeUnit.NANOSECONDS.toMillis(period) / TimeUnit.SECONDS.toMillis(1);\n+                if (_contentProducer.getRawContentArrived() < minimumData)\n+                {\n+                    BadMessageException bad = new BadMessageException(HttpStatus.REQUEST_TIMEOUT_408,\n+                        String.format(\"Request content data rate < %d B/s\", minRequestDataRate));\n+                    if (_channelState.isResponseCommitted())\n+                        _channelState.getHttpChannel().abort(bad);\n+                    throw bad;\n+                }\n             }\n-            return false;\n         }\n-        catch (IOException e)\n-        {\n-            LOG.ignore(e);\n-            return true;\n-        }\n-    }\n \n-    @Override\n-    public void setReadListener(ReadListener readListener)\n-    {\n-        boolean woken = false;\n-        try\n+        while (true)\n         {\n-            synchronized (_inputQ)\n+            _semaphore.drainPermits();\n+            int read = _contentProducer.read(this::produceRawContent, b, off, len);\n+            if (LOG.isDebugEnabled())\n+                LOG.debug(\"read produced {} byte(s)\", read);\n+            if (read > 0)\n+                return read;\n+\n+            if (LOG.isDebugEnabled())\n+                LOG.debug(\"read error = \" + _error);\n+            if (_error != null)\n+                throw new IOException(_error);\n+\n+            if (LOG.isDebugEnabled())\n+                LOG.debug(\"read EOF = {}\", _eof);\n+            if (_eof.isEarly())\n+                throw new EofException(\"Early EOF\");\n+\n+            if (LOG.isDebugEnabled())\n+                LOG.debug(\"read async = {}\", isAsync());\n+            if (!isAsync())\n             {\n-                if (_listener != null)\n-                    throw new IllegalStateException(\"ReadListener already set\");\n-\n-                _listener = Objects.requireNonNull(readListener);\n-\n-                if (isError())\n+                if (_eof.isEof())\n+                {\n+                    _eof = Eof.CONSUMED_EOF;\n+                    if (LOG.isDebugEnabled())\n+                        LOG.debug(\"read on EOF, switching to CONSUMED_EOF and returning\");\n+                    return -1;\n+                }\n+                if (LOG.isDebugEnabled())\n+                    LOG.debug(\"read blocked\");\n+                blockForContent();\n+                if (LOG.isDebugEnabled())\n+                    LOG.debug(\"read unblocked\");\n+            }\n+            else\n+            {\n+                if (_eof.isEof())\n                 {\n-                    woken = _channelState.onReadReady();\n+                    boolean wasInAsyncWait = _channelState.onReadEof();\n+                    if (wasInAsyncWait)\n+                        scheduleReadListenerNotification();\n+                    if (LOG.isDebugEnabled())\n+                        LOG.debug(\"async read on EOF (was in async wait? {}), switching to CONSUMED_EOF and returning\", wasInAsyncWait);\n+                    _eof = Eof.CONSUMED_EOF;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "743877ce7be889862c63f51350d61e5281f42a66"}, "originalPosition": 943}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzczNTQ2NDM4", "url": "https://github.com/eclipse/jetty.project/pull/4556#pullrequestreview-373546438", "createdAt": "2020-03-12T13:19:41Z", "commit": {"oid": "743877ce7be889862c63f51350d61e5281f42a66"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMlQxMzoxOTo0MVrOF1ePRA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMlQxMzoxOTo0MVrOF1ePRA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTYxNDI3Ng==", "bodyText": "As per eclipse-ee4j/servlet-api#301 throwing an ISE here is good.\nWe just have to make sure that we never call OnDataAvailable because of raw content that get's entirely consumed by interceptors", "url": "https://github.com/eclipse/jetty.project/pull/4556#discussion_r391614276", "createdAt": "2020-03-12T13:19:41Z", "author": {"login": "gregw"}, "path": "jetty-server/src/main/java/org/eclipse/jetty/server/HttpInput.java", "diffHunk": "@@ -190,633 +89,348 @@ public Interceptor getInterceptor()\n      */\n     public void setInterceptor(Interceptor interceptor)\n     {\n-        _interceptor = interceptor;\n+        _contentProducer.setInterceptor(interceptor);\n     }\n \n     /**\n-     * Set the {@link Interceptor}, using a {@link ChainedInterceptor} if\n+     * Set the {@link Interceptor}, chaining it to the existing one if\n      * an {@link Interceptor} is already set.\n      *\n      * @param interceptor the next {@link Interceptor} in a chain\n      */\n     public void addInterceptor(Interceptor interceptor)\n     {\n-        if (_interceptor == null)\n-            _interceptor = interceptor;\n+        Interceptor currentInterceptor = _contentProducer.getInterceptor();\n+        if (currentInterceptor == null)\n+            _contentProducer.setInterceptor(interceptor);\n         else\n-            _interceptor = new ChainedInterceptor(_interceptor, interceptor);\n-    }\n-\n-    @Override\n-    public int available()\n-    {\n-        int available = 0;\n-        boolean woken = false;\n-        synchronized (_inputQ)\n-        {\n-            if (_content == null)\n-                _content = _inputQ.poll();\n-            if (_content == null)\n-            {\n-                try\n-                {\n-                    produceContent();\n-                }\n-                catch (IOException e)\n-                {\n-                    woken = failed(e);\n-                }\n-                if (_content == null)\n-                    _content = _inputQ.poll();\n-            }\n-\n-            if (_content != null)\n-                available = _content.remaining();\n-        }\n-\n-        if (woken)\n-            wake();\n-        return available;\n-    }\n-\n-    protected void wake()\n-    {\n-        HttpChannel channel = _channelState.getHttpChannel();\n-        Executor executor = channel.getConnector().getServer().getThreadPool();\n-        executor.execute(channel);\n-    }\n-\n-    @Override\n-    public int read() throws IOException\n-    {\n-        int read = read(_oneByteBuffer, 0, 1);\n-        if (read == 0)\n-            throw new IllegalStateException(\"unready read=0\");\n-        return read < 0 ? -1 : _oneByteBuffer[0] & 0xFF;\n-    }\n-\n-    @Override\n-    public int read(byte[] b, int off, int len) throws IOException\n-    {\n-        boolean wake = false;\n-        int l;\n-        synchronized (_inputQ)\n-        {\n-            // Calculate minimum request rate for DOS protection\n-            long minRequestDataRate = _channelState.getHttpChannel().getHttpConfiguration().getMinRequestDataRate();\n-            if (minRequestDataRate > 0 && _firstByteTimeStamp != -1)\n-            {\n-                long period = System.nanoTime() - _firstByteTimeStamp;\n-                if (period > 0)\n-                {\n-                    long minimumData = minRequestDataRate * TimeUnit.NANOSECONDS.toMillis(period) / TimeUnit.SECONDS.toMillis(1);\n-                    if (_contentArrived < minimumData)\n-                    {\n-                        BadMessageException bad = new BadMessageException(HttpStatus.REQUEST_TIMEOUT_408,\n-                            String.format(\"Request content data rate < %d B/s\", minRequestDataRate));\n-                        if (_channelState.isResponseCommitted())\n-                            _channelState.getHttpChannel().abort(bad);\n-                        throw bad;\n-                    }\n-                }\n-            }\n-\n-            // Consume content looking for bytes to read\n-            while (true)\n-            {\n-                Content item = nextContent();\n-                if (item != null)\n-                {\n-                    l = get(item, b, off, len);\n-                    if (LOG.isDebugEnabled())\n-                        LOG.debug(\"{} read {} from {}\", this, l, item);\n-\n-                    // Consume any following poison pills\n-                    if (item.isEmpty())\n-                        nextInterceptedContent();\n-                    break;\n-                }\n-\n-                // No content, so should we block?\n-                if (!_state.blockForContent(this))\n-                {\n-                    // Not blocking, so what should we return?\n-                    l = _state.noContent();\n-\n-                    if (l < 0)\n-                        // If EOF do we need to wake for allDataRead callback?\n-                        wake = _channelState.onReadEof();\n-                    break;\n-                }\n-            }\n-        }\n-\n-        if (wake)\n-            wake();\n-        return l;\n+            _contentProducer.setInterceptor(new ChainedInterceptor(currentInterceptor, interceptor));\n     }\n \n     /**\n-     * Called when derived implementations should attempt to produce more Content and add it via {@link #addContent(Content)}. For protocols that are constantly\n-     * producing (eg HTTP2) this can be left as a noop;\n-     *\n-     * @throws IOException if unable to produce content\n+     * Called by channel when asynchronous IO needs to produce more content\n      */\n-    protected void produceContent() throws IOException\n+    public void asyncReadProduce()\n     {\n+        if (LOG.isDebugEnabled())\n+            LOG.debug(\"asyncReadProduce {}\", _contentProducer);\n+        produceRawContent();\n     }\n \n     /**\n-     * Called by channel when asynchronous IO needs to produce more content\n+     * Adds some content to this input stream.\n      *\n-     * @throws IOException if unable to produce content\n+     * @param content the content to add\n      */\n-    public void asyncReadProduce() throws IOException\n+    public void addContent(Content content)\n     {\n-        synchronized (_inputQ)\n+        if (LOG.isDebugEnabled())\n+            LOG.debug(\"addContent {} {}\", content, _contentProducer);\n+        if (_firstByteTimeStamp == Long.MIN_VALUE)\n         {\n-            produceContent();\n+            _firstByteTimeStamp = System.nanoTime();\n+            if (_firstByteTimeStamp == Long.MIN_VALUE)\n+                _firstByteTimeStamp++;\n         }\n+        _contentProducer.addContent(content);\n+        if (isAsync())\n+            _channelState.onContentAdded();\n     }\n \n-    /**\n-     * Get the next content from the inputQ, calling {@link #produceContent()} if need be. EOF is processed and state changed.\n-     *\n-     * @return the content or null if none available.\n-     * @throws IOException if retrieving the content fails\n-     */\n-    protected Content nextContent() throws IOException\n+    public boolean hasContent()\n     {\n-        Content content = nextNonSentinelContent();\n-        if (content == null && !isFinished())\n-        {\n-            produceContent();\n-            content = nextNonSentinelContent();\n-        }\n-        return content;\n+        return _contentProducer.hasRawContent();\n     }\n \n-    /**\n-     * Poll the inputQ for Content. Consumed buffers and {@link SentinelContent}s are removed and EOF state updated if need be.\n-     *\n-     * @return Content or null\n-     */\n-    protected Content nextNonSentinelContent()\n+    public void unblock()\n     {\n-        while (true)\n-        {\n-            // Get the next content (or EOF)\n-            Content content = nextInterceptedContent();\n-\n-            // If it is EOF, consume it here\n-            if (content instanceof SentinelContent)\n-            {\n-                // Consume the EOF content, either if it was original content\n-                // or if it was produced by interception\n-                consume(content);\n-                continue;\n-            }\n+        if (LOG.isDebugEnabled())\n+            LOG.debug(\"signalling blocked thread to wake up\");\n+        if (!isError() && !_eof.isEof() && _semaphore.availablePermits() > 0)\n+            throw new AssertionError();\n+        _semaphore.release();\n+    }\n \n-            return content;\n-        }\n+    public long getContentLength()\n+    {\n+        return _contentProducer.getRawContentArrived();\n     }\n \n     /**\n-     * Get the next readable from the inputQ, calling {@link #produceContent()} if need be. EOF is NOT processed and state is not changed.\n+     * This method should be called to signal that an EOF has been detected before all the expected content arrived.\n+     * <p>\n+     * Typically this will result in an EOFException being thrown from a subsequent read rather than a -1 return.\n      *\n-     * @return the content or EOF or null if none available.\n-     * @throws IOException if retrieving the content fails\n+     * @return true if content channel woken for read\n      */\n-    protected Content produceNextContext() throws IOException\n+    public boolean earlyEOF()\n     {\n-        Content content = nextInterceptedContent();\n-        if (content == null && !isFinished())\n-        {\n-            produceContent();\n-            content = nextInterceptedContent();\n-        }\n-        return content;\n+        if (LOG.isDebugEnabled())\n+            LOG.debug(\"received early EOF\");\n+        _eof = Eof.EARLY_EOF;\n+        if (isAsync())\n+            return _channelState.onContentAdded();\n+        unblock();\n+        return false;\n     }\n \n     /**\n-     * Poll the inputQ for Content or EOF. Consumed buffers and non EOF {@link SentinelContent}s are removed. EOF state is not updated.\n-     * Interception is done within this method.\n+     * This method should be called to signal that all the expected content arrived.\n      *\n-     * @return Content with remaining, a {@link SentinelContent},  or null\n+     * @return true if content channel woken for read\n      */\n-    protected Content nextInterceptedContent()\n+    public boolean eof()\n     {\n-        // If we have a chunk produced by interception\n-        if (_intercepted != null)\n-        {\n-            // Use it if it has any remaining content\n-            if (_intercepted.hasContent())\n-                return _intercepted;\n-\n-            // succeed the chunk\n-            _intercepted.succeeded();\n-            _intercepted = null;\n-        }\n-\n-        // If we don't have a Content under consideration, get\n-        // the next one off the input Q.\n-        if (_content == null)\n-            _content = _inputQ.poll();\n-\n-        // While we have content to consider.\n-        while (_content != null)\n-        {\n-            // Are we intercepting?\n-            if (_interceptor != null)\n-            {\n-                // Intercept the current content (may be called several\n-                // times for the same content\n-                _intercepted = _interceptor.readFrom(_content);\n-\n-                // If interception produced new content\n-                if (_intercepted != null && _intercepted != _content)\n-                {\n-                    // if it is not empty use it\n-                    if (_intercepted.hasContent())\n-                        return _intercepted;\n-                    _intercepted.succeeded();\n-                }\n-\n-                // intercepted content consumed\n-                _intercepted = null;\n-\n-                // fall through so that the unintercepted _content is\n-                // considered for any remaining content, for EOF and to\n-                // succeed it if it is entirely consumed.\n-            }\n-\n-            // If the content has content or is an EOF marker, use it\n-            if (_content.hasContent() || _content instanceof SentinelContent)\n-                return _content;\n-\n-            // The content is consumed, so get the next one.  Note that EOF\n-            // content is never consumed here, but in #pollContent\n-            _content.succeeded();\n-            _content = _inputQ.poll();\n-        }\n-\n-        return null;\n+        if (LOG.isDebugEnabled())\n+            LOG.debug(\"received EOF\");\n+        _eof = Eof.EOF;\n+        if (isAsync())\n+            return _channelState.onContentAdded();\n+        unblock();\n+        return false;\n     }\n \n-    private void consume(Content content)\n+    public boolean consumeAll()\n     {\n-        if (!isError() && content instanceof EofContent)\n-        {\n-            if (content == EARLY_EOF_CONTENT)\n-                _state = EARLY_EOF;\n-            else if (_listener == null)\n-                _state = EOF;\n-            else\n-                _state = AEOF;\n-        }\n+        if (LOG.isDebugEnabled())\n+            LOG.debug(\"consume all\");\n+        _contentProducer.consumeTransformedContent(this::failRawContent, new IOException(\"Unconsumed content\"));\n+        if (_eof.isEof())\n+            _eof = Eof.CONSUMED_EOF;\n+\n+        if (isFinished())\n+            return !isError();\n \n-        // Consume the content, either if it was original content\n-        // or if it was produced by interception\n-        content.succeeded();\n-        if (_content == content)\n-            _content = null;\n-        else if (_intercepted == content)\n-            _intercepted = null;\n+        _eof = Eof.EARLY_EOF;\n+        return false;\n     }\n \n-    /**\n-     * Copies the given content into the given byte buffer.\n-     *\n-     * @param content the content to copy from\n-     * @param buffer the buffer to copy into\n-     * @param offset the buffer offset to start copying from\n-     * @param length the space available in the buffer\n-     * @return the number of bytes actually copied\n-     */\n-    protected int get(Content content, byte[] buffer, int offset, int length)\n+    public boolean isError()\n     {\n-        int l = content.get(buffer, offset, length);\n-        _contentConsumed += l;\n-        return l;\n+        return _error != null;\n     }\n \n-    /**\n-     * Consumes the given content. Calls the content succeeded if all content consumed.\n-     *\n-     * @param content the content to consume\n-     * @param length the number of bytes to consume\n-     */\n-    protected void skip(Content content, int length)\n+    public boolean isAsync()\n     {\n-        int l = content.skip(length);\n-\n-        _contentConsumed += l;\n-        if (l > 0 && content.isEmpty())\n-            nextNonSentinelContent(); // hungry succeed\n+        return _readListener != null;\n     }\n \n-    /**\n-     * Blocks until some content or some end-of-file event arrives.\n-     *\n-     * @throws IOException if the wait is interrupted\n-     */\n-    protected void blockForContent() throws IOException\n+    public boolean onIdleTimeout(Throwable x)\n     {\n-        try\n-        {\n-            _waitingForContent = true;\n-            _channelState.getHttpChannel().onBlockWaitForContent();\n-\n-            boolean loop = false;\n-            long timeout = 0;\n-            while (true)\n-            {\n-                // This method is called from a loop, so we just\n-                // need to check the timeout before and after waiting.\n-                if (loop)\n-                    break;\n-\n-                if (LOG.isDebugEnabled())\n-                    LOG.debug(\"{} blocking for content timeout={}\", this, timeout);\n-                if (timeout > 0)\n-                    _inputQ.wait(timeout);\n-                else\n-                    _inputQ.wait();\n-\n-                loop = true;\n-            }\n-        }\n-        catch (Throwable x)\n+        boolean neverDispatched = _channelState.isIdle();\n+        boolean waitingForContent = _contentProducer.available(this::produceRawContent) == 0 && !_eof.isEof();\n+        if ((waitingForContent || neverDispatched) && !isError())\n         {\n-            _channelState.getHttpChannel().onBlockWaitForContentFailure(x);\n+            x.addSuppressed(new Throwable(\"HttpInput idle timeout\"));\n+            _error = x;\n+            if (isAsync())\n+                return _channelState.onContentAdded();\n+            unblock();\n         }\n+        return false;\n     }\n \n-    /**\n-     * Adds some content to this input stream.\n-     *\n-     * @param content the content to add\n-     * @return true if content channel woken for read\n-     */\n-    public boolean addContent(Content content)\n+    public boolean failed(Throwable x)\n     {\n-        synchronized (_inputQ)\n-        {\n-            _waitingForContent = false;\n-            if (_firstByteTimeStamp == -1)\n-                _firstByteTimeStamp = System.nanoTime();\n-\n-            if (isFinished())\n-            {\n-                Throwable failure = isError() ? _state.getError() : new EOFException(\"Content after EOF\");\n-                content.failed(failure);\n-                return false;\n-            }\n-            else\n-            {\n-                _contentArrived += content.remaining();\n-\n-                if (_content == null && _inputQ.isEmpty())\n-                    _content = content;\n-                else\n-                    _inputQ.offer(content);\n-\n-                if (LOG.isDebugEnabled())\n-                    LOG.debug(\"{} addContent {}\", this, content);\n+        if (LOG.isDebugEnabled())\n+            LOG.debug(\"failed \" + x);\n+        if (_error != null && _error != x)\n+            _error.addSuppressed(x);\n+        else\n+            _error = x;\n \n-                if (nextInterceptedContent() != null)\n-                    return wakeup();\n-                else\n-                    return false;\n-            }\n-        }\n+        if (isAsync())\n+            return _channelState.onContentAdded();\n+        unblock();\n+        return false;\n     }\n \n-    public boolean hasContent()\n-    {\n-        synchronized (_inputQ)\n-        {\n-            return _content != null || _inputQ.size() > 0;\n-        }\n-    }\n+    /* ServletInputStream */\n \n-    public void unblock()\n+    @Override\n+    public boolean isFinished()\n     {\n-        synchronized (_inputQ)\n-        {\n-            _inputQ.notify();\n-        }\n+        boolean finished = !_contentProducer.hasRawContent() && _eof.isConsumed();\n+        if (LOG.isDebugEnabled())\n+            LOG.debug(\"isFinished? {}\", finished);\n+        return finished;\n     }\n \n-    public long getContentConsumed()\n+    @Override\n+    public boolean isReady()\n     {\n-        synchronized (_inputQ)\n+        // calling _contentProducer.available() might change the _eof state, so the following test order matters\n+        if (_contentProducer.available(this::produceRawContent) > 0 || _eof.isEof())\n         {\n-            return _contentConsumed;\n+            if (LOG.isDebugEnabled())\n+                LOG.debug(\"isReady? true\");\n+            return true;\n         }\n+        if (LOG.isDebugEnabled())\n+            LOG.debug(\"isReady? false\");\n+        _channelState.onReadUnready();\n+        return false;\n     }\n \n-    /**\n-     * This method should be called to signal that an EOF has been detected before all the expected content arrived.\n-     * <p>\n-     * Typically this will result in an EOFException being thrown from a subsequent read rather than a -1 return.\n-     *\n-     * @return true if content channel woken for read\n-     */\n-    public boolean earlyEOF()\n-    {\n-        return addContent(EARLY_EOF_CONTENT);\n-    }\n-\n-    /**\n-     * This method should be called to signal that all the expected content arrived.\n-     *\n-     * @return true if content channel woken for read\n-     */\n-    public boolean eof()\n+    @Override\n+    public void setReadListener(ReadListener readListener)\n     {\n-        return addContent(EOF_CONTENT);\n-    }\n+        if (_readListener != null)\n+            throw new IllegalStateException(\"ReadListener already set\");\n+        _readListener = Objects.requireNonNull(readListener);\n \n-    public boolean consumeAll()\n-    {\n-        synchronized (_inputQ)\n+        if (LOG.isDebugEnabled())\n+            LOG.debug(\"setReadListener error=\" + _error + \" eof=\" + _eof + \" \" + _contentProducer);\n+        boolean woken;\n+        if (isError())\n         {\n-            try\n+            woken = _channelState.onReadReady();\n+        }\n+        else\n+        {\n+            if (_contentProducer.available(this::produceRawContent) > 0)\n             {\n-                while (true)\n-                {\n-                    Content item = nextContent();\n-                    if (item == null)\n-                        break; // Let's not bother blocking\n-\n-                    skip(item, item.remaining());\n-                }\n-                if (isFinished())\n-                    return !isError();\n-\n-                _state = EARLY_EOF;\n-                return false;\n+                woken = _channelState.onReadReady();\n+            }\n+            else if (_eof.isEof())\n+            {\n+                woken = _channelState.onReadEof();\n             }\n-            catch (Throwable e)\n+            else\n             {\n-                LOG.debug(e);\n-                _state = new ErrorState(e);\n-                return false;\n+                _channelState.onReadUnready();\n+                woken = false;\n             }\n         }\n-    }\n \n-    public boolean isError()\n-    {\n-        synchronized (_inputQ)\n-        {\n-            return _state instanceof ErrorState;\n-        }\n+        if (LOG.isDebugEnabled())\n+            LOG.debug(\"setReadListener woken=\" + woken);\n+        if (woken)\n+            scheduleReadListenerNotification();\n     }\n \n-    public boolean isAsync()\n+    private void scheduleReadListenerNotification()\n     {\n-        synchronized (_inputQ)\n-        {\n-            return _state == ASYNC;\n-        }\n+        HttpChannel channel = _channelState.getHttpChannel();\n+        channel.execute(channel);\n     }\n \n     @Override\n-    public boolean isFinished()\n+    public int read() throws IOException\n     {\n-        synchronized (_inputQ)\n-        {\n-            return _state instanceof EOFState;\n-        }\n+        int read = read(_oneByteBuffer, 0, 1);\n+        if (read == 0)\n+            throw new IOException(\"unready read=0\");\n+        return read < 0 ? -1 : _oneByteBuffer[0] & 0xFF;\n     }\n \n     @Override\n-    public boolean isReady()\n+    public int read(byte[] b, int off, int len) throws IOException\n     {\n-        try\n+        // Calculate minimum request rate for DOS protection\n+        long minRequestDataRate = _channelState.getHttpChannel().getHttpConfiguration().getMinRequestDataRate();\n+        if (minRequestDataRate > 0 && _firstByteTimeStamp != Long.MIN_VALUE)\n         {\n-            synchronized (_inputQ)\n+            long period = System.nanoTime() - _firstByteTimeStamp;\n+            if (period > 0)\n             {\n-                if (_listener == null)\n-                    return true;\n-                if (_state instanceof EOFState)\n-                    return true;\n-                if (_waitingForContent)\n-                    return false;\n-                if (produceNextContext() != null)\n-                    return true;\n-                _channelState.onReadUnready();\n-                _waitingForContent = true;\n+                long minimumData = minRequestDataRate * TimeUnit.NANOSECONDS.toMillis(period) / TimeUnit.SECONDS.toMillis(1);\n+                if (_contentProducer.getRawContentArrived() < minimumData)\n+                {\n+                    BadMessageException bad = new BadMessageException(HttpStatus.REQUEST_TIMEOUT_408,\n+                        String.format(\"Request content data rate < %d B/s\", minRequestDataRate));\n+                    if (_channelState.isResponseCommitted())\n+                        _channelState.getHttpChannel().abort(bad);\n+                    throw bad;\n+                }\n             }\n-            return false;\n         }\n-        catch (IOException e)\n-        {\n-            LOG.ignore(e);\n-            return true;\n-        }\n-    }\n \n-    @Override\n-    public void setReadListener(ReadListener readListener)\n-    {\n-        boolean woken = false;\n-        try\n+        while (true)\n         {\n-            synchronized (_inputQ)\n+            _semaphore.drainPermits();\n+            int read = _contentProducer.read(this::produceRawContent, b, off, len);\n+            if (LOG.isDebugEnabled())\n+                LOG.debug(\"read produced {} byte(s)\", read);\n+            if (read > 0)\n+                return read;\n+\n+            if (LOG.isDebugEnabled())\n+                LOG.debug(\"read error = \" + _error);\n+            if (_error != null)\n+                throw new IOException(_error);\n+\n+            if (LOG.isDebugEnabled())\n+                LOG.debug(\"read EOF = {}\", _eof);\n+            if (_eof.isEarly())\n+                throw new EofException(\"Early EOF\");\n+\n+            if (LOG.isDebugEnabled())\n+                LOG.debug(\"read async = {}\", isAsync());\n+            if (!isAsync())\n             {\n-                if (_listener != null)\n-                    throw new IllegalStateException(\"ReadListener already set\");\n-\n-                _listener = Objects.requireNonNull(readListener);\n-\n-                if (isError())\n+                if (_eof.isEof())\n+                {\n+                    _eof = Eof.CONSUMED_EOF;\n+                    if (LOG.isDebugEnabled())\n+                        LOG.debug(\"read on EOF, switching to CONSUMED_EOF and returning\");\n+                    return -1;\n+                }\n+                if (LOG.isDebugEnabled())\n+                    LOG.debug(\"read blocked\");\n+                blockForContent();\n+                if (LOG.isDebugEnabled())\n+                    LOG.debug(\"read unblocked\");\n+            }\n+            else\n+            {\n+                if (_eof.isEof())\n                 {\n-                    woken = _channelState.onReadReady();\n+                    boolean wasInAsyncWait = _channelState.onReadEof();\n+                    if (wasInAsyncWait)\n+                        scheduleReadListenerNotification();\n+                    if (LOG.isDebugEnabled())\n+                        LOG.debug(\"async read on EOF (was in async wait? {}), switching to CONSUMED_EOF and returning\", wasInAsyncWait);\n+                    _eof = Eof.CONSUMED_EOF;\n+                    return -1;\n                 }\n                 else\n                 {\n-                    Content content = produceNextContext();\n-                    if (content != null)\n-                    {\n-                        _state = ASYNC;\n-                        woken = _channelState.onReadReady();\n-                    }\n-                    else if (_state == EOF)\n-                    {\n-                        _state = AEOF;\n-                        woken = _channelState.onReadEof();\n-                    }\n-                    else\n-                    {\n-                        _state = ASYNC;\n-                        _channelState.onReadUnready();\n-                        _waitingForContent = true;\n-                    }\n+                    //TODO returning 0 breaks the InputStream contract. Shouldn't IOException be thrown instead?", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "743877ce7be889862c63f51350d61e5281f42a66"}, "originalPosition": 965}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzczNTUxNDc4", "url": "https://github.com/eclipse/jetty.project/pull/4556#pullrequestreview-373551478", "createdAt": "2020-03-12T13:26:03Z", "commit": {"oid": "743877ce7be889862c63f51350d61e5281f42a66"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMlQxMzoyNjowM1rOF1eeXw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMlQxMzoyNjowM1rOF1eeXw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTYxODE0Mw==", "bodyText": "I'm not a big fan of the passed array!   I'd much rather you return a HttpInput.LastContent wrapper of the HttpInput.Content", "url": "https://github.com/eclipse/jetty.project/pull/4556#discussion_r391618143", "createdAt": "2020-03-12T13:26:03Z", "author": {"login": "gregw"}, "path": "jetty-http2/http2-server/src/main/java/org/eclipse/jetty/http2/server/HttpChannelOverHTTP2.java", "diffHunk": "@@ -57,6 +58,64 @@\n     private boolean _expect100Continue;\n     private boolean _delayedUntilContent;\n     private boolean _useOutputDirectByteBuffers;\n+    private final RequestContent _requestContent = new RequestContent();\n+\n+    private class RequestContent\n+    {\n+        private HttpInput.Content _content;\n+        private boolean _endStream;\n+        private boolean _producing;\n+        private final AutoLock _lock = new AutoLock();\n+\n+        void setContent(boolean endStream, HttpInput.Content content)\n+        {\n+            try (AutoLock ignored = _lock.lock())\n+            {\n+                if (_content != null)\n+                    throw new AssertionError(\"content cannot be queued; stream=\" + getStream());\n+                _endStream = endStream;\n+                _content = content;\n+                _producing = false;\n+            }\n+        }\n+\n+        private HttpInput.Content takeContent(boolean[] endStreamResult)\n+        {\n+            try (AutoLock ignored = _lock.lock())\n+            {\n+                if (_content == null)\n+                    return null;\n+                HttpInput.Content contentCopy = _content;\n+                endStreamResult[0] = _endStream;\n+                _content = null;\n+                _endStream = false;\n+                return contentCopy;\n+            }\n+        }\n+\n+        HttpInput.Content takeContentOrDemand(boolean[] endStreamResult)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "743877ce7be889862c63f51350d61e5281f42a66"}, "originalPosition": 47}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzczNTYwMDAw", "url": "https://github.com/eclipse/jetty.project/pull/4556#pullrequestreview-373560000", "createdAt": "2020-03-12T13:36:41Z", "commit": {"oid": "743877ce7be889862c63f51350d61e5281f42a66"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMlQxMzozNjo0MVrOF1e3eg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMlQxMzozNjo0MVrOF1e3eg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTYyNDU3MA==", "bodyText": "I think the problem here is that we may wake up if we receive raw content that is fully consumed by an interceptor.\nI think that either:\n\naddContent should attempt to do a transform and return a boolean to indicate if there is some; OR\nin the isAsyncCase you try calling nextNonEmptyContent to check if there is a non zero return.", "url": "https://github.com/eclipse/jetty.project/pull/4556#discussion_r391624570", "createdAt": "2020-03-12T13:36:41Z", "author": {"login": "gregw"}, "path": "jetty-server/src/main/java/org/eclipse/jetty/server/HttpInput.java", "diffHunk": "@@ -190,633 +89,348 @@ public Interceptor getInterceptor()\n      */\n     public void setInterceptor(Interceptor interceptor)\n     {\n-        _interceptor = interceptor;\n+        _contentProducer.setInterceptor(interceptor);\n     }\n \n     /**\n-     * Set the {@link Interceptor}, using a {@link ChainedInterceptor} if\n+     * Set the {@link Interceptor}, chaining it to the existing one if\n      * an {@link Interceptor} is already set.\n      *\n      * @param interceptor the next {@link Interceptor} in a chain\n      */\n     public void addInterceptor(Interceptor interceptor)\n     {\n-        if (_interceptor == null)\n-            _interceptor = interceptor;\n+        Interceptor currentInterceptor = _contentProducer.getInterceptor();\n+        if (currentInterceptor == null)\n+            _contentProducer.setInterceptor(interceptor);\n         else\n-            _interceptor = new ChainedInterceptor(_interceptor, interceptor);\n-    }\n-\n-    @Override\n-    public int available()\n-    {\n-        int available = 0;\n-        boolean woken = false;\n-        synchronized (_inputQ)\n-        {\n-            if (_content == null)\n-                _content = _inputQ.poll();\n-            if (_content == null)\n-            {\n-                try\n-                {\n-                    produceContent();\n-                }\n-                catch (IOException e)\n-                {\n-                    woken = failed(e);\n-                }\n-                if (_content == null)\n-                    _content = _inputQ.poll();\n-            }\n-\n-            if (_content != null)\n-                available = _content.remaining();\n-        }\n-\n-        if (woken)\n-            wake();\n-        return available;\n-    }\n-\n-    protected void wake()\n-    {\n-        HttpChannel channel = _channelState.getHttpChannel();\n-        Executor executor = channel.getConnector().getServer().getThreadPool();\n-        executor.execute(channel);\n-    }\n-\n-    @Override\n-    public int read() throws IOException\n-    {\n-        int read = read(_oneByteBuffer, 0, 1);\n-        if (read == 0)\n-            throw new IllegalStateException(\"unready read=0\");\n-        return read < 0 ? -1 : _oneByteBuffer[0] & 0xFF;\n-    }\n-\n-    @Override\n-    public int read(byte[] b, int off, int len) throws IOException\n-    {\n-        boolean wake = false;\n-        int l;\n-        synchronized (_inputQ)\n-        {\n-            // Calculate minimum request rate for DOS protection\n-            long minRequestDataRate = _channelState.getHttpChannel().getHttpConfiguration().getMinRequestDataRate();\n-            if (minRequestDataRate > 0 && _firstByteTimeStamp != -1)\n-            {\n-                long period = System.nanoTime() - _firstByteTimeStamp;\n-                if (period > 0)\n-                {\n-                    long minimumData = minRequestDataRate * TimeUnit.NANOSECONDS.toMillis(period) / TimeUnit.SECONDS.toMillis(1);\n-                    if (_contentArrived < minimumData)\n-                    {\n-                        BadMessageException bad = new BadMessageException(HttpStatus.REQUEST_TIMEOUT_408,\n-                            String.format(\"Request content data rate < %d B/s\", minRequestDataRate));\n-                        if (_channelState.isResponseCommitted())\n-                            _channelState.getHttpChannel().abort(bad);\n-                        throw bad;\n-                    }\n-                }\n-            }\n-\n-            // Consume content looking for bytes to read\n-            while (true)\n-            {\n-                Content item = nextContent();\n-                if (item != null)\n-                {\n-                    l = get(item, b, off, len);\n-                    if (LOG.isDebugEnabled())\n-                        LOG.debug(\"{} read {} from {}\", this, l, item);\n-\n-                    // Consume any following poison pills\n-                    if (item.isEmpty())\n-                        nextInterceptedContent();\n-                    break;\n-                }\n-\n-                // No content, so should we block?\n-                if (!_state.blockForContent(this))\n-                {\n-                    // Not blocking, so what should we return?\n-                    l = _state.noContent();\n-\n-                    if (l < 0)\n-                        // If EOF do we need to wake for allDataRead callback?\n-                        wake = _channelState.onReadEof();\n-                    break;\n-                }\n-            }\n-        }\n-\n-        if (wake)\n-            wake();\n-        return l;\n+            _contentProducer.setInterceptor(new ChainedInterceptor(currentInterceptor, interceptor));\n     }\n \n     /**\n-     * Called when derived implementations should attempt to produce more Content and add it via {@link #addContent(Content)}. For protocols that are constantly\n-     * producing (eg HTTP2) this can be left as a noop;\n-     *\n-     * @throws IOException if unable to produce content\n+     * Called by channel when asynchronous IO needs to produce more content\n      */\n-    protected void produceContent() throws IOException\n+    public void asyncReadProduce()\n     {\n+        if (LOG.isDebugEnabled())\n+            LOG.debug(\"asyncReadProduce {}\", _contentProducer);\n+        produceRawContent();\n     }\n \n     /**\n-     * Called by channel when asynchronous IO needs to produce more content\n+     * Adds some content to this input stream.\n      *\n-     * @throws IOException if unable to produce content\n+     * @param content the content to add\n      */\n-    public void asyncReadProduce() throws IOException\n+    public void addContent(Content content)\n     {\n-        synchronized (_inputQ)\n+        if (LOG.isDebugEnabled())\n+            LOG.debug(\"addContent {} {}\", content, _contentProducer);\n+        if (_firstByteTimeStamp == Long.MIN_VALUE)\n         {\n-            produceContent();\n+            _firstByteTimeStamp = System.nanoTime();\n+            if (_firstByteTimeStamp == Long.MIN_VALUE)\n+                _firstByteTimeStamp++;\n         }\n+        _contentProducer.addContent(content);\n+        if (isAsync())\n+            _channelState.onContentAdded();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "743877ce7be889862c63f51350d61e5281f42a66"}, "originalPosition": 365}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "121ba179f754c661dcf25db6ede90ab226c7386a", "author": {"user": {"login": "lorban", "name": "Ludovic Orban"}}, "url": "https://github.com/eclipse/jetty.project/commit/121ba179f754c661dcf25db6ede90ab226c7386a", "committedDate": "2020-03-17T16:44:18Z", "message": "fixed two race conditions\n\nSigned-off-by: Ludovic Orban <lorban@bitronix.be>"}, "afterCommit": {"oid": "92e760711fe4c6a5f682adc69797b1f4182306ed", "author": {"user": {"login": "lorban", "name": "Ludovic Orban"}}, "url": "https://github.com/eclipse/jetty.project/commit/92e760711fe4c6a5f682adc69797b1f4182306ed", "committedDate": "2020-03-20T08:48:11Z", "message": "apply slf4j changes\n\nSigned-off-by: Ludovic Orban <lorban@bitronix.be>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "92e760711fe4c6a5f682adc69797b1f4182306ed", "author": {"user": {"login": "lorban", "name": "Ludovic Orban"}}, "url": "https://github.com/eclipse/jetty.project/commit/92e760711fe4c6a5f682adc69797b1f4182306ed", "committedDate": "2020-03-20T08:48:11Z", "message": "apply slf4j changes\n\nSigned-off-by: Ludovic Orban <lorban@bitronix.be>"}, "afterCommit": {"oid": "89badf0eea2cfe12b609fe45287e2ef15d549bbf", "author": {"user": {"login": "lorban", "name": "Ludovic Orban"}}, "url": "https://github.com/eclipse/jetty.project/commit/89badf0eea2cfe12b609fe45287e2ef15d549bbf", "committedDate": "2020-03-20T09:29:17Z", "message": "apply slf4j changes\n\nSigned-off-by: Ludovic Orban <lorban@bitronix.be>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "3de5985d004e1c6f100225496e95b7f12c5deb02", "author": {"user": {"login": "lorban", "name": "Ludovic Orban"}}, "url": "https://github.com/eclipse/jetty.project/commit/3de5985d004e1c6f100225496e95b7f12c5deb02", "committedDate": "2020-03-24T10:25:22Z", "message": "fix deadlock by calling callbacks out of lock scope\n\nSigned-off-by: Ludovic Orban <lorban@bitronix.be>"}, "afterCommit": {"oid": "1c326618a8f2f970375832bdf3a05d4e7b1faa63", "author": {"user": {"login": "lorban", "name": "Ludovic Orban"}}, "url": "https://github.com/eclipse/jetty.project/commit/1c326618a8f2f970375832bdf3a05d4e7b1faa63", "committedDate": "2020-03-24T11:29:16Z", "message": "fix deadlock by calling callbacks out of lock scope\n\nSigned-off-by: Ludovic Orban <lorban@bitronix.be>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "1c326618a8f2f970375832bdf3a05d4e7b1faa63", "author": {"user": {"login": "lorban", "name": "Ludovic Orban"}}, "url": "https://github.com/eclipse/jetty.project/commit/1c326618a8f2f970375832bdf3a05d4e7b1faa63", "committedDate": "2020-03-24T11:29:16Z", "message": "fix deadlock by calling callbacks out of lock scope\n\nSigned-off-by: Ludovic Orban <lorban@bitronix.be>"}, "afterCommit": {"oid": "3e7cdf055bd73934eba01d68a674a27fe3c0c1ae", "author": {"user": {"login": "lorban", "name": "Ludovic Orban"}}, "url": "https://github.com/eclipse/jetty.project/commit/3e7cdf055bd73934eba01d68a674a27fe3c0c1ae", "committedDate": "2020-03-24T13:29:43Z", "message": "fix deadlock by calling callbacks out of lock scope\n\nSigned-off-by: Ludovic Orban <lorban@bitronix.be>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "3e7cdf055bd73934eba01d68a674a27fe3c0c1ae", "author": {"user": {"login": "lorban", "name": "Ludovic Orban"}}, "url": "https://github.com/eclipse/jetty.project/commit/3e7cdf055bd73934eba01d68a674a27fe3c0c1ae", "committedDate": "2020-03-24T13:29:43Z", "message": "fix deadlock by calling callbacks out of lock scope\n\nSigned-off-by: Ludovic Orban <lorban@bitronix.be>"}, "afterCommit": {"oid": "bc5845d3c7e7fdd39bb07c607f0d50932e2238f9", "author": {"user": {"login": "lorban", "name": "Ludovic Orban"}}, "url": "https://github.com/eclipse/jetty.project/commit/bc5845d3c7e7fdd39bb07c607f0d50932e2238f9", "committedDate": "2020-03-24T11:29:16Z", "message": "apply slf4j changes\n\nSigned-off-by: Ludovic Orban <lorban@bitronix.be>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzgyOTA4NjIw", "url": "https://github.com/eclipse/jetty.project/pull/4556#pullrequestreview-382908620", "createdAt": "2020-03-27T14:29:14Z", "commit": {"oid": "b2533d6772c223f0991aa3c4fa7bfeeacaf073d8"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yN1QxNDoyOToxNFrOF8zpcQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yN1QxNDozNDo1OVrOF8z5xQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTMwNTA3Mw==", "bodyText": "Considering that HttpInput.Content is our interface, why don't we just put an isLast() method on it?", "url": "https://github.com/eclipse/jetty.project/pull/4556#discussion_r399305073", "createdAt": "2020-03-27T14:29:14Z", "author": {"login": "gregw"}, "path": "jetty-http2/http2-server/src/main/java/org/eclipse/jetty/http2/server/HttpChannelOverHTTP2.java", "diffHunk": "@@ -285,6 +285,23 @@ public void recycle()\n         getHttpTransport().recycle();\n     }\n \n+    public void onAsyncWaitForContent()\n+    {\n+        // Check if demand was fulfilled while we were transitioning to the REGISTERED state,\n+        // push the content to the HttpInput if that was the case.\n+        boolean[] endStreamResult = new boolean[1];\n+        HttpInput.Content content = _requestContent.takeContent(endStreamResult);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b2533d6772c223f0991aa3c4fa7bfeeacaf073d8"}, "originalPosition": 18}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTMwODAxNQ==", "bodyText": "Can you explain how content can be added in POSSIBLE state?\nI thought the idea was that we switched to POSSIBLE from REGISTERED state when the callback happened, but then we call handle and it is only withing handle that we then switch from POSSIBLE to PRODUCING state and then onContentAdded might be called.", "url": "https://github.com/eclipse/jetty.project/pull/4556#discussion_r399308015", "createdAt": "2020-03-27T14:33:14Z", "author": {"login": "gregw"}, "path": "jetty-server/src/main/java/org/eclipse/jetty/server/HttpChannelState.java", "diffHunk": "@@ -1294,6 +1294,7 @@ public boolean onContentAdded()\n                 case READY:\n                     break;\n \n+                case POSSIBLE:", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b2533d6772c223f0991aa3c4fa7bfeeacaf073d8"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTMwOTI1Mw==", "bodyText": "Again can you explain this?   If we are in POSSIBLE state then a thread is on its way to call handle an switch us to PRODUCING.   So we've already been called back! How can we get called back again?", "url": "https://github.com/eclipse/jetty.project/pull/4556#discussion_r399309253", "createdAt": "2020-03-27T14:34:59Z", "author": {"login": "gregw"}, "path": "jetty-server/src/main/java/org/eclipse/jetty/server/HttpChannelState.java", "diffHunk": "@@ -1378,6 +1379,7 @@ public boolean onReadPossible()\n                 case IDLE:\n                 case READY:\n                 case REGISTER:\n+                case POSSIBLE:", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b2533d6772c223f0991aa3c4fa7bfeeacaf073d8"}, "originalPosition": 21}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzkyMjE4NTc1", "url": "https://github.com/eclipse/jetty.project/pull/4556#pullrequestreview-392218575", "createdAt": "2020-04-13T15:28:17Z", "commit": {"oid": "1e094a193e10f54fc241a680d89525b42842f2a7"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xM1QxNToyODoxN1rOGEqLwQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xM1QxNToyODoxN1rOGEqLwQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzUzODYyNQ==", "bodyText": "I'm not particularly fond of this - I'm sure it can be done otherwise.\nThe demand mechanism is well established now (even present in the JDK) so I would not change its semantic.", "url": "https://github.com/eclipse/jetty.project/pull/4556#discussion_r407538625", "createdAt": "2020-04-13T15:28:17Z", "author": {"login": "sbordet"}, "path": "jetty-http2/http2-server/src/main/java/org/eclipse/jetty/http2/server/HttpChannelOverHTTP2.java", "diffHunk": "@@ -62,58 +62,54 @@\n \n     private class RequestContent\n     {\n-        private HttpInput.Content _content;\n-        private boolean _endStream;\n         private boolean _producing;\n+        private boolean _woken;\n         private final AutoLock _lock = new AutoLock();\n \n-        void setContent(boolean endStream, HttpInput.Content content)\n+        public boolean woken()\n         {\n             try (AutoLock ignored = _lock.lock())\n             {\n-                if (_content != null)\n-                    throw new AssertionError(\"content cannot be queued; stream=\" + getStream());\n-                _endStream = endStream;\n-                _content = content;\n-                _producing = false;\n+                return _woken;\n             }\n         }\n \n-        HttpInput.Content takeContent(boolean[] endStreamResult)\n+        void setContent(boolean endStream, HttpInput.Content content)\n         {\n             try (AutoLock ignored = _lock.lock())\n             {\n-                if (_content == null)\n-                    return null;\n-                HttpInput.Content contentCopy = _content;\n-                endStreamResult[0] = _endStream;\n-                _content = null;\n-                _endStream = false;\n-                return contentCopy;\n+                _producing = false;\n+            }\n+\n+            boolean woken = onContent(content);\n+            if (endStream)\n+            {\n+                onContentComplete();\n+                woken |= onRequestComplete();\n+            }\n+\n+            try (AutoLock ignored = _lock.lock())\n+            {\n+                _woken = woken;\n             }\n         }\n \n-        HttpInput.Content takeContentOrDemand(boolean[] endStreamResult)\n+        void poll()\n         {\n-            HttpInput.Content content = takeContent(endStreamResult);\n-            if (content != null)\n-                return content;\n+            getStream().demand(0);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1e094a193e10f54fc241a680d89525b42842f2a7"}, "originalPosition": 58}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "1e094a193e10f54fc241a680d89525b42842f2a7", "author": {"user": {"login": "lorban", "name": "Ludovic Orban"}}, "url": "https://github.com/eclipse/jetty.project/commit/1e094a193e10f54fc241a680d89525b42842f2a7", "committedDate": "2020-04-13T15:17:29Z", "message": "better align HTTP 1 and 2 by introducing Stream.demand(0)\n\nSigned-off-by: Ludovic Orban <lorban@bitronix.be>"}, "afterCommit": {"oid": "626538029e55fba20086149854cea33c55c16335", "author": {"user": {"login": "lorban", "name": "Ludovic Orban"}}, "url": "https://github.com/eclipse/jetty.project/commit/626538029e55fba20086149854cea33c55c16335", "committedDate": "2020-04-13T15:54:51Z", "message": "better align HTTP 1 and 2 by introducing Stream.demand(0)\n\nSigned-off-by: Ludovic Orban <lorban@bitronix.be>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "626538029e55fba20086149854cea33c55c16335", "author": {"user": {"login": "lorban", "name": "Ludovic Orban"}}, "url": "https://github.com/eclipse/jetty.project/commit/626538029e55fba20086149854cea33c55c16335", "committedDate": "2020-04-13T15:54:51Z", "message": "better align HTTP 1 and 2 by introducing Stream.demand(0)\n\nSigned-off-by: Ludovic Orban <lorban@bitronix.be>"}, "afterCommit": {"oid": "0885323b85e66b3ac1897be0d9b431e62fbd4003", "author": {"user": {"login": "lorban", "name": "Ludovic Orban"}}, "url": "https://github.com/eclipse/jetty.project/commit/0885323b85e66b3ac1897be0d9b431e62fbd4003", "committedDate": "2020-04-14T10:20:48Z", "message": "refactor to minimize code changes vs Milestone 3\n\nSigned-off-by: Ludovic Orban <lorban@bitronix.be>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "0885323b85e66b3ac1897be0d9b431e62fbd4003", "author": {"user": {"login": "lorban", "name": "Ludovic Orban"}}, "url": "https://github.com/eclipse/jetty.project/commit/0885323b85e66b3ac1897be0d9b431e62fbd4003", "committedDate": "2020-04-14T10:20:48Z", "message": "refactor to minimize code changes vs Milestone 3\n\nSigned-off-by: Ludovic Orban <lorban@bitronix.be>"}, "afterCommit": {"oid": "dd0f4aed1eae618872ac8eb914b0602591f7d0b0", "author": {"user": {"login": "lorban", "name": "Ludovic Orban"}}, "url": "https://github.com/eclipse/jetty.project/commit/dd0f4aed1eae618872ac8eb914b0602591f7d0b0", "committedDate": "2020-04-14T13:44:31Z", "message": "refactor to minimize code changes vs Milestone 3\n\nSigned-off-by: Ludovic Orban <lorban@bitronix.be>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "dd0f4aed1eae618872ac8eb914b0602591f7d0b0", "author": {"user": {"login": "lorban", "name": "Ludovic Orban"}}, "url": "https://github.com/eclipse/jetty.project/commit/dd0f4aed1eae618872ac8eb914b0602591f7d0b0", "committedDate": "2020-04-14T13:44:31Z", "message": "refactor to minimize code changes vs Milestone 3\n\nSigned-off-by: Ludovic Orban <lorban@bitronix.be>"}, "afterCommit": {"oid": "d284fe9165e365002e9442b9d4f88e60fbda0ecc", "author": {"user": {"login": "lorban", "name": "Ludovic Orban"}}, "url": "https://github.com/eclipse/jetty.project/commit/d284fe9165e365002e9442b9d4f88e60fbda0ecc", "committedDate": "2020-04-15T09:39:16Z", "message": "refactor to minimize code changes vs Milestone 3\n\nSigned-off-by: Ludovic Orban <lorban@bitronix.be>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "d284fe9165e365002e9442b9d4f88e60fbda0ecc", "author": {"user": {"login": "lorban", "name": "Ludovic Orban"}}, "url": "https://github.com/eclipse/jetty.project/commit/d284fe9165e365002e9442b9d4f88e60fbda0ecc", "committedDate": "2020-04-15T09:39:16Z", "message": "refactor to minimize code changes vs Milestone 3\n\nSigned-off-by: Ludovic Orban <lorban@bitronix.be>"}, "afterCommit": {"oid": "5cde27ce38474bea46b20bcad754145a05908457", "author": {"user": {"login": "lorban", "name": "Ludovic Orban"}}, "url": "https://github.com/eclipse/jetty.project/commit/5cde27ce38474bea46b20bcad754145a05908457", "committedDate": "2020-04-15T13:05:33Z", "message": "better align HTTP 1 and 2 by introducing Stream.available()\n\nSigned-off-by: Ludovic Orban <lorban@bitronix.be>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "5cde27ce38474bea46b20bcad754145a05908457", "author": {"user": {"login": "lorban", "name": "Ludovic Orban"}}, "url": "https://github.com/eclipse/jetty.project/commit/5cde27ce38474bea46b20bcad754145a05908457", "committedDate": "2020-04-15T13:05:33Z", "message": "better align HTTP 1 and 2 by introducing Stream.available()\n\nSigned-off-by: Ludovic Orban <lorban@bitronix.be>"}, "afterCommit": {"oid": "c962ad964697a44d60c6acf8cb55683a9b1da973", "author": {"user": {"login": "lorban", "name": "Ludovic Orban"}}, "url": "https://github.com/eclipse/jetty.project/commit/c962ad964697a44d60c6acf8cb55683a9b1da973", "committedDate": "2020-07-07T08:00:44Z", "message": "better align HTTP 1 and 2 by introducing Stream.available()\n\nSigned-off-by: Ludovic Orban <lorban@bitronix.be>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "f54383aa3b760d6fa1df9b84777ed3a4165464ca", "author": {"user": {"login": "lorban", "name": "Ludovic Orban"}}, "url": "https://github.com/eclipse/jetty.project/commit/f54383aa3b760d6fa1df9b84777ed3a4165464ca", "committedDate": "2020-07-07T08:17:15Z", "message": "fix rebase\n\nSigned-off-by: Ludovic Orban <lorban@bitronix.be>"}, "afterCommit": {"oid": "040ec64bfd0f091101f917a8a276b9f621c5a0ce", "author": {"user": {"login": "lorban", "name": "Ludovic Orban"}}, "url": "https://github.com/eclipse/jetty.project/commit/040ec64bfd0f091101f917a8a276b9f621c5a0ce", "committedDate": "2020-08-11T07:57:16Z", "message": "implement http 1 needContent()\n\nSigned-off-by: Ludovic Orban <lorban@bitronix.be>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "040ec64bfd0f091101f917a8a276b9f621c5a0ce", "author": {"user": {"login": "lorban", "name": "Ludovic Orban"}}, "url": "https://github.com/eclipse/jetty.project/commit/040ec64bfd0f091101f917a8a276b9f621c5a0ce", "committedDate": "2020-08-11T07:57:16Z", "message": "implement http 1 needContent()\n\nSigned-off-by: Ludovic Orban <lorban@bitronix.be>"}, "afterCommit": {"oid": "14edc7abe51603dfcb4e604210db24d4cfe741ca", "author": {"user": {"login": "lorban", "name": "Ludovic Orban"}}, "url": "https://github.com/eclipse/jetty.project/commit/14edc7abe51603dfcb4e604210db24d4cfe741ca", "committedDate": "2020-08-11T09:18:33Z", "message": "implement needContent()\n\nSigned-off-by: Ludovic Orban <lorban@bitronix.be>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "14edc7abe51603dfcb4e604210db24d4cfe741ca", "author": {"user": {"login": "lorban", "name": "Ludovic Orban"}}, "url": "https://github.com/eclipse/jetty.project/commit/14edc7abe51603dfcb4e604210db24d4cfe741ca", "committedDate": "2020-08-11T09:18:33Z", "message": "implement needContent()\n\nSigned-off-by: Ludovic Orban <lorban@bitronix.be>"}, "afterCommit": {"oid": "3ebc68060188d5b0a8bb1ec85909d980f0d05ab7", "author": {"user": {"login": "lorban", "name": "Ludovic Orban"}}, "url": "https://github.com/eclipse/jetty.project/commit/3ebc68060188d5b0a8bb1ec85909d980f0d05ab7", "committedDate": "2020-08-11T09:27:40Z", "message": "implement needContent()\n\nSigned-off-by: Ludovic Orban <lorban@bitronix.be>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "3ebc68060188d5b0a8bb1ec85909d980f0d05ab7", "author": {"user": {"login": "lorban", "name": "Ludovic Orban"}}, "url": "https://github.com/eclipse/jetty.project/commit/3ebc68060188d5b0a8bb1ec85909d980f0d05ab7", "committedDate": "2020-08-11T09:27:40Z", "message": "implement needContent()\n\nSigned-off-by: Ludovic Orban <lorban@bitronix.be>"}, "afterCommit": {"oid": "49ac047a512ce0f4df95a30f3e393ff154011a2f", "author": {"user": {"login": "lorban", "name": "Ludovic Orban"}}, "url": "https://github.com/eclipse/jetty.project/commit/49ac047a512ce0f4df95a30f3e393ff154011a2f", "committedDate": "2020-08-11T09:28:31Z", "message": "implement needContent()\n\nSigned-off-by: Ludovic Orban <lorban@bitronix.be>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "53c0a8415311821703fca8da6f913f451da39fed", "author": {"user": {"login": "lorban", "name": "Ludovic Orban"}}, "url": "https://github.com/eclipse/jetty.project/commit/53c0a8415311821703fca8da6f913f451da39fed", "committedDate": "2020-08-11T10:42:03Z", "message": "move content production to ContentProducer\n\nSigned-off-by: Ludovic Orban <lorban@bitronix.be>"}, "afterCommit": {"oid": "12a38ac90e0c5a50cd7ba58657285e51badd07f9", "author": {"user": {"login": "lorban", "name": "Ludovic Orban"}}, "url": "https://github.com/eclipse/jetty.project/commit/12a38ac90e0c5a50cd7ba58657285e51badd07f9", "committedDate": "2020-08-11T12:06:14Z", "message": "move content production to ContentProducer\n\nSigned-off-by: Ludovic Orban <lorban@bitronix.be>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "1c1936e682b1a1f244fb5e33bf06c19a0dbe0a4e", "author": {"user": {"login": "lorban", "name": "Ludovic Orban"}}, "url": "https://github.com/eclipse/jetty.project/commit/1c1936e682b1a1f244fb5e33bf06c19a0dbe0a4e", "committedDate": "2020-08-11T13:49:04Z", "message": "fix http 1 failContent\n\nSigned-off-by: Ludovic Orban <lorban@bitronix.be>"}, "afterCommit": {"oid": "9ad742a9f2f00f6ff5561549cadc48178af9a59a", "author": {"user": {"login": "lorban", "name": "Ludovic Orban"}}, "url": "https://github.com/eclipse/jetty.project/commit/9ad742a9f2f00f6ff5561549cadc48178af9a59a", "committedDate": "2020-08-17T09:15:54Z", "message": "fix http 1 failContent\n\nSigned-off-by: Ludovic Orban <lorban@bitronix.be>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "df581027a7e83f01cbaab57c0f54f74d216c883d", "author": {"user": {"login": "lorban", "name": "Ludovic Orban"}}, "url": "https://github.com/eclipse/jetty.project/commit/df581027a7e83f01cbaab57c0f54f74d216c883d", "committedDate": "2020-08-17T12:05:58Z", "message": "implement http 2\n\nSigned-off-by: Ludovic Orban <lorban@bitronix.be>"}, "afterCommit": {"oid": "e3f5a69b116e77730436a5e183416740781e1045", "author": {"user": {"login": "lorban", "name": "Ludovic Orban"}}, "url": "https://github.com/eclipse/jetty.project/commit/e3f5a69b116e77730436a5e183416740781e1045", "committedDate": "2020-08-17T12:52:54Z", "message": "implement http 2\n\nSigned-off-by: Ludovic Orban <lorban@bitronix.be>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "435d0097987d7d9078963bd2f93a30c666edccd2", "author": {"user": {"login": "lorban", "name": "Ludovic Orban"}}, "url": "https://github.com/eclipse/jetty.project/commit/435d0097987d7d9078963bd2f93a30c666edccd2", "committedDate": "2020-08-18T09:08:11Z", "message": "move H2 data failure state from stream to channel\n\nSigned-off-by: Ludovic Orban <lorban@bitronix.be>"}, "afterCommit": {"oid": "8131020bba1e1eaccf386f3ac3e34ea59cd700fc", "author": {"user": {"login": "lorban", "name": "Ludovic Orban"}}, "url": "https://github.com/eclipse/jetty.project/commit/8131020bba1e1eaccf386f3ac3e34ea59cd700fc", "committedDate": "2020-08-18T10:02:44Z", "message": "get rid of HttpInput.addContent()\n\nSigned-off-by: Ludovic Orban <lorban@bitronix.be>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "8131020bba1e1eaccf386f3ac3e34ea59cd700fc", "author": {"user": {"login": "lorban", "name": "Ludovic Orban"}}, "url": "https://github.com/eclipse/jetty.project/commit/8131020bba1e1eaccf386f3ac3e34ea59cd700fc", "committedDate": "2020-08-18T10:02:44Z", "message": "get rid of HttpInput.addContent()\n\nSigned-off-by: Ludovic Orban <lorban@bitronix.be>"}, "afterCommit": {"oid": "1eea901c285a4ba02843267f50c8dde9825460e7", "author": {"user": {"login": "lorban", "name": "Ludovic Orban"}}, "url": "https://github.com/eclipse/jetty.project/commit/1eea901c285a4ba02843267f50c8dde9825460e7", "committedDate": "2020-08-18T11:07:38Z", "message": "get rid of HttpInput.addContent()\n\nSigned-off-by: Ludovic Orban <lorban@bitronix.be>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "7597e06adb36d50ddcab631c81ee8df7f9fd961b", "author": {"user": {"login": "lorban", "name": "Ludovic Orban"}}, "url": "https://github.com/eclipse/jetty.project/commit/7597e06adb36d50ddcab631c81ee8df7f9fd961b", "committedDate": "2020-08-18T15:50:29Z", "message": "tentative: remove 1st call to produceContent()\n\nSigned-off-by: Ludovic Orban <lorban@bitronix.be>"}, "afterCommit": {"oid": "c2cabb8df98ff33e6379b2b99f5f3ba9dff9ade4", "author": {"user": {"login": "lorban", "name": "Ludovic Orban"}}, "url": "https://github.com/eclipse/jetty.project/commit/c2cabb8df98ff33e6379b2b99f5f3ba9dff9ade4", "committedDate": "2020-08-19T08:18:40Z", "message": "javadoc and renaming\n\nSigned-off-by: Ludovic Orban <lorban@bitronix.be>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "c2cabb8df98ff33e6379b2b99f5f3ba9dff9ade4", "author": {"user": {"login": "lorban", "name": "Ludovic Orban"}}, "url": "https://github.com/eclipse/jetty.project/commit/c2cabb8df98ff33e6379b2b99f5f3ba9dff9ade4", "committedDate": "2020-08-19T08:18:40Z", "message": "javadoc and renaming\n\nSigned-off-by: Ludovic Orban <lorban@bitronix.be>"}, "afterCommit": {"oid": "614b4b092c836653d38d432e30f903c453843fea", "author": {"user": {"login": "lorban", "name": "Ludovic Orban"}}, "url": "https://github.com/eclipse/jetty.project/commit/614b4b092c836653d38d432e30f903c453843fea", "committedDate": "2020-08-24T13:26:49Z", "message": "make use of special content for EOF and errors\n\nSigned-off-by: Ludovic Orban <lorban@bitronix.be>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "614b4b092c836653d38d432e30f903c453843fea", "author": {"user": {"login": "lorban", "name": "Ludovic Orban"}}, "url": "https://github.com/eclipse/jetty.project/commit/614b4b092c836653d38d432e30f903c453843fea", "committedDate": "2020-08-24T13:26:49Z", "message": "make use of special content for EOF and errors\n\nSigned-off-by: Ludovic Orban <lorban@bitronix.be>"}, "afterCommit": {"oid": "ed47bc8dde6f5fd1df02bd6e78f714b295fab4d0", "author": {"user": {"login": "lorban", "name": "Ludovic Orban"}}, "url": "https://github.com/eclipse/jetty.project/commit/ed47bc8dde6f5fd1df02bd6e78f714b295fab4d0", "committedDate": "2020-08-24T14:44:51Z", "message": "new ContentProducer hierarchy\n\nSigned-off-by: Ludovic Orban <lorban@bitronix.be>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "ed47bc8dde6f5fd1df02bd6e78f714b295fab4d0", "author": {"user": {"login": "lorban", "name": "Ludovic Orban"}}, "url": "https://github.com/eclipse/jetty.project/commit/ed47bc8dde6f5fd1df02bd6e78f714b295fab4d0", "committedDate": "2020-08-24T14:44:51Z", "message": "new ContentProducer hierarchy\n\nSigned-off-by: Ludovic Orban <lorban@bitronix.be>"}, "afterCommit": {"oid": "c352c3cd093b0f0a581c1d415395b6d0c5fceee6", "author": {"user": {"login": "lorban", "name": "Ludovic Orban"}}, "url": "https://github.com/eclipse/jetty.project/commit/c352c3cd093b0f0a581c1d415395b6d0c5fceee6", "committedDate": "2020-08-24T14:53:29Z", "message": "new ContentProducer hierarchy\n\nSigned-off-by: Ludovic Orban <lorban@bitronix.be>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "c352c3cd093b0f0a581c1d415395b6d0c5fceee6", "author": {"user": {"login": "lorban", "name": "Ludovic Orban"}}, "url": "https://github.com/eclipse/jetty.project/commit/c352c3cd093b0f0a581c1d415395b6d0c5fceee6", "committedDate": "2020-08-24T14:53:29Z", "message": "new ContentProducer hierarchy\n\nSigned-off-by: Ludovic Orban <lorban@bitronix.be>"}, "afterCommit": {"oid": "38fa4d94b97c37daaf535c1755d83558cbab0dd4", "author": {"user": {"login": "lorban", "name": "Ludovic Orban"}}, "url": "https://github.com/eclipse/jetty.project/commit/38fa4d94b97c37daaf535c1755d83558cbab0dd4", "committedDate": "2020-08-24T15:40:20Z", "message": "new ContentProducer hierarchy\n\nSigned-off-by: Ludovic Orban <lorban@bitronix.be>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "38fa4d94b97c37daaf535c1755d83558cbab0dd4", "author": {"user": {"login": "lorban", "name": "Ludovic Orban"}}, "url": "https://github.com/eclipse/jetty.project/commit/38fa4d94b97c37daaf535c1755d83558cbab0dd4", "committedDate": "2020-08-24T15:40:20Z", "message": "new ContentProducer hierarchy\n\nSigned-off-by: Ludovic Orban <lorban@bitronix.be>"}, "afterCommit": {"oid": "cb80a4b0158c76d4a59f81f10cfe1fc556667cf9", "author": {"user": {"login": "lorban", "name": "Ludovic Orban"}}, "url": "https://github.com/eclipse/jetty.project/commit/cb80a4b0158c76d4a59f81f10cfe1fc556667cf9", "committedDate": "2020-08-25T15:01:27Z", "message": "make use of special content for EOF and errors (H2)\n\nSigned-off-by: Ludovic Orban <lorban@bitronix.be>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "8a20aaf2c77991c2bc42811c1918f0e41e2ffe34", "author": {"user": {"login": "lorban", "name": "Ludovic Orban"}}, "url": "https://github.com/eclipse/jetty.project/commit/8a20aaf2c77991c2bc42811c1918f0e41e2ffe34", "committedDate": "2020-08-26T09:03:34Z", "message": "fix H2 async content production\n\nSigned-off-by: Ludovic Orban <lorban@bitronix.be>"}, "afterCommit": {"oid": "9bb173dae87bc0f091c0ca71fed8e70d0ed12f56", "author": {"user": {"login": "lorban", "name": "Ludovic Orban"}}, "url": "https://github.com/eclipse/jetty.project/commit/9bb173dae87bc0f091c0ca71fed8e70d0ed12f56", "committedDate": "2020-08-26T11:45:21Z", "message": "new ContentProducer hierarchy\n\nSigned-off-by: Ludovic Orban <lorban@bitronix.be>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "f1a5347ee8f7ba2940b2db1108243b336cc3402c", "author": {"user": {"login": "lorban", "name": "Ludovic Orban"}}, "url": "https://github.com/eclipse/jetty.project/commit/f1a5347ee8f7ba2940b2db1108243b336cc3402c", "committedDate": "2020-09-10T13:40:58Z", "message": "re-introduce minimum request rate and raw bytes counting\n\nSigned-off-by: Ludovic Orban <lorban@bitronix.be>"}, "afterCommit": {"oid": "8d8e34e30f2c472d54d2af1441a489cd8a48ede9", "author": {"user": {"login": "lorban", "name": "Ludovic Orban"}}, "url": "https://github.com/eclipse/jetty.project/commit/8d8e34e30f2c472d54d2af1441a489cd8a48ede9", "committedDate": "2020-09-10T15:52:40Z", "message": "re-introduce minimum request rate and raw bytes counting\n\nSigned-off-by: Ludovic Orban <lorban@bitronix.be>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "f7f8ec5aaa63f81796cfe913e76fa33e60c4529c", "author": {"user": {"login": "lorban", "name": "Ludovic Orban"}}, "url": "https://github.com/eclipse/jetty.project/commit/f7f8ec5aaa63f81796cfe913e76fa33e60c4529c", "committedDate": "2020-09-11T13:05:59Z", "message": "fix FCGI\n\nSigned-off-by: Ludovic Orban <lorban@bitronix.be>"}, "afterCommit": {"oid": "4ebba92a3436c6279421b022664610f3f4d3f18f", "author": {"user": {"login": "lorban", "name": "Ludovic Orban"}}, "url": "https://github.com/eclipse/jetty.project/commit/4ebba92a3436c6279421b022664610f3f4d3f18f", "committedDate": "2020-09-14T06:42:42Z", "message": "fix FCGI\n\nSigned-off-by: Ludovic Orban <lorban@bitronix.be>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "71daebd70210427ad3ea41f78a4a956b6d31139f", "author": {"user": {"login": "lorban", "name": "Ludovic Orban"}}, "url": "https://github.com/eclipse/jetty.project/commit/71daebd70210427ad3ea41f78a4a956b6d31139f", "committedDate": "2020-09-14T07:02:45Z", "message": "fix tests\n\nSigned-off-by: Ludovic Orban <lorban@bitronix.be>"}, "afterCommit": {"oid": "e6db8272c7bda8a11a1d686039117124ccdf8d47", "author": {"user": {"login": "lorban", "name": "Ludovic Orban"}}, "url": "https://github.com/eclipse/jetty.project/commit/e6db8272c7bda8a11a1d686039117124ccdf8d47", "committedDate": "2020-09-16T13:07:50Z", "message": "enqueue special content together with normal content\n\nSigned-off-by: Ludovic Orban <lorban@bitronix.be>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "e6d0e73232764c7483a76ea9a710836a1bf3cc18", "author": {"user": {"login": "lorban", "name": "Ludovic Orban"}}, "url": "https://github.com/eclipse/jetty.project/commit/e6d0e73232764c7483a76ea9a710836a1bf3cc18", "committedDate": "2020-09-16T16:08:23Z", "message": "do not consume special content\n\nSigned-off-by: Ludovic Orban <lorban@bitronix.be>"}, "afterCommit": {"oid": "21169bb9c2cf6930e3f50145cd8cee994f294483", "author": {"user": {"login": "lorban", "name": "Ludovic Orban"}}, "url": "https://github.com/eclipse/jetty.project/commit/21169bb9c2cf6930e3f50145cd8cee994f294483", "committedDate": "2020-09-17T09:44:44Z", "message": "consumeAll must not modify the Channel state\n\nSigned-off-by: Ludovic Orban <lorban@bitronix.be>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "8ea2c1ed772be52a327bfbe888489024d49c7e53", "author": {"user": {"login": "lorban", "name": "Ludovic Orban"}}, "url": "https://github.com/eclipse/jetty.project/commit/8ea2c1ed772be52a327bfbe888489024d49c7e53", "committedDate": "2020-09-21T08:45:50Z", "message": "simplify code\n\nSigned-off-by: Ludovic Orban <lorban@bitronix.be>"}, "afterCommit": {"oid": "519760ddb6ab01944a3f0da1337be7825563e533", "author": {"user": {"login": "lorban", "name": "Ludovic Orban"}}, "url": "https://github.com/eclipse/jetty.project/commit/519760ddb6ab01944a3f0da1337be7825563e533", "committedDate": "2020-09-21T09:01:47Z", "message": "fix rebase\n\nSigned-off-by: Ludovic Orban <lorban@bitronix.be>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "74da3fa8637cbe6fd459ca7bbad1b314154b22c0", "author": {"user": {"login": "lorban", "name": "Ludovic Orban"}}, "url": "https://github.com/eclipse/jetty.project/commit/74da3fa8637cbe6fd459ca7bbad1b314154b22c0", "committedDate": "2020-09-21T14:19:34Z", "message": "fix testReadStarvation\n\nSigned-off-by: Ludovic Orban <lorban@bitronix.be>"}, "afterCommit": {"oid": "56aa53d5d301e518da8b829862a85b3078a92e3e", "author": {"user": {"login": "lorban", "name": "Ludovic Orban"}}, "url": "https://github.com/eclipse/jetty.project/commit/56aa53d5d301e518da8b829862a85b3078a92e3e", "committedDate": "2020-09-21T15:46:12Z", "message": "update state diagram\n\nSigned-off-by: Ludovic Orban <lorban@bitronix.be>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "529d0d0e8544262793c7150571c2abec19cc0858", "author": {"user": {"login": "lorban", "name": "Ludovic Orban"}}, "url": "https://github.com/eclipse/jetty.project/commit/529d0d0e8544262793c7150571c2abec19cc0858", "committedDate": "2020-09-22T16:53:30Z", "message": "read() should not trigger content demand\n\nSigned-off-by: Ludovic Orban <lorban@bitronix.be>"}, "afterCommit": {"oid": "2f343b98613f99e14fc9c4c2c96f2bf13c804243", "author": {"user": {"login": "lorban", "name": "Ludovic Orban"}}, "url": "https://github.com/eclipse/jetty.project/commit/2f343b98613f99e14fc9c4c2c96f2bf13c804243", "committedDate": "2020-09-22T16:55:09Z", "message": "read() should not trigger content demand\n\nSigned-off-by: Ludovic Orban <lorban@bitronix.be>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "3ef63d2531dde02120a3912c35e218e388b85ac3", "author": {"user": {"login": "lorban", "name": "Ludovic Orban"}}, "url": "https://github.com/eclipse/jetty.project/commit/3ef63d2531dde02120a3912c35e218e388b85ac3", "committedDate": "2020-09-29T11:46:52Z", "message": "fix test\n\nSigned-off-by: Ludovic Orban <lorban@bitronix.be>"}, "afterCommit": {"oid": "76f1997cb557fbc61f6a49239f52038c45af79d6", "author": {"user": {"login": "lorban", "name": "Ludovic Orban"}}, "url": "https://github.com/eclipse/jetty.project/commit/76f1997cb557fbc61f6a49239f52038c45af79d6", "committedDate": "2020-09-29T11:48:40Z", "message": "fix test\n\nSigned-off-by: Ludovic Orban <lorban@bitronix.be>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "a902629ed54cde77879c29a72a82fe606f161417", "author": {"user": {"login": "lorban", "name": "Ludovic Orban"}}, "url": "https://github.com/eclipse/jetty.project/commit/a902629ed54cde77879c29a72a82fe606f161417", "committedDate": "2020-09-30T13:31:06Z", "message": "add channel state diagrams\n\nSigned-off-by: Ludovic Orban <lorban@bitronix.be>"}, "afterCommit": {"oid": "f04217513884ab0c82df112a5dc6ff37c42f645b", "author": {"user": {"login": "lorban", "name": "Ludovic Orban"}}, "url": "https://github.com/eclipse/jetty.project/commit/f04217513884ab0c82df112a5dc6ff37c42f645b", "committedDate": "2020-09-30T14:51:39Z", "message": "add channel state diagrams\n\nSigned-off-by: Ludovic Orban <lorban@bitronix.be>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "05b7defcc7b63da2ab076a0c21b16a45e1ae149d", "author": {"user": {"login": "lorban", "name": "Ludovic Orban"}}, "url": "https://github.com/eclipse/jetty.project/commit/05b7defcc7b63da2ab076a0c21b16a45e1ae149d", "committedDate": "2020-09-30T15:25:00Z", "message": "cleanups\n\nSigned-off-by: Ludovic Orban <lorban@bitronix.be>"}, "afterCommit": {"oid": "d2b3c42a9bbecef9322169f82f0cb2df65248b99", "author": {"user": {"login": "lorban", "name": "Ludovic Orban"}}, "url": "https://github.com/eclipse/jetty.project/commit/d2b3c42a9bbecef9322169f82f0cb2df65248b99", "committedDate": "2020-10-01T09:55:35Z", "message": "cleanups\n\nSigned-off-by: Ludovic Orban <lorban@bitronix.be>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "0ee574b0166f9881c9a010b57b0a40d8f6a041ba", "author": {"user": {"login": "lorban", "name": "Ludovic Orban"}}, "url": "https://github.com/eclipse/jetty.project/commit/0ee574b0166f9881c9a010b57b0a40d8f6a041ba", "committedDate": "2020-10-05T11:02:54Z", "message": "is a different wakeup required at EOF?\n\nSigned-off-by: Ludovic Orban <lorban@bitronix.be>"}, "afterCommit": {"oid": "80b56f3e8b1538d83c70a78fd9d4e47032e555d9", "author": {"user": {"login": "lorban", "name": "Ludovic Orban"}}, "url": "https://github.com/eclipse/jetty.project/commit/80b56f3e8b1538d83c70a78fd9d4e47032e555d9", "committedDate": "2020-10-05T11:29:38Z", "message": "is a different wakeup required at EOF?\n\nSigned-off-by: Ludovic Orban <lorban@bitronix.be>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "465e059594a84507e59c6718e4b8bd2ede085101", "author": {"user": {"login": "lorban", "name": "Ludovic Orban"}}, "url": "https://github.com/eclipse/jetty.project/commit/465e059594a84507e59c6718e4b8bd2ede085101", "committedDate": "2020-10-06T10:34:47Z", "message": "cleanup queue demander implementation\n\nSigned-off-by: Ludovic Orban <lorban@bitronix.be>"}, "afterCommit": {"oid": "2ad82e8e2c0e8a82c2be89552a4ffd457ea9b791", "author": {"user": {"login": "lorban", "name": "Ludovic Orban"}}, "url": "https://github.com/eclipse/jetty.project/commit/2ad82e8e2c0e8a82c2be89552a4ffd457ea9b791", "committedDate": "2020-10-06T13:59:10Z", "message": "make some HttpChannel methods abstract\n\nSigned-off-by: Ludovic Orban <lorban@bitronix.be>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA2NTAxOTc3", "url": "https://github.com/eclipse/jetty.project/pull/4556#pullrequestreview-506501977", "createdAt": "2020-10-12T10:38:57Z", "commit": {"oid": "24bbc717dd41dee613298b0b71d35ed35a556e61"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xMlQxMDozODo1N1rOHf5HUw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xMlQxMDo0MDo1NlrOHf5LRg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzIwMzY2Nw==", "bodyText": "I don't think we need both implementations now.  Let's just go for the atomic one, so we can probably get rid of the interface.", "url": "https://github.com/eclipse/jetty.project/pull/4556#discussion_r503203667", "createdAt": "2020-10-12T10:38:57Z", "author": {"login": "gregw"}, "path": "jetty-http2/http2-server/src/main/java/org/eclipse/jetty/http2/server/HttpChannelOverHTTP2.java", "diffHunk": "@@ -261,31 +268,408 @@ public InvocationType getInvocationType()\n             {\n                 return callback.getInvocationType();\n             }\n-        });\n+        };\n+        _contentDemander.onContent(content);\n+        boolean handle = onContent(content);\n \n         boolean endStream = frame.isEndStream();\n         if (endStream)\n         {\n             boolean handleContent = onContentComplete();\n+            // this will generate EOF -> must happen before wakeup\n             boolean handleRequest = onRequestComplete();\n             handle |= handleContent | handleRequest;\n         }\n \n+        boolean woken = getRequest().getHttpInput().wakeup();\n         if (LOG.isDebugEnabled())\n         {\n-            LOG.debug(\"HTTP2 Request #{}/{}: {} bytes of {} content, handle: {}\",\n+            Stream stream = getStream();\n+            LOG.debug(\"HTTP2 Request #{}/{}: {} bytes of {} content, woken: {}, handle: {}\",\n                     stream.getId(),\n                     Integer.toHexString(stream.getSession().hashCode()),\n                     length,\n                     endStream ? \"last\" : \"some\",\n+                    woken,\n                     handle);\n         }\n+        handle |= woken;\n \n         boolean wasDelayed = _delayedUntilContent;\n         _delayedUntilContent = false;\n         return handle || wasDelayed ? this : null;\n     }\n \n+    private interface ContentDemander", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "24bbc717dd41dee613298b0b71d35ed35a556e61"}, "originalPosition": 134}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzIwMzk0NA==", "bodyText": "Can we remove the Tracer from all code now", "url": "https://github.com/eclipse/jetty.project/pull/4556#discussion_r503203944", "createdAt": "2020-10-12T10:39:32Z", "author": {"login": "gregw"}, "path": "jetty-http2/http2-server/src/main/java/org/eclipse/jetty/http2/server/HttpChannelOverHTTP2.java", "diffHunk": "@@ -261,31 +268,408 @@ public InvocationType getInvocationType()\n             {\n                 return callback.getInvocationType();\n             }\n-        });\n+        };\n+        _contentDemander.onContent(content);\n+        boolean handle = onContent(content);\n \n         boolean endStream = frame.isEndStream();\n         if (endStream)\n         {\n             boolean handleContent = onContentComplete();\n+            // this will generate EOF -> must happen before wakeup\n             boolean handleRequest = onRequestComplete();\n             handle |= handleContent | handleRequest;\n         }\n \n+        boolean woken = getRequest().getHttpInput().wakeup();\n         if (LOG.isDebugEnabled())\n         {\n-            LOG.debug(\"HTTP2 Request #{}/{}: {} bytes of {} content, handle: {}\",\n+            Stream stream = getStream();\n+            LOG.debug(\"HTTP2 Request #{}/{}: {} bytes of {} content, woken: {}, handle: {}\",\n                     stream.getId(),\n                     Integer.toHexString(stream.getSession().hashCode()),\n                     length,\n                     endStream ? \"last\" : \"some\",\n+                    woken,\n                     handle);\n         }\n+        handle |= woken;\n \n         boolean wasDelayed = _delayedUntilContent;\n         _delayedUntilContent = false;\n         return handle || wasDelayed ? this : null;\n     }\n \n+    private interface ContentDemander\n+    {\n+        void eof();\n+\n+        void recycle();\n+\n+        HttpInput.Content take();\n+\n+        boolean demand();\n+\n+        void onContent(HttpInput.Content content);\n+\n+        boolean onTimeout(Throwable failure);\n+\n+        void failContent(Throwable failure);\n+    }\n+\n+    private class ContentDemanderQueue implements ContentDemander\n+    {\n+        private boolean _demanding;\n+        private final Queue<HttpInput.Content> _contentQueue = new LinkedList<>();\n+\n+        @Override\n+        public synchronized void recycle()\n+        {\n+            _contentQueue.forEach(c ->\n+            {\n+                if (!c.isSpecial())\n+                    throw new AssertionError(\"unconsumed content: \" + _contentQueue);\n+            });\n+            _demanding = false;\n+            _contentQueue.clear();\n+        }\n+\n+        @Override\n+        public synchronized HttpInput.Content take()\n+        {\n+            HttpInput.Content c = _contentQueue.peek();\n+            if (c != null && !c.isSpecial())\n+            {\n+                _contentQueue.poll();\n+                if (c.isEof())\n+                    _contentQueue.add(EOF);\n+            }\n+            return c;\n+        }\n+\n+        @Override\n+        public synchronized boolean demand()\n+        {\n+            if (!_contentQueue.isEmpty())\n+                return true;\n+            if (!_demanding)\n+            {\n+                _demanding = true;\n+                IStream stream = getStream();\n+                if (stream == null)\n+                    _demanding = false;\n+                else\n+                    stream.demand(1);\n+            }\n+            return !_contentQueue.isEmpty();\n+        }\n+\n+        @Override\n+        public synchronized void onContent(HttpInput.Content content)\n+        {\n+            _demanding = false; // TODO maybe distinguish between upstream content and downstream errors\n+            if (content.isEof() && content.isSpecial() && content.isEmpty() && _contentQueue.size() == 1 && _contentQueue.peek().isEof())\n+            {\n+                content.succeeded();\n+                return;\n+            }\n+\n+            // error content fails and replaces any other content\n+            Throwable x = content.getError();\n+            if (x != null)\n+            {\n+                _contentQueue.forEach(c -> c.failed(x));\n+                _contentQueue.clear();\n+            }\n+\n+            _contentQueue.offer(content);\n+            if (_contentQueue.size() > 1)\n+                throw new AssertionError(\"Queue should never be more than 1: \" + _contentQueue);\n+        }\n+\n+        @Override\n+        public synchronized boolean onTimeout(Throwable failure)\n+        {\n+            if (_demanding && _contentQueue.isEmpty())\n+            {\n+                _demanding = false;\n+                _contentQueue.add(new HttpInput.ErrorContent(failure));\n+                return true;\n+            }\n+            return false;\n+        }\n+\n+        @Override\n+        public synchronized void eof()\n+        {\n+            if (LOG.isDebugEnabled())\n+                LOG.debug(\"received EOF\");\n+\n+            if (_contentQueue.size() != 1 || !_contentQueue.peek().isEof())\n+                _contentQueue.add(EOF);\n+        }\n+\n+        @Override\n+        public synchronized void failContent(Throwable failure)\n+        {\n+            for (Iterator<HttpInput.Content> i = _contentQueue.iterator(); i.hasNext();)\n+            {\n+                HttpInput.Content c = i.next();\n+                if (!c.isSpecial())\n+                {\n+                    i.remove();\n+                    c.failed(failure);\n+                }\n+            }\n+        }\n+    }\n+\n+    private static final HttpInput.Content EOF = new HttpInput.EofContent();\n+    private static final HttpInput.Content DEMANDING = new HttpInput.SpecialContent() {};\n+\n+    private class ContentDemanderAtomic implements ContentDemander\n+    {\n+        private final AtomicReference<HttpInput.Content> _content = new AtomicReference<>();\n+\n+        @Override\n+        public void recycle()\n+        {\n+            HttpInput.Content c = _content.getAndSet(null);\n+            if (c != null && !c.isSpecial())\n+                throw new AssertionError(\"unconsumed content: \" + c);\n+        }\n+\n+        @Override\n+        public HttpInput.Content take()\n+        {\n+            while (true)\n+            {\n+                HttpInput.Content c = _content.get();\n+                if (c == null || c.isSpecial() || _content.compareAndSet(c, c.isEof() ? EOF : null))\n+                    return c;\n+            }\n+        }\n+\n+        @Override\n+        public boolean demand()\n+        {\n+            while (true)\n+            {\n+                HttpInput.Content c = _content.get();\n+                if (c == DEMANDING)\n+                    return false;\n+                if (c != null)\n+                    return true;\n+                if (_content.compareAndSet(null, DEMANDING))\n+                {\n+                    IStream stream = getStream();\n+                    if (stream == null)\n+                    {\n+                        _content.set(null);\n+                        return false;\n+                    }\n+                    stream.demand(1);\n+                    c = _content.get();\n+                    return c != DEMANDING && c != null;\n+                }\n+            }\n+        }\n+\n+        @Override\n+        public void onContent(HttpInput.Content content)\n+        {\n+            while (true)\n+            {\n+                HttpInput.Content c = _content.get();\n+                if (c == DEMANDING)\n+                {\n+                    if (_content.compareAndSet(DEMANDING, content))\n+                        return;\n+                }\n+                else if (c == null)\n+                {\n+                    if (!content.isSpecial())\n+                        throw new AssertionError(\"Non special content without demand\");\n+                    if (_content.compareAndSet(null, content))\n+                        return;\n+                }\n+                else if (c.isEof() && content.isEof() && content.isEmpty())\n+                {\n+                    content.succeeded();\n+                    return;\n+                }\n+                else if (content.getError() != null)\n+                {\n+                    if (c.getError() != null)\n+                    {\n+                        if (c.getError() != content.getError())\n+                            c.getError().addSuppressed(content.getError());\n+                        return;\n+                    }\n+                    if (_content.compareAndSet(c, content))\n+                    {\n+                        c.failed(content.getError());\n+                        return;\n+                    }\n+                }\n+                else if (c.getError() != null && content.remaining() == 0)\n+                {\n+                    content.succeeded();\n+                    return;\n+                }\n+                else\n+                {\n+                    throw new IllegalStateException(\"Cannot overwrite exiting content \" + c + \" with \" + content);\n+                }\n+            }\n+        }\n+\n+        @Override\n+        public boolean onTimeout(Throwable failure)\n+        {\n+            while (true)\n+            {\n+                HttpInput.Content c = _content.get();\n+                if (c != DEMANDING)\n+                    return false;\n+                if (_content.compareAndSet(DEMANDING, new HttpInput.ErrorContent(failure)))\n+                    return true;\n+            }\n+        }\n+\n+        @Override\n+        public void eof()\n+        {\n+            while (true)\n+            {\n+                HttpInput.Content c = _content.get();\n+                if (c == DEMANDING)\n+                {\n+                    if (_content.compareAndSet(DEMANDING, EOF))\n+                        return;\n+                }\n+                else if (c == null)\n+                {\n+                    if (_content.compareAndSet(null, EOF))\n+                        return;\n+                }\n+                else if (c.isEof())\n+                {\n+                    return;\n+                }\n+                else if (c.remaining() == 0)\n+                {\n+                    if (_content.compareAndSet(c, EOF))\n+                        return;\n+                }\n+                else\n+                {\n+                    HttpInput.Content content = new HttpInput.Content(c.getByteBuffer())\n+                    {\n+                        @Override\n+                        public boolean isEof()\n+                        {\n+                            return true;\n+                        }\n+\n+                        @Override\n+                        public void succeeded()\n+                        {\n+                            c.succeeded();\n+                        }\n+\n+                        @Override\n+                        public void failed(Throwable x)\n+                        {\n+                            c.failed(x);\n+                        }\n+\n+                        @Override\n+                        public InvocationType getInvocationType()\n+                        {\n+                            return c.getInvocationType();\n+                        }\n+                    };\n+                    if (_content.compareAndSet(c, content))\n+                        return;\n+                }\n+            }\n+        }\n+\n+        @Override\n+        public void failContent(Throwable failure)\n+        {\n+            while (true)\n+            {\n+                HttpInput.Content c = _content.get();\n+                if (c == null || c.isSpecial())\n+                    return;\n+                if (_content.compareAndSet(c, null))\n+                {\n+                    c.failed(failure);\n+                    return;\n+                }\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public boolean needContent()\n+    {\n+        Tracer.in();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "24bbc717dd41dee613298b0b71d35ed35a556e61"}, "originalPosition": 450}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzIwNDY3OA==", "bodyText": "We need a puml interaction diagram and/or state diagram for this state machine!", "url": "https://github.com/eclipse/jetty.project/pull/4556#discussion_r503204678", "createdAt": "2020-10-12T10:40:56Z", "author": {"login": "gregw"}, "path": "jetty-http2/http2-server/src/main/java/org/eclipse/jetty/http2/server/HttpChannelOverHTTP2.java", "diffHunk": "@@ -261,31 +268,408 @@ public InvocationType getInvocationType()\n             {\n                 return callback.getInvocationType();\n             }\n-        });\n+        };\n+        _contentDemander.onContent(content);\n+        boolean handle = onContent(content);\n \n         boolean endStream = frame.isEndStream();\n         if (endStream)\n         {\n             boolean handleContent = onContentComplete();\n+            // this will generate EOF -> must happen before wakeup\n             boolean handleRequest = onRequestComplete();\n             handle |= handleContent | handleRequest;\n         }\n \n+        boolean woken = getRequest().getHttpInput().wakeup();\n         if (LOG.isDebugEnabled())\n         {\n-            LOG.debug(\"HTTP2 Request #{}/{}: {} bytes of {} content, handle: {}\",\n+            Stream stream = getStream();\n+            LOG.debug(\"HTTP2 Request #{}/{}: {} bytes of {} content, woken: {}, handle: {}\",\n                     stream.getId(),\n                     Integer.toHexString(stream.getSession().hashCode()),\n                     length,\n                     endStream ? \"last\" : \"some\",\n+                    woken,\n                     handle);\n         }\n+        handle |= woken;\n \n         boolean wasDelayed = _delayedUntilContent;\n         _delayedUntilContent = false;\n         return handle || wasDelayed ? this : null;\n     }\n \n+    private interface ContentDemander\n+    {\n+        void eof();\n+\n+        void recycle();\n+\n+        HttpInput.Content take();\n+\n+        boolean demand();\n+\n+        void onContent(HttpInput.Content content);\n+\n+        boolean onTimeout(Throwable failure);\n+\n+        void failContent(Throwable failure);\n+    }\n+\n+    private class ContentDemanderQueue implements ContentDemander\n+    {\n+        private boolean _demanding;\n+        private final Queue<HttpInput.Content> _contentQueue = new LinkedList<>();\n+\n+        @Override\n+        public synchronized void recycle()\n+        {\n+            _contentQueue.forEach(c ->\n+            {\n+                if (!c.isSpecial())\n+                    throw new AssertionError(\"unconsumed content: \" + _contentQueue);\n+            });\n+            _demanding = false;\n+            _contentQueue.clear();\n+        }\n+\n+        @Override\n+        public synchronized HttpInput.Content take()\n+        {\n+            HttpInput.Content c = _contentQueue.peek();\n+            if (c != null && !c.isSpecial())\n+            {\n+                _contentQueue.poll();\n+                if (c.isEof())\n+                    _contentQueue.add(EOF);\n+            }\n+            return c;\n+        }\n+\n+        @Override\n+        public synchronized boolean demand()\n+        {\n+            if (!_contentQueue.isEmpty())\n+                return true;\n+            if (!_demanding)\n+            {\n+                _demanding = true;\n+                IStream stream = getStream();\n+                if (stream == null)\n+                    _demanding = false;\n+                else\n+                    stream.demand(1);\n+            }\n+            return !_contentQueue.isEmpty();\n+        }\n+\n+        @Override\n+        public synchronized void onContent(HttpInput.Content content)\n+        {\n+            _demanding = false; // TODO maybe distinguish between upstream content and downstream errors\n+            if (content.isEof() && content.isSpecial() && content.isEmpty() && _contentQueue.size() == 1 && _contentQueue.peek().isEof())\n+            {\n+                content.succeeded();\n+                return;\n+            }\n+\n+            // error content fails and replaces any other content\n+            Throwable x = content.getError();\n+            if (x != null)\n+            {\n+                _contentQueue.forEach(c -> c.failed(x));\n+                _contentQueue.clear();\n+            }\n+\n+            _contentQueue.offer(content);\n+            if (_contentQueue.size() > 1)\n+                throw new AssertionError(\"Queue should never be more than 1: \" + _contentQueue);\n+        }\n+\n+        @Override\n+        public synchronized boolean onTimeout(Throwable failure)\n+        {\n+            if (_demanding && _contentQueue.isEmpty())\n+            {\n+                _demanding = false;\n+                _contentQueue.add(new HttpInput.ErrorContent(failure));\n+                return true;\n+            }\n+            return false;\n+        }\n+\n+        @Override\n+        public synchronized void eof()\n+        {\n+            if (LOG.isDebugEnabled())\n+                LOG.debug(\"received EOF\");\n+\n+            if (_contentQueue.size() != 1 || !_contentQueue.peek().isEof())\n+                _contentQueue.add(EOF);\n+        }\n+\n+        @Override\n+        public synchronized void failContent(Throwable failure)\n+        {\n+            for (Iterator<HttpInput.Content> i = _contentQueue.iterator(); i.hasNext();)\n+            {\n+                HttpInput.Content c = i.next();\n+                if (!c.isSpecial())\n+                {\n+                    i.remove();\n+                    c.failed(failure);\n+                }\n+            }\n+        }\n+    }\n+\n+    private static final HttpInput.Content EOF = new HttpInput.EofContent();\n+    private static final HttpInput.Content DEMANDING = new HttpInput.SpecialContent() {};\n+\n+    private class ContentDemanderAtomic implements ContentDemander\n+    {\n+        private final AtomicReference<HttpInput.Content> _content = new AtomicReference<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "24bbc717dd41dee613298b0b71d35ed35a556e61"}, "originalPosition": 263}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "24bbc717dd41dee613298b0b71d35ed35a556e61", "author": {"user": {"login": "lorban", "name": "Ludovic Orban"}}, "url": "https://github.com/eclipse/jetty.project/commit/24bbc717dd41dee613298b0b71d35ed35a556e61", "committedDate": "2020-10-07T16:33:27Z", "message": "remove System.err logs\n\nSigned-off-by: Ludovic Orban <lorban@bitronix.be>"}, "afterCommit": {"oid": "82919412dbd87260462ec3127cd57d9ffbe1c73f", "author": {"user": {"login": "lorban", "name": "Ludovic Orban"}}, "url": "https://github.com/eclipse/jetty.project/commit/82919412dbd87260462ec3127cd57d9ffbe1c73f", "committedDate": "2020-10-12T12:06:42Z", "message": "remove tracer\n\nSigned-off-by: Ludovic Orban <lorban@bitronix.be>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA2NzUzNDM3", "url": "https://github.com/eclipse/jetty.project/pull/4556#pullrequestreview-506753437", "createdAt": "2020-10-12T16:14:14Z", "commit": {"oid": "e86ce0103c9041952160e0cacbf48acde3f0ea60"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xMlQxNjoxNDoxNFrOHgFCPQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xMlQxNjoxNDoxNFrOHgFCPQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzM5ODk3Mw==", "bodyText": "ALERT ALERT ALERT!!!!!!\nOMG a queue!!!!!!!!!!!\n:)", "url": "https://github.com/eclipse/jetty.project/pull/4556#discussion_r503398973", "createdAt": "2020-10-12T16:14:14Z", "author": {"login": "gregw"}, "path": "jetty-fcgi/fcgi-server/src/main/java/org/eclipse/jetty/fcgi/server/HttpChannelOverFCGI.java", "diffHunk": "@@ -43,6 +46,8 @@\n {\n     private static final Logger LOG = LoggerFactory.getLogger(HttpChannelOverFCGI.class);\n \n+    private final Queue<HttpInput.Content> _contentQueue = new LinkedList<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e86ce0103c9041952160e0cacbf48acde3f0ea60"}, "originalPosition": 22}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA2NzU0Nzk3", "url": "https://github.com/eclipse/jetty.project/pull/4556#pullrequestreview-506754797", "createdAt": "2020-10-12T16:16:16Z", "commit": {"oid": "e86ce0103c9041952160e0cacbf48acde3f0ea60"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xMlQxNjoxNjoxNlrOHgFGnw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xMlQxNjoxNjoxNlrOHgFGnw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzQwMDA5NQ==", "bodyText": "Why?", "url": "https://github.com/eclipse/jetty.project/pull/4556#discussion_r503400095", "createdAt": "2020-10-12T16:16:16Z", "author": {"login": "gregw"}, "path": "jetty-http2/http2-common/src/main/java/org/eclipse/jetty/http2/HTTP2StreamEndPoint.java", "diffHunk": "@@ -611,6 +610,7 @@ private IOException ioFailure()\n         private void succeed()\n         {\n             callback.succeeded();\n+            stream.demand(1);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e86ce0103c9041952160e0cacbf48acde3f0ea60"}, "originalPosition": 33}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA2NzU2NzYz", "url": "https://github.com/eclipse/jetty.project/pull/4556#pullrequestreview-506756763", "createdAt": "2020-10-12T16:19:08Z", "commit": {"oid": "e86ce0103c9041952160e0cacbf48acde3f0ea60"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xMlQxNjoxOTowOFrOHgFM1A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xMlQxNjoxOTowOFrOHgFM1A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzQwMTY4NA==", "bodyText": "what about onContent, onTimeout etc?", "url": "https://github.com/eclipse/jetty.project/pull/4556#discussion_r503401684", "createdAt": "2020-10-12T16:19:08Z", "author": {"login": "gregw"}, "path": "jetty-http2/http2-server/src/main/java/org/eclipse/jetty/http2/server/ContentDemander_state.puml", "diffHunk": "@@ -0,0 +1,25 @@\n+@startuml\n+\n+null:\n+content:\n+DEMANDING:\n+EOF:\n+\n+[*] --> null\n+\n+null --> DEMANDING : demand()\n+null --> EOF : eof()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e86ce0103c9041952160e0cacbf48acde3f0ea60"}, "originalPosition": 11}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA2NzU4MjQz", "url": "https://github.com/eclipse/jetty.project/pull/4556#pullrequestreview-506758243", "createdAt": "2020-10-12T16:21:18Z", "commit": {"oid": "e86ce0103c9041952160e0cacbf48acde3f0ea60"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xMlQxNjoyMToxOFrOHgFRhw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xMlQxNjoyMToxOFrOHgFRhw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzQwMjg4Nw==", "bodyText": "Need a comment somewhere saying why atomics/volatiles/locks are not needed in this class", "url": "https://github.com/eclipse/jetty.project/pull/4556#discussion_r503402887", "createdAt": "2020-10-12T16:21:18Z", "author": {"login": "gregw"}, "path": "jetty-server/src/main/java/org/eclipse/jetty/server/HttpChannelOverHttp.java", "diffHunk": "@@ -75,6 +78,55 @@ public void abort(Throwable failure)\n         _httpConnection.getGenerator().setPersistent(false);\n     }\n \n+    @Override\n+    public boolean needContent()\n+    {\n+        if (_specialContent != null || _content != null)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e86ce0103c9041952160e0cacbf48acde3f0ea60"}, "originalPosition": 24}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA2NzU4Njky", "url": "https://github.com/eclipse/jetty.project/pull/4556#pullrequestreview-506758692", "createdAt": "2020-10-12T16:21:59Z", "commit": {"oid": "e86ce0103c9041952160e0cacbf48acde3f0ea60"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xMlQxNjoyMTo1OVrOHgFTBg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xMlQxNjoyMTo1OVrOHgFTBg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzQwMzI3MA==", "bodyText": "remove XXXs", "url": "https://github.com/eclipse/jetty.project/pull/4556#discussion_r503403270", "createdAt": "2020-10-12T16:21:59Z", "author": {"login": "gregw"}, "path": "jetty-server/src/main/java/org/eclipse/jetty/server/HttpChannelOverHttp.java", "diffHunk": "@@ -75,6 +78,55 @@ public void abort(Throwable failure)\n         _httpConnection.getGenerator().setPersistent(false);\n     }\n \n+    @Override\n+    public boolean needContent()\n+    {\n+        if (_specialContent != null || _content != null)\n+        {\n+            if (LOG.isDebugEnabled())\n+                LOG.debug(\"needContent has content immediately available: c={} sc={}\", _content, _specialContent);\n+            return true;\n+        }\n+        _httpConnection.parseAndFillForContent();\n+        if (_specialContent != null || _content != null)\n+        {\n+            if (LOG.isDebugEnabled())\n+                LOG.debug(\"needContent has content after parseAndFillForContent: c={} sc={}\", _content, _specialContent);\n+            return true;\n+        }\n+\n+        if (LOG.isDebugEnabled())\n+            LOG.debug(\"needContent has no content\");\n+        _httpConnection.asyncReadFillInterested();\n+        return false;\n+    }\n+\n+    @Override\n+    public HttpInput.Content produceContent()\n+    {\n+        // XXX if (_content == null && _specialContent == null)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e86ce0103c9041952160e0cacbf48acde3f0ea60"}, "originalPosition": 47}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "e86ce0103c9041952160e0cacbf48acde3f0ea60", "author": {"user": {"login": "lorban", "name": "Ludovic Orban"}}, "url": "https://github.com/eclipse/jetty.project/commit/e86ce0103c9041952160e0cacbf48acde3f0ea60", "committedDate": "2020-10-12T12:31:21Z", "message": "ContentDemander state diagram\n\nSigned-off-by: Ludovic Orban <lorban@bitronix.be>"}, "afterCommit": {"oid": "46d881adf81e66f15e036ff668c0e596236da0bc", "author": {"user": {"login": "lorban", "name": "Ludovic Orban"}}, "url": "https://github.com/eclipse/jetty.project/commit/46d881adf81e66f15e036ff668c0e596236da0bc", "committedDate": "2020-10-13T08:28:00Z", "message": "changes after review #1\n\nSigned-off-by: Ludovic Orban <lorban@bitronix.be>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "f4f389dda2c179cf171cf4fe1a1c0d34181fd30f", "author": {"user": {"login": "lorban", "name": "Ludovic Orban"}}, "url": "https://github.com/eclipse/jetty.project/commit/f4f389dda2c179cf171cf4fe1a1c0d34181fd30f", "committedDate": "2020-10-13T11:51:31Z", "message": "revert demand on Entry.succeed\n\nSigned-off-by: Ludovic Orban <lorban@bitronix.be>"}, "afterCommit": {"oid": "273213e8df4f438bf853787ec932e22424e7fe8b", "author": {"user": {"login": "lorban", "name": "Ludovic Orban"}}, "url": "https://github.com/eclipse/jetty.project/commit/273213e8df4f438bf853787ec932e22424e7fe8b", "committedDate": "2020-10-13T15:22:08Z", "message": "move demand out of Entry.succeed and comment explaining why it must be explicitly called\n\nSigned-off-by: Ludovic Orban <lorban@bitronix.be>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA4NzQ5MTE2", "url": "https://github.com/eclipse/jetty.project/pull/4556#pullrequestreview-508749116", "createdAt": "2020-10-14T21:22:06Z", "commit": {"oid": "273213e8df4f438bf853787ec932e22424e7fe8b"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNFQyMToyMjowN1rOHhlgmg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNFQyMToyMjo1MFrOHhliAQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDk3OTYxMA==", "bodyText": "javadoc please", "url": "https://github.com/eclipse/jetty.project/pull/4556#discussion_r504979610", "createdAt": "2020-10-14T21:22:07Z", "author": {"login": "gregw"}, "path": "jetty-server/src/main/java/org/eclipse/jetty/server/BlockingContentProducer.java", "diffHunk": "@@ -0,0 +1,133 @@\n+//\n+// ========================================================================\n+// Copyright (c) 1995-2020 Mort Bay Consulting Pty Ltd and others.\n+//\n+// This program and the accompanying materials are made available under\n+// the terms of the Eclipse Public License 2.0 which is available at\n+// https://www.eclipse.org/legal/epl-2.0\n+//\n+// This Source Code may also be made available under the following\n+// Secondary Licenses when the conditions for such availability set\n+// forth in the Eclipse Public License, v. 2.0 are satisfied:\n+// the Apache License v2.0 which is available at\n+// https://www.apache.org/licenses/LICENSE-2.0\n+//\n+// SPDX-License-Identifier: EPL-2.0 OR Apache-2.0\n+// ========================================================================\n+//\n+\n+package org.eclipse.jetty.server;\n+\n+import java.util.concurrent.Semaphore;\n+\n+class BlockingContentProducer implements ContentProducer", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "273213e8df4f438bf853787ec932e22424e7fe8b"}, "originalPosition": 23}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDk3OTk2OQ==", "bodyText": "I really REALLY don't like having drainPermits.  This should not be necessary", "url": "https://github.com/eclipse/jetty.project/pull/4556#discussion_r504979969", "createdAt": "2020-10-14T21:22:50Z", "author": {"login": "gregw"}, "path": "jetty-server/src/main/java/org/eclipse/jetty/server/BlockingContentProducer.java", "diffHunk": "@@ -0,0 +1,133 @@\n+//\n+// ========================================================================\n+// Copyright (c) 1995-2020 Mort Bay Consulting Pty Ltd and others.\n+//\n+// This program and the accompanying materials are made available under\n+// the terms of the Eclipse Public License 2.0 which is available at\n+// https://www.eclipse.org/legal/epl-2.0\n+//\n+// This Source Code may also be made available under the following\n+// Secondary Licenses when the conditions for such availability set\n+// forth in the Eclipse Public License, v. 2.0 are satisfied:\n+// the Apache License v2.0 which is available at\n+// https://www.apache.org/licenses/LICENSE-2.0\n+//\n+// SPDX-License-Identifier: EPL-2.0 OR Apache-2.0\n+// ========================================================================\n+//\n+\n+package org.eclipse.jetty.server;\n+\n+import java.util.concurrent.Semaphore;\n+\n+class BlockingContentProducer implements ContentProducer\n+{\n+    private final Semaphore _semaphore = new Semaphore(0);\n+    private final AsyncContentProducer _asyncContentProducer;\n+    private final HttpChannel _httpChannel;\n+\n+    public BlockingContentProducer(HttpChannel httpChannel, AsyncContentProducer delegate)\n+    {\n+        _asyncContentProducer = delegate;\n+        _httpChannel = httpChannel;\n+    }\n+\n+    @Override\n+    public void recycle()\n+    {\n+        _asyncContentProducer.recycle();\n+    }\n+\n+    @Override\n+    public int available()\n+    {\n+        return _asyncContentProducer.available();\n+    }\n+\n+    @Override\n+    public boolean hasContent()\n+    {\n+        return _asyncContentProducer.hasContent();\n+    }\n+\n+    @Override\n+    public boolean isError()\n+    {\n+        return _asyncContentProducer.isError();\n+    }\n+\n+    @Override\n+    public void checkMinDataRate()\n+    {\n+        _asyncContentProducer.checkMinDataRate();\n+    }\n+\n+    @Override\n+    public long getRawContentArrived()\n+    {\n+        return _asyncContentProducer.getRawContentArrived();\n+    }\n+\n+    @Override\n+    public boolean consumeAll(Throwable x)\n+    {\n+        return _asyncContentProducer.consumeAll(x);\n+    }\n+\n+    @Override\n+    public HttpInput.Content nextContent()\n+    {\n+        while (true)\n+        {\n+            HttpInput.Content content = _asyncContentProducer.nextContent();\n+            if (content != null)\n+                return content;\n+\n+            _semaphore.drainPermits();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "273213e8df4f438bf853787ec932e22424e7fe8b"}, "originalPosition": 86}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA4NzkzODg3", "url": "https://github.com/eclipse/jetty.project/pull/4556#pullrequestreview-508793887", "createdAt": "2020-10-14T21:47:52Z", "commit": {"oid": "273213e8df4f438bf853787ec932e22424e7fe8b"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNFQyMTo0Nzo1MlrOHhmRvw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNFQyMTo0Nzo1MlrOHhmRvw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDk5MjE5MQ==", "bodyText": "I think this is wrong because it means a spurious wakeup can occur even if needContent has not been called.\nA call to produceContent can do demand, so onData may be called at any time afterwards... so it is wrong for it to wakeup HttpInput if needContent has not been called.\nThis class needs to know if needContent has been called and only do a wakeup if it has.", "url": "https://github.com/eclipse/jetty.project/pull/4556#discussion_r504992191", "createdAt": "2020-10-14T21:47:52Z", "author": {"login": "gregw"}, "path": "jetty-http2/http2-server/src/main/java/org/eclipse/jetty/http2/server/HttpChannelOverHTTP2.java", "diffHunk": "@@ -261,31 +264,265 @@ public InvocationType getInvocationType()\n             {\n                 return callback.getInvocationType();\n             }\n-        });\n+        };\n+        _contentDemander.onContent(content);\n+        boolean handle = onContent(content);\n \n         boolean endStream = frame.isEndStream();\n         if (endStream)\n         {\n             boolean handleContent = onContentComplete();\n+            // this will generate EOF -> must happen before wakeup\n             boolean handleRequest = onRequestComplete();\n             handle |= handleContent | handleRequest;\n         }\n \n+        boolean woken = getRequest().getHttpInput().wakeup();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "273213e8df4f438bf853787ec932e22424e7fe8b"}, "originalPosition": 103}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA4NDg0OTUz", "url": "https://github.com/eclipse/jetty.project/pull/4556#pullrequestreview-508484953", "createdAt": "2020-10-14T15:43:31Z", "commit": {"oid": "273213e8df4f438bf853787ec932e22424e7fe8b"}, "state": "COMMENTED", "comments": {"totalCount": 36, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNFQxNTo0MzozMVrOHhZfZw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNVQwODoyNDoyNVrOHh69Pg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDc4MjY5NQ==", "bodyText": "Use AutoLock where you use synchronized.", "url": "https://github.com/eclipse/jetty.project/pull/4556#discussion_r504782695", "createdAt": "2020-10-14T15:43:31Z", "author": {"login": "sbordet"}, "path": "jetty-fcgi/fcgi-server/src/main/java/org/eclipse/jetty/fcgi/server/HttpChannelOverFCGI.java", "diffHunk": "@@ -57,6 +62,92 @@ public HttpChannelOverFCGI(Connector connector, HttpConfiguration configuration,\n         this.dispatcher = new Dispatcher(connector.getServer().getThreadPool(), this);\n     }\n \n+    void enqueueContent(HttpInput.Content content)\n+    {\n+        Throwable failure;\n+        synchronized (_contentQueue)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "273213e8df4f438bf853787ec932e22424e7fe8b"}, "originalPosition": 34}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDc4NTc5Ng==", "bodyText": "Missing javadocs.", "url": "https://github.com/eclipse/jetty.project/pull/4556#discussion_r504785796", "createdAt": "2020-10-14T15:47:57Z", "author": {"login": "sbordet"}, "path": "jetty-server/src/main/java/org/eclipse/jetty/server/HttpChannel.java", "diffHunk": "@@ -119,11 +119,23 @@ public boolean isSendError()\n         return _state.isSendError();\n     }\n \n-    protected HttpInput newHttpInput(HttpChannelState state)\n+    private HttpInput newHttpInput(HttpChannelState state)\n     {\n         return new HttpInput(state);\n     }\n \n+    /**\n+     * @return true if content is immediately available.\n+     */\n+    public abstract boolean needContent();\n+\n+    /**\n+     * @return a {@link HttpInput.Content} object if one is immediately available without blocking, null otherwise.\n+     */\n+    public abstract HttpInput.Content produceContent();\n+\n+    public abstract void failContent(Throwable failure);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "273213e8df4f438bf853787ec932e22424e7fe8b"}, "originalPosition": 29}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDc4NjY1NA==", "bodyText": "Needs an explanation of what exactly the contract is, because produceContent() returns null if there is no content, so why would you need needContent() - I'm guessing to implement available(), but needs to be made clear.", "url": "https://github.com/eclipse/jetty.project/pull/4556#discussion_r504786654", "createdAt": "2020-10-14T15:49:11Z", "author": {"login": "sbordet"}, "path": "jetty-server/src/main/java/org/eclipse/jetty/server/HttpChannel.java", "diffHunk": "@@ -119,11 +119,23 @@ public boolean isSendError()\n         return _state.isSendError();\n     }\n \n-    protected HttpInput newHttpInput(HttpChannelState state)\n+    private HttpInput newHttpInput(HttpChannelState state)\n     {\n         return new HttpInput(state);\n     }\n \n+    /**\n+     * @return true if content is immediately available.\n+     */\n+    public abstract boolean needContent();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "273213e8df4f438bf853787ec932e22424e7fe8b"}, "originalPosition": 22}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDc4NzUxNA==", "bodyText": "Perhaps expand the javadocs saying that the content is raw (i.e. not decoded). Can \"special\" content be returned here?", "url": "https://github.com/eclipse/jetty.project/pull/4556#discussion_r504787514", "createdAt": "2020-10-14T15:50:18Z", "author": {"login": "sbordet"}, "path": "jetty-server/src/main/java/org/eclipse/jetty/server/HttpChannel.java", "diffHunk": "@@ -119,11 +119,23 @@ public boolean isSendError()\n         return _state.isSendError();\n     }\n \n-    protected HttpInput newHttpInput(HttpChannelState state)\n+    private HttpInput newHttpInput(HttpChannelState state)\n     {\n         return new HttpInput(state);\n     }\n \n+    /**\n+     * @return true if content is immediately available.\n+     */\n+    public abstract boolean needContent();\n+\n+    /**\n+     * @return a {@link HttpInput.Content} object if one is immediately available without blocking, null otherwise.\n+     */\n+    public abstract HttpInput.Content produceContent();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "273213e8df4f438bf853787ec932e22424e7fe8b"}, "originalPosition": 27}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDc5Mzk3OA==", "bodyText": "This is not right, I think.\nAs soon as the parser parses some content, it should notify HttpChannel.onContent().\nThis class should override onContent(), call super, and then queue the content.", "url": "https://github.com/eclipse/jetty.project/pull/4556#discussion_r504793978", "createdAt": "2020-10-14T15:58:59Z", "author": {"login": "sbordet"}, "path": "jetty-fcgi/fcgi-server/src/main/java/org/eclipse/jetty/fcgi/server/HttpChannelOverFCGI.java", "diffHunk": "@@ -57,6 +62,92 @@ public HttpChannelOverFCGI(Connector connector, HttpConfiguration configuration,\n         this.dispatcher = new Dispatcher(connector.getServer().getThreadPool(), this);\n     }\n \n+    void enqueueContent(HttpInput.Content content)\n+    {\n+        Throwable failure;\n+        synchronized (_contentQueue)\n+        {\n+            failure = _specialContent == null ? null : _specialContent.getError();\n+            if (failure == null)\n+                _contentQueue.offer(content);\n+        }\n+        if (failure != null)\n+            content.failed(failure);\n+    }\n+\n+    @Override\n+    public boolean needContent()\n+    {\n+        synchronized (_contentQueue)\n+        {\n+            if (_specialContent != null)\n+                return true;\n+            return !_contentQueue.isEmpty();\n+        }\n+    }\n+\n+    @Override\n+    public HttpInput.Content produceContent()\n+    {\n+        HttpInput.Content content;\n+        synchronized (_contentQueue)\n+        {\n+            content = _contentQueue.poll();\n+        }\n+        if (content != null)\n+        {\n+            onContent(content);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "273213e8df4f438bf853787ec932e22424e7fe8b"}, "originalPosition": 65}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDc5NTE4Mg==", "bodyText": "HttpInput.Content is a Callback. Just clearing the queue does not feel right - should you not fail all the elements?\nAlso the method is called failContent() as if it would fail a specific content, but it fails all of them?", "url": "https://github.com/eclipse/jetty.project/pull/4556#discussion_r504795182", "createdAt": "2020-10-14T16:00:37Z", "author": {"login": "sbordet"}, "path": "jetty-fcgi/fcgi-server/src/main/java/org/eclipse/jetty/fcgi/server/HttpChannelOverFCGI.java", "diffHunk": "@@ -57,6 +62,92 @@ public HttpChannelOverFCGI(Connector connector, HttpConfiguration configuration,\n         this.dispatcher = new Dispatcher(connector.getServer().getThreadPool(), this);\n     }\n \n+    void enqueueContent(HttpInput.Content content)\n+    {\n+        Throwable failure;\n+        synchronized (_contentQueue)\n+        {\n+            failure = _specialContent == null ? null : _specialContent.getError();\n+            if (failure == null)\n+                _contentQueue.offer(content);\n+        }\n+        if (failure != null)\n+            content.failed(failure);\n+    }\n+\n+    @Override\n+    public boolean needContent()\n+    {\n+        synchronized (_contentQueue)\n+        {\n+            if (_specialContent != null)\n+                return true;\n+            return !_contentQueue.isEmpty();\n+        }\n+    }\n+\n+    @Override\n+    public HttpInput.Content produceContent()\n+    {\n+        HttpInput.Content content;\n+        synchronized (_contentQueue)\n+        {\n+            content = _contentQueue.poll();\n+        }\n+        if (content != null)\n+        {\n+            onContent(content);\n+        }\n+        else\n+        {\n+            synchronized (_contentQueue)\n+            {\n+                content = _specialContent;\n+            }\n+        }\n+        return content;\n+    }\n+\n+    @Override\n+    public void failContent(Throwable failure)\n+    {\n+        synchronized (_contentQueue)\n+        {\n+            _contentQueue.clear();\n+        }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "273213e8df4f438bf853787ec932e22424e7fe8b"}, "originalPosition": 83}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDc5NjgxOA==", "bodyText": "Coalesce the 2 sync blocks.", "url": "https://github.com/eclipse/jetty.project/pull/4556#discussion_r504796818", "createdAt": "2020-10-14T16:03:04Z", "author": {"login": "sbordet"}, "path": "jetty-fcgi/fcgi-server/src/main/java/org/eclipse/jetty/fcgi/server/HttpChannelOverFCGI.java", "diffHunk": "@@ -127,12 +218,48 @@ protected void dispatch()\n \n     public boolean onIdleTimeout(Throwable timeout)\n     {\n-        boolean handle = getRequest().getHttpInput().onIdleTimeout(timeout);\n+        boolean handle = doOnIdleTimeout(timeout);\n         if (handle)\n             execute(this);\n         return !handle;\n     }\n \n+    private boolean doOnIdleTimeout(Throwable x)\n+    {\n+        boolean neverDispatched = getState().isIdle();\n+        boolean waitingForContent;\n+        synchronized (_contentQueue)\n+        {\n+            waitingForContent = _contentQueue.isEmpty() || _contentQueue.peek().remaining() == 0;\n+        }\n+        HttpInput.Content specialContent;\n+        synchronized (_contentQueue)\n+        {\n+            specialContent = _specialContent;\n+        }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "273213e8df4f438bf853787ec932e22424e7fe8b"}, "originalPosition": 143}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDc5NzI4Ng==", "bodyText": "What if the queue is not empty? Items in it should be failed, no?", "url": "https://github.com/eclipse/jetty.project/pull/4556#discussion_r504797286", "createdAt": "2020-10-14T16:03:52Z", "author": {"login": "sbordet"}, "path": "jetty-fcgi/fcgi-server/src/main/java/org/eclipse/jetty/fcgi/server/HttpChannelOverFCGI.java", "diffHunk": "@@ -127,12 +218,48 @@ protected void dispatch()\n \n     public boolean onIdleTimeout(Throwable timeout)\n     {\n-        boolean handle = getRequest().getHttpInput().onIdleTimeout(timeout);\n+        boolean handle = doOnIdleTimeout(timeout);\n         if (handle)\n             execute(this);\n         return !handle;\n     }\n \n+    private boolean doOnIdleTimeout(Throwable x)\n+    {\n+        boolean neverDispatched = getState().isIdle();\n+        boolean waitingForContent;\n+        synchronized (_contentQueue)\n+        {\n+            waitingForContent = _contentQueue.isEmpty() || _contentQueue.peek().remaining() == 0;\n+        }\n+        HttpInput.Content specialContent;\n+        synchronized (_contentQueue)\n+        {\n+            specialContent = _specialContent;\n+        }\n+        if ((waitingForContent || neverDispatched) && specialContent == null)\n+        {\n+            x.addSuppressed(new Throwable(\"HttpInput idle timeout\"));\n+            synchronized (_contentQueue)\n+            {\n+                _specialContent = new HttpInput.ErrorContent(x);\n+            }\n+            return getRequest().getHttpInput().wakeup();\n+        }\n+        return false;\n+    }\n+\n+    @Override\n+    public void recycle()\n+    {\n+        synchronized (_contentQueue)\n+        {\n+            _contentQueue.clear();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "273213e8df4f438bf853787ec932e22424e7fe8b"}, "originalPosition": 161}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDc5Nzg0Mg==", "bodyText": "I would call onContent() as before, see previous comment.", "url": "https://github.com/eclipse/jetty.project/pull/4556#discussion_r504797842", "createdAt": "2020-10-14T16:04:40Z", "author": {"login": "sbordet"}, "path": "jetty-fcgi/fcgi-server/src/main/java/org/eclipse/jetty/fcgi/server/ServerFCGIConnection.java", "diffHunk": "@@ -197,7 +197,7 @@ public boolean onContent(int request, FCGI.StreamType stream, ByteBuffer buffer)\n             {\n                 ByteBuffer copy = ByteBuffer.allocate(buffer.remaining());\n                 copy.put(buffer).flip();\n-                channel.onContent(new HttpInput.Content(copy));\n+                channel.enqueueContent(new HttpInput.Content(copy));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "273213e8df4f438bf853787ec932e22424e7fe8b"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDc5ODI1Mg==", "bodyText": "Nope, calling a callback with a lock held.", "url": "https://github.com/eclipse/jetty.project/pull/4556#discussion_r504798252", "createdAt": "2020-10-14T16:05:13Z", "author": {"login": "sbordet"}, "path": "jetty-http2/http2-common/src/main/java/org/eclipse/jetty/http2/HTTP2Stream.java", "diffHunk": "@@ -235,6 +235,22 @@ public boolean isRemotelyClosed()\n         return state == CloseState.REMOTELY_CLOSED || state == CloseState.CLOSING || state == CloseState.CLOSED;\n     }\n \n+    @Override\n+    public void failAllData(Throwable x)\n+    {\n+        try (AutoLock l = lock.lock())\n+        {\n+            dataDemand = 0;\n+            while (true)\n+            {\n+                DataEntry dataEntry = dataQueue.poll();\n+                if (dataEntry == null)\n+                    break;\n+                dataEntry.callback.failed(x);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "273213e8df4f438bf853787ec932e22424e7fe8b"}, "originalPosition": 15}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDgwMDMzMA==", "bodyText": "Let's not put into comment previous versions of the implementation.\nThe reason to demand after succeeding an entry is because WebSocket does not have a backpressure API so you must always demand the next frame.", "url": "https://github.com/eclipse/jetty.project/pull/4556#discussion_r504800330", "createdAt": "2020-10-14T16:08:07Z", "author": {"login": "sbordet"}, "path": "jetty-http2/http2-common/src/main/java/org/eclipse/jetty/http2/HTTP2StreamEndPoint.java", "diffHunk": "@@ -216,6 +216,12 @@ public int fill(ByteBuffer sink) throws IOException\n         else\n         {\n             entry.succeed();\n+            // A demand must be made here because HTTP2ServerConnectionFactory overrides onDataDemanded() instead of onData()\n+            // to call HttpChannelOverHTTP2.onData() as HttpChannelOverHTTP2 must manually control when Stream.demand() is\n+            // called. When HttpInput used to queue content, it was okay to chain Stream.demand() requests as yet-undemanded\n+            // content was queued. But now that content isn't queued anymore, HttpChannelOverHTTP2 explicitly calls\n+            // Stream.demand() and this fake endpoint must do too to feed content to non-HttpInput users like WebSocket.\n+            stream.demand(1);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "273213e8df4f438bf853787ec932e22424e7fe8b"}, "originalPosition": 9}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDgyMjUzMw==", "bodyText": "Is this necessary?\nBefore, a failure had to be notified to HttpInput because it had the queue of content, to fail them all.\nNow that the queue is gone, we should not come back to the stream, because it's the stream that originates the failure, or some other component that has the stream available.\nFor example:\nHttpTransportOverHTTP2.onCompleted() -> has the stream available, so failAllData() may be called here already.\n  HttpChannelOverHTTP2.consumeInput()\n    HttpInput.consumeAll()\n      ContentProducer.consumeAll()\n        HttpChannel.failContent()\n          Stream.failAllData()\n\nSeems like a back and forth that is not justified?\nCan't we just fail the stream immediately rather than forwarding through the channel, input, producer, and back?\nThere are other similar places where the stream is available, but we laser through to HttpInput.", "url": "https://github.com/eclipse/jetty.project/pull/4556#discussion_r504822533", "createdAt": "2020-10-14T16:42:16Z", "author": {"login": "sbordet"}, "path": "jetty-http2/http2-common/src/main/java/org/eclipse/jetty/http2/IStream.java", "diffHunk": "@@ -119,6 +119,13 @@\n      */\n     boolean isRemotelyClosed();\n \n+    /**\n+     * Fail all data queued in the stream and reset\n+     * demand to 0.\n+     * @param x the exception to fail the data with.\n+     */\n+    void failAllData(Throwable x);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "273213e8df4f438bf853787ec932e22424e7fe8b"}, "originalPosition": 9}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDgyMzIxMQ==", "bodyText": "Can't we have a default implementation for all these methods?", "url": "https://github.com/eclipse/jetty.project/pull/4556#discussion_r504823211", "createdAt": "2020-10-14T16:43:24Z", "author": {"login": "sbordet"}, "path": "jetty-security/src/test/java/org/eclipse/jetty/security/authentication/SpnegoAuthenticatorTest.java", "diffHunk": "@@ -62,6 +63,35 @@ public Server getServer()\n                 return null;\n             }\n \n+            @Override\n+            public boolean failed(Throwable x)\n+            {\n+                return false;\n+            }\n+\n+            @Override\n+            protected boolean eof()\n+            {\n+                return false;\n+            }\n+\n+            @Override\n+            public boolean needContent()\n+            {\n+                return false;\n+            }\n+\n+            @Override\n+            public HttpInput.Content produceContent()\n+            {\n+                return null;\n+            }\n+\n+            @Override\n+            public void failContent(Throwable failure)\n+            {\n+            }\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "273213e8df4f438bf853787ec932e22424e7fe8b"}, "originalPosition": 40}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDgyMzQ4Mg==", "bodyText": "Needs javadoc.", "url": "https://github.com/eclipse/jetty.project/pull/4556#discussion_r504823482", "createdAt": "2020-10-14T16:43:53Z", "author": {"login": "sbordet"}, "path": "jetty-server/src/main/java/org/eclipse/jetty/server/AsyncContentProducer.java", "diffHunk": "@@ -0,0 +1,259 @@\n+//\n+// ========================================================================\n+// Copyright (c) 1995-2020 Mort Bay Consulting Pty Ltd and others.\n+//\n+// This program and the accompanying materials are made available under\n+// the terms of the Eclipse Public License 2.0 which is available at\n+// https://www.eclipse.org/legal/epl-2.0\n+//\n+// This Source Code may also be made available under the following\n+// Secondary Licenses when the conditions for such availability set\n+// forth in the Eclipse Public License, v. 2.0 are satisfied:\n+// the Apache License v2.0 which is available at\n+// https://www.apache.org/licenses/LICENSE-2.0\n+//\n+// SPDX-License-Identifier: EPL-2.0 OR Apache-2.0\n+// ========================================================================\n+//\n+\n+package org.eclipse.jetty.server;\n+\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jetty.http.BadMessageException;\n+import org.eclipse.jetty.http.HttpStatus;\n+\n+class AsyncContentProducer implements ContentProducer", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "273213e8df4f438bf853787ec932e22424e7fe8b"}, "originalPosition": 26}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDgyNjA3NQ==", "bodyText": "Remove unnecessary braces and inline.", "url": "https://github.com/eclipse/jetty.project/pull/4556#discussion_r504826075", "createdAt": "2020-10-14T16:47:55Z", "author": {"login": "sbordet"}, "path": "jetty-http2/http2-server/src/main/java/org/eclipse/jetty/http2/server/HttpChannelOverHTTP2.java", "diffHunk": "@@ -261,31 +264,265 @@ public InvocationType getInvocationType()\n             {\n                 return callback.getInvocationType();\n             }\n-        });\n+        };\n+        _contentDemander.onContent(content);\n+        boolean handle = onContent(content);\n \n         boolean endStream = frame.isEndStream();\n         if (endStream)\n         {\n             boolean handleContent = onContentComplete();\n+            // this will generate EOF -> must happen before wakeup\n             boolean handleRequest = onRequestComplete();\n             handle |= handleContent | handleRequest;\n         }\n \n+        boolean woken = getRequest().getHttpInput().wakeup();\n         if (LOG.isDebugEnabled())\n         {\n-            LOG.debug(\"HTTP2 Request #{}/{}: {} bytes of {} content, handle: {}\",\n+            Stream stream = getStream();\n+            LOG.debug(\"HTTP2 Request #{}/{}: {} bytes of {} content, woken: {}, handle: {}\",\n                     stream.getId(),\n                     Integer.toHexString(stream.getSession().hashCode()),\n                     length,\n                     endStream ? \"last\" : \"some\",\n+                    woken,\n                     handle);\n         }\n+        handle |= woken;\n \n         boolean wasDelayed = _delayedUntilContent;\n         _delayedUntilContent = false;\n         return handle || wasDelayed ? this : null;\n     }\n \n+    private static final HttpInput.Content EOF = new HttpInput.EofContent();\n+    private static final HttpInput.Content DEMANDING = new HttpInput.SpecialContent() {};\n+\n+    private class ContentDemander\n+    {\n+        private final AtomicReference<HttpInput.Content> _content = new AtomicReference<>();\n+\n+        public void recycle()\n+        {\n+            HttpInput.Content c = _content.getAndSet(null);\n+            if (c != null && !c.isSpecial())\n+                throw new AssertionError(\"unconsumed content: \" + c);\n+        }\n+\n+        public HttpInput.Content take()\n+        {\n+            while (true)\n+            {\n+                HttpInput.Content c = _content.get();\n+                if (c == null || c.isSpecial() || _content.compareAndSet(c, c.isEof() ? EOF : null))\n+                    return c;\n+            }\n+        }\n+\n+        public boolean demand()\n+        {\n+            while (true)\n+            {\n+                HttpInput.Content c = _content.get();\n+                if (c == DEMANDING)\n+                    return false;\n+                if (c != null)\n+                    return true;\n+                if (_content.compareAndSet(null, DEMANDING))\n+                {\n+                    IStream stream = getStream();\n+                    if (stream == null)\n+                    {\n+                        _content.set(null);\n+                        return false;\n+                    }\n+                    stream.demand(1);\n+                    c = _content.get();\n+                    return c != DEMANDING && c != null;\n+                }\n+            }\n+        }\n+\n+        public void onContent(HttpInput.Content content)\n+        {\n+            while (true)\n+            {\n+                HttpInput.Content c = _content.get();\n+                if (c == DEMANDING)\n+                {\n+                    if (_content.compareAndSet(DEMANDING, content))\n+                        return;\n+                }\n+                else if (c == null)\n+                {\n+                    if (!content.isSpecial())\n+                        throw new AssertionError(\"Non special content without demand\");\n+                    if (_content.compareAndSet(null, content))\n+                        return;\n+                }\n+                else if (c.isEof() && content.isEof() && content.isEmpty())\n+                {\n+                    content.succeeded();\n+                    return;\n+                }\n+                else if (content.getError() != null)\n+                {\n+                    if (c.getError() != null)\n+                    {\n+                        if (c.getError() != content.getError())\n+                            c.getError().addSuppressed(content.getError());\n+                        return;\n+                    }\n+                    if (_content.compareAndSet(c, content))\n+                    {\n+                        c.failed(content.getError());\n+                        return;\n+                    }\n+                }\n+                else if (c.getError() != null && content.remaining() == 0)\n+                {\n+                    content.succeeded();\n+                    return;\n+                }\n+                else\n+                {\n+                    throw new IllegalStateException(\"Cannot overwrite exiting content \" + c + \" with \" + content);\n+                }\n+            }\n+        }\n+\n+        public boolean onTimeout(Throwable failure)\n+        {\n+            while (true)\n+            {\n+                HttpInput.Content c = _content.get();\n+                if (c != DEMANDING)\n+                    return false;\n+                if (_content.compareAndSet(DEMANDING, new HttpInput.ErrorContent(failure)))\n+                    return true;\n+            }\n+        }\n+\n+        public void eof()\n+        {\n+            while (true)\n+            {\n+                HttpInput.Content c = _content.get();\n+                if (c == DEMANDING)\n+                {\n+                    if (_content.compareAndSet(DEMANDING, EOF))\n+                        return;\n+                }\n+                else if (c == null)\n+                {\n+                    if (_content.compareAndSet(null, EOF))\n+                        return;\n+                }\n+                else if (c.isEof())\n+                {\n+                    return;\n+                }\n+                else if (c.remaining() == 0)\n+                {\n+                    if (_content.compareAndSet(c, EOF))\n+                        return;\n+                }\n+                else\n+                {\n+                    HttpInput.Content content = new HttpInput.Content(c.getByteBuffer())\n+                    {\n+                        @Override\n+                        public boolean isEof()\n+                        {\n+                            return true;\n+                        }\n+\n+                        @Override\n+                        public void succeeded()\n+                        {\n+                            c.succeeded();\n+                        }\n+\n+                        @Override\n+                        public void failed(Throwable x)\n+                        {\n+                            c.failed(x);\n+                        }\n+\n+                        @Override\n+                        public InvocationType getInvocationType()\n+                        {\n+                            return c.getInvocationType();\n+                        }\n+                    };\n+                    if (_content.compareAndSet(c, content))\n+                        return;\n+                }\n+            }\n+        }\n+\n+        public void failContent(Throwable failure)\n+        {\n+            while (true)\n+            {\n+                HttpInput.Content c = _content.get();\n+                if (c == null || c.isSpecial())\n+                    return;\n+                if (_content.compareAndSet(c, null))\n+                {\n+                    c.failed(failure);\n+                    return;\n+                }\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public boolean needContent()\n+    {\n+        boolean hasContent = _contentDemander.demand();\n+        return hasContent;\n+    }\n+\n+    @Override\n+    public HttpInput.Content produceContent()\n+    {\n+        if (_contentDemander.demand())\n+        {\n+            HttpInput.Content result = _contentDemander.take();\n+            {\n+                return result;\n+            }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "273213e8df4f438bf853787ec932e22424e7fe8b"}, "originalPosition": 320}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDgyOTQzNw==", "bodyText": "Before the logic for demanding was not taking into account _delayedUntilContent.\nWhy now it is necessary?", "url": "https://github.com/eclipse/jetty.project/pull/4556#discussion_r504829437", "createdAt": "2020-10-14T16:53:35Z", "author": {"login": "sbordet"}, "path": "jetty-http2/http2-server/src/main/java/org/eclipse/jetty/http2/server/HttpChannelOverHTTP2.java", "diffHunk": "@@ -131,9 +134,18 @@ public Runnable onRequest(HeadersFrame frame)\n             _delayedUntilContent = getHttpConfiguration().isDelayDispatchUntilContent() &&\n                     !endStream && !_expect100Continue && !connect;\n \n-            // Delay the demand of DATA frames for CONNECT with :protocol.\n-            if (!connect || request.getProtocol() == null)\n-                getStream().demand(1);\n+            // Delay the demand of DATA frames for CONNECT with :protocol\n+            // or for normal requests expecting 100 continue.\n+            if (connect)\n+            {\n+                if (request.getProtocol() == null)\n+                    _contentDemander.demand();\n+            }\n+            else\n+            {\n+                if (_delayedUntilContent)\n+                    _contentDemander.demand();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "273213e8df4f438bf853787ec932e22424e7fe8b"}, "originalPosition": 38}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDgzMDQ4Mw==", "bodyText": "Why this logic has been removed?", "url": "https://github.com/eclipse/jetty.project/pull/4556#discussion_r504830483", "createdAt": "2020-10-14T16:55:15Z", "author": {"login": "sbordet"}, "path": "jetty-http2/http2-server/src/main/java/org/eclipse/jetty/http2/server/HttpChannelOverHTTP2.java", "diffHunk": "@@ -224,26 +237,16 @@ protected void commit(MetaData.Response info)\n     @Override\n     public Runnable onData(DataFrame frame, Callback callback)\n     {\n-        return onRequestContent(frame, callback);\n-    }\n-\n-    public Runnable onRequestContent(DataFrame frame, final Callback callback)\n-    {\n-        Stream stream = getStream();\n-        if (stream.isReset())\n-        {\n-            // Consume previously queued content to\n-            // enlarge the session flow control window.\n-            consumeInput();\n-            // Consume immediately this content.\n-            callback.succeeded();\n-            return null;\n-        }\n-", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "273213e8df4f438bf853787ec932e22424e7fe8b"}, "originalPosition": 70}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDg0NDM3NA==", "bodyText": "Should be named poll() since take() has typically blocking semantic.", "url": "https://github.com/eclipse/jetty.project/pull/4556#discussion_r504844374", "createdAt": "2020-10-14T17:18:27Z", "author": {"login": "sbordet"}, "path": "jetty-http2/http2-server/src/main/java/org/eclipse/jetty/http2/server/HttpChannelOverHTTP2.java", "diffHunk": "@@ -261,31 +264,265 @@ public InvocationType getInvocationType()\n             {\n                 return callback.getInvocationType();\n             }\n-        });\n+        };\n+        _contentDemander.onContent(content);\n+        boolean handle = onContent(content);\n \n         boolean endStream = frame.isEndStream();\n         if (endStream)\n         {\n             boolean handleContent = onContentComplete();\n+            // this will generate EOF -> must happen before wakeup\n             boolean handleRequest = onRequestComplete();\n             handle |= handleContent | handleRequest;\n         }\n \n+        boolean woken = getRequest().getHttpInput().wakeup();\n         if (LOG.isDebugEnabled())\n         {\n-            LOG.debug(\"HTTP2 Request #{}/{}: {} bytes of {} content, handle: {}\",\n+            Stream stream = getStream();\n+            LOG.debug(\"HTTP2 Request #{}/{}: {} bytes of {} content, woken: {}, handle: {}\",\n                     stream.getId(),\n                     Integer.toHexString(stream.getSession().hashCode()),\n                     length,\n                     endStream ? \"last\" : \"some\",\n+                    woken,\n                     handle);\n         }\n+        handle |= woken;\n \n         boolean wasDelayed = _delayedUntilContent;\n         _delayedUntilContent = false;\n         return handle || wasDelayed ? this : null;\n     }\n \n+    private static final HttpInput.Content EOF = new HttpInput.EofContent();\n+    private static final HttpInput.Content DEMANDING = new HttpInput.SpecialContent() {};\n+\n+    private class ContentDemander\n+    {\n+        private final AtomicReference<HttpInput.Content> _content = new AtomicReference<>();\n+\n+        public void recycle()\n+        {\n+            HttpInput.Content c = _content.getAndSet(null);\n+            if (c != null && !c.isSpecial())\n+                throw new AssertionError(\"unconsumed content: \" + c);\n+        }\n+\n+        public HttpInput.Content take()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "273213e8df4f438bf853787ec932e22424e7fe8b"}, "originalPosition": 137}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDg0NjIxOA==", "bodyText": "This check can be out of the if block, so you don't have to set _content back to null.", "url": "https://github.com/eclipse/jetty.project/pull/4556#discussion_r504846218", "createdAt": "2020-10-14T17:21:42Z", "author": {"login": "sbordet"}, "path": "jetty-http2/http2-server/src/main/java/org/eclipse/jetty/http2/server/HttpChannelOverHTTP2.java", "diffHunk": "@@ -261,31 +264,265 @@ public InvocationType getInvocationType()\n             {\n                 return callback.getInvocationType();\n             }\n-        });\n+        };\n+        _contentDemander.onContent(content);\n+        boolean handle = onContent(content);\n \n         boolean endStream = frame.isEndStream();\n         if (endStream)\n         {\n             boolean handleContent = onContentComplete();\n+            // this will generate EOF -> must happen before wakeup\n             boolean handleRequest = onRequestComplete();\n             handle |= handleContent | handleRequest;\n         }\n \n+        boolean woken = getRequest().getHttpInput().wakeup();\n         if (LOG.isDebugEnabled())\n         {\n-            LOG.debug(\"HTTP2 Request #{}/{}: {} bytes of {} content, handle: {}\",\n+            Stream stream = getStream();\n+            LOG.debug(\"HTTP2 Request #{}/{}: {} bytes of {} content, woken: {}, handle: {}\",\n                     stream.getId(),\n                     Integer.toHexString(stream.getSession().hashCode()),\n                     length,\n                     endStream ? \"last\" : \"some\",\n+                    woken,\n                     handle);\n         }\n+        handle |= woken;\n \n         boolean wasDelayed = _delayedUntilContent;\n         _delayedUntilContent = false;\n         return handle || wasDelayed ? this : null;\n     }\n \n+    private static final HttpInput.Content EOF = new HttpInput.EofContent();\n+    private static final HttpInput.Content DEMANDING = new HttpInput.SpecialContent() {};\n+\n+    private class ContentDemander\n+    {\n+        private final AtomicReference<HttpInput.Content> _content = new AtomicReference<>();\n+\n+        public void recycle()\n+        {\n+            HttpInput.Content c = _content.getAndSet(null);\n+            if (c != null && !c.isSpecial())\n+                throw new AssertionError(\"unconsumed content: \" + c);\n+        }\n+\n+        public HttpInput.Content take()\n+        {\n+            while (true)\n+            {\n+                HttpInput.Content c = _content.get();\n+                if (c == null || c.isSpecial() || _content.compareAndSet(c, c.isEof() ? EOF : null))\n+                    return c;\n+            }\n+        }\n+\n+        public boolean demand()\n+        {\n+            while (true)\n+            {\n+                HttpInput.Content c = _content.get();\n+                if (c == DEMANDING)\n+                    return false;\n+                if (c != null)\n+                    return true;\n+                if (_content.compareAndSet(null, DEMANDING))\n+                {\n+                    IStream stream = getStream();\n+                    if (stream == null)\n+                    {\n+                        _content.set(null);\n+                        return false;\n+                    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "273213e8df4f438bf853787ec932e22424e7fe8b"}, "originalPosition": 163}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDg0NzE0OQ==", "bodyText": "The above 2 lines are the same as the first lines, can't you just loop around after stream.demand(1)?", "url": "https://github.com/eclipse/jetty.project/pull/4556#discussion_r504847149", "createdAt": "2020-10-14T17:23:23Z", "author": {"login": "sbordet"}, "path": "jetty-http2/http2-server/src/main/java/org/eclipse/jetty/http2/server/HttpChannelOverHTTP2.java", "diffHunk": "@@ -261,31 +264,265 @@ public InvocationType getInvocationType()\n             {\n                 return callback.getInvocationType();\n             }\n-        });\n+        };\n+        _contentDemander.onContent(content);\n+        boolean handle = onContent(content);\n \n         boolean endStream = frame.isEndStream();\n         if (endStream)\n         {\n             boolean handleContent = onContentComplete();\n+            // this will generate EOF -> must happen before wakeup\n             boolean handleRequest = onRequestComplete();\n             handle |= handleContent | handleRequest;\n         }\n \n+        boolean woken = getRequest().getHttpInput().wakeup();\n         if (LOG.isDebugEnabled())\n         {\n-            LOG.debug(\"HTTP2 Request #{}/{}: {} bytes of {} content, handle: {}\",\n+            Stream stream = getStream();\n+            LOG.debug(\"HTTP2 Request #{}/{}: {} bytes of {} content, woken: {}, handle: {}\",\n                     stream.getId(),\n                     Integer.toHexString(stream.getSession().hashCode()),\n                     length,\n                     endStream ? \"last\" : \"some\",\n+                    woken,\n                     handle);\n         }\n+        handle |= woken;\n \n         boolean wasDelayed = _delayedUntilContent;\n         _delayedUntilContent = false;\n         return handle || wasDelayed ? this : null;\n     }\n \n+    private static final HttpInput.Content EOF = new HttpInput.EofContent();\n+    private static final HttpInput.Content DEMANDING = new HttpInput.SpecialContent() {};\n+\n+    private class ContentDemander\n+    {\n+        private final AtomicReference<HttpInput.Content> _content = new AtomicReference<>();\n+\n+        public void recycle()\n+        {\n+            HttpInput.Content c = _content.getAndSet(null);\n+            if (c != null && !c.isSpecial())\n+                throw new AssertionError(\"unconsumed content: \" + c);\n+        }\n+\n+        public HttpInput.Content take()\n+        {\n+            while (true)\n+            {\n+                HttpInput.Content c = _content.get();\n+                if (c == null || c.isSpecial() || _content.compareAndSet(c, c.isEof() ? EOF : null))\n+                    return c;\n+            }\n+        }\n+\n+        public boolean demand()\n+        {\n+            while (true)\n+            {\n+                HttpInput.Content c = _content.get();\n+                if (c == DEMANDING)\n+                    return false;\n+                if (c != null)\n+                    return true;\n+                if (_content.compareAndSet(null, DEMANDING))\n+                {\n+                    IStream stream = getStream();\n+                    if (stream == null)\n+                    {\n+                        _content.set(null);\n+                        return false;\n+                    }\n+                    stream.demand(1);\n+                    c = _content.get();\n+                    return c != DEMANDING && c != null;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "273213e8df4f438bf853787ec932e22424e7fe8b"}, "originalPosition": 166}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDg0ODk4NQ==", "bodyText": "This covers multiple EOF? Can an EOF content be non-empty? Because if it can, it will end up in the illegal case below.", "url": "https://github.com/eclipse/jetty.project/pull/4556#discussion_r504848985", "createdAt": "2020-10-14T17:26:07Z", "author": {"login": "sbordet"}, "path": "jetty-http2/http2-server/src/main/java/org/eclipse/jetty/http2/server/HttpChannelOverHTTP2.java", "diffHunk": "@@ -261,31 +264,265 @@ public InvocationType getInvocationType()\n             {\n                 return callback.getInvocationType();\n             }\n-        });\n+        };\n+        _contentDemander.onContent(content);\n+        boolean handle = onContent(content);\n \n         boolean endStream = frame.isEndStream();\n         if (endStream)\n         {\n             boolean handleContent = onContentComplete();\n+            // this will generate EOF -> must happen before wakeup\n             boolean handleRequest = onRequestComplete();\n             handle |= handleContent | handleRequest;\n         }\n \n+        boolean woken = getRequest().getHttpInput().wakeup();\n         if (LOG.isDebugEnabled())\n         {\n-            LOG.debug(\"HTTP2 Request #{}/{}: {} bytes of {} content, handle: {}\",\n+            Stream stream = getStream();\n+            LOG.debug(\"HTTP2 Request #{}/{}: {} bytes of {} content, woken: {}, handle: {}\",\n                     stream.getId(),\n                     Integer.toHexString(stream.getSession().hashCode()),\n                     length,\n                     endStream ? \"last\" : \"some\",\n+                    woken,\n                     handle);\n         }\n+        handle |= woken;\n \n         boolean wasDelayed = _delayedUntilContent;\n         _delayedUntilContent = false;\n         return handle || wasDelayed ? this : null;\n     }\n \n+    private static final HttpInput.Content EOF = new HttpInput.EofContent();\n+    private static final HttpInput.Content DEMANDING = new HttpInput.SpecialContent() {};\n+\n+    private class ContentDemander\n+    {\n+        private final AtomicReference<HttpInput.Content> _content = new AtomicReference<>();\n+\n+        public void recycle()\n+        {\n+            HttpInput.Content c = _content.getAndSet(null);\n+            if (c != null && !c.isSpecial())\n+                throw new AssertionError(\"unconsumed content: \" + c);\n+        }\n+\n+        public HttpInput.Content take()\n+        {\n+            while (true)\n+            {\n+                HttpInput.Content c = _content.get();\n+                if (c == null || c.isSpecial() || _content.compareAndSet(c, c.isEof() ? EOF : null))\n+                    return c;\n+            }\n+        }\n+\n+        public boolean demand()\n+        {\n+            while (true)\n+            {\n+                HttpInput.Content c = _content.get();\n+                if (c == DEMANDING)\n+                    return false;\n+                if (c != null)\n+                    return true;\n+                if (_content.compareAndSet(null, DEMANDING))\n+                {\n+                    IStream stream = getStream();\n+                    if (stream == null)\n+                    {\n+                        _content.set(null);\n+                        return false;\n+                    }\n+                    stream.demand(1);\n+                    c = _content.get();\n+                    return c != DEMANDING && c != null;\n+                }\n+            }\n+        }\n+\n+        public void onContent(HttpInput.Content content)\n+        {\n+            while (true)\n+            {\n+                HttpInput.Content c = _content.get();\n+                if (c == DEMANDING)\n+                {\n+                    if (_content.compareAndSet(DEMANDING, content))\n+                        return;\n+                }\n+                else if (c == null)\n+                {\n+                    if (!content.isSpecial())\n+                        throw new AssertionError(\"Non special content without demand\");\n+                    if (_content.compareAndSet(null, content))\n+                        return;\n+                }\n+                else if (c.isEof() && content.isEof() && content.isEmpty())", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "273213e8df4f438bf853787ec932e22424e7fe8b"}, "originalPosition": 188}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDg1MjQwNg==", "bodyText": "Cannot throw! The content won't be completed and the flow control window will close. Must fail the content.", "url": "https://github.com/eclipse/jetty.project/pull/4556#discussion_r504852406", "createdAt": "2020-10-14T17:31:52Z", "author": {"login": "sbordet"}, "path": "jetty-http2/http2-server/src/main/java/org/eclipse/jetty/http2/server/HttpChannelOverHTTP2.java", "diffHunk": "@@ -261,31 +264,265 @@ public InvocationType getInvocationType()\n             {\n                 return callback.getInvocationType();\n             }\n-        });\n+        };\n+        _contentDemander.onContent(content);\n+        boolean handle = onContent(content);\n \n         boolean endStream = frame.isEndStream();\n         if (endStream)\n         {\n             boolean handleContent = onContentComplete();\n+            // this will generate EOF -> must happen before wakeup\n             boolean handleRequest = onRequestComplete();\n             handle |= handleContent | handleRequest;\n         }\n \n+        boolean woken = getRequest().getHttpInput().wakeup();\n         if (LOG.isDebugEnabled())\n         {\n-            LOG.debug(\"HTTP2 Request #{}/{}: {} bytes of {} content, handle: {}\",\n+            Stream stream = getStream();\n+            LOG.debug(\"HTTP2 Request #{}/{}: {} bytes of {} content, woken: {}, handle: {}\",\n                     stream.getId(),\n                     Integer.toHexString(stream.getSession().hashCode()),\n                     length,\n                     endStream ? \"last\" : \"some\",\n+                    woken,\n                     handle);\n         }\n+        handle |= woken;\n \n         boolean wasDelayed = _delayedUntilContent;\n         _delayedUntilContent = false;\n         return handle || wasDelayed ? this : null;\n     }\n \n+    private static final HttpInput.Content EOF = new HttpInput.EofContent();\n+    private static final HttpInput.Content DEMANDING = new HttpInput.SpecialContent() {};\n+\n+    private class ContentDemander\n+    {\n+        private final AtomicReference<HttpInput.Content> _content = new AtomicReference<>();\n+\n+        public void recycle()\n+        {\n+            HttpInput.Content c = _content.getAndSet(null);\n+            if (c != null && !c.isSpecial())\n+                throw new AssertionError(\"unconsumed content: \" + c);\n+        }\n+\n+        public HttpInput.Content take()\n+        {\n+            while (true)\n+            {\n+                HttpInput.Content c = _content.get();\n+                if (c == null || c.isSpecial() || _content.compareAndSet(c, c.isEof() ? EOF : null))\n+                    return c;\n+            }\n+        }\n+\n+        public boolean demand()\n+        {\n+            while (true)\n+            {\n+                HttpInput.Content c = _content.get();\n+                if (c == DEMANDING)\n+                    return false;\n+                if (c != null)\n+                    return true;\n+                if (_content.compareAndSet(null, DEMANDING))\n+                {\n+                    IStream stream = getStream();\n+                    if (stream == null)\n+                    {\n+                        _content.set(null);\n+                        return false;\n+                    }\n+                    stream.demand(1);\n+                    c = _content.get();\n+                    return c != DEMANDING && c != null;\n+                }\n+            }\n+        }\n+\n+        public void onContent(HttpInput.Content content)\n+        {\n+            while (true)\n+            {\n+                HttpInput.Content c = _content.get();\n+                if (c == DEMANDING)\n+                {\n+                    if (_content.compareAndSet(DEMANDING, content))\n+                        return;\n+                }\n+                else if (c == null)\n+                {\n+                    if (!content.isSpecial())\n+                        throw new AssertionError(\"Non special content without demand\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "273213e8df4f438bf853787ec932e22424e7fe8b"}, "originalPosition": 184}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDg1MjYzNA==", "bodyText": "Cannot throw! Must fail the content and exit the loop.", "url": "https://github.com/eclipse/jetty.project/pull/4556#discussion_r504852634", "createdAt": "2020-10-14T17:32:18Z", "author": {"login": "sbordet"}, "path": "jetty-http2/http2-server/src/main/java/org/eclipse/jetty/http2/server/HttpChannelOverHTTP2.java", "diffHunk": "@@ -261,31 +264,265 @@ public InvocationType getInvocationType()\n             {\n                 return callback.getInvocationType();\n             }\n-        });\n+        };\n+        _contentDemander.onContent(content);\n+        boolean handle = onContent(content);\n \n         boolean endStream = frame.isEndStream();\n         if (endStream)\n         {\n             boolean handleContent = onContentComplete();\n+            // this will generate EOF -> must happen before wakeup\n             boolean handleRequest = onRequestComplete();\n             handle |= handleContent | handleRequest;\n         }\n \n+        boolean woken = getRequest().getHttpInput().wakeup();\n         if (LOG.isDebugEnabled())\n         {\n-            LOG.debug(\"HTTP2 Request #{}/{}: {} bytes of {} content, handle: {}\",\n+            Stream stream = getStream();\n+            LOG.debug(\"HTTP2 Request #{}/{}: {} bytes of {} content, woken: {}, handle: {}\",\n                     stream.getId(),\n                     Integer.toHexString(stream.getSession().hashCode()),\n                     length,\n                     endStream ? \"last\" : \"some\",\n+                    woken,\n                     handle);\n         }\n+        handle |= woken;\n \n         boolean wasDelayed = _delayedUntilContent;\n         _delayedUntilContent = false;\n         return handle || wasDelayed ? this : null;\n     }\n \n+    private static final HttpInput.Content EOF = new HttpInput.EofContent();\n+    private static final HttpInput.Content DEMANDING = new HttpInput.SpecialContent() {};\n+\n+    private class ContentDemander\n+    {\n+        private final AtomicReference<HttpInput.Content> _content = new AtomicReference<>();\n+\n+        public void recycle()\n+        {\n+            HttpInput.Content c = _content.getAndSet(null);\n+            if (c != null && !c.isSpecial())\n+                throw new AssertionError(\"unconsumed content: \" + c);\n+        }\n+\n+        public HttpInput.Content take()\n+        {\n+            while (true)\n+            {\n+                HttpInput.Content c = _content.get();\n+                if (c == null || c.isSpecial() || _content.compareAndSet(c, c.isEof() ? EOF : null))\n+                    return c;\n+            }\n+        }\n+\n+        public boolean demand()\n+        {\n+            while (true)\n+            {\n+                HttpInput.Content c = _content.get();\n+                if (c == DEMANDING)\n+                    return false;\n+                if (c != null)\n+                    return true;\n+                if (_content.compareAndSet(null, DEMANDING))\n+                {\n+                    IStream stream = getStream();\n+                    if (stream == null)\n+                    {\n+                        _content.set(null);\n+                        return false;\n+                    }\n+                    stream.demand(1);\n+                    c = _content.get();\n+                    return c != DEMANDING && c != null;\n+                }\n+            }\n+        }\n+\n+        public void onContent(HttpInput.Content content)\n+        {\n+            while (true)\n+            {\n+                HttpInput.Content c = _content.get();\n+                if (c == DEMANDING)\n+                {\n+                    if (_content.compareAndSet(DEMANDING, content))\n+                        return;\n+                }\n+                else if (c == null)\n+                {\n+                    if (!content.isSpecial())\n+                        throw new AssertionError(\"Non special content without demand\");\n+                    if (_content.compareAndSet(null, content))\n+                        return;\n+                }\n+                else if (c.isEof() && content.isEof() && content.isEmpty())\n+                {\n+                    content.succeeded();\n+                    return;\n+                }\n+                else if (content.getError() != null)\n+                {\n+                    if (c.getError() != null)\n+                    {\n+                        if (c.getError() != content.getError())\n+                            c.getError().addSuppressed(content.getError());\n+                        return;\n+                    }\n+                    if (_content.compareAndSet(c, content))\n+                    {\n+                        c.failed(content.getError());\n+                        return;\n+                    }\n+                }\n+                else if (c.getError() != null && content.remaining() == 0)\n+                {\n+                    content.succeeded();\n+                    return;\n+                }\n+                else\n+                {\n+                    throw new IllegalStateException(\"Cannot overwrite exiting content \" + c + \" with \" + content);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "273213e8df4f438bf853787ec932e22424e7fe8b"}, "originalPosition": 214}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDkyNDU4Mg==", "bodyText": "So EOF content can be non-empty, which invalidates the logic above?", "url": "https://github.com/eclipse/jetty.project/pull/4556#discussion_r504924582", "createdAt": "2020-10-14T19:36:13Z", "author": {"login": "sbordet"}, "path": "jetty-http2/http2-server/src/main/java/org/eclipse/jetty/http2/server/HttpChannelOverHTTP2.java", "diffHunk": "@@ -261,31 +264,265 @@ public InvocationType getInvocationType()\n             {\n                 return callback.getInvocationType();\n             }\n-        });\n+        };\n+        _contentDemander.onContent(content);\n+        boolean handle = onContent(content);\n \n         boolean endStream = frame.isEndStream();\n         if (endStream)\n         {\n             boolean handleContent = onContentComplete();\n+            // this will generate EOF -> must happen before wakeup\n             boolean handleRequest = onRequestComplete();\n             handle |= handleContent | handleRequest;\n         }\n \n+        boolean woken = getRequest().getHttpInput().wakeup();\n         if (LOG.isDebugEnabled())\n         {\n-            LOG.debug(\"HTTP2 Request #{}/{}: {} bytes of {} content, handle: {}\",\n+            Stream stream = getStream();\n+            LOG.debug(\"HTTP2 Request #{}/{}: {} bytes of {} content, woken: {}, handle: {}\",\n                     stream.getId(),\n                     Integer.toHexString(stream.getSession().hashCode()),\n                     length,\n                     endStream ? \"last\" : \"some\",\n+                    woken,\n                     handle);\n         }\n+        handle |= woken;\n \n         boolean wasDelayed = _delayedUntilContent;\n         _delayedUntilContent = false;\n         return handle || wasDelayed ? this : null;\n     }\n \n+    private static final HttpInput.Content EOF = new HttpInput.EofContent();\n+    private static final HttpInput.Content DEMANDING = new HttpInput.SpecialContent() {};\n+\n+    private class ContentDemander\n+    {\n+        private final AtomicReference<HttpInput.Content> _content = new AtomicReference<>();\n+\n+        public void recycle()\n+        {\n+            HttpInput.Content c = _content.getAndSet(null);\n+            if (c != null && !c.isSpecial())\n+                throw new AssertionError(\"unconsumed content: \" + c);\n+        }\n+\n+        public HttpInput.Content take()\n+        {\n+            while (true)\n+            {\n+                HttpInput.Content c = _content.get();\n+                if (c == null || c.isSpecial() || _content.compareAndSet(c, c.isEof() ? EOF : null))\n+                    return c;\n+            }\n+        }\n+\n+        public boolean demand()\n+        {\n+            while (true)\n+            {\n+                HttpInput.Content c = _content.get();\n+                if (c == DEMANDING)\n+                    return false;\n+                if (c != null)\n+                    return true;\n+                if (_content.compareAndSet(null, DEMANDING))\n+                {\n+                    IStream stream = getStream();\n+                    if (stream == null)\n+                    {\n+                        _content.set(null);\n+                        return false;\n+                    }\n+                    stream.demand(1);\n+                    c = _content.get();\n+                    return c != DEMANDING && c != null;\n+                }\n+            }\n+        }\n+\n+        public void onContent(HttpInput.Content content)\n+        {\n+            while (true)\n+            {\n+                HttpInput.Content c = _content.get();\n+                if (c == DEMANDING)\n+                {\n+                    if (_content.compareAndSet(DEMANDING, content))\n+                        return;\n+                }\n+                else if (c == null)\n+                {\n+                    if (!content.isSpecial())\n+                        throw new AssertionError(\"Non special content without demand\");\n+                    if (_content.compareAndSet(null, content))\n+                        return;\n+                }\n+                else if (c.isEof() && content.isEof() && content.isEmpty())\n+                {\n+                    content.succeeded();\n+                    return;\n+                }\n+                else if (content.getError() != null)\n+                {\n+                    if (c.getError() != null)\n+                    {\n+                        if (c.getError() != content.getError())\n+                            c.getError().addSuppressed(content.getError());\n+                        return;\n+                    }\n+                    if (_content.compareAndSet(c, content))\n+                    {\n+                        c.failed(content.getError());\n+                        return;\n+                    }\n+                }\n+                else if (c.getError() != null && content.remaining() == 0)\n+                {\n+                    content.succeeded();\n+                    return;\n+                }\n+                else\n+                {\n+                    throw new IllegalStateException(\"Cannot overwrite exiting content \" + c + \" with \" + content);\n+                }\n+            }\n+        }\n+\n+        public boolean onTimeout(Throwable failure)\n+        {\n+            while (true)\n+            {\n+                HttpInput.Content c = _content.get();\n+                if (c != DEMANDING)\n+                    return false;\n+                if (_content.compareAndSet(DEMANDING, new HttpInput.ErrorContent(failure)))\n+                    return true;\n+            }\n+        }\n+\n+        public void eof()\n+        {\n+            while (true)\n+            {\n+                HttpInput.Content c = _content.get();\n+                if (c == DEMANDING)\n+                {\n+                    if (_content.compareAndSet(DEMANDING, EOF))\n+                        return;\n+                }\n+                else if (c == null)\n+                {\n+                    if (_content.compareAndSet(null, EOF))\n+                        return;\n+                }\n+                else if (c.isEof())\n+                {\n+                    return;\n+                }\n+                else if (c.remaining() == 0)\n+                {\n+                    if (_content.compareAndSet(c, EOF))\n+                        return;\n+                }\n+                else\n+                {\n+                    HttpInput.Content content = new HttpInput.Content(c.getByteBuffer())", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "273213e8df4f438bf853787ec932e22424e7fe8b"}, "originalPosition": 257}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDkyNTI0OQ==", "bodyText": "Inline this.", "url": "https://github.com/eclipse/jetty.project/pull/4556#discussion_r504925249", "createdAt": "2020-10-14T19:37:29Z", "author": {"login": "sbordet"}, "path": "jetty-http2/http2-server/src/main/java/org/eclipse/jetty/http2/server/HttpChannelOverHTTP2.java", "diffHunk": "@@ -261,31 +264,265 @@ public InvocationType getInvocationType()\n             {\n                 return callback.getInvocationType();\n             }\n-        });\n+        };\n+        _contentDemander.onContent(content);\n+        boolean handle = onContent(content);\n \n         boolean endStream = frame.isEndStream();\n         if (endStream)\n         {\n             boolean handleContent = onContentComplete();\n+            // this will generate EOF -> must happen before wakeup\n             boolean handleRequest = onRequestComplete();\n             handle |= handleContent | handleRequest;\n         }\n \n+        boolean woken = getRequest().getHttpInput().wakeup();\n         if (LOG.isDebugEnabled())\n         {\n-            LOG.debug(\"HTTP2 Request #{}/{}: {} bytes of {} content, handle: {}\",\n+            Stream stream = getStream();\n+            LOG.debug(\"HTTP2 Request #{}/{}: {} bytes of {} content, woken: {}, handle: {}\",\n                     stream.getId(),\n                     Integer.toHexString(stream.getSession().hashCode()),\n                     length,\n                     endStream ? \"last\" : \"some\",\n+                    woken,\n                     handle);\n         }\n+        handle |= woken;\n \n         boolean wasDelayed = _delayedUntilContent;\n         _delayedUntilContent = false;\n         return handle || wasDelayed ? this : null;\n     }\n \n+    private static final HttpInput.Content EOF = new HttpInput.EofContent();\n+    private static final HttpInput.Content DEMANDING = new HttpInput.SpecialContent() {};\n+\n+    private class ContentDemander\n+    {\n+        private final AtomicReference<HttpInput.Content> _content = new AtomicReference<>();\n+\n+        public void recycle()\n+        {\n+            HttpInput.Content c = _content.getAndSet(null);\n+            if (c != null && !c.isSpecial())\n+                throw new AssertionError(\"unconsumed content: \" + c);\n+        }\n+\n+        public HttpInput.Content take()\n+        {\n+            while (true)\n+            {\n+                HttpInput.Content c = _content.get();\n+                if (c == null || c.isSpecial() || _content.compareAndSet(c, c.isEof() ? EOF : null))\n+                    return c;\n+            }\n+        }\n+\n+        public boolean demand()\n+        {\n+            while (true)\n+            {\n+                HttpInput.Content c = _content.get();\n+                if (c == DEMANDING)\n+                    return false;\n+                if (c != null)\n+                    return true;\n+                if (_content.compareAndSet(null, DEMANDING))\n+                {\n+                    IStream stream = getStream();\n+                    if (stream == null)\n+                    {\n+                        _content.set(null);\n+                        return false;\n+                    }\n+                    stream.demand(1);\n+                    c = _content.get();\n+                    return c != DEMANDING && c != null;\n+                }\n+            }\n+        }\n+\n+        public void onContent(HttpInput.Content content)\n+        {\n+            while (true)\n+            {\n+                HttpInput.Content c = _content.get();\n+                if (c == DEMANDING)\n+                {\n+                    if (_content.compareAndSet(DEMANDING, content))\n+                        return;\n+                }\n+                else if (c == null)\n+                {\n+                    if (!content.isSpecial())\n+                        throw new AssertionError(\"Non special content without demand\");\n+                    if (_content.compareAndSet(null, content))\n+                        return;\n+                }\n+                else if (c.isEof() && content.isEof() && content.isEmpty())\n+                {\n+                    content.succeeded();\n+                    return;\n+                }\n+                else if (content.getError() != null)\n+                {\n+                    if (c.getError() != null)\n+                    {\n+                        if (c.getError() != content.getError())\n+                            c.getError().addSuppressed(content.getError());\n+                        return;\n+                    }\n+                    if (_content.compareAndSet(c, content))\n+                    {\n+                        c.failed(content.getError());\n+                        return;\n+                    }\n+                }\n+                else if (c.getError() != null && content.remaining() == 0)\n+                {\n+                    content.succeeded();\n+                    return;\n+                }\n+                else\n+                {\n+                    throw new IllegalStateException(\"Cannot overwrite exiting content \" + c + \" with \" + content);\n+                }\n+            }\n+        }\n+\n+        public boolean onTimeout(Throwable failure)\n+        {\n+            while (true)\n+            {\n+                HttpInput.Content c = _content.get();\n+                if (c != DEMANDING)\n+                    return false;\n+                if (_content.compareAndSet(DEMANDING, new HttpInput.ErrorContent(failure)))\n+                    return true;\n+            }\n+        }\n+\n+        public void eof()\n+        {\n+            while (true)\n+            {\n+                HttpInput.Content c = _content.get();\n+                if (c == DEMANDING)\n+                {\n+                    if (_content.compareAndSet(DEMANDING, EOF))\n+                        return;\n+                }\n+                else if (c == null)\n+                {\n+                    if (_content.compareAndSet(null, EOF))\n+                        return;\n+                }\n+                else if (c.isEof())\n+                {\n+                    return;\n+                }\n+                else if (c.remaining() == 0)\n+                {\n+                    if (_content.compareAndSet(c, EOF))\n+                        return;\n+                }\n+                else\n+                {\n+                    HttpInput.Content content = new HttpInput.Content(c.getByteBuffer())\n+                    {\n+                        @Override\n+                        public boolean isEof()\n+                        {\n+                            return true;\n+                        }\n+\n+                        @Override\n+                        public void succeeded()\n+                        {\n+                            c.succeeded();\n+                        }\n+\n+                        @Override\n+                        public void failed(Throwable x)\n+                        {\n+                            c.failed(x);\n+                        }\n+\n+                        @Override\n+                        public InvocationType getInvocationType()\n+                        {\n+                            return c.getInvocationType();\n+                        }\n+                    };\n+                    if (_content.compareAndSet(c, content))\n+                        return;\n+                }\n+            }\n+        }\n+\n+        public void failContent(Throwable failure)\n+        {\n+            while (true)\n+            {\n+                HttpInput.Content c = _content.get();\n+                if (c == null || c.isSpecial())\n+                    return;\n+                if (_content.compareAndSet(c, null))\n+                {\n+                    c.failed(failure);\n+                    return;\n+                }\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public boolean needContent()\n+    {\n+        boolean hasContent = _contentDemander.demand();\n+        return hasContent;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "273213e8df4f438bf853787ec932e22424e7fe8b"}, "originalPosition": 309}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDkyNzAzNw==", "bodyText": "Remove empty line.", "url": "https://github.com/eclipse/jetty.project/pull/4556#discussion_r504927037", "createdAt": "2020-10-14T19:40:43Z", "author": {"login": "sbordet"}, "path": "jetty-server/src/main/java/org/eclipse/jetty/server/AsyncContentProducer.java", "diffHunk": "@@ -0,0 +1,259 @@\n+//\n+// ========================================================================\n+// Copyright (c) 1995-2020 Mort Bay Consulting Pty Ltd and others.\n+//\n+// This program and the accompanying materials are made available under\n+// the terms of the Eclipse Public License 2.0 which is available at\n+// https://www.eclipse.org/legal/epl-2.0\n+//\n+// This Source Code may also be made available under the following\n+// Secondary Licenses when the conditions for such availability set\n+// forth in the Eclipse Public License, v. 2.0 are satisfied:\n+// the Apache License v2.0 which is available at\n+// https://www.apache.org/licenses/LICENSE-2.0\n+//\n+// SPDX-License-Identifier: EPL-2.0 OR Apache-2.0\n+// ========================================================================\n+//\n+\n+package org.eclipse.jetty.server;\n+\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jetty.http.BadMessageException;\n+import org.eclipse.jetty.http.HttpStatus;\n+\n+class AsyncContentProducer implements ContentProducer\n+{\n+    private final HttpChannel _httpChannel;\n+    private HttpInput.Interceptor _interceptor;\n+    private HttpInput.Content _rawContent;\n+    private HttpInput.Content _transformedContent;\n+    private boolean _error;\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "273213e8df4f438bf853787ec932e22424e7fe8b"}, "originalPosition": 33}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDkyNzI3Nw==", "bodyText": "Remove public.", "url": "https://github.com/eclipse/jetty.project/pull/4556#discussion_r504927277", "createdAt": "2020-10-14T19:41:07Z", "author": {"login": "sbordet"}, "path": "jetty-server/src/main/java/org/eclipse/jetty/server/AsyncContentProducer.java", "diffHunk": "@@ -0,0 +1,259 @@\n+//\n+// ========================================================================\n+// Copyright (c) 1995-2020 Mort Bay Consulting Pty Ltd and others.\n+//\n+// This program and the accompanying materials are made available under\n+// the terms of the Eclipse Public License 2.0 which is available at\n+// https://www.eclipse.org/legal/epl-2.0\n+//\n+// This Source Code may also be made available under the following\n+// Secondary Licenses when the conditions for such availability set\n+// forth in the Eclipse Public License, v. 2.0 are satisfied:\n+// the Apache License v2.0 which is available at\n+// https://www.apache.org/licenses/LICENSE-2.0\n+//\n+// SPDX-License-Identifier: EPL-2.0 OR Apache-2.0\n+// ========================================================================\n+//\n+\n+package org.eclipse.jetty.server;\n+\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jetty.http.BadMessageException;\n+import org.eclipse.jetty.http.HttpStatus;\n+\n+class AsyncContentProducer implements ContentProducer\n+{\n+    private final HttpChannel _httpChannel;\n+    private HttpInput.Interceptor _interceptor;\n+    private HttpInput.Content _rawContent;\n+    private HttpInput.Content _transformedContent;\n+    private boolean _error;\n+\n+    private long _firstByteTimeStamp = Long.MIN_VALUE;\n+    private long _rawContentArrived;\n+\n+    public AsyncContentProducer(HttpChannel httpChannel)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "273213e8df4f438bf853787ec932e22424e7fe8b"}, "originalPosition": 37}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDkyODM1Mw==", "bodyText": "What does it mean that \"the produceContent() mechanism does not guarantee that all available content will be returned\"?\nSeems like a bug if produceContent() does not return the content?", "url": "https://github.com/eclipse/jetty.project/pull/4556#discussion_r504928353", "createdAt": "2020-10-14T19:43:06Z", "author": {"login": "sbordet"}, "path": "jetty-server/src/main/java/org/eclipse/jetty/server/AsyncContentProducer.java", "diffHunk": "@@ -0,0 +1,259 @@\n+//\n+// ========================================================================\n+// Copyright (c) 1995-2020 Mort Bay Consulting Pty Ltd and others.\n+//\n+// This program and the accompanying materials are made available under\n+// the terms of the Eclipse Public License 2.0 which is available at\n+// https://www.eclipse.org/legal/epl-2.0\n+//\n+// This Source Code may also be made available under the following\n+// Secondary Licenses when the conditions for such availability set\n+// forth in the Eclipse Public License, v. 2.0 are satisfied:\n+// the Apache License v2.0 which is available at\n+// https://www.apache.org/licenses/LICENSE-2.0\n+//\n+// SPDX-License-Identifier: EPL-2.0 OR Apache-2.0\n+// ========================================================================\n+//\n+\n+package org.eclipse.jetty.server;\n+\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jetty.http.BadMessageException;\n+import org.eclipse.jetty.http.HttpStatus;\n+\n+class AsyncContentProducer implements ContentProducer\n+{\n+    private final HttpChannel _httpChannel;\n+    private HttpInput.Interceptor _interceptor;\n+    private HttpInput.Content _rawContent;\n+    private HttpInput.Content _transformedContent;\n+    private boolean _error;\n+\n+    private long _firstByteTimeStamp = Long.MIN_VALUE;\n+    private long _rawContentArrived;\n+\n+    public AsyncContentProducer(HttpChannel httpChannel)\n+    {\n+        _httpChannel = httpChannel;\n+    }\n+\n+    @Override\n+    public void recycle()\n+    {\n+        _interceptor = null;\n+        _rawContent = null;\n+        _transformedContent = null;\n+        _error = false;\n+        _firstByteTimeStamp = Long.MIN_VALUE;\n+        _rawContentArrived = 0L;\n+    }\n+\n+    @Override\n+    public HttpInput.Interceptor getInterceptor()\n+    {\n+        return _interceptor;\n+    }\n+\n+    @Override\n+    public void setInterceptor(HttpInput.Interceptor interceptor)\n+    {\n+        this._interceptor = interceptor;\n+    }\n+\n+    @Override\n+    public int available()\n+    {\n+        HttpInput.Content content = nextTransformedContent();\n+        return content == null ? 0 : content.remaining();\n+    }\n+\n+    @Override\n+    public boolean hasContent()\n+    {\n+        return _rawContent != null;\n+    }\n+\n+    @Override\n+    public boolean isError()\n+    {\n+        return _error;\n+    }\n+\n+    @Override\n+    public void checkMinDataRate()\n+    {\n+        long minRequestDataRate = _httpChannel.getHttpConfiguration().getMinRequestDataRate();\n+        if (minRequestDataRate > 0 && _firstByteTimeStamp != Long.MIN_VALUE)\n+        {\n+            long period = System.nanoTime() - _firstByteTimeStamp;\n+            if (period > 0)\n+            {\n+                long minimumData = minRequestDataRate * TimeUnit.NANOSECONDS.toMillis(period) / TimeUnit.SECONDS.toMillis(1);\n+                if (getRawContentArrived() < minimumData)\n+                {\n+                    BadMessageException bad = new BadMessageException(HttpStatus.REQUEST_TIMEOUT_408,\n+                        String.format(\"Request content data rate < %d B/s\", minRequestDataRate));\n+                    if (_httpChannel.getState().isResponseCommitted())\n+                        _httpChannel.abort(bad);\n+                    failCurrentContent(bad);\n+                    throw bad;\n+                }\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public long getRawContentArrived()\n+    {\n+        return _rawContentArrived;\n+    }\n+\n+    @Override\n+    public boolean consumeAll(Throwable x)\n+    {\n+        failCurrentContent(x);\n+        // A specific HttpChannel mechanism must be used as the normal produceContent()\n+        // mechanism does not guarantee that all available content will be returned;\n+        // tests in StreamResetTest cover this.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "273213e8df4f438bf853787ec932e22424e7fe8b"}, "originalPosition": 119}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDkyOTAyNg==", "bodyText": "Remove public.", "url": "https://github.com/eclipse/jetty.project/pull/4556#discussion_r504929026", "createdAt": "2020-10-14T19:44:09Z", "author": {"login": "sbordet"}, "path": "jetty-server/src/main/java/org/eclipse/jetty/server/BlockingContentProducer.java", "diffHunk": "@@ -0,0 +1,133 @@\n+//\n+// ========================================================================\n+// Copyright (c) 1995-2020 Mort Bay Consulting Pty Ltd and others.\n+//\n+// This program and the accompanying materials are made available under\n+// the terms of the Eclipse Public License 2.0 which is available at\n+// https://www.eclipse.org/legal/epl-2.0\n+//\n+// This Source Code may also be made available under the following\n+// Secondary Licenses when the conditions for such availability set\n+// forth in the Eclipse Public License, v. 2.0 are satisfied:\n+// the Apache License v2.0 which is available at\n+// https://www.apache.org/licenses/LICENSE-2.0\n+//\n+// SPDX-License-Identifier: EPL-2.0 OR Apache-2.0\n+// ========================================================================\n+//\n+\n+package org.eclipse.jetty.server;\n+\n+import java.util.concurrent.Semaphore;\n+\n+class BlockingContentProducer implements ContentProducer\n+{\n+    private final Semaphore _semaphore = new Semaphore(0);\n+    private final AsyncContentProducer _asyncContentProducer;\n+    private final HttpChannel _httpChannel;\n+\n+    public BlockingContentProducer(HttpChannel httpChannel, AsyncContentProducer delegate)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "273213e8df4f438bf853787ec932e22424e7fe8b"}, "originalPosition": 29}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDkzMTYyNg==", "bodyText": "What's this comment?", "url": "https://github.com/eclipse/jetty.project/pull/4556#discussion_r504931626", "createdAt": "2020-10-14T19:49:06Z", "author": {"login": "sbordet"}, "path": "jetty-server/src/main/java/org/eclipse/jetty/server/BlockingContentProducer.java", "diffHunk": "@@ -0,0 +1,133 @@\n+//\n+// ========================================================================\n+// Copyright (c) 1995-2020 Mort Bay Consulting Pty Ltd and others.\n+//\n+// This program and the accompanying materials are made available under\n+// the terms of the Eclipse Public License 2.0 which is available at\n+// https://www.eclipse.org/legal/epl-2.0\n+//\n+// This Source Code may also be made available under the following\n+// Secondary Licenses when the conditions for such availability set\n+// forth in the Eclipse Public License, v. 2.0 are satisfied:\n+// the Apache License v2.0 which is available at\n+// https://www.apache.org/licenses/LICENSE-2.0\n+//\n+// SPDX-License-Identifier: EPL-2.0 OR Apache-2.0\n+// ========================================================================\n+//\n+\n+package org.eclipse.jetty.server;\n+\n+import java.util.concurrent.Semaphore;\n+\n+class BlockingContentProducer implements ContentProducer\n+{\n+    private final Semaphore _semaphore = new Semaphore(0);\n+    private final AsyncContentProducer _asyncContentProducer;\n+    private final HttpChannel _httpChannel;\n+\n+    public BlockingContentProducer(HttpChannel httpChannel, AsyncContentProducer delegate)\n+    {\n+        _asyncContentProducer = delegate;\n+        _httpChannel = httpChannel;\n+    }\n+\n+    @Override\n+    public void recycle()\n+    {\n+        _asyncContentProducer.recycle();\n+    }\n+\n+    @Override\n+    public int available()\n+    {\n+        return _asyncContentProducer.available();\n+    }\n+\n+    @Override\n+    public boolean hasContent()\n+    {\n+        return _asyncContentProducer.hasContent();\n+    }\n+\n+    @Override\n+    public boolean isError()\n+    {\n+        return _asyncContentProducer.isError();\n+    }\n+\n+    @Override\n+    public void checkMinDataRate()\n+    {\n+        _asyncContentProducer.checkMinDataRate();\n+    }\n+\n+    @Override\n+    public long getRawContentArrived()\n+    {\n+        return _asyncContentProducer.getRawContentArrived();\n+    }\n+\n+    @Override\n+    public boolean consumeAll(Throwable x)\n+    {\n+        return _asyncContentProducer.consumeAll(x);\n+    }\n+\n+    @Override\n+    public HttpInput.Content nextContent()\n+    {\n+        while (true)\n+        {\n+            HttpInput.Content content = _asyncContentProducer.nextContent();\n+            if (content != null)\n+                return content;\n+\n+            _semaphore.drainPermits();\n+            _httpChannel.getState().onReadUnready();\n+            if (_httpChannel.needContent())\n+                continue;\n+\n+            try\n+            {\n+                _semaphore.acquire();\n+            }\n+            catch (InterruptedException e)\n+            {\n+                return new HttpInput.ErrorContent(e);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void reclaim(HttpInput.Content content)\n+    {\n+        _asyncContentProducer.reclaim(content);\n+    }\n+\n+    @Override\n+    public boolean isReady()\n+    {\n+        return available() > 0;\n+    }\n+\n+    @Override\n+    public HttpInput.Interceptor getInterceptor()\n+    {\n+        return _asyncContentProducer.getInterceptor();\n+    }\n+\n+    @Override\n+    public void setInterceptor(HttpInput.Interceptor interceptor)\n+    {\n+        _asyncContentProducer.setInterceptor(interceptor);\n+    }\n+\n+    @Override\n+    public boolean wakeup()\n+    {\n+        // Calling _asyncContentProducer.wakeup() breaks AsyncIOServletTest.testAsyncWriteThrowsError H2C.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "273213e8df4f438bf853787ec932e22424e7fe8b"}, "originalPosition": 129}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDkzMTg5Mg==", "bodyText": "Empty line.", "url": "https://github.com/eclipse/jetty.project/pull/4556#discussion_r504931892", "createdAt": "2020-10-14T19:49:31Z", "author": {"login": "sbordet"}, "path": "jetty-server/src/main/java/org/eclipse/jetty/server/ContentProducer.java", "diffHunk": "@@ -0,0 +1,87 @@\n+//\n+// ========================================================================\n+// Copyright (c) 1995-2020 Mort Bay Consulting Pty Ltd and others.\n+//\n+// This program and the accompanying materials are made available under\n+// the terms of the Eclipse Public License 2.0 which is available at\n+// https://www.eclipse.org/legal/epl-2.0\n+//\n+// This Source Code may also be made available under the following\n+// Secondary Licenses when the conditions for such availability set\n+// forth in the Eclipse Public License, v. 2.0 are satisfied:\n+// the Apache License v2.0 which is available at\n+// https://www.apache.org/licenses/LICENSE-2.0\n+//\n+// SPDX-License-Identifier: EPL-2.0 OR Apache-2.0\n+// ========================================================================\n+//\n+\n+package org.eclipse.jetty.server;\n+\n+public interface ContentProducer\n+{\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "273213e8df4f438bf853787ec932e22424e7fe8b"}, "originalPosition": 23}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDkzMTk1MQ==", "bodyText": "javadocs, for the class and for all the methods.\nWhat's currently there does not explain what the method does, e.g. getRawContentArrived() does what?", "url": "https://github.com/eclipse/jetty.project/pull/4556#discussion_r504931951", "createdAt": "2020-10-14T19:49:39Z", "author": {"login": "sbordet"}, "path": "jetty-server/src/main/java/org/eclipse/jetty/server/ContentProducer.java", "diffHunk": "@@ -0,0 +1,87 @@\n+//\n+// ========================================================================\n+// Copyright (c) 1995-2020 Mort Bay Consulting Pty Ltd and others.\n+//\n+// This program and the accompanying materials are made available under\n+// the terms of the Eclipse Public License 2.0 which is available at\n+// https://www.eclipse.org/legal/epl-2.0\n+//\n+// This Source Code may also be made available under the following\n+// Secondary Licenses when the conditions for such availability set\n+// forth in the Eclipse Public License, v. 2.0 are satisfied:\n+// the Apache License v2.0 which is available at\n+// https://www.apache.org/licenses/LICENSE-2.0\n+//\n+// SPDX-License-Identifier: EPL-2.0 OR Apache-2.0\n+// ========================================================================\n+//\n+\n+package org.eclipse.jetty.server;\n+\n+public interface ContentProducer", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "273213e8df4f438bf853787ec932e22424e7fe8b"}, "originalPosition": 21}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDk0NjMxMQ==", "bodyText": "Why do you need to call produceRawContent() again? This is consumeAll() so we just fail what we have, right?", "url": "https://github.com/eclipse/jetty.project/pull/4556#discussion_r504946311", "createdAt": "2020-10-14T20:16:09Z", "author": {"login": "sbordet"}, "path": "jetty-server/src/main/java/org/eclipse/jetty/server/AsyncContentProducer.java", "diffHunk": "@@ -0,0 +1,259 @@\n+//\n+// ========================================================================\n+// Copyright (c) 1995-2020 Mort Bay Consulting Pty Ltd and others.\n+//\n+// This program and the accompanying materials are made available under\n+// the terms of the Eclipse Public License 2.0 which is available at\n+// https://www.eclipse.org/legal/epl-2.0\n+//\n+// This Source Code may also be made available under the following\n+// Secondary Licenses when the conditions for such availability set\n+// forth in the Eclipse Public License, v. 2.0 are satisfied:\n+// the Apache License v2.0 which is available at\n+// https://www.apache.org/licenses/LICENSE-2.0\n+//\n+// SPDX-License-Identifier: EPL-2.0 OR Apache-2.0\n+// ========================================================================\n+//\n+\n+package org.eclipse.jetty.server;\n+\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jetty.http.BadMessageException;\n+import org.eclipse.jetty.http.HttpStatus;\n+\n+class AsyncContentProducer implements ContentProducer\n+{\n+    private final HttpChannel _httpChannel;\n+    private HttpInput.Interceptor _interceptor;\n+    private HttpInput.Content _rawContent;\n+    private HttpInput.Content _transformedContent;\n+    private boolean _error;\n+\n+    private long _firstByteTimeStamp = Long.MIN_VALUE;\n+    private long _rawContentArrived;\n+\n+    public AsyncContentProducer(HttpChannel httpChannel)\n+    {\n+        _httpChannel = httpChannel;\n+    }\n+\n+    @Override\n+    public void recycle()\n+    {\n+        _interceptor = null;\n+        _rawContent = null;\n+        _transformedContent = null;\n+        _error = false;\n+        _firstByteTimeStamp = Long.MIN_VALUE;\n+        _rawContentArrived = 0L;\n+    }\n+\n+    @Override\n+    public HttpInput.Interceptor getInterceptor()\n+    {\n+        return _interceptor;\n+    }\n+\n+    @Override\n+    public void setInterceptor(HttpInput.Interceptor interceptor)\n+    {\n+        this._interceptor = interceptor;\n+    }\n+\n+    @Override\n+    public int available()\n+    {\n+        HttpInput.Content content = nextTransformedContent();\n+        return content == null ? 0 : content.remaining();\n+    }\n+\n+    @Override\n+    public boolean hasContent()\n+    {\n+        return _rawContent != null;\n+    }\n+\n+    @Override\n+    public boolean isError()\n+    {\n+        return _error;\n+    }\n+\n+    @Override\n+    public void checkMinDataRate()\n+    {\n+        long minRequestDataRate = _httpChannel.getHttpConfiguration().getMinRequestDataRate();\n+        if (minRequestDataRate > 0 && _firstByteTimeStamp != Long.MIN_VALUE)\n+        {\n+            long period = System.nanoTime() - _firstByteTimeStamp;\n+            if (period > 0)\n+            {\n+                long minimumData = minRequestDataRate * TimeUnit.NANOSECONDS.toMillis(period) / TimeUnit.SECONDS.toMillis(1);\n+                if (getRawContentArrived() < minimumData)\n+                {\n+                    BadMessageException bad = new BadMessageException(HttpStatus.REQUEST_TIMEOUT_408,\n+                        String.format(\"Request content data rate < %d B/s\", minRequestDataRate));\n+                    if (_httpChannel.getState().isResponseCommitted())\n+                        _httpChannel.abort(bad);\n+                    failCurrentContent(bad);\n+                    throw bad;\n+                }\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public long getRawContentArrived()\n+    {\n+        return _rawContentArrived;\n+    }\n+\n+    @Override\n+    public boolean consumeAll(Throwable x)\n+    {\n+        failCurrentContent(x);\n+        // A specific HttpChannel mechanism must be used as the normal produceContent()\n+        // mechanism does not guarantee that all available content will be returned;\n+        // tests in StreamResetTest cover this.\n+        _httpChannel.failContent(x);\n+        HttpInput.Content c = produceRawContent();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "273213e8df4f438bf853787ec932e22424e7fe8b"}, "originalPosition": 121}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDk0ODQwMA==", "bodyText": "Why this call may block? Isn't it wrong that there is a blocking method if it can be implemented by AsyncContentProducer?", "url": "https://github.com/eclipse/jetty.project/pull/4556#discussion_r504948400", "createdAt": "2020-10-14T20:20:04Z", "author": {"login": "sbordet"}, "path": "jetty-server/src/main/java/org/eclipse/jetty/server/ContentProducer.java", "diffHunk": "@@ -0,0 +1,87 @@\n+//\n+// ========================================================================\n+// Copyright (c) 1995-2020 Mort Bay Consulting Pty Ltd and others.\n+//\n+// This program and the accompanying materials are made available under\n+// the terms of the Eclipse Public License 2.0 which is available at\n+// https://www.eclipse.org/legal/epl-2.0\n+//\n+// This Source Code may also be made available under the following\n+// Secondary Licenses when the conditions for such availability set\n+// forth in the Eclipse Public License, v. 2.0 are satisfied:\n+// the Apache License v2.0 which is available at\n+// https://www.apache.org/licenses/LICENSE-2.0\n+//\n+// SPDX-License-Identifier: EPL-2.0 OR Apache-2.0\n+// ========================================================================\n+//\n+\n+package org.eclipse.jetty.server;\n+\n+public interface ContentProducer\n+{\n+\n+    void recycle();\n+\n+    /**\n+     * This call is always non-blocking.\n+     * Doesn't change state.\n+     * @return true if EOF was reached.\n+     */\n+    boolean consumeAll(Throwable x);\n+\n+    void checkMinDataRate();\n+\n+    /**\n+     * This call is always non-blocking.\n+     * Doesn't change state.\n+     */\n+    long getRawContentArrived();\n+\n+    /**\n+     * This call is always non-blocking.\n+     * Doesn't change state.\n+     */\n+    int available();\n+\n+    /**\n+     * This call is always non-blocking.\n+     * Doesn't change state.\n+     * Doesn't query the HttpChannel.\n+     */\n+    boolean hasContent();\n+\n+    /**\n+     * This call is always non-blocking.\n+     * Doesn't change state.\n+     * Doesn't query the HttpChannel.\n+     */\n+    boolean isError();\n+\n+    /**\n+     * This call may block.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "273213e8df4f438bf853787ec932e22424e7fe8b"}, "originalPosition": 62}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDk1NDk2Nw==", "bodyText": "It's not true that _specialContent is only accessed by one thread. It is set by the scheduler thread during idle timeouts.", "url": "https://github.com/eclipse/jetty.project/pull/4556#discussion_r504954967", "createdAt": "2020-10-14T20:32:33Z", "author": {"login": "sbordet"}, "path": "jetty-server/src/main/java/org/eclipse/jetty/server/HttpChannelOverHttp.java", "diffHunk": "@@ -61,6 +62,15 @@\n     private boolean _expect102Processing = false;\n     private List<String> _complianceViolations;\n     private HttpFields.Mutable _trailers;\n+    // Both _content and _specialContent don't need to be volatile nor protected by a lock\n+    // as they're always accessed by the same thread, i.e.: we get notified by onFillable\n+    // that the socket contains new bytes and either schedule an onDataAvailable\n+    // call that is going to read the socket or release the blocking semaphore to wake up\n+    // the blocked reader and make it read the socket. The same logic is true for async\n+    // events like timeout: we get notified and either schedule onError or release the\n+    // blocking semaphore.\n+    private HttpInput.Content _content;\n+    private HttpInput.Content _specialContent;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "273213e8df4f438bf853787ec932e22424e7fe8b"}, "originalPosition": 20}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTMzMTAwNg==", "bodyText": "Why is not this call needed for the async case?\nFeels that blocking may be implemented in terms of async with just the semaphore, but only in this case we need an additional state change?", "url": "https://github.com/eclipse/jetty.project/pull/4556#discussion_r505331006", "createdAt": "2020-10-15T08:24:25Z", "author": {"login": "sbordet"}, "path": "jetty-server/src/main/java/org/eclipse/jetty/server/BlockingContentProducer.java", "diffHunk": "@@ -0,0 +1,133 @@\n+//\n+// ========================================================================\n+// Copyright (c) 1995-2020 Mort Bay Consulting Pty Ltd and others.\n+//\n+// This program and the accompanying materials are made available under\n+// the terms of the Eclipse Public License 2.0 which is available at\n+// https://www.eclipse.org/legal/epl-2.0\n+//\n+// This Source Code may also be made available under the following\n+// Secondary Licenses when the conditions for such availability set\n+// forth in the Eclipse Public License, v. 2.0 are satisfied:\n+// the Apache License v2.0 which is available at\n+// https://www.apache.org/licenses/LICENSE-2.0\n+//\n+// SPDX-License-Identifier: EPL-2.0 OR Apache-2.0\n+// ========================================================================\n+//\n+\n+package org.eclipse.jetty.server;\n+\n+import java.util.concurrent.Semaphore;\n+\n+class BlockingContentProducer implements ContentProducer\n+{\n+    private final Semaphore _semaphore = new Semaphore(0);\n+    private final AsyncContentProducer _asyncContentProducer;\n+    private final HttpChannel _httpChannel;\n+\n+    public BlockingContentProducer(HttpChannel httpChannel, AsyncContentProducer delegate)\n+    {\n+        _asyncContentProducer = delegate;\n+        _httpChannel = httpChannel;\n+    }\n+\n+    @Override\n+    public void recycle()\n+    {\n+        _asyncContentProducer.recycle();\n+    }\n+\n+    @Override\n+    public int available()\n+    {\n+        return _asyncContentProducer.available();\n+    }\n+\n+    @Override\n+    public boolean hasContent()\n+    {\n+        return _asyncContentProducer.hasContent();\n+    }\n+\n+    @Override\n+    public boolean isError()\n+    {\n+        return _asyncContentProducer.isError();\n+    }\n+\n+    @Override\n+    public void checkMinDataRate()\n+    {\n+        _asyncContentProducer.checkMinDataRate();\n+    }\n+\n+    @Override\n+    public long getRawContentArrived()\n+    {\n+        return _asyncContentProducer.getRawContentArrived();\n+    }\n+\n+    @Override\n+    public boolean consumeAll(Throwable x)\n+    {\n+        return _asyncContentProducer.consumeAll(x);\n+    }\n+\n+    @Override\n+    public HttpInput.Content nextContent()\n+    {\n+        while (true)\n+        {\n+            HttpInput.Content content = _asyncContentProducer.nextContent();\n+            if (content != null)\n+                return content;\n+\n+            _semaphore.drainPermits();\n+            _httpChannel.getState().onReadUnready();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "273213e8df4f438bf853787ec932e22424e7fe8b"}, "originalPosition": 87}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA5MTcyNTgz", "url": "https://github.com/eclipse/jetty.project/pull/4556#pullrequestreview-509172583", "createdAt": "2020-10-15T09:08:59Z", "commit": {"oid": "273213e8df4f438bf853787ec932e22424e7fe8b"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNVQwOTowODo1OVrOHh987A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNVQwOTowODo1OVrOHh987A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTM4MDA3Ng==", "bodyText": "It needs to be PRECISELY that only when needContent returns false will there be some callback that will release the semaphore. So we need to only ever acquire the semaphore in that case. We then don't need drain permits.       I'm still thinking needContent(Callback) is the way to go.", "url": "https://github.com/eclipse/jetty.project/pull/4556#discussion_r505380076", "createdAt": "2020-10-15T09:08:59Z", "author": {"login": "gregw"}, "path": "jetty-server/src/main/java/org/eclipse/jetty/server/BlockingContentProducer.java", "diffHunk": "@@ -0,0 +1,133 @@\n+//\n+// ========================================================================\n+// Copyright (c) 1995-2020 Mort Bay Consulting Pty Ltd and others.\n+//\n+// This program and the accompanying materials are made available under\n+// the terms of the Eclipse Public License 2.0 which is available at\n+// https://www.eclipse.org/legal/epl-2.0\n+//\n+// This Source Code may also be made available under the following\n+// Secondary Licenses when the conditions for such availability set\n+// forth in the Eclipse Public License, v. 2.0 are satisfied:\n+// the Apache License v2.0 which is available at\n+// https://www.apache.org/licenses/LICENSE-2.0\n+//\n+// SPDX-License-Identifier: EPL-2.0 OR Apache-2.0\n+// ========================================================================\n+//\n+\n+package org.eclipse.jetty.server;\n+\n+import java.util.concurrent.Semaphore;\n+\n+class BlockingContentProducer implements ContentProducer\n+{\n+    private final Semaphore _semaphore = new Semaphore(0);\n+    private final AsyncContentProducer _asyncContentProducer;\n+    private final HttpChannel _httpChannel;\n+\n+    public BlockingContentProducer(HttpChannel httpChannel, AsyncContentProducer delegate)\n+    {\n+        _asyncContentProducer = delegate;\n+        _httpChannel = httpChannel;\n+    }\n+\n+    @Override\n+    public void recycle()\n+    {\n+        _asyncContentProducer.recycle();\n+    }\n+\n+    @Override\n+    public int available()\n+    {\n+        return _asyncContentProducer.available();\n+    }\n+\n+    @Override\n+    public boolean hasContent()\n+    {\n+        return _asyncContentProducer.hasContent();\n+    }\n+\n+    @Override\n+    public boolean isError()\n+    {\n+        return _asyncContentProducer.isError();\n+    }\n+\n+    @Override\n+    public void checkMinDataRate()\n+    {\n+        _asyncContentProducer.checkMinDataRate();\n+    }\n+\n+    @Override\n+    public long getRawContentArrived()\n+    {\n+        return _asyncContentProducer.getRawContentArrived();\n+    }\n+\n+    @Override\n+    public boolean consumeAll(Throwable x)\n+    {\n+        return _asyncContentProducer.consumeAll(x);\n+    }\n+\n+    @Override\n+    public HttpInput.Content nextContent()\n+    {\n+        while (true)\n+        {\n+            HttpInput.Content content = _asyncContentProducer.nextContent();\n+            if (content != null)\n+                return content;\n+\n+            _semaphore.drainPermits();\n+            _httpChannel.getState().onReadUnready();\n+            if (_httpChannel.needContent())", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "273213e8df4f438bf853787ec932e22424e7fe8b"}, "originalPosition": 88}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA5MTY2NzUw", "url": "https://github.com/eclipse/jetty.project/pull/4556#pullrequestreview-509166750", "createdAt": "2020-10-15T09:02:03Z", "commit": {"oid": "273213e8df4f438bf853787ec932e22424e7fe8b"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 27, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNVQwOTowMjowM1rOHh9o0w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNVQxMDoxNDowNFrOHiAw1w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTM3NDkzMQ==", "bodyText": "Also, feels weird that we are not forwarding to _asyncContextProducer -- if really not needed, it deserves a comment.", "url": "https://github.com/eclipse/jetty.project/pull/4556#discussion_r505374931", "createdAt": "2020-10-15T09:02:03Z", "author": {"login": "sbordet"}, "path": "jetty-server/src/main/java/org/eclipse/jetty/server/BlockingContentProducer.java", "diffHunk": "@@ -0,0 +1,133 @@\n+//\n+// ========================================================================\n+// Copyright (c) 1995-2020 Mort Bay Consulting Pty Ltd and others.\n+//\n+// This program and the accompanying materials are made available under\n+// the terms of the Eclipse Public License 2.0 which is available at\n+// https://www.eclipse.org/legal/epl-2.0\n+//\n+// This Source Code may also be made available under the following\n+// Secondary Licenses when the conditions for such availability set\n+// forth in the Eclipse Public License, v. 2.0 are satisfied:\n+// the Apache License v2.0 which is available at\n+// https://www.apache.org/licenses/LICENSE-2.0\n+//\n+// SPDX-License-Identifier: EPL-2.0 OR Apache-2.0\n+// ========================================================================\n+//\n+\n+package org.eclipse.jetty.server;\n+\n+import java.util.concurrent.Semaphore;\n+\n+class BlockingContentProducer implements ContentProducer\n+{\n+    private final Semaphore _semaphore = new Semaphore(0);\n+    private final AsyncContentProducer _asyncContentProducer;\n+    private final HttpChannel _httpChannel;\n+\n+    public BlockingContentProducer(HttpChannel httpChannel, AsyncContentProducer delegate)\n+    {\n+        _asyncContentProducer = delegate;\n+        _httpChannel = httpChannel;\n+    }\n+\n+    @Override\n+    public void recycle()\n+    {\n+        _asyncContentProducer.recycle();\n+    }\n+\n+    @Override\n+    public int available()\n+    {\n+        return _asyncContentProducer.available();\n+    }\n+\n+    @Override\n+    public boolean hasContent()\n+    {\n+        return _asyncContentProducer.hasContent();\n+    }\n+\n+    @Override\n+    public boolean isError()\n+    {\n+        return _asyncContentProducer.isError();\n+    }\n+\n+    @Override\n+    public void checkMinDataRate()\n+    {\n+        _asyncContentProducer.checkMinDataRate();\n+    }\n+\n+    @Override\n+    public long getRawContentArrived()\n+    {\n+        return _asyncContentProducer.getRawContentArrived();\n+    }\n+\n+    @Override\n+    public boolean consumeAll(Throwable x)\n+    {\n+        return _asyncContentProducer.consumeAll(x);\n+    }\n+\n+    @Override\n+    public HttpInput.Content nextContent()\n+    {\n+        while (true)\n+        {\n+            HttpInput.Content content = _asyncContentProducer.nextContent();\n+            if (content != null)\n+                return content;\n+\n+            _semaphore.drainPermits();\n+            _httpChannel.getState().onReadUnready();\n+            if (_httpChannel.needContent())\n+                continue;\n+\n+            try\n+            {\n+                _semaphore.acquire();\n+            }\n+            catch (InterruptedException e)\n+            {\n+                return new HttpInput.ErrorContent(e);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void reclaim(HttpInput.Content content)\n+    {\n+        _asyncContentProducer.reclaim(content);\n+    }\n+\n+    @Override\n+    public boolean isReady()\n+    {\n+        return available() > 0;\n+    }\n+\n+    @Override\n+    public HttpInput.Interceptor getInterceptor()\n+    {\n+        return _asyncContentProducer.getInterceptor();\n+    }\n+\n+    @Override\n+    public void setInterceptor(HttpInput.Interceptor interceptor)\n+    {\n+        _asyncContentProducer.setInterceptor(interceptor);\n+    }\n+\n+    @Override\n+    public boolean wakeup()\n+    {\n+        // Calling _asyncContentProducer.wakeup() breaks AsyncIOServletTest.testAsyncWriteThrowsError H2C.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDkzMTYyNg=="}, "originalCommit": {"oid": "273213e8df4f438bf853787ec932e22424e7fe8b"}, "originalPosition": 129}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTM3NjM4NQ==", "bodyText": "Typo: should be \"onReadEof\".", "url": "https://github.com/eclipse/jetty.project/pull/4556#discussion_r505376385", "createdAt": "2020-10-15T09:03:59Z", "author": {"login": "sbordet"}, "path": "jetty-server/src/main/java/org/eclipse/jetty/server/HttpChannelState.java", "diffHunk": "@@ -1223,78 +1211,53 @@ public void setAttribute(String name, Object attribute)\n     }\n \n     /**\n-     * Called to signal async read isReady() has returned false.\n-     * This indicates that there is no content available to be consumed\n-     * and that once the channel enters the ASYNC_WAIT state it will\n-     * register for read interest by calling {@link HttpChannel#onAsyncWaitForContent()}\n-     * either from this method or from a subsequent call to {@link #unhandle()}.\n+     * Called to signal that the channel is ready for a callback.\n+     *\n+     * @return true if woken\n      */\n-    public void onReadUnready()\n+    public boolean onReadReady()\n     {\n-        boolean interested = false;\n+        boolean woken = false;\n         try (AutoLock l = lock())\n         {\n             if (LOG.isDebugEnabled())\n-                LOG.debug(\"onReadUnready {}\", toStringLocked());\n+                LOG.debug(\"onReadReady {}\", toStringLocked());\n \n             switch (_inputState)\n             {\n-                case IDLE:\n                 case READY:\n+                    _inputState = InputState.READY;\n+                    break;\n+                case IDLE:\n+                case UNREADY:\n+                    _inputState = InputState.READY;\n                     if (_state == State.WAITING)\n                     {\n-                        interested = true;\n-                        _inputState = InputState.REGISTERED;\n-                    }\n-                    else\n-                    {\n-                        _inputState = InputState.REGISTER;\n+                        woken = true;\n+                        _state = State.WOKEN;\n                     }\n                     break;\n \n-                case REGISTER:\n-                case REGISTERED:\n-                case POSSIBLE:\n-                case PRODUCING:\n-                    break;\n-\n                 default:\n                     throw new IllegalStateException(toStringLocked());\n             }\n         }\n-\n-        if (interested)\n-            _channel.onAsyncWaitForContent();\n+        return woken;\n     }\n \n-    /**\n-     * Called to signal that content is now available to read.\n-     * If the channel is in ASYNC_WAIT state and unready (ie isReady() has\n-     * returned false), then the state is changed to ASYNC_WOKEN and true\n-     * is returned.\n-     *\n-     * @return True IFF the channel was unready and in ASYNC_WAIT state\n-     */\n-    public boolean onContentAdded()\n+    public boolean onReadEof()\n     {\n         boolean woken = false;\n         try (AutoLock l = lock())\n         {\n             if (LOG.isDebugEnabled())\n-                LOG.debug(\"onContentAdded {}\", toStringLocked());\n+                LOG.debug(\"onReadReady {}\", toStringLocked());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "273213e8df4f438bf853787ec932e22424e7fe8b"}, "originalPosition": 126}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTM3NjcwNg==", "bodyText": "Typo: should be \"onReadIdle\".", "url": "https://github.com/eclipse/jetty.project/pull/4556#discussion_r505376706", "createdAt": "2020-10-15T09:04:29Z", "author": {"login": "sbordet"}, "path": "jetty-server/src/main/java/org/eclipse/jetty/server/HttpChannelState.java", "diffHunk": "@@ -1329,77 +1283,62 @@ public boolean onReadReady()\n             switch (_inputState)\n             {\n                 case IDLE:\n+                case UNREADY:\n+                case READY:\n                     _inputState = InputState.READY;\n-                    if (_state == State.WAITING)\n-                    {\n-                        woken = true;\n-                        _state = State.WOKEN;\n-                    }\n                     break;\n \n                 default:\n                     throw new IllegalStateException(toStringLocked());\n             }\n         }\n-        return woken;\n     }\n \n-    /**\n-     * Called to indicate that more content may be available,\n-     * but that a handling thread may need to produce (fill/parse)\n-     * it.  Typically called by the async read success callback.\n-     *\n-     * @return {@code true} if more content may be available\n-     */\n-    public boolean onReadPossible()\n+    public void onReadIdle()\n     {\n-        boolean woken = false;\n         try (AutoLock l = lock())\n         {\n             if (LOG.isDebugEnabled())\n-                LOG.debug(\"onReadPossible {}\", toStringLocked());\n+                LOG.debug(\"onReadReady {}\", toStringLocked());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "273213e8df4f438bf853787ec932e22424e7fe8b"}, "originalPosition": 199}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTM3Njk5NA==", "bodyText": "Typo: should be \"onReadUnready\".", "url": "https://github.com/eclipse/jetty.project/pull/4556#discussion_r505376994", "createdAt": "2020-10-15T09:04:51Z", "author": {"login": "sbordet"}, "path": "jetty-server/src/main/java/org/eclipse/jetty/server/HttpChannelState.java", "diffHunk": "@@ -1329,77 +1283,62 @@ public boolean onReadReady()\n             switch (_inputState)\n             {\n                 case IDLE:\n+                case UNREADY:\n+                case READY:\n                     _inputState = InputState.READY;\n-                    if (_state == State.WAITING)\n-                    {\n-                        woken = true;\n-                        _state = State.WOKEN;\n-                    }\n                     break;\n \n                 default:\n                     throw new IllegalStateException(toStringLocked());\n             }\n         }\n-        return woken;\n     }\n \n-    /**\n-     * Called to indicate that more content may be available,\n-     * but that a handling thread may need to produce (fill/parse)\n-     * it.  Typically called by the async read success callback.\n-     *\n-     * @return {@code true} if more content may be available\n-     */\n-    public boolean onReadPossible()\n+    public void onReadIdle()\n     {\n-        boolean woken = false;\n         try (AutoLock l = lock())\n         {\n             if (LOG.isDebugEnabled())\n-                LOG.debug(\"onReadPossible {}\", toStringLocked());\n+                LOG.debug(\"onReadReady {}\", toStringLocked());\n \n             switch (_inputState)\n             {\n-                case REGISTERED:\n-                    _inputState = InputState.POSSIBLE;\n-                    if (_state == State.WAITING)\n-                    {\n-                        woken = true;\n-                        _state = State.WOKEN;\n-                    }\n+                case UNREADY:\n+                case READY:\n+                case IDLE:\n+                    _inputState = InputState.IDLE;\n                     break;\n \n                 default:\n                     throw new IllegalStateException(toStringLocked());\n             }\n         }\n-        return woken;\n     }\n \n     /**\n-     * Called to signal that a read has read -1.\n-     * Will wake if the read was called while in ASYNC_WAIT state\n-     *\n-     * @return {@code true} if woken\n+     * Called to indicate that more content may be available,\n+     * but that a handling thread may need to produce (fill/parse)\n+     * it.  Typically called by the async read success callback.\n      */\n-    public boolean onReadEof()\n+    public void onReadUnready()\n     {\n-        boolean woken = false;\n         try (AutoLock l = lock())\n         {\n             if (LOG.isDebugEnabled())\n-                LOG.debug(\"onEof {}\", toStringLocked());\n+                LOG.debug(\"onReadPossible {}\", toStringLocked());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "273213e8df4f438bf853787ec932e22424e7fe8b"}, "originalPosition": 240}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTM3Nzg1Nw==", "bodyText": "The comment is wrong, since parse() is called before fill().", "url": "https://github.com/eclipse/jetty.project/pull/4556#discussion_r505377857", "createdAt": "2020-10-15T09:06:01Z", "author": {"login": "sbordet"}, "path": "jetty-server/src/main/java/org/eclipse/jetty/server/HttpConnection.java", "diffHunk": "@@ -316,21 +314,20 @@ else if (filled < 0)\n     }\n \n     /**\n-     * Fill and parse data looking for content\n-     *\n-     * @return true if an {@link RequestHandler} method was called and it returned true;\n+     * Parse and fill data, looking for content\n      */\n-    protected boolean fillAndParseForContent()\n+    void parseAndFillForContent()\n     {\n-        boolean handled = false;\n+        // parseRequestBuffer() must always be called after fillRequestBuffer() otherwise this method doesn't trigger EOF/earlyEOF\n+        // which breaks AsyncRequestReadTest.testPartialReadThenShutdown()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "273213e8df4f438bf853787ec932e22424e7fe8b"}, "originalPosition": 30}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTM3OTYxOQ==", "bodyText": "Remove comment.", "url": "https://github.com/eclipse/jetty.project/pull/4556#discussion_r505379619", "createdAt": "2020-10-15T09:08:16Z", "author": {"login": "sbordet"}, "path": "jetty-server/src/main/java/org/eclipse/jetty/server/HttpConnection.java", "diffHunk": "@@ -666,46 +652,32 @@ public void failed(Throwable x)\n         }\n     }\n \n-    private class BlockingReadCallback implements Callback\n+    private class AsyncReadCallback implements Callback\n     {\n         @Override\n         public void succeeded()\n         {\n-            _input.unblock();\n+            if (_channel.getRequest().getHttpInput().wakeup())\n+                _channel.execute(_channel);\n         }\n \n         @Override\n         public void failed(Throwable x)\n         {\n-            _input.failed(x);\n+            if (_channel.failed(x))\n+                _channel.execute(_channel);\n         }\n \n         @Override\n         public InvocationType getInvocationType()\n         {\n             // This callback does not block, rather it wakes up the\n             // thread that is blocked waiting on the read.\n+            // Must be NON_BLOCKING otherwise ThreadStarvationTest.testReadStarvation fails.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "273213e8df4f438bf853787ec932e22424e7fe8b"}, "originalPosition": 118}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTM4MTIwNg==", "bodyText": "We don't want to execute() the channel here. This is async so we must be able to just use the caller thread to do all the work without another queue+dispatch to another thread.", "url": "https://github.com/eclipse/jetty.project/pull/4556#discussion_r505381206", "createdAt": "2020-10-15T09:10:23Z", "author": {"login": "sbordet"}, "path": "jetty-server/src/main/java/org/eclipse/jetty/server/HttpConnection.java", "diffHunk": "@@ -666,46 +652,32 @@ public void failed(Throwable x)\n         }\n     }\n \n-    private class BlockingReadCallback implements Callback\n+    private class AsyncReadCallback implements Callback\n     {\n         @Override\n         public void succeeded()\n         {\n-            _input.unblock();\n+            if (_channel.getRequest().getHttpInput().wakeup())\n+                _channel.execute(_channel);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "273213e8df4f438bf853787ec932e22424e7fe8b"}, "originalPosition": 102}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTM4MTU5NA==", "bodyText": "Again, I don't think we want to execute here.", "url": "https://github.com/eclipse/jetty.project/pull/4556#discussion_r505381594", "createdAt": "2020-10-15T09:10:53Z", "author": {"login": "sbordet"}, "path": "jetty-server/src/main/java/org/eclipse/jetty/server/HttpConnection.java", "diffHunk": "@@ -666,46 +652,32 @@ public void failed(Throwable x)\n         }\n     }\n \n-    private class BlockingReadCallback implements Callback\n+    private class AsyncReadCallback implements Callback\n     {\n         @Override\n         public void succeeded()\n         {\n-            _input.unblock();\n+            if (_channel.getRequest().getHttpInput().wakeup())\n+                _channel.execute(_channel);\n         }\n \n         @Override\n         public void failed(Throwable x)\n         {\n-            _input.failed(x);\n+            if (_channel.failed(x))\n+                _channel.execute(_channel);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "273213e8df4f438bf853787ec932e22424e7fe8b"}, "originalPosition": 110}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTM4OTM3OQ==", "bodyText": "This method should be removed because nobody uses it.\nIf we really want to keep it for information purposes, we really need a better name that says whether these are bytes arrived (but possibly not yet consumed by the application), or bytes consumed by the application via read(), and clarify whether these are before or after transformation (e.g. ungzipping).", "url": "https://github.com/eclipse/jetty.project/pull/4556#discussion_r505389379", "createdAt": "2020-10-15T09:21:21Z", "author": {"login": "sbordet"}, "path": "jetty-server/src/main/java/org/eclipse/jetty/server/Request.java", "diffHunk": "@@ -749,7 +749,7 @@ public long getContentLengthLong()\n \n     public long getContentRead()\n     {\n-        return _input.getContentConsumed();\n+        return _input.getContentReceived();\n     }\n ", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "273213e8df4f438bf853787ec932e22424e7fe8b"}, "originalPosition": 7}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTM4OTk1OA==", "bodyText": "Obsolete comment?", "url": "https://github.com/eclipse/jetty.project/pull/4556#discussion_r505389958", "createdAt": "2020-10-15T09:22:14Z", "author": {"login": "sbordet"}, "path": "jetty-server/src/main/java/org/eclipse/jetty/server/HttpInput.java", "diffHunk": "@@ -192,648 +83,183 @@ public Interceptor getInterceptor()\n      */\n     public void setInterceptor(Interceptor interceptor)\n     {\n-        _interceptor = interceptor;\n+        _contentProducer.setInterceptor(interceptor);\n     }\n \n     /**\n-     * Set the {@link Interceptor}, using a {@link ChainedInterceptor} if\n+     * Set the {@link Interceptor}, chaining it to the existing one if\n      * an {@link Interceptor} is already set.\n      *\n      * @param interceptor the next {@link Interceptor} in a chain\n      */\n     public void addInterceptor(Interceptor interceptor)\n     {\n-        if (_interceptor == null)\n-            _interceptor = interceptor;\n+        Interceptor currentInterceptor = _contentProducer.getInterceptor();\n+        if (currentInterceptor == null)\n+            _contentProducer.setInterceptor(interceptor);\n         else\n-            _interceptor = new ChainedInterceptor(_interceptor, interceptor);\n+            _contentProducer.setInterceptor(new ChainedInterceptor(currentInterceptor, interceptor));\n     }\n \n-    @Override\n-    public int available()\n-    {\n-        int available = 0;\n-        boolean woken = false;\n-        try (AutoLock l = _lock.lock())\n-        {\n-            if (_content == null)\n-                _content = _inputQ.poll();\n-            if (_content == null)\n-            {\n-                try\n-                {\n-                    produceContent();\n-                }\n-                catch (IOException e)\n-                {\n-                    woken = failed(e);\n-                }\n-                if (_content == null)\n-                    _content = _inputQ.poll();\n-            }\n-\n-            if (_content != null)\n-                available = _content.remaining();\n-        }\n-\n-        if (woken)\n-            wake();\n-        return available;\n-    }\n-\n-    protected void wake()\n-    {\n-        HttpChannel channel = _channelState.getHttpChannel();\n-        Executor executor = channel.getConnector().getServer().getThreadPool();\n-        executor.execute(channel);\n-    }\n-\n-    @Override\n-    public int read() throws IOException\n+    public long getContentReceived()\n     {\n-        int read = read(_oneByteBuffer, 0, 1);\n-        if (read == 0)\n-            throw new IllegalStateException(\"unready read=0\");\n-        return read < 0 ? -1 : _oneByteBuffer[0] & 0xFF;\n+        return _contentProducer.getRawContentArrived();\n     }\n \n-    @Override\n-    public int read(byte[] b, int off, int len) throws IOException\n+    public boolean consumeAll()\n     {\n-        boolean wake = false;\n-        int read;\n-        try (AutoLock l = _lock.lock())\n-        {\n-            // Calculate minimum request rate for DOS protection\n-            long minRequestDataRate = _channelState.getHttpChannel().getHttpConfiguration().getMinRequestDataRate();\n-            if (minRequestDataRate > 0 && _firstByteTimeStamp != -1)\n-            {\n-                long period = System.nanoTime() - _firstByteTimeStamp;\n-                if (period > 0)\n-                {\n-                    long minimumData = minRequestDataRate * TimeUnit.NANOSECONDS.toMillis(period) / TimeUnit.SECONDS.toMillis(1);\n-                    if (_contentArrived < minimumData)\n-                    {\n-                        BadMessageException bad = new BadMessageException(HttpStatus.REQUEST_TIMEOUT_408,\n-                            String.format(\"Request content data rate < %d B/s\", minRequestDataRate));\n-                        if (_channelState.isResponseCommitted())\n-                            _channelState.getHttpChannel().abort(bad);\n-                        throw bad;\n-                    }\n-                }\n-            }\n+        if (LOG.isDebugEnabled())\n+            LOG.debug(\"consume all\");\n+        boolean atEof = _contentProducer.consumeAll(new IOException(\"Unconsumed content\"));\n+        if (atEof)\n+            _consumedEof = true;\n \n-            // Consume content looking for bytes to read\n-            while (true)\n-            {\n-                Content item = nextContent();\n-                if (item != null)\n-                {\n-                    read = get(item, b, off, len);\n-                    if (LOG.isDebugEnabled())\n-                        LOG.debug(\"{} read {} from {}\", this, read, item);\n-\n-                    // Consume any following poison pills\n-                    if (item.isEmpty())\n-                        nextInterceptedContent();\n-                    break;\n-                }\n-\n-                // No content, so should we block?\n-                if (!_state.blockForContent(this))\n-                {\n-                    // Not blocking, so what should we return?\n-                    read = _state.noContent();\n-\n-                    if (read < 0)\n-                        // If EOF do we need to wake for allDataRead callback?\n-                        wake = _channelState.onReadEof();\n-                    break;\n-                }\n-            }\n-        }\n-\n-        if (wake)\n-            wake();\n-        return read;\n-    }\n+        if (isFinished())\n+            return !isError();\n \n-    /**\n-     * Called when derived implementations should attempt to produce more Content and add it via {@link #addContent(Content)}. For protocols that are constantly\n-     * producing (eg HTTP2) this can be left as a noop;\n-     *\n-     * @throws IOException if unable to produce content\n-     */\n-    protected void produceContent() throws IOException\n-    {\n+        // Modifying the state here to anything other than IDLE makes\n+        // ServerTimeoutsTest.testAsyncReadWithDelayedFirstContentWithDelayedDispatchIdleTimeoutFires H2C fail.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "273213e8df4f438bf853787ec932e22424e7fe8b"}, "originalPosition": 347}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTM5MjY0NQ==", "bodyText": "I would call reclaim() only after a check to see if content is consumed. Like this seems a weird call and forces to read the reclaim() implementation to make sure it does nothing if there still is content to consume.", "url": "https://github.com/eclipse/jetty.project/pull/4556#discussion_r505392645", "createdAt": "2020-10-15T09:26:06Z", "author": {"login": "sbordet"}, "path": "jetty-server/src/main/java/org/eclipse/jetty/server/HttpInput.java", "diffHunk": "@@ -192,648 +83,183 @@ public Interceptor getInterceptor()\n      */\n     public void setInterceptor(Interceptor interceptor)\n     {\n-        _interceptor = interceptor;\n+        _contentProducer.setInterceptor(interceptor);\n     }\n \n     /**\n-     * Set the {@link Interceptor}, using a {@link ChainedInterceptor} if\n+     * Set the {@link Interceptor}, chaining it to the existing one if\n      * an {@link Interceptor} is already set.\n      *\n      * @param interceptor the next {@link Interceptor} in a chain\n      */\n     public void addInterceptor(Interceptor interceptor)\n     {\n-        if (_interceptor == null)\n-            _interceptor = interceptor;\n+        Interceptor currentInterceptor = _contentProducer.getInterceptor();\n+        if (currentInterceptor == null)\n+            _contentProducer.setInterceptor(interceptor);\n         else\n-            _interceptor = new ChainedInterceptor(_interceptor, interceptor);\n+            _contentProducer.setInterceptor(new ChainedInterceptor(currentInterceptor, interceptor));\n     }\n \n-    @Override\n-    public int available()\n-    {\n-        int available = 0;\n-        boolean woken = false;\n-        try (AutoLock l = _lock.lock())\n-        {\n-            if (_content == null)\n-                _content = _inputQ.poll();\n-            if (_content == null)\n-            {\n-                try\n-                {\n-                    produceContent();\n-                }\n-                catch (IOException e)\n-                {\n-                    woken = failed(e);\n-                }\n-                if (_content == null)\n-                    _content = _inputQ.poll();\n-            }\n-\n-            if (_content != null)\n-                available = _content.remaining();\n-        }\n-\n-        if (woken)\n-            wake();\n-        return available;\n-    }\n-\n-    protected void wake()\n-    {\n-        HttpChannel channel = _channelState.getHttpChannel();\n-        Executor executor = channel.getConnector().getServer().getThreadPool();\n-        executor.execute(channel);\n-    }\n-\n-    @Override\n-    public int read() throws IOException\n+    public long getContentReceived()\n     {\n-        int read = read(_oneByteBuffer, 0, 1);\n-        if (read == 0)\n-            throw new IllegalStateException(\"unready read=0\");\n-        return read < 0 ? -1 : _oneByteBuffer[0] & 0xFF;\n+        return _contentProducer.getRawContentArrived();\n     }\n \n-    @Override\n-    public int read(byte[] b, int off, int len) throws IOException\n+    public boolean consumeAll()\n     {\n-        boolean wake = false;\n-        int read;\n-        try (AutoLock l = _lock.lock())\n-        {\n-            // Calculate minimum request rate for DOS protection\n-            long minRequestDataRate = _channelState.getHttpChannel().getHttpConfiguration().getMinRequestDataRate();\n-            if (minRequestDataRate > 0 && _firstByteTimeStamp != -1)\n-            {\n-                long period = System.nanoTime() - _firstByteTimeStamp;\n-                if (period > 0)\n-                {\n-                    long minimumData = minRequestDataRate * TimeUnit.NANOSECONDS.toMillis(period) / TimeUnit.SECONDS.toMillis(1);\n-                    if (_contentArrived < minimumData)\n-                    {\n-                        BadMessageException bad = new BadMessageException(HttpStatus.REQUEST_TIMEOUT_408,\n-                            String.format(\"Request content data rate < %d B/s\", minRequestDataRate));\n-                        if (_channelState.isResponseCommitted())\n-                            _channelState.getHttpChannel().abort(bad);\n-                        throw bad;\n-                    }\n-                }\n-            }\n+        if (LOG.isDebugEnabled())\n+            LOG.debug(\"consume all\");\n+        boolean atEof = _contentProducer.consumeAll(new IOException(\"Unconsumed content\"));\n+        if (atEof)\n+            _consumedEof = true;\n \n-            // Consume content looking for bytes to read\n-            while (true)\n-            {\n-                Content item = nextContent();\n-                if (item != null)\n-                {\n-                    read = get(item, b, off, len);\n-                    if (LOG.isDebugEnabled())\n-                        LOG.debug(\"{} read {} from {}\", this, read, item);\n-\n-                    // Consume any following poison pills\n-                    if (item.isEmpty())\n-                        nextInterceptedContent();\n-                    break;\n-                }\n-\n-                // No content, so should we block?\n-                if (!_state.blockForContent(this))\n-                {\n-                    // Not blocking, so what should we return?\n-                    read = _state.noContent();\n-\n-                    if (read < 0)\n-                        // If EOF do we need to wake for allDataRead callback?\n-                        wake = _channelState.onReadEof();\n-                    break;\n-                }\n-            }\n-        }\n-\n-        if (wake)\n-            wake();\n-        return read;\n-    }\n+        if (isFinished())\n+            return !isError();\n \n-    /**\n-     * Called when derived implementations should attempt to produce more Content and add it via {@link #addContent(Content)}. For protocols that are constantly\n-     * producing (eg HTTP2) this can be left as a noop;\n-     *\n-     * @throws IOException if unable to produce content\n-     */\n-    protected void produceContent() throws IOException\n-    {\n+        // Modifying the state here to anything other than IDLE makes\n+        // ServerTimeoutsTest.testAsyncReadWithDelayedFirstContentWithDelayedDispatchIdleTimeoutFires H2C fail.\n+        return false;\n     }\n \n-    /**\n-     * Called by channel when asynchronous IO needs to produce more content\n-     *\n-     * @throws IOException if unable to produce content\n-     */\n-    public void asyncReadProduce() throws IOException\n+    public boolean isError()\n     {\n-        try (AutoLock l = _lock.lock())\n-        {\n-            produceContent();\n-        }\n+        return _contentProducer.isError();\n     }\n \n-    /**\n-     * Get the next content from the inputQ, calling {@link #produceContent()} if need be. EOF is processed and state changed.\n-     *\n-     * @return the content or null if none available.\n-     * @throws IOException if retrieving the content fails\n-     */\n-    protected Content nextContent() throws IOException\n+    public boolean isAsync()\n     {\n-        Content content = nextNonSentinelContent();\n-        if (content == null && !isFinished())\n-        {\n-            produceContent();\n-            content = nextNonSentinelContent();\n-        }\n-        return content;\n+        return _readListener != null;\n     }\n \n-    /**\n-     * Poll the inputQ for Content. Consumed buffers and {@link SentinelContent}s are removed and EOF state updated if need be.\n-     *\n-     * @return Content or null\n-     */\n-    protected Content nextNonSentinelContent()\n-    {\n-        while (true)\n-        {\n-            // Get the next content (or EOF)\n-            Content content = nextInterceptedContent();\n-\n-            // If it is EOF, consume it here\n-            if (content instanceof SentinelContent)\n-            {\n-                // Consume the EOF content, either if it was original content\n-                // or if it was produced by interception\n-                consume(content);\n-                continue;\n-            }\n+    /* ServletInputStream */\n \n-            return content;\n-        }\n-    }\n-\n-    /**\n-     * Get the next readable from the inputQ, calling {@link #produceContent()} if need be. EOF is NOT processed and state is not changed.\n-     *\n-     * @return the content or EOF or null if none available.\n-     * @throws IOException if retrieving the content fails\n-     */\n-    protected Content produceNextContext() throws IOException\n+    @Override\n+    public boolean isFinished()\n     {\n-        Content content = nextInterceptedContent();\n-        if (content == null && !isFinished())\n-        {\n-            produceContent();\n-            content = nextInterceptedContent();\n-        }\n-        return content;\n+        boolean finished = _consumedEof;\n+        if (LOG.isDebugEnabled())\n+            LOG.debug(\"isFinished? {}\", finished);\n+        return finished;\n     }\n \n-    /**\n-     * Poll the inputQ for Content or EOF. Consumed buffers and non EOF {@link SentinelContent}s are removed. EOF state is not updated.\n-     * Interception is done within this method.\n-     *\n-     * @return Content with remaining, a {@link SentinelContent},  or null\n-     */\n-    protected Content nextInterceptedContent()\n+    @Override\n+    public boolean isReady()\n     {\n-        // If we have a chunk produced by interception\n-        if (_intercepted != null)\n+        boolean ready = _contentProducer.isReady();\n+        if (!ready)\n         {\n-            // Use it if it has any remaining content\n-            if (_intercepted.hasContent())\n-                return _intercepted;\n-\n-            // succeed the chunk\n-            _intercepted.succeeded();\n-            _intercepted = null;\n-        }\n-\n-        // If we don't have a Content under consideration, get\n-        // the next one off the input Q.\n-        if (_content == null)\n-            _content = _inputQ.poll();\n-\n-        // While we have content to consider.\n-        while (_content != null)\n-        {\n-            // Are we intercepting?\n-            if (_interceptor != null)\n-            {\n-                // Intercept the current content (may be called several\n-                // times for the same content\n-                _intercepted = _interceptor.readFrom(_content);\n-\n-                // If interception produced new content\n-                if (_intercepted != null && _intercepted != _content)\n-                {\n-                    // if it is not empty use it\n-                    if (_intercepted.hasContent())\n-                        return _intercepted;\n-                    _intercepted.succeeded();\n-                }\n-\n-                // intercepted content consumed\n-                _intercepted = null;\n-\n-                // fall through so that the unintercepted _content is\n-                // considered for any remaining content, for EOF and to\n-                // succeed it if it is entirely consumed.\n-            }\n-\n-            // If the content has content or is an EOF marker, use it\n-            if (_content.hasContent() || _content instanceof SentinelContent)\n-                return _content;\n-\n-            // The content is consumed, so get the next one.  Note that EOF\n-            // content is never consumed here, but in #pollContent\n-            _content.succeeded();\n-            _content = _inputQ.poll();\n+            if (LOG.isDebugEnabled())\n+                LOG.debug(\"isReady? false\");\n+            return false;\n         }\n \n-        return null;\n+        if (LOG.isDebugEnabled())\n+            LOG.debug(\"isReady? true\");\n+        return true;\n     }\n \n-    private void consume(Content content)\n+    @Override\n+    public void setReadListener(ReadListener readListener)\n     {\n-        if (!isError() && content instanceof EofContent)\n-        {\n-            if (content == EARLY_EOF_CONTENT)\n-                _state = EARLY_EOF;\n-            else if (_listener == null)\n-                _state = EOF;\n-            else\n-                _state = AEOF;\n-        }\n+        if (_readListener != null)\n+            throw new IllegalStateException(\"ReadListener already set\");\n+        _readListener = Objects.requireNonNull(readListener);\n+        //illegal if async not started\n+        if (!_channelState.isAsyncStarted())\n+            throw new IllegalStateException(\"Async not started\");\n \n-        // Consume the content, either if it was original content\n-        // or if it was produced by interception\n-        content.succeeded();\n-        if (_content == content)\n-            _content = null;\n-        else if (_intercepted == content)\n-            _intercepted = null;\n+        _contentProducer = _asyncContentProducer;\n+        // trigger content production\n+        if (isReady() && _channelState.onReadEof()) // onReadEof b/c we want to transition from WAITING to WOKEN\n+            scheduleReadListenerNotification(); // this is needed by AsyncServletIOTest.testStolenAsyncRead\n     }\n \n-    /**\n-     * Copies the given content into the given byte buffer.\n-     *\n-     * @param content the content to copy from\n-     * @param buffer the buffer to copy into\n-     * @param offset the buffer offset to start copying from\n-     * @param length the space available in the buffer\n-     * @return the number of bytes actually copied\n-     */\n-    protected int get(Content content, byte[] buffer, int offset, int length)\n+    public boolean wakeup()\n     {\n-        int l = content.get(buffer, offset, length);\n-        _contentConsumed += l;\n-        return l;\n+        boolean wakeup = _contentProducer.wakeup();\n+        return wakeup;\n     }\n \n-    /**\n-     * Consumes the given content. Calls the content succeeded if all content consumed.\n-     *\n-     * @param content the content to consume\n-     * @param length the number of bytes to consume\n-     */\n-    protected void skip(Content content, int length)\n-    {\n-        int l = content.skip(length);\n-\n-        _contentConsumed += l;\n-        if (l > 0 && content.isEmpty())\n-            nextNonSentinelContent(); // hungry succeed\n-    }\n-\n-    /**\n-     * Blocks until some content or some end-of-file event arrives.\n-     *\n-     * @throws IOException if the wait is interrupted\n-     */\n-    protected void blockForContent() throws IOException\n+    @Override\n+    public int read() throws IOException\n     {\n-        assert _lock.isHeldByCurrentThread();\n-        try\n-        {\n-            _waitingForContent = true;\n-            _channelState.getHttpChannel().onBlockWaitForContent();\n-\n-            boolean loop = false;\n-            long timeout = 0;\n-            while (true)\n-            {\n-                // This method is called from a loop, so we just\n-                // need to check the timeout before and after waiting.\n-                if (loop)\n-                    break;\n-\n-                if (LOG.isDebugEnabled())\n-                    LOG.debug(\"{} blocking for content timeout={}\", this, timeout);\n-                if (timeout > 0)\n-                    _lock.await(timeout, TimeUnit.MILLISECONDS);\n-                else\n-                    _lock.await();\n-\n-                loop = true;\n-            }\n-        }\n-        catch (Throwable x)\n-        {\n-            _channelState.getHttpChannel().onBlockWaitForContentFailure(x);\n-        }\n+        int read = read(_oneByteBuffer, 0, 1);\n+        if (read == 0)\n+            throw new IOException(\"unready read=0\");\n+        return read < 0 ? -1 : _oneByteBuffer[0] & 0xFF;\n     }\n \n-    /**\n-     * Adds some content to this input stream.\n-     *\n-     * @param content the content to add\n-     * @return true if content channel woken for read\n-     */\n-    public boolean addContent(Content content)\n+    @Override\n+    public int read(byte[] b, int off, int len) throws IOException\n     {\n-        try (AutoLock l = _lock.lock())\n-        {\n-            _waitingForContent = false;\n-            if (_firstByteTimeStamp == -1)\n-                _firstByteTimeStamp = System.nanoTime();\n+        // Calculate minimum request rate for DoS protection\n+        _contentProducer.checkMinDataRate();\n \n-            if (isFinished())\n-            {\n-                Throwable failure = isError() ? _state.getError() : new EOFException(\"Content after EOF\");\n-                content.failed(failure);\n-                return false;\n-            }\n-            else\n-            {\n-                _contentArrived += content.remaining();\n-\n-                if (_content == null && _inputQ.isEmpty())\n-                    _content = content;\n-                else\n-                    _inputQ.offer(content);\n-\n-                if (LOG.isDebugEnabled())\n-                    LOG.debug(\"{} addContent {}\", this, content);\n-\n-                if (nextInterceptedContent() != null)\n-                    return wakeup();\n-                else\n-                    return false;\n-            }\n-        }\n-    }\n-\n-    public boolean hasContent()\n-    {\n-        try (AutoLock l = _lock.lock())\n+        Content content = _contentProducer.nextContent();\n+        if (content == null)\n+            throw new IllegalStateException(\"read on unready input\");\n+        if (!content.isSpecial())\n         {\n-            return _content != null || _inputQ.size() > 0;\n+            int read = content.get(b, off, len);\n+            if (LOG.isDebugEnabled())\n+                LOG.debug(\"read produced {} byte(s)\", read);\n+            // Content may be null after the call to read, so it may need to be freed up.\n+            _contentProducer.reclaim(content);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "273213e8df4f438bf853787ec932e22424e7fe8b"}, "originalPosition": 677}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTQwNTA5MA==", "bodyText": "Could this wrapping be a problem in AsyncContentProducer, where content instances are compared using ==.\nAlso, code that does isSpecial() typically implies isEOF(), but now we have a case where isSpecial() does not trigger even if the content is EOF. I am worried that elsewhere this is not taken into account correctly.", "url": "https://github.com/eclipse/jetty.project/pull/4556#discussion_r505405090", "createdAt": "2020-10-15T09:42:24Z", "author": {"login": "sbordet"}, "path": "jetty-http2/http2-server/src/main/java/org/eclipse/jetty/http2/server/HttpChannelOverHTTP2.java", "diffHunk": "@@ -261,31 +264,265 @@ public InvocationType getInvocationType()\n             {\n                 return callback.getInvocationType();\n             }\n-        });\n+        };\n+        _contentDemander.onContent(content);\n+        boolean handle = onContent(content);\n \n         boolean endStream = frame.isEndStream();\n         if (endStream)\n         {\n             boolean handleContent = onContentComplete();\n+            // this will generate EOF -> must happen before wakeup\n             boolean handleRequest = onRequestComplete();\n             handle |= handleContent | handleRequest;\n         }\n \n+        boolean woken = getRequest().getHttpInput().wakeup();\n         if (LOG.isDebugEnabled())\n         {\n-            LOG.debug(\"HTTP2 Request #{}/{}: {} bytes of {} content, handle: {}\",\n+            Stream stream = getStream();\n+            LOG.debug(\"HTTP2 Request #{}/{}: {} bytes of {} content, woken: {}, handle: {}\",\n                     stream.getId(),\n                     Integer.toHexString(stream.getSession().hashCode()),\n                     length,\n                     endStream ? \"last\" : \"some\",\n+                    woken,\n                     handle);\n         }\n+        handle |= woken;\n \n         boolean wasDelayed = _delayedUntilContent;\n         _delayedUntilContent = false;\n         return handle || wasDelayed ? this : null;\n     }\n \n+    private static final HttpInput.Content EOF = new HttpInput.EofContent();\n+    private static final HttpInput.Content DEMANDING = new HttpInput.SpecialContent() {};\n+\n+    private class ContentDemander\n+    {\n+        private final AtomicReference<HttpInput.Content> _content = new AtomicReference<>();\n+\n+        public void recycle()\n+        {\n+            HttpInput.Content c = _content.getAndSet(null);\n+            if (c != null && !c.isSpecial())\n+                throw new AssertionError(\"unconsumed content: \" + c);\n+        }\n+\n+        public HttpInput.Content take()\n+        {\n+            while (true)\n+            {\n+                HttpInput.Content c = _content.get();\n+                if (c == null || c.isSpecial() || _content.compareAndSet(c, c.isEof() ? EOF : null))\n+                    return c;\n+            }\n+        }\n+\n+        public boolean demand()\n+        {\n+            while (true)\n+            {\n+                HttpInput.Content c = _content.get();\n+                if (c == DEMANDING)\n+                    return false;\n+                if (c != null)\n+                    return true;\n+                if (_content.compareAndSet(null, DEMANDING))\n+                {\n+                    IStream stream = getStream();\n+                    if (stream == null)\n+                    {\n+                        _content.set(null);\n+                        return false;\n+                    }\n+                    stream.demand(1);\n+                    c = _content.get();\n+                    return c != DEMANDING && c != null;\n+                }\n+            }\n+        }\n+\n+        public void onContent(HttpInput.Content content)\n+        {\n+            while (true)\n+            {\n+                HttpInput.Content c = _content.get();\n+                if (c == DEMANDING)\n+                {\n+                    if (_content.compareAndSet(DEMANDING, content))\n+                        return;\n+                }\n+                else if (c == null)\n+                {\n+                    if (!content.isSpecial())\n+                        throw new AssertionError(\"Non special content without demand\");\n+                    if (_content.compareAndSet(null, content))\n+                        return;\n+                }\n+                else if (c.isEof() && content.isEof() && content.isEmpty())\n+                {\n+                    content.succeeded();\n+                    return;\n+                }\n+                else if (content.getError() != null)\n+                {\n+                    if (c.getError() != null)\n+                    {\n+                        if (c.getError() != content.getError())\n+                            c.getError().addSuppressed(content.getError());\n+                        return;\n+                    }\n+                    if (_content.compareAndSet(c, content))\n+                    {\n+                        c.failed(content.getError());\n+                        return;\n+                    }\n+                }\n+                else if (c.getError() != null && content.remaining() == 0)\n+                {\n+                    content.succeeded();\n+                    return;\n+                }\n+                else\n+                {\n+                    throw new IllegalStateException(\"Cannot overwrite exiting content \" + c + \" with \" + content);\n+                }\n+            }\n+        }\n+\n+        public boolean onTimeout(Throwable failure)\n+        {\n+            while (true)\n+            {\n+                HttpInput.Content c = _content.get();\n+                if (c != DEMANDING)\n+                    return false;\n+                if (_content.compareAndSet(DEMANDING, new HttpInput.ErrorContent(failure)))\n+                    return true;\n+            }\n+        }\n+\n+        public void eof()\n+        {\n+            while (true)\n+            {\n+                HttpInput.Content c = _content.get();\n+                if (c == DEMANDING)\n+                {\n+                    if (_content.compareAndSet(DEMANDING, EOF))\n+                        return;\n+                }\n+                else if (c == null)\n+                {\n+                    if (_content.compareAndSet(null, EOF))\n+                        return;\n+                }\n+                else if (c.isEof())\n+                {\n+                    return;\n+                }\n+                else if (c.remaining() == 0)\n+                {\n+                    if (_content.compareAndSet(c, EOF))\n+                        return;\n+                }\n+                else\n+                {\n+                    HttpInput.Content content = new HttpInput.Content(c.getByteBuffer())", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDkyNDU4Mg=="}, "originalCommit": {"oid": "273213e8df4f438bf853787ec932e22424e7fe8b"}, "originalPosition": 257}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTQwNzEwNw==", "bodyText": "Does this code block work for EOF-wrapped content?\nConsider that below there is a content.isEof() check, so here we seem to assume that if a content is not special, then it cannot be EOF.", "url": "https://github.com/eclipse/jetty.project/pull/4556#discussion_r505407107", "createdAt": "2020-10-15T09:44:59Z", "author": {"login": "sbordet"}, "path": "jetty-server/src/main/java/org/eclipse/jetty/server/HttpInput.java", "diffHunk": "@@ -192,648 +83,183 @@ public Interceptor getInterceptor()\n      */\n     public void setInterceptor(Interceptor interceptor)\n     {\n-        _interceptor = interceptor;\n+        _contentProducer.setInterceptor(interceptor);\n     }\n \n     /**\n-     * Set the {@link Interceptor}, using a {@link ChainedInterceptor} if\n+     * Set the {@link Interceptor}, chaining it to the existing one if\n      * an {@link Interceptor} is already set.\n      *\n      * @param interceptor the next {@link Interceptor} in a chain\n      */\n     public void addInterceptor(Interceptor interceptor)\n     {\n-        if (_interceptor == null)\n-            _interceptor = interceptor;\n+        Interceptor currentInterceptor = _contentProducer.getInterceptor();\n+        if (currentInterceptor == null)\n+            _contentProducer.setInterceptor(interceptor);\n         else\n-            _interceptor = new ChainedInterceptor(_interceptor, interceptor);\n+            _contentProducer.setInterceptor(new ChainedInterceptor(currentInterceptor, interceptor));\n     }\n \n-    @Override\n-    public int available()\n-    {\n-        int available = 0;\n-        boolean woken = false;\n-        try (AutoLock l = _lock.lock())\n-        {\n-            if (_content == null)\n-                _content = _inputQ.poll();\n-            if (_content == null)\n-            {\n-                try\n-                {\n-                    produceContent();\n-                }\n-                catch (IOException e)\n-                {\n-                    woken = failed(e);\n-                }\n-                if (_content == null)\n-                    _content = _inputQ.poll();\n-            }\n-\n-            if (_content != null)\n-                available = _content.remaining();\n-        }\n-\n-        if (woken)\n-            wake();\n-        return available;\n-    }\n-\n-    protected void wake()\n-    {\n-        HttpChannel channel = _channelState.getHttpChannel();\n-        Executor executor = channel.getConnector().getServer().getThreadPool();\n-        executor.execute(channel);\n-    }\n-\n-    @Override\n-    public int read() throws IOException\n+    public long getContentReceived()\n     {\n-        int read = read(_oneByteBuffer, 0, 1);\n-        if (read == 0)\n-            throw new IllegalStateException(\"unready read=0\");\n-        return read < 0 ? -1 : _oneByteBuffer[0] & 0xFF;\n+        return _contentProducer.getRawContentArrived();\n     }\n \n-    @Override\n-    public int read(byte[] b, int off, int len) throws IOException\n+    public boolean consumeAll()\n     {\n-        boolean wake = false;\n-        int read;\n-        try (AutoLock l = _lock.lock())\n-        {\n-            // Calculate minimum request rate for DOS protection\n-            long minRequestDataRate = _channelState.getHttpChannel().getHttpConfiguration().getMinRequestDataRate();\n-            if (minRequestDataRate > 0 && _firstByteTimeStamp != -1)\n-            {\n-                long period = System.nanoTime() - _firstByteTimeStamp;\n-                if (period > 0)\n-                {\n-                    long minimumData = minRequestDataRate * TimeUnit.NANOSECONDS.toMillis(period) / TimeUnit.SECONDS.toMillis(1);\n-                    if (_contentArrived < minimumData)\n-                    {\n-                        BadMessageException bad = new BadMessageException(HttpStatus.REQUEST_TIMEOUT_408,\n-                            String.format(\"Request content data rate < %d B/s\", minRequestDataRate));\n-                        if (_channelState.isResponseCommitted())\n-                            _channelState.getHttpChannel().abort(bad);\n-                        throw bad;\n-                    }\n-                }\n-            }\n+        if (LOG.isDebugEnabled())\n+            LOG.debug(\"consume all\");\n+        boolean atEof = _contentProducer.consumeAll(new IOException(\"Unconsumed content\"));\n+        if (atEof)\n+            _consumedEof = true;\n \n-            // Consume content looking for bytes to read\n-            while (true)\n-            {\n-                Content item = nextContent();\n-                if (item != null)\n-                {\n-                    read = get(item, b, off, len);\n-                    if (LOG.isDebugEnabled())\n-                        LOG.debug(\"{} read {} from {}\", this, read, item);\n-\n-                    // Consume any following poison pills\n-                    if (item.isEmpty())\n-                        nextInterceptedContent();\n-                    break;\n-                }\n-\n-                // No content, so should we block?\n-                if (!_state.blockForContent(this))\n-                {\n-                    // Not blocking, so what should we return?\n-                    read = _state.noContent();\n-\n-                    if (read < 0)\n-                        // If EOF do we need to wake for allDataRead callback?\n-                        wake = _channelState.onReadEof();\n-                    break;\n-                }\n-            }\n-        }\n-\n-        if (wake)\n-            wake();\n-        return read;\n-    }\n+        if (isFinished())\n+            return !isError();\n \n-    /**\n-     * Called when derived implementations should attempt to produce more Content and add it via {@link #addContent(Content)}. For protocols that are constantly\n-     * producing (eg HTTP2) this can be left as a noop;\n-     *\n-     * @throws IOException if unable to produce content\n-     */\n-    protected void produceContent() throws IOException\n-    {\n+        // Modifying the state here to anything other than IDLE makes\n+        // ServerTimeoutsTest.testAsyncReadWithDelayedFirstContentWithDelayedDispatchIdleTimeoutFires H2C fail.\n+        return false;\n     }\n \n-    /**\n-     * Called by channel when asynchronous IO needs to produce more content\n-     *\n-     * @throws IOException if unable to produce content\n-     */\n-    public void asyncReadProduce() throws IOException\n+    public boolean isError()\n     {\n-        try (AutoLock l = _lock.lock())\n-        {\n-            produceContent();\n-        }\n+        return _contentProducer.isError();\n     }\n \n-    /**\n-     * Get the next content from the inputQ, calling {@link #produceContent()} if need be. EOF is processed and state changed.\n-     *\n-     * @return the content or null if none available.\n-     * @throws IOException if retrieving the content fails\n-     */\n-    protected Content nextContent() throws IOException\n+    public boolean isAsync()\n     {\n-        Content content = nextNonSentinelContent();\n-        if (content == null && !isFinished())\n-        {\n-            produceContent();\n-            content = nextNonSentinelContent();\n-        }\n-        return content;\n+        return _readListener != null;\n     }\n \n-    /**\n-     * Poll the inputQ for Content. Consumed buffers and {@link SentinelContent}s are removed and EOF state updated if need be.\n-     *\n-     * @return Content or null\n-     */\n-    protected Content nextNonSentinelContent()\n-    {\n-        while (true)\n-        {\n-            // Get the next content (or EOF)\n-            Content content = nextInterceptedContent();\n-\n-            // If it is EOF, consume it here\n-            if (content instanceof SentinelContent)\n-            {\n-                // Consume the EOF content, either if it was original content\n-                // or if it was produced by interception\n-                consume(content);\n-                continue;\n-            }\n+    /* ServletInputStream */\n \n-            return content;\n-        }\n-    }\n-\n-    /**\n-     * Get the next readable from the inputQ, calling {@link #produceContent()} if need be. EOF is NOT processed and state is not changed.\n-     *\n-     * @return the content or EOF or null if none available.\n-     * @throws IOException if retrieving the content fails\n-     */\n-    protected Content produceNextContext() throws IOException\n+    @Override\n+    public boolean isFinished()\n     {\n-        Content content = nextInterceptedContent();\n-        if (content == null && !isFinished())\n-        {\n-            produceContent();\n-            content = nextInterceptedContent();\n-        }\n-        return content;\n+        boolean finished = _consumedEof;\n+        if (LOG.isDebugEnabled())\n+            LOG.debug(\"isFinished? {}\", finished);\n+        return finished;\n     }\n \n-    /**\n-     * Poll the inputQ for Content or EOF. Consumed buffers and non EOF {@link SentinelContent}s are removed. EOF state is not updated.\n-     * Interception is done within this method.\n-     *\n-     * @return Content with remaining, a {@link SentinelContent},  or null\n-     */\n-    protected Content nextInterceptedContent()\n+    @Override\n+    public boolean isReady()\n     {\n-        // If we have a chunk produced by interception\n-        if (_intercepted != null)\n+        boolean ready = _contentProducer.isReady();\n+        if (!ready)\n         {\n-            // Use it if it has any remaining content\n-            if (_intercepted.hasContent())\n-                return _intercepted;\n-\n-            // succeed the chunk\n-            _intercepted.succeeded();\n-            _intercepted = null;\n-        }\n-\n-        // If we don't have a Content under consideration, get\n-        // the next one off the input Q.\n-        if (_content == null)\n-            _content = _inputQ.poll();\n-\n-        // While we have content to consider.\n-        while (_content != null)\n-        {\n-            // Are we intercepting?\n-            if (_interceptor != null)\n-            {\n-                // Intercept the current content (may be called several\n-                // times for the same content\n-                _intercepted = _interceptor.readFrom(_content);\n-\n-                // If interception produced new content\n-                if (_intercepted != null && _intercepted != _content)\n-                {\n-                    // if it is not empty use it\n-                    if (_intercepted.hasContent())\n-                        return _intercepted;\n-                    _intercepted.succeeded();\n-                }\n-\n-                // intercepted content consumed\n-                _intercepted = null;\n-\n-                // fall through so that the unintercepted _content is\n-                // considered for any remaining content, for EOF and to\n-                // succeed it if it is entirely consumed.\n-            }\n-\n-            // If the content has content or is an EOF marker, use it\n-            if (_content.hasContent() || _content instanceof SentinelContent)\n-                return _content;\n-\n-            // The content is consumed, so get the next one.  Note that EOF\n-            // content is never consumed here, but in #pollContent\n-            _content.succeeded();\n-            _content = _inputQ.poll();\n+            if (LOG.isDebugEnabled())\n+                LOG.debug(\"isReady? false\");\n+            return false;\n         }\n \n-        return null;\n+        if (LOG.isDebugEnabled())\n+            LOG.debug(\"isReady? true\");\n+        return true;\n     }\n \n-    private void consume(Content content)\n+    @Override\n+    public void setReadListener(ReadListener readListener)\n     {\n-        if (!isError() && content instanceof EofContent)\n-        {\n-            if (content == EARLY_EOF_CONTENT)\n-                _state = EARLY_EOF;\n-            else if (_listener == null)\n-                _state = EOF;\n-            else\n-                _state = AEOF;\n-        }\n+        if (_readListener != null)\n+            throw new IllegalStateException(\"ReadListener already set\");\n+        _readListener = Objects.requireNonNull(readListener);\n+        //illegal if async not started\n+        if (!_channelState.isAsyncStarted())\n+            throw new IllegalStateException(\"Async not started\");\n \n-        // Consume the content, either if it was original content\n-        // or if it was produced by interception\n-        content.succeeded();\n-        if (_content == content)\n-            _content = null;\n-        else if (_intercepted == content)\n-            _intercepted = null;\n+        _contentProducer = _asyncContentProducer;\n+        // trigger content production\n+        if (isReady() && _channelState.onReadEof()) // onReadEof b/c we want to transition from WAITING to WOKEN\n+            scheduleReadListenerNotification(); // this is needed by AsyncServletIOTest.testStolenAsyncRead\n     }\n \n-    /**\n-     * Copies the given content into the given byte buffer.\n-     *\n-     * @param content the content to copy from\n-     * @param buffer the buffer to copy into\n-     * @param offset the buffer offset to start copying from\n-     * @param length the space available in the buffer\n-     * @return the number of bytes actually copied\n-     */\n-    protected int get(Content content, byte[] buffer, int offset, int length)\n+    public boolean wakeup()\n     {\n-        int l = content.get(buffer, offset, length);\n-        _contentConsumed += l;\n-        return l;\n+        boolean wakeup = _contentProducer.wakeup();\n+        return wakeup;\n     }\n \n-    /**\n-     * Consumes the given content. Calls the content succeeded if all content consumed.\n-     *\n-     * @param content the content to consume\n-     * @param length the number of bytes to consume\n-     */\n-    protected void skip(Content content, int length)\n-    {\n-        int l = content.skip(length);\n-\n-        _contentConsumed += l;\n-        if (l > 0 && content.isEmpty())\n-            nextNonSentinelContent(); // hungry succeed\n-    }\n-\n-    /**\n-     * Blocks until some content or some end-of-file event arrives.\n-     *\n-     * @throws IOException if the wait is interrupted\n-     */\n-    protected void blockForContent() throws IOException\n+    @Override\n+    public int read() throws IOException\n     {\n-        assert _lock.isHeldByCurrentThread();\n-        try\n-        {\n-            _waitingForContent = true;\n-            _channelState.getHttpChannel().onBlockWaitForContent();\n-\n-            boolean loop = false;\n-            long timeout = 0;\n-            while (true)\n-            {\n-                // This method is called from a loop, so we just\n-                // need to check the timeout before and after waiting.\n-                if (loop)\n-                    break;\n-\n-                if (LOG.isDebugEnabled())\n-                    LOG.debug(\"{} blocking for content timeout={}\", this, timeout);\n-                if (timeout > 0)\n-                    _lock.await(timeout, TimeUnit.MILLISECONDS);\n-                else\n-                    _lock.await();\n-\n-                loop = true;\n-            }\n-        }\n-        catch (Throwable x)\n-        {\n-            _channelState.getHttpChannel().onBlockWaitForContentFailure(x);\n-        }\n+        int read = read(_oneByteBuffer, 0, 1);\n+        if (read == 0)\n+            throw new IOException(\"unready read=0\");\n+        return read < 0 ? -1 : _oneByteBuffer[0] & 0xFF;\n     }\n \n-    /**\n-     * Adds some content to this input stream.\n-     *\n-     * @param content the content to add\n-     * @return true if content channel woken for read\n-     */\n-    public boolean addContent(Content content)\n+    @Override\n+    public int read(byte[] b, int off, int len) throws IOException\n     {\n-        try (AutoLock l = _lock.lock())\n-        {\n-            _waitingForContent = false;\n-            if (_firstByteTimeStamp == -1)\n-                _firstByteTimeStamp = System.nanoTime();\n+        // Calculate minimum request rate for DoS protection\n+        _contentProducer.checkMinDataRate();\n \n-            if (isFinished())\n-            {\n-                Throwable failure = isError() ? _state.getError() : new EOFException(\"Content after EOF\");\n-                content.failed(failure);\n-                return false;\n-            }\n-            else\n-            {\n-                _contentArrived += content.remaining();\n-\n-                if (_content == null && _inputQ.isEmpty())\n-                    _content = content;\n-                else\n-                    _inputQ.offer(content);\n-\n-                if (LOG.isDebugEnabled())\n-                    LOG.debug(\"{} addContent {}\", this, content);\n-\n-                if (nextInterceptedContent() != null)\n-                    return wakeup();\n-                else\n-                    return false;\n-            }\n-        }\n-    }\n-\n-    public boolean hasContent()\n-    {\n-        try (AutoLock l = _lock.lock())\n+        Content content = _contentProducer.nextContent();\n+        if (content == null)\n+            throw new IllegalStateException(\"read on unready input\");\n+        if (!content.isSpecial())\n         {\n-            return _content != null || _inputQ.size() > 0;\n+            int read = content.get(b, off, len);\n+            if (LOG.isDebugEnabled())\n+                LOG.debug(\"read produced {} byte(s)\", read);\n+            // Content may be null after the call to read, so it may need to be freed up.\n+            _contentProducer.reclaim(content);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTM5MjY0NQ=="}, "originalCommit": {"oid": "273213e8df4f438bf853787ec932e22424e7fe8b"}, "originalPosition": 677}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTQwODY5Mw==", "bodyText": "See above comment, does this work for EOF-wrapped content?", "url": "https://github.com/eclipse/jetty.project/pull/4556#discussion_r505408693", "createdAt": "2020-10-15T09:47:02Z", "author": {"login": "sbordet"}, "path": "jetty-server/src/main/java/org/eclipse/jetty/server/HttpInput.java", "diffHunk": "@@ -192,648 +83,183 @@ public Interceptor getInterceptor()\n      */\n     public void setInterceptor(Interceptor interceptor)\n     {\n-        _interceptor = interceptor;\n+        _contentProducer.setInterceptor(interceptor);\n     }\n \n     /**\n-     * Set the {@link Interceptor}, using a {@link ChainedInterceptor} if\n+     * Set the {@link Interceptor}, chaining it to the existing one if\n      * an {@link Interceptor} is already set.\n      *\n      * @param interceptor the next {@link Interceptor} in a chain\n      */\n     public void addInterceptor(Interceptor interceptor)\n     {\n-        if (_interceptor == null)\n-            _interceptor = interceptor;\n+        Interceptor currentInterceptor = _contentProducer.getInterceptor();\n+        if (currentInterceptor == null)\n+            _contentProducer.setInterceptor(interceptor);\n         else\n-            _interceptor = new ChainedInterceptor(_interceptor, interceptor);\n+            _contentProducer.setInterceptor(new ChainedInterceptor(currentInterceptor, interceptor));\n     }\n \n-    @Override\n-    public int available()\n-    {\n-        int available = 0;\n-        boolean woken = false;\n-        try (AutoLock l = _lock.lock())\n-        {\n-            if (_content == null)\n-                _content = _inputQ.poll();\n-            if (_content == null)\n-            {\n-                try\n-                {\n-                    produceContent();\n-                }\n-                catch (IOException e)\n-                {\n-                    woken = failed(e);\n-                }\n-                if (_content == null)\n-                    _content = _inputQ.poll();\n-            }\n-\n-            if (_content != null)\n-                available = _content.remaining();\n-        }\n-\n-        if (woken)\n-            wake();\n-        return available;\n-    }\n-\n-    protected void wake()\n-    {\n-        HttpChannel channel = _channelState.getHttpChannel();\n-        Executor executor = channel.getConnector().getServer().getThreadPool();\n-        executor.execute(channel);\n-    }\n-\n-    @Override\n-    public int read() throws IOException\n+    public long getContentReceived()\n     {\n-        int read = read(_oneByteBuffer, 0, 1);\n-        if (read == 0)\n-            throw new IllegalStateException(\"unready read=0\");\n-        return read < 0 ? -1 : _oneByteBuffer[0] & 0xFF;\n+        return _contentProducer.getRawContentArrived();\n     }\n \n-    @Override\n-    public int read(byte[] b, int off, int len) throws IOException\n+    public boolean consumeAll()\n     {\n-        boolean wake = false;\n-        int read;\n-        try (AutoLock l = _lock.lock())\n-        {\n-            // Calculate minimum request rate for DOS protection\n-            long minRequestDataRate = _channelState.getHttpChannel().getHttpConfiguration().getMinRequestDataRate();\n-            if (minRequestDataRate > 0 && _firstByteTimeStamp != -1)\n-            {\n-                long period = System.nanoTime() - _firstByteTimeStamp;\n-                if (period > 0)\n-                {\n-                    long minimumData = minRequestDataRate * TimeUnit.NANOSECONDS.toMillis(period) / TimeUnit.SECONDS.toMillis(1);\n-                    if (_contentArrived < minimumData)\n-                    {\n-                        BadMessageException bad = new BadMessageException(HttpStatus.REQUEST_TIMEOUT_408,\n-                            String.format(\"Request content data rate < %d B/s\", minRequestDataRate));\n-                        if (_channelState.isResponseCommitted())\n-                            _channelState.getHttpChannel().abort(bad);\n-                        throw bad;\n-                    }\n-                }\n-            }\n+        if (LOG.isDebugEnabled())\n+            LOG.debug(\"consume all\");\n+        boolean atEof = _contentProducer.consumeAll(new IOException(\"Unconsumed content\"));\n+        if (atEof)\n+            _consumedEof = true;\n \n-            // Consume content looking for bytes to read\n-            while (true)\n-            {\n-                Content item = nextContent();\n-                if (item != null)\n-                {\n-                    read = get(item, b, off, len);\n-                    if (LOG.isDebugEnabled())\n-                        LOG.debug(\"{} read {} from {}\", this, read, item);\n-\n-                    // Consume any following poison pills\n-                    if (item.isEmpty())\n-                        nextInterceptedContent();\n-                    break;\n-                }\n-\n-                // No content, so should we block?\n-                if (!_state.blockForContent(this))\n-                {\n-                    // Not blocking, so what should we return?\n-                    read = _state.noContent();\n-\n-                    if (read < 0)\n-                        // If EOF do we need to wake for allDataRead callback?\n-                        wake = _channelState.onReadEof();\n-                    break;\n-                }\n-            }\n-        }\n-\n-        if (wake)\n-            wake();\n-        return read;\n-    }\n+        if (isFinished())\n+            return !isError();\n \n-    /**\n-     * Called when derived implementations should attempt to produce more Content and add it via {@link #addContent(Content)}. For protocols that are constantly\n-     * producing (eg HTTP2) this can be left as a noop;\n-     *\n-     * @throws IOException if unable to produce content\n-     */\n-    protected void produceContent() throws IOException\n-    {\n+        // Modifying the state here to anything other than IDLE makes\n+        // ServerTimeoutsTest.testAsyncReadWithDelayedFirstContentWithDelayedDispatchIdleTimeoutFires H2C fail.\n+        return false;\n     }\n \n-    /**\n-     * Called by channel when asynchronous IO needs to produce more content\n-     *\n-     * @throws IOException if unable to produce content\n-     */\n-    public void asyncReadProduce() throws IOException\n+    public boolean isError()\n     {\n-        try (AutoLock l = _lock.lock())\n-        {\n-            produceContent();\n-        }\n+        return _contentProducer.isError();\n     }\n \n-    /**\n-     * Get the next content from the inputQ, calling {@link #produceContent()} if need be. EOF is processed and state changed.\n-     *\n-     * @return the content or null if none available.\n-     * @throws IOException if retrieving the content fails\n-     */\n-    protected Content nextContent() throws IOException\n+    public boolean isAsync()\n     {\n-        Content content = nextNonSentinelContent();\n-        if (content == null && !isFinished())\n-        {\n-            produceContent();\n-            content = nextNonSentinelContent();\n-        }\n-        return content;\n+        return _readListener != null;\n     }\n \n-    /**\n-     * Poll the inputQ for Content. Consumed buffers and {@link SentinelContent}s are removed and EOF state updated if need be.\n-     *\n-     * @return Content or null\n-     */\n-    protected Content nextNonSentinelContent()\n-    {\n-        while (true)\n-        {\n-            // Get the next content (or EOF)\n-            Content content = nextInterceptedContent();\n-\n-            // If it is EOF, consume it here\n-            if (content instanceof SentinelContent)\n-            {\n-                // Consume the EOF content, either if it was original content\n-                // or if it was produced by interception\n-                consume(content);\n-                continue;\n-            }\n+    /* ServletInputStream */\n \n-            return content;\n-        }\n-    }\n-\n-    /**\n-     * Get the next readable from the inputQ, calling {@link #produceContent()} if need be. EOF is NOT processed and state is not changed.\n-     *\n-     * @return the content or EOF or null if none available.\n-     * @throws IOException if retrieving the content fails\n-     */\n-    protected Content produceNextContext() throws IOException\n+    @Override\n+    public boolean isFinished()\n     {\n-        Content content = nextInterceptedContent();\n-        if (content == null && !isFinished())\n-        {\n-            produceContent();\n-            content = nextInterceptedContent();\n-        }\n-        return content;\n+        boolean finished = _consumedEof;\n+        if (LOG.isDebugEnabled())\n+            LOG.debug(\"isFinished? {}\", finished);\n+        return finished;\n     }\n \n-    /**\n-     * Poll the inputQ for Content or EOF. Consumed buffers and non EOF {@link SentinelContent}s are removed. EOF state is not updated.\n-     * Interception is done within this method.\n-     *\n-     * @return Content with remaining, a {@link SentinelContent},  or null\n-     */\n-    protected Content nextInterceptedContent()\n+    @Override\n+    public boolean isReady()\n     {\n-        // If we have a chunk produced by interception\n-        if (_intercepted != null)\n+        boolean ready = _contentProducer.isReady();\n+        if (!ready)\n         {\n-            // Use it if it has any remaining content\n-            if (_intercepted.hasContent())\n-                return _intercepted;\n-\n-            // succeed the chunk\n-            _intercepted.succeeded();\n-            _intercepted = null;\n-        }\n-\n-        // If we don't have a Content under consideration, get\n-        // the next one off the input Q.\n-        if (_content == null)\n-            _content = _inputQ.poll();\n-\n-        // While we have content to consider.\n-        while (_content != null)\n-        {\n-            // Are we intercepting?\n-            if (_interceptor != null)\n-            {\n-                // Intercept the current content (may be called several\n-                // times for the same content\n-                _intercepted = _interceptor.readFrom(_content);\n-\n-                // If interception produced new content\n-                if (_intercepted != null && _intercepted != _content)\n-                {\n-                    // if it is not empty use it\n-                    if (_intercepted.hasContent())\n-                        return _intercepted;\n-                    _intercepted.succeeded();\n-                }\n-\n-                // intercepted content consumed\n-                _intercepted = null;\n-\n-                // fall through so that the unintercepted _content is\n-                // considered for any remaining content, for EOF and to\n-                // succeed it if it is entirely consumed.\n-            }\n-\n-            // If the content has content or is an EOF marker, use it\n-            if (_content.hasContent() || _content instanceof SentinelContent)\n-                return _content;\n-\n-            // The content is consumed, so get the next one.  Note that EOF\n-            // content is never consumed here, but in #pollContent\n-            _content.succeeded();\n-            _content = _inputQ.poll();\n+            if (LOG.isDebugEnabled())\n+                LOG.debug(\"isReady? false\");\n+            return false;\n         }\n \n-        return null;\n+        if (LOG.isDebugEnabled())\n+            LOG.debug(\"isReady? true\");\n+        return true;\n     }\n \n-    private void consume(Content content)\n+    @Override\n+    public void setReadListener(ReadListener readListener)\n     {\n-        if (!isError() && content instanceof EofContent)\n-        {\n-            if (content == EARLY_EOF_CONTENT)\n-                _state = EARLY_EOF;\n-            else if (_listener == null)\n-                _state = EOF;\n-            else\n-                _state = AEOF;\n-        }\n+        if (_readListener != null)\n+            throw new IllegalStateException(\"ReadListener already set\");\n+        _readListener = Objects.requireNonNull(readListener);\n+        //illegal if async not started\n+        if (!_channelState.isAsyncStarted())\n+            throw new IllegalStateException(\"Async not started\");\n \n-        // Consume the content, either if it was original content\n-        // or if it was produced by interception\n-        content.succeeded();\n-        if (_content == content)\n-            _content = null;\n-        else if (_intercepted == content)\n-            _intercepted = null;\n+        _contentProducer = _asyncContentProducer;\n+        // trigger content production\n+        if (isReady() && _channelState.onReadEof()) // onReadEof b/c we want to transition from WAITING to WOKEN\n+            scheduleReadListenerNotification(); // this is needed by AsyncServletIOTest.testStolenAsyncRead\n     }\n \n-    /**\n-     * Copies the given content into the given byte buffer.\n-     *\n-     * @param content the content to copy from\n-     * @param buffer the buffer to copy into\n-     * @param offset the buffer offset to start copying from\n-     * @param length the space available in the buffer\n-     * @return the number of bytes actually copied\n-     */\n-    protected int get(Content content, byte[] buffer, int offset, int length)\n+    public boolean wakeup()\n     {\n-        int l = content.get(buffer, offset, length);\n-        _contentConsumed += l;\n-        return l;\n+        boolean wakeup = _contentProducer.wakeup();\n+        return wakeup;\n     }\n \n-    /**\n-     * Consumes the given content. Calls the content succeeded if all content consumed.\n-     *\n-     * @param content the content to consume\n-     * @param length the number of bytes to consume\n-     */\n-    protected void skip(Content content, int length)\n-    {\n-        int l = content.skip(length);\n-\n-        _contentConsumed += l;\n-        if (l > 0 && content.isEmpty())\n-            nextNonSentinelContent(); // hungry succeed\n-    }\n-\n-    /**\n-     * Blocks until some content or some end-of-file event arrives.\n-     *\n-     * @throws IOException if the wait is interrupted\n-     */\n-    protected void blockForContent() throws IOException\n+    @Override\n+    public int read() throws IOException\n     {\n-        assert _lock.isHeldByCurrentThread();\n-        try\n-        {\n-            _waitingForContent = true;\n-            _channelState.getHttpChannel().onBlockWaitForContent();\n-\n-            boolean loop = false;\n-            long timeout = 0;\n-            while (true)\n-            {\n-                // This method is called from a loop, so we just\n-                // need to check the timeout before and after waiting.\n-                if (loop)\n-                    break;\n-\n-                if (LOG.isDebugEnabled())\n-                    LOG.debug(\"{} blocking for content timeout={}\", this, timeout);\n-                if (timeout > 0)\n-                    _lock.await(timeout, TimeUnit.MILLISECONDS);\n-                else\n-                    _lock.await();\n-\n-                loop = true;\n-            }\n-        }\n-        catch (Throwable x)\n-        {\n-            _channelState.getHttpChannel().onBlockWaitForContentFailure(x);\n-        }\n+        int read = read(_oneByteBuffer, 0, 1);\n+        if (read == 0)\n+            throw new IOException(\"unready read=0\");\n+        return read < 0 ? -1 : _oneByteBuffer[0] & 0xFF;\n     }\n \n-    /**\n-     * Adds some content to this input stream.\n-     *\n-     * @param content the content to add\n-     * @return true if content channel woken for read\n-     */\n-    public boolean addContent(Content content)\n+    @Override\n+    public int read(byte[] b, int off, int len) throws IOException\n     {\n-        try (AutoLock l = _lock.lock())\n-        {\n-            _waitingForContent = false;\n-            if (_firstByteTimeStamp == -1)\n-                _firstByteTimeStamp = System.nanoTime();\n+        // Calculate minimum request rate for DoS protection\n+        _contentProducer.checkMinDataRate();\n \n-            if (isFinished())\n-            {\n-                Throwable failure = isError() ? _state.getError() : new EOFException(\"Content after EOF\");\n-                content.failed(failure);\n-                return false;\n-            }\n-            else\n-            {\n-                _contentArrived += content.remaining();\n-\n-                if (_content == null && _inputQ.isEmpty())\n-                    _content = content;\n-                else\n-                    _inputQ.offer(content);\n-\n-                if (LOG.isDebugEnabled())\n-                    LOG.debug(\"{} addContent {}\", this, content);\n-\n-                if (nextInterceptedContent() != null)\n-                    return wakeup();\n-                else\n-                    return false;\n-            }\n-        }\n-    }\n-\n-    public boolean hasContent()\n-    {\n-        try (AutoLock l = _lock.lock())\n+        Content content = _contentProducer.nextContent();\n+        if (content == null)\n+            throw new IllegalStateException(\"read on unready input\");\n+        if (!content.isSpecial())\n         {\n-            return _content != null || _inputQ.size() > 0;\n+            int read = content.get(b, off, len);\n+            if (LOG.isDebugEnabled())\n+                LOG.debug(\"read produced {} byte(s)\", read);\n+            // Content may be null after the call to read, so it may need to be freed up.\n+            _contentProducer.reclaim(content);\n+            return read;\n         }\n-    }\n \n-    public void unblock()\n-    {\n-        try (AutoLock.WithCondition l = _lock.lock())\n+        Throwable error = content.getError();\n+        if (LOG.isDebugEnabled())\n+            LOG.debug(\"read error = \" + error);\n+        if (error != null)\n         {\n-            l.signal();\n+            if (error instanceof IOException)\n+                throw (IOException)error;\n+            throw new IOException(error);\n         }\n-    }\n \n-    public long getContentConsumed()\n-    {\n-        try (AutoLock l = _lock.lock())\n+        if (content.isEof())", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "273213e8df4f438bf853787ec932e22424e7fe8b"}, "originalPosition": 700}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTQxMDIwMA==", "bodyText": "This will dispatch a new thread -- why do we need to wakeup from inside read() and dispatch a new thread?", "url": "https://github.com/eclipse/jetty.project/pull/4556#discussion_r505410200", "createdAt": "2020-10-15T09:48:57Z", "author": {"login": "sbordet"}, "path": "jetty-server/src/main/java/org/eclipse/jetty/server/HttpInput.java", "diffHunk": "@@ -192,648 +83,183 @@ public Interceptor getInterceptor()\n      */\n     public void setInterceptor(Interceptor interceptor)\n     {\n-        _interceptor = interceptor;\n+        _contentProducer.setInterceptor(interceptor);\n     }\n \n     /**\n-     * Set the {@link Interceptor}, using a {@link ChainedInterceptor} if\n+     * Set the {@link Interceptor}, chaining it to the existing one if\n      * an {@link Interceptor} is already set.\n      *\n      * @param interceptor the next {@link Interceptor} in a chain\n      */\n     public void addInterceptor(Interceptor interceptor)\n     {\n-        if (_interceptor == null)\n-            _interceptor = interceptor;\n+        Interceptor currentInterceptor = _contentProducer.getInterceptor();\n+        if (currentInterceptor == null)\n+            _contentProducer.setInterceptor(interceptor);\n         else\n-            _interceptor = new ChainedInterceptor(_interceptor, interceptor);\n+            _contentProducer.setInterceptor(new ChainedInterceptor(currentInterceptor, interceptor));\n     }\n \n-    @Override\n-    public int available()\n-    {\n-        int available = 0;\n-        boolean woken = false;\n-        try (AutoLock l = _lock.lock())\n-        {\n-            if (_content == null)\n-                _content = _inputQ.poll();\n-            if (_content == null)\n-            {\n-                try\n-                {\n-                    produceContent();\n-                }\n-                catch (IOException e)\n-                {\n-                    woken = failed(e);\n-                }\n-                if (_content == null)\n-                    _content = _inputQ.poll();\n-            }\n-\n-            if (_content != null)\n-                available = _content.remaining();\n-        }\n-\n-        if (woken)\n-            wake();\n-        return available;\n-    }\n-\n-    protected void wake()\n-    {\n-        HttpChannel channel = _channelState.getHttpChannel();\n-        Executor executor = channel.getConnector().getServer().getThreadPool();\n-        executor.execute(channel);\n-    }\n-\n-    @Override\n-    public int read() throws IOException\n+    public long getContentReceived()\n     {\n-        int read = read(_oneByteBuffer, 0, 1);\n-        if (read == 0)\n-            throw new IllegalStateException(\"unready read=0\");\n-        return read < 0 ? -1 : _oneByteBuffer[0] & 0xFF;\n+        return _contentProducer.getRawContentArrived();\n     }\n \n-    @Override\n-    public int read(byte[] b, int off, int len) throws IOException\n+    public boolean consumeAll()\n     {\n-        boolean wake = false;\n-        int read;\n-        try (AutoLock l = _lock.lock())\n-        {\n-            // Calculate minimum request rate for DOS protection\n-            long minRequestDataRate = _channelState.getHttpChannel().getHttpConfiguration().getMinRequestDataRate();\n-            if (minRequestDataRate > 0 && _firstByteTimeStamp != -1)\n-            {\n-                long period = System.nanoTime() - _firstByteTimeStamp;\n-                if (period > 0)\n-                {\n-                    long minimumData = minRequestDataRate * TimeUnit.NANOSECONDS.toMillis(period) / TimeUnit.SECONDS.toMillis(1);\n-                    if (_contentArrived < minimumData)\n-                    {\n-                        BadMessageException bad = new BadMessageException(HttpStatus.REQUEST_TIMEOUT_408,\n-                            String.format(\"Request content data rate < %d B/s\", minRequestDataRate));\n-                        if (_channelState.isResponseCommitted())\n-                            _channelState.getHttpChannel().abort(bad);\n-                        throw bad;\n-                    }\n-                }\n-            }\n+        if (LOG.isDebugEnabled())\n+            LOG.debug(\"consume all\");\n+        boolean atEof = _contentProducer.consumeAll(new IOException(\"Unconsumed content\"));\n+        if (atEof)\n+            _consumedEof = true;\n \n-            // Consume content looking for bytes to read\n-            while (true)\n-            {\n-                Content item = nextContent();\n-                if (item != null)\n-                {\n-                    read = get(item, b, off, len);\n-                    if (LOG.isDebugEnabled())\n-                        LOG.debug(\"{} read {} from {}\", this, read, item);\n-\n-                    // Consume any following poison pills\n-                    if (item.isEmpty())\n-                        nextInterceptedContent();\n-                    break;\n-                }\n-\n-                // No content, so should we block?\n-                if (!_state.blockForContent(this))\n-                {\n-                    // Not blocking, so what should we return?\n-                    read = _state.noContent();\n-\n-                    if (read < 0)\n-                        // If EOF do we need to wake for allDataRead callback?\n-                        wake = _channelState.onReadEof();\n-                    break;\n-                }\n-            }\n-        }\n-\n-        if (wake)\n-            wake();\n-        return read;\n-    }\n+        if (isFinished())\n+            return !isError();\n \n-    /**\n-     * Called when derived implementations should attempt to produce more Content and add it via {@link #addContent(Content)}. For protocols that are constantly\n-     * producing (eg HTTP2) this can be left as a noop;\n-     *\n-     * @throws IOException if unable to produce content\n-     */\n-    protected void produceContent() throws IOException\n-    {\n+        // Modifying the state here to anything other than IDLE makes\n+        // ServerTimeoutsTest.testAsyncReadWithDelayedFirstContentWithDelayedDispatchIdleTimeoutFires H2C fail.\n+        return false;\n     }\n \n-    /**\n-     * Called by channel when asynchronous IO needs to produce more content\n-     *\n-     * @throws IOException if unable to produce content\n-     */\n-    public void asyncReadProduce() throws IOException\n+    public boolean isError()\n     {\n-        try (AutoLock l = _lock.lock())\n-        {\n-            produceContent();\n-        }\n+        return _contentProducer.isError();\n     }\n \n-    /**\n-     * Get the next content from the inputQ, calling {@link #produceContent()} if need be. EOF is processed and state changed.\n-     *\n-     * @return the content or null if none available.\n-     * @throws IOException if retrieving the content fails\n-     */\n-    protected Content nextContent() throws IOException\n+    public boolean isAsync()\n     {\n-        Content content = nextNonSentinelContent();\n-        if (content == null && !isFinished())\n-        {\n-            produceContent();\n-            content = nextNonSentinelContent();\n-        }\n-        return content;\n+        return _readListener != null;\n     }\n \n-    /**\n-     * Poll the inputQ for Content. Consumed buffers and {@link SentinelContent}s are removed and EOF state updated if need be.\n-     *\n-     * @return Content or null\n-     */\n-    protected Content nextNonSentinelContent()\n-    {\n-        while (true)\n-        {\n-            // Get the next content (or EOF)\n-            Content content = nextInterceptedContent();\n-\n-            // If it is EOF, consume it here\n-            if (content instanceof SentinelContent)\n-            {\n-                // Consume the EOF content, either if it was original content\n-                // or if it was produced by interception\n-                consume(content);\n-                continue;\n-            }\n+    /* ServletInputStream */\n \n-            return content;\n-        }\n-    }\n-\n-    /**\n-     * Get the next readable from the inputQ, calling {@link #produceContent()} if need be. EOF is NOT processed and state is not changed.\n-     *\n-     * @return the content or EOF or null if none available.\n-     * @throws IOException if retrieving the content fails\n-     */\n-    protected Content produceNextContext() throws IOException\n+    @Override\n+    public boolean isFinished()\n     {\n-        Content content = nextInterceptedContent();\n-        if (content == null && !isFinished())\n-        {\n-            produceContent();\n-            content = nextInterceptedContent();\n-        }\n-        return content;\n+        boolean finished = _consumedEof;\n+        if (LOG.isDebugEnabled())\n+            LOG.debug(\"isFinished? {}\", finished);\n+        return finished;\n     }\n \n-    /**\n-     * Poll the inputQ for Content or EOF. Consumed buffers and non EOF {@link SentinelContent}s are removed. EOF state is not updated.\n-     * Interception is done within this method.\n-     *\n-     * @return Content with remaining, a {@link SentinelContent},  or null\n-     */\n-    protected Content nextInterceptedContent()\n+    @Override\n+    public boolean isReady()\n     {\n-        // If we have a chunk produced by interception\n-        if (_intercepted != null)\n+        boolean ready = _contentProducer.isReady();\n+        if (!ready)\n         {\n-            // Use it if it has any remaining content\n-            if (_intercepted.hasContent())\n-                return _intercepted;\n-\n-            // succeed the chunk\n-            _intercepted.succeeded();\n-            _intercepted = null;\n-        }\n-\n-        // If we don't have a Content under consideration, get\n-        // the next one off the input Q.\n-        if (_content == null)\n-            _content = _inputQ.poll();\n-\n-        // While we have content to consider.\n-        while (_content != null)\n-        {\n-            // Are we intercepting?\n-            if (_interceptor != null)\n-            {\n-                // Intercept the current content (may be called several\n-                // times for the same content\n-                _intercepted = _interceptor.readFrom(_content);\n-\n-                // If interception produced new content\n-                if (_intercepted != null && _intercepted != _content)\n-                {\n-                    // if it is not empty use it\n-                    if (_intercepted.hasContent())\n-                        return _intercepted;\n-                    _intercepted.succeeded();\n-                }\n-\n-                // intercepted content consumed\n-                _intercepted = null;\n-\n-                // fall through so that the unintercepted _content is\n-                // considered for any remaining content, for EOF and to\n-                // succeed it if it is entirely consumed.\n-            }\n-\n-            // If the content has content or is an EOF marker, use it\n-            if (_content.hasContent() || _content instanceof SentinelContent)\n-                return _content;\n-\n-            // The content is consumed, so get the next one.  Note that EOF\n-            // content is never consumed here, but in #pollContent\n-            _content.succeeded();\n-            _content = _inputQ.poll();\n+            if (LOG.isDebugEnabled())\n+                LOG.debug(\"isReady? false\");\n+            return false;\n         }\n \n-        return null;\n+        if (LOG.isDebugEnabled())\n+            LOG.debug(\"isReady? true\");\n+        return true;\n     }\n \n-    private void consume(Content content)\n+    @Override\n+    public void setReadListener(ReadListener readListener)\n     {\n-        if (!isError() && content instanceof EofContent)\n-        {\n-            if (content == EARLY_EOF_CONTENT)\n-                _state = EARLY_EOF;\n-            else if (_listener == null)\n-                _state = EOF;\n-            else\n-                _state = AEOF;\n-        }\n+        if (_readListener != null)\n+            throw new IllegalStateException(\"ReadListener already set\");\n+        _readListener = Objects.requireNonNull(readListener);\n+        //illegal if async not started\n+        if (!_channelState.isAsyncStarted())\n+            throw new IllegalStateException(\"Async not started\");\n \n-        // Consume the content, either if it was original content\n-        // or if it was produced by interception\n-        content.succeeded();\n-        if (_content == content)\n-            _content = null;\n-        else if (_intercepted == content)\n-            _intercepted = null;\n+        _contentProducer = _asyncContentProducer;\n+        // trigger content production\n+        if (isReady() && _channelState.onReadEof()) // onReadEof b/c we want to transition from WAITING to WOKEN\n+            scheduleReadListenerNotification(); // this is needed by AsyncServletIOTest.testStolenAsyncRead\n     }\n \n-    /**\n-     * Copies the given content into the given byte buffer.\n-     *\n-     * @param content the content to copy from\n-     * @param buffer the buffer to copy into\n-     * @param offset the buffer offset to start copying from\n-     * @param length the space available in the buffer\n-     * @return the number of bytes actually copied\n-     */\n-    protected int get(Content content, byte[] buffer, int offset, int length)\n+    public boolean wakeup()\n     {\n-        int l = content.get(buffer, offset, length);\n-        _contentConsumed += l;\n-        return l;\n+        boolean wakeup = _contentProducer.wakeup();\n+        return wakeup;\n     }\n \n-    /**\n-     * Consumes the given content. Calls the content succeeded if all content consumed.\n-     *\n-     * @param content the content to consume\n-     * @param length the number of bytes to consume\n-     */\n-    protected void skip(Content content, int length)\n-    {\n-        int l = content.skip(length);\n-\n-        _contentConsumed += l;\n-        if (l > 0 && content.isEmpty())\n-            nextNonSentinelContent(); // hungry succeed\n-    }\n-\n-    /**\n-     * Blocks until some content or some end-of-file event arrives.\n-     *\n-     * @throws IOException if the wait is interrupted\n-     */\n-    protected void blockForContent() throws IOException\n+    @Override\n+    public int read() throws IOException\n     {\n-        assert _lock.isHeldByCurrentThread();\n-        try\n-        {\n-            _waitingForContent = true;\n-            _channelState.getHttpChannel().onBlockWaitForContent();\n-\n-            boolean loop = false;\n-            long timeout = 0;\n-            while (true)\n-            {\n-                // This method is called from a loop, so we just\n-                // need to check the timeout before and after waiting.\n-                if (loop)\n-                    break;\n-\n-                if (LOG.isDebugEnabled())\n-                    LOG.debug(\"{} blocking for content timeout={}\", this, timeout);\n-                if (timeout > 0)\n-                    _lock.await(timeout, TimeUnit.MILLISECONDS);\n-                else\n-                    _lock.await();\n-\n-                loop = true;\n-            }\n-        }\n-        catch (Throwable x)\n-        {\n-            _channelState.getHttpChannel().onBlockWaitForContentFailure(x);\n-        }\n+        int read = read(_oneByteBuffer, 0, 1);\n+        if (read == 0)\n+            throw new IOException(\"unready read=0\");\n+        return read < 0 ? -1 : _oneByteBuffer[0] & 0xFF;\n     }\n \n-    /**\n-     * Adds some content to this input stream.\n-     *\n-     * @param content the content to add\n-     * @return true if content channel woken for read\n-     */\n-    public boolean addContent(Content content)\n+    @Override\n+    public int read(byte[] b, int off, int len) throws IOException\n     {\n-        try (AutoLock l = _lock.lock())\n-        {\n-            _waitingForContent = false;\n-            if (_firstByteTimeStamp == -1)\n-                _firstByteTimeStamp = System.nanoTime();\n+        // Calculate minimum request rate for DoS protection\n+        _contentProducer.checkMinDataRate();\n \n-            if (isFinished())\n-            {\n-                Throwable failure = isError() ? _state.getError() : new EOFException(\"Content after EOF\");\n-                content.failed(failure);\n-                return false;\n-            }\n-            else\n-            {\n-                _contentArrived += content.remaining();\n-\n-                if (_content == null && _inputQ.isEmpty())\n-                    _content = content;\n-                else\n-                    _inputQ.offer(content);\n-\n-                if (LOG.isDebugEnabled())\n-                    LOG.debug(\"{} addContent {}\", this, content);\n-\n-                if (nextInterceptedContent() != null)\n-                    return wakeup();\n-                else\n-                    return false;\n-            }\n-        }\n-    }\n-\n-    public boolean hasContent()\n-    {\n-        try (AutoLock l = _lock.lock())\n+        Content content = _contentProducer.nextContent();\n+        if (content == null)\n+            throw new IllegalStateException(\"read on unready input\");\n+        if (!content.isSpecial())\n         {\n-            return _content != null || _inputQ.size() > 0;\n+            int read = content.get(b, off, len);\n+            if (LOG.isDebugEnabled())\n+                LOG.debug(\"read produced {} byte(s)\", read);\n+            // Content may be null after the call to read, so it may need to be freed up.\n+            _contentProducer.reclaim(content);\n+            return read;\n         }\n-    }\n \n-    public void unblock()\n-    {\n-        try (AutoLock.WithCondition l = _lock.lock())\n+        Throwable error = content.getError();\n+        if (LOG.isDebugEnabled())\n+            LOG.debug(\"read error = \" + error);\n+        if (error != null)\n         {\n-            l.signal();\n+            if (error instanceof IOException)\n+                throw (IOException)error;\n+            throw new IOException(error);\n         }\n-    }\n \n-    public long getContentConsumed()\n-    {\n-        try (AutoLock l = _lock.lock())\n+        if (content.isEof())\n         {\n-            return _contentConsumed;\n+            if (LOG.isDebugEnabled())\n+                LOG.debug(\"read on EOF, switching to CONSUMED_EOF and returning\");\n+            _consumedEof = true;\n+            if (wakeup())\n+                scheduleReadListenerNotification();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "273213e8df4f438bf853787ec932e22424e7fe8b"}, "originalPosition": 707}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTQxMDgxNA==", "bodyText": "Perhaps \"peekContent()` is more descriptive of what the method does.", "url": "https://github.com/eclipse/jetty.project/pull/4556#discussion_r505410814", "createdAt": "2020-10-15T09:49:55Z", "author": {"login": "sbordet"}, "path": "jetty-server/src/main/java/org/eclipse/jetty/server/HttpInput.java", "diffHunk": "@@ -192,648 +83,183 @@ public Interceptor getInterceptor()\n      */\n     public void setInterceptor(Interceptor interceptor)\n     {\n-        _interceptor = interceptor;\n+        _contentProducer.setInterceptor(interceptor);\n     }\n \n     /**\n-     * Set the {@link Interceptor}, using a {@link ChainedInterceptor} if\n+     * Set the {@link Interceptor}, chaining it to the existing one if\n      * an {@link Interceptor} is already set.\n      *\n      * @param interceptor the next {@link Interceptor} in a chain\n      */\n     public void addInterceptor(Interceptor interceptor)\n     {\n-        if (_interceptor == null)\n-            _interceptor = interceptor;\n+        Interceptor currentInterceptor = _contentProducer.getInterceptor();\n+        if (currentInterceptor == null)\n+            _contentProducer.setInterceptor(interceptor);\n         else\n-            _interceptor = new ChainedInterceptor(_interceptor, interceptor);\n+            _contentProducer.setInterceptor(new ChainedInterceptor(currentInterceptor, interceptor));\n     }\n \n-    @Override\n-    public int available()\n-    {\n-        int available = 0;\n-        boolean woken = false;\n-        try (AutoLock l = _lock.lock())\n-        {\n-            if (_content == null)\n-                _content = _inputQ.poll();\n-            if (_content == null)\n-            {\n-                try\n-                {\n-                    produceContent();\n-                }\n-                catch (IOException e)\n-                {\n-                    woken = failed(e);\n-                }\n-                if (_content == null)\n-                    _content = _inputQ.poll();\n-            }\n-\n-            if (_content != null)\n-                available = _content.remaining();\n-        }\n-\n-        if (woken)\n-            wake();\n-        return available;\n-    }\n-\n-    protected void wake()\n-    {\n-        HttpChannel channel = _channelState.getHttpChannel();\n-        Executor executor = channel.getConnector().getServer().getThreadPool();\n-        executor.execute(channel);\n-    }\n-\n-    @Override\n-    public int read() throws IOException\n+    public long getContentReceived()\n     {\n-        int read = read(_oneByteBuffer, 0, 1);\n-        if (read == 0)\n-            throw new IllegalStateException(\"unready read=0\");\n-        return read < 0 ? -1 : _oneByteBuffer[0] & 0xFF;\n+        return _contentProducer.getRawContentArrived();\n     }\n \n-    @Override\n-    public int read(byte[] b, int off, int len) throws IOException\n+    public boolean consumeAll()\n     {\n-        boolean wake = false;\n-        int read;\n-        try (AutoLock l = _lock.lock())\n-        {\n-            // Calculate minimum request rate for DOS protection\n-            long minRequestDataRate = _channelState.getHttpChannel().getHttpConfiguration().getMinRequestDataRate();\n-            if (minRequestDataRate > 0 && _firstByteTimeStamp != -1)\n-            {\n-                long period = System.nanoTime() - _firstByteTimeStamp;\n-                if (period > 0)\n-                {\n-                    long minimumData = minRequestDataRate * TimeUnit.NANOSECONDS.toMillis(period) / TimeUnit.SECONDS.toMillis(1);\n-                    if (_contentArrived < minimumData)\n-                    {\n-                        BadMessageException bad = new BadMessageException(HttpStatus.REQUEST_TIMEOUT_408,\n-                            String.format(\"Request content data rate < %d B/s\", minRequestDataRate));\n-                        if (_channelState.isResponseCommitted())\n-                            _channelState.getHttpChannel().abort(bad);\n-                        throw bad;\n-                    }\n-                }\n-            }\n+        if (LOG.isDebugEnabled())\n+            LOG.debug(\"consume all\");\n+        boolean atEof = _contentProducer.consumeAll(new IOException(\"Unconsumed content\"));\n+        if (atEof)\n+            _consumedEof = true;\n \n-            // Consume content looking for bytes to read\n-            while (true)\n-            {\n-                Content item = nextContent();\n-                if (item != null)\n-                {\n-                    read = get(item, b, off, len);\n-                    if (LOG.isDebugEnabled())\n-                        LOG.debug(\"{} read {} from {}\", this, read, item);\n-\n-                    // Consume any following poison pills\n-                    if (item.isEmpty())\n-                        nextInterceptedContent();\n-                    break;\n-                }\n-\n-                // No content, so should we block?\n-                if (!_state.blockForContent(this))\n-                {\n-                    // Not blocking, so what should we return?\n-                    read = _state.noContent();\n-\n-                    if (read < 0)\n-                        // If EOF do we need to wake for allDataRead callback?\n-                        wake = _channelState.onReadEof();\n-                    break;\n-                }\n-            }\n-        }\n-\n-        if (wake)\n-            wake();\n-        return read;\n-    }\n+        if (isFinished())\n+            return !isError();\n \n-    /**\n-     * Called when derived implementations should attempt to produce more Content and add it via {@link #addContent(Content)}. For protocols that are constantly\n-     * producing (eg HTTP2) this can be left as a noop;\n-     *\n-     * @throws IOException if unable to produce content\n-     */\n-    protected void produceContent() throws IOException\n-    {\n+        // Modifying the state here to anything other than IDLE makes\n+        // ServerTimeoutsTest.testAsyncReadWithDelayedFirstContentWithDelayedDispatchIdleTimeoutFires H2C fail.\n+        return false;\n     }\n \n-    /**\n-     * Called by channel when asynchronous IO needs to produce more content\n-     *\n-     * @throws IOException if unable to produce content\n-     */\n-    public void asyncReadProduce() throws IOException\n+    public boolean isError()\n     {\n-        try (AutoLock l = _lock.lock())\n-        {\n-            produceContent();\n-        }\n+        return _contentProducer.isError();\n     }\n \n-    /**\n-     * Get the next content from the inputQ, calling {@link #produceContent()} if need be. EOF is processed and state changed.\n-     *\n-     * @return the content or null if none available.\n-     * @throws IOException if retrieving the content fails\n-     */\n-    protected Content nextContent() throws IOException\n+    public boolean isAsync()\n     {\n-        Content content = nextNonSentinelContent();\n-        if (content == null && !isFinished())\n-        {\n-            produceContent();\n-            content = nextNonSentinelContent();\n-        }\n-        return content;\n+        return _readListener != null;\n     }\n \n-    /**\n-     * Poll the inputQ for Content. Consumed buffers and {@link SentinelContent}s are removed and EOF state updated if need be.\n-     *\n-     * @return Content or null\n-     */\n-    protected Content nextNonSentinelContent()\n-    {\n-        while (true)\n-        {\n-            // Get the next content (or EOF)\n-            Content content = nextInterceptedContent();\n-\n-            // If it is EOF, consume it here\n-            if (content instanceof SentinelContent)\n-            {\n-                // Consume the EOF content, either if it was original content\n-                // or if it was produced by interception\n-                consume(content);\n-                continue;\n-            }\n+    /* ServletInputStream */\n \n-            return content;\n-        }\n-    }\n-\n-    /**\n-     * Get the next readable from the inputQ, calling {@link #produceContent()} if need be. EOF is NOT processed and state is not changed.\n-     *\n-     * @return the content or EOF or null if none available.\n-     * @throws IOException if retrieving the content fails\n-     */\n-    protected Content produceNextContext() throws IOException\n+    @Override\n+    public boolean isFinished()\n     {\n-        Content content = nextInterceptedContent();\n-        if (content == null && !isFinished())\n-        {\n-            produceContent();\n-            content = nextInterceptedContent();\n-        }\n-        return content;\n+        boolean finished = _consumedEof;\n+        if (LOG.isDebugEnabled())\n+            LOG.debug(\"isFinished? {}\", finished);\n+        return finished;\n     }\n \n-    /**\n-     * Poll the inputQ for Content or EOF. Consumed buffers and non EOF {@link SentinelContent}s are removed. EOF state is not updated.\n-     * Interception is done within this method.\n-     *\n-     * @return Content with remaining, a {@link SentinelContent},  or null\n-     */\n-    protected Content nextInterceptedContent()\n+    @Override\n+    public boolean isReady()\n     {\n-        // If we have a chunk produced by interception\n-        if (_intercepted != null)\n+        boolean ready = _contentProducer.isReady();\n+        if (!ready)\n         {\n-            // Use it if it has any remaining content\n-            if (_intercepted.hasContent())\n-                return _intercepted;\n-\n-            // succeed the chunk\n-            _intercepted.succeeded();\n-            _intercepted = null;\n-        }\n-\n-        // If we don't have a Content under consideration, get\n-        // the next one off the input Q.\n-        if (_content == null)\n-            _content = _inputQ.poll();\n-\n-        // While we have content to consider.\n-        while (_content != null)\n-        {\n-            // Are we intercepting?\n-            if (_interceptor != null)\n-            {\n-                // Intercept the current content (may be called several\n-                // times for the same content\n-                _intercepted = _interceptor.readFrom(_content);\n-\n-                // If interception produced new content\n-                if (_intercepted != null && _intercepted != _content)\n-                {\n-                    // if it is not empty use it\n-                    if (_intercepted.hasContent())\n-                        return _intercepted;\n-                    _intercepted.succeeded();\n-                }\n-\n-                // intercepted content consumed\n-                _intercepted = null;\n-\n-                // fall through so that the unintercepted _content is\n-                // considered for any remaining content, for EOF and to\n-                // succeed it if it is entirely consumed.\n-            }\n-\n-            // If the content has content or is an EOF marker, use it\n-            if (_content.hasContent() || _content instanceof SentinelContent)\n-                return _content;\n-\n-            // The content is consumed, so get the next one.  Note that EOF\n-            // content is never consumed here, but in #pollContent\n-            _content.succeeded();\n-            _content = _inputQ.poll();\n+            if (LOG.isDebugEnabled())\n+                LOG.debug(\"isReady? false\");\n+            return false;\n         }\n \n-        return null;\n+        if (LOG.isDebugEnabled())\n+            LOG.debug(\"isReady? true\");\n+        return true;\n     }\n \n-    private void consume(Content content)\n+    @Override\n+    public void setReadListener(ReadListener readListener)\n     {\n-        if (!isError() && content instanceof EofContent)\n-        {\n-            if (content == EARLY_EOF_CONTENT)\n-                _state = EARLY_EOF;\n-            else if (_listener == null)\n-                _state = EOF;\n-            else\n-                _state = AEOF;\n-        }\n+        if (_readListener != null)\n+            throw new IllegalStateException(\"ReadListener already set\");\n+        _readListener = Objects.requireNonNull(readListener);\n+        //illegal if async not started\n+        if (!_channelState.isAsyncStarted())\n+            throw new IllegalStateException(\"Async not started\");\n \n-        // Consume the content, either if it was original content\n-        // or if it was produced by interception\n-        content.succeeded();\n-        if (_content == content)\n-            _content = null;\n-        else if (_intercepted == content)\n-            _intercepted = null;\n+        _contentProducer = _asyncContentProducer;\n+        // trigger content production\n+        if (isReady() && _channelState.onReadEof()) // onReadEof b/c we want to transition from WAITING to WOKEN\n+            scheduleReadListenerNotification(); // this is needed by AsyncServletIOTest.testStolenAsyncRead\n     }\n \n-    /**\n-     * Copies the given content into the given byte buffer.\n-     *\n-     * @param content the content to copy from\n-     * @param buffer the buffer to copy into\n-     * @param offset the buffer offset to start copying from\n-     * @param length the space available in the buffer\n-     * @return the number of bytes actually copied\n-     */\n-    protected int get(Content content, byte[] buffer, int offset, int length)\n+    public boolean wakeup()\n     {\n-        int l = content.get(buffer, offset, length);\n-        _contentConsumed += l;\n-        return l;\n+        boolean wakeup = _contentProducer.wakeup();\n+        return wakeup;\n     }\n \n-    /**\n-     * Consumes the given content. Calls the content succeeded if all content consumed.\n-     *\n-     * @param content the content to consume\n-     * @param length the number of bytes to consume\n-     */\n-    protected void skip(Content content, int length)\n-    {\n-        int l = content.skip(length);\n-\n-        _contentConsumed += l;\n-        if (l > 0 && content.isEmpty())\n-            nextNonSentinelContent(); // hungry succeed\n-    }\n-\n-    /**\n-     * Blocks until some content or some end-of-file event arrives.\n-     *\n-     * @throws IOException if the wait is interrupted\n-     */\n-    protected void blockForContent() throws IOException\n+    @Override\n+    public int read() throws IOException\n     {\n-        assert _lock.isHeldByCurrentThread();\n-        try\n-        {\n-            _waitingForContent = true;\n-            _channelState.getHttpChannel().onBlockWaitForContent();\n-\n-            boolean loop = false;\n-            long timeout = 0;\n-            while (true)\n-            {\n-                // This method is called from a loop, so we just\n-                // need to check the timeout before and after waiting.\n-                if (loop)\n-                    break;\n-\n-                if (LOG.isDebugEnabled())\n-                    LOG.debug(\"{} blocking for content timeout={}\", this, timeout);\n-                if (timeout > 0)\n-                    _lock.await(timeout, TimeUnit.MILLISECONDS);\n-                else\n-                    _lock.await();\n-\n-                loop = true;\n-            }\n-        }\n-        catch (Throwable x)\n-        {\n-            _channelState.getHttpChannel().onBlockWaitForContentFailure(x);\n-        }\n+        int read = read(_oneByteBuffer, 0, 1);\n+        if (read == 0)\n+            throw new IOException(\"unready read=0\");\n+        return read < 0 ? -1 : _oneByteBuffer[0] & 0xFF;\n     }\n \n-    /**\n-     * Adds some content to this input stream.\n-     *\n-     * @param content the content to add\n-     * @return true if content channel woken for read\n-     */\n-    public boolean addContent(Content content)\n+    @Override\n+    public int read(byte[] b, int off, int len) throws IOException\n     {\n-        try (AutoLock l = _lock.lock())\n-        {\n-            _waitingForContent = false;\n-            if (_firstByteTimeStamp == -1)\n-                _firstByteTimeStamp = System.nanoTime();\n+        // Calculate minimum request rate for DoS protection\n+        _contentProducer.checkMinDataRate();\n \n-            if (isFinished())\n-            {\n-                Throwable failure = isError() ? _state.getError() : new EOFException(\"Content after EOF\");\n-                content.failed(failure);\n-                return false;\n-            }\n-            else\n-            {\n-                _contentArrived += content.remaining();\n-\n-                if (_content == null && _inputQ.isEmpty())\n-                    _content = content;\n-                else\n-                    _inputQ.offer(content);\n-\n-                if (LOG.isDebugEnabled())\n-                    LOG.debug(\"{} addContent {}\", this, content);\n-\n-                if (nextInterceptedContent() != null)\n-                    return wakeup();\n-                else\n-                    return false;\n-            }\n-        }\n-    }\n-\n-    public boolean hasContent()\n-    {\n-        try (AutoLock l = _lock.lock())\n+        Content content = _contentProducer.nextContent();\n+        if (content == null)\n+            throw new IllegalStateException(\"read on unready input\");\n+        if (!content.isSpecial())\n         {\n-            return _content != null || _inputQ.size() > 0;\n+            int read = content.get(b, off, len);\n+            if (LOG.isDebugEnabled())\n+                LOG.debug(\"read produced {} byte(s)\", read);\n+            // Content may be null after the call to read, so it may need to be freed up.\n+            _contentProducer.reclaim(content);\n+            return read;\n         }\n-    }\n \n-    public void unblock()\n-    {\n-        try (AutoLock.WithCondition l = _lock.lock())\n+        Throwable error = content.getError();\n+        if (LOG.isDebugEnabled())\n+            LOG.debug(\"read error = \" + error);\n+        if (error != null)\n         {\n-            l.signal();\n+            if (error instanceof IOException)\n+                throw (IOException)error;\n+            throw new IOException(error);\n         }\n-    }\n \n-    public long getContentConsumed()\n-    {\n-        try (AutoLock l = _lock.lock())\n+        if (content.isEof())\n         {\n-            return _contentConsumed;\n+            if (LOG.isDebugEnabled())\n+                LOG.debug(\"read on EOF, switching to CONSUMED_EOF and returning\");\n+            _consumedEof = true;\n+            if (wakeup())\n+                scheduleReadListenerNotification();\n+            return -1;\n         }\n-    }\n \n-    public long getContentReceived()\n-    {\n-        synchronized (_inputQ)\n-        {\n-            return _contentArrived;\n-        }\n+        throw new AssertionError(\"no data, no error and not EOF\");\n     }\n \n-    /**\n-     * This method should be called to signal that an EOF has been detected before all the expected content arrived.\n-     * <p>\n-     * Typically this will result in an EOFException being thrown from a subsequent read rather than a -1 return.\n-     *\n-     * @return true if content channel woken for read\n-     */\n-    public boolean earlyEOF()\n+    private void scheduleReadListenerNotification()\n     {\n-        return addContent(EARLY_EOF_CONTENT);\n+        HttpChannel channel = _channelState.getHttpChannel();\n+        channel.execute(channel);\n     }\n \n     /**\n-     * This method should be called to signal that all the expected content arrived.\n-     *\n-     * @return true if content channel woken for read\n+     * Check if this HttpInput instance has content stored internally, without fetching/parsing\n+     * anything from the underlying channel.\n+     * @return true if the input contains content, false otherwise.\n      */\n-    public boolean eof()\n-    {\n-        return addContent(EOF_CONTENT);\n-    }\n-\n-    public boolean consumeAll()\n-    {\n-        try (AutoLock l = _lock.lock())\n-        {\n-            try\n-            {\n-                while (true)\n-                {\n-                    Content item = nextContent();\n-                    if (item == null)\n-                        break; // Let's not bother blocking\n-\n-                    skip(item, item.remaining());\n-                }\n-                if (isFinished())\n-                    return !isError();\n-\n-                _state = EARLY_EOF;\n-                return false;\n-            }\n-            catch (Throwable e)\n-            {\n-                if (LOG.isDebugEnabled())\n-                    LOG.debug(\"Unable to consume all input\", e);\n-                _state = new ErrorState(e);\n-                return false;\n-            }\n-        }\n-    }\n-\n-    public boolean isError()\n-    {\n-        try (AutoLock l = _lock.lock())\n-        {\n-            return _state instanceof ErrorState;\n-        }\n-    }\n-\n-    public boolean isAsync()\n-    {\n-        try (AutoLock l = _lock.lock())\n-        {\n-            return _state == ASYNC;\n-        }\n-    }\n-\n-    @Override\n-    public boolean isFinished()\n-    {\n-        try (AutoLock l = _lock.lock())\n-        {\n-            return _state instanceof EOFState;\n-        }\n-    }\n-\n-    @Override\n-    public boolean isReady()\n+    public boolean hasContent()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "273213e8df4f438bf853787ec932e22424e7fe8b"}, "originalPosition": 806}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTQxMjI1MA==", "bodyText": "Don't mention test failures -- just why available() cannot be called.\nEven though available() should be an idempotent method without side effects -- why can't be used here?", "url": "https://github.com/eclipse/jetty.project/pull/4556#discussion_r505412250", "createdAt": "2020-10-15T09:52:05Z", "author": {"login": "sbordet"}, "path": "jetty-server/src/main/java/org/eclipse/jetty/server/HttpInput.java", "diffHunk": "@@ -192,648 +83,183 @@ public Interceptor getInterceptor()\n      */\n     public void setInterceptor(Interceptor interceptor)\n     {\n-        _interceptor = interceptor;\n+        _contentProducer.setInterceptor(interceptor);\n     }\n \n     /**\n-     * Set the {@link Interceptor}, using a {@link ChainedInterceptor} if\n+     * Set the {@link Interceptor}, chaining it to the existing one if\n      * an {@link Interceptor} is already set.\n      *\n      * @param interceptor the next {@link Interceptor} in a chain\n      */\n     public void addInterceptor(Interceptor interceptor)\n     {\n-        if (_interceptor == null)\n-            _interceptor = interceptor;\n+        Interceptor currentInterceptor = _contentProducer.getInterceptor();\n+        if (currentInterceptor == null)\n+            _contentProducer.setInterceptor(interceptor);\n         else\n-            _interceptor = new ChainedInterceptor(_interceptor, interceptor);\n+            _contentProducer.setInterceptor(new ChainedInterceptor(currentInterceptor, interceptor));\n     }\n \n-    @Override\n-    public int available()\n-    {\n-        int available = 0;\n-        boolean woken = false;\n-        try (AutoLock l = _lock.lock())\n-        {\n-            if (_content == null)\n-                _content = _inputQ.poll();\n-            if (_content == null)\n-            {\n-                try\n-                {\n-                    produceContent();\n-                }\n-                catch (IOException e)\n-                {\n-                    woken = failed(e);\n-                }\n-                if (_content == null)\n-                    _content = _inputQ.poll();\n-            }\n-\n-            if (_content != null)\n-                available = _content.remaining();\n-        }\n-\n-        if (woken)\n-            wake();\n-        return available;\n-    }\n-\n-    protected void wake()\n-    {\n-        HttpChannel channel = _channelState.getHttpChannel();\n-        Executor executor = channel.getConnector().getServer().getThreadPool();\n-        executor.execute(channel);\n-    }\n-\n-    @Override\n-    public int read() throws IOException\n+    public long getContentReceived()\n     {\n-        int read = read(_oneByteBuffer, 0, 1);\n-        if (read == 0)\n-            throw new IllegalStateException(\"unready read=0\");\n-        return read < 0 ? -1 : _oneByteBuffer[0] & 0xFF;\n+        return _contentProducer.getRawContentArrived();\n     }\n \n-    @Override\n-    public int read(byte[] b, int off, int len) throws IOException\n+    public boolean consumeAll()\n     {\n-        boolean wake = false;\n-        int read;\n-        try (AutoLock l = _lock.lock())\n-        {\n-            // Calculate minimum request rate for DOS protection\n-            long minRequestDataRate = _channelState.getHttpChannel().getHttpConfiguration().getMinRequestDataRate();\n-            if (minRequestDataRate > 0 && _firstByteTimeStamp != -1)\n-            {\n-                long period = System.nanoTime() - _firstByteTimeStamp;\n-                if (period > 0)\n-                {\n-                    long minimumData = minRequestDataRate * TimeUnit.NANOSECONDS.toMillis(period) / TimeUnit.SECONDS.toMillis(1);\n-                    if (_contentArrived < minimumData)\n-                    {\n-                        BadMessageException bad = new BadMessageException(HttpStatus.REQUEST_TIMEOUT_408,\n-                            String.format(\"Request content data rate < %d B/s\", minRequestDataRate));\n-                        if (_channelState.isResponseCommitted())\n-                            _channelState.getHttpChannel().abort(bad);\n-                        throw bad;\n-                    }\n-                }\n-            }\n+        if (LOG.isDebugEnabled())\n+            LOG.debug(\"consume all\");\n+        boolean atEof = _contentProducer.consumeAll(new IOException(\"Unconsumed content\"));\n+        if (atEof)\n+            _consumedEof = true;\n \n-            // Consume content looking for bytes to read\n-            while (true)\n-            {\n-                Content item = nextContent();\n-                if (item != null)\n-                {\n-                    read = get(item, b, off, len);\n-                    if (LOG.isDebugEnabled())\n-                        LOG.debug(\"{} read {} from {}\", this, read, item);\n-\n-                    // Consume any following poison pills\n-                    if (item.isEmpty())\n-                        nextInterceptedContent();\n-                    break;\n-                }\n-\n-                // No content, so should we block?\n-                if (!_state.blockForContent(this))\n-                {\n-                    // Not blocking, so what should we return?\n-                    read = _state.noContent();\n-\n-                    if (read < 0)\n-                        // If EOF do we need to wake for allDataRead callback?\n-                        wake = _channelState.onReadEof();\n-                    break;\n-                }\n-            }\n-        }\n-\n-        if (wake)\n-            wake();\n-        return read;\n-    }\n+        if (isFinished())\n+            return !isError();\n \n-    /**\n-     * Called when derived implementations should attempt to produce more Content and add it via {@link #addContent(Content)}. For protocols that are constantly\n-     * producing (eg HTTP2) this can be left as a noop;\n-     *\n-     * @throws IOException if unable to produce content\n-     */\n-    protected void produceContent() throws IOException\n-    {\n+        // Modifying the state here to anything other than IDLE makes\n+        // ServerTimeoutsTest.testAsyncReadWithDelayedFirstContentWithDelayedDispatchIdleTimeoutFires H2C fail.\n+        return false;\n     }\n \n-    /**\n-     * Called by channel when asynchronous IO needs to produce more content\n-     *\n-     * @throws IOException if unable to produce content\n-     */\n-    public void asyncReadProduce() throws IOException\n+    public boolean isError()\n     {\n-        try (AutoLock l = _lock.lock())\n-        {\n-            produceContent();\n-        }\n+        return _contentProducer.isError();\n     }\n \n-    /**\n-     * Get the next content from the inputQ, calling {@link #produceContent()} if need be. EOF is processed and state changed.\n-     *\n-     * @return the content or null if none available.\n-     * @throws IOException if retrieving the content fails\n-     */\n-    protected Content nextContent() throws IOException\n+    public boolean isAsync()\n     {\n-        Content content = nextNonSentinelContent();\n-        if (content == null && !isFinished())\n-        {\n-            produceContent();\n-            content = nextNonSentinelContent();\n-        }\n-        return content;\n+        return _readListener != null;\n     }\n \n-    /**\n-     * Poll the inputQ for Content. Consumed buffers and {@link SentinelContent}s are removed and EOF state updated if need be.\n-     *\n-     * @return Content or null\n-     */\n-    protected Content nextNonSentinelContent()\n-    {\n-        while (true)\n-        {\n-            // Get the next content (or EOF)\n-            Content content = nextInterceptedContent();\n-\n-            // If it is EOF, consume it here\n-            if (content instanceof SentinelContent)\n-            {\n-                // Consume the EOF content, either if it was original content\n-                // or if it was produced by interception\n-                consume(content);\n-                continue;\n-            }\n+    /* ServletInputStream */\n \n-            return content;\n-        }\n-    }\n-\n-    /**\n-     * Get the next readable from the inputQ, calling {@link #produceContent()} if need be. EOF is NOT processed and state is not changed.\n-     *\n-     * @return the content or EOF or null if none available.\n-     * @throws IOException if retrieving the content fails\n-     */\n-    protected Content produceNextContext() throws IOException\n+    @Override\n+    public boolean isFinished()\n     {\n-        Content content = nextInterceptedContent();\n-        if (content == null && !isFinished())\n-        {\n-            produceContent();\n-            content = nextInterceptedContent();\n-        }\n-        return content;\n+        boolean finished = _consumedEof;\n+        if (LOG.isDebugEnabled())\n+            LOG.debug(\"isFinished? {}\", finished);\n+        return finished;\n     }\n \n-    /**\n-     * Poll the inputQ for Content or EOF. Consumed buffers and non EOF {@link SentinelContent}s are removed. EOF state is not updated.\n-     * Interception is done within this method.\n-     *\n-     * @return Content with remaining, a {@link SentinelContent},  or null\n-     */\n-    protected Content nextInterceptedContent()\n+    @Override\n+    public boolean isReady()\n     {\n-        // If we have a chunk produced by interception\n-        if (_intercepted != null)\n+        boolean ready = _contentProducer.isReady();\n+        if (!ready)\n         {\n-            // Use it if it has any remaining content\n-            if (_intercepted.hasContent())\n-                return _intercepted;\n-\n-            // succeed the chunk\n-            _intercepted.succeeded();\n-            _intercepted = null;\n-        }\n-\n-        // If we don't have a Content under consideration, get\n-        // the next one off the input Q.\n-        if (_content == null)\n-            _content = _inputQ.poll();\n-\n-        // While we have content to consider.\n-        while (_content != null)\n-        {\n-            // Are we intercepting?\n-            if (_interceptor != null)\n-            {\n-                // Intercept the current content (may be called several\n-                // times for the same content\n-                _intercepted = _interceptor.readFrom(_content);\n-\n-                // If interception produced new content\n-                if (_intercepted != null && _intercepted != _content)\n-                {\n-                    // if it is not empty use it\n-                    if (_intercepted.hasContent())\n-                        return _intercepted;\n-                    _intercepted.succeeded();\n-                }\n-\n-                // intercepted content consumed\n-                _intercepted = null;\n-\n-                // fall through so that the unintercepted _content is\n-                // considered for any remaining content, for EOF and to\n-                // succeed it if it is entirely consumed.\n-            }\n-\n-            // If the content has content or is an EOF marker, use it\n-            if (_content.hasContent() || _content instanceof SentinelContent)\n-                return _content;\n-\n-            // The content is consumed, so get the next one.  Note that EOF\n-            // content is never consumed here, but in #pollContent\n-            _content.succeeded();\n-            _content = _inputQ.poll();\n+            if (LOG.isDebugEnabled())\n+                LOG.debug(\"isReady? false\");\n+            return false;\n         }\n \n-        return null;\n+        if (LOG.isDebugEnabled())\n+            LOG.debug(\"isReady? true\");\n+        return true;\n     }\n \n-    private void consume(Content content)\n+    @Override\n+    public void setReadListener(ReadListener readListener)\n     {\n-        if (!isError() && content instanceof EofContent)\n-        {\n-            if (content == EARLY_EOF_CONTENT)\n-                _state = EARLY_EOF;\n-            else if (_listener == null)\n-                _state = EOF;\n-            else\n-                _state = AEOF;\n-        }\n+        if (_readListener != null)\n+            throw new IllegalStateException(\"ReadListener already set\");\n+        _readListener = Objects.requireNonNull(readListener);\n+        //illegal if async not started\n+        if (!_channelState.isAsyncStarted())\n+            throw new IllegalStateException(\"Async not started\");\n \n-        // Consume the content, either if it was original content\n-        // or if it was produced by interception\n-        content.succeeded();\n-        if (_content == content)\n-            _content = null;\n-        else if (_intercepted == content)\n-            _intercepted = null;\n+        _contentProducer = _asyncContentProducer;\n+        // trigger content production\n+        if (isReady() && _channelState.onReadEof()) // onReadEof b/c we want to transition from WAITING to WOKEN\n+            scheduleReadListenerNotification(); // this is needed by AsyncServletIOTest.testStolenAsyncRead\n     }\n \n-    /**\n-     * Copies the given content into the given byte buffer.\n-     *\n-     * @param content the content to copy from\n-     * @param buffer the buffer to copy into\n-     * @param offset the buffer offset to start copying from\n-     * @param length the space available in the buffer\n-     * @return the number of bytes actually copied\n-     */\n-    protected int get(Content content, byte[] buffer, int offset, int length)\n+    public boolean wakeup()\n     {\n-        int l = content.get(buffer, offset, length);\n-        _contentConsumed += l;\n-        return l;\n+        boolean wakeup = _contentProducer.wakeup();\n+        return wakeup;\n     }\n \n-    /**\n-     * Consumes the given content. Calls the content succeeded if all content consumed.\n-     *\n-     * @param content the content to consume\n-     * @param length the number of bytes to consume\n-     */\n-    protected void skip(Content content, int length)\n-    {\n-        int l = content.skip(length);\n-\n-        _contentConsumed += l;\n-        if (l > 0 && content.isEmpty())\n-            nextNonSentinelContent(); // hungry succeed\n-    }\n-\n-    /**\n-     * Blocks until some content or some end-of-file event arrives.\n-     *\n-     * @throws IOException if the wait is interrupted\n-     */\n-    protected void blockForContent() throws IOException\n+    @Override\n+    public int read() throws IOException\n     {\n-        assert _lock.isHeldByCurrentThread();\n-        try\n-        {\n-            _waitingForContent = true;\n-            _channelState.getHttpChannel().onBlockWaitForContent();\n-\n-            boolean loop = false;\n-            long timeout = 0;\n-            while (true)\n-            {\n-                // This method is called from a loop, so we just\n-                // need to check the timeout before and after waiting.\n-                if (loop)\n-                    break;\n-\n-                if (LOG.isDebugEnabled())\n-                    LOG.debug(\"{} blocking for content timeout={}\", this, timeout);\n-                if (timeout > 0)\n-                    _lock.await(timeout, TimeUnit.MILLISECONDS);\n-                else\n-                    _lock.await();\n-\n-                loop = true;\n-            }\n-        }\n-        catch (Throwable x)\n-        {\n-            _channelState.getHttpChannel().onBlockWaitForContentFailure(x);\n-        }\n+        int read = read(_oneByteBuffer, 0, 1);\n+        if (read == 0)\n+            throw new IOException(\"unready read=0\");\n+        return read < 0 ? -1 : _oneByteBuffer[0] & 0xFF;\n     }\n \n-    /**\n-     * Adds some content to this input stream.\n-     *\n-     * @param content the content to add\n-     * @return true if content channel woken for read\n-     */\n-    public boolean addContent(Content content)\n+    @Override\n+    public int read(byte[] b, int off, int len) throws IOException\n     {\n-        try (AutoLock l = _lock.lock())\n-        {\n-            _waitingForContent = false;\n-            if (_firstByteTimeStamp == -1)\n-                _firstByteTimeStamp = System.nanoTime();\n+        // Calculate minimum request rate for DoS protection\n+        _contentProducer.checkMinDataRate();\n \n-            if (isFinished())\n-            {\n-                Throwable failure = isError() ? _state.getError() : new EOFException(\"Content after EOF\");\n-                content.failed(failure);\n-                return false;\n-            }\n-            else\n-            {\n-                _contentArrived += content.remaining();\n-\n-                if (_content == null && _inputQ.isEmpty())\n-                    _content = content;\n-                else\n-                    _inputQ.offer(content);\n-\n-                if (LOG.isDebugEnabled())\n-                    LOG.debug(\"{} addContent {}\", this, content);\n-\n-                if (nextInterceptedContent() != null)\n-                    return wakeup();\n-                else\n-                    return false;\n-            }\n-        }\n-    }\n-\n-    public boolean hasContent()\n-    {\n-        try (AutoLock l = _lock.lock())\n+        Content content = _contentProducer.nextContent();\n+        if (content == null)\n+            throw new IllegalStateException(\"read on unready input\");\n+        if (!content.isSpecial())\n         {\n-            return _content != null || _inputQ.size() > 0;\n+            int read = content.get(b, off, len);\n+            if (LOG.isDebugEnabled())\n+                LOG.debug(\"read produced {} byte(s)\", read);\n+            // Content may be null after the call to read, so it may need to be freed up.\n+            _contentProducer.reclaim(content);\n+            return read;\n         }\n-    }\n \n-    public void unblock()\n-    {\n-        try (AutoLock.WithCondition l = _lock.lock())\n+        Throwable error = content.getError();\n+        if (LOG.isDebugEnabled())\n+            LOG.debug(\"read error = \" + error);\n+        if (error != null)\n         {\n-            l.signal();\n+            if (error instanceof IOException)\n+                throw (IOException)error;\n+            throw new IOException(error);\n         }\n-    }\n \n-    public long getContentConsumed()\n-    {\n-        try (AutoLock l = _lock.lock())\n+        if (content.isEof())\n         {\n-            return _contentConsumed;\n+            if (LOG.isDebugEnabled())\n+                LOG.debug(\"read on EOF, switching to CONSUMED_EOF and returning\");\n+            _consumedEof = true;\n+            if (wakeup())\n+                scheduleReadListenerNotification();\n+            return -1;\n         }\n-    }\n \n-    public long getContentReceived()\n-    {\n-        synchronized (_inputQ)\n-        {\n-            return _contentArrived;\n-        }\n+        throw new AssertionError(\"no data, no error and not EOF\");\n     }\n \n-    /**\n-     * This method should be called to signal that an EOF has been detected before all the expected content arrived.\n-     * <p>\n-     * Typically this will result in an EOFException being thrown from a subsequent read rather than a -1 return.\n-     *\n-     * @return true if content channel woken for read\n-     */\n-    public boolean earlyEOF()\n+    private void scheduleReadListenerNotification()\n     {\n-        return addContent(EARLY_EOF_CONTENT);\n+        HttpChannel channel = _channelState.getHttpChannel();\n+        channel.execute(channel);\n     }\n \n     /**\n-     * This method should be called to signal that all the expected content arrived.\n-     *\n-     * @return true if content channel woken for read\n+     * Check if this HttpInput instance has content stored internally, without fetching/parsing\n+     * anything from the underlying channel.\n+     * @return true if the input contains content, false otherwise.\n      */\n-    public boolean eof()\n-    {\n-        return addContent(EOF_CONTENT);\n-    }\n-\n-    public boolean consumeAll()\n-    {\n-        try (AutoLock l = _lock.lock())\n-        {\n-            try\n-            {\n-                while (true)\n-                {\n-                    Content item = nextContent();\n-                    if (item == null)\n-                        break; // Let's not bother blocking\n-\n-                    skip(item, item.remaining());\n-                }\n-                if (isFinished())\n-                    return !isError();\n-\n-                _state = EARLY_EOF;\n-                return false;\n-            }\n-            catch (Throwable e)\n-            {\n-                if (LOG.isDebugEnabled())\n-                    LOG.debug(\"Unable to consume all input\", e);\n-                _state = new ErrorState(e);\n-                return false;\n-            }\n-        }\n-    }\n-\n-    public boolean isError()\n-    {\n-        try (AutoLock l = _lock.lock())\n-        {\n-            return _state instanceof ErrorState;\n-        }\n-    }\n-\n-    public boolean isAsync()\n-    {\n-        try (AutoLock l = _lock.lock())\n-        {\n-            return _state == ASYNC;\n-        }\n-    }\n-\n-    @Override\n-    public boolean isFinished()\n-    {\n-        try (AutoLock l = _lock.lock())\n-        {\n-            return _state instanceof EOFState;\n-        }\n-    }\n-\n-    @Override\n-    public boolean isReady()\n+    public boolean hasContent()\n     {\n-        try\n-        {\n-            try (AutoLock l = _lock.lock())\n-            {\n-                if (_listener == null)\n-                    return true;\n-                if (_state instanceof EOFState)\n-                    return true;\n-                if (_waitingForContent)\n-                    return false;\n-                if (produceNextContext() != null)\n-                    return true;\n-                _channelState.onReadUnready();\n-                _waitingForContent = true;\n-            }\n-            return false;\n-        }\n-        catch (IOException e)\n-        {\n-            LOG.trace(\"IGNORED\", e);\n-            return true;\n-        }\n+        // Cannot call _contentProducer.available() (which calls HttpChannel.produceContent())\n+        // as this breaks WebSocketOverHTTP2Test.testSlowWebSocketUpgradeWithHTTP2DataFramesQueued.\n+        return _contentProducer.hasContent();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "273213e8df4f438bf853787ec932e22424e7fe8b"}, "originalPosition": 832}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTQxNTIwMg==", "bodyText": "Remove comment.", "url": "https://github.com/eclipse/jetty.project/pull/4556#discussion_r505415202", "createdAt": "2020-10-15T09:56:09Z", "author": {"login": "sbordet"}, "path": "jetty-server/src/main/java/org/eclipse/jetty/server/HttpInput.java", "diffHunk": "@@ -842,144 +268,122 @@ private boolean wakeup()\n     @Override\n     public void run()\n     {\n-        final ReadListener listener;\n-        Throwable error;\n-        boolean aeof = false;\n+        Content content = _contentProducer.nextContent();\n+        // The nextContent() call could return null if the transformer ate all\n+        // the raw bytes without producing any transformed content.\n+        if (content == null)\n+            return; // testAsyncEcho HTTP2 requires this", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "273213e8df4f438bf853787ec932e22424e7fe8b"}, "originalPosition": 958}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTQxNTcyNA==", "bodyText": "Another case of \"eof\" implies \"special\"?", "url": "https://github.com/eclipse/jetty.project/pull/4556#discussion_r505415724", "createdAt": "2020-10-15T09:56:53Z", "author": {"login": "sbordet"}, "path": "jetty-server/src/main/java/org/eclipse/jetty/server/HttpInput.java", "diffHunk": "@@ -842,144 +268,122 @@ private boolean wakeup()\n     @Override\n     public void run()\n     {\n-        final ReadListener listener;\n-        Throwable error;\n-        boolean aeof = false;\n+        Content content = _contentProducer.nextContent();\n+        // The nextContent() call could return null if the transformer ate all\n+        // the raw bytes without producing any transformed content.\n+        if (content == null)\n+            return; // testAsyncEcho HTTP2 requires this\n \n-        try (AutoLock l = _lock.lock())\n+        // required for AsyncRequestReadTest.testAsyncReadsWithDelays()\n+        if (_readListener == null)\n         {\n-            listener = _listener;\n-\n-            if (_state == EOF)\n-                return;\n-\n-            if (_state == AEOF)\n-            {\n-                _state = EOF;\n-                aeof = true;\n-            }\n-\n-            error = _state.getError();\n-\n-            if (!aeof && error == null)\n-            {\n-                Content content = nextInterceptedContent();\n-                if (content == null)\n-                    return;\n-\n-                // Consume a directly received EOF without first calling onDataAvailable\n-                // So -1 will never be read and only onAddDataRread or onError will be called\n-                if (content instanceof EofContent)\n-                {\n-                    consume(content);\n-                    if (_state == EARLY_EOF)\n-                        error = _state.getError();\n-                    else if (_state == AEOF)\n-                    {\n-                        aeof = true;\n-                        _state = EOF;\n-                    }\n-                }\n-            }\n+            wakeup();\n+            return;\n         }\n \n-        try\n+        if (content.isSpecial())\n         {\n+            Throwable error = content.getError();\n             if (error != null)\n             {\n                 // TODO is this necessary to add here?\n                 _channelState.getHttpChannel().getResponse().getHttpFields().add(HttpConnection.CONNECTION_CLOSE);\n-                listener.onError(error);\n-            }\n-            else if (aeof)\n-            {\n-                listener.onAllDataRead();\n+                _readListener.onError(error);\n             }\n-            else\n+            else if (content.isEof())", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "273213e8df4f438bf853787ec932e22424e7fe8b"}, "originalPosition": 1017}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTQxOTYxNw==", "bodyText": "Please make it public due to JPMS, JUnit, etc.", "url": "https://github.com/eclipse/jetty.project/pull/4556#discussion_r505419617", "createdAt": "2020-10-15T10:02:35Z", "author": {"login": "sbordet"}, "path": "jetty-server/src/test/java/org/eclipse/jetty/server/AsyncContentProducerTest.java", "diffHunk": "@@ -0,0 +1,339 @@\n+//\n+// ========================================================================\n+// Copyright (c) 1995-2020 Mort Bay Consulting Pty Ltd and others.\n+//\n+// This program and the accompanying materials are made available under\n+// the terms of the Eclipse Public License 2.0 which is available at\n+// https://www.eclipse.org/legal/epl-2.0\n+//\n+// This Source Code may also be made available under the following\n+// Secondary Licenses when the conditions for such availability set\n+// forth in the Eclipse Public License, v. 2.0 are satisfied:\n+// the Apache License v2.0 which is available at\n+// https://www.apache.org/licenses/LICENSE-2.0\n+//\n+// SPDX-License-Identifier: EPL-2.0 OR Apache-2.0\n+// ========================================================================\n+//\n+\n+package org.eclipse.jetty.server;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.nio.charset.StandardCharsets;\n+import java.util.concurrent.BrokenBarrierException;\n+import java.util.concurrent.CyclicBarrier;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import java.util.zip.GZIPOutputStream;\n+\n+import org.eclipse.jetty.io.ArrayByteBufferPool;\n+import org.eclipse.jetty.io.EofException;\n+import org.eclipse.jetty.server.handler.gzip.GzipHttpInputInterceptor;\n+import org.eclipse.jetty.util.compression.CompressionPool;\n+import org.eclipse.jetty.util.compression.InflaterPool;\n+import org.hamcrest.core.Is;\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.is;\n+import static org.hamcrest.Matchers.notNullValue;\n+import static org.hamcrest.Matchers.nullValue;\n+\n+public class AsyncContentProducerTest\n+{\n+    private ScheduledExecutorService scheduledExecutorService;\n+    private InflaterPool inflaterPool;\n+\n+    @BeforeEach\n+    void setUp()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "273213e8df4f438bf853787ec932e22424e7fe8b"}, "originalPosition": 54}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTQxOTY4Ng==", "bodyText": "Make it public.", "url": "https://github.com/eclipse/jetty.project/pull/4556#discussion_r505419686", "createdAt": "2020-10-15T10:02:45Z", "author": {"login": "sbordet"}, "path": "jetty-server/src/test/java/org/eclipse/jetty/server/AsyncContentProducerTest.java", "diffHunk": "@@ -0,0 +1,339 @@\n+//\n+// ========================================================================\n+// Copyright (c) 1995-2020 Mort Bay Consulting Pty Ltd and others.\n+//\n+// This program and the accompanying materials are made available under\n+// the terms of the Eclipse Public License 2.0 which is available at\n+// https://www.eclipse.org/legal/epl-2.0\n+//\n+// This Source Code may also be made available under the following\n+// Secondary Licenses when the conditions for such availability set\n+// forth in the Eclipse Public License, v. 2.0 are satisfied:\n+// the Apache License v2.0 which is available at\n+// https://www.apache.org/licenses/LICENSE-2.0\n+//\n+// SPDX-License-Identifier: EPL-2.0 OR Apache-2.0\n+// ========================================================================\n+//\n+\n+package org.eclipse.jetty.server;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.nio.charset.StandardCharsets;\n+import java.util.concurrent.BrokenBarrierException;\n+import java.util.concurrent.CyclicBarrier;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import java.util.zip.GZIPOutputStream;\n+\n+import org.eclipse.jetty.io.ArrayByteBufferPool;\n+import org.eclipse.jetty.io.EofException;\n+import org.eclipse.jetty.server.handler.gzip.GzipHttpInputInterceptor;\n+import org.eclipse.jetty.util.compression.CompressionPool;\n+import org.eclipse.jetty.util.compression.InflaterPool;\n+import org.hamcrest.core.Is;\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.is;\n+import static org.hamcrest.Matchers.notNullValue;\n+import static org.hamcrest.Matchers.nullValue;\n+\n+public class AsyncContentProducerTest\n+{\n+    private ScheduledExecutorService scheduledExecutorService;\n+    private InflaterPool inflaterPool;\n+\n+    @BeforeEach\n+    void setUp()\n+    {\n+        scheduledExecutorService = Executors.newSingleThreadScheduledExecutor();\n+        inflaterPool = new InflaterPool(CompressionPool.INFINITE_CAPACITY, true);\n+    }\n+\n+    @AfterEach\n+    void tearDown()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "273213e8df4f438bf853787ec932e22424e7fe8b"}, "originalPosition": 61}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTQyMTMwMg==", "bodyText": "Another case of \"eof\" implies \"special\"?", "url": "https://github.com/eclipse/jetty.project/pull/4556#discussion_r505421302", "createdAt": "2020-10-15T10:05:25Z", "author": {"login": "sbordet"}, "path": "jetty-server/src/test/java/org/eclipse/jetty/server/AsyncContentProducerTest.java", "diffHunk": "@@ -0,0 +1,339 @@\n+//\n+// ========================================================================\n+// Copyright (c) 1995-2020 Mort Bay Consulting Pty Ltd and others.\n+//\n+// This program and the accompanying materials are made available under\n+// the terms of the Eclipse Public License 2.0 which is available at\n+// https://www.eclipse.org/legal/epl-2.0\n+//\n+// This Source Code may also be made available under the following\n+// Secondary Licenses when the conditions for such availability set\n+// forth in the Eclipse Public License, v. 2.0 are satisfied:\n+// the Apache License v2.0 which is available at\n+// https://www.apache.org/licenses/LICENSE-2.0\n+//\n+// SPDX-License-Identifier: EPL-2.0 OR Apache-2.0\n+// ========================================================================\n+//\n+\n+package org.eclipse.jetty.server;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.nio.charset.StandardCharsets;\n+import java.util.concurrent.BrokenBarrierException;\n+import java.util.concurrent.CyclicBarrier;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import java.util.zip.GZIPOutputStream;\n+\n+import org.eclipse.jetty.io.ArrayByteBufferPool;\n+import org.eclipse.jetty.io.EofException;\n+import org.eclipse.jetty.server.handler.gzip.GzipHttpInputInterceptor;\n+import org.eclipse.jetty.util.compression.CompressionPool;\n+import org.eclipse.jetty.util.compression.InflaterPool;\n+import org.hamcrest.core.Is;\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.is;\n+import static org.hamcrest.Matchers.notNullValue;\n+import static org.hamcrest.Matchers.nullValue;\n+\n+public class AsyncContentProducerTest\n+{\n+    private ScheduledExecutorService scheduledExecutorService;\n+    private InflaterPool inflaterPool;\n+\n+    @BeforeEach\n+    void setUp()\n+    {\n+        scheduledExecutorService = Executors.newSingleThreadScheduledExecutor();\n+        inflaterPool = new InflaterPool(CompressionPool.INFINITE_CAPACITY, true);\n+    }\n+\n+    @AfterEach\n+    void tearDown()\n+    {\n+        scheduledExecutorService.shutdownNow();\n+    }\n+\n+    @Test\n+    public void testAsyncContentProducerNoInterceptor() throws Exception\n+    {\n+        ByteBuffer[] buffers = new ByteBuffer[3];\n+        buffers[0] = ByteBuffer.wrap(\"1 hello 1\".getBytes(StandardCharsets.ISO_8859_1));\n+        buffers[1] = ByteBuffer.wrap(\"2 howdy 2\".getBytes(StandardCharsets.ISO_8859_1));\n+        buffers[2] = ByteBuffer.wrap(\"3 hey ya 3\".getBytes(StandardCharsets.ISO_8859_1));\n+        final int totalContentBytesCount = countRemaining(buffers);\n+        final String originalContentString = asString(buffers);\n+\n+        CyclicBarrier barrier = new CyclicBarrier(2);\n+\n+        ContentProducer contentProducer = new AsyncContentProducer(new ArrayDelayedHttpChannel(buffers, new HttpInput.EofContent(), scheduledExecutorService, barrier));\n+\n+        Throwable error = readAndAssertContent(totalContentBytesCount, originalContentString, contentProducer, (buffers.length + 1) * 2, 0, 4, barrier);\n+        assertThat(error, nullValue());\n+    }\n+\n+    @Test\n+    public void testAsyncContentProducerNoInterceptorWithError() throws Exception\n+    {\n+        ByteBuffer[] buffers = new ByteBuffer[3];\n+        buffers[0] = ByteBuffer.wrap(\"1 hello 1\".getBytes(StandardCharsets.ISO_8859_1));\n+        buffers[1] = ByteBuffer.wrap(\"2 howdy 2\".getBytes(StandardCharsets.ISO_8859_1));\n+        buffers[2] = ByteBuffer.wrap(\"3 hey ya 3\".getBytes(StandardCharsets.ISO_8859_1));\n+        final int totalContentBytesCount = countRemaining(buffers);\n+        final String originalContentString = asString(buffers);\n+        final Throwable expectedError = new EofException(\"Early EOF\");\n+\n+        CyclicBarrier barrier = new CyclicBarrier(2);\n+\n+        ContentProducer contentProducer = new AsyncContentProducer(new ArrayDelayedHttpChannel(buffers, new HttpInput.ErrorContent(expectedError), scheduledExecutorService, barrier));\n+\n+        Throwable error = readAndAssertContent(totalContentBytesCount, originalContentString, contentProducer, (buffers.length + 1) * 2, 0, 4, barrier);\n+        assertThat(error, Is.is(expectedError));\n+    }\n+\n+    @Test\n+    public void testAsyncContentProducerGzipInterceptor() throws Exception\n+    {\n+        ByteBuffer[] uncompressedBuffers = new ByteBuffer[3];\n+        uncompressedBuffers[0] = ByteBuffer.wrap(\"1 hello 1\".getBytes(StandardCharsets.ISO_8859_1));\n+        uncompressedBuffers[1] = ByteBuffer.wrap(\"2 howdy 2\".getBytes(StandardCharsets.ISO_8859_1));\n+        uncompressedBuffers[2] = ByteBuffer.wrap(\"3 hey ya 3\".getBytes(StandardCharsets.ISO_8859_1));\n+        final int totalContentBytesCount = countRemaining(uncompressedBuffers);\n+        final String originalContentString = asString(uncompressedBuffers);\n+\n+        ByteBuffer[] buffers = new ByteBuffer[3];\n+        buffers[0] = gzipByteBuffer(uncompressedBuffers[0]);\n+        buffers[1] = gzipByteBuffer(uncompressedBuffers[1]);\n+        buffers[2] = gzipByteBuffer(uncompressedBuffers[2]);\n+\n+        CyclicBarrier barrier = new CyclicBarrier(2);\n+\n+        ContentProducer contentProducer = new AsyncContentProducer(new ArrayDelayedHttpChannel(buffers, new HttpInput.EofContent(), scheduledExecutorService, barrier));\n+        contentProducer.setInterceptor(new GzipHttpInputInterceptor(inflaterPool, new ArrayByteBufferPool(1, 1, 2), 32));\n+\n+        Throwable error = readAndAssertContent(totalContentBytesCount, originalContentString, contentProducer, (buffers.length + 1) * 2, 0, 4, barrier);\n+        assertThat(error, nullValue());\n+    }\n+\n+    @Test\n+    public void testAsyncContentProducerGzipInterceptorWithTinyBuffers() throws Exception\n+    {\n+        ByteBuffer[] uncompressedBuffers = new ByteBuffer[3];\n+        uncompressedBuffers[0] = ByteBuffer.wrap(\"1 hello 1\".getBytes(StandardCharsets.ISO_8859_1));\n+        uncompressedBuffers[1] = ByteBuffer.wrap(\"2 howdy 2\".getBytes(StandardCharsets.ISO_8859_1));\n+        uncompressedBuffers[2] = ByteBuffer.wrap(\"3 hey ya 3\".getBytes(StandardCharsets.ISO_8859_1));\n+        final int totalContentBytesCount = countRemaining(uncompressedBuffers);\n+        final String originalContentString = asString(uncompressedBuffers);\n+\n+        ByteBuffer[] buffers = new ByteBuffer[3];\n+        buffers[0] = gzipByteBuffer(uncompressedBuffers[0]);\n+        buffers[1] = gzipByteBuffer(uncompressedBuffers[1]);\n+        buffers[2] = gzipByteBuffer(uncompressedBuffers[2]);\n+\n+        CyclicBarrier barrier = new CyclicBarrier(2);\n+\n+        ContentProducer contentProducer = new AsyncContentProducer(new ArrayDelayedHttpChannel(buffers, new HttpInput.EofContent(), scheduledExecutorService, barrier));\n+        contentProducer.setInterceptor(new GzipHttpInputInterceptor(inflaterPool, new ArrayByteBufferPool(1, 1, 2), 1));\n+\n+        Throwable error = readAndAssertContent(totalContentBytesCount, originalContentString, contentProducer, totalContentBytesCount + buffers.length + 2, 25, 4, barrier);\n+        assertThat(error, nullValue());\n+    }\n+\n+    @Test\n+    public void testBlockingContentProducerGzipInterceptorWithError() throws Exception\n+    {\n+        ByteBuffer[] uncompressedBuffers = new ByteBuffer[3];\n+        uncompressedBuffers[0] = ByteBuffer.wrap(\"1 hello 1\".getBytes(StandardCharsets.ISO_8859_1));\n+        uncompressedBuffers[1] = ByteBuffer.wrap(\"2 howdy 2\".getBytes(StandardCharsets.ISO_8859_1));\n+        uncompressedBuffers[2] = ByteBuffer.wrap(\"3 hey ya 3\".getBytes(StandardCharsets.ISO_8859_1));\n+        final int totalContentBytesCount = countRemaining(uncompressedBuffers);\n+        final String originalContentString = asString(uncompressedBuffers);\n+        final Throwable expectedError = new Throwable(\"HttpInput idle timeout\");\n+\n+        ByteBuffer[] buffers = new ByteBuffer[3];\n+        buffers[0] = gzipByteBuffer(uncompressedBuffers[0]);\n+        buffers[1] = gzipByteBuffer(uncompressedBuffers[1]);\n+        buffers[2] = gzipByteBuffer(uncompressedBuffers[2]);\n+\n+        CyclicBarrier barrier = new CyclicBarrier(2);\n+\n+        ContentProducer contentProducer = new AsyncContentProducer(new ArrayDelayedHttpChannel(buffers, new HttpInput.ErrorContent(expectedError), scheduledExecutorService, barrier));\n+        contentProducer.setInterceptor(new GzipHttpInputInterceptor(inflaterPool, new ArrayByteBufferPool(1, 1, 2), 32));\n+\n+        Throwable error = readAndAssertContent(totalContentBytesCount, originalContentString, contentProducer, (buffers.length + 1) * 2, 0, 4, barrier);\n+        assertThat(error, Is.is(expectedError));\n+    }\n+\n+    private Throwable readAndAssertContent(int totalContentBytesCount, String originalContentString, ContentProducer contentProducer, int totalContentCount, int readyCount, int notReadyCount, CyclicBarrier barrier) throws InterruptedException, BrokenBarrierException, TimeoutException\n+    {\n+        int readBytes = 0;\n+        String consumedString = \"\";\n+        int nextContentCount = 0;\n+        int isReadyFalseCount = 0;\n+        int isReadyTrueCount = 0;\n+        Throwable error = null;\n+\n+        while (true)\n+        {\n+            if (contentProducer.isReady())\n+                isReadyTrueCount++;\n+            else\n+                isReadyFalseCount++;\n+\n+            HttpInput.Content content = contentProducer.nextContent();\n+            nextContentCount++;\n+            if (content == null)\n+            {\n+                barrier.await(5, TimeUnit.SECONDS);\n+                content = contentProducer.nextContent();\n+                nextContentCount++;\n+            }\n+            assertThat(content, notNullValue());\n+\n+            if (content.isSpecial())\n+            {\n+                if (content.isEof())", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "273213e8df4f438bf853787ec932e22424e7fe8b"}, "originalPosition": 204}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTQyMjQ2NQ==", "bodyText": "Make it public.", "url": "https://github.com/eclipse/jetty.project/pull/4556#discussion_r505422465", "createdAt": "2020-10-15T10:07:29Z", "author": {"login": "sbordet"}, "path": "jetty-server/src/test/java/org/eclipse/jetty/server/BlockingContentProducerTest.java", "diffHunk": "@@ -0,0 +1,320 @@\n+//\n+// ========================================================================\n+// Copyright (c) 1995-2020 Mort Bay Consulting Pty Ltd and others.\n+//\n+// This program and the accompanying materials are made available under\n+// the terms of the Eclipse Public License 2.0 which is available at\n+// https://www.eclipse.org/legal/epl-2.0\n+//\n+// This Source Code may also be made available under the following\n+// Secondary Licenses when the conditions for such availability set\n+// forth in the Eclipse Public License, v. 2.0 are satisfied:\n+// the Apache License v2.0 which is available at\n+// https://www.apache.org/licenses/LICENSE-2.0\n+//\n+// SPDX-License-Identifier: EPL-2.0 OR Apache-2.0\n+// ========================================================================\n+//\n+\n+package org.eclipse.jetty.server;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.nio.charset.StandardCharsets;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.zip.GZIPOutputStream;\n+\n+import org.eclipse.jetty.io.ArrayByteBufferPool;\n+import org.eclipse.jetty.io.EofException;\n+import org.eclipse.jetty.server.handler.gzip.GzipHttpInputInterceptor;\n+import org.eclipse.jetty.util.compression.CompressionPool;\n+import org.eclipse.jetty.util.compression.InflaterPool;\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.nullValue;\n+import static org.hamcrest.core.Is.is;\n+\n+public class BlockingContentProducerTest\n+{\n+    private ScheduledExecutorService scheduledExecutorService;\n+    private InflaterPool inflaterPool;\n+\n+    @BeforeEach\n+    void setUp()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "273213e8df4f438bf853787ec932e22424e7fe8b"}, "originalPosition": 50}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTQyMjU4MA==", "bodyText": "Make it public.", "url": "https://github.com/eclipse/jetty.project/pull/4556#discussion_r505422580", "createdAt": "2020-10-15T10:07:41Z", "author": {"login": "sbordet"}, "path": "jetty-server/src/test/java/org/eclipse/jetty/server/BlockingContentProducerTest.java", "diffHunk": "@@ -0,0 +1,320 @@\n+//\n+// ========================================================================\n+// Copyright (c) 1995-2020 Mort Bay Consulting Pty Ltd and others.\n+//\n+// This program and the accompanying materials are made available under\n+// the terms of the Eclipse Public License 2.0 which is available at\n+// https://www.eclipse.org/legal/epl-2.0\n+//\n+// This Source Code may also be made available under the following\n+// Secondary Licenses when the conditions for such availability set\n+// forth in the Eclipse Public License, v. 2.0 are satisfied:\n+// the Apache License v2.0 which is available at\n+// https://www.apache.org/licenses/LICENSE-2.0\n+//\n+// SPDX-License-Identifier: EPL-2.0 OR Apache-2.0\n+// ========================================================================\n+//\n+\n+package org.eclipse.jetty.server;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.nio.charset.StandardCharsets;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.zip.GZIPOutputStream;\n+\n+import org.eclipse.jetty.io.ArrayByteBufferPool;\n+import org.eclipse.jetty.io.EofException;\n+import org.eclipse.jetty.server.handler.gzip.GzipHttpInputInterceptor;\n+import org.eclipse.jetty.util.compression.CompressionPool;\n+import org.eclipse.jetty.util.compression.InflaterPool;\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.nullValue;\n+import static org.hamcrest.core.Is.is;\n+\n+public class BlockingContentProducerTest\n+{\n+    private ScheduledExecutorService scheduledExecutorService;\n+    private InflaterPool inflaterPool;\n+\n+    @BeforeEach\n+    void setUp()\n+    {\n+        scheduledExecutorService = Executors.newSingleThreadScheduledExecutor();\n+        inflaterPool = new InflaterPool(CompressionPool.INFINITE_CAPACITY, true);\n+    }\n+\n+    @AfterEach\n+    void tearDown()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "273213e8df4f438bf853787ec932e22424e7fe8b"}, "originalPosition": 57}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTQyMjgzNA==", "bodyText": "\"eof\" implies \"special\"?", "url": "https://github.com/eclipse/jetty.project/pull/4556#discussion_r505422834", "createdAt": "2020-10-15T10:08:09Z", "author": {"login": "sbordet"}, "path": "jetty-server/src/test/java/org/eclipse/jetty/server/BlockingContentProducerTest.java", "diffHunk": "@@ -0,0 +1,320 @@\n+//\n+// ========================================================================\n+// Copyright (c) 1995-2020 Mort Bay Consulting Pty Ltd and others.\n+//\n+// This program and the accompanying materials are made available under\n+// the terms of the Eclipse Public License 2.0 which is available at\n+// https://www.eclipse.org/legal/epl-2.0\n+//\n+// This Source Code may also be made available under the following\n+// Secondary Licenses when the conditions for such availability set\n+// forth in the Eclipse Public License, v. 2.0 are satisfied:\n+// the Apache License v2.0 which is available at\n+// https://www.apache.org/licenses/LICENSE-2.0\n+//\n+// SPDX-License-Identifier: EPL-2.0 OR Apache-2.0\n+// ========================================================================\n+//\n+\n+package org.eclipse.jetty.server;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.nio.charset.StandardCharsets;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.zip.GZIPOutputStream;\n+\n+import org.eclipse.jetty.io.ArrayByteBufferPool;\n+import org.eclipse.jetty.io.EofException;\n+import org.eclipse.jetty.server.handler.gzip.GzipHttpInputInterceptor;\n+import org.eclipse.jetty.util.compression.CompressionPool;\n+import org.eclipse.jetty.util.compression.InflaterPool;\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.nullValue;\n+import static org.hamcrest.core.Is.is;\n+\n+public class BlockingContentProducerTest\n+{\n+    private ScheduledExecutorService scheduledExecutorService;\n+    private InflaterPool inflaterPool;\n+\n+    @BeforeEach\n+    void setUp()\n+    {\n+        scheduledExecutorService = Executors.newSingleThreadScheduledExecutor();\n+        inflaterPool = new InflaterPool(CompressionPool.INFINITE_CAPACITY, true);\n+    }\n+\n+    @AfterEach\n+    void tearDown()\n+    {\n+        scheduledExecutorService.shutdownNow();\n+    }\n+\n+    @Test\n+    public void testBlockingContentProducerNoInterceptor()\n+    {\n+        ByteBuffer[] buffers = new ByteBuffer[3];\n+        buffers[0] = ByteBuffer.wrap(\"1 hello 1\".getBytes(StandardCharsets.ISO_8859_1));\n+        buffers[1] = ByteBuffer.wrap(\"2 howdy 2\".getBytes(StandardCharsets.ISO_8859_1));\n+        buffers[2] = ByteBuffer.wrap(\"3 hey ya 3\".getBytes(StandardCharsets.ISO_8859_1));\n+        final int totalContentBytesCount = countRemaining(buffers);\n+        final String originalContentString = asString(buffers);\n+\n+        AtomicReference<ContentProducer> ref = new AtomicReference<>();\n+        ArrayDelayedHttpChannel httpChannel = new ArrayDelayedHttpChannel(buffers, new HttpInput.EofContent(), scheduledExecutorService, () -> ref.get().wakeup());\n+        ContentProducer contentProducer = new BlockingContentProducer(httpChannel, new AsyncContentProducer(httpChannel));\n+        ref.set(contentProducer);\n+\n+        Throwable error = readAndAssertContent(totalContentBytesCount, originalContentString, buffers.length + 1, contentProducer);\n+        assertThat(error, nullValue());\n+    }\n+\n+    @Test\n+    public void testBlockingContentProducerNoInterceptorWithError()\n+    {\n+        ByteBuffer[] buffers = new ByteBuffer[3];\n+        buffers[0] = ByteBuffer.wrap(\"1 hello 1\".getBytes(StandardCharsets.ISO_8859_1));\n+        buffers[1] = ByteBuffer.wrap(\"2 howdy 2\".getBytes(StandardCharsets.ISO_8859_1));\n+        buffers[2] = ByteBuffer.wrap(\"3 hey ya 3\".getBytes(StandardCharsets.ISO_8859_1));\n+        final int totalContentBytesCount = countRemaining(buffers);\n+        final String originalContentString = asString(buffers);\n+        final Throwable expectedError = new EofException(\"Early EOF\");\n+\n+        AtomicReference<ContentProducer> ref = new AtomicReference<>();\n+        ArrayDelayedHttpChannel httpChannel = new ArrayDelayedHttpChannel(buffers, new HttpInput.ErrorContent(expectedError), scheduledExecutorService, () -> ref.get().wakeup());\n+        ContentProducer contentProducer = new BlockingContentProducer(httpChannel, new AsyncContentProducer(httpChannel));\n+        ref.set(contentProducer);\n+\n+        Throwable error = readAndAssertContent(totalContentBytesCount, originalContentString, buffers.length + 1, contentProducer);\n+        assertThat(error, is(expectedError));\n+    }\n+\n+    @Test\n+    public void testBlockingContentProducerGzipInterceptor()\n+    {\n+        ByteBuffer[] uncompressedBuffers = new ByteBuffer[3];\n+        uncompressedBuffers[0] = ByteBuffer.wrap(\"1 hello 1\".getBytes(StandardCharsets.ISO_8859_1));\n+        uncompressedBuffers[1] = ByteBuffer.wrap(\"2 howdy 2\".getBytes(StandardCharsets.ISO_8859_1));\n+        uncompressedBuffers[2] = ByteBuffer.wrap(\"3 hey ya 3\".getBytes(StandardCharsets.ISO_8859_1));\n+        final int totalContentBytesCount = countRemaining(uncompressedBuffers);\n+        final String originalContentString = asString(uncompressedBuffers);\n+\n+        ByteBuffer[] buffers = new ByteBuffer[3];\n+        buffers[0] = gzipByteBuffer(uncompressedBuffers[0]);\n+        buffers[1] = gzipByteBuffer(uncompressedBuffers[1]);\n+        buffers[2] = gzipByteBuffer(uncompressedBuffers[2]);\n+\n+        AtomicReference<ContentProducer> ref = new AtomicReference<>();\n+        ArrayDelayedHttpChannel httpChannel = new ArrayDelayedHttpChannel(buffers, new HttpInput.EofContent(), scheduledExecutorService, () -> ref.get().wakeup());\n+        ContentProducer contentProducer = new BlockingContentProducer(httpChannel, new AsyncContentProducer(httpChannel));\n+        ref.set(contentProducer);\n+        contentProducer.setInterceptor(new GzipHttpInputInterceptor(inflaterPool, new ArrayByteBufferPool(1, 1, 2), 32));\n+\n+        Throwable error = readAndAssertContent(totalContentBytesCount, originalContentString, buffers.length + 1, contentProducer);\n+        assertThat(error, nullValue());\n+    }\n+\n+    @Test\n+    public void testBlockingContentProducerGzipInterceptorWithTinyBuffers()\n+    {\n+        ByteBuffer[] uncompressedBuffers = new ByteBuffer[3];\n+        uncompressedBuffers[0] = ByteBuffer.wrap(\"1 hello 1\".getBytes(StandardCharsets.ISO_8859_1));\n+        uncompressedBuffers[1] = ByteBuffer.wrap(\"2 howdy 2\".getBytes(StandardCharsets.ISO_8859_1));\n+        uncompressedBuffers[2] = ByteBuffer.wrap(\"3 hey ya 3\".getBytes(StandardCharsets.ISO_8859_1));\n+        final int totalContentBytesCount = countRemaining(uncompressedBuffers);\n+        final String originalContentString = asString(uncompressedBuffers);\n+\n+        ByteBuffer[] buffers = new ByteBuffer[3];\n+        buffers[0] = gzipByteBuffer(uncompressedBuffers[0]);\n+        buffers[1] = gzipByteBuffer(uncompressedBuffers[1]);\n+        buffers[2] = gzipByteBuffer(uncompressedBuffers[2]);\n+\n+        AtomicReference<ContentProducer> ref = new AtomicReference<>();\n+        ArrayDelayedHttpChannel httpChannel = new ArrayDelayedHttpChannel(buffers, new HttpInput.EofContent(), scheduledExecutorService, () -> ref.get().wakeup());\n+        ContentProducer contentProducer = new BlockingContentProducer(httpChannel, new AsyncContentProducer(httpChannel));\n+        ref.set(contentProducer);\n+        contentProducer.setInterceptor(new GzipHttpInputInterceptor(inflaterPool, new ArrayByteBufferPool(1, 1, 2), 1));\n+\n+        Throwable error = readAndAssertContent(totalContentBytesCount, originalContentString, totalContentBytesCount + 1, contentProducer);\n+        assertThat(error, nullValue());\n+    }\n+\n+    @Test\n+    public void testBlockingContentProducerGzipInterceptorWithError()\n+    {\n+        ByteBuffer[] uncompressedBuffers = new ByteBuffer[3];\n+        uncompressedBuffers[0] = ByteBuffer.wrap(\"1 hello 1\".getBytes(StandardCharsets.ISO_8859_1));\n+        uncompressedBuffers[1] = ByteBuffer.wrap(\"2 howdy 2\".getBytes(StandardCharsets.ISO_8859_1));\n+        uncompressedBuffers[2] = ByteBuffer.wrap(\"3 hey ya 3\".getBytes(StandardCharsets.ISO_8859_1));\n+        final int totalContentBytesCount = countRemaining(uncompressedBuffers);\n+        final String originalContentString = asString(uncompressedBuffers);\n+        final Throwable expectedError = new Throwable(\"HttpInput idle timeout\");\n+\n+        ByteBuffer[] buffers = new ByteBuffer[3];\n+        buffers[0] = gzipByteBuffer(uncompressedBuffers[0]);\n+        buffers[1] = gzipByteBuffer(uncompressedBuffers[1]);\n+        buffers[2] = gzipByteBuffer(uncompressedBuffers[2]);\n+\n+        AtomicReference<ContentProducer> ref = new AtomicReference<>();\n+        ArrayDelayedHttpChannel httpChannel = new ArrayDelayedHttpChannel(buffers, new HttpInput.ErrorContent(expectedError), scheduledExecutorService, () -> ref.get().wakeup());\n+        ContentProducer contentProducer = new BlockingContentProducer(httpChannel, new AsyncContentProducer(httpChannel));\n+        ref.set(contentProducer);\n+        contentProducer.setInterceptor(new GzipHttpInputInterceptor(inflaterPool, new ArrayByteBufferPool(1, 1, 2), 32));\n+\n+        Throwable error = readAndAssertContent(totalContentBytesCount, originalContentString, buffers.length + 1, contentProducer);\n+        assertThat(error, is(expectedError));\n+    }\n+\n+    private Throwable readAndAssertContent(int totalContentBytesCount, String originalContentString, int totalContentCount, ContentProducer contentProducer)\n+    {\n+        int readBytes = 0;\n+        int nextContentCount = 0;\n+        String consumedString = \"\";\n+        Throwable error = null;\n+        while (true)\n+        {\n+            HttpInput.Content content = contentProducer.nextContent();\n+            nextContentCount++;\n+\n+            if (content.isSpecial())\n+            {\n+                if (content.isEof())", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "273213e8df4f438bf853787ec932e22424e7fe8b"}, "originalPosition": 190}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTQyNTUyMA==", "bodyText": "Use a for loop for this?", "url": "https://github.com/eclipse/jetty.project/pull/4556#discussion_r505425520", "createdAt": "2020-10-15T10:12:55Z", "author": {"login": "sbordet"}, "path": "tests/test-http-client-transport/src/test/java/org/eclipse/jetty/http/client/AsyncIOServletTest.java", "diffHunk": "@@ -1345,6 +1358,324 @@ public void onComplete(Result result)\n         assertTrue(clientLatch.await(10, TimeUnit.SECONDS));\n     }\n \n+    @ParameterizedTest\n+    @ArgumentsSource(TransportProvider.class)\n+    public void testAsyncEcho(Transport transport) throws Exception\n+    {\n+        init(transport);\n+        scenario.start(new HttpServlet()\n+        {\n+            @Override\n+            protected void service(HttpServletRequest request, HttpServletResponse response) throws IOException\n+            {\n+                System.err.println(\"Service \" + request);\n+\n+                AsyncContext asyncContext = request.startAsync();\n+                ServletInputStream input = request.getInputStream();\n+                input.setReadListener(new ReadListener()\n+                {\n+                    @Override\n+                    public void onDataAvailable() throws IOException\n+                    {\n+                        while (input.isReady())\n+                        {\n+                            int b = input.read();\n+                            if (b >= 0)\n+                            {\n+                                // System.err.printf(\"0x%2x %s %n\", b, Character.isISOControl(b)?\"?\":(\"\"+(char)b));\n+                                response.getOutputStream().write(b);\n+                            }\n+                            else\n+                                return;\n+                        }\n+                    }\n+\n+                    @Override\n+                    public void onAllDataRead() throws IOException\n+                    {\n+                        asyncContext.complete();\n+                    }\n+\n+                    @Override\n+                    public void onError(Throwable x)\n+                    {\n+                    }\n+                });\n+            }\n+        });\n+\n+        AsyncRequestContent contentProvider = new AsyncRequestContent();\n+        CountDownLatch clientLatch = new CountDownLatch(1);\n+\n+        AtomicReference<Result> resultRef = new AtomicReference<>();\n+        scenario.client.newRequest(scenario.newURI())\n+            .method(HttpMethod.POST)\n+            .path(scenario.servletPath)\n+            .body(contentProvider)\n+            .send(new BufferingResponseListener(16 * 1024 * 1024)\n+            {\n+                @Override\n+                public void onComplete(Result result)\n+                {\n+                    resultRef.set(result);\n+                    clientLatch.countDown();\n+                }\n+            });\n+\n+        for (int i = 0; i < 1_000_000; i++)\n+        {\n+            contentProvider.offer(BufferUtil.toBuffer(\"S\" + i));\n+        }\n+        contentProvider.close();\n+\n+        assertTrue(clientLatch.await(30, TimeUnit.SECONDS));\n+        assertThat(resultRef.get().isSucceeded(), Matchers.is(true));\n+        assertThat(resultRef.get().getResponse().getStatus(), Matchers.equalTo(HttpStatus.OK_200));\n+    }\n+\n+    @ParameterizedTest\n+    @ArgumentsSource(TransportProvider.class)\n+    public void testAsyncInterceptedTwice(Transport transport) throws Exception\n+    {\n+        init(transport);\n+        scenario.start(new HttpServlet()\n+        {\n+            @Override\n+            protected void service(HttpServletRequest request, HttpServletResponse response) throws IOException\n+            {\n+                System.err.println(\"Service \" + request);\n+\n+                final HttpInput httpInput = ((Request)request).getHttpInput();\n+                httpInput.addInterceptor(new GzipHttpInputInterceptor(new InflaterPool(CompressionPool.INFINITE_CAPACITY, true), ((Request)request).getHttpChannel().getByteBufferPool(), 1024));\n+                httpInput.addInterceptor(content ->\n+                {\n+                    ByteBuffer byteBuffer = content.getByteBuffer();\n+                    byte[] bytes = new byte[2];\n+                    bytes[1] = byteBuffer.get();\n+                    bytes[0] = byteBuffer.get();\n+                    return new Content(wrap(bytes));\n+                });\n+\n+                AsyncContext asyncContext = request.startAsync();\n+                ServletInputStream input = request.getInputStream();\n+                ByteArrayOutputStream out = new ByteArrayOutputStream();\n+\n+                input.setReadListener(new ReadListener()\n+                {\n+                    @Override\n+                    public void onDataAvailable() throws IOException\n+                    {\n+                        while (input.isReady())\n+                        {\n+                            int b = input.read();\n+                            if (b > 0)\n+                            {\n+                                // System.err.printf(\"0x%2x %s %n\", b, Character.isISOControl(b)?\"?\":(\"\"+(char)b));\n+                                out.write(b);\n+                            }\n+                            else if (b < 0)\n+                                return;\n+                        }\n+                    }\n+\n+                    @Override\n+                    public void onAllDataRead() throws IOException\n+                    {\n+                        response.getOutputStream().write(out.toByteArray());\n+                        asyncContext.complete();\n+                    }\n+\n+                    @Override\n+                    public void onError(Throwable x)\n+                    {\n+                    }\n+                });\n+            }\n+        });\n+\n+        AsyncRequestContent contentProvider = new AsyncRequestContent();\n+        CountDownLatch clientLatch = new CountDownLatch(1);\n+\n+        String expected =\n+                \"0S\" +\n+                \"1S\" +\n+                \"2S\" +\n+                \"3S\" +\n+                \"4S\" +\n+                \"5S\" +\n+                \"6S\";\n+\n+        scenario.client.newRequest(scenario.newURI())\n+            .method(HttpMethod.POST)\n+            .path(scenario.servletPath)\n+            .body(contentProvider)\n+            .send(new BufferingResponseListener()\n+            {\n+                @Override\n+                public void onComplete(Result result)\n+                {\n+                    if (result.isSucceeded())\n+                    {\n+                        Response response = result.getResponse();\n+                        assertThat(response.getStatus(), Matchers.equalTo(HttpStatus.OK_200));\n+                        assertThat(getContentAsString(), Matchers.equalTo(expected));\n+                        clientLatch.countDown();\n+                    }\n+                }\n+            });\n+\n+        contentProvider.offer(gzipToBuffer(\"S0\"));\n+        contentProvider.flush();\n+        contentProvider.offer(gzipToBuffer(\"S1\"));\n+        contentProvider.flush();\n+        contentProvider.offer(gzipToBuffer(\"S2\"));\n+        contentProvider.flush();\n+        contentProvider.offer(gzipToBuffer(\"S3\"));\n+        contentProvider.flush();\n+        contentProvider.offer(gzipToBuffer(\"S4\"));\n+        contentProvider.flush();\n+        contentProvider.offer(gzipToBuffer(\"S5\"));\n+        contentProvider.flush();\n+        contentProvider.offer(gzipToBuffer(\"S6\"));\n+        contentProvider.close();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "273213e8df4f438bf853787ec932e22424e7fe8b"}, "originalPosition": 263}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTQyNjEzNQ==", "bodyText": "Why was this removed?", "url": "https://github.com/eclipse/jetty.project/pull/4556#discussion_r505426135", "createdAt": "2020-10-15T10:14:04Z", "author": {"login": "sbordet"}, "path": "tests/test-http-client-transport/src/test/java/org/eclipse/jetty/http/client/TransportScenario.java", "diffHunk": "@@ -328,8 +326,6 @@ public void startServer(Handler handler) throws Exception\n         serverThreads.setName(\"server\");\n         serverThreads.setDetailedDump(true);\n         server = new Server(serverThreads);\n-        MBeanContainer mbeanContainer = new MBeanContainer(ManagementFactory.getPlatformMBeanServer());\n-        server.addBean(mbeanContainer);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "273213e8df4f438bf853787ec932e22424e7fe8b"}, "originalPosition": 21}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "601d4dba4d94fc021c62e008124a3339d7af894f", "author": {"user": {"login": "lorban", "name": "Ludovic Orban"}}, "url": "https://github.com/eclipse/jetty.project/commit/601d4dba4d94fc021c62e008124a3339d7af894f", "committedDate": "2020-10-16T08:06:04Z", "message": "fix FCGI content queuing\n\nSigned-off-by: Ludovic Orban <lorban@bitronix.be>"}, "afterCommit": {"oid": "e213bac2c8015b200c69e6ed0a6fc42a937e0250", "author": {"user": {"login": "lorban", "name": "Ludovic Orban"}}, "url": "https://github.com/eclipse/jetty.project/commit/e213bac2c8015b200c69e6ed0a6fc42a937e0250", "committedDate": "2020-10-16T08:59:10Z", "message": "fix compilation after rebase\n\nSigned-off-by: Ludovic Orban <lorban@bitronix.be>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "3701b8abb99fb32ccc3227202117f9fff7f2c158", "author": {"user": {"login": "lorban", "name": "Ludovic Orban"}}, "url": "https://github.com/eclipse/jetty.project/commit/3701b8abb99fb32ccc3227202117f9fff7f2c158", "committedDate": "2020-10-16T10:09:09Z", "message": "fix compilation after rebase\n\nSigned-off-by: Ludovic Orban <lorban@bitronix.be>"}, "afterCommit": {"oid": "95a93cb0173e9a42780c07f2d45a5b0f0c00b48b", "author": {"user": {"login": "lorban", "name": "Ludovic Orban"}}, "url": "https://github.com/eclipse/jetty.project/commit/95a93cb0173e9a42780c07f2d45a5b0f0c00b48b", "committedDate": "2020-10-19T08:42:31Z", "message": "fix compilation after rebase\n\nSigned-off-by: Ludovic Orban <lorban@bitronix.be>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "bc6756fd03b63ea590e4d2e1df810e7d0ef80dc7", "author": {"user": {"login": "lorban", "name": "Ludovic Orban"}}, "url": "https://github.com/eclipse/jetty.project/commit/bc6756fd03b63ea590e4d2e1df810e7d0ef80dc7", "committedDate": "2020-10-19T11:50:46Z", "message": "fix test\n\nSigned-off-by: Ludovic Orban <lorban@bitronix.be>"}, "afterCommit": {"oid": "5fe974883042120c758255d82d5a33044c7fe979", "author": {"user": {"login": "lorban", "name": "Ludovic Orban"}}, "url": "https://github.com/eclipse/jetty.project/commit/5fe974883042120c758255d82d5a33044c7fe979", "committedDate": "2020-10-19T13:39:24Z", "message": "only wakeup when needContent demanded\n\nSigned-off-by: Ludovic Orban <lorban@bitronix.be>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "5fe974883042120c758255d82d5a33044c7fe979", "author": {"user": {"login": "lorban", "name": "Ludovic Orban"}}, "url": "https://github.com/eclipse/jetty.project/commit/5fe974883042120c758255d82d5a33044c7fe979", "committedDate": "2020-10-19T13:39:24Z", "message": "only wakeup when needContent demanded\n\nSigned-off-by: Ludovic Orban <lorban@bitronix.be>"}, "afterCommit": {"oid": "0065312d38203e75e3c06386cc8bfb2f3eb56b6f", "author": {"user": {"login": "lorban", "name": "Ludovic Orban"}}, "url": "https://github.com/eclipse/jetty.project/commit/0065312d38203e75e3c06386cc8bfb2f3eb56b6f", "committedDate": "2020-10-19T14:11:08Z", "message": "only wakeup when needContent demanded\n\nSigned-off-by: Ludovic Orban <lorban@bitronix.be>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "0065312d38203e75e3c06386cc8bfb2f3eb56b6f", "author": {"user": {"login": "lorban", "name": "Ludovic Orban"}}, "url": "https://github.com/eclipse/jetty.project/commit/0065312d38203e75e3c06386cc8bfb2f3eb56b6f", "committedDate": "2020-10-19T14:11:08Z", "message": "only wakeup when needContent demanded\n\nSigned-off-by: Ludovic Orban <lorban@bitronix.be>"}, "afterCommit": {"oid": "ae16653550c4db993b10659606b1553a11796cb2", "author": {"user": {"login": "lorban", "name": "Ludovic Orban"}}, "url": "https://github.com/eclipse/jetty.project/commit/ae16653550c4db993b10659606b1553a11796cb2", "committedDate": "2020-10-19T15:01:50Z", "message": "only wakeup when needContent demanded\n\nSigned-off-by: Ludovic Orban <lorban@bitronix.be>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "adad99e8cb9418e4294a04a15416b2469d235662", "author": {"user": {"login": "lorban", "name": "Ludovic Orban"}}, "url": "https://github.com/eclipse/jetty.project/commit/adad99e8cb9418e4294a04a15416b2469d235662", "committedDate": "2020-10-20T09:15:30Z", "message": "do not reschedule when AsyncReadCallback succeeds\n\nSigned-off-by: Ludovic Orban <lorban@bitronix.be>"}, "afterCommit": {"oid": "e616a89edfb6c02bf7c737af35060c03035f8143", "author": {"user": {"login": "lorban", "name": "Ludovic Orban"}}, "url": "https://github.com/eclipse/jetty.project/commit/e616a89edfb6c02bf7c737af35060c03035f8143", "committedDate": "2020-10-20T11:32:00Z", "message": "cleanup comment\n\nSigned-off-by: Ludovic Orban <lorban@bitronix.be>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "526fe2887f4a043bfe8de6d172a94a28cdf0d299", "author": {"user": {"login": "lorban", "name": "Ludovic Orban"}}, "url": "https://github.com/eclipse/jetty.project/commit/526fe2887f4a043bfe8de6d172a94a28cdf0d299", "committedDate": "2020-10-21T11:13:18Z", "message": "make HttpChannel.failAllContent return a boolean to indicate if EOF was reached\n\nSigned-off-by: Ludovic Orban <lorban@bitronix.be>"}, "afterCommit": {"oid": "2ddddd9deb240f7edb120d5aae29efe6cd8dd2d2", "author": {"user": {"login": "lorban", "name": "Ludovic Orban"}}, "url": "https://github.com/eclipse/jetty.project/commit/2ddddd9deb240f7edb120d5aae29efe6cd8dd2d2", "committedDate": "2020-10-21T12:22:07Z", "message": "cleanup\n\nSigned-off-by: Ludovic Orban <lorban@bitronix.be>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "6de872263993f12cf2f53536b3a609bff28142b6", "author": {"user": {"login": "lorban", "name": "Ludovic Orban"}}, "url": "https://github.com/eclipse/jetty.project/commit/6de872263993f12cf2f53536b3a609bff28142b6", "committedDate": "2020-10-23T10:13:02Z", "message": "restore reset check\n\nSigned-off-by: Ludovic Orban <lorban@bitronix.be>"}, "afterCommit": {"oid": "98d831b85c23aa760744582a85e061bc99032af8", "author": {"user": {"login": "lorban", "name": "Ludovic Orban"}}, "url": "https://github.com/eclipse/jetty.project/commit/98d831b85c23aa760744582a85e061bc99032af8", "committedDate": "2020-10-26T13:39:55Z", "message": "content javadoc\n\nSigned-off-by: Ludovic Orban <lorban@bitronix.be>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTE2OTUxNjY1", "url": "https://github.com/eclipse/jetty.project/pull/4556#pullrequestreview-516951665", "createdAt": "2020-10-26T16:22:36Z", "commit": {"oid": "98d831b85c23aa760744582a85e061bc99032af8"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNlQxNjoyMjozN1rOHoXmrg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNlQxNjoyMjozN1rOHoXmrg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjA5MTgyMg==", "bodyText": "Create 2 static final DemandingContents and pick between them rather than creating new ones all the time", "url": "https://github.com/eclipse/jetty.project/pull/4556#discussion_r512091822", "createdAt": "2020-10-26T16:22:37Z", "author": {"login": "gregw"}, "path": "jetty-http2/http2-server/src/main/java/org/eclipse/jetty/http2/server/HttpChannelOverHTTP2.java", "diffHunk": "@@ -261,31 +275,277 @@ public InvocationType getInvocationType()\n             {\n                 return callback.getInvocationType();\n             }\n-        });\n+        };\n+        boolean wakeup = _contentDemander.onContent(content);\n+        boolean handle = onContent(content);\n \n         boolean endStream = frame.isEndStream();\n         if (endStream)\n         {\n             boolean handleContent = onContentComplete();\n+            // this will generate EOF -> must happen before onContentProducible\n             boolean handleRequest = onRequestComplete();\n             handle |= handleContent | handleRequest;\n         }\n \n+        boolean woken = wakeup && getRequest().getHttpInput().onContentProducible();\n         if (LOG.isDebugEnabled())\n         {\n-            LOG.debug(\"HTTP2 Request #{}/{}: {} bytes of {} content, handle: {}\",\n+            LOG.debug(\"HTTP2 Request #{}/{}: {} bytes of {} content, woken: {}, handle: {}\",\n                     stream.getId(),\n                     Integer.toHexString(stream.getSession().hashCode()),\n                     length,\n                     endStream ? \"last\" : \"some\",\n+                    woken,\n                     handle);\n         }\n+        handle |= woken;\n \n         boolean wasDelayed = _delayedUntilContent;\n         _delayedUntilContent = false;\n         return handle || wasDelayed ? this : null;\n     }\n \n+    private static final HttpInput.Content EOF = new HttpInput.EofContent();\n+\n+    private static final class DemandingContent extends HttpInput.SpecialContent\n+    {\n+        private final boolean wakeup;\n+\n+        public DemandingContent(boolean wakeup)\n+        {\n+            this.wakeup = wakeup;\n+        }\n+    }\n+\n+    private class ContentDemander\n+    {\n+        private final AtomicReference<HttpInput.Content> _content = new AtomicReference<>();\n+\n+        public void recycle()\n+        {\n+            HttpInput.Content c = _content.getAndSet(null);\n+            if (c != null && !c.isSpecial())\n+                throw new AssertionError(\"unconsumed content: \" + c);\n+        }\n+\n+        public HttpInput.Content poll()\n+        {\n+            while (true)\n+            {\n+                HttpInput.Content c = _content.get();\n+                if (c == null || c.isSpecial() || _content.compareAndSet(c, c.isEof() ? EOF : null))\n+                    return c;\n+            }\n+        }\n+\n+        public boolean demand(boolean wakeup)\n+        {\n+            while (true)\n+            {\n+                HttpInput.Content c = _content.get();\n+                if (c instanceof DemandingContent)\n+                {\n+                    if (wakeup && !((DemandingContent)c).wakeup)\n+                    {\n+                        if (!_content.compareAndSet(c, new DemandingContent(true)))\n+                            continue;\n+                    }\n+                    return false;\n+                }\n+                if (c != null)\n+                    return true;\n+                if (_content.compareAndSet(null, new DemandingContent(wakeup)))", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "98d831b85c23aa760744582a85e061bc99032af8"}, "originalPosition": 165}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTE2OTUyNjgz", "url": "https://github.com/eclipse/jetty.project/pull/4556#pullrequestreview-516952683", "createdAt": "2020-10-26T16:23:43Z", "commit": {"oid": "98d831b85c23aa760744582a85e061bc99032af8"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNlQxNjoyMzo0M1rOHoXppA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNlQxNjoyMzo0M1rOHoXppA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjA5MjU4MA==", "bodyText": "rename wakeup  to needed", "url": "https://github.com/eclipse/jetty.project/pull/4556#discussion_r512092580", "createdAt": "2020-10-26T16:23:43Z", "author": {"login": "gregw"}, "path": "jetty-http2/http2-server/src/main/java/org/eclipse/jetty/http2/server/HttpChannelOverHTTP2.java", "diffHunk": "@@ -261,31 +275,277 @@ public InvocationType getInvocationType()\n             {\n                 return callback.getInvocationType();\n             }\n-        });\n+        };\n+        boolean wakeup = _contentDemander.onContent(content);\n+        boolean handle = onContent(content);\n \n         boolean endStream = frame.isEndStream();\n         if (endStream)\n         {\n             boolean handleContent = onContentComplete();\n+            // this will generate EOF -> must happen before onContentProducible\n             boolean handleRequest = onRequestComplete();\n             handle |= handleContent | handleRequest;\n         }\n \n+        boolean woken = wakeup && getRequest().getHttpInput().onContentProducible();\n         if (LOG.isDebugEnabled())\n         {\n-            LOG.debug(\"HTTP2 Request #{}/{}: {} bytes of {} content, handle: {}\",\n+            LOG.debug(\"HTTP2 Request #{}/{}: {} bytes of {} content, woken: {}, handle: {}\",\n                     stream.getId(),\n                     Integer.toHexString(stream.getSession().hashCode()),\n                     length,\n                     endStream ? \"last\" : \"some\",\n+                    woken,\n                     handle);\n         }\n+        handle |= woken;\n \n         boolean wasDelayed = _delayedUntilContent;\n         _delayedUntilContent = false;\n         return handle || wasDelayed ? this : null;\n     }\n \n+    private static final HttpInput.Content EOF = new HttpInput.EofContent();\n+\n+    private static final class DemandingContent extends HttpInput.SpecialContent\n+    {\n+        private final boolean wakeup;\n+\n+        public DemandingContent(boolean wakeup)\n+        {\n+            this.wakeup = wakeup;\n+        }\n+    }\n+\n+    private class ContentDemander\n+    {\n+        private final AtomicReference<HttpInput.Content> _content = new AtomicReference<>();\n+\n+        public void recycle()\n+        {\n+            HttpInput.Content c = _content.getAndSet(null);\n+            if (c != null && !c.isSpecial())\n+                throw new AssertionError(\"unconsumed content: \" + c);\n+        }\n+\n+        public HttpInput.Content poll()\n+        {\n+            while (true)\n+            {\n+                HttpInput.Content c = _content.get();\n+                if (c == null || c.isSpecial() || _content.compareAndSet(c, c.isEof() ? EOF : null))\n+                    return c;\n+            }\n+        }\n+\n+        public boolean demand(boolean wakeup)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "98d831b85c23aa760744582a85e061bc99032af8"}, "originalPosition": 149}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTE2OTUyOTU1", "url": "https://github.com/eclipse/jetty.project/pull/4556#pullrequestreview-516952955", "createdAt": "2020-10-26T16:24:01Z", "commit": {"oid": "98d831b85c23aa760744582a85e061bc99032af8"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNlQxNjoyNDowMVrOHoXqeA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNlQxNjoyNDowMVrOHoXqeA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjA5Mjc5Mg==", "bodyText": "rename wakeup to needed", "url": "https://github.com/eclipse/jetty.project/pull/4556#discussion_r512092792", "createdAt": "2020-10-26T16:24:01Z", "author": {"login": "gregw"}, "path": "jetty-http2/http2-server/src/main/java/org/eclipse/jetty/http2/server/HttpChannelOverHTTP2.java", "diffHunk": "@@ -261,31 +275,277 @@ public InvocationType getInvocationType()\n             {\n                 return callback.getInvocationType();\n             }\n-        });\n+        };\n+        boolean wakeup = _contentDemander.onContent(content);\n+        boolean handle = onContent(content);\n \n         boolean endStream = frame.isEndStream();\n         if (endStream)\n         {\n             boolean handleContent = onContentComplete();\n+            // this will generate EOF -> must happen before onContentProducible\n             boolean handleRequest = onRequestComplete();\n             handle |= handleContent | handleRequest;\n         }\n \n+        boolean woken = wakeup && getRequest().getHttpInput().onContentProducible();\n         if (LOG.isDebugEnabled())\n         {\n-            LOG.debug(\"HTTP2 Request #{}/{}: {} bytes of {} content, handle: {}\",\n+            LOG.debug(\"HTTP2 Request #{}/{}: {} bytes of {} content, woken: {}, handle: {}\",\n                     stream.getId(),\n                     Integer.toHexString(stream.getSession().hashCode()),\n                     length,\n                     endStream ? \"last\" : \"some\",\n+                    woken,\n                     handle);\n         }\n+        handle |= woken;\n \n         boolean wasDelayed = _delayedUntilContent;\n         _delayedUntilContent = false;\n         return handle || wasDelayed ? this : null;\n     }\n \n+    private static final HttpInput.Content EOF = new HttpInput.EofContent();\n+\n+    private static final class DemandingContent extends HttpInput.SpecialContent\n+    {\n+        private final boolean wakeup;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "98d831b85c23aa760744582a85e061bc99032af8"}, "originalPosition": 120}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTE2OTYzNjY2", "url": "https://github.com/eclipse/jetty.project/pull/4556#pullrequestreview-516963666", "createdAt": "2020-10-26T16:34:55Z", "commit": {"oid": "98d831b85c23aa760744582a85e061bc99032af8"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNlQxNjozNDo1NVrOHoYKKw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNlQxNjozNDo1NVrOHoYKKw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjEwMDkwNw==", "bodyText": "So this is not really wakeup at this point.   It's more like contentWasNeeded or just `needed'", "url": "https://github.com/eclipse/jetty.project/pull/4556#discussion_r512100907", "createdAt": "2020-10-26T16:34:55Z", "author": {"login": "gregw"}, "path": "jetty-http2/http2-server/src/main/java/org/eclipse/jetty/http2/server/HttpChannelOverHTTP2.java", "diffHunk": "@@ -261,31 +275,277 @@ public InvocationType getInvocationType()\n             {\n                 return callback.getInvocationType();\n             }\n-        });\n+        };\n+        boolean wakeup = _contentDemander.onContent(content);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "98d831b85c23aa760744582a85e061bc99032af8"}, "originalPosition": 85}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTE2OTY2NjE1", "url": "https://github.com/eclipse/jetty.project/pull/4556#pullrequestreview-516966615", "createdAt": "2020-10-26T16:38:18Z", "commit": {"oid": "98d831b85c23aa760744582a85e061bc99032af8"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNlQxNjozODoxOFrOHoYTKw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNlQxNjozODoxOFrOHoYTKw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjEwMzIxMQ==", "bodyText": "A comment here to say that IFF isReady() returns false has needContent been called, thus we no that eventually a call to onContentProducible will come.", "url": "https://github.com/eclipse/jetty.project/pull/4556#discussion_r512103211", "createdAt": "2020-10-26T16:38:18Z", "author": {"login": "gregw"}, "path": "jetty-server/src/main/java/org/eclipse/jetty/server/BlockingContentProducer.java", "diffHunk": "@@ -0,0 +1,142 @@\n+//\n+// ========================================================================\n+// Copyright (c) 1995-2020 Mort Bay Consulting Pty Ltd and others.\n+//\n+// This program and the accompanying materials are made available under\n+// the terms of the Eclipse Public License 2.0 which is available at\n+// https://www.eclipse.org/legal/epl-2.0\n+//\n+// This Source Code may also be made available under the following\n+// Secondary Licenses when the conditions for such availability set\n+// forth in the Eclipse Public License, v. 2.0 are satisfied:\n+// the Apache License v2.0 which is available at\n+// https://www.apache.org/licenses/LICENSE-2.0\n+//\n+// SPDX-License-Identifier: EPL-2.0 OR Apache-2.0\n+// ========================================================================\n+//\n+\n+package org.eclipse.jetty.server;\n+\n+import java.util.concurrent.Semaphore;\n+\n+/**\n+ * Blocking implementation of {@link ContentProducer}. Calling {@link #nextContent()} will block when\n+ * there is no available content but will never return null.\n+ */\n+class BlockingContentProducer implements ContentProducer\n+{\n+    private final Semaphore _semaphore = new Semaphore(0);\n+    private final AsyncContentProducer _asyncContentProducer;\n+\n+    public BlockingContentProducer(AsyncContentProducer delegate)\n+    {\n+        _asyncContentProducer = delegate;\n+    }\n+\n+    @Override\n+    public void recycle()\n+    {\n+        _asyncContentProducer.recycle();\n+        _semaphore.drainPermits();\n+    }\n+\n+    @Override\n+    public int available()\n+    {\n+        return _asyncContentProducer.available();\n+    }\n+\n+    @Override\n+    public boolean hasContent()\n+    {\n+        return _asyncContentProducer.hasContent();\n+    }\n+\n+    @Override\n+    public boolean isError()\n+    {\n+        return _asyncContentProducer.isError();\n+    }\n+\n+    @Override\n+    public void checkMinDataRate()\n+    {\n+        _asyncContentProducer.checkMinDataRate();\n+    }\n+\n+    @Override\n+    public long getRawContentArrived()\n+    {\n+        return _asyncContentProducer.getRawContentArrived();\n+    }\n+\n+    @Override\n+    public boolean consumeAll(Throwable x)\n+    {\n+        return _asyncContentProducer.consumeAll(x);\n+    }\n+\n+    @Override\n+    public HttpInput.Content nextContent()\n+    {\n+        while (true)\n+        {\n+            HttpInput.Content content = _asyncContentProducer.nextContent();\n+            if (content != null)\n+                return content;\n+\n+            if (_asyncContentProducer.isReady())\n+                continue;\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "98d831b85c23aa760744582a85e061bc99032af8"}, "originalPosition": 91}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "6acf91eb875a27c46bbcf485abb9a1228bf46a09", "author": {"user": {"login": "lorban", "name": "Ludovic Orban"}}, "url": "https://github.com/eclipse/jetty.project/commit/6acf91eb875a27c46bbcf485abb9a1228bf46a09", "committedDate": "2020-10-26T17:12:33Z", "message": "rename wakeup to needed + introduce static DemandingContent instances\n\nSigned-off-by: Ludovic Orban <lorban@bitronix.be>"}, "afterCommit": {"oid": "99f227a68292ad51f103d313f5c8e686f0108532", "author": {"user": {"login": "lorban", "name": "Ludovic Orban"}}, "url": "https://github.com/eclipse/jetty.project/commit/99f227a68292ad51f103d313f5c8e686f0108532", "committedDate": "2020-10-27T13:22:14Z", "message": "remove reset check\n\nSigned-off-by: Ludovic Orban <lorban@bitronix.be>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "99f227a68292ad51f103d313f5c8e686f0108532", "author": {"user": {"login": "lorban", "name": "Ludovic Orban"}}, "url": "https://github.com/eclipse/jetty.project/commit/99f227a68292ad51f103d313f5c8e686f0108532", "committedDate": "2020-10-27T13:22:14Z", "message": "remove reset check\n\nSigned-off-by: Ludovic Orban <lorban@bitronix.be>"}, "afterCommit": {"oid": "abd0fe15d030317f52710b43d8b7e00329c9ee32", "author": {"user": {"login": "lorban", "name": "Ludovic Orban"}}, "url": "https://github.com/eclipse/jetty.project/commit/abd0fe15d030317f52710b43d8b7e00329c9ee32", "committedDate": "2020-10-27T13:47:10Z", "message": "remove reset check\n\nSigned-off-by: Ludovic Orban <lorban@bitronix.be>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "e74a418c3065046464c316d213349e97dffa3893", "author": {"user": {"login": "lorban", "name": "Ludovic Orban"}}, "url": "https://github.com/eclipse/jetty.project/commit/e74a418c3065046464c316d213349e97dffa3893", "committedDate": "2020-10-27T14:41:56Z", "message": "fail current content too\n\nSigned-off-by: Ludovic Orban <lorban@bitronix.be>"}, "afterCommit": {"oid": "0b90ca72ac35889289d7b10508642bfbfd372763", "author": {"user": {"login": "lorban", "name": "Ludovic Orban"}}, "url": "https://github.com/eclipse/jetty.project/commit/0b90ca72ac35889289d7b10508642bfbfd372763", "committedDate": "2020-10-27T15:33:10Z", "message": "add comment explaining why a branch is needed\n\nSigned-off-by: Ludovic Orban <lorban@bitronix.be>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "027545fb42514cee3df9cc9e0be882c29567eeea", "author": {"user": {"login": "lorban", "name": "Ludovic Orban"}}, "url": "https://github.com/eclipse/jetty.project/commit/027545fb42514cee3df9cc9e0be882c29567eeea", "committedDate": "2020-10-27T17:41:40Z", "message": "get rid of special content field\n\nSigned-off-by: Ludovic Orban <lorban@bitronix.be>"}, "afterCommit": {"oid": "cba85b58aee7b8969746dc37619749d4b4874f36", "author": {"user": {"login": "lorban", "name": "Ludovic Orban"}}, "url": "https://github.com/eclipse/jetty.project/commit/cba85b58aee7b8969746dc37619749d4b4874f36", "committedDate": "2020-10-29T08:21:14Z", "message": "Get rid of addContent() by making produceContent() return Content instead.\nMake EOF and errors be special content.\nTransition to a much simplified FSM by using the needContent() / produceContent() model.\nImplement blocking on top of async, this way there is only one FSM.\n(Milestone 7)\n\nSigned-off-by: Ludovic Orban <lorban@bitronix.be>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIyMjkxNjA2", "url": "https://github.com/eclipse/jetty.project/pull/4556#pullrequestreview-522291606", "createdAt": "2020-11-03T09:00:29Z", "commit": {"oid": "cba85b58aee7b8969746dc37619749d4b4874f36"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wM1QwOTowMDoyOVrOHslQmw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wM1QwOTowMDoyOVrOHslQmw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjUwOTg1MQ==", "bodyText": "Doesn't special content, or at least EOF, need to be passed to the interceptors?\nRemember that we can EOF on non special content now, so interceptors might sometimes see EOF.... so they should always see it.\nIt may be that an interceptor is buffering content and can produce lots of content (over and over) from an empty EOF raw content.", "url": "https://github.com/eclipse/jetty.project/pull/4556#discussion_r516509851", "createdAt": "2020-11-03T09:00:29Z", "author": {"login": "gregw"}, "path": "jetty-server/src/main/java/org/eclipse/jetty/server/AsyncContentProducer.java", "diffHunk": "@@ -0,0 +1,352 @@\n+//\n+// ========================================================================\n+// Copyright (c) 1995-2020 Mort Bay Consulting Pty Ltd and others.\n+//\n+// This program and the accompanying materials are made available under\n+// the terms of the Eclipse Public License 2.0 which is available at\n+// https://www.eclipse.org/legal/epl-2.0\n+//\n+// This Source Code may also be made available under the following\n+// Secondary Licenses when the conditions for such availability set\n+// forth in the Eclipse Public License, v. 2.0 are satisfied:\n+// the Apache License v2.0 which is available at\n+// https://www.apache.org/licenses/LICENSE-2.0\n+//\n+// SPDX-License-Identifier: EPL-2.0 OR Apache-2.0\n+// ========================================================================\n+//\n+\n+package org.eclipse.jetty.server;\n+\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jetty.http.BadMessageException;\n+import org.eclipse.jetty.http.HttpStatus;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Non-blocking {@link ContentProducer} implementation. Calling {@link #nextContent()} will never block\n+ * but will return null when there is no available content but will never return block.\n+ */\n+class AsyncContentProducer implements ContentProducer\n+{\n+    private static final Logger LOG = LoggerFactory.getLogger(AsyncContentProducer.class);\n+\n+    private final HttpChannel _httpChannel;\n+    private HttpInput.Interceptor _interceptor;\n+    private HttpInput.Content _rawContent;\n+    private HttpInput.Content _transformedContent;\n+    private boolean _error;\n+    private long _firstByteTimeStamp = Long.MIN_VALUE;\n+    private long _rawContentArrived;\n+\n+    AsyncContentProducer(HttpChannel httpChannel)\n+    {\n+        _httpChannel = httpChannel;\n+    }\n+\n+    @Override\n+    public void recycle()\n+    {\n+        if (LOG.isDebugEnabled())\n+            LOG.debug(\"recycling {}\", this);\n+        _interceptor = null;\n+        _rawContent = null;\n+        _transformedContent = null;\n+        _error = false;\n+        _firstByteTimeStamp = Long.MIN_VALUE;\n+        _rawContentArrived = 0L;\n+    }\n+\n+    @Override\n+    public HttpInput.Interceptor getInterceptor()\n+    {\n+        return _interceptor;\n+    }\n+\n+    @Override\n+    public void setInterceptor(HttpInput.Interceptor interceptor)\n+    {\n+        this._interceptor = interceptor;\n+    }\n+\n+    @Override\n+    public int available()\n+    {\n+        HttpInput.Content content = nextTransformedContent();\n+        int available = content == null ? 0 : content.remaining();\n+        if (LOG.isDebugEnabled())\n+            LOG.debug(\"available = {}\", available);\n+        return available;\n+    }\n+\n+    @Override\n+    public boolean hasContent()\n+    {\n+        boolean hasContent = _rawContent != null;\n+        if (LOG.isDebugEnabled())\n+            LOG.debug(\"hasContent = {}\", hasContent);\n+        return hasContent;\n+    }\n+\n+    @Override\n+    public boolean isError()\n+    {\n+        if (LOG.isDebugEnabled())\n+            LOG.debug(\"isError = {}\", _error);\n+        return _error;\n+    }\n+\n+    @Override\n+    public void checkMinDataRate()\n+    {\n+        long minRequestDataRate = _httpChannel.getHttpConfiguration().getMinRequestDataRate();\n+        if (LOG.isDebugEnabled())\n+            LOG.debug(\"checkMinDataRate [m={},t={}]\", minRequestDataRate, _firstByteTimeStamp);\n+        if (minRequestDataRate > 0 && _firstByteTimeStamp != Long.MIN_VALUE)\n+        {\n+            long period = System.nanoTime() - _firstByteTimeStamp;\n+            if (period > 0)\n+            {\n+                long minimumData = minRequestDataRate * TimeUnit.NANOSECONDS.toMillis(period) / TimeUnit.SECONDS.toMillis(1);\n+                if (getRawContentArrived() < minimumData)\n+                {\n+                    if (LOG.isDebugEnabled())\n+                        LOG.debug(\"checkMinDataRate check failed\");\n+                    BadMessageException bad = new BadMessageException(HttpStatus.REQUEST_TIMEOUT_408,\n+                        String.format(\"Request content data rate < %d B/s\", minRequestDataRate));\n+                    if (_httpChannel.getState().isResponseCommitted())\n+                    {\n+                        if (LOG.isDebugEnabled())\n+                            LOG.debug(\"checkMinDataRate aborting channel\");\n+                        _httpChannel.abort(bad);\n+                    }\n+                    failCurrentContent(bad);\n+                    throw bad;\n+                }\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public long getRawContentArrived()\n+    {\n+        if (LOG.isDebugEnabled())\n+            LOG.debug(\"getRawContentArrived = {}\", _rawContentArrived);\n+        return _rawContentArrived;\n+    }\n+\n+    @Override\n+    public boolean consumeAll(Throwable x)\n+    {\n+        if (LOG.isDebugEnabled())\n+            LOG.debug(\"consumeAll [e={}]\", (Object)x);\n+        failCurrentContent(x);\n+        // A specific HttpChannel mechanism must be used as the following code\n+        // does not guarantee that the channel will synchronously deliver all\n+        // content it already contains:\n+        //   while (true)\n+        //   {\n+        //       HttpInput.Content content = _httpChannel.produceContent();\n+        //       ...\n+        //   }\n+        // as the HttpChannel's produceContent() contract makes no such promise;\n+        // for instance the H2 implementation calls Stream.demand() that may\n+        // deliver the content asynchronously. Tests in StreamResetTest cover this.\n+        boolean atEof = _httpChannel.failAllContent(x);\n+        if (LOG.isDebugEnabled())\n+            LOG.debug(\"failed all content of http channel; at EOF? {}\", atEof);\n+        return atEof;\n+    }\n+\n+    private void failCurrentContent(Throwable x)\n+    {\n+        if (LOG.isDebugEnabled())\n+            LOG.debug(\"failing currently held content [r={},t={}]\", _rawContent, _transformedContent, x);\n+        if (_transformedContent != null && !_transformedContent.isSpecial())\n+        {\n+            if (_transformedContent != _rawContent)\n+            {\n+                _transformedContent.skip(_transformedContent.remaining());\n+                _transformedContent.failed(x);\n+            }\n+            _transformedContent = null;\n+        }\n+\n+        if (_rawContent != null && !_rawContent.isSpecial())\n+        {\n+            _rawContent.skip(_rawContent.remaining());\n+            _rawContent.failed(x);\n+            _rawContent = null;\n+        }\n+    }\n+\n+    @Override\n+    public boolean onContentProducible()\n+    {\n+        if (LOG.isDebugEnabled())\n+            LOG.debug(\"onContentProducible\");\n+        return _httpChannel.getState().onReadReady();\n+    }\n+\n+    @Override\n+    public HttpInput.Content nextContent()\n+    {\n+        HttpInput.Content content = nextTransformedContent();\n+        if (LOG.isDebugEnabled())\n+            LOG.debug(\"nextContent = {}\", content);\n+        if (content != null)\n+            _httpChannel.getState().onReadIdle();\n+        return content;\n+    }\n+\n+    @Override\n+    public void reclaim(HttpInput.Content content)\n+    {\n+        if (LOG.isDebugEnabled())\n+            LOG.debug(\"reclaim {} [t={}]\", content, _transformedContent);\n+        if (_transformedContent == content)\n+        {\n+            content.succeeded();\n+            if (_transformedContent == _rawContent)\n+                _rawContent = null;\n+            _transformedContent = null;\n+        }\n+    }\n+\n+    @Override\n+    public boolean isReady()\n+    {\n+        HttpInput.Content content = nextTransformedContent();\n+        if (content == null)\n+        {\n+            _httpChannel.getState().onReadUnready();\n+            if (_httpChannel.needContent())\n+            {\n+                content = nextTransformedContent();\n+                if (LOG.isDebugEnabled())\n+                    LOG.debug(\"isReady got transformed content after needContent retry {}\", content);\n+                if (content != null)\n+                    _httpChannel.getState().onContentAdded();\n+            }\n+            else\n+            {\n+                if (LOG.isDebugEnabled())\n+                    LOG.debug(\"isReady has no transformed content after needContent\");\n+            }\n+        }\n+        else\n+        {\n+            if (LOG.isDebugEnabled())\n+                LOG.debug(\"isReady got transformed content {}\", content);\n+            _httpChannel.getState().onContentAdded();\n+        }\n+        boolean ready = content != null;\n+        if (LOG.isDebugEnabled())\n+            LOG.debug(\"isReady = {}\", ready);\n+        return ready;\n+    }\n+\n+    private HttpInput.Content nextTransformedContent()\n+    {\n+        if (LOG.isDebugEnabled())\n+            LOG.debug(\"nextTransformedContent [r={},t={}]\", _rawContent, _transformedContent);\n+        if (_rawContent == null)\n+        {\n+            _rawContent = produceRawContent();\n+            if (_rawContent == null)\n+                return null;\n+        }\n+\n+        if (_transformedContent != null && _transformedContent.isEmpty())\n+        {\n+            if (_transformedContent != _rawContent)\n+                _transformedContent.succeeded();\n+            if (LOG.isDebugEnabled())\n+                LOG.debug(\"nulling depleted transformed content\");\n+            _transformedContent = null;\n+        }\n+\n+        while (_transformedContent == null)\n+        {\n+            if (_rawContent.isSpecial())\n+            {\n+                _error = _rawContent.getError() != null;\n+                if (LOG.isDebugEnabled())\n+                    LOG.debug(\"raw content is special (with error = {}), returning it\", _error);\n+                return _rawContent;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cba85b58aee7b8969746dc37619749d4b4874f36"}, "originalPosition": 278}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIyNDAzNjYx", "url": "https://github.com/eclipse/jetty.project/pull/4556#pullrequestreview-522403661", "createdAt": "2020-11-03T11:25:46Z", "commit": {"oid": "cba85b58aee7b8969746dc37619749d4b4874f36"}, "state": "APPROVED", "comments": {"totalCount": 9, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wM1QxMToyNTo0NlrOHsqkbw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wM1QxNDoxMjo0N1rOHswjsw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjU5Njg0Nw==", "bodyText": "I think it's entirely possible that an application does not want to read the content, so we should not throw here.", "url": "https://github.com/eclipse/jetty.project/pull/4556#discussion_r516596847", "createdAt": "2020-11-03T11:25:46Z", "author": {"login": "sbordet"}, "path": "jetty-fcgi/fcgi-server/src/main/java/org/eclipse/jetty/fcgi/server/HttpChannelOverFCGI.java", "diffHunk": "@@ -127,12 +231,46 @@ protected void dispatch()\n \n     public boolean onIdleTimeout(Throwable timeout)\n     {\n-        boolean handle = getRequest().getHttpInput().onIdleTimeout(timeout);\n+        boolean handle = doOnIdleTimeout(timeout);\n         if (handle)\n             execute(this);\n         return !handle;\n     }\n \n+    private boolean doOnIdleTimeout(Throwable x)\n+    {\n+        boolean neverDispatched = getState().isIdle();\n+        boolean waitingForContent;\n+        HttpInput.Content specialContent;\n+        try (AutoLock l = _lock.lock())\n+        {\n+            waitingForContent = _contentQueue.isEmpty() || _contentQueue.peek().remaining() == 0;\n+            specialContent = _specialContent;\n+        }\n+        if ((waitingForContent || neverDispatched) && specialContent == null)\n+        {\n+            x.addSuppressed(new Throwable(\"HttpInput idle timeout\"));\n+            try (AutoLock l = _lock.lock())\n+            {\n+                _specialContent = new HttpInput.ErrorContent(x);\n+            }\n+            return getRequest().getHttpInput().onContentProducible();\n+        }\n+        return false;\n+    }\n+\n+    @Override\n+    public void recycle()\n+    {\n+        try (AutoLock l = _lock.lock())\n+        {\n+            if (!_contentQueue.isEmpty())\n+                throw new AssertionError(\"unconsumed content: \" + _contentQueue);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cba85b58aee7b8969746dc37619749d4b4874f36"}, "originalPosition": 174}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjU5OTcyOA==", "bodyText": "Isn't it possible that there is unconsumed content?", "url": "https://github.com/eclipse/jetty.project/pull/4556#discussion_r516599728", "createdAt": "2020-11-03T11:31:12Z", "author": {"login": "sbordet"}, "path": "jetty-http2/http2-server/src/main/java/org/eclipse/jetty/http2/server/HttpChannelOverHTTP2.java", "diffHunk": "@@ -286,6 +297,345 @@ public InvocationType getInvocationType()\n         return handle || wasDelayed ? this : null;\n     }\n \n+    /**\n+     * Demanding content is a marker content that is used to remember that a demand was\n+     * registered into the stream. The {@code needed} flag indicates if the demand originated\n+     * from a call to {@link #produceContent()} when false or {@link #needContent()}\n+     * when true, as {@link HttpInput#onContentProducible()} must only be called\n+     * only when {@link #needContent()} was called.\n+     * Instances of this class must never escape the scope of this channel impl,\n+     * so {@link #produceContent()} must never return one.\n+     */\n+    private static final class DemandingContent extends HttpInput.SpecialContent\n+    {\n+        private final boolean needed;\n+\n+        private DemandingContent(boolean needed)\n+        {\n+            this.needed = needed;\n+        }\n+    }\n+\n+    private static final HttpInput.Content EOF = new HttpInput.EofContent();\n+    private static final HttpInput.Content DEMANDING_NEEDED = new DemandingContent(true);\n+    private static final HttpInput.Content DEMANDING_NOT_NEEDED = new DemandingContent(false);\n+\n+    private class ContentDemander\n+    {\n+        private final AtomicReference<HttpInput.Content> _content = new AtomicReference<>();\n+\n+        public void recycle()\n+        {\n+            if (LOG.isDebugEnabled())\n+                LOG.debug(\"recycle {}\", this);\n+            HttpInput.Content c = _content.getAndSet(null);\n+            if (c != null && !c.isSpecial())\n+                throw new AssertionError(\"unconsumed content: \" + c);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cba85b58aee7b8969746dc37619749d4b4874f36"}, "originalPosition": 156}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjYxMDAwMA==", "bodyText": "I insist that we cannot throw, even if it's a bug.\nThrowing will cause the server to hang and require a restart, while failing the callback will fail the current request and allow for future requests.", "url": "https://github.com/eclipse/jetty.project/pull/4556#discussion_r516610000", "createdAt": "2020-11-03T11:50:37Z", "author": {"login": "sbordet"}, "path": "jetty-http2/http2-server/src/main/java/org/eclipse/jetty/http2/server/HttpChannelOverHTTP2.java", "diffHunk": "@@ -261,31 +264,265 @@ public InvocationType getInvocationType()\n             {\n                 return callback.getInvocationType();\n             }\n-        });\n+        };\n+        _contentDemander.onContent(content);\n+        boolean handle = onContent(content);\n \n         boolean endStream = frame.isEndStream();\n         if (endStream)\n         {\n             boolean handleContent = onContentComplete();\n+            // this will generate EOF -> must happen before wakeup\n             boolean handleRequest = onRequestComplete();\n             handle |= handleContent | handleRequest;\n         }\n \n+        boolean woken = getRequest().getHttpInput().wakeup();\n         if (LOG.isDebugEnabled())\n         {\n-            LOG.debug(\"HTTP2 Request #{}/{}: {} bytes of {} content, handle: {}\",\n+            Stream stream = getStream();\n+            LOG.debug(\"HTTP2 Request #{}/{}: {} bytes of {} content, woken: {}, handle: {}\",\n                     stream.getId(),\n                     Integer.toHexString(stream.getSession().hashCode()),\n                     length,\n                     endStream ? \"last\" : \"some\",\n+                    woken,\n                     handle);\n         }\n+        handle |= woken;\n \n         boolean wasDelayed = _delayedUntilContent;\n         _delayedUntilContent = false;\n         return handle || wasDelayed ? this : null;\n     }\n \n+    private static final HttpInput.Content EOF = new HttpInput.EofContent();\n+    private static final HttpInput.Content DEMANDING = new HttpInput.SpecialContent() {};\n+\n+    private class ContentDemander\n+    {\n+        private final AtomicReference<HttpInput.Content> _content = new AtomicReference<>();\n+\n+        public void recycle()\n+        {\n+            HttpInput.Content c = _content.getAndSet(null);\n+            if (c != null && !c.isSpecial())\n+                throw new AssertionError(\"unconsumed content: \" + c);\n+        }\n+\n+        public HttpInput.Content take()\n+        {\n+            while (true)\n+            {\n+                HttpInput.Content c = _content.get();\n+                if (c == null || c.isSpecial() || _content.compareAndSet(c, c.isEof() ? EOF : null))\n+                    return c;\n+            }\n+        }\n+\n+        public boolean demand()\n+        {\n+            while (true)\n+            {\n+                HttpInput.Content c = _content.get();\n+                if (c == DEMANDING)\n+                    return false;\n+                if (c != null)\n+                    return true;\n+                if (_content.compareAndSet(null, DEMANDING))\n+                {\n+                    IStream stream = getStream();\n+                    if (stream == null)\n+                    {\n+                        _content.set(null);\n+                        return false;\n+                    }\n+                    stream.demand(1);\n+                    c = _content.get();\n+                    return c != DEMANDING && c != null;\n+                }\n+            }\n+        }\n+\n+        public void onContent(HttpInput.Content content)\n+        {\n+            while (true)\n+            {\n+                HttpInput.Content c = _content.get();\n+                if (c == DEMANDING)\n+                {\n+                    if (_content.compareAndSet(DEMANDING, content))\n+                        return;\n+                }\n+                else if (c == null)\n+                {\n+                    if (!content.isSpecial())\n+                        throw new AssertionError(\"Non special content without demand\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDg1MjQwNg=="}, "originalCommit": {"oid": "273213e8df4f438bf853787ec932e22424e7fe8b"}, "originalPosition": 184}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjYxMDI5Ng==", "bodyText": "Cannot throw.", "url": "https://github.com/eclipse/jetty.project/pull/4556#discussion_r516610296", "createdAt": "2020-11-03T11:51:10Z", "author": {"login": "sbordet"}, "path": "jetty-http2/http2-server/src/main/java/org/eclipse/jetty/http2/server/HttpChannelOverHTTP2.java", "diffHunk": "@@ -286,6 +297,345 @@ public InvocationType getInvocationType()\n         return handle || wasDelayed ? this : null;\n     }\n \n+    /**\n+     * Demanding content is a marker content that is used to remember that a demand was\n+     * registered into the stream. The {@code needed} flag indicates if the demand originated\n+     * from a call to {@link #produceContent()} when false or {@link #needContent()}\n+     * when true, as {@link HttpInput#onContentProducible()} must only be called\n+     * only when {@link #needContent()} was called.\n+     * Instances of this class must never escape the scope of this channel impl,\n+     * so {@link #produceContent()} must never return one.\n+     */\n+    private static final class DemandingContent extends HttpInput.SpecialContent\n+    {\n+        private final boolean needed;\n+\n+        private DemandingContent(boolean needed)\n+        {\n+            this.needed = needed;\n+        }\n+    }\n+\n+    private static final HttpInput.Content EOF = new HttpInput.EofContent();\n+    private static final HttpInput.Content DEMANDING_NEEDED = new DemandingContent(true);\n+    private static final HttpInput.Content DEMANDING_NOT_NEEDED = new DemandingContent(false);\n+\n+    private class ContentDemander\n+    {\n+        private final AtomicReference<HttpInput.Content> _content = new AtomicReference<>();\n+\n+        public void recycle()\n+        {\n+            if (LOG.isDebugEnabled())\n+                LOG.debug(\"recycle {}\", this);\n+            HttpInput.Content c = _content.getAndSet(null);\n+            if (c != null && !c.isSpecial())\n+                throw new AssertionError(\"unconsumed content: \" + c);\n+        }\n+\n+        public HttpInput.Content poll()\n+        {\n+            while (true)\n+            {\n+                HttpInput.Content c = _content.get();\n+                if (LOG.isDebugEnabled())\n+                    LOG.debug(\"poll, content = {}\", c);\n+                if (c == null || c.isSpecial() || _content.compareAndSet(c, c.isEof() ? EOF : null))\n+                {\n+                    if (LOG.isDebugEnabled())\n+                        LOG.debug(\"returning current content\");\n+                    return c;\n+                }\n+            }\n+        }\n+\n+        public boolean demand(boolean needed)\n+        {\n+            while (true)\n+            {\n+                HttpInput.Content c = _content.get();\n+                if (LOG.isDebugEnabled())\n+                    LOG.debug(\"demand({}), content = {}\", needed, c);\n+                if (c instanceof DemandingContent)\n+                {\n+                    if (needed && !((DemandingContent)c).needed)\n+                    {\n+                        if (!_content.compareAndSet(c, DEMANDING_NEEDED))\n+                        {\n+                            if (LOG.isDebugEnabled())\n+                                LOG.debug(\"already demanding but switched needed flag to true\");\n+                            continue;\n+                        }\n+                    }\n+                    if (LOG.isDebugEnabled())\n+                        LOG.debug(\"already demanding, returning false\");\n+                    return false;\n+                }\n+                if (c != null)\n+                {\n+                    if (LOG.isDebugEnabled())\n+                        LOG.debug(\"content available, returning true\");\n+                    return true;\n+                }\n+                if (_content.compareAndSet(null, needed ? DEMANDING_NEEDED : DEMANDING_NOT_NEEDED))\n+                {\n+                    IStream stream = getStream();\n+                    if (stream == null)\n+                    {\n+                        _content.set(null);\n+                        if (LOG.isDebugEnabled())\n+                            LOG.debug(\"no content available, switched to demanding but stream is now null\");\n+                        return false;\n+                    }\n+                    if (LOG.isDebugEnabled())\n+                        LOG.debug(\"no content available, demanding stream {}\", stream);\n+                    stream.demand(1);\n+                    c = _content.get();\n+                    boolean hasContent = !(c instanceof DemandingContent) && c != null;\n+                    if (LOG.isDebugEnabled())\n+                        LOG.debug(\"has content now? {}\", hasContent);\n+                    return hasContent;\n+                }\n+            }\n+        }\n+\n+        public boolean onContent(HttpInput.Content content)\n+        {\n+            while (true)\n+            {\n+                HttpInput.Content c = _content.get();\n+                if (LOG.isDebugEnabled())\n+                    LOG.debug(\"content delivered by stream: {}, current content: {}\", content, c);\n+                if (c instanceof DemandingContent)\n+                {\n+                    if (_content.compareAndSet(c, content))\n+                    {\n+                        boolean needed = ((DemandingContent)c).needed;\n+                        if (LOG.isDebugEnabled())\n+                            LOG.debug(\"replacing demand content with {} succeeded; returning {}\", content, needed);\n+                        return needed;\n+                    }\n+                }\n+                else if (c == null)\n+                {\n+                    if (!content.isSpecial())\n+                        throw new AssertionError(\"Non special content without demand\");\n+                    if (_content.compareAndSet(null, content))\n+                    {\n+                        if (LOG.isDebugEnabled())\n+                            LOG.debug(\"replacing null content with {} succeeded\", content);\n+                        return false;\n+                    }\n+                }\n+                else if (c.isEof() && content.isEof() && content.isEmpty())\n+                {\n+                    content.succeeded();\n+                    return true;\n+                }\n+                else if (content.getError() != null)\n+                {\n+                    if (c.getError() != null)\n+                    {\n+                        if (c.getError() != content.getError())\n+                            c.getError().addSuppressed(content.getError());\n+                        return true;\n+                    }\n+                    if (_content.compareAndSet(c, content))\n+                    {\n+                        c.failed(content.getError());\n+                        if (LOG.isDebugEnabled())\n+                            LOG.debug(\"replacing current content with {} succeeded\", content);\n+                        return true;\n+                    }\n+                }\n+                else if (c.getError() != null && content.remaining() == 0)\n+                {\n+                    content.succeeded();\n+                    return true;\n+                }\n+                else\n+                {\n+                    throw new AssertionError(\"Cannot overwrite exiting content \" + c + \" with \" + content);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cba85b58aee7b8969746dc37619749d4b4874f36"}, "originalPosition": 281}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjYxMjMwNw==", "bodyText": "I don't think this is right, because we replace a valid content with EOF, but we don't complete the existing content, right?\nWe must call succeeded() or failed(Throwable) on c, but if we remove it from here, who will have a reference to it to complete it?", "url": "https://github.com/eclipse/jetty.project/pull/4556#discussion_r516612307", "createdAt": "2020-11-03T11:55:06Z", "author": {"login": "sbordet"}, "path": "jetty-http2/http2-server/src/main/java/org/eclipse/jetty/http2/server/HttpChannelOverHTTP2.java", "diffHunk": "@@ -286,6 +297,345 @@ public InvocationType getInvocationType()\n         return handle || wasDelayed ? this : null;\n     }\n \n+    /**\n+     * Demanding content is a marker content that is used to remember that a demand was\n+     * registered into the stream. The {@code needed} flag indicates if the demand originated\n+     * from a call to {@link #produceContent()} when false or {@link #needContent()}\n+     * when true, as {@link HttpInput#onContentProducible()} must only be called\n+     * only when {@link #needContent()} was called.\n+     * Instances of this class must never escape the scope of this channel impl,\n+     * so {@link #produceContent()} must never return one.\n+     */\n+    private static final class DemandingContent extends HttpInput.SpecialContent\n+    {\n+        private final boolean needed;\n+\n+        private DemandingContent(boolean needed)\n+        {\n+            this.needed = needed;\n+        }\n+    }\n+\n+    private static final HttpInput.Content EOF = new HttpInput.EofContent();\n+    private static final HttpInput.Content DEMANDING_NEEDED = new DemandingContent(true);\n+    private static final HttpInput.Content DEMANDING_NOT_NEEDED = new DemandingContent(false);\n+\n+    private class ContentDemander\n+    {\n+        private final AtomicReference<HttpInput.Content> _content = new AtomicReference<>();\n+\n+        public void recycle()\n+        {\n+            if (LOG.isDebugEnabled())\n+                LOG.debug(\"recycle {}\", this);\n+            HttpInput.Content c = _content.getAndSet(null);\n+            if (c != null && !c.isSpecial())\n+                throw new AssertionError(\"unconsumed content: \" + c);\n+        }\n+\n+        public HttpInput.Content poll()\n+        {\n+            while (true)\n+            {\n+                HttpInput.Content c = _content.get();\n+                if (LOG.isDebugEnabled())\n+                    LOG.debug(\"poll, content = {}\", c);\n+                if (c == null || c.isSpecial() || _content.compareAndSet(c, c.isEof() ? EOF : null))\n+                {\n+                    if (LOG.isDebugEnabled())\n+                        LOG.debug(\"returning current content\");\n+                    return c;\n+                }\n+            }\n+        }\n+\n+        public boolean demand(boolean needed)\n+        {\n+            while (true)\n+            {\n+                HttpInput.Content c = _content.get();\n+                if (LOG.isDebugEnabled())\n+                    LOG.debug(\"demand({}), content = {}\", needed, c);\n+                if (c instanceof DemandingContent)\n+                {\n+                    if (needed && !((DemandingContent)c).needed)\n+                    {\n+                        if (!_content.compareAndSet(c, DEMANDING_NEEDED))\n+                        {\n+                            if (LOG.isDebugEnabled())\n+                                LOG.debug(\"already demanding but switched needed flag to true\");\n+                            continue;\n+                        }\n+                    }\n+                    if (LOG.isDebugEnabled())\n+                        LOG.debug(\"already demanding, returning false\");\n+                    return false;\n+                }\n+                if (c != null)\n+                {\n+                    if (LOG.isDebugEnabled())\n+                        LOG.debug(\"content available, returning true\");\n+                    return true;\n+                }\n+                if (_content.compareAndSet(null, needed ? DEMANDING_NEEDED : DEMANDING_NOT_NEEDED))\n+                {\n+                    IStream stream = getStream();\n+                    if (stream == null)\n+                    {\n+                        _content.set(null);\n+                        if (LOG.isDebugEnabled())\n+                            LOG.debug(\"no content available, switched to demanding but stream is now null\");\n+                        return false;\n+                    }\n+                    if (LOG.isDebugEnabled())\n+                        LOG.debug(\"no content available, demanding stream {}\", stream);\n+                    stream.demand(1);\n+                    c = _content.get();\n+                    boolean hasContent = !(c instanceof DemandingContent) && c != null;\n+                    if (LOG.isDebugEnabled())\n+                        LOG.debug(\"has content now? {}\", hasContent);\n+                    return hasContent;\n+                }\n+            }\n+        }\n+\n+        public boolean onContent(HttpInput.Content content)\n+        {\n+            while (true)\n+            {\n+                HttpInput.Content c = _content.get();\n+                if (LOG.isDebugEnabled())\n+                    LOG.debug(\"content delivered by stream: {}, current content: {}\", content, c);\n+                if (c instanceof DemandingContent)\n+                {\n+                    if (_content.compareAndSet(c, content))\n+                    {\n+                        boolean needed = ((DemandingContent)c).needed;\n+                        if (LOG.isDebugEnabled())\n+                            LOG.debug(\"replacing demand content with {} succeeded; returning {}\", content, needed);\n+                        return needed;\n+                    }\n+                }\n+                else if (c == null)\n+                {\n+                    if (!content.isSpecial())\n+                        throw new AssertionError(\"Non special content without demand\");\n+                    if (_content.compareAndSet(null, content))\n+                    {\n+                        if (LOG.isDebugEnabled())\n+                            LOG.debug(\"replacing null content with {} succeeded\", content);\n+                        return false;\n+                    }\n+                }\n+                else if (c.isEof() && content.isEof() && content.isEmpty())\n+                {\n+                    content.succeeded();\n+                    return true;\n+                }\n+                else if (content.getError() != null)\n+                {\n+                    if (c.getError() != null)\n+                    {\n+                        if (c.getError() != content.getError())\n+                            c.getError().addSuppressed(content.getError());\n+                        return true;\n+                    }\n+                    if (_content.compareAndSet(c, content))\n+                    {\n+                        c.failed(content.getError());\n+                        if (LOG.isDebugEnabled())\n+                            LOG.debug(\"replacing current content with {} succeeded\", content);\n+                        return true;\n+                    }\n+                }\n+                else if (c.getError() != null && content.remaining() == 0)\n+                {\n+                    content.succeeded();\n+                    return true;\n+                }\n+                else\n+                {\n+                    throw new AssertionError(\"Cannot overwrite exiting content \" + c + \" with \" + content);\n+                }\n+            }\n+        }\n+\n+        public boolean onTimeout(Throwable failure)\n+        {\n+            while (true)\n+            {\n+                HttpInput.Content c = _content.get();\n+                if (LOG.isDebugEnabled())\n+                    LOG.debug(\"onTimeout with current content: {} and failure = {}\", c, failure);\n+                if (!(c instanceof DemandingContent))\n+                    return false;\n+                if (_content.compareAndSet(c, new HttpInput.ErrorContent(failure)))\n+                {\n+                    if (LOG.isDebugEnabled())\n+                        LOG.debug(\"replacing current content with error succeeded\");\n+                    return true;\n+                }\n+            }\n+        }\n+\n+        public void eof()\n+        {\n+            while (true)\n+            {\n+                HttpInput.Content c = _content.get();\n+                if (LOG.isDebugEnabled())\n+                    LOG.debug(\"eof with current content: {}\", c);\n+                if (c instanceof DemandingContent)\n+                {\n+                    if (_content.compareAndSet(c, EOF))\n+                    {\n+                        if (LOG.isDebugEnabled())\n+                            LOG.debug(\"replacing current content with special EOF succeeded\");\n+                        return;\n+                    }\n+                }\n+                else if (c == null)\n+                {\n+                    if (_content.compareAndSet(null, EOF))\n+                    {\n+                        if (LOG.isDebugEnabled())\n+                            LOG.debug(\"replacing null content with special EOF succeeded\");\n+                        return;\n+                    }\n+                }\n+                else if (c.isEof())\n+                {\n+                    if (LOG.isDebugEnabled())\n+                        LOG.debug(\"current content already is EOF\");\n+                    return;\n+                }\n+                else if (c.remaining() == 0)\n+                {\n+                    if (_content.compareAndSet(c, EOF))\n+                    {\n+                        if (LOG.isDebugEnabled())\n+                            LOG.debug(\"replacing current content with special EOF succeeded\");\n+                        return;\n+                    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cba85b58aee7b8969746dc37619749d4b4874f36"}, "originalPosition": 342}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjYyNDc0Mg==", "bodyText": "Improve the comment to:\n\"EOF may arrive with HEADERS frame (e.g. a trailer) that is not flow controlled, so we need to wrap the existing content.\"", "url": "https://github.com/eclipse/jetty.project/pull/4556#discussion_r516624742", "createdAt": "2020-11-03T12:18:38Z", "author": {"login": "sbordet"}, "path": "jetty-http2/http2-server/src/main/java/org/eclipse/jetty/http2/server/HttpChannelOverHTTP2.java", "diffHunk": "@@ -286,6 +297,345 @@ public InvocationType getInvocationType()\n         return handle || wasDelayed ? this : null;\n     }\n \n+    /**\n+     * Demanding content is a marker content that is used to remember that a demand was\n+     * registered into the stream. The {@code needed} flag indicates if the demand originated\n+     * from a call to {@link #produceContent()} when false or {@link #needContent()}\n+     * when true, as {@link HttpInput#onContentProducible()} must only be called\n+     * only when {@link #needContent()} was called.\n+     * Instances of this class must never escape the scope of this channel impl,\n+     * so {@link #produceContent()} must never return one.\n+     */\n+    private static final class DemandingContent extends HttpInput.SpecialContent\n+    {\n+        private final boolean needed;\n+\n+        private DemandingContent(boolean needed)\n+        {\n+            this.needed = needed;\n+        }\n+    }\n+\n+    private static final HttpInput.Content EOF = new HttpInput.EofContent();\n+    private static final HttpInput.Content DEMANDING_NEEDED = new DemandingContent(true);\n+    private static final HttpInput.Content DEMANDING_NOT_NEEDED = new DemandingContent(false);\n+\n+    private class ContentDemander\n+    {\n+        private final AtomicReference<HttpInput.Content> _content = new AtomicReference<>();\n+\n+        public void recycle()\n+        {\n+            if (LOG.isDebugEnabled())\n+                LOG.debug(\"recycle {}\", this);\n+            HttpInput.Content c = _content.getAndSet(null);\n+            if (c != null && !c.isSpecial())\n+                throw new AssertionError(\"unconsumed content: \" + c);\n+        }\n+\n+        public HttpInput.Content poll()\n+        {\n+            while (true)\n+            {\n+                HttpInput.Content c = _content.get();\n+                if (LOG.isDebugEnabled())\n+                    LOG.debug(\"poll, content = {}\", c);\n+                if (c == null || c.isSpecial() || _content.compareAndSet(c, c.isEof() ? EOF : null))\n+                {\n+                    if (LOG.isDebugEnabled())\n+                        LOG.debug(\"returning current content\");\n+                    return c;\n+                }\n+            }\n+        }\n+\n+        public boolean demand(boolean needed)\n+        {\n+            while (true)\n+            {\n+                HttpInput.Content c = _content.get();\n+                if (LOG.isDebugEnabled())\n+                    LOG.debug(\"demand({}), content = {}\", needed, c);\n+                if (c instanceof DemandingContent)\n+                {\n+                    if (needed && !((DemandingContent)c).needed)\n+                    {\n+                        if (!_content.compareAndSet(c, DEMANDING_NEEDED))\n+                        {\n+                            if (LOG.isDebugEnabled())\n+                                LOG.debug(\"already demanding but switched needed flag to true\");\n+                            continue;\n+                        }\n+                    }\n+                    if (LOG.isDebugEnabled())\n+                        LOG.debug(\"already demanding, returning false\");\n+                    return false;\n+                }\n+                if (c != null)\n+                {\n+                    if (LOG.isDebugEnabled())\n+                        LOG.debug(\"content available, returning true\");\n+                    return true;\n+                }\n+                if (_content.compareAndSet(null, needed ? DEMANDING_NEEDED : DEMANDING_NOT_NEEDED))\n+                {\n+                    IStream stream = getStream();\n+                    if (stream == null)\n+                    {\n+                        _content.set(null);\n+                        if (LOG.isDebugEnabled())\n+                            LOG.debug(\"no content available, switched to demanding but stream is now null\");\n+                        return false;\n+                    }\n+                    if (LOG.isDebugEnabled())\n+                        LOG.debug(\"no content available, demanding stream {}\", stream);\n+                    stream.demand(1);\n+                    c = _content.get();\n+                    boolean hasContent = !(c instanceof DemandingContent) && c != null;\n+                    if (LOG.isDebugEnabled())\n+                        LOG.debug(\"has content now? {}\", hasContent);\n+                    return hasContent;\n+                }\n+            }\n+        }\n+\n+        public boolean onContent(HttpInput.Content content)\n+        {\n+            while (true)\n+            {\n+                HttpInput.Content c = _content.get();\n+                if (LOG.isDebugEnabled())\n+                    LOG.debug(\"content delivered by stream: {}, current content: {}\", content, c);\n+                if (c instanceof DemandingContent)\n+                {\n+                    if (_content.compareAndSet(c, content))\n+                    {\n+                        boolean needed = ((DemandingContent)c).needed;\n+                        if (LOG.isDebugEnabled())\n+                            LOG.debug(\"replacing demand content with {} succeeded; returning {}\", content, needed);\n+                        return needed;\n+                    }\n+                }\n+                else if (c == null)\n+                {\n+                    if (!content.isSpecial())\n+                        throw new AssertionError(\"Non special content without demand\");\n+                    if (_content.compareAndSet(null, content))\n+                    {\n+                        if (LOG.isDebugEnabled())\n+                            LOG.debug(\"replacing null content with {} succeeded\", content);\n+                        return false;\n+                    }\n+                }\n+                else if (c.isEof() && content.isEof() && content.isEmpty())\n+                {\n+                    content.succeeded();\n+                    return true;\n+                }\n+                else if (content.getError() != null)\n+                {\n+                    if (c.getError() != null)\n+                    {\n+                        if (c.getError() != content.getError())\n+                            c.getError().addSuppressed(content.getError());\n+                        return true;\n+                    }\n+                    if (_content.compareAndSet(c, content))\n+                    {\n+                        c.failed(content.getError());\n+                        if (LOG.isDebugEnabled())\n+                            LOG.debug(\"replacing current content with {} succeeded\", content);\n+                        return true;\n+                    }\n+                }\n+                else if (c.getError() != null && content.remaining() == 0)\n+                {\n+                    content.succeeded();\n+                    return true;\n+                }\n+                else\n+                {\n+                    throw new AssertionError(\"Cannot overwrite exiting content \" + c + \" with \" + content);\n+                }\n+            }\n+        }\n+\n+        public boolean onTimeout(Throwable failure)\n+        {\n+            while (true)\n+            {\n+                HttpInput.Content c = _content.get();\n+                if (LOG.isDebugEnabled())\n+                    LOG.debug(\"onTimeout with current content: {} and failure = {}\", c, failure);\n+                if (!(c instanceof DemandingContent))\n+                    return false;\n+                if (_content.compareAndSet(c, new HttpInput.ErrorContent(failure)))\n+                {\n+                    if (LOG.isDebugEnabled())\n+                        LOG.debug(\"replacing current content with error succeeded\");\n+                    return true;\n+                }\n+            }\n+        }\n+\n+        public void eof()\n+        {\n+            while (true)\n+            {\n+                HttpInput.Content c = _content.get();\n+                if (LOG.isDebugEnabled())\n+                    LOG.debug(\"eof with current content: {}\", c);\n+                if (c instanceof DemandingContent)\n+                {\n+                    if (_content.compareAndSet(c, EOF))\n+                    {\n+                        if (LOG.isDebugEnabled())\n+                            LOG.debug(\"replacing current content with special EOF succeeded\");\n+                        return;\n+                    }\n+                }\n+                else if (c == null)\n+                {\n+                    if (_content.compareAndSet(null, EOF))\n+                    {\n+                        if (LOG.isDebugEnabled())\n+                            LOG.debug(\"replacing null content with special EOF succeeded\");\n+                        return;\n+                    }\n+                }\n+                else if (c.isEof())\n+                {\n+                    if (LOG.isDebugEnabled())\n+                        LOG.debug(\"current content already is EOF\");\n+                    return;\n+                }\n+                else if (c.remaining() == 0)\n+                {\n+                    if (_content.compareAndSet(c, EOF))\n+                    {\n+                        if (LOG.isDebugEnabled())\n+                            LOG.debug(\"replacing current content with special EOF succeeded\");\n+                        return;\n+                    }\n+                }\n+                else\n+                {\n+                    // onTrailer() needs this branch,\n+                    // covered by HttpTrailersTest.testRequestTrailersWithContent.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cba85b58aee7b8969746dc37619749d4b4874f36"}, "originalPosition": 347}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjY4NjY1Ng==", "bodyText": "Fix end of sentence.", "url": "https://github.com/eclipse/jetty.project/pull/4556#discussion_r516686656", "createdAt": "2020-11-03T14:01:24Z", "author": {"login": "sbordet"}, "path": "jetty-server/src/main/java/org/eclipse/jetty/server/AsyncContentProducer.java", "diffHunk": "@@ -0,0 +1,352 @@\n+//\n+// ========================================================================\n+// Copyright (c) 1995-2020 Mort Bay Consulting Pty Ltd and others.\n+//\n+// This program and the accompanying materials are made available under\n+// the terms of the Eclipse Public License 2.0 which is available at\n+// https://www.eclipse.org/legal/epl-2.0\n+//\n+// This Source Code may also be made available under the following\n+// Secondary Licenses when the conditions for such availability set\n+// forth in the Eclipse Public License, v. 2.0 are satisfied:\n+// the Apache License v2.0 which is available at\n+// https://www.apache.org/licenses/LICENSE-2.0\n+//\n+// SPDX-License-Identifier: EPL-2.0 OR Apache-2.0\n+// ========================================================================\n+//\n+\n+package org.eclipse.jetty.server;\n+\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jetty.http.BadMessageException;\n+import org.eclipse.jetty.http.HttpStatus;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Non-blocking {@link ContentProducer} implementation. Calling {@link #nextContent()} will never block\n+ * but will return null when there is no available content but will never return block.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cba85b58aee7b8969746dc37619749d4b4874f36"}, "originalPosition": 30}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjY4ODAxNA==", "bodyText": "Javadocs.", "url": "https://github.com/eclipse/jetty.project/pull/4556#discussion_r516688014", "createdAt": "2020-11-03T14:03:22Z", "author": {"login": "sbordet"}, "path": "jetty-server/src/main/java/org/eclipse/jetty/server/HttpChannel.java", "diffHunk": "@@ -729,11 +733,15 @@ public boolean onRequestComplete()\n     {\n         if (LOG.isDebugEnabled())\n             LOG.debug(\"onRequestComplete {}\", this);\n-        boolean result = _request.getHttpInput().eof();\n+        boolean result = eof();\n         _combinedListener.onRequestEnd(_request);\n         return result;\n     }\n \n+    public abstract boolean failed(Throwable x);\n+\n+    protected abstract boolean eof();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cba85b58aee7b8969746dc37619749d4b4874f36"}, "originalPosition": 111}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjY5NDk2Mw==", "bodyText": "Both HTTP/2 and HTTP/1.1 wrap an existing content, so it's worth having a proper wrapper class with the ability to specify eof, rather than anonymous classes -- they will also print better when DEBUG is enabled.", "url": "https://github.com/eclipse/jetty.project/pull/4556#discussion_r516694963", "createdAt": "2020-11-03T14:12:47Z", "author": {"login": "sbordet"}, "path": "jetty-server/src/main/java/org/eclipse/jetty/server/HttpChannelOverHttp.java", "diffHunk": "@@ -147,12 +241,94 @@ public void earlyEOF()\n         _httpConnection.getGenerator().setPersistent(false);\n         // If we have no request yet, just close\n         if (_metadata == null)\n+        {\n             _httpConnection.close();\n-        else if (onEarlyEOF() || _delayedForContent)\n+        }\n+        else\n         {\n-            _delayedForContent = false;\n-            handle();\n+            markEarlyEOF();\n+            if (_delayedForContent)\n+            {\n+                _delayedForContent = false;\n+                handle();\n+            }\n+        }\n+    }\n+\n+    private void markEarlyEOF()\n+    {\n+        if (LOG.isDebugEnabled())\n+            LOG.debug(\"received early EOF, content = {}\", _content);\n+        EofException failure = new EofException(\"Early EOF\");\n+        if (_content != null)\n+            _content.failed(failure);\n+        _content = new HttpInput.ErrorContent(failure);\n+    }\n+\n+    @Override\n+    protected boolean eof()\n+    {\n+        if (LOG.isDebugEnabled())\n+            LOG.debug(\"received EOF, content = {}\", _content);\n+        if (_content == null)\n+        {\n+            _content = EOF;\n+        }\n+        else\n+        {\n+            HttpInput.Content c = _content;\n+            _content = new HttpInput.Content(c.getByteBuffer())", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cba85b58aee7b8969746dc37619749d4b4874f36"}, "originalPosition": 192}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "cba85b58aee7b8969746dc37619749d4b4874f36", "author": {"user": {"login": "lorban", "name": "Ludovic Orban"}}, "url": "https://github.com/eclipse/jetty.project/commit/cba85b58aee7b8969746dc37619749d4b4874f36", "committedDate": "2020-10-29T08:21:14Z", "message": "Get rid of addContent() by making produceContent() return Content instead.\nMake EOF and errors be special content.\nTransition to a much simplified FSM by using the needContent() / produceContent() model.\nImplement blocking on top of async, this way there is only one FSM.\n(Milestone 7)\n\nSigned-off-by: Ludovic Orban <lorban@bitronix.be>"}, "afterCommit": {"oid": "07c26e66b1ea4a73933b54052a1b4501dbae11b8", "author": {"user": {"login": "lorban", "name": "Ludovic Orban"}}, "url": "https://github.com/eclipse/jetty.project/commit/07c26e66b1ea4a73933b54052a1b4501dbae11b8", "committedDate": "2020-11-03T14:20:15Z", "message": "Get rid of addContent() by making produceContent() return Content instead.\nMake EOF and errors be special content.\nTransition to a much simplified FSM by using the needContent() / produceContent() model.\nImplement blocking on top of async, this way there is only one FSM.\n(Milestone 7)\n\nSigned-off-by: Ludovic Orban <lorban@bitronix.be>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIyNjMxNDcz", "url": "https://github.com/eclipse/jetty.project/pull/4556#pullrequestreview-522631473", "createdAt": "2020-11-03T15:47:39Z", "commit": {"oid": "07c26e66b1ea4a73933b54052a1b4501dbae11b8"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5a24c8dd174689b194e656b282242debc8e5e3bb", "author": {"user": {"login": "lorban", "name": "Ludovic Orban"}}, "url": "https://github.com/eclipse/jetty.project/commit/5a24c8dd174689b194e656b282242debc8e5e3bb", "committedDate": "2020-11-03T16:30:24Z", "message": "HTTP and FCGI pass all tests (Milestone 1)\n\nSigned-off-by: Ludovic Orban <lorban@bitronix.be>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "946f334810cf58cdca34513d69c059e1119188e3", "author": {"user": {"login": "lorban", "name": "Ludovic Orban"}}, "url": "https://github.com/eclipse/jetty.project/commit/946f334810cf58cdca34513d69c059e1119188e3", "committedDate": "2020-11-03T16:30:25Z", "message": "http2 impl (Milestone 2)\n\nSigned-off-by: Ludovic Orban <lorban@bitronix.be>"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 579, "cost": 1, "resetAt": "2021-11-01T13:51:04Z"}}}