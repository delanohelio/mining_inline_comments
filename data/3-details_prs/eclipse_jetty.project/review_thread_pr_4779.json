{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDAzODk0ODM1", "number": 4779, "reviewThreads": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wM1QyMDowMjowMlrOD4zwjA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wM1QyMDowNzowNVrOD4zydQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYwODk0ODYwOnYy", "diffSide": "RIGHT", "path": "jetty-servlets/src/test/java/org/eclipse/jetty/servlets/AbstractGzipTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wM1QyMDowMjowMlrOGPvCNw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wM1QyMDowMjowMlrOGPvCNw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTE1MjQzOQ==", "bodyText": "Remove static  block -- just do DEFAULT_OUTPUT_BUFFER_SIZE = new HttpConfiguration().getOutputBufferSize()", "url": "https://github.com/eclipse/jetty.project/pull/4779#discussion_r419152439", "createdAt": "2020-05-03T20:02:02Z", "author": {"login": "sbordet"}, "path": "jetty-servlets/src/test/java/org/eclipse/jetty/servlets/AbstractGzipTest.java", "diffHunk": "@@ -0,0 +1,165 @@\n+//\n+// ========================================================================\n+// Copyright (c) 1995-2020 Mort Bay Consulting Pty Ltd and others.\n+//\n+// This program and the accompanying materials are made available under\n+// the terms of the Eclipse Public License 2.0 which is available at\n+// https://www.eclipse.org/legal/epl-2.0\n+//\n+// This Source Code may also be made available under the following\n+// Secondary Licenses when the conditions for such availability set\n+// forth in the Eclipse Public License, v. 2.0 are satisfied:\n+// the Apache License v2.0 which is available at\n+// https://www.apache.org/licenses/LICENSE-2.0\n+//\n+// SPDX-License-Identifier: EPL-2.0 OR Apache-2.0\n+// ========================================================================\n+//\n+\n+package org.eclipse.jetty.servlets;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.FilterInputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.StandardOpenOption;\n+import java.security.DigestOutputStream;\n+import java.security.MessageDigest;\n+import java.security.NoSuchAlgorithmException;\n+import java.util.Locale;\n+import java.util.zip.GZIPInputStream;\n+import java.util.zip.Inflater;\n+import java.util.zip.InflaterInputStream;\n+\n+import org.eclipse.jetty.http.tools.HttpTester;\n+import org.eclipse.jetty.server.HttpConfiguration;\n+import org.eclipse.jetty.server.handler.gzip.GzipHandler;\n+import org.eclipse.jetty.toolchain.test.FS;\n+import org.eclipse.jetty.toolchain.test.IO;\n+import org.eclipse.jetty.toolchain.test.MavenTestingUtils;\n+import org.eclipse.jetty.util.TypeUtil;\n+\n+import static java.nio.charset.StandardCharsets.UTF_8;\n+\n+public abstract class AbstractGzipTest\n+{\n+    protected static final int DEFAULT_OUTPUT_BUFFER_SIZE;\n+\n+    static\n+    {\n+        HttpConfiguration defaultHttp = new HttpConfiguration();\n+        DEFAULT_OUTPUT_BUFFER_SIZE = defaultHttp.getOutputBufferSize();\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f9a215f18d634786b9409428fc1b9af1ce164c80"}, "originalPosition": 55}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYwODk1MTc5OnYy", "diffSide": "RIGHT", "path": "jetty-servlets/src/test/java/org/eclipse/jetty/servlets/GzipDefaultServletDeferredContentTypeTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wM1QyMDowNToyNFrOGPvDxQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNFQxNDoyNTo0NFrOGQC0gg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTE1MjgzNw==", "bodyText": "Why it's all commented out?", "url": "https://github.com/eclipse/jetty.project/pull/4779#discussion_r419152837", "createdAt": "2020-05-03T20:05:24Z", "author": {"login": "sbordet"}, "path": "jetty-servlets/src/test/java/org/eclipse/jetty/servlets/GzipDefaultServletDeferredContentTypeTest.java", "diffHunk": "@@ -0,0 +1,106 @@\n+//\n+// ========================================================================\n+// Copyright (c) 1995-2020 Mort Bay Consulting Pty Ltd and others.\n+//\n+// This program and the accompanying materials are made available under\n+// the terms of the Eclipse Public License 2.0 which is available at\n+// https://www.eclipse.org/legal/epl-2.0\n+//\n+// This Source Code may also be made available under the following\n+// Secondary Licenses when the conditions for such availability set\n+// forth in the Eclipse Public License, v. 2.0 are satisfied:\n+// the Apache License v2.0 which is available at\n+// https://www.apache.org/licenses/LICENSE-2.0\n+//\n+// SPDX-License-Identifier: EPL-2.0 OR Apache-2.0\n+// ========================================================================\n+//\n+\n+package org.eclipse.jetty.servlets;\n+\n+/**\n+ * GzipHandler setting of headers when reset and/or not compressed.\n+ *\n+ * The GzipHandler now sets deferred headers (content-length and etag) when it decides not to commit.\n+ * Also does not allow a reset after a decision to commit\n+ *\n+ * Originally from http://bugs.eclipse.org/408909\n+ */\n+public class GzipDefaultServletDeferredContentTypeTest extends AbstractGzipTest\n+{\n+    /*\n+    public static class AddDefaultServletCustomizer extends ServerHandlerCustomizer\n+    {\n+        @Override\n+        public Handler customize(ServletContextHandler servletContextHandler, Class<? extends Servlet> servletClass)\n+        {\n+            ServletHolder holder = new ServletHolder(\"default\", servletClass);\n+            servletContextHandler.addServlet(holder, \"/\");\n+            return servletContextHandler;\n+        }\n+    }\n+\n+    @Test\n+    public void testIsNotGzipCompressedByDeferredContentType() throws Exception\n+    {\n+        createServer(new AddDefaultServletCustomizer(), DeferredGetDefaultServlet.class);\n+\n+        int fileSize = DEFAULT_OUTPUT_BUFFER_SIZE * 4;\n+\n+        Path file = createFile(\"file.mp3.deferred\", fileSize);\n+        String expectedSha1Sum = Sha1Sum.calculate(file);\n+\n+        server.start();\n+\n+        // Setup request\n+        HttpTester.Request request = HttpTester.newRequest();\n+        request.setMethod(\"GET\");\n+        request.setVersion(HttpVersion.HTTP_1_1);\n+        request.setHeader(\"Host\", \"tester\");\n+        request.setHeader(\"Connection\", \"close\");\n+        request.setHeader(\"Accept-Encoding\", \"gzip\");\n+        request.setURI(\"/context/file.mp3.deferred\");\n+\n+        // Issue request\n+        ByteBuffer rawResponse = localConnector.getResponse(request.generate(), 5, TimeUnit.SECONDS);\n+\n+        // Parse response\n+        HttpTester.Response response = HttpTester.parseResponse(rawResponse);\n+\n+        assertThat(\"Response status\", response.getStatus(), is(HttpStatus.OK_200));\n+\n+        // Response Content-Encoding check\n+        assertThat(\"Response[Content-Encoding]\", response.get(\"Content-Encoding\"), not(containsString(\"gzip\")));\n+\n+        // Response Vary check\n+        assertThat(\"Response[Vary]\", response.get(\"Vary\"), is(emptyOrNullString()));\n+\n+        // Response Content checks\n+        UncompressedMetadata metadata = parseResponseContent(response);\n+        assertThat(\"(Uncompressed) Content Length\", metadata.uncompressedSize, is(fileSize));\n+        assertThat(\"(Uncompressed) Content Hash\", metadata.uncompressedSha1Sum, is(expectedSha1Sum));\n+    }\n+\n+    public static class DeferredGetDefaultServlet extends DefaultServlet\n+    {\n+        public DeferredGetDefaultServlet()\n+        {\n+            super();\n+        }\n+\n+        @Override\n+        public void service(HttpServletRequest req, HttpServletResponse resp) throws IOException, ServletException\n+        {\n+            String uri = req.getRequestURI();\n+            if (uri.endsWith(\".deferred\"))\n+            {\n+                // System.err.println(\"type for \"+uri.substring(0,uri.length()-9)+\" is \"+getServletContext().getMimeType(uri.substring(0,uri.length()-9)));\n+                resp.setContentType(getServletContext().getMimeType(uri.substring(0, uri.length() - 9)));\n+            }\n+\n+            doGet(req, resp);\n+        }\n+    }\n+\n+     */", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f9a215f18d634786b9409428fc1b9af1ce164c80"}, "originalPosition": 105}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTQ3NjYxMA==", "bodyText": "I need to fix this one.", "url": "https://github.com/eclipse/jetty.project/pull/4779#discussion_r419476610", "createdAt": "2020-05-04T14:25:44Z", "author": {"login": "joakime"}, "path": "jetty-servlets/src/test/java/org/eclipse/jetty/servlets/GzipDefaultServletDeferredContentTypeTest.java", "diffHunk": "@@ -0,0 +1,106 @@\n+//\n+// ========================================================================\n+// Copyright (c) 1995-2020 Mort Bay Consulting Pty Ltd and others.\n+//\n+// This program and the accompanying materials are made available under\n+// the terms of the Eclipse Public License 2.0 which is available at\n+// https://www.eclipse.org/legal/epl-2.0\n+//\n+// This Source Code may also be made available under the following\n+// Secondary Licenses when the conditions for such availability set\n+// forth in the Eclipse Public License, v. 2.0 are satisfied:\n+// the Apache License v2.0 which is available at\n+// https://www.apache.org/licenses/LICENSE-2.0\n+//\n+// SPDX-License-Identifier: EPL-2.0 OR Apache-2.0\n+// ========================================================================\n+//\n+\n+package org.eclipse.jetty.servlets;\n+\n+/**\n+ * GzipHandler setting of headers when reset and/or not compressed.\n+ *\n+ * The GzipHandler now sets deferred headers (content-length and etag) when it decides not to commit.\n+ * Also does not allow a reset after a decision to commit\n+ *\n+ * Originally from http://bugs.eclipse.org/408909\n+ */\n+public class GzipDefaultServletDeferredContentTypeTest extends AbstractGzipTest\n+{\n+    /*\n+    public static class AddDefaultServletCustomizer extends ServerHandlerCustomizer\n+    {\n+        @Override\n+        public Handler customize(ServletContextHandler servletContextHandler, Class<? extends Servlet> servletClass)\n+        {\n+            ServletHolder holder = new ServletHolder(\"default\", servletClass);\n+            servletContextHandler.addServlet(holder, \"/\");\n+            return servletContextHandler;\n+        }\n+    }\n+\n+    @Test\n+    public void testIsNotGzipCompressedByDeferredContentType() throws Exception\n+    {\n+        createServer(new AddDefaultServletCustomizer(), DeferredGetDefaultServlet.class);\n+\n+        int fileSize = DEFAULT_OUTPUT_BUFFER_SIZE * 4;\n+\n+        Path file = createFile(\"file.mp3.deferred\", fileSize);\n+        String expectedSha1Sum = Sha1Sum.calculate(file);\n+\n+        server.start();\n+\n+        // Setup request\n+        HttpTester.Request request = HttpTester.newRequest();\n+        request.setMethod(\"GET\");\n+        request.setVersion(HttpVersion.HTTP_1_1);\n+        request.setHeader(\"Host\", \"tester\");\n+        request.setHeader(\"Connection\", \"close\");\n+        request.setHeader(\"Accept-Encoding\", \"gzip\");\n+        request.setURI(\"/context/file.mp3.deferred\");\n+\n+        // Issue request\n+        ByteBuffer rawResponse = localConnector.getResponse(request.generate(), 5, TimeUnit.SECONDS);\n+\n+        // Parse response\n+        HttpTester.Response response = HttpTester.parseResponse(rawResponse);\n+\n+        assertThat(\"Response status\", response.getStatus(), is(HttpStatus.OK_200));\n+\n+        // Response Content-Encoding check\n+        assertThat(\"Response[Content-Encoding]\", response.get(\"Content-Encoding\"), not(containsString(\"gzip\")));\n+\n+        // Response Vary check\n+        assertThat(\"Response[Vary]\", response.get(\"Vary\"), is(emptyOrNullString()));\n+\n+        // Response Content checks\n+        UncompressedMetadata metadata = parseResponseContent(response);\n+        assertThat(\"(Uncompressed) Content Length\", metadata.uncompressedSize, is(fileSize));\n+        assertThat(\"(Uncompressed) Content Hash\", metadata.uncompressedSha1Sum, is(expectedSha1Sum));\n+    }\n+\n+    public static class DeferredGetDefaultServlet extends DefaultServlet\n+    {\n+        public DeferredGetDefaultServlet()\n+        {\n+            super();\n+        }\n+\n+        @Override\n+        public void service(HttpServletRequest req, HttpServletResponse resp) throws IOException, ServletException\n+        {\n+            String uri = req.getRequestURI();\n+            if (uri.endsWith(\".deferred\"))\n+            {\n+                // System.err.println(\"type for \"+uri.substring(0,uri.length()-9)+\" is \"+getServletContext().getMimeType(uri.substring(0,uri.length()-9)));\n+                resp.setContentType(getServletContext().getMimeType(uri.substring(0, uri.length() - 9)));\n+            }\n+\n+            doGet(req, resp);\n+        }\n+    }\n+\n+     */", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTE1MjgzNw=="}, "originalCommit": {"oid": "f9a215f18d634786b9409428fc1b9af1ce164c80"}, "originalPosition": 105}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYwODk1MzQ5OnYy", "diffSide": "RIGHT", "path": "jetty-servlets/src/test/java/org/eclipse/jetty/servlets/GzipContentLengthTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wM1QyMDowNzowNVrOGPvEnA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNFQxNDoyNTo1OVrOGQC1WQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTE1MzA1Mg==", "bodyText": "Fix TODOs?", "url": "https://github.com/eclipse/jetty.project/pull/4779#discussion_r419153052", "createdAt": "2020-05-03T20:07:05Z", "author": {"login": "sbordet"}, "path": "jetty-servlets/src/test/java/org/eclipse/jetty/servlets/GzipContentLengthTest.java", "diffHunk": "@@ -42,317 +49,180 @@\n import static org.hamcrest.Matchers.not;\n \n /**\n- * Test the GzipHandler support for Content-Length setting variations.\n- *\n- * @see <a href=\"Eclipse Bug 354014\">http://bugs.eclipse.org/354014</a>\n+ * Test the {@code GzipHandler} support for the various ways that an App can set {@code Content-Length}.\n  */\n-@ExtendWith(WorkDirExtension.class)\n-public class GzipContentLengthTest\n+public class GzipContentLengthTest extends AbstractGzipTest\n {\n-    public WorkDir workDir;\n-\n-    private static final HttpConfiguration defaultHttp = new HttpConfiguration();\n-    private static final int LARGE = defaultHttp.getOutputBufferSize() * 8;\n-    private static final int MEDIUM = defaultHttp.getOutputBufferSize();\n-    private static final int SMALL = defaultHttp.getOutputBufferSize() / 4;\n-    private static final int TINY = GzipHandler.DEFAULT_MIN_GZIP_SIZE / 2;\n-    private static final boolean EXPECT_COMPRESSED = true;\n-\n-    public static Stream<Arguments> scenarios()\n+    enum GzipMode\n     {\n-        List<Scenario> ret = new ArrayList<>();\n-\n-        ret.add(new Scenario(0, \"empty.txt\", !EXPECT_COMPRESSED));\n-        ret.add(new Scenario(TINY, \"file-tiny.txt\", !EXPECT_COMPRESSED));\n-        ret.add(new Scenario(SMALL, \"file-small.txt\", EXPECT_COMPRESSED));\n-        ret.add(new Scenario(SMALL, \"file-small.mp3\", !EXPECT_COMPRESSED));\n-        ret.add(new Scenario(MEDIUM, \"file-med.txt\", EXPECT_COMPRESSED));\n-        ret.add(new Scenario(MEDIUM, \"file-medium.mp3\", !EXPECT_COMPRESSED));\n-        ret.add(new Scenario(LARGE, \"file-large.txt\", EXPECT_COMPRESSED));\n-        ret.add(new Scenario(LARGE, \"file-large.mp3\", !EXPECT_COMPRESSED));\n-\n-        return ret.stream().map(Arguments::of);\n+        INTERNAL, EXTERNAL\n     }\n \n-    private void testWithGzip(Scenario scenario, Class<? extends TestDirContentServlet> contentServlet) throws Exception\n+    public static Stream<Arguments> scenarios()\n     {\n-        GzipTester tester = new GzipTester(workDir.getPath(), GzipHandler.GZIP);\n-\n-        // Add AsyncGzip Configuration\n-        tester.getGzipHandler().setIncludedMimeTypes(\"text/plain\");\n-        tester.getGzipHandler().setIncludedPaths(\"*.txt\", \"*.mp3\");\n-\n-        // Add content servlet\n-        tester.setContentServlet(contentServlet);\n-\n-        try\n+        // The list of servlets that implement various content sending behaviors\n+        // some behaviors are more sane then others, but they are all real world scenarios\n+        // that we have seen or had issues reported against Jetty.\n+        List<Class<? extends AbstractFileContentServlet>> servlets = new ArrayList<>();\n+\n+        // AsyncContext create -> timeout -> onTimeout -> write-response -> complete\n+        servlets.add(AsyncTimeoutCompleteWrite.Default.class);\n+        servlets.add(AsyncTimeoutCompleteWrite.Passed.class);\n+        // AsyncContext create -> timeout -> onTimeout -> dispatch -> write-response\n+        servlets.add(AsyncTimeoutDispatchWrite.Default.class);\n+        servlets.add(AsyncTimeoutDispatchWrite.Passed.class);\n+        // AsyncContext create -> no-timeout -> scheduler.schedule -> dispatch -> write-response\n+        servlets.add(AsyncScheduledDispatchWrite.Default.class);\n+        servlets.add(AsyncScheduledDispatchWrite.Passed.class);\n+\n+        // HttpOutput usage scenario from http://bugs.eclipse.org/450873\n+        // 1. getOutputStream()\n+        // 2. setHeader(content-type)\n+        // 3. setHeader(content-length)\n+        // 4. (unwrapped) HttpOutput.write(ByteBuffer)\n+        servlets.add(HttpOutputWriteFileContentServlet.class);\n+\n+        // The following blocking scenarios are from http://bugs.eclipse.org/354014\n+        // Blocking\n+        // 1. setHeader(content-length)\n+        // 2. getOutputStream()\n+        // 3. setHeader(content-type)\n+        // 4. outputStream.write()\n+        servlets.add(BlockingServletLengthStreamTypeWrite.class);\n+        // Blocking\n+        // 1. setHeader(content-length)\n+        // 2. setHeader(content-type)\n+        // 3. getOutputStream()\n+        // 4. outputStream.write()\n+        servlets.add(BlockingServletLengthTypeStreamWrite.class);\n+        // Blocking\n+        // 1. getOutputStream()\n+        // 2. setHeader(content-length)\n+        // 3. setHeader(content-type)\n+        // 4. outputStream.write()\n+        servlets.add(BlockingServletStreamLengthTypeWrite.class);\n+        // Blocking\n+        // 1. getOutputStream()\n+        // 2. setHeader(content-length)\n+        // 3. setHeader(content-type)\n+        // 4. outputStream.write() (with frequent response flush)\n+        servlets.add(BlockingServletStreamLengthTypeWriteWithFlush.class);\n+        // Blocking\n+        // 1. getOutputStream()\n+        // 2. setHeader(content-type)\n+        // 3. setHeader(content-length)\n+        // 4. outputStream.write()\n+        servlets.add(BlockingServletStreamTypeLengthWrite.class);\n+        // Blocking\n+        // 1. setHeader(content-type)\n+        // 2. setHeader(content-length)\n+        // 3. getOutputStream()\n+        // 4. outputStream.write()\n+        servlets.add(BlockingServletTypeLengthStreamWrite.class);\n+        // Blocking\n+        // 1. setHeader(content-type)\n+        // 2. getOutputStream()\n+        // 3. setHeader(content-length)\n+        // 4. outputStream.write()\n+        servlets.add(BlockingServletTypeStreamLengthWrite.class);\n+\n+        List<Arguments> scenarios = new ArrayList<>();\n+\n+        for (Class<? extends Servlet> servlet : servlets)\n         {\n-            String testFilename = String.format(\"%s-%s\", contentServlet.getSimpleName(), scenario.fileName);\n-            File testFile = tester.prepareServerFile(testFilename, scenario.fileSize);\n-\n-            tester.start();\n-\n-            HttpTester.Response response = tester.executeRequest(\"GET\", \"/context/\" + testFile.getName(), 5, TimeUnit.SECONDS);\n-\n-            if (response.getStatus() != 200)\n-                System.err.println(\"DANG!!!! \" + response);\n-\n-            assertThat(\"Response status\", response.getStatus(), is(HttpStatus.OK_200));\n-\n-            if (scenario.expectCompressed)\n-            {\n-                // Must be gzip compressed\n-                assertThat(\"Content-Encoding\", response.get(\"Content-Encoding\"), containsString(GzipHandler.GZIP));\n-            }\n-            else\n+            for (GzipMode gzipMode : GzipMode.values())\n             {\n-                assertThat(\"Content-Encoding\", response.get(\"Content-Encoding\"), not(containsString(GzipHandler.GZIP)));\n+                // Not compressible (not large enough)\n+                scenarios.add(Arguments.of(gzipMode, servlet, 0, \"empty.txt\", false));\n+                scenarios.add(Arguments.of(gzipMode, servlet, GzipHandler.DEFAULT_MIN_GZIP_SIZE / 2, \"file-tiny.txt\", false));\n+\n+                // Compressible.\n+                scenarios.add(Arguments.of(gzipMode, servlet, DEFAULT_OUTPUT_BUFFER_SIZE / 2, \"file-small.txt\", true));\n+                scenarios.add(Arguments.of(gzipMode, servlet, DEFAULT_OUTPUT_BUFFER_SIZE, \"file-medium.txt\", true));\n+                scenarios.add(Arguments.of(gzipMode, servlet, DEFAULT_OUTPUT_BUFFER_SIZE * 4, \"file-large.txt\", true));\n+\n+                // Not compressible (not a matching Content-Type)\n+                scenarios.add(Arguments.of(gzipMode, servlet, DEFAULT_OUTPUT_BUFFER_SIZE / 2, \"file-small.mp3\", false));\n+                scenarios.add(Arguments.of(gzipMode, servlet, DEFAULT_OUTPUT_BUFFER_SIZE, \"file-medium.mp3\", false));\n+                scenarios.add(Arguments.of(gzipMode, servlet, DEFAULT_OUTPUT_BUFFER_SIZE * 4, \"file-large.mp3\", false));\n             }\n-\n-            // Uncompressed content Size\n-            ContentMetadata content = tester.getResponseMetadata(response);\n-            assertThat(\"(Uncompressed) Content Length\", content.size, is((long)scenario.fileSize));\n         }\n-        finally\n-        {\n-            tester.stop();\n-        }\n-    }\n \n-    /**\n-     * Test with content servlet that does:\n-     * AsyncContext create -> timeout -> onTimeout -> write-response -> complete\n-     *\n-     * @throws Exception on test failure\n-     */\n-    @ParameterizedTest\n-    @MethodSource(\"scenarios\")\n-    public void testAsyncTimeoutCompleteWriteDefault(Scenario scenario) throws Exception\n-    {\n-        testWithGzip(scenario, AsyncTimeoutCompleteWrite.Default.class);\n-    }\n-\n-    /**\n-     * Test with content servlet that does:\n-     * AsyncContext create -> timeout -> onTimeout -> write-response -> complete\n-     *\n-     * @throws Exception on test failure\n-     */\n-    @ParameterizedTest\n-    @MethodSource(\"scenarios\")\n-    public void testAsyncTimeoutCompleteWritePassed(Scenario scenario) throws Exception\n-    {\n-        testWithGzip(scenario, AsyncTimeoutCompleteWrite.Passed.class);\n+        return scenarios.stream();\n     }\n \n-    /**\n-     * Test with content servlet that does:\n-     * AsyncContext create -> timeout -> onTimeout -> dispatch -> write-response\n-     *\n-     * @throws Exception on test failure\n-     */\n-    @ParameterizedTest\n-    @MethodSource(\"scenarios\")\n-    public void testAsyncTimeoutDispatchWriteDefault(Scenario scenario) throws Exception\n-    {\n-        testWithGzip(scenario, AsyncTimeoutDispatchWrite.Default.class);\n-    }\n-\n-    /**\n-     * Test with content servlet that does:\n-     * AsyncContext create -> timeout -> onTimeout -> dispatch -> write-response\n-     *\n-     * @throws Exception on test failure\n-     */\n-    @ParameterizedTest\n-    @MethodSource(\"scenarios\")\n-    public void testAsyncTimeoutDispatchWritePassed(Scenario scenario) throws Exception\n-    {\n-        testWithGzip(scenario, AsyncTimeoutDispatchWrite.Passed.class);\n-    }\n-\n-    /**\n-     * Test with content servlet that does:\n-     * AsyncContext create -> no-timeout -> scheduler.schedule -> dispatch -> write-response\n-     *\n-     * @throws Exception on test failure\n-     */\n-    @ParameterizedTest\n-    @MethodSource(\"scenarios\")\n-    public void testAsyncScheduledDispatchWriteDefault(Scenario scenario) throws Exception\n-    {\n-        testWithGzip(scenario, AsyncScheduledDispatchWrite.Default.class);\n-    }\n+    private Server server;\n \n-    /**\n-     * Test with content servlet that does:\n-     * AsyncContext create -> no-timeout -> scheduler.schedule -> dispatch -> write-response\n-     *\n-     * @throws Exception on test failure\n-     */\n-    @ParameterizedTest\n-    @MethodSource(\"scenarios\")\n-    public void testAsyncScheduledDispatchWritePassed(Scenario scenario) throws Exception\n+    @AfterEach\n+    public void stopServer()\n     {\n-        testWithGzip(scenario, AsyncScheduledDispatchWrite.Passed.class);\n+        LifeCycle.stop(server);\n     }\n \n-    /**\n-     * Test with content servlet that does:\n-     * 1) setHeader(content-length)\n-     * 2) getOutputStream()\n-     * 3) setHeader(content-type)\n-     * 4) outputStream.write()\n-     *\n-     * @throws Exception on test failure\n-     * @see <a href=\"http://bugs.eclipse.org/354014\">Eclipse Bug 354014</a>\n-     */\n     @ParameterizedTest\n     @MethodSource(\"scenarios\")\n-    public void testServletLengthStreamTypeWrite(Scenario scenario) throws Exception\n+    public void executeScenario(GzipMode gzipMode, Class<? extends Servlet> contentServlet, int fileSize, String fileName, boolean compressible) throws Exception\n     {\n-        testWithGzip(scenario, TestServletLengthStreamTypeWrite.class);\n-    }\n+        server = new Server();\n+        LocalConnector localConnector = new LocalConnector(server);\n+        server.addConnector(localConnector);\n \n-    /**\n-     * Test with content servlet that does:\n-     * 1) setHeader(content-length)\n-     * 2) setHeader(content-type)\n-     * 3) getOutputStream()\n-     * 4) outputStream.write()\n-     *\n-     * @throws Exception on test failure\n-     * @see <a href=\"http://bugs.eclipse.org/354014\">Eclipse Bug 354014</a>\n-     */\n-    @ParameterizedTest\n-    @MethodSource(\"scenarios\")\n-    public void testServletLengthTypeStreamWrite(Scenario scenario) throws Exception\n-    {\n-        testWithGzip(scenario, TestServletLengthTypeStreamWrite.class);\n-    }\n+        Path contextDir = workDir.resolve(\"context\");\n+        FS.ensureDirExists(contextDir);\n \n-    /**\n-     * Test with content servlet that does:\n-     * 1) getOutputStream()\n-     * 2) setHeader(content-length)\n-     * 3) setHeader(content-type)\n-     * 4) outputStream.write()\n-     *\n-     * @throws Exception on test failure\n-     * @see <a href=\"http://bugs.eclipse.org/354014\">Eclipse Bug 354014</a>\n-     */\n-    @ParameterizedTest\n-    @MethodSource(\"scenarios\")\n-    public void testServletStreamLengthTypeWrite(Scenario scenario) throws Exception\n-    {\n-        testWithGzip(scenario, TestServletStreamLengthTypeWrite.class);\n-    }\n+        ServletContextHandler servletContextHandler = new ServletContextHandler();\n+        servletContextHandler.setContextPath(\"/context\");\n+        servletContextHandler.setBaseResource(new PathResource(contextDir));\n+        servletContextHandler.addServlet(contentServlet, \"/*\");\n+        GzipHandler gzipHandler = new GzipHandler();\n \n-    /**\n-     * Test with content servlet that does:\n-     * 1) getOutputStream()\n-     * 2) setHeader(content-length)\n-     * 3) setHeader(content-type)\n-     * 4) outputStream.write() (with frequent response flush)\n-     *\n-     * @throws Exception on test failure\n-     * @see <a href=\"http://bugs.eclipse.org/354014\">Eclipse Bug 354014</a>\n-     */\n-    @ParameterizedTest\n-    @MethodSource(\"scenarios\")\n-    public void testServletStreamLengthTypeWriteWithFlush(Scenario scenario) throws Exception\n-    {\n-        testWithGzip(scenario, TestServletStreamLengthTypeWriteWithFlush.class);\n-    }\n+        switch (gzipMode)\n+        {\n+            case INTERNAL:\n+                servletContextHandler.insertHandler(gzipHandler);\n+                server.setHandler(servletContextHandler);\n+                break;\n+            case EXTERNAL:\n+                gzipHandler.setHandler(servletContextHandler);\n+                server.setHandler(gzipHandler);\n+                break;\n+        }\n \n-    /**\n-     * Test with content servlet that does:\n-     * 1) getOutputStream()\n-     * 2) setHeader(content-type)\n-     * 3) setHeader(content-length)\n-     * 4) outputStream.write()\n-     *\n-     * @throws Exception on test failure\n-     * @see <a href=\"http://bugs.eclipse.org/354014\">Eclipse Bug 354014</a>\n-     */\n-    @ParameterizedTest\n-    @MethodSource(\"scenarios\")\n-    public void testServletStreamTypeLengthWrite(Scenario scenario) throws Exception\n-    {\n-        testWithGzip(scenario, TestServletStreamTypeLengthWrite.class);\n-    }\n+        Path file = createFile(contextDir, fileName, fileSize);\n+        String expectedSha1Sum = Sha1Sum.calculate(file);\n \n-    /**\n-     * Test with content servlet that does:\n-     * 1) setHeader(content-type)\n-     * 2) setHeader(content-length)\n-     * 3) getOutputStream()\n-     * 4) outputStream.write()\n-     *\n-     * @throws Exception on test failure\n-     * @see <a href=\"http://bugs.eclipse.org/354014\">Eclipse Bug 354014</a>\n-     */\n-    @ParameterizedTest\n-    @MethodSource(\"scenarios\")\n-    public void testServletTypeLengthStreamWrite(Scenario scenario) throws Exception\n-    {\n-        testWithGzip(scenario, TestServletTypeLengthStreamWrite.class);\n-    }\n+        server.start();\n \n-    /**\n-     * Test with content servlet that does:\n-     * 1) setHeader(content-type)\n-     * 2) getOutputStream()\n-     * 3) setHeader(content-length)\n-     * 4) outputStream.write()\n-     *\n-     * @throws Exception on test failure\n-     * @see <a href=\"Eclipse Bug 354014\">http://bugs.eclipse.org/354014</a>\n-     */\n-    @ParameterizedTest\n-    @MethodSource(\"scenarios\")\n-    public void testServletTypeStreamLengthWrite(Scenario scenario) throws Exception\n-    {\n-        testWithGzip(scenario, TestServletTypeStreamLengthWrite.class);\n-    }\n+        // Setup request\n+        HttpTester.Request request = HttpTester.newRequest();\n+        request.setMethod(\"GET\");\n+        request.setVersion(HttpVersion.HTTP_1_1);\n+        request.setHeader(\"Host\", \"tester\");\n+        request.setHeader(\"Connection\", \"close\");\n+        request.setHeader(\"Accept-Encoding\", \"gzip\");\n+        request.setURI(\"/context/\" + file.getFileName().toString());\n \n-    /**\n-     * Test with content servlet that does:\n-     * 2) getOutputStream()\n-     * 1) setHeader(content-type)\n-     * 3) setHeader(content-length)\n-     * 4) (unwrapped) HttpOutput.write(ByteBuffer)\n-     *\n-     * This is done to demonstrate a bug with using HttpOutput.write()\n-     * while also using GzipFilter\n-     *\n-     * @throws Exception on test failure\n-     * @see <a href=\"http://bugs.eclipse.org/450873\">Eclipse Bug 450873</a>\n-     */\n-    @ParameterizedTest\n-    @MethodSource(\"scenarios\")\n-    public void testHttpOutputWrite(Scenario scenario) throws Exception\n-    {\n-        testWithGzip(scenario, TestServletBufferTypeLengthWrite.class);\n-    }\n+        // Issue request\n+        ByteBuffer rawResponse = localConnector.getResponse(request.generate(), 5, TimeUnit.SECONDS);\n \n-    public static class Scenario\n-    {\n-        final int fileSize;\n-        final String fileName;\n-        final boolean expectCompressed;\n+        // Parse response\n+        HttpTester.Response response = HttpTester.parseResponse(rawResponse);\n \n-        public Scenario(int fileSize, String fileName, boolean expectCompressed)\n-        {\n-            this.fileSize = fileSize;\n-            this.fileName = fileName;\n-            this.expectCompressed = expectCompressed;\n-        }\n+        assertThat(\"Response status\", response.getStatus(), is(HttpStatus.OK_200));\n \n-        @Override\n-        public String toString()\n+        // Response Content-Encoding check\n+        Matcher<String> contentEncodingMatcher = containsString(GzipHandler.GZIP);\n+        if (!compressible)\n         {\n-            return String.format(\"%s [%,d bytes, compressed=%b]\", fileName, fileSize, expectCompressed);\n+            contentEncodingMatcher = not(contentEncodingMatcher);\n         }\n+        assertThat(\"Content-Encoding\", response.get(\"Content-Encoding\"), contentEncodingMatcher);\n+\n+        // Response Content checks\n+        UncompressedMetadata metadata = parseResponseContent(response);\n+        assertThat(\"(Uncompressed) Content Length\", metadata.uncompressedSize, is(fileSize));\n+        // TODO: Assertions.assertArrayEquals();\n+        // TODO: compare bytes", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f9a215f18d634786b9409428fc1b9af1ce164c80"}, "originalPosition": 491}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTQ3NjgyNQ==", "bodyText": "I'll address these", "url": "https://github.com/eclipse/jetty.project/pull/4779#discussion_r419476825", "createdAt": "2020-05-04T14:25:59Z", "author": {"login": "joakime"}, "path": "jetty-servlets/src/test/java/org/eclipse/jetty/servlets/GzipContentLengthTest.java", "diffHunk": "@@ -42,317 +49,180 @@\n import static org.hamcrest.Matchers.not;\n \n /**\n- * Test the GzipHandler support for Content-Length setting variations.\n- *\n- * @see <a href=\"Eclipse Bug 354014\">http://bugs.eclipse.org/354014</a>\n+ * Test the {@code GzipHandler} support for the various ways that an App can set {@code Content-Length}.\n  */\n-@ExtendWith(WorkDirExtension.class)\n-public class GzipContentLengthTest\n+public class GzipContentLengthTest extends AbstractGzipTest\n {\n-    public WorkDir workDir;\n-\n-    private static final HttpConfiguration defaultHttp = new HttpConfiguration();\n-    private static final int LARGE = defaultHttp.getOutputBufferSize() * 8;\n-    private static final int MEDIUM = defaultHttp.getOutputBufferSize();\n-    private static final int SMALL = defaultHttp.getOutputBufferSize() / 4;\n-    private static final int TINY = GzipHandler.DEFAULT_MIN_GZIP_SIZE / 2;\n-    private static final boolean EXPECT_COMPRESSED = true;\n-\n-    public static Stream<Arguments> scenarios()\n+    enum GzipMode\n     {\n-        List<Scenario> ret = new ArrayList<>();\n-\n-        ret.add(new Scenario(0, \"empty.txt\", !EXPECT_COMPRESSED));\n-        ret.add(new Scenario(TINY, \"file-tiny.txt\", !EXPECT_COMPRESSED));\n-        ret.add(new Scenario(SMALL, \"file-small.txt\", EXPECT_COMPRESSED));\n-        ret.add(new Scenario(SMALL, \"file-small.mp3\", !EXPECT_COMPRESSED));\n-        ret.add(new Scenario(MEDIUM, \"file-med.txt\", EXPECT_COMPRESSED));\n-        ret.add(new Scenario(MEDIUM, \"file-medium.mp3\", !EXPECT_COMPRESSED));\n-        ret.add(new Scenario(LARGE, \"file-large.txt\", EXPECT_COMPRESSED));\n-        ret.add(new Scenario(LARGE, \"file-large.mp3\", !EXPECT_COMPRESSED));\n-\n-        return ret.stream().map(Arguments::of);\n+        INTERNAL, EXTERNAL\n     }\n \n-    private void testWithGzip(Scenario scenario, Class<? extends TestDirContentServlet> contentServlet) throws Exception\n+    public static Stream<Arguments> scenarios()\n     {\n-        GzipTester tester = new GzipTester(workDir.getPath(), GzipHandler.GZIP);\n-\n-        // Add AsyncGzip Configuration\n-        tester.getGzipHandler().setIncludedMimeTypes(\"text/plain\");\n-        tester.getGzipHandler().setIncludedPaths(\"*.txt\", \"*.mp3\");\n-\n-        // Add content servlet\n-        tester.setContentServlet(contentServlet);\n-\n-        try\n+        // The list of servlets that implement various content sending behaviors\n+        // some behaviors are more sane then others, but they are all real world scenarios\n+        // that we have seen or had issues reported against Jetty.\n+        List<Class<? extends AbstractFileContentServlet>> servlets = new ArrayList<>();\n+\n+        // AsyncContext create -> timeout -> onTimeout -> write-response -> complete\n+        servlets.add(AsyncTimeoutCompleteWrite.Default.class);\n+        servlets.add(AsyncTimeoutCompleteWrite.Passed.class);\n+        // AsyncContext create -> timeout -> onTimeout -> dispatch -> write-response\n+        servlets.add(AsyncTimeoutDispatchWrite.Default.class);\n+        servlets.add(AsyncTimeoutDispatchWrite.Passed.class);\n+        // AsyncContext create -> no-timeout -> scheduler.schedule -> dispatch -> write-response\n+        servlets.add(AsyncScheduledDispatchWrite.Default.class);\n+        servlets.add(AsyncScheduledDispatchWrite.Passed.class);\n+\n+        // HttpOutput usage scenario from http://bugs.eclipse.org/450873\n+        // 1. getOutputStream()\n+        // 2. setHeader(content-type)\n+        // 3. setHeader(content-length)\n+        // 4. (unwrapped) HttpOutput.write(ByteBuffer)\n+        servlets.add(HttpOutputWriteFileContentServlet.class);\n+\n+        // The following blocking scenarios are from http://bugs.eclipse.org/354014\n+        // Blocking\n+        // 1. setHeader(content-length)\n+        // 2. getOutputStream()\n+        // 3. setHeader(content-type)\n+        // 4. outputStream.write()\n+        servlets.add(BlockingServletLengthStreamTypeWrite.class);\n+        // Blocking\n+        // 1. setHeader(content-length)\n+        // 2. setHeader(content-type)\n+        // 3. getOutputStream()\n+        // 4. outputStream.write()\n+        servlets.add(BlockingServletLengthTypeStreamWrite.class);\n+        // Blocking\n+        // 1. getOutputStream()\n+        // 2. setHeader(content-length)\n+        // 3. setHeader(content-type)\n+        // 4. outputStream.write()\n+        servlets.add(BlockingServletStreamLengthTypeWrite.class);\n+        // Blocking\n+        // 1. getOutputStream()\n+        // 2. setHeader(content-length)\n+        // 3. setHeader(content-type)\n+        // 4. outputStream.write() (with frequent response flush)\n+        servlets.add(BlockingServletStreamLengthTypeWriteWithFlush.class);\n+        // Blocking\n+        // 1. getOutputStream()\n+        // 2. setHeader(content-type)\n+        // 3. setHeader(content-length)\n+        // 4. outputStream.write()\n+        servlets.add(BlockingServletStreamTypeLengthWrite.class);\n+        // Blocking\n+        // 1. setHeader(content-type)\n+        // 2. setHeader(content-length)\n+        // 3. getOutputStream()\n+        // 4. outputStream.write()\n+        servlets.add(BlockingServletTypeLengthStreamWrite.class);\n+        // Blocking\n+        // 1. setHeader(content-type)\n+        // 2. getOutputStream()\n+        // 3. setHeader(content-length)\n+        // 4. outputStream.write()\n+        servlets.add(BlockingServletTypeStreamLengthWrite.class);\n+\n+        List<Arguments> scenarios = new ArrayList<>();\n+\n+        for (Class<? extends Servlet> servlet : servlets)\n         {\n-            String testFilename = String.format(\"%s-%s\", contentServlet.getSimpleName(), scenario.fileName);\n-            File testFile = tester.prepareServerFile(testFilename, scenario.fileSize);\n-\n-            tester.start();\n-\n-            HttpTester.Response response = tester.executeRequest(\"GET\", \"/context/\" + testFile.getName(), 5, TimeUnit.SECONDS);\n-\n-            if (response.getStatus() != 200)\n-                System.err.println(\"DANG!!!! \" + response);\n-\n-            assertThat(\"Response status\", response.getStatus(), is(HttpStatus.OK_200));\n-\n-            if (scenario.expectCompressed)\n-            {\n-                // Must be gzip compressed\n-                assertThat(\"Content-Encoding\", response.get(\"Content-Encoding\"), containsString(GzipHandler.GZIP));\n-            }\n-            else\n+            for (GzipMode gzipMode : GzipMode.values())\n             {\n-                assertThat(\"Content-Encoding\", response.get(\"Content-Encoding\"), not(containsString(GzipHandler.GZIP)));\n+                // Not compressible (not large enough)\n+                scenarios.add(Arguments.of(gzipMode, servlet, 0, \"empty.txt\", false));\n+                scenarios.add(Arguments.of(gzipMode, servlet, GzipHandler.DEFAULT_MIN_GZIP_SIZE / 2, \"file-tiny.txt\", false));\n+\n+                // Compressible.\n+                scenarios.add(Arguments.of(gzipMode, servlet, DEFAULT_OUTPUT_BUFFER_SIZE / 2, \"file-small.txt\", true));\n+                scenarios.add(Arguments.of(gzipMode, servlet, DEFAULT_OUTPUT_BUFFER_SIZE, \"file-medium.txt\", true));\n+                scenarios.add(Arguments.of(gzipMode, servlet, DEFAULT_OUTPUT_BUFFER_SIZE * 4, \"file-large.txt\", true));\n+\n+                // Not compressible (not a matching Content-Type)\n+                scenarios.add(Arguments.of(gzipMode, servlet, DEFAULT_OUTPUT_BUFFER_SIZE / 2, \"file-small.mp3\", false));\n+                scenarios.add(Arguments.of(gzipMode, servlet, DEFAULT_OUTPUT_BUFFER_SIZE, \"file-medium.mp3\", false));\n+                scenarios.add(Arguments.of(gzipMode, servlet, DEFAULT_OUTPUT_BUFFER_SIZE * 4, \"file-large.mp3\", false));\n             }\n-\n-            // Uncompressed content Size\n-            ContentMetadata content = tester.getResponseMetadata(response);\n-            assertThat(\"(Uncompressed) Content Length\", content.size, is((long)scenario.fileSize));\n         }\n-        finally\n-        {\n-            tester.stop();\n-        }\n-    }\n \n-    /**\n-     * Test with content servlet that does:\n-     * AsyncContext create -> timeout -> onTimeout -> write-response -> complete\n-     *\n-     * @throws Exception on test failure\n-     */\n-    @ParameterizedTest\n-    @MethodSource(\"scenarios\")\n-    public void testAsyncTimeoutCompleteWriteDefault(Scenario scenario) throws Exception\n-    {\n-        testWithGzip(scenario, AsyncTimeoutCompleteWrite.Default.class);\n-    }\n-\n-    /**\n-     * Test with content servlet that does:\n-     * AsyncContext create -> timeout -> onTimeout -> write-response -> complete\n-     *\n-     * @throws Exception on test failure\n-     */\n-    @ParameterizedTest\n-    @MethodSource(\"scenarios\")\n-    public void testAsyncTimeoutCompleteWritePassed(Scenario scenario) throws Exception\n-    {\n-        testWithGzip(scenario, AsyncTimeoutCompleteWrite.Passed.class);\n+        return scenarios.stream();\n     }\n \n-    /**\n-     * Test with content servlet that does:\n-     * AsyncContext create -> timeout -> onTimeout -> dispatch -> write-response\n-     *\n-     * @throws Exception on test failure\n-     */\n-    @ParameterizedTest\n-    @MethodSource(\"scenarios\")\n-    public void testAsyncTimeoutDispatchWriteDefault(Scenario scenario) throws Exception\n-    {\n-        testWithGzip(scenario, AsyncTimeoutDispatchWrite.Default.class);\n-    }\n-\n-    /**\n-     * Test with content servlet that does:\n-     * AsyncContext create -> timeout -> onTimeout -> dispatch -> write-response\n-     *\n-     * @throws Exception on test failure\n-     */\n-    @ParameterizedTest\n-    @MethodSource(\"scenarios\")\n-    public void testAsyncTimeoutDispatchWritePassed(Scenario scenario) throws Exception\n-    {\n-        testWithGzip(scenario, AsyncTimeoutDispatchWrite.Passed.class);\n-    }\n-\n-    /**\n-     * Test with content servlet that does:\n-     * AsyncContext create -> no-timeout -> scheduler.schedule -> dispatch -> write-response\n-     *\n-     * @throws Exception on test failure\n-     */\n-    @ParameterizedTest\n-    @MethodSource(\"scenarios\")\n-    public void testAsyncScheduledDispatchWriteDefault(Scenario scenario) throws Exception\n-    {\n-        testWithGzip(scenario, AsyncScheduledDispatchWrite.Default.class);\n-    }\n+    private Server server;\n \n-    /**\n-     * Test with content servlet that does:\n-     * AsyncContext create -> no-timeout -> scheduler.schedule -> dispatch -> write-response\n-     *\n-     * @throws Exception on test failure\n-     */\n-    @ParameterizedTest\n-    @MethodSource(\"scenarios\")\n-    public void testAsyncScheduledDispatchWritePassed(Scenario scenario) throws Exception\n+    @AfterEach\n+    public void stopServer()\n     {\n-        testWithGzip(scenario, AsyncScheduledDispatchWrite.Passed.class);\n+        LifeCycle.stop(server);\n     }\n \n-    /**\n-     * Test with content servlet that does:\n-     * 1) setHeader(content-length)\n-     * 2) getOutputStream()\n-     * 3) setHeader(content-type)\n-     * 4) outputStream.write()\n-     *\n-     * @throws Exception on test failure\n-     * @see <a href=\"http://bugs.eclipse.org/354014\">Eclipse Bug 354014</a>\n-     */\n     @ParameterizedTest\n     @MethodSource(\"scenarios\")\n-    public void testServletLengthStreamTypeWrite(Scenario scenario) throws Exception\n+    public void executeScenario(GzipMode gzipMode, Class<? extends Servlet> contentServlet, int fileSize, String fileName, boolean compressible) throws Exception\n     {\n-        testWithGzip(scenario, TestServletLengthStreamTypeWrite.class);\n-    }\n+        server = new Server();\n+        LocalConnector localConnector = new LocalConnector(server);\n+        server.addConnector(localConnector);\n \n-    /**\n-     * Test with content servlet that does:\n-     * 1) setHeader(content-length)\n-     * 2) setHeader(content-type)\n-     * 3) getOutputStream()\n-     * 4) outputStream.write()\n-     *\n-     * @throws Exception on test failure\n-     * @see <a href=\"http://bugs.eclipse.org/354014\">Eclipse Bug 354014</a>\n-     */\n-    @ParameterizedTest\n-    @MethodSource(\"scenarios\")\n-    public void testServletLengthTypeStreamWrite(Scenario scenario) throws Exception\n-    {\n-        testWithGzip(scenario, TestServletLengthTypeStreamWrite.class);\n-    }\n+        Path contextDir = workDir.resolve(\"context\");\n+        FS.ensureDirExists(contextDir);\n \n-    /**\n-     * Test with content servlet that does:\n-     * 1) getOutputStream()\n-     * 2) setHeader(content-length)\n-     * 3) setHeader(content-type)\n-     * 4) outputStream.write()\n-     *\n-     * @throws Exception on test failure\n-     * @see <a href=\"http://bugs.eclipse.org/354014\">Eclipse Bug 354014</a>\n-     */\n-    @ParameterizedTest\n-    @MethodSource(\"scenarios\")\n-    public void testServletStreamLengthTypeWrite(Scenario scenario) throws Exception\n-    {\n-        testWithGzip(scenario, TestServletStreamLengthTypeWrite.class);\n-    }\n+        ServletContextHandler servletContextHandler = new ServletContextHandler();\n+        servletContextHandler.setContextPath(\"/context\");\n+        servletContextHandler.setBaseResource(new PathResource(contextDir));\n+        servletContextHandler.addServlet(contentServlet, \"/*\");\n+        GzipHandler gzipHandler = new GzipHandler();\n \n-    /**\n-     * Test with content servlet that does:\n-     * 1) getOutputStream()\n-     * 2) setHeader(content-length)\n-     * 3) setHeader(content-type)\n-     * 4) outputStream.write() (with frequent response flush)\n-     *\n-     * @throws Exception on test failure\n-     * @see <a href=\"http://bugs.eclipse.org/354014\">Eclipse Bug 354014</a>\n-     */\n-    @ParameterizedTest\n-    @MethodSource(\"scenarios\")\n-    public void testServletStreamLengthTypeWriteWithFlush(Scenario scenario) throws Exception\n-    {\n-        testWithGzip(scenario, TestServletStreamLengthTypeWriteWithFlush.class);\n-    }\n+        switch (gzipMode)\n+        {\n+            case INTERNAL:\n+                servletContextHandler.insertHandler(gzipHandler);\n+                server.setHandler(servletContextHandler);\n+                break;\n+            case EXTERNAL:\n+                gzipHandler.setHandler(servletContextHandler);\n+                server.setHandler(gzipHandler);\n+                break;\n+        }\n \n-    /**\n-     * Test with content servlet that does:\n-     * 1) getOutputStream()\n-     * 2) setHeader(content-type)\n-     * 3) setHeader(content-length)\n-     * 4) outputStream.write()\n-     *\n-     * @throws Exception on test failure\n-     * @see <a href=\"http://bugs.eclipse.org/354014\">Eclipse Bug 354014</a>\n-     */\n-    @ParameterizedTest\n-    @MethodSource(\"scenarios\")\n-    public void testServletStreamTypeLengthWrite(Scenario scenario) throws Exception\n-    {\n-        testWithGzip(scenario, TestServletStreamTypeLengthWrite.class);\n-    }\n+        Path file = createFile(contextDir, fileName, fileSize);\n+        String expectedSha1Sum = Sha1Sum.calculate(file);\n \n-    /**\n-     * Test with content servlet that does:\n-     * 1) setHeader(content-type)\n-     * 2) setHeader(content-length)\n-     * 3) getOutputStream()\n-     * 4) outputStream.write()\n-     *\n-     * @throws Exception on test failure\n-     * @see <a href=\"http://bugs.eclipse.org/354014\">Eclipse Bug 354014</a>\n-     */\n-    @ParameterizedTest\n-    @MethodSource(\"scenarios\")\n-    public void testServletTypeLengthStreamWrite(Scenario scenario) throws Exception\n-    {\n-        testWithGzip(scenario, TestServletTypeLengthStreamWrite.class);\n-    }\n+        server.start();\n \n-    /**\n-     * Test with content servlet that does:\n-     * 1) setHeader(content-type)\n-     * 2) getOutputStream()\n-     * 3) setHeader(content-length)\n-     * 4) outputStream.write()\n-     *\n-     * @throws Exception on test failure\n-     * @see <a href=\"Eclipse Bug 354014\">http://bugs.eclipse.org/354014</a>\n-     */\n-    @ParameterizedTest\n-    @MethodSource(\"scenarios\")\n-    public void testServletTypeStreamLengthWrite(Scenario scenario) throws Exception\n-    {\n-        testWithGzip(scenario, TestServletTypeStreamLengthWrite.class);\n-    }\n+        // Setup request\n+        HttpTester.Request request = HttpTester.newRequest();\n+        request.setMethod(\"GET\");\n+        request.setVersion(HttpVersion.HTTP_1_1);\n+        request.setHeader(\"Host\", \"tester\");\n+        request.setHeader(\"Connection\", \"close\");\n+        request.setHeader(\"Accept-Encoding\", \"gzip\");\n+        request.setURI(\"/context/\" + file.getFileName().toString());\n \n-    /**\n-     * Test with content servlet that does:\n-     * 2) getOutputStream()\n-     * 1) setHeader(content-type)\n-     * 3) setHeader(content-length)\n-     * 4) (unwrapped) HttpOutput.write(ByteBuffer)\n-     *\n-     * This is done to demonstrate a bug with using HttpOutput.write()\n-     * while also using GzipFilter\n-     *\n-     * @throws Exception on test failure\n-     * @see <a href=\"http://bugs.eclipse.org/450873\">Eclipse Bug 450873</a>\n-     */\n-    @ParameterizedTest\n-    @MethodSource(\"scenarios\")\n-    public void testHttpOutputWrite(Scenario scenario) throws Exception\n-    {\n-        testWithGzip(scenario, TestServletBufferTypeLengthWrite.class);\n-    }\n+        // Issue request\n+        ByteBuffer rawResponse = localConnector.getResponse(request.generate(), 5, TimeUnit.SECONDS);\n \n-    public static class Scenario\n-    {\n-        final int fileSize;\n-        final String fileName;\n-        final boolean expectCompressed;\n+        // Parse response\n+        HttpTester.Response response = HttpTester.parseResponse(rawResponse);\n \n-        public Scenario(int fileSize, String fileName, boolean expectCompressed)\n-        {\n-            this.fileSize = fileSize;\n-            this.fileName = fileName;\n-            this.expectCompressed = expectCompressed;\n-        }\n+        assertThat(\"Response status\", response.getStatus(), is(HttpStatus.OK_200));\n \n-        @Override\n-        public String toString()\n+        // Response Content-Encoding check\n+        Matcher<String> contentEncodingMatcher = containsString(GzipHandler.GZIP);\n+        if (!compressible)\n         {\n-            return String.format(\"%s [%,d bytes, compressed=%b]\", fileName, fileSize, expectCompressed);\n+            contentEncodingMatcher = not(contentEncodingMatcher);\n         }\n+        assertThat(\"Content-Encoding\", response.get(\"Content-Encoding\"), contentEncodingMatcher);\n+\n+        // Response Content checks\n+        UncompressedMetadata metadata = parseResponseContent(response);\n+        assertThat(\"(Uncompressed) Content Length\", metadata.uncompressedSize, is(fileSize));\n+        // TODO: Assertions.assertArrayEquals();\n+        // TODO: compare bytes", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTE1MzA1Mg=="}, "originalCommit": {"oid": "f9a215f18d634786b9409428fc1b9af1ce164c80"}, "originalPosition": 491}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2478, "cost": 1, "resetAt": "2021-11-12T18:49:56Z"}}}