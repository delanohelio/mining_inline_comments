{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDI4NjE3NzQx", "number": 4946, "reviewThreads": {"totalCount": 25, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOFQwNjozNzowM1rOEDUOqQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOFQxMTozOTozMlrOEDZ-vg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcxOTEyNjE3OnYy", "diffSide": "RIGHT", "path": "jetty-http2/http2-server/src/main/java/org/eclipse/jetty/http2/server/HTTP2ServerConnection.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOFQwNjozNzowM1rOGgQy2Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOFQxNjo1MjoyNFrOGgnTBA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQ4Mjc3Nw==", "bodyText": "Is this method still required?  It doesn't override any contract?", "url": "https://github.com/eclipse/jetty.project/pull/4946#discussion_r436482777", "createdAt": "2020-06-08T06:37:03Z", "author": {"login": "gregw"}, "path": "jetty-http2/http2-server/src/main/java/org/eclipse/jetty/http2/server/HTTP2ServerConnection.java", "diffHunk": "@@ -245,22 +246,10 @@ public boolean onSessionTimeout(Throwable failure)\n \n     public void onSessionFailure(Throwable failure, Callback callback)\n     {\n-        ISession session = getSession();\n         if (LOG.isDebugEnabled())\n-            LOG.debug(\"Processing failure on {}: {}\", session, failure);\n-        Collection<Stream> streams = session.getStreams();\n-        if (streams.isEmpty())\n-        {\n-            callback.succeeded();\n-        }\n-        else\n-        {\n-            CountingCallback counter = new CountingCallback(callback, streams.size());\n-            for (Stream stream : streams)\n-            {\n-                onStreamFailure((IStream)stream, failure, counter);\n-            }\n-        }\n+            LOG.debug(\"Processing session failure on {}\", getSession(), failure);\n+        // All the streams have already been failed, just succeed the callback.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8d606368297183bb89bd309e38772b6c2a47aa5f"}, "originalPosition": 57}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjg1MTQ2MA==", "bodyText": "@sbordet ?", "url": "https://github.com/eclipse/jetty.project/pull/4946#discussion_r436851460", "createdAt": "2020-06-08T16:52:24Z", "author": {"login": "gregw"}, "path": "jetty-http2/http2-server/src/main/java/org/eclipse/jetty/http2/server/HTTP2ServerConnection.java", "diffHunk": "@@ -245,22 +246,10 @@ public boolean onSessionTimeout(Throwable failure)\n \n     public void onSessionFailure(Throwable failure, Callback callback)\n     {\n-        ISession session = getSession();\n         if (LOG.isDebugEnabled())\n-            LOG.debug(\"Processing failure on {}: {}\", session, failure);\n-        Collection<Stream> streams = session.getStreams();\n-        if (streams.isEmpty())\n-        {\n-            callback.succeeded();\n-        }\n-        else\n-        {\n-            CountingCallback counter = new CountingCallback(callback, streams.size());\n-            for (Stream stream : streams)\n-            {\n-                onStreamFailure((IStream)stream, failure, counter);\n-            }\n-        }\n+            LOG.debug(\"Processing session failure on {}\", getSession(), failure);\n+        // All the streams have already been failed, just succeed the callback.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQ4Mjc3Nw=="}, "originalCommit": {"oid": "8d606368297183bb89bd309e38772b6c2a47aa5f"}, "originalPosition": 57}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcxOTEzMTM0OnYy", "diffSide": "RIGHT", "path": "jetty-http2/http2-server/src/main/java/org/eclipse/jetty/http2/server/HttpTransportOverHTTP2.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOFQwNjozODo1OVrOGgQ1wQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOFQwNjozODo1OVrOGgQ1wQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQ4MzUyMQ==", "bodyText": "Some comments on how we could get to these states between preSend and postSend would be good.", "url": "https://github.com/eclipse/jetty.project/pull/4946#discussion_r436483521", "createdAt": "2020-06-08T06:38:59Z", "author": {"login": "gregw"}, "path": "jetty-http2/http2-server/src/main/java/org/eclipse/jetty/http2/server/HttpTransportOverHTTP2.java", "diffHunk": "@@ -352,117 +353,259 @@ public void abort(Throwable failure)\n \n     private class TransportCallback implements Callback\n     {\n-        private State state = State.IDLE;\n-        private Callback callback;\n-        private Throwable failure;\n-        private boolean commit;\n+        private State _state = State.IDLE;\n+        private Callback _callback;\n+        private boolean _commit;\n+        private Throwable _failure;\n \n-        public boolean start(Callback callback, boolean commit)\n+        private void reset()\n         {\n-            State state;\n+            assert Thread.holdsLock(this);\n+            _state = State.IDLE;\n+            _callback = null;\n+            _commit = false;\n+            _failure = null;\n+        }\n+\n+        private void send(Callback callback, boolean commit, Consumer<Callback> consumer)\n+        {\n+            Throwable failure = preSend(callback, commit);\n+            if (failure == null)\n+            {\n+                consumer.accept(this);\n+                postSend();\n+            }\n+            else\n+            {\n+                callback.failed(failure);\n+            }\n+        }\n+\n+        private Throwable preSend(Callback callback, boolean commit)\n+        {\n+            synchronized (this)\n+            {\n+                switch (_state)\n+                {\n+                    case IDLE:\n+                    {\n+                        _state = State.PRE_SEND;\n+                        _callback = callback;\n+                        _commit = commit;\n+                        return null;\n+                    }\n+                    default:\n+                    {\n+                        Throwable failure = _failure;\n+                        if (failure == null)\n+                            failure = new IllegalStateException(\"Invalid transport state: \" + _state);\n+                        return failure;\n+                    }\n+                }\n+            }\n+        }\n+\n+        private void postSend()\n+        {\n+            Callback callback;\n+            boolean commit;\n             Throwable failure;\n             synchronized (this)\n             {\n-                state = this.state;\n-                failure = this.failure;\n-                if (state == State.IDLE)\n+                switch (_state)\n                 {\n-                    this.state = State.WRITING;\n-                    this.callback = callback;\n-                    this.commit = commit;\n-                    return true;\n+                    case PRE_SEND:\n+                    {\n+                        _state = State.POST_SEND;\n+                        return;\n+                    }\n+                    case SUCCEED:\n+                    {\n+                        callback = _callback;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8d606368297183bb89bd309e38772b6c2a47aa5f"}, "originalPosition": 202}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcxOTEzNDYyOnYy", "diffSide": "RIGHT", "path": "jetty-http2/http2-server/src/main/java/org/eclipse/jetty/http2/server/HttpTransportOverHTTP2.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOFQwNjo0MDoxNlrOGgQ3rw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOFQwNjo0MDoxNlrOGgQ3rw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQ4NDAxNQ==", "bodyText": "Why does SUCCEED just remember stuff while this one moves the state on? Comments needed", "url": "https://github.com/eclipse/jetty.project/pull/4946#discussion_r436484015", "createdAt": "2020-06-08T06:40:16Z", "author": {"login": "gregw"}, "path": "jetty-http2/http2-server/src/main/java/org/eclipse/jetty/http2/server/HttpTransportOverHTTP2.java", "diffHunk": "@@ -352,117 +353,259 @@ public void abort(Throwable failure)\n \n     private class TransportCallback implements Callback\n     {\n-        private State state = State.IDLE;\n-        private Callback callback;\n-        private Throwable failure;\n-        private boolean commit;\n+        private State _state = State.IDLE;\n+        private Callback _callback;\n+        private boolean _commit;\n+        private Throwable _failure;\n \n-        public boolean start(Callback callback, boolean commit)\n+        private void reset()\n         {\n-            State state;\n+            assert Thread.holdsLock(this);\n+            _state = State.IDLE;\n+            _callback = null;\n+            _commit = false;\n+            _failure = null;\n+        }\n+\n+        private void send(Callback callback, boolean commit, Consumer<Callback> consumer)\n+        {\n+            Throwable failure = preSend(callback, commit);\n+            if (failure == null)\n+            {\n+                consumer.accept(this);\n+                postSend();\n+            }\n+            else\n+            {\n+                callback.failed(failure);\n+            }\n+        }\n+\n+        private Throwable preSend(Callback callback, boolean commit)\n+        {\n+            synchronized (this)\n+            {\n+                switch (_state)\n+                {\n+                    case IDLE:\n+                    {\n+                        _state = State.PRE_SEND;\n+                        _callback = callback;\n+                        _commit = commit;\n+                        return null;\n+                    }\n+                    default:\n+                    {\n+                        Throwable failure = _failure;\n+                        if (failure == null)\n+                            failure = new IllegalStateException(\"Invalid transport state: \" + _state);\n+                        return failure;\n+                    }\n+                }\n+            }\n+        }\n+\n+        private void postSend()\n+        {\n+            Callback callback;\n+            boolean commit;\n             Throwable failure;\n             synchronized (this)\n             {\n-                state = this.state;\n-                failure = this.failure;\n-                if (state == State.IDLE)\n+                switch (_state)\n                 {\n-                    this.state = State.WRITING;\n-                    this.callback = callback;\n-                    this.commit = commit;\n-                    return true;\n+                    case PRE_SEND:\n+                    {\n+                        _state = State.POST_SEND;\n+                        return;\n+                    }\n+                    case SUCCEED:\n+                    {\n+                        callback = _callback;\n+                        commit = _commit;\n+                        failure = null;\n+                        reset();\n+                        break;\n+                    }\n+                    case FAIL:\n+                    {\n+                        _state = State.FAILED;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8d606368297183bb89bd309e38772b6c2a47aa5f"}, "originalPosition": 210}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcxOTEzNjc4OnYy", "diffSide": "RIGHT", "path": "jetty-http2/http2-server/src/main/java/org/eclipse/jetty/http2/server/HttpTransportOverHTTP2.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOFQwNjo0MToxNVrOGgQ4_A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOFQwNjo0MToxNVrOGgQ4_A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQ4NDM0OA==", "bodyText": "should _commit be nulled so we know we can only call it once?", "url": "https://github.com/eclipse/jetty.project/pull/4946#discussion_r436484348", "createdAt": "2020-06-08T06:41:15Z", "author": {"login": "gregw"}, "path": "jetty-http2/http2-server/src/main/java/org/eclipse/jetty/http2/server/HttpTransportOverHTTP2.java", "diffHunk": "@@ -352,117 +353,259 @@ public void abort(Throwable failure)\n \n     private class TransportCallback implements Callback\n     {\n-        private State state = State.IDLE;\n-        private Callback callback;\n-        private Throwable failure;\n-        private boolean commit;\n+        private State _state = State.IDLE;\n+        private Callback _callback;\n+        private boolean _commit;\n+        private Throwable _failure;\n \n-        public boolean start(Callback callback, boolean commit)\n+        private void reset()\n         {\n-            State state;\n+            assert Thread.holdsLock(this);\n+            _state = State.IDLE;\n+            _callback = null;\n+            _commit = false;\n+            _failure = null;\n+        }\n+\n+        private void send(Callback callback, boolean commit, Consumer<Callback> consumer)\n+        {\n+            Throwable failure = preSend(callback, commit);\n+            if (failure == null)\n+            {\n+                consumer.accept(this);\n+                postSend();\n+            }\n+            else\n+            {\n+                callback.failed(failure);\n+            }\n+        }\n+\n+        private Throwable preSend(Callback callback, boolean commit)\n+        {\n+            synchronized (this)\n+            {\n+                switch (_state)\n+                {\n+                    case IDLE:\n+                    {\n+                        _state = State.PRE_SEND;\n+                        _callback = callback;\n+                        _commit = commit;\n+                        return null;\n+                    }\n+                    default:\n+                    {\n+                        Throwable failure = _failure;\n+                        if (failure == null)\n+                            failure = new IllegalStateException(\"Invalid transport state: \" + _state);\n+                        return failure;\n+                    }\n+                }\n+            }\n+        }\n+\n+        private void postSend()\n+        {\n+            Callback callback;\n+            boolean commit;\n             Throwable failure;\n             synchronized (this)\n             {\n-                state = this.state;\n-                failure = this.failure;\n-                if (state == State.IDLE)\n+                switch (_state)\n                 {\n-                    this.state = State.WRITING;\n-                    this.callback = callback;\n-                    this.commit = commit;\n-                    return true;\n+                    case PRE_SEND:\n+                    {\n+                        _state = State.POST_SEND;\n+                        return;\n+                    }\n+                    case SUCCEED:\n+                    {\n+                        callback = _callback;\n+                        commit = _commit;\n+                        failure = null;\n+                        reset();\n+                        break;\n+                    }\n+                    case FAIL:\n+                    {\n+                        _state = State.FAILED;\n+                        callback = _callback;\n+                        commit = _commit;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8d606368297183bb89bd309e38772b6c2a47aa5f"}, "originalPosition": 212}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcxOTEzODcxOnYy", "diffSide": "RIGHT", "path": "jetty-http2/http2-server/src/main/java/org/eclipse/jetty/http2/server/HttpTransportOverHTTP2.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOFQwNjo0MjoxMFrOGgQ6RA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOFQwNjo0MjoxMFrOGgQ6RA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQ4NDY3Ng==", "bodyText": "what if callback is null?  I think it is an ISE, so that should be explicitly thrown", "url": "https://github.com/eclipse/jetty.project/pull/4946#discussion_r436484676", "createdAt": "2020-06-08T06:42:10Z", "author": {"login": "gregw"}, "path": "jetty-http2/http2-server/src/main/java/org/eclipse/jetty/http2/server/HttpTransportOverHTTP2.java", "diffHunk": "@@ -352,117 +353,259 @@ public void abort(Throwable failure)\n \n     private class TransportCallback implements Callback\n     {\n-        private State state = State.IDLE;\n-        private Callback callback;\n-        private Throwable failure;\n-        private boolean commit;\n+        private State _state = State.IDLE;\n+        private Callback _callback;\n+        private boolean _commit;\n+        private Throwable _failure;\n \n-        public boolean start(Callback callback, boolean commit)\n+        private void reset()\n         {\n-            State state;\n+            assert Thread.holdsLock(this);\n+            _state = State.IDLE;\n+            _callback = null;\n+            _commit = false;\n+            _failure = null;\n+        }\n+\n+        private void send(Callback callback, boolean commit, Consumer<Callback> consumer)\n+        {\n+            Throwable failure = preSend(callback, commit);\n+            if (failure == null)\n+            {\n+                consumer.accept(this);\n+                postSend();\n+            }\n+            else\n+            {\n+                callback.failed(failure);\n+            }\n+        }\n+\n+        private Throwable preSend(Callback callback, boolean commit)\n+        {\n+            synchronized (this)\n+            {\n+                switch (_state)\n+                {\n+                    case IDLE:\n+                    {\n+                        _state = State.PRE_SEND;\n+                        _callback = callback;\n+                        _commit = commit;\n+                        return null;\n+                    }\n+                    default:\n+                    {\n+                        Throwable failure = _failure;\n+                        if (failure == null)\n+                            failure = new IllegalStateException(\"Invalid transport state: \" + _state);\n+                        return failure;\n+                    }\n+                }\n+            }\n+        }\n+\n+        private void postSend()\n+        {\n+            Callback callback;\n+            boolean commit;\n             Throwable failure;\n             synchronized (this)\n             {\n-                state = this.state;\n-                failure = this.failure;\n-                if (state == State.IDLE)\n+                switch (_state)\n                 {\n-                    this.state = State.WRITING;\n-                    this.callback = callback;\n-                    this.commit = commit;\n-                    return true;\n+                    case PRE_SEND:\n+                    {\n+                        _state = State.POST_SEND;\n+                        return;\n+                    }\n+                    case SUCCEED:\n+                    {\n+                        callback = _callback;\n+                        commit = _commit;\n+                        failure = null;\n+                        reset();\n+                        break;\n+                    }\n+                    case FAIL:\n+                    {\n+                        _state = State.FAILED;\n+                        callback = _callback;\n+                        commit = _commit;\n+                        failure = _failure;\n+                        break;\n+                    }\n+                    default:\n+                    {\n+                        _state = State.FAILED;\n+                        _failure = new IllegalStateException(\"Invalid transport state: \" + _state);\n+                        callback = _callback;\n+                        commit = _commit;\n+                        failure = _failure;\n+                        break;\n+                    }\n                 }\n             }\n             if (failure == null)\n-                failure = new IllegalStateException(\"Invalid transport state: \" + state);\n-            callback.failed(failure);\n-            return false;\n+                succeed(callback, commit);\n+            else\n+                fail(callback, commit, failure);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8d606368297183bb89bd309e38772b6c2a47aa5f"}, "originalPosition": 233}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcxOTE0MTM1OnYy", "diffSide": "RIGHT", "path": "jetty-http2/http2-server/src/main/java/org/eclipse/jetty/http2/server/HttpTransportOverHTTP2.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOFQwNjo0MzoxOFrOGgQ74Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOFQwNjo0MzoxOFrOGgQ74Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQ4NTA4OQ==", "bodyText": "comment", "url": "https://github.com/eclipse/jetty.project/pull/4946#discussion_r436485089", "createdAt": "2020-06-08T06:43:18Z", "author": {"login": "gregw"}, "path": "jetty-http2/http2-server/src/main/java/org/eclipse/jetty/http2/server/HttpTransportOverHTTP2.java", "diffHunk": "@@ -352,117 +353,259 @@ public void abort(Throwable failure)\n \n     private class TransportCallback implements Callback\n     {\n-        private State state = State.IDLE;\n-        private Callback callback;\n-        private Throwable failure;\n-        private boolean commit;\n+        private State _state = State.IDLE;\n+        private Callback _callback;\n+        private boolean _commit;\n+        private Throwable _failure;\n \n-        public boolean start(Callback callback, boolean commit)\n+        private void reset()\n         {\n-            State state;\n+            assert Thread.holdsLock(this);\n+            _state = State.IDLE;\n+            _callback = null;\n+            _commit = false;\n+            _failure = null;\n+        }\n+\n+        private void send(Callback callback, boolean commit, Consumer<Callback> consumer)\n+        {\n+            Throwable failure = preSend(callback, commit);\n+            if (failure == null)\n+            {\n+                consumer.accept(this);\n+                postSend();\n+            }\n+            else\n+            {\n+                callback.failed(failure);\n+            }\n+        }\n+\n+        private Throwable preSend(Callback callback, boolean commit)\n+        {\n+            synchronized (this)\n+            {\n+                switch (_state)\n+                {\n+                    case IDLE:\n+                    {\n+                        _state = State.PRE_SEND;\n+                        _callback = callback;\n+                        _commit = commit;\n+                        return null;\n+                    }\n+                    default:\n+                    {\n+                        Throwable failure = _failure;\n+                        if (failure == null)\n+                            failure = new IllegalStateException(\"Invalid transport state: \" + _state);\n+                        return failure;\n+                    }\n+                }\n+            }\n+        }\n+\n+        private void postSend()\n+        {\n+            Callback callback;\n+            boolean commit;\n             Throwable failure;\n             synchronized (this)\n             {\n-                state = this.state;\n-                failure = this.failure;\n-                if (state == State.IDLE)\n+                switch (_state)\n                 {\n-                    this.state = State.WRITING;\n-                    this.callback = callback;\n-                    this.commit = commit;\n-                    return true;\n+                    case PRE_SEND:\n+                    {\n+                        _state = State.POST_SEND;\n+                        return;\n+                    }\n+                    case SUCCEED:\n+                    {\n+                        callback = _callback;\n+                        commit = _commit;\n+                        failure = null;\n+                        reset();\n+                        break;\n+                    }\n+                    case FAIL:\n+                    {\n+                        _state = State.FAILED;\n+                        callback = _callback;\n+                        commit = _commit;\n+                        failure = _failure;\n+                        break;\n+                    }\n+                    default:\n+                    {\n+                        _state = State.FAILED;\n+                        _failure = new IllegalStateException(\"Invalid transport state: \" + _state);\n+                        callback = _callback;\n+                        commit = _commit;\n+                        failure = _failure;\n+                        break;\n+                    }\n                 }\n             }\n             if (failure == null)\n-                failure = new IllegalStateException(\"Invalid transport state: \" + state);\n-            callback.failed(failure);\n-            return false;\n+                succeed(callback, commit);\n+            else\n+                fail(callback, commit, failure);\n         }\n \n         @Override\n         public void succeeded()\n         {\n+            Callback callback;\n             boolean commit;\n-            Callback callback = null;\n             synchronized (this)\n             {\n-                commit = this.commit;\n-                if (state == State.WRITING)\n+                switch (_state)\n                 {\n-                    this.state = State.IDLE;\n-                    callback = this.callback;\n-                    this.callback = null;\n-                    this.commit = false;\n+                    case PRE_SEND:\n+                    {\n+                        _state = State.SUCCEED;\n+                        // Succeeding the callback will be done in postSend().\n+                        return;\n+                    }\n+                    case POST_SEND:\n+                    {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8d606368297183bb89bd309e38772b6c2a47aa5f"}, "originalPosition": 259}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcxOTE0MjI2OnYy", "diffSide": "RIGHT", "path": "jetty-http2/http2-server/src/main/java/org/eclipse/jetty/http2/server/HttpTransportOverHTTP2.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOFQwNjo0Mzo0NFrOGgQ8bA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOFQwNjo0Mzo0NFrOGgQ8bA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQ4NTIyOA==", "bodyText": "the race with whom?", "url": "https://github.com/eclipse/jetty.project/pull/4946#discussion_r436485228", "createdAt": "2020-06-08T06:43:44Z", "author": {"login": "gregw"}, "path": "jetty-http2/http2-server/src/main/java/org/eclipse/jetty/http2/server/HttpTransportOverHTTP2.java", "diffHunk": "@@ -352,117 +353,259 @@ public void abort(Throwable failure)\n \n     private class TransportCallback implements Callback\n     {\n-        private State state = State.IDLE;\n-        private Callback callback;\n-        private Throwable failure;\n-        private boolean commit;\n+        private State _state = State.IDLE;\n+        private Callback _callback;\n+        private boolean _commit;\n+        private Throwable _failure;\n \n-        public boolean start(Callback callback, boolean commit)\n+        private void reset()\n         {\n-            State state;\n+            assert Thread.holdsLock(this);\n+            _state = State.IDLE;\n+            _callback = null;\n+            _commit = false;\n+            _failure = null;\n+        }\n+\n+        private void send(Callback callback, boolean commit, Consumer<Callback> consumer)\n+        {\n+            Throwable failure = preSend(callback, commit);\n+            if (failure == null)\n+            {\n+                consumer.accept(this);\n+                postSend();\n+            }\n+            else\n+            {\n+                callback.failed(failure);\n+            }\n+        }\n+\n+        private Throwable preSend(Callback callback, boolean commit)\n+        {\n+            synchronized (this)\n+            {\n+                switch (_state)\n+                {\n+                    case IDLE:\n+                    {\n+                        _state = State.PRE_SEND;\n+                        _callback = callback;\n+                        _commit = commit;\n+                        return null;\n+                    }\n+                    default:\n+                    {\n+                        Throwable failure = _failure;\n+                        if (failure == null)\n+                            failure = new IllegalStateException(\"Invalid transport state: \" + _state);\n+                        return failure;\n+                    }\n+                }\n+            }\n+        }\n+\n+        private void postSend()\n+        {\n+            Callback callback;\n+            boolean commit;\n             Throwable failure;\n             synchronized (this)\n             {\n-                state = this.state;\n-                failure = this.failure;\n-                if (state == State.IDLE)\n+                switch (_state)\n                 {\n-                    this.state = State.WRITING;\n-                    this.callback = callback;\n-                    this.commit = commit;\n-                    return true;\n+                    case PRE_SEND:\n+                    {\n+                        _state = State.POST_SEND;\n+                        return;\n+                    }\n+                    case SUCCEED:\n+                    {\n+                        callback = _callback;\n+                        commit = _commit;\n+                        failure = null;\n+                        reset();\n+                        break;\n+                    }\n+                    case FAIL:\n+                    {\n+                        _state = State.FAILED;\n+                        callback = _callback;\n+                        commit = _commit;\n+                        failure = _failure;\n+                        break;\n+                    }\n+                    default:\n+                    {\n+                        _state = State.FAILED;\n+                        _failure = new IllegalStateException(\"Invalid transport state: \" + _state);\n+                        callback = _callback;\n+                        commit = _commit;\n+                        failure = _failure;\n+                        break;\n+                    }\n                 }\n             }\n             if (failure == null)\n-                failure = new IllegalStateException(\"Invalid transport state: \" + state);\n-            callback.failed(failure);\n-            return false;\n+                succeed(callback, commit);\n+            else\n+                fail(callback, commit, failure);\n         }\n \n         @Override\n         public void succeeded()\n         {\n+            Callback callback;\n             boolean commit;\n-            Callback callback = null;\n             synchronized (this)\n             {\n-                commit = this.commit;\n-                if (state == State.WRITING)\n+                switch (_state)\n                 {\n-                    this.state = State.IDLE;\n-                    callback = this.callback;\n-                    this.callback = null;\n-                    this.commit = false;\n+                    case PRE_SEND:\n+                    {\n+                        _state = State.SUCCEED;\n+                        // Succeeding the callback will be done in postSend().\n+                        return;\n+                    }\n+                    case POST_SEND:\n+                    {\n+                        callback = _callback;\n+                        commit = _commit;\n+                        reset();\n+                        break;\n+                    }\n+                    default:\n+                    {\n+                        // The race to succeed was lost and other states", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8d606368297183bb89bd309e38772b6c2a47aa5f"}, "originalPosition": 267}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcxOTQ1MDQyOnYy", "diffSide": "RIGHT", "path": "jetty-http2/http2-server/src/main/java/org/eclipse/jetty/http2/server/HttpTransportOverHTTP2.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOFQwODozMDo0MlrOGgT8Sg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOFQxMDoxOTozOFrOGgXowg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjUzNDM0Ng==", "bodyText": "Since all lambdas passed to this method are always capturing, I see no point in passing it the Callback. I think changing the signature here to accept a Runnable instead of a Consumer would be slightly more readable.", "url": "https://github.com/eclipse/jetty.project/pull/4946#discussion_r436534346", "createdAt": "2020-06-08T08:30:42Z", "author": {"login": "lorban"}, "path": "jetty-http2/http2-server/src/main/java/org/eclipse/jetty/http2/server/HttpTransportOverHTTP2.java", "diffHunk": "@@ -352,117 +353,259 @@ public void abort(Throwable failure)\n \n     private class TransportCallback implements Callback\n     {\n-        private State state = State.IDLE;\n-        private Callback callback;\n-        private Throwable failure;\n-        private boolean commit;\n+        private State _state = State.IDLE;\n+        private Callback _callback;\n+        private boolean _commit;\n+        private Throwable _failure;\n \n-        public boolean start(Callback callback, boolean commit)\n+        private void reset()\n         {\n-            State state;\n+            assert Thread.holdsLock(this);\n+            _state = State.IDLE;\n+            _callback = null;\n+            _commit = false;\n+            _failure = null;\n+        }\n+\n+        private void send(Callback callback, boolean commit, Consumer<Callback> consumer)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "82529e614f71fbc36d9212377376a33f2d4220f0"}, "originalPosition": 141}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjU2NTY0OA==", "bodyText": "I agree.  At the very least the param name needs to be changed to sendFrame.", "url": "https://github.com/eclipse/jetty.project/pull/4946#discussion_r436565648", "createdAt": "2020-06-08T09:25:18Z", "author": {"login": "gregw"}, "path": "jetty-http2/http2-server/src/main/java/org/eclipse/jetty/http2/server/HttpTransportOverHTTP2.java", "diffHunk": "@@ -352,117 +353,259 @@ public void abort(Throwable failure)\n \n     private class TransportCallback implements Callback\n     {\n-        private State state = State.IDLE;\n-        private Callback callback;\n-        private Throwable failure;\n-        private boolean commit;\n+        private State _state = State.IDLE;\n+        private Callback _callback;\n+        private boolean _commit;\n+        private Throwable _failure;\n \n-        public boolean start(Callback callback, boolean commit)\n+        private void reset()\n         {\n-            State state;\n+            assert Thread.holdsLock(this);\n+            _state = State.IDLE;\n+            _callback = null;\n+            _commit = false;\n+            _failure = null;\n+        }\n+\n+        private void send(Callback callback, boolean commit, Consumer<Callback> consumer)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjUzNDM0Ng=="}, "originalCommit": {"oid": "82529e614f71fbc36d9212377376a33f2d4220f0"}, "originalPosition": 141}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjU5MjcyMw==", "bodyText": "I like the Consumer<Callback> for 2 reasons:\n\nit allows TransportCallback.send() to give to the Consumer some other callback if needs to without having the sendXXXFrame() methods be aware of what callback to use\nit keeps the semantic of the sendXXXFrame() clear: they take a callback parameter, and therefore they are asynchronous", "url": "https://github.com/eclipse/jetty.project/pull/4946#discussion_r436592723", "createdAt": "2020-06-08T10:15:29Z", "author": {"login": "sbordet"}, "path": "jetty-http2/http2-server/src/main/java/org/eclipse/jetty/http2/server/HttpTransportOverHTTP2.java", "diffHunk": "@@ -352,117 +353,259 @@ public void abort(Throwable failure)\n \n     private class TransportCallback implements Callback\n     {\n-        private State state = State.IDLE;\n-        private Callback callback;\n-        private Throwable failure;\n-        private boolean commit;\n+        private State _state = State.IDLE;\n+        private Callback _callback;\n+        private boolean _commit;\n+        private Throwable _failure;\n \n-        public boolean start(Callback callback, boolean commit)\n+        private void reset()\n         {\n-            State state;\n+            assert Thread.holdsLock(this);\n+            _state = State.IDLE;\n+            _callback = null;\n+            _commit = false;\n+            _failure = null;\n+        }\n+\n+        private void send(Callback callback, boolean commit, Consumer<Callback> consumer)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjUzNDM0Ng=="}, "originalCommit": {"oid": "82529e614f71fbc36d9212377376a33f2d4220f0"}, "originalPosition": 141}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjU5NDg4Mg==", "bodyText": "@sbordet if you keep the Consumer it has to have a better name than consumer.   I think sendFrame is best as it indicates what the Consumer is meant to do.", "url": "https://github.com/eclipse/jetty.project/pull/4946#discussion_r436594882", "createdAt": "2020-06-08T10:19:38Z", "author": {"login": "gregw"}, "path": "jetty-http2/http2-server/src/main/java/org/eclipse/jetty/http2/server/HttpTransportOverHTTP2.java", "diffHunk": "@@ -352,117 +353,259 @@ public void abort(Throwable failure)\n \n     private class TransportCallback implements Callback\n     {\n-        private State state = State.IDLE;\n-        private Callback callback;\n-        private Throwable failure;\n-        private boolean commit;\n+        private State _state = State.IDLE;\n+        private Callback _callback;\n+        private boolean _commit;\n+        private Throwable _failure;\n \n-        public boolean start(Callback callback, boolean commit)\n+        private void reset()\n         {\n-            State state;\n+            assert Thread.holdsLock(this);\n+            _state = State.IDLE;\n+            _callback = null;\n+            _commit = false;\n+            _failure = null;\n+        }\n+\n+        private void send(Callback callback, boolean commit, Consumer<Callback> consumer)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjUzNDM0Ng=="}, "originalCommit": {"oid": "82529e614f71fbc36d9212377376a33f2d4220f0"}, "originalPosition": 141}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcxOTQ1NTYxOnYy", "diffSide": "RIGHT", "path": "jetty-http2/http2-server/src/main/java/org/eclipse/jetty/http2/server/HttpTransportOverHTTP2.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOFQwODozMjowN1rOGgT_YA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOFQxMDoxNTo0MVrOGgXgwQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjUzNTEzNg==", "bodyText": "These states and their transitions should be javadoc'ed as it's not easy to grok what the FSM looks like by reading the code.", "url": "https://github.com/eclipse/jetty.project/pull/4946#discussion_r436535136", "createdAt": "2020-06-08T08:32:07Z", "author": {"login": "lorban"}, "path": "jetty-http2/http2-server/src/main/java/org/eclipse/jetty/http2/server/HttpTransportOverHTTP2.java", "diffHunk": "@@ -352,117 +353,259 @@ public void abort(Throwable failure)\n \n     private class TransportCallback implements Callback\n     {\n-        private State state = State.IDLE;\n-        private Callback callback;\n-        private Throwable failure;\n-        private boolean commit;\n+        private State _state = State.IDLE;\n+        private Callback _callback;\n+        private boolean _commit;\n+        private Throwable _failure;\n \n-        public boolean start(Callback callback, boolean commit)\n+        private void reset()\n         {\n-            State state;\n+            assert Thread.holdsLock(this);\n+            _state = State.IDLE;\n+            _callback = null;\n+            _commit = false;\n+            _failure = null;\n+        }\n+\n+        private void send(Callback callback, boolean commit, Consumer<Callback> consumer)\n+        {\n+            Throwable failure = preSend(callback, commit);\n+            if (failure == null)\n+            {\n+                consumer.accept(this);\n+                postSend();\n+            }\n+            else\n+            {\n+                callback.failed(failure);\n+            }\n+        }\n+\n+        private Throwable preSend(Callback callback, boolean commit)\n+        {\n+            synchronized (this)\n+            {\n+                switch (_state)\n+                {\n+                    case IDLE:\n+                    {\n+                        _state = State.PRE_SEND;\n+                        _callback = callback;\n+                        _commit = commit;\n+                        return null;\n+                    }\n+                    default:\n+                    {\n+                        Throwable failure = _failure;\n+                        if (failure == null)\n+                            failure = new IllegalStateException(\"Invalid transport state: \" + _state);\n+                        return failure;\n+                    }\n+                }\n+            }\n+        }\n+\n+        private void postSend()\n+        {\n+            Callback callback;\n+            boolean commit;\n             Throwable failure;\n             synchronized (this)\n             {\n-                state = this.state;\n-                failure = this.failure;\n-                if (state == State.IDLE)\n+                switch (_state)\n                 {\n-                    this.state = State.WRITING;\n-                    this.callback = callback;\n-                    this.commit = commit;\n-                    return true;\n+                    case PRE_SEND:\n+                    {\n+                        _state = State.POST_SEND;\n+                        return;\n+                    }\n+                    case SUCCEED:\n+                    {\n+                        callback = _callback;\n+                        commit = _commit;\n+                        failure = null;\n+                        reset();\n+                        break;\n+                    }\n+                    case FAIL:\n+                    {\n+                        _state = State.FAILED;\n+                        callback = _callback;\n+                        commit = _commit;\n+                        failure = _failure;\n+                        break;\n+                    }\n+                    default:\n+                    {\n+                        _state = State.FAILED;\n+                        _failure = new IllegalStateException(\"Invalid transport state: \" + _state);\n+                        callback = _callback;\n+                        commit = _commit;\n+                        failure = _failure;\n+                        break;\n+                    }\n                 }\n             }\n             if (failure == null)\n-                failure = new IllegalStateException(\"Invalid transport state: \" + state);\n-            callback.failed(failure);\n-            return false;\n+                succeed(callback, commit);\n+            else\n+                fail(callback, commit, failure);\n         }\n \n         @Override\n         public void succeeded()\n         {\n+            Callback callback;\n             boolean commit;\n-            Callback callback = null;\n             synchronized (this)\n             {\n-                commit = this.commit;\n-                if (state == State.WRITING)\n+                switch (_state)\n                 {\n-                    this.state = State.IDLE;\n-                    callback = this.callback;\n-                    this.callback = null;\n-                    this.commit = false;\n+                    case PRE_SEND:\n+                    {\n+                        _state = State.SUCCEED;\n+                        // Succeeding the callback will be done in postSend().\n+                        return;\n+                    }\n+                    case POST_SEND:\n+                    {\n+                        callback = _callback;\n+                        commit = _commit;\n+                        reset();\n+                        break;\n+                    }\n+                    default:\n+                    {\n+                        // The race to succeed was lost and other states\n+                        // have already performed their terminal action.\n+                        return;\n+                    }\n                 }\n             }\n-            if (LOG.isDebugEnabled())\n-                LOG.debug(\"HTTP2 Response #{}/{} {} {}\",\n-                    stream.getId(), Integer.toHexString(stream.getSession().hashCode()),\n-                    commit ? \"commit\" : \"flush\",\n-                    callback == null ? \"failure\" : \"success\");\n-            if (callback != null)\n-                callback.succeeded();\n+            succeed(callback, commit);\n         }\n \n         @Override\n         public void failed(Throwable failure)\n         {\n-            boolean commit;\n             Callback callback;\n+            boolean commit;\n             synchronized (this)\n             {\n-                commit = this.commit;\n-                this.state = State.FAILED;\n-                callback = this.callback;\n-                this.callback = null;\n-                this.failure = failure;\n+                switch (_state)\n+                {\n+                    case PRE_SEND:\n+                    {\n+                        _state = State.FAIL;\n+                        _failure = failure;\n+                        // Failing the callback will be done in postSend().\n+                        return;\n+                    }\n+                    case IDLE:\n+                    case POST_SEND:\n+                    {\n+                        _state = State.FAILED;\n+                        _failure = failure;\n+                        callback = _callback;\n+                        commit = _commit;\n+                        break;\n+                    }\n+                    default:\n+                    {\n+                        // The race to fail was lost and other states\n+                        // have already performed their terminal action.\n+                        return;\n+                    }\n+                }\n             }\n-            if (LOG.isDebugEnabled())\n-                LOG.debug(String.format(\"HTTP2 Response #%d/%h %s %s\", stream.getId(), stream.getSession(),\n-                    commit ? \"commit\" : \"flush\", callback == null ? \"ignored\" : \"failed\"), failure);\n-            if (callback != null)\n-                callback.failed(failure);\n+            fail(callback, commit, failure);\n         }\n \n-        private boolean onIdleTimeout(Throwable failure)\n+        private boolean idleTimeout(Throwable failure)\n         {\n-            boolean result;\n-            Callback callback = null;\n+            Callback callback;\n+            boolean timeout;\n             synchronized (this)\n             {\n-                // Ignore idle timeouts if not writing,\n-                // as the application may be suspended.\n-                result = state == State.WRITING;\n-                if (result)\n+                switch (_state)\n                 {\n-                    this.state = State.TIMEOUT;\n-                    callback = this.callback;\n-                    this.callback = null;\n-                    this.failure = failure;\n+                    case POST_SEND:\n+                    {\n+                        // The send was started but idle timed out, fail it.\n+                        _state = State.FAILED;\n+                        _failure = failure;\n+                        callback = _callback;\n+                        timeout = true;\n+                        break;\n+                    }\n+                    case IDLE:\n+                        // The application may be suspended, ignore the idle timeout.\n+                    case PRE_SEND:\n+                        // A send has been started at the same time of an idle timeout;\n+                        // Ignore the idle timeout and let the write continue normally.\n+                    case SUCCEED:\n+                    case FAIL:\n+                        // An idle timeout during these transient states is ignored.\n+                    case FAILED:\n+                        // Already failed, ignore the idle timeout.\n+                    {\n+                        callback = null;\n+                        timeout = false;\n+                        break;\n+                    }\n+                    default:\n+                    {\n+                        // Should not happen, but just in case.\n+                        _state = State.FAILED;\n+                        _failure = new IllegalStateException(\"Invalid transport state: \" + _state, failure);\n+                        callback = _callback;\n+                        if (callback == null)\n+                            callback = Callback.NOOP;\n+                        timeout = true;\n+                        failure = _failure;\n+                        break;\n+                    }\n                 }\n             }\n+            idleTimeout(callback, timeout, failure);\n+            return timeout;\n+        }\n+\n+        private void succeed(Callback callback, boolean commit)\n+        {\n             if (LOG.isDebugEnabled())\n-                LOG.debug(String.format(\"HTTP2 Response #%d/%h idle timeout %s\", stream.getId(), stream.getSession(), result ? \"expired\" : \"ignored\"), failure);\n-            if (result)\n+                LOG.debug(\"HTTP2 Response #{}/{} {} success\",\n+                    stream.getId(), Integer.toHexString(stream.getSession().hashCode()),\n+                    commit ? \"commit\" : \"flush\");\n+            callback.succeeded();\n+        }\n+\n+        private void fail(Callback callback, boolean commit, Throwable failure)\n+        {\n+            if (LOG.isDebugEnabled())\n+                LOG.debug(\"HTTP2 Response #{}/{} {} failure\",\n+                    stream.getId(), Integer.toHexString(stream.getSession().hashCode()),\n+                    commit ? \"commit\" : \"flush\",\n+                    failure);\n+            if (callback != null)\n                 callback.failed(failure);\n-            return result;\n         }\n \n-        @Override\n-        public InvocationType getInvocationType()\n+        private void idleTimeout(Callback callback, boolean timeout, Throwable failure)\n         {\n-            Callback callback;\n-            synchronized (this)\n-            {\n-                callback = this.callback;\n-            }\n-            return callback != null ? callback.getInvocationType() : Callback.super.getInvocationType();\n+            if (LOG.isDebugEnabled())\n+                LOG.debug(\"HTTP2 Response #{}/{} idle timeout {}\",\n+                    stream.getId(), Integer.toHexString(stream.getSession().hashCode()),\n+                    timeout ? \"expired\" : \"ignored\",\n+                    failure);\n+            if (timeout)\n+                callback.failed(failure);\n         }\n     }\n \n     private enum State\n     {\n-        IDLE, WRITING, FAILED, TIMEOUT\n+        IDLE, PRE_SEND, POST_SEND, SUCCEED, FAIL, FAILED", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "82529e614f71fbc36d9212377376a33f2d4220f0"}, "originalPosition": 437}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjU5MjgzMw==", "bodyText": "Done.", "url": "https://github.com/eclipse/jetty.project/pull/4946#discussion_r436592833", "createdAt": "2020-06-08T10:15:41Z", "author": {"login": "sbordet"}, "path": "jetty-http2/http2-server/src/main/java/org/eclipse/jetty/http2/server/HttpTransportOverHTTP2.java", "diffHunk": "@@ -352,117 +353,259 @@ public void abort(Throwable failure)\n \n     private class TransportCallback implements Callback\n     {\n-        private State state = State.IDLE;\n-        private Callback callback;\n-        private Throwable failure;\n-        private boolean commit;\n+        private State _state = State.IDLE;\n+        private Callback _callback;\n+        private boolean _commit;\n+        private Throwable _failure;\n \n-        public boolean start(Callback callback, boolean commit)\n+        private void reset()\n         {\n-            State state;\n+            assert Thread.holdsLock(this);\n+            _state = State.IDLE;\n+            _callback = null;\n+            _commit = false;\n+            _failure = null;\n+        }\n+\n+        private void send(Callback callback, boolean commit, Consumer<Callback> consumer)\n+        {\n+            Throwable failure = preSend(callback, commit);\n+            if (failure == null)\n+            {\n+                consumer.accept(this);\n+                postSend();\n+            }\n+            else\n+            {\n+                callback.failed(failure);\n+            }\n+        }\n+\n+        private Throwable preSend(Callback callback, boolean commit)\n+        {\n+            synchronized (this)\n+            {\n+                switch (_state)\n+                {\n+                    case IDLE:\n+                    {\n+                        _state = State.PRE_SEND;\n+                        _callback = callback;\n+                        _commit = commit;\n+                        return null;\n+                    }\n+                    default:\n+                    {\n+                        Throwable failure = _failure;\n+                        if (failure == null)\n+                            failure = new IllegalStateException(\"Invalid transport state: \" + _state);\n+                        return failure;\n+                    }\n+                }\n+            }\n+        }\n+\n+        private void postSend()\n+        {\n+            Callback callback;\n+            boolean commit;\n             Throwable failure;\n             synchronized (this)\n             {\n-                state = this.state;\n-                failure = this.failure;\n-                if (state == State.IDLE)\n+                switch (_state)\n                 {\n-                    this.state = State.WRITING;\n-                    this.callback = callback;\n-                    this.commit = commit;\n-                    return true;\n+                    case PRE_SEND:\n+                    {\n+                        _state = State.POST_SEND;\n+                        return;\n+                    }\n+                    case SUCCEED:\n+                    {\n+                        callback = _callback;\n+                        commit = _commit;\n+                        failure = null;\n+                        reset();\n+                        break;\n+                    }\n+                    case FAIL:\n+                    {\n+                        _state = State.FAILED;\n+                        callback = _callback;\n+                        commit = _commit;\n+                        failure = _failure;\n+                        break;\n+                    }\n+                    default:\n+                    {\n+                        _state = State.FAILED;\n+                        _failure = new IllegalStateException(\"Invalid transport state: \" + _state);\n+                        callback = _callback;\n+                        commit = _commit;\n+                        failure = _failure;\n+                        break;\n+                    }\n                 }\n             }\n             if (failure == null)\n-                failure = new IllegalStateException(\"Invalid transport state: \" + state);\n-            callback.failed(failure);\n-            return false;\n+                succeed(callback, commit);\n+            else\n+                fail(callback, commit, failure);\n         }\n \n         @Override\n         public void succeeded()\n         {\n+            Callback callback;\n             boolean commit;\n-            Callback callback = null;\n             synchronized (this)\n             {\n-                commit = this.commit;\n-                if (state == State.WRITING)\n+                switch (_state)\n                 {\n-                    this.state = State.IDLE;\n-                    callback = this.callback;\n-                    this.callback = null;\n-                    this.commit = false;\n+                    case PRE_SEND:\n+                    {\n+                        _state = State.SUCCEED;\n+                        // Succeeding the callback will be done in postSend().\n+                        return;\n+                    }\n+                    case POST_SEND:\n+                    {\n+                        callback = _callback;\n+                        commit = _commit;\n+                        reset();\n+                        break;\n+                    }\n+                    default:\n+                    {\n+                        // The race to succeed was lost and other states\n+                        // have already performed their terminal action.\n+                        return;\n+                    }\n                 }\n             }\n-            if (LOG.isDebugEnabled())\n-                LOG.debug(\"HTTP2 Response #{}/{} {} {}\",\n-                    stream.getId(), Integer.toHexString(stream.getSession().hashCode()),\n-                    commit ? \"commit\" : \"flush\",\n-                    callback == null ? \"failure\" : \"success\");\n-            if (callback != null)\n-                callback.succeeded();\n+            succeed(callback, commit);\n         }\n \n         @Override\n         public void failed(Throwable failure)\n         {\n-            boolean commit;\n             Callback callback;\n+            boolean commit;\n             synchronized (this)\n             {\n-                commit = this.commit;\n-                this.state = State.FAILED;\n-                callback = this.callback;\n-                this.callback = null;\n-                this.failure = failure;\n+                switch (_state)\n+                {\n+                    case PRE_SEND:\n+                    {\n+                        _state = State.FAIL;\n+                        _failure = failure;\n+                        // Failing the callback will be done in postSend().\n+                        return;\n+                    }\n+                    case IDLE:\n+                    case POST_SEND:\n+                    {\n+                        _state = State.FAILED;\n+                        _failure = failure;\n+                        callback = _callback;\n+                        commit = _commit;\n+                        break;\n+                    }\n+                    default:\n+                    {\n+                        // The race to fail was lost and other states\n+                        // have already performed their terminal action.\n+                        return;\n+                    }\n+                }\n             }\n-            if (LOG.isDebugEnabled())\n-                LOG.debug(String.format(\"HTTP2 Response #%d/%h %s %s\", stream.getId(), stream.getSession(),\n-                    commit ? \"commit\" : \"flush\", callback == null ? \"ignored\" : \"failed\"), failure);\n-            if (callback != null)\n-                callback.failed(failure);\n+            fail(callback, commit, failure);\n         }\n \n-        private boolean onIdleTimeout(Throwable failure)\n+        private boolean idleTimeout(Throwable failure)\n         {\n-            boolean result;\n-            Callback callback = null;\n+            Callback callback;\n+            boolean timeout;\n             synchronized (this)\n             {\n-                // Ignore idle timeouts if not writing,\n-                // as the application may be suspended.\n-                result = state == State.WRITING;\n-                if (result)\n+                switch (_state)\n                 {\n-                    this.state = State.TIMEOUT;\n-                    callback = this.callback;\n-                    this.callback = null;\n-                    this.failure = failure;\n+                    case POST_SEND:\n+                    {\n+                        // The send was started but idle timed out, fail it.\n+                        _state = State.FAILED;\n+                        _failure = failure;\n+                        callback = _callback;\n+                        timeout = true;\n+                        break;\n+                    }\n+                    case IDLE:\n+                        // The application may be suspended, ignore the idle timeout.\n+                    case PRE_SEND:\n+                        // A send has been started at the same time of an idle timeout;\n+                        // Ignore the idle timeout and let the write continue normally.\n+                    case SUCCEED:\n+                    case FAIL:\n+                        // An idle timeout during these transient states is ignored.\n+                    case FAILED:\n+                        // Already failed, ignore the idle timeout.\n+                    {\n+                        callback = null;\n+                        timeout = false;\n+                        break;\n+                    }\n+                    default:\n+                    {\n+                        // Should not happen, but just in case.\n+                        _state = State.FAILED;\n+                        _failure = new IllegalStateException(\"Invalid transport state: \" + _state, failure);\n+                        callback = _callback;\n+                        if (callback == null)\n+                            callback = Callback.NOOP;\n+                        timeout = true;\n+                        failure = _failure;\n+                        break;\n+                    }\n                 }\n             }\n+            idleTimeout(callback, timeout, failure);\n+            return timeout;\n+        }\n+\n+        private void succeed(Callback callback, boolean commit)\n+        {\n             if (LOG.isDebugEnabled())\n-                LOG.debug(String.format(\"HTTP2 Response #%d/%h idle timeout %s\", stream.getId(), stream.getSession(), result ? \"expired\" : \"ignored\"), failure);\n-            if (result)\n+                LOG.debug(\"HTTP2 Response #{}/{} {} success\",\n+                    stream.getId(), Integer.toHexString(stream.getSession().hashCode()),\n+                    commit ? \"commit\" : \"flush\");\n+            callback.succeeded();\n+        }\n+\n+        private void fail(Callback callback, boolean commit, Throwable failure)\n+        {\n+            if (LOG.isDebugEnabled())\n+                LOG.debug(\"HTTP2 Response #{}/{} {} failure\",\n+                    stream.getId(), Integer.toHexString(stream.getSession().hashCode()),\n+                    commit ? \"commit\" : \"flush\",\n+                    failure);\n+            if (callback != null)\n                 callback.failed(failure);\n-            return result;\n         }\n \n-        @Override\n-        public InvocationType getInvocationType()\n+        private void idleTimeout(Callback callback, boolean timeout, Throwable failure)\n         {\n-            Callback callback;\n-            synchronized (this)\n-            {\n-                callback = this.callback;\n-            }\n-            return callback != null ? callback.getInvocationType() : Callback.super.getInvocationType();\n+            if (LOG.isDebugEnabled())\n+                LOG.debug(\"HTTP2 Response #{}/{} idle timeout {}\",\n+                    stream.getId(), Integer.toHexString(stream.getSession().hashCode()),\n+                    timeout ? \"expired\" : \"ignored\",\n+                    failure);\n+            if (timeout)\n+                callback.failed(failure);\n         }\n     }\n \n     private enum State\n     {\n-        IDLE, WRITING, FAILED, TIMEOUT\n+        IDLE, PRE_SEND, POST_SEND, SUCCEED, FAIL, FAILED", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjUzNTEzNg=="}, "originalCommit": {"oid": "82529e614f71fbc36d9212377376a33f2d4220f0"}, "originalPosition": 437}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcxOTQ5MDI3OnYy", "diffSide": "RIGHT", "path": "jetty-http2/http2-common/src/main/java/org/eclipse/jetty/http2/api/Stream.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOFQwODo0MjowOFrOGgUUww==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOFQxMDoxOTo1NVrOGgXpWw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjU0MDYxMQ==", "bodyText": "I find this new method's signature and default implementation surprising. I would have expected that the error and reason parameters to go away especially since the overriding implementations just ignore them. Plus the fact that the default implementation drops the failure in favor of calling the deprecated implementation instead of directly succeeding the callback also makes me scratch my head.\nMaybe FailureFrame.getFailure() should return some sort of H2Exception that wraps the original exception as well as containing the reason and error code?", "url": "https://github.com/eclipse/jetty.project/pull/4946#discussion_r436540611", "createdAt": "2020-06-08T08:42:08Z", "author": {"login": "lorban"}, "path": "jetty-http2/http2-common/src/main/java/org/eclipse/jetty/http2/api/Stream.java", "diffHunk": "@@ -227,8 +227,24 @@ default boolean onIdleTimeout(Stream stream, Throwable x)\n          * @param stream the stream\n          * @param error the error code\n          * @param reason the error reason, or null\n+         * @param failure the failure\n          * @param callback the callback to complete when the failure has been handled\n          */\n+        default void onFailure(Stream stream, int error, String reason, Throwable failure, Callback callback)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "82529e614f71fbc36d9212377376a33f2d4220f0"}, "originalPosition": 7}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjU5NTAzNQ==", "bodyText": "This is at the HTTP/2 low-level API so our implementation may not use error and reason but users of these APIs may.\nHowever, there are cases where we still have a failure but not an associated error (e.g. idle timeout and aborts).", "url": "https://github.com/eclipse/jetty.project/pull/4946#discussion_r436595035", "createdAt": "2020-06-08T10:19:55Z", "author": {"login": "sbordet"}, "path": "jetty-http2/http2-common/src/main/java/org/eclipse/jetty/http2/api/Stream.java", "diffHunk": "@@ -227,8 +227,24 @@ default boolean onIdleTimeout(Stream stream, Throwable x)\n          * @param stream the stream\n          * @param error the error code\n          * @param reason the error reason, or null\n+         * @param failure the failure\n          * @param callback the callback to complete when the failure has been handled\n          */\n+        default void onFailure(Stream stream, int error, String reason, Throwable failure, Callback callback)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjU0MDYxMQ=="}, "originalCommit": {"oid": "82529e614f71fbc36d9212377376a33f2d4220f0"}, "originalPosition": 7}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcxOTY2MjI0OnYy", "diffSide": "RIGHT", "path": "jetty-http2/http2-server/src/main/java/org/eclipse/jetty/http2/server/HttpTransportOverHTTP2.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOFQwOToyOTowMFrOGgV-GA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOFQxMDoyNTozNFrOGgX0aQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjU2NzU3Ng==", "bodyText": "I don't like the PRE_SEND,  POST_SEND and SUCCEEDnames as they are confusing in that during PRE_SEND sending is happening and in POST_SEND the send is pending.\nHow about: IDLE -> SENDING -> PENDING -> SUCCEEDED -> FAILED\nI think ING and ED names line up better with our practises elsewhere.", "url": "https://github.com/eclipse/jetty.project/pull/4946#discussion_r436567576", "createdAt": "2020-06-08T09:29:00Z", "author": {"login": "gregw"}, "path": "jetty-http2/http2-server/src/main/java/org/eclipse/jetty/http2/server/HttpTransportOverHTTP2.java", "diffHunk": "@@ -350,119 +351,356 @@ public void abort(Throwable failure)\n             stream.reset(new ResetFrame(stream.getId(), ErrorCode.CANCEL_STREAM_ERROR.code), Callback.NOOP);\n     }\n \n+    /**\n+     * <p>Callback that controls sends initiated by the transport, by eventually\n+     * notifying a nested callback.</p>\n+     * <p>There are 3 sources of concurrency after a send is initiated:</p>\n+     * <ul>\n+     *   <li>the completion of the send operation, either success or failure</li>\n+     *   <li>an asynchronous failure coming from the read side such as a stream\n+     *   being reset, or the connection being closed</li>\n+     *   <li>an asynchronous idle timeout</li>\n+     * </ul>\n+     * <p>The last 2 cases may happen <em>during</em> a send, when the frames\n+     * are being generated in the flusher.\n+     * In such cases, this class must avoid that the nested callback is notified\n+     * while the frame generation is in progress, because the nested callback\n+     * may modify other states (such as clearing the {@code HttpOutput._buffer})\n+     * that are accessed during frame generation.</p>\n+     * <p>The solution implemented in this class works by splitting the send\n+     * operation in 3 parts: {@code preSend()}, {@code send()} and {@code postSend()}.\n+     * Asynchronous state changes happening during {@code send()} are stored\n+     * and only executed in {@code postSend()}, therefore never interfering\n+     * with frame generation.</p>\n+     *\n+     * @see State\n+     */\n     private class TransportCallback implements Callback\n     {\n-        private State state = State.IDLE;\n-        private Callback callback;\n-        private Throwable failure;\n-        private boolean commit;\n+        private State _state = State.IDLE;\n+        private Callback _callback;\n+        private boolean _commit;\n+        private Throwable _failure;\n \n-        public boolean start(Callback callback, boolean commit)\n+        private void reset()\n         {\n-            State state;\n+            assert Thread.holdsLock(this);\n+            _state = State.IDLE;\n+            _callback = null;\n+            _commit = false;\n+            _failure = null;\n+        }\n+\n+        private void send(Callback callback, boolean commit, Consumer<Callback> consumer)\n+        {\n+            Throwable failure = preSend(callback, commit);\n+            if (failure == null)\n+            {\n+                consumer.accept(this);\n+                postSend();\n+            }\n+            else\n+            {\n+                callback.failed(failure);\n+            }\n+        }\n+\n+        private Throwable preSend(Callback callback, boolean commit)\n+        {\n+            synchronized (this)\n+            {\n+                switch (_state)\n+                {\n+                    case IDLE:\n+                    {\n+                        _state = State.PRE_SEND;\n+                        _callback = callback;\n+                        _commit = commit;\n+                        return null;\n+                    }\n+                    default:\n+                    {\n+                        Throwable failure = _failure;\n+                        if (failure == null)\n+                            failure = new IllegalStateException(\"Invalid transport state: \" + _state);\n+                        return failure;\n+                    }\n+                }\n+            }\n+        }\n+\n+        private void postSend()\n+        {\n+            Callback callback;\n+            boolean commit;\n             Throwable failure;\n             synchronized (this)\n             {\n-                state = this.state;\n-                failure = this.failure;\n-                if (state == State.IDLE)\n+                switch (_state)\n                 {\n-                    this.state = State.WRITING;\n-                    this.callback = callback;\n-                    this.commit = commit;\n-                    return true;\n+                    case PRE_SEND:\n+                    {\n+                        _state = State.POST_SEND;\n+                        return;\n+                    }\n+                    case SUCCEED:\n+                    {\n+                        callback = _callback;\n+                        commit = _commit;\n+                        failure = null;\n+                        reset();\n+                        break;\n+                    }\n+                    case FAIL:\n+                    {\n+                        _state = State.FAILED;\n+                        callback = _callback;\n+                        commit = _commit;\n+                        failure = _failure;\n+                        break;\n+                    }\n+                    default:\n+                    {\n+                        _state = State.FAILED;\n+                        _failure = new IllegalStateException(\"Invalid transport state: \" + _state);\n+                        callback = _callback;\n+                        commit = _commit;\n+                        failure = _failure;\n+                        break;\n+                    }\n                 }\n             }\n             if (failure == null)\n-                failure = new IllegalStateException(\"Invalid transport state: \" + state);\n-            callback.failed(failure);\n-            return false;\n+                succeed(callback, commit);\n+            else\n+                fail(callback, commit, failure);\n         }\n \n         @Override\n         public void succeeded()\n         {\n+            Callback callback;\n             boolean commit;\n-            Callback callback = null;\n             synchronized (this)\n             {\n-                commit = this.commit;\n-                if (state == State.WRITING)\n+                switch (_state)\n                 {\n-                    this.state = State.IDLE;\n-                    callback = this.callback;\n-                    this.callback = null;\n-                    this.commit = false;\n+                    case PRE_SEND:\n+                    {\n+                        _state = State.SUCCEED;\n+                        // Succeeding the callback will be done in postSend().\n+                        return;\n+                    }\n+                    case POST_SEND:\n+                    {\n+                        callback = _callback;\n+                        commit = _commit;\n+                        reset();\n+                        break;\n+                    }\n+                    default:\n+                    {\n+                        // This thread lost the race to succeed the current\n+                        // send, as other threads likely already failed it.\n+                        return;\n+                    }\n                 }\n             }\n-            if (LOG.isDebugEnabled())\n-                LOG.debug(\"HTTP2 Response #{}/{} {} {}\",\n-                    stream.getId(), Integer.toHexString(stream.getSession().hashCode()),\n-                    commit ? \"commit\" : \"flush\",\n-                    callback == null ? \"failure\" : \"success\");\n-            if (callback != null)\n-                callback.succeeded();\n+            succeed(callback, commit);\n         }\n \n         @Override\n         public void failed(Throwable failure)\n         {\n-            boolean commit;\n             Callback callback;\n+            boolean commit;\n             synchronized (this)\n             {\n-                commit = this.commit;\n-                this.state = State.FAILED;\n-                callback = this.callback;\n-                this.callback = null;\n-                this.failure = failure;\n+                switch (_state)\n+                {\n+                    case PRE_SEND:\n+                    {\n+                        _state = State.FAIL;\n+                        _failure = failure;\n+                        // Failing the callback will be done in postSend().\n+                        return;\n+                    }\n+                    case IDLE:\n+                    case POST_SEND:\n+                    {\n+                        _state = State.FAILED;\n+                        _failure = failure;\n+                        callback = _callback;\n+                        commit = _commit;\n+                        break;\n+                    }\n+                    default:\n+                    {\n+                        // This thread lost the race to fail the current send,\n+                        // as other threads already succeeded or failed it.\n+                        return;\n+                    }\n+                }\n             }\n-            if (LOG.isDebugEnabled())\n-                LOG.debug(String.format(\"HTTP2 Response #%d/%h %s %s\", stream.getId(), stream.getSession(),\n-                    commit ? \"commit\" : \"flush\", callback == null ? \"ignored\" : \"failed\"), failure);\n-            if (callback != null)\n-                callback.failed(failure);\n+            fail(callback, commit, failure);\n         }\n \n-        private boolean onIdleTimeout(Throwable failure)\n+        private boolean idleTimeout(Throwable failure)\n         {\n-            boolean result;\n-            Callback callback = null;\n+            Callback callback;\n+            boolean timeout;\n             synchronized (this)\n             {\n-                // Ignore idle timeouts if not writing,\n-                // as the application may be suspended.\n-                result = state == State.WRITING;\n-                if (result)\n+                switch (_state)\n                 {\n-                    this.state = State.TIMEOUT;\n-                    callback = this.callback;\n-                    this.callback = null;\n-                    this.failure = failure;\n+                    case POST_SEND:\n+                    {\n+                        // The send was started but idle timed out, fail it.\n+                        _state = State.FAILED;\n+                        _failure = failure;\n+                        callback = _callback;\n+                        timeout = true;\n+                        break;\n+                    }\n+                    case IDLE:\n+                        // The application may be suspended, ignore the idle timeout.\n+                    case PRE_SEND:\n+                        // A send has been started at the same time of an idle timeout;\n+                        // Ignore the idle timeout and let the write continue normally.\n+                    case SUCCEED:\n+                    case FAIL:\n+                        // An idle timeout during these transient states is ignored.\n+                    case FAILED:\n+                        // Already failed, ignore the idle timeout.\n+                    {\n+                        callback = null;\n+                        timeout = false;\n+                        break;\n+                    }\n+                    default:\n+                    {\n+                        // Should not happen, but just in case.\n+                        _state = State.FAILED;\n+                        _failure = new IllegalStateException(\"Invalid transport state: \" + _state, failure);\n+                        callback = _callback;\n+                        if (callback == null)\n+                            callback = Callback.NOOP;\n+                        timeout = true;\n+                        failure = _failure;\n+                        break;\n+                    }\n                 }\n             }\n+            idleTimeout(callback, timeout, failure);\n+            return timeout;\n+        }\n+\n+        private void succeed(Callback callback, boolean commit)\n+        {\n             if (LOG.isDebugEnabled())\n-                LOG.debug(String.format(\"HTTP2 Response #%d/%h idle timeout %s\", stream.getId(), stream.getSession(), result ? \"expired\" : \"ignored\"), failure);\n-            if (result)\n+                LOG.debug(\"HTTP2 Response #{}/{} {} success\",\n+                    stream.getId(), Integer.toHexString(stream.getSession().hashCode()),\n+                    commit ? \"commit\" : \"flush\");\n+            callback.succeeded();\n+        }\n+\n+        private void fail(Callback callback, boolean commit, Throwable failure)\n+        {\n+            if (LOG.isDebugEnabled())\n+                LOG.debug(\"HTTP2 Response #{}/{} {} failure\",\n+                    stream.getId(), Integer.toHexString(stream.getSession().hashCode()),\n+                    commit ? \"commit\" : \"flush\",\n+                    failure);\n+            if (callback != null)\n                 callback.failed(failure);\n-            return result;\n         }\n \n-        @Override\n-        public InvocationType getInvocationType()\n+        private void idleTimeout(Callback callback, boolean timeout, Throwable failure)\n         {\n-            Callback callback;\n-            synchronized (this)\n-            {\n-                callback = this.callback;\n-            }\n-            return callback != null ? callback.getInvocationType() : Callback.super.getInvocationType();\n+            if (LOG.isDebugEnabled())\n+                LOG.debug(\"HTTP2 Response #{}/{} idle timeout {}\",\n+                    stream.getId(), Integer.toHexString(stream.getSession().hashCode()),\n+                    timeout ? \"expired\" : \"ignored\",\n+                    failure);\n+            if (timeout)\n+                callback.failed(failure);\n         }\n     }\n \n+    /**\n+     * <p>Send states for {@link TransportCallback}.</p>\n+     *\n+     * @see TransportCallback\n+     */\n     private enum State\n     {\n-        IDLE, WRITING, FAILED, TIMEOUT\n+        /**\n+         * <p>No send initiated or in progress.</p>\n+         * <p>Next states could be:</p>\n+         * <ul>\n+         *   <li>{@link #PRE_SEND}, when {@link TransportCallback#send(Callback, boolean, Consumer)}\n+         *   is called by the transport to initiate a send</li>\n+         *   <li>{@link #FAILED}, when {@link TransportCallback#failed(Throwable)}\n+         *   is called by an asynchronous failure</li>\n+         * </ul>\n+         */\n+        IDLE,\n+        /**\n+         * <p>A send is initiated; the nested callback in {@link TransportCallback}\n+         * cannot be notified while in this state.</p>\n+         * <p>Next states could be:</p>\n+         * <ul>\n+         *   <li>{@link #SUCCEED}, when {@link TransportCallback#succeeded()}\n+         *   is called synchronously because the send succeeded</li>\n+         *   <li>{@link #FAIL}, when {@link TransportCallback#failed(Throwable)}\n+         *   is called synchronously because the send failed</li>\n+         *   <li>{@link #POST_SEND}, when {@link TransportCallback#postSend()}\n+         *   is called before the send completes</li>\n+         * </ul>\n+         */\n+        PRE_SEND,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "42a5d2785b51f06e3440bbcf4a4d845b5f8bc5e1"}, "originalPosition": 492}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjU5Nzg2NQ==", "bodyText": "They are not correct.\nSUCCEED and FAIL are commands, it's what postSend() should do, either succeed by calling succeeded() or fail by calling failed(Throwable).\nI'm ok with PRE_SEND -> SENDING and POST_SEND -> PENDING, but I need 2 more states for SUCCEED and FAIL as commands about what to do next.\nFAILED is a terminal state (so it cannot be used for the command), but we don't have a SUCCEEDED terminal state (we go back to IDLE).", "url": "https://github.com/eclipse/jetty.project/pull/4946#discussion_r436597865", "createdAt": "2020-06-08T10:25:34Z", "author": {"login": "sbordet"}, "path": "jetty-http2/http2-server/src/main/java/org/eclipse/jetty/http2/server/HttpTransportOverHTTP2.java", "diffHunk": "@@ -350,119 +351,356 @@ public void abort(Throwable failure)\n             stream.reset(new ResetFrame(stream.getId(), ErrorCode.CANCEL_STREAM_ERROR.code), Callback.NOOP);\n     }\n \n+    /**\n+     * <p>Callback that controls sends initiated by the transport, by eventually\n+     * notifying a nested callback.</p>\n+     * <p>There are 3 sources of concurrency after a send is initiated:</p>\n+     * <ul>\n+     *   <li>the completion of the send operation, either success or failure</li>\n+     *   <li>an asynchronous failure coming from the read side such as a stream\n+     *   being reset, or the connection being closed</li>\n+     *   <li>an asynchronous idle timeout</li>\n+     * </ul>\n+     * <p>The last 2 cases may happen <em>during</em> a send, when the frames\n+     * are being generated in the flusher.\n+     * In such cases, this class must avoid that the nested callback is notified\n+     * while the frame generation is in progress, because the nested callback\n+     * may modify other states (such as clearing the {@code HttpOutput._buffer})\n+     * that are accessed during frame generation.</p>\n+     * <p>The solution implemented in this class works by splitting the send\n+     * operation in 3 parts: {@code preSend()}, {@code send()} and {@code postSend()}.\n+     * Asynchronous state changes happening during {@code send()} are stored\n+     * and only executed in {@code postSend()}, therefore never interfering\n+     * with frame generation.</p>\n+     *\n+     * @see State\n+     */\n     private class TransportCallback implements Callback\n     {\n-        private State state = State.IDLE;\n-        private Callback callback;\n-        private Throwable failure;\n-        private boolean commit;\n+        private State _state = State.IDLE;\n+        private Callback _callback;\n+        private boolean _commit;\n+        private Throwable _failure;\n \n-        public boolean start(Callback callback, boolean commit)\n+        private void reset()\n         {\n-            State state;\n+            assert Thread.holdsLock(this);\n+            _state = State.IDLE;\n+            _callback = null;\n+            _commit = false;\n+            _failure = null;\n+        }\n+\n+        private void send(Callback callback, boolean commit, Consumer<Callback> consumer)\n+        {\n+            Throwable failure = preSend(callback, commit);\n+            if (failure == null)\n+            {\n+                consumer.accept(this);\n+                postSend();\n+            }\n+            else\n+            {\n+                callback.failed(failure);\n+            }\n+        }\n+\n+        private Throwable preSend(Callback callback, boolean commit)\n+        {\n+            synchronized (this)\n+            {\n+                switch (_state)\n+                {\n+                    case IDLE:\n+                    {\n+                        _state = State.PRE_SEND;\n+                        _callback = callback;\n+                        _commit = commit;\n+                        return null;\n+                    }\n+                    default:\n+                    {\n+                        Throwable failure = _failure;\n+                        if (failure == null)\n+                            failure = new IllegalStateException(\"Invalid transport state: \" + _state);\n+                        return failure;\n+                    }\n+                }\n+            }\n+        }\n+\n+        private void postSend()\n+        {\n+            Callback callback;\n+            boolean commit;\n             Throwable failure;\n             synchronized (this)\n             {\n-                state = this.state;\n-                failure = this.failure;\n-                if (state == State.IDLE)\n+                switch (_state)\n                 {\n-                    this.state = State.WRITING;\n-                    this.callback = callback;\n-                    this.commit = commit;\n-                    return true;\n+                    case PRE_SEND:\n+                    {\n+                        _state = State.POST_SEND;\n+                        return;\n+                    }\n+                    case SUCCEED:\n+                    {\n+                        callback = _callback;\n+                        commit = _commit;\n+                        failure = null;\n+                        reset();\n+                        break;\n+                    }\n+                    case FAIL:\n+                    {\n+                        _state = State.FAILED;\n+                        callback = _callback;\n+                        commit = _commit;\n+                        failure = _failure;\n+                        break;\n+                    }\n+                    default:\n+                    {\n+                        _state = State.FAILED;\n+                        _failure = new IllegalStateException(\"Invalid transport state: \" + _state);\n+                        callback = _callback;\n+                        commit = _commit;\n+                        failure = _failure;\n+                        break;\n+                    }\n                 }\n             }\n             if (failure == null)\n-                failure = new IllegalStateException(\"Invalid transport state: \" + state);\n-            callback.failed(failure);\n-            return false;\n+                succeed(callback, commit);\n+            else\n+                fail(callback, commit, failure);\n         }\n \n         @Override\n         public void succeeded()\n         {\n+            Callback callback;\n             boolean commit;\n-            Callback callback = null;\n             synchronized (this)\n             {\n-                commit = this.commit;\n-                if (state == State.WRITING)\n+                switch (_state)\n                 {\n-                    this.state = State.IDLE;\n-                    callback = this.callback;\n-                    this.callback = null;\n-                    this.commit = false;\n+                    case PRE_SEND:\n+                    {\n+                        _state = State.SUCCEED;\n+                        // Succeeding the callback will be done in postSend().\n+                        return;\n+                    }\n+                    case POST_SEND:\n+                    {\n+                        callback = _callback;\n+                        commit = _commit;\n+                        reset();\n+                        break;\n+                    }\n+                    default:\n+                    {\n+                        // This thread lost the race to succeed the current\n+                        // send, as other threads likely already failed it.\n+                        return;\n+                    }\n                 }\n             }\n-            if (LOG.isDebugEnabled())\n-                LOG.debug(\"HTTP2 Response #{}/{} {} {}\",\n-                    stream.getId(), Integer.toHexString(stream.getSession().hashCode()),\n-                    commit ? \"commit\" : \"flush\",\n-                    callback == null ? \"failure\" : \"success\");\n-            if (callback != null)\n-                callback.succeeded();\n+            succeed(callback, commit);\n         }\n \n         @Override\n         public void failed(Throwable failure)\n         {\n-            boolean commit;\n             Callback callback;\n+            boolean commit;\n             synchronized (this)\n             {\n-                commit = this.commit;\n-                this.state = State.FAILED;\n-                callback = this.callback;\n-                this.callback = null;\n-                this.failure = failure;\n+                switch (_state)\n+                {\n+                    case PRE_SEND:\n+                    {\n+                        _state = State.FAIL;\n+                        _failure = failure;\n+                        // Failing the callback will be done in postSend().\n+                        return;\n+                    }\n+                    case IDLE:\n+                    case POST_SEND:\n+                    {\n+                        _state = State.FAILED;\n+                        _failure = failure;\n+                        callback = _callback;\n+                        commit = _commit;\n+                        break;\n+                    }\n+                    default:\n+                    {\n+                        // This thread lost the race to fail the current send,\n+                        // as other threads already succeeded or failed it.\n+                        return;\n+                    }\n+                }\n             }\n-            if (LOG.isDebugEnabled())\n-                LOG.debug(String.format(\"HTTP2 Response #%d/%h %s %s\", stream.getId(), stream.getSession(),\n-                    commit ? \"commit\" : \"flush\", callback == null ? \"ignored\" : \"failed\"), failure);\n-            if (callback != null)\n-                callback.failed(failure);\n+            fail(callback, commit, failure);\n         }\n \n-        private boolean onIdleTimeout(Throwable failure)\n+        private boolean idleTimeout(Throwable failure)\n         {\n-            boolean result;\n-            Callback callback = null;\n+            Callback callback;\n+            boolean timeout;\n             synchronized (this)\n             {\n-                // Ignore idle timeouts if not writing,\n-                // as the application may be suspended.\n-                result = state == State.WRITING;\n-                if (result)\n+                switch (_state)\n                 {\n-                    this.state = State.TIMEOUT;\n-                    callback = this.callback;\n-                    this.callback = null;\n-                    this.failure = failure;\n+                    case POST_SEND:\n+                    {\n+                        // The send was started but idle timed out, fail it.\n+                        _state = State.FAILED;\n+                        _failure = failure;\n+                        callback = _callback;\n+                        timeout = true;\n+                        break;\n+                    }\n+                    case IDLE:\n+                        // The application may be suspended, ignore the idle timeout.\n+                    case PRE_SEND:\n+                        // A send has been started at the same time of an idle timeout;\n+                        // Ignore the idle timeout and let the write continue normally.\n+                    case SUCCEED:\n+                    case FAIL:\n+                        // An idle timeout during these transient states is ignored.\n+                    case FAILED:\n+                        // Already failed, ignore the idle timeout.\n+                    {\n+                        callback = null;\n+                        timeout = false;\n+                        break;\n+                    }\n+                    default:\n+                    {\n+                        // Should not happen, but just in case.\n+                        _state = State.FAILED;\n+                        _failure = new IllegalStateException(\"Invalid transport state: \" + _state, failure);\n+                        callback = _callback;\n+                        if (callback == null)\n+                            callback = Callback.NOOP;\n+                        timeout = true;\n+                        failure = _failure;\n+                        break;\n+                    }\n                 }\n             }\n+            idleTimeout(callback, timeout, failure);\n+            return timeout;\n+        }\n+\n+        private void succeed(Callback callback, boolean commit)\n+        {\n             if (LOG.isDebugEnabled())\n-                LOG.debug(String.format(\"HTTP2 Response #%d/%h idle timeout %s\", stream.getId(), stream.getSession(), result ? \"expired\" : \"ignored\"), failure);\n-            if (result)\n+                LOG.debug(\"HTTP2 Response #{}/{} {} success\",\n+                    stream.getId(), Integer.toHexString(stream.getSession().hashCode()),\n+                    commit ? \"commit\" : \"flush\");\n+            callback.succeeded();\n+        }\n+\n+        private void fail(Callback callback, boolean commit, Throwable failure)\n+        {\n+            if (LOG.isDebugEnabled())\n+                LOG.debug(\"HTTP2 Response #{}/{} {} failure\",\n+                    stream.getId(), Integer.toHexString(stream.getSession().hashCode()),\n+                    commit ? \"commit\" : \"flush\",\n+                    failure);\n+            if (callback != null)\n                 callback.failed(failure);\n-            return result;\n         }\n \n-        @Override\n-        public InvocationType getInvocationType()\n+        private void idleTimeout(Callback callback, boolean timeout, Throwable failure)\n         {\n-            Callback callback;\n-            synchronized (this)\n-            {\n-                callback = this.callback;\n-            }\n-            return callback != null ? callback.getInvocationType() : Callback.super.getInvocationType();\n+            if (LOG.isDebugEnabled())\n+                LOG.debug(\"HTTP2 Response #{}/{} idle timeout {}\",\n+                    stream.getId(), Integer.toHexString(stream.getSession().hashCode()),\n+                    timeout ? \"expired\" : \"ignored\",\n+                    failure);\n+            if (timeout)\n+                callback.failed(failure);\n         }\n     }\n \n+    /**\n+     * <p>Send states for {@link TransportCallback}.</p>\n+     *\n+     * @see TransportCallback\n+     */\n     private enum State\n     {\n-        IDLE, WRITING, FAILED, TIMEOUT\n+        /**\n+         * <p>No send initiated or in progress.</p>\n+         * <p>Next states could be:</p>\n+         * <ul>\n+         *   <li>{@link #PRE_SEND}, when {@link TransportCallback#send(Callback, boolean, Consumer)}\n+         *   is called by the transport to initiate a send</li>\n+         *   <li>{@link #FAILED}, when {@link TransportCallback#failed(Throwable)}\n+         *   is called by an asynchronous failure</li>\n+         * </ul>\n+         */\n+        IDLE,\n+        /**\n+         * <p>A send is initiated; the nested callback in {@link TransportCallback}\n+         * cannot be notified while in this state.</p>\n+         * <p>Next states could be:</p>\n+         * <ul>\n+         *   <li>{@link #SUCCEED}, when {@link TransportCallback#succeeded()}\n+         *   is called synchronously because the send succeeded</li>\n+         *   <li>{@link #FAIL}, when {@link TransportCallback#failed(Throwable)}\n+         *   is called synchronously because the send failed</li>\n+         *   <li>{@link #POST_SEND}, when {@link TransportCallback#postSend()}\n+         *   is called before the send completes</li>\n+         * </ul>\n+         */\n+        PRE_SEND,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjU2NzU3Ng=="}, "originalCommit": {"oid": "42a5d2785b51f06e3440bbcf4a4d845b5f8bc5e1"}, "originalPosition": 492}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcxOTY3NDUwOnYy", "diffSide": "RIGHT", "path": "jetty-http2/http2-server/src/main/java/org/eclipse/jetty/http2/server/HttpTransportOverHTTP2.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOFQwOTozMjo0M1rOGgWFxA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOFQxMDozMTo1NVrOGgYAtA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjU2OTU0MA==", "bodyText": "rename method to onSending", "url": "https://github.com/eclipse/jetty.project/pull/4946#discussion_r436569540", "createdAt": "2020-06-08T09:32:43Z", "author": {"login": "gregw"}, "path": "jetty-http2/http2-server/src/main/java/org/eclipse/jetty/http2/server/HttpTransportOverHTTP2.java", "diffHunk": "@@ -350,119 +351,356 @@ public void abort(Throwable failure)\n             stream.reset(new ResetFrame(stream.getId(), ErrorCode.CANCEL_STREAM_ERROR.code), Callback.NOOP);\n     }\n \n+    /**\n+     * <p>Callback that controls sends initiated by the transport, by eventually\n+     * notifying a nested callback.</p>\n+     * <p>There are 3 sources of concurrency after a send is initiated:</p>\n+     * <ul>\n+     *   <li>the completion of the send operation, either success or failure</li>\n+     *   <li>an asynchronous failure coming from the read side such as a stream\n+     *   being reset, or the connection being closed</li>\n+     *   <li>an asynchronous idle timeout</li>\n+     * </ul>\n+     * <p>The last 2 cases may happen <em>during</em> a send, when the frames\n+     * are being generated in the flusher.\n+     * In such cases, this class must avoid that the nested callback is notified\n+     * while the frame generation is in progress, because the nested callback\n+     * may modify other states (such as clearing the {@code HttpOutput._buffer})\n+     * that are accessed during frame generation.</p>\n+     * <p>The solution implemented in this class works by splitting the send\n+     * operation in 3 parts: {@code preSend()}, {@code send()} and {@code postSend()}.\n+     * Asynchronous state changes happening during {@code send()} are stored\n+     * and only executed in {@code postSend()}, therefore never interfering\n+     * with frame generation.</p>\n+     *\n+     * @see State\n+     */\n     private class TransportCallback implements Callback\n     {\n-        private State state = State.IDLE;\n-        private Callback callback;\n-        private Throwable failure;\n-        private boolean commit;\n+        private State _state = State.IDLE;\n+        private Callback _callback;\n+        private boolean _commit;\n+        private Throwable _failure;\n \n-        public boolean start(Callback callback, boolean commit)\n+        private void reset()\n         {\n-            State state;\n+            assert Thread.holdsLock(this);\n+            _state = State.IDLE;\n+            _callback = null;\n+            _commit = false;\n+            _failure = null;\n+        }\n+\n+        private void send(Callback callback, boolean commit, Consumer<Callback> consumer)\n+        {\n+            Throwable failure = preSend(callback, commit);\n+            if (failure == null)\n+            {\n+                consumer.accept(this);\n+                postSend();\n+            }\n+            else\n+            {\n+                callback.failed(failure);\n+            }\n+        }\n+\n+        private Throwable preSend(Callback callback, boolean commit)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "42a5d2785b51f06e3440bbcf4a4d845b5f8bc5e1"}, "originalPosition": 181}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjYwMTAxMg==", "bodyText": "Perhaps, after we agree on state names.", "url": "https://github.com/eclipse/jetty.project/pull/4946#discussion_r436601012", "createdAt": "2020-06-08T10:31:55Z", "author": {"login": "sbordet"}, "path": "jetty-http2/http2-server/src/main/java/org/eclipse/jetty/http2/server/HttpTransportOverHTTP2.java", "diffHunk": "@@ -350,119 +351,356 @@ public void abort(Throwable failure)\n             stream.reset(new ResetFrame(stream.getId(), ErrorCode.CANCEL_STREAM_ERROR.code), Callback.NOOP);\n     }\n \n+    /**\n+     * <p>Callback that controls sends initiated by the transport, by eventually\n+     * notifying a nested callback.</p>\n+     * <p>There are 3 sources of concurrency after a send is initiated:</p>\n+     * <ul>\n+     *   <li>the completion of the send operation, either success or failure</li>\n+     *   <li>an asynchronous failure coming from the read side such as a stream\n+     *   being reset, or the connection being closed</li>\n+     *   <li>an asynchronous idle timeout</li>\n+     * </ul>\n+     * <p>The last 2 cases may happen <em>during</em> a send, when the frames\n+     * are being generated in the flusher.\n+     * In such cases, this class must avoid that the nested callback is notified\n+     * while the frame generation is in progress, because the nested callback\n+     * may modify other states (such as clearing the {@code HttpOutput._buffer})\n+     * that are accessed during frame generation.</p>\n+     * <p>The solution implemented in this class works by splitting the send\n+     * operation in 3 parts: {@code preSend()}, {@code send()} and {@code postSend()}.\n+     * Asynchronous state changes happening during {@code send()} are stored\n+     * and only executed in {@code postSend()}, therefore never interfering\n+     * with frame generation.</p>\n+     *\n+     * @see State\n+     */\n     private class TransportCallback implements Callback\n     {\n-        private State state = State.IDLE;\n-        private Callback callback;\n-        private Throwable failure;\n-        private boolean commit;\n+        private State _state = State.IDLE;\n+        private Callback _callback;\n+        private boolean _commit;\n+        private Throwable _failure;\n \n-        public boolean start(Callback callback, boolean commit)\n+        private void reset()\n         {\n-            State state;\n+            assert Thread.holdsLock(this);\n+            _state = State.IDLE;\n+            _callback = null;\n+            _commit = false;\n+            _failure = null;\n+        }\n+\n+        private void send(Callback callback, boolean commit, Consumer<Callback> consumer)\n+        {\n+            Throwable failure = preSend(callback, commit);\n+            if (failure == null)\n+            {\n+                consumer.accept(this);\n+                postSend();\n+            }\n+            else\n+            {\n+                callback.failed(failure);\n+            }\n+        }\n+\n+        private Throwable preSend(Callback callback, boolean commit)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjU2OTU0MA=="}, "originalCommit": {"oid": "42a5d2785b51f06e3440bbcf4a4d845b5f8bc5e1"}, "originalPosition": 181}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcxOTY5MjY5OnYy", "diffSide": "RIGHT", "path": "jetty-http2/http2-server/src/main/java/org/eclipse/jetty/http2/server/HttpTransportOverHTTP2.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOFQwOTozODowMFrOGgWRRg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOFQxMDoyOTozNFrOGgX8BQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjU3MjQ4Ng==", "bodyText": "This is not one case but two. Also needs comments:\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                default:\n          \n          \n            \n                                {\n          \n          \n            \n                                    Throwable failure = _failure;\n          \n          \n            \n                                    if (failure == null)\n          \n          \n            \n                                        failure = new IllegalStateException(\"Invalid transport state: \" + _state);\n          \n          \n            \n                                    return failure;\n          \n          \n            \n                                }\n          \n          \n            \n                                case FAIL:\n          \n          \n            \n                                    // better comment that an async failure happened while we were just about to send something\n          \n          \n            \n                                    return _failure;\n          \n          \n            \n                                default:\n          \n          \n            \n                                    return new IllegalStateException(\"Invalid transport state: \" + _state);", "url": "https://github.com/eclipse/jetty.project/pull/4946#discussion_r436572486", "createdAt": "2020-06-08T09:38:00Z", "author": {"login": "gregw"}, "path": "jetty-http2/http2-server/src/main/java/org/eclipse/jetty/http2/server/HttpTransportOverHTTP2.java", "diffHunk": "@@ -350,119 +351,356 @@ public void abort(Throwable failure)\n             stream.reset(new ResetFrame(stream.getId(), ErrorCode.CANCEL_STREAM_ERROR.code), Callback.NOOP);\n     }\n \n+    /**\n+     * <p>Callback that controls sends initiated by the transport, by eventually\n+     * notifying a nested callback.</p>\n+     * <p>There are 3 sources of concurrency after a send is initiated:</p>\n+     * <ul>\n+     *   <li>the completion of the send operation, either success or failure</li>\n+     *   <li>an asynchronous failure coming from the read side such as a stream\n+     *   being reset, or the connection being closed</li>\n+     *   <li>an asynchronous idle timeout</li>\n+     * </ul>\n+     * <p>The last 2 cases may happen <em>during</em> a send, when the frames\n+     * are being generated in the flusher.\n+     * In such cases, this class must avoid that the nested callback is notified\n+     * while the frame generation is in progress, because the nested callback\n+     * may modify other states (such as clearing the {@code HttpOutput._buffer})\n+     * that are accessed during frame generation.</p>\n+     * <p>The solution implemented in this class works by splitting the send\n+     * operation in 3 parts: {@code preSend()}, {@code send()} and {@code postSend()}.\n+     * Asynchronous state changes happening during {@code send()} are stored\n+     * and only executed in {@code postSend()}, therefore never interfering\n+     * with frame generation.</p>\n+     *\n+     * @see State\n+     */\n     private class TransportCallback implements Callback\n     {\n-        private State state = State.IDLE;\n-        private Callback callback;\n-        private Throwable failure;\n-        private boolean commit;\n+        private State _state = State.IDLE;\n+        private Callback _callback;\n+        private boolean _commit;\n+        private Throwable _failure;\n \n-        public boolean start(Callback callback, boolean commit)\n+        private void reset()\n         {\n-            State state;\n+            assert Thread.holdsLock(this);\n+            _state = State.IDLE;\n+            _callback = null;\n+            _commit = false;\n+            _failure = null;\n+        }\n+\n+        private void send(Callback callback, boolean commit, Consumer<Callback> consumer)\n+        {\n+            Throwable failure = preSend(callback, commit);\n+            if (failure == null)\n+            {\n+                consumer.accept(this);\n+                postSend();\n+            }\n+            else\n+            {\n+                callback.failed(failure);\n+            }\n+        }\n+\n+        private Throwable preSend(Callback callback, boolean commit)\n+        {\n+            synchronized (this)\n+            {\n+                switch (_state)\n+                {\n+                    case IDLE:\n+                    {\n+                        _state = State.PRE_SEND;\n+                        _callback = callback;\n+                        _commit = commit;\n+                        return null;\n+                    }\n+                    default:\n+                    {\n+                        Throwable failure = _failure;\n+                        if (failure == null)\n+                            failure = new IllegalStateException(\"Invalid transport state: \" + _state);\n+                        return failure;\n+                    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "42a5d2785b51f06e3440bbcf4a4d845b5f8bc5e1"}, "originalPosition": 200}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjU5OTgxMw==", "bodyText": "FAIL here is an illegal state.\nFAILED here is legal and I can return failure like you propose.\nHowever, is that what you meant?", "url": "https://github.com/eclipse/jetty.project/pull/4946#discussion_r436599813", "createdAt": "2020-06-08T10:29:34Z", "author": {"login": "sbordet"}, "path": "jetty-http2/http2-server/src/main/java/org/eclipse/jetty/http2/server/HttpTransportOverHTTP2.java", "diffHunk": "@@ -350,119 +351,356 @@ public void abort(Throwable failure)\n             stream.reset(new ResetFrame(stream.getId(), ErrorCode.CANCEL_STREAM_ERROR.code), Callback.NOOP);\n     }\n \n+    /**\n+     * <p>Callback that controls sends initiated by the transport, by eventually\n+     * notifying a nested callback.</p>\n+     * <p>There are 3 sources of concurrency after a send is initiated:</p>\n+     * <ul>\n+     *   <li>the completion of the send operation, either success or failure</li>\n+     *   <li>an asynchronous failure coming from the read side such as a stream\n+     *   being reset, or the connection being closed</li>\n+     *   <li>an asynchronous idle timeout</li>\n+     * </ul>\n+     * <p>The last 2 cases may happen <em>during</em> a send, when the frames\n+     * are being generated in the flusher.\n+     * In such cases, this class must avoid that the nested callback is notified\n+     * while the frame generation is in progress, because the nested callback\n+     * may modify other states (such as clearing the {@code HttpOutput._buffer})\n+     * that are accessed during frame generation.</p>\n+     * <p>The solution implemented in this class works by splitting the send\n+     * operation in 3 parts: {@code preSend()}, {@code send()} and {@code postSend()}.\n+     * Asynchronous state changes happening during {@code send()} are stored\n+     * and only executed in {@code postSend()}, therefore never interfering\n+     * with frame generation.</p>\n+     *\n+     * @see State\n+     */\n     private class TransportCallback implements Callback\n     {\n-        private State state = State.IDLE;\n-        private Callback callback;\n-        private Throwable failure;\n-        private boolean commit;\n+        private State _state = State.IDLE;\n+        private Callback _callback;\n+        private boolean _commit;\n+        private Throwable _failure;\n \n-        public boolean start(Callback callback, boolean commit)\n+        private void reset()\n         {\n-            State state;\n+            assert Thread.holdsLock(this);\n+            _state = State.IDLE;\n+            _callback = null;\n+            _commit = false;\n+            _failure = null;\n+        }\n+\n+        private void send(Callback callback, boolean commit, Consumer<Callback> consumer)\n+        {\n+            Throwable failure = preSend(callback, commit);\n+            if (failure == null)\n+            {\n+                consumer.accept(this);\n+                postSend();\n+            }\n+            else\n+            {\n+                callback.failed(failure);\n+            }\n+        }\n+\n+        private Throwable preSend(Callback callback, boolean commit)\n+        {\n+            synchronized (this)\n+            {\n+                switch (_state)\n+                {\n+                    case IDLE:\n+                    {\n+                        _state = State.PRE_SEND;\n+                        _callback = callback;\n+                        _commit = commit;\n+                        return null;\n+                    }\n+                    default:\n+                    {\n+                        Throwable failure = _failure;\n+                        if (failure == null)\n+                            failure = new IllegalStateException(\"Invalid transport state: \" + _state);\n+                        return failure;\n+                    }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjU3MjQ4Ng=="}, "originalCommit": {"oid": "42a5d2785b51f06e3440bbcf4a4d845b5f8bc5e1"}, "originalPosition": 200}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcxOTY5NDY0OnYy", "diffSide": "RIGHT", "path": "jetty-http2/http2-server/src/main/java/org/eclipse/jetty/http2/server/HttpTransportOverHTTP2.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOFQwOTozODozNFrOGgWSaw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOFQxMDozMjowM1rOGgYA7w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjU3Mjc3OQ==", "bodyText": "rename to onSent", "url": "https://github.com/eclipse/jetty.project/pull/4946#discussion_r436572779", "createdAt": "2020-06-08T09:38:34Z", "author": {"login": "gregw"}, "path": "jetty-http2/http2-server/src/main/java/org/eclipse/jetty/http2/server/HttpTransportOverHTTP2.java", "diffHunk": "@@ -350,119 +351,356 @@ public void abort(Throwable failure)\n             stream.reset(new ResetFrame(stream.getId(), ErrorCode.CANCEL_STREAM_ERROR.code), Callback.NOOP);\n     }\n \n+    /**\n+     * <p>Callback that controls sends initiated by the transport, by eventually\n+     * notifying a nested callback.</p>\n+     * <p>There are 3 sources of concurrency after a send is initiated:</p>\n+     * <ul>\n+     *   <li>the completion of the send operation, either success or failure</li>\n+     *   <li>an asynchronous failure coming from the read side such as a stream\n+     *   being reset, or the connection being closed</li>\n+     *   <li>an asynchronous idle timeout</li>\n+     * </ul>\n+     * <p>The last 2 cases may happen <em>during</em> a send, when the frames\n+     * are being generated in the flusher.\n+     * In such cases, this class must avoid that the nested callback is notified\n+     * while the frame generation is in progress, because the nested callback\n+     * may modify other states (such as clearing the {@code HttpOutput._buffer})\n+     * that are accessed during frame generation.</p>\n+     * <p>The solution implemented in this class works by splitting the send\n+     * operation in 3 parts: {@code preSend()}, {@code send()} and {@code postSend()}.\n+     * Asynchronous state changes happening during {@code send()} are stored\n+     * and only executed in {@code postSend()}, therefore never interfering\n+     * with frame generation.</p>\n+     *\n+     * @see State\n+     */\n     private class TransportCallback implements Callback\n     {\n-        private State state = State.IDLE;\n-        private Callback callback;\n-        private Throwable failure;\n-        private boolean commit;\n+        private State _state = State.IDLE;\n+        private Callback _callback;\n+        private boolean _commit;\n+        private Throwable _failure;\n \n-        public boolean start(Callback callback, boolean commit)\n+        private void reset()\n         {\n-            State state;\n+            assert Thread.holdsLock(this);\n+            _state = State.IDLE;\n+            _callback = null;\n+            _commit = false;\n+            _failure = null;\n+        }\n+\n+        private void send(Callback callback, boolean commit, Consumer<Callback> consumer)\n+        {\n+            Throwable failure = preSend(callback, commit);\n+            if (failure == null)\n+            {\n+                consumer.accept(this);\n+                postSend();\n+            }\n+            else\n+            {\n+                callback.failed(failure);\n+            }\n+        }\n+\n+        private Throwable preSend(Callback callback, boolean commit)\n+        {\n+            synchronized (this)\n+            {\n+                switch (_state)\n+                {\n+                    case IDLE:\n+                    {\n+                        _state = State.PRE_SEND;\n+                        _callback = callback;\n+                        _commit = commit;\n+                        return null;\n+                    }\n+                    default:\n+                    {\n+                        Throwable failure = _failure;\n+                        if (failure == null)\n+                            failure = new IllegalStateException(\"Invalid transport state: \" + _state);\n+                        return failure;\n+                    }\n+                }\n+            }\n+        }\n+\n+        private void postSend()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "42a5d2785b51f06e3440bbcf4a4d845b5f8bc5e1"}, "originalPosition": 205}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjYwMTA3MQ==", "bodyText": "Perhaps, after we agree on state names.", "url": "https://github.com/eclipse/jetty.project/pull/4946#discussion_r436601071", "createdAt": "2020-06-08T10:32:03Z", "author": {"login": "sbordet"}, "path": "jetty-http2/http2-server/src/main/java/org/eclipse/jetty/http2/server/HttpTransportOverHTTP2.java", "diffHunk": "@@ -350,119 +351,356 @@ public void abort(Throwable failure)\n             stream.reset(new ResetFrame(stream.getId(), ErrorCode.CANCEL_STREAM_ERROR.code), Callback.NOOP);\n     }\n \n+    /**\n+     * <p>Callback that controls sends initiated by the transport, by eventually\n+     * notifying a nested callback.</p>\n+     * <p>There are 3 sources of concurrency after a send is initiated:</p>\n+     * <ul>\n+     *   <li>the completion of the send operation, either success or failure</li>\n+     *   <li>an asynchronous failure coming from the read side such as a stream\n+     *   being reset, or the connection being closed</li>\n+     *   <li>an asynchronous idle timeout</li>\n+     * </ul>\n+     * <p>The last 2 cases may happen <em>during</em> a send, when the frames\n+     * are being generated in the flusher.\n+     * In such cases, this class must avoid that the nested callback is notified\n+     * while the frame generation is in progress, because the nested callback\n+     * may modify other states (such as clearing the {@code HttpOutput._buffer})\n+     * that are accessed during frame generation.</p>\n+     * <p>The solution implemented in this class works by splitting the send\n+     * operation in 3 parts: {@code preSend()}, {@code send()} and {@code postSend()}.\n+     * Asynchronous state changes happening during {@code send()} are stored\n+     * and only executed in {@code postSend()}, therefore never interfering\n+     * with frame generation.</p>\n+     *\n+     * @see State\n+     */\n     private class TransportCallback implements Callback\n     {\n-        private State state = State.IDLE;\n-        private Callback callback;\n-        private Throwable failure;\n-        private boolean commit;\n+        private State _state = State.IDLE;\n+        private Callback _callback;\n+        private boolean _commit;\n+        private Throwable _failure;\n \n-        public boolean start(Callback callback, boolean commit)\n+        private void reset()\n         {\n-            State state;\n+            assert Thread.holdsLock(this);\n+            _state = State.IDLE;\n+            _callback = null;\n+            _commit = false;\n+            _failure = null;\n+        }\n+\n+        private void send(Callback callback, boolean commit, Consumer<Callback> consumer)\n+        {\n+            Throwable failure = preSend(callback, commit);\n+            if (failure == null)\n+            {\n+                consumer.accept(this);\n+                postSend();\n+            }\n+            else\n+            {\n+                callback.failed(failure);\n+            }\n+        }\n+\n+        private Throwable preSend(Callback callback, boolean commit)\n+        {\n+            synchronized (this)\n+            {\n+                switch (_state)\n+                {\n+                    case IDLE:\n+                    {\n+                        _state = State.PRE_SEND;\n+                        _callback = callback;\n+                        _commit = commit;\n+                        return null;\n+                    }\n+                    default:\n+                    {\n+                        Throwable failure = _failure;\n+                        if (failure == null)\n+                            failure = new IllegalStateException(\"Invalid transport state: \" + _state);\n+                        return failure;\n+                    }\n+                }\n+            }\n+        }\n+\n+        private void postSend()", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjU3Mjc3OQ=="}, "originalCommit": {"oid": "42a5d2785b51f06e3440bbcf4a4d845b5f8bc5e1"}, "originalPosition": 205}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcxOTY5ODkzOnYy", "diffSide": "RIGHT", "path": "jetty-http2/http2-server/src/main/java/org/eclipse/jetty/http2/server/HttpTransportOverHTTP2.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOFQwOTozOTo0M1rOGgWVBg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOFQwOTozOTo0M1rOGgWVBg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjU3MzQ0Ng==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                    _state = State.POST_SEND;\n          \n          \n            \n                                    // The send has not yet completed, wait for success or failure\n          \n          \n            \n                                    _state = State.PENDING;", "url": "https://github.com/eclipse/jetty.project/pull/4946#discussion_r436573446", "createdAt": "2020-06-08T09:39:43Z", "author": {"login": "gregw"}, "path": "jetty-http2/http2-server/src/main/java/org/eclipse/jetty/http2/server/HttpTransportOverHTTP2.java", "diffHunk": "@@ -350,119 +351,356 @@ public void abort(Throwable failure)\n             stream.reset(new ResetFrame(stream.getId(), ErrorCode.CANCEL_STREAM_ERROR.code), Callback.NOOP);\n     }\n \n+    /**\n+     * <p>Callback that controls sends initiated by the transport, by eventually\n+     * notifying a nested callback.</p>\n+     * <p>There are 3 sources of concurrency after a send is initiated:</p>\n+     * <ul>\n+     *   <li>the completion of the send operation, either success or failure</li>\n+     *   <li>an asynchronous failure coming from the read side such as a stream\n+     *   being reset, or the connection being closed</li>\n+     *   <li>an asynchronous idle timeout</li>\n+     * </ul>\n+     * <p>The last 2 cases may happen <em>during</em> a send, when the frames\n+     * are being generated in the flusher.\n+     * In such cases, this class must avoid that the nested callback is notified\n+     * while the frame generation is in progress, because the nested callback\n+     * may modify other states (such as clearing the {@code HttpOutput._buffer})\n+     * that are accessed during frame generation.</p>\n+     * <p>The solution implemented in this class works by splitting the send\n+     * operation in 3 parts: {@code preSend()}, {@code send()} and {@code postSend()}.\n+     * Asynchronous state changes happening during {@code send()} are stored\n+     * and only executed in {@code postSend()}, therefore never interfering\n+     * with frame generation.</p>\n+     *\n+     * @see State\n+     */\n     private class TransportCallback implements Callback\n     {\n-        private State state = State.IDLE;\n-        private Callback callback;\n-        private Throwable failure;\n-        private boolean commit;\n+        private State _state = State.IDLE;\n+        private Callback _callback;\n+        private boolean _commit;\n+        private Throwable _failure;\n \n-        public boolean start(Callback callback, boolean commit)\n+        private void reset()\n         {\n-            State state;\n+            assert Thread.holdsLock(this);\n+            _state = State.IDLE;\n+            _callback = null;\n+            _commit = false;\n+            _failure = null;\n+        }\n+\n+        private void send(Callback callback, boolean commit, Consumer<Callback> consumer)\n+        {\n+            Throwable failure = preSend(callback, commit);\n+            if (failure == null)\n+            {\n+                consumer.accept(this);\n+                postSend();\n+            }\n+            else\n+            {\n+                callback.failed(failure);\n+            }\n+        }\n+\n+        private Throwable preSend(Callback callback, boolean commit)\n+        {\n+            synchronized (this)\n+            {\n+                switch (_state)\n+                {\n+                    case IDLE:\n+                    {\n+                        _state = State.PRE_SEND;\n+                        _callback = callback;\n+                        _commit = commit;\n+                        return null;\n+                    }\n+                    default:\n+                    {\n+                        Throwable failure = _failure;\n+                        if (failure == null)\n+                            failure = new IllegalStateException(\"Invalid transport state: \" + _state);\n+                        return failure;\n+                    }\n+                }\n+            }\n+        }\n+\n+        private void postSend()\n+        {\n+            Callback callback;\n+            boolean commit;\n             Throwable failure;\n             synchronized (this)\n             {\n-                state = this.state;\n-                failure = this.failure;\n-                if (state == State.IDLE)\n+                switch (_state)\n                 {\n-                    this.state = State.WRITING;\n-                    this.callback = callback;\n-                    this.commit = commit;\n-                    return true;\n+                    case PRE_SEND:\n+                    {\n+                        _state = State.POST_SEND;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "42a5d2785b51f06e3440bbcf4a4d845b5f8bc5e1"}, "originalPosition": 223}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcxOTcwNDE4OnYy", "diffSide": "RIGHT", "path": "jetty-http2/http2-server/src/main/java/org/eclipse/jetty/http2/server/HttpTransportOverHTTP2.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOFQwOTo0MTowMlrOGgWYAg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOFQxMDozNDo1NFrOGgYGTQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjU3NDIxMA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                    callback = _callback;\n          \n          \n            \n                                    // The send has already completed successfully but callback not yet called, we can process callback now\n          \n          \n            \n                                    callback = _callback;\n          \n          \n            \n                                    _callback = null;", "url": "https://github.com/eclipse/jetty.project/pull/4946#discussion_r436574210", "createdAt": "2020-06-08T09:41:02Z", "author": {"login": "gregw"}, "path": "jetty-http2/http2-server/src/main/java/org/eclipse/jetty/http2/server/HttpTransportOverHTTP2.java", "diffHunk": "@@ -350,119 +351,356 @@ public void abort(Throwable failure)\n             stream.reset(new ResetFrame(stream.getId(), ErrorCode.CANCEL_STREAM_ERROR.code), Callback.NOOP);\n     }\n \n+    /**\n+     * <p>Callback that controls sends initiated by the transport, by eventually\n+     * notifying a nested callback.</p>\n+     * <p>There are 3 sources of concurrency after a send is initiated:</p>\n+     * <ul>\n+     *   <li>the completion of the send operation, either success or failure</li>\n+     *   <li>an asynchronous failure coming from the read side such as a stream\n+     *   being reset, or the connection being closed</li>\n+     *   <li>an asynchronous idle timeout</li>\n+     * </ul>\n+     * <p>The last 2 cases may happen <em>during</em> a send, when the frames\n+     * are being generated in the flusher.\n+     * In such cases, this class must avoid that the nested callback is notified\n+     * while the frame generation is in progress, because the nested callback\n+     * may modify other states (such as clearing the {@code HttpOutput._buffer})\n+     * that are accessed during frame generation.</p>\n+     * <p>The solution implemented in this class works by splitting the send\n+     * operation in 3 parts: {@code preSend()}, {@code send()} and {@code postSend()}.\n+     * Asynchronous state changes happening during {@code send()} are stored\n+     * and only executed in {@code postSend()}, therefore never interfering\n+     * with frame generation.</p>\n+     *\n+     * @see State\n+     */\n     private class TransportCallback implements Callback\n     {\n-        private State state = State.IDLE;\n-        private Callback callback;\n-        private Throwable failure;\n-        private boolean commit;\n+        private State _state = State.IDLE;\n+        private Callback _callback;\n+        private boolean _commit;\n+        private Throwable _failure;\n \n-        public boolean start(Callback callback, boolean commit)\n+        private void reset()\n         {\n-            State state;\n+            assert Thread.holdsLock(this);\n+            _state = State.IDLE;\n+            _callback = null;\n+            _commit = false;\n+            _failure = null;\n+        }\n+\n+        private void send(Callback callback, boolean commit, Consumer<Callback> consumer)\n+        {\n+            Throwable failure = preSend(callback, commit);\n+            if (failure == null)\n+            {\n+                consumer.accept(this);\n+                postSend();\n+            }\n+            else\n+            {\n+                callback.failed(failure);\n+            }\n+        }\n+\n+        private Throwable preSend(Callback callback, boolean commit)\n+        {\n+            synchronized (this)\n+            {\n+                switch (_state)\n+                {\n+                    case IDLE:\n+                    {\n+                        _state = State.PRE_SEND;\n+                        _callback = callback;\n+                        _commit = commit;\n+                        return null;\n+                    }\n+                    default:\n+                    {\n+                        Throwable failure = _failure;\n+                        if (failure == null)\n+                            failure = new IllegalStateException(\"Invalid transport state: \" + _state);\n+                        return failure;\n+                    }\n+                }\n+            }\n+        }\n+\n+        private void postSend()\n+        {\n+            Callback callback;\n+            boolean commit;\n             Throwable failure;\n             synchronized (this)\n             {\n-                state = this.state;\n-                failure = this.failure;\n-                if (state == State.IDLE)\n+                switch (_state)\n                 {\n-                    this.state = State.WRITING;\n-                    this.callback = callback;\n-                    this.commit = commit;\n-                    return true;\n+                    case PRE_SEND:\n+                    {\n+                        _state = State.POST_SEND;\n+                        return;\n+                    }\n+                    case SUCCEED:\n+                    {\n+                        callback = _callback;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "42a5d2785b51f06e3440bbcf4a4d845b5f8bc5e1"}, "originalPosition": 228}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjYwMjQ0NQ==", "bodyText": "This is wrong, here succeeded() has already been called.", "url": "https://github.com/eclipse/jetty.project/pull/4946#discussion_r436602445", "createdAt": "2020-06-08T10:34:54Z", "author": {"login": "sbordet"}, "path": "jetty-http2/http2-server/src/main/java/org/eclipse/jetty/http2/server/HttpTransportOverHTTP2.java", "diffHunk": "@@ -350,119 +351,356 @@ public void abort(Throwable failure)\n             stream.reset(new ResetFrame(stream.getId(), ErrorCode.CANCEL_STREAM_ERROR.code), Callback.NOOP);\n     }\n \n+    /**\n+     * <p>Callback that controls sends initiated by the transport, by eventually\n+     * notifying a nested callback.</p>\n+     * <p>There are 3 sources of concurrency after a send is initiated:</p>\n+     * <ul>\n+     *   <li>the completion of the send operation, either success or failure</li>\n+     *   <li>an asynchronous failure coming from the read side such as a stream\n+     *   being reset, or the connection being closed</li>\n+     *   <li>an asynchronous idle timeout</li>\n+     * </ul>\n+     * <p>The last 2 cases may happen <em>during</em> a send, when the frames\n+     * are being generated in the flusher.\n+     * In such cases, this class must avoid that the nested callback is notified\n+     * while the frame generation is in progress, because the nested callback\n+     * may modify other states (such as clearing the {@code HttpOutput._buffer})\n+     * that are accessed during frame generation.</p>\n+     * <p>The solution implemented in this class works by splitting the send\n+     * operation in 3 parts: {@code preSend()}, {@code send()} and {@code postSend()}.\n+     * Asynchronous state changes happening during {@code send()} are stored\n+     * and only executed in {@code postSend()}, therefore never interfering\n+     * with frame generation.</p>\n+     *\n+     * @see State\n+     */\n     private class TransportCallback implements Callback\n     {\n-        private State state = State.IDLE;\n-        private Callback callback;\n-        private Throwable failure;\n-        private boolean commit;\n+        private State _state = State.IDLE;\n+        private Callback _callback;\n+        private boolean _commit;\n+        private Throwable _failure;\n \n-        public boolean start(Callback callback, boolean commit)\n+        private void reset()\n         {\n-            State state;\n+            assert Thread.holdsLock(this);\n+            _state = State.IDLE;\n+            _callback = null;\n+            _commit = false;\n+            _failure = null;\n+        }\n+\n+        private void send(Callback callback, boolean commit, Consumer<Callback> consumer)\n+        {\n+            Throwable failure = preSend(callback, commit);\n+            if (failure == null)\n+            {\n+                consumer.accept(this);\n+                postSend();\n+            }\n+            else\n+            {\n+                callback.failed(failure);\n+            }\n+        }\n+\n+        private Throwable preSend(Callback callback, boolean commit)\n+        {\n+            synchronized (this)\n+            {\n+                switch (_state)\n+                {\n+                    case IDLE:\n+                    {\n+                        _state = State.PRE_SEND;\n+                        _callback = callback;\n+                        _commit = commit;\n+                        return null;\n+                    }\n+                    default:\n+                    {\n+                        Throwable failure = _failure;\n+                        if (failure == null)\n+                            failure = new IllegalStateException(\"Invalid transport state: \" + _state);\n+                        return failure;\n+                    }\n+                }\n+            }\n+        }\n+\n+        private void postSend()\n+        {\n+            Callback callback;\n+            boolean commit;\n             Throwable failure;\n             synchronized (this)\n             {\n-                state = this.state;\n-                failure = this.failure;\n-                if (state == State.IDLE)\n+                switch (_state)\n                 {\n-                    this.state = State.WRITING;\n-                    this.callback = callback;\n-                    this.commit = commit;\n-                    return true;\n+                    case PRE_SEND:\n+                    {\n+                        _state = State.POST_SEND;\n+                        return;\n+                    }\n+                    case SUCCEED:\n+                    {\n+                        callback = _callback;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjU3NDIxMA=="}, "originalCommit": {"oid": "42a5d2785b51f06e3440bbcf4a4d845b5f8bc5e1"}, "originalPosition": 228}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcxOTcyMDExOnYy", "diffSide": "RIGHT", "path": "jetty-http2/http2-server/src/main/java/org/eclipse/jetty/http2/server/HttpTransportOverHTTP2.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOFQwOTo0NToxNVrOGgWhgw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOFQwOTo0NToxNVrOGgWhgw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjU3NjY0Mw==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                case FAIL:\n          \n          \n            \n                                {\n          \n          \n            \n                                    _state = State.FAILED;\n          \n          \n            \n                                    callback = _callback;\n          \n          \n            \n                                    commit = _commit;\n          \n          \n            \n                                    failure = _failure;\n          \n          \n            \n                                    break;\n          \n          \n            \n                                case FAIL:\n          \n          \n            \n                                {\n          \n          \n            \n                                    // The send has already failed (either synchronously or asynchronously), but callback not yet called, so handle now\n          \n          \n            \n                                    _state = State.FAILED;\n          \n          \n            \n                                    callback = _callback;\n          \n          \n            \n                                    _callback = null;\n          \n          \n            \n                                    commit = _commit;\n          \n          \n            \n                                    failure = _failure;\n          \n          \n            \n                                    break;", "url": "https://github.com/eclipse/jetty.project/pull/4946#discussion_r436576643", "createdAt": "2020-06-08T09:45:15Z", "author": {"login": "gregw"}, "path": "jetty-http2/http2-server/src/main/java/org/eclipse/jetty/http2/server/HttpTransportOverHTTP2.java", "diffHunk": "@@ -350,119 +351,356 @@ public void abort(Throwable failure)\n             stream.reset(new ResetFrame(stream.getId(), ErrorCode.CANCEL_STREAM_ERROR.code), Callback.NOOP);\n     }\n \n+    /**\n+     * <p>Callback that controls sends initiated by the transport, by eventually\n+     * notifying a nested callback.</p>\n+     * <p>There are 3 sources of concurrency after a send is initiated:</p>\n+     * <ul>\n+     *   <li>the completion of the send operation, either success or failure</li>\n+     *   <li>an asynchronous failure coming from the read side such as a stream\n+     *   being reset, or the connection being closed</li>\n+     *   <li>an asynchronous idle timeout</li>\n+     * </ul>\n+     * <p>The last 2 cases may happen <em>during</em> a send, when the frames\n+     * are being generated in the flusher.\n+     * In such cases, this class must avoid that the nested callback is notified\n+     * while the frame generation is in progress, because the nested callback\n+     * may modify other states (such as clearing the {@code HttpOutput._buffer})\n+     * that are accessed during frame generation.</p>\n+     * <p>The solution implemented in this class works by splitting the send\n+     * operation in 3 parts: {@code preSend()}, {@code send()} and {@code postSend()}.\n+     * Asynchronous state changes happening during {@code send()} are stored\n+     * and only executed in {@code postSend()}, therefore never interfering\n+     * with frame generation.</p>\n+     *\n+     * @see State\n+     */\n     private class TransportCallback implements Callback\n     {\n-        private State state = State.IDLE;\n-        private Callback callback;\n-        private Throwable failure;\n-        private boolean commit;\n+        private State _state = State.IDLE;\n+        private Callback _callback;\n+        private boolean _commit;\n+        private Throwable _failure;\n \n-        public boolean start(Callback callback, boolean commit)\n+        private void reset()\n         {\n-            State state;\n+            assert Thread.holdsLock(this);\n+            _state = State.IDLE;\n+            _callback = null;\n+            _commit = false;\n+            _failure = null;\n+        }\n+\n+        private void send(Callback callback, boolean commit, Consumer<Callback> consumer)\n+        {\n+            Throwable failure = preSend(callback, commit);\n+            if (failure == null)\n+            {\n+                consumer.accept(this);\n+                postSend();\n+            }\n+            else\n+            {\n+                callback.failed(failure);\n+            }\n+        }\n+\n+        private Throwable preSend(Callback callback, boolean commit)\n+        {\n+            synchronized (this)\n+            {\n+                switch (_state)\n+                {\n+                    case IDLE:\n+                    {\n+                        _state = State.PRE_SEND;\n+                        _callback = callback;\n+                        _commit = commit;\n+                        return null;\n+                    }\n+                    default:\n+                    {\n+                        Throwable failure = _failure;\n+                        if (failure == null)\n+                            failure = new IllegalStateException(\"Invalid transport state: \" + _state);\n+                        return failure;\n+                    }\n+                }\n+            }\n+        }\n+\n+        private void postSend()\n+        {\n+            Callback callback;\n+            boolean commit;\n             Throwable failure;\n             synchronized (this)\n             {\n-                state = this.state;\n-                failure = this.failure;\n-                if (state == State.IDLE)\n+                switch (_state)\n                 {\n-                    this.state = State.WRITING;\n-                    this.callback = callback;\n-                    this.commit = commit;\n-                    return true;\n+                    case PRE_SEND:\n+                    {\n+                        _state = State.POST_SEND;\n+                        return;\n+                    }\n+                    case SUCCEED:\n+                    {\n+                        callback = _callback;\n+                        commit = _commit;\n+                        failure = null;\n+                        reset();\n+                        break;\n+                    }\n+                    case FAIL:\n+                    {\n+                        _state = State.FAILED;\n+                        callback = _callback;\n+                        commit = _commit;\n+                        failure = _failure;\n+                        break;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "42a5d2785b51f06e3440bbcf4a4d845b5f8bc5e1"}, "originalPosition": 240}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcxOTcyODQ0OnYy", "diffSide": "RIGHT", "path": "jetty-http2/http2-server/src/main/java/org/eclipse/jetty/http2/server/HttpTransportOverHTTP2.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOFQwOTo0Nzo0NVrOGgWmqA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOFQxMDozMToxN1rOGgX_cw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjU3Nzk2MA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            succeed(callback, commit);\n          \n          \n            \n                        else\n          \n          \n            \n                            fail(callback, commit, failure);\n          \n          \n            \n                            succeed(callback, commit);\n          \n          \n            \n                        else if (callback != null )\n          \n          \n            \n                            fail(callback, commit, failure);\n          \n          \n            \n                        else\n          \n          \n            \n                            threw new IllegalStateException();", "url": "https://github.com/eclipse/jetty.project/pull/4946#discussion_r436577960", "createdAt": "2020-06-08T09:47:45Z", "author": {"login": "gregw"}, "path": "jetty-http2/http2-server/src/main/java/org/eclipse/jetty/http2/server/HttpTransportOverHTTP2.java", "diffHunk": "@@ -350,119 +351,356 @@ public void abort(Throwable failure)\n             stream.reset(new ResetFrame(stream.getId(), ErrorCode.CANCEL_STREAM_ERROR.code), Callback.NOOP);\n     }\n \n+    /**\n+     * <p>Callback that controls sends initiated by the transport, by eventually\n+     * notifying a nested callback.</p>\n+     * <p>There are 3 sources of concurrency after a send is initiated:</p>\n+     * <ul>\n+     *   <li>the completion of the send operation, either success or failure</li>\n+     *   <li>an asynchronous failure coming from the read side such as a stream\n+     *   being reset, or the connection being closed</li>\n+     *   <li>an asynchronous idle timeout</li>\n+     * </ul>\n+     * <p>The last 2 cases may happen <em>during</em> a send, when the frames\n+     * are being generated in the flusher.\n+     * In such cases, this class must avoid that the nested callback is notified\n+     * while the frame generation is in progress, because the nested callback\n+     * may modify other states (such as clearing the {@code HttpOutput._buffer})\n+     * that are accessed during frame generation.</p>\n+     * <p>The solution implemented in this class works by splitting the send\n+     * operation in 3 parts: {@code preSend()}, {@code send()} and {@code postSend()}.\n+     * Asynchronous state changes happening during {@code send()} are stored\n+     * and only executed in {@code postSend()}, therefore never interfering\n+     * with frame generation.</p>\n+     *\n+     * @see State\n+     */\n     private class TransportCallback implements Callback\n     {\n-        private State state = State.IDLE;\n-        private Callback callback;\n-        private Throwable failure;\n-        private boolean commit;\n+        private State _state = State.IDLE;\n+        private Callback _callback;\n+        private boolean _commit;\n+        private Throwable _failure;\n \n-        public boolean start(Callback callback, boolean commit)\n+        private void reset()\n         {\n-            State state;\n+            assert Thread.holdsLock(this);\n+            _state = State.IDLE;\n+            _callback = null;\n+            _commit = false;\n+            _failure = null;\n+        }\n+\n+        private void send(Callback callback, boolean commit, Consumer<Callback> consumer)\n+        {\n+            Throwable failure = preSend(callback, commit);\n+            if (failure == null)\n+            {\n+                consumer.accept(this);\n+                postSend();\n+            }\n+            else\n+            {\n+                callback.failed(failure);\n+            }\n+        }\n+\n+        private Throwable preSend(Callback callback, boolean commit)\n+        {\n+            synchronized (this)\n+            {\n+                switch (_state)\n+                {\n+                    case IDLE:\n+                    {\n+                        _state = State.PRE_SEND;\n+                        _callback = callback;\n+                        _commit = commit;\n+                        return null;\n+                    }\n+                    default:\n+                    {\n+                        Throwable failure = _failure;\n+                        if (failure == null)\n+                            failure = new IllegalStateException(\"Invalid transport state: \" + _state);\n+                        return failure;\n+                    }\n+                }\n+            }\n+        }\n+\n+        private void postSend()\n+        {\n+            Callback callback;\n+            boolean commit;\n             Throwable failure;\n             synchronized (this)\n             {\n-                state = this.state;\n-                failure = this.failure;\n-                if (state == State.IDLE)\n+                switch (_state)\n                 {\n-                    this.state = State.WRITING;\n-                    this.callback = callback;\n-                    this.commit = commit;\n-                    return true;\n+                    case PRE_SEND:\n+                    {\n+                        _state = State.POST_SEND;\n+                        return;\n+                    }\n+                    case SUCCEED:\n+                    {\n+                        callback = _callback;\n+                        commit = _commit;\n+                        failure = null;\n+                        reset();\n+                        break;\n+                    }\n+                    case FAIL:\n+                    {\n+                        _state = State.FAILED;\n+                        callback = _callback;\n+                        commit = _commit;\n+                        failure = _failure;\n+                        break;\n+                    }\n+                    default:\n+                    {\n+                        _state = State.FAILED;\n+                        _failure = new IllegalStateException(\"Invalid transport state: \" + _state);\n+                        callback = _callback;\n+                        commit = _commit;\n+                        failure = _failure;\n+                        break;\n+                    }\n                 }\n             }\n             if (failure == null)\n-                failure = new IllegalStateException(\"Invalid transport state: \" + state);\n-            callback.failed(failure);\n-            return false;\n+                succeed(callback, commit);\n+            else\n+                fail(callback, commit, failure);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "42a5d2785b51f06e3440bbcf4a4d845b5f8bc5e1"}, "originalPosition": 259}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjYwMDY5MQ==", "bodyText": "Nope, callback cannot be null - if it is then we would have a bad state and we handle it already in the default case.\nPlus I don't want to throw from this class but fail the callback instead.", "url": "https://github.com/eclipse/jetty.project/pull/4946#discussion_r436600691", "createdAt": "2020-06-08T10:31:17Z", "author": {"login": "sbordet"}, "path": "jetty-http2/http2-server/src/main/java/org/eclipse/jetty/http2/server/HttpTransportOverHTTP2.java", "diffHunk": "@@ -350,119 +351,356 @@ public void abort(Throwable failure)\n             stream.reset(new ResetFrame(stream.getId(), ErrorCode.CANCEL_STREAM_ERROR.code), Callback.NOOP);\n     }\n \n+    /**\n+     * <p>Callback that controls sends initiated by the transport, by eventually\n+     * notifying a nested callback.</p>\n+     * <p>There are 3 sources of concurrency after a send is initiated:</p>\n+     * <ul>\n+     *   <li>the completion of the send operation, either success or failure</li>\n+     *   <li>an asynchronous failure coming from the read side such as a stream\n+     *   being reset, or the connection being closed</li>\n+     *   <li>an asynchronous idle timeout</li>\n+     * </ul>\n+     * <p>The last 2 cases may happen <em>during</em> a send, when the frames\n+     * are being generated in the flusher.\n+     * In such cases, this class must avoid that the nested callback is notified\n+     * while the frame generation is in progress, because the nested callback\n+     * may modify other states (such as clearing the {@code HttpOutput._buffer})\n+     * that are accessed during frame generation.</p>\n+     * <p>The solution implemented in this class works by splitting the send\n+     * operation in 3 parts: {@code preSend()}, {@code send()} and {@code postSend()}.\n+     * Asynchronous state changes happening during {@code send()} are stored\n+     * and only executed in {@code postSend()}, therefore never interfering\n+     * with frame generation.</p>\n+     *\n+     * @see State\n+     */\n     private class TransportCallback implements Callback\n     {\n-        private State state = State.IDLE;\n-        private Callback callback;\n-        private Throwable failure;\n-        private boolean commit;\n+        private State _state = State.IDLE;\n+        private Callback _callback;\n+        private boolean _commit;\n+        private Throwable _failure;\n \n-        public boolean start(Callback callback, boolean commit)\n+        private void reset()\n         {\n-            State state;\n+            assert Thread.holdsLock(this);\n+            _state = State.IDLE;\n+            _callback = null;\n+            _commit = false;\n+            _failure = null;\n+        }\n+\n+        private void send(Callback callback, boolean commit, Consumer<Callback> consumer)\n+        {\n+            Throwable failure = preSend(callback, commit);\n+            if (failure == null)\n+            {\n+                consumer.accept(this);\n+                postSend();\n+            }\n+            else\n+            {\n+                callback.failed(failure);\n+            }\n+        }\n+\n+        private Throwable preSend(Callback callback, boolean commit)\n+        {\n+            synchronized (this)\n+            {\n+                switch (_state)\n+                {\n+                    case IDLE:\n+                    {\n+                        _state = State.PRE_SEND;\n+                        _callback = callback;\n+                        _commit = commit;\n+                        return null;\n+                    }\n+                    default:\n+                    {\n+                        Throwable failure = _failure;\n+                        if (failure == null)\n+                            failure = new IllegalStateException(\"Invalid transport state: \" + _state);\n+                        return failure;\n+                    }\n+                }\n+            }\n+        }\n+\n+        private void postSend()\n+        {\n+            Callback callback;\n+            boolean commit;\n             Throwable failure;\n             synchronized (this)\n             {\n-                state = this.state;\n-                failure = this.failure;\n-                if (state == State.IDLE)\n+                switch (_state)\n                 {\n-                    this.state = State.WRITING;\n-                    this.callback = callback;\n-                    this.commit = commit;\n-                    return true;\n+                    case PRE_SEND:\n+                    {\n+                        _state = State.POST_SEND;\n+                        return;\n+                    }\n+                    case SUCCEED:\n+                    {\n+                        callback = _callback;\n+                        commit = _commit;\n+                        failure = null;\n+                        reset();\n+                        break;\n+                    }\n+                    case FAIL:\n+                    {\n+                        _state = State.FAILED;\n+                        callback = _callback;\n+                        commit = _commit;\n+                        failure = _failure;\n+                        break;\n+                    }\n+                    default:\n+                    {\n+                        _state = State.FAILED;\n+                        _failure = new IllegalStateException(\"Invalid transport state: \" + _state);\n+                        callback = _callback;\n+                        commit = _commit;\n+                        failure = _failure;\n+                        break;\n+                    }\n                 }\n             }\n             if (failure == null)\n-                failure = new IllegalStateException(\"Invalid transport state: \" + state);\n-            callback.failed(failure);\n-            return false;\n+                succeed(callback, commit);\n+            else\n+                fail(callback, commit, failure);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjU3Nzk2MA=="}, "originalCommit": {"oid": "42a5d2785b51f06e3440bbcf4a4d845b5f8bc5e1"}, "originalPosition": 259}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcyMDAzODcxOnYy", "diffSide": "RIGHT", "path": "jetty-http2/http2-server/src/main/java/org/eclipse/jetty/http2/server/HttpTransportOverHTTP2.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOFQxMToyODo1OVrOGgZoFA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOFQxMzozODoxMlrOGgefwA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjYyNzQ3Ng==", "bodyText": "I think we should null _callback whenever we take it.", "url": "https://github.com/eclipse/jetty.project/pull/4946#discussion_r436627476", "createdAt": "2020-06-08T11:28:59Z", "author": {"login": "gregw"}, "path": "jetty-http2/http2-server/src/main/java/org/eclipse/jetty/http2/server/HttpTransportOverHTTP2.java", "diffHunk": "@@ -350,119 +351,363 @@ public void abort(Throwable failure)\n             stream.reset(new ResetFrame(stream.getId(), ErrorCode.CANCEL_STREAM_ERROR.code), Callback.NOOP);\n     }\n \n+    /**\n+     * <p>Callback that controls sends initiated by the transport, by eventually\n+     * notifying a nested callback.</p>\n+     * <p>There are 3 sources of concurrency after a send is initiated:</p>\n+     * <ul>\n+     *   <li>the completion of the send operation, either success or failure</li>\n+     *   <li>an asynchronous failure coming from the read side such as a stream\n+     *   being reset, or the connection being closed</li>\n+     *   <li>an asynchronous idle timeout</li>\n+     * </ul>\n+     * <p>The last 2 cases may happen <em>during</em> a send, when the frames\n+     * are being generated in the flusher.\n+     * In such cases, this class must avoid that the nested callback is notified\n+     * while the frame generation is in progress, because the nested callback\n+     * may modify other states (such as clearing the {@code HttpOutput._buffer})\n+     * that are accessed during frame generation.</p>\n+     * <p>The solution implemented in this class works by splitting the send\n+     * operation in 3 parts: {@code pre-send}, {@code send} and {@code post-send}.\n+     * Asynchronous state changes happening during {@code send} are stored\n+     * and only executed in {@code post-send}, therefore never interfering\n+     * with frame generation.</p>\n+     *\n+     * @see State\n+     */\n     private class TransportCallback implements Callback\n     {\n-        private State state = State.IDLE;\n-        private Callback callback;\n-        private Throwable failure;\n-        private boolean commit;\n+        private State _state = State.IDLE;\n+        private Callback _callback;\n+        private boolean _commit;\n+        private Throwable _failure;\n \n-        public boolean start(Callback callback, boolean commit)\n+        private void reset()\n         {\n-            State state;\n+            assert Thread.holdsLock(this);\n+            _state = State.IDLE;\n+            _callback = null;\n+            _commit = false;\n+            _failure = null;\n+        }\n+\n+        private void send(Callback callback, boolean commit, Consumer<Callback> sendFrame)\n+        {\n+            Throwable failure = sending(callback, commit);\n+            if (failure == null)\n+            {\n+                sendFrame.accept(this);\n+                pending();\n+            }\n+            else\n+            {\n+                callback.failed(failure);\n+            }\n+        }\n+\n+        private Throwable sending(Callback callback, boolean commit)\n+        {\n+            synchronized (this)\n+            {\n+                switch (_state)\n+                {\n+                    case IDLE:\n+                    {\n+                        _state = State.SENDING;\n+                        _callback = callback;\n+                        _commit = commit;\n+                        return null;\n+                    }\n+                    case FAILED:\n+                    {\n+                        return _failure;\n+                    }\n+                    default:\n+                    {\n+                        return new IllegalStateException(\"Invalid transport state: \" + _state);\n+                    }\n+                }\n+            }\n+        }\n+\n+        private void pending()\n+        {\n+            Callback callback;\n+            boolean commit;\n             Throwable failure;\n             synchronized (this)\n             {\n-                state = this.state;\n-                failure = this.failure;\n-                if (state == State.IDLE)\n+                switch (_state)\n                 {\n-                    this.state = State.WRITING;\n-                    this.callback = callback;\n-                    this.commit = commit;\n-                    return true;\n+                    case SENDING:\n+                    {\n+                        // The send has not completed the callback yet,\n+                        // wait for succeeded() or failed() to be called.\n+                        _state = State.PENDING;\n+                        return;\n+                    }\n+                    case SUCCEEDING:\n+                    {\n+                        // The send already completed successfully, but the\n+                        // call to succeeded() was delayed, so call it now.\n+                        callback = _callback;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ee5183906cf9ffcbf4010d13b96857a92b0a8dc0"}, "originalPosition": 233}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjcwNzI2NA==", "bodyText": "It is in reset() few lines below.", "url": "https://github.com/eclipse/jetty.project/pull/4946#discussion_r436707264", "createdAt": "2020-06-08T13:38:12Z", "author": {"login": "sbordet"}, "path": "jetty-http2/http2-server/src/main/java/org/eclipse/jetty/http2/server/HttpTransportOverHTTP2.java", "diffHunk": "@@ -350,119 +351,363 @@ public void abort(Throwable failure)\n             stream.reset(new ResetFrame(stream.getId(), ErrorCode.CANCEL_STREAM_ERROR.code), Callback.NOOP);\n     }\n \n+    /**\n+     * <p>Callback that controls sends initiated by the transport, by eventually\n+     * notifying a nested callback.</p>\n+     * <p>There are 3 sources of concurrency after a send is initiated:</p>\n+     * <ul>\n+     *   <li>the completion of the send operation, either success or failure</li>\n+     *   <li>an asynchronous failure coming from the read side such as a stream\n+     *   being reset, or the connection being closed</li>\n+     *   <li>an asynchronous idle timeout</li>\n+     * </ul>\n+     * <p>The last 2 cases may happen <em>during</em> a send, when the frames\n+     * are being generated in the flusher.\n+     * In such cases, this class must avoid that the nested callback is notified\n+     * while the frame generation is in progress, because the nested callback\n+     * may modify other states (such as clearing the {@code HttpOutput._buffer})\n+     * that are accessed during frame generation.</p>\n+     * <p>The solution implemented in this class works by splitting the send\n+     * operation in 3 parts: {@code pre-send}, {@code send} and {@code post-send}.\n+     * Asynchronous state changes happening during {@code send} are stored\n+     * and only executed in {@code post-send}, therefore never interfering\n+     * with frame generation.</p>\n+     *\n+     * @see State\n+     */\n     private class TransportCallback implements Callback\n     {\n-        private State state = State.IDLE;\n-        private Callback callback;\n-        private Throwable failure;\n-        private boolean commit;\n+        private State _state = State.IDLE;\n+        private Callback _callback;\n+        private boolean _commit;\n+        private Throwable _failure;\n \n-        public boolean start(Callback callback, boolean commit)\n+        private void reset()\n         {\n-            State state;\n+            assert Thread.holdsLock(this);\n+            _state = State.IDLE;\n+            _callback = null;\n+            _commit = false;\n+            _failure = null;\n+        }\n+\n+        private void send(Callback callback, boolean commit, Consumer<Callback> sendFrame)\n+        {\n+            Throwable failure = sending(callback, commit);\n+            if (failure == null)\n+            {\n+                sendFrame.accept(this);\n+                pending();\n+            }\n+            else\n+            {\n+                callback.failed(failure);\n+            }\n+        }\n+\n+        private Throwable sending(Callback callback, boolean commit)\n+        {\n+            synchronized (this)\n+            {\n+                switch (_state)\n+                {\n+                    case IDLE:\n+                    {\n+                        _state = State.SENDING;\n+                        _callback = callback;\n+                        _commit = commit;\n+                        return null;\n+                    }\n+                    case FAILED:\n+                    {\n+                        return _failure;\n+                    }\n+                    default:\n+                    {\n+                        return new IllegalStateException(\"Invalid transport state: \" + _state);\n+                    }\n+                }\n+            }\n+        }\n+\n+        private void pending()\n+        {\n+            Callback callback;\n+            boolean commit;\n             Throwable failure;\n             synchronized (this)\n             {\n-                state = this.state;\n-                failure = this.failure;\n-                if (state == State.IDLE)\n+                switch (_state)\n                 {\n-                    this.state = State.WRITING;\n-                    this.callback = callback;\n-                    this.commit = commit;\n-                    return true;\n+                    case SENDING:\n+                    {\n+                        // The send has not completed the callback yet,\n+                        // wait for succeeded() or failed() to be called.\n+                        _state = State.PENDING;\n+                        return;\n+                    }\n+                    case SUCCEEDING:\n+                    {\n+                        // The send already completed successfully, but the\n+                        // call to succeeded() was delayed, so call it now.\n+                        callback = _callback;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjYyNzQ3Ng=="}, "originalCommit": {"oid": "ee5183906cf9ffcbf4010d13b96857a92b0a8dc0"}, "originalPosition": 233}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcyMDA0MTAxOnYy", "diffSide": "RIGHT", "path": "jetty-http2/http2-server/src/main/java/org/eclipse/jetty/http2/server/HttpTransportOverHTTP2.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOFQxMToyOTo1MlrOGgZprQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOFQxNjo1MzoyMlrOGgnVhA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjYyNzg4NQ==", "bodyText": "if we null _callback when we take it, we can throw ISE here if it is not null", "url": "https://github.com/eclipse/jetty.project/pull/4946#discussion_r436627885", "createdAt": "2020-06-08T11:29:52Z", "author": {"login": "gregw"}, "path": "jetty-http2/http2-server/src/main/java/org/eclipse/jetty/http2/server/HttpTransportOverHTTP2.java", "diffHunk": "@@ -350,119 +351,363 @@ public void abort(Throwable failure)\n             stream.reset(new ResetFrame(stream.getId(), ErrorCode.CANCEL_STREAM_ERROR.code), Callback.NOOP);\n     }\n \n+    /**\n+     * <p>Callback that controls sends initiated by the transport, by eventually\n+     * notifying a nested callback.</p>\n+     * <p>There are 3 sources of concurrency after a send is initiated:</p>\n+     * <ul>\n+     *   <li>the completion of the send operation, either success or failure</li>\n+     *   <li>an asynchronous failure coming from the read side such as a stream\n+     *   being reset, or the connection being closed</li>\n+     *   <li>an asynchronous idle timeout</li>\n+     * </ul>\n+     * <p>The last 2 cases may happen <em>during</em> a send, when the frames\n+     * are being generated in the flusher.\n+     * In such cases, this class must avoid that the nested callback is notified\n+     * while the frame generation is in progress, because the nested callback\n+     * may modify other states (such as clearing the {@code HttpOutput._buffer})\n+     * that are accessed during frame generation.</p>\n+     * <p>The solution implemented in this class works by splitting the send\n+     * operation in 3 parts: {@code pre-send}, {@code send} and {@code post-send}.\n+     * Asynchronous state changes happening during {@code send} are stored\n+     * and only executed in {@code post-send}, therefore never interfering\n+     * with frame generation.</p>\n+     *\n+     * @see State\n+     */\n     private class TransportCallback implements Callback\n     {\n-        private State state = State.IDLE;\n-        private Callback callback;\n-        private Throwable failure;\n-        private boolean commit;\n+        private State _state = State.IDLE;\n+        private Callback _callback;\n+        private boolean _commit;\n+        private Throwable _failure;\n \n-        public boolean start(Callback callback, boolean commit)\n+        private void reset()\n         {\n-            State state;\n+            assert Thread.holdsLock(this);\n+            _state = State.IDLE;\n+            _callback = null;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ee5183906cf9ffcbf4010d13b96857a92b0a8dc0"}, "originalPosition": 162}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjcyNzMyNw==", "bodyText": "Don't want to throw from this class, it will just hang the server.", "url": "https://github.com/eclipse/jetty.project/pull/4946#discussion_r436727327", "createdAt": "2020-06-08T13:58:40Z", "author": {"login": "sbordet"}, "path": "jetty-http2/http2-server/src/main/java/org/eclipse/jetty/http2/server/HttpTransportOverHTTP2.java", "diffHunk": "@@ -350,119 +351,363 @@ public void abort(Throwable failure)\n             stream.reset(new ResetFrame(stream.getId(), ErrorCode.CANCEL_STREAM_ERROR.code), Callback.NOOP);\n     }\n \n+    /**\n+     * <p>Callback that controls sends initiated by the transport, by eventually\n+     * notifying a nested callback.</p>\n+     * <p>There are 3 sources of concurrency after a send is initiated:</p>\n+     * <ul>\n+     *   <li>the completion of the send operation, either success or failure</li>\n+     *   <li>an asynchronous failure coming from the read side such as a stream\n+     *   being reset, or the connection being closed</li>\n+     *   <li>an asynchronous idle timeout</li>\n+     * </ul>\n+     * <p>The last 2 cases may happen <em>during</em> a send, when the frames\n+     * are being generated in the flusher.\n+     * In such cases, this class must avoid that the nested callback is notified\n+     * while the frame generation is in progress, because the nested callback\n+     * may modify other states (such as clearing the {@code HttpOutput._buffer})\n+     * that are accessed during frame generation.</p>\n+     * <p>The solution implemented in this class works by splitting the send\n+     * operation in 3 parts: {@code pre-send}, {@code send} and {@code post-send}.\n+     * Asynchronous state changes happening during {@code send} are stored\n+     * and only executed in {@code post-send}, therefore never interfering\n+     * with frame generation.</p>\n+     *\n+     * @see State\n+     */\n     private class TransportCallback implements Callback\n     {\n-        private State state = State.IDLE;\n-        private Callback callback;\n-        private Throwable failure;\n-        private boolean commit;\n+        private State _state = State.IDLE;\n+        private Callback _callback;\n+        private boolean _commit;\n+        private Throwable _failure;\n \n-        public boolean start(Callback callback, boolean commit)\n+        private void reset()\n         {\n-            State state;\n+            assert Thread.holdsLock(this);\n+            _state = State.IDLE;\n+            _callback = null;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjYyNzg4NQ=="}, "originalCommit": {"oid": "ee5183906cf9ffcbf4010d13b96857a92b0a8dc0"}, "originalPosition": 162}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjg1MjEwMA==", "bodyText": "If we get here with a non null callback, then the server is as good as dead anyway.  At least the exception will tell us why!", "url": "https://github.com/eclipse/jetty.project/pull/4946#discussion_r436852100", "createdAt": "2020-06-08T16:53:22Z", "author": {"login": "gregw"}, "path": "jetty-http2/http2-server/src/main/java/org/eclipse/jetty/http2/server/HttpTransportOverHTTP2.java", "diffHunk": "@@ -350,119 +351,363 @@ public void abort(Throwable failure)\n             stream.reset(new ResetFrame(stream.getId(), ErrorCode.CANCEL_STREAM_ERROR.code), Callback.NOOP);\n     }\n \n+    /**\n+     * <p>Callback that controls sends initiated by the transport, by eventually\n+     * notifying a nested callback.</p>\n+     * <p>There are 3 sources of concurrency after a send is initiated:</p>\n+     * <ul>\n+     *   <li>the completion of the send operation, either success or failure</li>\n+     *   <li>an asynchronous failure coming from the read side such as a stream\n+     *   being reset, or the connection being closed</li>\n+     *   <li>an asynchronous idle timeout</li>\n+     * </ul>\n+     * <p>The last 2 cases may happen <em>during</em> a send, when the frames\n+     * are being generated in the flusher.\n+     * In such cases, this class must avoid that the nested callback is notified\n+     * while the frame generation is in progress, because the nested callback\n+     * may modify other states (such as clearing the {@code HttpOutput._buffer})\n+     * that are accessed during frame generation.</p>\n+     * <p>The solution implemented in this class works by splitting the send\n+     * operation in 3 parts: {@code pre-send}, {@code send} and {@code post-send}.\n+     * Asynchronous state changes happening during {@code send} are stored\n+     * and only executed in {@code post-send}, therefore never interfering\n+     * with frame generation.</p>\n+     *\n+     * @see State\n+     */\n     private class TransportCallback implements Callback\n     {\n-        private State state = State.IDLE;\n-        private Callback callback;\n-        private Throwable failure;\n-        private boolean commit;\n+        private State _state = State.IDLE;\n+        private Callback _callback;\n+        private boolean _commit;\n+        private Throwable _failure;\n \n-        public boolean start(Callback callback, boolean commit)\n+        private void reset()\n         {\n-            State state;\n+            assert Thread.holdsLock(this);\n+            _state = State.IDLE;\n+            _callback = null;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjYyNzg4NQ=="}, "originalCommit": {"oid": "ee5183906cf9ffcbf4010d13b96857a92b0a8dc0"}, "originalPosition": 162}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcyMDA1MTI2OnYy", "diffSide": "RIGHT", "path": "jetty-http2/http2-server/src/main/java/org/eclipse/jetty/http2/server/HttpTransportOverHTTP2.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOFQxMTozMzowNVrOGgZvvg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOFQxNDowMToyN1rOGgf5PA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjYyOTQzOA==", "bodyText": "I kind of think the timeout should win this race.  Who knows what else has been closed already by the timeout, plus the timeout might be due to a really slow generation of the frame.", "url": "https://github.com/eclipse/jetty.project/pull/4946#discussion_r436629438", "createdAt": "2020-06-08T11:33:05Z", "author": {"login": "gregw"}, "path": "jetty-http2/http2-server/src/main/java/org/eclipse/jetty/http2/server/HttpTransportOverHTTP2.java", "diffHunk": "@@ -350,119 +351,363 @@ public void abort(Throwable failure)\n             stream.reset(new ResetFrame(stream.getId(), ErrorCode.CANCEL_STREAM_ERROR.code), Callback.NOOP);\n     }\n \n+    /**\n+     * <p>Callback that controls sends initiated by the transport, by eventually\n+     * notifying a nested callback.</p>\n+     * <p>There are 3 sources of concurrency after a send is initiated:</p>\n+     * <ul>\n+     *   <li>the completion of the send operation, either success or failure</li>\n+     *   <li>an asynchronous failure coming from the read side such as a stream\n+     *   being reset, or the connection being closed</li>\n+     *   <li>an asynchronous idle timeout</li>\n+     * </ul>\n+     * <p>The last 2 cases may happen <em>during</em> a send, when the frames\n+     * are being generated in the flusher.\n+     * In such cases, this class must avoid that the nested callback is notified\n+     * while the frame generation is in progress, because the nested callback\n+     * may modify other states (such as clearing the {@code HttpOutput._buffer})\n+     * that are accessed during frame generation.</p>\n+     * <p>The solution implemented in this class works by splitting the send\n+     * operation in 3 parts: {@code pre-send}, {@code send} and {@code post-send}.\n+     * Asynchronous state changes happening during {@code send} are stored\n+     * and only executed in {@code post-send}, therefore never interfering\n+     * with frame generation.</p>\n+     *\n+     * @see State\n+     */\n     private class TransportCallback implements Callback\n     {\n-        private State state = State.IDLE;\n-        private Callback callback;\n-        private Throwable failure;\n-        private boolean commit;\n+        private State _state = State.IDLE;\n+        private Callback _callback;\n+        private boolean _commit;\n+        private Throwable _failure;\n \n-        public boolean start(Callback callback, boolean commit)\n+        private void reset()\n         {\n-            State state;\n+            assert Thread.holdsLock(this);\n+            _state = State.IDLE;\n+            _callback = null;\n+            _commit = false;\n+            _failure = null;\n+        }\n+\n+        private void send(Callback callback, boolean commit, Consumer<Callback> sendFrame)\n+        {\n+            Throwable failure = sending(callback, commit);\n+            if (failure == null)\n+            {\n+                sendFrame.accept(this);\n+                pending();\n+            }\n+            else\n+            {\n+                callback.failed(failure);\n+            }\n+        }\n+\n+        private Throwable sending(Callback callback, boolean commit)\n+        {\n+            synchronized (this)\n+            {\n+                switch (_state)\n+                {\n+                    case IDLE:\n+                    {\n+                        _state = State.SENDING;\n+                        _callback = callback;\n+                        _commit = commit;\n+                        return null;\n+                    }\n+                    case FAILED:\n+                    {\n+                        return _failure;\n+                    }\n+                    default:\n+                    {\n+                        return new IllegalStateException(\"Invalid transport state: \" + _state);\n+                    }\n+                }\n+            }\n+        }\n+\n+        private void pending()\n+        {\n+            Callback callback;\n+            boolean commit;\n             Throwable failure;\n             synchronized (this)\n             {\n-                state = this.state;\n-                failure = this.failure;\n-                if (state == State.IDLE)\n+                switch (_state)\n                 {\n-                    this.state = State.WRITING;\n-                    this.callback = callback;\n-                    this.commit = commit;\n-                    return true;\n+                    case SENDING:\n+                    {\n+                        // The send has not completed the callback yet,\n+                        // wait for succeeded() or failed() to be called.\n+                        _state = State.PENDING;\n+                        return;\n+                    }\n+                    case SUCCEEDING:\n+                    {\n+                        // The send already completed successfully, but the\n+                        // call to succeeded() was delayed, so call it now.\n+                        callback = _callback;\n+                        commit = _commit;\n+                        failure = null;\n+                        reset();\n+                        break;\n+                    }\n+                    case FAILING:\n+                    {\n+                        // The send already completed with a failure, but\n+                        // the call to failed() was delayed, so call it now.\n+                        _state = State.FAILED;\n+                        callback = _callback;\n+                        commit = _commit;\n+                        failure = _failure;\n+                        break;\n+                    }\n+                    default:\n+                    {\n+                        _state = State.FAILED;\n+                        _failure = new IllegalStateException(\"Invalid transport state: \" + _state);\n+                        callback = _callback;\n+                        commit = _commit;\n+                        failure = _failure;\n+                        break;\n+                    }\n                 }\n             }\n             if (failure == null)\n-                failure = new IllegalStateException(\"Invalid transport state: \" + state);\n-            callback.failed(failure);\n-            return false;\n+                succeed(callback, commit);\n+            else\n+                fail(callback, commit, failure);\n         }\n \n         @Override\n         public void succeeded()\n         {\n+            Callback callback;\n             boolean commit;\n-            Callback callback = null;\n             synchronized (this)\n             {\n-                commit = this.commit;\n-                if (state == State.WRITING)\n+                switch (_state)\n                 {\n-                    this.state = State.IDLE;\n-                    callback = this.callback;\n-                    this.callback = null;\n-                    this.commit = false;\n+                    case SENDING:\n+                    {\n+                        _state = State.SUCCEEDING;\n+                        // Succeeding the callback will be done in postSend().\n+                        return;\n+                    }\n+                    case PENDING:\n+                    {\n+                        callback = _callback;\n+                        commit = _commit;\n+                        reset();\n+                        break;\n+                    }\n+                    default:\n+                    {\n+                        // This thread lost the race to succeed the current\n+                        // send, as other threads likely already failed it.\n+                        return;\n+                    }\n                 }\n             }\n-            if (LOG.isDebugEnabled())\n-                LOG.debug(\"HTTP2 Response #{}/{} {} {}\",\n-                    stream.getId(), Integer.toHexString(stream.getSession().hashCode()),\n-                    commit ? \"commit\" : \"flush\",\n-                    callback == null ? \"failure\" : \"success\");\n-            if (callback != null)\n-                callback.succeeded();\n+            succeed(callback, commit);\n         }\n \n         @Override\n         public void failed(Throwable failure)\n         {\n-            boolean commit;\n             Callback callback;\n+            boolean commit;\n             synchronized (this)\n             {\n-                commit = this.commit;\n-                this.state = State.FAILED;\n-                callback = this.callback;\n-                this.callback = null;\n-                this.failure = failure;\n+                switch (_state)\n+                {\n+                    case SENDING:\n+                    {\n+                        _state = State.FAILING;\n+                        _failure = failure;\n+                        // Failing the callback will be done in postSend().\n+                        return;\n+                    }\n+                    case IDLE:\n+                    case PENDING:\n+                    {\n+                        _state = State.FAILED;\n+                        _failure = failure;\n+                        callback = _callback;\n+                        commit = _commit;\n+                        break;\n+                    }\n+                    default:\n+                    {\n+                        // This thread lost the race to fail the current send,\n+                        // as other threads already succeeded or failed it.\n+                        return;\n+                    }\n+                }\n             }\n-            if (LOG.isDebugEnabled())\n-                LOG.debug(String.format(\"HTTP2 Response #%d/%h %s %s\", stream.getId(), stream.getSession(),\n-                    commit ? \"commit\" : \"flush\", callback == null ? \"ignored\" : \"failed\"), failure);\n-            if (callback != null)\n-                callback.failed(failure);\n+            fail(callback, commit, failure);\n         }\n \n-        private boolean onIdleTimeout(Throwable failure)\n+        private boolean idleTimeout(Throwable failure)\n         {\n-            boolean result;\n-            Callback callback = null;\n+            Callback callback;\n+            boolean timeout;\n             synchronized (this)\n             {\n-                // Ignore idle timeouts if not writing,\n-                // as the application may be suspended.\n-                result = state == State.WRITING;\n-                if (result)\n+                switch (_state)\n                 {\n-                    this.state = State.TIMEOUT;\n-                    callback = this.callback;\n-                    this.callback = null;\n-                    this.failure = failure;\n+                    case PENDING:\n+                    {\n+                        // The send was started but idle timed out, fail it.\n+                        _state = State.FAILED;\n+                        _failure = failure;\n+                        callback = _callback;\n+                        timeout = true;\n+                        break;\n+                    }\n+                    case IDLE:\n+                        // The application may be suspended, ignore the idle timeout.\n+                    case SENDING:\n+                        // A send has been started at the same time of an idle timeout;\n+                        // Ignore the idle timeout and let the write continue normally.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ee5183906cf9ffcbf4010d13b96857a92b0a8dc0"}, "originalPosition": 395}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjczMDE3Mg==", "bodyText": "Nope, we should support ignoring idle timeouts in case the application is idle as per Servlet specification, so if we were just unlucky here we should ignore the idle timeout.\nI think we should enforce the idle timeout only when we are PENDING, i.e. really sure that we have initiated a write but it won't complete in time.", "url": "https://github.com/eclipse/jetty.project/pull/4946#discussion_r436730172", "createdAt": "2020-06-08T14:01:27Z", "author": {"login": "sbordet"}, "path": "jetty-http2/http2-server/src/main/java/org/eclipse/jetty/http2/server/HttpTransportOverHTTP2.java", "diffHunk": "@@ -350,119 +351,363 @@ public void abort(Throwable failure)\n             stream.reset(new ResetFrame(stream.getId(), ErrorCode.CANCEL_STREAM_ERROR.code), Callback.NOOP);\n     }\n \n+    /**\n+     * <p>Callback that controls sends initiated by the transport, by eventually\n+     * notifying a nested callback.</p>\n+     * <p>There are 3 sources of concurrency after a send is initiated:</p>\n+     * <ul>\n+     *   <li>the completion of the send operation, either success or failure</li>\n+     *   <li>an asynchronous failure coming from the read side such as a stream\n+     *   being reset, or the connection being closed</li>\n+     *   <li>an asynchronous idle timeout</li>\n+     * </ul>\n+     * <p>The last 2 cases may happen <em>during</em> a send, when the frames\n+     * are being generated in the flusher.\n+     * In such cases, this class must avoid that the nested callback is notified\n+     * while the frame generation is in progress, because the nested callback\n+     * may modify other states (such as clearing the {@code HttpOutput._buffer})\n+     * that are accessed during frame generation.</p>\n+     * <p>The solution implemented in this class works by splitting the send\n+     * operation in 3 parts: {@code pre-send}, {@code send} and {@code post-send}.\n+     * Asynchronous state changes happening during {@code send} are stored\n+     * and only executed in {@code post-send}, therefore never interfering\n+     * with frame generation.</p>\n+     *\n+     * @see State\n+     */\n     private class TransportCallback implements Callback\n     {\n-        private State state = State.IDLE;\n-        private Callback callback;\n-        private Throwable failure;\n-        private boolean commit;\n+        private State _state = State.IDLE;\n+        private Callback _callback;\n+        private boolean _commit;\n+        private Throwable _failure;\n \n-        public boolean start(Callback callback, boolean commit)\n+        private void reset()\n         {\n-            State state;\n+            assert Thread.holdsLock(this);\n+            _state = State.IDLE;\n+            _callback = null;\n+            _commit = false;\n+            _failure = null;\n+        }\n+\n+        private void send(Callback callback, boolean commit, Consumer<Callback> sendFrame)\n+        {\n+            Throwable failure = sending(callback, commit);\n+            if (failure == null)\n+            {\n+                sendFrame.accept(this);\n+                pending();\n+            }\n+            else\n+            {\n+                callback.failed(failure);\n+            }\n+        }\n+\n+        private Throwable sending(Callback callback, boolean commit)\n+        {\n+            synchronized (this)\n+            {\n+                switch (_state)\n+                {\n+                    case IDLE:\n+                    {\n+                        _state = State.SENDING;\n+                        _callback = callback;\n+                        _commit = commit;\n+                        return null;\n+                    }\n+                    case FAILED:\n+                    {\n+                        return _failure;\n+                    }\n+                    default:\n+                    {\n+                        return new IllegalStateException(\"Invalid transport state: \" + _state);\n+                    }\n+                }\n+            }\n+        }\n+\n+        private void pending()\n+        {\n+            Callback callback;\n+            boolean commit;\n             Throwable failure;\n             synchronized (this)\n             {\n-                state = this.state;\n-                failure = this.failure;\n-                if (state == State.IDLE)\n+                switch (_state)\n                 {\n-                    this.state = State.WRITING;\n-                    this.callback = callback;\n-                    this.commit = commit;\n-                    return true;\n+                    case SENDING:\n+                    {\n+                        // The send has not completed the callback yet,\n+                        // wait for succeeded() or failed() to be called.\n+                        _state = State.PENDING;\n+                        return;\n+                    }\n+                    case SUCCEEDING:\n+                    {\n+                        // The send already completed successfully, but the\n+                        // call to succeeded() was delayed, so call it now.\n+                        callback = _callback;\n+                        commit = _commit;\n+                        failure = null;\n+                        reset();\n+                        break;\n+                    }\n+                    case FAILING:\n+                    {\n+                        // The send already completed with a failure, but\n+                        // the call to failed() was delayed, so call it now.\n+                        _state = State.FAILED;\n+                        callback = _callback;\n+                        commit = _commit;\n+                        failure = _failure;\n+                        break;\n+                    }\n+                    default:\n+                    {\n+                        _state = State.FAILED;\n+                        _failure = new IllegalStateException(\"Invalid transport state: \" + _state);\n+                        callback = _callback;\n+                        commit = _commit;\n+                        failure = _failure;\n+                        break;\n+                    }\n                 }\n             }\n             if (failure == null)\n-                failure = new IllegalStateException(\"Invalid transport state: \" + state);\n-            callback.failed(failure);\n-            return false;\n+                succeed(callback, commit);\n+            else\n+                fail(callback, commit, failure);\n         }\n \n         @Override\n         public void succeeded()\n         {\n+            Callback callback;\n             boolean commit;\n-            Callback callback = null;\n             synchronized (this)\n             {\n-                commit = this.commit;\n-                if (state == State.WRITING)\n+                switch (_state)\n                 {\n-                    this.state = State.IDLE;\n-                    callback = this.callback;\n-                    this.callback = null;\n-                    this.commit = false;\n+                    case SENDING:\n+                    {\n+                        _state = State.SUCCEEDING;\n+                        // Succeeding the callback will be done in postSend().\n+                        return;\n+                    }\n+                    case PENDING:\n+                    {\n+                        callback = _callback;\n+                        commit = _commit;\n+                        reset();\n+                        break;\n+                    }\n+                    default:\n+                    {\n+                        // This thread lost the race to succeed the current\n+                        // send, as other threads likely already failed it.\n+                        return;\n+                    }\n                 }\n             }\n-            if (LOG.isDebugEnabled())\n-                LOG.debug(\"HTTP2 Response #{}/{} {} {}\",\n-                    stream.getId(), Integer.toHexString(stream.getSession().hashCode()),\n-                    commit ? \"commit\" : \"flush\",\n-                    callback == null ? \"failure\" : \"success\");\n-            if (callback != null)\n-                callback.succeeded();\n+            succeed(callback, commit);\n         }\n \n         @Override\n         public void failed(Throwable failure)\n         {\n-            boolean commit;\n             Callback callback;\n+            boolean commit;\n             synchronized (this)\n             {\n-                commit = this.commit;\n-                this.state = State.FAILED;\n-                callback = this.callback;\n-                this.callback = null;\n-                this.failure = failure;\n+                switch (_state)\n+                {\n+                    case SENDING:\n+                    {\n+                        _state = State.FAILING;\n+                        _failure = failure;\n+                        // Failing the callback will be done in postSend().\n+                        return;\n+                    }\n+                    case IDLE:\n+                    case PENDING:\n+                    {\n+                        _state = State.FAILED;\n+                        _failure = failure;\n+                        callback = _callback;\n+                        commit = _commit;\n+                        break;\n+                    }\n+                    default:\n+                    {\n+                        // This thread lost the race to fail the current send,\n+                        // as other threads already succeeded or failed it.\n+                        return;\n+                    }\n+                }\n             }\n-            if (LOG.isDebugEnabled())\n-                LOG.debug(String.format(\"HTTP2 Response #%d/%h %s %s\", stream.getId(), stream.getSession(),\n-                    commit ? \"commit\" : \"flush\", callback == null ? \"ignored\" : \"failed\"), failure);\n-            if (callback != null)\n-                callback.failed(failure);\n+            fail(callback, commit, failure);\n         }\n \n-        private boolean onIdleTimeout(Throwable failure)\n+        private boolean idleTimeout(Throwable failure)\n         {\n-            boolean result;\n-            Callback callback = null;\n+            Callback callback;\n+            boolean timeout;\n             synchronized (this)\n             {\n-                // Ignore idle timeouts if not writing,\n-                // as the application may be suspended.\n-                result = state == State.WRITING;\n-                if (result)\n+                switch (_state)\n                 {\n-                    this.state = State.TIMEOUT;\n-                    callback = this.callback;\n-                    this.callback = null;\n-                    this.failure = failure;\n+                    case PENDING:\n+                    {\n+                        // The send was started but idle timed out, fail it.\n+                        _state = State.FAILED;\n+                        _failure = failure;\n+                        callback = _callback;\n+                        timeout = true;\n+                        break;\n+                    }\n+                    case IDLE:\n+                        // The application may be suspended, ignore the idle timeout.\n+                    case SENDING:\n+                        // A send has been started at the same time of an idle timeout;\n+                        // Ignore the idle timeout and let the write continue normally.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjYyOTQzOA=="}, "originalCommit": {"oid": "ee5183906cf9ffcbf4010d13b96857a92b0a8dc0"}, "originalPosition": 395}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcyMDA1NDAxOnYy", "diffSide": "RIGHT", "path": "jetty-http2/http2-server/src/main/java/org/eclipse/jetty/http2/server/HttpTransportOverHTTP2.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOFQxMTozNDowOVrOGgZxbQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOFQxNDowMjoxOFrOGgf7xA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjYyOTg2OQ==", "bodyText": "just inline the idleTimeout method here.", "url": "https://github.com/eclipse/jetty.project/pull/4946#discussion_r436629869", "createdAt": "2020-06-08T11:34:09Z", "author": {"login": "gregw"}, "path": "jetty-http2/http2-server/src/main/java/org/eclipse/jetty/http2/server/HttpTransportOverHTTP2.java", "diffHunk": "@@ -350,119 +351,363 @@ public void abort(Throwable failure)\n             stream.reset(new ResetFrame(stream.getId(), ErrorCode.CANCEL_STREAM_ERROR.code), Callback.NOOP);\n     }\n \n+    /**\n+     * <p>Callback that controls sends initiated by the transport, by eventually\n+     * notifying a nested callback.</p>\n+     * <p>There are 3 sources of concurrency after a send is initiated:</p>\n+     * <ul>\n+     *   <li>the completion of the send operation, either success or failure</li>\n+     *   <li>an asynchronous failure coming from the read side such as a stream\n+     *   being reset, or the connection being closed</li>\n+     *   <li>an asynchronous idle timeout</li>\n+     * </ul>\n+     * <p>The last 2 cases may happen <em>during</em> a send, when the frames\n+     * are being generated in the flusher.\n+     * In such cases, this class must avoid that the nested callback is notified\n+     * while the frame generation is in progress, because the nested callback\n+     * may modify other states (such as clearing the {@code HttpOutput._buffer})\n+     * that are accessed during frame generation.</p>\n+     * <p>The solution implemented in this class works by splitting the send\n+     * operation in 3 parts: {@code pre-send}, {@code send} and {@code post-send}.\n+     * Asynchronous state changes happening during {@code send} are stored\n+     * and only executed in {@code post-send}, therefore never interfering\n+     * with frame generation.</p>\n+     *\n+     * @see State\n+     */\n     private class TransportCallback implements Callback\n     {\n-        private State state = State.IDLE;\n-        private Callback callback;\n-        private Throwable failure;\n-        private boolean commit;\n+        private State _state = State.IDLE;\n+        private Callback _callback;\n+        private boolean _commit;\n+        private Throwable _failure;\n \n-        public boolean start(Callback callback, boolean commit)\n+        private void reset()\n         {\n-            State state;\n+            assert Thread.holdsLock(this);\n+            _state = State.IDLE;\n+            _callback = null;\n+            _commit = false;\n+            _failure = null;\n+        }\n+\n+        private void send(Callback callback, boolean commit, Consumer<Callback> sendFrame)\n+        {\n+            Throwable failure = sending(callback, commit);\n+            if (failure == null)\n+            {\n+                sendFrame.accept(this);\n+                pending();\n+            }\n+            else\n+            {\n+                callback.failed(failure);\n+            }\n+        }\n+\n+        private Throwable sending(Callback callback, boolean commit)\n+        {\n+            synchronized (this)\n+            {\n+                switch (_state)\n+                {\n+                    case IDLE:\n+                    {\n+                        _state = State.SENDING;\n+                        _callback = callback;\n+                        _commit = commit;\n+                        return null;\n+                    }\n+                    case FAILED:\n+                    {\n+                        return _failure;\n+                    }\n+                    default:\n+                    {\n+                        return new IllegalStateException(\"Invalid transport state: \" + _state);\n+                    }\n+                }\n+            }\n+        }\n+\n+        private void pending()\n+        {\n+            Callback callback;\n+            boolean commit;\n             Throwable failure;\n             synchronized (this)\n             {\n-                state = this.state;\n-                failure = this.failure;\n-                if (state == State.IDLE)\n+                switch (_state)\n                 {\n-                    this.state = State.WRITING;\n-                    this.callback = callback;\n-                    this.commit = commit;\n-                    return true;\n+                    case SENDING:\n+                    {\n+                        // The send has not completed the callback yet,\n+                        // wait for succeeded() or failed() to be called.\n+                        _state = State.PENDING;\n+                        return;\n+                    }\n+                    case SUCCEEDING:\n+                    {\n+                        // The send already completed successfully, but the\n+                        // call to succeeded() was delayed, so call it now.\n+                        callback = _callback;\n+                        commit = _commit;\n+                        failure = null;\n+                        reset();\n+                        break;\n+                    }\n+                    case FAILING:\n+                    {\n+                        // The send already completed with a failure, but\n+                        // the call to failed() was delayed, so call it now.\n+                        _state = State.FAILED;\n+                        callback = _callback;\n+                        commit = _commit;\n+                        failure = _failure;\n+                        break;\n+                    }\n+                    default:\n+                    {\n+                        _state = State.FAILED;\n+                        _failure = new IllegalStateException(\"Invalid transport state: \" + _state);\n+                        callback = _callback;\n+                        commit = _commit;\n+                        failure = _failure;\n+                        break;\n+                    }\n                 }\n             }\n             if (failure == null)\n-                failure = new IllegalStateException(\"Invalid transport state: \" + state);\n-            callback.failed(failure);\n-            return false;\n+                succeed(callback, commit);\n+            else\n+                fail(callback, commit, failure);\n         }\n \n         @Override\n         public void succeeded()\n         {\n+            Callback callback;\n             boolean commit;\n-            Callback callback = null;\n             synchronized (this)\n             {\n-                commit = this.commit;\n-                if (state == State.WRITING)\n+                switch (_state)\n                 {\n-                    this.state = State.IDLE;\n-                    callback = this.callback;\n-                    this.callback = null;\n-                    this.commit = false;\n+                    case SENDING:\n+                    {\n+                        _state = State.SUCCEEDING;\n+                        // Succeeding the callback will be done in postSend().\n+                        return;\n+                    }\n+                    case PENDING:\n+                    {\n+                        callback = _callback;\n+                        commit = _commit;\n+                        reset();\n+                        break;\n+                    }\n+                    default:\n+                    {\n+                        // This thread lost the race to succeed the current\n+                        // send, as other threads likely already failed it.\n+                        return;\n+                    }\n                 }\n             }\n-            if (LOG.isDebugEnabled())\n-                LOG.debug(\"HTTP2 Response #{}/{} {} {}\",\n-                    stream.getId(), Integer.toHexString(stream.getSession().hashCode()),\n-                    commit ? \"commit\" : \"flush\",\n-                    callback == null ? \"failure\" : \"success\");\n-            if (callback != null)\n-                callback.succeeded();\n+            succeed(callback, commit);\n         }\n \n         @Override\n         public void failed(Throwable failure)\n         {\n-            boolean commit;\n             Callback callback;\n+            boolean commit;\n             synchronized (this)\n             {\n-                commit = this.commit;\n-                this.state = State.FAILED;\n-                callback = this.callback;\n-                this.callback = null;\n-                this.failure = failure;\n+                switch (_state)\n+                {\n+                    case SENDING:\n+                    {\n+                        _state = State.FAILING;\n+                        _failure = failure;\n+                        // Failing the callback will be done in postSend().\n+                        return;\n+                    }\n+                    case IDLE:\n+                    case PENDING:\n+                    {\n+                        _state = State.FAILED;\n+                        _failure = failure;\n+                        callback = _callback;\n+                        commit = _commit;\n+                        break;\n+                    }\n+                    default:\n+                    {\n+                        // This thread lost the race to fail the current send,\n+                        // as other threads already succeeded or failed it.\n+                        return;\n+                    }\n+                }\n             }\n-            if (LOG.isDebugEnabled())\n-                LOG.debug(String.format(\"HTTP2 Response #%d/%h %s %s\", stream.getId(), stream.getSession(),\n-                    commit ? \"commit\" : \"flush\", callback == null ? \"ignored\" : \"failed\"), failure);\n-            if (callback != null)\n-                callback.failed(failure);\n+            fail(callback, commit, failure);\n         }\n \n-        private boolean onIdleTimeout(Throwable failure)\n+        private boolean idleTimeout(Throwable failure)\n         {\n-            boolean result;\n-            Callback callback = null;\n+            Callback callback;\n+            boolean timeout;\n             synchronized (this)\n             {\n-                // Ignore idle timeouts if not writing,\n-                // as the application may be suspended.\n-                result = state == State.WRITING;\n-                if (result)\n+                switch (_state)\n                 {\n-                    this.state = State.TIMEOUT;\n-                    callback = this.callback;\n-                    this.callback = null;\n-                    this.failure = failure;\n+                    case PENDING:\n+                    {\n+                        // The send was started but idle timed out, fail it.\n+                        _state = State.FAILED;\n+                        _failure = failure;\n+                        callback = _callback;\n+                        timeout = true;\n+                        break;\n+                    }\n+                    case IDLE:\n+                        // The application may be suspended, ignore the idle timeout.\n+                    case SENDING:\n+                        // A send has been started at the same time of an idle timeout;\n+                        // Ignore the idle timeout and let the write continue normally.\n+                    case SUCCEEDING:\n+                    case FAILING:\n+                        // An idle timeout during these transient states is ignored.\n+                    case FAILED:\n+                        // Already failed, ignore the idle timeout.\n+                    {\n+                        callback = null;\n+                        timeout = false;\n+                        break;\n+                    }\n+                    default:\n+                    {\n+                        // Should not happen, but just in case.\n+                        _state = State.FAILED;\n+                        _failure = new IllegalStateException(\"Invalid transport state: \" + _state, failure);\n+                        callback = _callback;\n+                        if (callback == null)\n+                            callback = Callback.NOOP;\n+                        timeout = true;\n+                        failure = _failure;\n+                        break;\n+                    }\n                 }\n             }\n+            idleTimeout(callback, timeout, failure);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ee5183906cf9ffcbf4010d13b96857a92b0a8dc0"}, "originalPosition": 420}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjczMDgyMA==", "bodyText": "Nah, it nicely complements the succeed() and fail() methods, with logging callback action.", "url": "https://github.com/eclipse/jetty.project/pull/4946#discussion_r436730820", "createdAt": "2020-06-08T14:02:18Z", "author": {"login": "sbordet"}, "path": "jetty-http2/http2-server/src/main/java/org/eclipse/jetty/http2/server/HttpTransportOverHTTP2.java", "diffHunk": "@@ -350,119 +351,363 @@ public void abort(Throwable failure)\n             stream.reset(new ResetFrame(stream.getId(), ErrorCode.CANCEL_STREAM_ERROR.code), Callback.NOOP);\n     }\n \n+    /**\n+     * <p>Callback that controls sends initiated by the transport, by eventually\n+     * notifying a nested callback.</p>\n+     * <p>There are 3 sources of concurrency after a send is initiated:</p>\n+     * <ul>\n+     *   <li>the completion of the send operation, either success or failure</li>\n+     *   <li>an asynchronous failure coming from the read side such as a stream\n+     *   being reset, or the connection being closed</li>\n+     *   <li>an asynchronous idle timeout</li>\n+     * </ul>\n+     * <p>The last 2 cases may happen <em>during</em> a send, when the frames\n+     * are being generated in the flusher.\n+     * In such cases, this class must avoid that the nested callback is notified\n+     * while the frame generation is in progress, because the nested callback\n+     * may modify other states (such as clearing the {@code HttpOutput._buffer})\n+     * that are accessed during frame generation.</p>\n+     * <p>The solution implemented in this class works by splitting the send\n+     * operation in 3 parts: {@code pre-send}, {@code send} and {@code post-send}.\n+     * Asynchronous state changes happening during {@code send} are stored\n+     * and only executed in {@code post-send}, therefore never interfering\n+     * with frame generation.</p>\n+     *\n+     * @see State\n+     */\n     private class TransportCallback implements Callback\n     {\n-        private State state = State.IDLE;\n-        private Callback callback;\n-        private Throwable failure;\n-        private boolean commit;\n+        private State _state = State.IDLE;\n+        private Callback _callback;\n+        private boolean _commit;\n+        private Throwable _failure;\n \n-        public boolean start(Callback callback, boolean commit)\n+        private void reset()\n         {\n-            State state;\n+            assert Thread.holdsLock(this);\n+            _state = State.IDLE;\n+            _callback = null;\n+            _commit = false;\n+            _failure = null;\n+        }\n+\n+        private void send(Callback callback, boolean commit, Consumer<Callback> sendFrame)\n+        {\n+            Throwable failure = sending(callback, commit);\n+            if (failure == null)\n+            {\n+                sendFrame.accept(this);\n+                pending();\n+            }\n+            else\n+            {\n+                callback.failed(failure);\n+            }\n+        }\n+\n+        private Throwable sending(Callback callback, boolean commit)\n+        {\n+            synchronized (this)\n+            {\n+                switch (_state)\n+                {\n+                    case IDLE:\n+                    {\n+                        _state = State.SENDING;\n+                        _callback = callback;\n+                        _commit = commit;\n+                        return null;\n+                    }\n+                    case FAILED:\n+                    {\n+                        return _failure;\n+                    }\n+                    default:\n+                    {\n+                        return new IllegalStateException(\"Invalid transport state: \" + _state);\n+                    }\n+                }\n+            }\n+        }\n+\n+        private void pending()\n+        {\n+            Callback callback;\n+            boolean commit;\n             Throwable failure;\n             synchronized (this)\n             {\n-                state = this.state;\n-                failure = this.failure;\n-                if (state == State.IDLE)\n+                switch (_state)\n                 {\n-                    this.state = State.WRITING;\n-                    this.callback = callback;\n-                    this.commit = commit;\n-                    return true;\n+                    case SENDING:\n+                    {\n+                        // The send has not completed the callback yet,\n+                        // wait for succeeded() or failed() to be called.\n+                        _state = State.PENDING;\n+                        return;\n+                    }\n+                    case SUCCEEDING:\n+                    {\n+                        // The send already completed successfully, but the\n+                        // call to succeeded() was delayed, so call it now.\n+                        callback = _callback;\n+                        commit = _commit;\n+                        failure = null;\n+                        reset();\n+                        break;\n+                    }\n+                    case FAILING:\n+                    {\n+                        // The send already completed with a failure, but\n+                        // the call to failed() was delayed, so call it now.\n+                        _state = State.FAILED;\n+                        callback = _callback;\n+                        commit = _commit;\n+                        failure = _failure;\n+                        break;\n+                    }\n+                    default:\n+                    {\n+                        _state = State.FAILED;\n+                        _failure = new IllegalStateException(\"Invalid transport state: \" + _state);\n+                        callback = _callback;\n+                        commit = _commit;\n+                        failure = _failure;\n+                        break;\n+                    }\n                 }\n             }\n             if (failure == null)\n-                failure = new IllegalStateException(\"Invalid transport state: \" + state);\n-            callback.failed(failure);\n-            return false;\n+                succeed(callback, commit);\n+            else\n+                fail(callback, commit, failure);\n         }\n \n         @Override\n         public void succeeded()\n         {\n+            Callback callback;\n             boolean commit;\n-            Callback callback = null;\n             synchronized (this)\n             {\n-                commit = this.commit;\n-                if (state == State.WRITING)\n+                switch (_state)\n                 {\n-                    this.state = State.IDLE;\n-                    callback = this.callback;\n-                    this.callback = null;\n-                    this.commit = false;\n+                    case SENDING:\n+                    {\n+                        _state = State.SUCCEEDING;\n+                        // Succeeding the callback will be done in postSend().\n+                        return;\n+                    }\n+                    case PENDING:\n+                    {\n+                        callback = _callback;\n+                        commit = _commit;\n+                        reset();\n+                        break;\n+                    }\n+                    default:\n+                    {\n+                        // This thread lost the race to succeed the current\n+                        // send, as other threads likely already failed it.\n+                        return;\n+                    }\n                 }\n             }\n-            if (LOG.isDebugEnabled())\n-                LOG.debug(\"HTTP2 Response #{}/{} {} {}\",\n-                    stream.getId(), Integer.toHexString(stream.getSession().hashCode()),\n-                    commit ? \"commit\" : \"flush\",\n-                    callback == null ? \"failure\" : \"success\");\n-            if (callback != null)\n-                callback.succeeded();\n+            succeed(callback, commit);\n         }\n \n         @Override\n         public void failed(Throwable failure)\n         {\n-            boolean commit;\n             Callback callback;\n+            boolean commit;\n             synchronized (this)\n             {\n-                commit = this.commit;\n-                this.state = State.FAILED;\n-                callback = this.callback;\n-                this.callback = null;\n-                this.failure = failure;\n+                switch (_state)\n+                {\n+                    case SENDING:\n+                    {\n+                        _state = State.FAILING;\n+                        _failure = failure;\n+                        // Failing the callback will be done in postSend().\n+                        return;\n+                    }\n+                    case IDLE:\n+                    case PENDING:\n+                    {\n+                        _state = State.FAILED;\n+                        _failure = failure;\n+                        callback = _callback;\n+                        commit = _commit;\n+                        break;\n+                    }\n+                    default:\n+                    {\n+                        // This thread lost the race to fail the current send,\n+                        // as other threads already succeeded or failed it.\n+                        return;\n+                    }\n+                }\n             }\n-            if (LOG.isDebugEnabled())\n-                LOG.debug(String.format(\"HTTP2 Response #%d/%h %s %s\", stream.getId(), stream.getSession(),\n-                    commit ? \"commit\" : \"flush\", callback == null ? \"ignored\" : \"failed\"), failure);\n-            if (callback != null)\n-                callback.failed(failure);\n+            fail(callback, commit, failure);\n         }\n \n-        private boolean onIdleTimeout(Throwable failure)\n+        private boolean idleTimeout(Throwable failure)\n         {\n-            boolean result;\n-            Callback callback = null;\n+            Callback callback;\n+            boolean timeout;\n             synchronized (this)\n             {\n-                // Ignore idle timeouts if not writing,\n-                // as the application may be suspended.\n-                result = state == State.WRITING;\n-                if (result)\n+                switch (_state)\n                 {\n-                    this.state = State.TIMEOUT;\n-                    callback = this.callback;\n-                    this.callback = null;\n-                    this.failure = failure;\n+                    case PENDING:\n+                    {\n+                        // The send was started but idle timed out, fail it.\n+                        _state = State.FAILED;\n+                        _failure = failure;\n+                        callback = _callback;\n+                        timeout = true;\n+                        break;\n+                    }\n+                    case IDLE:\n+                        // The application may be suspended, ignore the idle timeout.\n+                    case SENDING:\n+                        // A send has been started at the same time of an idle timeout;\n+                        // Ignore the idle timeout and let the write continue normally.\n+                    case SUCCEEDING:\n+                    case FAILING:\n+                        // An idle timeout during these transient states is ignored.\n+                    case FAILED:\n+                        // Already failed, ignore the idle timeout.\n+                    {\n+                        callback = null;\n+                        timeout = false;\n+                        break;\n+                    }\n+                    default:\n+                    {\n+                        // Should not happen, but just in case.\n+                        _state = State.FAILED;\n+                        _failure = new IllegalStateException(\"Invalid transport state: \" + _state, failure);\n+                        callback = _callback;\n+                        if (callback == null)\n+                            callback = Callback.NOOP;\n+                        timeout = true;\n+                        failure = _failure;\n+                        break;\n+                    }\n                 }\n             }\n+            idleTimeout(callback, timeout, failure);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjYyOTg2OQ=="}, "originalCommit": {"oid": "ee5183906cf9ffcbf4010d13b96857a92b0a8dc0"}, "originalPosition": 420}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcyMDA2MDg3OnYy", "diffSide": "RIGHT", "path": "jetty-http2/http2-server/src/main/java/org/eclipse/jetty/http2/server/HttpTransportOverHTTP2.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOFQxMTozNjoyNVrOGgZ1tQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOFQxNDowMzowM1rOGgf-rw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjYzMDk2NQ==", "bodyText": "perhaps onCompleteSuccess  to tie in with common behaviour of IteratingCallback?", "url": "https://github.com/eclipse/jetty.project/pull/4946#discussion_r436630965", "createdAt": "2020-06-08T11:36:25Z", "author": {"login": "gregw"}, "path": "jetty-http2/http2-server/src/main/java/org/eclipse/jetty/http2/server/HttpTransportOverHTTP2.java", "diffHunk": "@@ -350,119 +351,363 @@ public void abort(Throwable failure)\n             stream.reset(new ResetFrame(stream.getId(), ErrorCode.CANCEL_STREAM_ERROR.code), Callback.NOOP);\n     }\n \n+    /**\n+     * <p>Callback that controls sends initiated by the transport, by eventually\n+     * notifying a nested callback.</p>\n+     * <p>There are 3 sources of concurrency after a send is initiated:</p>\n+     * <ul>\n+     *   <li>the completion of the send operation, either success or failure</li>\n+     *   <li>an asynchronous failure coming from the read side such as a stream\n+     *   being reset, or the connection being closed</li>\n+     *   <li>an asynchronous idle timeout</li>\n+     * </ul>\n+     * <p>The last 2 cases may happen <em>during</em> a send, when the frames\n+     * are being generated in the flusher.\n+     * In such cases, this class must avoid that the nested callback is notified\n+     * while the frame generation is in progress, because the nested callback\n+     * may modify other states (such as clearing the {@code HttpOutput._buffer})\n+     * that are accessed during frame generation.</p>\n+     * <p>The solution implemented in this class works by splitting the send\n+     * operation in 3 parts: {@code pre-send}, {@code send} and {@code post-send}.\n+     * Asynchronous state changes happening during {@code send} are stored\n+     * and only executed in {@code post-send}, therefore never interfering\n+     * with frame generation.</p>\n+     *\n+     * @see State\n+     */\n     private class TransportCallback implements Callback\n     {\n-        private State state = State.IDLE;\n-        private Callback callback;\n-        private Throwable failure;\n-        private boolean commit;\n+        private State _state = State.IDLE;\n+        private Callback _callback;\n+        private boolean _commit;\n+        private Throwable _failure;\n \n-        public boolean start(Callback callback, boolean commit)\n+        private void reset()\n         {\n-            State state;\n+            assert Thread.holdsLock(this);\n+            _state = State.IDLE;\n+            _callback = null;\n+            _commit = false;\n+            _failure = null;\n+        }\n+\n+        private void send(Callback callback, boolean commit, Consumer<Callback> sendFrame)\n+        {\n+            Throwable failure = sending(callback, commit);\n+            if (failure == null)\n+            {\n+                sendFrame.accept(this);\n+                pending();\n+            }\n+            else\n+            {\n+                callback.failed(failure);\n+            }\n+        }\n+\n+        private Throwable sending(Callback callback, boolean commit)\n+        {\n+            synchronized (this)\n+            {\n+                switch (_state)\n+                {\n+                    case IDLE:\n+                    {\n+                        _state = State.SENDING;\n+                        _callback = callback;\n+                        _commit = commit;\n+                        return null;\n+                    }\n+                    case FAILED:\n+                    {\n+                        return _failure;\n+                    }\n+                    default:\n+                    {\n+                        return new IllegalStateException(\"Invalid transport state: \" + _state);\n+                    }\n+                }\n+            }\n+        }\n+\n+        private void pending()\n+        {\n+            Callback callback;\n+            boolean commit;\n             Throwable failure;\n             synchronized (this)\n             {\n-                state = this.state;\n-                failure = this.failure;\n-                if (state == State.IDLE)\n+                switch (_state)\n                 {\n-                    this.state = State.WRITING;\n-                    this.callback = callback;\n-                    this.commit = commit;\n-                    return true;\n+                    case SENDING:\n+                    {\n+                        // The send has not completed the callback yet,\n+                        // wait for succeeded() or failed() to be called.\n+                        _state = State.PENDING;\n+                        return;\n+                    }\n+                    case SUCCEEDING:\n+                    {\n+                        // The send already completed successfully, but the\n+                        // call to succeeded() was delayed, so call it now.\n+                        callback = _callback;\n+                        commit = _commit;\n+                        failure = null;\n+                        reset();\n+                        break;\n+                    }\n+                    case FAILING:\n+                    {\n+                        // The send already completed with a failure, but\n+                        // the call to failed() was delayed, so call it now.\n+                        _state = State.FAILED;\n+                        callback = _callback;\n+                        commit = _commit;\n+                        failure = _failure;\n+                        break;\n+                    }\n+                    default:\n+                    {\n+                        _state = State.FAILED;\n+                        _failure = new IllegalStateException(\"Invalid transport state: \" + _state);\n+                        callback = _callback;\n+                        commit = _commit;\n+                        failure = _failure;\n+                        break;\n+                    }\n                 }\n             }\n             if (failure == null)\n-                failure = new IllegalStateException(\"Invalid transport state: \" + state);\n-            callback.failed(failure);\n-            return false;\n+                succeed(callback, commit);\n+            else\n+                fail(callback, commit, failure);\n         }\n \n         @Override\n         public void succeeded()\n         {\n+            Callback callback;\n             boolean commit;\n-            Callback callback = null;\n             synchronized (this)\n             {\n-                commit = this.commit;\n-                if (state == State.WRITING)\n+                switch (_state)\n                 {\n-                    this.state = State.IDLE;\n-                    callback = this.callback;\n-                    this.callback = null;\n-                    this.commit = false;\n+                    case SENDING:\n+                    {\n+                        _state = State.SUCCEEDING;\n+                        // Succeeding the callback will be done in postSend().\n+                        return;\n+                    }\n+                    case PENDING:\n+                    {\n+                        callback = _callback;\n+                        commit = _commit;\n+                        reset();\n+                        break;\n+                    }\n+                    default:\n+                    {\n+                        // This thread lost the race to succeed the current\n+                        // send, as other threads likely already failed it.\n+                        return;\n+                    }\n                 }\n             }\n-            if (LOG.isDebugEnabled())\n-                LOG.debug(\"HTTP2 Response #{}/{} {} {}\",\n-                    stream.getId(), Integer.toHexString(stream.getSession().hashCode()),\n-                    commit ? \"commit\" : \"flush\",\n-                    callback == null ? \"failure\" : \"success\");\n-            if (callback != null)\n-                callback.succeeded();\n+            succeed(callback, commit);\n         }\n \n         @Override\n         public void failed(Throwable failure)\n         {\n-            boolean commit;\n             Callback callback;\n+            boolean commit;\n             synchronized (this)\n             {\n-                commit = this.commit;\n-                this.state = State.FAILED;\n-                callback = this.callback;\n-                this.callback = null;\n-                this.failure = failure;\n+                switch (_state)\n+                {\n+                    case SENDING:\n+                    {\n+                        _state = State.FAILING;\n+                        _failure = failure;\n+                        // Failing the callback will be done in postSend().\n+                        return;\n+                    }\n+                    case IDLE:\n+                    case PENDING:\n+                    {\n+                        _state = State.FAILED;\n+                        _failure = failure;\n+                        callback = _callback;\n+                        commit = _commit;\n+                        break;\n+                    }\n+                    default:\n+                    {\n+                        // This thread lost the race to fail the current send,\n+                        // as other threads already succeeded or failed it.\n+                        return;\n+                    }\n+                }\n             }\n-            if (LOG.isDebugEnabled())\n-                LOG.debug(String.format(\"HTTP2 Response #%d/%h %s %s\", stream.getId(), stream.getSession(),\n-                    commit ? \"commit\" : \"flush\", callback == null ? \"ignored\" : \"failed\"), failure);\n-            if (callback != null)\n-                callback.failed(failure);\n+            fail(callback, commit, failure);\n         }\n \n-        private boolean onIdleTimeout(Throwable failure)\n+        private boolean idleTimeout(Throwable failure)\n         {\n-            boolean result;\n-            Callback callback = null;\n+            Callback callback;\n+            boolean timeout;\n             synchronized (this)\n             {\n-                // Ignore idle timeouts if not writing,\n-                // as the application may be suspended.\n-                result = state == State.WRITING;\n-                if (result)\n+                switch (_state)\n                 {\n-                    this.state = State.TIMEOUT;\n-                    callback = this.callback;\n-                    this.callback = null;\n-                    this.failure = failure;\n+                    case PENDING:\n+                    {\n+                        // The send was started but idle timed out, fail it.\n+                        _state = State.FAILED;\n+                        _failure = failure;\n+                        callback = _callback;\n+                        timeout = true;\n+                        break;\n+                    }\n+                    case IDLE:\n+                        // The application may be suspended, ignore the idle timeout.\n+                    case SENDING:\n+                        // A send has been started at the same time of an idle timeout;\n+                        // Ignore the idle timeout and let the write continue normally.\n+                    case SUCCEEDING:\n+                    case FAILING:\n+                        // An idle timeout during these transient states is ignored.\n+                    case FAILED:\n+                        // Already failed, ignore the idle timeout.\n+                    {\n+                        callback = null;\n+                        timeout = false;\n+                        break;\n+                    }\n+                    default:\n+                    {\n+                        // Should not happen, but just in case.\n+                        _state = State.FAILED;\n+                        _failure = new IllegalStateException(\"Invalid transport state: \" + _state, failure);\n+                        callback = _callback;\n+                        if (callback == null)\n+                            callback = Callback.NOOP;\n+                        timeout = true;\n+                        failure = _failure;\n+                        break;\n+                    }\n                 }\n             }\n+            idleTimeout(callback, timeout, failure);\n+            return timeout;\n+        }\n+\n+        private void succeed(Callback callback, boolean commit)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ee5183906cf9ffcbf4010d13b96857a92b0a8dc0"}, "originalPosition": 424}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjczMTU2Nw==", "bodyText": "Not a big fan, as we are not iterating here.", "url": "https://github.com/eclipse/jetty.project/pull/4946#discussion_r436731567", "createdAt": "2020-06-08T14:03:03Z", "author": {"login": "sbordet"}, "path": "jetty-http2/http2-server/src/main/java/org/eclipse/jetty/http2/server/HttpTransportOverHTTP2.java", "diffHunk": "@@ -350,119 +351,363 @@ public void abort(Throwable failure)\n             stream.reset(new ResetFrame(stream.getId(), ErrorCode.CANCEL_STREAM_ERROR.code), Callback.NOOP);\n     }\n \n+    /**\n+     * <p>Callback that controls sends initiated by the transport, by eventually\n+     * notifying a nested callback.</p>\n+     * <p>There are 3 sources of concurrency after a send is initiated:</p>\n+     * <ul>\n+     *   <li>the completion of the send operation, either success or failure</li>\n+     *   <li>an asynchronous failure coming from the read side such as a stream\n+     *   being reset, or the connection being closed</li>\n+     *   <li>an asynchronous idle timeout</li>\n+     * </ul>\n+     * <p>The last 2 cases may happen <em>during</em> a send, when the frames\n+     * are being generated in the flusher.\n+     * In such cases, this class must avoid that the nested callback is notified\n+     * while the frame generation is in progress, because the nested callback\n+     * may modify other states (such as clearing the {@code HttpOutput._buffer})\n+     * that are accessed during frame generation.</p>\n+     * <p>The solution implemented in this class works by splitting the send\n+     * operation in 3 parts: {@code pre-send}, {@code send} and {@code post-send}.\n+     * Asynchronous state changes happening during {@code send} are stored\n+     * and only executed in {@code post-send}, therefore never interfering\n+     * with frame generation.</p>\n+     *\n+     * @see State\n+     */\n     private class TransportCallback implements Callback\n     {\n-        private State state = State.IDLE;\n-        private Callback callback;\n-        private Throwable failure;\n-        private boolean commit;\n+        private State _state = State.IDLE;\n+        private Callback _callback;\n+        private boolean _commit;\n+        private Throwable _failure;\n \n-        public boolean start(Callback callback, boolean commit)\n+        private void reset()\n         {\n-            State state;\n+            assert Thread.holdsLock(this);\n+            _state = State.IDLE;\n+            _callback = null;\n+            _commit = false;\n+            _failure = null;\n+        }\n+\n+        private void send(Callback callback, boolean commit, Consumer<Callback> sendFrame)\n+        {\n+            Throwable failure = sending(callback, commit);\n+            if (failure == null)\n+            {\n+                sendFrame.accept(this);\n+                pending();\n+            }\n+            else\n+            {\n+                callback.failed(failure);\n+            }\n+        }\n+\n+        private Throwable sending(Callback callback, boolean commit)\n+        {\n+            synchronized (this)\n+            {\n+                switch (_state)\n+                {\n+                    case IDLE:\n+                    {\n+                        _state = State.SENDING;\n+                        _callback = callback;\n+                        _commit = commit;\n+                        return null;\n+                    }\n+                    case FAILED:\n+                    {\n+                        return _failure;\n+                    }\n+                    default:\n+                    {\n+                        return new IllegalStateException(\"Invalid transport state: \" + _state);\n+                    }\n+                }\n+            }\n+        }\n+\n+        private void pending()\n+        {\n+            Callback callback;\n+            boolean commit;\n             Throwable failure;\n             synchronized (this)\n             {\n-                state = this.state;\n-                failure = this.failure;\n-                if (state == State.IDLE)\n+                switch (_state)\n                 {\n-                    this.state = State.WRITING;\n-                    this.callback = callback;\n-                    this.commit = commit;\n-                    return true;\n+                    case SENDING:\n+                    {\n+                        // The send has not completed the callback yet,\n+                        // wait for succeeded() or failed() to be called.\n+                        _state = State.PENDING;\n+                        return;\n+                    }\n+                    case SUCCEEDING:\n+                    {\n+                        // The send already completed successfully, but the\n+                        // call to succeeded() was delayed, so call it now.\n+                        callback = _callback;\n+                        commit = _commit;\n+                        failure = null;\n+                        reset();\n+                        break;\n+                    }\n+                    case FAILING:\n+                    {\n+                        // The send already completed with a failure, but\n+                        // the call to failed() was delayed, so call it now.\n+                        _state = State.FAILED;\n+                        callback = _callback;\n+                        commit = _commit;\n+                        failure = _failure;\n+                        break;\n+                    }\n+                    default:\n+                    {\n+                        _state = State.FAILED;\n+                        _failure = new IllegalStateException(\"Invalid transport state: \" + _state);\n+                        callback = _callback;\n+                        commit = _commit;\n+                        failure = _failure;\n+                        break;\n+                    }\n                 }\n             }\n             if (failure == null)\n-                failure = new IllegalStateException(\"Invalid transport state: \" + state);\n-            callback.failed(failure);\n-            return false;\n+                succeed(callback, commit);\n+            else\n+                fail(callback, commit, failure);\n         }\n \n         @Override\n         public void succeeded()\n         {\n+            Callback callback;\n             boolean commit;\n-            Callback callback = null;\n             synchronized (this)\n             {\n-                commit = this.commit;\n-                if (state == State.WRITING)\n+                switch (_state)\n                 {\n-                    this.state = State.IDLE;\n-                    callback = this.callback;\n-                    this.callback = null;\n-                    this.commit = false;\n+                    case SENDING:\n+                    {\n+                        _state = State.SUCCEEDING;\n+                        // Succeeding the callback will be done in postSend().\n+                        return;\n+                    }\n+                    case PENDING:\n+                    {\n+                        callback = _callback;\n+                        commit = _commit;\n+                        reset();\n+                        break;\n+                    }\n+                    default:\n+                    {\n+                        // This thread lost the race to succeed the current\n+                        // send, as other threads likely already failed it.\n+                        return;\n+                    }\n                 }\n             }\n-            if (LOG.isDebugEnabled())\n-                LOG.debug(\"HTTP2 Response #{}/{} {} {}\",\n-                    stream.getId(), Integer.toHexString(stream.getSession().hashCode()),\n-                    commit ? \"commit\" : \"flush\",\n-                    callback == null ? \"failure\" : \"success\");\n-            if (callback != null)\n-                callback.succeeded();\n+            succeed(callback, commit);\n         }\n \n         @Override\n         public void failed(Throwable failure)\n         {\n-            boolean commit;\n             Callback callback;\n+            boolean commit;\n             synchronized (this)\n             {\n-                commit = this.commit;\n-                this.state = State.FAILED;\n-                callback = this.callback;\n-                this.callback = null;\n-                this.failure = failure;\n+                switch (_state)\n+                {\n+                    case SENDING:\n+                    {\n+                        _state = State.FAILING;\n+                        _failure = failure;\n+                        // Failing the callback will be done in postSend().\n+                        return;\n+                    }\n+                    case IDLE:\n+                    case PENDING:\n+                    {\n+                        _state = State.FAILED;\n+                        _failure = failure;\n+                        callback = _callback;\n+                        commit = _commit;\n+                        break;\n+                    }\n+                    default:\n+                    {\n+                        // This thread lost the race to fail the current send,\n+                        // as other threads already succeeded or failed it.\n+                        return;\n+                    }\n+                }\n             }\n-            if (LOG.isDebugEnabled())\n-                LOG.debug(String.format(\"HTTP2 Response #%d/%h %s %s\", stream.getId(), stream.getSession(),\n-                    commit ? \"commit\" : \"flush\", callback == null ? \"ignored\" : \"failed\"), failure);\n-            if (callback != null)\n-                callback.failed(failure);\n+            fail(callback, commit, failure);\n         }\n \n-        private boolean onIdleTimeout(Throwable failure)\n+        private boolean idleTimeout(Throwable failure)\n         {\n-            boolean result;\n-            Callback callback = null;\n+            Callback callback;\n+            boolean timeout;\n             synchronized (this)\n             {\n-                // Ignore idle timeouts if not writing,\n-                // as the application may be suspended.\n-                result = state == State.WRITING;\n-                if (result)\n+                switch (_state)\n                 {\n-                    this.state = State.TIMEOUT;\n-                    callback = this.callback;\n-                    this.callback = null;\n-                    this.failure = failure;\n+                    case PENDING:\n+                    {\n+                        // The send was started but idle timed out, fail it.\n+                        _state = State.FAILED;\n+                        _failure = failure;\n+                        callback = _callback;\n+                        timeout = true;\n+                        break;\n+                    }\n+                    case IDLE:\n+                        // The application may be suspended, ignore the idle timeout.\n+                    case SENDING:\n+                        // A send has been started at the same time of an idle timeout;\n+                        // Ignore the idle timeout and let the write continue normally.\n+                    case SUCCEEDING:\n+                    case FAILING:\n+                        // An idle timeout during these transient states is ignored.\n+                    case FAILED:\n+                        // Already failed, ignore the idle timeout.\n+                    {\n+                        callback = null;\n+                        timeout = false;\n+                        break;\n+                    }\n+                    default:\n+                    {\n+                        // Should not happen, but just in case.\n+                        _state = State.FAILED;\n+                        _failure = new IllegalStateException(\"Invalid transport state: \" + _state, failure);\n+                        callback = _callback;\n+                        if (callback == null)\n+                            callback = Callback.NOOP;\n+                        timeout = true;\n+                        failure = _failure;\n+                        break;\n+                    }\n                 }\n             }\n+            idleTimeout(callback, timeout, failure);\n+            return timeout;\n+        }\n+\n+        private void succeed(Callback callback, boolean commit)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjYzMDk2NQ=="}, "originalCommit": {"oid": "ee5183906cf9ffcbf4010d13b96857a92b0a8dc0"}, "originalPosition": 424}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcyMDA2NDg1OnYy", "diffSide": "RIGHT", "path": "jetty-server/src/main/java/org/eclipse/jetty/server/HttpChannelState.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOFQxMTozODowNFrOGgZ4Nw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOFQxNDowNDoxNlrOGggDDg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjYzMTYwNw==", "bodyText": "Is this an unrelated fix?", "url": "https://github.com/eclipse/jetty.project/pull/4946#discussion_r436631607", "createdAt": "2020-06-08T11:38:04Z", "author": {"login": "gregw"}, "path": "jetty-server/src/main/java/org/eclipse/jetty/server/HttpChannelState.java", "diffHunk": "@@ -819,11 +819,16 @@ protected void onError(Throwable th)\n         {\n             // If we are still async and nobody has called sendError\n             if (_requestState == RequestState.ASYNC && !_sendError)\n+            {\n                 // Then the listeners did not invoke API methods\n                 // and the container must provide a default error dispatch.\n                 sendError(th);\n-            else\n+            }\n+            // Otherwise the listeners have called AsyncContext.complete().\n+            else if (_requestState != RequestState.COMPLETE)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ee5183906cf9ffcbf4010d13b96857a92b0a8dc0"}, "originalPosition": 11}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjczMjY4Ng==", "bodyText": "Correct, it has been introduced in a separate commit, 9dec284.", "url": "https://github.com/eclipse/jetty.project/pull/4946#discussion_r436732686", "createdAt": "2020-06-08T14:04:16Z", "author": {"login": "sbordet"}, "path": "jetty-server/src/main/java/org/eclipse/jetty/server/HttpChannelState.java", "diffHunk": "@@ -819,11 +819,16 @@ protected void onError(Throwable th)\n         {\n             // If we are still async and nobody has called sendError\n             if (_requestState == RequestState.ASYNC && !_sendError)\n+            {\n                 // Then the listeners did not invoke API methods\n                 // and the container must provide a default error dispatch.\n                 sendError(th);\n-            else\n+            }\n+            // Otherwise the listeners have called AsyncContext.complete().\n+            else if (_requestState != RequestState.COMPLETE)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjYzMTYwNw=="}, "originalCommit": {"oid": "ee5183906cf9ffcbf4010d13b96857a92b0a8dc0"}, "originalPosition": 11}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcyMDA2ODQ2OnYy", "diffSide": "RIGHT", "path": "jetty-server/src/main/java/org/eclipse/jetty/server/HttpChannelState.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOFQxMTozOTozMlrOGgZ6gA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOFQxNDowNjozOVrOGggMEg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjYzMjE5Mg==", "bodyText": "this comment comment is outside the if, so should be phrased as a conditional, or moved inside the if body", "url": "https://github.com/eclipse/jetty.project/pull/4946#discussion_r436632192", "createdAt": "2020-06-08T11:39:32Z", "author": {"login": "gregw"}, "path": "jetty-server/src/main/java/org/eclipse/jetty/server/HttpChannelState.java", "diffHunk": "@@ -819,11 +819,16 @@ protected void onError(Throwable th)\n         {\n             // If we are still async and nobody has called sendError\n             if (_requestState == RequestState.ASYNC && !_sendError)\n+            {\n                 // Then the listeners did not invoke API methods\n                 // and the container must provide a default error dispatch.\n                 sendError(th);\n-            else\n+            }\n+            // Otherwise the listeners have called AsyncContext.complete().", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ee5183906cf9ffcbf4010d13b96857a92b0a8dc0"}, "originalPosition": 10}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjczNDk5NA==", "bodyText": "I'm not a big fan of comments outside if/else that just say what the if/else is doing.\nI'm for removing both.", "url": "https://github.com/eclipse/jetty.project/pull/4946#discussion_r436734994", "createdAt": "2020-06-08T14:06:39Z", "author": {"login": "sbordet"}, "path": "jetty-server/src/main/java/org/eclipse/jetty/server/HttpChannelState.java", "diffHunk": "@@ -819,11 +819,16 @@ protected void onError(Throwable th)\n         {\n             // If we are still async and nobody has called sendError\n             if (_requestState == RequestState.ASYNC && !_sendError)\n+            {\n                 // Then the listeners did not invoke API methods\n                 // and the container must provide a default error dispatch.\n                 sendError(th);\n-            else\n+            }\n+            // Otherwise the listeners have called AsyncContext.complete().", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjYzMjE5Mg=="}, "originalCommit": {"oid": "ee5183906cf9ffcbf4010d13b96857a92b0a8dc0"}, "originalPosition": 10}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2596, "cost": 1, "resetAt": "2021-11-12T18:49:56Z"}}}