{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDY3MDMzNDky", "number": 5144, "reviewThreads": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xM1QwNzozNTo1MFrOEX7qHg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xM1QxMTozMzoxMFrOEYAzbQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkzNTMwMTQyOnYy", "diffSide": "RIGHT", "path": "jetty-http/src/main/java/org/eclipse/jetty/http/HttpFields.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xM1QwNzozNTo1MFrOG__kCw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xM1QwNzozNTo1MFrOG__kCw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTc1NDg5MQ==", "bodyText": "I'm not keen on this implementation as for the common cases it will create a bit more garbage than necessary. However I don't really want to hold up this PR any more, so perhaps I'll do a different PR to improve this implementation.... and look at using it in other places.", "url": "https://github.com/eclipse/jetty.project/pull/5144#discussion_r469754891", "createdAt": "2020-08-13T07:35:50Z", "author": {"login": "gregw"}, "path": "jetty-http/src/main/java/org/eclipse/jetty/http/HttpFields.java", "diffHunk": "@@ -88,6 +89,115 @@ public HttpFields(HttpFields fields)\n         _size = fields._size;\n     }\n \n+    /**\n+     * <p>Computes a single field for the given HTTP header name and for existing fields with the same name.</p>\n+     *\n+     * <p>The compute function receives the field name and a list of fields with the same name\n+     * so that their values can be used to compute the value of the field that is returned\n+     * by the compute function.\n+     * If the compute function returns {@code null}, the fields with the given name are removed.</p>\n+     * <p>This method comes handy when you want to add an HTTP header if it does not exist,\n+     * or add a value if the HTTP header already exists, similarly to\n+     * {@link Map#compute(Object, BiFunction)}.</p>\n+     *\n+     * <p>This method can be used to {@link #put(HttpField) put} a new field (or blindly replace its value):</p>\n+     * <pre>\n+     * httpFields.computeField(\"X-New-Header\",\n+     *     (name, fields) -> new HttpField(name, \"NewValue\"));\n+     * </pre>\n+     *\n+     * <p>This method can be used to coalesce many fields into one:</p>\n+     * <pre>\n+     * // Input:\n+     * GET / HTTP/1.1\n+     * Host: localhost\n+     * Cookie: foo=1\n+     * Cookie: bar=2,baz=3\n+     * User-Agent: Jetty\n+     *\n+     * // Computation:\n+     * httpFields.computeField(\"Cookie\", (name, fields) ->\n+     * {\n+     *     // No cookies, nothing to do.\n+     *     if (fields == null)\n+     *         return null;\n+     *\n+     *     // Coalesces all cookies.\n+     *     String coalesced = fields.stream()\n+     *         .flatMap(field -> Stream.of(field.getValues()))\n+     *         .collect(Collectors.joining(\", \"));\n+     *\n+     *     // Returns a single Cookie header with all cookies.\n+     *     return new HttpField(name, coalesced);\n+     * }\n+     *\n+     * // Output:\n+     * GET / HTTP/1.1\n+     * Host: localhost\n+     * Cookie: foo=1, bar=2, baz=3\n+     * User-Agent: Jetty\n+     * </pre>\n+     *\n+     * <p>This method can be used to replace a field:</p>\n+     * <pre>\n+     * httpFields.computeField(\"X-Length\", (name, fields) ->\n+     * {\n+     *     if (fields == null)\n+     *         return null;\n+     *\n+     *     // Get any value among the X-Length headers.\n+     *     String length = fields.stream()\n+     *         .map(HttpField::getValue)\n+     *         .findAny()\n+     *         .orElse(\"0\");\n+     *\n+     *     // Replace X-Length headers with X-Capacity header.\n+     *     return new HttpField(\"X-Capacity\", length);\n+     * });\n+     * </pre>\n+     *\n+     * <p>This method can be used to remove a field:</p>\n+     * <pre>\n+     * httpFields.computeField(\"Connection\", (name, fields) -> null);\n+     * </pre>\n+     *\n+     * @param name the HTTP header name\n+     * @param computeFn the compute function\n+     */\n+    public void computeField(String name, BiFunction<String, List<HttpField>, HttpField> computeFn)\n+    {\n+        boolean found = false;\n+        ListIterator<HttpField> iterator = listIterator();\n+        while (iterator.hasNext())\n+        {\n+            HttpField field = iterator.next();\n+            if (field.getName().equalsIgnoreCase(name))\n+            {\n+                if (found)\n+                {\n+                    // Remove other headers with the same name, since\n+                    // we have computed one from all of them already.\n+                    iterator.remove();\n+                }\n+                else\n+                {\n+                    found = true;\n+                    HttpField newField = computeFn.apply(name, Collections.unmodifiableList(getFields(name)));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "79d340fdb6202a5dbcd9e980a48718de44672a39"}, "originalPosition": 105}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkzNTM0NjEyOnYy", "diffSide": "RIGHT", "path": "jetty-http/src/main/java/org/eclipse/jetty/http/HttpFields.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xM1QwNzo0OToxNlrOG___Jw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xM1QwNzo0OToxNlrOG___Jw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTc2MTgzMQ==", "bodyText": "working on a better impl... meanwhile use add here not put, as you have already iterated and discovered that it is not found.", "url": "https://github.com/eclipse/jetty.project/pull/5144#discussion_r469761831", "createdAt": "2020-08-13T07:49:16Z", "author": {"login": "gregw"}, "path": "jetty-http/src/main/java/org/eclipse/jetty/http/HttpFields.java", "diffHunk": "@@ -88,6 +89,115 @@ public HttpFields(HttpFields fields)\n         _size = fields._size;\n     }\n \n+    /**\n+     * <p>Computes a single field for the given HTTP header name and for existing fields with the same name.</p>\n+     *\n+     * <p>The compute function receives the field name and a list of fields with the same name\n+     * so that their values can be used to compute the value of the field that is returned\n+     * by the compute function.\n+     * If the compute function returns {@code null}, the fields with the given name are removed.</p>\n+     * <p>This method comes handy when you want to add an HTTP header if it does not exist,\n+     * or add a value if the HTTP header already exists, similarly to\n+     * {@link Map#compute(Object, BiFunction)}.</p>\n+     *\n+     * <p>This method can be used to {@link #put(HttpField) put} a new field (or blindly replace its value):</p>\n+     * <pre>\n+     * httpFields.computeField(\"X-New-Header\",\n+     *     (name, fields) -> new HttpField(name, \"NewValue\"));\n+     * </pre>\n+     *\n+     * <p>This method can be used to coalesce many fields into one:</p>\n+     * <pre>\n+     * // Input:\n+     * GET / HTTP/1.1\n+     * Host: localhost\n+     * Cookie: foo=1\n+     * Cookie: bar=2,baz=3\n+     * User-Agent: Jetty\n+     *\n+     * // Computation:\n+     * httpFields.computeField(\"Cookie\", (name, fields) ->\n+     * {\n+     *     // No cookies, nothing to do.\n+     *     if (fields == null)\n+     *         return null;\n+     *\n+     *     // Coalesces all cookies.\n+     *     String coalesced = fields.stream()\n+     *         .flatMap(field -> Stream.of(field.getValues()))\n+     *         .collect(Collectors.joining(\", \"));\n+     *\n+     *     // Returns a single Cookie header with all cookies.\n+     *     return new HttpField(name, coalesced);\n+     * }\n+     *\n+     * // Output:\n+     * GET / HTTP/1.1\n+     * Host: localhost\n+     * Cookie: foo=1, bar=2, baz=3\n+     * User-Agent: Jetty\n+     * </pre>\n+     *\n+     * <p>This method can be used to replace a field:</p>\n+     * <pre>\n+     * httpFields.computeField(\"X-Length\", (name, fields) ->\n+     * {\n+     *     if (fields == null)\n+     *         return null;\n+     *\n+     *     // Get any value among the X-Length headers.\n+     *     String length = fields.stream()\n+     *         .map(HttpField::getValue)\n+     *         .findAny()\n+     *         .orElse(\"0\");\n+     *\n+     *     // Replace X-Length headers with X-Capacity header.\n+     *     return new HttpField(\"X-Capacity\", length);\n+     * });\n+     * </pre>\n+     *\n+     * <p>This method can be used to remove a field:</p>\n+     * <pre>\n+     * httpFields.computeField(\"Connection\", (name, fields) -> null);\n+     * </pre>\n+     *\n+     * @param name the HTTP header name\n+     * @param computeFn the compute function\n+     */\n+    public void computeField(String name, BiFunction<String, List<HttpField>, HttpField> computeFn)\n+    {\n+        boolean found = false;\n+        ListIterator<HttpField> iterator = listIterator();\n+        while (iterator.hasNext())\n+        {\n+            HttpField field = iterator.next();\n+            if (field.getName().equalsIgnoreCase(name))\n+            {\n+                if (found)\n+                {\n+                    // Remove other headers with the same name, since\n+                    // we have computed one from all of them already.\n+                    iterator.remove();\n+                }\n+                else\n+                {\n+                    found = true;\n+                    HttpField newField = computeFn.apply(name, Collections.unmodifiableList(getFields(name)));\n+                    if (newField == null)\n+                        iterator.remove();\n+                    else\n+                        iterator.set(newField);\n+                }\n+            }\n+        }\n+        if (!found)\n+        {\n+            HttpField newField = computeFn.apply(name, null);\n+            if (newField != null)\n+                put(newField);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "79d340fdb6202a5dbcd9e980a48718de44672a39"}, "originalPosition": 117}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkzNTM0NzQ4OnYy", "diffSide": "RIGHT", "path": "jetty-http/src/main/java/org/eclipse/jetty/http/HttpFields.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xM1QwNzo0OTozOVrOG___9g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xM1QwNzo0OTozOVrOG___9g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTc2MjAzOA==", "bodyText": "Need a version that takes a HttpHeader enum and you should use that for Via", "url": "https://github.com/eclipse/jetty.project/pull/5144#discussion_r469762038", "createdAt": "2020-08-13T07:49:39Z", "author": {"login": "gregw"}, "path": "jetty-http/src/main/java/org/eclipse/jetty/http/HttpFields.java", "diffHunk": "@@ -88,6 +89,115 @@ public HttpFields(HttpFields fields)\n         _size = fields._size;\n     }\n \n+    /**\n+     * <p>Computes a single field for the given HTTP header name and for existing fields with the same name.</p>\n+     *\n+     * <p>The compute function receives the field name and a list of fields with the same name\n+     * so that their values can be used to compute the value of the field that is returned\n+     * by the compute function.\n+     * If the compute function returns {@code null}, the fields with the given name are removed.</p>\n+     * <p>This method comes handy when you want to add an HTTP header if it does not exist,\n+     * or add a value if the HTTP header already exists, similarly to\n+     * {@link Map#compute(Object, BiFunction)}.</p>\n+     *\n+     * <p>This method can be used to {@link #put(HttpField) put} a new field (or blindly replace its value):</p>\n+     * <pre>\n+     * httpFields.computeField(\"X-New-Header\",\n+     *     (name, fields) -> new HttpField(name, \"NewValue\"));\n+     * </pre>\n+     *\n+     * <p>This method can be used to coalesce many fields into one:</p>\n+     * <pre>\n+     * // Input:\n+     * GET / HTTP/1.1\n+     * Host: localhost\n+     * Cookie: foo=1\n+     * Cookie: bar=2,baz=3\n+     * User-Agent: Jetty\n+     *\n+     * // Computation:\n+     * httpFields.computeField(\"Cookie\", (name, fields) ->\n+     * {\n+     *     // No cookies, nothing to do.\n+     *     if (fields == null)\n+     *         return null;\n+     *\n+     *     // Coalesces all cookies.\n+     *     String coalesced = fields.stream()\n+     *         .flatMap(field -> Stream.of(field.getValues()))\n+     *         .collect(Collectors.joining(\", \"));\n+     *\n+     *     // Returns a single Cookie header with all cookies.\n+     *     return new HttpField(name, coalesced);\n+     * }\n+     *\n+     * // Output:\n+     * GET / HTTP/1.1\n+     * Host: localhost\n+     * Cookie: foo=1, bar=2, baz=3\n+     * User-Agent: Jetty\n+     * </pre>\n+     *\n+     * <p>This method can be used to replace a field:</p>\n+     * <pre>\n+     * httpFields.computeField(\"X-Length\", (name, fields) ->\n+     * {\n+     *     if (fields == null)\n+     *         return null;\n+     *\n+     *     // Get any value among the X-Length headers.\n+     *     String length = fields.stream()\n+     *         .map(HttpField::getValue)\n+     *         .findAny()\n+     *         .orElse(\"0\");\n+     *\n+     *     // Replace X-Length headers with X-Capacity header.\n+     *     return new HttpField(\"X-Capacity\", length);\n+     * });\n+     * </pre>\n+     *\n+     * <p>This method can be used to remove a field:</p>\n+     * <pre>\n+     * httpFields.computeField(\"Connection\", (name, fields) -> null);\n+     * </pre>\n+     *\n+     * @param name the HTTP header name\n+     * @param computeFn the compute function\n+     */\n+    public void computeField(String name, BiFunction<String, List<HttpField>, HttpField> computeFn)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "79d340fdb6202a5dbcd9e980a48718de44672a39"}, "originalPosition": 87}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkzNjE0NDQ1OnYy", "diffSide": "RIGHT", "path": "jetty-proxy/src/main/java/org/eclipse/jetty/proxy/AbstractProxyServlet.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xM1QxMTozMzoxMFrOHAHigQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xM1QxMjoyMToyMVrOHAJBjg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTg4NTU2OQ==", "bodyText": "I trust that this fluent style will resolve to something efficient enough for the common case of a single Via field?   If not then it might not be a bad idea to have special handling for viaFields.size()==1", "url": "https://github.com/eclipse/jetty.project/pull/5144#discussion_r469885569", "createdAt": "2020-08-13T11:33:10Z", "author": {"login": "gregw"}, "path": "jetty-proxy/src/main/java/org/eclipse/jetty/proxy/AbstractProxyServlet.java", "diffHunk": "@@ -513,9 +524,50 @@ protected void addProxyHeaders(HttpServletRequest clientRequest, Request proxyRe\n         addXForwardedHeaders(clientRequest, proxyRequest);\n     }\n \n+    /**\n+     * Adds the HTTP {@code Via} header to the proxied request.\n+     *\n+     * @param proxyRequest the request being proxied\n+     * @see #addViaHeader(HttpServletRequest, Request)\n+     */\n     protected void addViaHeader(Request proxyRequest)\n     {\n-        proxyRequest.header(HttpHeader.VIA, \"http/1.1 \" + getViaHost());\n+        HttpServletRequest clientRequest = (HttpServletRequest)proxyRequest.getAttributes().get(CLIENT_REQUEST_ATTRIBUTE);\n+        addViaHeader(clientRequest, proxyRequest);\n+    }\n+\n+    /**\n+     * <p>Adds the HTTP {@code Via} header to the proxied request, taking into account data present in the client request.</p>\n+     * <p>This method considers the protocol of the client request when forming the proxied request. If it\n+     * is HTTP, then the protocol name will not be included in the {@code Via} header that is sent by the proxy, and only\n+     * the protocol version will be sent. If it is not, the entire protocol (name and version) will be included. \n+     * If the client request includes a {@code Via} header, the result will be appended to that to form a chain.</p>\n+     *\n+     * @param clientRequest the client request\n+     * @param proxyRequest the request being proxied\n+     * @see <a href=\"https://tools.ietf.org/html/rfc7230#section-5.7.1\">RFC 7230 section 5.7.1</a>\n+     */\n+    protected void addViaHeader(HttpServletRequest clientRequest, Request proxyRequest)\n+    {\n+        String protocol = clientRequest.getProtocol();\n+        String[] parts = protocol.split(\"/\", 2);\n+        // Retain only the version if the protocol is HTTP.\n+        String protocolPart = parts.length == 2 && \"HTTP\".equalsIgnoreCase(parts[0]) ? parts[1] : protocol;\n+        String viaHeaderValue = protocolPart + \" \" + getViaHost();\n+        proxyRequest.getHeaders().computeField(HttpHeader.VIA, (header, viaFields) ->\n+        {\n+            if (viaFields == null || viaFields.isEmpty())\n+                return new HttpField(header, viaHeaderValue);\n+            String separator = \", \";\n+            String newValue = viaFields.stream()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7b3dccc1bff6431538f6d4ff069a20d60293edd9"}, "originalPosition": 72}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTkwOTkwMg==", "bodyText": "@gregw lost in the rest of the proxying it's a case where I'd prefer less code than more special case handling.\nThe typical case is that we are the only proxy, so viaFields.size()==0, which is already optimized.", "url": "https://github.com/eclipse/jetty.project/pull/5144#discussion_r469909902", "createdAt": "2020-08-13T12:21:21Z", "author": {"login": "sbordet"}, "path": "jetty-proxy/src/main/java/org/eclipse/jetty/proxy/AbstractProxyServlet.java", "diffHunk": "@@ -513,9 +524,50 @@ protected void addProxyHeaders(HttpServletRequest clientRequest, Request proxyRe\n         addXForwardedHeaders(clientRequest, proxyRequest);\n     }\n \n+    /**\n+     * Adds the HTTP {@code Via} header to the proxied request.\n+     *\n+     * @param proxyRequest the request being proxied\n+     * @see #addViaHeader(HttpServletRequest, Request)\n+     */\n     protected void addViaHeader(Request proxyRequest)\n     {\n-        proxyRequest.header(HttpHeader.VIA, \"http/1.1 \" + getViaHost());\n+        HttpServletRequest clientRequest = (HttpServletRequest)proxyRequest.getAttributes().get(CLIENT_REQUEST_ATTRIBUTE);\n+        addViaHeader(clientRequest, proxyRequest);\n+    }\n+\n+    /**\n+     * <p>Adds the HTTP {@code Via} header to the proxied request, taking into account data present in the client request.</p>\n+     * <p>This method considers the protocol of the client request when forming the proxied request. If it\n+     * is HTTP, then the protocol name will not be included in the {@code Via} header that is sent by the proxy, and only\n+     * the protocol version will be sent. If it is not, the entire protocol (name and version) will be included. \n+     * If the client request includes a {@code Via} header, the result will be appended to that to form a chain.</p>\n+     *\n+     * @param clientRequest the client request\n+     * @param proxyRequest the request being proxied\n+     * @see <a href=\"https://tools.ietf.org/html/rfc7230#section-5.7.1\">RFC 7230 section 5.7.1</a>\n+     */\n+    protected void addViaHeader(HttpServletRequest clientRequest, Request proxyRequest)\n+    {\n+        String protocol = clientRequest.getProtocol();\n+        String[] parts = protocol.split(\"/\", 2);\n+        // Retain only the version if the protocol is HTTP.\n+        String protocolPart = parts.length == 2 && \"HTTP\".equalsIgnoreCase(parts[0]) ? parts[1] : protocol;\n+        String viaHeaderValue = protocolPart + \" \" + getViaHost();\n+        proxyRequest.getHeaders().computeField(HttpHeader.VIA, (header, viaFields) ->\n+        {\n+            if (viaFields == null || viaFields.isEmpty())\n+                return new HttpField(header, viaHeaderValue);\n+            String separator = \", \";\n+            String newValue = viaFields.stream()", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTg4NTU2OQ=="}, "originalCommit": {"oid": "7b3dccc1bff6431538f6d4ff069a20d60293edd9"}, "originalPosition": 72}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2305, "cost": 1, "resetAt": "2021-11-12T18:49:56Z"}}}