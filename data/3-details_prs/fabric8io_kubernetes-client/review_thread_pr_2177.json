{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDEwNzY5ODYw", "number": 2177, "reviewThreads": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNVQwMjo0Nzo0N1rOD5O-gA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNVQwMjo0Nzo0N1rOD5O-gA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYxMzQwODAwOnYy", "diffSide": "RIGHT", "path": "kubernetes-model/kubernetes-model-core/src/main/java/io/fabric8/kubernetes/internal/KubernetesDeserializer.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNVQwMjo0Nzo0N1rOGQYyTw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNVQwODozOTowMFrOGQfshw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTgzNjQ5NQ==", "bodyText": "could you take care of the indentation here?", "url": "https://github.com/fabric8io/kubernetes-client/pull/2177#discussion_r419836495", "createdAt": "2020-05-05T02:47:47Z", "author": {"login": "dev-gaur"}, "path": "kubernetes-model/kubernetes-model-core/src/main/java/io/fabric8/kubernetes/internal/KubernetesDeserializer.java", "diffHunk": "@@ -152,42 +111,133 @@ public static void registerCustomKind(String kind, Class<? extends KubernetesRes\n      * Registers a Custom Resource Definition Kind\n      */\n     public static void registerCustomKind(String apiVersion, String kind, Class<? extends KubernetesResource> clazz) {\n-        MAP.put(getKey(apiVersion, kind), clazz);\n+        mapping.registerKind(apiVersion, kind, clazz);\n+    }\n+\n+    /**\n+     * Registers a Custom Resource Mapping Provider\n+     */\n+    public static void registerProvider(KubernetesResourceMappingProvider provider) {\n+        mapping.registerProvider(provider);\n     }\n \n-    private static Class getTypeForKey(String key) {\n-        Class<? extends KubernetesResource> result = MAP.get(key);\n-        if (result == null) {\n-            String name = key != null && key.contains(KEY_SEPARATOR) ?\n-                key.substring(key.indexOf(KEY_SEPARATOR) + 1) :\n-                key;\n-            \n-            result = getInternalTypeForName(name);\n+    static class Mapping {\n+\n+        private static final String KEY_SEPARATOR = \"#\";\n+        private static final String[] PACKAGES = {\n+                \"io.fabric8.kubernetes.api.model.\",\n+                \"io.fabric8.kubernetes.api.model.admissionregistration.\",\n+                \"io.fabric8.kubernetes.api.model.apiextensions.\",\n+                \"io.fabric8.kubernetes.api.model.apps.\",\n+                \"io.fabric8.kubernetes.api.model.authentication.\",\n+                \"io.fabric8.kubernetes.api.model.authorization.\",\n+                \"io.fabric8.kubernetes.api.model.batch.\",\n+                \"io.fabric8.kubernetes.api.model.certificates.\",\n+                \"io.fabric8.kubernetes.api.model.coordination.\",\n+                \"io.fabric8.kubernetes.api.model.discovery.\",\n+                \"io.fabric8.kubernetes.api.model.extensions.\",\n+                \"io.fabric8.kubernetes.api.model.events.\",\n+                \"io.fabric8.kubernetes.api.model.networking.\",\n+                \"io.fabric8.kubernetes.api.model.policy.\",\n+                \"io.fabric8.kubernetes.api.model.rbac.\",\n+                \"io.fabric8.kubernetes.api.model.storage.\",\n+                \"io.fabric8.kubernetes.api.model.scheduling.\",\n+                \"io.fabric8.kubernetes.api.model.settings.\",\n+                \"io.fabric8.openshift.api.model.\"\n+        };\n+\n+        private Map<String, Class<? extends KubernetesResource>> mappings;\n+\n+        public synchronized Class<? extends KubernetesResource> getForKey(String key) {\n+            return getMappings().computeIfAbsent(key, k -> getInternalTypeForName(getClassName(k)));\n         }\n \n-        if (result != null) {\n-            MAP.put(key, result);\n+        public synchronized void registerKind(String apiVersion, String kind, Class<? extends KubernetesResource> clazz) {\n+            getMappings().put(createKey(apiVersion, kind), clazz);\n+        }\n+\n+        public synchronized void registerProvider(KubernetesResourceMappingProvider provider) {\n+            if (provider == null) {\n+                return;\n+            }\n+            Map<String, Class<? extends KubernetesResource>> providerMappings = provider.getMappings().entrySet().stream()\n+                    //If the model is shaded (which is as part of kubernetes-client uberjar) this is going to cause conflicts.\n+                    //This is why we NEED TO filter out incompatible resources.\n+                    .filter(entry -> KubernetesResource.class.isAssignableFrom(entry.getValue()))\n+                    .collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getValue));\n+            getMappings().putAll(providerMappings);\n         }\n-        return result;\n-    }\n \n-    private static Class getInternalTypeForName(String name) {\n+        /**\n+         * Returns a composite key for apiVersion and kind.\n+         */\n+        protected String createKey(String apiVersion, String kind) {\n+            if (kind == null) {\n+                return null;\n+            } else if (apiVersion == null) {\n+                return kind;\n+            } else {\n+                return apiVersion + KEY_SEPARATOR + kind;\n+            }\n+        }\n \n-      for (String aPackage : PACKAGES) {\n-        Class result = loadClassIfExists(aPackage + name);\n-        if (result != null) {\n-          return result;\n+        private synchronized Map<String, Class<? extends KubernetesResource>> getMappings() {\n+            if (mappings == null) {\n+                this.mappings = new HashMap<>();\n+                getAllMappingProviders().forEach(this::registerProvider);\n+            }\n+            return mappings;\n         }\n-      }\n \n-        return null;\n-    } \n+        protected Stream<KubernetesResourceMappingProvider> getAllMappingProviders() {\n+            //Use service loader to load extension types.\n+            Iterable<KubernetesResourceMappingProvider> currentThreadClassLoader =\n+                    () -> ServiceLoader.load(KubernetesResourceMappingProvider.class, Thread.currentThread().getContextClassLoader())\n+                            .iterator();\n+            Iterable<KubernetesResourceMappingProvider> classClassLoader =\n+                    () -> ServiceLoader.load(KubernetesResourceMappingProvider.class, KubernetesDeserializer.class.getClassLoader())\n+                            .iterator();\n+            return Stream.concat(\n+                    StreamSupport.stream(currentThreadClassLoader.spliterator(), false),\n+                    StreamSupport.stream(classClassLoader.spliterator(), false))\n+                    .filter(distinctByClassName(KubernetesResourceMappingProvider::getClass));\n+        }\n \n-    private static Class loadClassIfExists(String className) {\n-        try {\n-            return KubernetesDeserializer.class.getClassLoader().loadClass(className);\n-        } catch (Throwable t) {\n+        private String getClassName(String key) {\n+            if (key != null && key.contains(KEY_SEPARATOR)) {\n+                return key.substring(key.indexOf(KEY_SEPARATOR) + 1);\n+            } else {\n+                return key;\n+            }\n+        }\n+\n+        private Class<? extends KubernetesResource> getInternalTypeForName(String name) {\n+            for (String aPackage : PACKAGES) {\n+                Class<? extends KubernetesResource> result = loadClassIfExists(aPackage + name);\n+                if (result != null) {\n+                    return result;\n+                }\n+            }\n             return null;\n         }\n+\n+        private Class<? extends KubernetesResource> loadClassIfExists(String className) {\n+            try {\n+                Class<?> clazz = KubernetesDeserializer.class.getClassLoader().loadClass(className);\n+                if (!KubernetesResource.class.isAssignableFrom(clazz)) {\n+                    return null;\n+                }\n+                return (Class<? extends KubernetesResource>) clazz;\n+            } catch (Throwable t) {\n+                return null;\n+            }\n+        }\n+\n+        private Predicate<KubernetesResourceMappingProvider> distinctByClassName(\n+                Function<KubernetesResourceMappingProvider, Class<? extends KubernetesResourceMappingProvider>> mapperProvider) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "eafebb47fd1707b9f6144db5ada36d7ee3355539"}, "originalPosition": 321}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTk0OTcwMw==", "bodyText": "@dev-gaur this indentation is on purpose, the whole line is too long to fit in 120 characters. Splitting parts isn't readable since it's a single parameter with lengthy generics declaration. I therefore opted to keep the param declaration all together but pushed it onto it's own line that's indented by 4. 4 characters indentation is what I used consistently across this class. Makes sense?", "url": "https://github.com/fabric8io/kubernetes-client/pull/2177#discussion_r419949703", "createdAt": "2020-05-05T08:39:00Z", "author": {"login": "adietish"}, "path": "kubernetes-model/kubernetes-model-core/src/main/java/io/fabric8/kubernetes/internal/KubernetesDeserializer.java", "diffHunk": "@@ -152,42 +111,133 @@ public static void registerCustomKind(String kind, Class<? extends KubernetesRes\n      * Registers a Custom Resource Definition Kind\n      */\n     public static void registerCustomKind(String apiVersion, String kind, Class<? extends KubernetesResource> clazz) {\n-        MAP.put(getKey(apiVersion, kind), clazz);\n+        mapping.registerKind(apiVersion, kind, clazz);\n+    }\n+\n+    /**\n+     * Registers a Custom Resource Mapping Provider\n+     */\n+    public static void registerProvider(KubernetesResourceMappingProvider provider) {\n+        mapping.registerProvider(provider);\n     }\n \n-    private static Class getTypeForKey(String key) {\n-        Class<? extends KubernetesResource> result = MAP.get(key);\n-        if (result == null) {\n-            String name = key != null && key.contains(KEY_SEPARATOR) ?\n-                key.substring(key.indexOf(KEY_SEPARATOR) + 1) :\n-                key;\n-            \n-            result = getInternalTypeForName(name);\n+    static class Mapping {\n+\n+        private static final String KEY_SEPARATOR = \"#\";\n+        private static final String[] PACKAGES = {\n+                \"io.fabric8.kubernetes.api.model.\",\n+                \"io.fabric8.kubernetes.api.model.admissionregistration.\",\n+                \"io.fabric8.kubernetes.api.model.apiextensions.\",\n+                \"io.fabric8.kubernetes.api.model.apps.\",\n+                \"io.fabric8.kubernetes.api.model.authentication.\",\n+                \"io.fabric8.kubernetes.api.model.authorization.\",\n+                \"io.fabric8.kubernetes.api.model.batch.\",\n+                \"io.fabric8.kubernetes.api.model.certificates.\",\n+                \"io.fabric8.kubernetes.api.model.coordination.\",\n+                \"io.fabric8.kubernetes.api.model.discovery.\",\n+                \"io.fabric8.kubernetes.api.model.extensions.\",\n+                \"io.fabric8.kubernetes.api.model.events.\",\n+                \"io.fabric8.kubernetes.api.model.networking.\",\n+                \"io.fabric8.kubernetes.api.model.policy.\",\n+                \"io.fabric8.kubernetes.api.model.rbac.\",\n+                \"io.fabric8.kubernetes.api.model.storage.\",\n+                \"io.fabric8.kubernetes.api.model.scheduling.\",\n+                \"io.fabric8.kubernetes.api.model.settings.\",\n+                \"io.fabric8.openshift.api.model.\"\n+        };\n+\n+        private Map<String, Class<? extends KubernetesResource>> mappings;\n+\n+        public synchronized Class<? extends KubernetesResource> getForKey(String key) {\n+            return getMappings().computeIfAbsent(key, k -> getInternalTypeForName(getClassName(k)));\n         }\n \n-        if (result != null) {\n-            MAP.put(key, result);\n+        public synchronized void registerKind(String apiVersion, String kind, Class<? extends KubernetesResource> clazz) {\n+            getMappings().put(createKey(apiVersion, kind), clazz);\n+        }\n+\n+        public synchronized void registerProvider(KubernetesResourceMappingProvider provider) {\n+            if (provider == null) {\n+                return;\n+            }\n+            Map<String, Class<? extends KubernetesResource>> providerMappings = provider.getMappings().entrySet().stream()\n+                    //If the model is shaded (which is as part of kubernetes-client uberjar) this is going to cause conflicts.\n+                    //This is why we NEED TO filter out incompatible resources.\n+                    .filter(entry -> KubernetesResource.class.isAssignableFrom(entry.getValue()))\n+                    .collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getValue));\n+            getMappings().putAll(providerMappings);\n         }\n-        return result;\n-    }\n \n-    private static Class getInternalTypeForName(String name) {\n+        /**\n+         * Returns a composite key for apiVersion and kind.\n+         */\n+        protected String createKey(String apiVersion, String kind) {\n+            if (kind == null) {\n+                return null;\n+            } else if (apiVersion == null) {\n+                return kind;\n+            } else {\n+                return apiVersion + KEY_SEPARATOR + kind;\n+            }\n+        }\n \n-      for (String aPackage : PACKAGES) {\n-        Class result = loadClassIfExists(aPackage + name);\n-        if (result != null) {\n-          return result;\n+        private synchronized Map<String, Class<? extends KubernetesResource>> getMappings() {\n+            if (mappings == null) {\n+                this.mappings = new HashMap<>();\n+                getAllMappingProviders().forEach(this::registerProvider);\n+            }\n+            return mappings;\n         }\n-      }\n \n-        return null;\n-    } \n+        protected Stream<KubernetesResourceMappingProvider> getAllMappingProviders() {\n+            //Use service loader to load extension types.\n+            Iterable<KubernetesResourceMappingProvider> currentThreadClassLoader =\n+                    () -> ServiceLoader.load(KubernetesResourceMappingProvider.class, Thread.currentThread().getContextClassLoader())\n+                            .iterator();\n+            Iterable<KubernetesResourceMappingProvider> classClassLoader =\n+                    () -> ServiceLoader.load(KubernetesResourceMappingProvider.class, KubernetesDeserializer.class.getClassLoader())\n+                            .iterator();\n+            return Stream.concat(\n+                    StreamSupport.stream(currentThreadClassLoader.spliterator(), false),\n+                    StreamSupport.stream(classClassLoader.spliterator(), false))\n+                    .filter(distinctByClassName(KubernetesResourceMappingProvider::getClass));\n+        }\n \n-    private static Class loadClassIfExists(String className) {\n-        try {\n-            return KubernetesDeserializer.class.getClassLoader().loadClass(className);\n-        } catch (Throwable t) {\n+        private String getClassName(String key) {\n+            if (key != null && key.contains(KEY_SEPARATOR)) {\n+                return key.substring(key.indexOf(KEY_SEPARATOR) + 1);\n+            } else {\n+                return key;\n+            }\n+        }\n+\n+        private Class<? extends KubernetesResource> getInternalTypeForName(String name) {\n+            for (String aPackage : PACKAGES) {\n+                Class<? extends KubernetesResource> result = loadClassIfExists(aPackage + name);\n+                if (result != null) {\n+                    return result;\n+                }\n+            }\n             return null;\n         }\n+\n+        private Class<? extends KubernetesResource> loadClassIfExists(String className) {\n+            try {\n+                Class<?> clazz = KubernetesDeserializer.class.getClassLoader().loadClass(className);\n+                if (!KubernetesResource.class.isAssignableFrom(clazz)) {\n+                    return null;\n+                }\n+                return (Class<? extends KubernetesResource>) clazz;\n+            } catch (Throwable t) {\n+                return null;\n+            }\n+        }\n+\n+        private Predicate<KubernetesResourceMappingProvider> distinctByClassName(\n+                Function<KubernetesResourceMappingProvider, Class<? extends KubernetesResourceMappingProvider>> mapperProvider) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTgzNjQ5NQ=="}, "originalCommit": {"oid": "eafebb47fd1707b9f6144db5ada36d7ee3355539"}, "originalPosition": 321}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3708, "cost": 1, "resetAt": "2021-11-12T18:49:56Z"}}}