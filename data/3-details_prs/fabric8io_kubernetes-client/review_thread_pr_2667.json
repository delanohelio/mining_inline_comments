{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTQwNjcwNDk1", "number": 2667, "reviewThreads": {"totalCount": 17, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xN1QxNjowNToxMVrOFGyE_w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yMVQwOToyNjowMFrOFHuLUA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQyNjU2MjU1OnYy", "diffSide": "RIGHT", "path": "kubernetes-tests/src/test/java/io/fabric8/kubernetes/client/mock/DefaultSharedIndexInformerTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xN1QxNjowNToxMVrOIH81Bg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xN1QxNjowNToxMVrOIH81Bg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTIwNzU1OA==", "bodyText": "These invocations should be added to a test setup method", "url": "https://github.com/fabric8io/kubernetes-client/pull/2667#discussion_r545207558", "createdAt": "2020-12-17T16:05:11Z", "author": {"login": "manusa"}, "path": "kubernetes-tests/src/test/java/io/fabric8/kubernetes/client/mock/DefaultSharedIndexInformerTest.java", "diffHunk": "@@ -617,6 +635,285 @@ public void onDelete(Star star, boolean deletedFinalStateUnknown) { }\n     sharedInformerFactory.stopAllRegisteredInformers();\n   }\n \n+  @Test\n+  @DisplayName(\"Pod Informer should without list type should watch in all namespaces\")\n+  void testPodInformerWithNoOperationContextAndNoListType() throws InterruptedException {\n+    // Given\n+    String startResourceVersion = \"1000\", endResourceVersion = \"1001\";\n+    server.expect().withPath(\"/api/v1/pods\")\n+      .andReturn(200, new PodListBuilder().withNewMetadata().withResourceVersion(startResourceVersion).endMetadata().withItems(Collections.emptyList()).build()).once();\n+    server.expect().withPath(\"/api/v1/pods?resourceVersion=\" + startResourceVersion + \"&watch=true\")\n+      .andUpgradeToWebSocket()\n+      .open()\n+      .waitFor(WATCH_EVENT_EMIT_TIME)\n+      .andEmit(new WatchEvent(new PodBuilder().withNewMetadata().withNamespace(\"test\").withName(\"pod1\").withResourceVersion(endResourceVersion).endMetadata().build(), \"ADDED\"))\n+      .waitFor(OUTDATED_WATCH_EVENT_EMIT_TIME)\n+      .andEmit(outdatedEvent).done().always();\n+    KubernetesClient client = server.getClient();\n+\n+    // When\n+    SharedInformerFactory factory = client.informers();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bfe683b2f56e3c7740be4489ce1deb93e1f900f9"}, "originalPosition": 78}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQyNjU2Mzg1OnYy", "diffSide": "RIGHT", "path": "kubernetes-tests/src/test/java/io/fabric8/kubernetes/client/mock/DefaultSharedIndexInformerTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xN1QxNjowNToyOFrOIH81xA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xN1QxNjowNToyOFrOIH81xA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTIwNzc0OA==", "bodyText": "These invocations should be added to a test teardown method", "url": "https://github.com/fabric8io/kubernetes-client/pull/2667#discussion_r545207748", "createdAt": "2020-12-17T16:05:28Z", "author": {"login": "manusa"}, "path": "kubernetes-tests/src/test/java/io/fabric8/kubernetes/client/mock/DefaultSharedIndexInformerTest.java", "diffHunk": "@@ -617,6 +635,285 @@ public void onDelete(Star star, boolean deletedFinalStateUnknown) { }\n     sharedInformerFactory.stopAllRegisteredInformers();\n   }\n \n+  @Test\n+  @DisplayName(\"Pod Informer should without list type should watch in all namespaces\")\n+  void testPodInformerWithNoOperationContextAndNoListType() throws InterruptedException {\n+    // Given\n+    String startResourceVersion = \"1000\", endResourceVersion = \"1001\";\n+    server.expect().withPath(\"/api/v1/pods\")\n+      .andReturn(200, new PodListBuilder().withNewMetadata().withResourceVersion(startResourceVersion).endMetadata().withItems(Collections.emptyList()).build()).once();\n+    server.expect().withPath(\"/api/v1/pods?resourceVersion=\" + startResourceVersion + \"&watch=true\")\n+      .andUpgradeToWebSocket()\n+      .open()\n+      .waitFor(WATCH_EVENT_EMIT_TIME)\n+      .andEmit(new WatchEvent(new PodBuilder().withNewMetadata().withNamespace(\"test\").withName(\"pod1\").withResourceVersion(endResourceVersion).endMetadata().build(), \"ADDED\"))\n+      .waitFor(OUTDATED_WATCH_EVENT_EMIT_TIME)\n+      .andEmit(outdatedEvent).done().always();\n+    KubernetesClient client = server.getClient();\n+\n+    // When\n+    SharedInformerFactory factory = client.informers();\n+    SharedIndexInformer<Pod> podInformer = factory.sharedIndexInformerFor(Pod.class, RESYNC_PERIOD);\n+    CountDownLatch foundExistingPod = new CountDownLatch(1);\n+    podInformer.addEventHandler(new TestResourceHandler<>(foundExistingPod, \"pod1\"));\n+    factory.startAllRegisteredInformers();\n+    foundExistingPod.await(LATCH_AWAIT_PERIOD_IN_SECONDS, TimeUnit.SECONDS);\n+\n+    // Then\n+    assertEquals(0, foundExistingPod.getCount());\n+    factory.stopAllRegisteredInformers();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bfe683b2f56e3c7740be4489ce1deb93e1f900f9"}, "originalPosition": 87}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQzMDE0ODEwOnYy", "diffSide": "RIGHT", "path": "kubernetes-client/src/main/java/io/fabric8/kubernetes/client/informers/SharedInformerFactory.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xOFQxMDoyMjoyOFrOIIdM8A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xOFQxMDoyMjoyOFrOIIdM8A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTczNzk2OA==", "bodyText": "Shouldn't this use the new HasMetadata#getApiVersion instead? Is there a scenario where the the apiVersion derived from the OperationContext would clash with the version provided by the class itself?", "url": "https://github.com/fabric8io/kubernetes-client/pull/2667#discussion_r545737968", "createdAt": "2020-12-18T10:22:28Z", "author": {"login": "metacosm"}, "path": "kubernetes-client/src/main/java/io/fabric8/kubernetes/client/informers/SharedInformerFactory.java", "diffHunk": "@@ -266,4 +385,12 @@ private void initOperationContext(Config configuration) {\n       context = context.withIsNamespaceConfiguredFromGlobalConfig(true);\n     }\n   }\n+\n+  private <T extends HasMetadata> void  registerKindToKubernetesDeserializer(OperationContext context, Class<T> apiTypeClass) {\n+    if (context.getApiGroupName() != null && context.getApiGroupVersion() != null) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dde65ab3998ba12c2534f3c88299f073369a5f1a"}, "originalPosition": 239}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQzMDE1MDg3OnYy", "diffSide": "RIGHT", "path": "kubernetes-client/src/main/java/io/fabric8/kubernetes/client/informers/SharedInformerFactory.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xOFQxMDoyMzoxNVrOIIdOmg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xOFQxNzozNzowNlrOIIsQrQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTczODM5NA==", "bodyText": "What should be done when the information provided by the CRDContext clashes with what could be derived from the api type class?", "url": "https://github.com/fabric8io/kubernetes-client/pull/2667#discussion_r545738394", "createdAt": "2020-12-18T10:23:15Z", "author": {"login": "metacosm"}, "path": "kubernetes-client/src/main/java/io/fabric8/kubernetes/client/informers/SharedInformerFactory.java", "diffHunk": "@@ -89,10 +86,134 @@ public SharedInformerFactory(ExecutorService threadPool, OkHttpClient okHttpClie\n    * @return the shared index informer\n    */\n   public synchronized <T extends HasMetadata, L extends KubernetesResourceList<T>> SharedIndexInformer<T> sharedIndexInformerFor(Class<T> apiTypeClass, Class<L> apiListTypeClass, long resyncPeriodInMillis) {\n-    return sharedIndexInformerFor(apiTypeClass, apiListTypeClass, context.withApiGroupName(Utils.getAnnotationValue(apiTypeClass, Group.class))\n-      .withApiGroupVersion(Utils.getAnnotationValue(apiTypeClass, Version.class))\n-      .withPlural(getPluralFromKind(apiTypeClass.getSimpleName()))\n-      .withIsNamespaceConfiguredFromGlobalConfig(context.isNamespaceFromGlobalConfig()), resyncPeriodInMillis);\n+    return sharedIndexInformerFor(apiTypeClass, apiListTypeClass, null, resyncPeriodInMillis);\n+  }\n+\n+  /**\n+   * Constructs and returns a shared index informer with resync period specified. And the\n+   * informer cache will be overwritten.\n+   *\n+   * <b>Note:</b>It watches for events in <b>ALL NAMESPACES</b>.\n+   *\n+   * @param apiTypeClass apiType class\n+   * @param resyncPeriodInMillis resync period in milliseconds\n+   * @param <T> the type parameter (should extend {@link io.fabric8.kubernetes.api.model.HasMetadata} and implement {@link io.fabric8.kubernetes.api.model.Namespaced}) if Namespace scoped resource\n+   * @return the shared index informer\n+   */\n+  public synchronized <T extends HasMetadata> SharedIndexInformer<T> sharedIndexInformerFor(Class<T> apiTypeClass, long resyncPeriodInMillis) {\n+    return sharedIndexInformerFor(apiTypeClass, KubernetesResourceUtil.inferListType(apiTypeClass), resyncPeriodInMillis);\n+  }\n+\n+  /**\n+   * Constructs and returns a shared index informer with resync period specified. And the\n+   * informer cache will be overwritten.\n+   *\n+   * <b>Note:</b>It watches for events in <b>ALL NAMESPACES</b>.\n+   *\n+   * @param apiTypeClass apiType class\n+   * @param operationContext {@link OperationContext} Operation Context\n+   * @param resyncPeriodInMillis resync period in milliseconds\n+   * @param <T> the type parameter (should extend {@link io.fabric8.kubernetes.api.model.HasMetadata} and implement {@link io.fabric8.kubernetes.api.model.Namespaced}) if Namespace scoped resource\n+   * @return the shared index informer\n+   */\n+  public synchronized <T extends HasMetadata> SharedIndexInformer<T> sharedIndexInformerFor(Class<T> apiTypeClass, OperationContext operationContext, long resyncPeriodInMillis) {\n+    return sharedIndexInformerFor(apiTypeClass, KubernetesResourceUtil.inferListType(apiTypeClass), operationContext, resyncPeriodInMillis);\n+  }\n+\n+  /**\n+   * Constructs and returns a shared index informer with resync period specified for custom resources. Note that\n+   * {@link CustomResourceDefinitionContext} would be build using opinionated defaults by inspecting the ApiType\n+   * POJO\n+   *\n+   * @param apiTypeClass apiType class\n+   * @param operationContext operation context\n+   * @param resyncPeriodInMillis resync period in milliseconds\n+   * @param <T> the type parameter (should extend {@link CustomResource} and implement {@link io.fabric8.kubernetes.api.model.Namespaced})\n+   * @return the shared index informer\n+   */\n+  public synchronized <T extends HasMetadata> SharedIndexInformer<T> sharedIndexInformerForCustomResource(Class<T> apiTypeClass, OperationContext operationContext, long resyncPeriodInMillis) {\n+    return sharedIndexInformerForCustomResource(CustomResourceDefinitionContext.fromCustomResourceType(apiTypeClass), apiTypeClass, CustomResourceOperationsImpl.inferListType(apiTypeClass), operationContext, resyncPeriodInMillis);\n+  }\n+\n+  /**\n+   * Constructs and returns a shared index informer with resync period specified for custom resources. Note that\n+   * {@link CustomResourceDefinitionContext} would be build using opinionated defaults by inspecting the ApiType\n+   * POJO\n+   *\n+   * @param apiTypeClass apiType class\n+   * @param resyncPeriodInMillis  resync period in milliseconds\n+   * @param <T> the type parameter (should extend {@link io.fabric8.kubernetes.api.model.HasMetadata} and implement {@link io.fabric8.kubernetes.api.model.Namespaced})\n+   * @return the shared index informer\n+   */\n+  public synchronized <T extends HasMetadata> SharedIndexInformer<T> sharedIndexInformerForCustomResource(Class<T> apiTypeClass, long resyncPeriodInMillis) {\n+    return sharedIndexInformerForCustomResource(CustomResourceDefinitionContext.fromCustomResourceType(apiTypeClass), apiTypeClass, CustomResourceOperationsImpl.inferListType(apiTypeClass), resyncPeriodInMillis);\n+  }\n+\n+  /**\n+   * Constructs and returns a shared index informer with resync period specified for custom resources. Note that\n+   * {@link CustomResourceDefinitionContext} would be build using opinionated defaults by inspecting the ApiType\n+   * POJO\n+   *\n+   * <b>Note:</b>It watches for events in <b>ALL NAMESPACES</b>.\n+   *\n+   * @param apiTypeClass apiType class\n+   * @param apiListTypeClass api list type class\n+   * @param resyncPeriodInMillis resync period in milliseconds\n+   * @param <T> the type parameter (should extend {@link io.fabric8.kubernetes.api.model.HasMetadata} and implement {@link io.fabric8.kubernetes.api.model.Namespaced})\n+   * @param <L> the type's list parameter (should extend {@link io.fabric8.kubernetes.api.model.KubernetesResourceList}\n+   * @return the shared index informer\n+   */\n+  public synchronized <T extends HasMetadata, L extends KubernetesResourceList<T>> SharedIndexInformer<T> sharedIndexInformerForCustomResource(Class<T> apiTypeClass, Class<L> apiListTypeClass, long resyncPeriodInMillis) {\n+    return sharedIndexInformerForCustomResource(CustomResourceDefinitionContext.fromCustomResourceType(apiTypeClass), apiTypeClass, apiListTypeClass, resyncPeriodInMillis);\n+  }\n+\n+  /**\n+   * Constructs and returns a shared index informer with resync period specified for custom resources. You can use this\n+   * method to specify namespace in {@link OperationContext} if you want to monitor for events in a dedicated namespace\n+   * only or provide other filtering options. Note that {@link CustomResourceDefinitionContext} would be build using\n+   * opinionated defaults by inspecting the ApiType POJO\n+   *\n+   * @param apiTypeClass apiType class\n+   * @param apiListTypeClass api list type class\n+   * @param operationContext operation context\n+   * @param resyncPeriodInMillis resync period in milliseconds\n+   * @param <T> the type parameter (should extend {@link io.fabric8.kubernetes.api.model.HasMetadata} and implement {@link io.fabric8.kubernetes.api.model.Namespaced})\n+   * @param <L> the type's list parameter (should extend {@link io.fabric8.kubernetes.api.model.KubernetesResourceList}\n+   * @return the shared index informer\n+   */\n+  public synchronized <T extends HasMetadata, L extends KubernetesResourceList<T>> SharedIndexInformer<T> sharedIndexInformerForCustomResource(Class<T> apiTypeClass, Class<L> apiListTypeClass, OperationContext operationContext, long resyncPeriodInMillis) {\n+    return sharedIndexInformerForCustomResource(CustomResourceDefinitionContext.fromCustomResourceType(apiTypeClass), apiTypeClass, apiListTypeClass, operationContext, resyncPeriodInMillis);\n+  }\n+\n+  /**\n+   * Constructs and returns a shared index informer with resync period specified for custom resources. You can use this\n+   * method to specify namespace in {@link OperationContext} if you want to monitor for events in a dedicated namespace\n+   * only or provide other filtering options.\n+   *\n+   * @param crdContext {@link CustomResourceDefinitionContext} Context for CustomResourceDefinition\n+   * @param apiTypeClass apiType class\n+   * @param resyncPeriodInMillis resync period in milliseconds\n+   * @param <T> the type parameter (should extend {@link io.fabric8.kubernetes.api.model.HasMetadata} and implement {@link io.fabric8.kubernetes.api.model.Namespaced})\n+   * @return the shared index informer\n+   */\n+  public synchronized <T extends HasMetadata> SharedIndexInformer<T> sharedIndexInformerForCustomResource(CustomResourceDefinitionContext crdContext, Class<T> apiTypeClass, long resyncPeriodInMillis) {\n+    return sharedIndexInformerForCustomResource(crdContext, apiTypeClass, CustomResourceOperationsImpl.inferListType(apiTypeClass), resyncPeriodInMillis);\n+  }\n+\n+  /**\n+   * Constructs and returns a shared index informer with resync period specified for custom resources. You can use this\n+   * method to specify namespace in {@link OperationContext} if you want to monitor for events in a dedicated namespace\n+   * only or provide other filtering options.\n+   *\n+   * @param crdContext {@link CustomResourceDefinitionContext} Context for CustomResourceDefinition\n+   * @param apiTypeClass apiType class\n+   * @param operationContext operation context\n+   * @param resyncPeriodInMillis resync period in milliseconds\n+   * @param <T> the type parameter (should extend {@link io.fabric8.kubernetes.api.model.HasMetadata} and implement {@link io.fabric8.kubernetes.api.model.Namespaced})\n+   * @return the shared index informer\n+   */\n+  public synchronized <T extends HasMetadata> SharedIndexInformer<T> sharedIndexInformerForCustomResource(CustomResourceDefinitionContext crdContext, Class<T> apiTypeClass, OperationContext operationContext, long resyncPeriodInMillis) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dde65ab3998ba12c2534f3c88299f073369a5f1a"}, "originalPosition": 186}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTk4NDY4NQ==", "bodyText": "As per our discussion, I'm removing this method in favor of new improved methods. Now CRDContext should be built from POJO annotations or opinionated defaults.", "url": "https://github.com/fabric8io/kubernetes-client/pull/2667#discussion_r545984685", "createdAt": "2020-12-18T17:37:06Z", "author": {"login": "rohanKanojia"}, "path": "kubernetes-client/src/main/java/io/fabric8/kubernetes/client/informers/SharedInformerFactory.java", "diffHunk": "@@ -89,10 +86,134 @@ public SharedInformerFactory(ExecutorService threadPool, OkHttpClient okHttpClie\n    * @return the shared index informer\n    */\n   public synchronized <T extends HasMetadata, L extends KubernetesResourceList<T>> SharedIndexInformer<T> sharedIndexInformerFor(Class<T> apiTypeClass, Class<L> apiListTypeClass, long resyncPeriodInMillis) {\n-    return sharedIndexInformerFor(apiTypeClass, apiListTypeClass, context.withApiGroupName(Utils.getAnnotationValue(apiTypeClass, Group.class))\n-      .withApiGroupVersion(Utils.getAnnotationValue(apiTypeClass, Version.class))\n-      .withPlural(getPluralFromKind(apiTypeClass.getSimpleName()))\n-      .withIsNamespaceConfiguredFromGlobalConfig(context.isNamespaceFromGlobalConfig()), resyncPeriodInMillis);\n+    return sharedIndexInformerFor(apiTypeClass, apiListTypeClass, null, resyncPeriodInMillis);\n+  }\n+\n+  /**\n+   * Constructs and returns a shared index informer with resync period specified. And the\n+   * informer cache will be overwritten.\n+   *\n+   * <b>Note:</b>It watches for events in <b>ALL NAMESPACES</b>.\n+   *\n+   * @param apiTypeClass apiType class\n+   * @param resyncPeriodInMillis resync period in milliseconds\n+   * @param <T> the type parameter (should extend {@link io.fabric8.kubernetes.api.model.HasMetadata} and implement {@link io.fabric8.kubernetes.api.model.Namespaced}) if Namespace scoped resource\n+   * @return the shared index informer\n+   */\n+  public synchronized <T extends HasMetadata> SharedIndexInformer<T> sharedIndexInformerFor(Class<T> apiTypeClass, long resyncPeriodInMillis) {\n+    return sharedIndexInformerFor(apiTypeClass, KubernetesResourceUtil.inferListType(apiTypeClass), resyncPeriodInMillis);\n+  }\n+\n+  /**\n+   * Constructs and returns a shared index informer with resync period specified. And the\n+   * informer cache will be overwritten.\n+   *\n+   * <b>Note:</b>It watches for events in <b>ALL NAMESPACES</b>.\n+   *\n+   * @param apiTypeClass apiType class\n+   * @param operationContext {@link OperationContext} Operation Context\n+   * @param resyncPeriodInMillis resync period in milliseconds\n+   * @param <T> the type parameter (should extend {@link io.fabric8.kubernetes.api.model.HasMetadata} and implement {@link io.fabric8.kubernetes.api.model.Namespaced}) if Namespace scoped resource\n+   * @return the shared index informer\n+   */\n+  public synchronized <T extends HasMetadata> SharedIndexInformer<T> sharedIndexInformerFor(Class<T> apiTypeClass, OperationContext operationContext, long resyncPeriodInMillis) {\n+    return sharedIndexInformerFor(apiTypeClass, KubernetesResourceUtil.inferListType(apiTypeClass), operationContext, resyncPeriodInMillis);\n+  }\n+\n+  /**\n+   * Constructs and returns a shared index informer with resync period specified for custom resources. Note that\n+   * {@link CustomResourceDefinitionContext} would be build using opinionated defaults by inspecting the ApiType\n+   * POJO\n+   *\n+   * @param apiTypeClass apiType class\n+   * @param operationContext operation context\n+   * @param resyncPeriodInMillis resync period in milliseconds\n+   * @param <T> the type parameter (should extend {@link CustomResource} and implement {@link io.fabric8.kubernetes.api.model.Namespaced})\n+   * @return the shared index informer\n+   */\n+  public synchronized <T extends HasMetadata> SharedIndexInformer<T> sharedIndexInformerForCustomResource(Class<T> apiTypeClass, OperationContext operationContext, long resyncPeriodInMillis) {\n+    return sharedIndexInformerForCustomResource(CustomResourceDefinitionContext.fromCustomResourceType(apiTypeClass), apiTypeClass, CustomResourceOperationsImpl.inferListType(apiTypeClass), operationContext, resyncPeriodInMillis);\n+  }\n+\n+  /**\n+   * Constructs and returns a shared index informer with resync period specified for custom resources. Note that\n+   * {@link CustomResourceDefinitionContext} would be build using opinionated defaults by inspecting the ApiType\n+   * POJO\n+   *\n+   * @param apiTypeClass apiType class\n+   * @param resyncPeriodInMillis  resync period in milliseconds\n+   * @param <T> the type parameter (should extend {@link io.fabric8.kubernetes.api.model.HasMetadata} and implement {@link io.fabric8.kubernetes.api.model.Namespaced})\n+   * @return the shared index informer\n+   */\n+  public synchronized <T extends HasMetadata> SharedIndexInformer<T> sharedIndexInformerForCustomResource(Class<T> apiTypeClass, long resyncPeriodInMillis) {\n+    return sharedIndexInformerForCustomResource(CustomResourceDefinitionContext.fromCustomResourceType(apiTypeClass), apiTypeClass, CustomResourceOperationsImpl.inferListType(apiTypeClass), resyncPeriodInMillis);\n+  }\n+\n+  /**\n+   * Constructs and returns a shared index informer with resync period specified for custom resources. Note that\n+   * {@link CustomResourceDefinitionContext} would be build using opinionated defaults by inspecting the ApiType\n+   * POJO\n+   *\n+   * <b>Note:</b>It watches for events in <b>ALL NAMESPACES</b>.\n+   *\n+   * @param apiTypeClass apiType class\n+   * @param apiListTypeClass api list type class\n+   * @param resyncPeriodInMillis resync period in milliseconds\n+   * @param <T> the type parameter (should extend {@link io.fabric8.kubernetes.api.model.HasMetadata} and implement {@link io.fabric8.kubernetes.api.model.Namespaced})\n+   * @param <L> the type's list parameter (should extend {@link io.fabric8.kubernetes.api.model.KubernetesResourceList}\n+   * @return the shared index informer\n+   */\n+  public synchronized <T extends HasMetadata, L extends KubernetesResourceList<T>> SharedIndexInformer<T> sharedIndexInformerForCustomResource(Class<T> apiTypeClass, Class<L> apiListTypeClass, long resyncPeriodInMillis) {\n+    return sharedIndexInformerForCustomResource(CustomResourceDefinitionContext.fromCustomResourceType(apiTypeClass), apiTypeClass, apiListTypeClass, resyncPeriodInMillis);\n+  }\n+\n+  /**\n+   * Constructs and returns a shared index informer with resync period specified for custom resources. You can use this\n+   * method to specify namespace in {@link OperationContext} if you want to monitor for events in a dedicated namespace\n+   * only or provide other filtering options. Note that {@link CustomResourceDefinitionContext} would be build using\n+   * opinionated defaults by inspecting the ApiType POJO\n+   *\n+   * @param apiTypeClass apiType class\n+   * @param apiListTypeClass api list type class\n+   * @param operationContext operation context\n+   * @param resyncPeriodInMillis resync period in milliseconds\n+   * @param <T> the type parameter (should extend {@link io.fabric8.kubernetes.api.model.HasMetadata} and implement {@link io.fabric8.kubernetes.api.model.Namespaced})\n+   * @param <L> the type's list parameter (should extend {@link io.fabric8.kubernetes.api.model.KubernetesResourceList}\n+   * @return the shared index informer\n+   */\n+  public synchronized <T extends HasMetadata, L extends KubernetesResourceList<T>> SharedIndexInformer<T> sharedIndexInformerForCustomResource(Class<T> apiTypeClass, Class<L> apiListTypeClass, OperationContext operationContext, long resyncPeriodInMillis) {\n+    return sharedIndexInformerForCustomResource(CustomResourceDefinitionContext.fromCustomResourceType(apiTypeClass), apiTypeClass, apiListTypeClass, operationContext, resyncPeriodInMillis);\n+  }\n+\n+  /**\n+   * Constructs and returns a shared index informer with resync period specified for custom resources. You can use this\n+   * method to specify namespace in {@link OperationContext} if you want to monitor for events in a dedicated namespace\n+   * only or provide other filtering options.\n+   *\n+   * @param crdContext {@link CustomResourceDefinitionContext} Context for CustomResourceDefinition\n+   * @param apiTypeClass apiType class\n+   * @param resyncPeriodInMillis resync period in milliseconds\n+   * @param <T> the type parameter (should extend {@link io.fabric8.kubernetes.api.model.HasMetadata} and implement {@link io.fabric8.kubernetes.api.model.Namespaced})\n+   * @return the shared index informer\n+   */\n+  public synchronized <T extends HasMetadata> SharedIndexInformer<T> sharedIndexInformerForCustomResource(CustomResourceDefinitionContext crdContext, Class<T> apiTypeClass, long resyncPeriodInMillis) {\n+    return sharedIndexInformerForCustomResource(crdContext, apiTypeClass, CustomResourceOperationsImpl.inferListType(apiTypeClass), resyncPeriodInMillis);\n+  }\n+\n+  /**\n+   * Constructs and returns a shared index informer with resync period specified for custom resources. You can use this\n+   * method to specify namespace in {@link OperationContext} if you want to monitor for events in a dedicated namespace\n+   * only or provide other filtering options.\n+   *\n+   * @param crdContext {@link CustomResourceDefinitionContext} Context for CustomResourceDefinition\n+   * @param apiTypeClass apiType class\n+   * @param operationContext operation context\n+   * @param resyncPeriodInMillis resync period in milliseconds\n+   * @param <T> the type parameter (should extend {@link io.fabric8.kubernetes.api.model.HasMetadata} and implement {@link io.fabric8.kubernetes.api.model.Namespaced})\n+   * @return the shared index informer\n+   */\n+  public synchronized <T extends HasMetadata> SharedIndexInformer<T> sharedIndexInformerForCustomResource(CustomResourceDefinitionContext crdContext, Class<T> apiTypeClass, OperationContext operationContext, long resyncPeriodInMillis) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTczODM5NA=="}, "originalCommit": {"oid": "dde65ab3998ba12c2534f3c88299f073369a5f1a"}, "originalPosition": 186}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQzMDE1MzM3OnYy", "diffSide": "RIGHT", "path": "kubernetes-client/src/main/java/io/fabric8/kubernetes/client/utils/KubernetesResourceUtil.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xOFQxMDoyMzo1NFrOIIdQCg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xOFQxNzozNzowMFrOIIsQeA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTczODc2Mg==", "bodyText": "Maybe that should be moved to HasMetadata?", "url": "https://github.com/fabric8io/kubernetes-client/pull/2667#discussion_r545738762", "createdAt": "2020-12-18T10:23:54Z", "author": {"login": "metacosm"}, "path": "kubernetes-client/src/main/java/io/fabric8/kubernetes/client/utils/KubernetesResourceUtil.java", "diffHunk": "@@ -367,4 +369,16 @@ public static Duration getAge(HasMetadata kubernetesResource) {\n     Instant instant = Instant.parse(kubernetesResource.getMetadata().getCreationTimestamp());\n     return Duration.between(instant, Instant.now()).abs();\n   }\n+\n+  public static <T extends HasMetadata> Class<? extends KubernetesResourceList> inferListType(Class<T> type) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dde65ab3998ba12c2534f3c88299f073369a5f1a"}, "originalPosition": 16}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTk4NDYzMg==", "bodyText": "I'm not sure about this. There are several resources which implement HasMetadata but do not have a list type(For example TokenReview, SelfSubjectAccessReview etc)", "url": "https://github.com/fabric8io/kubernetes-client/pull/2667#discussion_r545984632", "createdAt": "2020-12-18T17:37:00Z", "author": {"login": "rohanKanojia"}, "path": "kubernetes-client/src/main/java/io/fabric8/kubernetes/client/utils/KubernetesResourceUtil.java", "diffHunk": "@@ -367,4 +369,16 @@ public static Duration getAge(HasMetadata kubernetesResource) {\n     Instant instant = Instant.parse(kubernetesResource.getMetadata().getCreationTimestamp());\n     return Duration.between(instant, Instant.now()).abs();\n   }\n+\n+  public static <T extends HasMetadata> Class<? extends KubernetesResourceList> inferListType(Class<T> type) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTczODc2Mg=="}, "originalCommit": {"oid": "dde65ab3998ba12c2534f3c88299f073369a5f1a"}, "originalPosition": 16}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQzMjQwNzc3OnYy", "diffSide": "RIGHT", "path": "doc/CHEATSHEET.md", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xOFQyMDo0MDo0M1rOIIyGIw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xOFQyMDo0MDo0M1rOIIyGIw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjA4MDI5MQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            Kubernetes Client also provides `SharedInformer` support in order to stay updated to events happening to your resource inside Kubernetes. It's implementation is just list and watch operations after a certain interval of time. Here are some of the common usages:\n          \n          \n            \n            Kubernetes Client also provides `SharedInformer` support in order to stay updated to events happening to your resource inside Kubernetes. Its implementation is simply list and watch operations after a certain interval of time. Here are some of the common usages:", "url": "https://github.com/fabric8io/kubernetes-client/pull/2667#discussion_r546080291", "createdAt": "2020-12-18T20:40:43Z", "author": {"login": "metacosm"}, "path": "doc/CHEATSHEET.md", "diffHunk": "@@ -2019,12 +2019,12 @@ try (KubernetesClient client = new DefaultKubernetesClient()) {\n ### SharedInformers\n Kubernetes Client also provides `SharedInformer` support in order to stay updated to events happening to your resource inside Kubernetes. It's implementation is just list and watch operations after a certain interval of time. Here are some of the common usages:", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "31ca3a338f9bd753c426d586693b493b00338193"}, "originalPosition": 2}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQzMjQwOTQwOnYy", "diffSide": "RIGHT", "path": "doc/CHEATSHEET.md", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xOFQyMDo0MToyMFrOIIyHGA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xOFQyMDo0MToyMFrOIIyHGA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjA4MDUzNg==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            - Create `SharedIndexInformer` for some Kubernetes Resource(requires resource's class, resource's list class, and resync period(when to check with server again while watching something).  By default it watches in all namespaces.:\n          \n          \n            \n            - Create `SharedIndexInformer` for some Kubernetes Resource(requires resource's class and resync period(when to check with server again while watching something).  By default it watches in all namespaces:", "url": "https://github.com/fabric8io/kubernetes-client/pull/2667#discussion_r546080536", "createdAt": "2020-12-18T20:41:20Z", "author": {"login": "metacosm"}, "path": "doc/CHEATSHEET.md", "diffHunk": "@@ -2019,12 +2019,12 @@ try (KubernetesClient client = new DefaultKubernetesClient()) {\n ### SharedInformers\n Kubernetes Client also provides `SharedInformer` support in order to stay updated to events happening to your resource inside Kubernetes. It's implementation is just list and watch operations after a certain interval of time. Here are some of the common usages:\n - Get `SharedInformerFactory`:\n-```\n+```java\n SharedInformerFactory sharedInformerFactory = client.informers();\n ```\n - Create `SharedIndexInformer` for some Kubernetes Resource(requires resource's class, resource's list class, and resync period(when to check with server again while watching something).  By default it watches in all namespaces.:", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "31ca3a338f9bd753c426d586693b493b00338193"}, "originalPosition": 8}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQzMjQxMTY3OnYy", "diffSide": "RIGHT", "path": "doc/CHEATSHEET.md", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xOFQyMDo0MjoxNFrOIIyIcA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xOFQyMDo0MjoxNFrOIIyIcA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjA4MDg4MA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            - Create `SharedIndexInformer` for some Custom Resource(in our case, `Dummy` resource provided in our [examples](https://github.com/fabric8io/kubernetes-client/tree/master/kubernetes-examples/src/main/java/io/fabric8/kubernetes/examples/crds) . By default it watches in all namespaces.\n          \n          \n            \n            - Create `SharedIndexInformer` for some Custom Resource(in our case, `Dummy` resource provided in our [examples](https://github.com/fabric8io/kubernetes-client/tree/master/kubernetes-examples/src/main/java/io/fabric8/kubernetes/examples/crds). By default it watches in all namespaces.", "url": "https://github.com/fabric8io/kubernetes-client/pull/2667#discussion_r546080880", "createdAt": "2020-12-18T20:42:14Z", "author": {"login": "metacosm"}, "path": "doc/CHEATSHEET.md", "diffHunk": "@@ -2043,14 +2043,8 @@ podInformer.addEventHandler(new ResourceEventHandler<Pod>() {\n });\n ```\n - Create `SharedIndexInformer` for some Custom Resource(in our case, `Dummy` resource provided in our [examples](https://github.com/fabric8io/kubernetes-client/tree/master/kubernetes-examples/src/main/java/io/fabric8/kubernetes/examples/crds) . By default it watches in all namespaces.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "31ca3a338f9bd753c426d586693b493b00338193"}, "originalPosition": 19}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQzMjQxNjQwOnYy", "diffSide": "RIGHT", "path": "doc/CHEATSHEET.md", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xOFQyMDo0Mzo1OVrOIIyLIQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yMVQwNjozMDo0MlrOIJNoHA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjA4MTU2OQ==", "bodyText": "This feels kinda weird\u2026", "url": "https://github.com/fabric8io/kubernetes-client/pull/2667#discussion_r546081569", "createdAt": "2020-12-18T20:43:59Z", "author": {"login": "metacosm"}, "path": "doc/CHEATSHEET.md", "diffHunk": "@@ -2069,11 +2063,10 @@ dummyInformer.addEventHandler(new ResourceEventHandler<Dummy>() {\n });\n ```\n - Create namespaced `SharedIndexInformer` (informers specific to a particular `Namespace`):\n-```\n+```java\n SharedInformerFactory sharedInformerFactory = client.informers();\n SharedIndexInformer<Pod> podInformer = sharedInformerFactory.sharedIndexInformerFor(\n         Pod.class,\n-        PodList.class,\n         new OperationContext().withNamespace(\"default\"),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "31ca3a338f9bd753c426d586693b493b00338193"}, "originalPosition": 43}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjUzMTM1Ng==", "bodyText": "Yes, I agree it's a bit confusing. I've added helper inNamespace() and withName() methods to configure namespace and name", "url": "https://github.com/fabric8io/kubernetes-client/pull/2667#discussion_r546531356", "createdAt": "2020-12-21T06:30:42Z", "author": {"login": "rohanKanojia"}, "path": "doc/CHEATSHEET.md", "diffHunk": "@@ -2069,11 +2063,10 @@ dummyInformer.addEventHandler(new ResourceEventHandler<Dummy>() {\n });\n ```\n - Create namespaced `SharedIndexInformer` (informers specific to a particular `Namespace`):\n-```\n+```java\n SharedInformerFactory sharedInformerFactory = client.informers();\n SharedIndexInformer<Pod> podInformer = sharedInformerFactory.sharedIndexInformerFor(\n         Pod.class,\n-        PodList.class,\n         new OperationContext().withNamespace(\"default\"),", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjA4MTU2OQ=="}, "originalCommit": {"oid": "31ca3a338f9bd753c426d586693b493b00338193"}, "originalPosition": 43}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQzMjQyMDY3OnYy", "diffSide": "RIGHT", "path": "doc/CHEATSHEET.md", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xOFQyMDo0NTo0MVrOIIyNqQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xOFQyMDo0NTo0MVrOIIyNqQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjA4MjIxNw==", "bodyText": "Plural is not required. It can be automatically computed based on the singular version. It's only required if the plural is uncommon. For example, Dummies should work automatically.", "url": "https://github.com/fabric8io/kubernetes-client/pull/2667#discussion_r546082217", "createdAt": "2020-12-18T20:45:41Z", "author": {"login": "metacosm"}, "path": "doc/CHEATSHEET.md", "diffHunk": "@@ -2094,18 +2087,27 @@ podInformer.addEventHandler(new ResourceEventHandler<Pod>() {\n         logger.info(\"Pod \" + pod.getMetadata().getName() + \" got deleted\");\n     }\n });\n+}\n ```\n - Create Namespaced Informer for a Custom Resource(**Note:** Your CustomResource POJO must implement `Namespaced` interface like the one used in this example: [Dummy.java](https://github.com/fabric8io/kubernetes-client/blob/master/kubernetes-examples/src/main/java/io/fabric8/kubernetes/examples/crds/Dummy.java))\n+You should have your CustomResource type POJO annotated with group, version and plural fields with respect to your CRD:", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "31ca3a338f9bd753c426d586693b493b00338193"}, "originalPosition": 53}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQzMjQyNjkzOnYy", "diffSide": "RIGHT", "path": "kubernetes-client/src/main/java/io/fabric8/kubernetes/client/informers/SharedInformerFactory.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xOFQyMDo0Nzo0NlrOIIyROA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xOFQyMDo0Nzo0NlrOIIyROA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjA4MzEyOA==", "bodyText": "What do you mean by informer cache will be overwritten? Is that needed information to specify in the javadoc?", "url": "https://github.com/fabric8io/kubernetes-client/pull/2667#discussion_r546083128", "createdAt": "2020-12-18T20:47:46Z", "author": {"login": "metacosm"}, "path": "kubernetes-client/src/main/java/io/fabric8/kubernetes/client/informers/SharedInformerFactory.java", "diffHunk": "@@ -82,58 +79,57 @@ public SharedInformerFactory(ExecutorService threadPool, OkHttpClient okHttpClie\n    * <b>Note:</b>It watches for events in <b>ALL NAMESPACES</b>.\n    *\n    * @param apiTypeClass apiType class\n-   * @param apiListTypeClass api list type class\n    * @param resyncPeriodInMillis resync period in milliseconds\n-   * @param <T> the type parameter (should extend {@link io.fabric8.kubernetes.api.model.HasMetadata} and implement {@link io.fabric8.kubernetes.api.model.Namespaced})\n-   * @param <L> the type's list parameter (should extend {@link io.fabric8.kubernetes.api.model.KubernetesResourceList}\n+   * @param <T> the type parameter (should extend {@link io.fabric8.kubernetes.api.model.HasMetadata} and implement {@link io.fabric8.kubernetes.api.model.Namespaced}) if Namespace scoped resource\n    * @return the shared index informer\n    */\n-  public synchronized <T extends HasMetadata, L extends KubernetesResourceList<T>> SharedIndexInformer<T> sharedIndexInformerFor(Class<T> apiTypeClass, Class<L> apiListTypeClass, long resyncPeriodInMillis) {\n-    return sharedIndexInformerFor(apiTypeClass, apiListTypeClass, context.withApiGroupName(Utils.getAnnotationValue(apiTypeClass, Group.class))\n-      .withApiGroupVersion(Utils.getAnnotationValue(apiTypeClass, Version.class))\n-      .withPlural(getPluralFromKind(apiTypeClass.getSimpleName()))\n-      .withIsNamespaceConfiguredFromGlobalConfig(context.isNamespaceFromGlobalConfig()), resyncPeriodInMillis);\n+  public synchronized <T extends HasMetadata> SharedIndexInformer<T> sharedIndexInformerFor(Class<T> apiTypeClass, long resyncPeriodInMillis) {\n+    return sharedIndexInformerFor(apiTypeClass, KubernetesResourceUtil.inferListType(apiTypeClass), null, resyncPeriodInMillis);\n   }\n \n   /**\n-   * Constructs and returns a shared index informer with resync period specified for custom resources.\n+   * Constructs and returns a shared index informer with resync period specified. And the\n+   * informer cache will be overwritten.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "31ca3a338f9bd753c426d586693b493b00338193"}, "originalPosition": 75}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQzMjQzMDYyOnYy", "diffSide": "RIGHT", "path": "kubernetes-client/src/main/java/io/fabric8/kubernetes/client/informers/SharedInformerFactory.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xOFQyMDo0OTowNVrOIIyTbg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xOFQyMDo0OTowNVrOIIyTbg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjA4MzY5NA==", "bodyText": "I don't think we need to mention how things are implemented here.", "url": "https://github.com/fabric8io/kubernetes-client/pull/2667#discussion_r546083694", "createdAt": "2020-12-18T20:49:05Z", "author": {"login": "metacosm"}, "path": "kubernetes-client/src/main/java/io/fabric8/kubernetes/client/informers/SharedInformerFactory.java", "diffHunk": "@@ -82,58 +79,57 @@ public SharedInformerFactory(ExecutorService threadPool, OkHttpClient okHttpClie\n    * <b>Note:</b>It watches for events in <b>ALL NAMESPACES</b>.\n    *\n    * @param apiTypeClass apiType class\n-   * @param apiListTypeClass api list type class\n    * @param resyncPeriodInMillis resync period in milliseconds\n-   * @param <T> the type parameter (should extend {@link io.fabric8.kubernetes.api.model.HasMetadata} and implement {@link io.fabric8.kubernetes.api.model.Namespaced})\n-   * @param <L> the type's list parameter (should extend {@link io.fabric8.kubernetes.api.model.KubernetesResourceList}\n+   * @param <T> the type parameter (should extend {@link io.fabric8.kubernetes.api.model.HasMetadata} and implement {@link io.fabric8.kubernetes.api.model.Namespaced}) if Namespace scoped resource\n    * @return the shared index informer\n    */\n-  public synchronized <T extends HasMetadata, L extends KubernetesResourceList<T>> SharedIndexInformer<T> sharedIndexInformerFor(Class<T> apiTypeClass, Class<L> apiListTypeClass, long resyncPeriodInMillis) {\n-    return sharedIndexInformerFor(apiTypeClass, apiListTypeClass, context.withApiGroupName(Utils.getAnnotationValue(apiTypeClass, Group.class))\n-      .withApiGroupVersion(Utils.getAnnotationValue(apiTypeClass, Version.class))\n-      .withPlural(getPluralFromKind(apiTypeClass.getSimpleName()))\n-      .withIsNamespaceConfiguredFromGlobalConfig(context.isNamespaceFromGlobalConfig()), resyncPeriodInMillis);\n+  public synchronized <T extends HasMetadata> SharedIndexInformer<T> sharedIndexInformerFor(Class<T> apiTypeClass, long resyncPeriodInMillis) {\n+    return sharedIndexInformerFor(apiTypeClass, KubernetesResourceUtil.inferListType(apiTypeClass), null, resyncPeriodInMillis);\n   }\n \n   /**\n-   * Constructs and returns a shared index informer with resync period specified for custom resources.\n+   * Constructs and returns a shared index informer with resync period specified. And the\n+   * informer cache will be overwritten.\n    *\n    * <b>Note:</b>It watches for events in <b>ALL NAMESPACES</b>.\n    *\n-   * @param customResourceContext basic information about the Custom Resource Definition corresponding to that custom resource\n    * @param apiTypeClass apiType class\n-   * @param apiListTypeClass api list type class\n+   * @param operationContext {@link OperationContext} Operation Context\n    * @param resyncPeriodInMillis resync period in milliseconds\n-   * @param <T> the type parameter (should extend {@link io.fabric8.kubernetes.api.model.HasMetadata} and implement {@link io.fabric8.kubernetes.api.model.Namespaced})\n-   * @param <L> the type's list parameter (should extend {@link io.fabric8.kubernetes.api.model.KubernetesResourceList}\n+   * @param <T> the type parameter (should extend {@link io.fabric8.kubernetes.api.model.HasMetadata} and implement {@link io.fabric8.kubernetes.api.model.Namespaced}) if Namespace scoped resource\n    * @return the shared index informer\n    */\n-  public synchronized <T extends HasMetadata, L extends KubernetesResourceList<T>> SharedIndexInformer<T> sharedIndexInformerForCustomResource(CustomResourceDefinitionContext customResourceContext, Class<T> apiTypeClass, Class<L> apiListTypeClass, long resyncPeriodInMillis) {\n-    return sharedIndexInformerFor(apiTypeClass, apiListTypeClass, context.withApiGroupVersion(customResourceContext.getVersion())\n-      .withApiGroupName(customResourceContext.getGroup())\n-      .withPlural(customResourceContext.getPlural())\n-      .withIsNamespaceConfiguredFromGlobalConfig(context.isNamespaceFromGlobalConfig()), resyncPeriodInMillis);\n+  public synchronized <T extends HasMetadata> SharedIndexInformer<T> sharedIndexInformerFor(Class<T> apiTypeClass, OperationContext operationContext, long resyncPeriodInMillis) {\n+    return sharedIndexInformerFor(apiTypeClass, KubernetesResourceUtil.inferListType(apiTypeClass), operationContext, resyncPeriodInMillis);\n   }\n \n   /**\n-   * Constructs and returns a shared index informer with resync period specified for custom resources. You can use this\n-   * method to specify namespace in {@link OperationContext} if you want to monitor for events in a dedicated namespace\n-   * only or provide other filtering options.\n+   * Constructs and returns a shared index informer with resync period specified for custom resources. Note that", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "31ca3a338f9bd753c426d586693b493b00338193"}, "originalPosition": 102}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQzMjQ0MjkwOnYy", "diffSide": "RIGHT", "path": "kubernetes-client/src/main/java/io/fabric8/kubernetes/client/informers/SharedInformerFactory.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xOFQyMDo1Mzo1MVrOIIyavQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xOFQyMDo1Mzo1MVrOIIyavQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjA4NTU2NQ==", "bodyText": "Why is the plural set here and not in other instances?", "url": "https://github.com/fabric8io/kubernetes-client/pull/2667#discussion_r546085565", "createdAt": "2020-12-18T20:53:51Z", "author": {"login": "metacosm"}, "path": "kubernetes-client/src/main/java/io/fabric8/kubernetes/client/informers/SharedInformerFactory.java", "diffHunk": "@@ -82,58 +79,57 @@ public SharedInformerFactory(ExecutorService threadPool, OkHttpClient okHttpClie\n    * <b>Note:</b>It watches for events in <b>ALL NAMESPACES</b>.\n    *\n    * @param apiTypeClass apiType class\n-   * @param apiListTypeClass api list type class\n    * @param resyncPeriodInMillis resync period in milliseconds\n-   * @param <T> the type parameter (should extend {@link io.fabric8.kubernetes.api.model.HasMetadata} and implement {@link io.fabric8.kubernetes.api.model.Namespaced})\n-   * @param <L> the type's list parameter (should extend {@link io.fabric8.kubernetes.api.model.KubernetesResourceList}\n+   * @param <T> the type parameter (should extend {@link io.fabric8.kubernetes.api.model.HasMetadata} and implement {@link io.fabric8.kubernetes.api.model.Namespaced}) if Namespace scoped resource\n    * @return the shared index informer\n    */\n-  public synchronized <T extends HasMetadata, L extends KubernetesResourceList<T>> SharedIndexInformer<T> sharedIndexInformerFor(Class<T> apiTypeClass, Class<L> apiListTypeClass, long resyncPeriodInMillis) {\n-    return sharedIndexInformerFor(apiTypeClass, apiListTypeClass, context.withApiGroupName(Utils.getAnnotationValue(apiTypeClass, Group.class))\n-      .withApiGroupVersion(Utils.getAnnotationValue(apiTypeClass, Version.class))\n-      .withPlural(getPluralFromKind(apiTypeClass.getSimpleName()))\n-      .withIsNamespaceConfiguredFromGlobalConfig(context.isNamespaceFromGlobalConfig()), resyncPeriodInMillis);\n+  public synchronized <T extends HasMetadata> SharedIndexInformer<T> sharedIndexInformerFor(Class<T> apiTypeClass, long resyncPeriodInMillis) {\n+    return sharedIndexInformerFor(apiTypeClass, KubernetesResourceUtil.inferListType(apiTypeClass), null, resyncPeriodInMillis);\n   }\n \n   /**\n-   * Constructs and returns a shared index informer with resync period specified for custom resources.\n+   * Constructs and returns a shared index informer with resync period specified. And the\n+   * informer cache will be overwritten.\n    *\n    * <b>Note:</b>It watches for events in <b>ALL NAMESPACES</b>.\n    *\n-   * @param customResourceContext basic information about the Custom Resource Definition corresponding to that custom resource\n    * @param apiTypeClass apiType class\n-   * @param apiListTypeClass api list type class\n+   * @param operationContext {@link OperationContext} Operation Context\n    * @param resyncPeriodInMillis resync period in milliseconds\n-   * @param <T> the type parameter (should extend {@link io.fabric8.kubernetes.api.model.HasMetadata} and implement {@link io.fabric8.kubernetes.api.model.Namespaced})\n-   * @param <L> the type's list parameter (should extend {@link io.fabric8.kubernetes.api.model.KubernetesResourceList}\n+   * @param <T> the type parameter (should extend {@link io.fabric8.kubernetes.api.model.HasMetadata} and implement {@link io.fabric8.kubernetes.api.model.Namespaced}) if Namespace scoped resource\n    * @return the shared index informer\n    */\n-  public synchronized <T extends HasMetadata, L extends KubernetesResourceList<T>> SharedIndexInformer<T> sharedIndexInformerForCustomResource(CustomResourceDefinitionContext customResourceContext, Class<T> apiTypeClass, Class<L> apiListTypeClass, long resyncPeriodInMillis) {\n-    return sharedIndexInformerFor(apiTypeClass, apiListTypeClass, context.withApiGroupVersion(customResourceContext.getVersion())\n-      .withApiGroupName(customResourceContext.getGroup())\n-      .withPlural(customResourceContext.getPlural())\n-      .withIsNamespaceConfiguredFromGlobalConfig(context.isNamespaceFromGlobalConfig()), resyncPeriodInMillis);\n+  public synchronized <T extends HasMetadata> SharedIndexInformer<T> sharedIndexInformerFor(Class<T> apiTypeClass, OperationContext operationContext, long resyncPeriodInMillis) {\n+    return sharedIndexInformerFor(apiTypeClass, KubernetesResourceUtil.inferListType(apiTypeClass), operationContext, resyncPeriodInMillis);\n   }\n \n   /**\n-   * Constructs and returns a shared index informer with resync period specified for custom resources. You can use this\n-   * method to specify namespace in {@link OperationContext} if you want to monitor for events in a dedicated namespace\n-   * only or provide other filtering options.\n+   * Constructs and returns a shared index informer with resync period specified for custom resources. Note that\n+   * {@link CustomResourceDefinitionContext} would be build using opinionated defaults by inspecting the ApiType\n+   * POJO\n    *\n-   * @param customResourceContext basic information about the Custom Resource Definition corresponding to that custom resource\n    * @param apiTypeClass apiType class\n-   * @param apiListTypeClass api list type class\n    * @param operationContext operation context\n    * @param resyncPeriodInMillis resync period in milliseconds\n+   * @param <T> the type parameter (should extend {@link CustomResource} and implement {@link io.fabric8.kubernetes.api.model.Namespaced})\n+   * @return the shared index informer\n+   */\n+  public synchronized <T extends HasMetadata> SharedIndexInformer<T> sharedIndexInformerForCustomResource(Class<T> apiTypeClass, OperationContext operationContext, long resyncPeriodInMillis) {\n+    return sharedIndexInformerFor(apiTypeClass, CustomResourceOperationsImpl.inferListType(apiTypeClass), operationContext.withPlural(CustomResourceDefinitionContext.fromCustomResourceType(apiTypeClass).getPlural()), resyncPeriodInMillis);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "31ca3a338f9bd753c426d586693b493b00338193"}, "originalPosition": 115}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQzMjQ0NDA5OnYy", "diffSide": "RIGHT", "path": "kubernetes-client/src/main/java/io/fabric8/kubernetes/client/informers/SharedInformerFactory.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xOFQyMDo1NDoyMFrOIIybbA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xOFQyMDo1NDoyMFrOIIybbA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjA4NTc0MA==", "bodyText": "Same as above: not sure we need to detail the implementation here.", "url": "https://github.com/fabric8io/kubernetes-client/pull/2667#discussion_r546085740", "createdAt": "2020-12-18T20:54:20Z", "author": {"login": "metacosm"}, "path": "kubernetes-client/src/main/java/io/fabric8/kubernetes/client/informers/SharedInformerFactory.java", "diffHunk": "@@ -82,58 +79,57 @@ public SharedInformerFactory(ExecutorService threadPool, OkHttpClient okHttpClie\n    * <b>Note:</b>It watches for events in <b>ALL NAMESPACES</b>.\n    *\n    * @param apiTypeClass apiType class\n-   * @param apiListTypeClass api list type class\n    * @param resyncPeriodInMillis resync period in milliseconds\n-   * @param <T> the type parameter (should extend {@link io.fabric8.kubernetes.api.model.HasMetadata} and implement {@link io.fabric8.kubernetes.api.model.Namespaced})\n-   * @param <L> the type's list parameter (should extend {@link io.fabric8.kubernetes.api.model.KubernetesResourceList}\n+   * @param <T> the type parameter (should extend {@link io.fabric8.kubernetes.api.model.HasMetadata} and implement {@link io.fabric8.kubernetes.api.model.Namespaced}) if Namespace scoped resource\n    * @return the shared index informer\n    */\n-  public synchronized <T extends HasMetadata, L extends KubernetesResourceList<T>> SharedIndexInformer<T> sharedIndexInformerFor(Class<T> apiTypeClass, Class<L> apiListTypeClass, long resyncPeriodInMillis) {\n-    return sharedIndexInformerFor(apiTypeClass, apiListTypeClass, context.withApiGroupName(Utils.getAnnotationValue(apiTypeClass, Group.class))\n-      .withApiGroupVersion(Utils.getAnnotationValue(apiTypeClass, Version.class))\n-      .withPlural(getPluralFromKind(apiTypeClass.getSimpleName()))\n-      .withIsNamespaceConfiguredFromGlobalConfig(context.isNamespaceFromGlobalConfig()), resyncPeriodInMillis);\n+  public synchronized <T extends HasMetadata> SharedIndexInformer<T> sharedIndexInformerFor(Class<T> apiTypeClass, long resyncPeriodInMillis) {\n+    return sharedIndexInformerFor(apiTypeClass, KubernetesResourceUtil.inferListType(apiTypeClass), null, resyncPeriodInMillis);\n   }\n \n   /**\n-   * Constructs and returns a shared index informer with resync period specified for custom resources.\n+   * Constructs and returns a shared index informer with resync period specified. And the\n+   * informer cache will be overwritten.\n    *\n    * <b>Note:</b>It watches for events in <b>ALL NAMESPACES</b>.\n    *\n-   * @param customResourceContext basic information about the Custom Resource Definition corresponding to that custom resource\n    * @param apiTypeClass apiType class\n-   * @param apiListTypeClass api list type class\n+   * @param operationContext {@link OperationContext} Operation Context\n    * @param resyncPeriodInMillis resync period in milliseconds\n-   * @param <T> the type parameter (should extend {@link io.fabric8.kubernetes.api.model.HasMetadata} and implement {@link io.fabric8.kubernetes.api.model.Namespaced})\n-   * @param <L> the type's list parameter (should extend {@link io.fabric8.kubernetes.api.model.KubernetesResourceList}\n+   * @param <T> the type parameter (should extend {@link io.fabric8.kubernetes.api.model.HasMetadata} and implement {@link io.fabric8.kubernetes.api.model.Namespaced}) if Namespace scoped resource\n    * @return the shared index informer\n    */\n-  public synchronized <T extends HasMetadata, L extends KubernetesResourceList<T>> SharedIndexInformer<T> sharedIndexInformerForCustomResource(CustomResourceDefinitionContext customResourceContext, Class<T> apiTypeClass, Class<L> apiListTypeClass, long resyncPeriodInMillis) {\n-    return sharedIndexInformerFor(apiTypeClass, apiListTypeClass, context.withApiGroupVersion(customResourceContext.getVersion())\n-      .withApiGroupName(customResourceContext.getGroup())\n-      .withPlural(customResourceContext.getPlural())\n-      .withIsNamespaceConfiguredFromGlobalConfig(context.isNamespaceFromGlobalConfig()), resyncPeriodInMillis);\n+  public synchronized <T extends HasMetadata> SharedIndexInformer<T> sharedIndexInformerFor(Class<T> apiTypeClass, OperationContext operationContext, long resyncPeriodInMillis) {\n+    return sharedIndexInformerFor(apiTypeClass, KubernetesResourceUtil.inferListType(apiTypeClass), operationContext, resyncPeriodInMillis);\n   }\n \n   /**\n-   * Constructs and returns a shared index informer with resync period specified for custom resources. You can use this\n-   * method to specify namespace in {@link OperationContext} if you want to monitor for events in a dedicated namespace\n-   * only or provide other filtering options.\n+   * Constructs and returns a shared index informer with resync period specified for custom resources. Note that\n+   * {@link CustomResourceDefinitionContext} would be build using opinionated defaults by inspecting the ApiType\n+   * POJO\n    *\n-   * @param customResourceContext basic information about the Custom Resource Definition corresponding to that custom resource\n    * @param apiTypeClass apiType class\n-   * @param apiListTypeClass api list type class\n    * @param operationContext operation context\n    * @param resyncPeriodInMillis resync period in milliseconds\n+   * @param <T> the type parameter (should extend {@link CustomResource} and implement {@link io.fabric8.kubernetes.api.model.Namespaced})\n+   * @return the shared index informer\n+   */\n+  public synchronized <T extends HasMetadata> SharedIndexInformer<T> sharedIndexInformerForCustomResource(Class<T> apiTypeClass, OperationContext operationContext, long resyncPeriodInMillis) {\n+    return sharedIndexInformerFor(apiTypeClass, CustomResourceOperationsImpl.inferListType(apiTypeClass), operationContext.withPlural(CustomResourceDefinitionContext.fromCustomResourceType(apiTypeClass).getPlural()), resyncPeriodInMillis);\n+  }\n+\n+  /**\n+   * Constructs and returns a shared index informer with resync period specified for custom resources. Note that\n+   * {@link CustomResourceDefinitionContext} would be build using opinionated defaults by inspecting the ApiType", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "31ca3a338f9bd753c426d586693b493b00338193"}, "originalPosition": 120}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQzMjQ2MDIyOnYy", "diffSide": "RIGHT", "path": "kubernetes-examples/src/main/java/io/fabric8/kubernetes/examples/crds/Dummy.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xOFQyMTowMDowNFrOIIyk4w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yMVQwOToxMTo0N1rOIJROZA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjA4ODE2Mw==", "bodyText": "Is that needed?", "url": "https://github.com/fabric8io/kubernetes-client/pull/2667#discussion_r546088163", "createdAt": "2020-12-18T21:00:04Z", "author": {"login": "metacosm"}, "path": "kubernetes-examples/src/main/java/io/fabric8/kubernetes/examples/crds/Dummy.java", "diffHunk": "@@ -20,10 +20,13 @@\n import io.fabric8.kubernetes.client.CustomResource;\n import io.fabric8.kubernetes.model.annotation.Group;\n import io.fabric8.kubernetes.model.annotation.Version;\n+import io.fabric8.kubernetes.model.annotation.Plural;\n \n @Version(Dummy.VERSION)\n @Group(Dummy.GROUP)\n+@Plural(Dummy.PLURAL)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "31ca3a338f9bd753c426d586693b493b00338193"}, "originalPosition": 8}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjUzMTkxOA==", "bodyText": "I was using Utils.getPluralFromKind for resolving plural which wasn't handling it. I've changed informers to use Pluralize.toPlural instead which now handle this case", "url": "https://github.com/fabric8io/kubernetes-client/pull/2667#discussion_r546531918", "createdAt": "2020-12-21T06:32:54Z", "author": {"login": "rohanKanojia"}, "path": "kubernetes-examples/src/main/java/io/fabric8/kubernetes/examples/crds/Dummy.java", "diffHunk": "@@ -20,10 +20,13 @@\n import io.fabric8.kubernetes.client.CustomResource;\n import io.fabric8.kubernetes.model.annotation.Group;\n import io.fabric8.kubernetes.model.annotation.Version;\n+import io.fabric8.kubernetes.model.annotation.Plural;\n \n @Version(Dummy.VERSION)\n @Group(Dummy.GROUP)\n+@Plural(Dummy.PLURAL)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjA4ODE2Mw=="}, "originalCommit": {"oid": "31ca3a338f9bd753c426d586693b493b00338193"}, "originalPosition": 8}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjU5MDMwOA==", "bodyText": "The problem is that this logic should be taken from CustomResource so that we don't have several different implementations that more or less do the same thing albeit sightly differently.  Similarly, there should be only one method that does the pluralization and everything should use it instead of having 2 different methods.", "url": "https://github.com/fabric8io/kubernetes-client/pull/2667#discussion_r546590308", "createdAt": "2020-12-21T09:11:47Z", "author": {"login": "metacosm"}, "path": "kubernetes-examples/src/main/java/io/fabric8/kubernetes/examples/crds/Dummy.java", "diffHunk": "@@ -20,10 +20,13 @@\n import io.fabric8.kubernetes.client.CustomResource;\n import io.fabric8.kubernetes.model.annotation.Group;\n import io.fabric8.kubernetes.model.annotation.Version;\n+import io.fabric8.kubernetes.model.annotation.Plural;\n \n @Version(Dummy.VERSION)\n @Group(Dummy.GROUP)\n+@Plural(Dummy.PLURAL)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjA4ODE2Mw=="}, "originalCommit": {"oid": "31ca3a338f9bd753c426d586693b493b00338193"}, "originalPosition": 8}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQzNjM5NDc4OnYy", "diffSide": "RIGHT", "path": "kubernetes-client/src/main/java/io/fabric8/kubernetes/client/informers/SharedInformerFactory.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yMVQwOToyMTozNlrOIJRgnQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yMVQxMDo1Mzo0OFrOIJUNqQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjU5NDk3Mw==", "bodyText": "That should really be: CustomResource.getPlural(apiTypeClass). The problem, though, is that this requires apiTypeClass to extend CustomResource, which is why I tend to think that the logic for these methods should maybe be moved to HasMetadata. Either that, or make these informers methods take a CustomResource instance?\nThe problem with the logic above is that potentially the class has been annotated with @Singular which means that the singular version might not be equal to kind. The class might also have been annotated with @Plural in which case, that value should be used and not some other computation\u2026", "url": "https://github.com/fabric8io/kubernetes-client/pull/2667#discussion_r546594973", "createdAt": "2020-12-21T09:21:36Z", "author": {"login": "metacosm"}, "path": "kubernetes-client/src/main/java/io/fabric8/kubernetes/client/informers/SharedInformerFactory.java", "diffHunk": "@@ -275,6 +268,6 @@ private void initOperationContext(Config configuration) {\n     if (CustomResource.class.isAssignableFrom(apiTypeClass)) {\n       return CustomResourceDefinitionContext.fromCustomResourceType(apiTypeClass).getPlural();\n     }\n-    return getPluralFromKind(HasMetadata.getKind(apiTypeClass));\n+    return Pluralize.toPlural(HasMetadata.getKind(apiTypeClass)).toLowerCase();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a9bda082fe43e77f0552e687a3392b9ec9513cfc"}, "originalPosition": 78}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjYzOTI3Mw==", "bodyText": "Yes, I think you're right. We should update sharedIndexInformerForCustomResource to use CustomResource instead. I'll update this.", "url": "https://github.com/fabric8io/kubernetes-client/pull/2667#discussion_r546639273", "createdAt": "2020-12-21T10:53:48Z", "author": {"login": "rohanKanojia"}, "path": "kubernetes-client/src/main/java/io/fabric8/kubernetes/client/informers/SharedInformerFactory.java", "diffHunk": "@@ -275,6 +268,6 @@ private void initOperationContext(Config configuration) {\n     if (CustomResource.class.isAssignableFrom(apiTypeClass)) {\n       return CustomResourceDefinitionContext.fromCustomResourceType(apiTypeClass).getPlural();\n     }\n-    return getPluralFromKind(HasMetadata.getKind(apiTypeClass));\n+    return Pluralize.toPlural(HasMetadata.getKind(apiTypeClass)).toLowerCase();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjU5NDk3Mw=="}, "originalCommit": {"oid": "a9bda082fe43e77f0552e687a3392b9ec9513cfc"}, "originalPosition": 78}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQzNjQwOTEyOnYy", "diffSide": "RIGHT", "path": "doc/CHEATSHEET.md", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yMVQwOToyNjowMFrOIJRpQQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yMVQxNTozODo1NFrOIJcgAQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjU5NzE4NQ==", "bodyText": "Feels better, indeed but then all methods taking an OperationContext should be removed, right?", "url": "https://github.com/fabric8io/kubernetes-client/pull/2667#discussion_r546597185", "createdAt": "2020-12-21T09:26:00Z", "author": {"login": "metacosm"}, "path": "doc/CHEATSHEET.md", "diffHunk": "@@ -2065,9 +2065,8 @@ dummyInformer.addEventHandler(new ResourceEventHandler<Dummy>() {\n - Create namespaced `SharedIndexInformer` (informers specific to a particular `Namespace`):\n ```java\n SharedInformerFactory sharedInformerFactory = client.informers();\n-SharedIndexInformer<Pod> podInformer = sharedInformerFactory.sharedIndexInformerFor(\n+SharedIndexInformer<Pod> podInformer = sharedInformerFactory.inNamespace(\"default\").sharedIndexInformerFor(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "39bf5f195197396cf565b52af734b2ca51546354"}, "originalPosition": 14}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjYzNDg1Ng==", "bodyText": "I have provided utility methods like inNamespace(), withName() for configuring namespace/name. A user might also want to provide more filtering options like labels, fieldSelectors which can be done by these OperationContext methods.\nShall I introduce withLabels(), withFields methods in SharedInformerFactory or shall I keep these OperationContext methods?", "url": "https://github.com/fabric8io/kubernetes-client/pull/2667#discussion_r546634856", "createdAt": "2020-12-21T10:44:09Z", "author": {"login": "rohanKanojia"}, "path": "doc/CHEATSHEET.md", "diffHunk": "@@ -2065,9 +2065,8 @@ dummyInformer.addEventHandler(new ResourceEventHandler<Dummy>() {\n - Create namespaced `SharedIndexInformer` (informers specific to a particular `Namespace`):\n ```java\n SharedInformerFactory sharedInformerFactory = client.informers();\n-SharedIndexInformer<Pod> podInformer = sharedInformerFactory.sharedIndexInformerFor(\n+SharedIndexInformer<Pod> podInformer = sharedInformerFactory.inNamespace(\"default\").sharedIndexInformerFor(", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjU5NzE4NQ=="}, "originalCommit": {"oid": "39bf5f195197396cf565b52af734b2ca51546354"}, "originalPosition": 14}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Njc3NTA0MQ==", "bodyText": "I'd rather have a consistent API i.e. either everything with with methods or with OperationContext, not a mix of both.", "url": "https://github.com/fabric8io/kubernetes-client/pull/2667#discussion_r546775041", "createdAt": "2020-12-21T15:38:54Z", "author": {"login": "metacosm"}, "path": "doc/CHEATSHEET.md", "diffHunk": "@@ -2065,9 +2065,8 @@ dummyInformer.addEventHandler(new ResourceEventHandler<Dummy>() {\n - Create namespaced `SharedIndexInformer` (informers specific to a particular `Namespace`):\n ```java\n SharedInformerFactory sharedInformerFactory = client.informers();\n-SharedIndexInformer<Pod> podInformer = sharedInformerFactory.sharedIndexInformerFor(\n+SharedIndexInformer<Pod> podInformer = sharedInformerFactory.inNamespace(\"default\").sharedIndexInformerFor(", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjU5NzE4NQ=="}, "originalCommit": {"oid": "39bf5f195197396cf565b52af734b2ca51546354"}, "originalPosition": 14}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3646, "cost": 1, "resetAt": "2021-11-12T18:49:56Z"}}}