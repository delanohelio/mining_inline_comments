{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDIzNDU0MzA5", "number": 4057, "title": "PLFM-5753 - Add DAO for OAuth2 Refresh Tokens", "bodyText": "", "createdAt": "2020-05-26T20:45:45Z", "url": "https://github.com/Sage-Bionetworks/Synapse-Repository-Services/pull/4057", "merged": true, "mergeCommit": {"oid": "e32db7c24ec592270b4b7e57f31b836d372462a2"}, "closed": true, "closedAt": "2020-06-03T20:47:55Z", "author": {"login": "nickgros"}, "timelineItems": {"totalCount": 16, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABclNIdQgH2gAyNDIzNDU0MzA5OmY3YWEwMDYxOTY3MDRmOWJjMWMzZTBkZGM1Mzc0ZDMzMDMyMjA1MWY=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcnvwpSAFqTQyMzkxNzMwMA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "f7aa006196704f9bc1c3e0ddc5374d330322051f", "author": {"user": {"login": "nickgros", "name": "Nick Grosenbacher"}}, "url": "https://github.com/Sage-Bionetworks/Synapse-Repository-Services/commit/f7aa006196704f9bc1c3e0ddc5374d330322051f", "committedDate": "2020-05-26T23:19:17Z", "message": "Add DAO for OAuth2 Refresh Tokens"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "576306ea928ece8a779d353fff3d5e180dbe910f", "author": {"user": {"login": "nickgros", "name": "Nick Grosenbacher"}}, "url": "https://github.com/Sage-Bionetworks/Synapse-Repository-Services/commit/576306ea928ece8a779d353fff3d5e180dbe910f", "committedDate": "2020-05-26T20:44:59Z", "message": "Add DAO for OAuth2 Refresh Tokens"}, "afterCommit": {"oid": "f7aa006196704f9bc1c3e0ddc5374d330322051f", "author": {"user": {"login": "nickgros", "name": "Nick Grosenbacher"}}, "url": "https://github.com/Sage-Bionetworks/Synapse-Repository-Services/commit/f7aa006196704f9bc1c3e0ddc5374d330322051f", "committedDate": "2020-05-26T23:19:17Z", "message": "Add DAO for OAuth2 Refresh Tokens"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d0c285091eb2437534f1e283fdcac231d925ec9f", "author": {"user": {"login": "nickgros", "name": "Nick Grosenbacher"}}, "url": "https://github.com/Sage-Bionetworks/Synapse-Repository-Services/commit/d0c285091eb2437534f1e283fdcac231d925ec9f", "committedDate": "2020-05-28T17:51:56Z", "message": "Separate Refresh Token DAO methods for updating metadata/hash. Select refresh token record for update when retrieving by hash in order to handle conflicting updates upon rotating refresh tokens."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIwMzg4ODA1", "url": "https://github.com/Sage-Bionetworks/Synapse-Repository-Services/pull/4057#pullrequestreview-420388805", "createdAt": "2020-05-28T18:40:53Z", "commit": {"oid": "f7aa006196704f9bc1c3e0ddc5374d330322051f"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOFQxODo0MDo1M1rOGcB3CQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOFQxODo0MDo1M1rOGcB3CQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjA0Mzc4NQ==", "bodyText": "\"the oldest timestamp for an active resource token for the given client and user.\"", "url": "https://github.com/Sage-Bionetworks/Synapse-Repository-Services/pull/4057#discussion_r432043785", "createdAt": "2020-05-28T18:40:53Z", "author": {"login": "brucehoff"}, "path": "lib/lib-auto-generated/src/main/resources/schema/org/sagebionetworks/repo/model/oauth/OAuthClientAuthorization.json", "diffHunk": "@@ -0,0 +1,25 @@\n+{\n+    \"description\": \"An object representing an OAuth 2.0 client that has been authorized to request a user's resources and identity\",\n+ \t\"properties\": {\n+\t\t\"client\": {\n+\t\t\t\"$ref\": \"org.sagebionetworks.repo.model.oauth.OAuthClient\",\n+\t\t\t\"description\": \"The OAuth 2.0 client that has been granted access\",\n+\t\t\t\"links\": [\n+\t\t\t\t{\n+\t\t\t\t\t\"rel\": \"describedby\",\n+\t\t\t\t\t\"href\": \"http://synapse.sagebase.org/access/public\"\n+\t\t\t\t}\n+\t\t\t]\n+\t\t},\n+\t\t\"authorizedOn\": {\n+\t\t\t\"type\": \"string\",\n+\t\t\t\"format\": \"date-time\",\n+\t\t\t\"description\": \"The date that authorization was granted to the OAuth client.\"", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f7aa006196704f9bc1c3e0ddc5374d330322051f"}, "originalPosition": 17}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIwMzkxMDc1", "url": "https://github.com/Sage-Bionetworks/Synapse-Repository-Services/pull/4057#pullrequestreview-420391075", "createdAt": "2020-05-28T18:44:09Z", "commit": {"oid": "f7aa006196704f9bc1c3e0ddc5374d330322051f"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOFQxODo0NDowOVrOGcB-Jg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOFQxODo0NDowOVrOGcB-Jg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjA0NTYwNg==", "bodyText": "can you think of a name that differentiates from the existing \"OAuthAuthorizationResponse\" class, e.g. \"OAuthClientAuthorizationRecord\", \"OAuthClientAuthorizationHistory\"", "url": "https://github.com/Sage-Bionetworks/Synapse-Repository-Services/pull/4057#discussion_r432045606", "createdAt": "2020-05-28T18:44:09Z", "author": {"login": "brucehoff"}, "path": "lib/lib-auto-generated/src/main/resources/schema/org/sagebionetworks/repo/model/oauth/OAuthClientAuthorization.json", "diffHunk": "@@ -0,0 +1,25 @@\n+{", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f7aa006196704f9bc1c3e0ddc5374d330322051f"}, "originalPosition": 1}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIwMzk5NDE1", "url": "https://github.com/Sage-Bionetworks/Synapse-Repository-Services/pull/4057#pullrequestreview-420399415", "createdAt": "2020-05-28T18:55:34Z", "commit": {"oid": "f7aa006196704f9bc1c3e0ddc5374d330322051f"}, "state": "COMMENTED", "comments": {"totalCount": 9, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOFQxODo1NTozNFrOGcCW6Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOFQxOTo1NjoxNVrOGcEd-g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjA1MTk0NQ==", "bodyText": "consider \"getAuthorizedClientHistory\", or something to indicate that it's more than just a list of OAuthClients.", "url": "https://github.com/Sage-Bionetworks/Synapse-Repository-Services/pull/4057#discussion_r432051945", "createdAt": "2020-05-28T18:55:34Z", "author": {"login": "brucehoff"}, "path": "lib/models/src/main/java/org/sagebionetworks/repo/model/auth/OAuthClientDao.java", "diffHunk": "@@ -115,6 +116,15 @@\n \t * @throws NotFoundException If a client with the given id does not exist\n \t */\n \tboolean isOauthClientVerified(String clientId) throws NotFoundException;\n-\t\n-\t\n+\n+\t/**\n+\t * Retrieve all clients that a specified user has granted long-lived access to via OAuth refresh tokens.\n+\t * Does not include clients where access has expired.\n+\t * @param userId The user who has delegated access to clients via OAuth 2 refresh tokens\n+\t * @param nextPageToken For pagination\n+\t * @param maxLeaseLengthInDays Clients who have not used a refresh token in this many days will not be retrieved.\n+\t *                               Semantically, this should be maximum lease length of a refresh token\n+\t * @return a paginated list of clients with OAuth 2 access to a user's resources\n+\t */\n+\tOAuthClientAuthorizationList getAuthorizedClients(String userId, String nextPageToken, Long maxLeaseLengthInDays);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f7aa006196704f9bc1c3e0ddc5374d330322051f"}, "originalPosition": 24}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjA1MjM0Mg==", "bodyText": "has expired or has been revoked.", "url": "https://github.com/Sage-Bionetworks/Synapse-Repository-Services/pull/4057#discussion_r432052342", "createdAt": "2020-05-28T18:56:16Z", "author": {"login": "brucehoff"}, "path": "lib/models/src/main/java/org/sagebionetworks/repo/model/auth/OAuthClientDao.java", "diffHunk": "@@ -115,6 +116,15 @@\n \t * @throws NotFoundException If a client with the given id does not exist\n \t */\n \tboolean isOauthClientVerified(String clientId) throws NotFoundException;\n-\t\n-\t\n+\n+\t/**\n+\t * Retrieve all clients that a specified user has granted long-lived access to via OAuth refresh tokens.\n+\t * Does not include clients where access has expired.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f7aa006196704f9bc1c3e0ddc5374d330322051f"}, "originalPosition": 17}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjA1NjczMA==", "bodyText": "@param maxLeaseLengthInDays  maximum lease length of a refresh token.  Clients having no refresh token which has been used after this time window are omitted from the results.", "url": "https://github.com/Sage-Bionetworks/Synapse-Repository-Services/pull/4057#discussion_r432056730", "createdAt": "2020-05-28T19:04:08Z", "author": {"login": "brucehoff"}, "path": "lib/models/src/main/java/org/sagebionetworks/repo/model/auth/OAuthClientDao.java", "diffHunk": "@@ -115,6 +116,15 @@\n \t * @throws NotFoundException If a client with the given id does not exist\n \t */\n \tboolean isOauthClientVerified(String clientId) throws NotFoundException;\n-\t\n-\t\n+\n+\t/**\n+\t * Retrieve all clients that a specified user has granted long-lived access to via OAuth refresh tokens.\n+\t * Does not include clients where access has expired.\n+\t * @param userId The user who has delegated access to clients via OAuth 2 refresh tokens\n+\t * @param nextPageToken For pagination\n+\t * @param maxLeaseLengthInDays Clients who have not used a refresh token in this many days will not be retrieved.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f7aa006196704f9bc1c3e0ddc5374d330322051f"}, "originalPosition": 20}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjA1Nzg5Mg==", "bodyText": "a paginated list of clients which have been granted refresh token(s) for the given user.", "url": "https://github.com/Sage-Bionetworks/Synapse-Repository-Services/pull/4057#discussion_r432057892", "createdAt": "2020-05-28T19:06:14Z", "author": {"login": "brucehoff"}, "path": "lib/models/src/main/java/org/sagebionetworks/repo/model/auth/OAuthClientDao.java", "diffHunk": "@@ -115,6 +116,15 @@\n \t * @throws NotFoundException If a client with the given id does not exist\n \t */\n \tboolean isOauthClientVerified(String clientId) throws NotFoundException;\n-\t\n-\t\n+\n+\t/**\n+\t * Retrieve all clients that a specified user has granted long-lived access to via OAuth refresh tokens.\n+\t * Does not include clients where access has expired.\n+\t * @param userId The user who has delegated access to clients via OAuth 2 refresh tokens\n+\t * @param nextPageToken For pagination\n+\t * @param maxLeaseLengthInDays Clients who have not used a refresh token in this many days will not be retrieved.\n+\t *                               Semantically, this should be maximum lease length of a refresh token\n+\t * @return a paginated list of clients with OAuth 2 access to a user's resources", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f7aa006196704f9bc1c3e0ddc5374d330322051f"}, "originalPosition": 22}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjA2MDY2MQ==", "bodyText": "store claims too.  The claims will be a map whose keys are OIDCClaimName and whose values are OIDCClaimsRequestDetails.", "url": "https://github.com/Sage-Bionetworks/Synapse-Repository-Services/pull/4057#discussion_r432060661", "createdAt": "2020-05-28T19:11:31Z", "author": {"login": "brucehoff"}, "path": "lib/lib-auto-generated/src/main/resources/schema/org/sagebionetworks/repo/model/oauth/OAuthRefreshTokenInformation.json", "diffHunk": "@@ -0,0 +1,71 @@\n+{\n+    \"description\": \"OAuth 2.0 refresh token metadata. Note that the token itself may not be retrieved after it is issued to a client.\",\n+ \t\"properties\": {\n+\t\t\"tokenId\": {\n+\t\t\t\"type\": \"string\",\n+\t\t\t\"description\": \"The unique ID for this refresh token.\",\n+\t\t\t\"links\": [\n+\t\t\t\t{\n+\t\t\t\t\t\"rel\": \"describedby\",\n+\t\t\t\t\t\"href\": \"http://synapse.sagebase.org/access/public\"\n+\t\t\t\t}\n+\t\t\t]\n+\t\t},\n+\t\t\"clientId\": {\n+\t\t\t\"type\": \"string\",\n+\t\t\t\"description\": \"The unique ID for the OAuth client that may utilize this token.\",\n+\t\t\t\"links\": [\n+\t\t\t\t{\n+\t\t\t\t\t\"rel\": \"describedby\",\n+\t\t\t\t\t\"href\": \"http://synapse.sagebase.org/access/public\"\n+\t\t\t\t}\n+\t\t\t]\n+\t\t},\n+\t\t\"principalId\": {\n+\t\t\t\"type\": \"string\",\n+\t\t\t\"description\": \"The unique ID for the user whose resources can be accessed with this token.\",\n+\t\t\t\"links\": [\n+\t\t\t\t{\n+\t\t\t\t\t\"rel\": \"describedby\",\n+\t\t\t\t\t\"href\": \"http://synapse.sagebase.org/access/public\"\n+\t\t\t\t}\n+\t\t\t]\n+\t\t},\n+\t\t\"name\":{\n+\t\t\t\"type\": \"string\",\n+\t\t\t\"description\":\"A human-readable identifier for the token.\",\n+\t\t\t\"links\": [\n+\t\t\t\t{\n+\t\t\t\t\t\"rel\": \"describedby\",\n+\t\t\t\t\t\"href\": \"http://synapse.sagebase.org/access/public\"\n+\t\t\t\t}\n+\t\t\t]\n+\t\t},\n+\t\t\"scopes\": {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f7aa006196704f9bc1c3e0ddc5374d330322051f"}, "originalPosition": 44}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjA3MTgzOQ==", "bodyText": "claims too.  I suggest you use byte[] and our JDOSecondaryPropertyUtils.compressObject(), decompressObject() utilities to convert back and forth to POJOs.", "url": "https://github.com/Sage-Bionetworks/Synapse-Repository-Services/pull/4057#discussion_r432071839", "createdAt": "2020-05-28T19:33:17Z", "author": {"login": "brucehoff"}, "path": "lib/jdomodels/src/main/java/org/sagebionetworks/repo/model/dbo/persistence/DBOOAuthRefreshToken.java", "diffHunk": "@@ -0,0 +1,330 @@\n+package org.sagebionetworks.repo.model.dbo.persistence;\n+\n+import static org.sagebionetworks.repo.model.query.jdo.SqlConstants.COL_OAUTH_CLIENT_NAME;\n+import static org.sagebionetworks.repo.model.query.jdo.SqlConstants.COL_OAUTH_REFRESH_TOKEN_CLIENT_ID;\n+import static org.sagebionetworks.repo.model.query.jdo.SqlConstants.COL_OAUTH_REFRESH_TOKEN_CREATED_ON;\n+import static org.sagebionetworks.repo.model.query.jdo.SqlConstants.COL_OAUTH_REFRESH_TOKEN_ETAG;\n+import static org.sagebionetworks.repo.model.query.jdo.SqlConstants.COL_OAUTH_REFRESH_TOKEN_HASH;\n+import static org.sagebionetworks.repo.model.query.jdo.SqlConstants.COL_OAUTH_REFRESH_TOKEN_ID;\n+import static org.sagebionetworks.repo.model.query.jdo.SqlConstants.COL_OAUTH_REFRESH_TOKEN_LAST_USED;\n+import static org.sagebionetworks.repo.model.query.jdo.SqlConstants.COL_OAUTH_REFRESH_TOKEN_MODIFIED_ON;\n+import static org.sagebionetworks.repo.model.query.jdo.SqlConstants.COL_OAUTH_REFRESH_TOKEN_NAME;\n+import static org.sagebionetworks.repo.model.query.jdo.SqlConstants.COL_OAUTH_REFRESH_TOKEN_PRINCIPAL_ID;\n+import static org.sagebionetworks.repo.model.query.jdo.SqlConstants.COL_OAUTH_REFRESH_TOKEN_SCOPE;\n+import static org.sagebionetworks.repo.model.query.jdo.SqlConstants.DDL_OAUTH_REFRESH_TOKEN;\n+import static org.sagebionetworks.repo.model.query.jdo.SqlConstants.TABLE_OAUTH_REFRESH_TOKEN;\n+\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.sql.Timestamp;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.StringJoiner;\n+\n+import org.apache.commons.lang3.StringUtils;\n+import org.sagebionetworks.repo.model.dbo.FieldColumn;\n+import org.sagebionetworks.repo.model.dbo.MigratableDatabaseObject;\n+import org.sagebionetworks.repo.model.dbo.TableMapping;\n+import org.sagebionetworks.repo.model.dbo.migration.BasicMigratableTableTranslation;\n+import org.sagebionetworks.repo.model.dbo.migration.MigratableTableTranslation;\n+import org.sagebionetworks.repo.model.migration.MigrationType;\n+import org.sagebionetworks.repo.model.oauth.OAuthScope;\n+\n+/**\n+ * Database object representing an OAuth 2.0 refresh token\n+ */\n+public class DBOOAuthRefreshToken implements MigratableDatabaseObject<DBOOAuthRefreshToken, DBOOAuthRefreshToken> {\n+\tprivate Long id;\n+\tprivate String tokenHash;\n+\tprivate String name;\n+\tprivate Long principalId;\n+\tprivate Long clientId;\n+\tprivate String scopes;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f7aa006196704f9bc1c3e0ddc5374d330322051f"}, "originalPosition": 42}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjA3NzU5NA==", "bodyText": "suggest you simply pass byte[] in and out of this class", "url": "https://github.com/Sage-Bionetworks/Synapse-Repository-Services/pull/4057#discussion_r432077594", "createdAt": "2020-05-28T19:44:52Z", "author": {"login": "brucehoff"}, "path": "lib/jdomodels/src/main/java/org/sagebionetworks/repo/model/dbo/persistence/DBOOAuthRefreshToken.java", "diffHunk": "@@ -0,0 +1,330 @@\n+package org.sagebionetworks.repo.model.dbo.persistence;\n+\n+import static org.sagebionetworks.repo.model.query.jdo.SqlConstants.COL_OAUTH_CLIENT_NAME;\n+import static org.sagebionetworks.repo.model.query.jdo.SqlConstants.COL_OAUTH_REFRESH_TOKEN_CLIENT_ID;\n+import static org.sagebionetworks.repo.model.query.jdo.SqlConstants.COL_OAUTH_REFRESH_TOKEN_CREATED_ON;\n+import static org.sagebionetworks.repo.model.query.jdo.SqlConstants.COL_OAUTH_REFRESH_TOKEN_ETAG;\n+import static org.sagebionetworks.repo.model.query.jdo.SqlConstants.COL_OAUTH_REFRESH_TOKEN_HASH;\n+import static org.sagebionetworks.repo.model.query.jdo.SqlConstants.COL_OAUTH_REFRESH_TOKEN_ID;\n+import static org.sagebionetworks.repo.model.query.jdo.SqlConstants.COL_OAUTH_REFRESH_TOKEN_LAST_USED;\n+import static org.sagebionetworks.repo.model.query.jdo.SqlConstants.COL_OAUTH_REFRESH_TOKEN_MODIFIED_ON;\n+import static org.sagebionetworks.repo.model.query.jdo.SqlConstants.COL_OAUTH_REFRESH_TOKEN_NAME;\n+import static org.sagebionetworks.repo.model.query.jdo.SqlConstants.COL_OAUTH_REFRESH_TOKEN_PRINCIPAL_ID;\n+import static org.sagebionetworks.repo.model.query.jdo.SqlConstants.COL_OAUTH_REFRESH_TOKEN_SCOPE;\n+import static org.sagebionetworks.repo.model.query.jdo.SqlConstants.DDL_OAUTH_REFRESH_TOKEN;\n+import static org.sagebionetworks.repo.model.query.jdo.SqlConstants.TABLE_OAUTH_REFRESH_TOKEN;\n+\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.sql.Timestamp;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.StringJoiner;\n+\n+import org.apache.commons.lang3.StringUtils;\n+import org.sagebionetworks.repo.model.dbo.FieldColumn;\n+import org.sagebionetworks.repo.model.dbo.MigratableDatabaseObject;\n+import org.sagebionetworks.repo.model.dbo.TableMapping;\n+import org.sagebionetworks.repo.model.dbo.migration.BasicMigratableTableTranslation;\n+import org.sagebionetworks.repo.model.dbo.migration.MigratableTableTranslation;\n+import org.sagebionetworks.repo.model.migration.MigrationType;\n+import org.sagebionetworks.repo.model.oauth.OAuthScope;\n+\n+/**\n+ * Database object representing an OAuth 2.0 refresh token\n+ */\n+public class DBOOAuthRefreshToken implements MigratableDatabaseObject<DBOOAuthRefreshToken, DBOOAuthRefreshToken> {\n+\tprivate Long id;\n+\tprivate String tokenHash;\n+\tprivate String name;\n+\tprivate Long principalId;\n+\tprivate Long clientId;\n+\tprivate String scopes;\n+\tprivate Timestamp createdOn;\n+\tprivate Timestamp modifiedOn;\n+\tprivate Timestamp lastUsed;\n+\tprivate String etag;\n+\n+\tprivate static FieldColumn[] FIELDS = new FieldColumn[] {\n+\t\tnew FieldColumn(\"id\", COL_OAUTH_REFRESH_TOKEN_ID, true).withIsBackupId(true),\n+\t\t\tnew FieldColumn(\"tokenHash\", COL_OAUTH_REFRESH_TOKEN_HASH),\n+\t\t\tnew FieldColumn(\"name\", COL_OAUTH_REFRESH_TOKEN_NAME),\n+\t\t\tnew FieldColumn(\"principalId\", COL_OAUTH_REFRESH_TOKEN_PRINCIPAL_ID),\n+\t\t\tnew FieldColumn(\"clientId\", COL_OAUTH_REFRESH_TOKEN_CLIENT_ID),\n+\t\t\tnew FieldColumn(\"scopes\", COL_OAUTH_REFRESH_TOKEN_SCOPE),\n+\t\t\tnew FieldColumn(\"createdOn\", COL_OAUTH_REFRESH_TOKEN_CREATED_ON),\n+\t\t\tnew FieldColumn(\"modifiedOn\", COL_OAUTH_REFRESH_TOKEN_MODIFIED_ON),\n+\t\t\tnew FieldColumn(\"lastUsed\", COL_OAUTH_REFRESH_TOKEN_LAST_USED),\n+\t\t\tnew FieldColumn(\"etag\", COL_OAUTH_REFRESH_TOKEN_ETAG).withIsEtag(true),\n+\t\t};\n+\n+\t@Override\n+\tpublic TableMapping<DBOOAuthRefreshToken> getTableMapping() {\n+\t\treturn new TableMapping<DBOOAuthRefreshToken>() {\n+\t\t\t// Map a result set to this object\n+\t\t\t@Override\n+\t\t\tpublic DBOOAuthRefreshToken mapRow(ResultSet rs, int rowNum) throws SQLException {\n+\t\t\t\tDBOOAuthRefreshToken token = new DBOOAuthRefreshToken();\n+\t\t\t\ttoken.setId(rs.getLong(COL_OAUTH_REFRESH_TOKEN_ID));\n+\t\t\t\ttoken.setTokenHash(rs.getString(COL_OAUTH_REFRESH_TOKEN_HASH));\n+\t\t\t\ttoken.setName(rs.getString(COL_OAUTH_CLIENT_NAME));\n+\t\t\t\ttoken.setPrincipalId(rs.getLong(COL_OAUTH_REFRESH_TOKEN_PRINCIPAL_ID));\n+\t\t\t\ttoken.setClientId(rs.getLong(COL_OAUTH_REFRESH_TOKEN_CLIENT_ID));\n+\t\t\t\ttoken.setScopes(rs.getString(COL_OAUTH_REFRESH_TOKEN_SCOPE));\n+\t\t\t\ttoken.setCreatedOn(rs.getTimestamp(COL_OAUTH_REFRESH_TOKEN_CREATED_ON));\n+\t\t\t\ttoken.setModifiedOn(rs.getTimestamp(COL_OAUTH_REFRESH_TOKEN_MODIFIED_ON));\n+\t\t\t\ttoken.setLastUsed(rs.getTimestamp(COL_OAUTH_REFRESH_TOKEN_LAST_USED));\n+\t\t\t\ttoken.setEtag(rs.getString(COL_OAUTH_REFRESH_TOKEN_ETAG));\n+\t\t\t\treturn token;\n+\t\t\t}\n+\n+\t\t\t@Override\n+\t\t\tpublic String getTableName() {\n+\t\t\t\treturn TABLE_OAUTH_REFRESH_TOKEN;\n+\t\t\t}\n+\n+\t\t\t@Override\n+\t\t\tpublic String getDDLFileName() {\n+\t\t\t\treturn DDL_OAUTH_REFRESH_TOKEN;\n+\t\t\t}\n+\n+\t\t\t@Override\n+\t\t\tpublic FieldColumn[] getFieldColumns() {\n+\t\t\t\treturn FIELDS;\n+\t\t\t}\n+\n+\t\t\t@Override\n+\t\t\tpublic Class<? extends DBOOAuthRefreshToken> getDBOClass() {\n+\t\t\t\treturn DBOOAuthRefreshToken.class;\n+\t\t\t}\n+\t\t};\n+\t}\n+\n+\n+\tpublic Long getId() {\n+\t\treturn id;\n+\t}\n+\n+\tpublic void setId(Long id) {\n+\t\tthis.id = id;\n+\t}\n+\n+\tpublic String getName() {\n+\t\treturn name;\n+\t}\n+\n+\tpublic String getTokenHash() {\n+\t\treturn tokenHash;\n+\t}\n+\n+\tpublic void setTokenHash(String tokenHash) {\n+\t\tthis.tokenHash = tokenHash;\n+\t}\n+\n+\tpublic Long getPrincipalId() {\n+\t\treturn principalId;\n+\t}\n+\n+\tpublic void setPrincipalId(Long principalId) {\n+\t\tthis.principalId = principalId;\n+\t}\n+\n+\tpublic Long getClientId() {\n+\t\treturn clientId;\n+\t}\n+\n+\tpublic void setClientId(Long clientId) {\n+\t\tthis.clientId = clientId;\n+\t}\n+\n+\t/**\n+\t * Returns scopes as a CSV. Needed to properly map the object to the relation.\n+\t * To get a list see {@link #getScopesAsList()}\n+\t * @return\n+\t */\n+\tpublic String getScopes() {\n+\t\treturn this.scopes;\n+\t}\n+\n+\tpublic List<OAuthScope> getScopesAsList() {\n+\t\tString[] scopesAsString = StringUtils.split(this.scopes, ',');", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f7aa006196704f9bc1c3e0ddc5374d330322051f"}, "originalPosition": 150}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjA4MDUzMw==", "bodyText": "if you are using a 256 bit digest, I think CHAR(32) is sufficient", "url": "https://github.com/Sage-Bionetworks/Synapse-Repository-Services/pull/4057#discussion_r432080533", "createdAt": "2020-05-28T19:48:39Z", "author": {"login": "brucehoff"}, "path": "lib/jdomodels/src/main/resources/schema/OAuthRefreshToken-ddl.sql", "diffHunk": "@@ -0,0 +1,16 @@\n+CREATE TABLE IF NOT EXISTS `OAUTH_REFRESH_TOKEN` (\n+  `ID` BIGINT NOT NULL,\n+  `TOKEN_HASH` CHAR(64) NOT NULL,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f7aa006196704f9bc1c3e0ddc5374d330322051f"}, "originalPosition": 3}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjA4NjUyMg==", "bodyText": "scope and claims will be mediumblob.", "url": "https://github.com/Sage-Bionetworks/Synapse-Repository-Services/pull/4057#discussion_r432086522", "createdAt": "2020-05-28T19:56:15Z", "author": {"login": "brucehoff"}, "path": "lib/jdomodels/src/main/resources/schema/OAuthRefreshToken-ddl.sql", "diffHunk": "@@ -0,0 +1,16 @@\n+CREATE TABLE IF NOT EXISTS `OAUTH_REFRESH_TOKEN` (\n+  `ID` BIGINT NOT NULL,\n+  `TOKEN_HASH` CHAR(64) NOT NULL,\n+  `NAME` VARCHAR(256) NOT NULL,\n+  `PRINCIPAL_ID` BIGINT NOT NULL,\n+  `CLIENT_ID` BIGINT NOT NULL,\n+  `SCOPE` VARCHAR(256) NOT NULL,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f7aa006196704f9bc1c3e0ddc5374d330322051f"}, "originalPosition": 7}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0fdda945f1df291cebcb494f49b48bbcba6c7862", "author": {"user": {"login": "nickgros", "name": "Nick Grosenbacher"}}, "url": "https://github.com/Sage-Bionetworks/Synapse-Repository-Services/commit/0fdda945f1df291cebcb494f49b48bbcba6c7862", "committedDate": "2020-05-29T13:26:14Z", "message": "Code review changes"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "cb1e7d70f4e91f45532e784a6a81ce2e2439b303", "author": {"user": {"login": "nickgros", "name": "Nick Grosenbacher"}}, "url": "https://github.com/Sage-Bionetworks/Synapse-Repository-Services/commit/cb1e7d70f4e91f45532e784a6a81ce2e2439b303", "committedDate": "2020-05-29T14:48:26Z", "message": "Fix tests, serialize scope and claims individually"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "04bb317239689c610f736ff18e1803ab1b14d44f", "author": {"user": {"login": "nickgros", "name": "Nick Grosenbacher"}}, "url": "https://github.com/Sage-Bionetworks/Synapse-Repository-Services/commit/04bb317239689c610f736ff18e1803ab1b14d44f", "committedDate": "2020-05-29T15:54:32Z", "message": "Merge pull request #1 from nickgros/PLFM-5753.1"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "20361cef4a6829ee93e7b4e9dbfd70c64b829380", "author": {"user": {"login": "nickgros", "name": "Nick Grosenbacher"}}, "url": "https://github.com/Sage-Bionetworks/Synapse-Repository-Services/commit/20361cef4a6829ee93e7b4e9dbfd70c64b829380", "committedDate": "2020-06-01T16:33:42Z", "message": "Test summary dates and pagination"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d2ca97b3b3ce7d309e967a44bb438154380a99ff", "author": {"user": {"login": "nickgros", "name": "Nick Grosenbacher"}}, "url": "https://github.com/Sage-Bionetworks/Synapse-Repository-Services/commit/d2ca97b3b3ce7d309e967a44bb438154380a99ff", "committedDate": "2020-06-01T16:40:05Z", "message": "Test pagination in OAuthRefreshTokenDao autowired test"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "bd558fd726cf88547bf5fe77053ecca833639788", "author": {"user": {"login": "nickgros", "name": "Nick Grosenbacher"}}, "url": "https://github.com/Sage-Bionetworks/Synapse-Repository-Services/commit/bd558fd726cf88547bf5fe77053ecca833639788", "committedDate": "2020-06-01T17:30:17Z", "message": "Merge pull request #2 from nickgros/PLFM-5753.1"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "723d76a31eea631b3277cd5b5f6b674b6960b139", "author": {"user": {"login": "nickgros", "name": "Nick Grosenbacher"}}, "url": "https://github.com/Sage-Bionetworks/Synapse-Repository-Services/commit/723d76a31eea631b3277cd5b5f6b674b6960b139", "committedDate": "2020-06-02T21:40:00Z", "message": "Code review changes + a new object to store OIDC claims"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e4a95ff405a34d424f05079f6eb9d9aecc8adcef", "author": {"user": {"login": "nickgros", "name": "Nick Grosenbacher"}}, "url": "https://github.com/Sage-Bionetworks/Synapse-Repository-Services/commit/e4a95ff405a34d424f05079f6eb9d9aecc8adcef", "committedDate": "2020-06-02T21:41:21Z", "message": "Merge pull request #3 from nickgros/PLFM-5753.1\n\nCode review changes + a new object to store OIDC claims"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIxMTY4MTkw", "url": "https://github.com/Sage-Bionetworks/Synapse-Repository-Services/pull/4057#pullrequestreview-421168190", "createdAt": "2020-05-29T17:55:31Z", "commit": {"oid": "04bb317239689c610f736ff18e1803ab1b14d44f"}, "state": "COMMENTED", "comments": {"totalCount": 17, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOVQxNzo1NTozMVrOGcmrYA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wM1QyMDozMzo0NFrOGesWNw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjY0NzAwOA==", "bodyText": "rt. COL_OAUTH_REFRESH_TOKEN_CLIENT_ID is redundant", "url": "https://github.com/Sage-Bionetworks/Synapse-Repository-Services/pull/4057#discussion_r432647008", "createdAt": "2020-05-29T17:55:31Z", "author": {"login": "brucehoff"}, "path": "lib/jdomodels/src/main/java/org/sagebionetworks/repo/model/dbo/auth/OAuthClientDaoImpl.java", "diffHunk": "@@ -75,7 +86,21 @@\n \tprivate static final String CLIENT_VERIFIED_SQL_SELECT = \"SELECT \" + COL_OAUTH_CLIENT_IS_VERIFIED +\n \t\t\t\" FROM \" + TABLE_OAUTH_CLIENT\n \t\t\t+ \" WHERE \" + COL_OAUTH_CLIENT_ID + \" = ?\";\n-\t\n+\n+\tprivate static final String SELECT_CLIENTS_WITH_ACTIVE_TOKENS_FOR_PRINCIPAL =\n+\t\t\t\"SELECT rt.\" + COL_OAUTH_REFRESH_TOKEN_CLIENT_ID + \", \"", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "04bb317239689c610f736ff18e1803ab1b14d44f"}, "originalPosition": 45}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjY1MjEyOA==", "bodyText": "make authorizedOn a param' of createRefreshToken", "url": "https://github.com/Sage-Bionetworks/Synapse-Repository-Services/pull/4057#discussion_r432652128", "createdAt": "2020-05-29T18:06:06Z", "author": {"login": "brucehoff"}, "path": "lib/jdomodels/src/test/java/org/sagebionetworks/repo/model/dbo/auth/OAuthClientDaoImplTest.java", "diffHunk": "@@ -476,4 +494,54 @@ public void testIsOauthClientVerified() throws Exception {\n \t\t\n \t}\n \n+\tprivate OAuthRefreshTokenInformation createRefreshToken(String clientId, String userId, Date lastUsedDate) {\n+\t\tOAuthRefreshTokenInformation token = new OAuthRefreshTokenInformation();\n+\t\ttoken.setName(UUID.randomUUID().toString());\n+\t\ttoken.setClientId(clientId);\n+\t\ttoken.setPrincipalId(userId);\n+\t\ttoken.setScopes(Collections.singletonList(OAuthScope.view));\n+\t\ttoken.setClaims(Collections.singletonMap(OIDCClaimName.email.name(), new OIDCClaimsRequestDetails()));\n+\t\ttoken.setAuthorizedOn(new Date());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "04bb317239689c610f736ff18e1803ab1b14d44f"}, "originalPosition": 75}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjY1NDE2OA==", "bodyText": "while this is fine you might also look at classes that autowire Clock and then mock it in tests to allow precise dates.", "url": "https://github.com/Sage-Bionetworks/Synapse-Repository-Services/pull/4057#discussion_r432654168", "createdAt": "2020-05-29T18:10:32Z", "author": {"login": "brucehoff"}, "path": "lib/jdomodels/src/test/java/org/sagebionetworks/repo/model/dbo/auth/OAuthClientDaoImplTest.java", "diffHunk": "@@ -476,4 +494,54 @@ public void testIsOauthClientVerified() throws Exception {\n \t\t\n \t}\n \n+\tprivate OAuthRefreshTokenInformation createRefreshToken(String clientId, String userId, Date lastUsedDate) {\n+\t\tOAuthRefreshTokenInformation token = new OAuthRefreshTokenInformation();\n+\t\ttoken.setName(UUID.randomUUID().toString());\n+\t\ttoken.setClientId(clientId);\n+\t\ttoken.setPrincipalId(userId);\n+\t\ttoken.setScopes(Collections.singletonList(OAuthScope.view));\n+\t\ttoken.setClaims(Collections.singletonMap(OIDCClaimName.email.name(), new OIDCClaimsRequestDetails()));\n+\t\ttoken.setAuthorizedOn(new Date());\n+\t\ttoken.setLastUsed(lastUsedDate);\n+\t\ttoken.setModifiedOn(new Date());\n+\t\ttoken.setEtag(UUID.randomUUID().toString());\n+\t\treturn oauthRefreshTokenDao.createRefreshToken(\"abcdef\", token);\n+\t}\n+\n+\t@Test\n+\tpublic void testGetAuthorizedClients() {\n+\t\tLong userId = BOOTSTRAP_PRINCIPAL.THE_ADMIN_USER.getPrincipalId();\n+\n+\t\tString client1 = createSectorIdentifierAndClient();\n+\t\tString client2 = createSectorIdentifierAndClient(SECOND_SECTOR_IDENTIFIER, userId, \"App 2\");\n+\n+\t\t// Valid token for client 1\n+\t\tOAuthRefreshTokenInformation token1 = createRefreshToken(client1, userId.toString(), new Date());\n+\t\t// Expired token for client 1\n+\t\tOAuthRefreshTokenInformation token2 = createRefreshToken(client1, userId.toString(), new Date(System.currentTimeMillis() - TWO_YEARS_MILLIS));\n+\t\t// Expired token for client 2\n+\t\tOAuthRefreshTokenInformation token3 = createRefreshToken(client2, userId.toString(), new Date(System.currentTimeMillis() - TWO_YEARS_MILLIS));\n+\n+\n+\t\t// Call under test\n+\t\tOAuthClientAuthorizationHistoryList results = oauthClientDao.getAuthorizedClientHistory(userId.toString(), null, 365L);\n+\n+\t\tlong FIVE_MINUTES_AGO = System.currentTimeMillis() - FIVE_MINUTES_MILLIS;\n+\t\t// We should only get back client 1, because no active tokens exist for client 2\n+\t\tassertEquals(1, results.getResults().size());\n+\t\tassertEquals( client1,results.getResults().get(0).getClient().getClient_id());\n+\t\tassertTrue(FIVE_MINUTES_AGO < results.getResults().get(0).getAuthorizedOn().getTime());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "04bb317239689c610f736ff18e1803ab1b14d44f"}, "originalPosition": 104}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzM4NTYzNQ==", "bodyText": "change upper case to camelcase, please", "url": "https://github.com/Sage-Bionetworks/Synapse-Repository-Services/pull/4057#discussion_r433385635", "createdAt": "2020-06-01T17:39:26Z", "author": {"login": "brucehoff"}, "path": "lib/jdomodels/src/test/java/org/sagebionetworks/repo/model/dbo/auth/OAuthClientDaoImplTest.java", "diffHunk": "@@ -476,4 +495,105 @@ public void testIsOauthClientVerified() throws Exception {\n \t\t\n \t}\n \n+\tprivate OAuthRefreshTokenInformation createRefreshToken(String clientId, String userId, Date authorizedOn, Date lastUsed) {\n+\t\tOAuthRefreshTokenInformation token = new OAuthRefreshTokenInformation();\n+\t\ttoken.setName(UUID.randomUUID().toString());\n+\t\ttoken.setClientId(clientId);\n+\t\ttoken.setPrincipalId(userId);\n+\t\ttoken.setScopes(Collections.singletonList(OAuthScope.view));\n+\t\ttoken.setClaims(Collections.singletonMap(OIDCClaimName.email.name(), new OIDCClaimsRequestDetails()));\n+\t\ttoken.setAuthorizedOn(authorizedOn);\n+\t\ttoken.setLastUsed(lastUsed);\n+\t\ttoken.setModifiedOn(new Date());\n+\t\ttoken.setEtag(UUID.randomUUID().toString());\n+\t\treturn oauthRefreshTokenDao.createRefreshToken(\"abcdef\", token);\n+\t}\n+\n+\t@Test\n+\tpublic void testGetAuthorizedClients() {\n+\t\tLong userId = BOOTSTRAP_PRINCIPAL.THE_ADMIN_USER.getPrincipalId();\n+\n+\t\tString client1 = createSectorIdentifierAndClient();\n+\t\tString client2 = createSectorIdentifierAndClient(SECOND_SECTOR_IDENTIFIER, userId, \"App 2\");\n+\n+\t\tfinal Date EXPECTED_AUTHZ_ON = new Date(System.currentTimeMillis() - ONE_YEAR_MILLIS * 5);// Earliest authorized on date", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bd558fd726cf88547bf5fe77053ecca833639788"}, "originalPosition": 90}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzM4ODI2MA==", "bodyText": "result1 -> client1AuthHistory; result2 -> clientAuthHistory;\nfor (ClientAuthHistory x : results.getResults()) {\nif (x.getClient_id().equals(client1)) result1=x;\nif (x.getClient_id().equals(client2)) result2=x;\n}\nassertNotNull(result1); assertNotNull(result2);", "url": "https://github.com/Sage-Bionetworks/Synapse-Repository-Services/pull/4057#discussion_r433388260", "createdAt": "2020-06-01T17:44:12Z", "author": {"login": "brucehoff"}, "path": "lib/jdomodels/src/test/java/org/sagebionetworks/repo/model/dbo/auth/OAuthClientDaoImplTest.java", "diffHunk": "@@ -476,4 +495,105 @@ public void testIsOauthClientVerified() throws Exception {\n \t\t\n \t}\n \n+\tprivate OAuthRefreshTokenInformation createRefreshToken(String clientId, String userId, Date authorizedOn, Date lastUsed) {\n+\t\tOAuthRefreshTokenInformation token = new OAuthRefreshTokenInformation();\n+\t\ttoken.setName(UUID.randomUUID().toString());\n+\t\ttoken.setClientId(clientId);\n+\t\ttoken.setPrincipalId(userId);\n+\t\ttoken.setScopes(Collections.singletonList(OAuthScope.view));\n+\t\ttoken.setClaims(Collections.singletonMap(OIDCClaimName.email.name(), new OIDCClaimsRequestDetails()));\n+\t\ttoken.setAuthorizedOn(authorizedOn);\n+\t\ttoken.setLastUsed(lastUsed);\n+\t\ttoken.setModifiedOn(new Date());\n+\t\ttoken.setEtag(UUID.randomUUID().toString());\n+\t\treturn oauthRefreshTokenDao.createRefreshToken(\"abcdef\", token);\n+\t}\n+\n+\t@Test\n+\tpublic void testGetAuthorizedClients() {\n+\t\tLong userId = BOOTSTRAP_PRINCIPAL.THE_ADMIN_USER.getPrincipalId();\n+\n+\t\tString client1 = createSectorIdentifierAndClient();\n+\t\tString client2 = createSectorIdentifierAndClient(SECOND_SECTOR_IDENTIFIER, userId, \"App 2\");\n+\n+\t\tfinal Date EXPECTED_AUTHZ_ON = new Date(System.currentTimeMillis() - ONE_YEAR_MILLIS * 5);// Earliest authorized on date\n+\t\tfinal Date EXPECTED_LAST_USED = new Date(System.currentTimeMillis() + ONE_YEAR_MILLIS * 5);// Latest last used date\n+\t\t// Valid tokens for client 1\n+\t\tcreateRefreshToken(client1, userId.toString(), EXPECTED_AUTHZ_ON, new Date());\n+\t\tcreateRefreshToken(client1, userId.toString(), new Date(), new Date());\n+\t\tcreateRefreshToken(client1, userId.toString(), new Date(), EXPECTED_LAST_USED);\n+\n+\t\t// Expired token for client 1. The dates are set up such that the result \"authorizedOn\" will not match if this token is not filtered.\n+\t\tcreateRefreshToken(client1, userId.toString(), new Date(System.currentTimeMillis() - ONE_YEAR_MILLIS * 10), new Date(System.currentTimeMillis() - TWO_YEARS_MILLIS));\n+\n+\t\t// Valid token for client 2\n+\t\tfinal Date CLIENT_2_AUTHZ_ON = new Date(System.currentTimeMillis() - 542326L);\n+\t\tfinal Date CLIENT_2_LAST_USED = new Date(System.currentTimeMillis() - 54232L);\n+\t\tcreateRefreshToken(client2, userId.toString(), CLIENT_2_AUTHZ_ON, CLIENT_2_LAST_USED);\n+\n+\t\t// Call under test\n+\t\tOAuthClientAuthorizationHistoryList results = oauthClientDao.getAuthorizedClientHistory(userId.toString(), null, ONE_YEAR_DAYS);\n+\n+\t\tassertEquals(2, results.getResults().size());\n+\t\tOAuthClientAuthorizationHistory result1;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bd558fd726cf88547bf5fe77053ecca833639788"}, "originalPosition": 109}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzM4OTU0Ng==", "bodyText": "// this makes page size  = 1", "url": "https://github.com/Sage-Bionetworks/Synapse-Repository-Services/pull/4057#discussion_r433389546", "createdAt": "2020-06-01T17:46:37Z", "author": {"login": "brucehoff"}, "path": "lib/jdomodels/src/test/java/org/sagebionetworks/repo/model/dbo/auth/OAuthClientDaoImplTest.java", "diffHunk": "@@ -476,4 +495,105 @@ public void testIsOauthClientVerified() throws Exception {\n \t\t\n \t}\n \n+\tprivate OAuthRefreshTokenInformation createRefreshToken(String clientId, String userId, Date authorizedOn, Date lastUsed) {\n+\t\tOAuthRefreshTokenInformation token = new OAuthRefreshTokenInformation();\n+\t\ttoken.setName(UUID.randomUUID().toString());\n+\t\ttoken.setClientId(clientId);\n+\t\ttoken.setPrincipalId(userId);\n+\t\ttoken.setScopes(Collections.singletonList(OAuthScope.view));\n+\t\ttoken.setClaims(Collections.singletonMap(OIDCClaimName.email.name(), new OIDCClaimsRequestDetails()));\n+\t\ttoken.setAuthorizedOn(authorizedOn);\n+\t\ttoken.setLastUsed(lastUsed);\n+\t\ttoken.setModifiedOn(new Date());\n+\t\ttoken.setEtag(UUID.randomUUID().toString());\n+\t\treturn oauthRefreshTokenDao.createRefreshToken(\"abcdef\", token);\n+\t}\n+\n+\t@Test\n+\tpublic void testGetAuthorizedClients() {\n+\t\tLong userId = BOOTSTRAP_PRINCIPAL.THE_ADMIN_USER.getPrincipalId();\n+\n+\t\tString client1 = createSectorIdentifierAndClient();\n+\t\tString client2 = createSectorIdentifierAndClient(SECOND_SECTOR_IDENTIFIER, userId, \"App 2\");\n+\n+\t\tfinal Date EXPECTED_AUTHZ_ON = new Date(System.currentTimeMillis() - ONE_YEAR_MILLIS * 5);// Earliest authorized on date\n+\t\tfinal Date EXPECTED_LAST_USED = new Date(System.currentTimeMillis() + ONE_YEAR_MILLIS * 5);// Latest last used date\n+\t\t// Valid tokens for client 1\n+\t\tcreateRefreshToken(client1, userId.toString(), EXPECTED_AUTHZ_ON, new Date());\n+\t\tcreateRefreshToken(client1, userId.toString(), new Date(), new Date());\n+\t\tcreateRefreshToken(client1, userId.toString(), new Date(), EXPECTED_LAST_USED);\n+\n+\t\t// Expired token for client 1. The dates are set up such that the result \"authorizedOn\" will not match if this token is not filtered.\n+\t\tcreateRefreshToken(client1, userId.toString(), new Date(System.currentTimeMillis() - ONE_YEAR_MILLIS * 10), new Date(System.currentTimeMillis() - TWO_YEARS_MILLIS));\n+\n+\t\t// Valid token for client 2\n+\t\tfinal Date CLIENT_2_AUTHZ_ON = new Date(System.currentTimeMillis() - 542326L);\n+\t\tfinal Date CLIENT_2_LAST_USED = new Date(System.currentTimeMillis() - 54232L);\n+\t\tcreateRefreshToken(client2, userId.toString(), CLIENT_2_AUTHZ_ON, CLIENT_2_LAST_USED);\n+\n+\t\t// Call under test\n+\t\tOAuthClientAuthorizationHistoryList results = oauthClientDao.getAuthorizedClientHistory(userId.toString(), null, ONE_YEAR_DAYS);\n+\n+\t\tassertEquals(2, results.getResults().size());\n+\t\tOAuthClientAuthorizationHistory result1;\n+\t\tOAuthClientAuthorizationHistory result2;\n+\t\tif (results.getResults().get(0).getClient().getClient_id().equals(client1)) {\n+\t\t\tresult1 = results.getResults().get(0);\n+\t\t\tresult2 = results.getResults().get(1);\n+\t\t} else {\n+\t\t\tresult1 = results.getResults().get(1);\n+\t\t\tresult2 = results.getResults().get(0);\n+\t\t}\n+\t\tassertEquals(client1, result1.getClient().getClient_id());\n+\t\tassertEquals(EXPECTED_AUTHZ_ON, result1.getAuthorizedOn());\n+\t\tassertEquals(EXPECTED_LAST_USED, result1.getLastUsed());\n+\n+\t\tassertEquals(client2, result2.getClient().getClient_id());\n+\t\tassertEquals(CLIENT_2_AUTHZ_ON, result2.getAuthorizedOn());\n+\t\tassertEquals(CLIENT_2_LAST_USED, result2.getLastUsed());\n+\n+\t\tassertNull(results.getNextPageToken());\n+\t}\n+\n+\t@Test\n+\tpublic void testGetAuthorizedClients_pagination() {\n+\t\tNextPageToken firstResultNPT = new NextPageToken(1, 0);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bd558fd726cf88547bf5fe77053ecca833639788"}, "originalPosition": 131}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzM5MDAzMA==", "bodyText": "consider the pattern suggested above", "url": "https://github.com/Sage-Bionetworks/Synapse-Repository-Services/pull/4057#discussion_r433390030", "createdAt": "2020-06-01T17:47:31Z", "author": {"login": "brucehoff"}, "path": "lib/jdomodels/src/test/java/org/sagebionetworks/repo/model/dbo/auth/OAuthClientDaoImplTest.java", "diffHunk": "@@ -476,4 +495,105 @@ public void testIsOauthClientVerified() throws Exception {\n \t\t\n \t}\n \n+\tprivate OAuthRefreshTokenInformation createRefreshToken(String clientId, String userId, Date authorizedOn, Date lastUsed) {\n+\t\tOAuthRefreshTokenInformation token = new OAuthRefreshTokenInformation();\n+\t\ttoken.setName(UUID.randomUUID().toString());\n+\t\ttoken.setClientId(clientId);\n+\t\ttoken.setPrincipalId(userId);\n+\t\ttoken.setScopes(Collections.singletonList(OAuthScope.view));\n+\t\ttoken.setClaims(Collections.singletonMap(OIDCClaimName.email.name(), new OIDCClaimsRequestDetails()));\n+\t\ttoken.setAuthorizedOn(authorizedOn);\n+\t\ttoken.setLastUsed(lastUsed);\n+\t\ttoken.setModifiedOn(new Date());\n+\t\ttoken.setEtag(UUID.randomUUID().toString());\n+\t\treturn oauthRefreshTokenDao.createRefreshToken(\"abcdef\", token);\n+\t}\n+\n+\t@Test\n+\tpublic void testGetAuthorizedClients() {\n+\t\tLong userId = BOOTSTRAP_PRINCIPAL.THE_ADMIN_USER.getPrincipalId();\n+\n+\t\tString client1 = createSectorIdentifierAndClient();\n+\t\tString client2 = createSectorIdentifierAndClient(SECOND_SECTOR_IDENTIFIER, userId, \"App 2\");\n+\n+\t\tfinal Date EXPECTED_AUTHZ_ON = new Date(System.currentTimeMillis() - ONE_YEAR_MILLIS * 5);// Earliest authorized on date\n+\t\tfinal Date EXPECTED_LAST_USED = new Date(System.currentTimeMillis() + ONE_YEAR_MILLIS * 5);// Latest last used date\n+\t\t// Valid tokens for client 1\n+\t\tcreateRefreshToken(client1, userId.toString(), EXPECTED_AUTHZ_ON, new Date());\n+\t\tcreateRefreshToken(client1, userId.toString(), new Date(), new Date());\n+\t\tcreateRefreshToken(client1, userId.toString(), new Date(), EXPECTED_LAST_USED);\n+\n+\t\t// Expired token for client 1. The dates are set up such that the result \"authorizedOn\" will not match if this token is not filtered.\n+\t\tcreateRefreshToken(client1, userId.toString(), new Date(System.currentTimeMillis() - ONE_YEAR_MILLIS * 10), new Date(System.currentTimeMillis() - TWO_YEARS_MILLIS));\n+\n+\t\t// Valid token for client 2\n+\t\tfinal Date CLIENT_2_AUTHZ_ON = new Date(System.currentTimeMillis() - 542326L);\n+\t\tfinal Date CLIENT_2_LAST_USED = new Date(System.currentTimeMillis() - 54232L);\n+\t\tcreateRefreshToken(client2, userId.toString(), CLIENT_2_AUTHZ_ON, CLIENT_2_LAST_USED);\n+\n+\t\t// Call under test\n+\t\tOAuthClientAuthorizationHistoryList results = oauthClientDao.getAuthorizedClientHistory(userId.toString(), null, ONE_YEAR_DAYS);\n+\n+\t\tassertEquals(2, results.getResults().size());\n+\t\tOAuthClientAuthorizationHistory result1;\n+\t\tOAuthClientAuthorizationHistory result2;\n+\t\tif (results.getResults().get(0).getClient().getClient_id().equals(client1)) {\n+\t\t\tresult1 = results.getResults().get(0);\n+\t\t\tresult2 = results.getResults().get(1);\n+\t\t} else {\n+\t\t\tresult1 = results.getResults().get(1);\n+\t\t\tresult2 = results.getResults().get(0);\n+\t\t}\n+\t\tassertEquals(client1, result1.getClient().getClient_id());\n+\t\tassertEquals(EXPECTED_AUTHZ_ON, result1.getAuthorizedOn());\n+\t\tassertEquals(EXPECTED_LAST_USED, result1.getLastUsed());\n+\n+\t\tassertEquals(client2, result2.getClient().getClient_id());\n+\t\tassertEquals(CLIENT_2_AUTHZ_ON, result2.getAuthorizedOn());\n+\t\tassertEquals(CLIENT_2_LAST_USED, result2.getLastUsed());\n+\n+\t\tassertNull(results.getNextPageToken());\n+\t}\n+\n+\t@Test\n+\tpublic void testGetAuthorizedClients_pagination() {\n+\t\tNextPageToken firstResultNPT = new NextPageToken(1, 0);\n+\n+\t\tLong userId = BOOTSTRAP_PRINCIPAL.THE_ADMIN_USER.getPrincipalId();\n+\n+\t\tString client1 = createSectorIdentifierAndClient();\n+\t\tString client2 = createSectorIdentifierAndClient(SECOND_SECTOR_IDENTIFIER, userId, \"App 2\");\n+\n+\t\t// Valid tokens for client 1 and client 2\n+\t\tcreateRefreshToken(client1, userId.toString(), new Date(), new Date());\n+\t\tcreateRefreshToken(client2, userId.toString(), new Date(), new Date());\n+\n+\t\t// Call under test -- first page\n+\t\tOAuthClientAuthorizationHistoryList firstPage = oauthClientDao.getAuthorizedClientHistory(userId.toString(), firstResultNPT.toToken(), ONE_YEAR_DAYS);\n+\t\tassertEquals(1, firstPage.getResults().size());\n+\t\tassertNotNull(firstPage.getNextPageToken());\n+\n+\t\t// Call under test -- second page\n+\t\tOAuthClientAuthorizationHistoryList secondPage = oauthClientDao.getAuthorizedClientHistory(userId.toString(), firstPage.getNextPageToken(), ONE_YEAR_DAYS);\n+\t\tassertEquals(1, secondPage.getResults().size());\n+\t\tassertNull(secondPage.getNextPageToken());\n+\n+\t\tif (firstPage.getResults().get(0).getClient().getClient_id().equals(client1)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bd558fd726cf88547bf5fe77053ecca833639788"}, "originalPosition": 152}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzM5NzUwNQ==", "bodyText": "remove out of date comment", "url": "https://github.com/Sage-Bionetworks/Synapse-Repository-Services/pull/4057#discussion_r433397505", "createdAt": "2020-06-01T18:01:11Z", "author": {"login": "brucehoff"}, "path": "lib/jdomodels/src/main/java/org/sagebionetworks/repo/model/dbo/auth/OAuthRefreshTokenDaoImpl.java", "diffHunk": "@@ -0,0 +1,255 @@\n+package org.sagebionetworks.repo.model.dbo.auth;\n+\n+import static org.sagebionetworks.repo.model.query.jdo.SqlConstants.COL_OAUTH_REFRESH_TOKEN_CLIENT_ID;\n+import static org.sagebionetworks.repo.model.query.jdo.SqlConstants.COL_OAUTH_REFRESH_TOKEN_ETAG;\n+import static org.sagebionetworks.repo.model.query.jdo.SqlConstants.COL_OAUTH_REFRESH_TOKEN_HASH;\n+import static org.sagebionetworks.repo.model.query.jdo.SqlConstants.COL_OAUTH_REFRESH_TOKEN_ID;\n+import static org.sagebionetworks.repo.model.query.jdo.SqlConstants.COL_OAUTH_REFRESH_TOKEN_LAST_USED;\n+import static org.sagebionetworks.repo.model.query.jdo.SqlConstants.COL_OAUTH_REFRESH_TOKEN_MODIFIED_ON;\n+import static org.sagebionetworks.repo.model.query.jdo.SqlConstants.COL_OAUTH_REFRESH_TOKEN_NAME;\n+import static org.sagebionetworks.repo.model.query.jdo.SqlConstants.COL_OAUTH_REFRESH_TOKEN_PRINCIPAL_ID;\n+import static org.sagebionetworks.repo.model.query.jdo.SqlConstants.TABLE_OAUTH_REFRESH_TOKEN;\n+\n+import java.io.IOException;\n+import java.sql.Timestamp;\n+import java.util.Date;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.UUID;\n+import java.util.stream.Collectors;\n+\n+import org.sagebionetworks.ids.IdGenerator;\n+import org.sagebionetworks.ids.IdType;\n+import org.sagebionetworks.repo.model.NextPageToken;\n+import org.sagebionetworks.repo.model.UnmodifiableXStream;\n+import org.sagebionetworks.repo.model.auth.OAuthRefreshTokenDao;\n+import org.sagebionetworks.repo.model.dbo.DBOBasicDao;\n+import org.sagebionetworks.repo.model.dbo.SinglePrimaryKeySqlParameterSource;\n+import org.sagebionetworks.repo.model.dbo.persistence.DBOOAuthRefreshToken;\n+import org.sagebionetworks.repo.model.jdo.JDOSecondaryPropertyUtils;\n+import org.sagebionetworks.repo.model.oauth.OAuthRefreshTokenInformation;\n+import org.sagebionetworks.repo.model.oauth.OAuthRefreshTokenInformationList;\n+import org.sagebionetworks.repo.model.oauth.OAuthScope;\n+import org.sagebionetworks.repo.model.oauth.OIDCClaimsRequestDetails;\n+import org.sagebionetworks.repo.transactions.MandatoryWriteTransaction;\n+import org.sagebionetworks.repo.transactions.WriteTransaction;\n+import org.sagebionetworks.util.ValidateArgument;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.jdbc.core.namedparam.MapSqlParameterSource;\n+import org.springframework.jdbc.core.namedparam.NamedParameterJdbcTemplate;\n+\n+public class OAuthRefreshTokenDaoImpl implements OAuthRefreshTokenDao {\n+\n+\tprivate static final String PARAM_TOKEN_HASH = \"tokenHash\";\n+\tprivate static final String PARAM_NAME = \"tokenName\";\n+\tprivate static final String PARAM_ETAG = \"etag\";\n+\tprivate static final String PARAM_MODIFIED_ON = \"modifiedOn\";\n+\tprivate static final String PARAM_LAST_USED = \"lastUsed\";\n+\tprivate static final String PARAM_TOKEN_ID = \"id\";\n+\tprivate static final String PARAM_PRINCIPAL_ID = \"principalId\";\n+\tprivate static final String PARAM_CLIENT_ID = \"clientId\";\n+\tprivate static final String PARAM_LIMIT = \"limitParam\";\n+\tprivate static final String PARAM_OFFSET = \"offsetParam\";\n+\tprivate static final String PARAM_DAYS = \"days\";\n+\n+\tprivate static final String UPDATE_REFRESH_TOKEN_METADATA = \"UPDATE \"+TABLE_OAUTH_REFRESH_TOKEN+\n+\t\t\t\" SET \"+\n+\t\t\tCOL_OAUTH_REFRESH_TOKEN_NAME+\" = :\" + PARAM_NAME + \", \"+\n+\t\t\tCOL_OAUTH_REFRESH_TOKEN_ETAG+\" = :\" + PARAM_ETAG + \", \" +\n+\t\t\tCOL_OAUTH_REFRESH_TOKEN_MODIFIED_ON + \" = :\"+ PARAM_MODIFIED_ON +\n+\t\t\t\" WHERE \"+ COL_OAUTH_REFRESH_TOKEN_ID+\" = :\" + PARAM_TOKEN_ID;\n+\n+\tprivate static final String UPDATE_REFRESH_TOKEN_HASH = \"UPDATE \"+TABLE_OAUTH_REFRESH_TOKEN+\n+\t\t\t\" SET \"+\n+\t\t\tCOL_OAUTH_REFRESH_TOKEN_HASH+\" = :\" + PARAM_TOKEN_HASH + \", \"+\n+\t\t\tCOL_OAUTH_REFRESH_TOKEN_LAST_USED + \" = :\"+ PARAM_LAST_USED + \", \" +\n+\t\t\tCOL_OAUTH_REFRESH_TOKEN_ETAG+\" = :\" + PARAM_ETAG +\n+\t\t\t\" WHERE \"+ COL_OAUTH_REFRESH_TOKEN_ID+\" = :\" + PARAM_TOKEN_ID;\n+\n+\tprivate static final String SELECT_TOKENS_FOR_CLIENT_AND_PRINCIPAL = \"SELECT * FROM \" + TABLE_OAUTH_REFRESH_TOKEN\n+\t\t\t+ \" WHERE \" + COL_OAUTH_REFRESH_TOKEN_PRINCIPAL_ID + \" = :\" + PARAM_PRINCIPAL_ID\n+\t\t\t+ \" AND \" + COL_OAUTH_REFRESH_TOKEN_CLIENT_ID + \" = :\" + PARAM_CLIENT_ID\n+\t\t\t+ \" AND \" + COL_OAUTH_REFRESH_TOKEN_LAST_USED +\n+\t\t\t\t\" > (NOW() - INTERVAL  :\" + PARAM_DAYS + \" DAY)\"\n+\t\t\t+ \" ORDER BY \" + COL_OAUTH_REFRESH_TOKEN_LAST_USED + \" DESC\"\n+\t\t\t+ \" LIMIT :\" + PARAM_LIMIT + \" OFFSET :\" + PARAM_OFFSET;\n+\n+\tprivate static final String SELECT_TOKEN_BY_HASH_FOR_UPDATE = \"SELECT * FROM \" + TABLE_OAUTH_REFRESH_TOKEN\n+\t\t\t+ \" WHERE \" + COL_OAUTH_REFRESH_TOKEN_HASH + \" = :\" + PARAM_TOKEN_HASH\n+\t\t\t+ \" AND \" + COL_OAUTH_REFRESH_TOKEN_CLIENT_ID + \" = :\" + PARAM_CLIENT_ID\n+\t\t\t+ \" FOR UPDATE\";\n+\n+\tprivate static final String DELETE_TOKEN_BY_ID = \"DELETE FROM \" + TABLE_OAUTH_REFRESH_TOKEN\n+\t\t\t+ \" WHERE \" + COL_OAUTH_REFRESH_TOKEN_ID + \" = :\" + PARAM_TOKEN_ID;\n+\n+\tprivate static final String DELETE_TOKEN_BY_CLIENT_USER_PAIR = \"DELETE FROM \" + TABLE_OAUTH_REFRESH_TOKEN\n+\t\t\t+ \" WHERE \" + COL_OAUTH_REFRESH_TOKEN_PRINCIPAL_ID + \" = :\" + PARAM_PRINCIPAL_ID\n+\t\t\t+ \" AND \" + COL_OAUTH_REFRESH_TOKEN_CLIENT_ID + \" = :\" + PARAM_CLIENT_ID;\n+\n+\t@Autowired\n+\tprivate DBOBasicDao basicDao;\n+\n+\t@Autowired\n+\tprivate IdGenerator idGenerator;\n+\n+\t@Autowired\n+\tprivate NamedParameterJdbcTemplate namedParameterJdbcTemplate;\n+\n+\t// We serialize explicitly chosen fields, not the entire DTO, so no need to omit fields in the builder\n+\tprivate static final UnmodifiableXStream X_STREAM = UnmodifiableXStream.builder().build();\n+\n+\tpublic static DBOOAuthRefreshToken refreshTokenDtoToDbo(OAuthRefreshTokenInformation dto) {\n+\t\tDBOOAuthRefreshToken dbo = new DBOOAuthRefreshToken();\n+\t\ttry {\n+\t\t\tdbo.setScopes(JDOSecondaryPropertyUtils.compressObject(X_STREAM, dto.getScopes()));\n+\t\t\tdbo.setClaims(JDOSecondaryPropertyUtils.compressObject(X_STREAM, dto.getClaims()));\n+\t\t} catch (IOException e) {\n+\t\t\tthrow new RuntimeException(e);\n+\t\t}\n+\t\tdbo.setId(Long.parseLong(dto.getTokenId()));\n+\t\tdbo.setName(dto.getName());\n+\t\tdbo.setPrincipalId(Long.parseLong(dto.getPrincipalId()));\n+\t\tdbo.setClientId(Long.parseLong(dto.getClientId()));\n+\t\tdbo.setCreatedOn(new Timestamp(dto.getAuthorizedOn().getTime()));\n+\t\tdbo.setModifiedOn(new Timestamp(dto.getModifiedOn().getTime()));\n+\t\tdbo.setLastUsed(new Timestamp(dto.getLastUsed().getTime()));\n+\t\tdbo.setEtag(dto.getEtag());\n+\t\treturn dbo;\n+\t}\n+\n+\tpublic static OAuthRefreshTokenInformation refreshTokenDboToDto(DBOOAuthRefreshToken dbo) {\n+\t\tOAuthRefreshTokenInformation dto = new OAuthRefreshTokenInformation();\n+\t\ttry {\n+\t\t\tdto.setScopes((List<OAuthScope>) JDOSecondaryPropertyUtils.decompressObject(X_STREAM, dbo.getScopes()));\n+\t\t\tdto.setClaims((Map<String, OIDCClaimsRequestDetails>) JDOSecondaryPropertyUtils.decompressObject(X_STREAM, dbo.getClaims()));\n+\t\t} catch (IOException e) {\n+\t\t\tthrow new RuntimeException(e);\n+\t\t}\n+\t\tdto.setTokenId(dbo.getId().toString());\n+\t\tdto.setName(dbo.getName());\n+\t\tdto.setPrincipalId(dbo.getPrincipalId().toString());\n+\t\tdto.setClientId(dbo.getClientId().toString());\n+\t\t// Timestamp must be converted to Date for .equals to work on the DTO\n+\t\tdto.setAuthorizedOn(new Date(dbo.getCreatedOn().getTime()));\n+\t\tdto.setModifiedOn(new Date(dbo.getModifiedOn().getTime()));\n+\t\tdto.setLastUsed(new Date(dbo.getLastUsed().getTime()));\n+\t\tdto.setEtag(dbo.getEtag());\n+\t\treturn dto;\n+\t}\n+\n+\t@MandatoryWriteTransaction\n+\t@Override\n+\tpublic void updateTokenHash(String tokenId, String newHash) {\n+\t\tValidateArgument.required(tokenId, \"Token ID\");\n+\t\tValidateArgument.required(newHash, \"Token hash\");\n+\n+\t\t// Currently, the only mutable fields are NAME, ETAG, MODIFIED_ON", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bd558fd726cf88547bf5fe77053ecca833639788"}, "originalPosition": 147}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzM5ODE2MA==", "bodyText": "be consistent in terms of where etag is defined (manager vs. dao).  See, e.g. OAuthClient Dao", "url": "https://github.com/Sage-Bionetworks/Synapse-Repository-Services/pull/4057#discussion_r433398160", "createdAt": "2020-06-01T18:02:28Z", "author": {"login": "brucehoff"}, "path": "lib/jdomodels/src/main/java/org/sagebionetworks/repo/model/dbo/auth/OAuthRefreshTokenDaoImpl.java", "diffHunk": "@@ -0,0 +1,255 @@\n+package org.sagebionetworks.repo.model.dbo.auth;\n+\n+import static org.sagebionetworks.repo.model.query.jdo.SqlConstants.COL_OAUTH_REFRESH_TOKEN_CLIENT_ID;\n+import static org.sagebionetworks.repo.model.query.jdo.SqlConstants.COL_OAUTH_REFRESH_TOKEN_ETAG;\n+import static org.sagebionetworks.repo.model.query.jdo.SqlConstants.COL_OAUTH_REFRESH_TOKEN_HASH;\n+import static org.sagebionetworks.repo.model.query.jdo.SqlConstants.COL_OAUTH_REFRESH_TOKEN_ID;\n+import static org.sagebionetworks.repo.model.query.jdo.SqlConstants.COL_OAUTH_REFRESH_TOKEN_LAST_USED;\n+import static org.sagebionetworks.repo.model.query.jdo.SqlConstants.COL_OAUTH_REFRESH_TOKEN_MODIFIED_ON;\n+import static org.sagebionetworks.repo.model.query.jdo.SqlConstants.COL_OAUTH_REFRESH_TOKEN_NAME;\n+import static org.sagebionetworks.repo.model.query.jdo.SqlConstants.COL_OAUTH_REFRESH_TOKEN_PRINCIPAL_ID;\n+import static org.sagebionetworks.repo.model.query.jdo.SqlConstants.TABLE_OAUTH_REFRESH_TOKEN;\n+\n+import java.io.IOException;\n+import java.sql.Timestamp;\n+import java.util.Date;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.UUID;\n+import java.util.stream.Collectors;\n+\n+import org.sagebionetworks.ids.IdGenerator;\n+import org.sagebionetworks.ids.IdType;\n+import org.sagebionetworks.repo.model.NextPageToken;\n+import org.sagebionetworks.repo.model.UnmodifiableXStream;\n+import org.sagebionetworks.repo.model.auth.OAuthRefreshTokenDao;\n+import org.sagebionetworks.repo.model.dbo.DBOBasicDao;\n+import org.sagebionetworks.repo.model.dbo.SinglePrimaryKeySqlParameterSource;\n+import org.sagebionetworks.repo.model.dbo.persistence.DBOOAuthRefreshToken;\n+import org.sagebionetworks.repo.model.jdo.JDOSecondaryPropertyUtils;\n+import org.sagebionetworks.repo.model.oauth.OAuthRefreshTokenInformation;\n+import org.sagebionetworks.repo.model.oauth.OAuthRefreshTokenInformationList;\n+import org.sagebionetworks.repo.model.oauth.OAuthScope;\n+import org.sagebionetworks.repo.model.oauth.OIDCClaimsRequestDetails;\n+import org.sagebionetworks.repo.transactions.MandatoryWriteTransaction;\n+import org.sagebionetworks.repo.transactions.WriteTransaction;\n+import org.sagebionetworks.util.ValidateArgument;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.jdbc.core.namedparam.MapSqlParameterSource;\n+import org.springframework.jdbc.core.namedparam.NamedParameterJdbcTemplate;\n+\n+public class OAuthRefreshTokenDaoImpl implements OAuthRefreshTokenDao {\n+\n+\tprivate static final String PARAM_TOKEN_HASH = \"tokenHash\";\n+\tprivate static final String PARAM_NAME = \"tokenName\";\n+\tprivate static final String PARAM_ETAG = \"etag\";\n+\tprivate static final String PARAM_MODIFIED_ON = \"modifiedOn\";\n+\tprivate static final String PARAM_LAST_USED = \"lastUsed\";\n+\tprivate static final String PARAM_TOKEN_ID = \"id\";\n+\tprivate static final String PARAM_PRINCIPAL_ID = \"principalId\";\n+\tprivate static final String PARAM_CLIENT_ID = \"clientId\";\n+\tprivate static final String PARAM_LIMIT = \"limitParam\";\n+\tprivate static final String PARAM_OFFSET = \"offsetParam\";\n+\tprivate static final String PARAM_DAYS = \"days\";\n+\n+\tprivate static final String UPDATE_REFRESH_TOKEN_METADATA = \"UPDATE \"+TABLE_OAUTH_REFRESH_TOKEN+\n+\t\t\t\" SET \"+\n+\t\t\tCOL_OAUTH_REFRESH_TOKEN_NAME+\" = :\" + PARAM_NAME + \", \"+\n+\t\t\tCOL_OAUTH_REFRESH_TOKEN_ETAG+\" = :\" + PARAM_ETAG + \", \" +\n+\t\t\tCOL_OAUTH_REFRESH_TOKEN_MODIFIED_ON + \" = :\"+ PARAM_MODIFIED_ON +\n+\t\t\t\" WHERE \"+ COL_OAUTH_REFRESH_TOKEN_ID+\" = :\" + PARAM_TOKEN_ID;\n+\n+\tprivate static final String UPDATE_REFRESH_TOKEN_HASH = \"UPDATE \"+TABLE_OAUTH_REFRESH_TOKEN+\n+\t\t\t\" SET \"+\n+\t\t\tCOL_OAUTH_REFRESH_TOKEN_HASH+\" = :\" + PARAM_TOKEN_HASH + \", \"+\n+\t\t\tCOL_OAUTH_REFRESH_TOKEN_LAST_USED + \" = :\"+ PARAM_LAST_USED + \", \" +\n+\t\t\tCOL_OAUTH_REFRESH_TOKEN_ETAG+\" = :\" + PARAM_ETAG +\n+\t\t\t\" WHERE \"+ COL_OAUTH_REFRESH_TOKEN_ID+\" = :\" + PARAM_TOKEN_ID;\n+\n+\tprivate static final String SELECT_TOKENS_FOR_CLIENT_AND_PRINCIPAL = \"SELECT * FROM \" + TABLE_OAUTH_REFRESH_TOKEN\n+\t\t\t+ \" WHERE \" + COL_OAUTH_REFRESH_TOKEN_PRINCIPAL_ID + \" = :\" + PARAM_PRINCIPAL_ID\n+\t\t\t+ \" AND \" + COL_OAUTH_REFRESH_TOKEN_CLIENT_ID + \" = :\" + PARAM_CLIENT_ID\n+\t\t\t+ \" AND \" + COL_OAUTH_REFRESH_TOKEN_LAST_USED +\n+\t\t\t\t\" > (NOW() - INTERVAL  :\" + PARAM_DAYS + \" DAY)\"\n+\t\t\t+ \" ORDER BY \" + COL_OAUTH_REFRESH_TOKEN_LAST_USED + \" DESC\"\n+\t\t\t+ \" LIMIT :\" + PARAM_LIMIT + \" OFFSET :\" + PARAM_OFFSET;\n+\n+\tprivate static final String SELECT_TOKEN_BY_HASH_FOR_UPDATE = \"SELECT * FROM \" + TABLE_OAUTH_REFRESH_TOKEN\n+\t\t\t+ \" WHERE \" + COL_OAUTH_REFRESH_TOKEN_HASH + \" = :\" + PARAM_TOKEN_HASH\n+\t\t\t+ \" AND \" + COL_OAUTH_REFRESH_TOKEN_CLIENT_ID + \" = :\" + PARAM_CLIENT_ID\n+\t\t\t+ \" FOR UPDATE\";\n+\n+\tprivate static final String DELETE_TOKEN_BY_ID = \"DELETE FROM \" + TABLE_OAUTH_REFRESH_TOKEN\n+\t\t\t+ \" WHERE \" + COL_OAUTH_REFRESH_TOKEN_ID + \" = :\" + PARAM_TOKEN_ID;\n+\n+\tprivate static final String DELETE_TOKEN_BY_CLIENT_USER_PAIR = \"DELETE FROM \" + TABLE_OAUTH_REFRESH_TOKEN\n+\t\t\t+ \" WHERE \" + COL_OAUTH_REFRESH_TOKEN_PRINCIPAL_ID + \" = :\" + PARAM_PRINCIPAL_ID\n+\t\t\t+ \" AND \" + COL_OAUTH_REFRESH_TOKEN_CLIENT_ID + \" = :\" + PARAM_CLIENT_ID;\n+\n+\t@Autowired\n+\tprivate DBOBasicDao basicDao;\n+\n+\t@Autowired\n+\tprivate IdGenerator idGenerator;\n+\n+\t@Autowired\n+\tprivate NamedParameterJdbcTemplate namedParameterJdbcTemplate;\n+\n+\t// We serialize explicitly chosen fields, not the entire DTO, so no need to omit fields in the builder\n+\tprivate static final UnmodifiableXStream X_STREAM = UnmodifiableXStream.builder().build();\n+\n+\tpublic static DBOOAuthRefreshToken refreshTokenDtoToDbo(OAuthRefreshTokenInformation dto) {\n+\t\tDBOOAuthRefreshToken dbo = new DBOOAuthRefreshToken();\n+\t\ttry {\n+\t\t\tdbo.setScopes(JDOSecondaryPropertyUtils.compressObject(X_STREAM, dto.getScopes()));\n+\t\t\tdbo.setClaims(JDOSecondaryPropertyUtils.compressObject(X_STREAM, dto.getClaims()));\n+\t\t} catch (IOException e) {\n+\t\t\tthrow new RuntimeException(e);\n+\t\t}\n+\t\tdbo.setId(Long.parseLong(dto.getTokenId()));\n+\t\tdbo.setName(dto.getName());\n+\t\tdbo.setPrincipalId(Long.parseLong(dto.getPrincipalId()));\n+\t\tdbo.setClientId(Long.parseLong(dto.getClientId()));\n+\t\tdbo.setCreatedOn(new Timestamp(dto.getAuthorizedOn().getTime()));\n+\t\tdbo.setModifiedOn(new Timestamp(dto.getModifiedOn().getTime()));\n+\t\tdbo.setLastUsed(new Timestamp(dto.getLastUsed().getTime()));\n+\t\tdbo.setEtag(dto.getEtag());\n+\t\treturn dbo;\n+\t}\n+\n+\tpublic static OAuthRefreshTokenInformation refreshTokenDboToDto(DBOOAuthRefreshToken dbo) {\n+\t\tOAuthRefreshTokenInformation dto = new OAuthRefreshTokenInformation();\n+\t\ttry {\n+\t\t\tdto.setScopes((List<OAuthScope>) JDOSecondaryPropertyUtils.decompressObject(X_STREAM, dbo.getScopes()));\n+\t\t\tdto.setClaims((Map<String, OIDCClaimsRequestDetails>) JDOSecondaryPropertyUtils.decompressObject(X_STREAM, dbo.getClaims()));\n+\t\t} catch (IOException e) {\n+\t\t\tthrow new RuntimeException(e);\n+\t\t}\n+\t\tdto.setTokenId(dbo.getId().toString());\n+\t\tdto.setName(dbo.getName());\n+\t\tdto.setPrincipalId(dbo.getPrincipalId().toString());\n+\t\tdto.setClientId(dbo.getClientId().toString());\n+\t\t// Timestamp must be converted to Date for .equals to work on the DTO\n+\t\tdto.setAuthorizedOn(new Date(dbo.getCreatedOn().getTime()));\n+\t\tdto.setModifiedOn(new Date(dbo.getModifiedOn().getTime()));\n+\t\tdto.setLastUsed(new Date(dbo.getLastUsed().getTime()));\n+\t\tdto.setEtag(dbo.getEtag());\n+\t\treturn dto;\n+\t}\n+\n+\t@MandatoryWriteTransaction\n+\t@Override\n+\tpublic void updateTokenHash(String tokenId, String newHash) {\n+\t\tValidateArgument.required(tokenId, \"Token ID\");\n+\t\tValidateArgument.required(newHash, \"Token hash\");\n+\n+\t\t// Currently, the only mutable fields are NAME, ETAG, MODIFIED_ON\n+\t\tMapSqlParameterSource params = new MapSqlParameterSource();\n+\t\tparams.addValue(PARAM_TOKEN_HASH, newHash);\n+\t\tparams.addValue(PARAM_ETAG, UUID.randomUUID().toString());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bd558fd726cf88547bf5fe77053ecca833639788"}, "originalPosition": 150}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzQwNDI3NQ==", "bodyText": "what is the representation of no claims?\ndoes this include both the id_token and userinfo claims?\nLook at how the claims are embedded in an access token, for example in ClaimsJsonUtil.addAccessClaims().", "url": "https://github.com/Sage-Bionetworks/Synapse-Repository-Services/pull/4057#discussion_r433404275", "createdAt": "2020-06-01T18:14:27Z", "author": {"login": "brucehoff"}, "path": "lib/jdomodels/src/main/java/org/sagebionetworks/repo/model/dbo/auth/OAuthRefreshTokenDaoImpl.java", "diffHunk": "@@ -0,0 +1,255 @@\n+package org.sagebionetworks.repo.model.dbo.auth;\n+\n+import static org.sagebionetworks.repo.model.query.jdo.SqlConstants.COL_OAUTH_REFRESH_TOKEN_CLIENT_ID;\n+import static org.sagebionetworks.repo.model.query.jdo.SqlConstants.COL_OAUTH_REFRESH_TOKEN_ETAG;\n+import static org.sagebionetworks.repo.model.query.jdo.SqlConstants.COL_OAUTH_REFRESH_TOKEN_HASH;\n+import static org.sagebionetworks.repo.model.query.jdo.SqlConstants.COL_OAUTH_REFRESH_TOKEN_ID;\n+import static org.sagebionetworks.repo.model.query.jdo.SqlConstants.COL_OAUTH_REFRESH_TOKEN_LAST_USED;\n+import static org.sagebionetworks.repo.model.query.jdo.SqlConstants.COL_OAUTH_REFRESH_TOKEN_MODIFIED_ON;\n+import static org.sagebionetworks.repo.model.query.jdo.SqlConstants.COL_OAUTH_REFRESH_TOKEN_NAME;\n+import static org.sagebionetworks.repo.model.query.jdo.SqlConstants.COL_OAUTH_REFRESH_TOKEN_PRINCIPAL_ID;\n+import static org.sagebionetworks.repo.model.query.jdo.SqlConstants.TABLE_OAUTH_REFRESH_TOKEN;\n+\n+import java.io.IOException;\n+import java.sql.Timestamp;\n+import java.util.Date;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.UUID;\n+import java.util.stream.Collectors;\n+\n+import org.sagebionetworks.ids.IdGenerator;\n+import org.sagebionetworks.ids.IdType;\n+import org.sagebionetworks.repo.model.NextPageToken;\n+import org.sagebionetworks.repo.model.UnmodifiableXStream;\n+import org.sagebionetworks.repo.model.auth.OAuthRefreshTokenDao;\n+import org.sagebionetworks.repo.model.dbo.DBOBasicDao;\n+import org.sagebionetworks.repo.model.dbo.SinglePrimaryKeySqlParameterSource;\n+import org.sagebionetworks.repo.model.dbo.persistence.DBOOAuthRefreshToken;\n+import org.sagebionetworks.repo.model.jdo.JDOSecondaryPropertyUtils;\n+import org.sagebionetworks.repo.model.oauth.OAuthRefreshTokenInformation;\n+import org.sagebionetworks.repo.model.oauth.OAuthRefreshTokenInformationList;\n+import org.sagebionetworks.repo.model.oauth.OAuthScope;\n+import org.sagebionetworks.repo.model.oauth.OIDCClaimsRequestDetails;\n+import org.sagebionetworks.repo.transactions.MandatoryWriteTransaction;\n+import org.sagebionetworks.repo.transactions.WriteTransaction;\n+import org.sagebionetworks.util.ValidateArgument;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.jdbc.core.namedparam.MapSqlParameterSource;\n+import org.springframework.jdbc.core.namedparam.NamedParameterJdbcTemplate;\n+\n+public class OAuthRefreshTokenDaoImpl implements OAuthRefreshTokenDao {\n+\n+\tprivate static final String PARAM_TOKEN_HASH = \"tokenHash\";\n+\tprivate static final String PARAM_NAME = \"tokenName\";\n+\tprivate static final String PARAM_ETAG = \"etag\";\n+\tprivate static final String PARAM_MODIFIED_ON = \"modifiedOn\";\n+\tprivate static final String PARAM_LAST_USED = \"lastUsed\";\n+\tprivate static final String PARAM_TOKEN_ID = \"id\";\n+\tprivate static final String PARAM_PRINCIPAL_ID = \"principalId\";\n+\tprivate static final String PARAM_CLIENT_ID = \"clientId\";\n+\tprivate static final String PARAM_LIMIT = \"limitParam\";\n+\tprivate static final String PARAM_OFFSET = \"offsetParam\";\n+\tprivate static final String PARAM_DAYS = \"days\";\n+\n+\tprivate static final String UPDATE_REFRESH_TOKEN_METADATA = \"UPDATE \"+TABLE_OAUTH_REFRESH_TOKEN+\n+\t\t\t\" SET \"+\n+\t\t\tCOL_OAUTH_REFRESH_TOKEN_NAME+\" = :\" + PARAM_NAME + \", \"+\n+\t\t\tCOL_OAUTH_REFRESH_TOKEN_ETAG+\" = :\" + PARAM_ETAG + \", \" +\n+\t\t\tCOL_OAUTH_REFRESH_TOKEN_MODIFIED_ON + \" = :\"+ PARAM_MODIFIED_ON +\n+\t\t\t\" WHERE \"+ COL_OAUTH_REFRESH_TOKEN_ID+\" = :\" + PARAM_TOKEN_ID;\n+\n+\tprivate static final String UPDATE_REFRESH_TOKEN_HASH = \"UPDATE \"+TABLE_OAUTH_REFRESH_TOKEN+\n+\t\t\t\" SET \"+\n+\t\t\tCOL_OAUTH_REFRESH_TOKEN_HASH+\" = :\" + PARAM_TOKEN_HASH + \", \"+\n+\t\t\tCOL_OAUTH_REFRESH_TOKEN_LAST_USED + \" = :\"+ PARAM_LAST_USED + \", \" +\n+\t\t\tCOL_OAUTH_REFRESH_TOKEN_ETAG+\" = :\" + PARAM_ETAG +\n+\t\t\t\" WHERE \"+ COL_OAUTH_REFRESH_TOKEN_ID+\" = :\" + PARAM_TOKEN_ID;\n+\n+\tprivate static final String SELECT_TOKENS_FOR_CLIENT_AND_PRINCIPAL = \"SELECT * FROM \" + TABLE_OAUTH_REFRESH_TOKEN\n+\t\t\t+ \" WHERE \" + COL_OAUTH_REFRESH_TOKEN_PRINCIPAL_ID + \" = :\" + PARAM_PRINCIPAL_ID\n+\t\t\t+ \" AND \" + COL_OAUTH_REFRESH_TOKEN_CLIENT_ID + \" = :\" + PARAM_CLIENT_ID\n+\t\t\t+ \" AND \" + COL_OAUTH_REFRESH_TOKEN_LAST_USED +\n+\t\t\t\t\" > (NOW() - INTERVAL  :\" + PARAM_DAYS + \" DAY)\"\n+\t\t\t+ \" ORDER BY \" + COL_OAUTH_REFRESH_TOKEN_LAST_USED + \" DESC\"\n+\t\t\t+ \" LIMIT :\" + PARAM_LIMIT + \" OFFSET :\" + PARAM_OFFSET;\n+\n+\tprivate static final String SELECT_TOKEN_BY_HASH_FOR_UPDATE = \"SELECT * FROM \" + TABLE_OAUTH_REFRESH_TOKEN\n+\t\t\t+ \" WHERE \" + COL_OAUTH_REFRESH_TOKEN_HASH + \" = :\" + PARAM_TOKEN_HASH\n+\t\t\t+ \" AND \" + COL_OAUTH_REFRESH_TOKEN_CLIENT_ID + \" = :\" + PARAM_CLIENT_ID\n+\t\t\t+ \" FOR UPDATE\";\n+\n+\tprivate static final String DELETE_TOKEN_BY_ID = \"DELETE FROM \" + TABLE_OAUTH_REFRESH_TOKEN\n+\t\t\t+ \" WHERE \" + COL_OAUTH_REFRESH_TOKEN_ID + \" = :\" + PARAM_TOKEN_ID;\n+\n+\tprivate static final String DELETE_TOKEN_BY_CLIENT_USER_PAIR = \"DELETE FROM \" + TABLE_OAUTH_REFRESH_TOKEN\n+\t\t\t+ \" WHERE \" + COL_OAUTH_REFRESH_TOKEN_PRINCIPAL_ID + \" = :\" + PARAM_PRINCIPAL_ID\n+\t\t\t+ \" AND \" + COL_OAUTH_REFRESH_TOKEN_CLIENT_ID + \" = :\" + PARAM_CLIENT_ID;\n+\n+\t@Autowired\n+\tprivate DBOBasicDao basicDao;\n+\n+\t@Autowired\n+\tprivate IdGenerator idGenerator;\n+\n+\t@Autowired\n+\tprivate NamedParameterJdbcTemplate namedParameterJdbcTemplate;\n+\n+\t// We serialize explicitly chosen fields, not the entire DTO, so no need to omit fields in the builder\n+\tprivate static final UnmodifiableXStream X_STREAM = UnmodifiableXStream.builder().build();\n+\n+\tpublic static DBOOAuthRefreshToken refreshTokenDtoToDbo(OAuthRefreshTokenInformation dto) {\n+\t\tDBOOAuthRefreshToken dbo = new DBOOAuthRefreshToken();\n+\t\ttry {\n+\t\t\tdbo.setScopes(JDOSecondaryPropertyUtils.compressObject(X_STREAM, dto.getScopes()));\n+\t\t\tdbo.setClaims(JDOSecondaryPropertyUtils.compressObject(X_STREAM, dto.getClaims()));\n+\t\t} catch (IOException e) {\n+\t\t\tthrow new RuntimeException(e);\n+\t\t}\n+\t\tdbo.setId(Long.parseLong(dto.getTokenId()));\n+\t\tdbo.setName(dto.getName());\n+\t\tdbo.setPrincipalId(Long.parseLong(dto.getPrincipalId()));\n+\t\tdbo.setClientId(Long.parseLong(dto.getClientId()));\n+\t\tdbo.setCreatedOn(new Timestamp(dto.getAuthorizedOn().getTime()));\n+\t\tdbo.setModifiedOn(new Timestamp(dto.getModifiedOn().getTime()));\n+\t\tdbo.setLastUsed(new Timestamp(dto.getLastUsed().getTime()));\n+\t\tdbo.setEtag(dto.getEtag());\n+\t\treturn dbo;\n+\t}\n+\n+\tpublic static OAuthRefreshTokenInformation refreshTokenDboToDto(DBOOAuthRefreshToken dbo) {\n+\t\tOAuthRefreshTokenInformation dto = new OAuthRefreshTokenInformation();\n+\t\ttry {\n+\t\t\tdto.setScopes((List<OAuthScope>) JDOSecondaryPropertyUtils.decompressObject(X_STREAM, dbo.getScopes()));\n+\t\t\tdto.setClaims((Map<String, OIDCClaimsRequestDetails>) JDOSecondaryPropertyUtils.decompressObject(X_STREAM, dbo.getClaims()));\n+\t\t} catch (IOException e) {\n+\t\t\tthrow new RuntimeException(e);\n+\t\t}\n+\t\tdto.setTokenId(dbo.getId().toString());\n+\t\tdto.setName(dbo.getName());\n+\t\tdto.setPrincipalId(dbo.getPrincipalId().toString());\n+\t\tdto.setClientId(dbo.getClientId().toString());\n+\t\t// Timestamp must be converted to Date for .equals to work on the DTO\n+\t\tdto.setAuthorizedOn(new Date(dbo.getCreatedOn().getTime()));\n+\t\tdto.setModifiedOn(new Date(dbo.getModifiedOn().getTime()));\n+\t\tdto.setLastUsed(new Date(dbo.getLastUsed().getTime()));\n+\t\tdto.setEtag(dbo.getEtag());\n+\t\treturn dto;\n+\t}\n+\n+\t@MandatoryWriteTransaction\n+\t@Override\n+\tpublic void updateTokenHash(String tokenId, String newHash) {\n+\t\tValidateArgument.required(tokenId, \"Token ID\");\n+\t\tValidateArgument.required(newHash, \"Token hash\");\n+\n+\t\t// Currently, the only mutable fields are NAME, ETAG, MODIFIED_ON\n+\t\tMapSqlParameterSource params = new MapSqlParameterSource();\n+\t\tparams.addValue(PARAM_TOKEN_HASH, newHash);\n+\t\tparams.addValue(PARAM_ETAG, UUID.randomUUID().toString());\n+\t\tparams.addValue(PARAM_LAST_USED, new Date());\n+\t\tparams.addValue(PARAM_TOKEN_ID, tokenId);\n+\t\tnamedParameterJdbcTemplate.update(UPDATE_REFRESH_TOKEN_HASH, params);\n+\t}\n+\n+\t@MandatoryWriteTransaction\n+\t@Override\n+\tpublic Optional<OAuthRefreshTokenInformation> getMatchingTokenByHashForUpdate(String hash, String clientId) {\n+\t\tValidateArgument.required(hash, \"token hash\");\n+\t\tValidateArgument.required(clientId, \"clientId\");\n+\t\tMapSqlParameterSource params = new MapSqlParameterSource();\n+\t\tparams.addValue(PARAM_TOKEN_HASH, hash);\n+\t\tparams.addValue(PARAM_CLIENT_ID, clientId);\n+\t\tOptional<DBOOAuthRefreshToken> dbo = Optional.ofNullable(namedParameterJdbcTemplate.queryForObject(SELECT_TOKEN_BY_HASH_FOR_UPDATE, params, (new DBOOAuthRefreshToken()).getTableMapping()));\n+\t\treturn dbo.map(OAuthRefreshTokenDaoImpl::refreshTokenDboToDto);\n+\t}\n+\n+\t@Override\n+\tpublic Optional<OAuthRefreshTokenInformation> getRefreshTokenMetadata(String tokenId) {\n+\t\tSinglePrimaryKeySqlParameterSource params = new SinglePrimaryKeySqlParameterSource(tokenId);\n+\t\treturn basicDao.getObjectByPrimaryKeyIfExists(DBOOAuthRefreshToken.class, params)\n+\t\t\t\t.map(OAuthRefreshTokenDaoImpl::refreshTokenDboToDto);\n+\t}\n+\n+\t@WriteTransaction\n+\t@Override\n+\tpublic OAuthRefreshTokenInformation createRefreshToken(String hashedToken, OAuthRefreshTokenInformation metadata) {\n+\t\tValidateArgument.required(metadata.getName(), \"Token Name\");\n+\t\tValidateArgument.required(metadata.getClientId(), \"Client ID\");\n+\t\tValidateArgument.required(metadata.getPrincipalId(), \"Principal ID\");\n+\t\tValidateArgument.required(metadata.getScopes(), \"Scope\");\n+\t\tValidateArgument.required(metadata.getClaims(), \"Claims\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bd558fd726cf88547bf5fe77053ecca833639788"}, "originalPosition": 182}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDgxNzg1MA==", "bodyText": "too much indentation!", "url": "https://github.com/Sage-Bionetworks/Synapse-Repository-Services/pull/4057#discussion_r434817850", "createdAt": "2020-06-03T19:55:19Z", "author": {"login": "brucehoff"}, "path": "lib/jdomodels/src/main/java/org/sagebionetworks/repo/model/dbo/auth/OAuthRefreshTokenDaoImpl.java", "diffHunk": "@@ -0,0 +1,255 @@\n+package org.sagebionetworks.repo.model.dbo.auth;\n+\n+import static org.sagebionetworks.repo.model.query.jdo.SqlConstants.COL_OAUTH_REFRESH_TOKEN_CLIENT_ID;\n+import static org.sagebionetworks.repo.model.query.jdo.SqlConstants.COL_OAUTH_REFRESH_TOKEN_ETAG;\n+import static org.sagebionetworks.repo.model.query.jdo.SqlConstants.COL_OAUTH_REFRESH_TOKEN_HASH;\n+import static org.sagebionetworks.repo.model.query.jdo.SqlConstants.COL_OAUTH_REFRESH_TOKEN_ID;\n+import static org.sagebionetworks.repo.model.query.jdo.SqlConstants.COL_OAUTH_REFRESH_TOKEN_LAST_USED;\n+import static org.sagebionetworks.repo.model.query.jdo.SqlConstants.COL_OAUTH_REFRESH_TOKEN_MODIFIED_ON;\n+import static org.sagebionetworks.repo.model.query.jdo.SqlConstants.COL_OAUTH_REFRESH_TOKEN_NAME;\n+import static org.sagebionetworks.repo.model.query.jdo.SqlConstants.COL_OAUTH_REFRESH_TOKEN_PRINCIPAL_ID;\n+import static org.sagebionetworks.repo.model.query.jdo.SqlConstants.TABLE_OAUTH_REFRESH_TOKEN;\n+\n+import java.io.IOException;\n+import java.sql.Timestamp;\n+import java.util.Date;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.stream.Collectors;\n+\n+import org.sagebionetworks.ids.IdGenerator;\n+import org.sagebionetworks.ids.IdType;\n+import org.sagebionetworks.repo.model.NextPageToken;\n+import org.sagebionetworks.repo.model.UnmodifiableXStream;\n+import org.sagebionetworks.repo.model.auth.OAuthRefreshTokenDao;\n+import org.sagebionetworks.repo.model.dbo.DBOBasicDao;\n+import org.sagebionetworks.repo.model.dbo.SinglePrimaryKeySqlParameterSource;\n+import org.sagebionetworks.repo.model.dbo.persistence.DBOOAuthRefreshToken;\n+import org.sagebionetworks.repo.model.jdo.JDOSecondaryPropertyUtils;\n+import org.sagebionetworks.repo.model.oauth.OAuthRefreshTokenInformation;\n+import org.sagebionetworks.repo.model.oauth.OAuthRefreshTokenInformationList;\n+import org.sagebionetworks.repo.model.oauth.OAuthScope;\n+import org.sagebionetworks.repo.model.oauth.OIDCClaimsRequest;\n+import org.sagebionetworks.repo.transactions.MandatoryWriteTransaction;\n+import org.sagebionetworks.repo.transactions.WriteTransaction;\n+import org.sagebionetworks.util.ValidateArgument;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.jdbc.core.namedparam.MapSqlParameterSource;\n+import org.springframework.jdbc.core.namedparam.NamedParameterJdbcTemplate;\n+\n+public class OAuthRefreshTokenDaoImpl implements OAuthRefreshTokenDao {\n+\n+\tprivate static final String PARAM_TOKEN_HASH = \"tokenHash\";\n+\tprivate static final String PARAM_NAME = \"tokenName\";\n+\tprivate static final String PARAM_ETAG = \"etag\";\n+\tprivate static final String PARAM_MODIFIED_ON = \"modifiedOn\";\n+\tprivate static final String PARAM_LAST_USED = \"lastUsed\";\n+\tprivate static final String PARAM_TOKEN_ID = \"id\";\n+\tprivate static final String PARAM_PRINCIPAL_ID = \"principalId\";\n+\tprivate static final String PARAM_CLIENT_ID = \"clientId\";\n+\tprivate static final String PARAM_LIMIT = \"limitParam\";\n+\tprivate static final String PARAM_OFFSET = \"offsetParam\";\n+\tprivate static final String PARAM_DAYS = \"days\";\n+\n+\tprivate static final String UPDATE_REFRESH_TOKEN_METADATA = \"UPDATE \"+TABLE_OAUTH_REFRESH_TOKEN+\n+\t\t\t\" SET \"+\n+\t\t\tCOL_OAUTH_REFRESH_TOKEN_NAME+\" = :\" + PARAM_NAME + \", \"+\n+\t\t\tCOL_OAUTH_REFRESH_TOKEN_ETAG+\" = :\" + PARAM_ETAG + \", \" +\n+\t\t\tCOL_OAUTH_REFRESH_TOKEN_MODIFIED_ON + \" = :\"+ PARAM_MODIFIED_ON +\n+\t\t\t\" WHERE \"+ COL_OAUTH_REFRESH_TOKEN_ID+\" = :\" + PARAM_TOKEN_ID;\n+\n+\tprivate static final String UPDATE_REFRESH_TOKEN_HASH = \"UPDATE \"+TABLE_OAUTH_REFRESH_TOKEN+\n+\t\t\t\" SET \"+\n+\t\t\tCOL_OAUTH_REFRESH_TOKEN_HASH+\" = :\" + PARAM_TOKEN_HASH + \", \"+\n+\t\t\tCOL_OAUTH_REFRESH_TOKEN_LAST_USED + \" = :\"+ PARAM_LAST_USED + \", \" +\n+\t\t\tCOL_OAUTH_REFRESH_TOKEN_ETAG+\" = :\" + PARAM_ETAG +\n+\t\t\t\" WHERE \"+ COL_OAUTH_REFRESH_TOKEN_ID+\" = :\" + PARAM_TOKEN_ID;\n+\n+\tprivate static final String SELECT_TOKENS_FOR_CLIENT_AND_PRINCIPAL = \"SELECT * FROM \" + TABLE_OAUTH_REFRESH_TOKEN\n+\t\t\t+ \" WHERE \" + COL_OAUTH_REFRESH_TOKEN_PRINCIPAL_ID + \" = :\" + PARAM_PRINCIPAL_ID\n+\t\t\t+ \" AND \" + COL_OAUTH_REFRESH_TOKEN_CLIENT_ID + \" = :\" + PARAM_CLIENT_ID\n+\t\t\t+ \" AND \" + COL_OAUTH_REFRESH_TOKEN_LAST_USED +\n+\t\t\t\t\" > (NOW() - INTERVAL  :\" + PARAM_DAYS + \" DAY)\"\n+\t\t\t+ \" ORDER BY \" + COL_OAUTH_REFRESH_TOKEN_LAST_USED + \" DESC\"\n+\t\t\t+ \" LIMIT :\" + PARAM_LIMIT + \" OFFSET :\" + PARAM_OFFSET;\n+\n+\tprivate static final String SELECT_TOKEN_BY_HASH_FOR_UPDATE = \"SELECT * FROM \" + TABLE_OAUTH_REFRESH_TOKEN\n+\t\t\t+ \" WHERE \" + COL_OAUTH_REFRESH_TOKEN_HASH + \" = :\" + PARAM_TOKEN_HASH\n+\t\t\t+ \" AND \" + COL_OAUTH_REFRESH_TOKEN_CLIENT_ID + \" = :\" + PARAM_CLIENT_ID\n+\t\t\t+ \" FOR UPDATE\";\n+\n+\tprivate static final String DELETE_TOKEN_BY_ID = \"DELETE FROM \" + TABLE_OAUTH_REFRESH_TOKEN\n+\t\t\t+ \" WHERE \" + COL_OAUTH_REFRESH_TOKEN_ID + \" = :\" + PARAM_TOKEN_ID;\n+\n+\tprivate static final String DELETE_TOKEN_BY_CLIENT_USER_PAIR = \"DELETE FROM \" + TABLE_OAUTH_REFRESH_TOKEN\n+\t\t\t+ \" WHERE \" + COL_OAUTH_REFRESH_TOKEN_PRINCIPAL_ID + \" = :\" + PARAM_PRINCIPAL_ID\n+\t\t\t+ \" AND \" + COL_OAUTH_REFRESH_TOKEN_CLIENT_ID + \" = :\" + PARAM_CLIENT_ID;\n+\n+\t@Autowired\n+\tprivate DBOBasicDao basicDao;\n+\n+\t@Autowired\n+\tprivate IdGenerator idGenerator;\n+\n+\t@Autowired\n+\tprivate NamedParameterJdbcTemplate namedParameterJdbcTemplate;\n+\n+\t// We serialize explicitly chosen fields, not the entire DTO, so no need to omit fields in the builder\n+\tprivate static final UnmodifiableXStream X_STREAM = UnmodifiableXStream.builder().build();\n+\n+\tpublic static DBOOAuthRefreshToken refreshTokenDtoToDbo(OAuthRefreshTokenInformation dto) {\n+\t\tDBOOAuthRefreshToken dbo = new DBOOAuthRefreshToken();\n+\t\ttry {\n+\t\t\tdbo.setScopes(JDOSecondaryPropertyUtils.compressObject(X_STREAM, dto.getScopes()));\n+\t\t\tdbo.setClaims(JDOSecondaryPropertyUtils.compressObject(X_STREAM, dto.getClaims()));\n+\t\t} catch (IOException e) {\n+\t\t\tthrow new RuntimeException(e);\n+\t\t}\n+\t\tdbo.setId(Long.parseLong(dto.getTokenId()));\n+\t\tdbo.setName(dto.getName());\n+\t\tdbo.setPrincipalId(Long.parseLong(dto.getPrincipalId()));\n+\t\tdbo.setClientId(Long.parseLong(dto.getClientId()));\n+\t\tdbo.setCreatedOn(new Timestamp(dto.getAuthorizedOn().getTime()));\n+\t\tdbo.setModifiedOn(new Timestamp(dto.getModifiedOn().getTime()));\n+\t\tdbo.setLastUsed(new Timestamp(dto.getLastUsed().getTime()));\n+\t\tdbo.setEtag(dto.getEtag());\n+\t\treturn dbo;\n+\t}\n+\n+\tpublic static OAuthRefreshTokenInformation refreshTokenDboToDto(DBOOAuthRefreshToken dbo) {\n+\t\tOAuthRefreshTokenInformation dto = new OAuthRefreshTokenInformation();\n+\t\ttry {\n+\t\t\tdto.setScopes((List<OAuthScope>) JDOSecondaryPropertyUtils.decompressObject(X_STREAM, dbo.getScopes()));\n+\t\t\tdto.setClaims((OIDCClaimsRequest) JDOSecondaryPropertyUtils.decompressObject(X_STREAM, dbo.getClaims()));\n+\t\t} catch (IOException e) {\n+\t\t\tthrow new RuntimeException(e);\n+\t\t}\n+\t\tdto.setTokenId(dbo.getId().toString());\n+\t\tdto.setName(dbo.getName());\n+\t\tdto.setPrincipalId(dbo.getPrincipalId().toString());\n+\t\tdto.setClientId(dbo.getClientId().toString());\n+\t\t// Timestamp must be converted to Date for .equals to work on the DTO\n+\t\tdto.setAuthorizedOn(new Date(dbo.getCreatedOn().getTime()));\n+\t\tdto.setModifiedOn(new Date(dbo.getModifiedOn().getTime()));\n+\t\tdto.setLastUsed(new Date(dbo.getLastUsed().getTime()));\n+\t\tdto.setEtag(dbo.getEtag());\n+\t\treturn dto;\n+\t}\n+\n+\t@MandatoryWriteTransaction\n+\t@Override\n+\tpublic void updateTokenHash(OAuthRefreshTokenInformation tokenInformation, String newHash) {\n+\t\tValidateArgument.required(tokenInformation, \"token information\");\n+\t\tValidateArgument.required(tokenInformation.getTokenId(), \"Token ID\");\n+\t\tValidateArgument.required(tokenInformation.getEtag(), \"etag\");\n+\t\tValidateArgument.required(tokenInformation.getLastUsed(), \"Last used\");\n+\t\tValidateArgument.required(newHash, \"Token hash\");\n+\n+\t\tMapSqlParameterSource params = new MapSqlParameterSource();\n+\t\tparams.addValue(PARAM_TOKEN_HASH, newHash);\n+\t\tparams.addValue(PARAM_ETAG, tokenInformation.getEtag());\n+\t\tparams.addValue(PARAM_LAST_USED, tokenInformation.getLastUsed());\n+\t\tparams.addValue(PARAM_TOKEN_ID, tokenInformation.getTokenId());\n+\t\tnamedParameterJdbcTemplate.update(UPDATE_REFRESH_TOKEN_HASH, params);\n+\t}\n+\n+\t@MandatoryWriteTransaction\n+\t@Override\n+\tpublic Optional<OAuthRefreshTokenInformation> getMatchingTokenByHashForUpdate(String hash, String clientId) {\n+\t\tValidateArgument.required(hash, \"token hash\");\n+\t\tValidateArgument.required(clientId, \"clientId\");\n+\t\tMapSqlParameterSource params = new MapSqlParameterSource();\n+\t\tparams.addValue(PARAM_TOKEN_HASH, hash);\n+\t\tparams.addValue(PARAM_CLIENT_ID, clientId);\n+\t\tOptional<DBOOAuthRefreshToken> dbo = Optional.ofNullable(namedParameterJdbcTemplate.queryForObject(SELECT_TOKEN_BY_HASH_FOR_UPDATE, params, (new DBOOAuthRefreshToken()).getTableMapping()));\n+\t\treturn dbo.map(OAuthRefreshTokenDaoImpl::refreshTokenDboToDto);\n+\t}\n+\n+\t@Override\n+\tpublic Optional<OAuthRefreshTokenInformation> getRefreshTokenMetadata(String tokenId) {\n+\t\tSinglePrimaryKeySqlParameterSource params = new SinglePrimaryKeySqlParameterSource(tokenId);\n+\t\treturn basicDao.getObjectByPrimaryKeyIfExists(DBOOAuthRefreshToken.class, params)\n+\t\t\t\t.map(OAuthRefreshTokenDaoImpl::refreshTokenDboToDto);\n+\t}\n+\n+\t@WriteTransaction\n+\t@Override\n+\tpublic OAuthRefreshTokenInformation createRefreshToken(String hashedToken, OAuthRefreshTokenInformation metadata) {\n+\t\tValidateArgument.required(metadata.getName(), \"Token Name\");\n+\t\tValidateArgument.required(metadata.getClientId(), \"Client ID\");\n+\t\tValidateArgument.required(metadata.getPrincipalId(), \"Principal ID\");\n+\t\tValidateArgument.required(metadata.getScopes(), \"Scope\");\n+\t\tValidateArgument.required(metadata.getClaims(), \"Claims\");\n+\t\tValidateArgument.required(metadata.getAuthorizedOn(), \"Authorized On\");\n+\t\tValidateArgument.required(metadata.getLastUsed(), \"Last Used\");\n+\t\tValidateArgument.required(metadata.getModifiedOn(), \"Modified On\");\n+\t\tValidateArgument.required(metadata.getEtag(), \"eTag\");\n+\t\tmetadata.setTokenId(idGenerator.generateNewId(IdType.OAUTH_REFRESH_TOKEN_ID).toString());\n+\t\tDBOOAuthRefreshToken dbo = refreshTokenDtoToDbo(metadata);\n+\t\tdbo.setTokenHash(hashedToken);\n+\t\tbasicDao.createNew(dbo);\n+\t\treturn this.getRefreshTokenMetadata(dbo.getId().toString()).get();\n+\t}\n+\n+\t@WriteTransaction\n+\t@Override\n+\tpublic void updateRefreshTokenMetadata(OAuthRefreshTokenInformation metadata) {\n+\t\tValidateArgument.required(metadata, \"Refresh token metadata\");\n+\t\tValidateArgument.required(metadata.getTokenId(), \"Token ID\");\n+\t\tValidateArgument.required(metadata.getName(), \"Token name\");\n+\t\tValidateArgument.required(metadata.getEtag(), \"eTag\");\n+\n+\t\t// Currently, the only mutable fields are NAME, ETAG, MODIFIED_ON\n+\t\tMapSqlParameterSource params = new MapSqlParameterSource();\n+\t\tparams.addValue(PARAM_NAME, metadata.getName());\n+\t\tparams.addValue(PARAM_ETAG, metadata.getEtag());\n+\t\tparams.addValue(PARAM_MODIFIED_ON, metadata.getModifiedOn());\n+\t\tparams.addValue(PARAM_TOKEN_ID, metadata.getTokenId());\n+\t\tnamedParameterJdbcTemplate.update(UPDATE_REFRESH_TOKEN_METADATA, params);\n+\t}\n+\n+\t@Override\n+\tpublic OAuthRefreshTokenInformationList getActiveTokenInformation(String userId,\n+\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t  String clientId,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e4a95ff405a34d424f05079f6eb9d9aecc8adcef"}, "originalPosition": 213}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDgxODYxNQ==", "bodyText": "you might define a static variable:\nprivate static final TABLE_MAPPING = (new DBOOAuthRefreshToken()).getTableMapping());\nso you don't have to instantiate one for each invocation.", "url": "https://github.com/Sage-Bionetworks/Synapse-Repository-Services/pull/4057#discussion_r434818615", "createdAt": "2020-06-03T19:56:55Z", "author": {"login": "brucehoff"}, "path": "lib/jdomodels/src/main/java/org/sagebionetworks/repo/model/dbo/auth/OAuthRefreshTokenDaoImpl.java", "diffHunk": "@@ -0,0 +1,255 @@\n+package org.sagebionetworks.repo.model.dbo.auth;\n+\n+import static org.sagebionetworks.repo.model.query.jdo.SqlConstants.COL_OAUTH_REFRESH_TOKEN_CLIENT_ID;\n+import static org.sagebionetworks.repo.model.query.jdo.SqlConstants.COL_OAUTH_REFRESH_TOKEN_ETAG;\n+import static org.sagebionetworks.repo.model.query.jdo.SqlConstants.COL_OAUTH_REFRESH_TOKEN_HASH;\n+import static org.sagebionetworks.repo.model.query.jdo.SqlConstants.COL_OAUTH_REFRESH_TOKEN_ID;\n+import static org.sagebionetworks.repo.model.query.jdo.SqlConstants.COL_OAUTH_REFRESH_TOKEN_LAST_USED;\n+import static org.sagebionetworks.repo.model.query.jdo.SqlConstants.COL_OAUTH_REFRESH_TOKEN_MODIFIED_ON;\n+import static org.sagebionetworks.repo.model.query.jdo.SqlConstants.COL_OAUTH_REFRESH_TOKEN_NAME;\n+import static org.sagebionetworks.repo.model.query.jdo.SqlConstants.COL_OAUTH_REFRESH_TOKEN_PRINCIPAL_ID;\n+import static org.sagebionetworks.repo.model.query.jdo.SqlConstants.TABLE_OAUTH_REFRESH_TOKEN;\n+\n+import java.io.IOException;\n+import java.sql.Timestamp;\n+import java.util.Date;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.stream.Collectors;\n+\n+import org.sagebionetworks.ids.IdGenerator;\n+import org.sagebionetworks.ids.IdType;\n+import org.sagebionetworks.repo.model.NextPageToken;\n+import org.sagebionetworks.repo.model.UnmodifiableXStream;\n+import org.sagebionetworks.repo.model.auth.OAuthRefreshTokenDao;\n+import org.sagebionetworks.repo.model.dbo.DBOBasicDao;\n+import org.sagebionetworks.repo.model.dbo.SinglePrimaryKeySqlParameterSource;\n+import org.sagebionetworks.repo.model.dbo.persistence.DBOOAuthRefreshToken;\n+import org.sagebionetworks.repo.model.jdo.JDOSecondaryPropertyUtils;\n+import org.sagebionetworks.repo.model.oauth.OAuthRefreshTokenInformation;\n+import org.sagebionetworks.repo.model.oauth.OAuthRefreshTokenInformationList;\n+import org.sagebionetworks.repo.model.oauth.OAuthScope;\n+import org.sagebionetworks.repo.model.oauth.OIDCClaimsRequest;\n+import org.sagebionetworks.repo.transactions.MandatoryWriteTransaction;\n+import org.sagebionetworks.repo.transactions.WriteTransaction;\n+import org.sagebionetworks.util.ValidateArgument;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.jdbc.core.namedparam.MapSqlParameterSource;\n+import org.springframework.jdbc.core.namedparam.NamedParameterJdbcTemplate;\n+\n+public class OAuthRefreshTokenDaoImpl implements OAuthRefreshTokenDao {\n+\n+\tprivate static final String PARAM_TOKEN_HASH = \"tokenHash\";\n+\tprivate static final String PARAM_NAME = \"tokenName\";\n+\tprivate static final String PARAM_ETAG = \"etag\";\n+\tprivate static final String PARAM_MODIFIED_ON = \"modifiedOn\";\n+\tprivate static final String PARAM_LAST_USED = \"lastUsed\";\n+\tprivate static final String PARAM_TOKEN_ID = \"id\";\n+\tprivate static final String PARAM_PRINCIPAL_ID = \"principalId\";\n+\tprivate static final String PARAM_CLIENT_ID = \"clientId\";\n+\tprivate static final String PARAM_LIMIT = \"limitParam\";\n+\tprivate static final String PARAM_OFFSET = \"offsetParam\";\n+\tprivate static final String PARAM_DAYS = \"days\";\n+\n+\tprivate static final String UPDATE_REFRESH_TOKEN_METADATA = \"UPDATE \"+TABLE_OAUTH_REFRESH_TOKEN+\n+\t\t\t\" SET \"+\n+\t\t\tCOL_OAUTH_REFRESH_TOKEN_NAME+\" = :\" + PARAM_NAME + \", \"+\n+\t\t\tCOL_OAUTH_REFRESH_TOKEN_ETAG+\" = :\" + PARAM_ETAG + \", \" +\n+\t\t\tCOL_OAUTH_REFRESH_TOKEN_MODIFIED_ON + \" = :\"+ PARAM_MODIFIED_ON +\n+\t\t\t\" WHERE \"+ COL_OAUTH_REFRESH_TOKEN_ID+\" = :\" + PARAM_TOKEN_ID;\n+\n+\tprivate static final String UPDATE_REFRESH_TOKEN_HASH = \"UPDATE \"+TABLE_OAUTH_REFRESH_TOKEN+\n+\t\t\t\" SET \"+\n+\t\t\tCOL_OAUTH_REFRESH_TOKEN_HASH+\" = :\" + PARAM_TOKEN_HASH + \", \"+\n+\t\t\tCOL_OAUTH_REFRESH_TOKEN_LAST_USED + \" = :\"+ PARAM_LAST_USED + \", \" +\n+\t\t\tCOL_OAUTH_REFRESH_TOKEN_ETAG+\" = :\" + PARAM_ETAG +\n+\t\t\t\" WHERE \"+ COL_OAUTH_REFRESH_TOKEN_ID+\" = :\" + PARAM_TOKEN_ID;\n+\n+\tprivate static final String SELECT_TOKENS_FOR_CLIENT_AND_PRINCIPAL = \"SELECT * FROM \" + TABLE_OAUTH_REFRESH_TOKEN\n+\t\t\t+ \" WHERE \" + COL_OAUTH_REFRESH_TOKEN_PRINCIPAL_ID + \" = :\" + PARAM_PRINCIPAL_ID\n+\t\t\t+ \" AND \" + COL_OAUTH_REFRESH_TOKEN_CLIENT_ID + \" = :\" + PARAM_CLIENT_ID\n+\t\t\t+ \" AND \" + COL_OAUTH_REFRESH_TOKEN_LAST_USED +\n+\t\t\t\t\" > (NOW() - INTERVAL  :\" + PARAM_DAYS + \" DAY)\"\n+\t\t\t+ \" ORDER BY \" + COL_OAUTH_REFRESH_TOKEN_LAST_USED + \" DESC\"\n+\t\t\t+ \" LIMIT :\" + PARAM_LIMIT + \" OFFSET :\" + PARAM_OFFSET;\n+\n+\tprivate static final String SELECT_TOKEN_BY_HASH_FOR_UPDATE = \"SELECT * FROM \" + TABLE_OAUTH_REFRESH_TOKEN\n+\t\t\t+ \" WHERE \" + COL_OAUTH_REFRESH_TOKEN_HASH + \" = :\" + PARAM_TOKEN_HASH\n+\t\t\t+ \" AND \" + COL_OAUTH_REFRESH_TOKEN_CLIENT_ID + \" = :\" + PARAM_CLIENT_ID\n+\t\t\t+ \" FOR UPDATE\";\n+\n+\tprivate static final String DELETE_TOKEN_BY_ID = \"DELETE FROM \" + TABLE_OAUTH_REFRESH_TOKEN\n+\t\t\t+ \" WHERE \" + COL_OAUTH_REFRESH_TOKEN_ID + \" = :\" + PARAM_TOKEN_ID;\n+\n+\tprivate static final String DELETE_TOKEN_BY_CLIENT_USER_PAIR = \"DELETE FROM \" + TABLE_OAUTH_REFRESH_TOKEN\n+\t\t\t+ \" WHERE \" + COL_OAUTH_REFRESH_TOKEN_PRINCIPAL_ID + \" = :\" + PARAM_PRINCIPAL_ID\n+\t\t\t+ \" AND \" + COL_OAUTH_REFRESH_TOKEN_CLIENT_ID + \" = :\" + PARAM_CLIENT_ID;\n+\n+\t@Autowired\n+\tprivate DBOBasicDao basicDao;\n+\n+\t@Autowired\n+\tprivate IdGenerator idGenerator;\n+\n+\t@Autowired\n+\tprivate NamedParameterJdbcTemplate namedParameterJdbcTemplate;\n+\n+\t// We serialize explicitly chosen fields, not the entire DTO, so no need to omit fields in the builder\n+\tprivate static final UnmodifiableXStream X_STREAM = UnmodifiableXStream.builder().build();\n+\n+\tpublic static DBOOAuthRefreshToken refreshTokenDtoToDbo(OAuthRefreshTokenInformation dto) {\n+\t\tDBOOAuthRefreshToken dbo = new DBOOAuthRefreshToken();\n+\t\ttry {\n+\t\t\tdbo.setScopes(JDOSecondaryPropertyUtils.compressObject(X_STREAM, dto.getScopes()));\n+\t\t\tdbo.setClaims(JDOSecondaryPropertyUtils.compressObject(X_STREAM, dto.getClaims()));\n+\t\t} catch (IOException e) {\n+\t\t\tthrow new RuntimeException(e);\n+\t\t}\n+\t\tdbo.setId(Long.parseLong(dto.getTokenId()));\n+\t\tdbo.setName(dto.getName());\n+\t\tdbo.setPrincipalId(Long.parseLong(dto.getPrincipalId()));\n+\t\tdbo.setClientId(Long.parseLong(dto.getClientId()));\n+\t\tdbo.setCreatedOn(new Timestamp(dto.getAuthorizedOn().getTime()));\n+\t\tdbo.setModifiedOn(new Timestamp(dto.getModifiedOn().getTime()));\n+\t\tdbo.setLastUsed(new Timestamp(dto.getLastUsed().getTime()));\n+\t\tdbo.setEtag(dto.getEtag());\n+\t\treturn dbo;\n+\t}\n+\n+\tpublic static OAuthRefreshTokenInformation refreshTokenDboToDto(DBOOAuthRefreshToken dbo) {\n+\t\tOAuthRefreshTokenInformation dto = new OAuthRefreshTokenInformation();\n+\t\ttry {\n+\t\t\tdto.setScopes((List<OAuthScope>) JDOSecondaryPropertyUtils.decompressObject(X_STREAM, dbo.getScopes()));\n+\t\t\tdto.setClaims((OIDCClaimsRequest) JDOSecondaryPropertyUtils.decompressObject(X_STREAM, dbo.getClaims()));\n+\t\t} catch (IOException e) {\n+\t\t\tthrow new RuntimeException(e);\n+\t\t}\n+\t\tdto.setTokenId(dbo.getId().toString());\n+\t\tdto.setName(dbo.getName());\n+\t\tdto.setPrincipalId(dbo.getPrincipalId().toString());\n+\t\tdto.setClientId(dbo.getClientId().toString());\n+\t\t// Timestamp must be converted to Date for .equals to work on the DTO\n+\t\tdto.setAuthorizedOn(new Date(dbo.getCreatedOn().getTime()));\n+\t\tdto.setModifiedOn(new Date(dbo.getModifiedOn().getTime()));\n+\t\tdto.setLastUsed(new Date(dbo.getLastUsed().getTime()));\n+\t\tdto.setEtag(dbo.getEtag());\n+\t\treturn dto;\n+\t}\n+\n+\t@MandatoryWriteTransaction\n+\t@Override\n+\tpublic void updateTokenHash(OAuthRefreshTokenInformation tokenInformation, String newHash) {\n+\t\tValidateArgument.required(tokenInformation, \"token information\");\n+\t\tValidateArgument.required(tokenInformation.getTokenId(), \"Token ID\");\n+\t\tValidateArgument.required(tokenInformation.getEtag(), \"etag\");\n+\t\tValidateArgument.required(tokenInformation.getLastUsed(), \"Last used\");\n+\t\tValidateArgument.required(newHash, \"Token hash\");\n+\n+\t\tMapSqlParameterSource params = new MapSqlParameterSource();\n+\t\tparams.addValue(PARAM_TOKEN_HASH, newHash);\n+\t\tparams.addValue(PARAM_ETAG, tokenInformation.getEtag());\n+\t\tparams.addValue(PARAM_LAST_USED, tokenInformation.getLastUsed());\n+\t\tparams.addValue(PARAM_TOKEN_ID, tokenInformation.getTokenId());\n+\t\tnamedParameterJdbcTemplate.update(UPDATE_REFRESH_TOKEN_HASH, params);\n+\t}\n+\n+\t@MandatoryWriteTransaction\n+\t@Override\n+\tpublic Optional<OAuthRefreshTokenInformation> getMatchingTokenByHashForUpdate(String hash, String clientId) {\n+\t\tValidateArgument.required(hash, \"token hash\");\n+\t\tValidateArgument.required(clientId, \"clientId\");\n+\t\tMapSqlParameterSource params = new MapSqlParameterSource();\n+\t\tparams.addValue(PARAM_TOKEN_HASH, hash);\n+\t\tparams.addValue(PARAM_CLIENT_ID, clientId);\n+\t\tOptional<DBOOAuthRefreshToken> dbo = Optional.ofNullable(namedParameterJdbcTemplate.queryForObject(SELECT_TOKEN_BY_HASH_FOR_UPDATE, params, (new DBOOAuthRefreshToken()).getTableMapping()));\n+\t\treturn dbo.map(OAuthRefreshTokenDaoImpl::refreshTokenDboToDto);\n+\t}\n+\n+\t@Override\n+\tpublic Optional<OAuthRefreshTokenInformation> getRefreshTokenMetadata(String tokenId) {\n+\t\tSinglePrimaryKeySqlParameterSource params = new SinglePrimaryKeySqlParameterSource(tokenId);\n+\t\treturn basicDao.getObjectByPrimaryKeyIfExists(DBOOAuthRefreshToken.class, params)\n+\t\t\t\t.map(OAuthRefreshTokenDaoImpl::refreshTokenDboToDto);\n+\t}\n+\n+\t@WriteTransaction\n+\t@Override\n+\tpublic OAuthRefreshTokenInformation createRefreshToken(String hashedToken, OAuthRefreshTokenInformation metadata) {\n+\t\tValidateArgument.required(metadata.getName(), \"Token Name\");\n+\t\tValidateArgument.required(metadata.getClientId(), \"Client ID\");\n+\t\tValidateArgument.required(metadata.getPrincipalId(), \"Principal ID\");\n+\t\tValidateArgument.required(metadata.getScopes(), \"Scope\");\n+\t\tValidateArgument.required(metadata.getClaims(), \"Claims\");\n+\t\tValidateArgument.required(metadata.getAuthorizedOn(), \"Authorized On\");\n+\t\tValidateArgument.required(metadata.getLastUsed(), \"Last Used\");\n+\t\tValidateArgument.required(metadata.getModifiedOn(), \"Modified On\");\n+\t\tValidateArgument.required(metadata.getEtag(), \"eTag\");\n+\t\tmetadata.setTokenId(idGenerator.generateNewId(IdType.OAUTH_REFRESH_TOKEN_ID).toString());\n+\t\tDBOOAuthRefreshToken dbo = refreshTokenDtoToDbo(metadata);\n+\t\tdbo.setTokenHash(hashedToken);\n+\t\tbasicDao.createNew(dbo);\n+\t\treturn this.getRefreshTokenMetadata(dbo.getId().toString()).get();\n+\t}\n+\n+\t@WriteTransaction\n+\t@Override\n+\tpublic void updateRefreshTokenMetadata(OAuthRefreshTokenInformation metadata) {\n+\t\tValidateArgument.required(metadata, \"Refresh token metadata\");\n+\t\tValidateArgument.required(metadata.getTokenId(), \"Token ID\");\n+\t\tValidateArgument.required(metadata.getName(), \"Token name\");\n+\t\tValidateArgument.required(metadata.getEtag(), \"eTag\");\n+\n+\t\t// Currently, the only mutable fields are NAME, ETAG, MODIFIED_ON\n+\t\tMapSqlParameterSource params = new MapSqlParameterSource();\n+\t\tparams.addValue(PARAM_NAME, metadata.getName());\n+\t\tparams.addValue(PARAM_ETAG, metadata.getEtag());\n+\t\tparams.addValue(PARAM_MODIFIED_ON, metadata.getModifiedOn());\n+\t\tparams.addValue(PARAM_TOKEN_ID, metadata.getTokenId());\n+\t\tnamedParameterJdbcTemplate.update(UPDATE_REFRESH_TOKEN_METADATA, params);\n+\t}\n+\n+\t@Override\n+\tpublic OAuthRefreshTokenInformationList getActiveTokenInformation(String userId,\n+\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t  String clientId,\n+\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t  String nextPageToken,\n+\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t  Long maxLeaseLengthInDays) {\n+\t\tNextPageToken nextPage = new NextPageToken(nextPageToken);\n+\t\tMapSqlParameterSource params = new MapSqlParameterSource();\n+\t\tparams.addValue(PARAM_PRINCIPAL_ID, userId);\n+\t\tparams.addValue(PARAM_CLIENT_ID, clientId);\n+\t\tparams.addValue(PARAM_LIMIT, nextPage.getLimitForQuery());\n+\t\tparams.addValue(PARAM_OFFSET, nextPage.getOffset());\n+\t\tparams.addValue(PARAM_DAYS, maxLeaseLengthInDays);\n+\n+\t\tList<DBOOAuthRefreshToken> tokenDbos = namedParameterJdbcTemplate.query(\n+\t\t\t\tSELECT_TOKENS_FOR_CLIENT_AND_PRINCIPAL, params, (new DBOOAuthRefreshToken()).getTableMapping());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e4a95ff405a34d424f05079f6eb9d9aecc8adcef"}, "originalPosition": 225}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDgxODc4Ng==", "bodyText": "too much indentation", "url": "https://github.com/Sage-Bionetworks/Synapse-Repository-Services/pull/4057#discussion_r434818786", "createdAt": "2020-06-03T19:57:16Z", "author": {"login": "brucehoff"}, "path": "lib/jdomodels/src/main/java/org/sagebionetworks/repo/model/dbo/auth/OAuthRefreshTokenDaoImpl.java", "diffHunk": "@@ -0,0 +1,255 @@\n+package org.sagebionetworks.repo.model.dbo.auth;\n+\n+import static org.sagebionetworks.repo.model.query.jdo.SqlConstants.COL_OAUTH_REFRESH_TOKEN_CLIENT_ID;\n+import static org.sagebionetworks.repo.model.query.jdo.SqlConstants.COL_OAUTH_REFRESH_TOKEN_ETAG;\n+import static org.sagebionetworks.repo.model.query.jdo.SqlConstants.COL_OAUTH_REFRESH_TOKEN_HASH;\n+import static org.sagebionetworks.repo.model.query.jdo.SqlConstants.COL_OAUTH_REFRESH_TOKEN_ID;\n+import static org.sagebionetworks.repo.model.query.jdo.SqlConstants.COL_OAUTH_REFRESH_TOKEN_LAST_USED;\n+import static org.sagebionetworks.repo.model.query.jdo.SqlConstants.COL_OAUTH_REFRESH_TOKEN_MODIFIED_ON;\n+import static org.sagebionetworks.repo.model.query.jdo.SqlConstants.COL_OAUTH_REFRESH_TOKEN_NAME;\n+import static org.sagebionetworks.repo.model.query.jdo.SqlConstants.COL_OAUTH_REFRESH_TOKEN_PRINCIPAL_ID;\n+import static org.sagebionetworks.repo.model.query.jdo.SqlConstants.TABLE_OAUTH_REFRESH_TOKEN;\n+\n+import java.io.IOException;\n+import java.sql.Timestamp;\n+import java.util.Date;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.stream.Collectors;\n+\n+import org.sagebionetworks.ids.IdGenerator;\n+import org.sagebionetworks.ids.IdType;\n+import org.sagebionetworks.repo.model.NextPageToken;\n+import org.sagebionetworks.repo.model.UnmodifiableXStream;\n+import org.sagebionetworks.repo.model.auth.OAuthRefreshTokenDao;\n+import org.sagebionetworks.repo.model.dbo.DBOBasicDao;\n+import org.sagebionetworks.repo.model.dbo.SinglePrimaryKeySqlParameterSource;\n+import org.sagebionetworks.repo.model.dbo.persistence.DBOOAuthRefreshToken;\n+import org.sagebionetworks.repo.model.jdo.JDOSecondaryPropertyUtils;\n+import org.sagebionetworks.repo.model.oauth.OAuthRefreshTokenInformation;\n+import org.sagebionetworks.repo.model.oauth.OAuthRefreshTokenInformationList;\n+import org.sagebionetworks.repo.model.oauth.OAuthScope;\n+import org.sagebionetworks.repo.model.oauth.OIDCClaimsRequest;\n+import org.sagebionetworks.repo.transactions.MandatoryWriteTransaction;\n+import org.sagebionetworks.repo.transactions.WriteTransaction;\n+import org.sagebionetworks.util.ValidateArgument;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.jdbc.core.namedparam.MapSqlParameterSource;\n+import org.springframework.jdbc.core.namedparam.NamedParameterJdbcTemplate;\n+\n+public class OAuthRefreshTokenDaoImpl implements OAuthRefreshTokenDao {\n+\n+\tprivate static final String PARAM_TOKEN_HASH = \"tokenHash\";\n+\tprivate static final String PARAM_NAME = \"tokenName\";\n+\tprivate static final String PARAM_ETAG = \"etag\";\n+\tprivate static final String PARAM_MODIFIED_ON = \"modifiedOn\";\n+\tprivate static final String PARAM_LAST_USED = \"lastUsed\";\n+\tprivate static final String PARAM_TOKEN_ID = \"id\";\n+\tprivate static final String PARAM_PRINCIPAL_ID = \"principalId\";\n+\tprivate static final String PARAM_CLIENT_ID = \"clientId\";\n+\tprivate static final String PARAM_LIMIT = \"limitParam\";\n+\tprivate static final String PARAM_OFFSET = \"offsetParam\";\n+\tprivate static final String PARAM_DAYS = \"days\";\n+\n+\tprivate static final String UPDATE_REFRESH_TOKEN_METADATA = \"UPDATE \"+TABLE_OAUTH_REFRESH_TOKEN+\n+\t\t\t\" SET \"+\n+\t\t\tCOL_OAUTH_REFRESH_TOKEN_NAME+\" = :\" + PARAM_NAME + \", \"+\n+\t\t\tCOL_OAUTH_REFRESH_TOKEN_ETAG+\" = :\" + PARAM_ETAG + \", \" +\n+\t\t\tCOL_OAUTH_REFRESH_TOKEN_MODIFIED_ON + \" = :\"+ PARAM_MODIFIED_ON +\n+\t\t\t\" WHERE \"+ COL_OAUTH_REFRESH_TOKEN_ID+\" = :\" + PARAM_TOKEN_ID;\n+\n+\tprivate static final String UPDATE_REFRESH_TOKEN_HASH = \"UPDATE \"+TABLE_OAUTH_REFRESH_TOKEN+\n+\t\t\t\" SET \"+\n+\t\t\tCOL_OAUTH_REFRESH_TOKEN_HASH+\" = :\" + PARAM_TOKEN_HASH + \", \"+\n+\t\t\tCOL_OAUTH_REFRESH_TOKEN_LAST_USED + \" = :\"+ PARAM_LAST_USED + \", \" +\n+\t\t\tCOL_OAUTH_REFRESH_TOKEN_ETAG+\" = :\" + PARAM_ETAG +\n+\t\t\t\" WHERE \"+ COL_OAUTH_REFRESH_TOKEN_ID+\" = :\" + PARAM_TOKEN_ID;\n+\n+\tprivate static final String SELECT_TOKENS_FOR_CLIENT_AND_PRINCIPAL = \"SELECT * FROM \" + TABLE_OAUTH_REFRESH_TOKEN\n+\t\t\t+ \" WHERE \" + COL_OAUTH_REFRESH_TOKEN_PRINCIPAL_ID + \" = :\" + PARAM_PRINCIPAL_ID\n+\t\t\t+ \" AND \" + COL_OAUTH_REFRESH_TOKEN_CLIENT_ID + \" = :\" + PARAM_CLIENT_ID\n+\t\t\t+ \" AND \" + COL_OAUTH_REFRESH_TOKEN_LAST_USED +\n+\t\t\t\t\" > (NOW() - INTERVAL  :\" + PARAM_DAYS + \" DAY)\"\n+\t\t\t+ \" ORDER BY \" + COL_OAUTH_REFRESH_TOKEN_LAST_USED + \" DESC\"\n+\t\t\t+ \" LIMIT :\" + PARAM_LIMIT + \" OFFSET :\" + PARAM_OFFSET;\n+\n+\tprivate static final String SELECT_TOKEN_BY_HASH_FOR_UPDATE = \"SELECT * FROM \" + TABLE_OAUTH_REFRESH_TOKEN\n+\t\t\t+ \" WHERE \" + COL_OAUTH_REFRESH_TOKEN_HASH + \" = :\" + PARAM_TOKEN_HASH\n+\t\t\t+ \" AND \" + COL_OAUTH_REFRESH_TOKEN_CLIENT_ID + \" = :\" + PARAM_CLIENT_ID\n+\t\t\t+ \" FOR UPDATE\";\n+\n+\tprivate static final String DELETE_TOKEN_BY_ID = \"DELETE FROM \" + TABLE_OAUTH_REFRESH_TOKEN\n+\t\t\t+ \" WHERE \" + COL_OAUTH_REFRESH_TOKEN_ID + \" = :\" + PARAM_TOKEN_ID;\n+\n+\tprivate static final String DELETE_TOKEN_BY_CLIENT_USER_PAIR = \"DELETE FROM \" + TABLE_OAUTH_REFRESH_TOKEN\n+\t\t\t+ \" WHERE \" + COL_OAUTH_REFRESH_TOKEN_PRINCIPAL_ID + \" = :\" + PARAM_PRINCIPAL_ID\n+\t\t\t+ \" AND \" + COL_OAUTH_REFRESH_TOKEN_CLIENT_ID + \" = :\" + PARAM_CLIENT_ID;\n+\n+\t@Autowired\n+\tprivate DBOBasicDao basicDao;\n+\n+\t@Autowired\n+\tprivate IdGenerator idGenerator;\n+\n+\t@Autowired\n+\tprivate NamedParameterJdbcTemplate namedParameterJdbcTemplate;\n+\n+\t// We serialize explicitly chosen fields, not the entire DTO, so no need to omit fields in the builder\n+\tprivate static final UnmodifiableXStream X_STREAM = UnmodifiableXStream.builder().build();\n+\n+\tpublic static DBOOAuthRefreshToken refreshTokenDtoToDbo(OAuthRefreshTokenInformation dto) {\n+\t\tDBOOAuthRefreshToken dbo = new DBOOAuthRefreshToken();\n+\t\ttry {\n+\t\t\tdbo.setScopes(JDOSecondaryPropertyUtils.compressObject(X_STREAM, dto.getScopes()));\n+\t\t\tdbo.setClaims(JDOSecondaryPropertyUtils.compressObject(X_STREAM, dto.getClaims()));\n+\t\t} catch (IOException e) {\n+\t\t\tthrow new RuntimeException(e);\n+\t\t}\n+\t\tdbo.setId(Long.parseLong(dto.getTokenId()));\n+\t\tdbo.setName(dto.getName());\n+\t\tdbo.setPrincipalId(Long.parseLong(dto.getPrincipalId()));\n+\t\tdbo.setClientId(Long.parseLong(dto.getClientId()));\n+\t\tdbo.setCreatedOn(new Timestamp(dto.getAuthorizedOn().getTime()));\n+\t\tdbo.setModifiedOn(new Timestamp(dto.getModifiedOn().getTime()));\n+\t\tdbo.setLastUsed(new Timestamp(dto.getLastUsed().getTime()));\n+\t\tdbo.setEtag(dto.getEtag());\n+\t\treturn dbo;\n+\t}\n+\n+\tpublic static OAuthRefreshTokenInformation refreshTokenDboToDto(DBOOAuthRefreshToken dbo) {\n+\t\tOAuthRefreshTokenInformation dto = new OAuthRefreshTokenInformation();\n+\t\ttry {\n+\t\t\tdto.setScopes((List<OAuthScope>) JDOSecondaryPropertyUtils.decompressObject(X_STREAM, dbo.getScopes()));\n+\t\t\tdto.setClaims((OIDCClaimsRequest) JDOSecondaryPropertyUtils.decompressObject(X_STREAM, dbo.getClaims()));\n+\t\t} catch (IOException e) {\n+\t\t\tthrow new RuntimeException(e);\n+\t\t}\n+\t\tdto.setTokenId(dbo.getId().toString());\n+\t\tdto.setName(dbo.getName());\n+\t\tdto.setPrincipalId(dbo.getPrincipalId().toString());\n+\t\tdto.setClientId(dbo.getClientId().toString());\n+\t\t// Timestamp must be converted to Date for .equals to work on the DTO\n+\t\tdto.setAuthorizedOn(new Date(dbo.getCreatedOn().getTime()));\n+\t\tdto.setModifiedOn(new Date(dbo.getModifiedOn().getTime()));\n+\t\tdto.setLastUsed(new Date(dbo.getLastUsed().getTime()));\n+\t\tdto.setEtag(dbo.getEtag());\n+\t\treturn dto;\n+\t}\n+\n+\t@MandatoryWriteTransaction\n+\t@Override\n+\tpublic void updateTokenHash(OAuthRefreshTokenInformation tokenInformation, String newHash) {\n+\t\tValidateArgument.required(tokenInformation, \"token information\");\n+\t\tValidateArgument.required(tokenInformation.getTokenId(), \"Token ID\");\n+\t\tValidateArgument.required(tokenInformation.getEtag(), \"etag\");\n+\t\tValidateArgument.required(tokenInformation.getLastUsed(), \"Last used\");\n+\t\tValidateArgument.required(newHash, \"Token hash\");\n+\n+\t\tMapSqlParameterSource params = new MapSqlParameterSource();\n+\t\tparams.addValue(PARAM_TOKEN_HASH, newHash);\n+\t\tparams.addValue(PARAM_ETAG, tokenInformation.getEtag());\n+\t\tparams.addValue(PARAM_LAST_USED, tokenInformation.getLastUsed());\n+\t\tparams.addValue(PARAM_TOKEN_ID, tokenInformation.getTokenId());\n+\t\tnamedParameterJdbcTemplate.update(UPDATE_REFRESH_TOKEN_HASH, params);\n+\t}\n+\n+\t@MandatoryWriteTransaction\n+\t@Override\n+\tpublic Optional<OAuthRefreshTokenInformation> getMatchingTokenByHashForUpdate(String hash, String clientId) {\n+\t\tValidateArgument.required(hash, \"token hash\");\n+\t\tValidateArgument.required(clientId, \"clientId\");\n+\t\tMapSqlParameterSource params = new MapSqlParameterSource();\n+\t\tparams.addValue(PARAM_TOKEN_HASH, hash);\n+\t\tparams.addValue(PARAM_CLIENT_ID, clientId);\n+\t\tOptional<DBOOAuthRefreshToken> dbo = Optional.ofNullable(namedParameterJdbcTemplate.queryForObject(SELECT_TOKEN_BY_HASH_FOR_UPDATE, params, (new DBOOAuthRefreshToken()).getTableMapping()));\n+\t\treturn dbo.map(OAuthRefreshTokenDaoImpl::refreshTokenDboToDto);\n+\t}\n+\n+\t@Override\n+\tpublic Optional<OAuthRefreshTokenInformation> getRefreshTokenMetadata(String tokenId) {\n+\t\tSinglePrimaryKeySqlParameterSource params = new SinglePrimaryKeySqlParameterSource(tokenId);\n+\t\treturn basicDao.getObjectByPrimaryKeyIfExists(DBOOAuthRefreshToken.class, params)\n+\t\t\t\t.map(OAuthRefreshTokenDaoImpl::refreshTokenDboToDto);\n+\t}\n+\n+\t@WriteTransaction\n+\t@Override\n+\tpublic OAuthRefreshTokenInformation createRefreshToken(String hashedToken, OAuthRefreshTokenInformation metadata) {\n+\t\tValidateArgument.required(metadata.getName(), \"Token Name\");\n+\t\tValidateArgument.required(metadata.getClientId(), \"Client ID\");\n+\t\tValidateArgument.required(metadata.getPrincipalId(), \"Principal ID\");\n+\t\tValidateArgument.required(metadata.getScopes(), \"Scope\");\n+\t\tValidateArgument.required(metadata.getClaims(), \"Claims\");\n+\t\tValidateArgument.required(metadata.getAuthorizedOn(), \"Authorized On\");\n+\t\tValidateArgument.required(metadata.getLastUsed(), \"Last Used\");\n+\t\tValidateArgument.required(metadata.getModifiedOn(), \"Modified On\");\n+\t\tValidateArgument.required(metadata.getEtag(), \"eTag\");\n+\t\tmetadata.setTokenId(idGenerator.generateNewId(IdType.OAUTH_REFRESH_TOKEN_ID).toString());\n+\t\tDBOOAuthRefreshToken dbo = refreshTokenDtoToDbo(metadata);\n+\t\tdbo.setTokenHash(hashedToken);\n+\t\tbasicDao.createNew(dbo);\n+\t\treturn this.getRefreshTokenMetadata(dbo.getId().toString()).get();\n+\t}\n+\n+\t@WriteTransaction\n+\t@Override\n+\tpublic void updateRefreshTokenMetadata(OAuthRefreshTokenInformation metadata) {\n+\t\tValidateArgument.required(metadata, \"Refresh token metadata\");\n+\t\tValidateArgument.required(metadata.getTokenId(), \"Token ID\");\n+\t\tValidateArgument.required(metadata.getName(), \"Token name\");\n+\t\tValidateArgument.required(metadata.getEtag(), \"eTag\");\n+\n+\t\t// Currently, the only mutable fields are NAME, ETAG, MODIFIED_ON\n+\t\tMapSqlParameterSource params = new MapSqlParameterSource();\n+\t\tparams.addValue(PARAM_NAME, metadata.getName());\n+\t\tparams.addValue(PARAM_ETAG, metadata.getEtag());\n+\t\tparams.addValue(PARAM_MODIFIED_ON, metadata.getModifiedOn());\n+\t\tparams.addValue(PARAM_TOKEN_ID, metadata.getTokenId());\n+\t\tnamedParameterJdbcTemplate.update(UPDATE_REFRESH_TOKEN_METADATA, params);\n+\t}\n+\n+\t@Override\n+\tpublic OAuthRefreshTokenInformationList getActiveTokenInformation(String userId,\n+\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t  String clientId,\n+\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t  String nextPageToken,\n+\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t  Long maxLeaseLengthInDays) {\n+\t\tNextPageToken nextPage = new NextPageToken(nextPageToken);\n+\t\tMapSqlParameterSource params = new MapSqlParameterSource();\n+\t\tparams.addValue(PARAM_PRINCIPAL_ID, userId);\n+\t\tparams.addValue(PARAM_CLIENT_ID, clientId);\n+\t\tparams.addValue(PARAM_LIMIT, nextPage.getLimitForQuery());\n+\t\tparams.addValue(PARAM_OFFSET, nextPage.getOffset());\n+\t\tparams.addValue(PARAM_DAYS, maxLeaseLengthInDays);\n+\n+\t\tList<DBOOAuthRefreshToken> tokenDbos = namedParameterJdbcTemplate.query(\n+\t\t\t\tSELECT_TOKENS_FOR_CLIENT_AND_PRINCIPAL, params, (new DBOOAuthRefreshToken()).getTableMapping());\n+\t\tOAuthRefreshTokenInformationList result = new OAuthRefreshTokenInformationList();\n+\t\tresult.setNextPageToken(nextPage.getNextPageTokenForCurrentResults(tokenDbos));\n+\t\tresult.setResults(\n+\t\t\t\ttokenDbos.stream()\n+\t\t\t\t\t\t.map(OAuthRefreshTokenDaoImpl::refreshTokenDboToDto)\n+\t\t\t\t\t\t.collect(Collectors.toList())", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e4a95ff405a34d424f05079f6eb9d9aecc8adcef"}, "originalPosition": 231}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDgyNzY3OQ==", "bodyText": "you can omit 'links' and the service that uses this object should return ONLY the public client fields.", "url": "https://github.com/Sage-Bionetworks/Synapse-Repository-Services/pull/4057#discussion_r434827679", "createdAt": "2020-06-03T20:15:33Z", "author": {"login": "brucehoff"}, "path": "lib/lib-auto-generated/src/main/resources/schema/org/sagebionetworks/repo/model/oauth/OAuthClientAuthorizationHistory.json", "diffHunk": "@@ -0,0 +1,25 @@\n+{\n+    \"description\": \"An object representing an OAuth 2.0 client that has been authorized to request a user's resources and identity\",\n+ \t\"properties\": {\n+\t\t\"client\": {\n+\t\t\t\"$ref\": \"org.sagebionetworks.repo.model.oauth.OAuthClient\",\n+\t\t\t\"description\": \"The OAuth 2.0 client that has been granted access\",\n+\t\t\t\"links\": [", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e4a95ff405a34d424f05079f6eb9d9aecc8adcef"}, "originalPosition": 7}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDgzMDUzNg==", "bodyText": "OAuthClientHistory actualHistory1 = null;\nOAuthClientHistory actualHistory2 = null;\nfor (OAuthClientAuthorizationHistory result : results.getResults()) {\nif (result.getClient().getClient_id().equals(client1)) {\nactualHistory1 = result;\n} else if (result.getClient().getClient_id().equals(client2)) {\nactualHistory2 = result;\n} else {\nfail();\n}\n}\nassertEquals(client1ExpectedAuthzOn, actualHistory1.getAuthorizedOn());\n// + 3 more assertions", "url": "https://github.com/Sage-Bionetworks/Synapse-Repository-Services/pull/4057#discussion_r434830536", "createdAt": "2020-06-03T20:20:59Z", "author": {"login": "brucehoff"}, "path": "lib/jdomodels/src/test/java/org/sagebionetworks/repo/model/dbo/auth/OAuthClientDaoImplTest.java", "diffHunk": "@@ -476,4 +494,100 @@ public void testIsOauthClientVerified() throws Exception {\n \t\t\n \t}\n \n+\tprivate OAuthRefreshTokenInformation createRefreshToken(String clientId, String userId, Date authorizedOn, Date lastUsed) {\n+\t\tOAuthRefreshTokenInformation token = new OAuthRefreshTokenInformation();\n+\t\ttoken.setName(UUID.randomUUID().toString());\n+\t\ttoken.setClientId(clientId);\n+\t\ttoken.setPrincipalId(userId);\n+\t\ttoken.setScopes(Collections.singletonList(OAuthScope.view));\n+\t\ttoken.setClaims(new OIDCClaimsRequest());\n+\t\ttoken.setAuthorizedOn(authorizedOn);\n+\t\ttoken.setLastUsed(lastUsed);\n+\t\ttoken.setModifiedOn(new Date());\n+\t\ttoken.setEtag(UUID.randomUUID().toString());\n+\t\treturn oauthRefreshTokenDao.createRefreshToken(\"abcdef\", token);\n+\t}\n+\n+\t@Test\n+\tpublic void testGetAuthorizedClients() {\n+\t\tLong userId = BOOTSTRAP_PRINCIPAL.THE_ADMIN_USER.getPrincipalId();\n+\n+\t\tString client1 = createSectorIdentifierAndClient();\n+\t\tString client2 = createSectorIdentifierAndClient(SECOND_SECTOR_IDENTIFIER, userId, \"App 2\");\n+\n+\t\tfinal Date client1ExpectedAuthzOn = new Date(System.currentTimeMillis() - ONE_YEAR_MILLIS * 5);// Earliest authorized on date\n+\t\tfinal Date client1ExpectedLastUsed = new Date(System.currentTimeMillis() + ONE_YEAR_MILLIS * 5);// Latest last used date\n+\t\t// Valid tokens for client 1\n+\t\tcreateRefreshToken(client1, userId.toString(), client1ExpectedAuthzOn, new Date());\n+\t\tcreateRefreshToken(client1, userId.toString(), new Date(), new Date());\n+\t\tcreateRefreshToken(client1, userId.toString(), new Date(), client1ExpectedLastUsed);\n+\n+\t\t// Expired token for client 1. The dates are set up such that the result \"authorizedOn\" will not match if this token is not filtered.\n+\t\tcreateRefreshToken(client1, userId.toString(), new Date(System.currentTimeMillis() - ONE_YEAR_MILLIS * 10), new Date(System.currentTimeMillis() - TWO_YEARS_MILLIS));\n+\n+\t\t// Valid token for client 2\n+\t\tfinal Date client2ExpectedAuthzOn = new Date(System.currentTimeMillis() - 542326L);\n+\t\tfinal Date client2ExpectedLastUsed = new Date(System.currentTimeMillis() - 54232L);\n+\t\tcreateRefreshToken(client2, userId.toString(), client2ExpectedAuthzOn, client2ExpectedLastUsed);\n+\n+\t\t// Call under test\n+\t\tOAuthClientAuthorizationHistoryList results = oauthClientDao.getAuthorizedClientHistory(userId.toString(), null, ONE_YEAR_DAYS);\n+\n+\t\tassertEquals(2, results.getResults().size());\n+\n+\t\tfor (OAuthClientAuthorizationHistory result : results.getResults()) {\n+\t\t\tif (result.getClient().getClient_id().equals(client1)) {\n+\t\t\t\tassertEquals(client1ExpectedAuthzOn, result.getAuthorizedOn());\n+\t\t\t\tassertEquals(client1ExpectedLastUsed, result.getLastUsed());\n+\t\t\t}\n+\t\t\tif (result.getClient().getClient_id().equals(client2)) {\n+\t\t\t\tassertEquals(client2ExpectedAuthzOn, result.getAuthorizedOn());\n+\t\t\t\tassertEquals(client2ExpectedLastUsed, result.getLastUsed());\n+\t\t\t}\n+\t\t}\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e4a95ff405a34d424f05079f6eb9d9aecc8adcef"}, "originalPosition": 119}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDgzMzUwMg==", "bodyText": "consider making this a static method to avoid the chance of referring to object members.", "url": "https://github.com/Sage-Bionetworks/Synapse-Repository-Services/pull/4057#discussion_r434833502", "createdAt": "2020-06-03T20:26:40Z", "author": {"login": "brucehoff"}, "path": "lib/jdomodels/src/main/java/org/sagebionetworks/repo/model/dbo/persistence/DBOOAuthRefreshToken.java", "diffHunk": "@@ -0,0 +1,325 @@\n+package org.sagebionetworks.repo.model.dbo.persistence;\n+\n+import static org.sagebionetworks.repo.model.query.jdo.SqlConstants.COL_OAUTH_CLIENT_NAME;\n+import static org.sagebionetworks.repo.model.query.jdo.SqlConstants.COL_OAUTH_REFRESH_TOKEN_CLAIMS;\n+import static org.sagebionetworks.repo.model.query.jdo.SqlConstants.COL_OAUTH_REFRESH_TOKEN_CLIENT_ID;\n+import static org.sagebionetworks.repo.model.query.jdo.SqlConstants.COL_OAUTH_REFRESH_TOKEN_CREATED_ON;\n+import static org.sagebionetworks.repo.model.query.jdo.SqlConstants.COL_OAUTH_REFRESH_TOKEN_ETAG;\n+import static org.sagebionetworks.repo.model.query.jdo.SqlConstants.COL_OAUTH_REFRESH_TOKEN_HASH;\n+import static org.sagebionetworks.repo.model.query.jdo.SqlConstants.COL_OAUTH_REFRESH_TOKEN_ID;\n+import static org.sagebionetworks.repo.model.query.jdo.SqlConstants.COL_OAUTH_REFRESH_TOKEN_LAST_USED;\n+import static org.sagebionetworks.repo.model.query.jdo.SqlConstants.COL_OAUTH_REFRESH_TOKEN_MODIFIED_ON;\n+import static org.sagebionetworks.repo.model.query.jdo.SqlConstants.COL_OAUTH_REFRESH_TOKEN_NAME;\n+import static org.sagebionetworks.repo.model.query.jdo.SqlConstants.COL_OAUTH_REFRESH_TOKEN_PRINCIPAL_ID;\n+import static org.sagebionetworks.repo.model.query.jdo.SqlConstants.COL_OAUTH_REFRESH_TOKEN_SCOPES;\n+import static org.sagebionetworks.repo.model.query.jdo.SqlConstants.DDL_OAUTH_REFRESH_TOKEN;\n+import static org.sagebionetworks.repo.model.query.jdo.SqlConstants.TABLE_OAUTH_REFRESH_TOKEN;\n+\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.sql.Timestamp;\n+import java.util.Arrays;\n+import java.util.List;\n+\n+import org.sagebionetworks.repo.model.dbo.FieldColumn;\n+import org.sagebionetworks.repo.model.dbo.MigratableDatabaseObject;\n+import org.sagebionetworks.repo.model.dbo.TableMapping;\n+import org.sagebionetworks.repo.model.dbo.migration.BasicMigratableTableTranslation;\n+import org.sagebionetworks.repo.model.dbo.migration.MigratableTableTranslation;\n+import org.sagebionetworks.repo.model.migration.MigrationType;\n+\n+/**\n+ * Database object representing an OAuth 2.0 refresh token\n+ */\n+public class DBOOAuthRefreshToken implements MigratableDatabaseObject<DBOOAuthRefreshToken, DBOOAuthRefreshToken> {\n+\tprivate Long id;\n+\tprivate String tokenHash;\n+\tprivate String name;\n+\tprivate Long principalId;\n+\tprivate Long clientId;\n+\tprivate byte[] scopes;\n+\tprivate byte[] claims;\n+\tprivate Timestamp createdOn;\n+\tprivate Timestamp modifiedOn;\n+\tprivate Timestamp lastUsed;\n+\tprivate String etag;\n+\n+\tprivate static FieldColumn[] FIELDS = new FieldColumn[] {\n+\t\tnew FieldColumn(\"id\", COL_OAUTH_REFRESH_TOKEN_ID, true).withIsBackupId(true),\n+\t\t\tnew FieldColumn(\"tokenHash\", COL_OAUTH_REFRESH_TOKEN_HASH),\n+\t\t\tnew FieldColumn(\"name\", COL_OAUTH_REFRESH_TOKEN_NAME),\n+\t\t\tnew FieldColumn(\"principalId\", COL_OAUTH_REFRESH_TOKEN_PRINCIPAL_ID),\n+\t\t\tnew FieldColumn(\"clientId\", COL_OAUTH_REFRESH_TOKEN_CLIENT_ID),\n+\t\t\tnew FieldColumn(\"scopes\", COL_OAUTH_REFRESH_TOKEN_SCOPES),\n+\t\t\tnew FieldColumn(\"claims\", COL_OAUTH_REFRESH_TOKEN_CLAIMS),\n+\t\t\tnew FieldColumn(\"createdOn\", COL_OAUTH_REFRESH_TOKEN_CREATED_ON),\n+\t\t\tnew FieldColumn(\"modifiedOn\", COL_OAUTH_REFRESH_TOKEN_MODIFIED_ON),\n+\t\t\tnew FieldColumn(\"lastUsed\", COL_OAUTH_REFRESH_TOKEN_LAST_USED),\n+\t\t\tnew FieldColumn(\"etag\", COL_OAUTH_REFRESH_TOKEN_ETAG).withIsEtag(true),\n+\t\t};\n+\n+\t@Override\n+\tpublic TableMapping<DBOOAuthRefreshToken> getTableMapping() {\n+\t\treturn new TableMapping<DBOOAuthRefreshToken>() {\n+\t\t\t// Map a result set to this object", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e4a95ff405a34d424f05079f6eb9d9aecc8adcef"}, "originalPosition": 64}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDgzNzA0Nw==", "bodyText": "change everything that can be changed, incl modifiedOn, etag", "url": "https://github.com/Sage-Bionetworks/Synapse-Repository-Services/pull/4057#discussion_r434837047", "createdAt": "2020-06-03T20:33:44Z", "author": {"login": "brucehoff"}, "path": "lib/jdomodels/src/test/java/org/sagebionetworks/repo/model/dbo/auth/OAuthRefreshTokenDaoAutowiredTest.java", "diffHunk": "@@ -0,0 +1,395 @@\n+package org.sagebionetworks.repo.model.dbo.auth;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertNotEquals;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertNull;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+import java.sql.Timestamp;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.UUID;\n+\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.extension.ExtendWith;\n+import org.sagebionetworks.repo.model.AuthorizationConstants;\n+import org.sagebionetworks.repo.model.NextPageToken;\n+import org.sagebionetworks.repo.model.UnmodifiableXStream;\n+import org.sagebionetworks.repo.model.auth.OAuthClientDao;\n+import org.sagebionetworks.repo.model.auth.OAuthRefreshTokenDao;\n+import org.sagebionetworks.repo.model.auth.SectorIdentifier;\n+import org.sagebionetworks.repo.model.dbo.persistence.DBOOAuthRefreshToken;\n+import org.sagebionetworks.repo.model.jdo.JDOSecondaryPropertyUtils;\n+import org.sagebionetworks.repo.model.oauth.OAuthClient;\n+import org.sagebionetworks.repo.model.oauth.OAuthRefreshTokenInformation;\n+import org.sagebionetworks.repo.model.oauth.OAuthRefreshTokenInformationList;\n+import org.sagebionetworks.repo.model.oauth.OAuthScope;\n+import org.sagebionetworks.repo.model.oauth.OIDCClaimName;\n+import org.sagebionetworks.repo.model.oauth.OIDCClaimsRequest;\n+import org.sagebionetworks.repo.model.oauth.OIDCClaimsRequestDetails;\n+import org.sagebionetworks.repo.web.NotFoundException;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.test.context.ContextConfiguration;\n+import org.springframework.test.context.junit.jupiter.SpringExtension;\n+import org.springframework.transaction.IllegalTransactionStateException;\n+import org.springframework.transaction.annotation.Transactional;\n+\n+\n+@ExtendWith(SpringExtension.class)\n+@ContextConfiguration(locations = {\"classpath:jdomodels-test-context.xml\"})\n+public class OAuthRefreshTokenDaoAutowiredTest {\n+\n+\tprivate List<String> tokenIdsToDelete;\n+\tprivate List<String> clientIdsToDelete;\n+\tprivate List<String> sectorIdentifiersToDelete;\n+\tprivate OAuthClient client;\n+\n+\tprivate static final String CLIENT_NAME = \"An OAuth 2 Client\";\n+\tprivate static final String SECTOR_IDENTIFIER = \"https://foo.bar\";\n+\tprivate static final String SECTOR_IDENTIFIER_URI = \"https://client.uri.com/path/to/json/file\";\n+\n+\tprivate static final String userId = AuthorizationConstants.BOOTSTRAP_PRINCIPAL.THE_ADMIN_USER.getPrincipalId().toString();\n+\n+\tprivate static final UnmodifiableXStream X_STREAM = UnmodifiableXStream.builder().build();\n+\n+\tprivate static final Long ONE_HOUR_MILLIS = 1000L * 60 * 60;\n+\tprivate static final Long ONE_DAY_MILLIS = ONE_HOUR_MILLIS * 24;\n+\tprivate static final Long ONE_YEAR_MILLIS = ONE_DAY_MILLIS * 365;\n+\tprivate static final Long HALF_YEAR_DAYS = 180L;\n+\n+\t@Autowired\n+\tprivate OAuthRefreshTokenDao oauthRefreshTokenDao;\n+\n+\t@Autowired\n+\tprivate OAuthClientDao oauthClientDao;\n+\n+\tprivate OAuthClient createClient(String clientName, String sectorIdentifierUri) {\n+\t\tSectorIdentifier sectorIdentifier = new SectorIdentifier();\n+\t\tsectorIdentifier.setSectorIdentifierUri(sectorIdentifierUri);\n+\t\tsectorIdentifier.setSecret(UUID.randomUUID().toString());\n+\t\tsectorIdentifier.setCreatedBy(Long.valueOf(userId));\n+\t\tsectorIdentifier.setCreatedOn((new Date()).getTime());\n+\t\toauthClientDao.createSectorIdentifier(sectorIdentifier);\n+\n+\n+\t\tOAuthClient client = new OAuthClient();\n+\t\tclient.setClient_name(clientName);\n+\t\tclient.setCreatedBy(userId);\n+\t\tclient.setSector_identifier(sectorIdentifierUri);\n+\t\tclient.setSector_identifier_uri(SECTOR_IDENTIFIER_URI);\n+\t\tclient.setVerified(true);\n+\t\tclient.setEtag(UUID.randomUUID().toString());\n+\t\tclient = oauthClientDao.createOAuthClient(client);\n+\n+\t\tclientIdsToDelete.add(client.getClient_id());\n+\t\tsectorIdentifiersToDelete.add(sectorIdentifierUri);\n+\t\treturn client;\n+\t}\n+\n+\t@BeforeEach\n+\tpublic void beforeEach() {\n+\t\ttokenIdsToDelete = new ArrayList<>();\n+\t\tclientIdsToDelete = new ArrayList<>();\n+\t\tsectorIdentifiersToDelete = new ArrayList<>();\n+\n+\t\tclient = createClient(CLIENT_NAME, SECTOR_IDENTIFIER);\n+\n+\t\tassertNotNull(oauthRefreshTokenDao);\n+\t}\n+\n+\t@AfterEach\n+\tpublic void afterEach() {\n+\t\tfor (String id : clientIdsToDelete) {\n+\t\t\ttry {\n+\t\t\t\toauthClientDao.deleteOAuthClient(id);\n+\t\t\t} catch (NotFoundException e) {\n+\t\t\t\t// Ignore\n+\t\t\t}\n+\t\t}\n+\t\tfor (String sectorIdentifier : sectorIdentifiersToDelete) {\n+\t\t\ttry {\n+\t\t\t\toauthClientDao.deleteSectorIdentifer(sectorIdentifier);\n+\t\t\t} catch (NotFoundException e) {\n+\t\t\t\t// Ignore\n+\t\t\t\t}\n+\t\t}\n+\t\tfor (String id : tokenIdsToDelete) {\n+\t\t\ttry {\n+\t\t\t\toauthRefreshTokenDao.deleteToken(id);\n+\t\t\t} catch (NotFoundException e) {\n+\t\t\t\t// Ignore\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\tprivate OAuthRefreshTokenInformation createRefreshToken(String hash, Date lastUsedDate, String clientId, String userId) {\n+\t\tOAuthRefreshTokenInformation metadata = new OAuthRefreshTokenInformation();\n+\t\tmetadata.setName(UUID.randomUUID().toString());\n+\t\tmetadata.setPrincipalId(userId);\n+\t\tmetadata.setClientId(clientId);\n+\t\tmetadata.setScopes(Collections.singletonList(OAuthScope.view));\n+\t\tmetadata.setClaims(new OIDCClaimsRequest());\n+\t\tmetadata.setModifiedOn(new Date());\n+\t\tmetadata.setLastUsed(lastUsedDate);\n+\t\tmetadata.setAuthorizedOn(new Date());\n+\t\tmetadata.setEtag(UUID.randomUUID().toString());\n+\n+\t\tOAuthRefreshTokenInformation token = oauthRefreshTokenDao.createRefreshToken(hash, metadata);\n+\t\ttokenIdsToDelete.add(token.getTokenId());\n+\t\treturn token;\n+\t}\n+\n+\tprivate OAuthRefreshTokenInformation createRefreshToken(String clientId, String userId) {\n+\t\treturn createRefreshToken(\"abcdef\", new Date(), clientId, userId);\n+\t}\n+\n+\tprivate OAuthRefreshTokenInformation createRefreshToken(String hash, Date lastUsedDate) {\n+\t\treturn createRefreshToken(hash, lastUsedDate, client.getClient_id(), userId);\n+\t}\n+\n+\tprivate OAuthRefreshTokenInformation createRefreshToken(Date lastUsedDate) {\n+\t\treturn createRefreshToken(\"abcdef\", lastUsedDate);\n+\t}\n+\n+\tprivate OAuthRefreshTokenInformation createRefreshToken() {\n+\t\treturn createRefreshToken(new Date());\n+\t}\n+\n+\n+\t@Test\n+\tvoid testDtoToDboAndBack() {\n+\t\tOAuthRefreshTokenInformation dto = new OAuthRefreshTokenInformation();\n+\t\tdto.setName(UUID.randomUUID().toString());\n+\t\tdto.setTokenId(\"111111\");\n+\t\tdto.setScopes(Arrays.asList(OAuthScope.modify, OAuthScope.authorize));\n+\n+\t\t// Set up arbitrary claims\n+\t\tMap<String, OIDCClaimsRequestDetails> userinfoClaims = new HashMap<>();\n+\t\tMap<String, OIDCClaimsRequestDetails> idTokenClaims = new HashMap<>();\n+\n+\t\tOIDCClaimsRequestDetails userNameClaimDetail = new OIDCClaimsRequestDetails();\n+\t\tuserNameClaimDetail.setEssential(true);\n+\t\tuserinfoClaims.put(OIDCClaimName.user_name.name(), userNameClaimDetail);\n+\n+\t\tOIDCClaimsRequestDetails teamsClaimDetail = new OIDCClaimsRequestDetails();\n+\t\tteamsClaimDetail.setEssential(false);\n+\t\tteamsClaimDetail.setValues(Arrays.asList(\"4214124\", \"325325\"));\n+\t\tidTokenClaims.put(OIDCClaimName.team.name(), teamsClaimDetail);\n+\n+\t\tOIDCClaimsRequest claims = new OIDCClaimsRequest();\n+\t\tclaims.setUserinfo(userinfoClaims);\n+\t\tclaims.setId_token(idTokenClaims);\n+\n+\t\tdto.setClaims(claims);\n+\n+\t\tdto.setClientId(\"888888\");\n+\t\tdto.setPrincipalId(\"999999\");\n+\t\tdto.setModifiedOn(new Date());\n+\t\tdto.setAuthorizedOn(new Date());\n+\t\tdto.setLastUsed(new Date());\n+\t\tdto.setEtag(UUID.randomUUID().toString());\n+\n+\t\t// Call under test -- map to DBO and back\n+\t\tOAuthRefreshTokenInformation mapped = OAuthRefreshTokenDaoImpl.refreshTokenDboToDto(\n+\t\t\t\tOAuthRefreshTokenDaoImpl.refreshTokenDtoToDbo(dto)\n+\t\t);\n+\n+\t\tassertEquals(dto, mapped);\n+\t}\n+\n+\t@Test\n+\tvoid testDboToDtoAndBack() throws Exception{\n+\t\tDBOOAuthRefreshToken dbo = new DBOOAuthRefreshToken();\n+\t\tdbo.setName(UUID.randomUUID().toString());\n+\t\tdbo.setId(11111L);\n+\t\tdbo.setScopes(JDOSecondaryPropertyUtils.compressObject(X_STREAM, Arrays.asList(OAuthScope.modify, OAuthScope.authorize)));\n+\t\tMap<String, OIDCClaimsRequestDetails> idTokenClaims = new HashMap<>();\n+\t\tOIDCClaimsRequestDetails detail = new OIDCClaimsRequestDetails();\n+\t\tdetail.setEssential(true);\n+\t\tidTokenClaims.put(OIDCClaimName.userid.name(), detail);\n+\t\tOIDCClaimsRequest claims = new OIDCClaimsRequest();\n+\t\tclaims.setId_token(idTokenClaims);\n+\t\tdbo.setClaims(JDOSecondaryPropertyUtils.compressObject(X_STREAM, claims));\n+\t\tdbo.setClientId(888888L);\n+\t\tdbo.setPrincipalId(999999L);\n+\t\tdbo.setModifiedOn(new Timestamp(System.currentTimeMillis()));\n+\t\tdbo.setCreatedOn(new Timestamp(System.currentTimeMillis()));\n+\t\tdbo.setLastUsed(new Timestamp(System.currentTimeMillis()));\n+\t\tdbo.setEtag(UUID.randomUUID().toString());\n+\t\t// The hash will be dropped, it isn't in the DTO\n+\t\tdbo.setTokenHash(\"abcdef\");\n+\n+\t\t// Call under test -- map to DBO and back\n+\t\tDBOOAuthRefreshToken mapped = OAuthRefreshTokenDaoImpl.refreshTokenDtoToDbo(\n+\t\t\t\tOAuthRefreshTokenDaoImpl.refreshTokenDboToDto(dbo)\n+\t\t);\n+\t\tdbo.setTokenHash(null);\n+\t\tassertEquals(dbo, mapped);\n+\t}\n+\n+\t@Test\n+\tvoid testRefreshTokenCRUD() {\n+\t\tString hash = \"abcdef\";\n+\t\tOAuthRefreshTokenInformation metadata = new OAuthRefreshTokenInformation();\n+\t\tmetadata.setName(UUID.randomUUID().toString());\n+\t\tmetadata.setPrincipalId(userId);\n+\t\tmetadata.setClientId(client.getClient_id());\n+\t\tmetadata.setScopes(Arrays.asList(OAuthScope.view, OAuthScope.download));\n+\t\tmetadata.setClaims(new OIDCClaimsRequest());\n+\t\tmetadata.setModifiedOn(new Date());\n+\t\tmetadata.setLastUsed(new Date());\n+\t\tmetadata.setAuthorizedOn(new Date());\n+\t\tmetadata.setEtag(UUID.randomUUID().toString());\n+\n+\t\t// Call under test -- Create\n+\t\tOAuthRefreshTokenInformation createResult = oauthRefreshTokenDao.createRefreshToken(hash, metadata);\n+\t\tassertNotNull(createResult.getTokenId());\n+\t\tmetadata.setTokenId(createResult.getTokenId());\n+\t\tassertEquals(metadata, createResult);\n+\n+\t\tString newTokenName = \"A new token name\";\n+\t\tmetadata.setName(newTokenName);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e4a95ff405a34d424f05079f6eb9d9aecc8adcef"}, "originalPosition": 262}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIzOTE3MzAw", "url": "https://github.com/Sage-Bionetworks/Synapse-Repository-Services/pull/4057#pullrequestreview-423917300", "createdAt": "2020-06-03T20:47:48Z", "commit": {"oid": "e4a95ff405a34d424f05079f6eb9d9aecc8adcef"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4728, "cost": 1, "resetAt": "2021-11-02T10:47:05Z"}}}