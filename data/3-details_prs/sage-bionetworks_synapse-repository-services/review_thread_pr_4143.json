{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDUzODgyNTgz", "number": 4143, "reviewThreads": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMVQwMTowMToxMlrOEQbH0g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yM1QwMDoyMDoxM1rOERQ2LQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg1NjU3MDQyOnYy", "diffSide": "RIGHT", "path": "services/repository-managers/src/main/java/org/sagebionetworks/repo/manager/dataaccess/AccessApprovalNotificationManagerImpl.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMVQwMTowMToxMlrOG0kVjg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMVQwMTowMToxMlrOG0kVjg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Nzc3NDQ3OA==", "bodyText": "is this needed?", "url": "https://github.com/Sage-Bionetworks/Synapse-Repository-Services/pull/4143#discussion_r457774478", "createdAt": "2020-07-21T01:01:12Z", "author": {"login": "john-hill"}, "path": "services/repository-managers/src/main/java/org/sagebionetworks/repo/manager/dataaccess/AccessApprovalNotificationManagerImpl.java", "diffHunk": "@@ -0,0 +1,300 @@\n+package org.sagebionetworks.repo.manager.dataaccess;\r\n+\r\n+import java.io.IOException;\r\n+import java.time.Instant;\r\n+import java.time.temporal.ChronoUnit;\r\n+import java.util.Collections;\r\n+import java.util.Date;\r\n+import java.util.HashMap;\r\n+import java.util.List;\r\n+import java.util.Map;\r\n+import java.util.Optional;\r\n+\r\n+import org.apache.logging.log4j.LogManager;\r\n+import org.apache.logging.log4j.Logger;\r\n+import org.sagebionetworks.repo.manager.MessageManager;\r\n+import org.sagebionetworks.repo.manager.UserManager;\r\n+import org.sagebionetworks.repo.manager.dataaccess.notifications.DataAccessNotificationBuilder;\r\n+import org.sagebionetworks.repo.manager.feature.FeatureManager;\r\n+import org.sagebionetworks.repo.manager.file.FileHandleManager;\r\n+import org.sagebionetworks.repo.manager.stack.ProdDetector;\r\n+import org.sagebionetworks.repo.model.AccessApproval;\r\n+import org.sagebionetworks.repo.model.AccessApprovalDAO;\r\n+import org.sagebionetworks.repo.model.AccessRequirement;\r\n+import org.sagebionetworks.repo.model.AccessRequirementDAO;\r\n+import org.sagebionetworks.repo.model.ApprovalState;\r\n+import org.sagebionetworks.repo.model.AuthorizationConstants.BOOTSTRAP_PRINCIPAL;\r\n+import org.sagebionetworks.repo.model.ManagedACTAccessRequirement;\r\n+import org.sagebionetworks.repo.model.ObjectType;\r\n+import org.sagebionetworks.repo.model.UserInfo;\r\n+import org.sagebionetworks.repo.model.dataaccess.DataAccessNotificationType;\r\n+import org.sagebionetworks.repo.model.dbo.dao.dataaccess.DataAccessNotificationDao;\r\n+import org.sagebionetworks.repo.model.dbo.feature.Feature;\r\n+import org.sagebionetworks.repo.model.message.BroadcastMessageDao;\r\n+import org.sagebionetworks.repo.model.message.ChangeMessage;\r\n+import org.sagebionetworks.repo.model.message.ChangeType;\r\n+import org.sagebionetworks.repo.model.message.MessageToUser;\r\n+import org.sagebionetworks.repo.transactions.WriteTransaction;\r\n+import org.sagebionetworks.util.ValidateArgument;\r\n+import org.sagebionetworks.workers.util.aws.message.RecoverableMessageException;\r\n+import org.springframework.beans.factory.annotation.Autowired;\r\n+import org.springframework.stereotype.Service;\r\n+\r\n+@Service\r\n+public class AccessApprovalNotificationManagerImpl implements AccessApprovalNotificationManager {\r\n+\t\r\n+\tprivate static final Logger LOG = LogManager.getLogger(AccessApprovalNotificationManagerImpl.class);\r\n+\r\n+\t// TODO: Notifications configuration should be stored in the DB, including the resend timeout and\r\n+\t// eventually the reminder period so that it can be changed later if needed in the DB\r\n+\t\r\n+\t// Do not re-send another notification if one was sent already within the last 7 days\r\n+\tprivate static final long REVOKED_RESEND_TIMEOUT_DAYS = 7;\r\n+\t\r\n+\t// Do not process a change message if it's older than 24 hours\r\n+\tprivate static final long CHANGE_TIMEOUT_HOURS = 24;\r\n+\t\r\n+\t// Fake id for messages to that are not actually created\r\n+\tprivate static final long NO_MESSAGE_TO_USER = -1;\r\n+\r\n+\tprivate BroadcastMessageDao broadcastMessageDao;\r\n+\tprivate UserManager userManager;\r\n+\tprivate DataAccessNotificationDao notificationDao;\r\n+\tprivate AccessApprovalDAO accessApprovalDao;\r\n+\tprivate AccessRequirementDAO accessRequirementDao;\r\n+\tprivate FileHandleManager fileHandleManager;\r\n+\tprivate MessageManager messageManager;\r\n+\tprivate FeatureManager featureManager;\r\n+\tprivate ProdDetector prodDetector;\r\n+\r\n+\tprivate Map<DataAccessNotificationType, DataAccessNotificationBuilder> notificationBuilders;\r\n+\r\n+\t@Autowired\r\n+\tpublic AccessApprovalNotificationManagerImpl(\r\n+\t\t\tfinal UserManager userManager, \r\n+\t\t\tfinal BroadcastMessageDao broadcastMessageDao,\r\n+\t\t\tfinal DataAccessNotificationDao notificationDao, \r\n+\t\t\tfinal AccessApprovalDAO accessApprovalDao,\r\n+\t\t\tfinal AccessRequirementDAO accessRequirementDao, \r\n+\t\t\tfinal FileHandleManager fileHandleManager,\r\n+\t\t\tfinal MessageManager messageManager, \r\n+\t\t\tfinal FeatureManager featureTesting,\r\n+\t\t\tfinal ProdDetector prodDetector) {\r\n+\t\tthis.broadcastMessageDao = broadcastMessageDao;\r\n+\t\tthis.userManager = userManager;\r\n+\t\tthis.notificationDao = notificationDao;\r\n+\t\tthis.accessApprovalDao = accessApprovalDao;\r\n+\t\tthis.accessRequirementDao = accessRequirementDao;\r\n+\t\tthis.fileHandleManager = fileHandleManager;\r\n+\t\tthis.messageManager = messageManager;\r\n+\t\tthis.featureManager = featureTesting;\r\n+\t\tthis.prodDetector = prodDetector;\r\n+\t}\r\n+\r\n+\t@Autowired(required = false)\r\n+\tpublic void configureDataAccessNotificationBuilders(List<DataAccessNotificationBuilder> builders) {\r\n+\t\tnotificationBuilders = new HashMap<>(DataAccessNotificationType.values().length);\r\n+\r\n+\t\tfor (DataAccessNotificationBuilder builder : builders) {\r\n+\t\t\tfor (DataAccessNotificationType supportedType : builder.supportedTypes()) {\r\n+\t\t\t\tif (notificationBuilders.containsKey(supportedType)) {\r\n+\t\t\t\t\tthrow new IllegalStateException(\r\n+\t\t\t\t\t\t\t\"A notification builder for type \" + supportedType + \" is already registred.\");\r\n+\t\t\t\t}\r\n+\t\t\t\tnotificationBuilders.put(supportedType, builder);\r\n+\t\t\t}\r\n+\t\t}\r\n+\r\n+\t}\r\n+\r\n+\t@Override\r\n+\t@WriteTransaction\r\n+\tpublic void processAccessApprovalChange(ChangeMessage message) throws RecoverableMessageException {\r\n+\t\tValidateArgument.required(message, \"The change message\");\r\n+\r\n+\t\t// Should we process this change?\r\n+\t\tif (discardChangeMessage(message)) {\r\n+\t\t\treturn;\r\n+\t\t}\r\n+\t\t\r\n+\t\t// Register the change as processed so that is not processed again (changes are sent multiple times)\r\n+\t\tbroadcastMessageDao.setBroadcast(message.getChangeNumber());\r\n+\t\t\r\n+\t\tAccessApproval approval = accessApprovalDao.get(message.getObjectId());\r\n+\r\n+\t\tUserInfo recipient = getRecipientForRevocation(approval);\r\n+\r\n+\t\t// Should we process this approval change?\r\n+\t\tif (discardAccessApproval(approval, recipient)) {\r\n+\t\t\treturn;\r\n+\t\t}\r\n+\r\n+\t\t// Send the notification\r\n+\t\tsendNotification(DataAccessNotificationType.REVOCATION, approval, recipient);\r\n+\t}\r\n+\r\n+\tboolean discardChangeMessage(ChangeMessage change) {\r\n+\t\t\r\n+\t\t// Check if it's an ACCESS_APPROVAL message\r\n+\t\tif (!ObjectType.ACCESS_APPROVAL.equals(change.getObjectType())) {\r\n+\t\t\treturn true;\r\n+\t\t}\r\n+\t\t\r\n+\t\t// Process only UPDATES\r\n+\t\tif (!ChangeType.UPDATE.equals(change.getChangeType())) {\r\n+\t\t\treturn true;\r\n+\t\t}\r\n+\t\t\r\n+\t\t// Discard old changes\r\n+\t\tif (change.getTimestamp().toInstant().isBefore(Instant.now().minus(CHANGE_TIMEOUT_HOURS, ChronoUnit.HOURS))) {\r\n+\t\t\treturn true;\r\n+\t\t}\r\n+\r\n+\t\t// Check if the message was already processed\r\n+\t\tif (broadcastMessageDao.wasBroadcast(change.getChangeNumber())) {\r", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a3ffd4fec5f9c6d2dd6f183492a78f67004500b3"}, "originalPosition": 154}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg1NjYzMjA1OnYy", "diffSide": "RIGHT", "path": "services/workers/src/main/resources/dataaccess-worker-spb.xml", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMVQwMTozMzo1NVrOG0k5oA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMVQwMTozMzo1NVrOG0k5oA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Nzc4MzcxMg==", "bodyText": "this cannot be increased without adding additional race condition logic to the worker", "url": "https://github.com/Sage-Bionetworks/Synapse-Repository-Services/pull/4143#discussion_r457783712", "createdAt": "2020-07-21T01:33:55Z", "author": {"login": "john-hill"}, "path": "services/workers/src/main/resources/dataaccess-worker-spb.xml", "diffHunk": "@@ -44,4 +44,42 @@\n \t\t<property name=\"repeatInterval\" value=\"30000\" />\r\n \t</bean>\r\n \t\r\n+\t<!-- This worker will process change messages from access approvals in order to send a notification if needed -->\r\n+\t<bean id=\"accessApprovalRevokedNotificationWorker\" class=\"org.sagebionetworks.dataaccess.workers.AccessApprovalRevokedNotificationWorker\" scope=\"singleton\" />\r\n+\t\r\n+\t<bean id=\"accessApprovalRevokedNotificationTrigger\" class=\"org.springframework.scheduling.quartz.SimpleTriggerFactoryBean\"\r\n+\t\tscope=\"singleton\">\r\n+\t\t<property name=\"jobDetail\">\r\n+\t\t\t<bean\r\n+\t\t\t\tclass=\"org.springframework.scheduling.quartz.MethodInvokingJobDetailFactoryBean\">\r\n+\t\t\t\t<property name=\"targetObject\">\r\n+\t\t\t\t\t<bean\r\n+\t\t\t\t\t\tclass=\"org.sagebionetworks.asynchronous.workers.changes.ChangeMessageDrivenWorkerStack\">\r\n+\t\t\t\t\t\t<constructor-arg index=\"0\" ref=\"countingSemaphore\" />\r\n+\t\t\t\t\t\t<constructor-arg index=\"1\" ref=\"awsSQSClient\" />\r\n+\t\t\t\t\t\t<constructor-arg index=\"2\">\r\n+\t\t\t\t\t\t\t<bean\r\n+\t\t\t\t\t\t\t\tclass=\"org.sagebionetworks.asynchronous.workers.changes.ChangeMessageDrivenWorkerStackConfig\">\r\n+\t\t\t\t\t\t\t\t<property name=\"runner\" ref=\"accessApprovalRevokedNotificationWorker\" />\r\n+\t\t\t\t\t\t\t\t<property name=\"semaphoreLockKey\" value=\"accessApprovalRevokedNotificationWorker\" />\r\n+\t\t\t\t\t\t\t\t<property name=\"semaphoreMaxLockCount\" value=\"1\" />\r", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a3ffd4fec5f9c6d2dd6f183492a78f67004500b3"}, "originalPosition": 22}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg1NjY1MTY2OnYy", "diffSide": "RIGHT", "path": "services/repository-managers/src/main/java/org/sagebionetworks/repo/manager/dataaccess/AccessApprovalNotificationManagerImpl.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMVQwMTo0NTowOFrOG0lFcw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMVQwMTo0NTowOFrOG0lFcw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Nzc4NjczOQ==", "bodyText": "if not prod and test user and feature enable still needs to work", "url": "https://github.com/Sage-Bionetworks/Synapse-Repository-Services/pull/4143#discussion_r457786739", "createdAt": "2020-07-21T01:45:08Z", "author": {"login": "john-hill"}, "path": "services/repository-managers/src/main/java/org/sagebionetworks/repo/manager/dataaccess/AccessApprovalNotificationManagerImpl.java", "diffHunk": "@@ -0,0 +1,300 @@\n+package org.sagebionetworks.repo.manager.dataaccess;\r\n+\r\n+import java.io.IOException;\r\n+import java.time.Instant;\r\n+import java.time.temporal.ChronoUnit;\r\n+import java.util.Collections;\r\n+import java.util.Date;\r\n+import java.util.HashMap;\r\n+import java.util.List;\r\n+import java.util.Map;\r\n+import java.util.Optional;\r\n+\r\n+import org.apache.logging.log4j.LogManager;\r\n+import org.apache.logging.log4j.Logger;\r\n+import org.sagebionetworks.repo.manager.MessageManager;\r\n+import org.sagebionetworks.repo.manager.UserManager;\r\n+import org.sagebionetworks.repo.manager.dataaccess.notifications.DataAccessNotificationBuilder;\r\n+import org.sagebionetworks.repo.manager.feature.FeatureManager;\r\n+import org.sagebionetworks.repo.manager.file.FileHandleManager;\r\n+import org.sagebionetworks.repo.manager.stack.ProdDetector;\r\n+import org.sagebionetworks.repo.model.AccessApproval;\r\n+import org.sagebionetworks.repo.model.AccessApprovalDAO;\r\n+import org.sagebionetworks.repo.model.AccessRequirement;\r\n+import org.sagebionetworks.repo.model.AccessRequirementDAO;\r\n+import org.sagebionetworks.repo.model.ApprovalState;\r\n+import org.sagebionetworks.repo.model.AuthorizationConstants.BOOTSTRAP_PRINCIPAL;\r\n+import org.sagebionetworks.repo.model.ManagedACTAccessRequirement;\r\n+import org.sagebionetworks.repo.model.ObjectType;\r\n+import org.sagebionetworks.repo.model.UserInfo;\r\n+import org.sagebionetworks.repo.model.dataaccess.DataAccessNotificationType;\r\n+import org.sagebionetworks.repo.model.dbo.dao.dataaccess.DataAccessNotificationDao;\r\n+import org.sagebionetworks.repo.model.dbo.feature.Feature;\r\n+import org.sagebionetworks.repo.model.message.BroadcastMessageDao;\r\n+import org.sagebionetworks.repo.model.message.ChangeMessage;\r\n+import org.sagebionetworks.repo.model.message.ChangeType;\r\n+import org.sagebionetworks.repo.model.message.MessageToUser;\r\n+import org.sagebionetworks.repo.transactions.WriteTransaction;\r\n+import org.sagebionetworks.util.ValidateArgument;\r\n+import org.sagebionetworks.workers.util.aws.message.RecoverableMessageException;\r\n+import org.springframework.beans.factory.annotation.Autowired;\r\n+import org.springframework.stereotype.Service;\r\n+\r\n+@Service\r\n+public class AccessApprovalNotificationManagerImpl implements AccessApprovalNotificationManager {\r\n+\t\r\n+\tprivate static final Logger LOG = LogManager.getLogger(AccessApprovalNotificationManagerImpl.class);\r\n+\r\n+\t// TODO: Notifications configuration should be stored in the DB, including the resend timeout and\r\n+\t// eventually the reminder period so that it can be changed later if needed in the DB\r\n+\t\r\n+\t// Do not re-send another notification if one was sent already within the last 7 days\r\n+\tprivate static final long REVOKED_RESEND_TIMEOUT_DAYS = 7;\r\n+\t\r\n+\t// Do not process a change message if it's older than 24 hours\r\n+\tprivate static final long CHANGE_TIMEOUT_HOURS = 24;\r\n+\t\r\n+\t// Fake id for messages to that are not actually created\r\n+\tprivate static final long NO_MESSAGE_TO_USER = -1;\r\n+\r\n+\tprivate BroadcastMessageDao broadcastMessageDao;\r\n+\tprivate UserManager userManager;\r\n+\tprivate DataAccessNotificationDao notificationDao;\r\n+\tprivate AccessApprovalDAO accessApprovalDao;\r\n+\tprivate AccessRequirementDAO accessRequirementDao;\r\n+\tprivate FileHandleManager fileHandleManager;\r\n+\tprivate MessageManager messageManager;\r\n+\tprivate FeatureManager featureManager;\r\n+\tprivate ProdDetector prodDetector;\r\n+\r\n+\tprivate Map<DataAccessNotificationType, DataAccessNotificationBuilder> notificationBuilders;\r\n+\r\n+\t@Autowired\r\n+\tpublic AccessApprovalNotificationManagerImpl(\r\n+\t\t\tfinal UserManager userManager, \r\n+\t\t\tfinal BroadcastMessageDao broadcastMessageDao,\r\n+\t\t\tfinal DataAccessNotificationDao notificationDao, \r\n+\t\t\tfinal AccessApprovalDAO accessApprovalDao,\r\n+\t\t\tfinal AccessRequirementDAO accessRequirementDao, \r\n+\t\t\tfinal FileHandleManager fileHandleManager,\r\n+\t\t\tfinal MessageManager messageManager, \r\n+\t\t\tfinal FeatureManager featureTesting,\r\n+\t\t\tfinal ProdDetector prodDetector) {\r\n+\t\tthis.broadcastMessageDao = broadcastMessageDao;\r\n+\t\tthis.userManager = userManager;\r\n+\t\tthis.notificationDao = notificationDao;\r\n+\t\tthis.accessApprovalDao = accessApprovalDao;\r\n+\t\tthis.accessRequirementDao = accessRequirementDao;\r\n+\t\tthis.fileHandleManager = fileHandleManager;\r\n+\t\tthis.messageManager = messageManager;\r\n+\t\tthis.featureManager = featureTesting;\r\n+\t\tthis.prodDetector = prodDetector;\r\n+\t}\r\n+\r\n+\t@Autowired(required = false)\r\n+\tpublic void configureDataAccessNotificationBuilders(List<DataAccessNotificationBuilder> builders) {\r\n+\t\tnotificationBuilders = new HashMap<>(DataAccessNotificationType.values().length);\r\n+\r\n+\t\tfor (DataAccessNotificationBuilder builder : builders) {\r\n+\t\t\tfor (DataAccessNotificationType supportedType : builder.supportedTypes()) {\r\n+\t\t\t\tif (notificationBuilders.containsKey(supportedType)) {\r\n+\t\t\t\t\tthrow new IllegalStateException(\r\n+\t\t\t\t\t\t\t\"A notification builder for type \" + supportedType + \" is already registred.\");\r\n+\t\t\t\t}\r\n+\t\t\t\tnotificationBuilders.put(supportedType, builder);\r\n+\t\t\t}\r\n+\t\t}\r\n+\r\n+\t}\r\n+\r\n+\t@Override\r\n+\t@WriteTransaction\r\n+\tpublic void processAccessApprovalChange(ChangeMessage message) throws RecoverableMessageException {\r\n+\t\tValidateArgument.required(message, \"The change message\");\r\n+\r\n+\t\t// Should we process this change?\r\n+\t\tif (discardChangeMessage(message)) {\r\n+\t\t\treturn;\r\n+\t\t}\r\n+\t\t\r\n+\t\t// Register the change as processed so that is not processed again (changes are sent multiple times)\r\n+\t\tbroadcastMessageDao.setBroadcast(message.getChangeNumber());\r\n+\t\t\r\n+\t\tAccessApproval approval = accessApprovalDao.get(message.getObjectId());\r\n+\r\n+\t\tUserInfo recipient = getRecipientForRevocation(approval);\r\n+\r\n+\t\t// Should we process this approval change?\r\n+\t\tif (discardAccessApproval(approval, recipient)) {\r\n+\t\t\treturn;\r\n+\t\t}\r\n+\r\n+\t\t// Send the notification\r\n+\t\tsendNotification(DataAccessNotificationType.REVOCATION, approval, recipient);\r\n+\t}\r\n+\r\n+\tboolean discardChangeMessage(ChangeMessage change) {\r\n+\t\t\r\n+\t\t// Check if it's an ACCESS_APPROVAL message\r\n+\t\tif (!ObjectType.ACCESS_APPROVAL.equals(change.getObjectType())) {\r\n+\t\t\treturn true;\r\n+\t\t}\r\n+\t\t\r\n+\t\t// Process only UPDATES\r\n+\t\tif (!ChangeType.UPDATE.equals(change.getChangeType())) {\r\n+\t\t\treturn true;\r\n+\t\t}\r\n+\t\t\r\n+\t\t// Discard old changes\r\n+\t\tif (change.getTimestamp().toInstant().isBefore(Instant.now().minus(CHANGE_TIMEOUT_HOURS, ChronoUnit.HOURS))) {\r\n+\t\t\treturn true;\r\n+\t\t}\r\n+\r\n+\t\t// Check if the message was already processed\r\n+\t\tif (broadcastMessageDao.wasBroadcast(change.getChangeNumber())) {\r\n+\t\t\treturn true;\r\n+\t\t}\r\n+\t\t\r\n+\t\treturn false;\r\n+\t}\r\n+\t\r\n+\tboolean discardAccessApproval(AccessApproval approval, UserInfo recipient) {\r\n+\t\t// Do not process approvals that are not revoked\r\n+\t\tif (!ApprovalState.REVOKED.equals(approval.getState())) {\r\n+\t\t\treturn true;\r\n+\t\t}\r\n+\t\t\r\n+\t\tfinal Long requirementId = approval.getRequirementId();\r\n+\t\t\r\n+\t\tString accessRequirementType = accessRequirementDao.getConcreteType(requirementId.toString());\r\n+\r\n+\t\t// Does not process notifications for non-managed access requirements\r\n+\t\tif (!ManagedACTAccessRequirement.class.getName().equals(accessRequirementType)) {\r\n+\t\t\treturn true;\r\n+\t\t}\r\n+\r\n+\t\t// Check if a revocation was already sent to the user for this requirement\r\n+\t\tOptional<Instant> sent = notificationDao.getSentOn(DataAccessNotificationType.REVOCATION, requirementId, recipient.getId());\r\n+\r\n+\t\tif (sent.isPresent()) {\r\n+\r\n+\t\t\tInstant sentOn = sent.get();\r\n+\t\t\tInstant approvalModifiedOn = approval.getModifiedOn().toInstant();\r\n+\r\n+\t\t\t// If it was sent after the approval modification then it was already processed\r\n+\t\t\tif (sentOn.isAfter(approvalModifiedOn)) {\r\n+\t\t\t\treturn true;\r\n+\t\t\t}\r\n+\t\t\t\r\n+\t\t\t// The approval was modified after the notification was sent (e.g. the user was added back and revoked again)\r\n+\t\t\t// We do not want to re-send another notification if the last one for the same approval was within the last week\r\n+\t\t\tif (sentOn.isAfter(approvalModifiedOn.minus(REVOKED_RESEND_TIMEOUT_DAYS, ChronoUnit.DAYS))) {\r\n+\t\t\t\treturn true;\r\n+\t\t\t}\r\n+\r\n+\t\t}\r\n+\r\n+\t\t// We need to check if an APPROVED access approval exists already for the same access requirement, in such a case\r\n+\t\t// there is no need to send a notification as the user is still considered APPROVED\r\n+\t\tif (!accessApprovalDao.listApprovalsByAccessor(requirementId.toString(), recipient.getId().toString()).isEmpty()) {\r\n+\t\t\treturn true;\r\n+\t\t}\r\n+\t\t\r\n+\t\treturn false;\r\n+\t}\r\n+\r\n+\tvoid sendNotification(DataAccessNotificationType notificationType, AccessApproval approval, UserInfo recipient) throws RecoverableMessageException {\r\n+\t\tLong messageId;\r\n+\t\tInstant sentOn;\r\n+\t\t\r\n+\t\tif (deliverMessage(approval, recipient)) {\r\n+\t\t\tMessageToUser messageToUser = sendMessageToUser(notificationType, approval, recipient);\r\n+\t\t\tmessageId = Long.valueOf(messageToUser.getId());\r\n+\t\t\tsentOn = messageToUser.getCreatedOn().toInstant();\r\n+\t\t} else {\r\n+\t\t\t// We do not deliver, but we still want to record the notification to avoid re-processing it\r\n+\t\t\tLOG.warn(\"{} notification (AR: {}, Recipient: {}, AP: {}) will not be delivered\", notificationType, approval.getRequirementId(), recipient.getId(), approval.getId());\r\n+\t\t\tmessageId = NO_MESSAGE_TO_USER;\r\n+\t\t\tsentOn = Instant.now();\r\n+\t\t}\r\n+\t\t\r\n+\t\tnotificationDao.registerNotification(notificationType, approval.getRequirementId(), recipient.getId(), approval.getId(), messageId, sentOn);\r\n+\t\r\n+\t}\r\n+\t\r\n+\tMessageToUser sendMessageToUser(DataAccessNotificationType notificationType, AccessApproval approval, UserInfo recipient) {\r\n+\r\n+\t\tDataAccessNotificationBuilder notificationBuidler = getNotificationBuilder(notificationType);\r\n+\t\t\r\n+\t\tAccessRequirement accessRequirement = accessRequirementDao.get(approval.getRequirementId().toString());\r\n+\t\t\r\n+\t\tif (!(accessRequirement instanceof ManagedACTAccessRequirement)) {\r\n+\t\t\tthrow new IllegalStateException(\"Cannot sent a notification for a non managed access requirement\");\r\n+\t\t}\r\n+\t\t\r\n+\t\tManagedACTAccessRequirement managedAccessRequriement = (ManagedACTAccessRequirement) accessRequirement;\r\n+\r\n+\t\tUserInfo notificationsSender = getNotificationsSender();\r\n+\t\t\r\n+\t\tString sender = notificationsSender.getId().toString();\r\n+\t\tString messageBody = notificationBuidler.buildMessageBody(managedAccessRequriement, approval);\r\n+\t\tString mimeType = notificationBuidler.getMimeType();\r\n+\t\tString subject = notificationBuidler.buildSubject(managedAccessRequriement, approval);\r\n+\t\tString fileHandleId = storeNotificationBody(sender, messageBody, mimeType);\r\n+\r\n+\t\tMessageToUser message = new MessageToUser();\r\n+\r\n+\t\tmessage.setSubject(subject);\r\n+\t\tmessage.setCreatedBy(sender);\r\n+\t\tmessage.setIsNotificationMessage(false);\r\n+\t\tmessage.setWithUnsubscribeLink(false);\r\n+\t\tmessage.setWithProfileSettingLink(false);\r\n+\t\tmessage.setFileHandleId(fileHandleId);\r\n+\t\tmessage.setRecipients(Collections.singleton(recipient.getId().toString()));\r\n+\r\n+\t\tboolean overrideNotificationSettings = true;\r\n+\r\n+\t\treturn messageManager.createMessage(notificationsSender, message, overrideNotificationSettings);\r\n+\t}\r\n+\t\r\n+\tUserInfo getNotificationsSender() {\r\n+\t\treturn userManager.getUserInfo(BOOTSTRAP_PRINCIPAL.DATA_ACCESS_NOTFICATIONS_SENDER.getPrincipalId());\r\n+\t}\r\n+\r\n+\tboolean deliverMessage(AccessApproval approval, UserInfo recipient) throws RecoverableMessageException {\r\n+\t\t// Checks if the feature is enabled first for the given recipient\r\n+\t\tif (featureManager.isFeatureEnabledForUser(Feature.DATA_ACCESS_RENEWALS, recipient)) {\r\n+\t\t\treturn true;\r\n+\t\t}\r\n+\t\t\r\n+\t\t// Once the feature is enabled we can process the notification only on production as we do not want\r\n+\t\t// to send duplicated messages from prod/staging\r\n+\t\treturn prodDetector.isProductionStack().orElseThrow(() -> \r\n+\t\t\tnew RecoverableMessageException(\"Cannot detect current stack\")\r", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a3ffd4fec5f9c6d2dd6f183492a78f67004500b3"}, "originalPosition": 273}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg2NDczNzgxOnYy", "diffSide": "RIGHT", "path": "lib/lib-auto-generated/src/main/resources/schema/org/sagebionetworks/repo/model/dataaccess/DataAccessNotificationType.json", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMlQyMDoxNDozN1rOG1ykFg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMlQyMDoxNDozN1rOG1ykFg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTA1NjE1MA==", "bodyText": "better name", "url": "https://github.com/Sage-Bionetworks/Synapse-Repository-Services/pull/4143#discussion_r459056150", "createdAt": "2020-07-22T20:14:37Z", "author": {"login": "john-hill"}, "path": "lib/lib-auto-generated/src/main/resources/schema/org/sagebionetworks/repo/model/dataaccess/DataAccessNotificationType.json", "diffHunk": "@@ -0,0 +1,18 @@\n+{\r\n+\t\"description\": \"Enumeration with the type of notification sent for data access approvals\",\r\n+    \"type\": \"string\",\r\n+    \"enum\": [\r\n+        {\r\n+            \"name\": \"RENEWAL_REMINDER_1\",\r", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3b500dd24a3023f3201bc0967588814fddb36ea7"}, "originalPosition": 6}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg2NTM2ODgzOnYy", "diffSide": "RIGHT", "path": "services/repository-managers/src/test/java/org/sagebionetworks/repo/manager/dataaccess/notifications/AccessRevokedNotificationBuilderIntegrationTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yM1QwMDoxNzo1OVrOG14hiA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yM1QwMDoxNzo1OVrOG14hiA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTE1MzgwMA==", "bodyText": "load from a file.", "url": "https://github.com/Sage-Bionetworks/Synapse-Repository-Services/pull/4143#discussion_r459153800", "createdAt": "2020-07-23T00:17:59Z", "author": {"login": "john-hill"}, "path": "services/repository-managers/src/test/java/org/sagebionetworks/repo/manager/dataaccess/notifications/AccessRevokedNotificationBuilderIntegrationTest.java", "diffHunk": "@@ -0,0 +1,150 @@\n+package org.sagebionetworks.repo.manager.dataaccess.notifications;\r\n+\r\n+import static org.junit.jupiter.api.Assertions.assertEquals;\r\n+import static org.mockito.ArgumentMatchers.any;\r\n+import static org.mockito.Mockito.when;\r\n+\r\n+import org.apache.commons.lang3.StringUtils;\r\n+import org.apache.velocity.app.VelocityEngine;\r\n+import org.junit.jupiter.api.BeforeEach;\r\n+import org.junit.jupiter.api.Test;\r\n+import org.junit.jupiter.api.extension.ExtendWith;\r\n+import org.mockito.Mock;\r\n+import org.mockito.junit.jupiter.MockitoExtension;\r\n+import org.sagebionetworks.repo.manager.UserProfileManager;\r\n+import org.sagebionetworks.repo.model.AccessApproval;\r\n+import org.sagebionetworks.repo.model.ManagedACTAccessRequirement;\r\n+import org.sagebionetworks.repo.model.UserInfo;\r\n+import org.sagebionetworks.repo.model.UserProfile;\r\n+import org.springframework.beans.factory.annotation.Autowired;\r\n+import org.springframework.test.context.ContextConfiguration;\r\n+import org.springframework.test.context.junit.jupiter.SpringExtension;\r\n+\r\n+@ExtendWith(value = {SpringExtension.class, MockitoExtension.class})\r\n+@ContextConfiguration(\"classpath:test-context.xml\")\r\n+public class AccessRevokedNotificationBuilderIntegrationTest {\r\n+\t\r\n+\t@Autowired\r\n+\tprivate VelocityEngine velocity;\r\n+\t\r\n+\tprivate AccessRevokedNotificationBuilder builder;\r\n+\t\r\n+\t// We mock all this as we only want to test the final template output\r\n+\t@Mock\r\n+\tprivate UserProfileManager profileManager;\r\n+\t@Mock\r\n+\tprivate UserProfile mockProfile;\r\n+\t@Mock\r\n+\tprivate ManagedACTAccessRequirement accessRequirement;\r\n+\t@Mock\r\n+\tprivate AccessApproval approval;\r\n+\t@Mock\r\n+\tprivate UserInfo recipient;\r\n+\t\r\n+\t@BeforeEach\r\n+\tpublic void before() {\r\n+\t\tbuilder = new AccessRevokedNotificationBuilder(profileManager, velocity);\r\n+\t}\r\n+\t\r\n+\t@Test\r\n+\tpublic void testBuildMessageBodyWithDescription() {\r\n+\t\t\r\n+\t\tLong recipientId = 4567L;\r\n+\t\tLong requirementId = 1234L;\r\n+\t\tString requirementDescription = \"Some Dataset\";\r\n+\t\tString firstName = \"First\";\r\n+\t\tString lastName = \"Second\";\r\n+\t\t\r\n+\t\twhen(recipient.getId()).thenReturn(recipientId);\r\n+\t\twhen(profileManager.getUserProfile(any())).thenReturn(mockProfile);\r\n+\t\twhen(mockProfile.getFirstName()).thenReturn(firstName);\r\n+\t\twhen(mockProfile.getLastName()).thenReturn(lastName);\r\n+\t\twhen(accessRequirement.getId()).thenReturn(requirementId);\r\n+\t\twhen(accessRequirement.getDescription()).thenReturn(requirementDescription);\r\n+\t\t\r\n+\t\tString expected = \"<html>\"\r", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3b500dd24a3023f3201bc0967588814fddb36ea7"}, "originalPosition": 65}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg2NTM3MjYxOnYy", "diffSide": "RIGHT", "path": "services/workers/src/main/java/org/sagebionetworks/dataaccess/workers/AccessApprovalRevokedNotificationWorker.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yM1QwMDoyMDoxM1rOG14jtA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yM1QwMDoyMDoxM1rOG14jtA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTE1NDM1Ng==", "bodyText": "remove", "url": "https://github.com/Sage-Bionetworks/Synapse-Repository-Services/pull/4143#discussion_r459154356", "createdAt": "2020-07-23T00:20:13Z", "author": {"login": "john-hill"}, "path": "services/workers/src/main/java/org/sagebionetworks/dataaccess/workers/AccessApprovalRevokedNotificationWorker.java", "diffHunk": "@@ -0,0 +1,56 @@\n+package org.sagebionetworks.dataaccess.workers;\r\n+\r\n+import org.apache.logging.log4j.LogManager;\r\n+import org.apache.logging.log4j.Logger;\r\n+import org.sagebionetworks.asynchronous.workers.changes.ChangeMessageDrivenRunner;\r\n+import org.sagebionetworks.common.util.progress.ProgressCallback;\r\n+import org.sagebionetworks.repo.manager.dataaccess.AccessApprovalNotificationManager;\r\n+import org.sagebionetworks.repo.manager.feature.FeatureManager;\r\n+import org.sagebionetworks.repo.model.ObjectType;\r\n+import org.sagebionetworks.repo.model.dbo.feature.Feature;\r\n+import org.sagebionetworks.repo.model.message.ChangeMessage;\r\n+import org.sagebionetworks.workers.util.aws.message.RecoverableMessageException;\r\n+import org.springframework.beans.factory.annotation.Autowired;\r\n+\r\n+/**\r\n+ * Worker that process {@link ObjectType#ACCESS_APPROVAL} changes to send\r\n+ * revocation notifications\r\n+ * \r\n+ * @author Marco Marasca\r\n+ *\r\n+ */\r\n+public class AccessApprovalRevokedNotificationWorker implements ChangeMessageDrivenRunner {\r\n+\r\n+\tprivate static final Logger LOG = LogManager.getLogger(AccessApprovalRevokedNotificationWorker.class);\r\n+\r\n+\tprivate AccessApprovalNotificationManager notificationManager;\r\n+\tprivate FeatureManager featureManager;\r\n+\r\n+\t@Autowired\r\n+\tpublic AccessApprovalRevokedNotificationWorker(final AccessApprovalNotificationManager notificationManager,\r\n+\t\t\tfinal FeatureManager featureManager) {\r\n+\t\tthis.notificationManager = notificationManager;\r\n+\t\tthis.featureManager = featureManager;\r\n+\t}\r\n+\r\n+\t@Override\r\n+\tpublic void run(ProgressCallback progressCallback, ChangeMessage message)\r\n+\t\t\tthrows RecoverableMessageException, Exception {\r\n+\t\t\r\n+\t\t// Feature not yet enabled\r\n+\t\tif (!featureManager.isFeatureEnabled(Feature.DATA_ACCESS_NOTIFICATIONS)) {\r\n+\t\t\treturn;\r\n+\t\t}\r\n+\t\t\r\n+\t\ttry {\r\n+\t\t\tnotificationManager.processAccessApprovalChange(message);\r\n+\t\t} catch (RecoverableMessageException e) {\r\n+\t\t\tSystem.out.println(\"Recoverable...\" + e.getMessage());\r", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3b500dd24a3023f3201bc0967588814fddb36ea7"}, "originalPosition": 48}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2938, "cost": 1, "resetAt": "2021-11-12T12:57:47Z"}}}