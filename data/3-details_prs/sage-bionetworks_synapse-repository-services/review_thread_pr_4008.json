{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDA1NDI1ODcy", "number": 4008, "reviewThreads": {"totalCount": 17, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOFQxODoyMzo1N1rOD3UxCA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOFQyMzoyMToxN1rOD3av1w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU5MzM4NTA0OnYy", "diffSide": "RIGHT", "path": "services/repository-managers/src/main/java/org/sagebionetworks/repo/manager/schema/JsonSchemaManagerImpl.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOFQxODoyMzo1N1rOGNhO3w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOFQxODoyMzo1N1rOGNhO3w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjgyOTE1MQ==", "bodyText": "Pull this out in a variable to construct the request object", "url": "https://github.com/Sage-Bionetworks/Synapse-Repository-Services/pull/4008#discussion_r416829151", "createdAt": "2020-04-28T18:23:57Z", "author": {"login": "marcomarasca"}, "path": "services/repository-managers/src/main/java/org/sagebionetworks/repo/manager/schema/JsonSchemaManagerImpl.java", "diffHunk": "@@ -176,65 +169,77 @@ public CreateSchemaResponse createJsonSchema(UserInfo user, CreateSchemaRequest\n \n \t\tSchemaId schemaId = SchemaIdParser.parseSchemaId(request.getSchema().get$id());\n \n-\t\tString semanticVersionString = getAndValidateSemanticVersion(schemaId.getSemanticVersion());\n+\t\tString semanticVersionString = null;\n+\t\tif(schemaId.getSemanticVersion() != null) {\n+\t\t\tsemanticVersionString = schemaId.getSemanticVersion().toString();\n+\t\t}\n+\t\tString schemaNameString = schemaId.getSchemaName().toString();\n \n-\t\t// Does the user have update on the organization\n+\t\t// User must have create on the organization.\n \t\tOrganization organization = organizationDao.getOrganizationByName(schemaId.getOrganizationName().toString());\n-\t\taclDao.canAccess(user, organization.getId(), ObjectType.ORGANIZATION, ACCESS_TYPE.UPDATE)\n+\t\taclDao.canAccess(user, organization.getId(), ObjectType.ORGANIZATION, ACCESS_TYPE.CREATE)\n \t\t\t\t.checkAuthorizationOrElseThrow();\n-\n-\t\t// Create or get the root schema\n-\t\tSchemaInfo schemaRoot = jsonSchemaDao\n-\t\t\t\t.createSchemaIfDoesNotExist(new NewSchemaRequest().withOrganizationId(organization.getId())\n-\t\t\t\t\t\t.withSchemaName(schemaId.getSchemaName().toString()).withCreatedBy(user.getId()));\n-\t\t// Create or get the JSON blob\n-\t\tString jsonBlobId = createJsonBlobIfDoesNotExist(request.getSchema());\n-\n-\t\t// Unconditionally create a new version.\n-\t\tJsonSchemaVersionInfo versionInfo = jsonSchemaDao\n-\t\t\t\t.createNewVersion(new NewVersionRequest().withSchemaId(schemaRoot.getNumericId())\n-\t\t\t\t\t\t.withSemanticVersion(semanticVersionString).withCreatedBy(user.getId()).withBlobId(jsonBlobId));\n+\t\t\n+\t\tJsonSchemaVersionInfo info = jsonSchemaDao.createNewSchemaVersion(\n+\t\t\t\tnew NewSchemaVersionRequest().withOrganizationId(organization.getId()).withCreatedBy(user.getId())", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b7ab950d66569dedcb77d15bfc43d23b610e95fe"}, "originalPosition": 77}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU5MzQwMTY0OnYy", "diffSide": "RIGHT", "path": "services/repository-managers/src/main/java/org/sagebionetworks/repo/manager/schema/JsonSchemaManagerImpl.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOFQxODoyODowMVrOGNhZNQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOFQxODoyODowMVrOGNhZNQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjgzMTc5Nw==", "bodyText": "You could use StringUtils.trimToNull for semanticVersion", "url": "https://github.com/Sage-Bionetworks/Synapse-Repository-Services/pull/4008#discussion_r416831797", "createdAt": "2020-04-28T18:28:01Z", "author": {"login": "marcomarasca"}, "path": "services/repository-managers/src/main/java/org/sagebionetworks/repo/manager/schema/JsonSchemaManagerImpl.java", "diffHunk": "@@ -176,65 +169,77 @@ public CreateSchemaResponse createJsonSchema(UserInfo user, CreateSchemaRequest\n \n \t\tSchemaId schemaId = SchemaIdParser.parseSchemaId(request.getSchema().get$id());\n \n-\t\tString semanticVersionString = getAndValidateSemanticVersion(schemaId.getSemanticVersion());\n+\t\tString semanticVersionString = null;\n+\t\tif(schemaId.getSemanticVersion() != null) {\n+\t\t\tsemanticVersionString = schemaId.getSemanticVersion().toString();\n+\t\t}\n+\t\tString schemaNameString = schemaId.getSchemaName().toString();\n \n-\t\t// Does the user have update on the organization\n+\t\t// User must have create on the organization.\n \t\tOrganization organization = organizationDao.getOrganizationByName(schemaId.getOrganizationName().toString());\n-\t\taclDao.canAccess(user, organization.getId(), ObjectType.ORGANIZATION, ACCESS_TYPE.UPDATE)\n+\t\taclDao.canAccess(user, organization.getId(), ObjectType.ORGANIZATION, ACCESS_TYPE.CREATE)\n \t\t\t\t.checkAuthorizationOrElseThrow();\n-\n-\t\t// Create or get the root schema\n-\t\tSchemaInfo schemaRoot = jsonSchemaDao\n-\t\t\t\t.createSchemaIfDoesNotExist(new NewSchemaRequest().withOrganizationId(organization.getId())\n-\t\t\t\t\t\t.withSchemaName(schemaId.getSchemaName().toString()).withCreatedBy(user.getId()));\n-\t\t// Create or get the JSON blob\n-\t\tString jsonBlobId = createJsonBlobIfDoesNotExist(request.getSchema());\n-\n-\t\t// Unconditionally create a new version.\n-\t\tJsonSchemaVersionInfo versionInfo = jsonSchemaDao\n-\t\t\t\t.createNewVersion(new NewVersionRequest().withSchemaId(schemaRoot.getNumericId())\n-\t\t\t\t\t\t.withSemanticVersion(semanticVersionString).withCreatedBy(user.getId()).withBlobId(jsonBlobId));\n+\t\t\n+\t\tJsonSchemaVersionInfo info = jsonSchemaDao.createNewSchemaVersion(\n+\t\t\t\tnew NewSchemaVersionRequest().withOrganizationId(organization.getId()).withCreatedBy(user.getId())\n+\t\t\t\t\t\t.withSchemaName(schemaNameString).withSemanticVersion(semanticVersionString).withJsonSchema(request.getSchema()));\n \n \t\tCreateSchemaResponse response = new CreateSchemaResponse();\n-\t\tresponse.setNewVersionInfo(versionInfo);\n+\t\tresponse.setNewVersionInfo(info);\n \t\treturn response;\n \t}\n \n-\t/**\n-\t * Create a new JSON blob if the one does not already exist for the given\n-\t * schema.\n-\t * \n-\t * @param schema\n-\t * @return\n-\t */\n-\tString createJsonBlobIfDoesNotExist(JsonSchema schema) {\n-\t\tValidateArgument.required(schema, \"schema\");\n-\t\tString schemaJson = null;\n-\t\ttry {\n-\t\t\tschemaJson = EntityFactory.createJSONStringForEntity(schema);\n-\t\t} catch (JSONObjectAdapterException e) {\n-\t\t\tthrow new IllegalArgumentException(e);\n+\t@Override\n+\tpublic JsonSchema getSchema(String organizationName, String schemaName, String semanticVersion) {\n+\t\tValidateArgument.required(organizationName, \"organizationName\");\n+\t\tValidateArgument.required(schemaName, \"schemaName\");\n+\t\torganizationName = organizationName.trim();\n+\t\tschemaName = schemaName.trim();\n+\t\tString versionId = null;\n+\t\tif(semanticVersion == null || semanticVersion.trim().isEmpty()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b7ab950d66569dedcb77d15bfc43d23b610e95fe"}, "originalPosition": 107}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU5MzQxNTE2OnYy", "diffSide": "RIGHT", "path": "services/repository-managers/src/test/java/org/sagebionetworks/repo/manager/schema/JsonSchemaManagerImplTest.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOFQxODozMToyM1rOGNhhdA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOFQxODozMToyM1rOGNhhdA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjgzMzkwOA==", "bodyText": "Might not need the spy anymore", "url": "https://github.com/Sage-Bionetworks/Synapse-Repository-Services/pull/4008#discussion_r416833908", "createdAt": "2020-04-28T18:31:23Z", "author": {"login": "marcomarasca"}, "path": "services/repository-managers/src/test/java/org/sagebionetworks/repo/manager/schema/JsonSchemaManagerImplTest.java", "diffHunk": "@@ -534,133 +529,294 @@ public void testGetOrganizationByNameTrim() {\n \t}\n \n \t@Test\n-\tpublic void testCreateJsonBlobIfDoesNotExist() {\n-\t\twhen(mockSchemaDao.createJsonBlobIfDoesNotExist(any(), any())).thenReturn(jsonBlobId);\n+\tpublic void testCreateJsonSchema() {\n+\t\twhen(mockOrganizationDao.getOrganizationByName(any())).thenReturn(organization);\n+\t\twhen(mockAclDao.canAccess(any(UserInfo.class), any(), any(), any()))\n+\t\t\t\t.thenReturn(AuthorizationStatus.authorized());\n+\t\twhen(mockSchemaDao.createNewSchemaVersion(any())).thenReturn(versionInfo);\n \t\t// call under test\n-\t\tString blobId = manager.createJsonBlobIfDoesNotExist(schema);\n-\t\tassertEquals(jsonBlobId, blobId);\n-\t\tverify(mockSchemaDao).createJsonBlobIfDoesNotExist(schemaJson, schemaJsonSHA256Hex);\n+\t\tCreateSchemaResponse response = managerSpy.createJsonSchema(user, createSchemaRequest);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b7ab950d66569dedcb77d15bfc43d23b610e95fe"}, "originalPosition": 101}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU5MzQxNjk4OnYy", "diffSide": "RIGHT", "path": "services/repository-managers/src/test/java/org/sagebionetworks/repo/manager/schema/JsonSchemaManagerImplTest.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOFQxODozMTo1MFrOGNhigQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOFQxODozMTo1MFrOGNhigQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjgzNDE3Nw==", "bodyText": "duplicate", "url": "https://github.com/Sage-Bionetworks/Synapse-Repository-Services/pull/4008#discussion_r416834177", "createdAt": "2020-04-28T18:31:50Z", "author": {"login": "marcomarasca"}, "path": "services/repository-managers/src/test/java/org/sagebionetworks/repo/manager/schema/JsonSchemaManagerImplTest.java", "diffHunk": "@@ -534,133 +529,294 @@ public void testGetOrganizationByNameTrim() {\n \t}\n \n \t@Test\n-\tpublic void testCreateJsonBlobIfDoesNotExist() {\n-\t\twhen(mockSchemaDao.createJsonBlobIfDoesNotExist(any(), any())).thenReturn(jsonBlobId);\n+\tpublic void testCreateJsonSchema() {\n+\t\twhen(mockOrganizationDao.getOrganizationByName(any())).thenReturn(organization);\n+\t\twhen(mockAclDao.canAccess(any(UserInfo.class), any(), any(), any()))\n+\t\t\t\t.thenReturn(AuthorizationStatus.authorized());\n+\t\twhen(mockSchemaDao.createNewSchemaVersion(any())).thenReturn(versionInfo);\n \t\t// call under test\n-\t\tString blobId = manager.createJsonBlobIfDoesNotExist(schema);\n-\t\tassertEquals(jsonBlobId, blobId);\n-\t\tverify(mockSchemaDao).createJsonBlobIfDoesNotExist(schemaJson, schemaJsonSHA256Hex);\n+\t\tCreateSchemaResponse response = managerSpy.createJsonSchema(user, createSchemaRequest);\n+\t\tassertNotNull(response);\n+\t\tassertEquals(versionInfo, response.getNewVersionInfo());\n+\t\tassertEquals(versionInfo, response.getNewVersionInfo());\n+\t\tverify(mockOrganizationDao).getOrganizationByName(organizationName);\n+\t\tverify(mockAclDao).canAccess(user, organization.getId(), ObjectType.ORGANIZATION, ACCESS_TYPE.CREATE);\n+\t\tNewSchemaVersionRequest expectedNewSchemaRequest = new NewSchemaVersionRequest()\n+\t\t\t\t.withOrganizationId(organization.getId()).withSchemaName(schemaName).withCreatedBy(user.getId())\n+\t\t\t\t.withJsonSchema(schema).withSemanticVersion(semanticVersionString);\n+\t\tverify(mockSchemaDao).createNewSchemaVersion(expectedNewSchemaRequest);\n \t}\n \n \t@Test\n-\tpublic void testCreateJsonBlobIfDoesNotExistNullSchema() {\n-\t\tschema = null;\n+\tpublic void testCreateJsonSchemaNullVersion() {\n+\t\twhen(mockOrganizationDao.getOrganizationByName(any())).thenReturn(organization);\n+\t\twhen(mockAclDao.canAccess(any(UserInfo.class), any(), any(), any()))\n+\t\t\t\t.thenReturn(AuthorizationStatus.authorized());\n+\t\twhen(mockSchemaDao.createNewSchemaVersion(any())).thenReturn(versionInfo);\n+\t\tschema.set$id(organizationName + \"/\" + schemaName);\n \t\t// call under test\n+\t\tCreateSchemaResponse response = managerSpy.createJsonSchema(user, createSchemaRequest);\n+\t\tassertNotNull(response);\n+\t\tassertEquals(versionInfo, response.getNewVersionInfo());\n+\t\tassertEquals(versionInfo, response.getNewVersionInfo());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b7ab950d66569dedcb77d15bfc43d23b610e95fe"}, "originalPosition": 126}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU5MzQzNzg0OnYy", "diffSide": "RIGHT", "path": "services/repository-managers/src/test/java/org/sagebionetworks/repo/manager/schema/JsonSchemaManagerImplTest.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOFQxODozNzoxNlrOGNhviw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOFQxODozNzoxNlrOGNhviw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjgzNzUxNQ==", "bodyText": "we can use a common patter using \"with\" after the method name, e.g. testDeleteSchemaVersionWithNullSemanticVersion", "url": "https://github.com/Sage-Bionetworks/Synapse-Repository-Services/pull/4008#discussion_r416837515", "createdAt": "2020-04-28T18:37:16Z", "author": {"login": "marcomarasca"}, "path": "services/repository-managers/src/test/java/org/sagebionetworks/repo/manager/schema/JsonSchemaManagerImplTest.java", "diffHunk": "@@ -534,133 +529,294 @@ public void testGetOrganizationByNameTrim() {\n \t}\n \n \t@Test\n-\tpublic void testCreateJsonBlobIfDoesNotExist() {\n-\t\twhen(mockSchemaDao.createJsonBlobIfDoesNotExist(any(), any())).thenReturn(jsonBlobId);\n+\tpublic void testCreateJsonSchema() {\n+\t\twhen(mockOrganizationDao.getOrganizationByName(any())).thenReturn(organization);\n+\t\twhen(mockAclDao.canAccess(any(UserInfo.class), any(), any(), any()))\n+\t\t\t\t.thenReturn(AuthorizationStatus.authorized());\n+\t\twhen(mockSchemaDao.createNewSchemaVersion(any())).thenReturn(versionInfo);\n \t\t// call under test\n-\t\tString blobId = manager.createJsonBlobIfDoesNotExist(schema);\n-\t\tassertEquals(jsonBlobId, blobId);\n-\t\tverify(mockSchemaDao).createJsonBlobIfDoesNotExist(schemaJson, schemaJsonSHA256Hex);\n+\t\tCreateSchemaResponse response = managerSpy.createJsonSchema(user, createSchemaRequest);\n+\t\tassertNotNull(response);\n+\t\tassertEquals(versionInfo, response.getNewVersionInfo());\n+\t\tassertEquals(versionInfo, response.getNewVersionInfo());\n+\t\tverify(mockOrganizationDao).getOrganizationByName(organizationName);\n+\t\tverify(mockAclDao).canAccess(user, organization.getId(), ObjectType.ORGANIZATION, ACCESS_TYPE.CREATE);\n+\t\tNewSchemaVersionRequest expectedNewSchemaRequest = new NewSchemaVersionRequest()\n+\t\t\t\t.withOrganizationId(organization.getId()).withSchemaName(schemaName).withCreatedBy(user.getId())\n+\t\t\t\t.withJsonSchema(schema).withSemanticVersion(semanticVersionString);\n+\t\tverify(mockSchemaDao).createNewSchemaVersion(expectedNewSchemaRequest);\n \t}\n \n \t@Test\n-\tpublic void testCreateJsonBlobIfDoesNotExistNullSchema() {\n-\t\tschema = null;\n+\tpublic void testCreateJsonSchemaNullVersion() {\n+\t\twhen(mockOrganizationDao.getOrganizationByName(any())).thenReturn(organization);\n+\t\twhen(mockAclDao.canAccess(any(UserInfo.class), any(), any(), any()))\n+\t\t\t\t.thenReturn(AuthorizationStatus.authorized());\n+\t\twhen(mockSchemaDao.createNewSchemaVersion(any())).thenReturn(versionInfo);\n+\t\tschema.set$id(organizationName + \"/\" + schemaName);\n \t\t// call under test\n+\t\tCreateSchemaResponse response = managerSpy.createJsonSchema(user, createSchemaRequest);\n+\t\tassertNotNull(response);\n+\t\tassertEquals(versionInfo, response.getNewVersionInfo());\n+\t\tassertEquals(versionInfo, response.getNewVersionInfo());\n+\t\tverify(mockOrganizationDao).getOrganizationByName(organizationName);\n+\t\tverify(mockAclDao).canAccess(user, organization.getId(), ObjectType.ORGANIZATION, ACCESS_TYPE.CREATE);\n+\t\tNewSchemaVersionRequest expectedNewSchemaRequest = new NewSchemaVersionRequest()\n+\t\t\t\t.withOrganizationId(organization.getId()).withSchemaName(schemaName).withCreatedBy(user.getId())\n+\t\t\t\t.withJsonSchema(schema).withSemanticVersion(null);\n+\t\tverify(mockSchemaDao).createNewSchemaVersion(expectedNewSchemaRequest);\n+\t}\n+\n+\t@Test\n+\tpublic void testCreateJsonSchemaAnonymous() {\n+\t\tString message = assertThrows(UnauthorizedException.class, () -> {\n+\t\t\tmanager.createJsonSchema(anonymousUser, createSchemaRequest);\n+\t\t}).getMessage();\n+\t\tassertEquals(\"Must login to perform this action\", message);\n+\t}\n+\n+\t@Test\n+\tpublic void testCreateJsonSchemaUnauthorized() {\n+\t\twhen(mockOrganizationDao.getOrganizationByName(any())).thenReturn(organization);\n+\t\twhen(mockAclDao.canAccess(any(UserInfo.class), any(), any(), any()))\n+\t\t\t\t.thenReturn(AuthorizationStatus.accessDenied(\"no\"));\n+\t\tString message = assertThrows(UnauthorizedException.class, () -> {\n+\t\t\tmanager.createJsonSchema(user, createSchemaRequest);\n+\t\t}).getMessage();\n+\t\tassertEquals(\"no\", message);\n+\t\tverify(mockAclDao).canAccess(user, organization.getId(), ObjectType.ORGANIZATION, ACCESS_TYPE.CREATE);\n+\t}\n+\n+\t@Test\n+\tpublic void testCreateJsonSchemaNullUser() {\n+\t\tuser = null;\n+\t\tassertThrows(IllegalArgumentException.class, () -> {\n+\t\t\tmanager.createJsonSchema(user, createSchemaRequest);\n+\t\t});\n+\t}\n+\n+\t@Test\n+\tpublic void testCreateJsonSchemaNullRequest() {\n+\t\tcreateSchemaRequest = null;\n \t\tassertThrows(IllegalArgumentException.class, () -> {\n-\t\t\tmanager.createJsonBlobIfDoesNotExist(schema);\n+\t\t\tmanager.createJsonSchema(user, createSchemaRequest);\n \t\t});\n \t}\n \n \t@Test\n-\tpublic void testGetAndValidateSemanticVersion() {\n-\t\tSemanticVersion version = schemaId.getSemanticVersion();\n-\t\tassertNotNull(version);\n+\tpublic void testCreateJsonSchemaNullSchema() {\n+\t\tcreateSchemaRequest.setSchema(null);\n+\t\tassertThrows(IllegalArgumentException.class, () -> {\n+\t\t\tmanager.createJsonSchema(user, createSchemaRequest);\n+\t\t});\n+\t}\n+\n+\t@Test\n+\tpublic void testGetSchemaWithVersion() {\n+\t\twhen(mockSchemaDao.getVersionId(any(), any(), any())).thenReturn(versionId);\n+\t\twhen(mockSchemaDao.getSchema(any())).thenReturn(schema);\n \t\t// call under test\n-\t\tString versionString = manager.getAndValidateSemanticVersion(version);\n-\t\tassertEquals(semanticVersionString, versionString);\n+\t\tJsonSchema result = manager.getSchema(organizationName, schemaName, semanticVersionString);\n+\t\tassertEquals(schema, result);\n+\t\tverify(mockSchemaDao).getVersionId(organizationName, schemaName, semanticVersionString);\n+\t\tverify(mockSchemaDao, never()).getLatestVersionId(any(), any());\n+\t\tverify(mockSchemaDao).getSchema(versionId);\n \t}\n \n \t@Test\n-\tpublic void testGetAndValidateSemanticVersionNull() {\n-\t\tSemanticVersion version = null;\n+\tpublic void testGetSchemaWithVersionTrim() {\n+\t\twhen(mockSchemaDao.getVersionId(any(), any(), any())).thenReturn(versionId);\n+\t\twhen(mockSchemaDao.getSchema(any())).thenReturn(schema);\n \t\t// call under test\n-\t\tString versionString = manager.getAndValidateSemanticVersion(version);\n-\t\tassertNull(versionString);\n+\t\tJsonSchema result = manager.getSchema(organizationName + \"\\n\", schemaName + \" \", semanticVersionString + \"\\t\");\n+\t\tassertEquals(schema, result);\n+\t\tverify(mockSchemaDao).getVersionId(organizationName, schemaName, semanticVersionString);\n+\t\tverify(mockSchemaDao, never()).getLatestVersionId(any(), any());\n+\t\tverify(mockSchemaDao).getSchema(versionId);\n \t}\n \n \t@Test\n-\tpublic void testGetAndValidateSemanticVersionAtLimit() throws ParseException {\n-\t\tString prefix = \"2.3.1+\";\n-\t\tString version = prefix\n-\t\t\t\t+ StringUtils.repeat('a', JsonSchemaManagerImpl.MAX_SEMANTIC_VERSION_CHARS - prefix.length());\n-\t\tassertEquals(JsonSchemaManagerImpl.MAX_SEMANTIC_VERSION_CHARS, version.length());\n-\t\tSemanticVersion semanticVersion = new SchemaIdParser(version).semanticVersion();\n+\tpublic void testGetSchemaNullVersion() {\n+\t\twhen(mockSchemaDao.getLatestVersionId(any(), any())).thenReturn(versionId);\n+\t\twhen(mockSchemaDao.getSchema(any())).thenReturn(schema);\n+\t\tsemanticVersionString = null;\n \t\t// call under test\n-\t\tString versionString = manager.getAndValidateSemanticVersion(semanticVersion);\n-\t\tassertEquals(version, versionString);\n+\t\tJsonSchema result = manager.getSchema(organizationName, schemaName, semanticVersionString);\n+\t\tassertEquals(schema, result);\n+\t\tverify(mockSchemaDao, never()).getVersionId(any(), any(), any());\n+\t\tverify(mockSchemaDao).getLatestVersionId(organizationName, schemaName);\n+\t\tverify(mockSchemaDao).getSchema(versionId);\n \t}\n \n \t@Test\n-\tpublic void testGetAndValidateSemanticVersionOverLimit() throws ParseException {\n-\t\tString prefix = \"2.3.1+\";\n-\t\tString version = prefix\n-\t\t\t\t+ StringUtils.repeat('a', JsonSchemaManagerImpl.MAX_SEMANTIC_VERSION_CHARS - prefix.length() + 1);\n-\t\tassertEquals(JsonSchemaManagerImpl.MAX_SEMANTIC_VERSION_CHARS + 1, version.length());\n-\t\tSemanticVersion semanticVersion = new SchemaIdParser(version).semanticVersion();\n-\t\tString message = assertThrows(IllegalArgumentException.class, () -> {\n+\tpublic void testGetSchemaNullVersionTrim() {\n+\t\twhen(mockSchemaDao.getLatestVersionId(any(), any())).thenReturn(versionId);\n+\t\twhen(mockSchemaDao.getSchema(any())).thenReturn(schema);\n+\t\tsemanticVersionString = null;\n+\t\t// call under test\n+\t\tJsonSchema result = manager.getSchema(organizationName + \" \", schemaName + \" \\t\", semanticVersionString);\n+\t\tassertEquals(schema, result);\n+\t\tverify(mockSchemaDao, never()).getVersionId(any(), any(), any());\n+\t\tverify(mockSchemaDao).getLatestVersionId(organizationName, schemaName);\n+\t\tverify(mockSchemaDao).getSchema(versionId);\n+\t}\n+\n+\t@Test\n+\tpublic void testGetSchemaEmptyVersion() {\n+\t\twhen(mockSchemaDao.getLatestVersionId(any(), any())).thenReturn(versionId);\n+\t\twhen(mockSchemaDao.getSchema(any())).thenReturn(schema);\n+\t\tsemanticVersionString = \" \";\n+\t\t// call under test\n+\t\tJsonSchema result = manager.getSchema(organizationName, schemaName, semanticVersionString);\n+\t\tassertEquals(schema, result);\n+\t\tverify(mockSchemaDao, never()).getVersionId(any(), any(), any());\n+\t\tverify(mockSchemaDao).getLatestVersionId(organizationName, schemaName);\n+\t\tverify(mockSchemaDao).getSchema(versionId);\n+\t}\n+\n+\t@Test\n+\tpublic void testGetSchemaNullOrganization() {\n+\t\torganizationName = null;\n+\t\tassertThrows(IllegalArgumentException.class, () -> {\n+\t\t\tmanager.getSchema(organizationName, schemaName, semanticVersionString);\n+\t\t});\n+\t}\n+\n+\t@Test\n+\tpublic void testGetSchemaNullSchemaName() {\n+\t\tschemaName = null;\n+\t\tassertThrows(IllegalArgumentException.class, () -> {\n+\t\t\tmanager.getSchema(organizationName, schemaName, semanticVersionString);\n+\t\t});\n+\t}\n+\n+\t@Test\n+\tpublic void testDeleteSchema() {\n+\t\twhen(mockSchemaDao.getVersionLatestInfo(any(), any())).thenReturn(versionInfo);\n+\t\twhen(mockAclDao.canAccess(any(UserInfo.class), any(), any(), any()))\n+\t\t\t\t.thenReturn(AuthorizationStatus.authorized());\n+\n+\t\t// call under test\n+\t\tmanager.deleteSchemaAllVersion(user, organizationName, schemaName);\n+\t\tverify(mockAclDao).canAccess(user, organization.getId(), ObjectType.ORGANIZATION, ACCESS_TYPE.DELETE);\n+\t\tverify(mockSchemaDao).deleteSchema(versionInfo.getSchemaId());\n+\t}\n+\n+\t@Test\n+\tpublic void testDeleteSchemaAdmin() {\n+\t\twhen(mockSchemaDao.getVersionLatestInfo(any(), any())).thenReturn(versionInfo);\n+\t\t// call under test\n+\t\tmanager.deleteSchemaAllVersion(adminUser, organizationName, schemaName);\n+\t\tverify(mockAclDao, never()).canAccess(user, organization.getId(), ObjectType.ORGANIZATION, ACCESS_TYPE.DELETE);\n+\t\tverify(mockSchemaDao).deleteSchema(versionInfo.getSchemaId());\n+\t}\n+\n+\t@Test\n+\tpublic void testDeleteSchemaUnauthorized() {\n+\t\twhen(mockSchemaDao.getVersionLatestInfo(any(), any())).thenReturn(versionInfo);\n+\t\twhen(mockAclDao.canAccess(any(UserInfo.class), any(), any(), any()))\n+\t\t\t\t.thenReturn(AuthorizationStatus.accessDenied(\"nope\"));\n+\t\tassertThrows(UnauthorizedException.class, () -> {\n \t\t\t// call under test\n-\t\t\tmanager.getAndValidateSemanticVersion(semanticVersion);\n-\t\t}).getMessage();\n-\t\tassertEquals(\"Semantic version must be 250 characters or less\", message);\n+\t\t\tmanager.deleteSchemaAllVersion(user, organizationName, schemaName);\n+\t\t});\n+\t\tverify(mockAclDao).canAccess(user, organization.getId(), ObjectType.ORGANIZATION, ACCESS_TYPE.DELETE);\n+\t\tverify(mockSchemaDao, never()).deleteSchema(any());\n \t}\n \n \t@Test\n-\tpublic void testCreateJsonSchema() {\n-\t\twhen(mockOrganizationDao.getOrganizationByName(any())).thenReturn(organization);\n+\tpublic void testDeleteSchemaNullUser() {\n+\t\tuser = null;\n+\t\tassertThrows(IllegalArgumentException.class, () -> {\n+\t\t\tmanager.deleteSchemaAllVersion(user, organizationName, schemaName);\n+\t\t});\n+\t}\n+\n+\t@Test\n+\tpublic void testDeleteSchemaNullOrganization() {\n+\t\torganizationName = null;\n+\t\tassertThrows(IllegalArgumentException.class, () -> {\n+\t\t\tmanager.deleteSchemaAllVersion(user, organizationName, schemaName);\n+\t\t});\n+\t}\n+\n+\t@Test\n+\tpublic void testDeleteSchemaNullSchema() {\n+\t\tschemaName = null;\n+\t\tassertThrows(IllegalArgumentException.class, () -> {\n+\t\t\tmanager.deleteSchemaAllVersion(user, organizationName, schemaName);\n+\t\t});\n+\t}\n+\n+\t@Test\n+\tpublic void testDeleteSchemaVersion() {\n+\t\twhen(mockSchemaDao.getVersionInfo(any(), any(), any())).thenReturn(versionInfo);\n \t\twhen(mockAclDao.canAccess(any(UserInfo.class), any(), any(), any()))\n \t\t\t\t.thenReturn(AuthorizationStatus.authorized());\n-\t\twhen(mockSchemaDao.createSchemaIfDoesNotExist(any())).thenReturn(schemaInfo);\n-\t\twhen(mockSchemaDao.createJsonBlobIfDoesNotExist(any(), any())).thenReturn(jsonBlobId);\n-\t\twhen(mockSchemaDao.createNewVersion(any())).thenReturn(versionInfo);\n \t\t// call under test\n-\t\tCreateSchemaResponse response = managerSpy.createJsonSchema(user, createSchemaRequest);\n-\t\tassertNotNull(response);\n-\t\tassertEquals(versionInfo, response.getNewVersionInfo());\n-\t\tverify(managerSpy).getAndValidateSemanticVersion(schemaId.getSemanticVersion());\n-\t\tassertEquals(versionInfo, response.getNewVersionInfo());\n-\t\tverify(mockOrganizationDao).getOrganizationByName(organizationName);\n-\t\tverify(mockAclDao).canAccess(user, organization.getId(), ObjectType.ORGANIZATION, ACCESS_TYPE.UPDATE);\n-\t\tNewSchemaRequest expectedNewSchemaRequest = new NewSchemaRequest().withOrganizationId(organization.getId())\n-\t\t\t\t.withSchemaName(schemaName).withCreatedBy(user.getId());\n-\t\tverify(mockSchemaDao).createSchemaIfDoesNotExist(expectedNewSchemaRequest);\n-\t\tverify(managerSpy).createJsonBlobIfDoesNotExist(schema);\n-\t\tverify(mockSchemaDao).createJsonBlobIfDoesNotExist(schemaJson, schemaJsonSHA256Hex);\n-\t\tNewVersionRequest expectedNewVersionRequest = new NewVersionRequest().withSchemaId(schemaInfo.getNumericId())\n-\t\t\t\t.withCreatedBy(user.getId()).withBlobId(jsonBlobId).withSemanticVersion(semanticVersionString);\n-\t\tverify(mockSchemaDao).createNewVersion(expectedNewVersionRequest);\n+\t\tmanager.deleteSchemaVersion(user, organizationName, schemaName, semanticVersionString);\n+\t\tverify(mockSchemaDao).getVersionInfo(organizationName, schemaName, semanticVersionString);\n+\t\tverify(mockAclDao).canAccess(user, organization.getId(), ObjectType.ORGANIZATION, ACCESS_TYPE.DELETE);\n+\t\tverify(mockSchemaDao).deleteSchemaVersion(versionId);\n \t}\n \t\n \t@Test\n-\tpublic void testCreateJsonSchemaAnonymous() {\n-\t\tString message = assertThrows(UnauthorizedException.class, ()->{\n-\t\t\t manager.createJsonSchema(anonymousUser, createSchemaRequest);\n-\t\t}).getMessage();\n-\t\tassertEquals(\"Must login to perform this action\", message);\n+\tpublic void testDeleteSchemaVersionUnauthorized() {\n+\t\twhen(mockSchemaDao.getVersionInfo(any(), any(), any())).thenReturn(versionInfo);\n+\t\twhen(mockAclDao.canAccess(any(UserInfo.class), any(), any(), any()))\n+\t\t\t\t.thenReturn(AuthorizationStatus.accessDenied(\"naw\"));\n+\t\tassertThrows(UnauthorizedException.class, ()->{\n+\t\t\t// call under test\n+\t\t\tmanager.deleteSchemaVersion(user, organizationName, schemaName, semanticVersionString);\n+\t\t});\n+\t\tverify(mockSchemaDao).getVersionInfo(organizationName, schemaName, semanticVersionString);\n+\t\tverify(mockAclDao).canAccess(user, organization.getId(), ObjectType.ORGANIZATION, ACCESS_TYPE.DELETE);\n+\t\tverify(mockSchemaDao, never()).deleteSchemaVersion(any());\n \t}\n \t\n \t@Test\n-\tpublic void testCreateJsonSchemaUnauthorized() {\n-\t\twhen(mockOrganizationDao.getOrganizationByName(any())).thenReturn(organization);\n-\t\twhen(mockAclDao.canAccess(any(UserInfo.class), any(), any(), any()))\n-\t\t\t\t.thenReturn(AuthorizationStatus.accessDenied(\"no\"));\n-\t\tString message = assertThrows(UnauthorizedException.class, ()->{\n-\t\t\tmanager.createJsonSchema(user, createSchemaRequest);\n-\t\t}).getMessage();\n-\t\tassertEquals(\"no\", message);\n-\t\tverify(mockAclDao).canAccess(user, organization.getId(), ObjectType.ORGANIZATION, ACCESS_TYPE.UPDATE);\n+\tpublic void testDeleteSchemaVersionAdmin() {\n+\t\twhen(mockSchemaDao.getVersionInfo(any(), any(), any())).thenReturn(versionInfo);\n+\t\t// call under test\n+\t\tmanager.deleteSchemaVersion(adminUser, organizationName, schemaName, semanticVersionString);\n+\t\tverify(mockSchemaDao).getVersionInfo(organizationName, schemaName, semanticVersionString);\n+\t\tverify(mockAclDao, never()).canAccess(any(UserInfo.class), any(), any(), any());\n+\t\tverify(mockSchemaDao).deleteSchemaVersion(versionId);\n \t}\n \t\n \t@Test\n-\tpublic void testCreateJsonSchemaNullUser() {\n+\tpublic void testDeleteSchemaVersionNullUser() {\n \t\tuser = null;\n \t\tassertThrows(IllegalArgumentException.class, ()->{\n-\t\t\tmanager.createJsonSchema(user, createSchemaRequest);\n+\t\t\t// call under test\n+\t\t\tmanager.deleteSchemaVersion(user, organizationName, schemaName, semanticVersionString);\n \t\t});\n \t}\n \t\n \t@Test\n-\tpublic void testCreateJsonSchemaNullRequest() {\n-\t\tcreateSchemaRequest = null;\n+\tpublic void testDeleteSchemaVersionNullOrganizationName() {\n+\t\torganizationName = null;\n \t\tassertThrows(IllegalArgumentException.class, ()->{\n-\t\t\tmanager.createJsonSchema(user, createSchemaRequest);\n+\t\t\t// call under test\n+\t\t\tmanager.deleteSchemaVersion(user, organizationName, schemaName, semanticVersionString);\n \t\t});\n \t}\n \t\n \t@Test\n-\tpublic void testCreateJsonSchemaNullSchema() {\n-\t\tcreateSchemaRequest.setSchema(null);\n+\tpublic void testDeleteSchemaVersionNullSchemaName() {\n+\t\tschemaName = null;\n \t\tassertThrows(IllegalArgumentException.class, ()->{\n-\t\t\tmanager.createJsonSchema(user, createSchemaRequest);\n+\t\t\t// call under test\n+\t\t\tmanager.deleteSchemaVersion(user, organizationName, schemaName, semanticVersionString);\n+\t\t});\n+\t}\n+\t\n+\t@Test\n+\tpublic void testDeleteSchemaVersionNullSemanticVersion() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b7ab950d66569dedcb77d15bfc43d23b610e95fe"}, "originalPosition": 450}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU5MzU2MTM5OnYy", "diffSide": "RIGHT", "path": "lib/jdomodels/src/main/resources/schema/JsonSchemaLatestVersion-ddl.sql", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOFQxOToxMDo0M1rOGNi8Cw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOFQxOToxMDo0M1rOGNi8Cw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjg1NzA5OQ==", "bodyText": "This is not necessary, you can have a composite FK to VERSION_ID, SCHEMA_ID referencing JSON_SCHEMA_VERSION:\nCONSTRAINT FOREIGN KEY (VERSION_ID, SCHEMA_ID) REFERENCES JSON_SCHEMA_VERSION (VERSION_ID, SCHEMA_ID) ON DELETE RESTRICT", "url": "https://github.com/Sage-Bionetworks/Synapse-Repository-Services/pull/4008#discussion_r416857099", "createdAt": "2020-04-28T19:10:43Z", "author": {"login": "marcomarasca"}, "path": "lib/jdomodels/src/main/resources/schema/JsonSchemaLatestVersion-ddl.sql", "diffHunk": "@@ -0,0 +1,8 @@\n+CREATE TABLE IF NOT EXISTS `JSON_SCHEMA_LATEST_VERSION` (\n+  `SCHEMA_ID` BIGINT NOT NULL,\n+  `ETAG` char(36) NOT NULL,\n+  `VERSION_ID` BIGINT NOT NULL,\n+  PRIMARY KEY (`SCHEMA_ID`),\n+  CONSTRAINT FOREIGN KEY (`SCHEMA_ID`) REFERENCES `JSON_SCHEMA` (`SCHEMA_ID`) ON DELETE RESTRICT,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b7ab950d66569dedcb77d15bfc43d23b610e95fe"}, "originalPosition": 6}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU5MzU5MzAwOnYy", "diffSide": "RIGHT", "path": "lib/jdomodels/src/main/resources/schema/JsonSchema-ddl.sql", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOFQxOToxOToxMFrOGNjPQA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOFQxOToxOToxMFrOGNjPQA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjg2MjAxNg==", "bodyText": "We might want to put the primary key on the SCHEMA_ID surrgate key, and the INDEX below needs to be profiled to see if the above PRIMARY key can be turned into the only index. E.g. INDEX(SCHEMA_NAME) vs INDEX(ORGANIZATION_ID, NAME). Note: we already have a FK for the join on organization.", "url": "https://github.com/Sage-Bionetworks/Synapse-Repository-Services/pull/4008#discussion_r416862016", "createdAt": "2020-04-28T19:19:10Z", "author": {"login": "marcomarasca"}, "path": "lib/jdomodels/src/main/resources/schema/JsonSchema-ddl.sql", "diffHunk": "@@ -1,11 +1,12 @@\n CREATE TABLE IF NOT EXISTS `JSON_SCHEMA` (\n-  `ID` BIGINT NOT NULL,\n+  `SCHEMA_ID` BIGINT NOT NULL,\n   `ORGANIZATION_ID` BIGINT NOT NULL,\n-  `NAME` VARCHAR(250) CHARACTER SET ascii COLLATE ascii_general_ci NOT NULL,\n+  `SCHEMA_NAME` VARCHAR(250) CHARACTER SET ascii COLLATE ascii_general_ci NOT NULL,\n   `CREATED_BY` BIGINT NOT NULL,\n   `CREATED_ON` TIMESTAMP(3) NOT NULL,\n-  PRIMARY KEY (`ORGANIZATION_ID`, `NAME`),\n-  UNIQUE (`ID`),\n+  PRIMARY KEY (`ORGANIZATION_ID`, `SCHEMA_NAME`),\n+  UNIQUE (`SCHEMA_ID`),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b7ab950d66569dedcb77d15bfc43d23b610e95fe"}, "originalPosition": 12}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU5NDIxOTYyOnYy", "diffSide": "RIGHT", "path": "lib/jdomodels/src/main/java/org/sagebionetworks/repo/model/dbo/schema/JsonSchemaDao.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOFQyMjoyMzo0MFrOGNpOjA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOFQyMjoyMzo0MFrOGNpOjA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjk2MDE0MA==", "bodyText": "Change to getSchemaIdForUpdate? Move to the end of the class and comment with // For testing purposes (if we cannot make the Impl autowiring work.", "url": "https://github.com/Sage-Bionetworks/Synapse-Repository-Services/pull/4008#discussion_r416960140", "createdAt": "2020-04-28T22:23:40Z", "author": {"login": "marcomarasca"}, "path": "lib/jdomodels/src/main/java/org/sagebionetworks/repo/model/dbo/schema/JsonSchemaDao.java", "diffHunk": "@@ -1,64 +1,160 @@\n package org.sagebionetworks.repo.model.dbo.schema;\n \n+import org.sagebionetworks.repo.model.schema.JsonSchema;\n import org.sagebionetworks.repo.model.schema.JsonSchemaVersionInfo;\n-import org.sagebionetworks.repo.model.schema.SchemaInfo;\n \n public interface JsonSchemaDao {\n \n \t/**\n-\t * Create a JSON schema if it does not already exist.\n+\t * Lookup the schemaId given an organizationId and schema name, and lock on the\n+\t * row using FOR UPDATE.\n \t * \n-\t * @param request\n-\t * @return The returned SchemaInfo.id will either be the ID of the newly created\n-\t *         schema or the ID of the existing schema.\n+\t * @param organizationId\n+\t * @param schemaName\n+\t * @return schemaId\n \t */\n-\tSchemaInfo createSchemaIfDoesNotExist(NewSchemaRequest request);\n+\tString getSchemaInfoForUpdate(String organizationId, String schemaName);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b7ab950d66569dedcb77d15bfc43d23b610e95fe"}, "originalPosition": 22}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU5NDIyMzEwOnYy", "diffSide": "RIGHT", "path": "lib/jdomodels/src/main/java/org/sagebionetworks/repo/model/dbo/schema/JsonSchemaDao.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOFQyMjoyNTowN1rOGNpQoA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOFQyMjoyNTowN1rOGNpQoA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjk2MDY3Mg==", "bodyText": "Add // For testing", "url": "https://github.com/Sage-Bionetworks/Synapse-Repository-Services/pull/4008#discussion_r416960672", "createdAt": "2020-04-28T22:25:07Z", "author": {"login": "marcomarasca"}, "path": "lib/jdomodels/src/main/java/org/sagebionetworks/repo/model/dbo/schema/JsonSchemaDao.java", "diffHunk": "@@ -1,64 +1,160 @@\n package org.sagebionetworks.repo.model.dbo.schema;\n \n+import org.sagebionetworks.repo.model.schema.JsonSchema;\n import org.sagebionetworks.repo.model.schema.JsonSchemaVersionInfo;\n-import org.sagebionetworks.repo.model.schema.SchemaInfo;\n \n public interface JsonSchemaDao {\n \n \t/**\n-\t * Create a JSON schema if it does not already exist.\n+\t * Lookup the schemaId given an organizationId and schema name, and lock on the\n+\t * row using FOR UPDATE.\n \t * \n-\t * @param request\n-\t * @return The returned SchemaInfo.id will either be the ID of the newly created\n-\t *         schema or the ID of the existing schema.\n+\t * @param organizationId\n+\t * @param schemaName\n+\t * @return schemaId\n \t */\n-\tSchemaInfo createSchemaIfDoesNotExist(NewSchemaRequest request);\n+\tString getSchemaInfoForUpdate(String organizationId, String schemaName);\n \n \t/**\n-\t * Lookup a SchemaInfo from an organization name and schema name.\n+\t * Get the JSON data ID for the provide sha256hex\n+\t * \n+\t * @param sha256hex\n+\t * @return\n+\t */\n+\tString getJsonBlobId(String sha256hex);\n+\n+\t/**\n+\t * Get the version information for the given version ID\n+\t * \n+\t * @param versionId\n+\t * @return\n+\t */\n+\tJsonSchemaVersionInfo getVersionInfo(String versionId);\n+\n+\t/**\n+\t * Get the versionId for a specific schema version.\n \t * \n \t * @param organizationName\n \t * @param schemaName\n+\t * @param semanticVersion\n \t * @return\n \t */\n-\tSchemaInfo getSchemaInfoForUpdate(String organizationName, String schemaName);\n+\tString getVersionId(String organizationName, String schemaName, String semanticVersion);\n \n \t/**\n-\t * Create a new JSON blob if the one does not already exist for the given\n-\t * sha256hex.\n+\t * Get the JsonSchemaVersionInfo for a specific version.\n \t * \n-\t * @param json\n-\t * @param sha256hex\n-\t * @return If a new JSON blob is created then the new ID will be returned, else\n-\t *         the existing ID will be returned.\n+\t * @param organizationName\n+\t * @param schemaName\n+\t * @param semanticVersion\n+\t * @return\n \t */\n-\tString createJsonBlobIfDoesNotExist(String json, String sha256hex);\n+\tJsonSchemaVersionInfo getVersionInfo(String organizationName, String schemaName, String semanticVersion);\n \n \t/**\n-\t * Get the JSON data ID for the provide sha256hex\n+\t * Get the versionId of the latest version for a schema.\n \t * \n-\t * @param sha256hex\n+\t * @param organizationName\n+\t * @param schemaName\n \t * @return\n \t */\n-\tString getJsonBlobId(String sha256hex);\n-\t\n+\tString getLatestVersionId(String organizationName, String schemaName);\n+\n \t/**\n-\t * Create a new version for a JSON schema.\n+\t * Get the latest JsonSchemaVersionInfo for a schema.\n+\t * \n+\t * @param organizationName\n+\t * @param schemaNames\n+\t * @return\n+\t */\n+\tJsonSchemaVersionInfo getVersionLatestInfo(String organizationName, String schemaName);\n+\n+\t/**\n+\t * Truncate all data.\n+\t */\n+\tvoid trunacteAll();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b7ab950d66569dedcb77d15bfc43d23b610e95fe"}, "originalPosition": 95}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU5NDIyNDUyOnYy", "diffSide": "RIGHT", "path": "lib/jdomodels/src/main/java/org/sagebionetworks/repo/model/dbo/schema/JsonSchemaDao.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOFQyMjoyNTo0NlrOGNpRmQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOFQyMjoyNTo0NlrOGNpRmQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjk2MDkyMQ==", "bodyText": "boolean?", "url": "https://github.com/Sage-Bionetworks/Synapse-Repository-Services/pull/4008#discussion_r416960921", "createdAt": "2020-04-28T22:25:46Z", "author": {"login": "marcomarasca"}, "path": "lib/jdomodels/src/main/java/org/sagebionetworks/repo/model/dbo/schema/JsonSchemaDao.java", "diffHunk": "@@ -1,64 +1,160 @@\n package org.sagebionetworks.repo.model.dbo.schema;\n \n+import org.sagebionetworks.repo.model.schema.JsonSchema;\n import org.sagebionetworks.repo.model.schema.JsonSchemaVersionInfo;\n-import org.sagebionetworks.repo.model.schema.SchemaInfo;\n \n public interface JsonSchemaDao {\n \n \t/**\n-\t * Create a JSON schema if it does not already exist.\n+\t * Lookup the schemaId given an organizationId and schema name, and lock on the\n+\t * row using FOR UPDATE.\n \t * \n-\t * @param request\n-\t * @return The returned SchemaInfo.id will either be the ID of the newly created\n-\t *         schema or the ID of the existing schema.\n+\t * @param organizationId\n+\t * @param schemaName\n+\t * @return schemaId\n \t */\n-\tSchemaInfo createSchemaIfDoesNotExist(NewSchemaRequest request);\n+\tString getSchemaInfoForUpdate(String organizationId, String schemaName);\n \n \t/**\n-\t * Lookup a SchemaInfo from an organization name and schema name.\n+\t * Get the JSON data ID for the provide sha256hex\n+\t * \n+\t * @param sha256hex\n+\t * @return\n+\t */\n+\tString getJsonBlobId(String sha256hex);\n+\n+\t/**\n+\t * Get the version information for the given version ID\n+\t * \n+\t * @param versionId\n+\t * @return\n+\t */\n+\tJsonSchemaVersionInfo getVersionInfo(String versionId);\n+\n+\t/**\n+\t * Get the versionId for a specific schema version.\n \t * \n \t * @param organizationName\n \t * @param schemaName\n+\t * @param semanticVersion\n \t * @return\n \t */\n-\tSchemaInfo getSchemaInfoForUpdate(String organizationName, String schemaName);\n+\tString getVersionId(String organizationName, String schemaName, String semanticVersion);\n \n \t/**\n-\t * Create a new JSON blob if the one does not already exist for the given\n-\t * sha256hex.\n+\t * Get the JsonSchemaVersionInfo for a specific version.\n \t * \n-\t * @param json\n-\t * @param sha256hex\n-\t * @return If a new JSON blob is created then the new ID will be returned, else\n-\t *         the existing ID will be returned.\n+\t * @param organizationName\n+\t * @param schemaName\n+\t * @param semanticVersion\n+\t * @return\n \t */\n-\tString createJsonBlobIfDoesNotExist(String json, String sha256hex);\n+\tJsonSchemaVersionInfo getVersionInfo(String organizationName, String schemaName, String semanticVersion);\n \n \t/**\n-\t * Get the JSON data ID for the provide sha256hex\n+\t * Get the versionId of the latest version for a schema.\n \t * \n-\t * @param sha256hex\n+\t * @param organizationName\n+\t * @param schemaName\n \t * @return\n \t */\n-\tString getJsonBlobId(String sha256hex);\n-\t\n+\tString getLatestVersionId(String organizationName, String schemaName);\n+\n \t/**\n-\t * Create a new version for a JSON schema.\n+\t * Get the latest JsonSchemaVersionInfo for a schema.\n+\t * \n+\t * @param organizationName\n+\t * @param schemaNames\n+\t * @return\n+\t */\n+\tJsonSchemaVersionInfo getVersionLatestInfo(String organizationName, String schemaName);\n+\n+\t/**\n+\t * Truncate all data.\n+\t */\n+\tvoid trunacteAll();\n+\n+\t/**\n+\t * Get the schema for the given version ID.\n+\t * \n+\t * @param organizationName\n+\t * @param schemaName\n+\t * @return\n+\t */\n+\tJsonSchema getSchema(String versionId);\n+\n+\t/**\n+\t * Attempt to delete the given schema.\n+\t * \n+\t * @param schemaId\n+\t */\n+\tint deleteSchema(String schemaId);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b7ab950d66569dedcb77d15bfc43d23b610e95fe"}, "originalPosition": 111}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU5NDI1NDMwOnYy", "diffSide": "RIGHT", "path": "lib/jdomodels/src/main/java/org/sagebionetworks/repo/model/dbo/schema/JsonSchemaDaoImpl.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOFQyMjozNzowMVrOGNpi-w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOFQyMjozNzowMVrOGNpi-w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjk2NTM3MQ==", "bodyText": "Extract the query to a string, so that can be easily debugged", "url": "https://github.com/Sage-Bionetworks/Synapse-Repository-Services/pull/4008#discussion_r416965371", "createdAt": "2020-04-28T22:37:01Z", "author": {"login": "marcomarasca"}, "path": "lib/jdomodels/src/main/java/org/sagebionetworks/repo/model/dbo/schema/JsonSchemaDaoImpl.java", "diffHunk": "@@ -166,14 +221,155 @@ public JsonSchemaVersionInfo createNewVersion(NewVersionRequest request) {\n \tpublic JsonSchemaVersionInfo getVersionInfo(String versionId) {\n \t\tValidateArgument.required(versionId, \"versionId\");\n \t\ttry {\n-\t\t\treturn jdbcTemplate.queryForObject(\n-\t\t\t\t\t\"SELECT V.*, B.\" + COL_JSON_SCHEMA_BLOB_SHA256 + \" FROM \" + TABLE_JSON_SCHEMA_VERSION\n-\t\t\t\t\t\t\t+ \" V INNER JOIN \" + TABLE_JSON_SCHEMA_BLOB + \" B ON (V.\" + COL_JSON_SCHEMA_VER_BLOB_ID\n-\t\t\t\t\t\t\t+ \"=B.\" + COL_JSON_SCHEMA_BLOB_ID + \") WHERE V.\" + COL_JSON_SCHEMA_VER_ID + \"=?\",\n-\t\t\t\t\tSCHEMA_VERSION_INFO_MAPPER, versionId);\n+\t\t\treturn jdbcTemplate.queryForObject(\"SELECT O.\" + COL_ORGANIZATION_ID + \", O.\" + COL_ORGANIZATION_NAME", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b7ab950d66569dedcb77d15bfc43d23b610e95fe"}, "originalPosition": 254}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU5NDI1NTI5OnYy", "diffSide": "RIGHT", "path": "lib/jdomodels/src/main/java/org/sagebionetworks/repo/model/dbo/schema/JsonSchemaDaoImpl.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOFQyMjozNzoyOFrOGNpjlQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOFQyMjozNzoyOFrOGNpjlQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjk2NTUyNQ==", "bodyText": "Maintain consistency between JOIN vs INNER JOIN", "url": "https://github.com/Sage-Bionetworks/Synapse-Repository-Services/pull/4008#discussion_r416965525", "createdAt": "2020-04-28T22:37:28Z", "author": {"login": "marcomarasca"}, "path": "lib/jdomodels/src/main/java/org/sagebionetworks/repo/model/dbo/schema/JsonSchemaDaoImpl.java", "diffHunk": "@@ -166,14 +221,155 @@ public JsonSchemaVersionInfo createNewVersion(NewVersionRequest request) {\n \tpublic JsonSchemaVersionInfo getVersionInfo(String versionId) {\n \t\tValidateArgument.required(versionId, \"versionId\");\n \t\ttry {\n-\t\t\treturn jdbcTemplate.queryForObject(\n-\t\t\t\t\t\"SELECT V.*, B.\" + COL_JSON_SCHEMA_BLOB_SHA256 + \" FROM \" + TABLE_JSON_SCHEMA_VERSION\n-\t\t\t\t\t\t\t+ \" V INNER JOIN \" + TABLE_JSON_SCHEMA_BLOB + \" B ON (V.\" + COL_JSON_SCHEMA_VER_BLOB_ID\n-\t\t\t\t\t\t\t+ \"=B.\" + COL_JSON_SCHEMA_BLOB_ID + \") WHERE V.\" + COL_JSON_SCHEMA_VER_ID + \"=?\",\n-\t\t\t\t\tSCHEMA_VERSION_INFO_MAPPER, versionId);\n+\t\t\treturn jdbcTemplate.queryForObject(\"SELECT O.\" + COL_ORGANIZATION_ID + \", O.\" + COL_ORGANIZATION_NAME\n+\t\t\t\t\t+ \", S.\" + COL_JSON_SCHEMA_ID + \", S.\" + COL_JSON_SCHEMA_NAME + \", V.*, B.\"\n+\t\t\t\t\t+ COL_JSON_SCHEMA_BLOB_SHA256 + \" FROM \" + TABLE_JSON_SCHEMA_VERSION + \" V INNER JOIN \"", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b7ab950d66569dedcb77d15bfc43d23b610e95fe"}, "originalPosition": 256}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU5NDI4NjA3OnYy", "diffSide": "RIGHT", "path": "lib/jdomodels/src/main/java/org/sagebionetworks/repo/model/dbo/schema/JsonSchemaDaoImpl.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOFQyMjo0OToyNVrOGNp1dg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOFQyMjo0OToyNVrOGNp1dg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjk3MDEwMg==", "bodyText": "Might use an Optional as return value", "url": "https://github.com/Sage-Bionetworks/Synapse-Repository-Services/pull/4008#discussion_r416970102", "createdAt": "2020-04-28T22:49:25Z", "author": {"login": "marcomarasca"}, "path": "lib/jdomodels/src/main/java/org/sagebionetworks/repo/model/dbo/schema/JsonSchemaDaoImpl.java", "diffHunk": "@@ -166,14 +221,155 @@ public JsonSchemaVersionInfo createNewVersion(NewVersionRequest request) {\n \tpublic JsonSchemaVersionInfo getVersionInfo(String versionId) {\n \t\tValidateArgument.required(versionId, \"versionId\");\n \t\ttry {\n-\t\t\treturn jdbcTemplate.queryForObject(\n-\t\t\t\t\t\"SELECT V.*, B.\" + COL_JSON_SCHEMA_BLOB_SHA256 + \" FROM \" + TABLE_JSON_SCHEMA_VERSION\n-\t\t\t\t\t\t\t+ \" V INNER JOIN \" + TABLE_JSON_SCHEMA_BLOB + \" B ON (V.\" + COL_JSON_SCHEMA_VER_BLOB_ID\n-\t\t\t\t\t\t\t+ \"=B.\" + COL_JSON_SCHEMA_BLOB_ID + \") WHERE V.\" + COL_JSON_SCHEMA_VER_ID + \"=?\",\n-\t\t\t\t\tSCHEMA_VERSION_INFO_MAPPER, versionId);\n+\t\t\treturn jdbcTemplate.queryForObject(\"SELECT O.\" + COL_ORGANIZATION_ID + \", O.\" + COL_ORGANIZATION_NAME\n+\t\t\t\t\t+ \", S.\" + COL_JSON_SCHEMA_ID + \", S.\" + COL_JSON_SCHEMA_NAME + \", V.*, B.\"\n+\t\t\t\t\t+ COL_JSON_SCHEMA_BLOB_SHA256 + \" FROM \" + TABLE_JSON_SCHEMA_VERSION + \" V INNER JOIN \"\n+\t\t\t\t\t+ TABLE_JSON_SCHEMA_BLOB + \" B ON (V.\" + COL_JSON_SCHEMA_VER_BLOB_ID + \"=B.\"\n+\t\t\t\t\t+ COL_JSON_SCHEMA_BLOB_ID + \") JOIN \" + TABLE_JSON_SCHEMA + \" S ON (V.\"\n+\t\t\t\t\t+ COL_JSON_SCHEMA_VER_SCHEMA_ID + \" = S.\" + COL_JSON_SCHEMA_ID + \" ) JOIN \" + TABLE_ORGANIZATION\n+\t\t\t\t\t+ \" O ON (S.\" + COL_JSON_SCHEMA_ORG_ID + \" = O.\" + COL_ORGANIZATION_ID + \") WHERE V.\"\n+\t\t\t\t\t+ COL_JSON_SCHEMA_VER_ID + \"=?\", SCHEMA_VERSION_INFO_MAPPER, versionId);\n \t\t} catch (EmptyResultDataAccessException e) {\n \t\t\tthrow new NotFoundException(\"JSON version not found for versionId: \" + versionId);\n \t\t}\n \t}\n \n+\t@WriteTransaction\n+\t@Override\n+\tpublic JsonSchemaVersionInfo createNewSchemaVersion(NewSchemaVersionRequest request) {\n+\t\tValidateArgument.required(request, \"request\");\n+\t\tValidateArgument.required(request.getOrganizationId(), \"request.organizationId\");\n+\t\tValidateArgument.required(request.getCreatedBy(), \"request.createdBy\");\n+\t\tValidateArgument.required(request.getSchemaName(), \"request.schemaName\");\n+\t\tValidateArgument.required(request.getJsonSchema(), \"request.jsonSchema\");\n+\t\tif (request.getSchemaName().length() > MAX_SCHEMA_NAME_CHARS) {\n+\t\t\tthrow new IllegalArgumentException(\"Schema name must be \" + MAX_SCHEMA_NAME_CHARS + \" characters or less\");\n+\t\t}\n+\t\tif (request.getSemanticVersion() != null) {\n+\t\t\tif (request.getSemanticVersion().length() > MAX_SEMANTIC_VERSION_CHARS) {\n+\t\t\t\tthrow new IllegalArgumentException(\n+\t\t\t\t\t\t\"Semantic version must be \" + MAX_SEMANTIC_VERSION_CHARS + \" characters or less\");\n+\t\t\t}\n+\t\t}\n+\t\tString schemaId = createSchemaIfDoesNotExist(request.getOrganizationId(), request.getSchemaName(),\n+\t\t\t\trequest.getCreatedBy());\n+\t\tString blobId = createJsonBlobIfDoesNotExist(request.getJsonSchema());\n+\t\treturn createNewVersion(schemaId, request.getSemanticVersion(), request.getCreatedBy(), blobId);\n+\t}\n+\n+\t@WriteTransaction\n+\t@Override\n+\tpublic int deleteSchema(String schemaId) {\n+\t\tValidateArgument.required(schemaId, \"schemaId\");\n+\t\tjdbcTemplate.update(\"DELETE FROM \" + TABLE_JSON_SCHEMA_LATEST_VERSION + \" WHERE \"\n+\t\t\t\t+ COL_JSON_SCHEMA_LATEST_VER_SCHEMA_ID + \" = ?\", schemaId);\n+\t\tjdbcTemplate.update(\n+\t\t\t\t\"DELETE FROM \" + TABLE_JSON_SCHEMA_VERSION + \" WHERE \" + COL_JSON_SCHEMA_VER_SCHEMA_ID + \" = ?\",\n+\t\t\t\tschemaId);\n+\t\treturn jdbcTemplate.update(\"DELETE FROM \" + TABLE_JSON_SCHEMA + \" WHERE \" + COL_JSON_SCHEMA_ID + \" = ?\",\n+\t\t\t\tschemaId);\n+\t}\n+\n+\t@WriteTransaction\n+\t@Override\n+\tpublic String getSchemaIdForUpdate(String versionId) {\n+\t\tValidateArgument.required(versionId, \"versionId\");\n+\t\ttry {\n+\t\t\treturn jdbcTemplate.queryForObject(\"SELECT \" + COL_JSON_SCHEMA_VER_SCHEMA_ID + \" FROM \"\n+\t\t\t\t\t+ TABLE_JSON_SCHEMA_VERSION + \" WHERE \" + COL_JSON_SCHEMA_VER_ID + \" = ? FOR UPDATE\", String.class,\n+\t\t\t\t\tversionId);\n+\t\t} catch (EmptyResultDataAccessException e) {\n+\t\t\tthrow new NotFoundException(\"JSON schema not found for versionId: \" + versionId);\n+\t\t}\n+\t}\n+\n+\t@WriteTransaction\n+\t@Override\n+\tpublic void deleteSchemaVersion(String versionId) {\n+\t\tValidateArgument.required(versionId, \"versionId\");\n+\t\t// lock on the schema\n+\t\tString schemaId = getSchemaIdForUpdate(versionId);\n+\t\t// clear the latest version cache\n+\t\tjdbcTemplate.update(\"DELETE FROM \" + TABLE_JSON_SCHEMA_LATEST_VERSION + \" WHERE \"\n+\t\t\t\t+ COL_JSON_SCHEMA_LATEST_VER_SCHEMA_ID + \" = ?\", schemaId);\n+\t\t// delete the requested version\n+\t\tjdbcTemplate.update(\"DELETE FROM \" + TABLE_JSON_SCHEMA_VERSION + \" WHERE \" + COL_JSON_SCHEMA_VER_ID + \" = ?\",\n+\t\t\t\tversionId);\n+\t\t// find the latest version for the schema\n+\t\tLong latestVersionId = findLatestVersionId(schemaId);\n+\t\tif (latestVersionId == null) {\n+\t\t\t// deleted the last version so delete the schema.\n+\t\t\tdeleteSchema(schemaId);\n+\t\t} else {\n+\t\t\tsetLatestVersion(schemaId, latestVersionId);\n+\t\t}\n+\t}\n+\n+\t@Override\n+\tpublic String getVersionId(String organizationName, String schemaName, String semanticVersion) {\n+\t\tValidateArgument.required(organizationName, \"organizationName\");\n+\t\tValidateArgument.required(schemaName, \"schemaName\");\n+\t\tValidateArgument.required(semanticVersion, \"semanticVersion\");\n+\t\tString sql = \"SELECT V.\" + COL_JSON_SCHEMA_VER_ID + \" FROM \" + TABLE_ORGANIZATION + \" O JOIN \"\n+\t\t\t\t+ TABLE_JSON_SCHEMA + \" S ON (O.\" + COL_ORGANIZATION_ID + \" = S.\" + COL_JSON_SCHEMA_ORG_ID + \") JOIN \"\n+\t\t\t\t+ TABLE_JSON_SCHEMA_VERSION + \" V ON (S.\" + COL_JSON_SCHEMA_ID + \" = V.\" + COL_JSON_SCHEMA_VER_SCHEMA_ID\n+\t\t\t\t+ \") WHERE O.\" + COL_ORGANIZATION_NAME + \" = ? AND S.\" + COL_JSON_SCHEMA_NAME + \" = ? AND V.\"\n+\t\t\t\t+ COL_JSON_SCHEMA_VER_SEMANTIC + \" = ?\";\n+\t\ttry {\n+\t\t\treturn jdbcTemplate.queryForObject(sql, String.class, organizationName, schemaName, semanticVersion);\n+\t\t} catch (EmptyResultDataAccessException e) {\n+\t\t\tthrow new NotFoundException(\"JSON Schema not found for organizationName: '\" + organizationName\n+\t\t\t\t\t+ \"' and schemaName: '\" + schemaName + \"' and semanticVersion: '\" + semanticVersion + \"'\");\n+\t\t}\n+\t}\n+\n+\t@Override\n+\tpublic String getLatestVersionId(String organizationName, String schemaName) {\n+\t\tValidateArgument.required(organizationName, \"organizationName\");\n+\t\tValidateArgument.required(schemaName, \"schemaName\");\n+\t\ttry {\n+\t\t\treturn jdbcTemplate.queryForObject(\"SELECT L.\" + COL_JSON_SCHEMA_LATEST_VER_VER_ID + \" FROM \"\n+\t\t\t\t\t+ TABLE_ORGANIZATION + \" O JOIN \" + TABLE_JSON_SCHEMA + \" S ON (O.\" + COL_ORGANIZATION_ID + \" = S.\"\n+\t\t\t\t\t+ COL_JSON_SCHEMA_ORG_ID + \") JOIN \" + TABLE_JSON_SCHEMA_LATEST_VERSION + \" L ON (S.\"\n+\t\t\t\t\t+ COL_JSON_SCHEMA_ID + \" = L.\" + COL_JSON_SCHEMA_LATEST_VER_SCHEMA_ID + \") WHERE O.\"\n+\t\t\t\t\t+ COL_ORGANIZATION_NAME + \" = ? AND \" + COL_JSON_SCHEMA_NAME + \" = ?\", String.class,\n+\t\t\t\t\torganizationName, schemaName);\n+\t\t} catch (EmptyResultDataAccessException e) {\n+\t\t\tthrow new NotFoundException(\"JSON Schema not found for organizationName: '\" + organizationName\n+\t\t\t\t\t+ \"' and schemaName: '\" + schemaName + \"'\");\n+\t\t}\n+\t}\n+\n+\t@Override\n+\tpublic JsonSchema getSchema(String versionId) {\n+\t\tValidateArgument.required(versionId, \"versionId\");\n+\t\ttry {\n+\t\t\treturn jdbcTemplate.queryForObject(\n+\t\t\t\t\t\"SELECT B.\" + COL_JSON_SCHEMA_BLOB_BLOB + \" FROM \" + TABLE_JSON_SCHEMA_VERSION + \" V JOIN \"\n+\t\t\t\t\t\t\t+ TABLE_JSON_SCHEMA_BLOB + \" B ON (V.\" + COL_JSON_SCHEMA_VER_BLOB_ID + \" = B.\"\n+\t\t\t\t\t\t\t+ COL_JSON_SCHEMA_BLOB_ID + \") WHERE V.\" + COL_JSON_SCHEMA_VER_ID + \" = ?\",\n+\t\t\t\t\tSCHEMA_MAPPER, versionId);\n+\t\t} catch (EmptyResultDataAccessException e) {\n+\t\t\tthrow new NotFoundException(\"JSON Schema not found for versionId: '\" + versionId + \"'\");\n+\t\t}\n+\t}\n+\n+\t@Override\n+\tpublic JsonSchemaVersionInfo getVersionInfo(String organizationName, String schemaName, String semanticVersion) {\n+\t\tString versionId = getVersionId(organizationName, schemaName, semanticVersion);\n+\t\treturn getVersionInfo(versionId);\n+\t}\n+\n+\t@Override\n+\tpublic JsonSchemaVersionInfo getVersionLatestInfo(String organizationName, String schemaName) {\n+\t\tString versionId = getLatestVersionId(organizationName, schemaName);\n+\t\treturn getVersionInfo(versionId);\n+\t}\n+\n+\t@Override\n+\tpublic Long findLatestVersionId(String schemaId) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b7ab950d66569dedcb77d15bfc43d23b610e95fe"}, "originalPosition": 400}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU5NDM0Nzc2OnYy", "diffSide": "RIGHT", "path": "lib/jdomodels/src/test/java/org/sagebionetworks/repo/model/dbo/schema/JsonSchemaDaoImplTest.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOFQyMzoxNDoyMlrOGNqY6w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOFQyMzoxNDoyMlrOGNqY6w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjk3OTE3OQ==", "bodyText": "Add assert on the message", "url": "https://github.com/Sage-Bionetworks/Synapse-Repository-Services/pull/4008#discussion_r416979179", "createdAt": "2020-04-28T23:14:22Z", "author": {"login": "marcomarasca"}, "path": "lib/jdomodels/src/test/java/org/sagebionetworks/repo/model/dbo/schema/JsonSchemaDaoImplTest.java", "diffHunk": "@@ -318,4 +308,532 @@ public void testGetVersionInfoNullId() {\n \t\t});\n \t}\n \n+\t@Test\n+\tpublic void testCreateNewSchemaVersion() {\n+\t\t// Call under test\n+\t\tJsonSchemaVersionInfo info = jsonSchemaDao.createNewSchemaVersion(newSchemaVersionRequest);\n+\t\tassertNotNull(info);\n+\t\tassertEquals(organizationId, info.getOrganizationId());\n+\t\tassertEquals(organizationName, info.getOrganizationName());\n+\t\tassertNotNull(info.getSchemaId());\n+\t\tassertEquals(schemaName, info.getSchemaName());\n+\t\tassertEquals(createdBy.toString(), info.getCreatedBy());\n+\t\tassertEquals(semanticVersion, info.getSemanticVersion());\n+\t\tassertNotNull(info.getVersionId());\n+\t\tassertEquals(schemaJsonSha256Hex ,info.getJsonSHA256Hex());\n+\t}\n+\t\n+\t@Test\n+\tpublic void testCreateNewSchemaVersionSchemaNameAtLimit() {\n+\t\tString schemaName = StringUtils.repeat(\"a\", JsonSchemaDaoImpl.MAX_SCHEMA_NAME_CHARS);\n+\t\tnewSchemaVersionRequest.withSchemaName(schemaName);\n+\t\tJsonSchemaVersionInfo info = jsonSchemaDao.createNewSchemaVersion(newSchemaVersionRequest);\n+\t\tassertNotNull(info);\n+\t\tassertEquals(schemaName, info.getSchemaName());\n+\t}\n+\t\n+\t@Test\n+\tpublic void testCreateNewSchemaVersionSchemaNameOverLimit() {\n+\t\tString schemaName = StringUtils.repeat(\"a\", JsonSchemaDaoImpl.MAX_SCHEMA_NAME_CHARS+1);\n+\t\tnewSchemaVersionRequest.withSchemaName(schemaName);\n+\t\tString message = assertThrows(IllegalArgumentException.class, ()->{\n+\t\t\tjsonSchemaDao.createNewSchemaVersion(newSchemaVersionRequest);\n+\t\t}).getMessage();\n+\t\tassertEquals(\"Schema name must be \"+JsonSchemaDaoImpl.MAX_SCHEMA_NAME_CHARS+\" characters or less\", message);\n+\t}\n+\t\n+\t@Test\n+\tpublic void testCreateNewSchemaVersionSemanticVersionAtLimit() {\n+\t\tsemanticVersion = StringUtils.repeat(\"a\", JsonSchemaDaoImpl.MAX_SEMANTIC_VERSION_CHARS);\n+\t\tnewSchemaVersionRequest.withSemanticVersion(semanticVersion);\n+\t\tJsonSchemaVersionInfo info = jsonSchemaDao.createNewSchemaVersion(newSchemaVersionRequest);\n+\t\tassertNotNull(info);\n+\t\tassertEquals(semanticVersion, info.getSemanticVersion());\n+\t}\n+\t\n+\t@Test\n+\tpublic void testCreateNewSchemaVersionSemanticVersionOverLimit() {\n+\t\tsemanticVersion = StringUtils.repeat(\"a\", JsonSchemaDaoImpl.MAX_SEMANTIC_VERSION_CHARS+1);\n+\t\tnewSchemaVersionRequest.withSemanticVersion(semanticVersion);\n+\t\tString message = assertThrows(IllegalArgumentException.class, ()->{\n+\t\t\tjsonSchemaDao.createNewSchemaVersion(newSchemaVersionRequest);\n+\t\t}).getMessage();\n+\t\tassertEquals(\"Semantic version must be \"+JsonSchemaDaoImpl.MAX_SEMANTIC_VERSION_CHARS+\" characters or less\", message);\n+\t}\n+\t\n+\t@Test\n+\tpublic void testCreateNewSchemaVerionNullRequest() {\n+\t\tnewSchemaVersionRequest = null;\n+\t\tassertThrows(IllegalArgumentException.class, ()->{\n+\t\t\tjsonSchemaDao.createNewSchemaVersion(newSchemaVersionRequest);\n+\t\t});\n+\t}\n+\t\n+\t@Test\n+\tpublic void testCreateNewSchemaVerionNullRequestNullOrganizationId() {\n+\t\tnewSchemaVersionRequest.withOrganizationId(null);\n+\t\tassertThrows(IllegalArgumentException.class, ()->{\n+\t\t\tjsonSchemaDao.createNewSchemaVersion(newSchemaVersionRequest);\n+\t\t});\n+\t}\n+\t\n+\t@Test\n+\tpublic void testCreateNewSchemaVerionNullRequestNullSchemaName() {\n+\t\tnewSchemaVersionRequest.withSchemaName(null);\n+\t\tassertThrows(IllegalArgumentException.class, ()->{\n+\t\t\tjsonSchemaDao.createNewSchemaVersion(newSchemaVersionRequest);\n+\t\t});\n+\t}\n+\t\n+\t@Test\n+\tpublic void testCreateNewSchemaVerionNullRequestNullCreatedBy() {\n+\t\tnewSchemaVersionRequest.withCreatedBy(null);\n+\t\tassertThrows(IllegalArgumentException.class, ()->{\n+\t\t\tjsonSchemaDao.createNewSchemaVersion(newSchemaVersionRequest);\n+\t\t});\n+\t}\n+\t\n+\t@Test\n+\tpublic void testCreateNewSchemaVersionNullSemanticVersion() {\n+\t\tsemanticVersion = null;\n+\t\tnewSchemaVersionRequest.withSemanticVersion(semanticVersion);\n+\t\tJsonSchemaVersionInfo info = jsonSchemaDao.createNewSchemaVersion(newSchemaVersionRequest);\n+\t\tassertNotNull(info);\n+\t\tassertEquals(semanticVersion, info.getSemanticVersion());\n+\t}\n+\t\n+\t@Test\n+\tpublic void testCreateNewSchemaVerionNullSchema() {\n+\t\tnewSchemaVersionRequest.withJsonSchema(null);\n+\t\tassertThrows(IllegalArgumentException.class, ()->{\n+\t\t\tjsonSchemaDao.createNewSchemaVersion(newSchemaVersionRequest);\n+\t\t});\n+\t}\n+\n+\t/**\n+\t * Helper to create a new JSON schema with the given $id\n+\t * \n+\t * @param schema\n+\t * @return\n+\t * @throws JSONObjectAdapterException\n+\t */\n+\tJsonSchemaVersionInfo createNewSchemaVersion(String id, int index) throws JSONObjectAdapterException {\n+\t\tSchemaId schemaId = SchemaIdParser.parseSchemaId(id);\n+\t\tString organizationName = schemaId.getOrganizationName().toString();\n+\t\tString schemaName = schemaId.getSchemaName().toString();\n+\t\tString semanticVersion = null;\n+\t\tif (schemaId.getSemanticVersion() != null) {\n+\t\t\tsemanticVersion = schemaId.getSemanticVersion().toString();\n+\t\t}\n+\t\tOrganization organization = null;\n+\t\ttry {\n+\t\t\torganization = organizationDao.getOrganizationByName(organizationName);\n+\t\t} catch (NotFoundException e) {\n+\t\t\torganization = organizationDao.createOrganization(organizationName, adminUserId);\n+\t\t}\n+\t\tschema = new JsonSchema();\n+\t\tschema.set$id(id);\n+\t\tschema.setDescription(\"index:\" + index);\n+\t\treturn jsonSchemaDao.createNewSchemaVersion(\n+\t\t\t\tnew NewSchemaVersionRequest().withOrganizationId(organization.getId()).withCreatedBy(createdBy)\n+\t\t\t\t\t\t.withJsonSchema(schema).withSchemaName(schemaName).withSemanticVersion(semanticVersion));\n+\t}\n+\n+\t/**\n+\t * Helper to get the SHA-256 hex string for a given schema.\n+\t * \n+\t * @param schema\n+\t * @return\n+\t * @throws JSONObjectAdapterException\n+\t */\n+\tstatic String getSchemaSHA256Hex(JsonSchema schema) throws JSONObjectAdapterException {\n+\t\tString json = EntityFactory.createJSONStringForEntity(schema);\n+\t\treturn DigestUtils.sha256Hex(json);\n+\t}\n+\n+\t@Test\n+\tpublic void testGetLatestVersion() throws JSONObjectAdapterException {\n+\t\tint index = 0;\n+\t\tcreateNewSchemaVersion(\"my.org.edu/foo.bar\", index++);\n+\t\tcreateNewSchemaVersion(\"my.org.edu/foo.bar\", index++);\n+\t\tcreateNewSchemaVersion(\"my.org.edu/foo.bar/1.0.1\", index++);\n+\t\tJsonSchemaVersionInfo lastVersion = createNewSchemaVersion(\"my.org.edu/foo.bar\", index++);\n+\t\tcreateNewSchemaVersion(\"other.org/foo.bar\", index++);\n+\t\tcreateNewSchemaVersion(\"my.org.edu/foo.bar.other\", index++);\n+\t\t// Call under test\n+\t\tString versionId = jsonSchemaDao.getLatestVersionId(\"my.org.edu\", \"foo.bar\");\n+\t\tassertEquals(lastVersion.getVersionId(), versionId);\n+\t}\n+\n+\t@Test\n+\tpublic void testGetLatestVersionOrganziationNotFound() throws JSONObjectAdapterException {\n+\t\tint index = 0;\n+\t\tcreateNewSchemaVersion(\"my.org.edu/foo.bar\", index++);\n+\t\tString message = assertThrows(NotFoundException.class, () -> {\n+\t\t\tjsonSchemaDao.getLatestVersionId(\"other.org\", \"foo.bar\");\n+\t\t}).getMessage();\n+\t\tassertEquals(\"JSON Schema not found for organizationName: 'other.org' and schemaName: 'foo.bar'\", message);\n+\t}\n+\n+\t@Test\n+\tpublic void testGetLatestVersionSchemaNameNotFound() throws JSONObjectAdapterException {\n+\t\tint index = 0;\n+\t\tcreateNewSchemaVersion(\"my.org.edu/foo.bar\", index++);\n+\t\tString message = assertThrows(NotFoundException.class, () -> {\n+\t\t\tjsonSchemaDao.getLatestVersionId(\"my.org.edu\", \"other.schema.name\");\n+\t\t}).getMessage();\n+\t\tassertEquals(\"JSON Schema not found for organizationName: 'my.org.edu' and schemaName: 'other.schema.name'\",\n+\t\t\t\tmessage);\n+\t}\n+\n+\t@Test\n+\tpublic void testGetSchemaLatestVersionNullOrganization() {\n+\t\tString organizationName = null;\n+\t\tString schemaName = \"other.schema.name\";\n+\t\tassertThrows(IllegalArgumentException.class, () -> {\n+\t\t\tjsonSchemaDao.getLatestVersionId(organizationName, schemaName);\n+\t\t});\n+\t}\n+\n+\t@Test\n+\tpublic void testGetSchemaLatestVersionNullSchema() {\n+\t\tString organizationName = \"my.org.edu\";\n+\t\tString schemaName = null;\n+\t\tassertThrows(IllegalArgumentException.class, () -> {\n+\t\t\tjsonSchemaDao.getLatestVersionId(organizationName, schemaName);\n+\t\t});\n+\t}\n+\n+\t@Test\n+\tpublic void testGetVersionId() throws JSONObjectAdapterException {\n+\t\tint index = 0;\n+\t\tcreateNewSchemaVersion(\"my.org.edu/foo.bar/0.0.1\", index++);\n+\t\tcreateNewSchemaVersion(\"my.org.edu/foo.bar\", index++);\n+\t\tJsonSchemaVersionInfo expected = createNewSchemaVersion(\"my.org.edu/foo.bar/1.0.1\", index++);\n+\t\tcreateNewSchemaVersion(\"my.org.edu/foo.bar\", index++);\n+\t\tcreateNewSchemaVersion(\"other.org/foo.bar\", index++);\n+\t\tcreateNewSchemaVersion(\"my.org.edu/foo.bar.other\", index++);\n+\n+\t\tString organizationName = \"my.org.edu\";\n+\t\tString schemaName = \"foo.bar\";\n+\t\tString semanticVersion = \"1.0.1\";\n+\t\t// call under test\n+\t\tString versionId = jsonSchemaDao.getVersionId(organizationName, schemaName, semanticVersion);\n+\t\tassertNotNull(versionId);\n+\t\tassertEquals(expected.getVersionId(), versionId);\n+\t}\n+\n+\t@Test\n+\tpublic void testGetVersionIdNotFound() throws JSONObjectAdapterException {\n+\t\tint index = 0;\n+\t\tcreateNewSchemaVersion(\"my.org.edu/foo.bar/0.0.1\", index++);\n+\n+\t\tString organizationName = \"my.org.edu\";\n+\t\tString schemaName = \"foo.bar\";\n+\t\tString semanticVersion = \"1.0.1\";\n+\t\t// call under test\n+\t\tString message = assertThrows(NotFoundException.class, () -> {\n+\t\t\tjsonSchemaDao.getVersionId(organizationName, schemaName, semanticVersion);\n+\t\t}).getMessage();\n+\t\tassertEquals(\n+\t\t\t\t\"JSON Schema not found for organizationName: 'my.org.edu' and schemaName: 'foo.bar' and semanticVersion: '1.0.1'\",\n+\t\t\t\tmessage);\n+\t}\n+\n+\t@Test\n+\tpublic void testGetVersionIdNullOrgName() throws JSONObjectAdapterException {\n+\t\tString organizationName = null;\n+\t\tString schemaName = \"foo.bar\";\n+\t\tString semanticVersion = \"1.0.1\";\n+\t\t// call under test\n+\t\tassertThrows(IllegalArgumentException.class, () -> {\n+\t\t\tjsonSchemaDao.getVersionId(organizationName, schemaName, semanticVersion);\n+\t\t});\n+\t}\n+\n+\t@Test\n+\tpublic void testGetVersionIdNullSchemaName() throws JSONObjectAdapterException {\n+\t\tString organizationName = \"my.org.edu\";\n+\t\tString schemaName = null;\n+\t\tString semanticVersion = \"1.0.1\";\n+\t\t// call under test\n+\t\tassertThrows(IllegalArgumentException.class, () -> {\n+\t\t\tjsonSchemaDao.getVersionId(organizationName, schemaName, semanticVersion);\n+\t\t});\n+\t}\n+\n+\t@Test\n+\tpublic void testGetVersionIdNullSemanticVersion() throws JSONObjectAdapterException {\n+\t\tString organizationName = \"my.org.edu\";\n+\t\tString schemaName = \"foo.bar\";\n+\t\tString semanticVersion = null;\n+\t\t// call under test\n+\t\tassertThrows(IllegalArgumentException.class, () -> {\n+\t\t\tjsonSchemaDao.getVersionId(organizationName, schemaName, semanticVersion);\n+\t\t});\n+\t}\n+\n+\t@Test\n+\tpublic void testGetVersionInfoTripple() throws JSONObjectAdapterException {\n+\t\tint index = 0;\n+\t\tcreateNewSchemaVersion(\"my.org.edu/foo.bar/0.0.1\", index++);\n+\t\tcreateNewSchemaVersion(\"my.org.edu/foo.bar\", index++);\n+\t\tJsonSchemaVersionInfo expected = createNewSchemaVersion(\"my.org.edu/foo.bar/1.0.1\", index++);\n+\t\tcreateNewSchemaVersion(\"my.org.edu/foo.bar\", index++);\n+\t\tcreateNewSchemaVersion(\"other.org/foo.bar\", index++);\n+\t\tcreateNewSchemaVersion(\"my.org.edu/foo.bar.other\", index++);\n+\n+\t\t// call under test\n+\t\tJsonSchemaVersionInfo resultInfo = jsonSchemaDao.getVersionInfo(\"my.org.edu\", \"foo.bar\", \"1.0.1\");\n+\t\tassertEquals(expected, resultInfo);\n+\t}\n+\n+\t@Test\n+\tpublic void testGetSchemaVersionOrganizationNotFound() throws JSONObjectAdapterException {\n+\t\tint index = 0;\n+\t\tcreateNewSchemaVersion(\"my.org.edu/foo.bar/1.0.1\", index++);\n+\t\tString message = assertThrows(NotFoundException.class, () -> {\n+\t\t\tjsonSchemaDao.getVersionInfo(\"other.org\", \"foo.bar\", \"1.0.1\");\n+\t\t}).getMessage();\n+\t\tassertEquals(\n+\t\t\t\t\"JSON Schema not found for organizationName: 'other.org' and schemaName: 'foo.bar' and semanticVersion: '1.0.1'\",\n+\t\t\t\tmessage);\n+\t}\n+\n+\t@Test\n+\tpublic void testGetSchemaVersionSchemaNameNotFound() throws JSONObjectAdapterException {\n+\t\tint index = 0;\n+\t\tcreateNewSchemaVersion(\"my.org.edu/foo.bar/1.0.1\", index++);\n+\t\tassertThrows(NotFoundException.class, () -> {\n+\t\t\tjsonSchemaDao.getVersionInfo(\"my.org.edu\", \"foo.bar.bar\", \"1.0.1\");\n+\t\t});", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b7ab950d66569dedcb77d15bfc43d23b610e95fe"}, "originalPosition": 657}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU5NDM0ODYzOnYy", "diffSide": "RIGHT", "path": "lib/jdomodels/src/test/java/org/sagebionetworks/repo/model/dbo/schema/JsonSchemaDaoImplTest.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOFQyMzoxNDo0M1rOGNqZdA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOFQyMzoxNDo0M1rOGNqZdA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjk3OTMxNg==", "bodyText": "Add assert on message", "url": "https://github.com/Sage-Bionetworks/Synapse-Repository-Services/pull/4008#discussion_r416979316", "createdAt": "2020-04-28T23:14:43Z", "author": {"login": "marcomarasca"}, "path": "lib/jdomodels/src/test/java/org/sagebionetworks/repo/model/dbo/schema/JsonSchemaDaoImplTest.java", "diffHunk": "@@ -318,4 +308,532 @@ public void testGetVersionInfoNullId() {\n \t\t});\n \t}\n \n+\t@Test\n+\tpublic void testCreateNewSchemaVersion() {\n+\t\t// Call under test\n+\t\tJsonSchemaVersionInfo info = jsonSchemaDao.createNewSchemaVersion(newSchemaVersionRequest);\n+\t\tassertNotNull(info);\n+\t\tassertEquals(organizationId, info.getOrganizationId());\n+\t\tassertEquals(organizationName, info.getOrganizationName());\n+\t\tassertNotNull(info.getSchemaId());\n+\t\tassertEquals(schemaName, info.getSchemaName());\n+\t\tassertEquals(createdBy.toString(), info.getCreatedBy());\n+\t\tassertEquals(semanticVersion, info.getSemanticVersion());\n+\t\tassertNotNull(info.getVersionId());\n+\t\tassertEquals(schemaJsonSha256Hex ,info.getJsonSHA256Hex());\n+\t}\n+\t\n+\t@Test\n+\tpublic void testCreateNewSchemaVersionSchemaNameAtLimit() {\n+\t\tString schemaName = StringUtils.repeat(\"a\", JsonSchemaDaoImpl.MAX_SCHEMA_NAME_CHARS);\n+\t\tnewSchemaVersionRequest.withSchemaName(schemaName);\n+\t\tJsonSchemaVersionInfo info = jsonSchemaDao.createNewSchemaVersion(newSchemaVersionRequest);\n+\t\tassertNotNull(info);\n+\t\tassertEquals(schemaName, info.getSchemaName());\n+\t}\n+\t\n+\t@Test\n+\tpublic void testCreateNewSchemaVersionSchemaNameOverLimit() {\n+\t\tString schemaName = StringUtils.repeat(\"a\", JsonSchemaDaoImpl.MAX_SCHEMA_NAME_CHARS+1);\n+\t\tnewSchemaVersionRequest.withSchemaName(schemaName);\n+\t\tString message = assertThrows(IllegalArgumentException.class, ()->{\n+\t\t\tjsonSchemaDao.createNewSchemaVersion(newSchemaVersionRequest);\n+\t\t}).getMessage();\n+\t\tassertEquals(\"Schema name must be \"+JsonSchemaDaoImpl.MAX_SCHEMA_NAME_CHARS+\" characters or less\", message);\n+\t}\n+\t\n+\t@Test\n+\tpublic void testCreateNewSchemaVersionSemanticVersionAtLimit() {\n+\t\tsemanticVersion = StringUtils.repeat(\"a\", JsonSchemaDaoImpl.MAX_SEMANTIC_VERSION_CHARS);\n+\t\tnewSchemaVersionRequest.withSemanticVersion(semanticVersion);\n+\t\tJsonSchemaVersionInfo info = jsonSchemaDao.createNewSchemaVersion(newSchemaVersionRequest);\n+\t\tassertNotNull(info);\n+\t\tassertEquals(semanticVersion, info.getSemanticVersion());\n+\t}\n+\t\n+\t@Test\n+\tpublic void testCreateNewSchemaVersionSemanticVersionOverLimit() {\n+\t\tsemanticVersion = StringUtils.repeat(\"a\", JsonSchemaDaoImpl.MAX_SEMANTIC_VERSION_CHARS+1);\n+\t\tnewSchemaVersionRequest.withSemanticVersion(semanticVersion);\n+\t\tString message = assertThrows(IllegalArgumentException.class, ()->{\n+\t\t\tjsonSchemaDao.createNewSchemaVersion(newSchemaVersionRequest);\n+\t\t}).getMessage();\n+\t\tassertEquals(\"Semantic version must be \"+JsonSchemaDaoImpl.MAX_SEMANTIC_VERSION_CHARS+\" characters or less\", message);\n+\t}\n+\t\n+\t@Test\n+\tpublic void testCreateNewSchemaVerionNullRequest() {\n+\t\tnewSchemaVersionRequest = null;\n+\t\tassertThrows(IllegalArgumentException.class, ()->{\n+\t\t\tjsonSchemaDao.createNewSchemaVersion(newSchemaVersionRequest);\n+\t\t});\n+\t}\n+\t\n+\t@Test\n+\tpublic void testCreateNewSchemaVerionNullRequestNullOrganizationId() {\n+\t\tnewSchemaVersionRequest.withOrganizationId(null);\n+\t\tassertThrows(IllegalArgumentException.class, ()->{\n+\t\t\tjsonSchemaDao.createNewSchemaVersion(newSchemaVersionRequest);\n+\t\t});\n+\t}\n+\t\n+\t@Test\n+\tpublic void testCreateNewSchemaVerionNullRequestNullSchemaName() {\n+\t\tnewSchemaVersionRequest.withSchemaName(null);\n+\t\tassertThrows(IllegalArgumentException.class, ()->{\n+\t\t\tjsonSchemaDao.createNewSchemaVersion(newSchemaVersionRequest);\n+\t\t});\n+\t}\n+\t\n+\t@Test\n+\tpublic void testCreateNewSchemaVerionNullRequestNullCreatedBy() {\n+\t\tnewSchemaVersionRequest.withCreatedBy(null);\n+\t\tassertThrows(IllegalArgumentException.class, ()->{\n+\t\t\tjsonSchemaDao.createNewSchemaVersion(newSchemaVersionRequest);\n+\t\t});\n+\t}\n+\t\n+\t@Test\n+\tpublic void testCreateNewSchemaVersionNullSemanticVersion() {\n+\t\tsemanticVersion = null;\n+\t\tnewSchemaVersionRequest.withSemanticVersion(semanticVersion);\n+\t\tJsonSchemaVersionInfo info = jsonSchemaDao.createNewSchemaVersion(newSchemaVersionRequest);\n+\t\tassertNotNull(info);\n+\t\tassertEquals(semanticVersion, info.getSemanticVersion());\n+\t}\n+\t\n+\t@Test\n+\tpublic void testCreateNewSchemaVerionNullSchema() {\n+\t\tnewSchemaVersionRequest.withJsonSchema(null);\n+\t\tassertThrows(IllegalArgumentException.class, ()->{\n+\t\t\tjsonSchemaDao.createNewSchemaVersion(newSchemaVersionRequest);\n+\t\t});\n+\t}\n+\n+\t/**\n+\t * Helper to create a new JSON schema with the given $id\n+\t * \n+\t * @param schema\n+\t * @return\n+\t * @throws JSONObjectAdapterException\n+\t */\n+\tJsonSchemaVersionInfo createNewSchemaVersion(String id, int index) throws JSONObjectAdapterException {\n+\t\tSchemaId schemaId = SchemaIdParser.parseSchemaId(id);\n+\t\tString organizationName = schemaId.getOrganizationName().toString();\n+\t\tString schemaName = schemaId.getSchemaName().toString();\n+\t\tString semanticVersion = null;\n+\t\tif (schemaId.getSemanticVersion() != null) {\n+\t\t\tsemanticVersion = schemaId.getSemanticVersion().toString();\n+\t\t}\n+\t\tOrganization organization = null;\n+\t\ttry {\n+\t\t\torganization = organizationDao.getOrganizationByName(organizationName);\n+\t\t} catch (NotFoundException e) {\n+\t\t\torganization = organizationDao.createOrganization(organizationName, adminUserId);\n+\t\t}\n+\t\tschema = new JsonSchema();\n+\t\tschema.set$id(id);\n+\t\tschema.setDescription(\"index:\" + index);\n+\t\treturn jsonSchemaDao.createNewSchemaVersion(\n+\t\t\t\tnew NewSchemaVersionRequest().withOrganizationId(organization.getId()).withCreatedBy(createdBy)\n+\t\t\t\t\t\t.withJsonSchema(schema).withSchemaName(schemaName).withSemanticVersion(semanticVersion));\n+\t}\n+\n+\t/**\n+\t * Helper to get the SHA-256 hex string for a given schema.\n+\t * \n+\t * @param schema\n+\t * @return\n+\t * @throws JSONObjectAdapterException\n+\t */\n+\tstatic String getSchemaSHA256Hex(JsonSchema schema) throws JSONObjectAdapterException {\n+\t\tString json = EntityFactory.createJSONStringForEntity(schema);\n+\t\treturn DigestUtils.sha256Hex(json);\n+\t}\n+\n+\t@Test\n+\tpublic void testGetLatestVersion() throws JSONObjectAdapterException {\n+\t\tint index = 0;\n+\t\tcreateNewSchemaVersion(\"my.org.edu/foo.bar\", index++);\n+\t\tcreateNewSchemaVersion(\"my.org.edu/foo.bar\", index++);\n+\t\tcreateNewSchemaVersion(\"my.org.edu/foo.bar/1.0.1\", index++);\n+\t\tJsonSchemaVersionInfo lastVersion = createNewSchemaVersion(\"my.org.edu/foo.bar\", index++);\n+\t\tcreateNewSchemaVersion(\"other.org/foo.bar\", index++);\n+\t\tcreateNewSchemaVersion(\"my.org.edu/foo.bar.other\", index++);\n+\t\t// Call under test\n+\t\tString versionId = jsonSchemaDao.getLatestVersionId(\"my.org.edu\", \"foo.bar\");\n+\t\tassertEquals(lastVersion.getVersionId(), versionId);\n+\t}\n+\n+\t@Test\n+\tpublic void testGetLatestVersionOrganziationNotFound() throws JSONObjectAdapterException {\n+\t\tint index = 0;\n+\t\tcreateNewSchemaVersion(\"my.org.edu/foo.bar\", index++);\n+\t\tString message = assertThrows(NotFoundException.class, () -> {\n+\t\t\tjsonSchemaDao.getLatestVersionId(\"other.org\", \"foo.bar\");\n+\t\t}).getMessage();\n+\t\tassertEquals(\"JSON Schema not found for organizationName: 'other.org' and schemaName: 'foo.bar'\", message);\n+\t}\n+\n+\t@Test\n+\tpublic void testGetLatestVersionSchemaNameNotFound() throws JSONObjectAdapterException {\n+\t\tint index = 0;\n+\t\tcreateNewSchemaVersion(\"my.org.edu/foo.bar\", index++);\n+\t\tString message = assertThrows(NotFoundException.class, () -> {\n+\t\t\tjsonSchemaDao.getLatestVersionId(\"my.org.edu\", \"other.schema.name\");\n+\t\t}).getMessage();\n+\t\tassertEquals(\"JSON Schema not found for organizationName: 'my.org.edu' and schemaName: 'other.schema.name'\",\n+\t\t\t\tmessage);\n+\t}\n+\n+\t@Test\n+\tpublic void testGetSchemaLatestVersionNullOrganization() {\n+\t\tString organizationName = null;\n+\t\tString schemaName = \"other.schema.name\";\n+\t\tassertThrows(IllegalArgumentException.class, () -> {\n+\t\t\tjsonSchemaDao.getLatestVersionId(organizationName, schemaName);\n+\t\t});\n+\t}\n+\n+\t@Test\n+\tpublic void testGetSchemaLatestVersionNullSchema() {\n+\t\tString organizationName = \"my.org.edu\";\n+\t\tString schemaName = null;\n+\t\tassertThrows(IllegalArgumentException.class, () -> {\n+\t\t\tjsonSchemaDao.getLatestVersionId(organizationName, schemaName);\n+\t\t});\n+\t}\n+\n+\t@Test\n+\tpublic void testGetVersionId() throws JSONObjectAdapterException {\n+\t\tint index = 0;\n+\t\tcreateNewSchemaVersion(\"my.org.edu/foo.bar/0.0.1\", index++);\n+\t\tcreateNewSchemaVersion(\"my.org.edu/foo.bar\", index++);\n+\t\tJsonSchemaVersionInfo expected = createNewSchemaVersion(\"my.org.edu/foo.bar/1.0.1\", index++);\n+\t\tcreateNewSchemaVersion(\"my.org.edu/foo.bar\", index++);\n+\t\tcreateNewSchemaVersion(\"other.org/foo.bar\", index++);\n+\t\tcreateNewSchemaVersion(\"my.org.edu/foo.bar.other\", index++);\n+\n+\t\tString organizationName = \"my.org.edu\";\n+\t\tString schemaName = \"foo.bar\";\n+\t\tString semanticVersion = \"1.0.1\";\n+\t\t// call under test\n+\t\tString versionId = jsonSchemaDao.getVersionId(organizationName, schemaName, semanticVersion);\n+\t\tassertNotNull(versionId);\n+\t\tassertEquals(expected.getVersionId(), versionId);\n+\t}\n+\n+\t@Test\n+\tpublic void testGetVersionIdNotFound() throws JSONObjectAdapterException {\n+\t\tint index = 0;\n+\t\tcreateNewSchemaVersion(\"my.org.edu/foo.bar/0.0.1\", index++);\n+\n+\t\tString organizationName = \"my.org.edu\";\n+\t\tString schemaName = \"foo.bar\";\n+\t\tString semanticVersion = \"1.0.1\";\n+\t\t// call under test\n+\t\tString message = assertThrows(NotFoundException.class, () -> {\n+\t\t\tjsonSchemaDao.getVersionId(organizationName, schemaName, semanticVersion);\n+\t\t}).getMessage();\n+\t\tassertEquals(\n+\t\t\t\t\"JSON Schema not found for organizationName: 'my.org.edu' and schemaName: 'foo.bar' and semanticVersion: '1.0.1'\",\n+\t\t\t\tmessage);\n+\t}\n+\n+\t@Test\n+\tpublic void testGetVersionIdNullOrgName() throws JSONObjectAdapterException {\n+\t\tString organizationName = null;\n+\t\tString schemaName = \"foo.bar\";\n+\t\tString semanticVersion = \"1.0.1\";\n+\t\t// call under test\n+\t\tassertThrows(IllegalArgumentException.class, () -> {\n+\t\t\tjsonSchemaDao.getVersionId(organizationName, schemaName, semanticVersion);\n+\t\t});\n+\t}\n+\n+\t@Test\n+\tpublic void testGetVersionIdNullSchemaName() throws JSONObjectAdapterException {\n+\t\tString organizationName = \"my.org.edu\";\n+\t\tString schemaName = null;\n+\t\tString semanticVersion = \"1.0.1\";\n+\t\t// call under test\n+\t\tassertThrows(IllegalArgumentException.class, () -> {\n+\t\t\tjsonSchemaDao.getVersionId(organizationName, schemaName, semanticVersion);\n+\t\t});\n+\t}\n+\n+\t@Test\n+\tpublic void testGetVersionIdNullSemanticVersion() throws JSONObjectAdapterException {\n+\t\tString organizationName = \"my.org.edu\";\n+\t\tString schemaName = \"foo.bar\";\n+\t\tString semanticVersion = null;\n+\t\t// call under test\n+\t\tassertThrows(IllegalArgumentException.class, () -> {\n+\t\t\tjsonSchemaDao.getVersionId(organizationName, schemaName, semanticVersion);\n+\t\t});\n+\t}\n+\n+\t@Test\n+\tpublic void testGetVersionInfoTripple() throws JSONObjectAdapterException {\n+\t\tint index = 0;\n+\t\tcreateNewSchemaVersion(\"my.org.edu/foo.bar/0.0.1\", index++);\n+\t\tcreateNewSchemaVersion(\"my.org.edu/foo.bar\", index++);\n+\t\tJsonSchemaVersionInfo expected = createNewSchemaVersion(\"my.org.edu/foo.bar/1.0.1\", index++);\n+\t\tcreateNewSchemaVersion(\"my.org.edu/foo.bar\", index++);\n+\t\tcreateNewSchemaVersion(\"other.org/foo.bar\", index++);\n+\t\tcreateNewSchemaVersion(\"my.org.edu/foo.bar.other\", index++);\n+\n+\t\t// call under test\n+\t\tJsonSchemaVersionInfo resultInfo = jsonSchemaDao.getVersionInfo(\"my.org.edu\", \"foo.bar\", \"1.0.1\");\n+\t\tassertEquals(expected, resultInfo);\n+\t}\n+\n+\t@Test\n+\tpublic void testGetSchemaVersionOrganizationNotFound() throws JSONObjectAdapterException {\n+\t\tint index = 0;\n+\t\tcreateNewSchemaVersion(\"my.org.edu/foo.bar/1.0.1\", index++);\n+\t\tString message = assertThrows(NotFoundException.class, () -> {\n+\t\t\tjsonSchemaDao.getVersionInfo(\"other.org\", \"foo.bar\", \"1.0.1\");\n+\t\t}).getMessage();\n+\t\tassertEquals(\n+\t\t\t\t\"JSON Schema not found for organizationName: 'other.org' and schemaName: 'foo.bar' and semanticVersion: '1.0.1'\",\n+\t\t\t\tmessage);\n+\t}\n+\n+\t@Test\n+\tpublic void testGetSchemaVersionSchemaNameNotFound() throws JSONObjectAdapterException {\n+\t\tint index = 0;\n+\t\tcreateNewSchemaVersion(\"my.org.edu/foo.bar/1.0.1\", index++);\n+\t\tassertThrows(NotFoundException.class, () -> {\n+\t\t\tjsonSchemaDao.getVersionInfo(\"my.org.edu\", \"foo.bar.bar\", \"1.0.1\");\n+\t\t});\n+\t}\n+\n+\t@Test\n+\tpublic void testGetVersionInfoWithVersionNotFound() throws JSONObjectAdapterException {\n+\t\tint index = 0;\n+\t\tcreateNewSchemaVersion(\"my.org.edu/foo.bar/1.0.1\", index++);\n+\t\tassertThrows(NotFoundException.class, () -> {\n+\t\t\tjsonSchemaDao.getVersionInfo(\"my.org.edu\", \"foo.bar\", \"1.0.2\");\n+\t\t});", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b7ab950d66569dedcb77d15bfc43d23b610e95fe"}, "originalPosition": 666}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU5NDM1MjIyOnYy", "diffSide": "RIGHT", "path": "lib/jdomodels/src/test/java/org/sagebionetworks/repo/model/dbo/schema/JsonSchemaDaoImplTest.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOFQyMzoxNjowN1rOGNqbdg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOFQyMzoxNjowN1rOGNqbdg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjk3OTgzMA==", "bodyText": "Add in a different schema (org or name) and make sure it does not get deleted (maybe with same semanticVersion)", "url": "https://github.com/Sage-Bionetworks/Synapse-Repository-Services/pull/4008#discussion_r416979830", "createdAt": "2020-04-28T23:16:07Z", "author": {"login": "marcomarasca"}, "path": "lib/jdomodels/src/test/java/org/sagebionetworks/repo/model/dbo/schema/JsonSchemaDaoImplTest.java", "diffHunk": "@@ -318,4 +308,532 @@ public void testGetVersionInfoNullId() {\n \t\t});\n \t}\n \n+\t@Test\n+\tpublic void testCreateNewSchemaVersion() {\n+\t\t// Call under test\n+\t\tJsonSchemaVersionInfo info = jsonSchemaDao.createNewSchemaVersion(newSchemaVersionRequest);\n+\t\tassertNotNull(info);\n+\t\tassertEquals(organizationId, info.getOrganizationId());\n+\t\tassertEquals(organizationName, info.getOrganizationName());\n+\t\tassertNotNull(info.getSchemaId());\n+\t\tassertEquals(schemaName, info.getSchemaName());\n+\t\tassertEquals(createdBy.toString(), info.getCreatedBy());\n+\t\tassertEquals(semanticVersion, info.getSemanticVersion());\n+\t\tassertNotNull(info.getVersionId());\n+\t\tassertEquals(schemaJsonSha256Hex ,info.getJsonSHA256Hex());\n+\t}\n+\t\n+\t@Test\n+\tpublic void testCreateNewSchemaVersionSchemaNameAtLimit() {\n+\t\tString schemaName = StringUtils.repeat(\"a\", JsonSchemaDaoImpl.MAX_SCHEMA_NAME_CHARS);\n+\t\tnewSchemaVersionRequest.withSchemaName(schemaName);\n+\t\tJsonSchemaVersionInfo info = jsonSchemaDao.createNewSchemaVersion(newSchemaVersionRequest);\n+\t\tassertNotNull(info);\n+\t\tassertEquals(schemaName, info.getSchemaName());\n+\t}\n+\t\n+\t@Test\n+\tpublic void testCreateNewSchemaVersionSchemaNameOverLimit() {\n+\t\tString schemaName = StringUtils.repeat(\"a\", JsonSchemaDaoImpl.MAX_SCHEMA_NAME_CHARS+1);\n+\t\tnewSchemaVersionRequest.withSchemaName(schemaName);\n+\t\tString message = assertThrows(IllegalArgumentException.class, ()->{\n+\t\t\tjsonSchemaDao.createNewSchemaVersion(newSchemaVersionRequest);\n+\t\t}).getMessage();\n+\t\tassertEquals(\"Schema name must be \"+JsonSchemaDaoImpl.MAX_SCHEMA_NAME_CHARS+\" characters or less\", message);\n+\t}\n+\t\n+\t@Test\n+\tpublic void testCreateNewSchemaVersionSemanticVersionAtLimit() {\n+\t\tsemanticVersion = StringUtils.repeat(\"a\", JsonSchemaDaoImpl.MAX_SEMANTIC_VERSION_CHARS);\n+\t\tnewSchemaVersionRequest.withSemanticVersion(semanticVersion);\n+\t\tJsonSchemaVersionInfo info = jsonSchemaDao.createNewSchemaVersion(newSchemaVersionRequest);\n+\t\tassertNotNull(info);\n+\t\tassertEquals(semanticVersion, info.getSemanticVersion());\n+\t}\n+\t\n+\t@Test\n+\tpublic void testCreateNewSchemaVersionSemanticVersionOverLimit() {\n+\t\tsemanticVersion = StringUtils.repeat(\"a\", JsonSchemaDaoImpl.MAX_SEMANTIC_VERSION_CHARS+1);\n+\t\tnewSchemaVersionRequest.withSemanticVersion(semanticVersion);\n+\t\tString message = assertThrows(IllegalArgumentException.class, ()->{\n+\t\t\tjsonSchemaDao.createNewSchemaVersion(newSchemaVersionRequest);\n+\t\t}).getMessage();\n+\t\tassertEquals(\"Semantic version must be \"+JsonSchemaDaoImpl.MAX_SEMANTIC_VERSION_CHARS+\" characters or less\", message);\n+\t}\n+\t\n+\t@Test\n+\tpublic void testCreateNewSchemaVerionNullRequest() {\n+\t\tnewSchemaVersionRequest = null;\n+\t\tassertThrows(IllegalArgumentException.class, ()->{\n+\t\t\tjsonSchemaDao.createNewSchemaVersion(newSchemaVersionRequest);\n+\t\t});\n+\t}\n+\t\n+\t@Test\n+\tpublic void testCreateNewSchemaVerionNullRequestNullOrganizationId() {\n+\t\tnewSchemaVersionRequest.withOrganizationId(null);\n+\t\tassertThrows(IllegalArgumentException.class, ()->{\n+\t\t\tjsonSchemaDao.createNewSchemaVersion(newSchemaVersionRequest);\n+\t\t});\n+\t}\n+\t\n+\t@Test\n+\tpublic void testCreateNewSchemaVerionNullRequestNullSchemaName() {\n+\t\tnewSchemaVersionRequest.withSchemaName(null);\n+\t\tassertThrows(IllegalArgumentException.class, ()->{\n+\t\t\tjsonSchemaDao.createNewSchemaVersion(newSchemaVersionRequest);\n+\t\t});\n+\t}\n+\t\n+\t@Test\n+\tpublic void testCreateNewSchemaVerionNullRequestNullCreatedBy() {\n+\t\tnewSchemaVersionRequest.withCreatedBy(null);\n+\t\tassertThrows(IllegalArgumentException.class, ()->{\n+\t\t\tjsonSchemaDao.createNewSchemaVersion(newSchemaVersionRequest);\n+\t\t});\n+\t}\n+\t\n+\t@Test\n+\tpublic void testCreateNewSchemaVersionNullSemanticVersion() {\n+\t\tsemanticVersion = null;\n+\t\tnewSchemaVersionRequest.withSemanticVersion(semanticVersion);\n+\t\tJsonSchemaVersionInfo info = jsonSchemaDao.createNewSchemaVersion(newSchemaVersionRequest);\n+\t\tassertNotNull(info);\n+\t\tassertEquals(semanticVersion, info.getSemanticVersion());\n+\t}\n+\t\n+\t@Test\n+\tpublic void testCreateNewSchemaVerionNullSchema() {\n+\t\tnewSchemaVersionRequest.withJsonSchema(null);\n+\t\tassertThrows(IllegalArgumentException.class, ()->{\n+\t\t\tjsonSchemaDao.createNewSchemaVersion(newSchemaVersionRequest);\n+\t\t});\n+\t}\n+\n+\t/**\n+\t * Helper to create a new JSON schema with the given $id\n+\t * \n+\t * @param schema\n+\t * @return\n+\t * @throws JSONObjectAdapterException\n+\t */\n+\tJsonSchemaVersionInfo createNewSchemaVersion(String id, int index) throws JSONObjectAdapterException {\n+\t\tSchemaId schemaId = SchemaIdParser.parseSchemaId(id);\n+\t\tString organizationName = schemaId.getOrganizationName().toString();\n+\t\tString schemaName = schemaId.getSchemaName().toString();\n+\t\tString semanticVersion = null;\n+\t\tif (schemaId.getSemanticVersion() != null) {\n+\t\t\tsemanticVersion = schemaId.getSemanticVersion().toString();\n+\t\t}\n+\t\tOrganization organization = null;\n+\t\ttry {\n+\t\t\torganization = organizationDao.getOrganizationByName(organizationName);\n+\t\t} catch (NotFoundException e) {\n+\t\t\torganization = organizationDao.createOrganization(organizationName, adminUserId);\n+\t\t}\n+\t\tschema = new JsonSchema();\n+\t\tschema.set$id(id);\n+\t\tschema.setDescription(\"index:\" + index);\n+\t\treturn jsonSchemaDao.createNewSchemaVersion(\n+\t\t\t\tnew NewSchemaVersionRequest().withOrganizationId(organization.getId()).withCreatedBy(createdBy)\n+\t\t\t\t\t\t.withJsonSchema(schema).withSchemaName(schemaName).withSemanticVersion(semanticVersion));\n+\t}\n+\n+\t/**\n+\t * Helper to get the SHA-256 hex string for a given schema.\n+\t * \n+\t * @param schema\n+\t * @return\n+\t * @throws JSONObjectAdapterException\n+\t */\n+\tstatic String getSchemaSHA256Hex(JsonSchema schema) throws JSONObjectAdapterException {\n+\t\tString json = EntityFactory.createJSONStringForEntity(schema);\n+\t\treturn DigestUtils.sha256Hex(json);\n+\t}\n+\n+\t@Test\n+\tpublic void testGetLatestVersion() throws JSONObjectAdapterException {\n+\t\tint index = 0;\n+\t\tcreateNewSchemaVersion(\"my.org.edu/foo.bar\", index++);\n+\t\tcreateNewSchemaVersion(\"my.org.edu/foo.bar\", index++);\n+\t\tcreateNewSchemaVersion(\"my.org.edu/foo.bar/1.0.1\", index++);\n+\t\tJsonSchemaVersionInfo lastVersion = createNewSchemaVersion(\"my.org.edu/foo.bar\", index++);\n+\t\tcreateNewSchemaVersion(\"other.org/foo.bar\", index++);\n+\t\tcreateNewSchemaVersion(\"my.org.edu/foo.bar.other\", index++);\n+\t\t// Call under test\n+\t\tString versionId = jsonSchemaDao.getLatestVersionId(\"my.org.edu\", \"foo.bar\");\n+\t\tassertEquals(lastVersion.getVersionId(), versionId);\n+\t}\n+\n+\t@Test\n+\tpublic void testGetLatestVersionOrganziationNotFound() throws JSONObjectAdapterException {\n+\t\tint index = 0;\n+\t\tcreateNewSchemaVersion(\"my.org.edu/foo.bar\", index++);\n+\t\tString message = assertThrows(NotFoundException.class, () -> {\n+\t\t\tjsonSchemaDao.getLatestVersionId(\"other.org\", \"foo.bar\");\n+\t\t}).getMessage();\n+\t\tassertEquals(\"JSON Schema not found for organizationName: 'other.org' and schemaName: 'foo.bar'\", message);\n+\t}\n+\n+\t@Test\n+\tpublic void testGetLatestVersionSchemaNameNotFound() throws JSONObjectAdapterException {\n+\t\tint index = 0;\n+\t\tcreateNewSchemaVersion(\"my.org.edu/foo.bar\", index++);\n+\t\tString message = assertThrows(NotFoundException.class, () -> {\n+\t\t\tjsonSchemaDao.getLatestVersionId(\"my.org.edu\", \"other.schema.name\");\n+\t\t}).getMessage();\n+\t\tassertEquals(\"JSON Schema not found for organizationName: 'my.org.edu' and schemaName: 'other.schema.name'\",\n+\t\t\t\tmessage);\n+\t}\n+\n+\t@Test\n+\tpublic void testGetSchemaLatestVersionNullOrganization() {\n+\t\tString organizationName = null;\n+\t\tString schemaName = \"other.schema.name\";\n+\t\tassertThrows(IllegalArgumentException.class, () -> {\n+\t\t\tjsonSchemaDao.getLatestVersionId(organizationName, schemaName);\n+\t\t});\n+\t}\n+\n+\t@Test\n+\tpublic void testGetSchemaLatestVersionNullSchema() {\n+\t\tString organizationName = \"my.org.edu\";\n+\t\tString schemaName = null;\n+\t\tassertThrows(IllegalArgumentException.class, () -> {\n+\t\t\tjsonSchemaDao.getLatestVersionId(organizationName, schemaName);\n+\t\t});\n+\t}\n+\n+\t@Test\n+\tpublic void testGetVersionId() throws JSONObjectAdapterException {\n+\t\tint index = 0;\n+\t\tcreateNewSchemaVersion(\"my.org.edu/foo.bar/0.0.1\", index++);\n+\t\tcreateNewSchemaVersion(\"my.org.edu/foo.bar\", index++);\n+\t\tJsonSchemaVersionInfo expected = createNewSchemaVersion(\"my.org.edu/foo.bar/1.0.1\", index++);\n+\t\tcreateNewSchemaVersion(\"my.org.edu/foo.bar\", index++);\n+\t\tcreateNewSchemaVersion(\"other.org/foo.bar\", index++);\n+\t\tcreateNewSchemaVersion(\"my.org.edu/foo.bar.other\", index++);\n+\n+\t\tString organizationName = \"my.org.edu\";\n+\t\tString schemaName = \"foo.bar\";\n+\t\tString semanticVersion = \"1.0.1\";\n+\t\t// call under test\n+\t\tString versionId = jsonSchemaDao.getVersionId(organizationName, schemaName, semanticVersion);\n+\t\tassertNotNull(versionId);\n+\t\tassertEquals(expected.getVersionId(), versionId);\n+\t}\n+\n+\t@Test\n+\tpublic void testGetVersionIdNotFound() throws JSONObjectAdapterException {\n+\t\tint index = 0;\n+\t\tcreateNewSchemaVersion(\"my.org.edu/foo.bar/0.0.1\", index++);\n+\n+\t\tString organizationName = \"my.org.edu\";\n+\t\tString schemaName = \"foo.bar\";\n+\t\tString semanticVersion = \"1.0.1\";\n+\t\t// call under test\n+\t\tString message = assertThrows(NotFoundException.class, () -> {\n+\t\t\tjsonSchemaDao.getVersionId(organizationName, schemaName, semanticVersion);\n+\t\t}).getMessage();\n+\t\tassertEquals(\n+\t\t\t\t\"JSON Schema not found for organizationName: 'my.org.edu' and schemaName: 'foo.bar' and semanticVersion: '1.0.1'\",\n+\t\t\t\tmessage);\n+\t}\n+\n+\t@Test\n+\tpublic void testGetVersionIdNullOrgName() throws JSONObjectAdapterException {\n+\t\tString organizationName = null;\n+\t\tString schemaName = \"foo.bar\";\n+\t\tString semanticVersion = \"1.0.1\";\n+\t\t// call under test\n+\t\tassertThrows(IllegalArgumentException.class, () -> {\n+\t\t\tjsonSchemaDao.getVersionId(organizationName, schemaName, semanticVersion);\n+\t\t});\n+\t}\n+\n+\t@Test\n+\tpublic void testGetVersionIdNullSchemaName() throws JSONObjectAdapterException {\n+\t\tString organizationName = \"my.org.edu\";\n+\t\tString schemaName = null;\n+\t\tString semanticVersion = \"1.0.1\";\n+\t\t// call under test\n+\t\tassertThrows(IllegalArgumentException.class, () -> {\n+\t\t\tjsonSchemaDao.getVersionId(organizationName, schemaName, semanticVersion);\n+\t\t});\n+\t}\n+\n+\t@Test\n+\tpublic void testGetVersionIdNullSemanticVersion() throws JSONObjectAdapterException {\n+\t\tString organizationName = \"my.org.edu\";\n+\t\tString schemaName = \"foo.bar\";\n+\t\tString semanticVersion = null;\n+\t\t// call under test\n+\t\tassertThrows(IllegalArgumentException.class, () -> {\n+\t\t\tjsonSchemaDao.getVersionId(organizationName, schemaName, semanticVersion);\n+\t\t});\n+\t}\n+\n+\t@Test\n+\tpublic void testGetVersionInfoTripple() throws JSONObjectAdapterException {\n+\t\tint index = 0;\n+\t\tcreateNewSchemaVersion(\"my.org.edu/foo.bar/0.0.1\", index++);\n+\t\tcreateNewSchemaVersion(\"my.org.edu/foo.bar\", index++);\n+\t\tJsonSchemaVersionInfo expected = createNewSchemaVersion(\"my.org.edu/foo.bar/1.0.1\", index++);\n+\t\tcreateNewSchemaVersion(\"my.org.edu/foo.bar\", index++);\n+\t\tcreateNewSchemaVersion(\"other.org/foo.bar\", index++);\n+\t\tcreateNewSchemaVersion(\"my.org.edu/foo.bar.other\", index++);\n+\n+\t\t// call under test\n+\t\tJsonSchemaVersionInfo resultInfo = jsonSchemaDao.getVersionInfo(\"my.org.edu\", \"foo.bar\", \"1.0.1\");\n+\t\tassertEquals(expected, resultInfo);\n+\t}\n+\n+\t@Test\n+\tpublic void testGetSchemaVersionOrganizationNotFound() throws JSONObjectAdapterException {\n+\t\tint index = 0;\n+\t\tcreateNewSchemaVersion(\"my.org.edu/foo.bar/1.0.1\", index++);\n+\t\tString message = assertThrows(NotFoundException.class, () -> {\n+\t\t\tjsonSchemaDao.getVersionInfo(\"other.org\", \"foo.bar\", \"1.0.1\");\n+\t\t}).getMessage();\n+\t\tassertEquals(\n+\t\t\t\t\"JSON Schema not found for organizationName: 'other.org' and schemaName: 'foo.bar' and semanticVersion: '1.0.1'\",\n+\t\t\t\tmessage);\n+\t}\n+\n+\t@Test\n+\tpublic void testGetSchemaVersionSchemaNameNotFound() throws JSONObjectAdapterException {\n+\t\tint index = 0;\n+\t\tcreateNewSchemaVersion(\"my.org.edu/foo.bar/1.0.1\", index++);\n+\t\tassertThrows(NotFoundException.class, () -> {\n+\t\t\tjsonSchemaDao.getVersionInfo(\"my.org.edu\", \"foo.bar.bar\", \"1.0.1\");\n+\t\t});\n+\t}\n+\n+\t@Test\n+\tpublic void testGetVersionInfoWithVersionNotFound() throws JSONObjectAdapterException {\n+\t\tint index = 0;\n+\t\tcreateNewSchemaVersion(\"my.org.edu/foo.bar/1.0.1\", index++);\n+\t\tassertThrows(NotFoundException.class, () -> {\n+\t\t\tjsonSchemaDao.getVersionInfo(\"my.org.edu\", \"foo.bar\", \"1.0.2\");\n+\t\t});\n+\t}\n+\n+\t@Test\n+\tpublic void testGetVersionInfoWithVersionNullOrganization() throws JSONObjectAdapterException {\n+\t\tString organizationName = null;\n+\t\tString schemaName = \"other.schema.name\";\n+\t\tString semanticVersion = \"1.0.2\";\n+\t\tassertThrows(IllegalArgumentException.class, () -> {\n+\t\t\tjsonSchemaDao.getVersionInfo(organizationName, schemaName, semanticVersion);\n+\t\t});\n+\t}\n+\n+\t@Test\n+\tpublic void testGetVersionInfoWithVersionNullSchema() throws JSONObjectAdapterException {\n+\t\tString organizationName = \"my.org.edu\";\n+\t\tString schemaName = null;\n+\t\tString semanticVersion = \"1.0.2\";\n+\t\tassertThrows(IllegalArgumentException.class, () -> {\n+\t\t\tjsonSchemaDao.getVersionInfo(organizationName, schemaName, semanticVersion);\n+\t\t});\n+\t}\n+\n+\t@Test\n+\tpublic void testGetVersionInfoWithVersionNullVersion() throws JSONObjectAdapterException {\n+\t\tString organizationName = \"my.org.edu\";\n+\t\tString schemaName = \"other.schema.name\";\n+\t\tString semanticVersion = null;\n+\t\tassertThrows(IllegalArgumentException.class, () -> {\n+\t\t\tjsonSchemaDao.getVersionInfo(organizationName, schemaName, semanticVersion);\n+\t\t});\n+\t}\n+\n+\t@Test\n+\tpublic void testDeleteSchema() throws JSONObjectAdapterException {\n+\t\tint index = 0;\n+\t\tcreateNewSchemaVersion(\"my.org.edu/foo.bar/1.0.1\", index++);\n+\t\tcreateNewSchemaVersion(\"my.org.edu/foo.bar/1.0.2\", index++);\n+\t\tJsonSchemaVersionInfo lastInfo = createNewSchemaVersion(\"my.org.edu/foo.bar\", index++);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b7ab950d66569dedcb77d15bfc43d23b610e95fe"}, "originalPosition": 704}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU5NDM2NTAzOnYy", "diffSide": "RIGHT", "path": "lib/jdomodels/src/test/java/org/sagebionetworks/repo/model/dbo/schema/JsonSchemaDaoImplTest.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOFQyMzoyMToxN1rOGNqi_Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOFQyMzoyMToxN1rOGNqi_Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjk4MTc1Nw==", "bodyText": "use the toDelete variable", "url": "https://github.com/Sage-Bionetworks/Synapse-Repository-Services/pull/4008#discussion_r416981757", "createdAt": "2020-04-28T23:21:17Z", "author": {"login": "marcomarasca"}, "path": "lib/jdomodels/src/test/java/org/sagebionetworks/repo/model/dbo/schema/JsonSchemaDaoImplTest.java", "diffHunk": "@@ -318,4 +308,532 @@ public void testGetVersionInfoNullId() {\n \t\t});\n \t}\n \n+\t@Test\n+\tpublic void testCreateNewSchemaVersion() {\n+\t\t// Call under test\n+\t\tJsonSchemaVersionInfo info = jsonSchemaDao.createNewSchemaVersion(newSchemaVersionRequest);\n+\t\tassertNotNull(info);\n+\t\tassertEquals(organizationId, info.getOrganizationId());\n+\t\tassertEquals(organizationName, info.getOrganizationName());\n+\t\tassertNotNull(info.getSchemaId());\n+\t\tassertEquals(schemaName, info.getSchemaName());\n+\t\tassertEquals(createdBy.toString(), info.getCreatedBy());\n+\t\tassertEquals(semanticVersion, info.getSemanticVersion());\n+\t\tassertNotNull(info.getVersionId());\n+\t\tassertEquals(schemaJsonSha256Hex ,info.getJsonSHA256Hex());\n+\t}\n+\t\n+\t@Test\n+\tpublic void testCreateNewSchemaVersionSchemaNameAtLimit() {\n+\t\tString schemaName = StringUtils.repeat(\"a\", JsonSchemaDaoImpl.MAX_SCHEMA_NAME_CHARS);\n+\t\tnewSchemaVersionRequest.withSchemaName(schemaName);\n+\t\tJsonSchemaVersionInfo info = jsonSchemaDao.createNewSchemaVersion(newSchemaVersionRequest);\n+\t\tassertNotNull(info);\n+\t\tassertEquals(schemaName, info.getSchemaName());\n+\t}\n+\t\n+\t@Test\n+\tpublic void testCreateNewSchemaVersionSchemaNameOverLimit() {\n+\t\tString schemaName = StringUtils.repeat(\"a\", JsonSchemaDaoImpl.MAX_SCHEMA_NAME_CHARS+1);\n+\t\tnewSchemaVersionRequest.withSchemaName(schemaName);\n+\t\tString message = assertThrows(IllegalArgumentException.class, ()->{\n+\t\t\tjsonSchemaDao.createNewSchemaVersion(newSchemaVersionRequest);\n+\t\t}).getMessage();\n+\t\tassertEquals(\"Schema name must be \"+JsonSchemaDaoImpl.MAX_SCHEMA_NAME_CHARS+\" characters or less\", message);\n+\t}\n+\t\n+\t@Test\n+\tpublic void testCreateNewSchemaVersionSemanticVersionAtLimit() {\n+\t\tsemanticVersion = StringUtils.repeat(\"a\", JsonSchemaDaoImpl.MAX_SEMANTIC_VERSION_CHARS);\n+\t\tnewSchemaVersionRequest.withSemanticVersion(semanticVersion);\n+\t\tJsonSchemaVersionInfo info = jsonSchemaDao.createNewSchemaVersion(newSchemaVersionRequest);\n+\t\tassertNotNull(info);\n+\t\tassertEquals(semanticVersion, info.getSemanticVersion());\n+\t}\n+\t\n+\t@Test\n+\tpublic void testCreateNewSchemaVersionSemanticVersionOverLimit() {\n+\t\tsemanticVersion = StringUtils.repeat(\"a\", JsonSchemaDaoImpl.MAX_SEMANTIC_VERSION_CHARS+1);\n+\t\tnewSchemaVersionRequest.withSemanticVersion(semanticVersion);\n+\t\tString message = assertThrows(IllegalArgumentException.class, ()->{\n+\t\t\tjsonSchemaDao.createNewSchemaVersion(newSchemaVersionRequest);\n+\t\t}).getMessage();\n+\t\tassertEquals(\"Semantic version must be \"+JsonSchemaDaoImpl.MAX_SEMANTIC_VERSION_CHARS+\" characters or less\", message);\n+\t}\n+\t\n+\t@Test\n+\tpublic void testCreateNewSchemaVerionNullRequest() {\n+\t\tnewSchemaVersionRequest = null;\n+\t\tassertThrows(IllegalArgumentException.class, ()->{\n+\t\t\tjsonSchemaDao.createNewSchemaVersion(newSchemaVersionRequest);\n+\t\t});\n+\t}\n+\t\n+\t@Test\n+\tpublic void testCreateNewSchemaVerionNullRequestNullOrganizationId() {\n+\t\tnewSchemaVersionRequest.withOrganizationId(null);\n+\t\tassertThrows(IllegalArgumentException.class, ()->{\n+\t\t\tjsonSchemaDao.createNewSchemaVersion(newSchemaVersionRequest);\n+\t\t});\n+\t}\n+\t\n+\t@Test\n+\tpublic void testCreateNewSchemaVerionNullRequestNullSchemaName() {\n+\t\tnewSchemaVersionRequest.withSchemaName(null);\n+\t\tassertThrows(IllegalArgumentException.class, ()->{\n+\t\t\tjsonSchemaDao.createNewSchemaVersion(newSchemaVersionRequest);\n+\t\t});\n+\t}\n+\t\n+\t@Test\n+\tpublic void testCreateNewSchemaVerionNullRequestNullCreatedBy() {\n+\t\tnewSchemaVersionRequest.withCreatedBy(null);\n+\t\tassertThrows(IllegalArgumentException.class, ()->{\n+\t\t\tjsonSchemaDao.createNewSchemaVersion(newSchemaVersionRequest);\n+\t\t});\n+\t}\n+\t\n+\t@Test\n+\tpublic void testCreateNewSchemaVersionNullSemanticVersion() {\n+\t\tsemanticVersion = null;\n+\t\tnewSchemaVersionRequest.withSemanticVersion(semanticVersion);\n+\t\tJsonSchemaVersionInfo info = jsonSchemaDao.createNewSchemaVersion(newSchemaVersionRequest);\n+\t\tassertNotNull(info);\n+\t\tassertEquals(semanticVersion, info.getSemanticVersion());\n+\t}\n+\t\n+\t@Test\n+\tpublic void testCreateNewSchemaVerionNullSchema() {\n+\t\tnewSchemaVersionRequest.withJsonSchema(null);\n+\t\tassertThrows(IllegalArgumentException.class, ()->{\n+\t\t\tjsonSchemaDao.createNewSchemaVersion(newSchemaVersionRequest);\n+\t\t});\n+\t}\n+\n+\t/**\n+\t * Helper to create a new JSON schema with the given $id\n+\t * \n+\t * @param schema\n+\t * @return\n+\t * @throws JSONObjectAdapterException\n+\t */\n+\tJsonSchemaVersionInfo createNewSchemaVersion(String id, int index) throws JSONObjectAdapterException {\n+\t\tSchemaId schemaId = SchemaIdParser.parseSchemaId(id);\n+\t\tString organizationName = schemaId.getOrganizationName().toString();\n+\t\tString schemaName = schemaId.getSchemaName().toString();\n+\t\tString semanticVersion = null;\n+\t\tif (schemaId.getSemanticVersion() != null) {\n+\t\t\tsemanticVersion = schemaId.getSemanticVersion().toString();\n+\t\t}\n+\t\tOrganization organization = null;\n+\t\ttry {\n+\t\t\torganization = organizationDao.getOrganizationByName(organizationName);\n+\t\t} catch (NotFoundException e) {\n+\t\t\torganization = organizationDao.createOrganization(organizationName, adminUserId);\n+\t\t}\n+\t\tschema = new JsonSchema();\n+\t\tschema.set$id(id);\n+\t\tschema.setDescription(\"index:\" + index);\n+\t\treturn jsonSchemaDao.createNewSchemaVersion(\n+\t\t\t\tnew NewSchemaVersionRequest().withOrganizationId(organization.getId()).withCreatedBy(createdBy)\n+\t\t\t\t\t\t.withJsonSchema(schema).withSchemaName(schemaName).withSemanticVersion(semanticVersion));\n+\t}\n+\n+\t/**\n+\t * Helper to get the SHA-256 hex string for a given schema.\n+\t * \n+\t * @param schema\n+\t * @return\n+\t * @throws JSONObjectAdapterException\n+\t */\n+\tstatic String getSchemaSHA256Hex(JsonSchema schema) throws JSONObjectAdapterException {\n+\t\tString json = EntityFactory.createJSONStringForEntity(schema);\n+\t\treturn DigestUtils.sha256Hex(json);\n+\t}\n+\n+\t@Test\n+\tpublic void testGetLatestVersion() throws JSONObjectAdapterException {\n+\t\tint index = 0;\n+\t\tcreateNewSchemaVersion(\"my.org.edu/foo.bar\", index++);\n+\t\tcreateNewSchemaVersion(\"my.org.edu/foo.bar\", index++);\n+\t\tcreateNewSchemaVersion(\"my.org.edu/foo.bar/1.0.1\", index++);\n+\t\tJsonSchemaVersionInfo lastVersion = createNewSchemaVersion(\"my.org.edu/foo.bar\", index++);\n+\t\tcreateNewSchemaVersion(\"other.org/foo.bar\", index++);\n+\t\tcreateNewSchemaVersion(\"my.org.edu/foo.bar.other\", index++);\n+\t\t// Call under test\n+\t\tString versionId = jsonSchemaDao.getLatestVersionId(\"my.org.edu\", \"foo.bar\");\n+\t\tassertEquals(lastVersion.getVersionId(), versionId);\n+\t}\n+\n+\t@Test\n+\tpublic void testGetLatestVersionOrganziationNotFound() throws JSONObjectAdapterException {\n+\t\tint index = 0;\n+\t\tcreateNewSchemaVersion(\"my.org.edu/foo.bar\", index++);\n+\t\tString message = assertThrows(NotFoundException.class, () -> {\n+\t\t\tjsonSchemaDao.getLatestVersionId(\"other.org\", \"foo.bar\");\n+\t\t}).getMessage();\n+\t\tassertEquals(\"JSON Schema not found for organizationName: 'other.org' and schemaName: 'foo.bar'\", message);\n+\t}\n+\n+\t@Test\n+\tpublic void testGetLatestVersionSchemaNameNotFound() throws JSONObjectAdapterException {\n+\t\tint index = 0;\n+\t\tcreateNewSchemaVersion(\"my.org.edu/foo.bar\", index++);\n+\t\tString message = assertThrows(NotFoundException.class, () -> {\n+\t\t\tjsonSchemaDao.getLatestVersionId(\"my.org.edu\", \"other.schema.name\");\n+\t\t}).getMessage();\n+\t\tassertEquals(\"JSON Schema not found for organizationName: 'my.org.edu' and schemaName: 'other.schema.name'\",\n+\t\t\t\tmessage);\n+\t}\n+\n+\t@Test\n+\tpublic void testGetSchemaLatestVersionNullOrganization() {\n+\t\tString organizationName = null;\n+\t\tString schemaName = \"other.schema.name\";\n+\t\tassertThrows(IllegalArgumentException.class, () -> {\n+\t\t\tjsonSchemaDao.getLatestVersionId(organizationName, schemaName);\n+\t\t});\n+\t}\n+\n+\t@Test\n+\tpublic void testGetSchemaLatestVersionNullSchema() {\n+\t\tString organizationName = \"my.org.edu\";\n+\t\tString schemaName = null;\n+\t\tassertThrows(IllegalArgumentException.class, () -> {\n+\t\t\tjsonSchemaDao.getLatestVersionId(organizationName, schemaName);\n+\t\t});\n+\t}\n+\n+\t@Test\n+\tpublic void testGetVersionId() throws JSONObjectAdapterException {\n+\t\tint index = 0;\n+\t\tcreateNewSchemaVersion(\"my.org.edu/foo.bar/0.0.1\", index++);\n+\t\tcreateNewSchemaVersion(\"my.org.edu/foo.bar\", index++);\n+\t\tJsonSchemaVersionInfo expected = createNewSchemaVersion(\"my.org.edu/foo.bar/1.0.1\", index++);\n+\t\tcreateNewSchemaVersion(\"my.org.edu/foo.bar\", index++);\n+\t\tcreateNewSchemaVersion(\"other.org/foo.bar\", index++);\n+\t\tcreateNewSchemaVersion(\"my.org.edu/foo.bar.other\", index++);\n+\n+\t\tString organizationName = \"my.org.edu\";\n+\t\tString schemaName = \"foo.bar\";\n+\t\tString semanticVersion = \"1.0.1\";\n+\t\t// call under test\n+\t\tString versionId = jsonSchemaDao.getVersionId(organizationName, schemaName, semanticVersion);\n+\t\tassertNotNull(versionId);\n+\t\tassertEquals(expected.getVersionId(), versionId);\n+\t}\n+\n+\t@Test\n+\tpublic void testGetVersionIdNotFound() throws JSONObjectAdapterException {\n+\t\tint index = 0;\n+\t\tcreateNewSchemaVersion(\"my.org.edu/foo.bar/0.0.1\", index++);\n+\n+\t\tString organizationName = \"my.org.edu\";\n+\t\tString schemaName = \"foo.bar\";\n+\t\tString semanticVersion = \"1.0.1\";\n+\t\t// call under test\n+\t\tString message = assertThrows(NotFoundException.class, () -> {\n+\t\t\tjsonSchemaDao.getVersionId(organizationName, schemaName, semanticVersion);\n+\t\t}).getMessage();\n+\t\tassertEquals(\n+\t\t\t\t\"JSON Schema not found for organizationName: 'my.org.edu' and schemaName: 'foo.bar' and semanticVersion: '1.0.1'\",\n+\t\t\t\tmessage);\n+\t}\n+\n+\t@Test\n+\tpublic void testGetVersionIdNullOrgName() throws JSONObjectAdapterException {\n+\t\tString organizationName = null;\n+\t\tString schemaName = \"foo.bar\";\n+\t\tString semanticVersion = \"1.0.1\";\n+\t\t// call under test\n+\t\tassertThrows(IllegalArgumentException.class, () -> {\n+\t\t\tjsonSchemaDao.getVersionId(organizationName, schemaName, semanticVersion);\n+\t\t});\n+\t}\n+\n+\t@Test\n+\tpublic void testGetVersionIdNullSchemaName() throws JSONObjectAdapterException {\n+\t\tString organizationName = \"my.org.edu\";\n+\t\tString schemaName = null;\n+\t\tString semanticVersion = \"1.0.1\";\n+\t\t// call under test\n+\t\tassertThrows(IllegalArgumentException.class, () -> {\n+\t\t\tjsonSchemaDao.getVersionId(organizationName, schemaName, semanticVersion);\n+\t\t});\n+\t}\n+\n+\t@Test\n+\tpublic void testGetVersionIdNullSemanticVersion() throws JSONObjectAdapterException {\n+\t\tString organizationName = \"my.org.edu\";\n+\t\tString schemaName = \"foo.bar\";\n+\t\tString semanticVersion = null;\n+\t\t// call under test\n+\t\tassertThrows(IllegalArgumentException.class, () -> {\n+\t\t\tjsonSchemaDao.getVersionId(organizationName, schemaName, semanticVersion);\n+\t\t});\n+\t}\n+\n+\t@Test\n+\tpublic void testGetVersionInfoTripple() throws JSONObjectAdapterException {\n+\t\tint index = 0;\n+\t\tcreateNewSchemaVersion(\"my.org.edu/foo.bar/0.0.1\", index++);\n+\t\tcreateNewSchemaVersion(\"my.org.edu/foo.bar\", index++);\n+\t\tJsonSchemaVersionInfo expected = createNewSchemaVersion(\"my.org.edu/foo.bar/1.0.1\", index++);\n+\t\tcreateNewSchemaVersion(\"my.org.edu/foo.bar\", index++);\n+\t\tcreateNewSchemaVersion(\"other.org/foo.bar\", index++);\n+\t\tcreateNewSchemaVersion(\"my.org.edu/foo.bar.other\", index++);\n+\n+\t\t// call under test\n+\t\tJsonSchemaVersionInfo resultInfo = jsonSchemaDao.getVersionInfo(\"my.org.edu\", \"foo.bar\", \"1.0.1\");\n+\t\tassertEquals(expected, resultInfo);\n+\t}\n+\n+\t@Test\n+\tpublic void testGetSchemaVersionOrganizationNotFound() throws JSONObjectAdapterException {\n+\t\tint index = 0;\n+\t\tcreateNewSchemaVersion(\"my.org.edu/foo.bar/1.0.1\", index++);\n+\t\tString message = assertThrows(NotFoundException.class, () -> {\n+\t\t\tjsonSchemaDao.getVersionInfo(\"other.org\", \"foo.bar\", \"1.0.1\");\n+\t\t}).getMessage();\n+\t\tassertEquals(\n+\t\t\t\t\"JSON Schema not found for organizationName: 'other.org' and schemaName: 'foo.bar' and semanticVersion: '1.0.1'\",\n+\t\t\t\tmessage);\n+\t}\n+\n+\t@Test\n+\tpublic void testGetSchemaVersionSchemaNameNotFound() throws JSONObjectAdapterException {\n+\t\tint index = 0;\n+\t\tcreateNewSchemaVersion(\"my.org.edu/foo.bar/1.0.1\", index++);\n+\t\tassertThrows(NotFoundException.class, () -> {\n+\t\t\tjsonSchemaDao.getVersionInfo(\"my.org.edu\", \"foo.bar.bar\", \"1.0.1\");\n+\t\t});\n+\t}\n+\n+\t@Test\n+\tpublic void testGetVersionInfoWithVersionNotFound() throws JSONObjectAdapterException {\n+\t\tint index = 0;\n+\t\tcreateNewSchemaVersion(\"my.org.edu/foo.bar/1.0.1\", index++);\n+\t\tassertThrows(NotFoundException.class, () -> {\n+\t\t\tjsonSchemaDao.getVersionInfo(\"my.org.edu\", \"foo.bar\", \"1.0.2\");\n+\t\t});\n+\t}\n+\n+\t@Test\n+\tpublic void testGetVersionInfoWithVersionNullOrganization() throws JSONObjectAdapterException {\n+\t\tString organizationName = null;\n+\t\tString schemaName = \"other.schema.name\";\n+\t\tString semanticVersion = \"1.0.2\";\n+\t\tassertThrows(IllegalArgumentException.class, () -> {\n+\t\t\tjsonSchemaDao.getVersionInfo(organizationName, schemaName, semanticVersion);\n+\t\t});\n+\t}\n+\n+\t@Test\n+\tpublic void testGetVersionInfoWithVersionNullSchema() throws JSONObjectAdapterException {\n+\t\tString organizationName = \"my.org.edu\";\n+\t\tString schemaName = null;\n+\t\tString semanticVersion = \"1.0.2\";\n+\t\tassertThrows(IllegalArgumentException.class, () -> {\n+\t\t\tjsonSchemaDao.getVersionInfo(organizationName, schemaName, semanticVersion);\n+\t\t});\n+\t}\n+\n+\t@Test\n+\tpublic void testGetVersionInfoWithVersionNullVersion() throws JSONObjectAdapterException {\n+\t\tString organizationName = \"my.org.edu\";\n+\t\tString schemaName = \"other.schema.name\";\n+\t\tString semanticVersion = null;\n+\t\tassertThrows(IllegalArgumentException.class, () -> {\n+\t\t\tjsonSchemaDao.getVersionInfo(organizationName, schemaName, semanticVersion);\n+\t\t});\n+\t}\n+\n+\t@Test\n+\tpublic void testDeleteSchema() throws JSONObjectAdapterException {\n+\t\tint index = 0;\n+\t\tcreateNewSchemaVersion(\"my.org.edu/foo.bar/1.0.1\", index++);\n+\t\tcreateNewSchemaVersion(\"my.org.edu/foo.bar/1.0.2\", index++);\n+\t\tJsonSchemaVersionInfo lastInfo = createNewSchemaVersion(\"my.org.edu/foo.bar\", index++);\n+\t\tString schemaName = \"foo.bar\";\n+\t\tString schemaId = jsonSchemaDao.getSchemaInfoForUpdate(lastInfo.getOrganizationId(), schemaName);\n+\t\t// call under test\n+\t\tint rowsUpdated = jsonSchemaDao.deleteSchema(schemaId);\n+\t\tassertEquals(1, rowsUpdated);\n+\t\tassertThrows(NotFoundException.class, () -> {\n+\t\t\tjsonSchemaDao.getSchemaInfoForUpdate(organizationName, schemaName);\n+\t\t});\n+\t}\n+\n+\t@Test\n+\tpublic void testDeleteSchemaNotFound() throws JSONObjectAdapterException {\n+\t\tString schemaId = \"-1\";\n+\t\t// call under test\n+\t\tint rowsUpdated = jsonSchemaDao.deleteSchema(schemaId);\n+\t\tassertEquals(0, rowsUpdated);\n+\t}\n+\n+\t@Test\n+\tpublic void testDeleteSchemaNullId() throws JSONObjectAdapterException {\n+\t\tString schemaId = null;\n+\t\tassertThrows(IllegalArgumentException.class, () -> {\n+\t\t\tjsonSchemaDao.deleteSchema(schemaId);\n+\t\t});\n+\t}\n+\t\n+\t@Test\n+\tpublic void testFindLatestVersion() throws JSONObjectAdapterException {\n+\t\tint index = 0;\n+\t\tJsonSchemaVersionInfo one = createNewSchemaVersion(\"my.org.edu/foo.bar/1.0.1\", index++);\n+\t\tJsonSchemaVersionInfo two = createNewSchemaVersion(\"my.org.edu/foo.bar/1.0.2\", index++);\n+\t\tJsonSchemaVersionInfo three = createNewSchemaVersion(\"my.org.edu/foo.bar\", index++);\n+\t\tJsonSchemaVersionInfo otherOrg = createNewSchemaVersion(\"another.org/foo.bar\", index++);\n+\t\tJsonSchemaVersionInfo otherName = createNewSchemaVersion(\"my.org.edu/other.name\", index++);\n+\t\t// Call under test\n+\t\tLong versionId = jsonSchemaDao.findLatestVersionId(one.getSchemaId());\n+\t\tassertEquals(three.getVersionId(), versionId.toString());\n+\t\t// call under test\n+\t\tversionId = jsonSchemaDao.findLatestVersionId(otherOrg.getSchemaId());\n+\t\tassertEquals(otherOrg.getVersionId(), versionId.toString());\n+\t\t// call under test\n+\t\tversionId = jsonSchemaDao.findLatestVersionId(otherName.getSchemaId());\n+\t\tassertEquals(otherName.getVersionId(), versionId.toString());\n+\t}\n+\t\n+\t@Test\n+\tpublic void testFindLatestVersionDoesNotExist() {\n+\t\tString schemaId = \"-1\";\n+\t\tLong latestVerion = jsonSchemaDao.findLatestVersionId(schemaId);\n+\t\tassertNull(latestVerion);\n+\t}\n+\t\n+\t@Test\n+\tpublic void testFindLatestVersionNullSchemaId() {\n+\t\tString schemaId = null;\n+\t\tassertThrows(IllegalArgumentException.class, ()->{\n+\t\t\tjsonSchemaDao.findLatestVersionId(schemaId);\n+\t\t});\n+\t}\n+\t\n+\t@Test\n+\tpublic void testGetSchemaIdForUpdate() throws JSONObjectAdapterException {\n+\t\tint index = 0;\n+\t\tJsonSchemaVersionInfo one = createNewSchemaVersion(\"my.org.edu/foo.bar/1.0.1\", index++);\n+\t\t// call under test\n+\t\tString schemaId = jsonSchemaDao.getSchemaIdForUpdate(one.getVersionId());\n+\t\tassertEquals(one.getSchemaId(), schemaId);\n+\t}\n+\t\n+\t@Test\n+\tpublic void testGetSchemaIdForUpdateNotFound() throws JSONObjectAdapterException {\n+\t\tString versionId = \"-1\";\n+\t\tString message = assertThrows(NotFoundException.class, ()->{\n+\t\t\tjsonSchemaDao.getSchemaIdForUpdate(versionId);\n+\t\t}).getMessage();\n+\t\tassertEquals(\"JSON schema not found for versionId: -1\", message);\n+\t}\n+\n+\t@Test\n+\tpublic void testDeleteVersionNotLatest() throws JSONObjectAdapterException {\n+\t\tint index = 0;\n+\t\tJsonSchemaVersionInfo stillExists = createNewSchemaVersion(\"my.org.edu/foo.bar/1.0.1\", index++);\n+\t\tJsonSchemaVersionInfo toDelete = createNewSchemaVersion(\"my.org.edu/foo.bar/1.0.2\", index++);\n+\t\tcreateNewSchemaVersion(\"my.org.edu/foo.bar\", index++);\n+\t\t// call under test\n+\t\tjsonSchemaDao.deleteSchemaVersion(toDelete.getVersionId());\n+\t\tassertThrows(NotFoundException.class, () -> {\n+\t\t\tjsonSchemaDao.getVersionInfo(\"my.org.edu\", \"foo.bar\", \"1.0.2\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b7ab950d66569dedcb77d15bfc43d23b610e95fe"}, "originalPosition": 792}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3184, "cost": 1, "resetAt": "2021-11-12T12:57:47Z"}}}