{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDA1MTcxNjUz", "number": 4006, "title": "PLFM-5170 VI", "bodyText": "", "createdAt": "2020-04-17T14:39:02Z", "url": "https://github.com/Sage-Bionetworks/Synapse-Repository-Services/pull/4006", "merged": true, "mergeCommit": {"oid": "556579595d7064683dfc1f8c1d68491bc41e8ae1"}, "closed": true, "closedAt": "2020-04-17T19:56:22Z", "author": {"login": "brucehoff"}, "timelineItems": {"totalCount": 31, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcW9dr5gH2gAyNDA1MTcxNjUzOmI4NjgzZjYyNjNiYWUwMTdhMDE1ZWQ3NWNkYzZkZDlhMjdhYjE1NGM=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcYmxarAFqTM5NTcxNzA1NQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "b8683f6263bae017a015ed75cdc6dd9a27ab154c", "author": {"user": {"login": "brucehoff", "name": "Bruce Hoff"}}, "url": "https://github.com/Sage-Bionetworks/Synapse-Repository-Services/commit/b8683f6263bae017a015ed75cdc6dd9a27ab154c", "committedDate": "2020-04-12T17:09:03Z", "message": "PLFM-5170-VI"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "fbd8f322fd99eff1cb4151e7fccc9afeb1701752", "author": {"user": {"login": "brucehoff", "name": "Bruce Hoff"}}, "url": "https://github.com/Sage-Bionetworks/Synapse-Repository-Services/commit/fbd8f322fd99eff1cb4151e7fccc9afeb1701752", "committedDate": "2020-04-12T22:26:04Z", "message": "PLFM-5170-VI"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "935600bbe524434dcd88f2c54289bbc3888fe08a", "author": {"user": {"login": "brucehoff", "name": "Bruce Hoff"}}, "url": "https://github.com/Sage-Bionetworks/Synapse-Repository-Services/commit/935600bbe524434dcd88f2c54289bbc3888fe08a", "committedDate": "2020-04-12T23:42:02Z", "message": "PLFM-5170-VI"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5864c2c2e0505bddbb2b589959ef9486d025fd2a", "author": {"user": {"login": "brucehoff", "name": "Bruce Hoff"}}, "url": "https://github.com/Sage-Bionetworks/Synapse-Repository-Services/commit/5864c2c2e0505bddbb2b589959ef9486d025fd2a", "committedDate": "2020-04-13T00:52:40Z", "message": "PLFM-5170-VI"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "645edad753ca98ebdf549bd26db72219ec890043", "author": {"user": {"login": "brucehoff", "name": "Bruce Hoff"}}, "url": "https://github.com/Sage-Bionetworks/Synapse-Repository-Services/commit/645edad753ca98ebdf549bd26db72219ec890043", "committedDate": "2020-04-13T02:21:22Z", "message": "PLFM-5170-VI"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "77d014f99cd00dee2269a28e7b052824615203d6", "author": {"user": {"login": "brucehoff", "name": "Bruce Hoff"}}, "url": "https://github.com/Sage-Bionetworks/Synapse-Repository-Services/commit/77d014f99cd00dee2269a28e7b052824615203d6", "committedDate": "2020-04-13T03:54:47Z", "message": "PLFM-5170-VI"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "415bea710399c98002d17972b92b1d06b0f4ff02", "author": {"user": {"login": "brucehoff", "name": "Bruce Hoff"}}, "url": "https://github.com/Sage-Bionetworks/Synapse-Repository-Services/commit/415bea710399c98002d17972b92b1d06b0f4ff02", "committedDate": "2020-04-13T04:32:03Z", "message": "PLFM-5170-VI"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "95451d1c0916c16a7a84088850ec8b44eee4c72c", "author": {"user": {"login": "brucehoff", "name": "Bruce Hoff"}}, "url": "https://github.com/Sage-Bionetworks/Synapse-Repository-Services/commit/95451d1c0916c16a7a84088850ec8b44eee4c72c", "committedDate": "2020-04-13T13:42:57Z", "message": "PLFM-5170-VI"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0b037152ef979a7a8147b876f012c734b29ca93c", "author": {"user": {"login": "brucehoff", "name": "Bruce Hoff"}}, "url": "https://github.com/Sage-Bionetworks/Synapse-Repository-Services/commit/0b037152ef979a7a8147b876f012c734b29ca93c", "committedDate": "2020-04-13T14:31:49Z", "message": "PLFM-5170-VI"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6a10275affb25c530aeb108b2a9f8d3354809da2", "author": {"user": {"login": "brucehoff", "name": "Bruce Hoff"}}, "url": "https://github.com/Sage-Bionetworks/Synapse-Repository-Services/commit/6a10275affb25c530aeb108b2a9f8d3354809da2", "committedDate": "2020-04-13T15:45:26Z", "message": "PLFM-5170-VI"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2fcc23b1b6b0681d47b6fe6aaa4d5be4f62a6029", "author": {"user": {"login": "brucehoff", "name": "Bruce Hoff"}}, "url": "https://github.com/Sage-Bionetworks/Synapse-Repository-Services/commit/2fcc23b1b6b0681d47b6fe6aaa4d5be4f62a6029", "committedDate": "2020-04-13T15:52:58Z", "message": "PLFM-5170-VI"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f2c25f3acfec2da550d7f60728fea28d4600e056", "author": {"user": {"login": "brucehoff", "name": "Bruce Hoff"}}, "url": "https://github.com/Sage-Bionetworks/Synapse-Repository-Services/commit/f2c25f3acfec2da550d7f60728fea28d4600e056", "committedDate": "2020-04-13T16:13:28Z", "message": "PLFM-5170-VI"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "007939f0b45dc43bd9b3b091aa4bc6ea7318e2da", "author": {"user": {"login": "brucehoff", "name": "Bruce Hoff"}}, "url": "https://github.com/Sage-Bionetworks/Synapse-Repository-Services/commit/007939f0b45dc43bd9b3b091aa4bc6ea7318e2da", "committedDate": "2020-04-13T18:21:45Z", "message": "PLFM-5170-VI"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5b8aee56faf854b6b75d1aaa7985b4ff15a47f93", "author": {"user": {"login": "brucehoff", "name": "Bruce Hoff"}}, "url": "https://github.com/Sage-Bionetworks/Synapse-Repository-Services/commit/5b8aee56faf854b6b75d1aaa7985b4ff15a47f93", "committedDate": "2020-04-13T23:41:47Z", "message": "PLFM-5170-VI"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a90fb69a1c6b9e29ef9f82fdb796ddb6bef031c9", "author": {"user": {"login": "brucehoff", "name": "Bruce Hoff"}}, "url": "https://github.com/Sage-Bionetworks/Synapse-Repository-Services/commit/a90fb69a1c6b9e29ef9f82fdb796ddb6bef031c9", "committedDate": "2020-04-14T00:46:41Z", "message": "PLFM-5170-VI"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e7134ca0408a3b82363a792dfbc40074d477299a", "author": {"user": {"login": "brucehoff", "name": "Bruce Hoff"}}, "url": "https://github.com/Sage-Bionetworks/Synapse-Repository-Services/commit/e7134ca0408a3b82363a792dfbc40074d477299a", "committedDate": "2020-04-14T01:05:55Z", "message": "PLFM-5170-VI"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "efd74196282fac9cd927a0f45405bce3e402b11a", "author": {"user": {"login": "brucehoff", "name": "Bruce Hoff"}}, "url": "https://github.com/Sage-Bionetworks/Synapse-Repository-Services/commit/efd74196282fac9cd927a0f45405bce3e402b11a", "committedDate": "2020-04-14T02:40:16Z", "message": "PLFM-5170-VI"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b545fbca2880c823a03fdc1c5f48013bd4db0eb8", "author": {"user": {"login": "brucehoff", "name": "Bruce Hoff"}}, "url": "https://github.com/Sage-Bionetworks/Synapse-Repository-Services/commit/b545fbca2880c823a03fdc1c5f48013bd4db0eb8", "committedDate": "2020-04-14T18:05:26Z", "message": "PLFM-5170-VI"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a9c91e3e34e005c98c256ba0eba00cbb8b1e7cd7", "author": {"user": {"login": "brucehoff", "name": "Bruce Hoff"}}, "url": "https://github.com/Sage-Bionetworks/Synapse-Repository-Services/commit/a9c91e3e34e005c98c256ba0eba00cbb8b1e7cd7", "committedDate": "2020-04-14T23:32:07Z", "message": "PLFM-5170-VI"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ce77e62f89ab8759d8068b05c47e0a33f9952476", "author": {"user": {"login": "brucehoff", "name": "Bruce Hoff"}}, "url": "https://github.com/Sage-Bionetworks/Synapse-Repository-Services/commit/ce77e62f89ab8759d8068b05c47e0a33f9952476", "committedDate": "2020-04-14T23:40:36Z", "message": "PLFM-5170-VI"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9d8a20c5e7dd4d2e9206455fd4d8f37286b325fc", "author": {"user": {"login": "brucehoff", "name": "Bruce Hoff"}}, "url": "https://github.com/Sage-Bionetworks/Synapse-Repository-Services/commit/9d8a20c5e7dd4d2e9206455fd4d8f37286b325fc", "committedDate": "2020-04-15T00:53:34Z", "message": "PLFM-5170-VI"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7b4536f7d7c6015d14eb39580dbc26922caa4508", "author": {"user": {"login": "brucehoff", "name": "Bruce Hoff"}}, "url": "https://github.com/Sage-Bionetworks/Synapse-Repository-Services/commit/7b4536f7d7c6015d14eb39580dbc26922caa4508", "committedDate": "2020-04-15T01:06:17Z", "message": "PLFM-5170-VI"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "740da20a59df34411c758663646dc7a9e44c91c1", "author": {"user": {"login": "brucehoff", "name": "Bruce Hoff"}}, "url": "https://github.com/Sage-Bionetworks/Synapse-Repository-Services/commit/740da20a59df34411c758663646dc7a9e44c91c1", "committedDate": "2020-04-15T01:12:45Z", "message": "PLFM-5170-VI"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0eda9b50653d0c4bbbb26b68a3813fd930d0553e", "author": {"user": {"login": "brucehoff", "name": "Bruce Hoff"}}, "url": "https://github.com/Sage-Bionetworks/Synapse-Repository-Services/commit/0eda9b50653d0c4bbbb26b68a3813fd930d0553e", "committedDate": "2020-04-15T01:17:44Z", "message": "PLFM-5170-VI"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8f632954aebba8f0c5940da54ad89b8a0c3ba2f7", "author": {"user": {"login": "brucehoff", "name": "Bruce Hoff"}}, "url": "https://github.com/Sage-Bionetworks/Synapse-Repository-Services/commit/8f632954aebba8f0c5940da54ad89b8a0c3ba2f7", "committedDate": "2020-04-15T01:44:48Z", "message": "PLFM-5170-VI"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f96bbb2c819605ec712a5c6abac4379b2c2be7de", "author": {"user": {"login": "brucehoff", "name": "Bruce Hoff"}}, "url": "https://github.com/Sage-Bionetworks/Synapse-Repository-Services/commit/f96bbb2c819605ec712a5c6abac4379b2c2be7de", "committedDate": "2020-04-17T14:37:59Z", "message": "PLFM-5170-VI"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3900d19b24665180b7149ff38b32e1b314fae499", "author": {"user": {"login": "brucehoff", "name": "Bruce Hoff"}}, "url": "https://github.com/Sage-Bionetworks/Synapse-Repository-Services/commit/3900d19b24665180b7149ff38b32e1b314fae499", "committedDate": "2020-04-17T14:48:38Z", "message": "PLFM-5170-VI"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d15e52c920bc6b87b0362bdfb20032070657c0db", "author": {"user": {"login": "brucehoff", "name": "Bruce Hoff"}}, "url": "https://github.com/Sage-Bionetworks/Synapse-Repository-Services/commit/d15e52c920bc6b87b0362bdfb20032070657c0db", "committedDate": "2020-04-17T17:49:36Z", "message": "PLFM-5170-VI"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "56e69b637c8277cfd24afcd58c21a8ca739d8959", "author": {"user": {"login": "brucehoff", "name": "Bruce Hoff"}}, "url": "https://github.com/Sage-Bionetworks/Synapse-Repository-Services/commit/56e69b637c8277cfd24afcd58c21a8ca739d8959", "committedDate": "2020-04-17T17:58:47Z", "message": "PLFM-5170-VI"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk1NzE0NzQ5", "url": "https://github.com/Sage-Bionetworks/Synapse-Repository-Services/pull/4006#pullrequestreview-395714749", "createdAt": "2020-04-17T19:23:02Z", "commit": {"oid": "56e69b637c8277cfd24afcd58c21a8ca739d8959"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xN1QxOToyMzowMlrOGHaUWw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xN1QxOToyMzowMlrOGHaUWw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDQyNDQxMQ==", "bodyText": "If the token is invalid it should return a 403", "url": "https://github.com/Sage-Bionetworks/Synapse-Repository-Services/pull/4006#discussion_r410424411", "createdAt": "2020-04-17T19:23:02Z", "author": {"login": "marcomarasca"}, "path": "services/repository/src/main/java/org/sagebionetworks/repo/web/OAuthScopeInterceptor.java", "diffHunk": "@@ -0,0 +1,137 @@\n+package org.sagebionetworks.repo.web;\n+\n+import static org.sagebionetworks.repo.model.AuthorizationConstants.SYNAPSE_AUTHORIZATION_HEADER_NAME;\n+\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.TreeSet;\n+\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+\n+import org.sagebionetworks.auth.HttpAuthUtil;\n+import org.sagebionetworks.repo.manager.oauth.ClaimsJsonUtil;\n+import org.sagebionetworks.repo.manager.oauth.OIDCTokenHelper;\n+import org.sagebionetworks.repo.model.AuthorizationConstants;\n+import org.sagebionetworks.repo.model.oauth.OAuthScope;\n+import org.sagebionetworks.repo.web.controller.RequiredScope;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.core.MethodParameter;\n+import org.springframework.http.HttpStatus;\n+import org.springframework.web.bind.annotation.RequestHeader;\n+import org.springframework.web.bind.annotation.RequestParam;\n+import org.springframework.web.method.HandlerMethod;\n+import org.springframework.web.servlet.HandlerInterceptor;\n+\n+import io.jsonwebtoken.Claims;\n+import io.jsonwebtoken.JwsHeader;\n+import io.jsonwebtoken.Jwt;\n+\n+/*\n+ * For requests which require authentication (have a 'userId' parameter) and are not anonymous, \n+ * the scope in the access token is compared to the scope in the RequiredScope annotation \n+ * (default to full scope) and 403 status is returned if the required scope is not present.\n+ */\n+public class OAuthScopeInterceptor implements HandlerInterceptor {\n+\n+\t/*\n+\t * If a handler is not annotated with RequiredScope then, by default, it requires the following\n+\t */\n+\tprivate static final Set<OAuthScope> DEFAULT_SCOPES;\n+\tstatic {\n+\t\tDEFAULT_SCOPES = new HashSet<OAuthScope>(Arrays.asList(OAuthScope.values()));\n+\t\tDEFAULT_SCOPES.remove(OAuthScope.openid);\n+\t}\n+\n+\tprivate static final String ERROR_MESSAGE_PREFIX  = \"Request lacks scope(s) required by this service: \";\n+\t\n+\t@Autowired\n+\tprivate OIDCTokenHelper oidcTokenHelper;\n+\t\n+\tpublic static boolean hasUserIdParameterOrAccessTokenHeader(HandlerMethod handlerMethod) {\n+\t\tfor (MethodParameter methodParameter : handlerMethod.getMethodParameters()) {\n+\t\t\tRequestParam requestParam = methodParameter.getParameterAnnotation(RequestParam.class);\n+\t\t\tif (requestParam!=null && requestParam.value().equals(AuthorizationConstants.USER_ID_PARAM)) {\n+\t\t\t\treturn true;\n+\t\t\t}\n+\t\t\tRequestHeader requestHeader = methodParameter.getParameterAnnotation(RequestHeader.class);\n+\t\t\tif (requestHeader!=null && requestHeader.value().equals(SYNAPSE_AUTHORIZATION_HEADER_NAME)) {\n+\t\t\t\treturn true;\n+\t\t\t}\n+\t\t}\n+\t\treturn false;\n+\t}\n+\t\n+\tpublic static boolean isAnonymous(HttpServletRequest request) {\n+\t\tString userIdRequestParameter = request.getParameter(AuthorizationConstants.USER_ID_PARAM);\n+\t\treturn userIdRequestParameter == null ||\n+\t\t\t\tAuthorizationConstants.BOOTSTRAP_PRINCIPAL.ANONYMOUS_USER.getPrincipalId()\n+\t\t\t\t\t.equals(Long.parseLong(userIdRequestParameter));\n+\t}\n+\n+\t@Override\n+\tpublic boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler)\n+\t\t\tthrows Exception {\n+\t\t\n+\t\t// anonymous requests do not need to have scope checked, they have the same \n+\t\t// access that unauthenticated requests have\n+\t\tif (isAnonymous(request)) {\n+\t\t\treturn true;\n+\t\t}\n+\t\t\n+\t\tSet<String> missingScopes = new TreeSet<String>();\n+\t\t{\n+\t\t\t// if no scopes are specified by an annotation on the method, then we use these defaults\n+\t\t\tSet<OAuthScope> requiredScopes = new TreeSet<OAuthScope>(DEFAULT_SCOPES);\n+\t\t\t\n+\t\t\tif (!(handler instanceof HandlerMethod)) {\n+\t\t\t\tthrow new IllegalStateException(\"Ths HandlerInterceptor should only be applied to HandlerMethods, but this handler is a \"+handler.getClass());\n+\t\t\t}\n+\t\t\t\n+\t\t\tHandlerMethod handlerMethod = (HandlerMethod) handler;\n+\n+\t\t\t// if no 'userId' parameter or access token header then this is \n+\t\t\t// not an authenticated request, and no scope is required\n+\t\t\tif (!hasUserIdParameterOrAccessTokenHeader(handlerMethod)) {\n+\t\t\t\treturn true;\n+\t\t\t}\n+\n+\t\t\tRequiredScope requiredScopeAnnotation = handlerMethod.getMethodAnnotation(RequiredScope.class);\n+\t\t\tif (requiredScopeAnnotation != null) {\n+\t\t\t\trequiredScopes = new HashSet<OAuthScope>(Arrays.asList(requiredScopeAnnotation.value()));\n+\t\t\t}\n+\n+\t\t\tList<OAuthScope> requestScopes = Collections.EMPTY_LIST;\n+\t\t\tString synapseAuthorizationHeader = request.getHeader(SYNAPSE_AUTHORIZATION_HEADER_NAME);\n+\t\t\tString accessToken = HttpAuthUtil.getBearerTokenFromAuthorizationHeader(synapseAuthorizationHeader);\n+\t\t\tif (accessToken!=null) {\n+\t\t\t\tJwt<JwsHeader, Claims> jwt = oidcTokenHelper.parseJWT(accessToken);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "56e69b637c8277cfd24afcd58c21a8ca739d8959"}, "originalPosition": 111}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk1NzE3MDU1", "url": "https://github.com/Sage-Bionetworks/Synapse-Repository-Services/pull/4006#pullrequestreview-395717055", "createdAt": "2020-04-17T19:26:49Z", "commit": {"oid": "56e69b637c8277cfd24afcd58c21a8ca739d8959"}, "state": "APPROVED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xN1QxOToyNjo0OVrOGHabRQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xN1QxOTo0Njo1MVrOGHa_Ag==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDQyNjE4MQ==", "bodyText": "We can compute the missing scopes when needed to build the error message and we can check on the requiredScopes.isEmpty() instead at line 121", "url": "https://github.com/Sage-Bionetworks/Synapse-Repository-Services/pull/4006#discussion_r410426181", "createdAt": "2020-04-17T19:26:49Z", "author": {"login": "marcomarasca"}, "path": "services/repository/src/main/java/org/sagebionetworks/repo/web/OAuthScopeInterceptor.java", "diffHunk": "@@ -0,0 +1,137 @@\n+package org.sagebionetworks.repo.web;\n+\n+import static org.sagebionetworks.repo.model.AuthorizationConstants.SYNAPSE_AUTHORIZATION_HEADER_NAME;\n+\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.TreeSet;\n+\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+\n+import org.sagebionetworks.auth.HttpAuthUtil;\n+import org.sagebionetworks.repo.manager.oauth.ClaimsJsonUtil;\n+import org.sagebionetworks.repo.manager.oauth.OIDCTokenHelper;\n+import org.sagebionetworks.repo.model.AuthorizationConstants;\n+import org.sagebionetworks.repo.model.oauth.OAuthScope;\n+import org.sagebionetworks.repo.web.controller.RequiredScope;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.core.MethodParameter;\n+import org.springframework.http.HttpStatus;\n+import org.springframework.web.bind.annotation.RequestHeader;\n+import org.springframework.web.bind.annotation.RequestParam;\n+import org.springframework.web.method.HandlerMethod;\n+import org.springframework.web.servlet.HandlerInterceptor;\n+\n+import io.jsonwebtoken.Claims;\n+import io.jsonwebtoken.JwsHeader;\n+import io.jsonwebtoken.Jwt;\n+\n+/*\n+ * For requests which require authentication (have a 'userId' parameter) and are not anonymous, \n+ * the scope in the access token is compared to the scope in the RequiredScope annotation \n+ * (default to full scope) and 403 status is returned if the required scope is not present.\n+ */\n+public class OAuthScopeInterceptor implements HandlerInterceptor {\n+\n+\t/*\n+\t * If a handler is not annotated with RequiredScope then, by default, it requires the following\n+\t */\n+\tprivate static final Set<OAuthScope> DEFAULT_SCOPES;\n+\tstatic {\n+\t\tDEFAULT_SCOPES = new HashSet<OAuthScope>(Arrays.asList(OAuthScope.values()));\n+\t\tDEFAULT_SCOPES.remove(OAuthScope.openid);\n+\t}\n+\n+\tprivate static final String ERROR_MESSAGE_PREFIX  = \"Request lacks scope(s) required by this service: \";\n+\t\n+\t@Autowired\n+\tprivate OIDCTokenHelper oidcTokenHelper;\n+\t\n+\tpublic static boolean hasUserIdParameterOrAccessTokenHeader(HandlerMethod handlerMethod) {\n+\t\tfor (MethodParameter methodParameter : handlerMethod.getMethodParameters()) {\n+\t\t\tRequestParam requestParam = methodParameter.getParameterAnnotation(RequestParam.class);\n+\t\t\tif (requestParam!=null && requestParam.value().equals(AuthorizationConstants.USER_ID_PARAM)) {\n+\t\t\t\treturn true;\n+\t\t\t}\n+\t\t\tRequestHeader requestHeader = methodParameter.getParameterAnnotation(RequestHeader.class);\n+\t\t\tif (requestHeader!=null && requestHeader.value().equals(SYNAPSE_AUTHORIZATION_HEADER_NAME)) {\n+\t\t\t\treturn true;\n+\t\t\t}\n+\t\t}\n+\t\treturn false;\n+\t}\n+\t\n+\tpublic static boolean isAnonymous(HttpServletRequest request) {\n+\t\tString userIdRequestParameter = request.getParameter(AuthorizationConstants.USER_ID_PARAM);\n+\t\treturn userIdRequestParameter == null ||\n+\t\t\t\tAuthorizationConstants.BOOTSTRAP_PRINCIPAL.ANONYMOUS_USER.getPrincipalId()\n+\t\t\t\t\t.equals(Long.parseLong(userIdRequestParameter));\n+\t}\n+\n+\t@Override\n+\tpublic boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler)\n+\t\t\tthrows Exception {\n+\t\t\n+\t\t// anonymous requests do not need to have scope checked, they have the same \n+\t\t// access that unauthenticated requests have\n+\t\tif (isAnonymous(request)) {\n+\t\t\treturn true;\n+\t\t}\n+\t\t\n+\t\tSet<String> missingScopes = new TreeSet<String>();\n+\t\t{\n+\t\t\t// if no scopes are specified by an annotation on the method, then we use these defaults\n+\t\t\tSet<OAuthScope> requiredScopes = new TreeSet<OAuthScope>(DEFAULT_SCOPES);\n+\t\t\t\n+\t\t\tif (!(handler instanceof HandlerMethod)) {\n+\t\t\t\tthrow new IllegalStateException(\"Ths HandlerInterceptor should only be applied to HandlerMethods, but this handler is a \"+handler.getClass());\n+\t\t\t}\n+\t\t\t\n+\t\t\tHandlerMethod handlerMethod = (HandlerMethod) handler;\n+\n+\t\t\t// if no 'userId' parameter or access token header then this is \n+\t\t\t// not an authenticated request, and no scope is required\n+\t\t\tif (!hasUserIdParameterOrAccessTokenHeader(handlerMethod)) {\n+\t\t\t\treturn true;\n+\t\t\t}\n+\n+\t\t\tRequiredScope requiredScopeAnnotation = handlerMethod.getMethodAnnotation(RequiredScope.class);\n+\t\t\tif (requiredScopeAnnotation != null) {\n+\t\t\t\trequiredScopes = new HashSet<OAuthScope>(Arrays.asList(requiredScopeAnnotation.value()));\n+\t\t\t}\n+\n+\t\t\tList<OAuthScope> requestScopes = Collections.EMPTY_LIST;\n+\t\t\tString synapseAuthorizationHeader = request.getHeader(SYNAPSE_AUTHORIZATION_HEADER_NAME);\n+\t\t\tString accessToken = HttpAuthUtil.getBearerTokenFromAuthorizationHeader(synapseAuthorizationHeader);\n+\t\t\tif (accessToken!=null) {\n+\t\t\t\tJwt<JwsHeader, Claims> jwt = oidcTokenHelper.parseJWT(accessToken);\n+\t\t\t\trequestScopes = ClaimsJsonUtil.getScopeFromClaims(jwt.getBody());\n+\t\t\t}\n+\n+\t\t\trequiredScopes.removeAll(requestScopes);\n+\t\t\tfor (OAuthScope scope: requiredScopes) {\n+\t\t\t\tmissingScopes.add(scope.name());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "56e69b637c8277cfd24afcd58c21a8ca739d8959"}, "originalPosition": 117}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDQyNjYwNg==", "bodyText": "We could use the String.join", "url": "https://github.com/Sage-Bionetworks/Synapse-Repository-Services/pull/4006#discussion_r410426606", "createdAt": "2020-04-17T19:27:50Z", "author": {"login": "marcomarasca"}, "path": "services/repository/src/main/java/org/sagebionetworks/repo/web/OAuthScopeInterceptor.java", "diffHunk": "@@ -0,0 +1,137 @@\n+package org.sagebionetworks.repo.web;\n+\n+import static org.sagebionetworks.repo.model.AuthorizationConstants.SYNAPSE_AUTHORIZATION_HEADER_NAME;\n+\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.TreeSet;\n+\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+\n+import org.sagebionetworks.auth.HttpAuthUtil;\n+import org.sagebionetworks.repo.manager.oauth.ClaimsJsonUtil;\n+import org.sagebionetworks.repo.manager.oauth.OIDCTokenHelper;\n+import org.sagebionetworks.repo.model.AuthorizationConstants;\n+import org.sagebionetworks.repo.model.oauth.OAuthScope;\n+import org.sagebionetworks.repo.web.controller.RequiredScope;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.core.MethodParameter;\n+import org.springframework.http.HttpStatus;\n+import org.springframework.web.bind.annotation.RequestHeader;\n+import org.springframework.web.bind.annotation.RequestParam;\n+import org.springframework.web.method.HandlerMethod;\n+import org.springframework.web.servlet.HandlerInterceptor;\n+\n+import io.jsonwebtoken.Claims;\n+import io.jsonwebtoken.JwsHeader;\n+import io.jsonwebtoken.Jwt;\n+\n+/*\n+ * For requests which require authentication (have a 'userId' parameter) and are not anonymous, \n+ * the scope in the access token is compared to the scope in the RequiredScope annotation \n+ * (default to full scope) and 403 status is returned if the required scope is not present.\n+ */\n+public class OAuthScopeInterceptor implements HandlerInterceptor {\n+\n+\t/*\n+\t * If a handler is not annotated with RequiredScope then, by default, it requires the following\n+\t */\n+\tprivate static final Set<OAuthScope> DEFAULT_SCOPES;\n+\tstatic {\n+\t\tDEFAULT_SCOPES = new HashSet<OAuthScope>(Arrays.asList(OAuthScope.values()));\n+\t\tDEFAULT_SCOPES.remove(OAuthScope.openid);\n+\t}\n+\n+\tprivate static final String ERROR_MESSAGE_PREFIX  = \"Request lacks scope(s) required by this service: \";\n+\t\n+\t@Autowired\n+\tprivate OIDCTokenHelper oidcTokenHelper;\n+\t\n+\tpublic static boolean hasUserIdParameterOrAccessTokenHeader(HandlerMethod handlerMethod) {\n+\t\tfor (MethodParameter methodParameter : handlerMethod.getMethodParameters()) {\n+\t\t\tRequestParam requestParam = methodParameter.getParameterAnnotation(RequestParam.class);\n+\t\t\tif (requestParam!=null && requestParam.value().equals(AuthorizationConstants.USER_ID_PARAM)) {\n+\t\t\t\treturn true;\n+\t\t\t}\n+\t\t\tRequestHeader requestHeader = methodParameter.getParameterAnnotation(RequestHeader.class);\n+\t\t\tif (requestHeader!=null && requestHeader.value().equals(SYNAPSE_AUTHORIZATION_HEADER_NAME)) {\n+\t\t\t\treturn true;\n+\t\t\t}\n+\t\t}\n+\t\treturn false;\n+\t}\n+\t\n+\tpublic static boolean isAnonymous(HttpServletRequest request) {\n+\t\tString userIdRequestParameter = request.getParameter(AuthorizationConstants.USER_ID_PARAM);\n+\t\treturn userIdRequestParameter == null ||\n+\t\t\t\tAuthorizationConstants.BOOTSTRAP_PRINCIPAL.ANONYMOUS_USER.getPrincipalId()\n+\t\t\t\t\t.equals(Long.parseLong(userIdRequestParameter));\n+\t}\n+\n+\t@Override\n+\tpublic boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler)\n+\t\t\tthrows Exception {\n+\t\t\n+\t\t// anonymous requests do not need to have scope checked, they have the same \n+\t\t// access that unauthenticated requests have\n+\t\tif (isAnonymous(request)) {\n+\t\t\treturn true;\n+\t\t}\n+\t\t\n+\t\tSet<String> missingScopes = new TreeSet<String>();\n+\t\t{\n+\t\t\t// if no scopes are specified by an annotation on the method, then we use these defaults\n+\t\t\tSet<OAuthScope> requiredScopes = new TreeSet<OAuthScope>(DEFAULT_SCOPES);\n+\t\t\t\n+\t\t\tif (!(handler instanceof HandlerMethod)) {\n+\t\t\t\tthrow new IllegalStateException(\"Ths HandlerInterceptor should only be applied to HandlerMethods, but this handler is a \"+handler.getClass());\n+\t\t\t}\n+\t\t\t\n+\t\t\tHandlerMethod handlerMethod = (HandlerMethod) handler;\n+\n+\t\t\t// if no 'userId' parameter or access token header then this is \n+\t\t\t// not an authenticated request, and no scope is required\n+\t\t\tif (!hasUserIdParameterOrAccessTokenHeader(handlerMethod)) {\n+\t\t\t\treturn true;\n+\t\t\t}\n+\n+\t\t\tRequiredScope requiredScopeAnnotation = handlerMethod.getMethodAnnotation(RequiredScope.class);\n+\t\t\tif (requiredScopeAnnotation != null) {\n+\t\t\t\trequiredScopes = new HashSet<OAuthScope>(Arrays.asList(requiredScopeAnnotation.value()));\n+\t\t\t}\n+\n+\t\t\tList<OAuthScope> requestScopes = Collections.EMPTY_LIST;\n+\t\t\tString synapseAuthorizationHeader = request.getHeader(SYNAPSE_AUTHORIZATION_HEADER_NAME);\n+\t\t\tString accessToken = HttpAuthUtil.getBearerTokenFromAuthorizationHeader(synapseAuthorizationHeader);\n+\t\t\tif (accessToken!=null) {\n+\t\t\t\tJwt<JwsHeader, Claims> jwt = oidcTokenHelper.parseJWT(accessToken);\n+\t\t\t\trequestScopes = ClaimsJsonUtil.getScopeFromClaims(jwt.getBody());\n+\t\t\t}\n+\n+\t\t\trequiredScopes.removeAll(requestScopes);\n+\t\t\tfor (OAuthScope scope: requiredScopes) {\n+\t\t\t\tmissingScopes.add(scope.name());\n+\t\t\t}\n+\t\t}\n+\n+\t\tif (missingScopes.isEmpty()) {\n+\t\t\treturn true;\n+\t\t}\n+\t\t\n+\t\tStringBuilder sb = new StringBuilder(ERROR_MESSAGE_PREFIX);\n+\t\tboolean first = true;\n+\t\tfor (String missingScope : missingScopes) {\n+\t\t\tif (first) first=false; else sb.append(\", \");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "56e69b637c8277cfd24afcd58c21a8ca739d8959"}, "originalPosition": 128}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDQyNjg2NQ==", "bodyText": "We can add some documentation to the annotation", "url": "https://github.com/Sage-Bionetworks/Synapse-Repository-Services/pull/4006#discussion_r410426865", "createdAt": "2020-04-17T19:28:24Z", "author": {"login": "marcomarasca"}, "path": "services/repository/src/main/java/org/sagebionetworks/repo/web/controller/RequiredScope.java", "diffHunk": "@@ -0,0 +1,15 @@\n+package org.sagebionetworks.repo.web.controller;\n+\n+import static java.lang.annotation.ElementType.METHOD;\n+import static java.lang.annotation.RetentionPolicy.RUNTIME;\n+\n+import java.lang.annotation.Retention;\n+import java.lang.annotation.Target;\n+\n+import org.sagebionetworks.repo.model.oauth.OAuthScope;\n+\n+@Retention(RUNTIME)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "56e69b637c8277cfd24afcd58c21a8ca739d8959"}, "originalPosition": 11}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDQzNTMzMA==", "bodyText": "Add test for the invalid token case, see the interceptor comment", "url": "https://github.com/Sage-Bionetworks/Synapse-Repository-Services/pull/4006#discussion_r410435330", "createdAt": "2020-04-17T19:46:51Z", "author": {"login": "marcomarasca"}, "path": "services/repository/src/test/java/org/sagebionetworks/repo/web/OAuthScopeInterceptorTest.java", "diffHunk": "@@ -0,0 +1,285 @@\n+package org.sagebionetworks.repo.web;\n+\n+import static org.junit.jupiter.api.Assertions.*;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.ArgumentMatchers.anyString;\n+import static org.mockito.Mockito.never;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.when;\n+import static org.sagebionetworks.repo.model.AuthorizationConstants.SYNAPSE_AUTHORIZATION_HEADER_NAME;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.io.OutputStream;\n+import java.io.PrintWriter;\n+import java.lang.annotation.Annotation;\n+import java.util.Arrays;\n+import java.util.Collections;\n+\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.extension.ExtendWith;\n+import org.mockito.InjectMocks;\n+import org.mockito.Mock;\n+import org.mockito.junit.jupiter.MockitoExtension;\n+import org.sagebionetworks.repo.manager.oauth.ClaimsJsonUtil;\n+import org.sagebionetworks.repo.manager.oauth.OIDCTokenHelper;\n+import org.sagebionetworks.repo.model.AuthorizationConstants;\n+import org.sagebionetworks.repo.model.oauth.OAuthScope;\n+import org.sagebionetworks.repo.web.controller.RequiredScope;\n+import org.springframework.core.MethodParameter;\n+import org.springframework.web.bind.annotation.RequestHeader;\n+import org.springframework.web.bind.annotation.RequestParam;\n+import org.springframework.web.method.HandlerMethod;\n+\n+import io.jsonwebtoken.Claims;\n+import io.jsonwebtoken.JwsHeader;\n+import io.jsonwebtoken.Jwt;\n+import io.jsonwebtoken.impl.DefaultClaims;\n+\n+@ExtendWith(MockitoExtension.class)\n+class OAuthScopeInterceptorTest {\n+\n+\t@Mock\n+\tprivate OIDCTokenHelper mockOidcTokenHelper;\n+\n+\t@InjectMocks\n+\tprivate OAuthScopeInterceptor oauthScopeInterceptor;\n+\t\n+\t@Mock\n+\tprivate HttpServletRequest mockRequest; \n+\t\n+\t@Mock\n+\tprivate HttpServletResponse mockResponse; \n+\t\n+\t@Mock\n+\tprivate HandlerMethod mockHandler;\n+\t\n+\t@Mock\n+\tprivate MethodParameter mockUserIdParameter;\n+\t\n+\t@Mock\n+\tprivate MethodParameter mockAccessTokenHeader;\n+\t\n+\t@Mock\n+\tprivate Jwt<JwsHeader, Claims> mockJwt;\n+\t\n+\t@Mock\n+\tprivate RequestParam mockRequestParam;\n+\t\n+\t@Mock\n+\tprivate RequestHeader mockRequestHeader;\n+\t\n+\tprivate static final String USER_ID = \"100001\";\n+\tprivate static final String ACCESS_TOKEN = \"access-token\";\n+\t\n+\tprivate static RequiredScope createRequiredScopeAnnotation(final OAuthScope[] scopes) {\n+\t\treturn new RequiredScope() {\n+\t\t\t@Override\n+\t\t\tpublic Class<? extends Annotation> annotationType() {return RequiredScope.class;}\n+\t\t\t@Override\n+\t\t\tpublic OAuthScope[] value() {return scopes;}\n+\t\t};\n+\t}\n+\t\n+\tprivate static Claims createClaimsForScope(final OAuthScope[] scopes) {\n+\t\tDefaultClaims result = new DefaultClaims();\n+\t\tClaimsJsonUtil.addAccessClaims( Arrays.asList(scopes), \n+\t\t\t\tCollections.EMPTY_MAP, result);\n+\t\treturn result;\n+\t}\n+\t\n+\t@BeforeEach\n+\tvoid before() {\n+\t}\n+\t\n+\t// mock an annotated method with a userId parameter\n+\tprivate void mockRequiredScopeAnnotation() {\n+\t\tRequiredScope requiredScopeAnnotation = createRequiredScopeAnnotation(OAuthScope.values());\n+\t\twhen(mockHandler.getMethodAnnotation(RequiredScope.class)).thenReturn(requiredScopeAnnotation);\n+\t}\n+\t\t\n+\tprivate void mockRequestIdParam() {\n+\t\twhen(mockRequestParam.value()).thenReturn( AuthorizationConstants.USER_ID_PARAM);\n+\t\twhen(mockHandler.getMethodParameters()).thenReturn(new MethodParameter[] {mockUserIdParameter});\n+\t\twhen(mockUserIdParameter.getParameterAnnotation(RequestParam.class)).thenReturn(mockRequestParam);\n+\t}\n+\t\n+\tprivate void mockRequest(String userId, String accessToken) {\n+\t\tif (accessToken!=null) {\n+\t\t\twhen(mockRequest.getHeader(SYNAPSE_AUTHORIZATION_HEADER_NAME)).thenReturn(\"Bearer \"+accessToken);\n+\t\t}\n+\t\twhen(mockRequest.getParameter(AuthorizationConstants.USER_ID_PARAM)).thenReturn(userId); \t\n+\t}\n+\t\n+\tprivate void mockAccessToken(OAuthScope[] scopes) {\n+\t\twhen(mockOidcTokenHelper.parseJWT(ACCESS_TOKEN)).thenReturn(mockJwt);\n+\t\twhen(mockJwt.getBody()).thenReturn(createClaimsForScope(scopes));\t\t\n+\t}\n+\t\n+\tprivate OutputStream mockResponse() throws IOException {\n+\t\tByteArrayOutputStream os = new ByteArrayOutputStream();\n+\t\twhen(mockResponse.getWriter()).thenReturn(new PrintWriter(os));\n+\t\treturn os;\n+\t}\n+\t\n+\t@Test\n+\tvoid testHasUserIdParameterOrAccessTokenHeader_withUserId() {\n+\t\twhen(mockHandler.getMethodParameters()).thenReturn(new MethodParameter[] {mockUserIdParameter});\n+\t\twhen(mockUserIdParameter.getParameterAnnotation(RequestParam.class)).thenReturn(mockRequestParam);\n+\t\twhen(mockRequestParam.value()).thenReturn( AuthorizationConstants.USER_ID_PARAM);\n+\n+\t\t// method under test\n+\t\tassertTrue(OAuthScopeInterceptor.hasUserIdParameterOrAccessTokenHeader(mockHandler));\n+\t}\n+\t\n+\t@Test\n+\tvoid testHasUserIdParameterOrAccessTokenHeader_withAccessToken() {\n+\t\twhen(mockHandler.getMethodParameters()).thenReturn(new MethodParameter[] {mockAccessTokenHeader});\n+\t\twhen(mockAccessTokenHeader.getParameterAnnotation(RequestParam.class)).thenReturn(null);\n+\t\twhen(mockAccessTokenHeader.getParameterAnnotation(RequestHeader.class)).thenReturn(mockRequestHeader);\n+\t\twhen(mockRequestHeader.value()).thenReturn( AuthorizationConstants.SYNAPSE_AUTHORIZATION_HEADER_NAME);\n+\n+\t\t// method under test\n+\t\tassertTrue(OAuthScopeInterceptor.hasUserIdParameterOrAccessTokenHeader(mockHandler));\n+\t}\n+\t\n+\t@Test\n+\tvoid testHasUserIdParameterOrAccessTokenHeader_Nothing() {\n+\t\twhen(mockHandler.getMethodParameters()).thenReturn(new MethodParameter[] {});\n+\t\t// method under test\n+\t\tassertFalse(OAuthScopeInterceptor.hasUserIdParameterOrAccessTokenHeader(mockHandler));\n+\t}\n+\t\n+\t@Test\n+\tvoid testIsAnonymous_anonymousId() {\n+\t\twhen(mockRequest.getParameter(AuthorizationConstants.USER_ID_PARAM)).\n+\t\t\tthenReturn(AuthorizationConstants.BOOTSTRAP_PRINCIPAL.ANONYMOUS_USER.getPrincipalId().toString());\n+\t\tassertTrue(OAuthScopeInterceptor.isAnonymous(mockRequest));\n+\t}\n+\t\n+\t@Test\n+\tvoid testIsAnonymous_missingId() {\n+\t\tassertTrue(OAuthScopeInterceptor.isAnonymous(mockRequest));\n+\t}\n+\t\n+\t@Test\n+\tvoid testIsAnonymous_NOT_anonymous() {\n+\t\twhen(mockRequest.getParameter(AuthorizationConstants.USER_ID_PARAM)).thenReturn(\"123\");\n+\t\tassertFalse(OAuthScopeInterceptor.isAnonymous(mockRequest));\n+\t}\n+\t\n+\t@Test\n+\tvoid testPrehandleAnonymous() throws Exception {\n+\t\tmockRequest(AuthorizationConstants.BOOTSTRAP_PRINCIPAL.ANONYMOUS_USER.getPrincipalId().toString(), null);// anonymous, no access token\n+\t\t\n+\t\t// method under test\n+\t\tboolean result = oauthScopeInterceptor.preHandle(mockRequest, mockResponse, mockHandler);\n+\t\t\n+\t\tassertTrue(result);\n+\t\t\n+\t\tverify(mockRequest, never()).getHeader(anyString());\n+\t\tverify(mockHandler, never()).getMethodAnnotation(any());\n+\t}\n+\n+\t@Test\n+\tvoid testPrehandleAnonymous_handlerWrongType() throws Exception {\n+\t\tmockRequest(\"123\", null);// NOT anonymous\n+\t\t\n+\t\t// method under test\n+\t\tassertThrows(IllegalStateException.class, \n+\t\t\t\t() -> {oauthScopeInterceptor.preHandle(mockRequest, mockResponse, String.class);\n+\t\t});\n+\n+\t}\n+\n+\t@Test\n+\tvoid testPrehandleNoUserIdORAccessTokenParameter() throws Exception {\n+\t\tmockRequest(null, null);// anonymous, no access token\n+\n+\t\t// method under test\n+\t\tboolean result = oauthScopeInterceptor.preHandle(mockRequest, mockResponse, mockHandler);\n+\t\t\n+\t\tassertTrue(result);\n+\t}\n+\n+\t@Test\n+\tvoid testPrehandleHappyCase() throws Exception {\n+\t\tmockRequiredScopeAnnotation();\n+\t\tmockRequestIdParam();\n+\t\tmockRequest(USER_ID, ACCESS_TOKEN);// NOT anonymous\t\n+\t\tmockAccessToken(OAuthScope.values());\n+\t\t\n+\t\t// method under test\n+\t\tboolean result = oauthScopeInterceptor.preHandle(mockRequest, mockResponse, mockHandler);\n+\t\t\n+\t\tassertTrue(result);\n+\t\t\n+\t\tverify(mockHandler).getMethodAnnotation(RequiredScope.class);\n+\t\tverify(mockRequest).getHeader(SYNAPSE_AUTHORIZATION_HEADER_NAME);\n+\t\tverify(mockOidcTokenHelper).parseJWT(ACCESS_TOKEN);\n+\t}\n+\n+\t@Test\n+\tvoid testPrehandleNoScopeAnnotation() throws Exception {\n+\t\twhen(mockHandler.getMethodAnnotation(RequiredScope.class)).thenReturn(null);\n+\t\tmockRequestIdParam();\n+\t\tmockRequest(USER_ID, ACCESS_TOKEN);// NOT anonymous\t\n+\t\tmockAccessToken(OAuthScope.values());\n+\t\t\n+\t\t// method under test\n+\t\tboolean result = oauthScopeInterceptor.preHandle(mockRequest, mockResponse, mockHandler);\n+\t\t\n+\t\tassertTrue(result);\n+\t\t\n+\t\tverify(mockHandler).getMethodAnnotation(RequiredScope.class);\n+\t\tverify(mockRequest).getHeader(SYNAPSE_AUTHORIZATION_HEADER_NAME);\n+\t\tverify(mockOidcTokenHelper).parseJWT(ACCESS_TOKEN);\n+\t}\n+\n+\t@Test\n+\tvoid testPrehandleInsufficentScope() throws Exception {\n+\t\tmockRequiredScopeAnnotation();\n+\t\tmockRequestIdParam();\n+\t\t\n+\t\tmockRequest(USER_ID, ACCESS_TOKEN);// NOT anonymous\t\n+\t\tmockAccessToken(new OAuthScope[] {OAuthScope.view});\n+\t\tOutputStream os = mockResponse();\n+\t\t\n+\t\t// method under test\n+\t\tboolean result = oauthScopeInterceptor.preHandle(mockRequest, mockResponse, mockHandler);\n+\t\t\n+\t\tassertFalse(result);\n+\t\t\n+\t\tverify(mockRequest).getHeader(SYNAPSE_AUTHORIZATION_HEADER_NAME);\n+\n+\t\tassertEquals(\"{\\\"reason\\\":\\\"Request lacks scope(s) required by this service: download, modify, openid\\\"}\\n\", os.toString());\n+\t\t\n+\t}\n+\n+\t@Test\n+\tvoid testPrehandleNoAccessToken() throws Exception {\n+\t\tmockRequiredScopeAnnotation();\n+\t\tmockRequestIdParam();\n+\t\t\n+\t\tmockRequest(USER_ID, null);// NOT anonymous, no access token\n+\t\tOutputStream os = mockResponse();\n+\t\t\n+\t\t// method under test\n+\t\tboolean result = oauthScopeInterceptor.preHandle(mockRequest, mockResponse, mockHandler);\n+\t\t\n+\t\tassertFalse(result);\n+\n+\t\tassertEquals(\"{\\\"reason\\\":\\\"Request lacks scope(s) required by this service: download, modify, openid, view\\\"}\\n\",  os.toString());\n+\t\t\n+\t\tverify(mockRequest).getHeader(SYNAPSE_AUTHORIZATION_HEADER_NAME);\n+\t\tverify(mockOidcTokenHelper, never()).parseJWT(anyString());\n+\t\tverify(mockHandler).getMethodAnnotation(RequiredScope.class);\n+\t}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "56e69b637c8277cfd24afcd58c21a8ca739d8959"}, "originalPosition": 283}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4867, "cost": 1, "resetAt": "2021-11-02T10:47:05Z"}}}