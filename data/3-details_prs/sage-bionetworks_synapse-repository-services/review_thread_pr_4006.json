{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDA1MTcxNjUz", "number": 4006, "reviewThreads": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xN1QxOToyMzowMlrODzBLhA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xN1QxOTo0Njo1MVrODzBlqw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU0ODIzMzAwOnYy", "diffSide": "RIGHT", "path": "services/repository/src/main/java/org/sagebionetworks/repo/web/OAuthScopeInterceptor.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xN1QxOToyMzowMlrOGHaUWw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xN1QxOToyMzowMlrOGHaUWw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDQyNDQxMQ==", "bodyText": "If the token is invalid it should return a 403", "url": "https://github.com/Sage-Bionetworks/Synapse-Repository-Services/pull/4006#discussion_r410424411", "createdAt": "2020-04-17T19:23:02Z", "author": {"login": "marcomarasca"}, "path": "services/repository/src/main/java/org/sagebionetworks/repo/web/OAuthScopeInterceptor.java", "diffHunk": "@@ -0,0 +1,137 @@\n+package org.sagebionetworks.repo.web;\n+\n+import static org.sagebionetworks.repo.model.AuthorizationConstants.SYNAPSE_AUTHORIZATION_HEADER_NAME;\n+\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.TreeSet;\n+\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+\n+import org.sagebionetworks.auth.HttpAuthUtil;\n+import org.sagebionetworks.repo.manager.oauth.ClaimsJsonUtil;\n+import org.sagebionetworks.repo.manager.oauth.OIDCTokenHelper;\n+import org.sagebionetworks.repo.model.AuthorizationConstants;\n+import org.sagebionetworks.repo.model.oauth.OAuthScope;\n+import org.sagebionetworks.repo.web.controller.RequiredScope;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.core.MethodParameter;\n+import org.springframework.http.HttpStatus;\n+import org.springframework.web.bind.annotation.RequestHeader;\n+import org.springframework.web.bind.annotation.RequestParam;\n+import org.springframework.web.method.HandlerMethod;\n+import org.springframework.web.servlet.HandlerInterceptor;\n+\n+import io.jsonwebtoken.Claims;\n+import io.jsonwebtoken.JwsHeader;\n+import io.jsonwebtoken.Jwt;\n+\n+/*\n+ * For requests which require authentication (have a 'userId' parameter) and are not anonymous, \n+ * the scope in the access token is compared to the scope in the RequiredScope annotation \n+ * (default to full scope) and 403 status is returned if the required scope is not present.\n+ */\n+public class OAuthScopeInterceptor implements HandlerInterceptor {\n+\n+\t/*\n+\t * If a handler is not annotated with RequiredScope then, by default, it requires the following\n+\t */\n+\tprivate static final Set<OAuthScope> DEFAULT_SCOPES;\n+\tstatic {\n+\t\tDEFAULT_SCOPES = new HashSet<OAuthScope>(Arrays.asList(OAuthScope.values()));\n+\t\tDEFAULT_SCOPES.remove(OAuthScope.openid);\n+\t}\n+\n+\tprivate static final String ERROR_MESSAGE_PREFIX  = \"Request lacks scope(s) required by this service: \";\n+\t\n+\t@Autowired\n+\tprivate OIDCTokenHelper oidcTokenHelper;\n+\t\n+\tpublic static boolean hasUserIdParameterOrAccessTokenHeader(HandlerMethod handlerMethod) {\n+\t\tfor (MethodParameter methodParameter : handlerMethod.getMethodParameters()) {\n+\t\t\tRequestParam requestParam = methodParameter.getParameterAnnotation(RequestParam.class);\n+\t\t\tif (requestParam!=null && requestParam.value().equals(AuthorizationConstants.USER_ID_PARAM)) {\n+\t\t\t\treturn true;\n+\t\t\t}\n+\t\t\tRequestHeader requestHeader = methodParameter.getParameterAnnotation(RequestHeader.class);\n+\t\t\tif (requestHeader!=null && requestHeader.value().equals(SYNAPSE_AUTHORIZATION_HEADER_NAME)) {\n+\t\t\t\treturn true;\n+\t\t\t}\n+\t\t}\n+\t\treturn false;\n+\t}\n+\t\n+\tpublic static boolean isAnonymous(HttpServletRequest request) {\n+\t\tString userIdRequestParameter = request.getParameter(AuthorizationConstants.USER_ID_PARAM);\n+\t\treturn userIdRequestParameter == null ||\n+\t\t\t\tAuthorizationConstants.BOOTSTRAP_PRINCIPAL.ANONYMOUS_USER.getPrincipalId()\n+\t\t\t\t\t.equals(Long.parseLong(userIdRequestParameter));\n+\t}\n+\n+\t@Override\n+\tpublic boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler)\n+\t\t\tthrows Exception {\n+\t\t\n+\t\t// anonymous requests do not need to have scope checked, they have the same \n+\t\t// access that unauthenticated requests have\n+\t\tif (isAnonymous(request)) {\n+\t\t\treturn true;\n+\t\t}\n+\t\t\n+\t\tSet<String> missingScopes = new TreeSet<String>();\n+\t\t{\n+\t\t\t// if no scopes are specified by an annotation on the method, then we use these defaults\n+\t\t\tSet<OAuthScope> requiredScopes = new TreeSet<OAuthScope>(DEFAULT_SCOPES);\n+\t\t\t\n+\t\t\tif (!(handler instanceof HandlerMethod)) {\n+\t\t\t\tthrow new IllegalStateException(\"Ths HandlerInterceptor should only be applied to HandlerMethods, but this handler is a \"+handler.getClass());\n+\t\t\t}\n+\t\t\t\n+\t\t\tHandlerMethod handlerMethod = (HandlerMethod) handler;\n+\n+\t\t\t// if no 'userId' parameter or access token header then this is \n+\t\t\t// not an authenticated request, and no scope is required\n+\t\t\tif (!hasUserIdParameterOrAccessTokenHeader(handlerMethod)) {\n+\t\t\t\treturn true;\n+\t\t\t}\n+\n+\t\t\tRequiredScope requiredScopeAnnotation = handlerMethod.getMethodAnnotation(RequiredScope.class);\n+\t\t\tif (requiredScopeAnnotation != null) {\n+\t\t\t\trequiredScopes = new HashSet<OAuthScope>(Arrays.asList(requiredScopeAnnotation.value()));\n+\t\t\t}\n+\n+\t\t\tList<OAuthScope> requestScopes = Collections.EMPTY_LIST;\n+\t\t\tString synapseAuthorizationHeader = request.getHeader(SYNAPSE_AUTHORIZATION_HEADER_NAME);\n+\t\t\tString accessToken = HttpAuthUtil.getBearerTokenFromAuthorizationHeader(synapseAuthorizationHeader);\n+\t\t\tif (accessToken!=null) {\n+\t\t\t\tJwt<JwsHeader, Claims> jwt = oidcTokenHelper.parseJWT(accessToken);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "56e69b637c8277cfd24afcd58c21a8ca739d8959"}, "originalPosition": 111}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU0ODI0Mzk5OnYy", "diffSide": "RIGHT", "path": "services/repository/src/main/java/org/sagebionetworks/repo/web/OAuthScopeInterceptor.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xN1QxOToyNjo0OVrOGHabRQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xN1QxOToyNjo0OVrOGHabRQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDQyNjE4MQ==", "bodyText": "We can compute the missing scopes when needed to build the error message and we can check on the requiredScopes.isEmpty() instead at line 121", "url": "https://github.com/Sage-Bionetworks/Synapse-Repository-Services/pull/4006#discussion_r410426181", "createdAt": "2020-04-17T19:26:49Z", "author": {"login": "marcomarasca"}, "path": "services/repository/src/main/java/org/sagebionetworks/repo/web/OAuthScopeInterceptor.java", "diffHunk": "@@ -0,0 +1,137 @@\n+package org.sagebionetworks.repo.web;\n+\n+import static org.sagebionetworks.repo.model.AuthorizationConstants.SYNAPSE_AUTHORIZATION_HEADER_NAME;\n+\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.TreeSet;\n+\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+\n+import org.sagebionetworks.auth.HttpAuthUtil;\n+import org.sagebionetworks.repo.manager.oauth.ClaimsJsonUtil;\n+import org.sagebionetworks.repo.manager.oauth.OIDCTokenHelper;\n+import org.sagebionetworks.repo.model.AuthorizationConstants;\n+import org.sagebionetworks.repo.model.oauth.OAuthScope;\n+import org.sagebionetworks.repo.web.controller.RequiredScope;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.core.MethodParameter;\n+import org.springframework.http.HttpStatus;\n+import org.springframework.web.bind.annotation.RequestHeader;\n+import org.springframework.web.bind.annotation.RequestParam;\n+import org.springframework.web.method.HandlerMethod;\n+import org.springframework.web.servlet.HandlerInterceptor;\n+\n+import io.jsonwebtoken.Claims;\n+import io.jsonwebtoken.JwsHeader;\n+import io.jsonwebtoken.Jwt;\n+\n+/*\n+ * For requests which require authentication (have a 'userId' parameter) and are not anonymous, \n+ * the scope in the access token is compared to the scope in the RequiredScope annotation \n+ * (default to full scope) and 403 status is returned if the required scope is not present.\n+ */\n+public class OAuthScopeInterceptor implements HandlerInterceptor {\n+\n+\t/*\n+\t * If a handler is not annotated with RequiredScope then, by default, it requires the following\n+\t */\n+\tprivate static final Set<OAuthScope> DEFAULT_SCOPES;\n+\tstatic {\n+\t\tDEFAULT_SCOPES = new HashSet<OAuthScope>(Arrays.asList(OAuthScope.values()));\n+\t\tDEFAULT_SCOPES.remove(OAuthScope.openid);\n+\t}\n+\n+\tprivate static final String ERROR_MESSAGE_PREFIX  = \"Request lacks scope(s) required by this service: \";\n+\t\n+\t@Autowired\n+\tprivate OIDCTokenHelper oidcTokenHelper;\n+\t\n+\tpublic static boolean hasUserIdParameterOrAccessTokenHeader(HandlerMethod handlerMethod) {\n+\t\tfor (MethodParameter methodParameter : handlerMethod.getMethodParameters()) {\n+\t\t\tRequestParam requestParam = methodParameter.getParameterAnnotation(RequestParam.class);\n+\t\t\tif (requestParam!=null && requestParam.value().equals(AuthorizationConstants.USER_ID_PARAM)) {\n+\t\t\t\treturn true;\n+\t\t\t}\n+\t\t\tRequestHeader requestHeader = methodParameter.getParameterAnnotation(RequestHeader.class);\n+\t\t\tif (requestHeader!=null && requestHeader.value().equals(SYNAPSE_AUTHORIZATION_HEADER_NAME)) {\n+\t\t\t\treturn true;\n+\t\t\t}\n+\t\t}\n+\t\treturn false;\n+\t}\n+\t\n+\tpublic static boolean isAnonymous(HttpServletRequest request) {\n+\t\tString userIdRequestParameter = request.getParameter(AuthorizationConstants.USER_ID_PARAM);\n+\t\treturn userIdRequestParameter == null ||\n+\t\t\t\tAuthorizationConstants.BOOTSTRAP_PRINCIPAL.ANONYMOUS_USER.getPrincipalId()\n+\t\t\t\t\t.equals(Long.parseLong(userIdRequestParameter));\n+\t}\n+\n+\t@Override\n+\tpublic boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler)\n+\t\t\tthrows Exception {\n+\t\t\n+\t\t// anonymous requests do not need to have scope checked, they have the same \n+\t\t// access that unauthenticated requests have\n+\t\tif (isAnonymous(request)) {\n+\t\t\treturn true;\n+\t\t}\n+\t\t\n+\t\tSet<String> missingScopes = new TreeSet<String>();\n+\t\t{\n+\t\t\t// if no scopes are specified by an annotation on the method, then we use these defaults\n+\t\t\tSet<OAuthScope> requiredScopes = new TreeSet<OAuthScope>(DEFAULT_SCOPES);\n+\t\t\t\n+\t\t\tif (!(handler instanceof HandlerMethod)) {\n+\t\t\t\tthrow new IllegalStateException(\"Ths HandlerInterceptor should only be applied to HandlerMethods, but this handler is a \"+handler.getClass());\n+\t\t\t}\n+\t\t\t\n+\t\t\tHandlerMethod handlerMethod = (HandlerMethod) handler;\n+\n+\t\t\t// if no 'userId' parameter or access token header then this is \n+\t\t\t// not an authenticated request, and no scope is required\n+\t\t\tif (!hasUserIdParameterOrAccessTokenHeader(handlerMethod)) {\n+\t\t\t\treturn true;\n+\t\t\t}\n+\n+\t\t\tRequiredScope requiredScopeAnnotation = handlerMethod.getMethodAnnotation(RequiredScope.class);\n+\t\t\tif (requiredScopeAnnotation != null) {\n+\t\t\t\trequiredScopes = new HashSet<OAuthScope>(Arrays.asList(requiredScopeAnnotation.value()));\n+\t\t\t}\n+\n+\t\t\tList<OAuthScope> requestScopes = Collections.EMPTY_LIST;\n+\t\t\tString synapseAuthorizationHeader = request.getHeader(SYNAPSE_AUTHORIZATION_HEADER_NAME);\n+\t\t\tString accessToken = HttpAuthUtil.getBearerTokenFromAuthorizationHeader(synapseAuthorizationHeader);\n+\t\t\tif (accessToken!=null) {\n+\t\t\t\tJwt<JwsHeader, Claims> jwt = oidcTokenHelper.parseJWT(accessToken);\n+\t\t\t\trequestScopes = ClaimsJsonUtil.getScopeFromClaims(jwt.getBody());\n+\t\t\t}\n+\n+\t\t\trequiredScopes.removeAll(requestScopes);\n+\t\t\tfor (OAuthScope scope: requiredScopes) {\n+\t\t\t\tmissingScopes.add(scope.name());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "56e69b637c8277cfd24afcd58c21a8ca739d8959"}, "originalPosition": 117}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU0ODI0NjUzOnYy", "diffSide": "RIGHT", "path": "services/repository/src/main/java/org/sagebionetworks/repo/web/OAuthScopeInterceptor.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xN1QxOToyNzo1MFrOGHac7g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xN1QxOToyNzo1MFrOGHac7g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDQyNjYwNg==", "bodyText": "We could use the String.join", "url": "https://github.com/Sage-Bionetworks/Synapse-Repository-Services/pull/4006#discussion_r410426606", "createdAt": "2020-04-17T19:27:50Z", "author": {"login": "marcomarasca"}, "path": "services/repository/src/main/java/org/sagebionetworks/repo/web/OAuthScopeInterceptor.java", "diffHunk": "@@ -0,0 +1,137 @@\n+package org.sagebionetworks.repo.web;\n+\n+import static org.sagebionetworks.repo.model.AuthorizationConstants.SYNAPSE_AUTHORIZATION_HEADER_NAME;\n+\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.TreeSet;\n+\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+\n+import org.sagebionetworks.auth.HttpAuthUtil;\n+import org.sagebionetworks.repo.manager.oauth.ClaimsJsonUtil;\n+import org.sagebionetworks.repo.manager.oauth.OIDCTokenHelper;\n+import org.sagebionetworks.repo.model.AuthorizationConstants;\n+import org.sagebionetworks.repo.model.oauth.OAuthScope;\n+import org.sagebionetworks.repo.web.controller.RequiredScope;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.core.MethodParameter;\n+import org.springframework.http.HttpStatus;\n+import org.springframework.web.bind.annotation.RequestHeader;\n+import org.springframework.web.bind.annotation.RequestParam;\n+import org.springframework.web.method.HandlerMethod;\n+import org.springframework.web.servlet.HandlerInterceptor;\n+\n+import io.jsonwebtoken.Claims;\n+import io.jsonwebtoken.JwsHeader;\n+import io.jsonwebtoken.Jwt;\n+\n+/*\n+ * For requests which require authentication (have a 'userId' parameter) and are not anonymous, \n+ * the scope in the access token is compared to the scope in the RequiredScope annotation \n+ * (default to full scope) and 403 status is returned if the required scope is not present.\n+ */\n+public class OAuthScopeInterceptor implements HandlerInterceptor {\n+\n+\t/*\n+\t * If a handler is not annotated with RequiredScope then, by default, it requires the following\n+\t */\n+\tprivate static final Set<OAuthScope> DEFAULT_SCOPES;\n+\tstatic {\n+\t\tDEFAULT_SCOPES = new HashSet<OAuthScope>(Arrays.asList(OAuthScope.values()));\n+\t\tDEFAULT_SCOPES.remove(OAuthScope.openid);\n+\t}\n+\n+\tprivate static final String ERROR_MESSAGE_PREFIX  = \"Request lacks scope(s) required by this service: \";\n+\t\n+\t@Autowired\n+\tprivate OIDCTokenHelper oidcTokenHelper;\n+\t\n+\tpublic static boolean hasUserIdParameterOrAccessTokenHeader(HandlerMethod handlerMethod) {\n+\t\tfor (MethodParameter methodParameter : handlerMethod.getMethodParameters()) {\n+\t\t\tRequestParam requestParam = methodParameter.getParameterAnnotation(RequestParam.class);\n+\t\t\tif (requestParam!=null && requestParam.value().equals(AuthorizationConstants.USER_ID_PARAM)) {\n+\t\t\t\treturn true;\n+\t\t\t}\n+\t\t\tRequestHeader requestHeader = methodParameter.getParameterAnnotation(RequestHeader.class);\n+\t\t\tif (requestHeader!=null && requestHeader.value().equals(SYNAPSE_AUTHORIZATION_HEADER_NAME)) {\n+\t\t\t\treturn true;\n+\t\t\t}\n+\t\t}\n+\t\treturn false;\n+\t}\n+\t\n+\tpublic static boolean isAnonymous(HttpServletRequest request) {\n+\t\tString userIdRequestParameter = request.getParameter(AuthorizationConstants.USER_ID_PARAM);\n+\t\treturn userIdRequestParameter == null ||\n+\t\t\t\tAuthorizationConstants.BOOTSTRAP_PRINCIPAL.ANONYMOUS_USER.getPrincipalId()\n+\t\t\t\t\t.equals(Long.parseLong(userIdRequestParameter));\n+\t}\n+\n+\t@Override\n+\tpublic boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler)\n+\t\t\tthrows Exception {\n+\t\t\n+\t\t// anonymous requests do not need to have scope checked, they have the same \n+\t\t// access that unauthenticated requests have\n+\t\tif (isAnonymous(request)) {\n+\t\t\treturn true;\n+\t\t}\n+\t\t\n+\t\tSet<String> missingScopes = new TreeSet<String>();\n+\t\t{\n+\t\t\t// if no scopes are specified by an annotation on the method, then we use these defaults\n+\t\t\tSet<OAuthScope> requiredScopes = new TreeSet<OAuthScope>(DEFAULT_SCOPES);\n+\t\t\t\n+\t\t\tif (!(handler instanceof HandlerMethod)) {\n+\t\t\t\tthrow new IllegalStateException(\"Ths HandlerInterceptor should only be applied to HandlerMethods, but this handler is a \"+handler.getClass());\n+\t\t\t}\n+\t\t\t\n+\t\t\tHandlerMethod handlerMethod = (HandlerMethod) handler;\n+\n+\t\t\t// if no 'userId' parameter or access token header then this is \n+\t\t\t// not an authenticated request, and no scope is required\n+\t\t\tif (!hasUserIdParameterOrAccessTokenHeader(handlerMethod)) {\n+\t\t\t\treturn true;\n+\t\t\t}\n+\n+\t\t\tRequiredScope requiredScopeAnnotation = handlerMethod.getMethodAnnotation(RequiredScope.class);\n+\t\t\tif (requiredScopeAnnotation != null) {\n+\t\t\t\trequiredScopes = new HashSet<OAuthScope>(Arrays.asList(requiredScopeAnnotation.value()));\n+\t\t\t}\n+\n+\t\t\tList<OAuthScope> requestScopes = Collections.EMPTY_LIST;\n+\t\t\tString synapseAuthorizationHeader = request.getHeader(SYNAPSE_AUTHORIZATION_HEADER_NAME);\n+\t\t\tString accessToken = HttpAuthUtil.getBearerTokenFromAuthorizationHeader(synapseAuthorizationHeader);\n+\t\t\tif (accessToken!=null) {\n+\t\t\t\tJwt<JwsHeader, Claims> jwt = oidcTokenHelper.parseJWT(accessToken);\n+\t\t\t\trequestScopes = ClaimsJsonUtil.getScopeFromClaims(jwt.getBody());\n+\t\t\t}\n+\n+\t\t\trequiredScopes.removeAll(requestScopes);\n+\t\t\tfor (OAuthScope scope: requiredScopes) {\n+\t\t\t\tmissingScopes.add(scope.name());\n+\t\t\t}\n+\t\t}\n+\n+\t\tif (missingScopes.isEmpty()) {\n+\t\t\treturn true;\n+\t\t}\n+\t\t\n+\t\tStringBuilder sb = new StringBuilder(ERROR_MESSAGE_PREFIX);\n+\t\tboolean first = true;\n+\t\tfor (String missingScope : missingScopes) {\n+\t\t\tif (first) first=false; else sb.append(\", \");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "56e69b637c8277cfd24afcd58c21a8ca739d8959"}, "originalPosition": 128}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU0ODI0ODA5OnYy", "diffSide": "RIGHT", "path": "services/repository/src/main/java/org/sagebionetworks/repo/web/controller/RequiredScope.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xN1QxOToyODoyNFrOGHad8Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xN1QxOToyODoyNFrOGHad8Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDQyNjg2NQ==", "bodyText": "We can add some documentation to the annotation", "url": "https://github.com/Sage-Bionetworks/Synapse-Repository-Services/pull/4006#discussion_r410426865", "createdAt": "2020-04-17T19:28:24Z", "author": {"login": "marcomarasca"}, "path": "services/repository/src/main/java/org/sagebionetworks/repo/web/controller/RequiredScope.java", "diffHunk": "@@ -0,0 +1,15 @@\n+package org.sagebionetworks.repo.web.controller;\n+\n+import static java.lang.annotation.ElementType.METHOD;\n+import static java.lang.annotation.RetentionPolicy.RUNTIME;\n+\n+import java.lang.annotation.Retention;\n+import java.lang.annotation.Target;\n+\n+import org.sagebionetworks.repo.model.oauth.OAuthScope;\n+\n+@Retention(RUNTIME)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "56e69b637c8277cfd24afcd58c21a8ca739d8959"}, "originalPosition": 11}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU0ODI5OTk1OnYy", "diffSide": "RIGHT", "path": "services/repository/src/test/java/org/sagebionetworks/repo/web/OAuthScopeInterceptorTest.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xN1QxOTo0Njo1MVrOGHa_Ag==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xN1QxOTo0Njo1MVrOGHa_Ag==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDQzNTMzMA==", "bodyText": "Add test for the invalid token case, see the interceptor comment", "url": "https://github.com/Sage-Bionetworks/Synapse-Repository-Services/pull/4006#discussion_r410435330", "createdAt": "2020-04-17T19:46:51Z", "author": {"login": "marcomarasca"}, "path": "services/repository/src/test/java/org/sagebionetworks/repo/web/OAuthScopeInterceptorTest.java", "diffHunk": "@@ -0,0 +1,285 @@\n+package org.sagebionetworks.repo.web;\n+\n+import static org.junit.jupiter.api.Assertions.*;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.ArgumentMatchers.anyString;\n+import static org.mockito.Mockito.never;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.when;\n+import static org.sagebionetworks.repo.model.AuthorizationConstants.SYNAPSE_AUTHORIZATION_HEADER_NAME;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.io.OutputStream;\n+import java.io.PrintWriter;\n+import java.lang.annotation.Annotation;\n+import java.util.Arrays;\n+import java.util.Collections;\n+\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.extension.ExtendWith;\n+import org.mockito.InjectMocks;\n+import org.mockito.Mock;\n+import org.mockito.junit.jupiter.MockitoExtension;\n+import org.sagebionetworks.repo.manager.oauth.ClaimsJsonUtil;\n+import org.sagebionetworks.repo.manager.oauth.OIDCTokenHelper;\n+import org.sagebionetworks.repo.model.AuthorizationConstants;\n+import org.sagebionetworks.repo.model.oauth.OAuthScope;\n+import org.sagebionetworks.repo.web.controller.RequiredScope;\n+import org.springframework.core.MethodParameter;\n+import org.springframework.web.bind.annotation.RequestHeader;\n+import org.springframework.web.bind.annotation.RequestParam;\n+import org.springframework.web.method.HandlerMethod;\n+\n+import io.jsonwebtoken.Claims;\n+import io.jsonwebtoken.JwsHeader;\n+import io.jsonwebtoken.Jwt;\n+import io.jsonwebtoken.impl.DefaultClaims;\n+\n+@ExtendWith(MockitoExtension.class)\n+class OAuthScopeInterceptorTest {\n+\n+\t@Mock\n+\tprivate OIDCTokenHelper mockOidcTokenHelper;\n+\n+\t@InjectMocks\n+\tprivate OAuthScopeInterceptor oauthScopeInterceptor;\n+\t\n+\t@Mock\n+\tprivate HttpServletRequest mockRequest; \n+\t\n+\t@Mock\n+\tprivate HttpServletResponse mockResponse; \n+\t\n+\t@Mock\n+\tprivate HandlerMethod mockHandler;\n+\t\n+\t@Mock\n+\tprivate MethodParameter mockUserIdParameter;\n+\t\n+\t@Mock\n+\tprivate MethodParameter mockAccessTokenHeader;\n+\t\n+\t@Mock\n+\tprivate Jwt<JwsHeader, Claims> mockJwt;\n+\t\n+\t@Mock\n+\tprivate RequestParam mockRequestParam;\n+\t\n+\t@Mock\n+\tprivate RequestHeader mockRequestHeader;\n+\t\n+\tprivate static final String USER_ID = \"100001\";\n+\tprivate static final String ACCESS_TOKEN = \"access-token\";\n+\t\n+\tprivate static RequiredScope createRequiredScopeAnnotation(final OAuthScope[] scopes) {\n+\t\treturn new RequiredScope() {\n+\t\t\t@Override\n+\t\t\tpublic Class<? extends Annotation> annotationType() {return RequiredScope.class;}\n+\t\t\t@Override\n+\t\t\tpublic OAuthScope[] value() {return scopes;}\n+\t\t};\n+\t}\n+\t\n+\tprivate static Claims createClaimsForScope(final OAuthScope[] scopes) {\n+\t\tDefaultClaims result = new DefaultClaims();\n+\t\tClaimsJsonUtil.addAccessClaims( Arrays.asList(scopes), \n+\t\t\t\tCollections.EMPTY_MAP, result);\n+\t\treturn result;\n+\t}\n+\t\n+\t@BeforeEach\n+\tvoid before() {\n+\t}\n+\t\n+\t// mock an annotated method with a userId parameter\n+\tprivate void mockRequiredScopeAnnotation() {\n+\t\tRequiredScope requiredScopeAnnotation = createRequiredScopeAnnotation(OAuthScope.values());\n+\t\twhen(mockHandler.getMethodAnnotation(RequiredScope.class)).thenReturn(requiredScopeAnnotation);\n+\t}\n+\t\t\n+\tprivate void mockRequestIdParam() {\n+\t\twhen(mockRequestParam.value()).thenReturn( AuthorizationConstants.USER_ID_PARAM);\n+\t\twhen(mockHandler.getMethodParameters()).thenReturn(new MethodParameter[] {mockUserIdParameter});\n+\t\twhen(mockUserIdParameter.getParameterAnnotation(RequestParam.class)).thenReturn(mockRequestParam);\n+\t}\n+\t\n+\tprivate void mockRequest(String userId, String accessToken) {\n+\t\tif (accessToken!=null) {\n+\t\t\twhen(mockRequest.getHeader(SYNAPSE_AUTHORIZATION_HEADER_NAME)).thenReturn(\"Bearer \"+accessToken);\n+\t\t}\n+\t\twhen(mockRequest.getParameter(AuthorizationConstants.USER_ID_PARAM)).thenReturn(userId); \t\n+\t}\n+\t\n+\tprivate void mockAccessToken(OAuthScope[] scopes) {\n+\t\twhen(mockOidcTokenHelper.parseJWT(ACCESS_TOKEN)).thenReturn(mockJwt);\n+\t\twhen(mockJwt.getBody()).thenReturn(createClaimsForScope(scopes));\t\t\n+\t}\n+\t\n+\tprivate OutputStream mockResponse() throws IOException {\n+\t\tByteArrayOutputStream os = new ByteArrayOutputStream();\n+\t\twhen(mockResponse.getWriter()).thenReturn(new PrintWriter(os));\n+\t\treturn os;\n+\t}\n+\t\n+\t@Test\n+\tvoid testHasUserIdParameterOrAccessTokenHeader_withUserId() {\n+\t\twhen(mockHandler.getMethodParameters()).thenReturn(new MethodParameter[] {mockUserIdParameter});\n+\t\twhen(mockUserIdParameter.getParameterAnnotation(RequestParam.class)).thenReturn(mockRequestParam);\n+\t\twhen(mockRequestParam.value()).thenReturn( AuthorizationConstants.USER_ID_PARAM);\n+\n+\t\t// method under test\n+\t\tassertTrue(OAuthScopeInterceptor.hasUserIdParameterOrAccessTokenHeader(mockHandler));\n+\t}\n+\t\n+\t@Test\n+\tvoid testHasUserIdParameterOrAccessTokenHeader_withAccessToken() {\n+\t\twhen(mockHandler.getMethodParameters()).thenReturn(new MethodParameter[] {mockAccessTokenHeader});\n+\t\twhen(mockAccessTokenHeader.getParameterAnnotation(RequestParam.class)).thenReturn(null);\n+\t\twhen(mockAccessTokenHeader.getParameterAnnotation(RequestHeader.class)).thenReturn(mockRequestHeader);\n+\t\twhen(mockRequestHeader.value()).thenReturn( AuthorizationConstants.SYNAPSE_AUTHORIZATION_HEADER_NAME);\n+\n+\t\t// method under test\n+\t\tassertTrue(OAuthScopeInterceptor.hasUserIdParameterOrAccessTokenHeader(mockHandler));\n+\t}\n+\t\n+\t@Test\n+\tvoid testHasUserIdParameterOrAccessTokenHeader_Nothing() {\n+\t\twhen(mockHandler.getMethodParameters()).thenReturn(new MethodParameter[] {});\n+\t\t// method under test\n+\t\tassertFalse(OAuthScopeInterceptor.hasUserIdParameterOrAccessTokenHeader(mockHandler));\n+\t}\n+\t\n+\t@Test\n+\tvoid testIsAnonymous_anonymousId() {\n+\t\twhen(mockRequest.getParameter(AuthorizationConstants.USER_ID_PARAM)).\n+\t\t\tthenReturn(AuthorizationConstants.BOOTSTRAP_PRINCIPAL.ANONYMOUS_USER.getPrincipalId().toString());\n+\t\tassertTrue(OAuthScopeInterceptor.isAnonymous(mockRequest));\n+\t}\n+\t\n+\t@Test\n+\tvoid testIsAnonymous_missingId() {\n+\t\tassertTrue(OAuthScopeInterceptor.isAnonymous(mockRequest));\n+\t}\n+\t\n+\t@Test\n+\tvoid testIsAnonymous_NOT_anonymous() {\n+\t\twhen(mockRequest.getParameter(AuthorizationConstants.USER_ID_PARAM)).thenReturn(\"123\");\n+\t\tassertFalse(OAuthScopeInterceptor.isAnonymous(mockRequest));\n+\t}\n+\t\n+\t@Test\n+\tvoid testPrehandleAnonymous() throws Exception {\n+\t\tmockRequest(AuthorizationConstants.BOOTSTRAP_PRINCIPAL.ANONYMOUS_USER.getPrincipalId().toString(), null);// anonymous, no access token\n+\t\t\n+\t\t// method under test\n+\t\tboolean result = oauthScopeInterceptor.preHandle(mockRequest, mockResponse, mockHandler);\n+\t\t\n+\t\tassertTrue(result);\n+\t\t\n+\t\tverify(mockRequest, never()).getHeader(anyString());\n+\t\tverify(mockHandler, never()).getMethodAnnotation(any());\n+\t}\n+\n+\t@Test\n+\tvoid testPrehandleAnonymous_handlerWrongType() throws Exception {\n+\t\tmockRequest(\"123\", null);// NOT anonymous\n+\t\t\n+\t\t// method under test\n+\t\tassertThrows(IllegalStateException.class, \n+\t\t\t\t() -> {oauthScopeInterceptor.preHandle(mockRequest, mockResponse, String.class);\n+\t\t});\n+\n+\t}\n+\n+\t@Test\n+\tvoid testPrehandleNoUserIdORAccessTokenParameter() throws Exception {\n+\t\tmockRequest(null, null);// anonymous, no access token\n+\n+\t\t// method under test\n+\t\tboolean result = oauthScopeInterceptor.preHandle(mockRequest, mockResponse, mockHandler);\n+\t\t\n+\t\tassertTrue(result);\n+\t}\n+\n+\t@Test\n+\tvoid testPrehandleHappyCase() throws Exception {\n+\t\tmockRequiredScopeAnnotation();\n+\t\tmockRequestIdParam();\n+\t\tmockRequest(USER_ID, ACCESS_TOKEN);// NOT anonymous\t\n+\t\tmockAccessToken(OAuthScope.values());\n+\t\t\n+\t\t// method under test\n+\t\tboolean result = oauthScopeInterceptor.preHandle(mockRequest, mockResponse, mockHandler);\n+\t\t\n+\t\tassertTrue(result);\n+\t\t\n+\t\tverify(mockHandler).getMethodAnnotation(RequiredScope.class);\n+\t\tverify(mockRequest).getHeader(SYNAPSE_AUTHORIZATION_HEADER_NAME);\n+\t\tverify(mockOidcTokenHelper).parseJWT(ACCESS_TOKEN);\n+\t}\n+\n+\t@Test\n+\tvoid testPrehandleNoScopeAnnotation() throws Exception {\n+\t\twhen(mockHandler.getMethodAnnotation(RequiredScope.class)).thenReturn(null);\n+\t\tmockRequestIdParam();\n+\t\tmockRequest(USER_ID, ACCESS_TOKEN);// NOT anonymous\t\n+\t\tmockAccessToken(OAuthScope.values());\n+\t\t\n+\t\t// method under test\n+\t\tboolean result = oauthScopeInterceptor.preHandle(mockRequest, mockResponse, mockHandler);\n+\t\t\n+\t\tassertTrue(result);\n+\t\t\n+\t\tverify(mockHandler).getMethodAnnotation(RequiredScope.class);\n+\t\tverify(mockRequest).getHeader(SYNAPSE_AUTHORIZATION_HEADER_NAME);\n+\t\tverify(mockOidcTokenHelper).parseJWT(ACCESS_TOKEN);\n+\t}\n+\n+\t@Test\n+\tvoid testPrehandleInsufficentScope() throws Exception {\n+\t\tmockRequiredScopeAnnotation();\n+\t\tmockRequestIdParam();\n+\t\t\n+\t\tmockRequest(USER_ID, ACCESS_TOKEN);// NOT anonymous\t\n+\t\tmockAccessToken(new OAuthScope[] {OAuthScope.view});\n+\t\tOutputStream os = mockResponse();\n+\t\t\n+\t\t// method under test\n+\t\tboolean result = oauthScopeInterceptor.preHandle(mockRequest, mockResponse, mockHandler);\n+\t\t\n+\t\tassertFalse(result);\n+\t\t\n+\t\tverify(mockRequest).getHeader(SYNAPSE_AUTHORIZATION_HEADER_NAME);\n+\n+\t\tassertEquals(\"{\\\"reason\\\":\\\"Request lacks scope(s) required by this service: download, modify, openid\\\"}\\n\", os.toString());\n+\t\t\n+\t}\n+\n+\t@Test\n+\tvoid testPrehandleNoAccessToken() throws Exception {\n+\t\tmockRequiredScopeAnnotation();\n+\t\tmockRequestIdParam();\n+\t\t\n+\t\tmockRequest(USER_ID, null);// NOT anonymous, no access token\n+\t\tOutputStream os = mockResponse();\n+\t\t\n+\t\t// method under test\n+\t\tboolean result = oauthScopeInterceptor.preHandle(mockRequest, mockResponse, mockHandler);\n+\t\t\n+\t\tassertFalse(result);\n+\n+\t\tassertEquals(\"{\\\"reason\\\":\\\"Request lacks scope(s) required by this service: download, modify, openid, view\\\"}\\n\",  os.toString());\n+\t\t\n+\t\tverify(mockRequest).getHeader(SYNAPSE_AUTHORIZATION_HEADER_NAME);\n+\t\tverify(mockOidcTokenHelper, never()).parseJWT(anyString());\n+\t\tverify(mockHandler).getMethodAnnotation(RequiredScope.class);\n+\t}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "56e69b637c8277cfd24afcd58c21a8ca739d8959"}, "originalPosition": 283}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3181, "cost": 1, "resetAt": "2021-11-12T12:57:47Z"}}}