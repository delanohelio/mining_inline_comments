{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDQwMzEwMjU3", "number": 4111, "reviewThreads": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNlQyMzoxODozM1rOEJShOA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNlQyMzoxODozM1rOEJShOA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc4MTc2MDU2OnYy", "diffSide": "RIGHT", "path": "lib/lib-table-cluster/src/test/java/org/sagebionetworks/table/cluster/TableIndexDAOImplTest.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNlQyMzoxODozM1rOGpxElA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNlQyMzoxODozM1rOGpxElA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjQ0ODc4OA==", "bodyText": "test with batch of objects with different ids.", "url": "https://github.com/Sage-Bionetworks/Synapse-Repository-Services/pull/4111#discussion_r446448788", "createdAt": "2020-06-26T23:18:33Z", "author": {"login": "john-hill"}, "path": "lib/lib-table-cluster/src/test/java/org/sagebionetworks/table/cluster/TableIndexDAOImplTest.java", "diffHunk": "@@ -1347,6 +1347,57 @@ public void testEntityReplication(){\n \t\tfetched = tableIndexDAO.getObjectData(objectType, 3L);\r\n \t\tassertEquals(file, fetched);\r\n \t}\r\n+\t\r\n+\t/**\r\n+\t * Test for PLFM-6306: The index failed to replicate because the insert was not handling duplicates. When replicating\r\n+\t * we first delete and then insert but with concurrent inserts and with no data it could lead to a race condition where\r\n+\t * a second thread that wasn't blocked by the first delete (since nothing needed to be deleted) tries to insert the same \r\n+\t * record. The solution is to allow updating on duplicate.\r\n+\t */\r\n+\t@Test\r\n+\tpublic void testEntityReplicationWithUpdate(){\r\n+\t\t\r\n+\t\tObjectDataDTO objectData = createObjectDataDTO(2L, EntityType.file, 2);\r\n+\t\t\r\n+\t\t// Add the data to the index once\r\n+\t\ttableIndexDAO.addObjectData(objectType, Collections.singletonList(objectData));\r\n+\t\t\r\n+\t\tObjectDataDTO result = tableIndexDAO.getObjectData(ViewObjectType.ENTITY, objectData.getId());\r\n+\t\r\n+\t\tassertEquals(objectData, result);\r\n+\t\t\r\n+\t\t// Update the data\r\n+\t\tobjectData.setEtag(objectData.getEtag() + \"_updated\");\r\n+\t\tobjectData.getAnnotations().get(0).setValue(\"updated_annotation\");\r\n+\t\t\r\n+\t\t// Re-adding to the index should simply update the object without throwing\r\n+\t\ttableIndexDAO.addObjectData(objectType, Collections.singletonList(objectData));\r\n+\t\t\r\n+\t\t// Makes sure the data was updated\r\n+\t\tresult = tableIndexDAO.getObjectData(ViewObjectType.ENTITY, objectData.getId());\r\n+\t\t\r\n+\t\tassertEquals(objectData, result);\r\n+\t}\r\n+\t\r", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0361164fd9f4cbdaa1de3921fd38fcd4f03c18cc"}, "originalPosition": 35}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3100, "cost": 1, "resetAt": "2021-11-12T12:57:47Z"}}}