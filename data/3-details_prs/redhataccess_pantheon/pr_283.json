{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDA4MzM1MjEz", "number": 283, "title": " CCS-3525: Create POC for validation framework", "bodyText": "This PR provides base framework for validations in Pantheon. The framework supports\n\n\nSynchronous validation where client instantiates the validators and calls the validation methods themselves.\n\n\nAsynchronous validation using Events (Sling Jobs) and Observer/Listener pattern. In this case, the client instantiates the validators needed and pass it on as event payload. Then, the client can register a listener for validation complete event. Once the validators are executed, the assimilated results are passed on to the client via the registered listeners.\n\n\nThe validators themselves extend Validator interface. How the data is passed and what logic has to be applied is left to the individual validator.\nIn this PR, StatusAcknowledgementServlet acts as client and NotNullValidator is the sample validator. StatusAcknowledgementServlet has example of both synchronous as well asynchronous  validations.\nThe following sequence diagrams depict how both kinds of Validations work (for brevity StatusAcknowledgementServlet has been depicted as AcknowledgementServlet):", "createdAt": "2020-04-24T05:16:08Z", "url": "https://github.com/redhataccess/pantheon/pull/283", "merged": true, "mergeCommit": {"oid": "1db0cc9cc6f716d2b15adc32ae848746d51b38e1"}, "closed": true, "closedAt": "2020-04-30T13:53:33Z", "author": {"login": "aprajshekhar"}, "timelineItems": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcaqIOzgH2gAyNDA4MzM1MjEzOjQxZGRkNjg3YTg4Y2IyMTNlM2QwMmI1MTA1MTA3ODI5Njc3YmVjMzM=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcctIGMAFqTQwMzUyMDUxMQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "41ddd687a88cb213e3d02b5105107829677bec33", "author": {"user": {"login": "aprajshekhar", "name": "A.P.Rajshekhar"}}, "url": "https://github.com/redhataccess/pantheon/commit/41ddd687a88cb213e3d02b5105107829677bec33", "committedDate": "2020-04-24T04:53:07Z", "message": " CCS-3525: Create POC for validation framework"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDAxMjg1Mjg3", "url": "https://github.com/redhataccess/pantheon/pull/283#pullrequestreview-401285287", "createdAt": "2020-04-27T20:05:03Z", "commit": {"oid": "41ddd687a88cb213e3d02b5105107829677bec33"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yN1QyMDowNTowM1rOGM1aVg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yN1QyMTowMzoxNlrOGM3lpQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjExMTE5MA==", "bodyText": "Can you please let me know why we need these additional imports?", "url": "https://github.com/redhataccess/pantheon/pull/283#discussion_r416111190", "createdAt": "2020-04-27T20:05:03Z", "author": {"login": "benradey"}, "path": "pantheon-bundle/pom.xml", "diffHunk": "@@ -82,6 +82,8 @@\n                             !org.apache.tools.ant,!org.joda.convert,!org.objectweb.asm,!sun.misc,\n                             !javax.ejb,\n                             !javax.jmdns,\n+                            !com.google.appengine.api,\n+                            !com.google.apphosting.api,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "41ddd687a88cb213e3d02b5105107829677bec33"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjEyNzYyNw==", "bodyText": "To be clear, it's not necessary to call eventBasedValidation as part of this method, correct? I think what you're trying to do is give an example of both the sync and async scenarios, and this \"just happens\" to be a convenient place to invoke the async portion. It has nothing to do with being inside of the sync portion. Let me know if I'm wrong.", "url": "https://github.com/redhataccess/pantheon/pull/283#discussion_r416127627", "createdAt": "2020-04-27T20:31:45Z", "author": {"login": "benradey"}, "path": "pantheon-bundle/src/main/java/com/redhat/pantheon/servlet/StatusAcknowledgeServlet.java", "diffHunk": "@@ -55,55 +69,82 @@ public StatusAcknowledgeServlet() {\n     @Override\n     protected void processPost(SlingHttpServletRequest request, SlingHttpServletResponse response, Acknowledgment acknowledgment)\n             throws ServletException, IOException {\n-        if(isObjectNullOrEmpty(acknowledgment)){\n-            getLogger().error(\"The request did not provide all the fiields \"+acknowledgment.toString());\n+        if (isObjectNullOrEmpty(acknowledgment)) {\n+            getLogger().error(\"The request did not provide all the fiields \" + acknowledgment.toString());\n             response.sendError(HttpServletResponse.SC_BAD_REQUEST, \"All the fields are required\");\n             return;\n         }\n         try {\n             Resource resource = getResourceByUuid(acknowledgment.getId(), request);\n-            Module module =  resource.adaptTo(Module.class);\n-            List<Resource> moduleLocale =  $(module).find(\"pant:moduleLocale\").asList();\n+            Module module = resource.adaptTo(Module.class);\n+            List<Resource> moduleLocale = $(module).find(\"pant:moduleLocale\").asList();\n \n-            if(!hasLocale(moduleLocale, \"en_US\")){\n-                getLogger().error(\"The module with id=\"+acknowledgment.getId()+\" does not have en_US locale\");\n+            if (!hasLocale(moduleLocale, \"en_US\")) {\n+                getLogger().error(\"The module with id=\" + acknowledgment.getId() + \" does not have en_US locale\");\n                 response.sendError(HttpServletResponse.SC_BAD_REQUEST, \"Locale other than en_US is not supported\");\n                 return;\n             }\n             processAcknowledgementRequest(acknowledgment, module, moduleLocale, request.getUserPrincipal().getName());\n \n-        } catch (RepositoryException|PersistenceException e) {\n-            getLogger().error(\"The request could not be processed because of error=\"+e.getMessage(), e);\n+        } catch (RepositoryException | PersistenceException e) {\n+            getLogger().error(\"The request could not be processed because of error=\" + e.getMessage(), e);\n             response.sendError(HttpServletResponse.SC_INTERNAL_SERVER_ERROR, e.getMessage());\n         }\n     }\n \n     /**\n-     *  Checks whether all the fields are present\n+     * Checks whether all the fields are present\n+     *\n      * @param acknowledgement the acknowledement object containing request data\n      * @return true if not all fields have data else return false\n      */\n     private boolean isObjectNullOrEmpty(Acknowledgment acknowledgement) {\n-        return null == acknowledgement ||\n-                Stream.of(acknowledgement.getId(), acknowledgement.getMessage(),\n-                        acknowledgement.getSender(),acknowledgement.getStatus())\n-                        .anyMatch(Objects::isNull);\n+        return null == acknowledgement || validate(acknowledgement);\n+\n+    }\n+\n+    private boolean validate(Acknowledgment acknowledgement) {\n+        //how the data is passed to validator is left to the implementing class. In the case of sample NotNullValidator\n+        //data is passed via setter\n+        getNotNullValidator().setObjectsToValidate(Stream.of(acknowledgement.getId(), acknowledgement.getMessage(),\n+                acknowledgement.getSender(), acknowledgement.getStatus())\n+                .collect(Collectors.toList()));\n+        //using event for the same\n+        eventBasedValidation(acknowledgement);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "41ddd687a88cb213e3d02b5105107829677bec33"}, "originalPosition": 145}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjEzMTMzMw==", "bodyText": "Not really sure where to put this comment, but overall I have conflicting thoughts about this code appearing here.\nOn one hand, I like the idea of having sync vs async options. It enables the use case of \"validation needs to happen as part of this servlet, because the caller needs to know whether to try again\" as well as \"validation can happen later, because maybe we're doing a bulk upload and let's try to do things fast.\"\nOn the other hand, I'm not a fan of the servlet needing to know about the specific validators that it needs to run (in this case, the servlet has its reference to NotNullValidator). I would rather see something along these lines:\nvalidation.fireEvent(Event.STATUS_UPDATE, Style.SYNC, \"/path/to/acknowledgement/node\")\nThat way, the servlet is blissfully ignorant of the validators that are actually running. The validators themselves can decide what events to pay attention to, and what fields on the relevant object (or related objects) are worth paying attention to.", "url": "https://github.com/redhataccess/pantheon/pull/283#discussion_r416131333", "createdAt": "2020-04-27T20:38:14Z", "author": {"login": "benradey"}, "path": "pantheon-bundle/src/main/java/com/redhat/pantheon/servlet/StatusAcknowledgeServlet.java", "diffHunk": "@@ -55,55 +69,82 @@ public StatusAcknowledgeServlet() {\n     @Override\n     protected void processPost(SlingHttpServletRequest request, SlingHttpServletResponse response, Acknowledgment acknowledgment)\n             throws ServletException, IOException {\n-        if(isObjectNullOrEmpty(acknowledgment)){\n-            getLogger().error(\"The request did not provide all the fiields \"+acknowledgment.toString());\n+        if (isObjectNullOrEmpty(acknowledgment)) {\n+            getLogger().error(\"The request did not provide all the fiields \" + acknowledgment.toString());\n             response.sendError(HttpServletResponse.SC_BAD_REQUEST, \"All the fields are required\");\n             return;\n         }\n         try {\n             Resource resource = getResourceByUuid(acknowledgment.getId(), request);\n-            Module module =  resource.adaptTo(Module.class);\n-            List<Resource> moduleLocale =  $(module).find(\"pant:moduleLocale\").asList();\n+            Module module = resource.adaptTo(Module.class);\n+            List<Resource> moduleLocale = $(module).find(\"pant:moduleLocale\").asList();\n \n-            if(!hasLocale(moduleLocale, \"en_US\")){\n-                getLogger().error(\"The module with id=\"+acknowledgment.getId()+\" does not have en_US locale\");\n+            if (!hasLocale(moduleLocale, \"en_US\")) {\n+                getLogger().error(\"The module with id=\" + acknowledgment.getId() + \" does not have en_US locale\");\n                 response.sendError(HttpServletResponse.SC_BAD_REQUEST, \"Locale other than en_US is not supported\");\n                 return;\n             }\n             processAcknowledgementRequest(acknowledgment, module, moduleLocale, request.getUserPrincipal().getName());\n \n-        } catch (RepositoryException|PersistenceException e) {\n-            getLogger().error(\"The request could not be processed because of error=\"+e.getMessage(), e);\n+        } catch (RepositoryException | PersistenceException e) {\n+            getLogger().error(\"The request could not be processed because of error=\" + e.getMessage(), e);\n             response.sendError(HttpServletResponse.SC_INTERNAL_SERVER_ERROR, e.getMessage());\n         }\n     }\n \n     /**\n-     *  Checks whether all the fields are present\n+     * Checks whether all the fields are present\n+     *\n      * @param acknowledgement the acknowledement object containing request data\n      * @return true if not all fields have data else return false\n      */\n     private boolean isObjectNullOrEmpty(Acknowledgment acknowledgement) {\n-        return null == acknowledgement ||\n-                Stream.of(acknowledgement.getId(), acknowledgement.getMessage(),\n-                        acknowledgement.getSender(),acknowledgement.getStatus())\n-                        .anyMatch(Objects::isNull);\n+        return null == acknowledgement || validate(acknowledgement);\n+\n+    }\n+\n+    private boolean validate(Acknowledgment acknowledgement) {\n+        //how the data is passed to validator is left to the implementing class. In the case of sample NotNullValidator\n+        //data is passed via setter\n+        getNotNullValidator().setObjectsToValidate(Stream.of(acknowledgement.getId(), acknowledgement.getMessage(),\n+                acknowledgement.getSender(), acknowledgement.getStatus())\n+                .collect(Collectors.toList()));\n+        //using event for the same\n+        eventBasedValidation(acknowledgement);\n+        return getNotNullValidator().validate().hasViolations();\n+    }\n+\n+    private void eventBasedValidation(Acknowledgment acknowledgement) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "41ddd687a88cb213e3d02b5105107829677bec33"}, "originalPosition": 149}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjEzNDcwOA==", "bodyText": "This syntax seems odd, what are you trying to accomplish here? Is the Set extracted from a ConcurrentHashMap somehow special?", "url": "https://github.com/redhataccess/pantheon/pull/283#discussion_r416134708", "createdAt": "2020-04-27T20:43:58Z", "author": {"login": "benradey"}, "path": "pantheon-bundle/src/main/java/com/redhat/pantheon/validation/events/ValidationsCompleteNotifierService.java", "diffHunk": "@@ -0,0 +1,60 @@\n+package com.redhat.pantheon.validation.events;\n+\n+import com.redhat.pantheon.validation.model.CombinedViolations;\n+import org.osgi.service.component.annotations.Activate;\n+import org.osgi.service.component.annotations.Component;\n+import org.osgi.service.component.annotations.ServiceScope;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+/**\n+ * The service that keeps track of all the listeners for validations completed event\n+ *\n+ * @author A.P. Rajshekhar\n+ */\n+@Component(service = ValidationsCompleteNotifierService.class,\n+scope = ServiceScope.SINGLETON)\n+public class ValidationsCompleteNotifierService {\n+    private final Set<ValidationsCompleteListener> listeners;\n+\n+    /**\n+     * Initialize the list that holds all the registered listeners\n+     */\n+    @Activate\n+    public ValidationsCompleteNotifierService(){\n+        listeners = Collections.newSetFromMap(\n+                new ConcurrentHashMap<ValidationsCompleteListener, Boolean>(0));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "41ddd687a88cb213e3d02b5105107829677bec33"}, "originalPosition": 30}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjEzNTc0Mg==", "bodyText": "Wondering about the singleton scope here... if we have multiple validations happening for multiple objects in parallel (i.e., asynchronous validation during a bulk upload), will the singleton scope cause all the validation results to accidentally mix together somehow?", "url": "https://github.com/redhataccess/pantheon/pull/283#discussion_r416135742", "createdAt": "2020-04-27T20:45:43Z", "author": {"login": "benradey"}, "path": "pantheon-bundle/src/main/java/com/redhat/pantheon/validation/events/ValidationsCompleteNotifierService.java", "diffHunk": "@@ -0,0 +1,60 @@\n+package com.redhat.pantheon.validation.events;\n+\n+import com.redhat.pantheon.validation.model.CombinedViolations;\n+import org.osgi.service.component.annotations.Activate;\n+import org.osgi.service.component.annotations.Component;\n+import org.osgi.service.component.annotations.ServiceScope;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+/**\n+ * The service that keeps track of all the listeners for validations completed event\n+ *\n+ * @author A.P. Rajshekhar\n+ */\n+@Component(service = ValidationsCompleteNotifierService.class,\n+scope = ServiceScope.SINGLETON)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "41ddd687a88cb213e3d02b5105107829677bec33"}, "originalPosition": 20}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjE0MjU0NQ==", "bodyText": "I think I understand what this method is doing - it's checking \"has this validator been requested to run\" - which kind of makes sense, but what supplies list of requested validators? Ultimately, the servlet did. I want to mention again that the servlet should be ignorant of what validators run. I think if we really want a fine level of control over which validators run in different scenarios, then we should achieve that by proliferating the number of events that we fire and that validators can choose to respond to.\nMaybe we have a \"status update\" event, another one for \"new module upload,\" another for \"module updated,\" maybe one for \"user-initiated manual validation request,\" stuff like that. Hell, we could even have periodic events - \"hourly,\" \"nightly,\" \"monthly,\" etc. The validators to respond to one, some, or all of them. Then it's just up to the system to emit the right events at the right times.", "url": "https://github.com/redhataccess/pantheon/pull/283#discussion_r416142545", "createdAt": "2020-04-27T20:56:29Z", "author": {"login": "benradey"}, "path": "pantheon-bundle/src/main/java/com/redhat/pantheon/validation/events/ValidionTriggerProcessor.java", "diffHunk": "@@ -0,0 +1,80 @@\n+package com.redhat.pantheon.validation.events;\n+\n+import com.redhat.pantheon.extension.Event;\n+import com.redhat.pantheon.extension.EventProcessingExtension;\n+import com.redhat.pantheon.validation.model.CombinedViolations;\n+import com.redhat.pantheon.validation.model.ValidationClientDetails;\n+import com.redhat.pantheon.validation.validators.Validator;\n+import org.osgi.service.component.annotations.Activate;\n+import org.osgi.service.component.annotations.Component;\n+import org.osgi.service.component.annotations.Reference;\n+\n+import java.util.List;\n+\n+/**\n+ * The event processor for  {@see ValidationTrigger}.\n+ * <p>\n+ *     The payload of the event would have one or more validators' names. The processor\n+ *     would execute each of the validators by getting the validators from Selected validator service\n+ *     and add the validator result against each\n+ *     validator. Once all the validators are executed, the processor notifies all the\n+ *     listeners waiting for validation to be completed and pass the accumulated\n+ *     result.\n+ * </p>\n+ */\n+@Component(\n+        service = EventProcessingExtension.class\n+)\n+public class ValidionTriggerProcessor implements EventProcessingExtension {\n+\n+    private ValidationsCompleteNotifierService validationsCompleteNotifierService;\n+    @Reference\n+    private SelectedValidationsService selectedValidationsService;\n+    /**\n+     * Instantiates a new Validion event processor by injecting the notifier service\n+     *\n+     * @param validationsCompleteNotifierService the notifier service to be invoked\n+     *                                          when all the validators in the event payload are executed\n+     */\n+    @Activate\n+    public ValidionTriggerProcessor(\n+            @Reference ValidationsCompleteNotifierService validationsCompleteNotifierService){\n+        this.validationsCompleteNotifierService = validationsCompleteNotifierService;\n+    }\n+\n+    @Override\n+    public boolean canProcessEvent(Event event) {\n+        return true;\n+    }\n+\n+    @Override\n+    public void processEvent(Event event) throws Exception {\n+        ValidationTrigger validationTriggerEvent = (ValidationTrigger) event;\n+        processValidation(validationTriggerEvent.getNames(), validationTriggerEvent.getComponent(), new CombinedViolations());\n+    }\n+\n+    /**\n+     *  Executes all the validators provided in the SelectedValdations and combine all the results. The details of component\n+     *  that has triggered this event is set as a part of the combined result.\n+     *  Once all the  validators are executed, the notifier service is invoked to notify all the listeners that\n+     *   all the validators have been executed\n+     * @param validators the validators to be executed\n+     * @param validationClientDetails\n+     * @param combinedViolations combined result\n+     */\n+    private void processValidation(String validators, String validationClientDetails, CombinedViolations combinedViolations) {\n+        selectedValidationsService.getValidators()\n+                .stream().\n+                filter(validator -> checkValidatorNames(validator, validators))\n+                .forEach(validator -> combinedViolations.add(validator.getName(), validator.validate()));\n+        combinedViolations.setValidationClientDetails(new ValidationClientDetails(validationClientDetails));\n+        this.validationsCompleteNotifierService.notifyValidationsCompleteListeners(combinedViolations);\n+    }\n+\n+    private boolean checkValidatorNames(Validator validator, String validators) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "41ddd687a88cb213e3d02b5105107829677bec33"}, "originalPosition": 74}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjE0Njg1Mw==", "bodyText": "I imagine adding a few more properties (annotations?) here to somehow list what events this validator cares about, sort of like what we already have in SlingModelAdaptorFactory:\n@Component(\n        service = NotNullValidator.class,\n        property = {\n                EVENT_TYPE + \"=com.redhat.pantheon.validation.events.Status_Update\",\n                EVENT_TYPE + \"=com.redhat.pantheon.validation.events.New_Module\",\n                EVENT_TYPE + \"=com.redhat.pantheon.validation.events.Metadata_Changed\"\n        }\n)\n\nI made that up and probably the syntax isn't the best, but something along those lines. I'm hoping you can be the OSGi expert and advise on how best to supply the information here.", "url": "https://github.com/redhataccess/pantheon/pull/283#discussion_r416146853", "createdAt": "2020-04-27T21:03:16Z", "author": {"login": "benradey"}, "path": "pantheon-bundle/src/main/java/com/redhat/pantheon/validation/validators/NotNullValidator.java", "diffHunk": "@@ -0,0 +1,68 @@\n+package com.redhat.pantheon.validation.validators;\n+\n+import com.redhat.pantheon.validation.model.ErrorDetails;\n+import com.redhat.pantheon.validation.model.Violations;\n+import org.osgi.framework.Constants;\n+import org.osgi.service.component.annotations.Component;\n+\n+import java.util.List;\n+import java.util.Objects;\n+\n+/**\n+ *  This is a sample validator that\n+ *  <p>\n+ *      <ol>Provides logic to check passed object is null or not </ol>\n+ *      <ol>Accepts the data via setter when injected</ol>\n+ *      <ol>Accepts the data via constructor instantiated normally</ol>\n+ *      <ol>Returns its unique name via getName()</ol>\n+ *      <ol>Returns the constraint violations via {@see Violations} instance</ol>\n+ *  </p>\n+ */\n+@Component( service = NotNullValidator.class,\n+        property = {\n+            Constants.SERVICE_DESCRIPTION + \"=Provides validation services\",\n+            Constants.SERVICE_VENDOR + \"=Red Hat Content Tooling team\"\n+        }\n+)\n+public class NotNullValidator implements Validator {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "41ddd687a88cb213e3d02b5105107829677bec33"}, "originalPosition": 27}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3f432695b34c575c9d674dfa77305d52d1292cc2", "author": {"user": {"login": "aprajshekhar", "name": "A.P.Rajshekhar"}}, "url": "https://github.com/redhataccess/pantheon/commit/3f432695b34c575c9d674dfa77305d52d1292cc2", "committedDate": "2020-04-28T09:53:47Z", "message": " CCS-3525: Create POC for validation framework. Removing rudimentary integration functionality."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDAzNTIwNTEx", "url": "https://github.com/redhataccess/pantheon/pull/283#pullrequestreview-403520511", "createdAt": "2020-04-30T13:30:32Z", "commit": {"oid": "3f432695b34c575c9d674dfa77305d52d1292cc2"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2111, "cost": 1, "resetAt": "2021-11-01T16:37:27Z"}}}