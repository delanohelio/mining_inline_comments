{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTE1NTYwNzM4", "number": 14827, "title": "Add arhive validation which allows prepended scripts", "bodyText": "Fixes #14826", "createdAt": "2020-11-04T18:19:30Z", "url": "https://github.com/OpenLiberty/open-liberty/pull/14827", "merged": true, "mergeCommit": {"oid": "4ab8e9a6e474879e647f6a2856bc2aa1993066bd"}, "closed": true, "closedAt": "2020-11-09T19:00:30Z", "author": {"login": "jimblye"}, "timelineItems": {"totalCount": 12, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdZR1hHgH2gAyNTE1NTYwNzM4OjU1N2NjNjZjMmM3YmJjYmU4MDNjMjcyNGUxOGFlMjg4YjhiYmMyYzE=", "endCursor": "Y3Vyc29yOnYyOpPPAAABdZ41CAgH2gAyNTE1NTYwNzM4OmJhOGVmMmZmYWQxODgxNjNhMGEyYjdlZjViMzQyOTgwN2I0ZDgwMDk=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "557cc66c2c7bbcbe803c2724e18ae288b8bbc2c1", "author": {"user": {"login": "jimblye", "name": null}}, "url": "https://github.com/OpenLiberty/open-liberty/commit/557cc66c2c7bbcbe803c2724e18ae288b8bbc2c1", "committedDate": "2020-11-04T18:12:11Z", "message": "Add arhive validation which allows prepended scripts"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIzNjc1NDA1", "url": "https://github.com/OpenLiberty/open-liberty/pull/14827#pullrequestreview-523675405", "createdAt": "2020-11-04T19:35:10Z", "commit": {"oid": "557cc66c2c7bbcbe803c2724e18ae288b8bbc2c1"}, "state": "APPROVED", "comments": {"totalCount": 13, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNFQxOTozNToxMVrOHtm18A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNFQxOTo1MjozMlrOHtnZvw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzU4NDM2OA==", "bodyText": "Is this cast to (int) safe?  How is it know that the offset is less than MAX_INT?", "url": "https://github.com/OpenLiberty/open-liberty/pull/14827#discussion_r517584368", "createdAt": "2020-11-04T19:35:11Z", "author": {"login": "tbitonti"}, "path": "dev/com.ibm.ws.artifact.zip/src/com/ibm/ws/artifact/zip/internal/JavaArchive.java", "diffHunk": "@@ -0,0 +1,575 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 IBM Corporation and others.\n+ * All rights reserved. This program and the accompanying materials\n+ * are made available under the terms of the Eclipse Public License v1.0\n+ * which accompanies this distribution, and is available at\n+ * http://www.eclipse.org/legal/epl-v10.html\n+ *\n+ * Contributors:\n+ *     IBM Corporation - initial API and implementation\n+ *******************************************************************************\n+ *\n+ * The purpose of this class is to test if a Java archive is valid without actually reading the entire JAR.\n+ * This is especially useful in cases where the archive has a script attached at the front of the file.\n+ * Of course, this is more of a sanity check than a rigorous validation, which would require reading the whole file.\n+ * \n+ *     [ script ]                   <---- start of file  (optional)\n+ *     [ local file header 1 ]      <---- actual start of archive\n+ *     [ encryption header 1 ]\n+ *     [ file data 1 ]\n+ *     [ data descriptor 1 ]\n+ *     . \n+ *     .\n+ *     .\n+ *     [ local file header n ]\n+ *     [ encryption header n ]\n+ *     [ file data n ]\n+ *     [ data descriptor n ]\n+ *     [ archive decryption header ] \n+ *     [ archive extra data record ] \n+ *     [ central directory header 1 ]       <---- start of central directory\n+ *     .\n+ *     .\n+ *     .\n+ *     [ central directory header n ]\n+ *     [ zip64 end of central directory record ]\n+ *     [ zip64 end of central directory locator ] \n+ *     [ end of central directory record ]\n+ * \n+ *  The validation calculates the size of the last 4 records listed above (as well as doing some\n+ *  validation checks on the sizes and signatures) and then calculates the actual offset\n+ *  of the archive within the file (which will normally be 0).  The final step is to check\n+ *  the signature at the beginning of the archive.\n+ *  \n+ *  The actual archive offset is calculated :\n+ *  \n+ *    fileLength - eocdRecordSize - zip64RecLengths - CentralDirectorySize - offsetOfCentralDirectory\n+ *   \n+ *   Note the offsetOfCentralDirectory is relative to the beginning of the actual archive (not an offset  \n+ *   from the beginning of the file.)  Subtracting away all of the known pieces gives us the unknown \n+ *   piece which is the actual archive offset.\n+ *  \n+ */\n+\n+package com.ibm.ws.artifact.zip.internal;\n+\n+import java.io.IOException;\n+import java.io.RandomAccessFile;\n+import java.util.Arrays;\n+\n+public class JavaArchive {\n+    \n+    // EOCDR is End-of-Central-Directory-Record\n+\tprivate static final int EOCDR_MIN_SIZE = 22;\n+\tprivate static final int EOCDR_MAX_COMMENT_LEN = 0xFFFF;\n+\tprivate static final int EOCDR_MAX_SIZE = EOCDR_MIN_SIZE + EOCDR_MAX_COMMENT_LEN;\n+\tprivate static final int EOCDR_SIGNATURE = 0x504b0506; \n+\tprivate static final int EOCDR_TOTAL_ENTRIES_OFFSET = 10;\n+\tprivate static final int ZIP64_INDICATOR = 0xFFFF;               // Indicates Zip64 when found at offset EOCDR_TOTAL_ENTRIES_OFFSET \n+\tprivate static final int EOCDR_CENTRAL_DIR_SIZE_OFFSET = 12;     // Offset to size of central directory\n+\tprivate static final int EOCDR_CENTRAL_DIR_OFFSET = 16;          // Offset to central directory relative to beginning of archive\n+\tprivate static final int EOCDR_COMMENT_LENGTH_OFFSET = 20; \t     // Offset to comment length\n+\t\n+\t// ZIP64_EOCDR is Zip64-End-of-Central-Directory-Record\n+\tprivate static final int ZIP64_EOCDR_SIGNATURE = 0x504b0606;\n+\tprivate static final int ZIP64_EOCDR_MINIMUM_SIZE = 56;\n+\tprivate static final int ZIP64_EOCDR_HEADER_SIZE = 12;           // 4 bytes for the signature and 8 bytes for the length\n+\tprivate static final int ZIP64_EOCDR_SIZE_OFFSET = 4;            // The size at this offset is the size of the zip64 EOCDR minus 12. (Meaning it does NOT include the 12-byte header)\n+\tprivate static final int ZIP64_EOCDR_SIZE_FIELD_LENGTH = 8;      // Number of bytes for size field.\n+\n+\t// ZIP64_LOCATOR is Zip64-End-of-Central-Directory-Record-Locator\n+\tprivate static final int ZIP64_LOCATOR_SIGNATURE = 0x504b0607;\n+\tprivate static final int ZIP64_LOCATOR_SIZE = 20;                // Fixed size.\n+\tprivate static final int ZIP64_LOCATOR_EOCD_OFFSET_OFFSET = 8;   // Position in the locator of the offset of the Zip64-End-of-Central-Direcory-Record\n+\t\n+\tprivate static final int LOCAL_FILE_HEADER_SIGNATURE = 0x504b0304;\n+\tprivate static final int BLOCK_SIZE = 256;\n+\tprivate static final int FORWARD_BLOCK_SIZE = 8192;\n+\t\n+\t// Maximum amount of data (usually a script) that is allowed by this implementation to be \n+\t// attached to the beginning of the archive. This value may be increased, but it will \n+\t// increase the time it takes to fail when the zip is corrupted.\n+\tprivate static final int MAX_PREFIX_ALLOWED = 1024*1024*5;       \n+\t\n+\tprivate byte[] _endOfCentralDirectoryRecord; // Only the minimum size is stored.  Does not include the comment \n+\tprivate int    _eocdRecordSize;              // Actual size of End-of-Central-Directory-Record - including comment\n+\tprivate byte[] _zip64EoCDRLocator;           // 20 bytes;\n+\tprivate long   _zip64EoCDRLocatorOffset;     // Offset (from end of file) of the Zip64 Locator\n+\tprivate byte[] _zip64EoCDR;                  // Only the minimum size is stored.  Does not include any extra fields.  \n+\tprivate long   _zip64EoCDRecSize;            // Size of Zip64-End-of-Central-Directory-Record\n+    private String _archiveFileName;\n+\tprivate long   _fileLength;                  // Length of the archive file\n+\t\n+    JavaArchive(String archiveFileName) {\n+    \t_archiveFileName = archiveFileName;\n+    }\n+    \n+    public boolean isValid() {\n+    \t\n+    \ttry (  RandomAccessFile file = new RandomAccessFile(_archiveFileName, \"r\") ) {\n+\n+    \t\t_fileLength = file.length();\n+    \t\t_endOfCentralDirectoryRecord = getEndOfCentralDirectoryRecord(file);\n+    \t\t\n+    \t\tif ( isZip64() ) {\n+    \t\t   _zip64EoCDRLocator = getZip64EoCDLocator(file);\n+    \t\t   _zip64EoCDRLocatorOffset = _fileLength - _eocdRecordSize - ZIP64_LOCATOR_SIZE;\n+    \t\t   _zip64EoCDR = getZip64EndOfCentralDirectoryRecord(file);\n+    \t\t   _zip64EoCDRecSize = getZip64EoCDRecordSize( _zip64EoCDR, 0 );\n+    \t\t}\n+    \t\t\n+    \t\tint archiveOffset = (int)getActualArchiveOffset();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "557cc66c2c7bbcbe803c2724e18ae288b8bbc2c1"}, "originalPosition": 121}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzU4NDY4Mw==", "bodyText": "Do we want to display some information here in case of an exception?", "url": "https://github.com/OpenLiberty/open-liberty/pull/14827#discussion_r517584683", "createdAt": "2020-11-04T19:35:52Z", "author": {"login": "tbitonti"}, "path": "dev/com.ibm.ws.artifact.zip/src/com/ibm/ws/artifact/zip/internal/JavaArchive.java", "diffHunk": "@@ -0,0 +1,575 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 IBM Corporation and others.\n+ * All rights reserved. This program and the accompanying materials\n+ * are made available under the terms of the Eclipse Public License v1.0\n+ * which accompanies this distribution, and is available at\n+ * http://www.eclipse.org/legal/epl-v10.html\n+ *\n+ * Contributors:\n+ *     IBM Corporation - initial API and implementation\n+ *******************************************************************************\n+ *\n+ * The purpose of this class is to test if a Java archive is valid without actually reading the entire JAR.\n+ * This is especially useful in cases where the archive has a script attached at the front of the file.\n+ * Of course, this is more of a sanity check than a rigorous validation, which would require reading the whole file.\n+ * \n+ *     [ script ]                   <---- start of file  (optional)\n+ *     [ local file header 1 ]      <---- actual start of archive\n+ *     [ encryption header 1 ]\n+ *     [ file data 1 ]\n+ *     [ data descriptor 1 ]\n+ *     . \n+ *     .\n+ *     .\n+ *     [ local file header n ]\n+ *     [ encryption header n ]\n+ *     [ file data n ]\n+ *     [ data descriptor n ]\n+ *     [ archive decryption header ] \n+ *     [ archive extra data record ] \n+ *     [ central directory header 1 ]       <---- start of central directory\n+ *     .\n+ *     .\n+ *     .\n+ *     [ central directory header n ]\n+ *     [ zip64 end of central directory record ]\n+ *     [ zip64 end of central directory locator ] \n+ *     [ end of central directory record ]\n+ * \n+ *  The validation calculates the size of the last 4 records listed above (as well as doing some\n+ *  validation checks on the sizes and signatures) and then calculates the actual offset\n+ *  of the archive within the file (which will normally be 0).  The final step is to check\n+ *  the signature at the beginning of the archive.\n+ *  \n+ *  The actual archive offset is calculated :\n+ *  \n+ *    fileLength - eocdRecordSize - zip64RecLengths - CentralDirectorySize - offsetOfCentralDirectory\n+ *   \n+ *   Note the offsetOfCentralDirectory is relative to the beginning of the actual archive (not an offset  \n+ *   from the beginning of the file.)  Subtracting away all of the known pieces gives us the unknown \n+ *   piece which is the actual archive offset.\n+ *  \n+ */\n+\n+package com.ibm.ws.artifact.zip.internal;\n+\n+import java.io.IOException;\n+import java.io.RandomAccessFile;\n+import java.util.Arrays;\n+\n+public class JavaArchive {\n+    \n+    // EOCDR is End-of-Central-Directory-Record\n+\tprivate static final int EOCDR_MIN_SIZE = 22;\n+\tprivate static final int EOCDR_MAX_COMMENT_LEN = 0xFFFF;\n+\tprivate static final int EOCDR_MAX_SIZE = EOCDR_MIN_SIZE + EOCDR_MAX_COMMENT_LEN;\n+\tprivate static final int EOCDR_SIGNATURE = 0x504b0506; \n+\tprivate static final int EOCDR_TOTAL_ENTRIES_OFFSET = 10;\n+\tprivate static final int ZIP64_INDICATOR = 0xFFFF;               // Indicates Zip64 when found at offset EOCDR_TOTAL_ENTRIES_OFFSET \n+\tprivate static final int EOCDR_CENTRAL_DIR_SIZE_OFFSET = 12;     // Offset to size of central directory\n+\tprivate static final int EOCDR_CENTRAL_DIR_OFFSET = 16;          // Offset to central directory relative to beginning of archive\n+\tprivate static final int EOCDR_COMMENT_LENGTH_OFFSET = 20; \t     // Offset to comment length\n+\t\n+\t// ZIP64_EOCDR is Zip64-End-of-Central-Directory-Record\n+\tprivate static final int ZIP64_EOCDR_SIGNATURE = 0x504b0606;\n+\tprivate static final int ZIP64_EOCDR_MINIMUM_SIZE = 56;\n+\tprivate static final int ZIP64_EOCDR_HEADER_SIZE = 12;           // 4 bytes for the signature and 8 bytes for the length\n+\tprivate static final int ZIP64_EOCDR_SIZE_OFFSET = 4;            // The size at this offset is the size of the zip64 EOCDR minus 12. (Meaning it does NOT include the 12-byte header)\n+\tprivate static final int ZIP64_EOCDR_SIZE_FIELD_LENGTH = 8;      // Number of bytes for size field.\n+\n+\t// ZIP64_LOCATOR is Zip64-End-of-Central-Directory-Record-Locator\n+\tprivate static final int ZIP64_LOCATOR_SIGNATURE = 0x504b0607;\n+\tprivate static final int ZIP64_LOCATOR_SIZE = 20;                // Fixed size.\n+\tprivate static final int ZIP64_LOCATOR_EOCD_OFFSET_OFFSET = 8;   // Position in the locator of the offset of the Zip64-End-of-Central-Direcory-Record\n+\t\n+\tprivate static final int LOCAL_FILE_HEADER_SIGNATURE = 0x504b0304;\n+\tprivate static final int BLOCK_SIZE = 256;\n+\tprivate static final int FORWARD_BLOCK_SIZE = 8192;\n+\t\n+\t// Maximum amount of data (usually a script) that is allowed by this implementation to be \n+\t// attached to the beginning of the archive. This value may be increased, but it will \n+\t// increase the time it takes to fail when the zip is corrupted.\n+\tprivate static final int MAX_PREFIX_ALLOWED = 1024*1024*5;       \n+\t\n+\tprivate byte[] _endOfCentralDirectoryRecord; // Only the minimum size is stored.  Does not include the comment \n+\tprivate int    _eocdRecordSize;              // Actual size of End-of-Central-Directory-Record - including comment\n+\tprivate byte[] _zip64EoCDRLocator;           // 20 bytes;\n+\tprivate long   _zip64EoCDRLocatorOffset;     // Offset (from end of file) of the Zip64 Locator\n+\tprivate byte[] _zip64EoCDR;                  // Only the minimum size is stored.  Does not include any extra fields.  \n+\tprivate long   _zip64EoCDRecSize;            // Size of Zip64-End-of-Central-Directory-Record\n+    private String _archiveFileName;\n+\tprivate long   _fileLength;                  // Length of the archive file\n+\t\n+    JavaArchive(String archiveFileName) {\n+    \t_archiveFileName = archiveFileName;\n+    }\n+    \n+    public boolean isValid() {\n+    \t\n+    \ttry (  RandomAccessFile file = new RandomAccessFile(_archiveFileName, \"r\") ) {\n+\n+    \t\t_fileLength = file.length();\n+    \t\t_endOfCentralDirectoryRecord = getEndOfCentralDirectoryRecord(file);\n+    \t\t\n+    \t\tif ( isZip64() ) {\n+    \t\t   _zip64EoCDRLocator = getZip64EoCDLocator(file);\n+    \t\t   _zip64EoCDRLocatorOffset = _fileLength - _eocdRecordSize - ZIP64_LOCATOR_SIZE;\n+    \t\t   _zip64EoCDR = getZip64EndOfCentralDirectoryRecord(file);\n+    \t\t   _zip64EoCDRecSize = getZip64EoCDRecordSize( _zip64EoCDR, 0 );\n+    \t\t}\n+    \t\t\n+    \t\tint archiveOffset = (int)getActualArchiveOffset();\n+\n+    \t\tif (archiveStartsWithSignature(file, archiveOffset)) {\n+    \t\t\treturn true;\n+    \t\t} \n+\n+    \t} catch (Exception e) {\n+    \t\t//e.printStackTrace();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "557cc66c2c7bbcbe803c2724e18ae288b8bbc2c1"}, "originalPosition": 128}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzU4NTIxOQ==", "bodyText": "Either add documentation on the @param and @throws lines, or omit them.", "url": "https://github.com/OpenLiberty/open-liberty/pull/14827#discussion_r517585219", "createdAt": "2020-11-04T19:36:58Z", "author": {"login": "tbitonti"}, "path": "dev/com.ibm.ws.artifact.zip/src/com/ibm/ws/artifact/zip/internal/JavaArchive.java", "diffHunk": "@@ -0,0 +1,575 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 IBM Corporation and others.\n+ * All rights reserved. This program and the accompanying materials\n+ * are made available under the terms of the Eclipse Public License v1.0\n+ * which accompanies this distribution, and is available at\n+ * http://www.eclipse.org/legal/epl-v10.html\n+ *\n+ * Contributors:\n+ *     IBM Corporation - initial API and implementation\n+ *******************************************************************************\n+ *\n+ * The purpose of this class is to test if a Java archive is valid without actually reading the entire JAR.\n+ * This is especially useful in cases where the archive has a script attached at the front of the file.\n+ * Of course, this is more of a sanity check than a rigorous validation, which would require reading the whole file.\n+ * \n+ *     [ script ]                   <---- start of file  (optional)\n+ *     [ local file header 1 ]      <---- actual start of archive\n+ *     [ encryption header 1 ]\n+ *     [ file data 1 ]\n+ *     [ data descriptor 1 ]\n+ *     . \n+ *     .\n+ *     .\n+ *     [ local file header n ]\n+ *     [ encryption header n ]\n+ *     [ file data n ]\n+ *     [ data descriptor n ]\n+ *     [ archive decryption header ] \n+ *     [ archive extra data record ] \n+ *     [ central directory header 1 ]       <---- start of central directory\n+ *     .\n+ *     .\n+ *     .\n+ *     [ central directory header n ]\n+ *     [ zip64 end of central directory record ]\n+ *     [ zip64 end of central directory locator ] \n+ *     [ end of central directory record ]\n+ * \n+ *  The validation calculates the size of the last 4 records listed above (as well as doing some\n+ *  validation checks on the sizes and signatures) and then calculates the actual offset\n+ *  of the archive within the file (which will normally be 0).  The final step is to check\n+ *  the signature at the beginning of the archive.\n+ *  \n+ *  The actual archive offset is calculated :\n+ *  \n+ *    fileLength - eocdRecordSize - zip64RecLengths - CentralDirectorySize - offsetOfCentralDirectory\n+ *   \n+ *   Note the offsetOfCentralDirectory is relative to the beginning of the actual archive (not an offset  \n+ *   from the beginning of the file.)  Subtracting away all of the known pieces gives us the unknown \n+ *   piece which is the actual archive offset.\n+ *  \n+ */\n+\n+package com.ibm.ws.artifact.zip.internal;\n+\n+import java.io.IOException;\n+import java.io.RandomAccessFile;\n+import java.util.Arrays;\n+\n+public class JavaArchive {\n+    \n+    // EOCDR is End-of-Central-Directory-Record\n+\tprivate static final int EOCDR_MIN_SIZE = 22;\n+\tprivate static final int EOCDR_MAX_COMMENT_LEN = 0xFFFF;\n+\tprivate static final int EOCDR_MAX_SIZE = EOCDR_MIN_SIZE + EOCDR_MAX_COMMENT_LEN;\n+\tprivate static final int EOCDR_SIGNATURE = 0x504b0506; \n+\tprivate static final int EOCDR_TOTAL_ENTRIES_OFFSET = 10;\n+\tprivate static final int ZIP64_INDICATOR = 0xFFFF;               // Indicates Zip64 when found at offset EOCDR_TOTAL_ENTRIES_OFFSET \n+\tprivate static final int EOCDR_CENTRAL_DIR_SIZE_OFFSET = 12;     // Offset to size of central directory\n+\tprivate static final int EOCDR_CENTRAL_DIR_OFFSET = 16;          // Offset to central directory relative to beginning of archive\n+\tprivate static final int EOCDR_COMMENT_LENGTH_OFFSET = 20; \t     // Offset to comment length\n+\t\n+\t// ZIP64_EOCDR is Zip64-End-of-Central-Directory-Record\n+\tprivate static final int ZIP64_EOCDR_SIGNATURE = 0x504b0606;\n+\tprivate static final int ZIP64_EOCDR_MINIMUM_SIZE = 56;\n+\tprivate static final int ZIP64_EOCDR_HEADER_SIZE = 12;           // 4 bytes for the signature and 8 bytes for the length\n+\tprivate static final int ZIP64_EOCDR_SIZE_OFFSET = 4;            // The size at this offset is the size of the zip64 EOCDR minus 12. (Meaning it does NOT include the 12-byte header)\n+\tprivate static final int ZIP64_EOCDR_SIZE_FIELD_LENGTH = 8;      // Number of bytes for size field.\n+\n+\t// ZIP64_LOCATOR is Zip64-End-of-Central-Directory-Record-Locator\n+\tprivate static final int ZIP64_LOCATOR_SIGNATURE = 0x504b0607;\n+\tprivate static final int ZIP64_LOCATOR_SIZE = 20;                // Fixed size.\n+\tprivate static final int ZIP64_LOCATOR_EOCD_OFFSET_OFFSET = 8;   // Position in the locator of the offset of the Zip64-End-of-Central-Direcory-Record\n+\t\n+\tprivate static final int LOCAL_FILE_HEADER_SIGNATURE = 0x504b0304;\n+\tprivate static final int BLOCK_SIZE = 256;\n+\tprivate static final int FORWARD_BLOCK_SIZE = 8192;\n+\t\n+\t// Maximum amount of data (usually a script) that is allowed by this implementation to be \n+\t// attached to the beginning of the archive. This value may be increased, but it will \n+\t// increase the time it takes to fail when the zip is corrupted.\n+\tprivate static final int MAX_PREFIX_ALLOWED = 1024*1024*5;       \n+\t\n+\tprivate byte[] _endOfCentralDirectoryRecord; // Only the minimum size is stored.  Does not include the comment \n+\tprivate int    _eocdRecordSize;              // Actual size of End-of-Central-Directory-Record - including comment\n+\tprivate byte[] _zip64EoCDRLocator;           // 20 bytes;\n+\tprivate long   _zip64EoCDRLocatorOffset;     // Offset (from end of file) of the Zip64 Locator\n+\tprivate byte[] _zip64EoCDR;                  // Only the minimum size is stored.  Does not include any extra fields.  \n+\tprivate long   _zip64EoCDRecSize;            // Size of Zip64-End-of-Central-Directory-Record\n+    private String _archiveFileName;\n+\tprivate long   _fileLength;                  // Length of the archive file\n+\t\n+    JavaArchive(String archiveFileName) {\n+    \t_archiveFileName = archiveFileName;\n+    }\n+    \n+    public boolean isValid() {\n+    \t\n+    \ttry (  RandomAccessFile file = new RandomAccessFile(_archiveFileName, \"r\") ) {\n+\n+    \t\t_fileLength = file.length();\n+    \t\t_endOfCentralDirectoryRecord = getEndOfCentralDirectoryRecord(file);\n+    \t\t\n+    \t\tif ( isZip64() ) {\n+    \t\t   _zip64EoCDRLocator = getZip64EoCDLocator(file);\n+    \t\t   _zip64EoCDRLocatorOffset = _fileLength - _eocdRecordSize - ZIP64_LOCATOR_SIZE;\n+    \t\t   _zip64EoCDR = getZip64EndOfCentralDirectoryRecord(file);\n+    \t\t   _zip64EoCDRecSize = getZip64EoCDRecordSize( _zip64EoCDR, 0 );\n+    \t\t}\n+    \t\t\n+    \t\tint archiveOffset = (int)getActualArchiveOffset();\n+\n+    \t\tif (archiveStartsWithSignature(file, archiveOffset)) {\n+    \t\t\treturn true;\n+    \t\t} \n+\n+    \t} catch (Exception e) {\n+    \t\t//e.printStackTrace();\n+    \t}\n+\n+    \treturn false;\n+    }\n+    \n+    /**\n+     * Find the End-of-Central-Director-Record which is always at the end of the file.\n+     * It is usually 22 bytes but may contain a comment up to 64K in size.\n+     * Reads from the end of the file looking backwards for the EoCDR signature.\n+     * \n+     * The implementation reads the file in BLOCK_SIZE blocks from the end of the file\n+     * and searches each block.  Note that there is some overlap of the successive \n+     * blocks; EOCDR_MIN_SIZE bytes of overlap to be precise.  This is because the \n+     * record might start at the end of one block and finish in the next.\n+     * \n+     * @param file\n+     * @throws IOException\n+     */", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "557cc66c2c7bbcbe803c2724e18ae288b8bbc2c1"}, "originalPosition": 146}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzU4NjE0Nw==", "bodyText": "As above; @param, @return, and @throws can be omitted if they provide no actual documentation.", "url": "https://github.com/OpenLiberty/open-liberty/pull/14827#discussion_r517586147", "createdAt": "2020-11-04T19:38:45Z", "author": {"login": "tbitonti"}, "path": "dev/com.ibm.ws.artifact.zip/src/com/ibm/ws/artifact/zip/internal/JavaArchive.java", "diffHunk": "@@ -0,0 +1,575 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 IBM Corporation and others.\n+ * All rights reserved. This program and the accompanying materials\n+ * are made available under the terms of the Eclipse Public License v1.0\n+ * which accompanies this distribution, and is available at\n+ * http://www.eclipse.org/legal/epl-v10.html\n+ *\n+ * Contributors:\n+ *     IBM Corporation - initial API and implementation\n+ *******************************************************************************\n+ *\n+ * The purpose of this class is to test if a Java archive is valid without actually reading the entire JAR.\n+ * This is especially useful in cases where the archive has a script attached at the front of the file.\n+ * Of course, this is more of a sanity check than a rigorous validation, which would require reading the whole file.\n+ * \n+ *     [ script ]                   <---- start of file  (optional)\n+ *     [ local file header 1 ]      <---- actual start of archive\n+ *     [ encryption header 1 ]\n+ *     [ file data 1 ]\n+ *     [ data descriptor 1 ]\n+ *     . \n+ *     .\n+ *     .\n+ *     [ local file header n ]\n+ *     [ encryption header n ]\n+ *     [ file data n ]\n+ *     [ data descriptor n ]\n+ *     [ archive decryption header ] \n+ *     [ archive extra data record ] \n+ *     [ central directory header 1 ]       <---- start of central directory\n+ *     .\n+ *     .\n+ *     .\n+ *     [ central directory header n ]\n+ *     [ zip64 end of central directory record ]\n+ *     [ zip64 end of central directory locator ] \n+ *     [ end of central directory record ]\n+ * \n+ *  The validation calculates the size of the last 4 records listed above (as well as doing some\n+ *  validation checks on the sizes and signatures) and then calculates the actual offset\n+ *  of the archive within the file (which will normally be 0).  The final step is to check\n+ *  the signature at the beginning of the archive.\n+ *  \n+ *  The actual archive offset is calculated :\n+ *  \n+ *    fileLength - eocdRecordSize - zip64RecLengths - CentralDirectorySize - offsetOfCentralDirectory\n+ *   \n+ *   Note the offsetOfCentralDirectory is relative to the beginning of the actual archive (not an offset  \n+ *   from the beginning of the file.)  Subtracting away all of the known pieces gives us the unknown \n+ *   piece which is the actual archive offset.\n+ *  \n+ */\n+\n+package com.ibm.ws.artifact.zip.internal;\n+\n+import java.io.IOException;\n+import java.io.RandomAccessFile;\n+import java.util.Arrays;\n+\n+public class JavaArchive {\n+    \n+    // EOCDR is End-of-Central-Directory-Record\n+\tprivate static final int EOCDR_MIN_SIZE = 22;\n+\tprivate static final int EOCDR_MAX_COMMENT_LEN = 0xFFFF;\n+\tprivate static final int EOCDR_MAX_SIZE = EOCDR_MIN_SIZE + EOCDR_MAX_COMMENT_LEN;\n+\tprivate static final int EOCDR_SIGNATURE = 0x504b0506; \n+\tprivate static final int EOCDR_TOTAL_ENTRIES_OFFSET = 10;\n+\tprivate static final int ZIP64_INDICATOR = 0xFFFF;               // Indicates Zip64 when found at offset EOCDR_TOTAL_ENTRIES_OFFSET \n+\tprivate static final int EOCDR_CENTRAL_DIR_SIZE_OFFSET = 12;     // Offset to size of central directory\n+\tprivate static final int EOCDR_CENTRAL_DIR_OFFSET = 16;          // Offset to central directory relative to beginning of archive\n+\tprivate static final int EOCDR_COMMENT_LENGTH_OFFSET = 20; \t     // Offset to comment length\n+\t\n+\t// ZIP64_EOCDR is Zip64-End-of-Central-Directory-Record\n+\tprivate static final int ZIP64_EOCDR_SIGNATURE = 0x504b0606;\n+\tprivate static final int ZIP64_EOCDR_MINIMUM_SIZE = 56;\n+\tprivate static final int ZIP64_EOCDR_HEADER_SIZE = 12;           // 4 bytes for the signature and 8 bytes for the length\n+\tprivate static final int ZIP64_EOCDR_SIZE_OFFSET = 4;            // The size at this offset is the size of the zip64 EOCDR minus 12. (Meaning it does NOT include the 12-byte header)\n+\tprivate static final int ZIP64_EOCDR_SIZE_FIELD_LENGTH = 8;      // Number of bytes for size field.\n+\n+\t// ZIP64_LOCATOR is Zip64-End-of-Central-Directory-Record-Locator\n+\tprivate static final int ZIP64_LOCATOR_SIGNATURE = 0x504b0607;\n+\tprivate static final int ZIP64_LOCATOR_SIZE = 20;                // Fixed size.\n+\tprivate static final int ZIP64_LOCATOR_EOCD_OFFSET_OFFSET = 8;   // Position in the locator of the offset of the Zip64-End-of-Central-Direcory-Record\n+\t\n+\tprivate static final int LOCAL_FILE_HEADER_SIGNATURE = 0x504b0304;\n+\tprivate static final int BLOCK_SIZE = 256;\n+\tprivate static final int FORWARD_BLOCK_SIZE = 8192;\n+\t\n+\t// Maximum amount of data (usually a script) that is allowed by this implementation to be \n+\t// attached to the beginning of the archive. This value may be increased, but it will \n+\t// increase the time it takes to fail when the zip is corrupted.\n+\tprivate static final int MAX_PREFIX_ALLOWED = 1024*1024*5;       \n+\t\n+\tprivate byte[] _endOfCentralDirectoryRecord; // Only the minimum size is stored.  Does not include the comment \n+\tprivate int    _eocdRecordSize;              // Actual size of End-of-Central-Directory-Record - including comment\n+\tprivate byte[] _zip64EoCDRLocator;           // 20 bytes;\n+\tprivate long   _zip64EoCDRLocatorOffset;     // Offset (from end of file) of the Zip64 Locator\n+\tprivate byte[] _zip64EoCDR;                  // Only the minimum size is stored.  Does not include any extra fields.  \n+\tprivate long   _zip64EoCDRecSize;            // Size of Zip64-End-of-Central-Directory-Record\n+    private String _archiveFileName;\n+\tprivate long   _fileLength;                  // Length of the archive file\n+\t\n+    JavaArchive(String archiveFileName) {\n+    \t_archiveFileName = archiveFileName;\n+    }\n+    \n+    public boolean isValid() {\n+    \t\n+    \ttry (  RandomAccessFile file = new RandomAccessFile(_archiveFileName, \"r\") ) {\n+\n+    \t\t_fileLength = file.length();\n+    \t\t_endOfCentralDirectoryRecord = getEndOfCentralDirectoryRecord(file);\n+    \t\t\n+    \t\tif ( isZip64() ) {\n+    \t\t   _zip64EoCDRLocator = getZip64EoCDLocator(file);\n+    \t\t   _zip64EoCDRLocatorOffset = _fileLength - _eocdRecordSize - ZIP64_LOCATOR_SIZE;\n+    \t\t   _zip64EoCDR = getZip64EndOfCentralDirectoryRecord(file);\n+    \t\t   _zip64EoCDRecSize = getZip64EoCDRecordSize( _zip64EoCDR, 0 );\n+    \t\t}\n+    \t\t\n+    \t\tint archiveOffset = (int)getActualArchiveOffset();\n+\n+    \t\tif (archiveStartsWithSignature(file, archiveOffset)) {\n+    \t\t\treturn true;\n+    \t\t} \n+\n+    \t} catch (Exception e) {\n+    \t\t//e.printStackTrace();\n+    \t}\n+\n+    \treturn false;\n+    }\n+    \n+    /**\n+     * Find the End-of-Central-Director-Record which is always at the end of the file.\n+     * It is usually 22 bytes but may contain a comment up to 64K in size.\n+     * Reads from the end of the file looking backwards for the EoCDR signature.\n+     * \n+     * The implementation reads the file in BLOCK_SIZE blocks from the end of the file\n+     * and searches each block.  Note that there is some overlap of the successive \n+     * blocks; EOCDR_MIN_SIZE bytes of overlap to be precise.  This is because the \n+     * record might start at the end of one block and finish in the next.\n+     * \n+     * @param file\n+     * @throws IOException\n+     */\n+\tprivate byte[] getEndOfCentralDirectoryRecord(RandomAccessFile file) throws IOException {\n+\t\t\n+\t\tbyte[] block = getBlockFromEndOfFile(file, BLOCK_SIZE);\n+\t\tint size = EOCDR_MIN_SIZE ;\n+\t\tint offset = block.length - size;\n+\t\tint offsetFromEnd = block.length - offset;   // offset from the end of the block (not the file)\n+\t\t\n+\t\tif ( block.length < EOCDR_MIN_SIZE ) {\n+\t\t\tthrow new IOException(\"Not a valid zip file.  Less than minimum required length.\");\n+\t\t}\n+\t\t\n+\t\t// We will only enter this loop if a comment is attached to the End-of-Central-Directory-Record\n+\t\t// ... or if the zip is invalid (doesn't have an End-of-Central-Directory-Record.\n+\t\t// Note that isValidEoCDRec must have EOCDR_MIN_SIZE available at the end of the block\n+\t\t// to avoid an exception because of a read past the end of the block.\n+\t\twhile ( !isValidEoCDRec( block, offset, size ) ) {\n+\t\t\tsize++;\n+\t\t\tif (size == 0xFFFF) {\n+\t\t\t\tint i = 0;\n+\t\t\t}\n+\t\t\toffsetFromEnd++;\n+\t\t\t \n+\t\t\tif ( size > EOCDR_MAX_SIZE || size > _fileLength ) {\n+\t\t\t\tthrow new IOException(\n+\t\t\t\t\t\t\"Cannot find central directory end record in zip\");\n+\t\t\t}\n+\t\t\t\n+\t\t\tif ( offsetFromEnd > block.length ) {\n+\n+\t\t\t\tblock = this.getBlockFromEndOfFile(file, size + BLOCK_SIZE - EOCDR_MIN_SIZE, BLOCK_SIZE);\n+\t\t\t\toffsetFromEnd = EOCDR_MIN_SIZE;\n+\t\t\t}\n+\t\t\toffset = block.length - offsetFromEnd;\t\t\t\n+\t\t}\n+\t\t\n+\t\t// Copy only the minimum end-of-central-directory-record, but record the actual size.  \n+\t\t// We don't need to store the comment, which could be up to 64k.\t\t\n+\t\t_eocdRecordSize = size;\n+\t\treturn Arrays.copyOfRange(block, offset, offset + EOCDR_MIN_SIZE ); \n+\t}\n+\t\n+//  Alternative implementation that avoids the overlapping blocks, but always reads to the end of\n+//  when retrieving a new block.  Thus the block size grows and can get quite large.\t\n+//\n+//\n+//\tprivate byte[] getEndOfCentralDirectoryRecord(RandomAccessFile file) throws IOException {\n+//\t\t\n+//\t\tbyte[] block = getBlockFromEndOfFile(file, BLOCK_SIZE);\n+//\t\tint blockLength = block.length;  // for debugging !!!!!!!!!!!!!!!!1\n+//\t\tint size = EOCDR_MIN_SIZE ;\n+//\t\tint offset = block.length - size;\n+//\t\t\n+//\t\tif ( block.length < EOCDR_MIN_SIZE ) {\n+//\t\t\tthrow new IOException(\"Not a valid zip file.  Less than minimum required length.\");\n+//\t\t}\n+//\t\t\n+//\t\t// We will only enter this loop if a comment is attached to the End-of-Central-Directory-Record\n+//\t\t// ... or if the zip is invalid (doesn't have an End-of-Central-Directory-Record.\n+//\t\twhile ( !isValidEoCDRec( block, offset, size ) ) {\n+//\t\t\tsize++;\n+//\t\t\tif ( size > block.length ) {\n+//\t\t\t\tif ( size >= EOCDR_MAX_SIZE || size > _fileLength ) {\n+//\t\t\t\t\tthrow new IOException(\n+//\t\t\t\t\t\t\t\"Cannot find central directory end record in zip\");\n+//\t\t\t\t}\n+//\t\t\t\tblock = this.getBlockFromEndOfFile(file, size + BLOCK_SIZE);\n+//\t\t\t}\n+//\t\t\tblockLength = block.length;\n+//\t\t\toffset = block.length - size;\n+//\t\t}\n+//\t\t\n+//\t\t// Copy only the minimum end-of-central-directory-record, but record the actual size.  \n+//\t\t// We don't need the comment, which could be up to 64k.\t\t\n+//\t\t_eocdRecordSize = size;\n+//\t\treturn Arrays.copyOfRange(block, offset, offset + EOCDR_MIN_SIZE ); \n+//\t}\n+\t\n+\t/**\n+\t * Get the 20-byte Zip64 Locator.  It must sit 20 bytes before the End-of-Central-Directory-Record.\n+\t * @param file the zip file\n+\t * @return\n+\t * @throws IOException", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "557cc66c2c7bbcbe803c2724e18ae288b8bbc2c1"}, "originalPosition": 228}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzU4NjU2OA==", "bodyText": "Stale 'this' reference.", "url": "https://github.com/OpenLiberty/open-liberty/pull/14827#discussion_r517586568", "createdAt": "2020-11-04T19:39:30Z", "author": {"login": "tbitonti"}, "path": "dev/com.ibm.ws.artifact.zip/src/com/ibm/ws/artifact/zip/internal/JavaArchive.java", "diffHunk": "@@ -0,0 +1,575 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 IBM Corporation and others.\n+ * All rights reserved. This program and the accompanying materials\n+ * are made available under the terms of the Eclipse Public License v1.0\n+ * which accompanies this distribution, and is available at\n+ * http://www.eclipse.org/legal/epl-v10.html\n+ *\n+ * Contributors:\n+ *     IBM Corporation - initial API and implementation\n+ *******************************************************************************\n+ *\n+ * The purpose of this class is to test if a Java archive is valid without actually reading the entire JAR.\n+ * This is especially useful in cases where the archive has a script attached at the front of the file.\n+ * Of course, this is more of a sanity check than a rigorous validation, which would require reading the whole file.\n+ * \n+ *     [ script ]                   <---- start of file  (optional)\n+ *     [ local file header 1 ]      <---- actual start of archive\n+ *     [ encryption header 1 ]\n+ *     [ file data 1 ]\n+ *     [ data descriptor 1 ]\n+ *     . \n+ *     .\n+ *     .\n+ *     [ local file header n ]\n+ *     [ encryption header n ]\n+ *     [ file data n ]\n+ *     [ data descriptor n ]\n+ *     [ archive decryption header ] \n+ *     [ archive extra data record ] \n+ *     [ central directory header 1 ]       <---- start of central directory\n+ *     .\n+ *     .\n+ *     .\n+ *     [ central directory header n ]\n+ *     [ zip64 end of central directory record ]\n+ *     [ zip64 end of central directory locator ] \n+ *     [ end of central directory record ]\n+ * \n+ *  The validation calculates the size of the last 4 records listed above (as well as doing some\n+ *  validation checks on the sizes and signatures) and then calculates the actual offset\n+ *  of the archive within the file (which will normally be 0).  The final step is to check\n+ *  the signature at the beginning of the archive.\n+ *  \n+ *  The actual archive offset is calculated :\n+ *  \n+ *    fileLength - eocdRecordSize - zip64RecLengths - CentralDirectorySize - offsetOfCentralDirectory\n+ *   \n+ *   Note the offsetOfCentralDirectory is relative to the beginning of the actual archive (not an offset  \n+ *   from the beginning of the file.)  Subtracting away all of the known pieces gives us the unknown \n+ *   piece which is the actual archive offset.\n+ *  \n+ */\n+\n+package com.ibm.ws.artifact.zip.internal;\n+\n+import java.io.IOException;\n+import java.io.RandomAccessFile;\n+import java.util.Arrays;\n+\n+public class JavaArchive {\n+    \n+    // EOCDR is End-of-Central-Directory-Record\n+\tprivate static final int EOCDR_MIN_SIZE = 22;\n+\tprivate static final int EOCDR_MAX_COMMENT_LEN = 0xFFFF;\n+\tprivate static final int EOCDR_MAX_SIZE = EOCDR_MIN_SIZE + EOCDR_MAX_COMMENT_LEN;\n+\tprivate static final int EOCDR_SIGNATURE = 0x504b0506; \n+\tprivate static final int EOCDR_TOTAL_ENTRIES_OFFSET = 10;\n+\tprivate static final int ZIP64_INDICATOR = 0xFFFF;               // Indicates Zip64 when found at offset EOCDR_TOTAL_ENTRIES_OFFSET \n+\tprivate static final int EOCDR_CENTRAL_DIR_SIZE_OFFSET = 12;     // Offset to size of central directory\n+\tprivate static final int EOCDR_CENTRAL_DIR_OFFSET = 16;          // Offset to central directory relative to beginning of archive\n+\tprivate static final int EOCDR_COMMENT_LENGTH_OFFSET = 20; \t     // Offset to comment length\n+\t\n+\t// ZIP64_EOCDR is Zip64-End-of-Central-Directory-Record\n+\tprivate static final int ZIP64_EOCDR_SIGNATURE = 0x504b0606;\n+\tprivate static final int ZIP64_EOCDR_MINIMUM_SIZE = 56;\n+\tprivate static final int ZIP64_EOCDR_HEADER_SIZE = 12;           // 4 bytes for the signature and 8 bytes for the length\n+\tprivate static final int ZIP64_EOCDR_SIZE_OFFSET = 4;            // The size at this offset is the size of the zip64 EOCDR minus 12. (Meaning it does NOT include the 12-byte header)\n+\tprivate static final int ZIP64_EOCDR_SIZE_FIELD_LENGTH = 8;      // Number of bytes for size field.\n+\n+\t// ZIP64_LOCATOR is Zip64-End-of-Central-Directory-Record-Locator\n+\tprivate static final int ZIP64_LOCATOR_SIGNATURE = 0x504b0607;\n+\tprivate static final int ZIP64_LOCATOR_SIZE = 20;                // Fixed size.\n+\tprivate static final int ZIP64_LOCATOR_EOCD_OFFSET_OFFSET = 8;   // Position in the locator of the offset of the Zip64-End-of-Central-Direcory-Record\n+\t\n+\tprivate static final int LOCAL_FILE_HEADER_SIGNATURE = 0x504b0304;\n+\tprivate static final int BLOCK_SIZE = 256;\n+\tprivate static final int FORWARD_BLOCK_SIZE = 8192;\n+\t\n+\t// Maximum amount of data (usually a script) that is allowed by this implementation to be \n+\t// attached to the beginning of the archive. This value may be increased, but it will \n+\t// increase the time it takes to fail when the zip is corrupted.\n+\tprivate static final int MAX_PREFIX_ALLOWED = 1024*1024*5;       \n+\t\n+\tprivate byte[] _endOfCentralDirectoryRecord; // Only the minimum size is stored.  Does not include the comment \n+\tprivate int    _eocdRecordSize;              // Actual size of End-of-Central-Directory-Record - including comment\n+\tprivate byte[] _zip64EoCDRLocator;           // 20 bytes;\n+\tprivate long   _zip64EoCDRLocatorOffset;     // Offset (from end of file) of the Zip64 Locator\n+\tprivate byte[] _zip64EoCDR;                  // Only the minimum size is stored.  Does not include any extra fields.  \n+\tprivate long   _zip64EoCDRecSize;            // Size of Zip64-End-of-Central-Directory-Record\n+    private String _archiveFileName;\n+\tprivate long   _fileLength;                  // Length of the archive file\n+\t\n+    JavaArchive(String archiveFileName) {\n+    \t_archiveFileName = archiveFileName;\n+    }\n+    \n+    public boolean isValid() {\n+    \t\n+    \ttry (  RandomAccessFile file = new RandomAccessFile(_archiveFileName, \"r\") ) {\n+\n+    \t\t_fileLength = file.length();\n+    \t\t_endOfCentralDirectoryRecord = getEndOfCentralDirectoryRecord(file);\n+    \t\t\n+    \t\tif ( isZip64() ) {\n+    \t\t   _zip64EoCDRLocator = getZip64EoCDLocator(file);\n+    \t\t   _zip64EoCDRLocatorOffset = _fileLength - _eocdRecordSize - ZIP64_LOCATOR_SIZE;\n+    \t\t   _zip64EoCDR = getZip64EndOfCentralDirectoryRecord(file);\n+    \t\t   _zip64EoCDRecSize = getZip64EoCDRecordSize( _zip64EoCDR, 0 );\n+    \t\t}\n+    \t\t\n+    \t\tint archiveOffset = (int)getActualArchiveOffset();\n+\n+    \t\tif (archiveStartsWithSignature(file, archiveOffset)) {\n+    \t\t\treturn true;\n+    \t\t} \n+\n+    \t} catch (Exception e) {\n+    \t\t//e.printStackTrace();\n+    \t}\n+\n+    \treturn false;\n+    }\n+    \n+    /**\n+     * Find the End-of-Central-Director-Record which is always at the end of the file.\n+     * It is usually 22 bytes but may contain a comment up to 64K in size.\n+     * Reads from the end of the file looking backwards for the EoCDR signature.\n+     * \n+     * The implementation reads the file in BLOCK_SIZE blocks from the end of the file\n+     * and searches each block.  Note that there is some overlap of the successive \n+     * blocks; EOCDR_MIN_SIZE bytes of overlap to be precise.  This is because the \n+     * record might start at the end of one block and finish in the next.\n+     * \n+     * @param file\n+     * @throws IOException\n+     */\n+\tprivate byte[] getEndOfCentralDirectoryRecord(RandomAccessFile file) throws IOException {\n+\t\t\n+\t\tbyte[] block = getBlockFromEndOfFile(file, BLOCK_SIZE);\n+\t\tint size = EOCDR_MIN_SIZE ;\n+\t\tint offset = block.length - size;\n+\t\tint offsetFromEnd = block.length - offset;   // offset from the end of the block (not the file)\n+\t\t\n+\t\tif ( block.length < EOCDR_MIN_SIZE ) {\n+\t\t\tthrow new IOException(\"Not a valid zip file.  Less than minimum required length.\");\n+\t\t}\n+\t\t\n+\t\t// We will only enter this loop if a comment is attached to the End-of-Central-Directory-Record\n+\t\t// ... or if the zip is invalid (doesn't have an End-of-Central-Directory-Record.\n+\t\t// Note that isValidEoCDRec must have EOCDR_MIN_SIZE available at the end of the block\n+\t\t// to avoid an exception because of a read past the end of the block.\n+\t\twhile ( !isValidEoCDRec( block, offset, size ) ) {\n+\t\t\tsize++;\n+\t\t\tif (size == 0xFFFF) {\n+\t\t\t\tint i = 0;\n+\t\t\t}\n+\t\t\toffsetFromEnd++;\n+\t\t\t \n+\t\t\tif ( size > EOCDR_MAX_SIZE || size > _fileLength ) {\n+\t\t\t\tthrow new IOException(\n+\t\t\t\t\t\t\"Cannot find central directory end record in zip\");\n+\t\t\t}\n+\t\t\t\n+\t\t\tif ( offsetFromEnd > block.length ) {\n+\n+\t\t\t\tblock = this.getBlockFromEndOfFile(file, size + BLOCK_SIZE - EOCDR_MIN_SIZE, BLOCK_SIZE);\n+\t\t\t\toffsetFromEnd = EOCDR_MIN_SIZE;\n+\t\t\t}\n+\t\t\toffset = block.length - offsetFromEnd;\t\t\t\n+\t\t}\n+\t\t\n+\t\t// Copy only the minimum end-of-central-directory-record, but record the actual size.  \n+\t\t// We don't need to store the comment, which could be up to 64k.\t\t\n+\t\t_eocdRecordSize = size;\n+\t\treturn Arrays.copyOfRange(block, offset, offset + EOCDR_MIN_SIZE ); \n+\t}\n+\t\n+//  Alternative implementation that avoids the overlapping blocks, but always reads to the end of\n+//  when retrieving a new block.  Thus the block size grows and can get quite large.\t\n+//\n+//\n+//\tprivate byte[] getEndOfCentralDirectoryRecord(RandomAccessFile file) throws IOException {\n+//\t\t\n+//\t\tbyte[] block = getBlockFromEndOfFile(file, BLOCK_SIZE);\n+//\t\tint blockLength = block.length;  // for debugging !!!!!!!!!!!!!!!!1\n+//\t\tint size = EOCDR_MIN_SIZE ;\n+//\t\tint offset = block.length - size;\n+//\t\t\n+//\t\tif ( block.length < EOCDR_MIN_SIZE ) {\n+//\t\t\tthrow new IOException(\"Not a valid zip file.  Less than minimum required length.\");\n+//\t\t}\n+//\t\t\n+//\t\t// We will only enter this loop if a comment is attached to the End-of-Central-Directory-Record\n+//\t\t// ... or if the zip is invalid (doesn't have an End-of-Central-Directory-Record.\n+//\t\twhile ( !isValidEoCDRec( block, offset, size ) ) {\n+//\t\t\tsize++;\n+//\t\t\tif ( size > block.length ) {\n+//\t\t\t\tif ( size >= EOCDR_MAX_SIZE || size > _fileLength ) {\n+//\t\t\t\t\tthrow new IOException(\n+//\t\t\t\t\t\t\t\"Cannot find central directory end record in zip\");\n+//\t\t\t\t}\n+//\t\t\t\tblock = this.getBlockFromEndOfFile(file, size + BLOCK_SIZE);\n+//\t\t\t}\n+//\t\t\tblockLength = block.length;\n+//\t\t\toffset = block.length - size;\n+//\t\t}\n+//\t\t\n+//\t\t// Copy only the minimum end-of-central-directory-record, but record the actual size.  \n+//\t\t// We don't need the comment, which could be up to 64k.\t\t\n+//\t\t_eocdRecordSize = size;\n+//\t\treturn Arrays.copyOfRange(block, offset, offset + EOCDR_MIN_SIZE ); \n+//\t}\n+\t\n+\t/**\n+\t * Get the 20-byte Zip64 Locator.  It must sit 20 bytes before the End-of-Central-Directory-Record.\n+\t * @param file the zip file\n+\t * @return\n+\t * @throws IOException\n+\t */\n+\tprivate byte[] getZip64EoCDLocator(RandomAccessFile file) throws IOException {\n+\n+\t\tif ( !isZip64() ) {\n+\t\t\treturn null;\n+\t\t}\n+\n+\t    byte[] block = getBlockFromEndOfFile(file, \n+\t    \t\t                             _eocdRecordSize + ZIP64_LOCATOR_SIZE, \n+\t    \t\t                             ZIP64_LOCATOR_SIZE);\t\n+\n+\t\tif ( !isValid_Zip64EoCDRLocator(block, 0)) {\n+\t\t\tthrow new IOException(\"Invalid Zip64-End-of-Central-Direcytory-Locator.\");\n+\t\t}\n+\n+\t\treturn Arrays.copyOfRange(block, 0, ZIP64_LOCATOR_SIZE);\n+\t}\n+\t\n+\t/**\n+\t * Locates the Zip64-End-of-Central-Directory-Record by using the offset \n+\t * in the Zip64 Locator.  If not found there, it is assumed that data has\n+\t * been prepended to the archive, and a forward search begins until we find the\n+\t * correct signature.  Of course, a false signature could appear just about  \n+\t * anywhere in the zip.  So the record must pass additional validation.\n+\t * @param file a zip file\n+\t * @return a copy of the Zip64-End-of-Central-Directory-Record\n+\t * @throws IOException\n+\t */\n+\tprivate byte[] getZip64EndOfCentralDirectoryRecord(RandomAccessFile file ) throws IOException {\n+\t\t\n+\t\tif ( !isZip64() ) {\n+\t\t\treturn null;\n+\t\t}\n+\n+\t\t// The offset of the Zip64-End-of-Central-Directory-Record is found in the Zip64 locator at offset 8.\n+\t\t// That offset will not be correct if data (i.e. a script) has been attached in front of the archive.\n+\t\tlong zip64EoCDOffset = this.getLittleEndianValue( _zip64EoCDRLocator, ZIP64_LOCATOR_EOCD_OFFSET_OFFSET, 4);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "557cc66c2c7bbcbe803c2724e18ae288b8bbc2c1"}, "originalPosition": 265}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzU4Nzc5Nw==", "bodyText": "This should probably be made into a unit test, with the test JARs constructed by the test, or stored remotely.", "url": "https://github.com/OpenLiberty/open-liberty/pull/14827#discussion_r517587797", "createdAt": "2020-11-04T19:41:53Z", "author": {"login": "tbitonti"}, "path": "dev/com.ibm.ws.artifact.zip/src/com/ibm/ws/artifact/zip/internal/JavaArchive.java", "diffHunk": "@@ -0,0 +1,575 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 IBM Corporation and others.\n+ * All rights reserved. This program and the accompanying materials\n+ * are made available under the terms of the Eclipse Public License v1.0\n+ * which accompanies this distribution, and is available at\n+ * http://www.eclipse.org/legal/epl-v10.html\n+ *\n+ * Contributors:\n+ *     IBM Corporation - initial API and implementation\n+ *******************************************************************************\n+ *\n+ * The purpose of this class is to test if a Java archive is valid without actually reading the entire JAR.\n+ * This is especially useful in cases where the archive has a script attached at the front of the file.\n+ * Of course, this is more of a sanity check than a rigorous validation, which would require reading the whole file.\n+ * \n+ *     [ script ]                   <---- start of file  (optional)\n+ *     [ local file header 1 ]      <---- actual start of archive\n+ *     [ encryption header 1 ]\n+ *     [ file data 1 ]\n+ *     [ data descriptor 1 ]\n+ *     . \n+ *     .\n+ *     .\n+ *     [ local file header n ]\n+ *     [ encryption header n ]\n+ *     [ file data n ]\n+ *     [ data descriptor n ]\n+ *     [ archive decryption header ] \n+ *     [ archive extra data record ] \n+ *     [ central directory header 1 ]       <---- start of central directory\n+ *     .\n+ *     .\n+ *     .\n+ *     [ central directory header n ]\n+ *     [ zip64 end of central directory record ]\n+ *     [ zip64 end of central directory locator ] \n+ *     [ end of central directory record ]\n+ * \n+ *  The validation calculates the size of the last 4 records listed above (as well as doing some\n+ *  validation checks on the sizes and signatures) and then calculates the actual offset\n+ *  of the archive within the file (which will normally be 0).  The final step is to check\n+ *  the signature at the beginning of the archive.\n+ *  \n+ *  The actual archive offset is calculated :\n+ *  \n+ *    fileLength - eocdRecordSize - zip64RecLengths - CentralDirectorySize - offsetOfCentralDirectory\n+ *   \n+ *   Note the offsetOfCentralDirectory is relative to the beginning of the actual archive (not an offset  \n+ *   from the beginning of the file.)  Subtracting away all of the known pieces gives us the unknown \n+ *   piece which is the actual archive offset.\n+ *  \n+ */\n+\n+package com.ibm.ws.artifact.zip.internal;\n+\n+import java.io.IOException;\n+import java.io.RandomAccessFile;\n+import java.util.Arrays;\n+\n+public class JavaArchive {\n+    \n+    // EOCDR is End-of-Central-Directory-Record\n+\tprivate static final int EOCDR_MIN_SIZE = 22;\n+\tprivate static final int EOCDR_MAX_COMMENT_LEN = 0xFFFF;\n+\tprivate static final int EOCDR_MAX_SIZE = EOCDR_MIN_SIZE + EOCDR_MAX_COMMENT_LEN;\n+\tprivate static final int EOCDR_SIGNATURE = 0x504b0506; \n+\tprivate static final int EOCDR_TOTAL_ENTRIES_OFFSET = 10;\n+\tprivate static final int ZIP64_INDICATOR = 0xFFFF;               // Indicates Zip64 when found at offset EOCDR_TOTAL_ENTRIES_OFFSET \n+\tprivate static final int EOCDR_CENTRAL_DIR_SIZE_OFFSET = 12;     // Offset to size of central directory\n+\tprivate static final int EOCDR_CENTRAL_DIR_OFFSET = 16;          // Offset to central directory relative to beginning of archive\n+\tprivate static final int EOCDR_COMMENT_LENGTH_OFFSET = 20; \t     // Offset to comment length\n+\t\n+\t// ZIP64_EOCDR is Zip64-End-of-Central-Directory-Record\n+\tprivate static final int ZIP64_EOCDR_SIGNATURE = 0x504b0606;\n+\tprivate static final int ZIP64_EOCDR_MINIMUM_SIZE = 56;\n+\tprivate static final int ZIP64_EOCDR_HEADER_SIZE = 12;           // 4 bytes for the signature and 8 bytes for the length\n+\tprivate static final int ZIP64_EOCDR_SIZE_OFFSET = 4;            // The size at this offset is the size of the zip64 EOCDR minus 12. (Meaning it does NOT include the 12-byte header)\n+\tprivate static final int ZIP64_EOCDR_SIZE_FIELD_LENGTH = 8;      // Number of bytes for size field.\n+\n+\t// ZIP64_LOCATOR is Zip64-End-of-Central-Directory-Record-Locator\n+\tprivate static final int ZIP64_LOCATOR_SIGNATURE = 0x504b0607;\n+\tprivate static final int ZIP64_LOCATOR_SIZE = 20;                // Fixed size.\n+\tprivate static final int ZIP64_LOCATOR_EOCD_OFFSET_OFFSET = 8;   // Position in the locator of the offset of the Zip64-End-of-Central-Direcory-Record\n+\t\n+\tprivate static final int LOCAL_FILE_HEADER_SIGNATURE = 0x504b0304;\n+\tprivate static final int BLOCK_SIZE = 256;\n+\tprivate static final int FORWARD_BLOCK_SIZE = 8192;\n+\t\n+\t// Maximum amount of data (usually a script) that is allowed by this implementation to be \n+\t// attached to the beginning of the archive. This value may be increased, but it will \n+\t// increase the time it takes to fail when the zip is corrupted.\n+\tprivate static final int MAX_PREFIX_ALLOWED = 1024*1024*5;       \n+\t\n+\tprivate byte[] _endOfCentralDirectoryRecord; // Only the minimum size is stored.  Does not include the comment \n+\tprivate int    _eocdRecordSize;              // Actual size of End-of-Central-Directory-Record - including comment\n+\tprivate byte[] _zip64EoCDRLocator;           // 20 bytes;\n+\tprivate long   _zip64EoCDRLocatorOffset;     // Offset (from end of file) of the Zip64 Locator\n+\tprivate byte[] _zip64EoCDR;                  // Only the minimum size is stored.  Does not include any extra fields.  \n+\tprivate long   _zip64EoCDRecSize;            // Size of Zip64-End-of-Central-Directory-Record\n+    private String _archiveFileName;\n+\tprivate long   _fileLength;                  // Length of the archive file\n+\t\n+    JavaArchive(String archiveFileName) {\n+    \t_archiveFileName = archiveFileName;\n+    }\n+    \n+    public boolean isValid() {\n+    \t\n+    \ttry (  RandomAccessFile file = new RandomAccessFile(_archiveFileName, \"r\") ) {\n+\n+    \t\t_fileLength = file.length();\n+    \t\t_endOfCentralDirectoryRecord = getEndOfCentralDirectoryRecord(file);\n+    \t\t\n+    \t\tif ( isZip64() ) {\n+    \t\t   _zip64EoCDRLocator = getZip64EoCDLocator(file);\n+    \t\t   _zip64EoCDRLocatorOffset = _fileLength - _eocdRecordSize - ZIP64_LOCATOR_SIZE;\n+    \t\t   _zip64EoCDR = getZip64EndOfCentralDirectoryRecord(file);\n+    \t\t   _zip64EoCDRecSize = getZip64EoCDRecordSize( _zip64EoCDR, 0 );\n+    \t\t}\n+    \t\t\n+    \t\tint archiveOffset = (int)getActualArchiveOffset();\n+\n+    \t\tif (archiveStartsWithSignature(file, archiveOffset)) {\n+    \t\t\treturn true;\n+    \t\t} \n+\n+    \t} catch (Exception e) {\n+    \t\t//e.printStackTrace();\n+    \t}\n+\n+    \treturn false;\n+    }\n+    \n+    /**\n+     * Find the End-of-Central-Director-Record which is always at the end of the file.\n+     * It is usually 22 bytes but may contain a comment up to 64K in size.\n+     * Reads from the end of the file looking backwards for the EoCDR signature.\n+     * \n+     * The implementation reads the file in BLOCK_SIZE blocks from the end of the file\n+     * and searches each block.  Note that there is some overlap of the successive \n+     * blocks; EOCDR_MIN_SIZE bytes of overlap to be precise.  This is because the \n+     * record might start at the end of one block and finish in the next.\n+     * \n+     * @param file\n+     * @throws IOException\n+     */\n+\tprivate byte[] getEndOfCentralDirectoryRecord(RandomAccessFile file) throws IOException {\n+\t\t\n+\t\tbyte[] block = getBlockFromEndOfFile(file, BLOCK_SIZE);\n+\t\tint size = EOCDR_MIN_SIZE ;\n+\t\tint offset = block.length - size;\n+\t\tint offsetFromEnd = block.length - offset;   // offset from the end of the block (not the file)\n+\t\t\n+\t\tif ( block.length < EOCDR_MIN_SIZE ) {\n+\t\t\tthrow new IOException(\"Not a valid zip file.  Less than minimum required length.\");\n+\t\t}\n+\t\t\n+\t\t// We will only enter this loop if a comment is attached to the End-of-Central-Directory-Record\n+\t\t// ... or if the zip is invalid (doesn't have an End-of-Central-Directory-Record.\n+\t\t// Note that isValidEoCDRec must have EOCDR_MIN_SIZE available at the end of the block\n+\t\t// to avoid an exception because of a read past the end of the block.\n+\t\twhile ( !isValidEoCDRec( block, offset, size ) ) {\n+\t\t\tsize++;\n+\t\t\tif (size == 0xFFFF) {\n+\t\t\t\tint i = 0;\n+\t\t\t}\n+\t\t\toffsetFromEnd++;\n+\t\t\t \n+\t\t\tif ( size > EOCDR_MAX_SIZE || size > _fileLength ) {\n+\t\t\t\tthrow new IOException(\n+\t\t\t\t\t\t\"Cannot find central directory end record in zip\");\n+\t\t\t}\n+\t\t\t\n+\t\t\tif ( offsetFromEnd > block.length ) {\n+\n+\t\t\t\tblock = this.getBlockFromEndOfFile(file, size + BLOCK_SIZE - EOCDR_MIN_SIZE, BLOCK_SIZE);\n+\t\t\t\toffsetFromEnd = EOCDR_MIN_SIZE;\n+\t\t\t}\n+\t\t\toffset = block.length - offsetFromEnd;\t\t\t\n+\t\t}\n+\t\t\n+\t\t// Copy only the minimum end-of-central-directory-record, but record the actual size.  \n+\t\t// We don't need to store the comment, which could be up to 64k.\t\t\n+\t\t_eocdRecordSize = size;\n+\t\treturn Arrays.copyOfRange(block, offset, offset + EOCDR_MIN_SIZE ); \n+\t}\n+\t\n+//  Alternative implementation that avoids the overlapping blocks, but always reads to the end of\n+//  when retrieving a new block.  Thus the block size grows and can get quite large.\t\n+//\n+//\n+//\tprivate byte[] getEndOfCentralDirectoryRecord(RandomAccessFile file) throws IOException {\n+//\t\t\n+//\t\tbyte[] block = getBlockFromEndOfFile(file, BLOCK_SIZE);\n+//\t\tint blockLength = block.length;  // for debugging !!!!!!!!!!!!!!!!1\n+//\t\tint size = EOCDR_MIN_SIZE ;\n+//\t\tint offset = block.length - size;\n+//\t\t\n+//\t\tif ( block.length < EOCDR_MIN_SIZE ) {\n+//\t\t\tthrow new IOException(\"Not a valid zip file.  Less than minimum required length.\");\n+//\t\t}\n+//\t\t\n+//\t\t// We will only enter this loop if a comment is attached to the End-of-Central-Directory-Record\n+//\t\t// ... or if the zip is invalid (doesn't have an End-of-Central-Directory-Record.\n+//\t\twhile ( !isValidEoCDRec( block, offset, size ) ) {\n+//\t\t\tsize++;\n+//\t\t\tif ( size > block.length ) {\n+//\t\t\t\tif ( size >= EOCDR_MAX_SIZE || size > _fileLength ) {\n+//\t\t\t\t\tthrow new IOException(\n+//\t\t\t\t\t\t\t\"Cannot find central directory end record in zip\");\n+//\t\t\t\t}\n+//\t\t\t\tblock = this.getBlockFromEndOfFile(file, size + BLOCK_SIZE);\n+//\t\t\t}\n+//\t\t\tblockLength = block.length;\n+//\t\t\toffset = block.length - size;\n+//\t\t}\n+//\t\t\n+//\t\t// Copy only the minimum end-of-central-directory-record, but record the actual size.  \n+//\t\t// We don't need the comment, which could be up to 64k.\t\t\n+//\t\t_eocdRecordSize = size;\n+//\t\treturn Arrays.copyOfRange(block, offset, offset + EOCDR_MIN_SIZE ); \n+//\t}\n+\t\n+\t/**\n+\t * Get the 20-byte Zip64 Locator.  It must sit 20 bytes before the End-of-Central-Directory-Record.\n+\t * @param file the zip file\n+\t * @return\n+\t * @throws IOException\n+\t */\n+\tprivate byte[] getZip64EoCDLocator(RandomAccessFile file) throws IOException {\n+\n+\t\tif ( !isZip64() ) {\n+\t\t\treturn null;\n+\t\t}\n+\n+\t    byte[] block = getBlockFromEndOfFile(file, \n+\t    \t\t                             _eocdRecordSize + ZIP64_LOCATOR_SIZE, \n+\t    \t\t                             ZIP64_LOCATOR_SIZE);\t\n+\n+\t\tif ( !isValid_Zip64EoCDRLocator(block, 0)) {\n+\t\t\tthrow new IOException(\"Invalid Zip64-End-of-Central-Direcytory-Locator.\");\n+\t\t}\n+\n+\t\treturn Arrays.copyOfRange(block, 0, ZIP64_LOCATOR_SIZE);\n+\t}\n+\t\n+\t/**\n+\t * Locates the Zip64-End-of-Central-Directory-Record by using the offset \n+\t * in the Zip64 Locator.  If not found there, it is assumed that data has\n+\t * been prepended to the archive, and a forward search begins until we find the\n+\t * correct signature.  Of course, a false signature could appear just about  \n+\t * anywhere in the zip.  So the record must pass additional validation.\n+\t * @param file a zip file\n+\t * @return a copy of the Zip64-End-of-Central-Directory-Record\n+\t * @throws IOException\n+\t */\n+\tprivate byte[] getZip64EndOfCentralDirectoryRecord(RandomAccessFile file ) throws IOException {\n+\t\t\n+\t\tif ( !isZip64() ) {\n+\t\t\treturn null;\n+\t\t}\n+\n+\t\t// The offset of the Zip64-End-of-Central-Directory-Record is found in the Zip64 locator at offset 8.\n+\t\t// That offset will not be correct if data (i.e. a script) has been attached in front of the archive.\n+\t\tlong zip64EoCDOffset = this.getLittleEndianValue( _zip64EoCDRLocator, ZIP64_LOCATOR_EOCD_OFFSET_OFFSET, 4);\n+\t\t\n+\t\tbyte [] block = getBlockFromBeginningOfFile(file, zip64EoCDOffset, ZIP64_EOCDR_MINIMUM_SIZE);\n+\t\tif (block.length < ZIP64_EOCDR_MINIMUM_SIZE) {\n+\t\t\tthrow new IOException(\"Offset to Zip64-End-of-Central-Directory-Record does not correct.  Reached end of file.\");\n+\t\t}\n+\t\t\n+\t\tlong offsetFromBeginningOfFile = zip64EoCDOffset;\n+\t\tint offsetInBlock = 0;\n+\t\tint offsetFromStartingPoint = 0;   // The starting point is zip64EoCDOffset;\n+\n+\t\t// We will only enter this loop if data has been attached to the front of the archive (or if\n+\t\t// the archive is invalid.)  The loop searches forward in the file starting at the point where\n+\t\t// the Zip64 Locator indicates the Zip64-End-of-Central-Directory-Record should be.\n+\t\twhile ( !isValid_Zip64EoCDRecord( block, offsetInBlock, offsetFromBeginningOfFile ) ) {\n+\t\t\toffsetInBlock++;\n+\t\t\toffsetFromBeginningOfFile++;\n+\t\t\toffsetFromStartingPoint++;\n+\t\t\t\n+\t\t\t// An artificial limit is placed on the size of data allowed to be prepended to an archive.\n+\t\t\t// This is because this implementation searches through the file.  A fruitless search through\n+\t\t\t// a large file would cause an unacceptable delay if we did not set a limit.\n+\t\t\tif (offsetFromStartingPoint > MAX_PREFIX_ALLOWED) {\n+\t\t\t     throw new IOException(\"Failed to find the Zip64-End-of-Central-Directory-Record after searching \" + MAX_PREFIX_ALLOWED + \" bytes.\");\t\n+\t\t\t}\n+\t\t\t\n+\t\t\tif ( offsetInBlock > block.length - 4 ) {  // Must allow 4 bytes at end of block to read signature\n+\n+\t\t\t\tblock = getBlockFromBeginningOfFile(file, offsetFromBeginningOfFile, FORWARD_BLOCK_SIZE);\n+\t\t\t\tif (block.length < 4) {\n+\t\t\t\t\tthrow new IOException(\"Reached end of file while searching for to Zip64-End-of-Central-Directory-Record does not correct.\");\n+\t\t\t\t}\n+\t\t\t\toffsetInBlock = 0;\n+\t\t\t}\n+\t\t}\n+\n+\t\tif (block.length < (offsetInBlock + ZIP64_EOCDR_MINIMUM_SIZE ))  {\n+\t\t\tblock = getBlockFromBeginningOfFile(file, offsetFromBeginningOfFile, ZIP64_EOCDR_MINIMUM_SIZE);\n+\t\t    return  Arrays.copyOfRange(block, 0, ZIP64_EOCDR_MINIMUM_SIZE);\n+\t\t} \n+\t\t\n+\t\t// Only store the minimum size for this record.  We don't need to store any extra data.\n+\t\treturn Arrays.copyOfRange(block, offsetInBlock , offsetInBlock + ZIP64_EOCDR_MINIMUM_SIZE);\n+\t}\n+\t\n+\t/**\n+\t * @param file a zip file\n+\t * @param size number of bytes to read from end of file.\n+\t * @return byte[] an array of data of 'size' bytes from the end of the file\n+\t * @throws IOException\n+\t */\n+\tprivate byte[] getBlockFromEndOfFile(RandomAccessFile file, int size) throws IOException {\n+\n+\t\tint blockLength =  size >_fileLength ? (int)_fileLength : size;\n+\t\tlong offset = _fileLength - blockLength;\n+\n+\t\tfile.seek(offset);\n+\n+\t\tbyte[] bytes = new byte[blockLength];\n+\t\tfile.read(bytes, 0, blockLength );\n+\t\treturn bytes;\n+\t}\n+\t\n+\t/**\n+\t * \n+\t * @param file  a zip file\n+\t * @param offsetFromEnd Offset from end of file where reading begins\n+\t * @param size number of bytes of data to read\n+\t * @return Returns an array of 'size' bytes that starts from 'offsetFromEnd' of file.\n+\t * @throws IOException\n+\t */\n+\tprivate byte[] getBlockFromEndOfFile(RandomAccessFile file, int offsetFromEnd, int size) throws IOException {\n+\t\t\n+\t\t// Have offset from end.  Get offset from beginning.\n+\t\tlong offset = _fileLength >= offsetFromEnd ? _fileLength - offsetFromEnd : 0;\n+\n+\t\tfile.seek(offset);\n+\n+\t\tbyte[] bytes = new byte[size];\n+\t\tfile.read(bytes, 0, size );\n+\t\treturn bytes;\n+\t}\n+\n+\t/**\n+\t * \n+\t * @param file a zip file\n+\t * @param offset Position from beginning of file, where data is to be read\n+\t * @param size number of bytes to read\n+\t * @return Returns an array of size 'size' read from file beginning at 'offset'\n+\t * @throws IOException\n+\t */\n+\tprivate byte[] getBlockFromBeginningOfFile(RandomAccessFile file, long offset, int size) throws IOException {\n+\t\t\n+\t\tfile.seek(offset);\n+\n+\t\tbyte[] bytes = new byte[size];\n+\t\tfile.read(bytes, 0, size );\n+\t\treturn bytes;\t\n+\t}\n+\t\n+\t/** \n+\t * Test for valid signature and size.\n+\t * @return true if the offset points to a valid End-of-Central-Directory-Record within \"bytes\"\n+\t */\n+\tprivate boolean isValidEoCDRec(byte[] bytes, int offset, int centralDirEndRecSize) {\n+\t\tif ( !isSignature(bytes, offset, EOCDR_SIGNATURE) \n+\t\t\t || !isValidEoCDRecSize(bytes, offset + EOCDR_COMMENT_LENGTH_OFFSET, centralDirEndRecSize)) {\n+\t\t\treturn false;\n+\t\t}\n+        return true;\n+\t}\n+\t\n+\t/**\n+\t * \n+\t * @return true if the signature parameter matches the bytes at offset\n+\t */\n+\tprivate boolean isSignature(byte[] bytes, int offset, int signature) {\n+\n+\t\tlong value = getSignature(bytes, offset);\n+\n+\t\treturn (value == signature);\n+\t}\n+\t\n+\tprivate boolean isValidEoCDRecSize(byte[] bytes, int offset, int size) {\n+\t\t// Size of central directory must be the structure size + comment\n+\t\t// First put length in little endian form (reverse the bytes).\n+\t\tlong commentLength = getLittleEndianValue(bytes, offset, 2);\n+\t\treturn size == (EOCDR_MIN_SIZE + commentLength);\n+\t}\n+\t\n+\t/** \n+\t * @param bytes the data\n+\t * @param offsetInByteArray pointer to a possible Zip64-End-Of-Central-Directory-Record\n+\t * @return true if the offset points to a valid Zip64-End-of-Central-Directory-Record within \"bytes\"\n+\t */\n+\tprivate boolean isValid_Zip64EoCDRecord(byte[] bytes, int offsetInByteArray, long offsetInFile) {\n+\t\t\n+\t\tif ( !isSignature(bytes, offsetInByteArray, ZIP64_EOCDR_SIGNATURE)) {\n+\t\t\treturn false;\n+\t\t} \n+\t     \n+\t\tif ( !isValid_Zip64EoCDRecordSize(bytes, offsetInByteArray, offsetInFile) ) {\n+\t\t\treturn false;\n+\t\t}\n+\t\t\n+        return true;\n+\t}\n+\t\n+\tprivate boolean isValid_Zip64EoCDRLocator(byte[] bytes, int offset) {\n+\t\t// Calculate length of Ziop64-End-of-Central-Directory-Record\n+\t\t//int zipLocatorOffset = bytes.length - _eocdRecordSize - ZIP64_LOCATOR_SIZE;\n+\t\tif ( !isSignature(bytes, offset, ZIP64_LOCATOR_SIGNATURE)) {\n+           return false;\n+\t\t}\n+\t\treturn true;\n+\t}\n+\t\n+\t/**\n+\t * This method assumes you've already found a valid signature for the Zip64-End-Of-Central-Directory-Record.\n+\t * Of course, the signature might just randomly appear anywhere in the data.  So this method\n+\t * tests to see if the length field makes sense.\n+\t * @param bytes the data\n+\t * @param offsetInArray pointer to Zip64-End-Of-Central-Directory-Record in the data\n+\t * @return true if the size makes sense for a \n+\t */\n+\tprivate boolean isValid_Zip64EoCDRecordSize(byte[] bytes, int offsetInArray, long offsetInFile) {\n+\n+\t\tlong specifiedZip64EoCDRecSize = getZip64EoCDRecordSize( bytes, offsetInArray );\n+\n+\t\tif (specifiedZip64EoCDRecSize > (_fileLength - _eocdRecordSize - ZIP64_LOCATOR_SIZE)) {\n+\t\t\treturn false;\n+\t\t}\n+\t\t\n+\t\tlong calculatedZip64EoCDRecSize = _zip64EoCDRLocatorOffset - offsetInFile;\n+\n+\t\treturn (calculatedZip64EoCDRecSize == specifiedZip64EoCDRecSize);\n+\t}\n+\t\n+\t/**\n+\t * @param bytes\n+\t * @param offsetInArray pointer to Zip64-End-Of-Central-Directory-Record in the data\n+\t * @return\n+\t */\n+\tprivate long getZip64EoCDRecordSize(byte[] bytes, int offsetInArray ) {\n+\n+\t\tlong specifiedZip64EoCDRecSize = getLittleEndianValue(bytes, offsetInArray + ZIP64_EOCDR_SIZE_OFFSET, ZIP64_EOCDR_SIZE_FIELD_LENGTH);\n+\t\t\n+\t\t// The recorded size does not include the 12-byte header.   So let's add that\n+\t\treturn specifiedZip64EoCDRecSize + ZIP64_EOCDR_HEADER_SIZE;\n+\t}\n+\t\t\n+\t/**\n+\t * @param bytes   array of byte\n+\t * @param offset  beginning of value in array of bytes\n+\t * @param length  Must be <= 4\n+\t * @return the bytes at the offset in reversed order\n+\t */\n+\tprivate long getLittleEndianValue(byte[] bytes, int offset, int length) {\n+\t\tlong value = 0;\n+\t\tfor (int i = length - 1; i >= 0; i--) {\n+\t\t\tvalue = ((value << 8) | (bytes[offset + i] & 0xFF));\n+\t\t}\n+\t\treturn value;\n+\t}\n+\t\n+\t/**\n+\t * @return 4-byte signature using offset into byte array.\n+\t */\n+\tprivate long getSignature(byte[] bytes, int offset) {\n+\t\tlong value = 0;\n+\t\tfor (int i = 0; i < 4; i++) {\n+\t\t\tvalue = ((value << 8) | (bytes[offset + i] & 0xFF));\n+\t\t}\n+\t\treturn value;\n+\t}\n+\t\n+\t/**\n+\t * @return true if the \"total # of entries\" offset in the End-of-Central-Directory-Record contains 0xFFFF\n+\t */\n+\tprivate boolean isZip64() {\n+\t\treturn (int) getLittleEndianValue(_endOfCentralDirectoryRecord, EOCDR_TOTAL_ENTRIES_OFFSET, 2) == ZIP64_INDICATOR;\n+\t}\n+\t\n+\t/**\n+\t * Checks if the beginning of the actual archive, which might not be at the beginning of the\n+\t * file contains the appropriate local-file-header-signature\n+\t * @param file the zip file\n+\t * @param archiveOffset the offset to the beginning of the archive within the file (Usually 0, but data might be attached in front of the archive).\n+\t * @return true if valid\n+\t * @throws IOException\n+\t */\n+\tprivate boolean archiveStartsWithSignature(RandomAccessFile file, int archiveOffset) throws IOException {\n+\t\t\t\n+\t\tSystem.out.println(\"Archive offset is \" + archiveOffset);\n+\t\t\n+\t\tfile.seek(archiveOffset);\n+\t\tbyte[] localFileHeaderSigBytes = new byte[ 4];\n+\t\tfile.read(localFileHeaderSigBytes, 0, 4);\n+\t\t\n+\t\tif (isSignature(localFileHeaderSigBytes, 0, LOCAL_FILE_HEADER_SIGNATURE)) {\n+\t\t\treturn true;\n+\t\t}\n+\t\t\n+\t\treturn false;\n+\t}\n+\t\t\n+\t/**\n+\t * @return \t The location in the file where the archive actually starts. That will normally\n+\t * be 0, but often scripts are pre-pended to the archive; for example to make\n+\t * a self-extracting zip.\n+\t * @throws IOException\n+\t */\n+\tpublic long getActualArchiveOffset() throws IOException {\n+\t\t\n+\t\t// At offset 12 into the End-of-Central-Directory-Record is the size of the Central Directory \n+\t\tlong lengthOfCentralDirectory = getLittleEndianValue( _endOfCentralDirectoryRecord, EOCDR_CENTRAL_DIR_SIZE_OFFSET, 4 );\n+\t\t\n+\t\t// Offset 16 contains the relative offset from the beginning of the actual archive to the Central Directory\n+\t\tlong offsetOfCentralDirectory = getLittleEndianValue( _endOfCentralDirectoryRecord, EOCDR_CENTRAL_DIR_OFFSET, 4 );\n+\t\t\n+\t\tlong zip64RecLengths = isZip64() ? ( _zip64EoCDRecSize + ZIP64_LOCATOR_SIZE ) : 0;\n+\t\t\n+\t\treturn _fileLength - _eocdRecordSize - zip64RecLengths - lengthOfCentralDirectory - offsetOfCentralDirectory;\n+\t}\n+\t\n+\tpublic static void main(String[] args) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "557cc66c2c7bbcbe803c2724e18ae288b8bbc2c1"}, "originalPosition": 530}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzU4ODQ2OA==", "bodyText": "Does the JavaArchive need to be closed?", "url": "https://github.com/OpenLiberty/open-liberty/pull/14827#discussion_r517588468", "createdAt": "2020-11-04T19:43:12Z", "author": {"login": "tbitonti"}, "path": "dev/com.ibm.ws.artifact.zip/src/com/ibm/ws/artifact/zip/internal/ZipFileContainerFactory.java", "diffHunk": "@@ -352,7 +352,10 @@ private static boolean isZip(ArtifactEntry artifactEntry) {\n             try {\n                 ZipEntry entry = zipInputStream.getNextEntry();\n                 if ( entry == null ) {\n-                    Tr.error(tc, \"bad.zip.data\", getPhysicalPath(artifactEntry));\n+                    JavaArchive javaArchive = new JavaArchive(getPhysicalPath(artifactEntry));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "557cc66c2c7bbcbe803c2724e18ae288b8bbc2c1"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzU4ODgyNw==", "bodyText": "Same as above: Does the JavaArchive need to be closed?", "url": "https://github.com/OpenLiberty/open-liberty/pull/14827#discussion_r517588827", "createdAt": "2020-11-04T19:43:52Z", "author": {"login": "tbitonti"}, "path": "dev/com.ibm.ws.artifact.zip/src/com/ibm/ws/artifact/zip/internal/ZipFileContainerFactory.java", "diffHunk": "@@ -448,8 +451,11 @@ private static boolean isZip(File file) {\n             try {\n                 ZipEntry entry = zipInputStream.getNextEntry(); // throws IOException\n                 if ( entry == null ) {\n-                    Tr.error(tc, \"bad.zip.data\", file.getAbsolutePath());\n-                    return false;\n+                    JavaArchive javaArchive = new JavaArchive(file.getAbsolutePath());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "557cc66c2c7bbcbe803c2724e18ae288b8bbc2c1"}, "originalPosition": 18}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzU4OTQ3MA==", "bodyText": "Not sure about using the name \"JavaArchive': The target archive is a PK archive, and can be a plain ZIP file, which has nothing to do with java.", "url": "https://github.com/OpenLiberty/open-liberty/pull/14827#discussion_r517589470", "createdAt": "2020-11-04T19:44:54Z", "author": {"login": "tbitonti"}, "path": "dev/com.ibm.ws.artifact.zip/src/com/ibm/ws/artifact/zip/internal/JavaArchive.java", "diffHunk": "@@ -0,0 +1,575 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 IBM Corporation and others.\n+ * All rights reserved. This program and the accompanying materials\n+ * are made available under the terms of the Eclipse Public License v1.0\n+ * which accompanies this distribution, and is available at\n+ * http://www.eclipse.org/legal/epl-v10.html\n+ *\n+ * Contributors:\n+ *     IBM Corporation - initial API and implementation\n+ *******************************************************************************\n+ *\n+ * The purpose of this class is to test if a Java archive is valid without actually reading the entire JAR.\n+ * This is especially useful in cases where the archive has a script attached at the front of the file.\n+ * Of course, this is more of a sanity check than a rigorous validation, which would require reading the whole file.\n+ * \n+ *     [ script ]                   <---- start of file  (optional)\n+ *     [ local file header 1 ]      <---- actual start of archive\n+ *     [ encryption header 1 ]\n+ *     [ file data 1 ]\n+ *     [ data descriptor 1 ]\n+ *     . \n+ *     .\n+ *     .\n+ *     [ local file header n ]\n+ *     [ encryption header n ]\n+ *     [ file data n ]\n+ *     [ data descriptor n ]\n+ *     [ archive decryption header ] \n+ *     [ archive extra data record ] \n+ *     [ central directory header 1 ]       <---- start of central directory\n+ *     .\n+ *     .\n+ *     .\n+ *     [ central directory header n ]\n+ *     [ zip64 end of central directory record ]\n+ *     [ zip64 end of central directory locator ] \n+ *     [ end of central directory record ]\n+ * \n+ *  The validation calculates the size of the last 4 records listed above (as well as doing some\n+ *  validation checks on the sizes and signatures) and then calculates the actual offset\n+ *  of the archive within the file (which will normally be 0).  The final step is to check\n+ *  the signature at the beginning of the archive.\n+ *  \n+ *  The actual archive offset is calculated :\n+ *  \n+ *    fileLength - eocdRecordSize - zip64RecLengths - CentralDirectorySize - offsetOfCentralDirectory\n+ *   \n+ *   Note the offsetOfCentralDirectory is relative to the beginning of the actual archive (not an offset  \n+ *   from the beginning of the file.)  Subtracting away all of the known pieces gives us the unknown \n+ *   piece which is the actual archive offset.\n+ *  \n+ */\n+\n+package com.ibm.ws.artifact.zip.internal;\n+\n+import java.io.IOException;\n+import java.io.RandomAccessFile;\n+import java.util.Arrays;\n+\n+public class JavaArchive {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "557cc66c2c7bbcbe803c2724e18ae288b8bbc2c1"}, "originalPosition": 60}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzU5MTA5NQ==", "bodyText": "Hmm; run on exception text?", "url": "https://github.com/OpenLiberty/open-liberty/pull/14827#discussion_r517591095", "createdAt": "2020-11-04T19:47:48Z", "author": {"login": "tbitonti"}, "path": "dev/com.ibm.ws.artifact.zip/src/com/ibm/ws/artifact/zip/internal/JavaArchive.java", "diffHunk": "@@ -0,0 +1,575 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 IBM Corporation and others.\n+ * All rights reserved. This program and the accompanying materials\n+ * are made available under the terms of the Eclipse Public License v1.0\n+ * which accompanies this distribution, and is available at\n+ * http://www.eclipse.org/legal/epl-v10.html\n+ *\n+ * Contributors:\n+ *     IBM Corporation - initial API and implementation\n+ *******************************************************************************\n+ *\n+ * The purpose of this class is to test if a Java archive is valid without actually reading the entire JAR.\n+ * This is especially useful in cases where the archive has a script attached at the front of the file.\n+ * Of course, this is more of a sanity check than a rigorous validation, which would require reading the whole file.\n+ * \n+ *     [ script ]                   <---- start of file  (optional)\n+ *     [ local file header 1 ]      <---- actual start of archive\n+ *     [ encryption header 1 ]\n+ *     [ file data 1 ]\n+ *     [ data descriptor 1 ]\n+ *     . \n+ *     .\n+ *     .\n+ *     [ local file header n ]\n+ *     [ encryption header n ]\n+ *     [ file data n ]\n+ *     [ data descriptor n ]\n+ *     [ archive decryption header ] \n+ *     [ archive extra data record ] \n+ *     [ central directory header 1 ]       <---- start of central directory\n+ *     .\n+ *     .\n+ *     .\n+ *     [ central directory header n ]\n+ *     [ zip64 end of central directory record ]\n+ *     [ zip64 end of central directory locator ] \n+ *     [ end of central directory record ]\n+ * \n+ *  The validation calculates the size of the last 4 records listed above (as well as doing some\n+ *  validation checks on the sizes and signatures) and then calculates the actual offset\n+ *  of the archive within the file (which will normally be 0).  The final step is to check\n+ *  the signature at the beginning of the archive.\n+ *  \n+ *  The actual archive offset is calculated :\n+ *  \n+ *    fileLength - eocdRecordSize - zip64RecLengths - CentralDirectorySize - offsetOfCentralDirectory\n+ *   \n+ *   Note the offsetOfCentralDirectory is relative to the beginning of the actual archive (not an offset  \n+ *   from the beginning of the file.)  Subtracting away all of the known pieces gives us the unknown \n+ *   piece which is the actual archive offset.\n+ *  \n+ */\n+\n+package com.ibm.ws.artifact.zip.internal;\n+\n+import java.io.IOException;\n+import java.io.RandomAccessFile;\n+import java.util.Arrays;\n+\n+public class JavaArchive {\n+    \n+    // EOCDR is End-of-Central-Directory-Record\n+\tprivate static final int EOCDR_MIN_SIZE = 22;\n+\tprivate static final int EOCDR_MAX_COMMENT_LEN = 0xFFFF;\n+\tprivate static final int EOCDR_MAX_SIZE = EOCDR_MIN_SIZE + EOCDR_MAX_COMMENT_LEN;\n+\tprivate static final int EOCDR_SIGNATURE = 0x504b0506; \n+\tprivate static final int EOCDR_TOTAL_ENTRIES_OFFSET = 10;\n+\tprivate static final int ZIP64_INDICATOR = 0xFFFF;               // Indicates Zip64 when found at offset EOCDR_TOTAL_ENTRIES_OFFSET \n+\tprivate static final int EOCDR_CENTRAL_DIR_SIZE_OFFSET = 12;     // Offset to size of central directory\n+\tprivate static final int EOCDR_CENTRAL_DIR_OFFSET = 16;          // Offset to central directory relative to beginning of archive\n+\tprivate static final int EOCDR_COMMENT_LENGTH_OFFSET = 20; \t     // Offset to comment length\n+\t\n+\t// ZIP64_EOCDR is Zip64-End-of-Central-Directory-Record\n+\tprivate static final int ZIP64_EOCDR_SIGNATURE = 0x504b0606;\n+\tprivate static final int ZIP64_EOCDR_MINIMUM_SIZE = 56;\n+\tprivate static final int ZIP64_EOCDR_HEADER_SIZE = 12;           // 4 bytes for the signature and 8 bytes for the length\n+\tprivate static final int ZIP64_EOCDR_SIZE_OFFSET = 4;            // The size at this offset is the size of the zip64 EOCDR minus 12. (Meaning it does NOT include the 12-byte header)\n+\tprivate static final int ZIP64_EOCDR_SIZE_FIELD_LENGTH = 8;      // Number of bytes for size field.\n+\n+\t// ZIP64_LOCATOR is Zip64-End-of-Central-Directory-Record-Locator\n+\tprivate static final int ZIP64_LOCATOR_SIGNATURE = 0x504b0607;\n+\tprivate static final int ZIP64_LOCATOR_SIZE = 20;                // Fixed size.\n+\tprivate static final int ZIP64_LOCATOR_EOCD_OFFSET_OFFSET = 8;   // Position in the locator of the offset of the Zip64-End-of-Central-Direcory-Record\n+\t\n+\tprivate static final int LOCAL_FILE_HEADER_SIGNATURE = 0x504b0304;\n+\tprivate static final int BLOCK_SIZE = 256;\n+\tprivate static final int FORWARD_BLOCK_SIZE = 8192;\n+\t\n+\t// Maximum amount of data (usually a script) that is allowed by this implementation to be \n+\t// attached to the beginning of the archive. This value may be increased, but it will \n+\t// increase the time it takes to fail when the zip is corrupted.\n+\tprivate static final int MAX_PREFIX_ALLOWED = 1024*1024*5;       \n+\t\n+\tprivate byte[] _endOfCentralDirectoryRecord; // Only the minimum size is stored.  Does not include the comment \n+\tprivate int    _eocdRecordSize;              // Actual size of End-of-Central-Directory-Record - including comment\n+\tprivate byte[] _zip64EoCDRLocator;           // 20 bytes;\n+\tprivate long   _zip64EoCDRLocatorOffset;     // Offset (from end of file) of the Zip64 Locator\n+\tprivate byte[] _zip64EoCDR;                  // Only the minimum size is stored.  Does not include any extra fields.  \n+\tprivate long   _zip64EoCDRecSize;            // Size of Zip64-End-of-Central-Directory-Record\n+    private String _archiveFileName;\n+\tprivate long   _fileLength;                  // Length of the archive file\n+\t\n+    JavaArchive(String archiveFileName) {\n+    \t_archiveFileName = archiveFileName;\n+    }\n+    \n+    public boolean isValid() {\n+    \t\n+    \ttry (  RandomAccessFile file = new RandomAccessFile(_archiveFileName, \"r\") ) {\n+\n+    \t\t_fileLength = file.length();\n+    \t\t_endOfCentralDirectoryRecord = getEndOfCentralDirectoryRecord(file);\n+    \t\t\n+    \t\tif ( isZip64() ) {\n+    \t\t   _zip64EoCDRLocator = getZip64EoCDLocator(file);\n+    \t\t   _zip64EoCDRLocatorOffset = _fileLength - _eocdRecordSize - ZIP64_LOCATOR_SIZE;\n+    \t\t   _zip64EoCDR = getZip64EndOfCentralDirectoryRecord(file);\n+    \t\t   _zip64EoCDRecSize = getZip64EoCDRecordSize( _zip64EoCDR, 0 );\n+    \t\t}\n+    \t\t\n+    \t\tint archiveOffset = (int)getActualArchiveOffset();\n+\n+    \t\tif (archiveStartsWithSignature(file, archiveOffset)) {\n+    \t\t\treturn true;\n+    \t\t} \n+\n+    \t} catch (Exception e) {\n+    \t\t//e.printStackTrace();\n+    \t}\n+\n+    \treturn false;\n+    }\n+    \n+    /**\n+     * Find the End-of-Central-Director-Record which is always at the end of the file.\n+     * It is usually 22 bytes but may contain a comment up to 64K in size.\n+     * Reads from the end of the file looking backwards for the EoCDR signature.\n+     * \n+     * The implementation reads the file in BLOCK_SIZE blocks from the end of the file\n+     * and searches each block.  Note that there is some overlap of the successive \n+     * blocks; EOCDR_MIN_SIZE bytes of overlap to be precise.  This is because the \n+     * record might start at the end of one block and finish in the next.\n+     * \n+     * @param file\n+     * @throws IOException\n+     */\n+\tprivate byte[] getEndOfCentralDirectoryRecord(RandomAccessFile file) throws IOException {\n+\t\t\n+\t\tbyte[] block = getBlockFromEndOfFile(file, BLOCK_SIZE);\n+\t\tint size = EOCDR_MIN_SIZE ;\n+\t\tint offset = block.length - size;\n+\t\tint offsetFromEnd = block.length - offset;   // offset from the end of the block (not the file)\n+\t\t\n+\t\tif ( block.length < EOCDR_MIN_SIZE ) {\n+\t\t\tthrow new IOException(\"Not a valid zip file.  Less than minimum required length.\");\n+\t\t}\n+\t\t\n+\t\t// We will only enter this loop if a comment is attached to the End-of-Central-Directory-Record\n+\t\t// ... or if the zip is invalid (doesn't have an End-of-Central-Directory-Record.\n+\t\t// Note that isValidEoCDRec must have EOCDR_MIN_SIZE available at the end of the block\n+\t\t// to avoid an exception because of a read past the end of the block.\n+\t\twhile ( !isValidEoCDRec( block, offset, size ) ) {\n+\t\t\tsize++;\n+\t\t\tif (size == 0xFFFF) {\n+\t\t\t\tint i = 0;\n+\t\t\t}\n+\t\t\toffsetFromEnd++;\n+\t\t\t \n+\t\t\tif ( size > EOCDR_MAX_SIZE || size > _fileLength ) {\n+\t\t\t\tthrow new IOException(\n+\t\t\t\t\t\t\"Cannot find central directory end record in zip\");\n+\t\t\t}\n+\t\t\t\n+\t\t\tif ( offsetFromEnd > block.length ) {\n+\n+\t\t\t\tblock = this.getBlockFromEndOfFile(file, size + BLOCK_SIZE - EOCDR_MIN_SIZE, BLOCK_SIZE);\n+\t\t\t\toffsetFromEnd = EOCDR_MIN_SIZE;\n+\t\t\t}\n+\t\t\toffset = block.length - offsetFromEnd;\t\t\t\n+\t\t}\n+\t\t\n+\t\t// Copy only the minimum end-of-central-directory-record, but record the actual size.  \n+\t\t// We don't need to store the comment, which could be up to 64k.\t\t\n+\t\t_eocdRecordSize = size;\n+\t\treturn Arrays.copyOfRange(block, offset, offset + EOCDR_MIN_SIZE ); \n+\t}\n+\t\n+//  Alternative implementation that avoids the overlapping blocks, but always reads to the end of\n+//  when retrieving a new block.  Thus the block size grows and can get quite large.\t\n+//\n+//\n+//\tprivate byte[] getEndOfCentralDirectoryRecord(RandomAccessFile file) throws IOException {\n+//\t\t\n+//\t\tbyte[] block = getBlockFromEndOfFile(file, BLOCK_SIZE);\n+//\t\tint blockLength = block.length;  // for debugging !!!!!!!!!!!!!!!!1\n+//\t\tint size = EOCDR_MIN_SIZE ;\n+//\t\tint offset = block.length - size;\n+//\t\t\n+//\t\tif ( block.length < EOCDR_MIN_SIZE ) {\n+//\t\t\tthrow new IOException(\"Not a valid zip file.  Less than minimum required length.\");\n+//\t\t}\n+//\t\t\n+//\t\t// We will only enter this loop if a comment is attached to the End-of-Central-Directory-Record\n+//\t\t// ... or if the zip is invalid (doesn't have an End-of-Central-Directory-Record.\n+//\t\twhile ( !isValidEoCDRec( block, offset, size ) ) {\n+//\t\t\tsize++;\n+//\t\t\tif ( size > block.length ) {\n+//\t\t\t\tif ( size >= EOCDR_MAX_SIZE || size > _fileLength ) {\n+//\t\t\t\t\tthrow new IOException(\n+//\t\t\t\t\t\t\t\"Cannot find central directory end record in zip\");\n+//\t\t\t\t}\n+//\t\t\t\tblock = this.getBlockFromEndOfFile(file, size + BLOCK_SIZE);\n+//\t\t\t}\n+//\t\t\tblockLength = block.length;\n+//\t\t\toffset = block.length - size;\n+//\t\t}\n+//\t\t\n+//\t\t// Copy only the minimum end-of-central-directory-record, but record the actual size.  \n+//\t\t// We don't need the comment, which could be up to 64k.\t\t\n+//\t\t_eocdRecordSize = size;\n+//\t\treturn Arrays.copyOfRange(block, offset, offset + EOCDR_MIN_SIZE ); \n+//\t}\n+\t\n+\t/**\n+\t * Get the 20-byte Zip64 Locator.  It must sit 20 bytes before the End-of-Central-Directory-Record.\n+\t * @param file the zip file\n+\t * @return\n+\t * @throws IOException\n+\t */\n+\tprivate byte[] getZip64EoCDLocator(RandomAccessFile file) throws IOException {\n+\n+\t\tif ( !isZip64() ) {\n+\t\t\treturn null;\n+\t\t}\n+\n+\t    byte[] block = getBlockFromEndOfFile(file, \n+\t    \t\t                             _eocdRecordSize + ZIP64_LOCATOR_SIZE, \n+\t    \t\t                             ZIP64_LOCATOR_SIZE);\t\n+\n+\t\tif ( !isValid_Zip64EoCDRLocator(block, 0)) {\n+\t\t\tthrow new IOException(\"Invalid Zip64-End-of-Central-Direcytory-Locator.\");\n+\t\t}\n+\n+\t\treturn Arrays.copyOfRange(block, 0, ZIP64_LOCATOR_SIZE);\n+\t}\n+\t\n+\t/**\n+\t * Locates the Zip64-End-of-Central-Directory-Record by using the offset \n+\t * in the Zip64 Locator.  If not found there, it is assumed that data has\n+\t * been prepended to the archive, and a forward search begins until we find the\n+\t * correct signature.  Of course, a false signature could appear just about  \n+\t * anywhere in the zip.  So the record must pass additional validation.\n+\t * @param file a zip file\n+\t * @return a copy of the Zip64-End-of-Central-Directory-Record\n+\t * @throws IOException\n+\t */\n+\tprivate byte[] getZip64EndOfCentralDirectoryRecord(RandomAccessFile file ) throws IOException {\n+\t\t\n+\t\tif ( !isZip64() ) {\n+\t\t\treturn null;\n+\t\t}\n+\n+\t\t// The offset of the Zip64-End-of-Central-Directory-Record is found in the Zip64 locator at offset 8.\n+\t\t// That offset will not be correct if data (i.e. a script) has been attached in front of the archive.\n+\t\tlong zip64EoCDOffset = this.getLittleEndianValue( _zip64EoCDRLocator, ZIP64_LOCATOR_EOCD_OFFSET_OFFSET, 4);\n+\t\t\n+\t\tbyte [] block = getBlockFromBeginningOfFile(file, zip64EoCDOffset, ZIP64_EOCDR_MINIMUM_SIZE);\n+\t\tif (block.length < ZIP64_EOCDR_MINIMUM_SIZE) {\n+\t\t\tthrow new IOException(\"Offset to Zip64-End-of-Central-Directory-Record does not correct.  Reached end of file.\");\n+\t\t}\n+\t\t\n+\t\tlong offsetFromBeginningOfFile = zip64EoCDOffset;\n+\t\tint offsetInBlock = 0;\n+\t\tint offsetFromStartingPoint = 0;   // The starting point is zip64EoCDOffset;\n+\n+\t\t// We will only enter this loop if data has been attached to the front of the archive (or if\n+\t\t// the archive is invalid.)  The loop searches forward in the file starting at the point where\n+\t\t// the Zip64 Locator indicates the Zip64-End-of-Central-Directory-Record should be.\n+\t\twhile ( !isValid_Zip64EoCDRecord( block, offsetInBlock, offsetFromBeginningOfFile ) ) {\n+\t\t\toffsetInBlock++;\n+\t\t\toffsetFromBeginningOfFile++;\n+\t\t\toffsetFromStartingPoint++;\n+\t\t\t\n+\t\t\t// An artificial limit is placed on the size of data allowed to be prepended to an archive.\n+\t\t\t// This is because this implementation searches through the file.  A fruitless search through\n+\t\t\t// a large file would cause an unacceptable delay if we did not set a limit.\n+\t\t\tif (offsetFromStartingPoint > MAX_PREFIX_ALLOWED) {\n+\t\t\t     throw new IOException(\"Failed to find the Zip64-End-of-Central-Directory-Record after searching \" + MAX_PREFIX_ALLOWED + \" bytes.\");\t\n+\t\t\t}\n+\t\t\t\n+\t\t\tif ( offsetInBlock > block.length - 4 ) {  // Must allow 4 bytes at end of block to read signature\n+\n+\t\t\t\tblock = getBlockFromBeginningOfFile(file, offsetFromBeginningOfFile, FORWARD_BLOCK_SIZE);\n+\t\t\t\tif (block.length < 4) {\n+\t\t\t\t\tthrow new IOException(\"Reached end of file while searching for to Zip64-End-of-Central-Directory-Record does not correct.\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "557cc66c2c7bbcbe803c2724e18ae288b8bbc2c1"}, "originalPosition": 295}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzU5MjMwNg==", "bodyText": "For better performance, the block can be allocated outside of the method, and reused when there are several calls.  But, since this code is a very rare case, that level of optimization doesn't seem necessary.", "url": "https://github.com/OpenLiberty/open-liberty/pull/14827#discussion_r517592306", "createdAt": "2020-11-04T19:50:06Z", "author": {"login": "tbitonti"}, "path": "dev/com.ibm.ws.artifact.zip/src/com/ibm/ws/artifact/zip/internal/JavaArchive.java", "diffHunk": "@@ -0,0 +1,575 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 IBM Corporation and others.\n+ * All rights reserved. This program and the accompanying materials\n+ * are made available under the terms of the Eclipse Public License v1.0\n+ * which accompanies this distribution, and is available at\n+ * http://www.eclipse.org/legal/epl-v10.html\n+ *\n+ * Contributors:\n+ *     IBM Corporation - initial API and implementation\n+ *******************************************************************************\n+ *\n+ * The purpose of this class is to test if a Java archive is valid without actually reading the entire JAR.\n+ * This is especially useful in cases where the archive has a script attached at the front of the file.\n+ * Of course, this is more of a sanity check than a rigorous validation, which would require reading the whole file.\n+ * \n+ *     [ script ]                   <---- start of file  (optional)\n+ *     [ local file header 1 ]      <---- actual start of archive\n+ *     [ encryption header 1 ]\n+ *     [ file data 1 ]\n+ *     [ data descriptor 1 ]\n+ *     . \n+ *     .\n+ *     .\n+ *     [ local file header n ]\n+ *     [ encryption header n ]\n+ *     [ file data n ]\n+ *     [ data descriptor n ]\n+ *     [ archive decryption header ] \n+ *     [ archive extra data record ] \n+ *     [ central directory header 1 ]       <---- start of central directory\n+ *     .\n+ *     .\n+ *     .\n+ *     [ central directory header n ]\n+ *     [ zip64 end of central directory record ]\n+ *     [ zip64 end of central directory locator ] \n+ *     [ end of central directory record ]\n+ * \n+ *  The validation calculates the size of the last 4 records listed above (as well as doing some\n+ *  validation checks on the sizes and signatures) and then calculates the actual offset\n+ *  of the archive within the file (which will normally be 0).  The final step is to check\n+ *  the signature at the beginning of the archive.\n+ *  \n+ *  The actual archive offset is calculated :\n+ *  \n+ *    fileLength - eocdRecordSize - zip64RecLengths - CentralDirectorySize - offsetOfCentralDirectory\n+ *   \n+ *   Note the offsetOfCentralDirectory is relative to the beginning of the actual archive (not an offset  \n+ *   from the beginning of the file.)  Subtracting away all of the known pieces gives us the unknown \n+ *   piece which is the actual archive offset.\n+ *  \n+ */\n+\n+package com.ibm.ws.artifact.zip.internal;\n+\n+import java.io.IOException;\n+import java.io.RandomAccessFile;\n+import java.util.Arrays;\n+\n+public class JavaArchive {\n+    \n+    // EOCDR is End-of-Central-Directory-Record\n+\tprivate static final int EOCDR_MIN_SIZE = 22;\n+\tprivate static final int EOCDR_MAX_COMMENT_LEN = 0xFFFF;\n+\tprivate static final int EOCDR_MAX_SIZE = EOCDR_MIN_SIZE + EOCDR_MAX_COMMENT_LEN;\n+\tprivate static final int EOCDR_SIGNATURE = 0x504b0506; \n+\tprivate static final int EOCDR_TOTAL_ENTRIES_OFFSET = 10;\n+\tprivate static final int ZIP64_INDICATOR = 0xFFFF;               // Indicates Zip64 when found at offset EOCDR_TOTAL_ENTRIES_OFFSET \n+\tprivate static final int EOCDR_CENTRAL_DIR_SIZE_OFFSET = 12;     // Offset to size of central directory\n+\tprivate static final int EOCDR_CENTRAL_DIR_OFFSET = 16;          // Offset to central directory relative to beginning of archive\n+\tprivate static final int EOCDR_COMMENT_LENGTH_OFFSET = 20; \t     // Offset to comment length\n+\t\n+\t// ZIP64_EOCDR is Zip64-End-of-Central-Directory-Record\n+\tprivate static final int ZIP64_EOCDR_SIGNATURE = 0x504b0606;\n+\tprivate static final int ZIP64_EOCDR_MINIMUM_SIZE = 56;\n+\tprivate static final int ZIP64_EOCDR_HEADER_SIZE = 12;           // 4 bytes for the signature and 8 bytes for the length\n+\tprivate static final int ZIP64_EOCDR_SIZE_OFFSET = 4;            // The size at this offset is the size of the zip64 EOCDR minus 12. (Meaning it does NOT include the 12-byte header)\n+\tprivate static final int ZIP64_EOCDR_SIZE_FIELD_LENGTH = 8;      // Number of bytes for size field.\n+\n+\t// ZIP64_LOCATOR is Zip64-End-of-Central-Directory-Record-Locator\n+\tprivate static final int ZIP64_LOCATOR_SIGNATURE = 0x504b0607;\n+\tprivate static final int ZIP64_LOCATOR_SIZE = 20;                // Fixed size.\n+\tprivate static final int ZIP64_LOCATOR_EOCD_OFFSET_OFFSET = 8;   // Position in the locator of the offset of the Zip64-End-of-Central-Direcory-Record\n+\t\n+\tprivate static final int LOCAL_FILE_HEADER_SIGNATURE = 0x504b0304;\n+\tprivate static final int BLOCK_SIZE = 256;\n+\tprivate static final int FORWARD_BLOCK_SIZE = 8192;\n+\t\n+\t// Maximum amount of data (usually a script) that is allowed by this implementation to be \n+\t// attached to the beginning of the archive. This value may be increased, but it will \n+\t// increase the time it takes to fail when the zip is corrupted.\n+\tprivate static final int MAX_PREFIX_ALLOWED = 1024*1024*5;       \n+\t\n+\tprivate byte[] _endOfCentralDirectoryRecord; // Only the minimum size is stored.  Does not include the comment \n+\tprivate int    _eocdRecordSize;              // Actual size of End-of-Central-Directory-Record - including comment\n+\tprivate byte[] _zip64EoCDRLocator;           // 20 bytes;\n+\tprivate long   _zip64EoCDRLocatorOffset;     // Offset (from end of file) of the Zip64 Locator\n+\tprivate byte[] _zip64EoCDR;                  // Only the minimum size is stored.  Does not include any extra fields.  \n+\tprivate long   _zip64EoCDRecSize;            // Size of Zip64-End-of-Central-Directory-Record\n+    private String _archiveFileName;\n+\tprivate long   _fileLength;                  // Length of the archive file\n+\t\n+    JavaArchive(String archiveFileName) {\n+    \t_archiveFileName = archiveFileName;\n+    }\n+    \n+    public boolean isValid() {\n+    \t\n+    \ttry (  RandomAccessFile file = new RandomAccessFile(_archiveFileName, \"r\") ) {\n+\n+    \t\t_fileLength = file.length();\n+    \t\t_endOfCentralDirectoryRecord = getEndOfCentralDirectoryRecord(file);\n+    \t\t\n+    \t\tif ( isZip64() ) {\n+    \t\t   _zip64EoCDRLocator = getZip64EoCDLocator(file);\n+    \t\t   _zip64EoCDRLocatorOffset = _fileLength - _eocdRecordSize - ZIP64_LOCATOR_SIZE;\n+    \t\t   _zip64EoCDR = getZip64EndOfCentralDirectoryRecord(file);\n+    \t\t   _zip64EoCDRecSize = getZip64EoCDRecordSize( _zip64EoCDR, 0 );\n+    \t\t}\n+    \t\t\n+    \t\tint archiveOffset = (int)getActualArchiveOffset();\n+\n+    \t\tif (archiveStartsWithSignature(file, archiveOffset)) {\n+    \t\t\treturn true;\n+    \t\t} \n+\n+    \t} catch (Exception e) {\n+    \t\t//e.printStackTrace();\n+    \t}\n+\n+    \treturn false;\n+    }\n+    \n+    /**\n+     * Find the End-of-Central-Director-Record which is always at the end of the file.\n+     * It is usually 22 bytes but may contain a comment up to 64K in size.\n+     * Reads from the end of the file looking backwards for the EoCDR signature.\n+     * \n+     * The implementation reads the file in BLOCK_SIZE blocks from the end of the file\n+     * and searches each block.  Note that there is some overlap of the successive \n+     * blocks; EOCDR_MIN_SIZE bytes of overlap to be precise.  This is because the \n+     * record might start at the end of one block and finish in the next.\n+     * \n+     * @param file\n+     * @throws IOException\n+     */\n+\tprivate byte[] getEndOfCentralDirectoryRecord(RandomAccessFile file) throws IOException {\n+\t\t\n+\t\tbyte[] block = getBlockFromEndOfFile(file, BLOCK_SIZE);\n+\t\tint size = EOCDR_MIN_SIZE ;\n+\t\tint offset = block.length - size;\n+\t\tint offsetFromEnd = block.length - offset;   // offset from the end of the block (not the file)\n+\t\t\n+\t\tif ( block.length < EOCDR_MIN_SIZE ) {\n+\t\t\tthrow new IOException(\"Not a valid zip file.  Less than minimum required length.\");\n+\t\t}\n+\t\t\n+\t\t// We will only enter this loop if a comment is attached to the End-of-Central-Directory-Record\n+\t\t// ... or if the zip is invalid (doesn't have an End-of-Central-Directory-Record.\n+\t\t// Note that isValidEoCDRec must have EOCDR_MIN_SIZE available at the end of the block\n+\t\t// to avoid an exception because of a read past the end of the block.\n+\t\twhile ( !isValidEoCDRec( block, offset, size ) ) {\n+\t\t\tsize++;\n+\t\t\tif (size == 0xFFFF) {\n+\t\t\t\tint i = 0;\n+\t\t\t}\n+\t\t\toffsetFromEnd++;\n+\t\t\t \n+\t\t\tif ( size > EOCDR_MAX_SIZE || size > _fileLength ) {\n+\t\t\t\tthrow new IOException(\n+\t\t\t\t\t\t\"Cannot find central directory end record in zip\");\n+\t\t\t}\n+\t\t\t\n+\t\t\tif ( offsetFromEnd > block.length ) {\n+\n+\t\t\t\tblock = this.getBlockFromEndOfFile(file, size + BLOCK_SIZE - EOCDR_MIN_SIZE, BLOCK_SIZE);\n+\t\t\t\toffsetFromEnd = EOCDR_MIN_SIZE;\n+\t\t\t}\n+\t\t\toffset = block.length - offsetFromEnd;\t\t\t\n+\t\t}\n+\t\t\n+\t\t// Copy only the minimum end-of-central-directory-record, but record the actual size.  \n+\t\t// We don't need to store the comment, which could be up to 64k.\t\t\n+\t\t_eocdRecordSize = size;\n+\t\treturn Arrays.copyOfRange(block, offset, offset + EOCDR_MIN_SIZE ); \n+\t}\n+\t\n+//  Alternative implementation that avoids the overlapping blocks, but always reads to the end of\n+//  when retrieving a new block.  Thus the block size grows and can get quite large.\t\n+//\n+//\n+//\tprivate byte[] getEndOfCentralDirectoryRecord(RandomAccessFile file) throws IOException {\n+//\t\t\n+//\t\tbyte[] block = getBlockFromEndOfFile(file, BLOCK_SIZE);\n+//\t\tint blockLength = block.length;  // for debugging !!!!!!!!!!!!!!!!1\n+//\t\tint size = EOCDR_MIN_SIZE ;\n+//\t\tint offset = block.length - size;\n+//\t\t\n+//\t\tif ( block.length < EOCDR_MIN_SIZE ) {\n+//\t\t\tthrow new IOException(\"Not a valid zip file.  Less than minimum required length.\");\n+//\t\t}\n+//\t\t\n+//\t\t// We will only enter this loop if a comment is attached to the End-of-Central-Directory-Record\n+//\t\t// ... or if the zip is invalid (doesn't have an End-of-Central-Directory-Record.\n+//\t\twhile ( !isValidEoCDRec( block, offset, size ) ) {\n+//\t\t\tsize++;\n+//\t\t\tif ( size > block.length ) {\n+//\t\t\t\tif ( size >= EOCDR_MAX_SIZE || size > _fileLength ) {\n+//\t\t\t\t\tthrow new IOException(\n+//\t\t\t\t\t\t\t\"Cannot find central directory end record in zip\");\n+//\t\t\t\t}\n+//\t\t\t\tblock = this.getBlockFromEndOfFile(file, size + BLOCK_SIZE);\n+//\t\t\t}\n+//\t\t\tblockLength = block.length;\n+//\t\t\toffset = block.length - size;\n+//\t\t}\n+//\t\t\n+//\t\t// Copy only the minimum end-of-central-directory-record, but record the actual size.  \n+//\t\t// We don't need the comment, which could be up to 64k.\t\t\n+//\t\t_eocdRecordSize = size;\n+//\t\treturn Arrays.copyOfRange(block, offset, offset + EOCDR_MIN_SIZE ); \n+//\t}\n+\t\n+\t/**\n+\t * Get the 20-byte Zip64 Locator.  It must sit 20 bytes before the End-of-Central-Directory-Record.\n+\t * @param file the zip file\n+\t * @return\n+\t * @throws IOException\n+\t */\n+\tprivate byte[] getZip64EoCDLocator(RandomAccessFile file) throws IOException {\n+\n+\t\tif ( !isZip64() ) {\n+\t\t\treturn null;\n+\t\t}\n+\n+\t    byte[] block = getBlockFromEndOfFile(file, \n+\t    \t\t                             _eocdRecordSize + ZIP64_LOCATOR_SIZE, \n+\t    \t\t                             ZIP64_LOCATOR_SIZE);\t\n+\n+\t\tif ( !isValid_Zip64EoCDRLocator(block, 0)) {\n+\t\t\tthrow new IOException(\"Invalid Zip64-End-of-Central-Direcytory-Locator.\");\n+\t\t}\n+\n+\t\treturn Arrays.copyOfRange(block, 0, ZIP64_LOCATOR_SIZE);\n+\t}\n+\t\n+\t/**\n+\t * Locates the Zip64-End-of-Central-Directory-Record by using the offset \n+\t * in the Zip64 Locator.  If not found there, it is assumed that data has\n+\t * been prepended to the archive, and a forward search begins until we find the\n+\t * correct signature.  Of course, a false signature could appear just about  \n+\t * anywhere in the zip.  So the record must pass additional validation.\n+\t * @param file a zip file\n+\t * @return a copy of the Zip64-End-of-Central-Directory-Record\n+\t * @throws IOException\n+\t */\n+\tprivate byte[] getZip64EndOfCentralDirectoryRecord(RandomAccessFile file ) throws IOException {\n+\t\t\n+\t\tif ( !isZip64() ) {\n+\t\t\treturn null;\n+\t\t}\n+\n+\t\t// The offset of the Zip64-End-of-Central-Directory-Record is found in the Zip64 locator at offset 8.\n+\t\t// That offset will not be correct if data (i.e. a script) has been attached in front of the archive.\n+\t\tlong zip64EoCDOffset = this.getLittleEndianValue( _zip64EoCDRLocator, ZIP64_LOCATOR_EOCD_OFFSET_OFFSET, 4);\n+\t\t\n+\t\tbyte [] block = getBlockFromBeginningOfFile(file, zip64EoCDOffset, ZIP64_EOCDR_MINIMUM_SIZE);\n+\t\tif (block.length < ZIP64_EOCDR_MINIMUM_SIZE) {\n+\t\t\tthrow new IOException(\"Offset to Zip64-End-of-Central-Directory-Record does not correct.  Reached end of file.\");\n+\t\t}\n+\t\t\n+\t\tlong offsetFromBeginningOfFile = zip64EoCDOffset;\n+\t\tint offsetInBlock = 0;\n+\t\tint offsetFromStartingPoint = 0;   // The starting point is zip64EoCDOffset;\n+\n+\t\t// We will only enter this loop if data has been attached to the front of the archive (or if\n+\t\t// the archive is invalid.)  The loop searches forward in the file starting at the point where\n+\t\t// the Zip64 Locator indicates the Zip64-End-of-Central-Directory-Record should be.\n+\t\twhile ( !isValid_Zip64EoCDRecord( block, offsetInBlock, offsetFromBeginningOfFile ) ) {\n+\t\t\toffsetInBlock++;\n+\t\t\toffsetFromBeginningOfFile++;\n+\t\t\toffsetFromStartingPoint++;\n+\t\t\t\n+\t\t\t// An artificial limit is placed on the size of data allowed to be prepended to an archive.\n+\t\t\t// This is because this implementation searches through the file.  A fruitless search through\n+\t\t\t// a large file would cause an unacceptable delay if we did not set a limit.\n+\t\t\tif (offsetFromStartingPoint > MAX_PREFIX_ALLOWED) {\n+\t\t\t     throw new IOException(\"Failed to find the Zip64-End-of-Central-Directory-Record after searching \" + MAX_PREFIX_ALLOWED + \" bytes.\");\t\n+\t\t\t}\n+\t\t\t\n+\t\t\tif ( offsetInBlock > block.length - 4 ) {  // Must allow 4 bytes at end of block to read signature\n+\n+\t\t\t\tblock = getBlockFromBeginningOfFile(file, offsetFromBeginningOfFile, FORWARD_BLOCK_SIZE);\n+\t\t\t\tif (block.length < 4) {\n+\t\t\t\t\tthrow new IOException(\"Reached end of file while searching for to Zip64-End-of-Central-Directory-Record does not correct.\");\n+\t\t\t\t}\n+\t\t\t\toffsetInBlock = 0;\n+\t\t\t}\n+\t\t}\n+\n+\t\tif (block.length < (offsetInBlock + ZIP64_EOCDR_MINIMUM_SIZE ))  {\n+\t\t\tblock = getBlockFromBeginningOfFile(file, offsetFromBeginningOfFile, ZIP64_EOCDR_MINIMUM_SIZE);\n+\t\t    return  Arrays.copyOfRange(block, 0, ZIP64_EOCDR_MINIMUM_SIZE);\n+\t\t} \n+\t\t\n+\t\t// Only store the minimum size for this record.  We don't need to store any extra data.\n+\t\treturn Arrays.copyOfRange(block, offsetInBlock , offsetInBlock + ZIP64_EOCDR_MINIMUM_SIZE);\n+\t}\n+\t\n+\t/**\n+\t * @param file a zip file\n+\t * @param size number of bytes to read from end of file.\n+\t * @return byte[] an array of data of 'size' bytes from the end of the file\n+\t * @throws IOException\n+\t */\n+\tprivate byte[] getBlockFromEndOfFile(RandomAccessFile file, int size) throws IOException {\n+\n+\t\tint blockLength =  size >_fileLength ? (int)_fileLength : size;\n+\t\tlong offset = _fileLength - blockLength;\n+\n+\t\tfile.seek(offset);\n+\n+\t\tbyte[] bytes = new byte[blockLength];\n+\t\tfile.read(bytes, 0, blockLength );\n+\t\treturn bytes;\n+\t}\n+\t\n+\t/**\n+\t * \n+\t * @param file  a zip file\n+\t * @param offsetFromEnd Offset from end of file where reading begins\n+\t * @param size number of bytes of data to read\n+\t * @return Returns an array of 'size' bytes that starts from 'offsetFromEnd' of file.\n+\t * @throws IOException\n+\t */\n+\tprivate byte[] getBlockFromEndOfFile(RandomAccessFile file, int offsetFromEnd, int size) throws IOException {\n+\t\t", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "557cc66c2c7bbcbe803c2724e18ae288b8bbc2c1"}, "originalPosition": 337}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzU5MjkzNg==", "bodyText": "We are reading a long but comparing that against an int signature value?", "url": "https://github.com/OpenLiberty/open-liberty/pull/14827#discussion_r517592936", "createdAt": "2020-11-04T19:51:18Z", "author": {"login": "tbitonti"}, "path": "dev/com.ibm.ws.artifact.zip/src/com/ibm/ws/artifact/zip/internal/JavaArchive.java", "diffHunk": "@@ -0,0 +1,575 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 IBM Corporation and others.\n+ * All rights reserved. This program and the accompanying materials\n+ * are made available under the terms of the Eclipse Public License v1.0\n+ * which accompanies this distribution, and is available at\n+ * http://www.eclipse.org/legal/epl-v10.html\n+ *\n+ * Contributors:\n+ *     IBM Corporation - initial API and implementation\n+ *******************************************************************************\n+ *\n+ * The purpose of this class is to test if a Java archive is valid without actually reading the entire JAR.\n+ * This is especially useful in cases where the archive has a script attached at the front of the file.\n+ * Of course, this is more of a sanity check than a rigorous validation, which would require reading the whole file.\n+ * \n+ *     [ script ]                   <---- start of file  (optional)\n+ *     [ local file header 1 ]      <---- actual start of archive\n+ *     [ encryption header 1 ]\n+ *     [ file data 1 ]\n+ *     [ data descriptor 1 ]\n+ *     . \n+ *     .\n+ *     .\n+ *     [ local file header n ]\n+ *     [ encryption header n ]\n+ *     [ file data n ]\n+ *     [ data descriptor n ]\n+ *     [ archive decryption header ] \n+ *     [ archive extra data record ] \n+ *     [ central directory header 1 ]       <---- start of central directory\n+ *     .\n+ *     .\n+ *     .\n+ *     [ central directory header n ]\n+ *     [ zip64 end of central directory record ]\n+ *     [ zip64 end of central directory locator ] \n+ *     [ end of central directory record ]\n+ * \n+ *  The validation calculates the size of the last 4 records listed above (as well as doing some\n+ *  validation checks on the sizes and signatures) and then calculates the actual offset\n+ *  of the archive within the file (which will normally be 0).  The final step is to check\n+ *  the signature at the beginning of the archive.\n+ *  \n+ *  The actual archive offset is calculated :\n+ *  \n+ *    fileLength - eocdRecordSize - zip64RecLengths - CentralDirectorySize - offsetOfCentralDirectory\n+ *   \n+ *   Note the offsetOfCentralDirectory is relative to the beginning of the actual archive (not an offset  \n+ *   from the beginning of the file.)  Subtracting away all of the known pieces gives us the unknown \n+ *   piece which is the actual archive offset.\n+ *  \n+ */\n+\n+package com.ibm.ws.artifact.zip.internal;\n+\n+import java.io.IOException;\n+import java.io.RandomAccessFile;\n+import java.util.Arrays;\n+\n+public class JavaArchive {\n+    \n+    // EOCDR is End-of-Central-Directory-Record\n+\tprivate static final int EOCDR_MIN_SIZE = 22;\n+\tprivate static final int EOCDR_MAX_COMMENT_LEN = 0xFFFF;\n+\tprivate static final int EOCDR_MAX_SIZE = EOCDR_MIN_SIZE + EOCDR_MAX_COMMENT_LEN;\n+\tprivate static final int EOCDR_SIGNATURE = 0x504b0506; \n+\tprivate static final int EOCDR_TOTAL_ENTRIES_OFFSET = 10;\n+\tprivate static final int ZIP64_INDICATOR = 0xFFFF;               // Indicates Zip64 when found at offset EOCDR_TOTAL_ENTRIES_OFFSET \n+\tprivate static final int EOCDR_CENTRAL_DIR_SIZE_OFFSET = 12;     // Offset to size of central directory\n+\tprivate static final int EOCDR_CENTRAL_DIR_OFFSET = 16;          // Offset to central directory relative to beginning of archive\n+\tprivate static final int EOCDR_COMMENT_LENGTH_OFFSET = 20; \t     // Offset to comment length\n+\t\n+\t// ZIP64_EOCDR is Zip64-End-of-Central-Directory-Record\n+\tprivate static final int ZIP64_EOCDR_SIGNATURE = 0x504b0606;\n+\tprivate static final int ZIP64_EOCDR_MINIMUM_SIZE = 56;\n+\tprivate static final int ZIP64_EOCDR_HEADER_SIZE = 12;           // 4 bytes for the signature and 8 bytes for the length\n+\tprivate static final int ZIP64_EOCDR_SIZE_OFFSET = 4;            // The size at this offset is the size of the zip64 EOCDR minus 12. (Meaning it does NOT include the 12-byte header)\n+\tprivate static final int ZIP64_EOCDR_SIZE_FIELD_LENGTH = 8;      // Number of bytes for size field.\n+\n+\t// ZIP64_LOCATOR is Zip64-End-of-Central-Directory-Record-Locator\n+\tprivate static final int ZIP64_LOCATOR_SIGNATURE = 0x504b0607;\n+\tprivate static final int ZIP64_LOCATOR_SIZE = 20;                // Fixed size.\n+\tprivate static final int ZIP64_LOCATOR_EOCD_OFFSET_OFFSET = 8;   // Position in the locator of the offset of the Zip64-End-of-Central-Direcory-Record\n+\t\n+\tprivate static final int LOCAL_FILE_HEADER_SIGNATURE = 0x504b0304;\n+\tprivate static final int BLOCK_SIZE = 256;\n+\tprivate static final int FORWARD_BLOCK_SIZE = 8192;\n+\t\n+\t// Maximum amount of data (usually a script) that is allowed by this implementation to be \n+\t// attached to the beginning of the archive. This value may be increased, but it will \n+\t// increase the time it takes to fail when the zip is corrupted.\n+\tprivate static final int MAX_PREFIX_ALLOWED = 1024*1024*5;       \n+\t\n+\tprivate byte[] _endOfCentralDirectoryRecord; // Only the minimum size is stored.  Does not include the comment \n+\tprivate int    _eocdRecordSize;              // Actual size of End-of-Central-Directory-Record - including comment\n+\tprivate byte[] _zip64EoCDRLocator;           // 20 bytes;\n+\tprivate long   _zip64EoCDRLocatorOffset;     // Offset (from end of file) of the Zip64 Locator\n+\tprivate byte[] _zip64EoCDR;                  // Only the minimum size is stored.  Does not include any extra fields.  \n+\tprivate long   _zip64EoCDRecSize;            // Size of Zip64-End-of-Central-Directory-Record\n+    private String _archiveFileName;\n+\tprivate long   _fileLength;                  // Length of the archive file\n+\t\n+    JavaArchive(String archiveFileName) {\n+    \t_archiveFileName = archiveFileName;\n+    }\n+    \n+    public boolean isValid() {\n+    \t\n+    \ttry (  RandomAccessFile file = new RandomAccessFile(_archiveFileName, \"r\") ) {\n+\n+    \t\t_fileLength = file.length();\n+    \t\t_endOfCentralDirectoryRecord = getEndOfCentralDirectoryRecord(file);\n+    \t\t\n+    \t\tif ( isZip64() ) {\n+    \t\t   _zip64EoCDRLocator = getZip64EoCDLocator(file);\n+    \t\t   _zip64EoCDRLocatorOffset = _fileLength - _eocdRecordSize - ZIP64_LOCATOR_SIZE;\n+    \t\t   _zip64EoCDR = getZip64EndOfCentralDirectoryRecord(file);\n+    \t\t   _zip64EoCDRecSize = getZip64EoCDRecordSize( _zip64EoCDR, 0 );\n+    \t\t}\n+    \t\t\n+    \t\tint archiveOffset = (int)getActualArchiveOffset();\n+\n+    \t\tif (archiveStartsWithSignature(file, archiveOffset)) {\n+    \t\t\treturn true;\n+    \t\t} \n+\n+    \t} catch (Exception e) {\n+    \t\t//e.printStackTrace();\n+    \t}\n+\n+    \treturn false;\n+    }\n+    \n+    /**\n+     * Find the End-of-Central-Director-Record which is always at the end of the file.\n+     * It is usually 22 bytes but may contain a comment up to 64K in size.\n+     * Reads from the end of the file looking backwards for the EoCDR signature.\n+     * \n+     * The implementation reads the file in BLOCK_SIZE blocks from the end of the file\n+     * and searches each block.  Note that there is some overlap of the successive \n+     * blocks; EOCDR_MIN_SIZE bytes of overlap to be precise.  This is because the \n+     * record might start at the end of one block and finish in the next.\n+     * \n+     * @param file\n+     * @throws IOException\n+     */\n+\tprivate byte[] getEndOfCentralDirectoryRecord(RandomAccessFile file) throws IOException {\n+\t\t\n+\t\tbyte[] block = getBlockFromEndOfFile(file, BLOCK_SIZE);\n+\t\tint size = EOCDR_MIN_SIZE ;\n+\t\tint offset = block.length - size;\n+\t\tint offsetFromEnd = block.length - offset;   // offset from the end of the block (not the file)\n+\t\t\n+\t\tif ( block.length < EOCDR_MIN_SIZE ) {\n+\t\t\tthrow new IOException(\"Not a valid zip file.  Less than minimum required length.\");\n+\t\t}\n+\t\t\n+\t\t// We will only enter this loop if a comment is attached to the End-of-Central-Directory-Record\n+\t\t// ... or if the zip is invalid (doesn't have an End-of-Central-Directory-Record.\n+\t\t// Note that isValidEoCDRec must have EOCDR_MIN_SIZE available at the end of the block\n+\t\t// to avoid an exception because of a read past the end of the block.\n+\t\twhile ( !isValidEoCDRec( block, offset, size ) ) {\n+\t\t\tsize++;\n+\t\t\tif (size == 0xFFFF) {\n+\t\t\t\tint i = 0;\n+\t\t\t}\n+\t\t\toffsetFromEnd++;\n+\t\t\t \n+\t\t\tif ( size > EOCDR_MAX_SIZE || size > _fileLength ) {\n+\t\t\t\tthrow new IOException(\n+\t\t\t\t\t\t\"Cannot find central directory end record in zip\");\n+\t\t\t}\n+\t\t\t\n+\t\t\tif ( offsetFromEnd > block.length ) {\n+\n+\t\t\t\tblock = this.getBlockFromEndOfFile(file, size + BLOCK_SIZE - EOCDR_MIN_SIZE, BLOCK_SIZE);\n+\t\t\t\toffsetFromEnd = EOCDR_MIN_SIZE;\n+\t\t\t}\n+\t\t\toffset = block.length - offsetFromEnd;\t\t\t\n+\t\t}\n+\t\t\n+\t\t// Copy only the minimum end-of-central-directory-record, but record the actual size.  \n+\t\t// We don't need to store the comment, which could be up to 64k.\t\t\n+\t\t_eocdRecordSize = size;\n+\t\treturn Arrays.copyOfRange(block, offset, offset + EOCDR_MIN_SIZE ); \n+\t}\n+\t\n+//  Alternative implementation that avoids the overlapping blocks, but always reads to the end of\n+//  when retrieving a new block.  Thus the block size grows and can get quite large.\t\n+//\n+//\n+//\tprivate byte[] getEndOfCentralDirectoryRecord(RandomAccessFile file) throws IOException {\n+//\t\t\n+//\t\tbyte[] block = getBlockFromEndOfFile(file, BLOCK_SIZE);\n+//\t\tint blockLength = block.length;  // for debugging !!!!!!!!!!!!!!!!1\n+//\t\tint size = EOCDR_MIN_SIZE ;\n+//\t\tint offset = block.length - size;\n+//\t\t\n+//\t\tif ( block.length < EOCDR_MIN_SIZE ) {\n+//\t\t\tthrow new IOException(\"Not a valid zip file.  Less than minimum required length.\");\n+//\t\t}\n+//\t\t\n+//\t\t// We will only enter this loop if a comment is attached to the End-of-Central-Directory-Record\n+//\t\t// ... or if the zip is invalid (doesn't have an End-of-Central-Directory-Record.\n+//\t\twhile ( !isValidEoCDRec( block, offset, size ) ) {\n+//\t\t\tsize++;\n+//\t\t\tif ( size > block.length ) {\n+//\t\t\t\tif ( size >= EOCDR_MAX_SIZE || size > _fileLength ) {\n+//\t\t\t\t\tthrow new IOException(\n+//\t\t\t\t\t\t\t\"Cannot find central directory end record in zip\");\n+//\t\t\t\t}\n+//\t\t\t\tblock = this.getBlockFromEndOfFile(file, size + BLOCK_SIZE);\n+//\t\t\t}\n+//\t\t\tblockLength = block.length;\n+//\t\t\toffset = block.length - size;\n+//\t\t}\n+//\t\t\n+//\t\t// Copy only the minimum end-of-central-directory-record, but record the actual size.  \n+//\t\t// We don't need the comment, which could be up to 64k.\t\t\n+//\t\t_eocdRecordSize = size;\n+//\t\treturn Arrays.copyOfRange(block, offset, offset + EOCDR_MIN_SIZE ); \n+//\t}\n+\t\n+\t/**\n+\t * Get the 20-byte Zip64 Locator.  It must sit 20 bytes before the End-of-Central-Directory-Record.\n+\t * @param file the zip file\n+\t * @return\n+\t * @throws IOException\n+\t */\n+\tprivate byte[] getZip64EoCDLocator(RandomAccessFile file) throws IOException {\n+\n+\t\tif ( !isZip64() ) {\n+\t\t\treturn null;\n+\t\t}\n+\n+\t    byte[] block = getBlockFromEndOfFile(file, \n+\t    \t\t                             _eocdRecordSize + ZIP64_LOCATOR_SIZE, \n+\t    \t\t                             ZIP64_LOCATOR_SIZE);\t\n+\n+\t\tif ( !isValid_Zip64EoCDRLocator(block, 0)) {\n+\t\t\tthrow new IOException(\"Invalid Zip64-End-of-Central-Direcytory-Locator.\");\n+\t\t}\n+\n+\t\treturn Arrays.copyOfRange(block, 0, ZIP64_LOCATOR_SIZE);\n+\t}\n+\t\n+\t/**\n+\t * Locates the Zip64-End-of-Central-Directory-Record by using the offset \n+\t * in the Zip64 Locator.  If not found there, it is assumed that data has\n+\t * been prepended to the archive, and a forward search begins until we find the\n+\t * correct signature.  Of course, a false signature could appear just about  \n+\t * anywhere in the zip.  So the record must pass additional validation.\n+\t * @param file a zip file\n+\t * @return a copy of the Zip64-End-of-Central-Directory-Record\n+\t * @throws IOException\n+\t */\n+\tprivate byte[] getZip64EndOfCentralDirectoryRecord(RandomAccessFile file ) throws IOException {\n+\t\t\n+\t\tif ( !isZip64() ) {\n+\t\t\treturn null;\n+\t\t}\n+\n+\t\t// The offset of the Zip64-End-of-Central-Directory-Record is found in the Zip64 locator at offset 8.\n+\t\t// That offset will not be correct if data (i.e. a script) has been attached in front of the archive.\n+\t\tlong zip64EoCDOffset = this.getLittleEndianValue( _zip64EoCDRLocator, ZIP64_LOCATOR_EOCD_OFFSET_OFFSET, 4);\n+\t\t\n+\t\tbyte [] block = getBlockFromBeginningOfFile(file, zip64EoCDOffset, ZIP64_EOCDR_MINIMUM_SIZE);\n+\t\tif (block.length < ZIP64_EOCDR_MINIMUM_SIZE) {\n+\t\t\tthrow new IOException(\"Offset to Zip64-End-of-Central-Directory-Record does not correct.  Reached end of file.\");\n+\t\t}\n+\t\t\n+\t\tlong offsetFromBeginningOfFile = zip64EoCDOffset;\n+\t\tint offsetInBlock = 0;\n+\t\tint offsetFromStartingPoint = 0;   // The starting point is zip64EoCDOffset;\n+\n+\t\t// We will only enter this loop if data has been attached to the front of the archive (or if\n+\t\t// the archive is invalid.)  The loop searches forward in the file starting at the point where\n+\t\t// the Zip64 Locator indicates the Zip64-End-of-Central-Directory-Record should be.\n+\t\twhile ( !isValid_Zip64EoCDRecord( block, offsetInBlock, offsetFromBeginningOfFile ) ) {\n+\t\t\toffsetInBlock++;\n+\t\t\toffsetFromBeginningOfFile++;\n+\t\t\toffsetFromStartingPoint++;\n+\t\t\t\n+\t\t\t// An artificial limit is placed on the size of data allowed to be prepended to an archive.\n+\t\t\t// This is because this implementation searches through the file.  A fruitless search through\n+\t\t\t// a large file would cause an unacceptable delay if we did not set a limit.\n+\t\t\tif (offsetFromStartingPoint > MAX_PREFIX_ALLOWED) {\n+\t\t\t     throw new IOException(\"Failed to find the Zip64-End-of-Central-Directory-Record after searching \" + MAX_PREFIX_ALLOWED + \" bytes.\");\t\n+\t\t\t}\n+\t\t\t\n+\t\t\tif ( offsetInBlock > block.length - 4 ) {  // Must allow 4 bytes at end of block to read signature\n+\n+\t\t\t\tblock = getBlockFromBeginningOfFile(file, offsetFromBeginningOfFile, FORWARD_BLOCK_SIZE);\n+\t\t\t\tif (block.length < 4) {\n+\t\t\t\t\tthrow new IOException(\"Reached end of file while searching for to Zip64-End-of-Central-Directory-Record does not correct.\");\n+\t\t\t\t}\n+\t\t\t\toffsetInBlock = 0;\n+\t\t\t}\n+\t\t}\n+\n+\t\tif (block.length < (offsetInBlock + ZIP64_EOCDR_MINIMUM_SIZE ))  {\n+\t\t\tblock = getBlockFromBeginningOfFile(file, offsetFromBeginningOfFile, ZIP64_EOCDR_MINIMUM_SIZE);\n+\t\t    return  Arrays.copyOfRange(block, 0, ZIP64_EOCDR_MINIMUM_SIZE);\n+\t\t} \n+\t\t\n+\t\t// Only store the minimum size for this record.  We don't need to store any extra data.\n+\t\treturn Arrays.copyOfRange(block, offsetInBlock , offsetInBlock + ZIP64_EOCDR_MINIMUM_SIZE);\n+\t}\n+\t\n+\t/**\n+\t * @param file a zip file\n+\t * @param size number of bytes to read from end of file.\n+\t * @return byte[] an array of data of 'size' bytes from the end of the file\n+\t * @throws IOException\n+\t */\n+\tprivate byte[] getBlockFromEndOfFile(RandomAccessFile file, int size) throws IOException {\n+\n+\t\tint blockLength =  size >_fileLength ? (int)_fileLength : size;\n+\t\tlong offset = _fileLength - blockLength;\n+\n+\t\tfile.seek(offset);\n+\n+\t\tbyte[] bytes = new byte[blockLength];\n+\t\tfile.read(bytes, 0, blockLength );\n+\t\treturn bytes;\n+\t}\n+\t\n+\t/**\n+\t * \n+\t * @param file  a zip file\n+\t * @param offsetFromEnd Offset from end of file where reading begins\n+\t * @param size number of bytes of data to read\n+\t * @return Returns an array of 'size' bytes that starts from 'offsetFromEnd' of file.\n+\t * @throws IOException\n+\t */\n+\tprivate byte[] getBlockFromEndOfFile(RandomAccessFile file, int offsetFromEnd, int size) throws IOException {\n+\t\t\n+\t\t// Have offset from end.  Get offset from beginning.\n+\t\tlong offset = _fileLength >= offsetFromEnd ? _fileLength - offsetFromEnd : 0;\n+\n+\t\tfile.seek(offset);\n+\n+\t\tbyte[] bytes = new byte[size];\n+\t\tfile.read(bytes, 0, size );\n+\t\treturn bytes;\n+\t}\n+\n+\t/**\n+\t * \n+\t * @param file a zip file\n+\t * @param offset Position from beginning of file, where data is to be read\n+\t * @param size number of bytes to read\n+\t * @return Returns an array of size 'size' read from file beginning at 'offset'\n+\t * @throws IOException\n+\t */\n+\tprivate byte[] getBlockFromBeginningOfFile(RandomAccessFile file, long offset, int size) throws IOException {\n+\t\t\n+\t\tfile.seek(offset);\n+\n+\t\tbyte[] bytes = new byte[size];\n+\t\tfile.read(bytes, 0, size );\n+\t\treturn bytes;\t\n+\t}\n+\t\n+\t/** \n+\t * Test for valid signature and size.\n+\t * @return true if the offset points to a valid End-of-Central-Directory-Record within \"bytes\"\n+\t */\n+\tprivate boolean isValidEoCDRec(byte[] bytes, int offset, int centralDirEndRecSize) {\n+\t\tif ( !isSignature(bytes, offset, EOCDR_SIGNATURE) \n+\t\t\t || !isValidEoCDRecSize(bytes, offset + EOCDR_COMMENT_LENGTH_OFFSET, centralDirEndRecSize)) {\n+\t\t\treturn false;\n+\t\t}\n+        return true;\n+\t}\n+\t\n+\t/**\n+\t * \n+\t * @return true if the signature parameter matches the bytes at offset\n+\t */\n+\tprivate boolean isSignature(byte[] bytes, int offset, int signature) {\n+\n+\t\tlong value = getSignature(bytes, offset);\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "557cc66c2c7bbcbe803c2724e18ae288b8bbc2c1"}, "originalPosition": 384}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzU5MzUzNQ==", "bodyText": "'size' is an int, but comment length is a long ... but the comment is restricted to 64K at most?  Should 'getLittleEndianValue' answer an int instead of a long?", "url": "https://github.com/OpenLiberty/open-liberty/pull/14827#discussion_r517593535", "createdAt": "2020-11-04T19:52:32Z", "author": {"login": "tbitonti"}, "path": "dev/com.ibm.ws.artifact.zip/src/com/ibm/ws/artifact/zip/internal/JavaArchive.java", "diffHunk": "@@ -0,0 +1,575 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 IBM Corporation and others.\n+ * All rights reserved. This program and the accompanying materials\n+ * are made available under the terms of the Eclipse Public License v1.0\n+ * which accompanies this distribution, and is available at\n+ * http://www.eclipse.org/legal/epl-v10.html\n+ *\n+ * Contributors:\n+ *     IBM Corporation - initial API and implementation\n+ *******************************************************************************\n+ *\n+ * The purpose of this class is to test if a Java archive is valid without actually reading the entire JAR.\n+ * This is especially useful in cases where the archive has a script attached at the front of the file.\n+ * Of course, this is more of a sanity check than a rigorous validation, which would require reading the whole file.\n+ * \n+ *     [ script ]                   <---- start of file  (optional)\n+ *     [ local file header 1 ]      <---- actual start of archive\n+ *     [ encryption header 1 ]\n+ *     [ file data 1 ]\n+ *     [ data descriptor 1 ]\n+ *     . \n+ *     .\n+ *     .\n+ *     [ local file header n ]\n+ *     [ encryption header n ]\n+ *     [ file data n ]\n+ *     [ data descriptor n ]\n+ *     [ archive decryption header ] \n+ *     [ archive extra data record ] \n+ *     [ central directory header 1 ]       <---- start of central directory\n+ *     .\n+ *     .\n+ *     .\n+ *     [ central directory header n ]\n+ *     [ zip64 end of central directory record ]\n+ *     [ zip64 end of central directory locator ] \n+ *     [ end of central directory record ]\n+ * \n+ *  The validation calculates the size of the last 4 records listed above (as well as doing some\n+ *  validation checks on the sizes and signatures) and then calculates the actual offset\n+ *  of the archive within the file (which will normally be 0).  The final step is to check\n+ *  the signature at the beginning of the archive.\n+ *  \n+ *  The actual archive offset is calculated :\n+ *  \n+ *    fileLength - eocdRecordSize - zip64RecLengths - CentralDirectorySize - offsetOfCentralDirectory\n+ *   \n+ *   Note the offsetOfCentralDirectory is relative to the beginning of the actual archive (not an offset  \n+ *   from the beginning of the file.)  Subtracting away all of the known pieces gives us the unknown \n+ *   piece which is the actual archive offset.\n+ *  \n+ */\n+\n+package com.ibm.ws.artifact.zip.internal;\n+\n+import java.io.IOException;\n+import java.io.RandomAccessFile;\n+import java.util.Arrays;\n+\n+public class JavaArchive {\n+    \n+    // EOCDR is End-of-Central-Directory-Record\n+\tprivate static final int EOCDR_MIN_SIZE = 22;\n+\tprivate static final int EOCDR_MAX_COMMENT_LEN = 0xFFFF;\n+\tprivate static final int EOCDR_MAX_SIZE = EOCDR_MIN_SIZE + EOCDR_MAX_COMMENT_LEN;\n+\tprivate static final int EOCDR_SIGNATURE = 0x504b0506; \n+\tprivate static final int EOCDR_TOTAL_ENTRIES_OFFSET = 10;\n+\tprivate static final int ZIP64_INDICATOR = 0xFFFF;               // Indicates Zip64 when found at offset EOCDR_TOTAL_ENTRIES_OFFSET \n+\tprivate static final int EOCDR_CENTRAL_DIR_SIZE_OFFSET = 12;     // Offset to size of central directory\n+\tprivate static final int EOCDR_CENTRAL_DIR_OFFSET = 16;          // Offset to central directory relative to beginning of archive\n+\tprivate static final int EOCDR_COMMENT_LENGTH_OFFSET = 20; \t     // Offset to comment length\n+\t\n+\t// ZIP64_EOCDR is Zip64-End-of-Central-Directory-Record\n+\tprivate static final int ZIP64_EOCDR_SIGNATURE = 0x504b0606;\n+\tprivate static final int ZIP64_EOCDR_MINIMUM_SIZE = 56;\n+\tprivate static final int ZIP64_EOCDR_HEADER_SIZE = 12;           // 4 bytes for the signature and 8 bytes for the length\n+\tprivate static final int ZIP64_EOCDR_SIZE_OFFSET = 4;            // The size at this offset is the size of the zip64 EOCDR minus 12. (Meaning it does NOT include the 12-byte header)\n+\tprivate static final int ZIP64_EOCDR_SIZE_FIELD_LENGTH = 8;      // Number of bytes for size field.\n+\n+\t// ZIP64_LOCATOR is Zip64-End-of-Central-Directory-Record-Locator\n+\tprivate static final int ZIP64_LOCATOR_SIGNATURE = 0x504b0607;\n+\tprivate static final int ZIP64_LOCATOR_SIZE = 20;                // Fixed size.\n+\tprivate static final int ZIP64_LOCATOR_EOCD_OFFSET_OFFSET = 8;   // Position in the locator of the offset of the Zip64-End-of-Central-Direcory-Record\n+\t\n+\tprivate static final int LOCAL_FILE_HEADER_SIGNATURE = 0x504b0304;\n+\tprivate static final int BLOCK_SIZE = 256;\n+\tprivate static final int FORWARD_BLOCK_SIZE = 8192;\n+\t\n+\t// Maximum amount of data (usually a script) that is allowed by this implementation to be \n+\t// attached to the beginning of the archive. This value may be increased, but it will \n+\t// increase the time it takes to fail when the zip is corrupted.\n+\tprivate static final int MAX_PREFIX_ALLOWED = 1024*1024*5;       \n+\t\n+\tprivate byte[] _endOfCentralDirectoryRecord; // Only the minimum size is stored.  Does not include the comment \n+\tprivate int    _eocdRecordSize;              // Actual size of End-of-Central-Directory-Record - including comment\n+\tprivate byte[] _zip64EoCDRLocator;           // 20 bytes;\n+\tprivate long   _zip64EoCDRLocatorOffset;     // Offset (from end of file) of the Zip64 Locator\n+\tprivate byte[] _zip64EoCDR;                  // Only the minimum size is stored.  Does not include any extra fields.  \n+\tprivate long   _zip64EoCDRecSize;            // Size of Zip64-End-of-Central-Directory-Record\n+    private String _archiveFileName;\n+\tprivate long   _fileLength;                  // Length of the archive file\n+\t\n+    JavaArchive(String archiveFileName) {\n+    \t_archiveFileName = archiveFileName;\n+    }\n+    \n+    public boolean isValid() {\n+    \t\n+    \ttry (  RandomAccessFile file = new RandomAccessFile(_archiveFileName, \"r\") ) {\n+\n+    \t\t_fileLength = file.length();\n+    \t\t_endOfCentralDirectoryRecord = getEndOfCentralDirectoryRecord(file);\n+    \t\t\n+    \t\tif ( isZip64() ) {\n+    \t\t   _zip64EoCDRLocator = getZip64EoCDLocator(file);\n+    \t\t   _zip64EoCDRLocatorOffset = _fileLength - _eocdRecordSize - ZIP64_LOCATOR_SIZE;\n+    \t\t   _zip64EoCDR = getZip64EndOfCentralDirectoryRecord(file);\n+    \t\t   _zip64EoCDRecSize = getZip64EoCDRecordSize( _zip64EoCDR, 0 );\n+    \t\t}\n+    \t\t\n+    \t\tint archiveOffset = (int)getActualArchiveOffset();\n+\n+    \t\tif (archiveStartsWithSignature(file, archiveOffset)) {\n+    \t\t\treturn true;\n+    \t\t} \n+\n+    \t} catch (Exception e) {\n+    \t\t//e.printStackTrace();\n+    \t}\n+\n+    \treturn false;\n+    }\n+    \n+    /**\n+     * Find the End-of-Central-Director-Record which is always at the end of the file.\n+     * It is usually 22 bytes but may contain a comment up to 64K in size.\n+     * Reads from the end of the file looking backwards for the EoCDR signature.\n+     * \n+     * The implementation reads the file in BLOCK_SIZE blocks from the end of the file\n+     * and searches each block.  Note that there is some overlap of the successive \n+     * blocks; EOCDR_MIN_SIZE bytes of overlap to be precise.  This is because the \n+     * record might start at the end of one block and finish in the next.\n+     * \n+     * @param file\n+     * @throws IOException\n+     */\n+\tprivate byte[] getEndOfCentralDirectoryRecord(RandomAccessFile file) throws IOException {\n+\t\t\n+\t\tbyte[] block = getBlockFromEndOfFile(file, BLOCK_SIZE);\n+\t\tint size = EOCDR_MIN_SIZE ;\n+\t\tint offset = block.length - size;\n+\t\tint offsetFromEnd = block.length - offset;   // offset from the end of the block (not the file)\n+\t\t\n+\t\tif ( block.length < EOCDR_MIN_SIZE ) {\n+\t\t\tthrow new IOException(\"Not a valid zip file.  Less than minimum required length.\");\n+\t\t}\n+\t\t\n+\t\t// We will only enter this loop if a comment is attached to the End-of-Central-Directory-Record\n+\t\t// ... or if the zip is invalid (doesn't have an End-of-Central-Directory-Record.\n+\t\t// Note that isValidEoCDRec must have EOCDR_MIN_SIZE available at the end of the block\n+\t\t// to avoid an exception because of a read past the end of the block.\n+\t\twhile ( !isValidEoCDRec( block, offset, size ) ) {\n+\t\t\tsize++;\n+\t\t\tif (size == 0xFFFF) {\n+\t\t\t\tint i = 0;\n+\t\t\t}\n+\t\t\toffsetFromEnd++;\n+\t\t\t \n+\t\t\tif ( size > EOCDR_MAX_SIZE || size > _fileLength ) {\n+\t\t\t\tthrow new IOException(\n+\t\t\t\t\t\t\"Cannot find central directory end record in zip\");\n+\t\t\t}\n+\t\t\t\n+\t\t\tif ( offsetFromEnd > block.length ) {\n+\n+\t\t\t\tblock = this.getBlockFromEndOfFile(file, size + BLOCK_SIZE - EOCDR_MIN_SIZE, BLOCK_SIZE);\n+\t\t\t\toffsetFromEnd = EOCDR_MIN_SIZE;\n+\t\t\t}\n+\t\t\toffset = block.length - offsetFromEnd;\t\t\t\n+\t\t}\n+\t\t\n+\t\t// Copy only the minimum end-of-central-directory-record, but record the actual size.  \n+\t\t// We don't need to store the comment, which could be up to 64k.\t\t\n+\t\t_eocdRecordSize = size;\n+\t\treturn Arrays.copyOfRange(block, offset, offset + EOCDR_MIN_SIZE ); \n+\t}\n+\t\n+//  Alternative implementation that avoids the overlapping blocks, but always reads to the end of\n+//  when retrieving a new block.  Thus the block size grows and can get quite large.\t\n+//\n+//\n+//\tprivate byte[] getEndOfCentralDirectoryRecord(RandomAccessFile file) throws IOException {\n+//\t\t\n+//\t\tbyte[] block = getBlockFromEndOfFile(file, BLOCK_SIZE);\n+//\t\tint blockLength = block.length;  // for debugging !!!!!!!!!!!!!!!!1\n+//\t\tint size = EOCDR_MIN_SIZE ;\n+//\t\tint offset = block.length - size;\n+//\t\t\n+//\t\tif ( block.length < EOCDR_MIN_SIZE ) {\n+//\t\t\tthrow new IOException(\"Not a valid zip file.  Less than minimum required length.\");\n+//\t\t}\n+//\t\t\n+//\t\t// We will only enter this loop if a comment is attached to the End-of-Central-Directory-Record\n+//\t\t// ... or if the zip is invalid (doesn't have an End-of-Central-Directory-Record.\n+//\t\twhile ( !isValidEoCDRec( block, offset, size ) ) {\n+//\t\t\tsize++;\n+//\t\t\tif ( size > block.length ) {\n+//\t\t\t\tif ( size >= EOCDR_MAX_SIZE || size > _fileLength ) {\n+//\t\t\t\t\tthrow new IOException(\n+//\t\t\t\t\t\t\t\"Cannot find central directory end record in zip\");\n+//\t\t\t\t}\n+//\t\t\t\tblock = this.getBlockFromEndOfFile(file, size + BLOCK_SIZE);\n+//\t\t\t}\n+//\t\t\tblockLength = block.length;\n+//\t\t\toffset = block.length - size;\n+//\t\t}\n+//\t\t\n+//\t\t// Copy only the minimum end-of-central-directory-record, but record the actual size.  \n+//\t\t// We don't need the comment, which could be up to 64k.\t\t\n+//\t\t_eocdRecordSize = size;\n+//\t\treturn Arrays.copyOfRange(block, offset, offset + EOCDR_MIN_SIZE ); \n+//\t}\n+\t\n+\t/**\n+\t * Get the 20-byte Zip64 Locator.  It must sit 20 bytes before the End-of-Central-Directory-Record.\n+\t * @param file the zip file\n+\t * @return\n+\t * @throws IOException\n+\t */\n+\tprivate byte[] getZip64EoCDLocator(RandomAccessFile file) throws IOException {\n+\n+\t\tif ( !isZip64() ) {\n+\t\t\treturn null;\n+\t\t}\n+\n+\t    byte[] block = getBlockFromEndOfFile(file, \n+\t    \t\t                             _eocdRecordSize + ZIP64_LOCATOR_SIZE, \n+\t    \t\t                             ZIP64_LOCATOR_SIZE);\t\n+\n+\t\tif ( !isValid_Zip64EoCDRLocator(block, 0)) {\n+\t\t\tthrow new IOException(\"Invalid Zip64-End-of-Central-Direcytory-Locator.\");\n+\t\t}\n+\n+\t\treturn Arrays.copyOfRange(block, 0, ZIP64_LOCATOR_SIZE);\n+\t}\n+\t\n+\t/**\n+\t * Locates the Zip64-End-of-Central-Directory-Record by using the offset \n+\t * in the Zip64 Locator.  If not found there, it is assumed that data has\n+\t * been prepended to the archive, and a forward search begins until we find the\n+\t * correct signature.  Of course, a false signature could appear just about  \n+\t * anywhere in the zip.  So the record must pass additional validation.\n+\t * @param file a zip file\n+\t * @return a copy of the Zip64-End-of-Central-Directory-Record\n+\t * @throws IOException\n+\t */\n+\tprivate byte[] getZip64EndOfCentralDirectoryRecord(RandomAccessFile file ) throws IOException {\n+\t\t\n+\t\tif ( !isZip64() ) {\n+\t\t\treturn null;\n+\t\t}\n+\n+\t\t// The offset of the Zip64-End-of-Central-Directory-Record is found in the Zip64 locator at offset 8.\n+\t\t// That offset will not be correct if data (i.e. a script) has been attached in front of the archive.\n+\t\tlong zip64EoCDOffset = this.getLittleEndianValue( _zip64EoCDRLocator, ZIP64_LOCATOR_EOCD_OFFSET_OFFSET, 4);\n+\t\t\n+\t\tbyte [] block = getBlockFromBeginningOfFile(file, zip64EoCDOffset, ZIP64_EOCDR_MINIMUM_SIZE);\n+\t\tif (block.length < ZIP64_EOCDR_MINIMUM_SIZE) {\n+\t\t\tthrow new IOException(\"Offset to Zip64-End-of-Central-Directory-Record does not correct.  Reached end of file.\");\n+\t\t}\n+\t\t\n+\t\tlong offsetFromBeginningOfFile = zip64EoCDOffset;\n+\t\tint offsetInBlock = 0;\n+\t\tint offsetFromStartingPoint = 0;   // The starting point is zip64EoCDOffset;\n+\n+\t\t// We will only enter this loop if data has been attached to the front of the archive (or if\n+\t\t// the archive is invalid.)  The loop searches forward in the file starting at the point where\n+\t\t// the Zip64 Locator indicates the Zip64-End-of-Central-Directory-Record should be.\n+\t\twhile ( !isValid_Zip64EoCDRecord( block, offsetInBlock, offsetFromBeginningOfFile ) ) {\n+\t\t\toffsetInBlock++;\n+\t\t\toffsetFromBeginningOfFile++;\n+\t\t\toffsetFromStartingPoint++;\n+\t\t\t\n+\t\t\t// An artificial limit is placed on the size of data allowed to be prepended to an archive.\n+\t\t\t// This is because this implementation searches through the file.  A fruitless search through\n+\t\t\t// a large file would cause an unacceptable delay if we did not set a limit.\n+\t\t\tif (offsetFromStartingPoint > MAX_PREFIX_ALLOWED) {\n+\t\t\t     throw new IOException(\"Failed to find the Zip64-End-of-Central-Directory-Record after searching \" + MAX_PREFIX_ALLOWED + \" bytes.\");\t\n+\t\t\t}\n+\t\t\t\n+\t\t\tif ( offsetInBlock > block.length - 4 ) {  // Must allow 4 bytes at end of block to read signature\n+\n+\t\t\t\tblock = getBlockFromBeginningOfFile(file, offsetFromBeginningOfFile, FORWARD_BLOCK_SIZE);\n+\t\t\t\tif (block.length < 4) {\n+\t\t\t\t\tthrow new IOException(\"Reached end of file while searching for to Zip64-End-of-Central-Directory-Record does not correct.\");\n+\t\t\t\t}\n+\t\t\t\toffsetInBlock = 0;\n+\t\t\t}\n+\t\t}\n+\n+\t\tif (block.length < (offsetInBlock + ZIP64_EOCDR_MINIMUM_SIZE ))  {\n+\t\t\tblock = getBlockFromBeginningOfFile(file, offsetFromBeginningOfFile, ZIP64_EOCDR_MINIMUM_SIZE);\n+\t\t    return  Arrays.copyOfRange(block, 0, ZIP64_EOCDR_MINIMUM_SIZE);\n+\t\t} \n+\t\t\n+\t\t// Only store the minimum size for this record.  We don't need to store any extra data.\n+\t\treturn Arrays.copyOfRange(block, offsetInBlock , offsetInBlock + ZIP64_EOCDR_MINIMUM_SIZE);\n+\t}\n+\t\n+\t/**\n+\t * @param file a zip file\n+\t * @param size number of bytes to read from end of file.\n+\t * @return byte[] an array of data of 'size' bytes from the end of the file\n+\t * @throws IOException\n+\t */\n+\tprivate byte[] getBlockFromEndOfFile(RandomAccessFile file, int size) throws IOException {\n+\n+\t\tint blockLength =  size >_fileLength ? (int)_fileLength : size;\n+\t\tlong offset = _fileLength - blockLength;\n+\n+\t\tfile.seek(offset);\n+\n+\t\tbyte[] bytes = new byte[blockLength];\n+\t\tfile.read(bytes, 0, blockLength );\n+\t\treturn bytes;\n+\t}\n+\t\n+\t/**\n+\t * \n+\t * @param file  a zip file\n+\t * @param offsetFromEnd Offset from end of file where reading begins\n+\t * @param size number of bytes of data to read\n+\t * @return Returns an array of 'size' bytes that starts from 'offsetFromEnd' of file.\n+\t * @throws IOException\n+\t */\n+\tprivate byte[] getBlockFromEndOfFile(RandomAccessFile file, int offsetFromEnd, int size) throws IOException {\n+\t\t\n+\t\t// Have offset from end.  Get offset from beginning.\n+\t\tlong offset = _fileLength >= offsetFromEnd ? _fileLength - offsetFromEnd : 0;\n+\n+\t\tfile.seek(offset);\n+\n+\t\tbyte[] bytes = new byte[size];\n+\t\tfile.read(bytes, 0, size );\n+\t\treturn bytes;\n+\t}\n+\n+\t/**\n+\t * \n+\t * @param file a zip file\n+\t * @param offset Position from beginning of file, where data is to be read\n+\t * @param size number of bytes to read\n+\t * @return Returns an array of size 'size' read from file beginning at 'offset'\n+\t * @throws IOException\n+\t */\n+\tprivate byte[] getBlockFromBeginningOfFile(RandomAccessFile file, long offset, int size) throws IOException {\n+\t\t\n+\t\tfile.seek(offset);\n+\n+\t\tbyte[] bytes = new byte[size];\n+\t\tfile.read(bytes, 0, size );\n+\t\treturn bytes;\t\n+\t}\n+\t\n+\t/** \n+\t * Test for valid signature and size.\n+\t * @return true if the offset points to a valid End-of-Central-Directory-Record within \"bytes\"\n+\t */\n+\tprivate boolean isValidEoCDRec(byte[] bytes, int offset, int centralDirEndRecSize) {\n+\t\tif ( !isSignature(bytes, offset, EOCDR_SIGNATURE) \n+\t\t\t || !isValidEoCDRecSize(bytes, offset + EOCDR_COMMENT_LENGTH_OFFSET, centralDirEndRecSize)) {\n+\t\t\treturn false;\n+\t\t}\n+        return true;\n+\t}\n+\t\n+\t/**\n+\t * \n+\t * @return true if the signature parameter matches the bytes at offset\n+\t */\n+\tprivate boolean isSignature(byte[] bytes, int offset, int signature) {\n+\n+\t\tlong value = getSignature(bytes, offset);\n+\n+\t\treturn (value == signature);\n+\t}\n+\t\n+\tprivate boolean isValidEoCDRecSize(byte[] bytes, int offset, int size) {\n+\t\t// Size of central directory must be the structure size + comment\n+\t\t// First put length in little endian form (reverse the bytes).\n+\t\tlong commentLength = getLittleEndianValue(bytes, offset, 2);\n+\t\treturn size == (EOCDR_MIN_SIZE + commentLength);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "557cc66c2c7bbcbe803c2724e18ae288b8bbc2c1"}, "originalPosition": 392}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0cb9754350b295845c6903f1fdbda052ad040542", "author": {"user": {"login": "jimblye", "name": null}}, "url": "https://github.com/OpenLiberty/open-liberty/commit/0cb9754350b295845c6903f1fdbda052ad040542", "committedDate": "2020-11-05T01:44:27Z", "message": "Modifications from code review"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7f6420db8d47508ece8affb9ff5bc676e8924ece", "author": {"user": {"login": "jimblye", "name": null}}, "url": "https://github.com/OpenLiberty/open-liberty/commit/7f6420db8d47508ece8affb9ff5bc676e8924ece", "committedDate": "2020-11-05T01:48:37Z", "message": "Rename JavaArchive to ZipValidator, remove 'main' method"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f398c12dc9d7da8346fc53972c49d1d606579649", "author": {"user": {"login": "jimblye", "name": null}}, "url": "https://github.com/OpenLiberty/open-liberty/commit/f398c12dc9d7da8346fc53972c49d1d606579649", "committedDate": "2020-11-05T02:15:45Z", "message": "getActualArchiveOffset() changed to private"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "066d65c10ec5fdd378f1c718cee7c33ae902a7d8", "author": {"user": {"login": "jimblye", "name": null}}, "url": "https://github.com/OpenLiberty/open-liberty/commit/066d65c10ec5fdd378f1c718cee7c33ae902a7d8", "committedDate": "2020-11-05T16:09:21Z", "message": "Fix getBlockFrom...() methods when not enough data"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIzODg5NDg5", "url": "https://github.com/OpenLiberty/open-liberty/pull/14827#pullrequestreview-523889489", "createdAt": "2020-11-05T02:51:00Z", "commit": {"oid": "f398c12dc9d7da8346fc53972c49d1d606579649"}, "state": "APPROVED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNVQwMjo1MTowMFrOHtxsLw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNVQwMjo1Mjo0MVrOHtxtzA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzc2MjA5NQ==", "bodyText": "This test seems unnecessary: The read will fail if there aren't enough bytes in the file.", "url": "https://github.com/OpenLiberty/open-liberty/pull/14827#discussion_r517762095", "createdAt": "2020-11-05T02:51:00Z", "author": {"login": "tbitonti"}, "path": "dev/com.ibm.ws.artifact.zip/src/com/ibm/ws/artifact/zip/internal/ZipValidator.java", "diffHunk": "@@ -0,0 +1,483 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 IBM Corporation and others.\n+ * All rights reserved. This program and the accompanying materials\n+ * are made available under the terms of the Eclipse Public License v1.0\n+ * which accompanies this distribution, and is available at\n+ * http://www.eclipse.org/legal/epl-v10.html\n+ *\n+ * Contributors:\n+ *     IBM Corporation - initial API and implementation\n+ *******************************************************************************\n+ *\n+ * The purpose of this class is to test if a Java archive is valid without actually reading the entire JAR.\n+ * This is especially useful in cases where the archive has a script attached at the front of the file.\n+ * Of course, this is more of a sanity check than a rigorous validation, which would require reading the whole file.\n+ * \n+ *     [ script ]                   <---- start of file  (optional)\n+ *     [ local file header 1 ]      <---- actual start of archive\n+ *     [ encryption header 1 ]\n+ *     [ file data 1 ]\n+ *     [ data descriptor 1 ]\n+ *     . \n+ *     .\n+ *     .\n+ *     [ local file header n ]\n+ *     [ encryption header n ]\n+ *     [ file data n ]\n+ *     [ data descriptor n ]\n+ *     [ archive decryption header ] \n+ *     [ archive extra data record ] \n+ *     [ central directory header 1 ]       <---- start of central directory\n+ *     .\n+ *     .\n+ *     .\n+ *     [ central directory header n ]\n+ *     [ zip64 end of central directory record ]\n+ *     [ zip64 end of central directory locator ] \n+ *     [ end of central directory record ]\n+ * \n+ *  The validation calculates the size of the last 4 records listed above (as well as doing some\n+ *  validation checks on the sizes and signatures) and then calculates the actual offset\n+ *  of the archive within the file (which will normally be 0).  The final step is to check\n+ *  the signature at the beginning of the archive.\n+ *  \n+ *  The actual archive offset is calculated :\n+ *  \n+ *    fileLength - eocdRecordSize - zip64RecLengths - CentralDirectorySize - offsetOfCentralDirectory\n+ *   \n+ *   Note the offsetOfCentralDirectory is relative to the beginning of the actual archive (not an offset  \n+ *   from the beginning of the file.)  Subtracting away all of the known pieces gives us the unknown \n+ *   piece which is the actual archive offset.  \n+ */\n+\n+package com.ibm.ws.artifact.zip.internal;\n+\n+import java.io.IOException;\n+import java.io.RandomAccessFile;\n+import java.util.Arrays;\n+\n+public class ZipValidator {\n+\n+    // EOCDR is End-of-Central-Directory-Record\n+    private static final int EOCDR_MIN_SIZE = 22;\n+    private static final int EOCDR_MAX_COMMENT_LEN = 0xFFFF;\n+    private static final int EOCDR_MAX_SIZE = EOCDR_MIN_SIZE + EOCDR_MAX_COMMENT_LEN;\n+    private static final int EOCDR_SIGNATURE = 0x504b0506; \n+    private static final int EOCDR_TOTAL_ENTRIES_OFFSET = 10;\n+    private static final int ZIP64_INDICATOR = 0xFFFF;               // Indicates Zip64 when found at offset EOCDR_TOTAL_ENTRIES_OFFSET \n+    private static final int EOCDR_CENTRAL_DIR_SIZE_OFFSET = 12;     // Offset to size of central directory\n+    private static final int EOCDR_CENTRAL_DIR_OFFSET = 16;          // Offset to central directory relative to beginning of archive\n+    private static final int EOCDR_COMMENT_LENGTH_OFFSET = 20; \t     // Offset to comment length\n+\n+    // ZIP64_EOCDR is Zip64-End-of-Central-Directory-Record\n+    private static final int ZIP64_EOCDR_SIGNATURE = 0x504b0606;\n+    private static final int ZIP64_EOCDR_MINIMUM_SIZE = 56;\n+    private static final int ZIP64_EOCDR_HEADER_SIZE = 12;           // 4 bytes for the signature and 8 bytes for the length\n+    private static final int ZIP64_EOCDR_SIZE_OFFSET = 4;            // The size at this offset is the size of the zip64 EOCDR minus 12. (Meaning it does NOT include the 12-byte header)\n+    private static final int ZIP64_EOCDR_SIZE_FIELD_LENGTH = 8;      // Number of bytes for size field.\n+\n+    // ZIP64_LOCATOR is Zip64-End-of-Central-Directory-Record-Locator\n+    private static final int ZIP64_LOCATOR_SIGNATURE = 0x504b0607;\n+    private static final int ZIP64_LOCATOR_SIZE = 20;                // Fixed size.\n+    private static final int ZIP64_LOCATOR_EOCD_OFFSET_OFFSET = 8;   // Position in the locator of the offset of the Zip64-End-of-Central-Direcory-Record\n+\n+    private static final int LOCAL_FILE_HEADER_SIGNATURE = 0x504b0304;\n+    private static final int BLOCK_SIZE = 256;\n+    private static final int FORWARD_BLOCK_SIZE = 8192;\n+\n+    // Maximum amount of data (usually a script) that is allowed, by this implementation,\n+    // to be prepended to an archive in Zip64 format. This value may be increased, but it\n+    // increases the time it takes to fail when the zip is corrupted.  This limitation does \n+    // not apply to archives not in Zip64 format.\n+    private static final int MAX_PREFIX_ALLOWED_FOR_ZIP64 = 200*1024*1024;       \n+\n+    private byte[] _endOfCentralDirectoryRecord; // Only the minimum size is stored.  Does not include the comment \n+    private int    _eocdRecordSize;              // Actual size of End-of-Central-Directory-Record - including comment\n+    private byte[] _zip64EoCDRLocator;           // 20 bytes;\n+    private long   _zip64EoCDRLocatorOffset;     // Offset (from end of file) of the Zip64 Locator\n+    private byte[] _zip64EoCDR;                  // Only the minimum size is stored.  Does not include any extra fields.  \n+    private long   _zip64EoCDRecSize;            // Size of Zip64-End-of-Central-Directory-Record\n+    private String _archiveFileName;\n+    private long   _fileLength;                  // Length of the archive file\n+\n+    ZipValidator(String archiveFileName) {\n+        _archiveFileName = archiveFileName;\n+    }\n+\n+    /** \n+     * @return true if the archive has valid format\n+     */\n+    public boolean isValid() {\n+\n+        try ( RandomAccessFile file = new RandomAccessFile(_archiveFileName, \"r\") ) {\n+\n+            _fileLength = file.length();\n+            _endOfCentralDirectoryRecord = getEndOfCentralDirectoryRecord(file);\n+\n+            if ( isZip64() ) {\n+                _zip64EoCDRLocator = getZip64EoCDLocator(file);\n+                _zip64EoCDRLocatorOffset = _fileLength - _eocdRecordSize - ZIP64_LOCATOR_SIZE;\n+                _zip64EoCDR = getZip64EndOfCentralDirectoryRecord(file);\n+                _zip64EoCDRecSize = getZip64EoCDRecordSize( _zip64EoCDR, 0 );\n+            }\n+\n+            long archiveOffset = getActualArchiveOffset();\n+\n+            if (archiveStartsWithSignature(file, archiveOffset)) {\n+                return true;\n+            } \n+\n+        } catch (Exception e) {\n+            //ffdc\n+        }\n+\n+        return false;\n+    }\n+\n+    /**\n+     * Find the End-of-Central-Director-Record which is always at the end of the file.\n+     * It is usually 22 bytes but may contain a comment up to 64K in size.\n+     * Reads from the end of the file looking backwards for the EoCDR signature.\n+     * \n+     * The implementation reads the file in BLOCK_SIZE blocks from the end of the file\n+     * and searches each block.  Note that there is some overlap of the successive \n+     * blocks; EOCDR_MIN_SIZE bytes of overlap to be precise.  This is because the \n+     * record might start at the end of one block and finish in the next.\n+     * \n+     * @param file the zip file \n+     */\n+    private byte[] getEndOfCentralDirectoryRecord(RandomAccessFile file) throws IOException {\n+\n+        byte[] block = getBlockFromEndOfFile(file, null, BLOCK_SIZE, BLOCK_SIZE);\n+        int size = EOCDR_MIN_SIZE ;\n+        int offset = block.length - size;\n+        int offsetFromEnd = block.length - offset;   // offset from the end of the block (not the file)\n+\n+        if ( block.length < EOCDR_MIN_SIZE ) {\n+            throw new IOException(\"Not a valid zip file.  Less than minimum required length.\");\n+        }\n+\n+        // We will only enter this loop if a comment is attached to the End-of-Central-Directory-Record\n+        // ... or if the zip is invalid (doesn't have an End-of-Central-Directory-Record.\n+        // Note that isValidEoCDRec must have EOCDR_MIN_SIZE available at the end of the block\n+        // to avoid an exception because of a read past the end of the block.\n+        while ( !isValidEoCDRec( block, offset, size ) ) {\n+            size++;\n+            offsetFromEnd++;\n+\n+            if ( size > EOCDR_MAX_SIZE || size > _fileLength ) {\n+                throw new IOException(\"Cannot find central directory end record in zip.\");\n+            }\n+\n+            if ( offsetFromEnd > block.length ) {\n+\n+                block = getBlockFromEndOfFile(file, block, size + BLOCK_SIZE - EOCDR_MIN_SIZE, BLOCK_SIZE);\n+                offsetFromEnd = EOCDR_MIN_SIZE;\n+            }\n+            offset = block.length - offsetFromEnd;\t\t\t\n+        }\n+\n+        // Copy only the minimum end-of-central-directory-record, but record the actual size.  \n+        // No need to store the comment, which could be up to 64k.\t\t\n+        _eocdRecordSize = size;\n+        return Arrays.copyOfRange(block, offset, offset + EOCDR_MIN_SIZE ); \n+    }\n+\n+    /**\n+     * Get the 20-byte Zip64 Locator.  It must sit 20 bytes before the End-of-Central-Directory-Record.\n+     * @param file the zip file\n+     */\n+    private byte[] getZip64EoCDLocator(RandomAccessFile file) throws IOException {\n+\n+        if ( !isZip64() ) {\n+            return null;\n+        }\n+\n+        byte[] block = getBlockFromEndOfFile(file, \n+                                             null,\n+                                             _eocdRecordSize + ZIP64_LOCATOR_SIZE, \n+                                             ZIP64_LOCATOR_SIZE);\t\n+\n+        if ( !isValid_Zip64EoCDRLocator(block, 0)) {\n+            throw new IOException(\"Invalid Zip64-End-of-Central-Direcytory-Locator.\");\n+        }\n+\n+        return Arrays.copyOfRange(block, 0, ZIP64_LOCATOR_SIZE);\n+    }\n+\n+    /**\n+     * Locates the Zip64-End-of-Central-Directory-Record by using the offset \n+     * in the Zip64 Locator.  If not found there, it is assumed that data has\n+     * been prepended to the archive, and a forward search begins until we find the\n+     * correct signature.  Of course, a false signature could appear just about  \n+     * anywhere in the zip.  So the record must pass additional validation.\n+     * @param file a zip file\n+     * @return a copy of the Zip64-End-of-Central-Directory-Record\n+     */\n+    private byte[] getZip64EndOfCentralDirectoryRecord(RandomAccessFile file ) throws IOException {\n+\n+        if ( !isZip64() ) {\n+            return null;\n+        }\n+\n+        // The offset of the Zip64-End-of-Central-Directory-Record is found in the Zip64 locator at offset 8.\n+        // That offset will NOT be correct if data (i.e. a script) has been attached in front of the archive,\n+        // but in that case, the offset will be our starting point for the search.\n+        long zip64EoCDOffset = getLittleEndianValue( _zip64EoCDRLocator, ZIP64_LOCATOR_EOCD_OFFSET_OFFSET, 4);\n+\n+        byte [] block = getBlockFromBeginningOfFile(file, null, zip64EoCDOffset, ZIP64_EOCDR_MINIMUM_SIZE);\n+        if (block.length < ZIP64_EOCDR_MINIMUM_SIZE) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f398c12dc9d7da8346fc53972c49d1d606579649"}, "originalPosition": 229}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzc2MjUwOA==", "bodyText": "Hmm, what happens if the file has less than BLOCK_SIZE bytes?", "url": "https://github.com/OpenLiberty/open-liberty/pull/14827#discussion_r517762508", "createdAt": "2020-11-05T02:52:41Z", "author": {"login": "tbitonti"}, "path": "dev/com.ibm.ws.artifact.zip/src/com/ibm/ws/artifact/zip/internal/ZipValidator.java", "diffHunk": "@@ -0,0 +1,483 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 IBM Corporation and others.\n+ * All rights reserved. This program and the accompanying materials\n+ * are made available under the terms of the Eclipse Public License v1.0\n+ * which accompanies this distribution, and is available at\n+ * http://www.eclipse.org/legal/epl-v10.html\n+ *\n+ * Contributors:\n+ *     IBM Corporation - initial API and implementation\n+ *******************************************************************************\n+ *\n+ * The purpose of this class is to test if a Java archive is valid without actually reading the entire JAR.\n+ * This is especially useful in cases where the archive has a script attached at the front of the file.\n+ * Of course, this is more of a sanity check than a rigorous validation, which would require reading the whole file.\n+ * \n+ *     [ script ]                   <---- start of file  (optional)\n+ *     [ local file header 1 ]      <---- actual start of archive\n+ *     [ encryption header 1 ]\n+ *     [ file data 1 ]\n+ *     [ data descriptor 1 ]\n+ *     . \n+ *     .\n+ *     .\n+ *     [ local file header n ]\n+ *     [ encryption header n ]\n+ *     [ file data n ]\n+ *     [ data descriptor n ]\n+ *     [ archive decryption header ] \n+ *     [ archive extra data record ] \n+ *     [ central directory header 1 ]       <---- start of central directory\n+ *     .\n+ *     .\n+ *     .\n+ *     [ central directory header n ]\n+ *     [ zip64 end of central directory record ]\n+ *     [ zip64 end of central directory locator ] \n+ *     [ end of central directory record ]\n+ * \n+ *  The validation calculates the size of the last 4 records listed above (as well as doing some\n+ *  validation checks on the sizes and signatures) and then calculates the actual offset\n+ *  of the archive within the file (which will normally be 0).  The final step is to check\n+ *  the signature at the beginning of the archive.\n+ *  \n+ *  The actual archive offset is calculated :\n+ *  \n+ *    fileLength - eocdRecordSize - zip64RecLengths - CentralDirectorySize - offsetOfCentralDirectory\n+ *   \n+ *   Note the offsetOfCentralDirectory is relative to the beginning of the actual archive (not an offset  \n+ *   from the beginning of the file.)  Subtracting away all of the known pieces gives us the unknown \n+ *   piece which is the actual archive offset.  \n+ */\n+\n+package com.ibm.ws.artifact.zip.internal;\n+\n+import java.io.IOException;\n+import java.io.RandomAccessFile;\n+import java.util.Arrays;\n+\n+public class ZipValidator {\n+\n+    // EOCDR is End-of-Central-Directory-Record\n+    private static final int EOCDR_MIN_SIZE = 22;\n+    private static final int EOCDR_MAX_COMMENT_LEN = 0xFFFF;\n+    private static final int EOCDR_MAX_SIZE = EOCDR_MIN_SIZE + EOCDR_MAX_COMMENT_LEN;\n+    private static final int EOCDR_SIGNATURE = 0x504b0506; \n+    private static final int EOCDR_TOTAL_ENTRIES_OFFSET = 10;\n+    private static final int ZIP64_INDICATOR = 0xFFFF;               // Indicates Zip64 when found at offset EOCDR_TOTAL_ENTRIES_OFFSET \n+    private static final int EOCDR_CENTRAL_DIR_SIZE_OFFSET = 12;     // Offset to size of central directory\n+    private static final int EOCDR_CENTRAL_DIR_OFFSET = 16;          // Offset to central directory relative to beginning of archive\n+    private static final int EOCDR_COMMENT_LENGTH_OFFSET = 20; \t     // Offset to comment length\n+\n+    // ZIP64_EOCDR is Zip64-End-of-Central-Directory-Record\n+    private static final int ZIP64_EOCDR_SIGNATURE = 0x504b0606;\n+    private static final int ZIP64_EOCDR_MINIMUM_SIZE = 56;\n+    private static final int ZIP64_EOCDR_HEADER_SIZE = 12;           // 4 bytes for the signature and 8 bytes for the length\n+    private static final int ZIP64_EOCDR_SIZE_OFFSET = 4;            // The size at this offset is the size of the zip64 EOCDR minus 12. (Meaning it does NOT include the 12-byte header)\n+    private static final int ZIP64_EOCDR_SIZE_FIELD_LENGTH = 8;      // Number of bytes for size field.\n+\n+    // ZIP64_LOCATOR is Zip64-End-of-Central-Directory-Record-Locator\n+    private static final int ZIP64_LOCATOR_SIGNATURE = 0x504b0607;\n+    private static final int ZIP64_LOCATOR_SIZE = 20;                // Fixed size.\n+    private static final int ZIP64_LOCATOR_EOCD_OFFSET_OFFSET = 8;   // Position in the locator of the offset of the Zip64-End-of-Central-Direcory-Record\n+\n+    private static final int LOCAL_FILE_HEADER_SIGNATURE = 0x504b0304;\n+    private static final int BLOCK_SIZE = 256;\n+    private static final int FORWARD_BLOCK_SIZE = 8192;\n+\n+    // Maximum amount of data (usually a script) that is allowed, by this implementation,\n+    // to be prepended to an archive in Zip64 format. This value may be increased, but it\n+    // increases the time it takes to fail when the zip is corrupted.  This limitation does \n+    // not apply to archives not in Zip64 format.\n+    private static final int MAX_PREFIX_ALLOWED_FOR_ZIP64 = 200*1024*1024;       \n+\n+    private byte[] _endOfCentralDirectoryRecord; // Only the minimum size is stored.  Does not include the comment \n+    private int    _eocdRecordSize;              // Actual size of End-of-Central-Directory-Record - including comment\n+    private byte[] _zip64EoCDRLocator;           // 20 bytes;\n+    private long   _zip64EoCDRLocatorOffset;     // Offset (from end of file) of the Zip64 Locator\n+    private byte[] _zip64EoCDR;                  // Only the minimum size is stored.  Does not include any extra fields.  \n+    private long   _zip64EoCDRecSize;            // Size of Zip64-End-of-Central-Directory-Record\n+    private String _archiveFileName;\n+    private long   _fileLength;                  // Length of the archive file\n+\n+    ZipValidator(String archiveFileName) {\n+        _archiveFileName = archiveFileName;\n+    }\n+\n+    /** \n+     * @return true if the archive has valid format\n+     */\n+    public boolean isValid() {\n+\n+        try ( RandomAccessFile file = new RandomAccessFile(_archiveFileName, \"r\") ) {\n+\n+            _fileLength = file.length();\n+            _endOfCentralDirectoryRecord = getEndOfCentralDirectoryRecord(file);\n+\n+            if ( isZip64() ) {\n+                _zip64EoCDRLocator = getZip64EoCDLocator(file);\n+                _zip64EoCDRLocatorOffset = _fileLength - _eocdRecordSize - ZIP64_LOCATOR_SIZE;\n+                _zip64EoCDR = getZip64EndOfCentralDirectoryRecord(file);\n+                _zip64EoCDRecSize = getZip64EoCDRecordSize( _zip64EoCDR, 0 );\n+            }\n+\n+            long archiveOffset = getActualArchiveOffset();\n+\n+            if (archiveStartsWithSignature(file, archiveOffset)) {\n+                return true;\n+            } \n+\n+        } catch (Exception e) {\n+            //ffdc\n+        }\n+\n+        return false;\n+    }\n+\n+    /**\n+     * Find the End-of-Central-Director-Record which is always at the end of the file.\n+     * It is usually 22 bytes but may contain a comment up to 64K in size.\n+     * Reads from the end of the file looking backwards for the EoCDR signature.\n+     * \n+     * The implementation reads the file in BLOCK_SIZE blocks from the end of the file\n+     * and searches each block.  Note that there is some overlap of the successive \n+     * blocks; EOCDR_MIN_SIZE bytes of overlap to be precise.  This is because the \n+     * record might start at the end of one block and finish in the next.\n+     * \n+     * @param file the zip file \n+     */\n+    private byte[] getEndOfCentralDirectoryRecord(RandomAccessFile file) throws IOException {\n+\n+        byte[] block = getBlockFromEndOfFile(file, null, BLOCK_SIZE, BLOCK_SIZE);\n+        int size = EOCDR_MIN_SIZE ;\n+        int offset = block.length - size;\n+        int offsetFromEnd = block.length - offset;   // offset from the end of the block (not the file)\n+\n+        if ( block.length < EOCDR_MIN_SIZE ) {\n+            throw new IOException(\"Not a valid zip file.  Less than minimum required length.\");\n+        }\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f398c12dc9d7da8346fc53972c49d1d606579649"}, "originalPosition": 159}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "cd2d5bd778aa31e5d177d552b9469983eb03e545", "author": {"user": {"login": "jimblye", "name": null}}, "url": "https://github.com/OpenLiberty/open-liberty/commit/cd2d5bd778aa31e5d177d552b9469983eb03e545", "committedDate": "2020-11-05T16:46:22Z", "message": "White space only"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0562570757348c68c212439e4b2dc7c4e9a1bcb8", "author": {"user": {"login": "jimblye", "name": null}}, "url": "https://github.com/OpenLiberty/open-liberty/commit/0562570757348c68c212439e4b2dc7c4e9a1bcb8", "committedDate": "2020-11-05T20:08:33Z", "message": "Change IOException to ZipException.  Move message"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTI0NjU2ODEz", "url": "https://github.com/OpenLiberty/open-liberty/pull/14827#pullrequestreview-524656813", "createdAt": "2020-11-05T20:52:29Z", "commit": {"oid": "0562570757348c68c212439e4b2dc7c4e9a1bcb8"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "88b8398f553936d92b056424958762a8aa09f91c", "author": {"user": {"login": "jimblye", "name": null}}, "url": "https://github.com/OpenLiberty/open-liberty/commit/88b8398f553936d92b056424958762a8aa09f91c", "committedDate": "2020-11-05T23:18:49Z", "message": "Fix getBlockFromEndOfFile when too few bytes left"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ba8ef2ffad188163a0a2b7ef5b3429807b4d8009", "author": {"user": {"login": "jimblye", "name": null}}, "url": "https://github.com/OpenLiberty/open-liberty/commit/ba8ef2ffad188163a0a2b7ef5b3429807b4d8009", "committedDate": "2020-11-06T15:37:57Z", "message": "Remove System.out.println"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2930, "cost": 1, "resetAt": "2021-10-28T19:08:13Z"}}}