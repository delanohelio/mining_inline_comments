{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDgyMTcyMzQ5", "number": 13829, "title": "Implicit Converter Cache", "bodyText": "MP Config 1.2, 1.3 and 1.4 automatically create converters for types that have appropriate methods. This PR aims to cache them in a way which will not cause a memory leak.\n#build", "createdAt": "2020-09-08T16:47:42Z", "url": "https://github.com/OpenLiberty/open-liberty/pull/13829", "merged": true, "mergeCommit": {"oid": "b49ec7c7ff16918f0e1ea4781c1e9a849edfabcb"}, "closed": true, "closedAt": "2020-12-07T14:57:18Z", "author": {"login": "tevans78"}, "timelineItems": {"totalCount": 9, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdHm4fYAFqTQ4NjE1NjczNA==", "endCursor": "Y3Vyc29yOnYyOpPPAAABdi3ucVAFqTU0NDk1NjAzNw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDg2MTU2NzM0", "url": "https://github.com/OpenLiberty/open-liberty/pull/13829#pullrequestreview-486156734", "createdAt": "2020-09-10T17:28:33Z", "commit": {"oid": "c2e036eec97ed60c54ad13e72029a5158b852580"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMFQxNzoyODozNFrOHP-azQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMFQyMDozMjowNlrOHQEsXw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjUxMzM1Nw==", "bodyText": "I have concerns that the synchronizedMap will become a bottleneck.  Should you consider a ConcurrentHashmap?  Of course we can measure to see if it becomes a bottleneck if you want to wait for that before making a decision.", "url": "https://github.com/OpenLiberty/open-liberty/pull/13829#discussion_r486513357", "createdAt": "2020-09-10T17:28:34Z", "author": {"login": "jhanders34"}, "path": "dev/com.ibm.ws.microprofile.config.1.2/src/com/ibm/ws/microprofile/config12/converters/ImplicitConverter.java", "diffHunk": "@@ -28,117 +33,196 @@\n public class ImplicitConverter extends BuiltInConverter {\n \n     private static final TraceComponent tc = Tr.register(ImplicitConverter.class);\n-    private Method valueOfMethod;\n-    private final Constructor<?> ctor;\n-    private Method parseMethod;\n+    private final Function<String, ?> implicitFunction;\n \n-    @Trivial\n     /**\n      *\n      * @param converterType The class to convert using\n      */\n+    @Trivial\n     public ImplicitConverter(Class<?> converterType) {\n+        this(converterType, getImplicitFunction(converterType));\n+    }\n+\n+    @Trivial\n+    public ImplicitConverter(Class<?> converterType, Function<String, ?> implicitFunction) {\n         super(converterType);\n-        this.ctor = getConstructor(converterType);\n-        if (this.ctor == null) {\n-            this.valueOfMethod = getValueOfMethod(converterType);\n+        this.implicitFunction = implicitFunction;\n+    }\n+\n+    @Trivial\n+    private static Function<String, ?> getImplicitFunction(Class<?> converterType) {\n+        Function<String, ?> implicitFunction = null;\n+        implicitFunction = getConstructorFunction(converterType);\n+\n+        if (implicitFunction == null) {\n+            implicitFunction = getValueOfFunction(converterType);\n+        } else {\n+            if (TraceComponent.isAnyTracingEnabled() && tc.isDebugEnabled()) {\n+                Tr.debug(tc, \"Automatic converter for {0} using {1}\", converterType, \"constructor\");\n+            }\n         }\n-        if (this.ctor == null && this.valueOfMethod == null) {\n-            this.parseMethod = getParse(converterType);\n+        if (implicitFunction == null) {\n+            implicitFunction = getParseFunction(converterType);\n+        } else {\n+            if (TraceComponent.isAnyTracingEnabled() && tc.isDebugEnabled()) {\n+                Tr.debug(tc, \"Automatic converter for {0} using {1}\", converterType, \"valueOf\");\n+            }\n         }\n-\n-        if (this.ctor == null && this.valueOfMethod == null && this.parseMethod == null) {\n+        if (implicitFunction == null) {\n             throw new IllegalArgumentException(Tr.formatMessage(tc, \"implicit.string.constructor.method.not.found.CWMCG0017E\", converterType));\n         } else {\n             if (TraceComponent.isAnyTracingEnabled() && tc.isDebugEnabled()) {\n-                if (this.ctor != null) {\n-                    Tr.debug(tc, \"Automatic converter for {0} using {1}\", converterType, this.ctor);\n-                } else if (this.valueOfMethod != null) {\n-                    Tr.debug(tc, \"Automatic converter for {0} using {1}\", converterType, this.valueOfMethod);\n-                } else if (this.parseMethod != null) {\n-                    Tr.debug(tc, \"Automatic converter for {0} using {1}\", converterType, this.parseMethod);\n-                }\n+                Tr.debug(tc, \"Automatic converter for {0} using {1}\", converterType, \"parse\");\n             }\n         }\n+        return implicitFunction;\n     }\n \n     @FFDCIgnore(NoSuchMethodException.class)\n     @Trivial\n-    private static <M> Constructor<M> getConstructor(Class<M> reflectionClass) {\n-        Constructor<M> ctor = null;\n+    protected static <X> Function<String, X> getConstructorFunction(Class<X> reflectionClass) {\n+        Function<String, X> implicitFunction = null;\n         try {\n-            ctor = reflectionClass.getConstructor(String.class);\n+            Constructor<X> ctor = reflectionClass.getConstructor(String.class);\n+            implicitFunction = wrapConstructor(reflectionClass, ctor);\n         } catch (NoSuchMethodException e) {\n             //No FFDC\n         }\n-        return ctor;\n+\n+        return implicitFunction;\n     }\n \n-    @FFDCIgnore(NoSuchMethodException.class)\n     @Trivial\n-    private static Method getValueOfMethod(Class<?> reflectionClass) {\n-        Method method = null;\n-        try {\n-            method = reflectionClass.getMethod(\"valueOf\", String.class);\n-            if ((method.getModifiers() & Modifier.STATIC) == 0) {\n-                method = null;\n-            } else if (!reflectionClass.equals(method.getReturnType())) {\n-                method = null;\n-            }\n-        } catch (NoSuchMethodException e) {\n-            //No FFDC\n-        }\n+    protected static Function<String, ?> getValueOfFunction(Class<?> reflectionClass) {\n+        return getFunction(reflectionClass, \"valueOf\", String.class);\n+    }\n \n-        return method;\n+    @Trivial\n+    protected static Function<String, ?> getParseFunction(Class<?> reflectionClass) {\n+        return getFunction(reflectionClass, \"parse\", CharSequence.class);\n     }\n \n     @FFDCIgnore(NoSuchMethodException.class)\n     @Trivial\n-    private static Method getParse(Class<?> reflectionClass) {\n-        Method method = null;\n+    protected static Function<String, ?> getFunction(Class<?> reflectionClass, String methodName, Class<?>... paramTypes) {\n+        Function<String, ?> implicitFunction = null;\n         try {\n-            method = reflectionClass.getMethod(\"parse\", CharSequence.class);\n+            Method method = reflectionClass.getMethod(methodName, paramTypes);\n             if ((method.getModifiers() & Modifier.STATIC) == 0) {\n                 method = null;\n             } else if (!reflectionClass.equals(method.getReturnType())) {\n                 method = null;\n             }\n+\n+            if (method != null) {\n+                implicitFunction = wrapMethod(reflectionClass, method);\n+            }\n         } catch (NoSuchMethodException e) {\n             //No FFDC\n         }\n-        return method;\n+        return implicitFunction;\n+    }\n+\n+    @Trivial\n+    protected static <X> Function<String, X> wrapMethod(Class<X> reflectionClass, Method method) {\n+        return new MethodFunction<X>(reflectionClass, method);\n+    }\n+\n+    @Trivial\n+    protected static <X> Function<String, X> wrapConstructor(Class<X> reflectionClass, Constructor<X> ctor) {\n+        return new ConstructorFunction<X>(reflectionClass, ctor);\n     }\n \n     /** {@inheritDoc} */\n     @Override\n     public Object convert(String value) {\n-        Object converted = null;\n-        if (value != null) { //if the value is null then we always return null\n-            try {\n-                if (this.ctor != null) {\n-                    converted = this.ctor.newInstance(value);\n-                } else if (this.valueOfMethod != null) {\n-                    converted = this.valueOfMethod.invoke(null, value);\n-                } else if (this.parseMethod != null) {\n-                    converted = this.parseMethod.invoke(null, value);\n-                }\n-            } catch (InvocationTargetException e) {\n-                Throwable cause = e.getCause();\n-                if (cause instanceof IllegalArgumentException) {\n-                    throw (IllegalArgumentException) cause;\n-                } else {\n-                    throw new ConversionException(cause);\n-                }\n-            } catch (IllegalAccessException | InstantiationException e) {\n-                throw new ConversionException(e);\n-            }\n-        }\n-        return converted;\n+        return this.implicitFunction.apply(value);\n     }\n \n     /** {@inheritDoc} */\n     @Override\n     public String toString() {\n         return \"Implicit Converter for type \" + getType();\n     }\n+\n+    protected static class ConstructorFunction<X> implements Function<String, X> {\n+        private final static Map<Class<?>, Constructor<?>> constructorCache = Collections.synchronizedMap(new WeakHashMap<>());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c2e036eec97ed60c54ad13e72029a5158b852580"}, "originalPosition": 203}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjUxNDEwOA==", "bodyText": "This will still leak.  The WeakReference on a WeakHashMap is on the key.  The problem is that the value is a Constructor or Method.  Both of those Object types will also have a reference to the Class which will keep it from being garbage collected.", "url": "https://github.com/OpenLiberty/open-liberty/pull/13829#discussion_r486514108", "createdAt": "2020-09-10T17:29:49Z", "author": {"login": "jhanders34"}, "path": "dev/com.ibm.ws.microprofile.config.1.2/src/com/ibm/ws/microprofile/config12/converters/ImplicitConverter.java", "diffHunk": "@@ -28,117 +33,196 @@\n public class ImplicitConverter extends BuiltInConverter {\n \n     private static final TraceComponent tc = Tr.register(ImplicitConverter.class);\n-    private Method valueOfMethod;\n-    private final Constructor<?> ctor;\n-    private Method parseMethod;\n+    private final Function<String, ?> implicitFunction;\n \n-    @Trivial\n     /**\n      *\n      * @param converterType The class to convert using\n      */\n+    @Trivial\n     public ImplicitConverter(Class<?> converterType) {\n+        this(converterType, getImplicitFunction(converterType));\n+    }\n+\n+    @Trivial\n+    public ImplicitConverter(Class<?> converterType, Function<String, ?> implicitFunction) {\n         super(converterType);\n-        this.ctor = getConstructor(converterType);\n-        if (this.ctor == null) {\n-            this.valueOfMethod = getValueOfMethod(converterType);\n+        this.implicitFunction = implicitFunction;\n+    }\n+\n+    @Trivial\n+    private static Function<String, ?> getImplicitFunction(Class<?> converterType) {\n+        Function<String, ?> implicitFunction = null;\n+        implicitFunction = getConstructorFunction(converterType);\n+\n+        if (implicitFunction == null) {\n+            implicitFunction = getValueOfFunction(converterType);\n+        } else {\n+            if (TraceComponent.isAnyTracingEnabled() && tc.isDebugEnabled()) {\n+                Tr.debug(tc, \"Automatic converter for {0} using {1}\", converterType, \"constructor\");\n+            }\n         }\n-        if (this.ctor == null && this.valueOfMethod == null) {\n-            this.parseMethod = getParse(converterType);\n+        if (implicitFunction == null) {\n+            implicitFunction = getParseFunction(converterType);\n+        } else {\n+            if (TraceComponent.isAnyTracingEnabled() && tc.isDebugEnabled()) {\n+                Tr.debug(tc, \"Automatic converter for {0} using {1}\", converterType, \"valueOf\");\n+            }\n         }\n-\n-        if (this.ctor == null && this.valueOfMethod == null && this.parseMethod == null) {\n+        if (implicitFunction == null) {\n             throw new IllegalArgumentException(Tr.formatMessage(tc, \"implicit.string.constructor.method.not.found.CWMCG0017E\", converterType));\n         } else {\n             if (TraceComponent.isAnyTracingEnabled() && tc.isDebugEnabled()) {\n-                if (this.ctor != null) {\n-                    Tr.debug(tc, \"Automatic converter for {0} using {1}\", converterType, this.ctor);\n-                } else if (this.valueOfMethod != null) {\n-                    Tr.debug(tc, \"Automatic converter for {0} using {1}\", converterType, this.valueOfMethod);\n-                } else if (this.parseMethod != null) {\n-                    Tr.debug(tc, \"Automatic converter for {0} using {1}\", converterType, this.parseMethod);\n-                }\n+                Tr.debug(tc, \"Automatic converter for {0} using {1}\", converterType, \"parse\");\n             }\n         }\n+        return implicitFunction;\n     }\n \n     @FFDCIgnore(NoSuchMethodException.class)\n     @Trivial\n-    private static <M> Constructor<M> getConstructor(Class<M> reflectionClass) {\n-        Constructor<M> ctor = null;\n+    protected static <X> Function<String, X> getConstructorFunction(Class<X> reflectionClass) {\n+        Function<String, X> implicitFunction = null;\n         try {\n-            ctor = reflectionClass.getConstructor(String.class);\n+            Constructor<X> ctor = reflectionClass.getConstructor(String.class);\n+            implicitFunction = wrapConstructor(reflectionClass, ctor);\n         } catch (NoSuchMethodException e) {\n             //No FFDC\n         }\n-        return ctor;\n+\n+        return implicitFunction;\n     }\n \n-    @FFDCIgnore(NoSuchMethodException.class)\n     @Trivial\n-    private static Method getValueOfMethod(Class<?> reflectionClass) {\n-        Method method = null;\n-        try {\n-            method = reflectionClass.getMethod(\"valueOf\", String.class);\n-            if ((method.getModifiers() & Modifier.STATIC) == 0) {\n-                method = null;\n-            } else if (!reflectionClass.equals(method.getReturnType())) {\n-                method = null;\n-            }\n-        } catch (NoSuchMethodException e) {\n-            //No FFDC\n-        }\n+    protected static Function<String, ?> getValueOfFunction(Class<?> reflectionClass) {\n+        return getFunction(reflectionClass, \"valueOf\", String.class);\n+    }\n \n-        return method;\n+    @Trivial\n+    protected static Function<String, ?> getParseFunction(Class<?> reflectionClass) {\n+        return getFunction(reflectionClass, \"parse\", CharSequence.class);\n     }\n \n     @FFDCIgnore(NoSuchMethodException.class)\n     @Trivial\n-    private static Method getParse(Class<?> reflectionClass) {\n-        Method method = null;\n+    protected static Function<String, ?> getFunction(Class<?> reflectionClass, String methodName, Class<?>... paramTypes) {\n+        Function<String, ?> implicitFunction = null;\n         try {\n-            method = reflectionClass.getMethod(\"parse\", CharSequence.class);\n+            Method method = reflectionClass.getMethod(methodName, paramTypes);\n             if ((method.getModifiers() & Modifier.STATIC) == 0) {\n                 method = null;\n             } else if (!reflectionClass.equals(method.getReturnType())) {\n                 method = null;\n             }\n+\n+            if (method != null) {\n+                implicitFunction = wrapMethod(reflectionClass, method);\n+            }\n         } catch (NoSuchMethodException e) {\n             //No FFDC\n         }\n-        return method;\n+        return implicitFunction;\n+    }\n+\n+    @Trivial\n+    protected static <X> Function<String, X> wrapMethod(Class<X> reflectionClass, Method method) {\n+        return new MethodFunction<X>(reflectionClass, method);\n+    }\n+\n+    @Trivial\n+    protected static <X> Function<String, X> wrapConstructor(Class<X> reflectionClass, Constructor<X> ctor) {\n+        return new ConstructorFunction<X>(reflectionClass, ctor);\n     }\n \n     /** {@inheritDoc} */\n     @Override\n     public Object convert(String value) {\n-        Object converted = null;\n-        if (value != null) { //if the value is null then we always return null\n-            try {\n-                if (this.ctor != null) {\n-                    converted = this.ctor.newInstance(value);\n-                } else if (this.valueOfMethod != null) {\n-                    converted = this.valueOfMethod.invoke(null, value);\n-                } else if (this.parseMethod != null) {\n-                    converted = this.parseMethod.invoke(null, value);\n-                }\n-            } catch (InvocationTargetException e) {\n-                Throwable cause = e.getCause();\n-                if (cause instanceof IllegalArgumentException) {\n-                    throw (IllegalArgumentException) cause;\n-                } else {\n-                    throw new ConversionException(cause);\n-                }\n-            } catch (IllegalAccessException | InstantiationException e) {\n-                throw new ConversionException(e);\n-            }\n-        }\n-        return converted;\n+        return this.implicitFunction.apply(value);\n     }\n \n     /** {@inheritDoc} */\n     @Override\n     public String toString() {\n         return \"Implicit Converter for type \" + getType();\n     }\n+\n+    protected static class ConstructorFunction<X> implements Function<String, X> {\n+        private final static Map<Class<?>, Constructor<?>> constructorCache = Collections.synchronizedMap(new WeakHashMap<>());\n+        private final WeakReference<Class<?>> classRef;\n+\n+        protected ConstructorFunction(Class<X> conversionType, Constructor<X> ctor) {\n+            constructorCache.put(conversionType, ctor);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c2e036eec97ed60c54ad13e72029a5158b852580"}, "originalPosition": 207}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjUxNzMwNQ==", "bodyText": "Why do we need this cache at all?  Isn't the cache in the manager sufficient?", "url": "https://github.com/OpenLiberty/open-liberty/pull/13829#discussion_r486517305", "createdAt": "2020-09-10T17:35:24Z", "author": {"login": "jhanders34"}, "path": "dev/com.ibm.ws.microprofile.config.1.2/src/com/ibm/ws/microprofile/config12/converters/ImplicitConverter.java", "diffHunk": "@@ -28,117 +33,196 @@\n public class ImplicitConverter extends BuiltInConverter {\n \n     private static final TraceComponent tc = Tr.register(ImplicitConverter.class);\n-    private Method valueOfMethod;\n-    private final Constructor<?> ctor;\n-    private Method parseMethod;\n+    private final Function<String, ?> implicitFunction;\n \n-    @Trivial\n     /**\n      *\n      * @param converterType The class to convert using\n      */\n+    @Trivial\n     public ImplicitConverter(Class<?> converterType) {\n+        this(converterType, getImplicitFunction(converterType));\n+    }\n+\n+    @Trivial\n+    public ImplicitConverter(Class<?> converterType, Function<String, ?> implicitFunction) {\n         super(converterType);\n-        this.ctor = getConstructor(converterType);\n-        if (this.ctor == null) {\n-            this.valueOfMethod = getValueOfMethod(converterType);\n+        this.implicitFunction = implicitFunction;\n+    }\n+\n+    @Trivial\n+    private static Function<String, ?> getImplicitFunction(Class<?> converterType) {\n+        Function<String, ?> implicitFunction = null;\n+        implicitFunction = getConstructorFunction(converterType);\n+\n+        if (implicitFunction == null) {\n+            implicitFunction = getValueOfFunction(converterType);\n+        } else {\n+            if (TraceComponent.isAnyTracingEnabled() && tc.isDebugEnabled()) {\n+                Tr.debug(tc, \"Automatic converter for {0} using {1}\", converterType, \"constructor\");\n+            }\n         }\n-        if (this.ctor == null && this.valueOfMethod == null) {\n-            this.parseMethod = getParse(converterType);\n+        if (implicitFunction == null) {\n+            implicitFunction = getParseFunction(converterType);\n+        } else {\n+            if (TraceComponent.isAnyTracingEnabled() && tc.isDebugEnabled()) {\n+                Tr.debug(tc, \"Automatic converter for {0} using {1}\", converterType, \"valueOf\");\n+            }\n         }\n-\n-        if (this.ctor == null && this.valueOfMethod == null && this.parseMethod == null) {\n+        if (implicitFunction == null) {\n             throw new IllegalArgumentException(Tr.formatMessage(tc, \"implicit.string.constructor.method.not.found.CWMCG0017E\", converterType));\n         } else {\n             if (TraceComponent.isAnyTracingEnabled() && tc.isDebugEnabled()) {\n-                if (this.ctor != null) {\n-                    Tr.debug(tc, \"Automatic converter for {0} using {1}\", converterType, this.ctor);\n-                } else if (this.valueOfMethod != null) {\n-                    Tr.debug(tc, \"Automatic converter for {0} using {1}\", converterType, this.valueOfMethod);\n-                } else if (this.parseMethod != null) {\n-                    Tr.debug(tc, \"Automatic converter for {0} using {1}\", converterType, this.parseMethod);\n-                }\n+                Tr.debug(tc, \"Automatic converter for {0} using {1}\", converterType, \"parse\");\n             }\n         }\n+        return implicitFunction;\n     }\n \n     @FFDCIgnore(NoSuchMethodException.class)\n     @Trivial\n-    private static <M> Constructor<M> getConstructor(Class<M> reflectionClass) {\n-        Constructor<M> ctor = null;\n+    protected static <X> Function<String, X> getConstructorFunction(Class<X> reflectionClass) {\n+        Function<String, X> implicitFunction = null;\n         try {\n-            ctor = reflectionClass.getConstructor(String.class);\n+            Constructor<X> ctor = reflectionClass.getConstructor(String.class);\n+            implicitFunction = wrapConstructor(reflectionClass, ctor);\n         } catch (NoSuchMethodException e) {\n             //No FFDC\n         }\n-        return ctor;\n+\n+        return implicitFunction;\n     }\n \n-    @FFDCIgnore(NoSuchMethodException.class)\n     @Trivial\n-    private static Method getValueOfMethod(Class<?> reflectionClass) {\n-        Method method = null;\n-        try {\n-            method = reflectionClass.getMethod(\"valueOf\", String.class);\n-            if ((method.getModifiers() & Modifier.STATIC) == 0) {\n-                method = null;\n-            } else if (!reflectionClass.equals(method.getReturnType())) {\n-                method = null;\n-            }\n-        } catch (NoSuchMethodException e) {\n-            //No FFDC\n-        }\n+    protected static Function<String, ?> getValueOfFunction(Class<?> reflectionClass) {\n+        return getFunction(reflectionClass, \"valueOf\", String.class);\n+    }\n \n-        return method;\n+    @Trivial\n+    protected static Function<String, ?> getParseFunction(Class<?> reflectionClass) {\n+        return getFunction(reflectionClass, \"parse\", CharSequence.class);\n     }\n \n     @FFDCIgnore(NoSuchMethodException.class)\n     @Trivial\n-    private static Method getParse(Class<?> reflectionClass) {\n-        Method method = null;\n+    protected static Function<String, ?> getFunction(Class<?> reflectionClass, String methodName, Class<?>... paramTypes) {\n+        Function<String, ?> implicitFunction = null;\n         try {\n-            method = reflectionClass.getMethod(\"parse\", CharSequence.class);\n+            Method method = reflectionClass.getMethod(methodName, paramTypes);\n             if ((method.getModifiers() & Modifier.STATIC) == 0) {\n                 method = null;\n             } else if (!reflectionClass.equals(method.getReturnType())) {\n                 method = null;\n             }\n+\n+            if (method != null) {\n+                implicitFunction = wrapMethod(reflectionClass, method);\n+            }\n         } catch (NoSuchMethodException e) {\n             //No FFDC\n         }\n-        return method;\n+        return implicitFunction;\n+    }\n+\n+    @Trivial\n+    protected static <X> Function<String, X> wrapMethod(Class<X> reflectionClass, Method method) {\n+        return new MethodFunction<X>(reflectionClass, method);\n+    }\n+\n+    @Trivial\n+    protected static <X> Function<String, X> wrapConstructor(Class<X> reflectionClass, Constructor<X> ctor) {\n+        return new ConstructorFunction<X>(reflectionClass, ctor);\n     }\n \n     /** {@inheritDoc} */\n     @Override\n     public Object convert(String value) {\n-        Object converted = null;\n-        if (value != null) { //if the value is null then we always return null\n-            try {\n-                if (this.ctor != null) {\n-                    converted = this.ctor.newInstance(value);\n-                } else if (this.valueOfMethod != null) {\n-                    converted = this.valueOfMethod.invoke(null, value);\n-                } else if (this.parseMethod != null) {\n-                    converted = this.parseMethod.invoke(null, value);\n-                }\n-            } catch (InvocationTargetException e) {\n-                Throwable cause = e.getCause();\n-                if (cause instanceof IllegalArgumentException) {\n-                    throw (IllegalArgumentException) cause;\n-                } else {\n-                    throw new ConversionException(cause);\n-                }\n-            } catch (IllegalAccessException | InstantiationException e) {\n-                throw new ConversionException(e);\n-            }\n-        }\n-        return converted;\n+        return this.implicitFunction.apply(value);\n     }\n \n     /** {@inheritDoc} */\n     @Override\n     public String toString() {\n         return \"Implicit Converter for type \" + getType();\n     }\n+\n+    protected static class ConstructorFunction<X> implements Function<String, X> {\n+        private final static Map<Class<?>, Constructor<?>> constructorCache = Collections.synchronizedMap(new WeakHashMap<>());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjUxMzM1Nw=="}, "originalCommit": {"oid": "c2e036eec97ed60c54ad13e72029a5158b852580"}, "originalPosition": 203}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjU3MDQxNQ==", "bodyText": "Since you are not using Tr.formatMessage, the {0}  and {1} substitutions will not be used.  You might as well remove them to avoid the ugliness in trace.", "url": "https://github.com/OpenLiberty/open-liberty/pull/13829#discussion_r486570415", "createdAt": "2020-09-10T19:02:16Z", "author": {"login": "jhanders34"}, "path": "dev/com.ibm.ws.microprofile.config.1.3/src/com/ibm/ws/microprofile/config13/converters/Config13ImplicitConverter.java", "diffHunk": "@@ -43,138 +44,47 @@\n      * <li>the target type {@code T} has a {@code public static T parse(CharSequence)} method</li>\n      * </ul>\n      *\n-     *\n      * @param converterType The class to convert using\n      */\n-    public Config13ImplicitConverter(Class<?> converterType) {\n-        super(converterType);\n+    @Trivial\n+    private static Function<String, ?> getImplicitFunction(Class<?> converterType) {\n+        Function<String, ?> implicitFunction = null;\n \n-        this.ofMethod = getOfMethod(converterType);\n-        if (this.ofMethod == null) {\n-            this.valueOfMethod = getValueOfMethod(converterType);\n-            if (this.valueOfMethod == null) {\n-                this.ctor = getConstructor(converterType);\n-                if (this.ctor == null) {\n-                    this.parseMethod = getParse(converterType);\n-                }\n+        implicitFunction = getOfMethod(converterType);\n+        if (implicitFunction == null) {\n+            implicitFunction = getValueOfFunction(converterType);\n+        } else {\n+            if (TraceComponent.isAnyTracingEnabled() && tc.isDebugEnabled()) {\n+                Tr.debug(tc, \"Automatic converter for {0} using {1}\", converterType, \"of\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c2e036eec97ed60c54ad13e72029a5158b852580"}, "originalPosition": 75}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjYxNjE1OQ==", "bodyText": "I assume some of these base classes like BuiltinConverter and ImplicitConverter could move to the common bundle at some point?", "url": "https://github.com/OpenLiberty/open-liberty/pull/13829#discussion_r486616159", "createdAt": "2020-09-10T20:32:06Z", "author": {"login": "jhanders34"}, "path": "dev/com.ibm.ws.microprofile.config.1.2/src/com/ibm/ws/microprofile/config12/converters/ImplicitConverter.java", "diffHunk": "@@ -28,117 +33,196 @@\n public class ImplicitConverter extends BuiltInConverter {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c2e036eec97ed60c54ad13e72029a5158b852580"}, "originalPosition": 24}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "c2e036eec97ed60c54ad13e72029a5158b852580", "author": {"user": {"login": "tevans78", "name": "Tom Evans"}}, "url": "https://github.com/OpenLiberty/open-liberty/commit/c2e036eec97ed60c54ad13e72029a5158b852580", "committedDate": "2020-09-08T16:45:50Z", "message": "Implicit Converter Cache"}, "afterCommit": {"oid": "0571aee48ed225c10ccc532d022b16b8695d1af2", "author": {"user": {"login": "tevans78", "name": "Tom Evans"}}, "url": "https://github.com/OpenLiberty/open-liberty/commit/0571aee48ed225c10ccc532d022b16b8695d1af2", "committedDate": "2020-11-25T19:06:47Z", "message": "Implicit Converter Cache"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "0571aee48ed225c10ccc532d022b16b8695d1af2", "author": {"user": {"login": "tevans78", "name": "Tom Evans"}}, "url": "https://github.com/OpenLiberty/open-liberty/commit/0571aee48ed225c10ccc532d022b16b8695d1af2", "committedDate": "2020-11-25T19:06:47Z", "message": "Implicit Converter Cache"}, "afterCommit": {"oid": "3f4da57b9095ff5c672a5ab04862727d9411f4fd", "author": {"user": {"login": "tevans78", "name": "Tom Evans"}}, "url": "https://github.com/OpenLiberty/open-liberty/commit/3f4da57b9095ff5c672a5ab04862727d9411f4fd", "committedDate": "2020-11-30T16:19:36Z", "message": "Implicit Converter Cache"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "3f4da57b9095ff5c672a5ab04862727d9411f4fd", "author": {"user": {"login": "tevans78", "name": "Tom Evans"}}, "url": "https://github.com/OpenLiberty/open-liberty/commit/3f4da57b9095ff5c672a5ab04862727d9411f4fd", "committedDate": "2020-11-30T16:19:36Z", "message": "Implicit Converter Cache"}, "afterCommit": {"oid": "7aa0b6ebb4cfb262dd581116f78c601ff532388b", "author": {"user": {"login": "tevans78", "name": "Tom Evans"}}, "url": "https://github.com/OpenLiberty/open-liberty/commit/7aa0b6ebb4cfb262dd581116f78c601ff532388b", "committedDate": "2020-11-30T17:01:51Z", "message": "Implicit Converter Cache"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "13e4fcf74ef40868c9ec54b38a36c0e7930bdeaf", "author": {"user": {"login": "tevans78", "name": "Tom Evans"}}, "url": "https://github.com/OpenLiberty/open-liberty/commit/13e4fcf74ef40868c9ec54b38a36c0e7930bdeaf", "committedDate": "2020-11-30T17:18:49Z", "message": "Implicit Converter Cache"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "7aa0b6ebb4cfb262dd581116f78c601ff532388b", "author": {"user": {"login": "tevans78", "name": "Tom Evans"}}, "url": "https://github.com/OpenLiberty/open-liberty/commit/7aa0b6ebb4cfb262dd581116f78c601ff532388b", "committedDate": "2020-11-30T17:01:51Z", "message": "Implicit Converter Cache"}, "afterCommit": {"oid": "13e4fcf74ef40868c9ec54b38a36c0e7930bdeaf", "author": {"user": {"login": "tevans78", "name": "Tom Evans"}}, "url": "https://github.com/OpenLiberty/open-liberty/commit/13e4fcf74ef40868c9ec54b38a36c0e7930bdeaf", "committedDate": "2020-11-30T17:18:49Z", "message": "Implicit Converter Cache"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQ0MTY0Nzg5", "url": "https://github.com/OpenLiberty/open-liberty/pull/13829#pullrequestreview-544164789", "createdAt": "2020-12-03T16:45:41Z", "commit": {"oid": "13e4fcf74ef40868c9ec54b38a36c0e7930bdeaf"}, "state": "COMMENTED", "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wM1QxNjo0NTo0MlrOH-mNfg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wM1QxNzoyMTo0NlrOH-oLPA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTM5OTgwNg==", "bodyText": "There's nothing unchecked to suppress", "url": "https://github.com/OpenLiberty/open-liberty/pull/13829#discussion_r535399806", "createdAt": "2020-12-03T16:45:42Z", "author": {"login": "Azquelt"}, "path": "dev/com.ibm.ws.microprofile.config.1.2/src/com/ibm/ws/microprofile/config12/converters/ConstructorFunction.java", "diffHunk": "@@ -0,0 +1,64 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 IBM Corporation and others.\n+ * All rights reserved. This program and the accompanying materials\n+ * are made available under the terms of the Eclipse Public License v1.0\n+ * which accompanies this distribution, and is available at\n+ * http://www.eclipse.org/legal/epl-v10.html\n+ *\n+ * Contributors:\n+ *     IBM Corporation - initial API and implementation\n+ *******************************************************************************/\n+package com.ibm.ws.microprofile.config12.converters;\n+\n+import java.lang.reflect.Constructor;\n+import java.lang.reflect.InvocationTargetException;\n+import java.util.function.Function;\n+\n+import com.ibm.websphere.ras.annotation.Trivial;\n+import com.ibm.ws.ffdc.annotation.FFDCIgnore;\n+import com.ibm.ws.microprofile.config.interfaces.ConversionException;\n+\n+public class ConstructorFunction<X> implements Function<String, X> {\n+    private final Constructor<X> constructor;\n+\n+    public ConstructorFunction(Constructor<X> constructor) {\n+        this.constructor = constructor;\n+    }\n+\n+    /** {@inheritDoc} */\n+    @SuppressWarnings(\"unchecked\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "13e4fcf74ef40868c9ec54b38a36c0e7930bdeaf"}, "originalPosition": 29}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTQwODkzMA==", "bodyText": "I really don't like these multiply nested if blocks with the debug messages separated from the case that it relates to.\nIf you want to avoid early returns, I'd suggest\n        Function<String, X> implicitFunction = ConstructorFunction.getConstructorFunction(converterType);\n\n        if (implicitFunction != null && TraceComponent.isAnyTracingEnabled() && tc.isDebugEnabled()) {\n            Tr.debug(tc, \"Automatic converter for \" + converterType + \" using \\\"constructor\\\"\");\n        }\n\n        if (implicitFunction == null) {\n            implicitFunction = MethodFunction.getValueOfFunction(converterType);\n\n            if (implicitFunction != null && TraceComponent.isAnyTracingEnabled() && tc.isDebugEnabled()) {\n                Tr.debug(tc, \"Automatic converter for \" + converterType + \" using \\\"valueOf\\\"\");\n            }\n        }\n\n        if (implicitFunction == null) {\n            implicitFunction = MethodFunction.getParseFunction(converterType);\n\n            if (implicitFunction != null && TraceComponent.isAnyTracingEnabled() && tc.isDebugEnabled()) {\n                Tr.debug(tc, \"Automatic converter for \" + converterType + \" using \\\"parse\\\"\");\n            }\n        }\n\n        if (implicitFunction == null) {\n            throw new IllegalArgumentException(Tr.formatMessage(tc, \"implicit.string.constructor.method.not.found.CWMCG0017E\", converterType));\n        }\n\n        return implicitFunction;", "url": "https://github.com/OpenLiberty/open-liberty/pull/13829#discussion_r535408930", "createdAt": "2020-12-03T16:55:04Z", "author": {"login": "Azquelt"}, "path": "dev/com.ibm.ws.microprofile.config.1.2/src/com/ibm/ws/microprofile/config12/converters/ImplicitConverter.java", "diffHunk": "@@ -10,130 +10,65 @@\n  *******************************************************************************/\n package com.ibm.ws.microprofile.config12.converters;\n \n-import java.lang.reflect.Constructor;\n-import java.lang.reflect.InvocationTargetException;\n-import java.lang.reflect.Method;\n-import java.lang.reflect.Modifier;\n+import java.util.function.Function;\n \n import com.ibm.websphere.ras.Tr;\n import com.ibm.websphere.ras.TraceComponent;\n import com.ibm.websphere.ras.annotation.Trivial;\n-import com.ibm.ws.ffdc.annotation.FFDCIgnore;\n import com.ibm.ws.microprofile.config.converters.BuiltInConverter;\n-import com.ibm.ws.microprofile.config.interfaces.ConversionException;\n \n /**\n  *\n  */\n public class ImplicitConverter extends BuiltInConverter {\n \n     private static final TraceComponent tc = Tr.register(ImplicitConverter.class);\n-    private Method valueOfMethod;\n-    private final Constructor<?> ctor;\n-    private Method parseMethod;\n+    private final Function<String, ?> implicitFunction;\n \n-    @Trivial\n     /**\n      *\n      * @param converterType The class to convert using\n      */\n+    @Trivial\n     public ImplicitConverter(Class<?> converterType) {\n         super(converterType);\n-        this.ctor = getConstructor(converterType);\n-        if (this.ctor == null) {\n-            this.valueOfMethod = getValueOfMethod(converterType);\n-        }\n-        if (this.ctor == null && this.valueOfMethod == null) {\n-            this.parseMethod = getParse(converterType);\n-        }\n-\n-        if (this.ctor == null && this.valueOfMethod == null && this.parseMethod == null) {\n-            throw new IllegalArgumentException(Tr.formatMessage(tc, \"implicit.string.constructor.method.not.found.CWMCG0017E\", converterType));\n-        } else {\n-            if (TraceComponent.isAnyTracingEnabled() && tc.isDebugEnabled()) {\n-                if (this.ctor != null) {\n-                    Tr.debug(tc, \"Automatic converter for {0} using {1}\", converterType, this.ctor);\n-                } else if (this.valueOfMethod != null) {\n-                    Tr.debug(tc, \"Automatic converter for {0} using {1}\", converterType, this.valueOfMethod);\n-                } else if (this.parseMethod != null) {\n-                    Tr.debug(tc, \"Automatic converter for {0} using {1}\", converterType, this.parseMethod);\n-                }\n-            }\n-        }\n+        this.implicitFunction = getImplicitFunction(converterType);\n     }\n \n-    @FFDCIgnore(NoSuchMethodException.class)\n     @Trivial\n-    private static <M> Constructor<M> getConstructor(Class<M> reflectionClass) {\n-        Constructor<M> ctor = null;\n-        try {\n-            ctor = reflectionClass.getConstructor(String.class);\n-        } catch (NoSuchMethodException e) {\n-            //No FFDC\n-        }\n-        return ctor;\n-    }\n+    protected <X> Function<String, X> getImplicitFunction(Class<X> converterType) {\n+        Function<String, X> implicitFunction = ConstructorFunction.getConstructorFunction(converterType);\n \n-    @FFDCIgnore(NoSuchMethodException.class)\n-    @Trivial\n-    private static Method getValueOfMethod(Class<?> reflectionClass) {\n-        Method method = null;\n-        try {\n-            method = reflectionClass.getMethod(\"valueOf\", String.class);\n-            if ((method.getModifiers() & Modifier.STATIC) == 0) {\n-                method = null;\n-            } else if (!reflectionClass.equals(method.getReturnType())) {\n-                method = null;\n-            }\n-        } catch (NoSuchMethodException e) {\n-            //No FFDC\n-        }\n+        if (implicitFunction == null) {\n+            implicitFunction = MethodFunction.getValueOfFunction(converterType);\n \n-        return method;\n-    }\n+            if (implicitFunction == null) {\n+                implicitFunction = MethodFunction.getParseFunction(converterType);\n \n-    @FFDCIgnore(NoSuchMethodException.class)\n-    @Trivial\n-    private static Method getParse(Class<?> reflectionClass) {\n-        Method method = null;\n-        try {\n-            method = reflectionClass.getMethod(\"parse\", CharSequence.class);\n-            if ((method.getModifiers() & Modifier.STATIC) == 0) {\n-                method = null;\n-            } else if (!reflectionClass.equals(method.getReturnType())) {\n-                method = null;\n+                if (implicitFunction == null) {\n+                    throw new IllegalArgumentException(Tr.formatMessage(tc, \"implicit.string.constructor.method.not.found.CWMCG0017E\", converterType));\n+                } else {\n+                    if (TraceComponent.isAnyTracingEnabled() && tc.isDebugEnabled()) {\n+                        Tr.debug(tc, \"Automatic converter for \" + converterType + \" using \\\"parse\\\"\");\n+                    }\n+                }\n+            } else {\n+                if (TraceComponent.isAnyTracingEnabled() && tc.isDebugEnabled()) {\n+                    Tr.debug(tc, \"Automatic converter for \" + converterType + \" using \\\"valueOf\\\"\");\n+                }\n+            }\n+        } else {\n+            if (TraceComponent.isAnyTracingEnabled() && tc.isDebugEnabled()) {\n+                Tr.debug(tc, \"Automatic converter for \" + converterType + \" using \\\"constructor\\\"\");\n             }\n-        } catch (NoSuchMethodException e) {\n-            //No FFDC\n         }\n-        return method;\n+        return implicitFunction;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "13e4fcf74ef40868c9ec54b38a36c0e7930bdeaf"}, "originalPosition": 133}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTQyNzg5MQ==", "bodyText": "Should this have @FFDCIgnore since we're throwing the exception up to the user anyway?\nAn exception here presumably means they had a method or constructor to create an object from a String, but calling it threw an exception?", "url": "https://github.com/OpenLiberty/open-liberty/pull/13829#discussion_r535427891", "createdAt": "2020-12-03T17:15:48Z", "author": {"login": "Azquelt"}, "path": "dev/com.ibm.ws.microprofile.config.1.2/src/com/ibm/ws/microprofile/config12/converters/MethodFunction.java", "diffHunk": "@@ -0,0 +1,86 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 IBM Corporation and others.\n+ * All rights reserved. This program and the accompanying materials\n+ * are made available under the terms of the Eclipse Public License v1.0\n+ * which accompanies this distribution, and is available at\n+ * http://www.eclipse.org/legal/epl-v10.html\n+ *\n+ * Contributors:\n+ *     IBM Corporation - initial API and implementation\n+ *******************************************************************************/\n+package com.ibm.ws.microprofile.config12.converters;\n+\n+import java.lang.reflect.InvocationTargetException;\n+import java.lang.reflect.Method;\n+import java.lang.reflect.Modifier;\n+import java.util.function.Function;\n+\n+import com.ibm.websphere.ras.annotation.Trivial;\n+import com.ibm.ws.ffdc.annotation.FFDCIgnore;\n+import com.ibm.ws.microprofile.config.interfaces.ConversionException;\n+\n+public class MethodFunction<X> implements Function<String, X> {\n+    private final Method method;\n+\n+    protected MethodFunction(Method method) {\n+        this.method = method;\n+    }\n+\n+    /** {@inheritDoc} */\n+    @SuppressWarnings(\"unchecked\")\n+    @Override\n+    public X apply(String value) {\n+        X converted = null;\n+        if (value != null) { //if the value is null then we always return null\n+            try {\n+                converted = (X) method.invoke(null, value);\n+            } catch (InvocationTargetException e) {\n+                Throwable cause = e.getCause();\n+                if (cause instanceof IllegalArgumentException) {\n+                    throw (IllegalArgumentException) cause;\n+                } else {\n+                    throw new ConversionException(cause);\n+                }\n+            } catch (IllegalAccessException e) {\n+                throw new ConversionException(e);\n+            }\n+        }\n+        return converted;\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "13e4fcf74ef40868c9ec54b38a36c0e7930bdeaf"}, "originalPosition": 49}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTQyOTQ5NQ==", "bodyText": "Don't much like these nested ifs either.", "url": "https://github.com/OpenLiberty/open-liberty/pull/13829#discussion_r535429495", "createdAt": "2020-12-03T17:18:06Z", "author": {"login": "Azquelt"}, "path": "dev/com.ibm.ws.microprofile.config.1.3/src/com/ibm/ws/microprofile/config13/converters/Config13ImplicitConverter.java", "diffHunk": "@@ -43,138 +42,60 @@\n      * <li>the target type {@code T} has a {@code public static T parse(CharSequence)} method</li>\n      * </ul>\n      *\n-     *\n      * @param converterType The class to convert using\n      */\n-    public Config13ImplicitConverter(Class<?> converterType) {\n-        super(converterType);\n-\n-        this.ofMethod = getOfMethod(converterType);\n-        if (this.ofMethod == null) {\n-            this.valueOfMethod = getValueOfMethod(converterType);\n-            if (this.valueOfMethod == null) {\n-                this.ctor = getConstructor(converterType);\n-                if (this.ctor == null) {\n-                    this.parseMethod = getParse(converterType);\n+    @Override\n+    @Trivial\n+    protected <X> Function<String, X> getImplicitFunction(Class<X> converterType) {\n+        Function<String, X> implicitFunction = null;\n+\n+        implicitFunction = MethodFunction.getOfMethod(converterType);\n+        if (implicitFunction == null) {\n+            implicitFunction = MethodFunction.getValueOfFunction(converterType);\n+            if (implicitFunction == null) {\n+                implicitFunction = ConstructorFunction.getConstructorFunction(converterType);\n+                if (implicitFunction == null) {\n+                    implicitFunction = MethodFunction.getParseFunction(converterType);\n+                    if (implicitFunction == null) {\n+                        throw new IllegalArgumentException(Tr.formatMessage(tc, \"implicit.string.constructor.method.not.found.CWMCG0017E\", converterType));\n+                    } else {\n+                        if (TraceComponent.isAnyTracingEnabled() && tc.isDebugEnabled()) {\n+                            Tr.debug(tc, Tr.formatMessage(tc, \"Automatic converter for \" + converterType + \" using \\\"parse\\\"\"));\n+                        }\n+                    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "13e4fcf74ef40868c9ec54b38a36c0e7930bdeaf"}, "originalPosition": 82}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTQzMDUwOA==", "bodyText": "Should this method have @FFDCIgnore? At the moment we would get an FFDC from the MethodFunction and then another one here. We shouldn't need both, right?", "url": "https://github.com/OpenLiberty/open-liberty/pull/13829#discussion_r535430508", "createdAt": "2020-12-03T17:19:37Z", "author": {"login": "Azquelt"}, "path": "dev/com.ibm.ws.microprofile.config.1.3/src/com/ibm/ws/microprofile/config13/converters/Config13ImplicitConverter.java", "diffHunk": "@@ -43,138 +42,60 @@\n      * <li>the target type {@code T} has a {@code public static T parse(CharSequence)} method</li>\n      * </ul>\n      *\n-     *\n      * @param converterType The class to convert using\n      */\n-    public Config13ImplicitConverter(Class<?> converterType) {\n-        super(converterType);\n-\n-        this.ofMethod = getOfMethod(converterType);\n-        if (this.ofMethod == null) {\n-            this.valueOfMethod = getValueOfMethod(converterType);\n-            if (this.valueOfMethod == null) {\n-                this.ctor = getConstructor(converterType);\n-                if (this.ctor == null) {\n-                    this.parseMethod = getParse(converterType);\n+    @Override\n+    @Trivial\n+    protected <X> Function<String, X> getImplicitFunction(Class<X> converterType) {\n+        Function<String, X> implicitFunction = null;\n+\n+        implicitFunction = MethodFunction.getOfMethod(converterType);\n+        if (implicitFunction == null) {\n+            implicitFunction = MethodFunction.getValueOfFunction(converterType);\n+            if (implicitFunction == null) {\n+                implicitFunction = ConstructorFunction.getConstructorFunction(converterType);\n+                if (implicitFunction == null) {\n+                    implicitFunction = MethodFunction.getParseFunction(converterType);\n+                    if (implicitFunction == null) {\n+                        throw new IllegalArgumentException(Tr.formatMessage(tc, \"implicit.string.constructor.method.not.found.CWMCG0017E\", converterType));\n+                    } else {\n+                        if (TraceComponent.isAnyTracingEnabled() && tc.isDebugEnabled()) {\n+                            Tr.debug(tc, Tr.formatMessage(tc, \"Automatic converter for \" + converterType + \" using \\\"parse\\\"\"));\n+                        }\n+                    }\n+                } else {\n+                    if (TraceComponent.isAnyTracingEnabled() && tc.isDebugEnabled()) {\n+                        Tr.debug(tc, \"Automatic converter for \" + converterType + \" using \\\"constructor\\\"\");\n+                    }\n+                }\n+            } else {\n+                if (TraceComponent.isAnyTracingEnabled() && tc.isDebugEnabled()) {\n+                    Tr.debug(tc, \"Automatic converter for \" + converterType + \" using \\\"valueOf\\\"\");\n                 }\n             }\n-        }\n-\n-        if (this.ofMethod == null && this.valueOfMethod == null && this.ctor == null && this.parseMethod == null) {\n-            throw new IllegalArgumentException(Tr.formatMessage(tc, \"implicit.string.constructor.method.not.found.CWMCG0017E\", converterType));\n         } else {\n             if (TraceComponent.isAnyTracingEnabled() && tc.isDebugEnabled()) {\n-                if (this.ofMethod != null) {\n-                    Tr.debug(tc, \"Automatic converter for {0} using {1}\", converterType, this.ofMethod);\n-                } else if (this.valueOfMethod != null) {\n-                    Tr.debug(tc, \"Automatic converter for {0} using {1}\", converterType, this.valueOfMethod);\n-                } else if (this.ctor != null) {\n-                    Tr.debug(tc, \"Automatic converter for {0} using {1}\", converterType, this.ctor);\n-                } else if (this.parseMethod != null) {\n-                    Tr.debug(tc, \"Automatic converter for {0} using {1}\", converterType, this.parseMethod);\n-                }\n+                Tr.debug(tc, \"Automatic converter for \" + converterType + \" using \\\"of\\\"\");\n             }\n         }\n-    }\n \n-    @FFDCIgnore(NoSuchMethodException.class)\n-    @Trivial\n-    private static <M> Constructor<M> getConstructor(Class<M> reflectionClass) {\n-        Constructor<M> ctor = null;\n-        try {\n-            ctor = reflectionClass.getConstructor(String.class);\n-        } catch (NoSuchMethodException e) {\n-            //No FFDC\n-        }\n-        return ctor;\n-    }\n-\n-    @FFDCIgnore(NoSuchMethodException.class)\n-    @Trivial\n-    private static Method getOfMethod(Class<?> reflectionClass) {\n-        Method method = null;\n-        try {\n-            method = reflectionClass.getMethod(\"of\", String.class);\n-            if ((method.getModifiers() & Modifier.STATIC) == 0) {\n-                method = null;\n-            } else if (!reflectionClass.equals(method.getReturnType())) {\n-                method = null;\n-            }\n-        } catch (NoSuchMethodException e) {\n-            //No FFDC\n-        }\n-\n-        return method;\n-    }\n-\n-    @FFDCIgnore(NoSuchMethodException.class)\n-    @Trivial\n-    private static Method getValueOfMethod(Class<?> reflectionClass) {\n-        Method method = null;\n-        try {\n-            method = reflectionClass.getMethod(\"valueOf\", String.class);\n-            if ((method.getModifiers() & Modifier.STATIC) == 0) {\n-                method = null;\n-            } else if (!reflectionClass.equals(method.getReturnType())) {\n-                method = null;\n-            }\n-        } catch (NoSuchMethodException e) {\n-            //No FFDC\n-        }\n-\n-        return method;\n-    }\n-\n-    @FFDCIgnore(NoSuchMethodException.class)\n-    @Trivial\n-    private static Method getParse(Class<?> reflectionClass) {\n-        Method method = null;\n-        try {\n-            method = reflectionClass.getMethod(\"parse\", CharSequence.class);\n-            if ((method.getModifiers() & Modifier.STATIC) == 0) {\n-                method = null;\n-            } else if (!reflectionClass.equals(method.getReturnType())) {\n-                method = null;\n-            }\n-        } catch (NoSuchMethodException e) {\n-            //No FFDC\n-        }\n-        return method;\n+        return implicitFunction;\n     }\n \n     /** {@inheritDoc} */\n     @Override\n     public Object convert(String value) {\n-        Object converted = null;\n-        if (value != null) { //if the value is null then we always return null\n-            try {\n-\n-                if (this.ofMethod != null) {\n-                    converted = this.ofMethod.invoke(null, value);\n-                } else if (this.valueOfMethod != null) {\n-                    converted = this.valueOfMethod.invoke(null, value);\n-                } else if (this.ctor != null) {\n-                    converted = this.ctor.newInstance(value);\n-                } else if (this.parseMethod != null) {\n-                    converted = this.parseMethod.invoke(null, value);\n-                }\n-            } catch (InvocationTargetException e) {\n-                Throwable cause = e.getCause();\n-                if (cause instanceof IllegalArgumentException) {\n-                    throw (IllegalArgumentException) cause;\n-                } else {\n-                    throw new IllegalArgumentException(cause);\n-                }\n-            } catch (IllegalAccessException | InstantiationException e) {\n-                throw new IllegalArgumentException(e);\n+        try {\n+            return super.convert(value);\n+        } catch (ConversionException e) { //The Config 1.3 spec clarified that the convert method should throw IllegalArgumentException\n+                                          //if the value cannot be converted to the specified type\n+            Throwable cause = e.getCause();\n+            if (cause instanceof IllegalArgumentException) {\n+                throw (IllegalArgumentException) cause;\n+            } else {\n+                throw new IllegalArgumentException(cause);\n             }\n         }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "13e4fcf74ef40868c9ec54b38a36c0e7930bdeaf"}, "originalPosition": 214}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTQzMTk5Ng==", "bodyText": "More nested ifs", "url": "https://github.com/OpenLiberty/open-liberty/pull/13829#discussion_r535431996", "createdAt": "2020-12-03T17:21:46Z", "author": {"login": "Azquelt"}, "path": "dev/com.ibm.ws.microprofile.config.1.4/src/com/ibm/ws/microprofile/config14/converters/Config14ImplicitConverter.java", "diffHunk": "@@ -46,135 +44,41 @@\n      *\n      * @param converterType The class to convert using\n      */\n-    public Config14ImplicitConverter(Class<?> converterType) {\n-        super(converterType);\n-\n-        this.ofMethod = getOfMethod(converterType);\n-        if (this.ofMethod == null) {\n-            this.valueOfMethod = getValueOfMethod(converterType);\n-            if (this.valueOfMethod == null) {\n-                this.parseMethod = getParse(converterType);\n-                if (this.parseMethod == null) {\n-                    this.ctor = getConstructor(converterType);\n+    @Override\n+    @Trivial\n+    protected <X> Function<String, X> getImplicitFunction(Class<X> converterType) {\n+        Function<String, X> implicitFunction = null;\n+\n+        implicitFunction = MethodFunction.getOfMethod(converterType);\n+        if (implicitFunction == null) {\n+            implicitFunction = MethodFunction.getValueOfFunction(converterType);\n+            if (implicitFunction == null) {\n+                implicitFunction = MethodFunction.getParseFunction(converterType);\n+                if (implicitFunction == null) {\n+                    implicitFunction = ConstructorFunction.getConstructorFunction(converterType);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "13e4fcf74ef40868c9ec54b38a36c0e7930bdeaf"}, "originalPosition": 64}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "00af5b5a5f4f3fb67a35cab7d1eca5dcc058437e", "author": {"user": {"login": "tevans78", "name": "Tom Evans"}}, "url": "https://github.com/OpenLiberty/open-liberty/commit/00af5b5a5f4f3fb67a35cab7d1eca5dcc058437e", "committedDate": "2020-12-04T13:15:30Z", "message": "Update FFDCIgnore and some debug processing"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQ0OTU2MDM3", "url": "https://github.com/OpenLiberty/open-liberty/pull/13829#pullrequestreview-544956037", "createdAt": "2020-12-04T13:26:10Z", "commit": {"oid": "00af5b5a5f4f3fb67a35cab7d1eca5dcc058437e"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3319, "cost": 1, "resetAt": "2021-10-28T19:08:13Z"}}}