{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzkwNjA4NDU2", "number": 11374, "reviewThreads": {"totalCount": 74, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOVQxOTo1OTo0NVrODpqGmQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wNlQxODowNzoyNlrODvPtjg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ1MDA4MDI1OnYy", "diffSide": "RIGHT", "path": "dev/com.ibm.ws.security.acme_fat/fat/src/com/ibm/ws/security/acme/docker/BoulderContainer.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOVQxOTo1OTo0NVrOF4-VlQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOVQxOTo1OTo0NVrOF4-VlQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTI4NTkwOQ==", "bodyText": "Add copyright.", "url": "https://github.com/OpenLiberty/open-liberty/pull/11374#discussion_r395285909", "createdAt": "2020-03-19T19:59:45Z", "author": {"login": "jvanhill"}, "path": "dev/com.ibm.ws.security.acme_fat/fat/src/com/ibm/ws/security/acme/docker/BoulderContainer.java", "diffHunk": "@@ -0,0 +1,253 @@\n+package com.ibm.ws.security.acme.docker;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3dd0ccb898e794282f2c55bdc25f1b9f77207045"}, "originalPosition": 1}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ1MDEyMjc3OnYy", "diffSide": "RIGHT", "path": "dev/com.ibm.ws.security.acme_fat/fat/src/com/ibm/ws/security/acme/docker/BoulderContainer.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOVQyMDoxMzoxN1rOF4-w2Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOVQyMDoxMzoxN1rOF4-w2Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTI5Mjg4OQ==", "bodyText": "No doc, does this override a method?", "url": "https://github.com/OpenLiberty/open-liberty/pull/11374#discussion_r395292889", "createdAt": "2020-03-19T20:13:17Z", "author": {"login": "jvanhill"}, "path": "dev/com.ibm.ws.security.acme_fat/fat/src/com/ibm/ws/security/acme/docker/BoulderContainer.java", "diffHunk": "@@ -0,0 +1,253 @@\n+package com.ibm.ws.security.acme.docker;\n+\n+import java.io.IOException;\n+import java.security.cert.X509Certificate;\n+import java.time.Duration;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import org.apache.http.StatusLine;\n+import org.apache.http.client.methods.CloseableHttpResponse;\n+import org.apache.http.client.methods.HttpGet;\n+import org.apache.http.client.methods.HttpPost;\n+import org.apache.http.entity.ContentType;\n+import org.apache.http.entity.StringEntity;\n+import org.apache.http.impl.client.CloseableHttpClient;\n+import org.apache.http.impl.client.HttpClients;\n+import org.apache.http.util.EntityUtils;\n+import org.testcontainers.containers.GenericContainer;\n+import org.testcontainers.containers.Network;\n+import org.testcontainers.utility.MountableFile;\n+\n+import com.github.dockerjava.api.model.ContainerNetwork;\n+import com.github.dockerjava.api.model.ContainerNetwork.Ipam;\n+import com.ibm.websphere.simplicity.log.Log;\n+import com.ibm.ws.security.acme.utils.AcmeFatUtils;\n+\n+public class BoulderContainer extends CAContainer {\n+\n+\tpublic static final int HTTP_PORT = 5002;\n+\n+\t/** The port used to listen for incoming ACME requests. */\n+\tpublic static final int LISTEN_PORT = 4001;\n+\n+\t/** The REST management API port. */\n+\tpublic static final int MANAGEMENT_PORT = 8055;\n+    \n+    public final Network bluenet = Network.builder()\n+            .createNetworkCmdModifier(cmd -> {\n+                cmd.withDriver(\"bridge\");\n+                cmd.withIpam(new com.github.dockerjava.api.model.Network.Ipam()\n+                        .withDriver(\"default\")\n+                        .withConfig(new com.github.dockerjava.api.model.Network.Ipam.Config()\n+                                .withSubnet(\"10.77.77.0/24\")));\n+            })\n+            .build();\n+\n+    public final Network rednet =  Network.builder()\n+            .createNetworkCmdModifier(cmd -> {\n+                cmd.withDriver(\"bridge\");\n+                cmd.withIpam(new com.github.dockerjava.api.model.Network.Ipam()\n+                        .withDriver(\"default\")\n+                        .withConfig(new com.github.dockerjava.api.model.Network.Ipam.Config()\n+                                .withSubnet(\"10.88.88.0/24\")));\n+            })\n+            .build();\n+    \n+    public final GenericContainer<?> bhsm = new GenericContainer<>(IMAGE)\n+            .withEnv(\"PKCS11_DAEMON_SOCKET\", \"tcp://0.0.0.0:5657\")\n+            .withExposedPorts(5657)\n+            .withNetwork(bluenet)\n+            .withNetworkAliases(\"boulder-hsm\")\n+            .withCommand(\"/usr/local/bin/pkcs11-daemon /usr/lib/softhsm/libsofthsm2.so\")\n+            .withLogConsumer(o -> System.out.print(\"[HSM] \" + o.getUtf8String()));\n+    \n+    public final GenericContainer<?> bmysql = new GenericContainer<>(\"mariadb:10.3\")\n+            .withNetwork(bluenet)\n+            .withExposedPorts(3306)\n+            .withNetworkAliases(\"boulder-mysql\")\n+            .withEnv(\"MYSQL_ALLOW_EMPTY_PASSWORD\", \"yes\")\n+            .withCommand(\"mysqld --bind-address=0.0.0.0 --slow-query-log --log-output=TABLE --log-queries-not-using-indexes=ON\")\n+            .withLogConsumer(o -> System.out.print(\"[SQL] \" + o.getUtf8String()));\n+    \n+    private static final String IMAGE = \"ryanesch/acme-boulder:latest\";\n+    \n+    public BoulderContainer() {\n+        super(IMAGE);\n+    }\n+    \n+    @Override\n+    protected void configure() {\n+            this.withEnv(\"FAKE_DNS\", \"172.17.0.68\")\n+            .withEnv(\"PKCS11_PROXY_SOCKET\", \"tcp://boulder-hsm:5657\")\n+            .withEnv(\"BOULDER_CONFIG_DIR\", \"test/config\")\n+            .withEnv(\"GO111MODULE\", \"on\")\n+            .withEnv(\"GOFLAGS\", \"-mod=vendor\")\n+            .withEnv(\"PYTHONIOENCODING\", \"utf-8\")\n+            .withCreateContainerCmdModifier(cmd -> {\n+                cmd.withDns(\"10.77.77.77\");\n+            })\n+            \n+            .withWorkingDirectory(\"/go/src/github.com/letsencrypt/boulder\")\n+            .withCommand(\"/go/src/github.com/letsencrypt/boulder/test/entrypoint.sh\")\n+            .withNetworkAliases(\"boulder\")\n+            .withCreateContainerCmdModifier(cmd -> cmd.withHostName(\"boulder\"))\n+    \t\t.withExposedPorts(MANAGEMENT_PORT, LISTEN_PORT)\n+            .withLogConsumer(o -> System.out.print(\"[BOL] \" + o.getUtf8String()))\n+            .withStartupTimeout(Duration.ofMinutes(3));\n+    }\n+    \t\t\t\t\t\t\t\t\t\n+    \t\t\t\t\t\t\t\n+    \t\t\t\t\t\t\t\t\t\n+\n+    @Override\n+    protected void containerIsCreated(String containerId) {\n+        getDockerClient().connectToNetworkCmd()\n+                .withNetworkId(bluenet.getId())\n+                .withContainerId(containerId)\n+                .withContainerNetwork(new ContainerNetwork()\n+                        .withIpv4Address(\"10.77.77.77\")\n+                        .withNetworkID(bluenet.getId())\n+                        .withIpamConfig(new Ipam().withIpv4Address(\"10.77.77.77\"))\n+                        .withAliases(\"sa1.boulder\", \"ca1.boulder\", \"ra1.boulder\", \"va1.boulder\", \"publisher1.boulder\", \n+                              \"ocsp-updater.boulder\", \"admin-revoker.boulder\", \"nonce1.boulder\"))\n+                .exec();\n+        \n+        getDockerClient().connectToNetworkCmd()\n+                .withNetworkId(rednet.getId())\n+                .withContainerId(containerId)\n+                .withContainerNetwork(new ContainerNetwork()\n+                        .withIpv4Address(\"10.88.88.88\")\n+                        .withNetworkID(rednet.getId())\n+                        .withIpamConfig(new Ipam().withIpv4Address(\"10.88.88.88\"))\n+                        .withAliases(\"sa2.boulder\", \"ca2.boulder\", \"ra2.boulder\", \"va2.boulder\", \n+                                \"publisher2.boulder\", \"nonce2.boulder\"))\n+                .exec();\n+    }\n+    \n+    @Override\n+    public void start() {\n+        bmysql.start();\n+        bhsm.start();\n+        super.start();\n+    }\n+    \n+\tpublic byte[] getAcmeCaIntermediateCertificate() throws Exception {\n+\t\tfinal String METHOD_NAME = \"getAcmeCaIntermediateCertificate()\";\n+\t\tString url = \"https://\" + this.getContainerIpAddress() + \":\" + this.getMappedPort(MANAGEMENT_PORT)\n+\t\t\t\t+ \"/intermediates/0\";\n+\n+\t\ttry (CloseableHttpClient httpclient = AcmeFatUtils.getInsecureHttpsClient()) {\n+\t\t\t/*\n+\t\t\t * Create a GET request to the ACME CA server.\n+\t\t\t */\n+\t\t\tHttpGet httpGet = new HttpGet(url);\n+\n+\t\t\t/*\n+\t\t\t * Send the GET request and process the response.\n+\t\t\t */\n+\t\t\ttry (final CloseableHttpResponse response = httpclient.execute(httpGet)) {\n+\t\t\t\tAcmeFatUtils.logHttpResponse(BoulderContainer.class, METHOD_NAME, httpGet, response);\n+\n+\t\t\t\tStatusLine statusLine = response.getStatusLine();\n+\n+\t\t\t\tif (statusLine.getStatusCode() != 200) {\n+\t\t\t\t\tthrow new IOException(\n+\t\t\t\t\t\t\tMETHOD_NAME + \": Expected response 200, but received response: \" + statusLine);\n+\t\t\t\t}\n+\n+\t\t\t\tbyte[] result = EntityUtils.toByteArray(response.getEntity());\n+\n+\t\t\t\tLog.info(BoulderContainer.class, METHOD_NAME, new String(result));\n+\t\t\t\treturn result;\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\tpublic byte[] getAcmeCaRootCertificate() throws Exception {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3dd0ccb898e794282f2c55bdc25f1b9f77207045"}, "originalPosition": 167}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ1MDEyNTA2OnYy", "diffSide": "RIGHT", "path": "dev/com.ibm.ws.security.acme_fat/fat/src/com/ibm/ws/security/acme/docker/BoulderContainer.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOVQyMDoxMzo1M1rOF4-yXA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOVQyMDoxMzo1M1rOF4-yXA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTI5MzI3Ng==", "bodyText": "No doc. Does this override a method? how is this different than the method in CAContainer?", "url": "https://github.com/OpenLiberty/open-liberty/pull/11374#discussion_r395293276", "createdAt": "2020-03-19T20:13:53Z", "author": {"login": "jvanhill"}, "path": "dev/com.ibm.ws.security.acme_fat/fat/src/com/ibm/ws/security/acme/docker/BoulderContainer.java", "diffHunk": "@@ -0,0 +1,253 @@\n+package com.ibm.ws.security.acme.docker;\n+\n+import java.io.IOException;\n+import java.security.cert.X509Certificate;\n+import java.time.Duration;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import org.apache.http.StatusLine;\n+import org.apache.http.client.methods.CloseableHttpResponse;\n+import org.apache.http.client.methods.HttpGet;\n+import org.apache.http.client.methods.HttpPost;\n+import org.apache.http.entity.ContentType;\n+import org.apache.http.entity.StringEntity;\n+import org.apache.http.impl.client.CloseableHttpClient;\n+import org.apache.http.impl.client.HttpClients;\n+import org.apache.http.util.EntityUtils;\n+import org.testcontainers.containers.GenericContainer;\n+import org.testcontainers.containers.Network;\n+import org.testcontainers.utility.MountableFile;\n+\n+import com.github.dockerjava.api.model.ContainerNetwork;\n+import com.github.dockerjava.api.model.ContainerNetwork.Ipam;\n+import com.ibm.websphere.simplicity.log.Log;\n+import com.ibm.ws.security.acme.utils.AcmeFatUtils;\n+\n+public class BoulderContainer extends CAContainer {\n+\n+\tpublic static final int HTTP_PORT = 5002;\n+\n+\t/** The port used to listen for incoming ACME requests. */\n+\tpublic static final int LISTEN_PORT = 4001;\n+\n+\t/** The REST management API port. */\n+\tpublic static final int MANAGEMENT_PORT = 8055;\n+    \n+    public final Network bluenet = Network.builder()\n+            .createNetworkCmdModifier(cmd -> {\n+                cmd.withDriver(\"bridge\");\n+                cmd.withIpam(new com.github.dockerjava.api.model.Network.Ipam()\n+                        .withDriver(\"default\")\n+                        .withConfig(new com.github.dockerjava.api.model.Network.Ipam.Config()\n+                                .withSubnet(\"10.77.77.0/24\")));\n+            })\n+            .build();\n+\n+    public final Network rednet =  Network.builder()\n+            .createNetworkCmdModifier(cmd -> {\n+                cmd.withDriver(\"bridge\");\n+                cmd.withIpam(new com.github.dockerjava.api.model.Network.Ipam()\n+                        .withDriver(\"default\")\n+                        .withConfig(new com.github.dockerjava.api.model.Network.Ipam.Config()\n+                                .withSubnet(\"10.88.88.0/24\")));\n+            })\n+            .build();\n+    \n+    public final GenericContainer<?> bhsm = new GenericContainer<>(IMAGE)\n+            .withEnv(\"PKCS11_DAEMON_SOCKET\", \"tcp://0.0.0.0:5657\")\n+            .withExposedPorts(5657)\n+            .withNetwork(bluenet)\n+            .withNetworkAliases(\"boulder-hsm\")\n+            .withCommand(\"/usr/local/bin/pkcs11-daemon /usr/lib/softhsm/libsofthsm2.so\")\n+            .withLogConsumer(o -> System.out.print(\"[HSM] \" + o.getUtf8String()));\n+    \n+    public final GenericContainer<?> bmysql = new GenericContainer<>(\"mariadb:10.3\")\n+            .withNetwork(bluenet)\n+            .withExposedPorts(3306)\n+            .withNetworkAliases(\"boulder-mysql\")\n+            .withEnv(\"MYSQL_ALLOW_EMPTY_PASSWORD\", \"yes\")\n+            .withCommand(\"mysqld --bind-address=0.0.0.0 --slow-query-log --log-output=TABLE --log-queries-not-using-indexes=ON\")\n+            .withLogConsumer(o -> System.out.print(\"[SQL] \" + o.getUtf8String()));\n+    \n+    private static final String IMAGE = \"ryanesch/acme-boulder:latest\";\n+    \n+    public BoulderContainer() {\n+        super(IMAGE);\n+    }\n+    \n+    @Override\n+    protected void configure() {\n+            this.withEnv(\"FAKE_DNS\", \"172.17.0.68\")\n+            .withEnv(\"PKCS11_PROXY_SOCKET\", \"tcp://boulder-hsm:5657\")\n+            .withEnv(\"BOULDER_CONFIG_DIR\", \"test/config\")\n+            .withEnv(\"GO111MODULE\", \"on\")\n+            .withEnv(\"GOFLAGS\", \"-mod=vendor\")\n+            .withEnv(\"PYTHONIOENCODING\", \"utf-8\")\n+            .withCreateContainerCmdModifier(cmd -> {\n+                cmd.withDns(\"10.77.77.77\");\n+            })\n+            \n+            .withWorkingDirectory(\"/go/src/github.com/letsencrypt/boulder\")\n+            .withCommand(\"/go/src/github.com/letsencrypt/boulder/test/entrypoint.sh\")\n+            .withNetworkAliases(\"boulder\")\n+            .withCreateContainerCmdModifier(cmd -> cmd.withHostName(\"boulder\"))\n+    \t\t.withExposedPorts(MANAGEMENT_PORT, LISTEN_PORT)\n+            .withLogConsumer(o -> System.out.print(\"[BOL] \" + o.getUtf8String()))\n+            .withStartupTimeout(Duration.ofMinutes(3));\n+    }\n+    \t\t\t\t\t\t\t\t\t\n+    \t\t\t\t\t\t\t\n+    \t\t\t\t\t\t\t\t\t\n+\n+    @Override\n+    protected void containerIsCreated(String containerId) {\n+        getDockerClient().connectToNetworkCmd()\n+                .withNetworkId(bluenet.getId())\n+                .withContainerId(containerId)\n+                .withContainerNetwork(new ContainerNetwork()\n+                        .withIpv4Address(\"10.77.77.77\")\n+                        .withNetworkID(bluenet.getId())\n+                        .withIpamConfig(new Ipam().withIpv4Address(\"10.77.77.77\"))\n+                        .withAliases(\"sa1.boulder\", \"ca1.boulder\", \"ra1.boulder\", \"va1.boulder\", \"publisher1.boulder\", \n+                              \"ocsp-updater.boulder\", \"admin-revoker.boulder\", \"nonce1.boulder\"))\n+                .exec();\n+        \n+        getDockerClient().connectToNetworkCmd()\n+                .withNetworkId(rednet.getId())\n+                .withContainerId(containerId)\n+                .withContainerNetwork(new ContainerNetwork()\n+                        .withIpv4Address(\"10.88.88.88\")\n+                        .withNetworkID(rednet.getId())\n+                        .withIpamConfig(new Ipam().withIpv4Address(\"10.88.88.88\"))\n+                        .withAliases(\"sa2.boulder\", \"ca2.boulder\", \"ra2.boulder\", \"va2.boulder\", \n+                                \"publisher2.boulder\", \"nonce2.boulder\"))\n+                .exec();\n+    }\n+    \n+    @Override\n+    public void start() {\n+        bmysql.start();\n+        bhsm.start();\n+        super.start();\n+    }\n+    \n+\tpublic byte[] getAcmeCaIntermediateCertificate() throws Exception {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3dd0ccb898e794282f2c55bdc25f1b9f77207045"}, "originalPosition": 135}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ1MDEyNjExOnYy", "diffSide": "RIGHT", "path": "dev/com.ibm.ws.security.acme_fat/fat/src/com/ibm/ws/security/acme/docker/CAContainer.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOVQyMDoxNDoxOFrOF4-zDg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOVQyMDoxNDoxOFrOF4-zDg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTI5MzQ1NA==", "bodyText": "Copyright is missing.", "url": "https://github.com/OpenLiberty/open-liberty/pull/11374#discussion_r395293454", "createdAt": "2020-03-19T20:14:18Z", "author": {"login": "jvanhill"}, "path": "dev/com.ibm.ws.security.acme_fat/fat/src/com/ibm/ws/security/acme/docker/CAContainer.java", "diffHunk": "@@ -0,0 +1,372 @@\n+package com.ibm.ws.security.acme.docker;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3dd0ccb898e794282f2c55bdc25f1b9f77207045"}, "originalPosition": 1}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ1MDEzMDA2OnYy", "diffSide": "RIGHT", "path": "dev/com.ibm.ws.security.acme_fat/fat/src/com/ibm/ws/security/acme/docker/CAContainer.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOVQyMDoxNToyOVrOF4-1fQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wNlQxNzozOTo0OFrOGBiyUA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTI5NDA3Nw==", "bodyText": "Should this be static? Or does each override it?", "url": "https://github.com/OpenLiberty/open-liberty/pull/11374#discussion_r395294077", "createdAt": "2020-03-19T20:15:29Z", "author": {"login": "jvanhill"}, "path": "dev/com.ibm.ws.security.acme_fat/fat/src/com/ibm/ws/security/acme/docker/CAContainer.java", "diffHunk": "@@ -0,0 +1,372 @@\n+package com.ibm.ws.security.acme.docker;\n+\n+import static junit.framework.Assert.fail;\n+\n+import java.io.IOException;\n+import java.security.cert.X509Certificate;\n+import java.util.Map.Entry;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import org.apache.http.StatusLine;\n+import org.apache.http.client.methods.CloseableHttpResponse;\n+import org.apache.http.client.methods.HttpGet;\n+import org.apache.http.client.methods.HttpPost;\n+import org.apache.http.entity.ContentType;\n+import org.apache.http.entity.StringEntity;\n+import org.apache.http.impl.client.CloseableHttpClient;\n+import org.apache.http.impl.client.HttpClients;\n+import org.apache.http.util.EntityUtils;\n+import org.testcontainers.containers.GenericContainer;\n+import org.testcontainers.images.builder.ImageFromDockerfile;\n+\n+import com.github.dockerjava.api.model.ContainerNetwork;\n+import com.ibm.websphere.simplicity.log.Log;\n+import com.ibm.ws.security.acme.utils.AcmeFatUtils;\n+\n+public class CAContainer extends GenericContainer<BoulderContainer> {\n+\n+\n+\tpublic static final int HTTP_PORT = 5002;\n+\n+\t/** The REST management API port. */\n+\tpublic int MANAGEMENT_PORT = 8055;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3dd0ccb898e794282f2c55bdc25f1b9f77207045"}, "originalPosition": 33}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTMwMzUwNQ==", "bodyText": "I see you set this in the construct. This field is confusing since it ghosted statically in the child classes. They won't all agree, which could be confusing.", "url": "https://github.com/OpenLiberty/open-liberty/pull/11374#discussion_r395303505", "createdAt": "2020-03-19T20:33:46Z", "author": {"login": "jvanhill"}, "path": "dev/com.ibm.ws.security.acme_fat/fat/src/com/ibm/ws/security/acme/docker/CAContainer.java", "diffHunk": "@@ -0,0 +1,372 @@\n+package com.ibm.ws.security.acme.docker;\n+\n+import static junit.framework.Assert.fail;\n+\n+import java.io.IOException;\n+import java.security.cert.X509Certificate;\n+import java.util.Map.Entry;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import org.apache.http.StatusLine;\n+import org.apache.http.client.methods.CloseableHttpResponse;\n+import org.apache.http.client.methods.HttpGet;\n+import org.apache.http.client.methods.HttpPost;\n+import org.apache.http.entity.ContentType;\n+import org.apache.http.entity.StringEntity;\n+import org.apache.http.impl.client.CloseableHttpClient;\n+import org.apache.http.impl.client.HttpClients;\n+import org.apache.http.util.EntityUtils;\n+import org.testcontainers.containers.GenericContainer;\n+import org.testcontainers.images.builder.ImageFromDockerfile;\n+\n+import com.github.dockerjava.api.model.ContainerNetwork;\n+import com.ibm.websphere.simplicity.log.Log;\n+import com.ibm.ws.security.acme.utils.AcmeFatUtils;\n+\n+public class CAContainer extends GenericContainer<BoulderContainer> {\n+\n+\n+\tpublic static final int HTTP_PORT = 5002;\n+\n+\t/** The REST management API port. */\n+\tpublic int MANAGEMENT_PORT = 8055;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTI5NDA3Nw=="}, "originalCommit": {"oid": "3dd0ccb898e794282f2c55bdc25f1b9f77207045"}, "originalPosition": 33}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDI3MTY5Ng==", "bodyText": "Rename so it follows java naming guidelines (camel-case) as it is not a constant.", "url": "https://github.com/OpenLiberty/open-liberty/pull/11374#discussion_r404271696", "createdAt": "2020-04-06T17:39:48Z", "author": {"login": "jvanhill"}, "path": "dev/com.ibm.ws.security.acme_fat/fat/src/com/ibm/ws/security/acme/docker/CAContainer.java", "diffHunk": "@@ -0,0 +1,372 @@\n+package com.ibm.ws.security.acme.docker;\n+\n+import static junit.framework.Assert.fail;\n+\n+import java.io.IOException;\n+import java.security.cert.X509Certificate;\n+import java.util.Map.Entry;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import org.apache.http.StatusLine;\n+import org.apache.http.client.methods.CloseableHttpResponse;\n+import org.apache.http.client.methods.HttpGet;\n+import org.apache.http.client.methods.HttpPost;\n+import org.apache.http.entity.ContentType;\n+import org.apache.http.entity.StringEntity;\n+import org.apache.http.impl.client.CloseableHttpClient;\n+import org.apache.http.impl.client.HttpClients;\n+import org.apache.http.util.EntityUtils;\n+import org.testcontainers.containers.GenericContainer;\n+import org.testcontainers.images.builder.ImageFromDockerfile;\n+\n+import com.github.dockerjava.api.model.ContainerNetwork;\n+import com.ibm.websphere.simplicity.log.Log;\n+import com.ibm.ws.security.acme.utils.AcmeFatUtils;\n+\n+public class CAContainer extends GenericContainer<BoulderContainer> {\n+\n+\n+\tpublic static final int HTTP_PORT = 5002;\n+\n+\t/** The REST management API port. */\n+\tpublic int MANAGEMENT_PORT = 8055;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTI5NDA3Nw=="}, "originalCommit": {"oid": "3dd0ccb898e794282f2c55bdc25f1b9f77207045"}, "originalPosition": 33}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ1MDEzMDY3OnYy", "diffSide": "RIGHT", "path": "dev/com.ibm.ws.security.acme_fat/fat/src/com/ibm/ws/security/acme/docker/CAContainer.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOVQyMDoxNTozOVrOF4-13Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOVQyMDoxNTozOVrOF4-13Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTI5NDE3Mw==", "bodyText": "Javadoc.\nShould this also be an abstract class?", "url": "https://github.com/OpenLiberty/open-liberty/pull/11374#discussion_r395294173", "createdAt": "2020-03-19T20:15:39Z", "author": {"login": "jvanhill"}, "path": "dev/com.ibm.ws.security.acme_fat/fat/src/com/ibm/ws/security/acme/docker/CAContainer.java", "diffHunk": "@@ -0,0 +1,372 @@\n+package com.ibm.ws.security.acme.docker;\n+\n+import static junit.framework.Assert.fail;\n+\n+import java.io.IOException;\n+import java.security.cert.X509Certificate;\n+import java.util.Map.Entry;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import org.apache.http.StatusLine;\n+import org.apache.http.client.methods.CloseableHttpResponse;\n+import org.apache.http.client.methods.HttpGet;\n+import org.apache.http.client.methods.HttpPost;\n+import org.apache.http.entity.ContentType;\n+import org.apache.http.entity.StringEntity;\n+import org.apache.http.impl.client.CloseableHttpClient;\n+import org.apache.http.impl.client.HttpClients;\n+import org.apache.http.util.EntityUtils;\n+import org.testcontainers.containers.GenericContainer;\n+import org.testcontainers.images.builder.ImageFromDockerfile;\n+\n+import com.github.dockerjava.api.model.ContainerNetwork;\n+import com.ibm.websphere.simplicity.log.Log;\n+import com.ibm.ws.security.acme.utils.AcmeFatUtils;\n+\n+public class CAContainer extends GenericContainer<BoulderContainer> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3dd0ccb898e794282f2c55bdc25f1b9f77207045"}, "originalPosition": 27}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ1MDEzMjE2OnYy", "diffSide": "RIGHT", "path": "dev/com.ibm.ws.security.acme_fat/fat/src/com/ibm/ws/security/acme/docker/CAContainer.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOVQyMDoxNjowNlrOF4-2wQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOVQyMDoxNjowNlrOF4-2wQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTI5NDQwMQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t * Get Pebble's intermediate certificate.\n          \n          \n            \n            \t * Get the CA server's intermediate certificate.", "url": "https://github.com/OpenLiberty/open-liberty/pull/11374#discussion_r395294401", "createdAt": "2020-03-19T20:16:06Z", "author": {"login": "jvanhill"}, "path": "dev/com.ibm.ws.security.acme_fat/fat/src/com/ibm/ws/security/acme/docker/CAContainer.java", "diffHunk": "@@ -0,0 +1,372 @@\n+package com.ibm.ws.security.acme.docker;\n+\n+import static junit.framework.Assert.fail;\n+\n+import java.io.IOException;\n+import java.security.cert.X509Certificate;\n+import java.util.Map.Entry;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import org.apache.http.StatusLine;\n+import org.apache.http.client.methods.CloseableHttpResponse;\n+import org.apache.http.client.methods.HttpGet;\n+import org.apache.http.client.methods.HttpPost;\n+import org.apache.http.entity.ContentType;\n+import org.apache.http.entity.StringEntity;\n+import org.apache.http.impl.client.CloseableHttpClient;\n+import org.apache.http.impl.client.HttpClients;\n+import org.apache.http.util.EntityUtils;\n+import org.testcontainers.containers.GenericContainer;\n+import org.testcontainers.images.builder.ImageFromDockerfile;\n+\n+import com.github.dockerjava.api.model.ContainerNetwork;\n+import com.ibm.websphere.simplicity.log.Log;\n+import com.ibm.ws.security.acme.utils.AcmeFatUtils;\n+\n+public class CAContainer extends GenericContainer<BoulderContainer> {\n+\n+\n+\tpublic static final int HTTP_PORT = 5002;\n+\n+\t/** The REST management API port. */\n+\tpublic int MANAGEMENT_PORT = 8055;\n+\t\n+\tpublic CAContainer(String image) {\n+\t\tsuper(image);\n+\t}\n+\n+\tpublic CAContainer(ImageFromDockerfile image, int managementPort) {\n+\t\tsuper(image);\n+\t\tMANAGEMENT_PORT = managementPort;\n+\t}\n+\n+\n+\t/**\n+\t * Get Pebble's intermediate certificate.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3dd0ccb898e794282f2c55bdc25f1b9f77207045"}, "originalPosition": 46}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ1MDEzNDY1OnYy", "diffSide": "RIGHT", "path": "dev/com.ibm.ws.security.acme_fat/fat/src/com/ibm/ws/security/acme/docker/CAContainer.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOVQyMDoxNjo1MFrOF4-4UA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOVQyMDoxNjo1MFrOF4-4UA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTI5NDgwMA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t * @return Pebble's root CA certificate in the form of a PEM file.\n          \n          \n            \n            \t * @return The CA's intermediate certificate in the form of PEM contained in a byte array.", "url": "https://github.com/OpenLiberty/open-liberty/pull/11374#discussion_r395294800", "createdAt": "2020-03-19T20:16:50Z", "author": {"login": "jvanhill"}, "path": "dev/com.ibm.ws.security.acme_fat/fat/src/com/ibm/ws/security/acme/docker/CAContainer.java", "diffHunk": "@@ -0,0 +1,372 @@\n+package com.ibm.ws.security.acme.docker;\n+\n+import static junit.framework.Assert.fail;\n+\n+import java.io.IOException;\n+import java.security.cert.X509Certificate;\n+import java.util.Map.Entry;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import org.apache.http.StatusLine;\n+import org.apache.http.client.methods.CloseableHttpResponse;\n+import org.apache.http.client.methods.HttpGet;\n+import org.apache.http.client.methods.HttpPost;\n+import org.apache.http.entity.ContentType;\n+import org.apache.http.entity.StringEntity;\n+import org.apache.http.impl.client.CloseableHttpClient;\n+import org.apache.http.impl.client.HttpClients;\n+import org.apache.http.util.EntityUtils;\n+import org.testcontainers.containers.GenericContainer;\n+import org.testcontainers.images.builder.ImageFromDockerfile;\n+\n+import com.github.dockerjava.api.model.ContainerNetwork;\n+import com.ibm.websphere.simplicity.log.Log;\n+import com.ibm.ws.security.acme.utils.AcmeFatUtils;\n+\n+public class CAContainer extends GenericContainer<BoulderContainer> {\n+\n+\n+\tpublic static final int HTTP_PORT = 5002;\n+\n+\t/** The REST management API port. */\n+\tpublic int MANAGEMENT_PORT = 8055;\n+\t\n+\tpublic CAContainer(String image) {\n+\t\tsuper(image);\n+\t}\n+\n+\tpublic CAContainer(ImageFromDockerfile image, int managementPort) {\n+\t\tsuper(image);\n+\t\tMANAGEMENT_PORT = managementPort;\n+\t}\n+\n+\n+\t/**\n+\t * Get Pebble's intermediate certificate.\n+\t * \n+\t * @param fileName\n+\t *            The name of the file to save the certificate to.\n+\t * @return Pebble's root CA certificate in the form of a PEM file.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3dd0ccb898e794282f2c55bdc25f1b9f77207045"}, "originalPosition": 50}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ1MDEzOTg2OnYy", "diffSide": "RIGHT", "path": "dev/com.ibm.ws.security.acme_fat/fat/src/com/ibm/ws/security/acme/docker/CAContainer.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOVQyMDoxODozM1rOF4-7uQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOVQyMDoxODozM1rOF4-7uQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTI5NTY3Mw==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t\t\t\tLog.info(PebbleContainer.class, METHOD_NAME, new String(result));\n          \n          \n            \n            \t\t\t\tLog.info(CAContainer.class, METHOD_NAME, new String(result));", "url": "https://github.com/OpenLiberty/open-liberty/pull/11374#discussion_r395295673", "createdAt": "2020-03-19T20:18:33Z", "author": {"login": "jvanhill"}, "path": "dev/com.ibm.ws.security.acme_fat/fat/src/com/ibm/ws/security/acme/docker/CAContainer.java", "diffHunk": "@@ -0,0 +1,372 @@\n+package com.ibm.ws.security.acme.docker;\n+\n+import static junit.framework.Assert.fail;\n+\n+import java.io.IOException;\n+import java.security.cert.X509Certificate;\n+import java.util.Map.Entry;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import org.apache.http.StatusLine;\n+import org.apache.http.client.methods.CloseableHttpResponse;\n+import org.apache.http.client.methods.HttpGet;\n+import org.apache.http.client.methods.HttpPost;\n+import org.apache.http.entity.ContentType;\n+import org.apache.http.entity.StringEntity;\n+import org.apache.http.impl.client.CloseableHttpClient;\n+import org.apache.http.impl.client.HttpClients;\n+import org.apache.http.util.EntityUtils;\n+import org.testcontainers.containers.GenericContainer;\n+import org.testcontainers.images.builder.ImageFromDockerfile;\n+\n+import com.github.dockerjava.api.model.ContainerNetwork;\n+import com.ibm.websphere.simplicity.log.Log;\n+import com.ibm.ws.security.acme.utils.AcmeFatUtils;\n+\n+public class CAContainer extends GenericContainer<BoulderContainer> {\n+\n+\n+\tpublic static final int HTTP_PORT = 5002;\n+\n+\t/** The REST management API port. */\n+\tpublic int MANAGEMENT_PORT = 8055;\n+\t\n+\tpublic CAContainer(String image) {\n+\t\tsuper(image);\n+\t}\n+\n+\tpublic CAContainer(ImageFromDockerfile image, int managementPort) {\n+\t\tsuper(image);\n+\t\tMANAGEMENT_PORT = managementPort;\n+\t}\n+\n+\n+\t/**\n+\t * Get Pebble's intermediate certificate.\n+\t * \n+\t * @param fileName\n+\t *            The name of the file to save the certificate to.\n+\t * @return Pebble's root CA certificate in the form of a PEM file.\n+\t * @throws Exception\n+\t *             If we failed to receive the certificate.\n+\t */\n+\tpublic byte[] getAcmeCaIntermediateCertificate() throws Exception {\n+\t\tfinal String METHOD_NAME = \"getAcmeCaIntermediateCertificate()\";\n+\t\tString url = \"https://\" + this.getContainerIpAddress() + \":\" + this.getMappedPort(MANAGEMENT_PORT)\n+\t\t\t\t+ \"/intermediates/0\";\n+\n+\t\ttry (CloseableHttpClient httpclient = AcmeFatUtils.getInsecureHttpsClient()) {\n+\t\t\t/*\n+\t\t\t * Create a GET request to the ACME CA server.\n+\t\t\t */\n+\t\t\tHttpGet httpGet = new HttpGet(url);\n+\n+\t\t\t/*\n+\t\t\t * Send the GET request and process the response.\n+\t\t\t */\n+\t\t\ttry (final CloseableHttpResponse response = httpclient.execute(httpGet)) {\n+\t\t\t\tAcmeFatUtils.logHttpResponse(PebbleContainer.class, METHOD_NAME, httpGet, response);\n+\n+\t\t\t\tStatusLine statusLine = response.getStatusLine();\n+\n+\t\t\t\tif (statusLine.getStatusCode() != 200) {\n+\t\t\t\t\tthrow new IOException(\n+\t\t\t\t\t\t\tMETHOD_NAME + \": Expected response 200, but received response: \" + statusLine);\n+\t\t\t\t}\n+\n+\t\t\t\tbyte[] result = EntityUtils.toByteArray(response.getEntity());\n+\n+\t\t\t\tLog.info(PebbleContainer.class, METHOD_NAME, new String(result));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3dd0ccb898e794282f2c55bdc25f1b9f77207045"}, "originalPosition": 80}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ1MDE0MDc5OnYy", "diffSide": "RIGHT", "path": "dev/com.ibm.ws.security.acme_fat/fat/src/com/ibm/ws/security/acme/docker/CAContainer.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOVQyMDoxODo1MVrOF4-8UA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOVQyMDoxODo1MVrOF4-8UA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTI5NTgyNA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t\t\t\tAcmeFatUtils.logHttpResponse(PebbleContainer.class, METHOD_NAME, httpGet, response);\n          \n          \n            \n            \t\t\t\tAcmeFatUtils.logHttpResponse(CAContainer.class, METHOD_NAME, httpGet, response);", "url": "https://github.com/OpenLiberty/open-liberty/pull/11374#discussion_r395295824", "createdAt": "2020-03-19T20:18:51Z", "author": {"login": "jvanhill"}, "path": "dev/com.ibm.ws.security.acme_fat/fat/src/com/ibm/ws/security/acme/docker/CAContainer.java", "diffHunk": "@@ -0,0 +1,372 @@\n+package com.ibm.ws.security.acme.docker;\n+\n+import static junit.framework.Assert.fail;\n+\n+import java.io.IOException;\n+import java.security.cert.X509Certificate;\n+import java.util.Map.Entry;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import org.apache.http.StatusLine;\n+import org.apache.http.client.methods.CloseableHttpResponse;\n+import org.apache.http.client.methods.HttpGet;\n+import org.apache.http.client.methods.HttpPost;\n+import org.apache.http.entity.ContentType;\n+import org.apache.http.entity.StringEntity;\n+import org.apache.http.impl.client.CloseableHttpClient;\n+import org.apache.http.impl.client.HttpClients;\n+import org.apache.http.util.EntityUtils;\n+import org.testcontainers.containers.GenericContainer;\n+import org.testcontainers.images.builder.ImageFromDockerfile;\n+\n+import com.github.dockerjava.api.model.ContainerNetwork;\n+import com.ibm.websphere.simplicity.log.Log;\n+import com.ibm.ws.security.acme.utils.AcmeFatUtils;\n+\n+public class CAContainer extends GenericContainer<BoulderContainer> {\n+\n+\n+\tpublic static final int HTTP_PORT = 5002;\n+\n+\t/** The REST management API port. */\n+\tpublic int MANAGEMENT_PORT = 8055;\n+\t\n+\tpublic CAContainer(String image) {\n+\t\tsuper(image);\n+\t}\n+\n+\tpublic CAContainer(ImageFromDockerfile image, int managementPort) {\n+\t\tsuper(image);\n+\t\tMANAGEMENT_PORT = managementPort;\n+\t}\n+\n+\n+\t/**\n+\t * Get Pebble's intermediate certificate.\n+\t * \n+\t * @param fileName\n+\t *            The name of the file to save the certificate to.\n+\t * @return Pebble's root CA certificate in the form of a PEM file.\n+\t * @throws Exception\n+\t *             If we failed to receive the certificate.\n+\t */\n+\tpublic byte[] getAcmeCaIntermediateCertificate() throws Exception {\n+\t\tfinal String METHOD_NAME = \"getAcmeCaIntermediateCertificate()\";\n+\t\tString url = \"https://\" + this.getContainerIpAddress() + \":\" + this.getMappedPort(MANAGEMENT_PORT)\n+\t\t\t\t+ \"/intermediates/0\";\n+\n+\t\ttry (CloseableHttpClient httpclient = AcmeFatUtils.getInsecureHttpsClient()) {\n+\t\t\t/*\n+\t\t\t * Create a GET request to the ACME CA server.\n+\t\t\t */\n+\t\t\tHttpGet httpGet = new HttpGet(url);\n+\n+\t\t\t/*\n+\t\t\t * Send the GET request and process the response.\n+\t\t\t */\n+\t\t\ttry (final CloseableHttpResponse response = httpclient.execute(httpGet)) {\n+\t\t\t\tAcmeFatUtils.logHttpResponse(PebbleContainer.class, METHOD_NAME, httpGet, response);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3dd0ccb898e794282f2c55bdc25f1b9f77207045"}, "originalPosition": 69}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ1MDE0MTgzOnYy", "diffSide": "RIGHT", "path": "dev/com.ibm.ws.security.acme_fat/fat/src/com/ibm/ws/security/acme/docker/CAContainer.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOVQyMDoxOToxNVrOF4-9Aw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOVQyMDoxOToxNVrOF4-9Aw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTI5NjAwMw==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t * Get Pebble's root certificate.\n          \n          \n            \n            \t * Get the CA server's root certificate.", "url": "https://github.com/OpenLiberty/open-liberty/pull/11374#discussion_r395296003", "createdAt": "2020-03-19T20:19:15Z", "author": {"login": "jvanhill"}, "path": "dev/com.ibm.ws.security.acme_fat/fat/src/com/ibm/ws/security/acme/docker/CAContainer.java", "diffHunk": "@@ -0,0 +1,372 @@\n+package com.ibm.ws.security.acme.docker;\n+\n+import static junit.framework.Assert.fail;\n+\n+import java.io.IOException;\n+import java.security.cert.X509Certificate;\n+import java.util.Map.Entry;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import org.apache.http.StatusLine;\n+import org.apache.http.client.methods.CloseableHttpResponse;\n+import org.apache.http.client.methods.HttpGet;\n+import org.apache.http.client.methods.HttpPost;\n+import org.apache.http.entity.ContentType;\n+import org.apache.http.entity.StringEntity;\n+import org.apache.http.impl.client.CloseableHttpClient;\n+import org.apache.http.impl.client.HttpClients;\n+import org.apache.http.util.EntityUtils;\n+import org.testcontainers.containers.GenericContainer;\n+import org.testcontainers.images.builder.ImageFromDockerfile;\n+\n+import com.github.dockerjava.api.model.ContainerNetwork;\n+import com.ibm.websphere.simplicity.log.Log;\n+import com.ibm.ws.security.acme.utils.AcmeFatUtils;\n+\n+public class CAContainer extends GenericContainer<BoulderContainer> {\n+\n+\n+\tpublic static final int HTTP_PORT = 5002;\n+\n+\t/** The REST management API port. */\n+\tpublic int MANAGEMENT_PORT = 8055;\n+\t\n+\tpublic CAContainer(String image) {\n+\t\tsuper(image);\n+\t}\n+\n+\tpublic CAContainer(ImageFromDockerfile image, int managementPort) {\n+\t\tsuper(image);\n+\t\tMANAGEMENT_PORT = managementPort;\n+\t}\n+\n+\n+\t/**\n+\t * Get Pebble's intermediate certificate.\n+\t * \n+\t * @param fileName\n+\t *            The name of the file to save the certificate to.\n+\t * @return Pebble's root CA certificate in the form of a PEM file.\n+\t * @throws Exception\n+\t *             If we failed to receive the certificate.\n+\t */\n+\tpublic byte[] getAcmeCaIntermediateCertificate() throws Exception {\n+\t\tfinal String METHOD_NAME = \"getAcmeCaIntermediateCertificate()\";\n+\t\tString url = \"https://\" + this.getContainerIpAddress() + \":\" + this.getMappedPort(MANAGEMENT_PORT)\n+\t\t\t\t+ \"/intermediates/0\";\n+\n+\t\ttry (CloseableHttpClient httpclient = AcmeFatUtils.getInsecureHttpsClient()) {\n+\t\t\t/*\n+\t\t\t * Create a GET request to the ACME CA server.\n+\t\t\t */\n+\t\t\tHttpGet httpGet = new HttpGet(url);\n+\n+\t\t\t/*\n+\t\t\t * Send the GET request and process the response.\n+\t\t\t */\n+\t\t\ttry (final CloseableHttpResponse response = httpclient.execute(httpGet)) {\n+\t\t\t\tAcmeFatUtils.logHttpResponse(PebbleContainer.class, METHOD_NAME, httpGet, response);\n+\n+\t\t\t\tStatusLine statusLine = response.getStatusLine();\n+\n+\t\t\t\tif (statusLine.getStatusCode() != 200) {\n+\t\t\t\t\tthrow new IOException(\n+\t\t\t\t\t\t\tMETHOD_NAME + \": Expected response 200, but received response: \" + statusLine);\n+\t\t\t\t}\n+\n+\t\t\t\tbyte[] result = EntityUtils.toByteArray(response.getEntity());\n+\n+\t\t\t\tLog.info(PebbleContainer.class, METHOD_NAME, new String(result));\n+\t\t\t\treturn result;\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Get Pebble's root certificate.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3dd0ccb898e794282f2c55bdc25f1b9f77207045"}, "originalPosition": 87}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ1MDE0Mzc1OnYy", "diffSide": "RIGHT", "path": "dev/com.ibm.ws.security.acme_fat/fat/src/com/ibm/ws/security/acme/docker/CAContainer.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOVQyMDoxOTo1M1rOF4--Nw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOVQyMDoxOTo1M1rOF4--Nw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTI5NjMxMQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t * @return Pebble's root CA certificate in the form of a PEM file.\n          \n          \n            \n            \t * @return The CA's root certificate in the form of PEM contained in a byte array.", "url": "https://github.com/OpenLiberty/open-liberty/pull/11374#discussion_r395296311", "createdAt": "2020-03-19T20:19:53Z", "author": {"login": "jvanhill"}, "path": "dev/com.ibm.ws.security.acme_fat/fat/src/com/ibm/ws/security/acme/docker/CAContainer.java", "diffHunk": "@@ -0,0 +1,372 @@\n+package com.ibm.ws.security.acme.docker;\n+\n+import static junit.framework.Assert.fail;\n+\n+import java.io.IOException;\n+import java.security.cert.X509Certificate;\n+import java.util.Map.Entry;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import org.apache.http.StatusLine;\n+import org.apache.http.client.methods.CloseableHttpResponse;\n+import org.apache.http.client.methods.HttpGet;\n+import org.apache.http.client.methods.HttpPost;\n+import org.apache.http.entity.ContentType;\n+import org.apache.http.entity.StringEntity;\n+import org.apache.http.impl.client.CloseableHttpClient;\n+import org.apache.http.impl.client.HttpClients;\n+import org.apache.http.util.EntityUtils;\n+import org.testcontainers.containers.GenericContainer;\n+import org.testcontainers.images.builder.ImageFromDockerfile;\n+\n+import com.github.dockerjava.api.model.ContainerNetwork;\n+import com.ibm.websphere.simplicity.log.Log;\n+import com.ibm.ws.security.acme.utils.AcmeFatUtils;\n+\n+public class CAContainer extends GenericContainer<BoulderContainer> {\n+\n+\n+\tpublic static final int HTTP_PORT = 5002;\n+\n+\t/** The REST management API port. */\n+\tpublic int MANAGEMENT_PORT = 8055;\n+\t\n+\tpublic CAContainer(String image) {\n+\t\tsuper(image);\n+\t}\n+\n+\tpublic CAContainer(ImageFromDockerfile image, int managementPort) {\n+\t\tsuper(image);\n+\t\tMANAGEMENT_PORT = managementPort;\n+\t}\n+\n+\n+\t/**\n+\t * Get Pebble's intermediate certificate.\n+\t * \n+\t * @param fileName\n+\t *            The name of the file to save the certificate to.\n+\t * @return Pebble's root CA certificate in the form of a PEM file.\n+\t * @throws Exception\n+\t *             If we failed to receive the certificate.\n+\t */\n+\tpublic byte[] getAcmeCaIntermediateCertificate() throws Exception {\n+\t\tfinal String METHOD_NAME = \"getAcmeCaIntermediateCertificate()\";\n+\t\tString url = \"https://\" + this.getContainerIpAddress() + \":\" + this.getMappedPort(MANAGEMENT_PORT)\n+\t\t\t\t+ \"/intermediates/0\";\n+\n+\t\ttry (CloseableHttpClient httpclient = AcmeFatUtils.getInsecureHttpsClient()) {\n+\t\t\t/*\n+\t\t\t * Create a GET request to the ACME CA server.\n+\t\t\t */\n+\t\t\tHttpGet httpGet = new HttpGet(url);\n+\n+\t\t\t/*\n+\t\t\t * Send the GET request and process the response.\n+\t\t\t */\n+\t\t\ttry (final CloseableHttpResponse response = httpclient.execute(httpGet)) {\n+\t\t\t\tAcmeFatUtils.logHttpResponse(PebbleContainer.class, METHOD_NAME, httpGet, response);\n+\n+\t\t\t\tStatusLine statusLine = response.getStatusLine();\n+\n+\t\t\t\tif (statusLine.getStatusCode() != 200) {\n+\t\t\t\t\tthrow new IOException(\n+\t\t\t\t\t\t\tMETHOD_NAME + \": Expected response 200, but received response: \" + statusLine);\n+\t\t\t\t}\n+\n+\t\t\t\tbyte[] result = EntityUtils.toByteArray(response.getEntity());\n+\n+\t\t\t\tLog.info(PebbleContainer.class, METHOD_NAME, new String(result));\n+\t\t\t\treturn result;\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Get Pebble's root certificate.\n+\t * \n+\t * @param fileName\n+\t *            The name of the file to save the certificate to.\n+\t * @return Pebble's root CA certificate in the form of a PEM file.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3dd0ccb898e794282f2c55bdc25f1b9f77207045"}, "originalPosition": 91}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ1MDE0NTE4OnYy", "diffSide": "RIGHT", "path": "dev/com.ibm.ws.security.acme_fat/fat/src/com/ibm/ws/security/acme/docker/CAContainer.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOVQyMDoyMDoyNFrOF4-_Lg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOVQyMDoyMDoyNFrOF4-_Lg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTI5NjU1OA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t\t\t\tAcmeFatUtils.logHttpResponse(BoulderContainer.class, METHOD_NAME, httpGet, response);\n          \n          \n            \n            \t\t\t\tAcmeFatUtils.logHttpResponse(CAContainer.class, METHOD_NAME, httpGet, response);", "url": "https://github.com/OpenLiberty/open-liberty/pull/11374#discussion_r395296558", "createdAt": "2020-03-19T20:20:24Z", "author": {"login": "jvanhill"}, "path": "dev/com.ibm.ws.security.acme_fat/fat/src/com/ibm/ws/security/acme/docker/CAContainer.java", "diffHunk": "@@ -0,0 +1,372 @@\n+package com.ibm.ws.security.acme.docker;\n+\n+import static junit.framework.Assert.fail;\n+\n+import java.io.IOException;\n+import java.security.cert.X509Certificate;\n+import java.util.Map.Entry;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import org.apache.http.StatusLine;\n+import org.apache.http.client.methods.CloseableHttpResponse;\n+import org.apache.http.client.methods.HttpGet;\n+import org.apache.http.client.methods.HttpPost;\n+import org.apache.http.entity.ContentType;\n+import org.apache.http.entity.StringEntity;\n+import org.apache.http.impl.client.CloseableHttpClient;\n+import org.apache.http.impl.client.HttpClients;\n+import org.apache.http.util.EntityUtils;\n+import org.testcontainers.containers.GenericContainer;\n+import org.testcontainers.images.builder.ImageFromDockerfile;\n+\n+import com.github.dockerjava.api.model.ContainerNetwork;\n+import com.ibm.websphere.simplicity.log.Log;\n+import com.ibm.ws.security.acme.utils.AcmeFatUtils;\n+\n+public class CAContainer extends GenericContainer<BoulderContainer> {\n+\n+\n+\tpublic static final int HTTP_PORT = 5002;\n+\n+\t/** The REST management API port. */\n+\tpublic int MANAGEMENT_PORT = 8055;\n+\t\n+\tpublic CAContainer(String image) {\n+\t\tsuper(image);\n+\t}\n+\n+\tpublic CAContainer(ImageFromDockerfile image, int managementPort) {\n+\t\tsuper(image);\n+\t\tMANAGEMENT_PORT = managementPort;\n+\t}\n+\n+\n+\t/**\n+\t * Get Pebble's intermediate certificate.\n+\t * \n+\t * @param fileName\n+\t *            The name of the file to save the certificate to.\n+\t * @return Pebble's root CA certificate in the form of a PEM file.\n+\t * @throws Exception\n+\t *             If we failed to receive the certificate.\n+\t */\n+\tpublic byte[] getAcmeCaIntermediateCertificate() throws Exception {\n+\t\tfinal String METHOD_NAME = \"getAcmeCaIntermediateCertificate()\";\n+\t\tString url = \"https://\" + this.getContainerIpAddress() + \":\" + this.getMappedPort(MANAGEMENT_PORT)\n+\t\t\t\t+ \"/intermediates/0\";\n+\n+\t\ttry (CloseableHttpClient httpclient = AcmeFatUtils.getInsecureHttpsClient()) {\n+\t\t\t/*\n+\t\t\t * Create a GET request to the ACME CA server.\n+\t\t\t */\n+\t\t\tHttpGet httpGet = new HttpGet(url);\n+\n+\t\t\t/*\n+\t\t\t * Send the GET request and process the response.\n+\t\t\t */\n+\t\t\ttry (final CloseableHttpResponse response = httpclient.execute(httpGet)) {\n+\t\t\t\tAcmeFatUtils.logHttpResponse(PebbleContainer.class, METHOD_NAME, httpGet, response);\n+\n+\t\t\t\tStatusLine statusLine = response.getStatusLine();\n+\n+\t\t\t\tif (statusLine.getStatusCode() != 200) {\n+\t\t\t\t\tthrow new IOException(\n+\t\t\t\t\t\t\tMETHOD_NAME + \": Expected response 200, but received response: \" + statusLine);\n+\t\t\t\t}\n+\n+\t\t\t\tbyte[] result = EntityUtils.toByteArray(response.getEntity());\n+\n+\t\t\t\tLog.info(PebbleContainer.class, METHOD_NAME, new String(result));\n+\t\t\t\treturn result;\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Get Pebble's root certificate.\n+\t * \n+\t * @param fileName\n+\t *            The name of the file to save the certificate to.\n+\t * @return Pebble's root CA certificate in the form of a PEM file.\n+\t * @throws Exception\n+\t *             If we failed to receive the certificate.\n+\t */\n+\tpublic byte[] getAcmeCaRootCertificate() throws Exception {\n+\t\tfinal String METHOD_NAME = \"getAcmeCaRootCertificate()\";\n+\t\tString url = \"https://\" + this.getContainerIpAddress() + \":\" + this.getMappedPort(MANAGEMENT_PORT) + \"/roots/0\";\n+\n+\t\ttry (CloseableHttpClient httpclient = AcmeFatUtils.getInsecureHttpsClient()) {\n+\t\t\t/*\n+\t\t\t * Create a GET request to the ACME CA server.\n+\t\t\t */\n+\t\t\tHttpGet httpGet = new HttpGet(url);\n+\n+\t\t\t/*\n+\t\t\t * Send the GET request and process the response.\n+\t\t\t */\n+\t\t\ttry (final CloseableHttpResponse response = httpclient.execute(httpGet)) {\n+\t\t\t\tAcmeFatUtils.logHttpResponse(BoulderContainer.class, METHOD_NAME, httpGet, response);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3dd0ccb898e794282f2c55bdc25f1b9f77207045"}, "originalPosition": 109}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ1MDE0NjAwOnYy", "diffSide": "RIGHT", "path": "dev/com.ibm.ws.security.acme_fat/fat/src/com/ibm/ws/security/acme/docker/CAContainer.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOVQyMDoyMDo0MFrOF4-_ug==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOVQyMDoyMDo0MFrOF4-_ug==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTI5NjY5OA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t\t\t\tLog.info(BoulderContainer.class, METHOD_NAME, new String(result));\n          \n          \n            \n            \t\t\t\tLog.info(CAContainer.class, METHOD_NAME, new String(result));", "url": "https://github.com/OpenLiberty/open-liberty/pull/11374#discussion_r395296698", "createdAt": "2020-03-19T20:20:40Z", "author": {"login": "jvanhill"}, "path": "dev/com.ibm.ws.security.acme_fat/fat/src/com/ibm/ws/security/acme/docker/CAContainer.java", "diffHunk": "@@ -0,0 +1,372 @@\n+package com.ibm.ws.security.acme.docker;\n+\n+import static junit.framework.Assert.fail;\n+\n+import java.io.IOException;\n+import java.security.cert.X509Certificate;\n+import java.util.Map.Entry;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import org.apache.http.StatusLine;\n+import org.apache.http.client.methods.CloseableHttpResponse;\n+import org.apache.http.client.methods.HttpGet;\n+import org.apache.http.client.methods.HttpPost;\n+import org.apache.http.entity.ContentType;\n+import org.apache.http.entity.StringEntity;\n+import org.apache.http.impl.client.CloseableHttpClient;\n+import org.apache.http.impl.client.HttpClients;\n+import org.apache.http.util.EntityUtils;\n+import org.testcontainers.containers.GenericContainer;\n+import org.testcontainers.images.builder.ImageFromDockerfile;\n+\n+import com.github.dockerjava.api.model.ContainerNetwork;\n+import com.ibm.websphere.simplicity.log.Log;\n+import com.ibm.ws.security.acme.utils.AcmeFatUtils;\n+\n+public class CAContainer extends GenericContainer<BoulderContainer> {\n+\n+\n+\tpublic static final int HTTP_PORT = 5002;\n+\n+\t/** The REST management API port. */\n+\tpublic int MANAGEMENT_PORT = 8055;\n+\t\n+\tpublic CAContainer(String image) {\n+\t\tsuper(image);\n+\t}\n+\n+\tpublic CAContainer(ImageFromDockerfile image, int managementPort) {\n+\t\tsuper(image);\n+\t\tMANAGEMENT_PORT = managementPort;\n+\t}\n+\n+\n+\t/**\n+\t * Get Pebble's intermediate certificate.\n+\t * \n+\t * @param fileName\n+\t *            The name of the file to save the certificate to.\n+\t * @return Pebble's root CA certificate in the form of a PEM file.\n+\t * @throws Exception\n+\t *             If we failed to receive the certificate.\n+\t */\n+\tpublic byte[] getAcmeCaIntermediateCertificate() throws Exception {\n+\t\tfinal String METHOD_NAME = \"getAcmeCaIntermediateCertificate()\";\n+\t\tString url = \"https://\" + this.getContainerIpAddress() + \":\" + this.getMappedPort(MANAGEMENT_PORT)\n+\t\t\t\t+ \"/intermediates/0\";\n+\n+\t\ttry (CloseableHttpClient httpclient = AcmeFatUtils.getInsecureHttpsClient()) {\n+\t\t\t/*\n+\t\t\t * Create a GET request to the ACME CA server.\n+\t\t\t */\n+\t\t\tHttpGet httpGet = new HttpGet(url);\n+\n+\t\t\t/*\n+\t\t\t * Send the GET request and process the response.\n+\t\t\t */\n+\t\t\ttry (final CloseableHttpResponse response = httpclient.execute(httpGet)) {\n+\t\t\t\tAcmeFatUtils.logHttpResponse(PebbleContainer.class, METHOD_NAME, httpGet, response);\n+\n+\t\t\t\tStatusLine statusLine = response.getStatusLine();\n+\n+\t\t\t\tif (statusLine.getStatusCode() != 200) {\n+\t\t\t\t\tthrow new IOException(\n+\t\t\t\t\t\t\tMETHOD_NAME + \": Expected response 200, but received response: \" + statusLine);\n+\t\t\t\t}\n+\n+\t\t\t\tbyte[] result = EntityUtils.toByteArray(response.getEntity());\n+\n+\t\t\t\tLog.info(PebbleContainer.class, METHOD_NAME, new String(result));\n+\t\t\t\treturn result;\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Get Pebble's root certificate.\n+\t * \n+\t * @param fileName\n+\t *            The name of the file to save the certificate to.\n+\t * @return Pebble's root CA certificate in the form of a PEM file.\n+\t * @throws Exception\n+\t *             If we failed to receive the certificate.\n+\t */\n+\tpublic byte[] getAcmeCaRootCertificate() throws Exception {\n+\t\tfinal String METHOD_NAME = \"getAcmeCaRootCertificate()\";\n+\t\tString url = \"https://\" + this.getContainerIpAddress() + \":\" + this.getMappedPort(MANAGEMENT_PORT) + \"/roots/0\";\n+\n+\t\ttry (CloseableHttpClient httpclient = AcmeFatUtils.getInsecureHttpsClient()) {\n+\t\t\t/*\n+\t\t\t * Create a GET request to the ACME CA server.\n+\t\t\t */\n+\t\t\tHttpGet httpGet = new HttpGet(url);\n+\n+\t\t\t/*\n+\t\t\t * Send the GET request and process the response.\n+\t\t\t */\n+\t\t\ttry (final CloseableHttpResponse response = httpclient.execute(httpGet)) {\n+\t\t\t\tAcmeFatUtils.logHttpResponse(BoulderContainer.class, METHOD_NAME, httpGet, response);\n+\n+\t\t\t\tStatusLine statusLine = response.getStatusLine();\n+\n+\t\t\t\tif (statusLine.getStatusCode() != 200) {\n+\t\t\t\t\tthrow new IOException(\n+\t\t\t\t\t\t\tMETHOD_NAME + \": Expected response 200, but received response: \" + statusLine);\n+\t\t\t\t}\n+\n+\t\t\t\tbyte[] result = EntityUtils.toByteArray(response.getEntity());\n+\n+\t\t\t\tLog.info(BoulderContainer.class, METHOD_NAME, new String(result));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3dd0ccb898e794282f2c55bdc25f1b9f77207045"}, "originalPosition": 120}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ1MDE0NzU1OnYy", "diffSide": "RIGHT", "path": "dev/com.ibm.ws.security.acme_fat/fat/src/com/ibm/ws/security/acme/docker/CAContainer.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOVQyMDoyMTowOFrOF4_Apw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOVQyMDoyMTowOFrOF4_Apw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTI5NjkzNQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t\t\t\tAcmeFatUtils.logHttpResponse(BoulderContainer.class, METHOD_NAME, httpGet, response);\n          \n          \n            \n            \t\t\t\tAcmeFatUtils.logHttpResponse(CAContainer.class, METHOD_NAME, httpGet, response);", "url": "https://github.com/OpenLiberty/open-liberty/pull/11374#discussion_r395296935", "createdAt": "2020-03-19T20:21:08Z", "author": {"login": "jvanhill"}, "path": "dev/com.ibm.ws.security.acme_fat/fat/src/com/ibm/ws/security/acme/docker/CAContainer.java", "diffHunk": "@@ -0,0 +1,372 @@\n+package com.ibm.ws.security.acme.docker;\n+\n+import static junit.framework.Assert.fail;\n+\n+import java.io.IOException;\n+import java.security.cert.X509Certificate;\n+import java.util.Map.Entry;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import org.apache.http.StatusLine;\n+import org.apache.http.client.methods.CloseableHttpResponse;\n+import org.apache.http.client.methods.HttpGet;\n+import org.apache.http.client.methods.HttpPost;\n+import org.apache.http.entity.ContentType;\n+import org.apache.http.entity.StringEntity;\n+import org.apache.http.impl.client.CloseableHttpClient;\n+import org.apache.http.impl.client.HttpClients;\n+import org.apache.http.util.EntityUtils;\n+import org.testcontainers.containers.GenericContainer;\n+import org.testcontainers.images.builder.ImageFromDockerfile;\n+\n+import com.github.dockerjava.api.model.ContainerNetwork;\n+import com.ibm.websphere.simplicity.log.Log;\n+import com.ibm.ws.security.acme.utils.AcmeFatUtils;\n+\n+public class CAContainer extends GenericContainer<BoulderContainer> {\n+\n+\n+\tpublic static final int HTTP_PORT = 5002;\n+\n+\t/** The REST management API port. */\n+\tpublic int MANAGEMENT_PORT = 8055;\n+\t\n+\tpublic CAContainer(String image) {\n+\t\tsuper(image);\n+\t}\n+\n+\tpublic CAContainer(ImageFromDockerfile image, int managementPort) {\n+\t\tsuper(image);\n+\t\tMANAGEMENT_PORT = managementPort;\n+\t}\n+\n+\n+\t/**\n+\t * Get Pebble's intermediate certificate.\n+\t * \n+\t * @param fileName\n+\t *            The name of the file to save the certificate to.\n+\t * @return Pebble's root CA certificate in the form of a PEM file.\n+\t * @throws Exception\n+\t *             If we failed to receive the certificate.\n+\t */\n+\tpublic byte[] getAcmeCaIntermediateCertificate() throws Exception {\n+\t\tfinal String METHOD_NAME = \"getAcmeCaIntermediateCertificate()\";\n+\t\tString url = \"https://\" + this.getContainerIpAddress() + \":\" + this.getMappedPort(MANAGEMENT_PORT)\n+\t\t\t\t+ \"/intermediates/0\";\n+\n+\t\ttry (CloseableHttpClient httpclient = AcmeFatUtils.getInsecureHttpsClient()) {\n+\t\t\t/*\n+\t\t\t * Create a GET request to the ACME CA server.\n+\t\t\t */\n+\t\t\tHttpGet httpGet = new HttpGet(url);\n+\n+\t\t\t/*\n+\t\t\t * Send the GET request and process the response.\n+\t\t\t */\n+\t\t\ttry (final CloseableHttpResponse response = httpclient.execute(httpGet)) {\n+\t\t\t\tAcmeFatUtils.logHttpResponse(PebbleContainer.class, METHOD_NAME, httpGet, response);\n+\n+\t\t\t\tStatusLine statusLine = response.getStatusLine();\n+\n+\t\t\t\tif (statusLine.getStatusCode() != 200) {\n+\t\t\t\t\tthrow new IOException(\n+\t\t\t\t\t\t\tMETHOD_NAME + \": Expected response 200, but received response: \" + statusLine);\n+\t\t\t\t}\n+\n+\t\t\t\tbyte[] result = EntityUtils.toByteArray(response.getEntity());\n+\n+\t\t\t\tLog.info(PebbleContainer.class, METHOD_NAME, new String(result));\n+\t\t\t\treturn result;\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Get Pebble's root certificate.\n+\t * \n+\t * @param fileName\n+\t *            The name of the file to save the certificate to.\n+\t * @return Pebble's root CA certificate in the form of a PEM file.\n+\t * @throws Exception\n+\t *             If we failed to receive the certificate.\n+\t */\n+\tpublic byte[] getAcmeCaRootCertificate() throws Exception {\n+\t\tfinal String METHOD_NAME = \"getAcmeCaRootCertificate()\";\n+\t\tString url = \"https://\" + this.getContainerIpAddress() + \":\" + this.getMappedPort(MANAGEMENT_PORT) + \"/roots/0\";\n+\n+\t\ttry (CloseableHttpClient httpclient = AcmeFatUtils.getInsecureHttpsClient()) {\n+\t\t\t/*\n+\t\t\t * Create a GET request to the ACME CA server.\n+\t\t\t */\n+\t\t\tHttpGet httpGet = new HttpGet(url);\n+\n+\t\t\t/*\n+\t\t\t * Send the GET request and process the response.\n+\t\t\t */\n+\t\t\ttry (final CloseableHttpResponse response = httpclient.execute(httpGet)) {\n+\t\t\t\tAcmeFatUtils.logHttpResponse(BoulderContainer.class, METHOD_NAME, httpGet, response);\n+\n+\t\t\t\tStatusLine statusLine = response.getStatusLine();\n+\n+\t\t\t\tif (statusLine.getStatusCode() != 200) {\n+\t\t\t\t\tthrow new IOException(\n+\t\t\t\t\t\t\tMETHOD_NAME + \": Expected response 200, but received response: \" + statusLine);\n+\t\t\t\t}\n+\n+\t\t\t\tbyte[] result = EntityUtils.toByteArray(response.getEntity());\n+\n+\t\t\t\tLog.info(BoulderContainer.class, METHOD_NAME, new String(result));\n+\t\t\t\treturn result;\n+\t\t\t}\n+\t\t}\n+\t}\n+\t\n+\t/**\n+\t * Get the status of the certificate from the ACME CA server.\n+\t * \n+\t * @param certificate\n+\t *            The certificate to check.\n+\t * @return The status of the certificate.\n+\t * @throws Exception\n+\t */\n+\tpublic String getAcmeCertificateStatus(X509Certificate certificate) throws Exception {\n+\t\tfinal String METHOD_NAME = \"getAcmeCertificateStatus()\";\n+\t\tString url = \"https://\" + this.getContainerIpAddress() + \":\" + this.getMappedPort(MANAGEMENT_PORT)\n+\t\t\t\t+ \"/cert-status-by-serial/\" + certificate.getSerialNumber().toString(16);\n+\n+\t\ttry (CloseableHttpClient httpclient = AcmeFatUtils.getInsecureHttpsClient()) {\n+\t\t\t/*\n+\t\t\t * Create a GET request to the ACME CA server.\n+\t\t\t */\n+\t\t\tHttpGet httpGet = new HttpGet(url);\n+\n+\t\t\t/*\n+\t\t\t * Send the GET request and process the response.\n+\t\t\t */\n+\t\t\ttry (final CloseableHttpResponse response = httpclient.execute(httpGet)) {\n+\t\t\t\tAcmeFatUtils.logHttpResponse(BoulderContainer.class, METHOD_NAME, httpGet, response);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3dd0ccb898e794282f2c55bdc25f1b9f77207045"}, "originalPosition": 149}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ1MDE0OTMwOnYy", "diffSide": "RIGHT", "path": "dev/com.ibm.ws.security.acme_fat/fat/src/com/ibm/ws/security/acme/docker/CAContainer.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOVQyMDoyMTozOFrOF4_Brg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOVQyMDoyMTozOFrOF4_Brg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTI5NzE5OA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t\t\t\tLog.info(BoulderContainer.class, METHOD_NAME, new String(result));\n          \n          \n            \n            \t\t\t\tLog.info(CAContainer.class, METHOD_NAME, new String(result));", "url": "https://github.com/OpenLiberty/open-liberty/pull/11374#discussion_r395297198", "createdAt": "2020-03-19T20:21:38Z", "author": {"login": "jvanhill"}, "path": "dev/com.ibm.ws.security.acme_fat/fat/src/com/ibm/ws/security/acme/docker/CAContainer.java", "diffHunk": "@@ -0,0 +1,372 @@\n+package com.ibm.ws.security.acme.docker;\n+\n+import static junit.framework.Assert.fail;\n+\n+import java.io.IOException;\n+import java.security.cert.X509Certificate;\n+import java.util.Map.Entry;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import org.apache.http.StatusLine;\n+import org.apache.http.client.methods.CloseableHttpResponse;\n+import org.apache.http.client.methods.HttpGet;\n+import org.apache.http.client.methods.HttpPost;\n+import org.apache.http.entity.ContentType;\n+import org.apache.http.entity.StringEntity;\n+import org.apache.http.impl.client.CloseableHttpClient;\n+import org.apache.http.impl.client.HttpClients;\n+import org.apache.http.util.EntityUtils;\n+import org.testcontainers.containers.GenericContainer;\n+import org.testcontainers.images.builder.ImageFromDockerfile;\n+\n+import com.github.dockerjava.api.model.ContainerNetwork;\n+import com.ibm.websphere.simplicity.log.Log;\n+import com.ibm.ws.security.acme.utils.AcmeFatUtils;\n+\n+public class CAContainer extends GenericContainer<BoulderContainer> {\n+\n+\n+\tpublic static final int HTTP_PORT = 5002;\n+\n+\t/** The REST management API port. */\n+\tpublic int MANAGEMENT_PORT = 8055;\n+\t\n+\tpublic CAContainer(String image) {\n+\t\tsuper(image);\n+\t}\n+\n+\tpublic CAContainer(ImageFromDockerfile image, int managementPort) {\n+\t\tsuper(image);\n+\t\tMANAGEMENT_PORT = managementPort;\n+\t}\n+\n+\n+\t/**\n+\t * Get Pebble's intermediate certificate.\n+\t * \n+\t * @param fileName\n+\t *            The name of the file to save the certificate to.\n+\t * @return Pebble's root CA certificate in the form of a PEM file.\n+\t * @throws Exception\n+\t *             If we failed to receive the certificate.\n+\t */\n+\tpublic byte[] getAcmeCaIntermediateCertificate() throws Exception {\n+\t\tfinal String METHOD_NAME = \"getAcmeCaIntermediateCertificate()\";\n+\t\tString url = \"https://\" + this.getContainerIpAddress() + \":\" + this.getMappedPort(MANAGEMENT_PORT)\n+\t\t\t\t+ \"/intermediates/0\";\n+\n+\t\ttry (CloseableHttpClient httpclient = AcmeFatUtils.getInsecureHttpsClient()) {\n+\t\t\t/*\n+\t\t\t * Create a GET request to the ACME CA server.\n+\t\t\t */\n+\t\t\tHttpGet httpGet = new HttpGet(url);\n+\n+\t\t\t/*\n+\t\t\t * Send the GET request and process the response.\n+\t\t\t */\n+\t\t\ttry (final CloseableHttpResponse response = httpclient.execute(httpGet)) {\n+\t\t\t\tAcmeFatUtils.logHttpResponse(PebbleContainer.class, METHOD_NAME, httpGet, response);\n+\n+\t\t\t\tStatusLine statusLine = response.getStatusLine();\n+\n+\t\t\t\tif (statusLine.getStatusCode() != 200) {\n+\t\t\t\t\tthrow new IOException(\n+\t\t\t\t\t\t\tMETHOD_NAME + \": Expected response 200, but received response: \" + statusLine);\n+\t\t\t\t}\n+\n+\t\t\t\tbyte[] result = EntityUtils.toByteArray(response.getEntity());\n+\n+\t\t\t\tLog.info(PebbleContainer.class, METHOD_NAME, new String(result));\n+\t\t\t\treturn result;\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Get Pebble's root certificate.\n+\t * \n+\t * @param fileName\n+\t *            The name of the file to save the certificate to.\n+\t * @return Pebble's root CA certificate in the form of a PEM file.\n+\t * @throws Exception\n+\t *             If we failed to receive the certificate.\n+\t */\n+\tpublic byte[] getAcmeCaRootCertificate() throws Exception {\n+\t\tfinal String METHOD_NAME = \"getAcmeCaRootCertificate()\";\n+\t\tString url = \"https://\" + this.getContainerIpAddress() + \":\" + this.getMappedPort(MANAGEMENT_PORT) + \"/roots/0\";\n+\n+\t\ttry (CloseableHttpClient httpclient = AcmeFatUtils.getInsecureHttpsClient()) {\n+\t\t\t/*\n+\t\t\t * Create a GET request to the ACME CA server.\n+\t\t\t */\n+\t\t\tHttpGet httpGet = new HttpGet(url);\n+\n+\t\t\t/*\n+\t\t\t * Send the GET request and process the response.\n+\t\t\t */\n+\t\t\ttry (final CloseableHttpResponse response = httpclient.execute(httpGet)) {\n+\t\t\t\tAcmeFatUtils.logHttpResponse(BoulderContainer.class, METHOD_NAME, httpGet, response);\n+\n+\t\t\t\tStatusLine statusLine = response.getStatusLine();\n+\n+\t\t\t\tif (statusLine.getStatusCode() != 200) {\n+\t\t\t\t\tthrow new IOException(\n+\t\t\t\t\t\t\tMETHOD_NAME + \": Expected response 200, but received response: \" + statusLine);\n+\t\t\t\t}\n+\n+\t\t\t\tbyte[] result = EntityUtils.toByteArray(response.getEntity());\n+\n+\t\t\t\tLog.info(BoulderContainer.class, METHOD_NAME, new String(result));\n+\t\t\t\treturn result;\n+\t\t\t}\n+\t\t}\n+\t}\n+\t\n+\t/**\n+\t * Get the status of the certificate from the ACME CA server.\n+\t * \n+\t * @param certificate\n+\t *            The certificate to check.\n+\t * @return The status of the certificate.\n+\t * @throws Exception\n+\t */\n+\tpublic String getAcmeCertificateStatus(X509Certificate certificate) throws Exception {\n+\t\tfinal String METHOD_NAME = \"getAcmeCertificateStatus()\";\n+\t\tString url = \"https://\" + this.getContainerIpAddress() + \":\" + this.getMappedPort(MANAGEMENT_PORT)\n+\t\t\t\t+ \"/cert-status-by-serial/\" + certificate.getSerialNumber().toString(16);\n+\n+\t\ttry (CloseableHttpClient httpclient = AcmeFatUtils.getInsecureHttpsClient()) {\n+\t\t\t/*\n+\t\t\t * Create a GET request to the ACME CA server.\n+\t\t\t */\n+\t\t\tHttpGet httpGet = new HttpGet(url);\n+\n+\t\t\t/*\n+\t\t\t * Send the GET request and process the response.\n+\t\t\t */\n+\t\t\ttry (final CloseableHttpResponse response = httpclient.execute(httpGet)) {\n+\t\t\t\tAcmeFatUtils.logHttpResponse(BoulderContainer.class, METHOD_NAME, httpGet, response);\n+\n+\t\t\t\tStatusLine statusLine = response.getStatusLine();\n+\n+\t\t\t\tif (statusLine.getStatusCode() != 200) {\n+\t\t\t\t\tthrow new IOException(\n+\t\t\t\t\t\t\tMETHOD_NAME + \": Expected response 200, but received response: \" + statusLine);\n+\t\t\t\t}\n+\n+\t\t\t\tString result = EntityUtils.toString(response.getEntity());\n+\n+\t\t\t\t/*\n+\t\t\t\t * The result is in JSON, lets just parse out the status.\n+\t\t\t\t */\n+\t\t\t\tPattern p = Pattern.compile(\".*\\\"Status\\\": \\\"(\\\\w+)\\\",.*\", Pattern.DOTALL);\n+\t\t\t\tMatcher m = p.matcher(result);\n+\t\t\t\tif (m.find()) {\n+\t\t\t\t\tresult = m.group(1);\n+\t\t\t\t} else {\n+\t\t\t\t\tthrow new Exception(\n+\t\t\t\t\t\t\t\"Certificate status response was not in expected JSON format. Response: \" + result);\n+\t\t\t\t}\n+\n+\t\t\t\tLog.info(BoulderContainer.class, METHOD_NAME, new String(result));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3dd0ccb898e794282f2c55bdc25f1b9f77207045"}, "originalPosition": 172}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ1MDE1MDM0OnYy", "diffSide": "RIGHT", "path": "dev/com.ibm.ws.security.acme_fat/fat/src/com/ibm/ws/security/acme/docker/CAContainer.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOVQyMDoyMjowMFrOF4_CXA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOVQyMDoyMjowMFrOF4_CXA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTI5NzM3Mg==", "bodyText": "Javadoc", "url": "https://github.com/OpenLiberty/open-liberty/pull/11374#discussion_r395297372", "createdAt": "2020-03-19T20:22:00Z", "author": {"login": "jvanhill"}, "path": "dev/com.ibm.ws.security.acme_fat/fat/src/com/ibm/ws/security/acme/docker/CAContainer.java", "diffHunk": "@@ -0,0 +1,372 @@\n+package com.ibm.ws.security.acme.docker;\n+\n+import static junit.framework.Assert.fail;\n+\n+import java.io.IOException;\n+import java.security.cert.X509Certificate;\n+import java.util.Map.Entry;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import org.apache.http.StatusLine;\n+import org.apache.http.client.methods.CloseableHttpResponse;\n+import org.apache.http.client.methods.HttpGet;\n+import org.apache.http.client.methods.HttpPost;\n+import org.apache.http.entity.ContentType;\n+import org.apache.http.entity.StringEntity;\n+import org.apache.http.impl.client.CloseableHttpClient;\n+import org.apache.http.impl.client.HttpClients;\n+import org.apache.http.util.EntityUtils;\n+import org.testcontainers.containers.GenericContainer;\n+import org.testcontainers.images.builder.ImageFromDockerfile;\n+\n+import com.github.dockerjava.api.model.ContainerNetwork;\n+import com.ibm.websphere.simplicity.log.Log;\n+import com.ibm.ws.security.acme.utils.AcmeFatUtils;\n+\n+public class CAContainer extends GenericContainer<BoulderContainer> {\n+\n+\n+\tpublic static final int HTTP_PORT = 5002;\n+\n+\t/** The REST management API port. */\n+\tpublic int MANAGEMENT_PORT = 8055;\n+\t\n+\tpublic CAContainer(String image) {\n+\t\tsuper(image);\n+\t}\n+\n+\tpublic CAContainer(ImageFromDockerfile image, int managementPort) {\n+\t\tsuper(image);\n+\t\tMANAGEMENT_PORT = managementPort;\n+\t}\n+\n+\n+\t/**\n+\t * Get Pebble's intermediate certificate.\n+\t * \n+\t * @param fileName\n+\t *            The name of the file to save the certificate to.\n+\t * @return Pebble's root CA certificate in the form of a PEM file.\n+\t * @throws Exception\n+\t *             If we failed to receive the certificate.\n+\t */\n+\tpublic byte[] getAcmeCaIntermediateCertificate() throws Exception {\n+\t\tfinal String METHOD_NAME = \"getAcmeCaIntermediateCertificate()\";\n+\t\tString url = \"https://\" + this.getContainerIpAddress() + \":\" + this.getMappedPort(MANAGEMENT_PORT)\n+\t\t\t\t+ \"/intermediates/0\";\n+\n+\t\ttry (CloseableHttpClient httpclient = AcmeFatUtils.getInsecureHttpsClient()) {\n+\t\t\t/*\n+\t\t\t * Create a GET request to the ACME CA server.\n+\t\t\t */\n+\t\t\tHttpGet httpGet = new HttpGet(url);\n+\n+\t\t\t/*\n+\t\t\t * Send the GET request and process the response.\n+\t\t\t */\n+\t\t\ttry (final CloseableHttpResponse response = httpclient.execute(httpGet)) {\n+\t\t\t\tAcmeFatUtils.logHttpResponse(PebbleContainer.class, METHOD_NAME, httpGet, response);\n+\n+\t\t\t\tStatusLine statusLine = response.getStatusLine();\n+\n+\t\t\t\tif (statusLine.getStatusCode() != 200) {\n+\t\t\t\t\tthrow new IOException(\n+\t\t\t\t\t\t\tMETHOD_NAME + \": Expected response 200, but received response: \" + statusLine);\n+\t\t\t\t}\n+\n+\t\t\t\tbyte[] result = EntityUtils.toByteArray(response.getEntity());\n+\n+\t\t\t\tLog.info(PebbleContainer.class, METHOD_NAME, new String(result));\n+\t\t\t\treturn result;\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Get Pebble's root certificate.\n+\t * \n+\t * @param fileName\n+\t *            The name of the file to save the certificate to.\n+\t * @return Pebble's root CA certificate in the form of a PEM file.\n+\t * @throws Exception\n+\t *             If we failed to receive the certificate.\n+\t */\n+\tpublic byte[] getAcmeCaRootCertificate() throws Exception {\n+\t\tfinal String METHOD_NAME = \"getAcmeCaRootCertificate()\";\n+\t\tString url = \"https://\" + this.getContainerIpAddress() + \":\" + this.getMappedPort(MANAGEMENT_PORT) + \"/roots/0\";\n+\n+\t\ttry (CloseableHttpClient httpclient = AcmeFatUtils.getInsecureHttpsClient()) {\n+\t\t\t/*\n+\t\t\t * Create a GET request to the ACME CA server.\n+\t\t\t */\n+\t\t\tHttpGet httpGet = new HttpGet(url);\n+\n+\t\t\t/*\n+\t\t\t * Send the GET request and process the response.\n+\t\t\t */\n+\t\t\ttry (final CloseableHttpResponse response = httpclient.execute(httpGet)) {\n+\t\t\t\tAcmeFatUtils.logHttpResponse(BoulderContainer.class, METHOD_NAME, httpGet, response);\n+\n+\t\t\t\tStatusLine statusLine = response.getStatusLine();\n+\n+\t\t\t\tif (statusLine.getStatusCode() != 200) {\n+\t\t\t\t\tthrow new IOException(\n+\t\t\t\t\t\t\tMETHOD_NAME + \": Expected response 200, but received response: \" + statusLine);\n+\t\t\t\t}\n+\n+\t\t\t\tbyte[] result = EntityUtils.toByteArray(response.getEntity());\n+\n+\t\t\t\tLog.info(BoulderContainer.class, METHOD_NAME, new String(result));\n+\t\t\t\treturn result;\n+\t\t\t}\n+\t\t}\n+\t}\n+\t\n+\t/**\n+\t * Get the status of the certificate from the ACME CA server.\n+\t * \n+\t * @param certificate\n+\t *            The certificate to check.\n+\t * @return The status of the certificate.\n+\t * @throws Exception\n+\t */\n+\tpublic String getAcmeCertificateStatus(X509Certificate certificate) throws Exception {\n+\t\tfinal String METHOD_NAME = \"getAcmeCertificateStatus()\";\n+\t\tString url = \"https://\" + this.getContainerIpAddress() + \":\" + this.getMappedPort(MANAGEMENT_PORT)\n+\t\t\t\t+ \"/cert-status-by-serial/\" + certificate.getSerialNumber().toString(16);\n+\n+\t\ttry (CloseableHttpClient httpclient = AcmeFatUtils.getInsecureHttpsClient()) {\n+\t\t\t/*\n+\t\t\t * Create a GET request to the ACME CA server.\n+\t\t\t */\n+\t\t\tHttpGet httpGet = new HttpGet(url);\n+\n+\t\t\t/*\n+\t\t\t * Send the GET request and process the response.\n+\t\t\t */\n+\t\t\ttry (final CloseableHttpResponse response = httpclient.execute(httpGet)) {\n+\t\t\t\tAcmeFatUtils.logHttpResponse(BoulderContainer.class, METHOD_NAME, httpGet, response);\n+\n+\t\t\t\tStatusLine statusLine = response.getStatusLine();\n+\n+\t\t\t\tif (statusLine.getStatusCode() != 200) {\n+\t\t\t\t\tthrow new IOException(\n+\t\t\t\t\t\t\tMETHOD_NAME + \": Expected response 200, but received response: \" + statusLine);\n+\t\t\t\t}\n+\n+\t\t\t\tString result = EntityUtils.toString(response.getEntity());\n+\n+\t\t\t\t/*\n+\t\t\t\t * The result is in JSON, lets just parse out the status.\n+\t\t\t\t */\n+\t\t\t\tPattern p = Pattern.compile(\".*\\\"Status\\\": \\\"(\\\\w+)\\\",.*\", Pattern.DOTALL);\n+\t\t\t\tMatcher m = p.matcher(result);\n+\t\t\t\tif (m.find()) {\n+\t\t\t\t\tresult = m.group(1);\n+\t\t\t\t} else {\n+\t\t\t\t\tthrow new Exception(\n+\t\t\t\t\t\t\t\"Certificate status response was not in expected JSON format. Response: \" + result);\n+\t\t\t\t}\n+\n+\t\t\t\tLog.info(BoulderContainer.class, METHOD_NAME, new String(result));\n+\t\t\t\treturn result;\n+\t\t\t}\n+\t\t}\n+\t}\n+\t\n+\tpublic String getClientHost() throws IllegalStateException {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3dd0ccb898e794282f2c55bdc25f1b9f77207045"}, "originalPosition": 178}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ1MDE1MzU5OnYy", "diffSide": "RIGHT", "path": "dev/com.ibm.ws.security.acme_fat/fat/src/com/ibm/ws/security/acme/docker/CAContainer.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOVQyMDoyMjo1NlrOF4_Eaw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOVQyMDoyMjo1NlrOF4_Eaw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTI5Nzg5OQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t\t\t\tAcmeFatUtils.logHttpResponse(ChalltestsrvContainer.class, METHOD_NAME, httpPost, response);\n          \n          \n            \n            \t\t\t\tAcmeFatUtils.logHttpResponse(CAContainer.class, METHOD_NAME, httpPost, response);", "url": "https://github.com/OpenLiberty/open-liberty/pull/11374#discussion_r395297899", "createdAt": "2020-03-19T20:22:56Z", "author": {"login": "jvanhill"}, "path": "dev/com.ibm.ws.security.acme_fat/fat/src/com/ibm/ws/security/acme/docker/CAContainer.java", "diffHunk": "@@ -0,0 +1,372 @@\n+package com.ibm.ws.security.acme.docker;\n+\n+import static junit.framework.Assert.fail;\n+\n+import java.io.IOException;\n+import java.security.cert.X509Certificate;\n+import java.util.Map.Entry;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import org.apache.http.StatusLine;\n+import org.apache.http.client.methods.CloseableHttpResponse;\n+import org.apache.http.client.methods.HttpGet;\n+import org.apache.http.client.methods.HttpPost;\n+import org.apache.http.entity.ContentType;\n+import org.apache.http.entity.StringEntity;\n+import org.apache.http.impl.client.CloseableHttpClient;\n+import org.apache.http.impl.client.HttpClients;\n+import org.apache.http.util.EntityUtils;\n+import org.testcontainers.containers.GenericContainer;\n+import org.testcontainers.images.builder.ImageFromDockerfile;\n+\n+import com.github.dockerjava.api.model.ContainerNetwork;\n+import com.ibm.websphere.simplicity.log.Log;\n+import com.ibm.ws.security.acme.utils.AcmeFatUtils;\n+\n+public class CAContainer extends GenericContainer<BoulderContainer> {\n+\n+\n+\tpublic static final int HTTP_PORT = 5002;\n+\n+\t/** The REST management API port. */\n+\tpublic int MANAGEMENT_PORT = 8055;\n+\t\n+\tpublic CAContainer(String image) {\n+\t\tsuper(image);\n+\t}\n+\n+\tpublic CAContainer(ImageFromDockerfile image, int managementPort) {\n+\t\tsuper(image);\n+\t\tMANAGEMENT_PORT = managementPort;\n+\t}\n+\n+\n+\t/**\n+\t * Get Pebble's intermediate certificate.\n+\t * \n+\t * @param fileName\n+\t *            The name of the file to save the certificate to.\n+\t * @return Pebble's root CA certificate in the form of a PEM file.\n+\t * @throws Exception\n+\t *             If we failed to receive the certificate.\n+\t */\n+\tpublic byte[] getAcmeCaIntermediateCertificate() throws Exception {\n+\t\tfinal String METHOD_NAME = \"getAcmeCaIntermediateCertificate()\";\n+\t\tString url = \"https://\" + this.getContainerIpAddress() + \":\" + this.getMappedPort(MANAGEMENT_PORT)\n+\t\t\t\t+ \"/intermediates/0\";\n+\n+\t\ttry (CloseableHttpClient httpclient = AcmeFatUtils.getInsecureHttpsClient()) {\n+\t\t\t/*\n+\t\t\t * Create a GET request to the ACME CA server.\n+\t\t\t */\n+\t\t\tHttpGet httpGet = new HttpGet(url);\n+\n+\t\t\t/*\n+\t\t\t * Send the GET request and process the response.\n+\t\t\t */\n+\t\t\ttry (final CloseableHttpResponse response = httpclient.execute(httpGet)) {\n+\t\t\t\tAcmeFatUtils.logHttpResponse(PebbleContainer.class, METHOD_NAME, httpGet, response);\n+\n+\t\t\t\tStatusLine statusLine = response.getStatusLine();\n+\n+\t\t\t\tif (statusLine.getStatusCode() != 200) {\n+\t\t\t\t\tthrow new IOException(\n+\t\t\t\t\t\t\tMETHOD_NAME + \": Expected response 200, but received response: \" + statusLine);\n+\t\t\t\t}\n+\n+\t\t\t\tbyte[] result = EntityUtils.toByteArray(response.getEntity());\n+\n+\t\t\t\tLog.info(PebbleContainer.class, METHOD_NAME, new String(result));\n+\t\t\t\treturn result;\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Get Pebble's root certificate.\n+\t * \n+\t * @param fileName\n+\t *            The name of the file to save the certificate to.\n+\t * @return Pebble's root CA certificate in the form of a PEM file.\n+\t * @throws Exception\n+\t *             If we failed to receive the certificate.\n+\t */\n+\tpublic byte[] getAcmeCaRootCertificate() throws Exception {\n+\t\tfinal String METHOD_NAME = \"getAcmeCaRootCertificate()\";\n+\t\tString url = \"https://\" + this.getContainerIpAddress() + \":\" + this.getMappedPort(MANAGEMENT_PORT) + \"/roots/0\";\n+\n+\t\ttry (CloseableHttpClient httpclient = AcmeFatUtils.getInsecureHttpsClient()) {\n+\t\t\t/*\n+\t\t\t * Create a GET request to the ACME CA server.\n+\t\t\t */\n+\t\t\tHttpGet httpGet = new HttpGet(url);\n+\n+\t\t\t/*\n+\t\t\t * Send the GET request and process the response.\n+\t\t\t */\n+\t\t\ttry (final CloseableHttpResponse response = httpclient.execute(httpGet)) {\n+\t\t\t\tAcmeFatUtils.logHttpResponse(BoulderContainer.class, METHOD_NAME, httpGet, response);\n+\n+\t\t\t\tStatusLine statusLine = response.getStatusLine();\n+\n+\t\t\t\tif (statusLine.getStatusCode() != 200) {\n+\t\t\t\t\tthrow new IOException(\n+\t\t\t\t\t\t\tMETHOD_NAME + \": Expected response 200, but received response: \" + statusLine);\n+\t\t\t\t}\n+\n+\t\t\t\tbyte[] result = EntityUtils.toByteArray(response.getEntity());\n+\n+\t\t\t\tLog.info(BoulderContainer.class, METHOD_NAME, new String(result));\n+\t\t\t\treturn result;\n+\t\t\t}\n+\t\t}\n+\t}\n+\t\n+\t/**\n+\t * Get the status of the certificate from the ACME CA server.\n+\t * \n+\t * @param certificate\n+\t *            The certificate to check.\n+\t * @return The status of the certificate.\n+\t * @throws Exception\n+\t */\n+\tpublic String getAcmeCertificateStatus(X509Certificate certificate) throws Exception {\n+\t\tfinal String METHOD_NAME = \"getAcmeCertificateStatus()\";\n+\t\tString url = \"https://\" + this.getContainerIpAddress() + \":\" + this.getMappedPort(MANAGEMENT_PORT)\n+\t\t\t\t+ \"/cert-status-by-serial/\" + certificate.getSerialNumber().toString(16);\n+\n+\t\ttry (CloseableHttpClient httpclient = AcmeFatUtils.getInsecureHttpsClient()) {\n+\t\t\t/*\n+\t\t\t * Create a GET request to the ACME CA server.\n+\t\t\t */\n+\t\t\tHttpGet httpGet = new HttpGet(url);\n+\n+\t\t\t/*\n+\t\t\t * Send the GET request and process the response.\n+\t\t\t */\n+\t\t\ttry (final CloseableHttpResponse response = httpclient.execute(httpGet)) {\n+\t\t\t\tAcmeFatUtils.logHttpResponse(BoulderContainer.class, METHOD_NAME, httpGet, response);\n+\n+\t\t\t\tStatusLine statusLine = response.getStatusLine();\n+\n+\t\t\t\tif (statusLine.getStatusCode() != 200) {\n+\t\t\t\t\tthrow new IOException(\n+\t\t\t\t\t\t\tMETHOD_NAME + \": Expected response 200, but received response: \" + statusLine);\n+\t\t\t\t}\n+\n+\t\t\t\tString result = EntityUtils.toString(response.getEntity());\n+\n+\t\t\t\t/*\n+\t\t\t\t * The result is in JSON, lets just parse out the status.\n+\t\t\t\t */\n+\t\t\t\tPattern p = Pattern.compile(\".*\\\"Status\\\": \\\"(\\\\w+)\\\",.*\", Pattern.DOTALL);\n+\t\t\t\tMatcher m = p.matcher(result);\n+\t\t\t\tif (m.find()) {\n+\t\t\t\t\tresult = m.group(1);\n+\t\t\t\t} else {\n+\t\t\t\t\tthrow new Exception(\n+\t\t\t\t\t\t\t\"Certificate status response was not in expected JSON format. Response: \" + result);\n+\t\t\t\t}\n+\n+\t\t\t\tLog.info(BoulderContainer.class, METHOD_NAME, new String(result));\n+\t\t\t\treturn result;\n+\t\t\t}\n+\t\t}\n+\t}\n+\t\n+\tpublic String getClientHost() throws IllegalStateException {\n+\t\tfor (String extraHost : this.getExtraHosts()) {\n+\t\t\tif (extraHost.startsWith(\"host.testcontainers.internal:\")) {\n+\t\t\t\treturn extraHost.replace(\"host.testcontainers.internal:\", \"\");\n+\t\t\t}\n+\t\t}\n+\n+\t\tthrow new IllegalStateException(\n+\t\t\t\t\"Unable to resolve local host from docker container. Could not find 'host.testcontainers.internal' property.\");\n+\t}\n+\t\n+\t/**\n+\t * Add an A record to the mock DNS server. This will allow us to redirect\n+\t * requests to a named domain to the IPv4 address of our choice.\n+\t * \n+\t * @param host\n+\t *            The host / domain to redirect requests for.\n+\t * @param address\n+\t *            The address to direct the requests for that host to.\n+\t * @throws IOException\n+\t */\n+\tpublic void addARecord(String host, String address) throws IOException {\n+\t\tfinal String METHOD_NAME = \"addARecord\";\n+\n+\t\ttry (CloseableHttpClient httpclient = HttpClients.createDefault()) {\n+\n+\t\t\t/*\n+\t\t\t * Generate the JSON request. The request can support multiple\n+\t\t\t * addresses but for the time being we will only support sending\n+\t\t\t * one.\n+\t\t\t */\n+\t\t\tString jsonString = \"{\\\"host\\\":\\\"\" + host + \"\\\",\\\"addresses\\\":[\\\"\" + address + \"\\\"]}\";\n+\t\t\tStringEntity requestEntity = new StringEntity(jsonString, ContentType.APPLICATION_JSON);\n+\n+\t\t\t/*\n+\t\t\t * Create a POST request to the mock DNS server.\n+\t\t\t */\n+\t\t\tHttpPost httpPost = new HttpPost(getManagementAddress() + \"/add-a\");\n+\t\t\thttpPost.setEntity(requestEntity);\n+\n+\t\t\t/*\n+\t\t\t * Send the POST request and process the response.\n+\t\t\t */\n+\t\t\ttry (final CloseableHttpResponse response = httpclient.execute(httpPost)) {\n+\t\t\t\tAcmeFatUtils.logHttpResponse(ChalltestsrvContainer.class, METHOD_NAME, httpPost, response);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3dd0ccb898e794282f2c55bdc25f1b9f77207045"}, "originalPosition": 222}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ1MDE1NDM1OnYy", "diffSide": "RIGHT", "path": "dev/com.ibm.ws.security.acme_fat/fat/src/com/ibm/ws/security/acme/docker/BoulderContainer.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOVQyMDoyMzoxM1rOF4_E9w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOVQyMDoyMzoxM1rOF4_E9w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTI5ODAzOQ==", "bodyText": "Javadoc. Maybe explain how you replicated what was in the docker-compose file.", "url": "https://github.com/OpenLiberty/open-liberty/pull/11374#discussion_r395298039", "createdAt": "2020-03-19T20:23:13Z", "author": {"login": "jvanhill"}, "path": "dev/com.ibm.ws.security.acme_fat/fat/src/com/ibm/ws/security/acme/docker/BoulderContainer.java", "diffHunk": "@@ -0,0 +1,253 @@\n+package com.ibm.ws.security.acme.docker;\n+\n+import java.io.IOException;\n+import java.security.cert.X509Certificate;\n+import java.time.Duration;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import org.apache.http.StatusLine;\n+import org.apache.http.client.methods.CloseableHttpResponse;\n+import org.apache.http.client.methods.HttpGet;\n+import org.apache.http.client.methods.HttpPost;\n+import org.apache.http.entity.ContentType;\n+import org.apache.http.entity.StringEntity;\n+import org.apache.http.impl.client.CloseableHttpClient;\n+import org.apache.http.impl.client.HttpClients;\n+import org.apache.http.util.EntityUtils;\n+import org.testcontainers.containers.GenericContainer;\n+import org.testcontainers.containers.Network;\n+import org.testcontainers.utility.MountableFile;\n+\n+import com.github.dockerjava.api.model.ContainerNetwork;\n+import com.github.dockerjava.api.model.ContainerNetwork.Ipam;\n+import com.ibm.websphere.simplicity.log.Log;\n+import com.ibm.ws.security.acme.utils.AcmeFatUtils;\n+\n+public class BoulderContainer extends CAContainer {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3dd0ccb898e794282f2c55bdc25f1b9f77207045"}, "originalPosition": 27}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ1MDE2NTQzOnYy", "diffSide": "RIGHT", "path": "dev/com.ibm.ws.security.acme_fat/fat/src/com/ibm/ws/security/acme/docker/BoulderContainer.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOVQyMDoyNjo1MFrOF4_MOA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOVQyMDoyNjo1MFrOF4_MOA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTI5OTg5Ng==", "bodyText": "white space", "url": "https://github.com/OpenLiberty/open-liberty/pull/11374#discussion_r395299896", "createdAt": "2020-03-19T20:26:50Z", "author": {"login": "jvanhill"}, "path": "dev/com.ibm.ws.security.acme_fat/fat/src/com/ibm/ws/security/acme/docker/BoulderContainer.java", "diffHunk": "@@ -0,0 +1,253 @@\n+package com.ibm.ws.security.acme.docker;\n+\n+import java.io.IOException;\n+import java.security.cert.X509Certificate;\n+import java.time.Duration;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import org.apache.http.StatusLine;\n+import org.apache.http.client.methods.CloseableHttpResponse;\n+import org.apache.http.client.methods.HttpGet;\n+import org.apache.http.client.methods.HttpPost;\n+import org.apache.http.entity.ContentType;\n+import org.apache.http.entity.StringEntity;\n+import org.apache.http.impl.client.CloseableHttpClient;\n+import org.apache.http.impl.client.HttpClients;\n+import org.apache.http.util.EntityUtils;\n+import org.testcontainers.containers.GenericContainer;\n+import org.testcontainers.containers.Network;\n+import org.testcontainers.utility.MountableFile;\n+\n+import com.github.dockerjava.api.model.ContainerNetwork;\n+import com.github.dockerjava.api.model.ContainerNetwork.Ipam;\n+import com.ibm.websphere.simplicity.log.Log;\n+import com.ibm.ws.security.acme.utils.AcmeFatUtils;\n+\n+public class BoulderContainer extends CAContainer {\n+\n+\tpublic static final int HTTP_PORT = 5002;\n+\n+\t/** The port used to listen for incoming ACME requests. */\n+\tpublic static final int LISTEN_PORT = 4001;\n+\n+\t/** The REST management API port. */\n+\tpublic static final int MANAGEMENT_PORT = 8055;\n+    \n+    public final Network bluenet = Network.builder()\n+            .createNetworkCmdModifier(cmd -> {\n+                cmd.withDriver(\"bridge\");\n+                cmd.withIpam(new com.github.dockerjava.api.model.Network.Ipam()\n+                        .withDriver(\"default\")\n+                        .withConfig(new com.github.dockerjava.api.model.Network.Ipam.Config()\n+                                .withSubnet(\"10.77.77.0/24\")));\n+            })\n+            .build();\n+\n+    public final Network rednet =  Network.builder()\n+            .createNetworkCmdModifier(cmd -> {\n+                cmd.withDriver(\"bridge\");\n+                cmd.withIpam(new com.github.dockerjava.api.model.Network.Ipam()\n+                        .withDriver(\"default\")\n+                        .withConfig(new com.github.dockerjava.api.model.Network.Ipam.Config()\n+                                .withSubnet(\"10.88.88.0/24\")));\n+            })\n+            .build();\n+    \n+    public final GenericContainer<?> bhsm = new GenericContainer<>(IMAGE)\n+            .withEnv(\"PKCS11_DAEMON_SOCKET\", \"tcp://0.0.0.0:5657\")\n+            .withExposedPorts(5657)\n+            .withNetwork(bluenet)\n+            .withNetworkAliases(\"boulder-hsm\")\n+            .withCommand(\"/usr/local/bin/pkcs11-daemon /usr/lib/softhsm/libsofthsm2.so\")\n+            .withLogConsumer(o -> System.out.print(\"[HSM] \" + o.getUtf8String()));\n+    \n+    public final GenericContainer<?> bmysql = new GenericContainer<>(\"mariadb:10.3\")\n+            .withNetwork(bluenet)\n+            .withExposedPorts(3306)\n+            .withNetworkAliases(\"boulder-mysql\")\n+            .withEnv(\"MYSQL_ALLOW_EMPTY_PASSWORD\", \"yes\")\n+            .withCommand(\"mysqld --bind-address=0.0.0.0 --slow-query-log --log-output=TABLE --log-queries-not-using-indexes=ON\")\n+            .withLogConsumer(o -> System.out.print(\"[SQL] \" + o.getUtf8String()));\n+    \n+    private static final String IMAGE = \"ryanesch/acme-boulder:latest\";\n+    \n+    public BoulderContainer() {\n+        super(IMAGE);\n+    }\n+    \n+    @Override\n+    protected void configure() {\n+            this.withEnv(\"FAKE_DNS\", \"172.17.0.68\")\n+            .withEnv(\"PKCS11_PROXY_SOCKET\", \"tcp://boulder-hsm:5657\")\n+            .withEnv(\"BOULDER_CONFIG_DIR\", \"test/config\")\n+            .withEnv(\"GO111MODULE\", \"on\")\n+            .withEnv(\"GOFLAGS\", \"-mod=vendor\")\n+            .withEnv(\"PYTHONIOENCODING\", \"utf-8\")\n+            .withCreateContainerCmdModifier(cmd -> {\n+                cmd.withDns(\"10.77.77.77\");\n+            })\n+            \n+            .withWorkingDirectory(\"/go/src/github.com/letsencrypt/boulder\")\n+            .withCommand(\"/go/src/github.com/letsencrypt/boulder/test/entrypoint.sh\")\n+            .withNetworkAliases(\"boulder\")\n+            .withCreateContainerCmdModifier(cmd -> cmd.withHostName(\"boulder\"))\n+    \t\t.withExposedPorts(MANAGEMENT_PORT, LISTEN_PORT)\n+            .withLogConsumer(o -> System.out.print(\"[BOL] \" + o.getUtf8String()))\n+            .withStartupTimeout(Duration.ofMinutes(3));\n+    }\n+    \t\t\t\t\t\t\t\t\t\n+    \t\t\t\t\t\t\t\n+    \t\t\t\t\t\t\t\t\t\n+\n+    @Override\n+    protected void containerIsCreated(String containerId) {\n+        getDockerClient().connectToNetworkCmd()\n+                .withNetworkId(bluenet.getId())\n+                .withContainerId(containerId)\n+                .withContainerNetwork(new ContainerNetwork()\n+                        .withIpv4Address(\"10.77.77.77\")\n+                        .withNetworkID(bluenet.getId())\n+                        .withIpamConfig(new Ipam().withIpv4Address(\"10.77.77.77\"))\n+                        .withAliases(\"sa1.boulder\", \"ca1.boulder\", \"ra1.boulder\", \"va1.boulder\", \"publisher1.boulder\", \n+                              \"ocsp-updater.boulder\", \"admin-revoker.boulder\", \"nonce1.boulder\"))\n+                .exec();\n+        \n+        getDockerClient().connectToNetworkCmd()\n+                .withNetworkId(rednet.getId())\n+                .withContainerId(containerId)\n+                .withContainerNetwork(new ContainerNetwork()\n+                        .withIpv4Address(\"10.88.88.88\")\n+                        .withNetworkID(rednet.getId())\n+                        .withIpamConfig(new Ipam().withIpv4Address(\"10.88.88.88\"))\n+                        .withAliases(\"sa2.boulder\", \"ca2.boulder\", \"ra2.boulder\", \"va2.boulder\", \n+                                \"publisher2.boulder\", \"nonce2.boulder\"))\n+                .exec();\n+    }\n+    \n+    @Override\n+    public void start() {\n+        bmysql.start();\n+        bhsm.start();\n+        super.start();\n+    }\n+    \n+\tpublic byte[] getAcmeCaIntermediateCertificate() throws Exception {\n+\t\tfinal String METHOD_NAME = \"getAcmeCaIntermediateCertificate()\";\n+\t\tString url = \"https://\" + this.getContainerIpAddress() + \":\" + this.getMappedPort(MANAGEMENT_PORT)\n+\t\t\t\t+ \"/intermediates/0\";\n+\n+\t\ttry (CloseableHttpClient httpclient = AcmeFatUtils.getInsecureHttpsClient()) {\n+\t\t\t/*\n+\t\t\t * Create a GET request to the ACME CA server.\n+\t\t\t */\n+\t\t\tHttpGet httpGet = new HttpGet(url);\n+\n+\t\t\t/*\n+\t\t\t * Send the GET request and process the response.\n+\t\t\t */\n+\t\t\ttry (final CloseableHttpResponse response = httpclient.execute(httpGet)) {\n+\t\t\t\tAcmeFatUtils.logHttpResponse(BoulderContainer.class, METHOD_NAME, httpGet, response);\n+\n+\t\t\t\tStatusLine statusLine = response.getStatusLine();\n+\n+\t\t\t\tif (statusLine.getStatusCode() != 200) {\n+\t\t\t\t\tthrow new IOException(\n+\t\t\t\t\t\t\tMETHOD_NAME + \": Expected response 200, but received response: \" + statusLine);\n+\t\t\t\t}\n+\n+\t\t\t\tbyte[] result = EntityUtils.toByteArray(response.getEntity());\n+\n+\t\t\t\tLog.info(BoulderContainer.class, METHOD_NAME, new String(result));\n+\t\t\t\treturn result;\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\tpublic byte[] getAcmeCaRootCertificate() throws Exception {\n+\t\tfinal String METHOD_NAME = \"getAcmeCaRootCertificate()\";\n+\t\tString url = \"https://\" + this.getContainerIpAddress() + \":\" + this.getMappedPort(MANAGEMENT_PORT) + \"/roots/0\";\n+\n+\t\ttry (CloseableHttpClient httpclient = AcmeFatUtils.getInsecureHttpsClient()) {\n+\t\t\t/*\n+\t\t\t * Create a GET request to the ACME CA server.\n+\t\t\t */\n+\t\t\tHttpGet httpGet = new HttpGet(url);\n+\n+\t\t\t/*\n+\t\t\t * Send the GET request and process the response.\n+\t\t\t */\n+\t\t\ttry (final CloseableHttpResponse response = httpclient.execute(httpGet)) {\n+\t\t\t\tAcmeFatUtils.logHttpResponse(BoulderContainer.class, METHOD_NAME, httpGet, response);\n+\n+\t\t\t\tStatusLine statusLine = response.getStatusLine();\n+\n+\t\t\t\tif (statusLine.getStatusCode() != 200) {\n+\t\t\t\t\tthrow new IOException(\n+\t\t\t\t\t\t\tMETHOD_NAME + \": Expected response 200, but received response: \" + statusLine);\n+\t\t\t\t}\n+\n+\t\t\t\tbyte[] result = EntityUtils.toByteArray(response.getEntity());\n+\n+\t\t\t\tLog.info(BoulderContainer.class, METHOD_NAME, new String(result));\n+\t\t\t\treturn result;\n+\t\t\t}\n+\t\t}\n+\t}\n+\t\n+\t/**\n+\t * Get the status of the certificate from the ACME CA server.\n+\t * \n+\t * @param certificate\n+\t *            The certificate to check.\n+\t * @return The status of the certificate.\n+\t * @throws Exception\n+\t */\n+\tpublic String getAcmeCertificateStatus(X509Certificate certificate) throws Exception {\n+\t\tfinal String METHOD_NAME = \"getAcmeCertificateStatus()\";\n+\t\tString url = \"https://\" + this.getContainerIpAddress() + \":\" + this.getMappedPort(MANAGEMENT_PORT)\n+\t\t\t\t+ \"/cert-status-by-serial/\" + certificate.getSerialNumber().toString(16);\n+\n+\t\ttry (CloseableHttpClient httpclient = AcmeFatUtils.getInsecureHttpsClient()) {\n+\t\t\t/*\n+\t\t\t * Create a GET request to the ACME CA server.\n+\t\t\t */\n+\t\t\tHttpGet httpGet = new HttpGet(url);\n+\n+\t\t\t/*\n+\t\t\t * Send the GET request and process the response.\n+\t\t\t */\n+\t\t\ttry (final CloseableHttpResponse response = httpclient.execute(httpGet)) {\n+\t\t\t\tAcmeFatUtils.logHttpResponse(BoulderContainer.class, METHOD_NAME, httpGet, response);\n+\n+\t\t\t\tStatusLine statusLine = response.getStatusLine();\n+\n+\t\t\t\tif (statusLine.getStatusCode() != 200) {\n+\t\t\t\t\tthrow new IOException(\n+\t\t\t\t\t\t\tMETHOD_NAME + \": Expected response 200, but received response: \" + statusLine);\n+\t\t\t\t}\n+\n+\t\t\t\tString result = EntityUtils.toString(response.getEntity());\n+\n+\t\t\t\t/*\n+\t\t\t\t * The result is in JSON, lets just parse out the status.\n+\t\t\t\t */\n+\t\t\t\tPattern p = Pattern.compile(\".*\\\"Status\\\": \\\"(\\\\w+)\\\",.*\", Pattern.DOTALL);\n+\t\t\t\tMatcher m = p.matcher(result);\n+\t\t\t\tif (m.find()) {\n+\t\t\t\t\tresult = m.group(1);\n+\t\t\t\t} else {\n+\t\t\t\t\tthrow new Exception(\n+\t\t\t\t\t\t\t\"Certificate status response was not in expected JSON format. Response: \" + result);\n+\t\t\t\t}\n+\n+\t\t\t\tLog.info(BoulderContainer.class, METHOD_NAME, new String(result));\n+\t\t\t\treturn result;\n+\t\t\t}\n+\t\t}\n+\t}\n+\t@Override", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3dd0ccb898e794282f2c55bdc25f1b9f77207045"}, "originalPosition": 249}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ1MDE2NzU3OnYy", "diffSide": "RIGHT", "path": "dev/com.ibm.ws.security.acme_fat/fat/src/com/ibm/ws/security/acme/docker/BoulderContainer.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOVQyMDoyNzozM1rOF4_NoA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOVQyMDoyNzozM1rOF4_NoA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTMwMDI1Ng==", "bodyText": "How is this different then the method in CAContainer?", "url": "https://github.com/OpenLiberty/open-liberty/pull/11374#discussion_r395300256", "createdAt": "2020-03-19T20:27:33Z", "author": {"login": "jvanhill"}, "path": "dev/com.ibm.ws.security.acme_fat/fat/src/com/ibm/ws/security/acme/docker/BoulderContainer.java", "diffHunk": "@@ -0,0 +1,253 @@\n+package com.ibm.ws.security.acme.docker;\n+\n+import java.io.IOException;\n+import java.security.cert.X509Certificate;\n+import java.time.Duration;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import org.apache.http.StatusLine;\n+import org.apache.http.client.methods.CloseableHttpResponse;\n+import org.apache.http.client.methods.HttpGet;\n+import org.apache.http.client.methods.HttpPost;\n+import org.apache.http.entity.ContentType;\n+import org.apache.http.entity.StringEntity;\n+import org.apache.http.impl.client.CloseableHttpClient;\n+import org.apache.http.impl.client.HttpClients;\n+import org.apache.http.util.EntityUtils;\n+import org.testcontainers.containers.GenericContainer;\n+import org.testcontainers.containers.Network;\n+import org.testcontainers.utility.MountableFile;\n+\n+import com.github.dockerjava.api.model.ContainerNetwork;\n+import com.github.dockerjava.api.model.ContainerNetwork.Ipam;\n+import com.ibm.websphere.simplicity.log.Log;\n+import com.ibm.ws.security.acme.utils.AcmeFatUtils;\n+\n+public class BoulderContainer extends CAContainer {\n+\n+\tpublic static final int HTTP_PORT = 5002;\n+\n+\t/** The port used to listen for incoming ACME requests. */\n+\tpublic static final int LISTEN_PORT = 4001;\n+\n+\t/** The REST management API port. */\n+\tpublic static final int MANAGEMENT_PORT = 8055;\n+    \n+    public final Network bluenet = Network.builder()\n+            .createNetworkCmdModifier(cmd -> {\n+                cmd.withDriver(\"bridge\");\n+                cmd.withIpam(new com.github.dockerjava.api.model.Network.Ipam()\n+                        .withDriver(\"default\")\n+                        .withConfig(new com.github.dockerjava.api.model.Network.Ipam.Config()\n+                                .withSubnet(\"10.77.77.0/24\")));\n+            })\n+            .build();\n+\n+    public final Network rednet =  Network.builder()\n+            .createNetworkCmdModifier(cmd -> {\n+                cmd.withDriver(\"bridge\");\n+                cmd.withIpam(new com.github.dockerjava.api.model.Network.Ipam()\n+                        .withDriver(\"default\")\n+                        .withConfig(new com.github.dockerjava.api.model.Network.Ipam.Config()\n+                                .withSubnet(\"10.88.88.0/24\")));\n+            })\n+            .build();\n+    \n+    public final GenericContainer<?> bhsm = new GenericContainer<>(IMAGE)\n+            .withEnv(\"PKCS11_DAEMON_SOCKET\", \"tcp://0.0.0.0:5657\")\n+            .withExposedPorts(5657)\n+            .withNetwork(bluenet)\n+            .withNetworkAliases(\"boulder-hsm\")\n+            .withCommand(\"/usr/local/bin/pkcs11-daemon /usr/lib/softhsm/libsofthsm2.so\")\n+            .withLogConsumer(o -> System.out.print(\"[HSM] \" + o.getUtf8String()));\n+    \n+    public final GenericContainer<?> bmysql = new GenericContainer<>(\"mariadb:10.3\")\n+            .withNetwork(bluenet)\n+            .withExposedPorts(3306)\n+            .withNetworkAliases(\"boulder-mysql\")\n+            .withEnv(\"MYSQL_ALLOW_EMPTY_PASSWORD\", \"yes\")\n+            .withCommand(\"mysqld --bind-address=0.0.0.0 --slow-query-log --log-output=TABLE --log-queries-not-using-indexes=ON\")\n+            .withLogConsumer(o -> System.out.print(\"[SQL] \" + o.getUtf8String()));\n+    \n+    private static final String IMAGE = \"ryanesch/acme-boulder:latest\";\n+    \n+    public BoulderContainer() {\n+        super(IMAGE);\n+    }\n+    \n+    @Override\n+    protected void configure() {\n+            this.withEnv(\"FAKE_DNS\", \"172.17.0.68\")\n+            .withEnv(\"PKCS11_PROXY_SOCKET\", \"tcp://boulder-hsm:5657\")\n+            .withEnv(\"BOULDER_CONFIG_DIR\", \"test/config\")\n+            .withEnv(\"GO111MODULE\", \"on\")\n+            .withEnv(\"GOFLAGS\", \"-mod=vendor\")\n+            .withEnv(\"PYTHONIOENCODING\", \"utf-8\")\n+            .withCreateContainerCmdModifier(cmd -> {\n+                cmd.withDns(\"10.77.77.77\");\n+            })\n+            \n+            .withWorkingDirectory(\"/go/src/github.com/letsencrypt/boulder\")\n+            .withCommand(\"/go/src/github.com/letsencrypt/boulder/test/entrypoint.sh\")\n+            .withNetworkAliases(\"boulder\")\n+            .withCreateContainerCmdModifier(cmd -> cmd.withHostName(\"boulder\"))\n+    \t\t.withExposedPorts(MANAGEMENT_PORT, LISTEN_PORT)\n+            .withLogConsumer(o -> System.out.print(\"[BOL] \" + o.getUtf8String()))\n+            .withStartupTimeout(Duration.ofMinutes(3));\n+    }\n+    \t\t\t\t\t\t\t\t\t\n+    \t\t\t\t\t\t\t\n+    \t\t\t\t\t\t\t\t\t\n+\n+    @Override\n+    protected void containerIsCreated(String containerId) {\n+        getDockerClient().connectToNetworkCmd()\n+                .withNetworkId(bluenet.getId())\n+                .withContainerId(containerId)\n+                .withContainerNetwork(new ContainerNetwork()\n+                        .withIpv4Address(\"10.77.77.77\")\n+                        .withNetworkID(bluenet.getId())\n+                        .withIpamConfig(new Ipam().withIpv4Address(\"10.77.77.77\"))\n+                        .withAliases(\"sa1.boulder\", \"ca1.boulder\", \"ra1.boulder\", \"va1.boulder\", \"publisher1.boulder\", \n+                              \"ocsp-updater.boulder\", \"admin-revoker.boulder\", \"nonce1.boulder\"))\n+                .exec();\n+        \n+        getDockerClient().connectToNetworkCmd()\n+                .withNetworkId(rednet.getId())\n+                .withContainerId(containerId)\n+                .withContainerNetwork(new ContainerNetwork()\n+                        .withIpv4Address(\"10.88.88.88\")\n+                        .withNetworkID(rednet.getId())\n+                        .withIpamConfig(new Ipam().withIpv4Address(\"10.88.88.88\"))\n+                        .withAliases(\"sa2.boulder\", \"ca2.boulder\", \"ra2.boulder\", \"va2.boulder\", \n+                                \"publisher2.boulder\", \"nonce2.boulder\"))\n+                .exec();\n+    }\n+    \n+    @Override\n+    public void start() {\n+        bmysql.start();\n+        bhsm.start();\n+        super.start();\n+    }\n+    \n+\tpublic byte[] getAcmeCaIntermediateCertificate() throws Exception {\n+\t\tfinal String METHOD_NAME = \"getAcmeCaIntermediateCertificate()\";\n+\t\tString url = \"https://\" + this.getContainerIpAddress() + \":\" + this.getMappedPort(MANAGEMENT_PORT)\n+\t\t\t\t+ \"/intermediates/0\";\n+\n+\t\ttry (CloseableHttpClient httpclient = AcmeFatUtils.getInsecureHttpsClient()) {\n+\t\t\t/*\n+\t\t\t * Create a GET request to the ACME CA server.\n+\t\t\t */\n+\t\t\tHttpGet httpGet = new HttpGet(url);\n+\n+\t\t\t/*\n+\t\t\t * Send the GET request and process the response.\n+\t\t\t */\n+\t\t\ttry (final CloseableHttpResponse response = httpclient.execute(httpGet)) {\n+\t\t\t\tAcmeFatUtils.logHttpResponse(BoulderContainer.class, METHOD_NAME, httpGet, response);\n+\n+\t\t\t\tStatusLine statusLine = response.getStatusLine();\n+\n+\t\t\t\tif (statusLine.getStatusCode() != 200) {\n+\t\t\t\t\tthrow new IOException(\n+\t\t\t\t\t\t\tMETHOD_NAME + \": Expected response 200, but received response: \" + statusLine);\n+\t\t\t\t}\n+\n+\t\t\t\tbyte[] result = EntityUtils.toByteArray(response.getEntity());\n+\n+\t\t\t\tLog.info(BoulderContainer.class, METHOD_NAME, new String(result));\n+\t\t\t\treturn result;\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\tpublic byte[] getAcmeCaRootCertificate() throws Exception {\n+\t\tfinal String METHOD_NAME = \"getAcmeCaRootCertificate()\";\n+\t\tString url = \"https://\" + this.getContainerIpAddress() + \":\" + this.getMappedPort(MANAGEMENT_PORT) + \"/roots/0\";\n+\n+\t\ttry (CloseableHttpClient httpclient = AcmeFatUtils.getInsecureHttpsClient()) {\n+\t\t\t/*\n+\t\t\t * Create a GET request to the ACME CA server.\n+\t\t\t */\n+\t\t\tHttpGet httpGet = new HttpGet(url);\n+\n+\t\t\t/*\n+\t\t\t * Send the GET request and process the response.\n+\t\t\t */\n+\t\t\ttry (final CloseableHttpResponse response = httpclient.execute(httpGet)) {\n+\t\t\t\tAcmeFatUtils.logHttpResponse(BoulderContainer.class, METHOD_NAME, httpGet, response);\n+\n+\t\t\t\tStatusLine statusLine = response.getStatusLine();\n+\n+\t\t\t\tif (statusLine.getStatusCode() != 200) {\n+\t\t\t\t\tthrow new IOException(\n+\t\t\t\t\t\t\tMETHOD_NAME + \": Expected response 200, but received response: \" + statusLine);\n+\t\t\t\t}\n+\n+\t\t\t\tbyte[] result = EntityUtils.toByteArray(response.getEntity());\n+\n+\t\t\t\tLog.info(BoulderContainer.class, METHOD_NAME, new String(result));\n+\t\t\t\treturn result;\n+\t\t\t}\n+\t\t}\n+\t}\n+\t\n+\t/**\n+\t * Get the status of the certificate from the ACME CA server.\n+\t * \n+\t * @param certificate\n+\t *            The certificate to check.\n+\t * @return The status of the certificate.\n+\t * @throws Exception\n+\t */\n+\tpublic String getAcmeCertificateStatus(X509Certificate certificate) throws Exception {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3dd0ccb898e794282f2c55bdc25f1b9f77207045"}, "originalPosition": 206}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ1MDE3OTY2OnYy", "diffSide": "RIGHT", "path": "dev/com.ibm.ws.security.acme_fat/fat/src/com/ibm/ws/security/acme/docker/BoulderContainer.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOVQyMDozMTowNVrOF4_U_A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOVQyMDozMTowNVrOF4_U_A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTMwMjE0MA==", "bodyText": "It appears that you set this value in CAContainer... do we need this one? This value is somewhat ghosting the one in CAContainer.", "url": "https://github.com/OpenLiberty/open-liberty/pull/11374#discussion_r395302140", "createdAt": "2020-03-19T20:31:05Z", "author": {"login": "jvanhill"}, "path": "dev/com.ibm.ws.security.acme_fat/fat/src/com/ibm/ws/security/acme/docker/BoulderContainer.java", "diffHunk": "@@ -0,0 +1,253 @@\n+package com.ibm.ws.security.acme.docker;\n+\n+import java.io.IOException;\n+import java.security.cert.X509Certificate;\n+import java.time.Duration;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import org.apache.http.StatusLine;\n+import org.apache.http.client.methods.CloseableHttpResponse;\n+import org.apache.http.client.methods.HttpGet;\n+import org.apache.http.client.methods.HttpPost;\n+import org.apache.http.entity.ContentType;\n+import org.apache.http.entity.StringEntity;\n+import org.apache.http.impl.client.CloseableHttpClient;\n+import org.apache.http.impl.client.HttpClients;\n+import org.apache.http.util.EntityUtils;\n+import org.testcontainers.containers.GenericContainer;\n+import org.testcontainers.containers.Network;\n+import org.testcontainers.utility.MountableFile;\n+\n+import com.github.dockerjava.api.model.ContainerNetwork;\n+import com.github.dockerjava.api.model.ContainerNetwork.Ipam;\n+import com.ibm.websphere.simplicity.log.Log;\n+import com.ibm.ws.security.acme.utils.AcmeFatUtils;\n+\n+public class BoulderContainer extends CAContainer {\n+\n+\tpublic static final int HTTP_PORT = 5002;\n+\n+\t/** The port used to listen for incoming ACME requests. */\n+\tpublic static final int LISTEN_PORT = 4001;\n+\n+\t/** The REST management API port. */\n+\tpublic static final int MANAGEMENT_PORT = 8055;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3dd0ccb898e794282f2c55bdc25f1b9f77207045"}, "originalPosition": 35}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ1MDE4MzQ3OnYy", "diffSide": "RIGHT", "path": "dev/com.ibm.ws.security.acme_fat/fat/src/com/ibm/ws/security/acme/docker/BoulderContainer.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOVQyMDozMjoyMVrOF4_XXw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOVQyMDozMjo0MVrOF4_YEw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTMwMjc1MQ==", "bodyText": "Rename to DOCKER image? May want to comment that you create this one as part of replicating docker-compose with a GenericContainer.\nI wonder if WebSphere has it's own docker hub we could use?", "url": "https://github.com/OpenLiberty/open-liberty/pull/11374#discussion_r395302751", "createdAt": "2020-03-19T20:32:21Z", "author": {"login": "jvanhill"}, "path": "dev/com.ibm.ws.security.acme_fat/fat/src/com/ibm/ws/security/acme/docker/BoulderContainer.java", "diffHunk": "@@ -0,0 +1,253 @@\n+package com.ibm.ws.security.acme.docker;\n+\n+import java.io.IOException;\n+import java.security.cert.X509Certificate;\n+import java.time.Duration;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import org.apache.http.StatusLine;\n+import org.apache.http.client.methods.CloseableHttpResponse;\n+import org.apache.http.client.methods.HttpGet;\n+import org.apache.http.client.methods.HttpPost;\n+import org.apache.http.entity.ContentType;\n+import org.apache.http.entity.StringEntity;\n+import org.apache.http.impl.client.CloseableHttpClient;\n+import org.apache.http.impl.client.HttpClients;\n+import org.apache.http.util.EntityUtils;\n+import org.testcontainers.containers.GenericContainer;\n+import org.testcontainers.containers.Network;\n+import org.testcontainers.utility.MountableFile;\n+\n+import com.github.dockerjava.api.model.ContainerNetwork;\n+import com.github.dockerjava.api.model.ContainerNetwork.Ipam;\n+import com.ibm.websphere.simplicity.log.Log;\n+import com.ibm.ws.security.acme.utils.AcmeFatUtils;\n+\n+public class BoulderContainer extends CAContainer {\n+\n+\tpublic static final int HTTP_PORT = 5002;\n+\n+\t/** The port used to listen for incoming ACME requests. */\n+\tpublic static final int LISTEN_PORT = 4001;\n+\n+\t/** The REST management API port. */\n+\tpublic static final int MANAGEMENT_PORT = 8055;\n+    \n+    public final Network bluenet = Network.builder()\n+            .createNetworkCmdModifier(cmd -> {\n+                cmd.withDriver(\"bridge\");\n+                cmd.withIpam(new com.github.dockerjava.api.model.Network.Ipam()\n+                        .withDriver(\"default\")\n+                        .withConfig(new com.github.dockerjava.api.model.Network.Ipam.Config()\n+                                .withSubnet(\"10.77.77.0/24\")));\n+            })\n+            .build();\n+\n+    public final Network rednet =  Network.builder()\n+            .createNetworkCmdModifier(cmd -> {\n+                cmd.withDriver(\"bridge\");\n+                cmd.withIpam(new com.github.dockerjava.api.model.Network.Ipam()\n+                        .withDriver(\"default\")\n+                        .withConfig(new com.github.dockerjava.api.model.Network.Ipam.Config()\n+                                .withSubnet(\"10.88.88.0/24\")));\n+            })\n+            .build();\n+    \n+    public final GenericContainer<?> bhsm = new GenericContainer<>(IMAGE)\n+            .withEnv(\"PKCS11_DAEMON_SOCKET\", \"tcp://0.0.0.0:5657\")\n+            .withExposedPorts(5657)\n+            .withNetwork(bluenet)\n+            .withNetworkAliases(\"boulder-hsm\")\n+            .withCommand(\"/usr/local/bin/pkcs11-daemon /usr/lib/softhsm/libsofthsm2.so\")\n+            .withLogConsumer(o -> System.out.print(\"[HSM] \" + o.getUtf8String()));\n+    \n+    public final GenericContainer<?> bmysql = new GenericContainer<>(\"mariadb:10.3\")\n+            .withNetwork(bluenet)\n+            .withExposedPorts(3306)\n+            .withNetworkAliases(\"boulder-mysql\")\n+            .withEnv(\"MYSQL_ALLOW_EMPTY_PASSWORD\", \"yes\")\n+            .withCommand(\"mysqld --bind-address=0.0.0.0 --slow-query-log --log-output=TABLE --log-queries-not-using-indexes=ON\")\n+            .withLogConsumer(o -> System.out.print(\"[SQL] \" + o.getUtf8String()));\n+    \n+    private static final String IMAGE = \"ryanesch/acme-boulder:latest\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3dd0ccb898e794282f2c55bdc25f1b9f77207045"}, "originalPosition": 73}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTMwMjkzMQ==", "bodyText": "We also probably need instruction on how you created your image.", "url": "https://github.com/OpenLiberty/open-liberty/pull/11374#discussion_r395302931", "createdAt": "2020-03-19T20:32:41Z", "author": {"login": "jvanhill"}, "path": "dev/com.ibm.ws.security.acme_fat/fat/src/com/ibm/ws/security/acme/docker/BoulderContainer.java", "diffHunk": "@@ -0,0 +1,253 @@\n+package com.ibm.ws.security.acme.docker;\n+\n+import java.io.IOException;\n+import java.security.cert.X509Certificate;\n+import java.time.Duration;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import org.apache.http.StatusLine;\n+import org.apache.http.client.methods.CloseableHttpResponse;\n+import org.apache.http.client.methods.HttpGet;\n+import org.apache.http.client.methods.HttpPost;\n+import org.apache.http.entity.ContentType;\n+import org.apache.http.entity.StringEntity;\n+import org.apache.http.impl.client.CloseableHttpClient;\n+import org.apache.http.impl.client.HttpClients;\n+import org.apache.http.util.EntityUtils;\n+import org.testcontainers.containers.GenericContainer;\n+import org.testcontainers.containers.Network;\n+import org.testcontainers.utility.MountableFile;\n+\n+import com.github.dockerjava.api.model.ContainerNetwork;\n+import com.github.dockerjava.api.model.ContainerNetwork.Ipam;\n+import com.ibm.websphere.simplicity.log.Log;\n+import com.ibm.ws.security.acme.utils.AcmeFatUtils;\n+\n+public class BoulderContainer extends CAContainer {\n+\n+\tpublic static final int HTTP_PORT = 5002;\n+\n+\t/** The port used to listen for incoming ACME requests. */\n+\tpublic static final int LISTEN_PORT = 4001;\n+\n+\t/** The REST management API port. */\n+\tpublic static final int MANAGEMENT_PORT = 8055;\n+    \n+    public final Network bluenet = Network.builder()\n+            .createNetworkCmdModifier(cmd -> {\n+                cmd.withDriver(\"bridge\");\n+                cmd.withIpam(new com.github.dockerjava.api.model.Network.Ipam()\n+                        .withDriver(\"default\")\n+                        .withConfig(new com.github.dockerjava.api.model.Network.Ipam.Config()\n+                                .withSubnet(\"10.77.77.0/24\")));\n+            })\n+            .build();\n+\n+    public final Network rednet =  Network.builder()\n+            .createNetworkCmdModifier(cmd -> {\n+                cmd.withDriver(\"bridge\");\n+                cmd.withIpam(new com.github.dockerjava.api.model.Network.Ipam()\n+                        .withDriver(\"default\")\n+                        .withConfig(new com.github.dockerjava.api.model.Network.Ipam.Config()\n+                                .withSubnet(\"10.88.88.0/24\")));\n+            })\n+            .build();\n+    \n+    public final GenericContainer<?> bhsm = new GenericContainer<>(IMAGE)\n+            .withEnv(\"PKCS11_DAEMON_SOCKET\", \"tcp://0.0.0.0:5657\")\n+            .withExposedPorts(5657)\n+            .withNetwork(bluenet)\n+            .withNetworkAliases(\"boulder-hsm\")\n+            .withCommand(\"/usr/local/bin/pkcs11-daemon /usr/lib/softhsm/libsofthsm2.so\")\n+            .withLogConsumer(o -> System.out.print(\"[HSM] \" + o.getUtf8String()));\n+    \n+    public final GenericContainer<?> bmysql = new GenericContainer<>(\"mariadb:10.3\")\n+            .withNetwork(bluenet)\n+            .withExposedPorts(3306)\n+            .withNetworkAliases(\"boulder-mysql\")\n+            .withEnv(\"MYSQL_ALLOW_EMPTY_PASSWORD\", \"yes\")\n+            .withCommand(\"mysqld --bind-address=0.0.0.0 --slow-query-log --log-output=TABLE --log-queries-not-using-indexes=ON\")\n+            .withLogConsumer(o -> System.out.print(\"[SQL] \" + o.getUtf8String()));\n+    \n+    private static final String IMAGE = \"ryanesch/acme-boulder:latest\";", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTMwMjc1MQ=="}, "originalCommit": {"oid": "3dd0ccb898e794282f2c55bdc25f1b9f77207045"}, "originalPosition": 73}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ1MDE4ODMwOnYy", "diffSide": "RIGHT", "path": "dev/com.ibm.ws.security.acme_fat/fat/src/com/ibm/ws/security/acme/docker/CAContainer.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOVQyMDozMzo1NFrOF4_aiw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOVQyMDozMzo1NFrOF4_aiw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTMwMzU2Mw==", "bodyText": "Javadoc", "url": "https://github.com/OpenLiberty/open-liberty/pull/11374#discussion_r395303563", "createdAt": "2020-03-19T20:33:54Z", "author": {"login": "jvanhill"}, "path": "dev/com.ibm.ws.security.acme_fat/fat/src/com/ibm/ws/security/acme/docker/CAContainer.java", "diffHunk": "@@ -0,0 +1,372 @@\n+package com.ibm.ws.security.acme.docker;\n+\n+import static junit.framework.Assert.fail;\n+\n+import java.io.IOException;\n+import java.security.cert.X509Certificate;\n+import java.util.Map.Entry;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import org.apache.http.StatusLine;\n+import org.apache.http.client.methods.CloseableHttpResponse;\n+import org.apache.http.client.methods.HttpGet;\n+import org.apache.http.client.methods.HttpPost;\n+import org.apache.http.entity.ContentType;\n+import org.apache.http.entity.StringEntity;\n+import org.apache.http.impl.client.CloseableHttpClient;\n+import org.apache.http.impl.client.HttpClients;\n+import org.apache.http.util.EntityUtils;\n+import org.testcontainers.containers.GenericContainer;\n+import org.testcontainers.images.builder.ImageFromDockerfile;\n+\n+import com.github.dockerjava.api.model.ContainerNetwork;\n+import com.ibm.websphere.simplicity.log.Log;\n+import com.ibm.ws.security.acme.utils.AcmeFatUtils;\n+\n+public class CAContainer extends GenericContainer<BoulderContainer> {\n+\n+\n+\tpublic static final int HTTP_PORT = 5002;\n+\n+\t/** The REST management API port. */\n+\tpublic int MANAGEMENT_PORT = 8055;\n+\t\n+\tpublic CAContainer(String image) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3dd0ccb898e794282f2c55bdc25f1b9f77207045"}, "originalPosition": 35}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ1MDE4ODcwOnYy", "diffSide": "RIGHT", "path": "dev/com.ibm.ws.security.acme_fat/fat/src/com/ibm/ws/security/acme/docker/CAContainer.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOVQyMDozNDowM1rOF4_azQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOVQyMDozNDowM1rOF4_azQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTMwMzYyOQ==", "bodyText": "javadoc", "url": "https://github.com/OpenLiberty/open-liberty/pull/11374#discussion_r395303629", "createdAt": "2020-03-19T20:34:03Z", "author": {"login": "jvanhill"}, "path": "dev/com.ibm.ws.security.acme_fat/fat/src/com/ibm/ws/security/acme/docker/CAContainer.java", "diffHunk": "@@ -0,0 +1,372 @@\n+package com.ibm.ws.security.acme.docker;\n+\n+import static junit.framework.Assert.fail;\n+\n+import java.io.IOException;\n+import java.security.cert.X509Certificate;\n+import java.util.Map.Entry;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import org.apache.http.StatusLine;\n+import org.apache.http.client.methods.CloseableHttpResponse;\n+import org.apache.http.client.methods.HttpGet;\n+import org.apache.http.client.methods.HttpPost;\n+import org.apache.http.entity.ContentType;\n+import org.apache.http.entity.StringEntity;\n+import org.apache.http.impl.client.CloseableHttpClient;\n+import org.apache.http.impl.client.HttpClients;\n+import org.apache.http.util.EntityUtils;\n+import org.testcontainers.containers.GenericContainer;\n+import org.testcontainers.images.builder.ImageFromDockerfile;\n+\n+import com.github.dockerjava.api.model.ContainerNetwork;\n+import com.ibm.websphere.simplicity.log.Log;\n+import com.ibm.ws.security.acme.utils.AcmeFatUtils;\n+\n+public class CAContainer extends GenericContainer<BoulderContainer> {\n+\n+\n+\tpublic static final int HTTP_PORT = 5002;\n+\n+\t/** The REST management API port. */\n+\tpublic int MANAGEMENT_PORT = 8055;\n+\t\n+\tpublic CAContainer(String image) {\n+\t\tsuper(image);\n+\t}\n+\n+\tpublic CAContainer(ImageFromDockerfile image, int managementPort) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3dd0ccb898e794282f2c55bdc25f1b9f77207045"}, "originalPosition": 39}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ1MDE5Mzk3OnYy", "diffSide": "RIGHT", "path": "dev/com.ibm.ws.security.acme_fat/fat/src/com/ibm/ws/security/acme/docker/CAContainer.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOVQyMDozNTo0M1rOF4_eAw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOVQyMDozNTo0M1rOF4_eAw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTMwNDQ1MQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t\t\t\tAcmeFatUtils.logHttpResponse(ChalltestsrvContainer.class, METHOD_NAME, httpPost, response);\n          \n          \n            \n            \t\t\t\tAcmeFatUtils.logHttpResponse(CAContainer.class, METHOD_NAME, httpPost, response);", "url": "https://github.com/OpenLiberty/open-liberty/pull/11374#discussion_r395304451", "createdAt": "2020-03-19T20:35:43Z", "author": {"login": "jvanhill"}, "path": "dev/com.ibm.ws.security.acme_fat/fat/src/com/ibm/ws/security/acme/docker/CAContainer.java", "diffHunk": "@@ -0,0 +1,372 @@\n+package com.ibm.ws.security.acme.docker;\n+\n+import static junit.framework.Assert.fail;\n+\n+import java.io.IOException;\n+import java.security.cert.X509Certificate;\n+import java.util.Map.Entry;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import org.apache.http.StatusLine;\n+import org.apache.http.client.methods.CloseableHttpResponse;\n+import org.apache.http.client.methods.HttpGet;\n+import org.apache.http.client.methods.HttpPost;\n+import org.apache.http.entity.ContentType;\n+import org.apache.http.entity.StringEntity;\n+import org.apache.http.impl.client.CloseableHttpClient;\n+import org.apache.http.impl.client.HttpClients;\n+import org.apache.http.util.EntityUtils;\n+import org.testcontainers.containers.GenericContainer;\n+import org.testcontainers.images.builder.ImageFromDockerfile;\n+\n+import com.github.dockerjava.api.model.ContainerNetwork;\n+import com.ibm.websphere.simplicity.log.Log;\n+import com.ibm.ws.security.acme.utils.AcmeFatUtils;\n+\n+public class CAContainer extends GenericContainer<BoulderContainer> {\n+\n+\n+\tpublic static final int HTTP_PORT = 5002;\n+\n+\t/** The REST management API port. */\n+\tpublic int MANAGEMENT_PORT = 8055;\n+\t\n+\tpublic CAContainer(String image) {\n+\t\tsuper(image);\n+\t}\n+\n+\tpublic CAContainer(ImageFromDockerfile image, int managementPort) {\n+\t\tsuper(image);\n+\t\tMANAGEMENT_PORT = managementPort;\n+\t}\n+\n+\n+\t/**\n+\t * Get Pebble's intermediate certificate.\n+\t * \n+\t * @param fileName\n+\t *            The name of the file to save the certificate to.\n+\t * @return Pebble's root CA certificate in the form of a PEM file.\n+\t * @throws Exception\n+\t *             If we failed to receive the certificate.\n+\t */\n+\tpublic byte[] getAcmeCaIntermediateCertificate() throws Exception {\n+\t\tfinal String METHOD_NAME = \"getAcmeCaIntermediateCertificate()\";\n+\t\tString url = \"https://\" + this.getContainerIpAddress() + \":\" + this.getMappedPort(MANAGEMENT_PORT)\n+\t\t\t\t+ \"/intermediates/0\";\n+\n+\t\ttry (CloseableHttpClient httpclient = AcmeFatUtils.getInsecureHttpsClient()) {\n+\t\t\t/*\n+\t\t\t * Create a GET request to the ACME CA server.\n+\t\t\t */\n+\t\t\tHttpGet httpGet = new HttpGet(url);\n+\n+\t\t\t/*\n+\t\t\t * Send the GET request and process the response.\n+\t\t\t */\n+\t\t\ttry (final CloseableHttpResponse response = httpclient.execute(httpGet)) {\n+\t\t\t\tAcmeFatUtils.logHttpResponse(PebbleContainer.class, METHOD_NAME, httpGet, response);\n+\n+\t\t\t\tStatusLine statusLine = response.getStatusLine();\n+\n+\t\t\t\tif (statusLine.getStatusCode() != 200) {\n+\t\t\t\t\tthrow new IOException(\n+\t\t\t\t\t\t\tMETHOD_NAME + \": Expected response 200, but received response: \" + statusLine);\n+\t\t\t\t}\n+\n+\t\t\t\tbyte[] result = EntityUtils.toByteArray(response.getEntity());\n+\n+\t\t\t\tLog.info(PebbleContainer.class, METHOD_NAME, new String(result));\n+\t\t\t\treturn result;\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Get Pebble's root certificate.\n+\t * \n+\t * @param fileName\n+\t *            The name of the file to save the certificate to.\n+\t * @return Pebble's root CA certificate in the form of a PEM file.\n+\t * @throws Exception\n+\t *             If we failed to receive the certificate.\n+\t */\n+\tpublic byte[] getAcmeCaRootCertificate() throws Exception {\n+\t\tfinal String METHOD_NAME = \"getAcmeCaRootCertificate()\";\n+\t\tString url = \"https://\" + this.getContainerIpAddress() + \":\" + this.getMappedPort(MANAGEMENT_PORT) + \"/roots/0\";\n+\n+\t\ttry (CloseableHttpClient httpclient = AcmeFatUtils.getInsecureHttpsClient()) {\n+\t\t\t/*\n+\t\t\t * Create a GET request to the ACME CA server.\n+\t\t\t */\n+\t\t\tHttpGet httpGet = new HttpGet(url);\n+\n+\t\t\t/*\n+\t\t\t * Send the GET request and process the response.\n+\t\t\t */\n+\t\t\ttry (final CloseableHttpResponse response = httpclient.execute(httpGet)) {\n+\t\t\t\tAcmeFatUtils.logHttpResponse(BoulderContainer.class, METHOD_NAME, httpGet, response);\n+\n+\t\t\t\tStatusLine statusLine = response.getStatusLine();\n+\n+\t\t\t\tif (statusLine.getStatusCode() != 200) {\n+\t\t\t\t\tthrow new IOException(\n+\t\t\t\t\t\t\tMETHOD_NAME + \": Expected response 200, but received response: \" + statusLine);\n+\t\t\t\t}\n+\n+\t\t\t\tbyte[] result = EntityUtils.toByteArray(response.getEntity());\n+\n+\t\t\t\tLog.info(BoulderContainer.class, METHOD_NAME, new String(result));\n+\t\t\t\treturn result;\n+\t\t\t}\n+\t\t}\n+\t}\n+\t\n+\t/**\n+\t * Get the status of the certificate from the ACME CA server.\n+\t * \n+\t * @param certificate\n+\t *            The certificate to check.\n+\t * @return The status of the certificate.\n+\t * @throws Exception\n+\t */\n+\tpublic String getAcmeCertificateStatus(X509Certificate certificate) throws Exception {\n+\t\tfinal String METHOD_NAME = \"getAcmeCertificateStatus()\";\n+\t\tString url = \"https://\" + this.getContainerIpAddress() + \":\" + this.getMappedPort(MANAGEMENT_PORT)\n+\t\t\t\t+ \"/cert-status-by-serial/\" + certificate.getSerialNumber().toString(16);\n+\n+\t\ttry (CloseableHttpClient httpclient = AcmeFatUtils.getInsecureHttpsClient()) {\n+\t\t\t/*\n+\t\t\t * Create a GET request to the ACME CA server.\n+\t\t\t */\n+\t\t\tHttpGet httpGet = new HttpGet(url);\n+\n+\t\t\t/*\n+\t\t\t * Send the GET request and process the response.\n+\t\t\t */\n+\t\t\ttry (final CloseableHttpResponse response = httpclient.execute(httpGet)) {\n+\t\t\t\tAcmeFatUtils.logHttpResponse(BoulderContainer.class, METHOD_NAME, httpGet, response);\n+\n+\t\t\t\tStatusLine statusLine = response.getStatusLine();\n+\n+\t\t\t\tif (statusLine.getStatusCode() != 200) {\n+\t\t\t\t\tthrow new IOException(\n+\t\t\t\t\t\t\tMETHOD_NAME + \": Expected response 200, but received response: \" + statusLine);\n+\t\t\t\t}\n+\n+\t\t\t\tString result = EntityUtils.toString(response.getEntity());\n+\n+\t\t\t\t/*\n+\t\t\t\t * The result is in JSON, lets just parse out the status.\n+\t\t\t\t */\n+\t\t\t\tPattern p = Pattern.compile(\".*\\\"Status\\\": \\\"(\\\\w+)\\\",.*\", Pattern.DOTALL);\n+\t\t\t\tMatcher m = p.matcher(result);\n+\t\t\t\tif (m.find()) {\n+\t\t\t\t\tresult = m.group(1);\n+\t\t\t\t} else {\n+\t\t\t\t\tthrow new Exception(\n+\t\t\t\t\t\t\t\"Certificate status response was not in expected JSON format. Response: \" + result);\n+\t\t\t\t}\n+\n+\t\t\t\tLog.info(BoulderContainer.class, METHOD_NAME, new String(result));\n+\t\t\t\treturn result;\n+\t\t\t}\n+\t\t}\n+\t}\n+\t\n+\tpublic String getClientHost() throws IllegalStateException {\n+\t\tfor (String extraHost : this.getExtraHosts()) {\n+\t\t\tif (extraHost.startsWith(\"host.testcontainers.internal:\")) {\n+\t\t\t\treturn extraHost.replace(\"host.testcontainers.internal:\", \"\");\n+\t\t\t}\n+\t\t}\n+\n+\t\tthrow new IllegalStateException(\n+\t\t\t\t\"Unable to resolve local host from docker container. Could not find 'host.testcontainers.internal' property.\");\n+\t}\n+\t\n+\t/**\n+\t * Add an A record to the mock DNS server. This will allow us to redirect\n+\t * requests to a named domain to the IPv4 address of our choice.\n+\t * \n+\t * @param host\n+\t *            The host / domain to redirect requests for.\n+\t * @param address\n+\t *            The address to direct the requests for that host to.\n+\t * @throws IOException\n+\t */\n+\tpublic void addARecord(String host, String address) throws IOException {\n+\t\tfinal String METHOD_NAME = \"addARecord\";\n+\n+\t\ttry (CloseableHttpClient httpclient = HttpClients.createDefault()) {\n+\n+\t\t\t/*\n+\t\t\t * Generate the JSON request. The request can support multiple\n+\t\t\t * addresses but for the time being we will only support sending\n+\t\t\t * one.\n+\t\t\t */\n+\t\t\tString jsonString = \"{\\\"host\\\":\\\"\" + host + \"\\\",\\\"addresses\\\":[\\\"\" + address + \"\\\"]}\";\n+\t\t\tStringEntity requestEntity = new StringEntity(jsonString, ContentType.APPLICATION_JSON);\n+\n+\t\t\t/*\n+\t\t\t * Create a POST request to the mock DNS server.\n+\t\t\t */\n+\t\t\tHttpPost httpPost = new HttpPost(getManagementAddress() + \"/add-a\");\n+\t\t\thttpPost.setEntity(requestEntity);\n+\n+\t\t\t/*\n+\t\t\t * Send the POST request and process the response.\n+\t\t\t */\n+\t\t\ttry (final CloseableHttpResponse response = httpclient.execute(httpPost)) {\n+\t\t\t\tAcmeFatUtils.logHttpResponse(ChalltestsrvContainer.class, METHOD_NAME, httpPost, response);\n+\n+\t\t\t\tStatusLine statusLine = response.getStatusLine();\n+\t\t\t\tif (statusLine.getStatusCode() != 200) {\n+\t\t\t\t\tthrow new IOException(\n+\t\t\t\t\t\t\tMETHOD_NAME + \": Expected response 200, but received response: \" + statusLine);\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t}\n+\t\n+\t/**\n+\t * Add an AAAA record to the mock DNS server. This will allow us to redirect\n+\t * requests to a named domain to the IPv6 address of our choice.\n+\t * \n+\t * @param host\n+\t *            The host / domain to redirect requests for.\n+\t * @param address\n+\t *            The address to direct the requests for that host to.\n+\t * @throws IOException\n+\t */\n+\tpublic void addAAAARecord(String host, String address) throws IOException {\n+\t\tfinal String METHOD_NAME = \"addAAAARecord\";\n+\n+\t\ttry (CloseableHttpClient httpclient = HttpClients.createDefault()) {\n+\n+\t\t\t/*\n+\t\t\t * Generate the JSON request. The request can support multiple\n+\t\t\t * addresses but for the time being we will only support sending\n+\t\t\t * one.\n+\t\t\t */\n+\t\t\tString jsonString = \"{\\\"host\\\":\\\"\" + host + \"\\\",\\\"addresses\\\":[\\\"\" + address + \"\\\"]}\";\n+\t\t\tStringEntity requestEntity = new StringEntity(jsonString, ContentType.APPLICATION_JSON);\n+\n+\t\t\t/*\n+\t\t\t * Create a POST request to the mock DNS server.\n+\t\t\t */\n+\t\t\tHttpPost httpPost = new HttpPost(getManagementAddress() + \"/add-aaaa\");\n+\t\t\thttpPost.setEntity(requestEntity);\n+\n+\t\t\t/*\n+\t\t\t * Send the POST request and process the response.\n+\t\t\t */\n+\t\t\ttry (final CloseableHttpResponse response = httpclient.execute(httpPost)) {\n+\t\t\t\tAcmeFatUtils.logHttpResponse(ChalltestsrvContainer.class, METHOD_NAME, httpPost, response);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3dd0ccb898e794282f2c55bdc25f1b9f77207045"}, "originalPosition": 266}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ1MDE5NTI0OnYy", "diffSide": "RIGHT", "path": "dev/com.ibm.ws.security.acme_fat/fat/src/com/ibm/ws/security/acme/docker/CAContainer.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOVQyMDozNjowOFrOF4_e5Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOVQyMDozNjowOFrOF4_e5Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTMwNDY3Nw==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t\t\t\tAcmeFatUtils.logHttpResponse(ChalltestsrvContainer.class, METHOD_NAME, httpPost, response);\n          \n          \n            \n            \t\t\t\tAcmeFatUtils.logHttpResponse(CAContainer.class, METHOD_NAME, httpPost, response);", "url": "https://github.com/OpenLiberty/open-liberty/pull/11374#discussion_r395304677", "createdAt": "2020-03-19T20:36:08Z", "author": {"login": "jvanhill"}, "path": "dev/com.ibm.ws.security.acme_fat/fat/src/com/ibm/ws/security/acme/docker/CAContainer.java", "diffHunk": "@@ -0,0 +1,372 @@\n+package com.ibm.ws.security.acme.docker;\n+\n+import static junit.framework.Assert.fail;\n+\n+import java.io.IOException;\n+import java.security.cert.X509Certificate;\n+import java.util.Map.Entry;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import org.apache.http.StatusLine;\n+import org.apache.http.client.methods.CloseableHttpResponse;\n+import org.apache.http.client.methods.HttpGet;\n+import org.apache.http.client.methods.HttpPost;\n+import org.apache.http.entity.ContentType;\n+import org.apache.http.entity.StringEntity;\n+import org.apache.http.impl.client.CloseableHttpClient;\n+import org.apache.http.impl.client.HttpClients;\n+import org.apache.http.util.EntityUtils;\n+import org.testcontainers.containers.GenericContainer;\n+import org.testcontainers.images.builder.ImageFromDockerfile;\n+\n+import com.github.dockerjava.api.model.ContainerNetwork;\n+import com.ibm.websphere.simplicity.log.Log;\n+import com.ibm.ws.security.acme.utils.AcmeFatUtils;\n+\n+public class CAContainer extends GenericContainer<BoulderContainer> {\n+\n+\n+\tpublic static final int HTTP_PORT = 5002;\n+\n+\t/** The REST management API port. */\n+\tpublic int MANAGEMENT_PORT = 8055;\n+\t\n+\tpublic CAContainer(String image) {\n+\t\tsuper(image);\n+\t}\n+\n+\tpublic CAContainer(ImageFromDockerfile image, int managementPort) {\n+\t\tsuper(image);\n+\t\tMANAGEMENT_PORT = managementPort;\n+\t}\n+\n+\n+\t/**\n+\t * Get Pebble's intermediate certificate.\n+\t * \n+\t * @param fileName\n+\t *            The name of the file to save the certificate to.\n+\t * @return Pebble's root CA certificate in the form of a PEM file.\n+\t * @throws Exception\n+\t *             If we failed to receive the certificate.\n+\t */\n+\tpublic byte[] getAcmeCaIntermediateCertificate() throws Exception {\n+\t\tfinal String METHOD_NAME = \"getAcmeCaIntermediateCertificate()\";\n+\t\tString url = \"https://\" + this.getContainerIpAddress() + \":\" + this.getMappedPort(MANAGEMENT_PORT)\n+\t\t\t\t+ \"/intermediates/0\";\n+\n+\t\ttry (CloseableHttpClient httpclient = AcmeFatUtils.getInsecureHttpsClient()) {\n+\t\t\t/*\n+\t\t\t * Create a GET request to the ACME CA server.\n+\t\t\t */\n+\t\t\tHttpGet httpGet = new HttpGet(url);\n+\n+\t\t\t/*\n+\t\t\t * Send the GET request and process the response.\n+\t\t\t */\n+\t\t\ttry (final CloseableHttpResponse response = httpclient.execute(httpGet)) {\n+\t\t\t\tAcmeFatUtils.logHttpResponse(PebbleContainer.class, METHOD_NAME, httpGet, response);\n+\n+\t\t\t\tStatusLine statusLine = response.getStatusLine();\n+\n+\t\t\t\tif (statusLine.getStatusCode() != 200) {\n+\t\t\t\t\tthrow new IOException(\n+\t\t\t\t\t\t\tMETHOD_NAME + \": Expected response 200, but received response: \" + statusLine);\n+\t\t\t\t}\n+\n+\t\t\t\tbyte[] result = EntityUtils.toByteArray(response.getEntity());\n+\n+\t\t\t\tLog.info(PebbleContainer.class, METHOD_NAME, new String(result));\n+\t\t\t\treturn result;\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Get Pebble's root certificate.\n+\t * \n+\t * @param fileName\n+\t *            The name of the file to save the certificate to.\n+\t * @return Pebble's root CA certificate in the form of a PEM file.\n+\t * @throws Exception\n+\t *             If we failed to receive the certificate.\n+\t */\n+\tpublic byte[] getAcmeCaRootCertificate() throws Exception {\n+\t\tfinal String METHOD_NAME = \"getAcmeCaRootCertificate()\";\n+\t\tString url = \"https://\" + this.getContainerIpAddress() + \":\" + this.getMappedPort(MANAGEMENT_PORT) + \"/roots/0\";\n+\n+\t\ttry (CloseableHttpClient httpclient = AcmeFatUtils.getInsecureHttpsClient()) {\n+\t\t\t/*\n+\t\t\t * Create a GET request to the ACME CA server.\n+\t\t\t */\n+\t\t\tHttpGet httpGet = new HttpGet(url);\n+\n+\t\t\t/*\n+\t\t\t * Send the GET request and process the response.\n+\t\t\t */\n+\t\t\ttry (final CloseableHttpResponse response = httpclient.execute(httpGet)) {\n+\t\t\t\tAcmeFatUtils.logHttpResponse(BoulderContainer.class, METHOD_NAME, httpGet, response);\n+\n+\t\t\t\tStatusLine statusLine = response.getStatusLine();\n+\n+\t\t\t\tif (statusLine.getStatusCode() != 200) {\n+\t\t\t\t\tthrow new IOException(\n+\t\t\t\t\t\t\tMETHOD_NAME + \": Expected response 200, but received response: \" + statusLine);\n+\t\t\t\t}\n+\n+\t\t\t\tbyte[] result = EntityUtils.toByteArray(response.getEntity());\n+\n+\t\t\t\tLog.info(BoulderContainer.class, METHOD_NAME, new String(result));\n+\t\t\t\treturn result;\n+\t\t\t}\n+\t\t}\n+\t}\n+\t\n+\t/**\n+\t * Get the status of the certificate from the ACME CA server.\n+\t * \n+\t * @param certificate\n+\t *            The certificate to check.\n+\t * @return The status of the certificate.\n+\t * @throws Exception\n+\t */\n+\tpublic String getAcmeCertificateStatus(X509Certificate certificate) throws Exception {\n+\t\tfinal String METHOD_NAME = \"getAcmeCertificateStatus()\";\n+\t\tString url = \"https://\" + this.getContainerIpAddress() + \":\" + this.getMappedPort(MANAGEMENT_PORT)\n+\t\t\t\t+ \"/cert-status-by-serial/\" + certificate.getSerialNumber().toString(16);\n+\n+\t\ttry (CloseableHttpClient httpclient = AcmeFatUtils.getInsecureHttpsClient()) {\n+\t\t\t/*\n+\t\t\t * Create a GET request to the ACME CA server.\n+\t\t\t */\n+\t\t\tHttpGet httpGet = new HttpGet(url);\n+\n+\t\t\t/*\n+\t\t\t * Send the GET request and process the response.\n+\t\t\t */\n+\t\t\ttry (final CloseableHttpResponse response = httpclient.execute(httpGet)) {\n+\t\t\t\tAcmeFatUtils.logHttpResponse(BoulderContainer.class, METHOD_NAME, httpGet, response);\n+\n+\t\t\t\tStatusLine statusLine = response.getStatusLine();\n+\n+\t\t\t\tif (statusLine.getStatusCode() != 200) {\n+\t\t\t\t\tthrow new IOException(\n+\t\t\t\t\t\t\tMETHOD_NAME + \": Expected response 200, but received response: \" + statusLine);\n+\t\t\t\t}\n+\n+\t\t\t\tString result = EntityUtils.toString(response.getEntity());\n+\n+\t\t\t\t/*\n+\t\t\t\t * The result is in JSON, lets just parse out the status.\n+\t\t\t\t */\n+\t\t\t\tPattern p = Pattern.compile(\".*\\\"Status\\\": \\\"(\\\\w+)\\\",.*\", Pattern.DOTALL);\n+\t\t\t\tMatcher m = p.matcher(result);\n+\t\t\t\tif (m.find()) {\n+\t\t\t\t\tresult = m.group(1);\n+\t\t\t\t} else {\n+\t\t\t\t\tthrow new Exception(\n+\t\t\t\t\t\t\t\"Certificate status response was not in expected JSON format. Response: \" + result);\n+\t\t\t\t}\n+\n+\t\t\t\tLog.info(BoulderContainer.class, METHOD_NAME, new String(result));\n+\t\t\t\treturn result;\n+\t\t\t}\n+\t\t}\n+\t}\n+\t\n+\tpublic String getClientHost() throws IllegalStateException {\n+\t\tfor (String extraHost : this.getExtraHosts()) {\n+\t\t\tif (extraHost.startsWith(\"host.testcontainers.internal:\")) {\n+\t\t\t\treturn extraHost.replace(\"host.testcontainers.internal:\", \"\");\n+\t\t\t}\n+\t\t}\n+\n+\t\tthrow new IllegalStateException(\n+\t\t\t\t\"Unable to resolve local host from docker container. Could not find 'host.testcontainers.internal' property.\");\n+\t}\n+\t\n+\t/**\n+\t * Add an A record to the mock DNS server. This will allow us to redirect\n+\t * requests to a named domain to the IPv4 address of our choice.\n+\t * \n+\t * @param host\n+\t *            The host / domain to redirect requests for.\n+\t * @param address\n+\t *            The address to direct the requests for that host to.\n+\t * @throws IOException\n+\t */\n+\tpublic void addARecord(String host, String address) throws IOException {\n+\t\tfinal String METHOD_NAME = \"addARecord\";\n+\n+\t\ttry (CloseableHttpClient httpclient = HttpClients.createDefault()) {\n+\n+\t\t\t/*\n+\t\t\t * Generate the JSON request. The request can support multiple\n+\t\t\t * addresses but for the time being we will only support sending\n+\t\t\t * one.\n+\t\t\t */\n+\t\t\tString jsonString = \"{\\\"host\\\":\\\"\" + host + \"\\\",\\\"addresses\\\":[\\\"\" + address + \"\\\"]}\";\n+\t\t\tStringEntity requestEntity = new StringEntity(jsonString, ContentType.APPLICATION_JSON);\n+\n+\t\t\t/*\n+\t\t\t * Create a POST request to the mock DNS server.\n+\t\t\t */\n+\t\t\tHttpPost httpPost = new HttpPost(getManagementAddress() + \"/add-a\");\n+\t\t\thttpPost.setEntity(requestEntity);\n+\n+\t\t\t/*\n+\t\t\t * Send the POST request and process the response.\n+\t\t\t */\n+\t\t\ttry (final CloseableHttpResponse response = httpclient.execute(httpPost)) {\n+\t\t\t\tAcmeFatUtils.logHttpResponse(ChalltestsrvContainer.class, METHOD_NAME, httpPost, response);\n+\n+\t\t\t\tStatusLine statusLine = response.getStatusLine();\n+\t\t\t\tif (statusLine.getStatusCode() != 200) {\n+\t\t\t\t\tthrow new IOException(\n+\t\t\t\t\t\t\tMETHOD_NAME + \": Expected response 200, but received response: \" + statusLine);\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t}\n+\t\n+\t/**\n+\t * Add an AAAA record to the mock DNS server. This will allow us to redirect\n+\t * requests to a named domain to the IPv6 address of our choice.\n+\t * \n+\t * @param host\n+\t *            The host / domain to redirect requests for.\n+\t * @param address\n+\t *            The address to direct the requests for that host to.\n+\t * @throws IOException\n+\t */\n+\tpublic void addAAAARecord(String host, String address) throws IOException {\n+\t\tfinal String METHOD_NAME = \"addAAAARecord\";\n+\n+\t\ttry (CloseableHttpClient httpclient = HttpClients.createDefault()) {\n+\n+\t\t\t/*\n+\t\t\t * Generate the JSON request. The request can support multiple\n+\t\t\t * addresses but for the time being we will only support sending\n+\t\t\t * one.\n+\t\t\t */\n+\t\t\tString jsonString = \"{\\\"host\\\":\\\"\" + host + \"\\\",\\\"addresses\\\":[\\\"\" + address + \"\\\"]}\";\n+\t\t\tStringEntity requestEntity = new StringEntity(jsonString, ContentType.APPLICATION_JSON);\n+\n+\t\t\t/*\n+\t\t\t * Create a POST request to the mock DNS server.\n+\t\t\t */\n+\t\t\tHttpPost httpPost = new HttpPost(getManagementAddress() + \"/add-aaaa\");\n+\t\t\thttpPost.setEntity(requestEntity);\n+\n+\t\t\t/*\n+\t\t\t * Send the POST request and process the response.\n+\t\t\t */\n+\t\t\ttry (final CloseableHttpResponse response = httpclient.execute(httpPost)) {\n+\t\t\t\tAcmeFatUtils.logHttpResponse(ChalltestsrvContainer.class, METHOD_NAME, httpPost, response);\n+\n+\t\t\t\tStatusLine statusLine = response.getStatusLine();\n+\t\t\t\tif (statusLine.getStatusCode() != 200) {\n+\t\t\t\t\tthrow new IOException(\n+\t\t\t\t\t\t\tMETHOD_NAME + \": Expected response 200, but received response: \" + statusLine);\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t}\n+\t/**\n+\t * Clear a previously added AAAA record that was added to the mock DNS\n+\t * server.\n+\t * \n+\t * @param host\n+\t *            The host / domain to redirect requests for.\n+\t * @throws IOException\n+\t */\n+\tpublic void clearAAAARecord(String host) throws IOException {\n+\t\tfinal String METHOD_NAME = \"clearAAAARecord(String)\";\n+\n+\t\ttry (CloseableHttpClient httpclient = HttpClients.createDefault()) {\n+\t\t\t/*\n+\t\t\t * Generate the JSON request.\n+\t\t\t */\n+\t\t\tString jsonString = \"{\\\"host\\\":\\\"\" + host + \"\\\"}\";\n+\t\t\tStringEntity requestEntity = new StringEntity(jsonString, ContentType.APPLICATION_JSON);\n+\n+\t\t\t/*\n+\t\t\t * Create a POST request to the mock DNS server.\n+\t\t\t */\n+\t\t\tHttpPost httpPost = new HttpPost(getManagementAddress() + \"/clear-aaaa\");\n+\t\t\thttpPost.setEntity(requestEntity);\n+\n+\t\t\t/*\n+\t\t\t * Send the POST request and process the response.\n+\t\t\t */\n+\t\t\ttry (final CloseableHttpResponse response = httpclient.execute(httpPost)) {\n+\t\t\t\tAcmeFatUtils.logHttpResponse(ChalltestsrvContainer.class, METHOD_NAME, httpPost, response);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3dd0ccb898e794282f2c55bdc25f1b9f77207045"}, "originalPosition": 304}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ1MDIwMjA4OnYy", "diffSide": "RIGHT", "path": "dev/com.ibm.ws.security.acme_fat/fat/src/com/ibm/ws/security/acme/docker/CAContainer.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOVQyMDozODowNVrOF4_jGA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOVQyMDozODowNVrOF4_jGA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTMwNTc1Mg==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t\t\t\tAcmeFatUtils.logHttpResponse(ChalltestsrvContainer.class, METHOD_NAME, httpPost, response);\n          \n          \n            \n            \t\t\t\tAcmeFatUtils.logHttpResponse(CAContainer.class, METHOD_NAME, httpPost, response);", "url": "https://github.com/OpenLiberty/open-liberty/pull/11374#discussion_r395305752", "createdAt": "2020-03-19T20:38:05Z", "author": {"login": "jvanhill"}, "path": "dev/com.ibm.ws.security.acme_fat/fat/src/com/ibm/ws/security/acme/docker/CAContainer.java", "diffHunk": "@@ -0,0 +1,372 @@\n+package com.ibm.ws.security.acme.docker;\n+\n+import static junit.framework.Assert.fail;\n+\n+import java.io.IOException;\n+import java.security.cert.X509Certificate;\n+import java.util.Map.Entry;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import org.apache.http.StatusLine;\n+import org.apache.http.client.methods.CloseableHttpResponse;\n+import org.apache.http.client.methods.HttpGet;\n+import org.apache.http.client.methods.HttpPost;\n+import org.apache.http.entity.ContentType;\n+import org.apache.http.entity.StringEntity;\n+import org.apache.http.impl.client.CloseableHttpClient;\n+import org.apache.http.impl.client.HttpClients;\n+import org.apache.http.util.EntityUtils;\n+import org.testcontainers.containers.GenericContainer;\n+import org.testcontainers.images.builder.ImageFromDockerfile;\n+\n+import com.github.dockerjava.api.model.ContainerNetwork;\n+import com.ibm.websphere.simplicity.log.Log;\n+import com.ibm.ws.security.acme.utils.AcmeFatUtils;\n+\n+public class CAContainer extends GenericContainer<BoulderContainer> {\n+\n+\n+\tpublic static final int HTTP_PORT = 5002;\n+\n+\t/** The REST management API port. */\n+\tpublic int MANAGEMENT_PORT = 8055;\n+\t\n+\tpublic CAContainer(String image) {\n+\t\tsuper(image);\n+\t}\n+\n+\tpublic CAContainer(ImageFromDockerfile image, int managementPort) {\n+\t\tsuper(image);\n+\t\tMANAGEMENT_PORT = managementPort;\n+\t}\n+\n+\n+\t/**\n+\t * Get Pebble's intermediate certificate.\n+\t * \n+\t * @param fileName\n+\t *            The name of the file to save the certificate to.\n+\t * @return Pebble's root CA certificate in the form of a PEM file.\n+\t * @throws Exception\n+\t *             If we failed to receive the certificate.\n+\t */\n+\tpublic byte[] getAcmeCaIntermediateCertificate() throws Exception {\n+\t\tfinal String METHOD_NAME = \"getAcmeCaIntermediateCertificate()\";\n+\t\tString url = \"https://\" + this.getContainerIpAddress() + \":\" + this.getMappedPort(MANAGEMENT_PORT)\n+\t\t\t\t+ \"/intermediates/0\";\n+\n+\t\ttry (CloseableHttpClient httpclient = AcmeFatUtils.getInsecureHttpsClient()) {\n+\t\t\t/*\n+\t\t\t * Create a GET request to the ACME CA server.\n+\t\t\t */\n+\t\t\tHttpGet httpGet = new HttpGet(url);\n+\n+\t\t\t/*\n+\t\t\t * Send the GET request and process the response.\n+\t\t\t */\n+\t\t\ttry (final CloseableHttpResponse response = httpclient.execute(httpGet)) {\n+\t\t\t\tAcmeFatUtils.logHttpResponse(PebbleContainer.class, METHOD_NAME, httpGet, response);\n+\n+\t\t\t\tStatusLine statusLine = response.getStatusLine();\n+\n+\t\t\t\tif (statusLine.getStatusCode() != 200) {\n+\t\t\t\t\tthrow new IOException(\n+\t\t\t\t\t\t\tMETHOD_NAME + \": Expected response 200, but received response: \" + statusLine);\n+\t\t\t\t}\n+\n+\t\t\t\tbyte[] result = EntityUtils.toByteArray(response.getEntity());\n+\n+\t\t\t\tLog.info(PebbleContainer.class, METHOD_NAME, new String(result));\n+\t\t\t\treturn result;\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Get Pebble's root certificate.\n+\t * \n+\t * @param fileName\n+\t *            The name of the file to save the certificate to.\n+\t * @return Pebble's root CA certificate in the form of a PEM file.\n+\t * @throws Exception\n+\t *             If we failed to receive the certificate.\n+\t */\n+\tpublic byte[] getAcmeCaRootCertificate() throws Exception {\n+\t\tfinal String METHOD_NAME = \"getAcmeCaRootCertificate()\";\n+\t\tString url = \"https://\" + this.getContainerIpAddress() + \":\" + this.getMappedPort(MANAGEMENT_PORT) + \"/roots/0\";\n+\n+\t\ttry (CloseableHttpClient httpclient = AcmeFatUtils.getInsecureHttpsClient()) {\n+\t\t\t/*\n+\t\t\t * Create a GET request to the ACME CA server.\n+\t\t\t */\n+\t\t\tHttpGet httpGet = new HttpGet(url);\n+\n+\t\t\t/*\n+\t\t\t * Send the GET request and process the response.\n+\t\t\t */\n+\t\t\ttry (final CloseableHttpResponse response = httpclient.execute(httpGet)) {\n+\t\t\t\tAcmeFatUtils.logHttpResponse(BoulderContainer.class, METHOD_NAME, httpGet, response);\n+\n+\t\t\t\tStatusLine statusLine = response.getStatusLine();\n+\n+\t\t\t\tif (statusLine.getStatusCode() != 200) {\n+\t\t\t\t\tthrow new IOException(\n+\t\t\t\t\t\t\tMETHOD_NAME + \": Expected response 200, but received response: \" + statusLine);\n+\t\t\t\t}\n+\n+\t\t\t\tbyte[] result = EntityUtils.toByteArray(response.getEntity());\n+\n+\t\t\t\tLog.info(BoulderContainer.class, METHOD_NAME, new String(result));\n+\t\t\t\treturn result;\n+\t\t\t}\n+\t\t}\n+\t}\n+\t\n+\t/**\n+\t * Get the status of the certificate from the ACME CA server.\n+\t * \n+\t * @param certificate\n+\t *            The certificate to check.\n+\t * @return The status of the certificate.\n+\t * @throws Exception\n+\t */\n+\tpublic String getAcmeCertificateStatus(X509Certificate certificate) throws Exception {\n+\t\tfinal String METHOD_NAME = \"getAcmeCertificateStatus()\";\n+\t\tString url = \"https://\" + this.getContainerIpAddress() + \":\" + this.getMappedPort(MANAGEMENT_PORT)\n+\t\t\t\t+ \"/cert-status-by-serial/\" + certificate.getSerialNumber().toString(16);\n+\n+\t\ttry (CloseableHttpClient httpclient = AcmeFatUtils.getInsecureHttpsClient()) {\n+\t\t\t/*\n+\t\t\t * Create a GET request to the ACME CA server.\n+\t\t\t */\n+\t\t\tHttpGet httpGet = new HttpGet(url);\n+\n+\t\t\t/*\n+\t\t\t * Send the GET request and process the response.\n+\t\t\t */\n+\t\t\ttry (final CloseableHttpResponse response = httpclient.execute(httpGet)) {\n+\t\t\t\tAcmeFatUtils.logHttpResponse(BoulderContainer.class, METHOD_NAME, httpGet, response);\n+\n+\t\t\t\tStatusLine statusLine = response.getStatusLine();\n+\n+\t\t\t\tif (statusLine.getStatusCode() != 200) {\n+\t\t\t\t\tthrow new IOException(\n+\t\t\t\t\t\t\tMETHOD_NAME + \": Expected response 200, but received response: \" + statusLine);\n+\t\t\t\t}\n+\n+\t\t\t\tString result = EntityUtils.toString(response.getEntity());\n+\n+\t\t\t\t/*\n+\t\t\t\t * The result is in JSON, lets just parse out the status.\n+\t\t\t\t */\n+\t\t\t\tPattern p = Pattern.compile(\".*\\\"Status\\\": \\\"(\\\\w+)\\\",.*\", Pattern.DOTALL);\n+\t\t\t\tMatcher m = p.matcher(result);\n+\t\t\t\tif (m.find()) {\n+\t\t\t\t\tresult = m.group(1);\n+\t\t\t\t} else {\n+\t\t\t\t\tthrow new Exception(\n+\t\t\t\t\t\t\t\"Certificate status response was not in expected JSON format. Response: \" + result);\n+\t\t\t\t}\n+\n+\t\t\t\tLog.info(BoulderContainer.class, METHOD_NAME, new String(result));\n+\t\t\t\treturn result;\n+\t\t\t}\n+\t\t}\n+\t}\n+\t\n+\tpublic String getClientHost() throws IllegalStateException {\n+\t\tfor (String extraHost : this.getExtraHosts()) {\n+\t\t\tif (extraHost.startsWith(\"host.testcontainers.internal:\")) {\n+\t\t\t\treturn extraHost.replace(\"host.testcontainers.internal:\", \"\");\n+\t\t\t}\n+\t\t}\n+\n+\t\tthrow new IllegalStateException(\n+\t\t\t\t\"Unable to resolve local host from docker container. Could not find 'host.testcontainers.internal' property.\");\n+\t}\n+\t\n+\t/**\n+\t * Add an A record to the mock DNS server. This will allow us to redirect\n+\t * requests to a named domain to the IPv4 address of our choice.\n+\t * \n+\t * @param host\n+\t *            The host / domain to redirect requests for.\n+\t * @param address\n+\t *            The address to direct the requests for that host to.\n+\t * @throws IOException\n+\t */\n+\tpublic void addARecord(String host, String address) throws IOException {\n+\t\tfinal String METHOD_NAME = \"addARecord\";\n+\n+\t\ttry (CloseableHttpClient httpclient = HttpClients.createDefault()) {\n+\n+\t\t\t/*\n+\t\t\t * Generate the JSON request. The request can support multiple\n+\t\t\t * addresses but for the time being we will only support sending\n+\t\t\t * one.\n+\t\t\t */\n+\t\t\tString jsonString = \"{\\\"host\\\":\\\"\" + host + \"\\\",\\\"addresses\\\":[\\\"\" + address + \"\\\"]}\";\n+\t\t\tStringEntity requestEntity = new StringEntity(jsonString, ContentType.APPLICATION_JSON);\n+\n+\t\t\t/*\n+\t\t\t * Create a POST request to the mock DNS server.\n+\t\t\t */\n+\t\t\tHttpPost httpPost = new HttpPost(getManagementAddress() + \"/add-a\");\n+\t\t\thttpPost.setEntity(requestEntity);\n+\n+\t\t\t/*\n+\t\t\t * Send the POST request and process the response.\n+\t\t\t */\n+\t\t\ttry (final CloseableHttpResponse response = httpclient.execute(httpPost)) {\n+\t\t\t\tAcmeFatUtils.logHttpResponse(ChalltestsrvContainer.class, METHOD_NAME, httpPost, response);\n+\n+\t\t\t\tStatusLine statusLine = response.getStatusLine();\n+\t\t\t\tif (statusLine.getStatusCode() != 200) {\n+\t\t\t\t\tthrow new IOException(\n+\t\t\t\t\t\t\tMETHOD_NAME + \": Expected response 200, but received response: \" + statusLine);\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t}\n+\t\n+\t/**\n+\t * Add an AAAA record to the mock DNS server. This will allow us to redirect\n+\t * requests to a named domain to the IPv6 address of our choice.\n+\t * \n+\t * @param host\n+\t *            The host / domain to redirect requests for.\n+\t * @param address\n+\t *            The address to direct the requests for that host to.\n+\t * @throws IOException\n+\t */\n+\tpublic void addAAAARecord(String host, String address) throws IOException {\n+\t\tfinal String METHOD_NAME = \"addAAAARecord\";\n+\n+\t\ttry (CloseableHttpClient httpclient = HttpClients.createDefault()) {\n+\n+\t\t\t/*\n+\t\t\t * Generate the JSON request. The request can support multiple\n+\t\t\t * addresses but for the time being we will only support sending\n+\t\t\t * one.\n+\t\t\t */\n+\t\t\tString jsonString = \"{\\\"host\\\":\\\"\" + host + \"\\\",\\\"addresses\\\":[\\\"\" + address + \"\\\"]}\";\n+\t\t\tStringEntity requestEntity = new StringEntity(jsonString, ContentType.APPLICATION_JSON);\n+\n+\t\t\t/*\n+\t\t\t * Create a POST request to the mock DNS server.\n+\t\t\t */\n+\t\t\tHttpPost httpPost = new HttpPost(getManagementAddress() + \"/add-aaaa\");\n+\t\t\thttpPost.setEntity(requestEntity);\n+\n+\t\t\t/*\n+\t\t\t * Send the POST request and process the response.\n+\t\t\t */\n+\t\t\ttry (final CloseableHttpResponse response = httpclient.execute(httpPost)) {\n+\t\t\t\tAcmeFatUtils.logHttpResponse(ChalltestsrvContainer.class, METHOD_NAME, httpPost, response);\n+\n+\t\t\t\tStatusLine statusLine = response.getStatusLine();\n+\t\t\t\tif (statusLine.getStatusCode() != 200) {\n+\t\t\t\t\tthrow new IOException(\n+\t\t\t\t\t\t\tMETHOD_NAME + \": Expected response 200, but received response: \" + statusLine);\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t}\n+\t/**\n+\t * Clear a previously added AAAA record that was added to the mock DNS\n+\t * server.\n+\t * \n+\t * @param host\n+\t *            The host / domain to redirect requests for.\n+\t * @throws IOException\n+\t */\n+\tpublic void clearAAAARecord(String host) throws IOException {\n+\t\tfinal String METHOD_NAME = \"clearAAAARecord(String)\";\n+\n+\t\ttry (CloseableHttpClient httpclient = HttpClients.createDefault()) {\n+\t\t\t/*\n+\t\t\t * Generate the JSON request.\n+\t\t\t */\n+\t\t\tString jsonString = \"{\\\"host\\\":\\\"\" + host + \"\\\"}\";\n+\t\t\tStringEntity requestEntity = new StringEntity(jsonString, ContentType.APPLICATION_JSON);\n+\n+\t\t\t/*\n+\t\t\t * Create a POST request to the mock DNS server.\n+\t\t\t */\n+\t\t\tHttpPost httpPost = new HttpPost(getManagementAddress() + \"/clear-aaaa\");\n+\t\t\thttpPost.setEntity(requestEntity);\n+\n+\t\t\t/*\n+\t\t\t * Send the POST request and process the response.\n+\t\t\t */\n+\t\t\ttry (final CloseableHttpResponse response = httpclient.execute(httpPost)) {\n+\t\t\t\tAcmeFatUtils.logHttpResponse(ChalltestsrvContainer.class, METHOD_NAME, httpPost, response);\n+\n+\t\t\t\tStatusLine statusLine = response.getStatusLine();\n+\t\t\t\tif (statusLine.getStatusCode() != 200) {\n+\t\t\t\t\tthrow new IOException(\n+\t\t\t\t\t\t\tMETHOD_NAME + \": Expected response 200, but received response: \" + statusLine);\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Clear a previously added A record that was added to the mock DNS server.\n+\t * \n+\t * @param host\n+\t *            The host / domain to redirect requests for.\n+\t * @throws IOException\n+\t */\n+\tpublic void clearARecord(String host) throws IOException {\n+\t\tfinal String METHOD_NAME = \"clearMockARecord(String)\";\n+\n+\t\ttry (CloseableHttpClient httpclient = HttpClients.createDefault()) {\n+\t\t\t/*\n+\t\t\t * Generate the JSON request.\n+\t\t\t */\n+\t\t\tString jsonString = \"{\\\"host\\\":\\\"\" + host + \"\\\"}\";\n+\t\t\tStringEntity requestEntity = new StringEntity(jsonString, ContentType.APPLICATION_JSON);\n+\n+\t\t\t/*\n+\t\t\t * Create a POST request to the mock DNS server.\n+\t\t\t */\n+\t\t\tHttpPost httpPost = new HttpPost(getManagementAddress() + \"/clear-a\");\n+\t\t\thttpPost.setEntity(requestEntity);\n+\n+\t\t\t/*\n+\t\t\t * Send the POST request and process the response.\n+\t\t\t */\n+\t\t\ttry (final CloseableHttpResponse response = httpclient.execute(httpPost)) {\n+\t\t\t\tAcmeFatUtils.logHttpResponse(ChalltestsrvContainer.class, METHOD_NAME, httpPost, response);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3dd0ccb898e794282f2c55bdc25f1b9f77207045"}, "originalPosition": 342}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ1MDIwMzU0OnYy", "diffSide": "RIGHT", "path": "dev/com.ibm.ws.security.acme_fat/fat/src/com/ibm/ws/security/acme/docker/CAContainer.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOVQyMDozODozNFrOF4_j_g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOVQyMDozODozNFrOF4_j_g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTMwNTk4Mg==", "bodyText": "Whitespace and javadoc", "url": "https://github.com/OpenLiberty/open-liberty/pull/11374#discussion_r395305982", "createdAt": "2020-03-19T20:38:34Z", "author": {"login": "jvanhill"}, "path": "dev/com.ibm.ws.security.acme_fat/fat/src/com/ibm/ws/security/acme/docker/CAContainer.java", "diffHunk": "@@ -0,0 +1,372 @@\n+package com.ibm.ws.security.acme.docker;\n+\n+import static junit.framework.Assert.fail;\n+\n+import java.io.IOException;\n+import java.security.cert.X509Certificate;\n+import java.util.Map.Entry;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import org.apache.http.StatusLine;\n+import org.apache.http.client.methods.CloseableHttpResponse;\n+import org.apache.http.client.methods.HttpGet;\n+import org.apache.http.client.methods.HttpPost;\n+import org.apache.http.entity.ContentType;\n+import org.apache.http.entity.StringEntity;\n+import org.apache.http.impl.client.CloseableHttpClient;\n+import org.apache.http.impl.client.HttpClients;\n+import org.apache.http.util.EntityUtils;\n+import org.testcontainers.containers.GenericContainer;\n+import org.testcontainers.images.builder.ImageFromDockerfile;\n+\n+import com.github.dockerjava.api.model.ContainerNetwork;\n+import com.ibm.websphere.simplicity.log.Log;\n+import com.ibm.ws.security.acme.utils.AcmeFatUtils;\n+\n+public class CAContainer extends GenericContainer<BoulderContainer> {\n+\n+\n+\tpublic static final int HTTP_PORT = 5002;\n+\n+\t/** The REST management API port. */\n+\tpublic int MANAGEMENT_PORT = 8055;\n+\t\n+\tpublic CAContainer(String image) {\n+\t\tsuper(image);\n+\t}\n+\n+\tpublic CAContainer(ImageFromDockerfile image, int managementPort) {\n+\t\tsuper(image);\n+\t\tMANAGEMENT_PORT = managementPort;\n+\t}\n+\n+\n+\t/**\n+\t * Get Pebble's intermediate certificate.\n+\t * \n+\t * @param fileName\n+\t *            The name of the file to save the certificate to.\n+\t * @return Pebble's root CA certificate in the form of a PEM file.\n+\t * @throws Exception\n+\t *             If we failed to receive the certificate.\n+\t */\n+\tpublic byte[] getAcmeCaIntermediateCertificate() throws Exception {\n+\t\tfinal String METHOD_NAME = \"getAcmeCaIntermediateCertificate()\";\n+\t\tString url = \"https://\" + this.getContainerIpAddress() + \":\" + this.getMappedPort(MANAGEMENT_PORT)\n+\t\t\t\t+ \"/intermediates/0\";\n+\n+\t\ttry (CloseableHttpClient httpclient = AcmeFatUtils.getInsecureHttpsClient()) {\n+\t\t\t/*\n+\t\t\t * Create a GET request to the ACME CA server.\n+\t\t\t */\n+\t\t\tHttpGet httpGet = new HttpGet(url);\n+\n+\t\t\t/*\n+\t\t\t * Send the GET request and process the response.\n+\t\t\t */\n+\t\t\ttry (final CloseableHttpResponse response = httpclient.execute(httpGet)) {\n+\t\t\t\tAcmeFatUtils.logHttpResponse(PebbleContainer.class, METHOD_NAME, httpGet, response);\n+\n+\t\t\t\tStatusLine statusLine = response.getStatusLine();\n+\n+\t\t\t\tif (statusLine.getStatusCode() != 200) {\n+\t\t\t\t\tthrow new IOException(\n+\t\t\t\t\t\t\tMETHOD_NAME + \": Expected response 200, but received response: \" + statusLine);\n+\t\t\t\t}\n+\n+\t\t\t\tbyte[] result = EntityUtils.toByteArray(response.getEntity());\n+\n+\t\t\t\tLog.info(PebbleContainer.class, METHOD_NAME, new String(result));\n+\t\t\t\treturn result;\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Get Pebble's root certificate.\n+\t * \n+\t * @param fileName\n+\t *            The name of the file to save the certificate to.\n+\t * @return Pebble's root CA certificate in the form of a PEM file.\n+\t * @throws Exception\n+\t *             If we failed to receive the certificate.\n+\t */\n+\tpublic byte[] getAcmeCaRootCertificate() throws Exception {\n+\t\tfinal String METHOD_NAME = \"getAcmeCaRootCertificate()\";\n+\t\tString url = \"https://\" + this.getContainerIpAddress() + \":\" + this.getMappedPort(MANAGEMENT_PORT) + \"/roots/0\";\n+\n+\t\ttry (CloseableHttpClient httpclient = AcmeFatUtils.getInsecureHttpsClient()) {\n+\t\t\t/*\n+\t\t\t * Create a GET request to the ACME CA server.\n+\t\t\t */\n+\t\t\tHttpGet httpGet = new HttpGet(url);\n+\n+\t\t\t/*\n+\t\t\t * Send the GET request and process the response.\n+\t\t\t */\n+\t\t\ttry (final CloseableHttpResponse response = httpclient.execute(httpGet)) {\n+\t\t\t\tAcmeFatUtils.logHttpResponse(BoulderContainer.class, METHOD_NAME, httpGet, response);\n+\n+\t\t\t\tStatusLine statusLine = response.getStatusLine();\n+\n+\t\t\t\tif (statusLine.getStatusCode() != 200) {\n+\t\t\t\t\tthrow new IOException(\n+\t\t\t\t\t\t\tMETHOD_NAME + \": Expected response 200, but received response: \" + statusLine);\n+\t\t\t\t}\n+\n+\t\t\t\tbyte[] result = EntityUtils.toByteArray(response.getEntity());\n+\n+\t\t\t\tLog.info(BoulderContainer.class, METHOD_NAME, new String(result));\n+\t\t\t\treturn result;\n+\t\t\t}\n+\t\t}\n+\t}\n+\t\n+\t/**\n+\t * Get the status of the certificate from the ACME CA server.\n+\t * \n+\t * @param certificate\n+\t *            The certificate to check.\n+\t * @return The status of the certificate.\n+\t * @throws Exception\n+\t */\n+\tpublic String getAcmeCertificateStatus(X509Certificate certificate) throws Exception {\n+\t\tfinal String METHOD_NAME = \"getAcmeCertificateStatus()\";\n+\t\tString url = \"https://\" + this.getContainerIpAddress() + \":\" + this.getMappedPort(MANAGEMENT_PORT)\n+\t\t\t\t+ \"/cert-status-by-serial/\" + certificate.getSerialNumber().toString(16);\n+\n+\t\ttry (CloseableHttpClient httpclient = AcmeFatUtils.getInsecureHttpsClient()) {\n+\t\t\t/*\n+\t\t\t * Create a GET request to the ACME CA server.\n+\t\t\t */\n+\t\t\tHttpGet httpGet = new HttpGet(url);\n+\n+\t\t\t/*\n+\t\t\t * Send the GET request and process the response.\n+\t\t\t */\n+\t\t\ttry (final CloseableHttpResponse response = httpclient.execute(httpGet)) {\n+\t\t\t\tAcmeFatUtils.logHttpResponse(BoulderContainer.class, METHOD_NAME, httpGet, response);\n+\n+\t\t\t\tStatusLine statusLine = response.getStatusLine();\n+\n+\t\t\t\tif (statusLine.getStatusCode() != 200) {\n+\t\t\t\t\tthrow new IOException(\n+\t\t\t\t\t\t\tMETHOD_NAME + \": Expected response 200, but received response: \" + statusLine);\n+\t\t\t\t}\n+\n+\t\t\t\tString result = EntityUtils.toString(response.getEntity());\n+\n+\t\t\t\t/*\n+\t\t\t\t * The result is in JSON, lets just parse out the status.\n+\t\t\t\t */\n+\t\t\t\tPattern p = Pattern.compile(\".*\\\"Status\\\": \\\"(\\\\w+)\\\",.*\", Pattern.DOTALL);\n+\t\t\t\tMatcher m = p.matcher(result);\n+\t\t\t\tif (m.find()) {\n+\t\t\t\t\tresult = m.group(1);\n+\t\t\t\t} else {\n+\t\t\t\t\tthrow new Exception(\n+\t\t\t\t\t\t\t\"Certificate status response was not in expected JSON format. Response: \" + result);\n+\t\t\t\t}\n+\n+\t\t\t\tLog.info(BoulderContainer.class, METHOD_NAME, new String(result));\n+\t\t\t\treturn result;\n+\t\t\t}\n+\t\t}\n+\t}\n+\t\n+\tpublic String getClientHost() throws IllegalStateException {\n+\t\tfor (String extraHost : this.getExtraHosts()) {\n+\t\t\tif (extraHost.startsWith(\"host.testcontainers.internal:\")) {\n+\t\t\t\treturn extraHost.replace(\"host.testcontainers.internal:\", \"\");\n+\t\t\t}\n+\t\t}\n+\n+\t\tthrow new IllegalStateException(\n+\t\t\t\t\"Unable to resolve local host from docker container. Could not find 'host.testcontainers.internal' property.\");\n+\t}\n+\t\n+\t/**\n+\t * Add an A record to the mock DNS server. This will allow us to redirect\n+\t * requests to a named domain to the IPv4 address of our choice.\n+\t * \n+\t * @param host\n+\t *            The host / domain to redirect requests for.\n+\t * @param address\n+\t *            The address to direct the requests for that host to.\n+\t * @throws IOException\n+\t */\n+\tpublic void addARecord(String host, String address) throws IOException {\n+\t\tfinal String METHOD_NAME = \"addARecord\";\n+\n+\t\ttry (CloseableHttpClient httpclient = HttpClients.createDefault()) {\n+\n+\t\t\t/*\n+\t\t\t * Generate the JSON request. The request can support multiple\n+\t\t\t * addresses but for the time being we will only support sending\n+\t\t\t * one.\n+\t\t\t */\n+\t\t\tString jsonString = \"{\\\"host\\\":\\\"\" + host + \"\\\",\\\"addresses\\\":[\\\"\" + address + \"\\\"]}\";\n+\t\t\tStringEntity requestEntity = new StringEntity(jsonString, ContentType.APPLICATION_JSON);\n+\n+\t\t\t/*\n+\t\t\t * Create a POST request to the mock DNS server.\n+\t\t\t */\n+\t\t\tHttpPost httpPost = new HttpPost(getManagementAddress() + \"/add-a\");\n+\t\t\thttpPost.setEntity(requestEntity);\n+\n+\t\t\t/*\n+\t\t\t * Send the POST request and process the response.\n+\t\t\t */\n+\t\t\ttry (final CloseableHttpResponse response = httpclient.execute(httpPost)) {\n+\t\t\t\tAcmeFatUtils.logHttpResponse(ChalltestsrvContainer.class, METHOD_NAME, httpPost, response);\n+\n+\t\t\t\tStatusLine statusLine = response.getStatusLine();\n+\t\t\t\tif (statusLine.getStatusCode() != 200) {\n+\t\t\t\t\tthrow new IOException(\n+\t\t\t\t\t\t\tMETHOD_NAME + \": Expected response 200, but received response: \" + statusLine);\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t}\n+\t\n+\t/**\n+\t * Add an AAAA record to the mock DNS server. This will allow us to redirect\n+\t * requests to a named domain to the IPv6 address of our choice.\n+\t * \n+\t * @param host\n+\t *            The host / domain to redirect requests for.\n+\t * @param address\n+\t *            The address to direct the requests for that host to.\n+\t * @throws IOException\n+\t */\n+\tpublic void addAAAARecord(String host, String address) throws IOException {\n+\t\tfinal String METHOD_NAME = \"addAAAARecord\";\n+\n+\t\ttry (CloseableHttpClient httpclient = HttpClients.createDefault()) {\n+\n+\t\t\t/*\n+\t\t\t * Generate the JSON request. The request can support multiple\n+\t\t\t * addresses but for the time being we will only support sending\n+\t\t\t * one.\n+\t\t\t */\n+\t\t\tString jsonString = \"{\\\"host\\\":\\\"\" + host + \"\\\",\\\"addresses\\\":[\\\"\" + address + \"\\\"]}\";\n+\t\t\tStringEntity requestEntity = new StringEntity(jsonString, ContentType.APPLICATION_JSON);\n+\n+\t\t\t/*\n+\t\t\t * Create a POST request to the mock DNS server.\n+\t\t\t */\n+\t\t\tHttpPost httpPost = new HttpPost(getManagementAddress() + \"/add-aaaa\");\n+\t\t\thttpPost.setEntity(requestEntity);\n+\n+\t\t\t/*\n+\t\t\t * Send the POST request and process the response.\n+\t\t\t */\n+\t\t\ttry (final CloseableHttpResponse response = httpclient.execute(httpPost)) {\n+\t\t\t\tAcmeFatUtils.logHttpResponse(ChalltestsrvContainer.class, METHOD_NAME, httpPost, response);\n+\n+\t\t\t\tStatusLine statusLine = response.getStatusLine();\n+\t\t\t\tif (statusLine.getStatusCode() != 200) {\n+\t\t\t\t\tthrow new IOException(\n+\t\t\t\t\t\t\tMETHOD_NAME + \": Expected response 200, but received response: \" + statusLine);\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t}\n+\t/**\n+\t * Clear a previously added AAAA record that was added to the mock DNS\n+\t * server.\n+\t * \n+\t * @param host\n+\t *            The host / domain to redirect requests for.\n+\t * @throws IOException\n+\t */\n+\tpublic void clearAAAARecord(String host) throws IOException {\n+\t\tfinal String METHOD_NAME = \"clearAAAARecord(String)\";\n+\n+\t\ttry (CloseableHttpClient httpclient = HttpClients.createDefault()) {\n+\t\t\t/*\n+\t\t\t * Generate the JSON request.\n+\t\t\t */\n+\t\t\tString jsonString = \"{\\\"host\\\":\\\"\" + host + \"\\\"}\";\n+\t\t\tStringEntity requestEntity = new StringEntity(jsonString, ContentType.APPLICATION_JSON);\n+\n+\t\t\t/*\n+\t\t\t * Create a POST request to the mock DNS server.\n+\t\t\t */\n+\t\t\tHttpPost httpPost = new HttpPost(getManagementAddress() + \"/clear-aaaa\");\n+\t\t\thttpPost.setEntity(requestEntity);\n+\n+\t\t\t/*\n+\t\t\t * Send the POST request and process the response.\n+\t\t\t */\n+\t\t\ttry (final CloseableHttpResponse response = httpclient.execute(httpPost)) {\n+\t\t\t\tAcmeFatUtils.logHttpResponse(ChalltestsrvContainer.class, METHOD_NAME, httpPost, response);\n+\n+\t\t\t\tStatusLine statusLine = response.getStatusLine();\n+\t\t\t\tif (statusLine.getStatusCode() != 200) {\n+\t\t\t\t\tthrow new IOException(\n+\t\t\t\t\t\t\tMETHOD_NAME + \": Expected response 200, but received response: \" + statusLine);\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Clear a previously added A record that was added to the mock DNS server.\n+\t * \n+\t * @param host\n+\t *            The host / domain to redirect requests for.\n+\t * @throws IOException\n+\t */\n+\tpublic void clearARecord(String host) throws IOException {\n+\t\tfinal String METHOD_NAME = \"clearMockARecord(String)\";\n+\n+\t\ttry (CloseableHttpClient httpclient = HttpClients.createDefault()) {\n+\t\t\t/*\n+\t\t\t * Generate the JSON request.\n+\t\t\t */\n+\t\t\tString jsonString = \"{\\\"host\\\":\\\"\" + host + \"\\\"}\";\n+\t\t\tStringEntity requestEntity = new StringEntity(jsonString, ContentType.APPLICATION_JSON);\n+\n+\t\t\t/*\n+\t\t\t * Create a POST request to the mock DNS server.\n+\t\t\t */\n+\t\t\tHttpPost httpPost = new HttpPost(getManagementAddress() + \"/clear-a\");\n+\t\t\thttpPost.setEntity(requestEntity);\n+\n+\t\t\t/*\n+\t\t\t * Send the POST request and process the response.\n+\t\t\t */\n+\t\t\ttry (final CloseableHttpResponse response = httpclient.execute(httpPost)) {\n+\t\t\t\tAcmeFatUtils.logHttpResponse(ChalltestsrvContainer.class, METHOD_NAME, httpPost, response);\n+\n+\t\t\t\tStatusLine statusLine = response.getStatusLine();\n+\t\t\t\tif (statusLine.getStatusCode() != 200) {\n+\t\t\t\t\tthrow new IOException(\n+\t\t\t\t\t\t\tMETHOD_NAME + \": Expected response 200, but received response: \" + statusLine);\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t}\n+\tpublic String getManagementAddress() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3dd0ccb898e794282f2c55bdc25f1b9f77207045"}, "originalPosition": 352}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ1MDIwNDEwOnYy", "diffSide": "RIGHT", "path": "dev/com.ibm.ws.security.acme_fat/fat/src/com/ibm/ws/security/acme/docker/CAContainer.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOVQyMDozODo0NVrOF4_kWQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOVQyMDozODo0NVrOF4_kWQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTMwNjA3Mw==", "bodyText": "javadoc", "url": "https://github.com/OpenLiberty/open-liberty/pull/11374#discussion_r395306073", "createdAt": "2020-03-19T20:38:45Z", "author": {"login": "jvanhill"}, "path": "dev/com.ibm.ws.security.acme_fat/fat/src/com/ibm/ws/security/acme/docker/CAContainer.java", "diffHunk": "@@ -0,0 +1,372 @@\n+package com.ibm.ws.security.acme.docker;\n+\n+import static junit.framework.Assert.fail;\n+\n+import java.io.IOException;\n+import java.security.cert.X509Certificate;\n+import java.util.Map.Entry;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import org.apache.http.StatusLine;\n+import org.apache.http.client.methods.CloseableHttpResponse;\n+import org.apache.http.client.methods.HttpGet;\n+import org.apache.http.client.methods.HttpPost;\n+import org.apache.http.entity.ContentType;\n+import org.apache.http.entity.StringEntity;\n+import org.apache.http.impl.client.CloseableHttpClient;\n+import org.apache.http.impl.client.HttpClients;\n+import org.apache.http.util.EntityUtils;\n+import org.testcontainers.containers.GenericContainer;\n+import org.testcontainers.images.builder.ImageFromDockerfile;\n+\n+import com.github.dockerjava.api.model.ContainerNetwork;\n+import com.ibm.websphere.simplicity.log.Log;\n+import com.ibm.ws.security.acme.utils.AcmeFatUtils;\n+\n+public class CAContainer extends GenericContainer<BoulderContainer> {\n+\n+\n+\tpublic static final int HTTP_PORT = 5002;\n+\n+\t/** The REST management API port. */\n+\tpublic int MANAGEMENT_PORT = 8055;\n+\t\n+\tpublic CAContainer(String image) {\n+\t\tsuper(image);\n+\t}\n+\n+\tpublic CAContainer(ImageFromDockerfile image, int managementPort) {\n+\t\tsuper(image);\n+\t\tMANAGEMENT_PORT = managementPort;\n+\t}\n+\n+\n+\t/**\n+\t * Get Pebble's intermediate certificate.\n+\t * \n+\t * @param fileName\n+\t *            The name of the file to save the certificate to.\n+\t * @return Pebble's root CA certificate in the form of a PEM file.\n+\t * @throws Exception\n+\t *             If we failed to receive the certificate.\n+\t */\n+\tpublic byte[] getAcmeCaIntermediateCertificate() throws Exception {\n+\t\tfinal String METHOD_NAME = \"getAcmeCaIntermediateCertificate()\";\n+\t\tString url = \"https://\" + this.getContainerIpAddress() + \":\" + this.getMappedPort(MANAGEMENT_PORT)\n+\t\t\t\t+ \"/intermediates/0\";\n+\n+\t\ttry (CloseableHttpClient httpclient = AcmeFatUtils.getInsecureHttpsClient()) {\n+\t\t\t/*\n+\t\t\t * Create a GET request to the ACME CA server.\n+\t\t\t */\n+\t\t\tHttpGet httpGet = new HttpGet(url);\n+\n+\t\t\t/*\n+\t\t\t * Send the GET request and process the response.\n+\t\t\t */\n+\t\t\ttry (final CloseableHttpResponse response = httpclient.execute(httpGet)) {\n+\t\t\t\tAcmeFatUtils.logHttpResponse(PebbleContainer.class, METHOD_NAME, httpGet, response);\n+\n+\t\t\t\tStatusLine statusLine = response.getStatusLine();\n+\n+\t\t\t\tif (statusLine.getStatusCode() != 200) {\n+\t\t\t\t\tthrow new IOException(\n+\t\t\t\t\t\t\tMETHOD_NAME + \": Expected response 200, but received response: \" + statusLine);\n+\t\t\t\t}\n+\n+\t\t\t\tbyte[] result = EntityUtils.toByteArray(response.getEntity());\n+\n+\t\t\t\tLog.info(PebbleContainer.class, METHOD_NAME, new String(result));\n+\t\t\t\treturn result;\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Get Pebble's root certificate.\n+\t * \n+\t * @param fileName\n+\t *            The name of the file to save the certificate to.\n+\t * @return Pebble's root CA certificate in the form of a PEM file.\n+\t * @throws Exception\n+\t *             If we failed to receive the certificate.\n+\t */\n+\tpublic byte[] getAcmeCaRootCertificate() throws Exception {\n+\t\tfinal String METHOD_NAME = \"getAcmeCaRootCertificate()\";\n+\t\tString url = \"https://\" + this.getContainerIpAddress() + \":\" + this.getMappedPort(MANAGEMENT_PORT) + \"/roots/0\";\n+\n+\t\ttry (CloseableHttpClient httpclient = AcmeFatUtils.getInsecureHttpsClient()) {\n+\t\t\t/*\n+\t\t\t * Create a GET request to the ACME CA server.\n+\t\t\t */\n+\t\t\tHttpGet httpGet = new HttpGet(url);\n+\n+\t\t\t/*\n+\t\t\t * Send the GET request and process the response.\n+\t\t\t */\n+\t\t\ttry (final CloseableHttpResponse response = httpclient.execute(httpGet)) {\n+\t\t\t\tAcmeFatUtils.logHttpResponse(BoulderContainer.class, METHOD_NAME, httpGet, response);\n+\n+\t\t\t\tStatusLine statusLine = response.getStatusLine();\n+\n+\t\t\t\tif (statusLine.getStatusCode() != 200) {\n+\t\t\t\t\tthrow new IOException(\n+\t\t\t\t\t\t\tMETHOD_NAME + \": Expected response 200, but received response: \" + statusLine);\n+\t\t\t\t}\n+\n+\t\t\t\tbyte[] result = EntityUtils.toByteArray(response.getEntity());\n+\n+\t\t\t\tLog.info(BoulderContainer.class, METHOD_NAME, new String(result));\n+\t\t\t\treturn result;\n+\t\t\t}\n+\t\t}\n+\t}\n+\t\n+\t/**\n+\t * Get the status of the certificate from the ACME CA server.\n+\t * \n+\t * @param certificate\n+\t *            The certificate to check.\n+\t * @return The status of the certificate.\n+\t * @throws Exception\n+\t */\n+\tpublic String getAcmeCertificateStatus(X509Certificate certificate) throws Exception {\n+\t\tfinal String METHOD_NAME = \"getAcmeCertificateStatus()\";\n+\t\tString url = \"https://\" + this.getContainerIpAddress() + \":\" + this.getMappedPort(MANAGEMENT_PORT)\n+\t\t\t\t+ \"/cert-status-by-serial/\" + certificate.getSerialNumber().toString(16);\n+\n+\t\ttry (CloseableHttpClient httpclient = AcmeFatUtils.getInsecureHttpsClient()) {\n+\t\t\t/*\n+\t\t\t * Create a GET request to the ACME CA server.\n+\t\t\t */\n+\t\t\tHttpGet httpGet = new HttpGet(url);\n+\n+\t\t\t/*\n+\t\t\t * Send the GET request and process the response.\n+\t\t\t */\n+\t\t\ttry (final CloseableHttpResponse response = httpclient.execute(httpGet)) {\n+\t\t\t\tAcmeFatUtils.logHttpResponse(BoulderContainer.class, METHOD_NAME, httpGet, response);\n+\n+\t\t\t\tStatusLine statusLine = response.getStatusLine();\n+\n+\t\t\t\tif (statusLine.getStatusCode() != 200) {\n+\t\t\t\t\tthrow new IOException(\n+\t\t\t\t\t\t\tMETHOD_NAME + \": Expected response 200, but received response: \" + statusLine);\n+\t\t\t\t}\n+\n+\t\t\t\tString result = EntityUtils.toString(response.getEntity());\n+\n+\t\t\t\t/*\n+\t\t\t\t * The result is in JSON, lets just parse out the status.\n+\t\t\t\t */\n+\t\t\t\tPattern p = Pattern.compile(\".*\\\"Status\\\": \\\"(\\\\w+)\\\",.*\", Pattern.DOTALL);\n+\t\t\t\tMatcher m = p.matcher(result);\n+\t\t\t\tif (m.find()) {\n+\t\t\t\t\tresult = m.group(1);\n+\t\t\t\t} else {\n+\t\t\t\t\tthrow new Exception(\n+\t\t\t\t\t\t\t\"Certificate status response was not in expected JSON format. Response: \" + result);\n+\t\t\t\t}\n+\n+\t\t\t\tLog.info(BoulderContainer.class, METHOD_NAME, new String(result));\n+\t\t\t\treturn result;\n+\t\t\t}\n+\t\t}\n+\t}\n+\t\n+\tpublic String getClientHost() throws IllegalStateException {\n+\t\tfor (String extraHost : this.getExtraHosts()) {\n+\t\t\tif (extraHost.startsWith(\"host.testcontainers.internal:\")) {\n+\t\t\t\treturn extraHost.replace(\"host.testcontainers.internal:\", \"\");\n+\t\t\t}\n+\t\t}\n+\n+\t\tthrow new IllegalStateException(\n+\t\t\t\t\"Unable to resolve local host from docker container. Could not find 'host.testcontainers.internal' property.\");\n+\t}\n+\t\n+\t/**\n+\t * Add an A record to the mock DNS server. This will allow us to redirect\n+\t * requests to a named domain to the IPv4 address of our choice.\n+\t * \n+\t * @param host\n+\t *            The host / domain to redirect requests for.\n+\t * @param address\n+\t *            The address to direct the requests for that host to.\n+\t * @throws IOException\n+\t */\n+\tpublic void addARecord(String host, String address) throws IOException {\n+\t\tfinal String METHOD_NAME = \"addARecord\";\n+\n+\t\ttry (CloseableHttpClient httpclient = HttpClients.createDefault()) {\n+\n+\t\t\t/*\n+\t\t\t * Generate the JSON request. The request can support multiple\n+\t\t\t * addresses but for the time being we will only support sending\n+\t\t\t * one.\n+\t\t\t */\n+\t\t\tString jsonString = \"{\\\"host\\\":\\\"\" + host + \"\\\",\\\"addresses\\\":[\\\"\" + address + \"\\\"]}\";\n+\t\t\tStringEntity requestEntity = new StringEntity(jsonString, ContentType.APPLICATION_JSON);\n+\n+\t\t\t/*\n+\t\t\t * Create a POST request to the mock DNS server.\n+\t\t\t */\n+\t\t\tHttpPost httpPost = new HttpPost(getManagementAddress() + \"/add-a\");\n+\t\t\thttpPost.setEntity(requestEntity);\n+\n+\t\t\t/*\n+\t\t\t * Send the POST request and process the response.\n+\t\t\t */\n+\t\t\ttry (final CloseableHttpResponse response = httpclient.execute(httpPost)) {\n+\t\t\t\tAcmeFatUtils.logHttpResponse(ChalltestsrvContainer.class, METHOD_NAME, httpPost, response);\n+\n+\t\t\t\tStatusLine statusLine = response.getStatusLine();\n+\t\t\t\tif (statusLine.getStatusCode() != 200) {\n+\t\t\t\t\tthrow new IOException(\n+\t\t\t\t\t\t\tMETHOD_NAME + \": Expected response 200, but received response: \" + statusLine);\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t}\n+\t\n+\t/**\n+\t * Add an AAAA record to the mock DNS server. This will allow us to redirect\n+\t * requests to a named domain to the IPv6 address of our choice.\n+\t * \n+\t * @param host\n+\t *            The host / domain to redirect requests for.\n+\t * @param address\n+\t *            The address to direct the requests for that host to.\n+\t * @throws IOException\n+\t */\n+\tpublic void addAAAARecord(String host, String address) throws IOException {\n+\t\tfinal String METHOD_NAME = \"addAAAARecord\";\n+\n+\t\ttry (CloseableHttpClient httpclient = HttpClients.createDefault()) {\n+\n+\t\t\t/*\n+\t\t\t * Generate the JSON request. The request can support multiple\n+\t\t\t * addresses but for the time being we will only support sending\n+\t\t\t * one.\n+\t\t\t */\n+\t\t\tString jsonString = \"{\\\"host\\\":\\\"\" + host + \"\\\",\\\"addresses\\\":[\\\"\" + address + \"\\\"]}\";\n+\t\t\tStringEntity requestEntity = new StringEntity(jsonString, ContentType.APPLICATION_JSON);\n+\n+\t\t\t/*\n+\t\t\t * Create a POST request to the mock DNS server.\n+\t\t\t */\n+\t\t\tHttpPost httpPost = new HttpPost(getManagementAddress() + \"/add-aaaa\");\n+\t\t\thttpPost.setEntity(requestEntity);\n+\n+\t\t\t/*\n+\t\t\t * Send the POST request and process the response.\n+\t\t\t */\n+\t\t\ttry (final CloseableHttpResponse response = httpclient.execute(httpPost)) {\n+\t\t\t\tAcmeFatUtils.logHttpResponse(ChalltestsrvContainer.class, METHOD_NAME, httpPost, response);\n+\n+\t\t\t\tStatusLine statusLine = response.getStatusLine();\n+\t\t\t\tif (statusLine.getStatusCode() != 200) {\n+\t\t\t\t\tthrow new IOException(\n+\t\t\t\t\t\t\tMETHOD_NAME + \": Expected response 200, but received response: \" + statusLine);\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t}\n+\t/**\n+\t * Clear a previously added AAAA record that was added to the mock DNS\n+\t * server.\n+\t * \n+\t * @param host\n+\t *            The host / domain to redirect requests for.\n+\t * @throws IOException\n+\t */\n+\tpublic void clearAAAARecord(String host) throws IOException {\n+\t\tfinal String METHOD_NAME = \"clearAAAARecord(String)\";\n+\n+\t\ttry (CloseableHttpClient httpclient = HttpClients.createDefault()) {\n+\t\t\t/*\n+\t\t\t * Generate the JSON request.\n+\t\t\t */\n+\t\t\tString jsonString = \"{\\\"host\\\":\\\"\" + host + \"\\\"}\";\n+\t\t\tStringEntity requestEntity = new StringEntity(jsonString, ContentType.APPLICATION_JSON);\n+\n+\t\t\t/*\n+\t\t\t * Create a POST request to the mock DNS server.\n+\t\t\t */\n+\t\t\tHttpPost httpPost = new HttpPost(getManagementAddress() + \"/clear-aaaa\");\n+\t\t\thttpPost.setEntity(requestEntity);\n+\n+\t\t\t/*\n+\t\t\t * Send the POST request and process the response.\n+\t\t\t */\n+\t\t\ttry (final CloseableHttpResponse response = httpclient.execute(httpPost)) {\n+\t\t\t\tAcmeFatUtils.logHttpResponse(ChalltestsrvContainer.class, METHOD_NAME, httpPost, response);\n+\n+\t\t\t\tStatusLine statusLine = response.getStatusLine();\n+\t\t\t\tif (statusLine.getStatusCode() != 200) {\n+\t\t\t\t\tthrow new IOException(\n+\t\t\t\t\t\t\tMETHOD_NAME + \": Expected response 200, but received response: \" + statusLine);\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Clear a previously added A record that was added to the mock DNS server.\n+\t * \n+\t * @param host\n+\t *            The host / domain to redirect requests for.\n+\t * @throws IOException\n+\t */\n+\tpublic void clearARecord(String host) throws IOException {\n+\t\tfinal String METHOD_NAME = \"clearMockARecord(String)\";\n+\n+\t\ttry (CloseableHttpClient httpclient = HttpClients.createDefault()) {\n+\t\t\t/*\n+\t\t\t * Generate the JSON request.\n+\t\t\t */\n+\t\t\tString jsonString = \"{\\\"host\\\":\\\"\" + host + \"\\\"}\";\n+\t\t\tStringEntity requestEntity = new StringEntity(jsonString, ContentType.APPLICATION_JSON);\n+\n+\t\t\t/*\n+\t\t\t * Create a POST request to the mock DNS server.\n+\t\t\t */\n+\t\t\tHttpPost httpPost = new HttpPost(getManagementAddress() + \"/clear-a\");\n+\t\t\thttpPost.setEntity(requestEntity);\n+\n+\t\t\t/*\n+\t\t\t * Send the POST request and process the response.\n+\t\t\t */\n+\t\t\ttry (final CloseableHttpResponse response = httpclient.execute(httpPost)) {\n+\t\t\t\tAcmeFatUtils.logHttpResponse(ChalltestsrvContainer.class, METHOD_NAME, httpPost, response);\n+\n+\t\t\t\tStatusLine statusLine = response.getStatusLine();\n+\t\t\t\tif (statusLine.getStatusCode() != 200) {\n+\t\t\t\t\tthrow new IOException(\n+\t\t\t\t\t\t\tMETHOD_NAME + \": Expected response 200, but received response: \" + statusLine);\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t}\n+\tpublic String getManagementAddress() {\n+\t\treturn \"http://\" + this.getContainerIpAddress() + \":\" + this.getMappedPort(MANAGEMENT_PORT);\n+\t}\n+\n+\tpublic String getAcmeDirectoryURI() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3dd0ccb898e794282f2c55bdc25f1b9f77207045"}, "originalPosition": 356}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ1MDIwNDU1OnYy", "diffSide": "RIGHT", "path": "dev/com.ibm.ws.security.acme_fat/fat/src/com/ibm/ws/security/acme/docker/CAContainer.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOVQyMDozODo1NlrOF4_kqQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOVQyMDozODo1NlrOF4_kqQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTMwNjE1Mw==", "bodyText": "Javadoc.", "url": "https://github.com/OpenLiberty/open-liberty/pull/11374#discussion_r395306153", "createdAt": "2020-03-19T20:38:56Z", "author": {"login": "jvanhill"}, "path": "dev/com.ibm.ws.security.acme_fat/fat/src/com/ibm/ws/security/acme/docker/CAContainer.java", "diffHunk": "@@ -0,0 +1,372 @@\n+package com.ibm.ws.security.acme.docker;\n+\n+import static junit.framework.Assert.fail;\n+\n+import java.io.IOException;\n+import java.security.cert.X509Certificate;\n+import java.util.Map.Entry;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import org.apache.http.StatusLine;\n+import org.apache.http.client.methods.CloseableHttpResponse;\n+import org.apache.http.client.methods.HttpGet;\n+import org.apache.http.client.methods.HttpPost;\n+import org.apache.http.entity.ContentType;\n+import org.apache.http.entity.StringEntity;\n+import org.apache.http.impl.client.CloseableHttpClient;\n+import org.apache.http.impl.client.HttpClients;\n+import org.apache.http.util.EntityUtils;\n+import org.testcontainers.containers.GenericContainer;\n+import org.testcontainers.images.builder.ImageFromDockerfile;\n+\n+import com.github.dockerjava.api.model.ContainerNetwork;\n+import com.ibm.websphere.simplicity.log.Log;\n+import com.ibm.ws.security.acme.utils.AcmeFatUtils;\n+\n+public class CAContainer extends GenericContainer<BoulderContainer> {\n+\n+\n+\tpublic static final int HTTP_PORT = 5002;\n+\n+\t/** The REST management API port. */\n+\tpublic int MANAGEMENT_PORT = 8055;\n+\t\n+\tpublic CAContainer(String image) {\n+\t\tsuper(image);\n+\t}\n+\n+\tpublic CAContainer(ImageFromDockerfile image, int managementPort) {\n+\t\tsuper(image);\n+\t\tMANAGEMENT_PORT = managementPort;\n+\t}\n+\n+\n+\t/**\n+\t * Get Pebble's intermediate certificate.\n+\t * \n+\t * @param fileName\n+\t *            The name of the file to save the certificate to.\n+\t * @return Pebble's root CA certificate in the form of a PEM file.\n+\t * @throws Exception\n+\t *             If we failed to receive the certificate.\n+\t */\n+\tpublic byte[] getAcmeCaIntermediateCertificate() throws Exception {\n+\t\tfinal String METHOD_NAME = \"getAcmeCaIntermediateCertificate()\";\n+\t\tString url = \"https://\" + this.getContainerIpAddress() + \":\" + this.getMappedPort(MANAGEMENT_PORT)\n+\t\t\t\t+ \"/intermediates/0\";\n+\n+\t\ttry (CloseableHttpClient httpclient = AcmeFatUtils.getInsecureHttpsClient()) {\n+\t\t\t/*\n+\t\t\t * Create a GET request to the ACME CA server.\n+\t\t\t */\n+\t\t\tHttpGet httpGet = new HttpGet(url);\n+\n+\t\t\t/*\n+\t\t\t * Send the GET request and process the response.\n+\t\t\t */\n+\t\t\ttry (final CloseableHttpResponse response = httpclient.execute(httpGet)) {\n+\t\t\t\tAcmeFatUtils.logHttpResponse(PebbleContainer.class, METHOD_NAME, httpGet, response);\n+\n+\t\t\t\tStatusLine statusLine = response.getStatusLine();\n+\n+\t\t\t\tif (statusLine.getStatusCode() != 200) {\n+\t\t\t\t\tthrow new IOException(\n+\t\t\t\t\t\t\tMETHOD_NAME + \": Expected response 200, but received response: \" + statusLine);\n+\t\t\t\t}\n+\n+\t\t\t\tbyte[] result = EntityUtils.toByteArray(response.getEntity());\n+\n+\t\t\t\tLog.info(PebbleContainer.class, METHOD_NAME, new String(result));\n+\t\t\t\treturn result;\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Get Pebble's root certificate.\n+\t * \n+\t * @param fileName\n+\t *            The name of the file to save the certificate to.\n+\t * @return Pebble's root CA certificate in the form of a PEM file.\n+\t * @throws Exception\n+\t *             If we failed to receive the certificate.\n+\t */\n+\tpublic byte[] getAcmeCaRootCertificate() throws Exception {\n+\t\tfinal String METHOD_NAME = \"getAcmeCaRootCertificate()\";\n+\t\tString url = \"https://\" + this.getContainerIpAddress() + \":\" + this.getMappedPort(MANAGEMENT_PORT) + \"/roots/0\";\n+\n+\t\ttry (CloseableHttpClient httpclient = AcmeFatUtils.getInsecureHttpsClient()) {\n+\t\t\t/*\n+\t\t\t * Create a GET request to the ACME CA server.\n+\t\t\t */\n+\t\t\tHttpGet httpGet = new HttpGet(url);\n+\n+\t\t\t/*\n+\t\t\t * Send the GET request and process the response.\n+\t\t\t */\n+\t\t\ttry (final CloseableHttpResponse response = httpclient.execute(httpGet)) {\n+\t\t\t\tAcmeFatUtils.logHttpResponse(BoulderContainer.class, METHOD_NAME, httpGet, response);\n+\n+\t\t\t\tStatusLine statusLine = response.getStatusLine();\n+\n+\t\t\t\tif (statusLine.getStatusCode() != 200) {\n+\t\t\t\t\tthrow new IOException(\n+\t\t\t\t\t\t\tMETHOD_NAME + \": Expected response 200, but received response: \" + statusLine);\n+\t\t\t\t}\n+\n+\t\t\t\tbyte[] result = EntityUtils.toByteArray(response.getEntity());\n+\n+\t\t\t\tLog.info(BoulderContainer.class, METHOD_NAME, new String(result));\n+\t\t\t\treturn result;\n+\t\t\t}\n+\t\t}\n+\t}\n+\t\n+\t/**\n+\t * Get the status of the certificate from the ACME CA server.\n+\t * \n+\t * @param certificate\n+\t *            The certificate to check.\n+\t * @return The status of the certificate.\n+\t * @throws Exception\n+\t */\n+\tpublic String getAcmeCertificateStatus(X509Certificate certificate) throws Exception {\n+\t\tfinal String METHOD_NAME = \"getAcmeCertificateStatus()\";\n+\t\tString url = \"https://\" + this.getContainerIpAddress() + \":\" + this.getMappedPort(MANAGEMENT_PORT)\n+\t\t\t\t+ \"/cert-status-by-serial/\" + certificate.getSerialNumber().toString(16);\n+\n+\t\ttry (CloseableHttpClient httpclient = AcmeFatUtils.getInsecureHttpsClient()) {\n+\t\t\t/*\n+\t\t\t * Create a GET request to the ACME CA server.\n+\t\t\t */\n+\t\t\tHttpGet httpGet = new HttpGet(url);\n+\n+\t\t\t/*\n+\t\t\t * Send the GET request and process the response.\n+\t\t\t */\n+\t\t\ttry (final CloseableHttpResponse response = httpclient.execute(httpGet)) {\n+\t\t\t\tAcmeFatUtils.logHttpResponse(BoulderContainer.class, METHOD_NAME, httpGet, response);\n+\n+\t\t\t\tStatusLine statusLine = response.getStatusLine();\n+\n+\t\t\t\tif (statusLine.getStatusCode() != 200) {\n+\t\t\t\t\tthrow new IOException(\n+\t\t\t\t\t\t\tMETHOD_NAME + \": Expected response 200, but received response: \" + statusLine);\n+\t\t\t\t}\n+\n+\t\t\t\tString result = EntityUtils.toString(response.getEntity());\n+\n+\t\t\t\t/*\n+\t\t\t\t * The result is in JSON, lets just parse out the status.\n+\t\t\t\t */\n+\t\t\t\tPattern p = Pattern.compile(\".*\\\"Status\\\": \\\"(\\\\w+)\\\",.*\", Pattern.DOTALL);\n+\t\t\t\tMatcher m = p.matcher(result);\n+\t\t\t\tif (m.find()) {\n+\t\t\t\t\tresult = m.group(1);\n+\t\t\t\t} else {\n+\t\t\t\t\tthrow new Exception(\n+\t\t\t\t\t\t\t\"Certificate status response was not in expected JSON format. Response: \" + result);\n+\t\t\t\t}\n+\n+\t\t\t\tLog.info(BoulderContainer.class, METHOD_NAME, new String(result));\n+\t\t\t\treturn result;\n+\t\t\t}\n+\t\t}\n+\t}\n+\t\n+\tpublic String getClientHost() throws IllegalStateException {\n+\t\tfor (String extraHost : this.getExtraHosts()) {\n+\t\t\tif (extraHost.startsWith(\"host.testcontainers.internal:\")) {\n+\t\t\t\treturn extraHost.replace(\"host.testcontainers.internal:\", \"\");\n+\t\t\t}\n+\t\t}\n+\n+\t\tthrow new IllegalStateException(\n+\t\t\t\t\"Unable to resolve local host from docker container. Could not find 'host.testcontainers.internal' property.\");\n+\t}\n+\t\n+\t/**\n+\t * Add an A record to the mock DNS server. This will allow us to redirect\n+\t * requests to a named domain to the IPv4 address of our choice.\n+\t * \n+\t * @param host\n+\t *            The host / domain to redirect requests for.\n+\t * @param address\n+\t *            The address to direct the requests for that host to.\n+\t * @throws IOException\n+\t */\n+\tpublic void addARecord(String host, String address) throws IOException {\n+\t\tfinal String METHOD_NAME = \"addARecord\";\n+\n+\t\ttry (CloseableHttpClient httpclient = HttpClients.createDefault()) {\n+\n+\t\t\t/*\n+\t\t\t * Generate the JSON request. The request can support multiple\n+\t\t\t * addresses but for the time being we will only support sending\n+\t\t\t * one.\n+\t\t\t */\n+\t\t\tString jsonString = \"{\\\"host\\\":\\\"\" + host + \"\\\",\\\"addresses\\\":[\\\"\" + address + \"\\\"]}\";\n+\t\t\tStringEntity requestEntity = new StringEntity(jsonString, ContentType.APPLICATION_JSON);\n+\n+\t\t\t/*\n+\t\t\t * Create a POST request to the mock DNS server.\n+\t\t\t */\n+\t\t\tHttpPost httpPost = new HttpPost(getManagementAddress() + \"/add-a\");\n+\t\t\thttpPost.setEntity(requestEntity);\n+\n+\t\t\t/*\n+\t\t\t * Send the POST request and process the response.\n+\t\t\t */\n+\t\t\ttry (final CloseableHttpResponse response = httpclient.execute(httpPost)) {\n+\t\t\t\tAcmeFatUtils.logHttpResponse(ChalltestsrvContainer.class, METHOD_NAME, httpPost, response);\n+\n+\t\t\t\tStatusLine statusLine = response.getStatusLine();\n+\t\t\t\tif (statusLine.getStatusCode() != 200) {\n+\t\t\t\t\tthrow new IOException(\n+\t\t\t\t\t\t\tMETHOD_NAME + \": Expected response 200, but received response: \" + statusLine);\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t}\n+\t\n+\t/**\n+\t * Add an AAAA record to the mock DNS server. This will allow us to redirect\n+\t * requests to a named domain to the IPv6 address of our choice.\n+\t * \n+\t * @param host\n+\t *            The host / domain to redirect requests for.\n+\t * @param address\n+\t *            The address to direct the requests for that host to.\n+\t * @throws IOException\n+\t */\n+\tpublic void addAAAARecord(String host, String address) throws IOException {\n+\t\tfinal String METHOD_NAME = \"addAAAARecord\";\n+\n+\t\ttry (CloseableHttpClient httpclient = HttpClients.createDefault()) {\n+\n+\t\t\t/*\n+\t\t\t * Generate the JSON request. The request can support multiple\n+\t\t\t * addresses but for the time being we will only support sending\n+\t\t\t * one.\n+\t\t\t */\n+\t\t\tString jsonString = \"{\\\"host\\\":\\\"\" + host + \"\\\",\\\"addresses\\\":[\\\"\" + address + \"\\\"]}\";\n+\t\t\tStringEntity requestEntity = new StringEntity(jsonString, ContentType.APPLICATION_JSON);\n+\n+\t\t\t/*\n+\t\t\t * Create a POST request to the mock DNS server.\n+\t\t\t */\n+\t\t\tHttpPost httpPost = new HttpPost(getManagementAddress() + \"/add-aaaa\");\n+\t\t\thttpPost.setEntity(requestEntity);\n+\n+\t\t\t/*\n+\t\t\t * Send the POST request and process the response.\n+\t\t\t */\n+\t\t\ttry (final CloseableHttpResponse response = httpclient.execute(httpPost)) {\n+\t\t\t\tAcmeFatUtils.logHttpResponse(ChalltestsrvContainer.class, METHOD_NAME, httpPost, response);\n+\n+\t\t\t\tStatusLine statusLine = response.getStatusLine();\n+\t\t\t\tif (statusLine.getStatusCode() != 200) {\n+\t\t\t\t\tthrow new IOException(\n+\t\t\t\t\t\t\tMETHOD_NAME + \": Expected response 200, but received response: \" + statusLine);\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t}\n+\t/**\n+\t * Clear a previously added AAAA record that was added to the mock DNS\n+\t * server.\n+\t * \n+\t * @param host\n+\t *            The host / domain to redirect requests for.\n+\t * @throws IOException\n+\t */\n+\tpublic void clearAAAARecord(String host) throws IOException {\n+\t\tfinal String METHOD_NAME = \"clearAAAARecord(String)\";\n+\n+\t\ttry (CloseableHttpClient httpclient = HttpClients.createDefault()) {\n+\t\t\t/*\n+\t\t\t * Generate the JSON request.\n+\t\t\t */\n+\t\t\tString jsonString = \"{\\\"host\\\":\\\"\" + host + \"\\\"}\";\n+\t\t\tStringEntity requestEntity = new StringEntity(jsonString, ContentType.APPLICATION_JSON);\n+\n+\t\t\t/*\n+\t\t\t * Create a POST request to the mock DNS server.\n+\t\t\t */\n+\t\t\tHttpPost httpPost = new HttpPost(getManagementAddress() + \"/clear-aaaa\");\n+\t\t\thttpPost.setEntity(requestEntity);\n+\n+\t\t\t/*\n+\t\t\t * Send the POST request and process the response.\n+\t\t\t */\n+\t\t\ttry (final CloseableHttpResponse response = httpclient.execute(httpPost)) {\n+\t\t\t\tAcmeFatUtils.logHttpResponse(ChalltestsrvContainer.class, METHOD_NAME, httpPost, response);\n+\n+\t\t\t\tStatusLine statusLine = response.getStatusLine();\n+\t\t\t\tif (statusLine.getStatusCode() != 200) {\n+\t\t\t\t\tthrow new IOException(\n+\t\t\t\t\t\t\tMETHOD_NAME + \": Expected response 200, but received response: \" + statusLine);\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Clear a previously added A record that was added to the mock DNS server.\n+\t * \n+\t * @param host\n+\t *            The host / domain to redirect requests for.\n+\t * @throws IOException\n+\t */\n+\tpublic void clearARecord(String host) throws IOException {\n+\t\tfinal String METHOD_NAME = \"clearMockARecord(String)\";\n+\n+\t\ttry (CloseableHttpClient httpclient = HttpClients.createDefault()) {\n+\t\t\t/*\n+\t\t\t * Generate the JSON request.\n+\t\t\t */\n+\t\t\tString jsonString = \"{\\\"host\\\":\\\"\" + host + \"\\\"}\";\n+\t\t\tStringEntity requestEntity = new StringEntity(jsonString, ContentType.APPLICATION_JSON);\n+\n+\t\t\t/*\n+\t\t\t * Create a POST request to the mock DNS server.\n+\t\t\t */\n+\t\t\tHttpPost httpPost = new HttpPost(getManagementAddress() + \"/clear-a\");\n+\t\t\thttpPost.setEntity(requestEntity);\n+\n+\t\t\t/*\n+\t\t\t * Send the POST request and process the response.\n+\t\t\t */\n+\t\t\ttry (final CloseableHttpResponse response = httpclient.execute(httpPost)) {\n+\t\t\t\tAcmeFatUtils.logHttpResponse(ChalltestsrvContainer.class, METHOD_NAME, httpPost, response);\n+\n+\t\t\t\tStatusLine statusLine = response.getStatusLine();\n+\t\t\t\tif (statusLine.getStatusCode() != 200) {\n+\t\t\t\t\tthrow new IOException(\n+\t\t\t\t\t\t\tMETHOD_NAME + \": Expected response 200, but received response: \" + statusLine);\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t}\n+\tpublic String getManagementAddress() {\n+\t\treturn \"http://\" + this.getContainerIpAddress() + \":\" + this.getMappedPort(MANAGEMENT_PORT);\n+\t}\n+\n+\tpublic String getAcmeDirectoryURI() {\n+\t\treturn null;\n+\t}\n+\n+\tpublic String getIntraContainerIP() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3dd0ccb898e794282f2c55bdc25f1b9f77207045"}, "originalPosition": 360}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ1MDIwNjU1OnYy", "diffSide": "RIGHT", "path": "dev/com.ibm.ws.security.acme_fat/fat/src/com/ibm/ws/security/acme/docker/CAContainer.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOVQyMDozOTozNVrOF4_l7g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOVQyMDozOTozNVrOF4_l7g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTMwNjQ3OA==", "bodyText": "Don't use fail. Throw an IllegalStateException. We don't want to assume everyone is using these in JUnits.", "url": "https://github.com/OpenLiberty/open-liberty/pull/11374#discussion_r395306478", "createdAt": "2020-03-19T20:39:35Z", "author": {"login": "jvanhill"}, "path": "dev/com.ibm.ws.security.acme_fat/fat/src/com/ibm/ws/security/acme/docker/CAContainer.java", "diffHunk": "@@ -0,0 +1,372 @@\n+package com.ibm.ws.security.acme.docker;\n+\n+import static junit.framework.Assert.fail;\n+\n+import java.io.IOException;\n+import java.security.cert.X509Certificate;\n+import java.util.Map.Entry;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import org.apache.http.StatusLine;\n+import org.apache.http.client.methods.CloseableHttpResponse;\n+import org.apache.http.client.methods.HttpGet;\n+import org.apache.http.client.methods.HttpPost;\n+import org.apache.http.entity.ContentType;\n+import org.apache.http.entity.StringEntity;\n+import org.apache.http.impl.client.CloseableHttpClient;\n+import org.apache.http.impl.client.HttpClients;\n+import org.apache.http.util.EntityUtils;\n+import org.testcontainers.containers.GenericContainer;\n+import org.testcontainers.images.builder.ImageFromDockerfile;\n+\n+import com.github.dockerjava.api.model.ContainerNetwork;\n+import com.ibm.websphere.simplicity.log.Log;\n+import com.ibm.ws.security.acme.utils.AcmeFatUtils;\n+\n+public class CAContainer extends GenericContainer<BoulderContainer> {\n+\n+\n+\tpublic static final int HTTP_PORT = 5002;\n+\n+\t/** The REST management API port. */\n+\tpublic int MANAGEMENT_PORT = 8055;\n+\t\n+\tpublic CAContainer(String image) {\n+\t\tsuper(image);\n+\t}\n+\n+\tpublic CAContainer(ImageFromDockerfile image, int managementPort) {\n+\t\tsuper(image);\n+\t\tMANAGEMENT_PORT = managementPort;\n+\t}\n+\n+\n+\t/**\n+\t * Get Pebble's intermediate certificate.\n+\t * \n+\t * @param fileName\n+\t *            The name of the file to save the certificate to.\n+\t * @return Pebble's root CA certificate in the form of a PEM file.\n+\t * @throws Exception\n+\t *             If we failed to receive the certificate.\n+\t */\n+\tpublic byte[] getAcmeCaIntermediateCertificate() throws Exception {\n+\t\tfinal String METHOD_NAME = \"getAcmeCaIntermediateCertificate()\";\n+\t\tString url = \"https://\" + this.getContainerIpAddress() + \":\" + this.getMappedPort(MANAGEMENT_PORT)\n+\t\t\t\t+ \"/intermediates/0\";\n+\n+\t\ttry (CloseableHttpClient httpclient = AcmeFatUtils.getInsecureHttpsClient()) {\n+\t\t\t/*\n+\t\t\t * Create a GET request to the ACME CA server.\n+\t\t\t */\n+\t\t\tHttpGet httpGet = new HttpGet(url);\n+\n+\t\t\t/*\n+\t\t\t * Send the GET request and process the response.\n+\t\t\t */\n+\t\t\ttry (final CloseableHttpResponse response = httpclient.execute(httpGet)) {\n+\t\t\t\tAcmeFatUtils.logHttpResponse(PebbleContainer.class, METHOD_NAME, httpGet, response);\n+\n+\t\t\t\tStatusLine statusLine = response.getStatusLine();\n+\n+\t\t\t\tif (statusLine.getStatusCode() != 200) {\n+\t\t\t\t\tthrow new IOException(\n+\t\t\t\t\t\t\tMETHOD_NAME + \": Expected response 200, but received response: \" + statusLine);\n+\t\t\t\t}\n+\n+\t\t\t\tbyte[] result = EntityUtils.toByteArray(response.getEntity());\n+\n+\t\t\t\tLog.info(PebbleContainer.class, METHOD_NAME, new String(result));\n+\t\t\t\treturn result;\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Get Pebble's root certificate.\n+\t * \n+\t * @param fileName\n+\t *            The name of the file to save the certificate to.\n+\t * @return Pebble's root CA certificate in the form of a PEM file.\n+\t * @throws Exception\n+\t *             If we failed to receive the certificate.\n+\t */\n+\tpublic byte[] getAcmeCaRootCertificate() throws Exception {\n+\t\tfinal String METHOD_NAME = \"getAcmeCaRootCertificate()\";\n+\t\tString url = \"https://\" + this.getContainerIpAddress() + \":\" + this.getMappedPort(MANAGEMENT_PORT) + \"/roots/0\";\n+\n+\t\ttry (CloseableHttpClient httpclient = AcmeFatUtils.getInsecureHttpsClient()) {\n+\t\t\t/*\n+\t\t\t * Create a GET request to the ACME CA server.\n+\t\t\t */\n+\t\t\tHttpGet httpGet = new HttpGet(url);\n+\n+\t\t\t/*\n+\t\t\t * Send the GET request and process the response.\n+\t\t\t */\n+\t\t\ttry (final CloseableHttpResponse response = httpclient.execute(httpGet)) {\n+\t\t\t\tAcmeFatUtils.logHttpResponse(BoulderContainer.class, METHOD_NAME, httpGet, response);\n+\n+\t\t\t\tStatusLine statusLine = response.getStatusLine();\n+\n+\t\t\t\tif (statusLine.getStatusCode() != 200) {\n+\t\t\t\t\tthrow new IOException(\n+\t\t\t\t\t\t\tMETHOD_NAME + \": Expected response 200, but received response: \" + statusLine);\n+\t\t\t\t}\n+\n+\t\t\t\tbyte[] result = EntityUtils.toByteArray(response.getEntity());\n+\n+\t\t\t\tLog.info(BoulderContainer.class, METHOD_NAME, new String(result));\n+\t\t\t\treturn result;\n+\t\t\t}\n+\t\t}\n+\t}\n+\t\n+\t/**\n+\t * Get the status of the certificate from the ACME CA server.\n+\t * \n+\t * @param certificate\n+\t *            The certificate to check.\n+\t * @return The status of the certificate.\n+\t * @throws Exception\n+\t */\n+\tpublic String getAcmeCertificateStatus(X509Certificate certificate) throws Exception {\n+\t\tfinal String METHOD_NAME = \"getAcmeCertificateStatus()\";\n+\t\tString url = \"https://\" + this.getContainerIpAddress() + \":\" + this.getMappedPort(MANAGEMENT_PORT)\n+\t\t\t\t+ \"/cert-status-by-serial/\" + certificate.getSerialNumber().toString(16);\n+\n+\t\ttry (CloseableHttpClient httpclient = AcmeFatUtils.getInsecureHttpsClient()) {\n+\t\t\t/*\n+\t\t\t * Create a GET request to the ACME CA server.\n+\t\t\t */\n+\t\t\tHttpGet httpGet = new HttpGet(url);\n+\n+\t\t\t/*\n+\t\t\t * Send the GET request and process the response.\n+\t\t\t */\n+\t\t\ttry (final CloseableHttpResponse response = httpclient.execute(httpGet)) {\n+\t\t\t\tAcmeFatUtils.logHttpResponse(BoulderContainer.class, METHOD_NAME, httpGet, response);\n+\n+\t\t\t\tStatusLine statusLine = response.getStatusLine();\n+\n+\t\t\t\tif (statusLine.getStatusCode() != 200) {\n+\t\t\t\t\tthrow new IOException(\n+\t\t\t\t\t\t\tMETHOD_NAME + \": Expected response 200, but received response: \" + statusLine);\n+\t\t\t\t}\n+\n+\t\t\t\tString result = EntityUtils.toString(response.getEntity());\n+\n+\t\t\t\t/*\n+\t\t\t\t * The result is in JSON, lets just parse out the status.\n+\t\t\t\t */\n+\t\t\t\tPattern p = Pattern.compile(\".*\\\"Status\\\": \\\"(\\\\w+)\\\",.*\", Pattern.DOTALL);\n+\t\t\t\tMatcher m = p.matcher(result);\n+\t\t\t\tif (m.find()) {\n+\t\t\t\t\tresult = m.group(1);\n+\t\t\t\t} else {\n+\t\t\t\t\tthrow new Exception(\n+\t\t\t\t\t\t\t\"Certificate status response was not in expected JSON format. Response: \" + result);\n+\t\t\t\t}\n+\n+\t\t\t\tLog.info(BoulderContainer.class, METHOD_NAME, new String(result));\n+\t\t\t\treturn result;\n+\t\t\t}\n+\t\t}\n+\t}\n+\t\n+\tpublic String getClientHost() throws IllegalStateException {\n+\t\tfor (String extraHost : this.getExtraHosts()) {\n+\t\t\tif (extraHost.startsWith(\"host.testcontainers.internal:\")) {\n+\t\t\t\treturn extraHost.replace(\"host.testcontainers.internal:\", \"\");\n+\t\t\t}\n+\t\t}\n+\n+\t\tthrow new IllegalStateException(\n+\t\t\t\t\"Unable to resolve local host from docker container. Could not find 'host.testcontainers.internal' property.\");\n+\t}\n+\t\n+\t/**\n+\t * Add an A record to the mock DNS server. This will allow us to redirect\n+\t * requests to a named domain to the IPv4 address of our choice.\n+\t * \n+\t * @param host\n+\t *            The host / domain to redirect requests for.\n+\t * @param address\n+\t *            The address to direct the requests for that host to.\n+\t * @throws IOException\n+\t */\n+\tpublic void addARecord(String host, String address) throws IOException {\n+\t\tfinal String METHOD_NAME = \"addARecord\";\n+\n+\t\ttry (CloseableHttpClient httpclient = HttpClients.createDefault()) {\n+\n+\t\t\t/*\n+\t\t\t * Generate the JSON request. The request can support multiple\n+\t\t\t * addresses but for the time being we will only support sending\n+\t\t\t * one.\n+\t\t\t */\n+\t\t\tString jsonString = \"{\\\"host\\\":\\\"\" + host + \"\\\",\\\"addresses\\\":[\\\"\" + address + \"\\\"]}\";\n+\t\t\tStringEntity requestEntity = new StringEntity(jsonString, ContentType.APPLICATION_JSON);\n+\n+\t\t\t/*\n+\t\t\t * Create a POST request to the mock DNS server.\n+\t\t\t */\n+\t\t\tHttpPost httpPost = new HttpPost(getManagementAddress() + \"/add-a\");\n+\t\t\thttpPost.setEntity(requestEntity);\n+\n+\t\t\t/*\n+\t\t\t * Send the POST request and process the response.\n+\t\t\t */\n+\t\t\ttry (final CloseableHttpResponse response = httpclient.execute(httpPost)) {\n+\t\t\t\tAcmeFatUtils.logHttpResponse(ChalltestsrvContainer.class, METHOD_NAME, httpPost, response);\n+\n+\t\t\t\tStatusLine statusLine = response.getStatusLine();\n+\t\t\t\tif (statusLine.getStatusCode() != 200) {\n+\t\t\t\t\tthrow new IOException(\n+\t\t\t\t\t\t\tMETHOD_NAME + \": Expected response 200, but received response: \" + statusLine);\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t}\n+\t\n+\t/**\n+\t * Add an AAAA record to the mock DNS server. This will allow us to redirect\n+\t * requests to a named domain to the IPv6 address of our choice.\n+\t * \n+\t * @param host\n+\t *            The host / domain to redirect requests for.\n+\t * @param address\n+\t *            The address to direct the requests for that host to.\n+\t * @throws IOException\n+\t */\n+\tpublic void addAAAARecord(String host, String address) throws IOException {\n+\t\tfinal String METHOD_NAME = \"addAAAARecord\";\n+\n+\t\ttry (CloseableHttpClient httpclient = HttpClients.createDefault()) {\n+\n+\t\t\t/*\n+\t\t\t * Generate the JSON request. The request can support multiple\n+\t\t\t * addresses but for the time being we will only support sending\n+\t\t\t * one.\n+\t\t\t */\n+\t\t\tString jsonString = \"{\\\"host\\\":\\\"\" + host + \"\\\",\\\"addresses\\\":[\\\"\" + address + \"\\\"]}\";\n+\t\t\tStringEntity requestEntity = new StringEntity(jsonString, ContentType.APPLICATION_JSON);\n+\n+\t\t\t/*\n+\t\t\t * Create a POST request to the mock DNS server.\n+\t\t\t */\n+\t\t\tHttpPost httpPost = new HttpPost(getManagementAddress() + \"/add-aaaa\");\n+\t\t\thttpPost.setEntity(requestEntity);\n+\n+\t\t\t/*\n+\t\t\t * Send the POST request and process the response.\n+\t\t\t */\n+\t\t\ttry (final CloseableHttpResponse response = httpclient.execute(httpPost)) {\n+\t\t\t\tAcmeFatUtils.logHttpResponse(ChalltestsrvContainer.class, METHOD_NAME, httpPost, response);\n+\n+\t\t\t\tStatusLine statusLine = response.getStatusLine();\n+\t\t\t\tif (statusLine.getStatusCode() != 200) {\n+\t\t\t\t\tthrow new IOException(\n+\t\t\t\t\t\t\tMETHOD_NAME + \": Expected response 200, but received response: \" + statusLine);\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t}\n+\t/**\n+\t * Clear a previously added AAAA record that was added to the mock DNS\n+\t * server.\n+\t * \n+\t * @param host\n+\t *            The host / domain to redirect requests for.\n+\t * @throws IOException\n+\t */\n+\tpublic void clearAAAARecord(String host) throws IOException {\n+\t\tfinal String METHOD_NAME = \"clearAAAARecord(String)\";\n+\n+\t\ttry (CloseableHttpClient httpclient = HttpClients.createDefault()) {\n+\t\t\t/*\n+\t\t\t * Generate the JSON request.\n+\t\t\t */\n+\t\t\tString jsonString = \"{\\\"host\\\":\\\"\" + host + \"\\\"}\";\n+\t\t\tStringEntity requestEntity = new StringEntity(jsonString, ContentType.APPLICATION_JSON);\n+\n+\t\t\t/*\n+\t\t\t * Create a POST request to the mock DNS server.\n+\t\t\t */\n+\t\t\tHttpPost httpPost = new HttpPost(getManagementAddress() + \"/clear-aaaa\");\n+\t\t\thttpPost.setEntity(requestEntity);\n+\n+\t\t\t/*\n+\t\t\t * Send the POST request and process the response.\n+\t\t\t */\n+\t\t\ttry (final CloseableHttpResponse response = httpclient.execute(httpPost)) {\n+\t\t\t\tAcmeFatUtils.logHttpResponse(ChalltestsrvContainer.class, METHOD_NAME, httpPost, response);\n+\n+\t\t\t\tStatusLine statusLine = response.getStatusLine();\n+\t\t\t\tif (statusLine.getStatusCode() != 200) {\n+\t\t\t\t\tthrow new IOException(\n+\t\t\t\t\t\t\tMETHOD_NAME + \": Expected response 200, but received response: \" + statusLine);\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Clear a previously added A record that was added to the mock DNS server.\n+\t * \n+\t * @param host\n+\t *            The host / domain to redirect requests for.\n+\t * @throws IOException\n+\t */\n+\tpublic void clearARecord(String host) throws IOException {\n+\t\tfinal String METHOD_NAME = \"clearMockARecord(String)\";\n+\n+\t\ttry (CloseableHttpClient httpclient = HttpClients.createDefault()) {\n+\t\t\t/*\n+\t\t\t * Generate the JSON request.\n+\t\t\t */\n+\t\t\tString jsonString = \"{\\\"host\\\":\\\"\" + host + \"\\\"}\";\n+\t\t\tStringEntity requestEntity = new StringEntity(jsonString, ContentType.APPLICATION_JSON);\n+\n+\t\t\t/*\n+\t\t\t * Create a POST request to the mock DNS server.\n+\t\t\t */\n+\t\t\tHttpPost httpPost = new HttpPost(getManagementAddress() + \"/clear-a\");\n+\t\t\thttpPost.setEntity(requestEntity);\n+\n+\t\t\t/*\n+\t\t\t * Send the POST request and process the response.\n+\t\t\t */\n+\t\t\ttry (final CloseableHttpResponse response = httpclient.execute(httpPost)) {\n+\t\t\t\tAcmeFatUtils.logHttpResponse(ChalltestsrvContainer.class, METHOD_NAME, httpPost, response);\n+\n+\t\t\t\tStatusLine statusLine = response.getStatusLine();\n+\t\t\t\tif (statusLine.getStatusCode() != 200) {\n+\t\t\t\t\tthrow new IOException(\n+\t\t\t\t\t\t\tMETHOD_NAME + \": Expected response 200, but received response: \" + statusLine);\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t}\n+\tpublic String getManagementAddress() {\n+\t\treturn \"http://\" + this.getContainerIpAddress() + \":\" + this.getMappedPort(MANAGEMENT_PORT);\n+\t}\n+\n+\tpublic String getAcmeDirectoryURI() {\n+\t\treturn null;\n+\t}\n+\n+\tpublic String getIntraContainerIP() {\n+\t\tString intraContainerIpAddress = null;\n+\t\tfor (Entry<String, ContainerNetwork> entry : getContainerInfo().getNetworkSettings().getNetworks().entrySet()) {\n+\t\t\tintraContainerIpAddress = entry.getValue().getIpAddress();\n+\t\t\tbreak;\n+\t\t}\n+\t\tif (intraContainerIpAddress == null) {\n+\t\t\tfail(\"Didn't find IP address for challtestsrv server.\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3dd0ccb898e794282f2c55bdc25f1b9f77207045"}, "originalPosition": 367}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ1MDIxMTQ5OnYy", "diffSide": "RIGHT", "path": "dev/com.ibm.ws.security.acme_fat/fat/src/com/ibm/ws/security/acme/docker/ChalltestsrvContainer.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOVQyMDo0MToxMFrOF4_pFQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOVQyMDo0MToxMFrOF4_pFQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTMwNzI4NQ==", "bodyText": "I wasn't really expecting both PebbleContainer and CAContainer to extend CAContainer. My expectation was that the There would be a new class that would wrap both the PebbleContainer and ChalltestsrvContainer that would extend the CAContainer. This class would then call through appropriately.", "url": "https://github.com/OpenLiberty/open-liberty/pull/11374#discussion_r395307285", "createdAt": "2020-03-19T20:41:10Z", "author": {"login": "jvanhill"}, "path": "dev/com.ibm.ws.security.acme_fat/fat/src/com/ibm/ws/security/acme/docker/ChalltestsrvContainer.java", "diffHunk": "@@ -13,29 +13,19 @@\n \n import static junit.framework.Assert.fail;\n \n-import java.io.IOException;\n import java.util.Map.Entry;\n \n-import org.apache.http.StatusLine;\n-import org.apache.http.client.methods.CloseableHttpResponse;\n-import org.apache.http.client.methods.HttpPost;\n-import org.apache.http.entity.ContentType;\n-import org.apache.http.entity.StringEntity;\n-import org.apache.http.impl.client.CloseableHttpClient;\n-import org.apache.http.impl.client.HttpClients;\n-import org.testcontainers.containers.GenericContainer;\n import org.testcontainers.containers.Network;\n import org.testcontainers.containers.output.OutputFrame;\n \n import com.github.dockerjava.api.model.ContainerNetwork;\n import com.ibm.websphere.simplicity.log.Log;\n-import com.ibm.ws.security.acme.utils.AcmeFatUtils;\n \n /**\n  * Testcontainer implementation for the letsencrypt/pebble-challtestsrv\n  * container.\n  */\n-public class ChalltestsrvContainer extends GenericContainer<ChalltestsrvContainer> {\n+public class ChalltestsrvContainer extends CAContainer {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3dd0ccb898e794282f2c55bdc25f1b9f77207045"}, "originalPosition": 27}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ1MDIxNDc5OnYy", "diffSide": "RIGHT", "path": "dev/com.ibm.ws.security.acme_fat/fat/src/com/ibm/ws/security/acme/docker/PebbleContainer.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOVQyMDo0MjoyM1rOF4_rSQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOVQyMDo0MjoyM1rOF4_rSQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTMwNzg0OQ==", "bodyText": "Again, I expected a wrapper class to extend CAContainer and to contain the Pebble and Challtestserv containers.", "url": "https://github.com/OpenLiberty/open-liberty/pull/11374#discussion_r395307849", "createdAt": "2020-03-19T20:42:23Z", "author": {"login": "jvanhill"}, "path": "dev/com.ibm.ws.security.acme_fat/fat/src/com/ibm/ws/security/acme/docker/PebbleContainer.java", "diffHunk": "@@ -33,13 +33,7 @@\n /**\n  * Testcontainer implementation for the letsencrypt/pebble container.\n  */\n-public class PebbleContainer extends GenericContainer<PebbleContainer> {\n-\n-\t/**\n-\t * The port that ACME HTTP validation requests will be sent to the domain\n-\t * on. Must match the port in 'publish/files/pebble-config.json'.\n-\t */\n-\tpublic static final int HTTP_PORT = 5002;\n+public class PebbleContainer extends CAContainer {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3dd0ccb898e794282f2c55bdc25f1b9f77207045"}, "originalPosition": 11}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ1MDIyNjA1OnYy", "diffSide": "RIGHT", "path": "dev/com.ibm.ws.security.acme_fat/publish/files/test-ca2.pem", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOVQyMDo0NjowNFrOF4_yhQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wNlQxNzoxMzo0N1rOGBhyzg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTMwOTcwMQ==", "bodyText": "Probably rename this file. What is this file for?", "url": "https://github.com/OpenLiberty/open-liberty/pull/11374#discussion_r395309701", "createdAt": "2020-03-19T20:46:04Z", "author": {"login": "jvanhill"}, "path": "dev/com.ibm.ws.security.acme_fat/publish/files/test-ca2.pem", "diffHunk": "@@ -0,0 +1,25 @@\n+-----BEGIN CERTIFICATE-----", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3dd0ccb898e794282f2c55bdc25f1b9f77207045"}, "originalPosition": 1}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDI1NTQzOA==", "bodyText": "That's what boulder uses to get the intermediate certificate.", "url": "https://github.com/OpenLiberty/open-liberty/pull/11374#discussion_r404255438", "createdAt": "2020-04-06T17:13:47Z", "author": {"login": "ryanesch"}, "path": "dev/com.ibm.ws.security.acme_fat/publish/files/test-ca2.pem", "diffHunk": "@@ -0,0 +1,25 @@\n+-----BEGIN CERTIFICATE-----", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTMwOTcwMQ=="}, "originalCommit": {"oid": "3dd0ccb898e794282f2c55bdc25f1b9f77207045"}, "originalPosition": 1}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ5MjI2MjU0OnYy", "diffSide": "RIGHT", "path": "dev/com.ibm.ws.security.acme_fat/fat/src/com/ibm/ws/security/acme/docker/BoulderContainer.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMVQxOTo0NzoxNFrOF_QBbg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMVQxOTo0NzoxNFrOF_QBbg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTg2NzExOA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n             * Copyright (c) 2019, 2020 IBM Corporation and others.\n          \n          \n            \n             * Copyright (c) 2020 IBM Corporation and others.", "url": "https://github.com/OpenLiberty/open-liberty/pull/11374#discussion_r401867118", "createdAt": "2020-04-01T19:47:14Z", "author": {"login": "jvanhill"}, "path": "dev/com.ibm.ws.security.acme_fat/fat/src/com/ibm/ws/security/acme/docker/BoulderContainer.java", "diffHunk": "@@ -0,0 +1,326 @@\n+/*******************************************************************************\n+ * Copyright (c) 2019, 2020 IBM Corporation and others.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "556f2bf0d7cd627f526cd95379940eb7d82bf9de"}, "originalPosition": 2}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ5MjI2NDc4OnYy", "diffSide": "RIGHT", "path": "dev/com.ibm.ws.security.acme_fat/fat/src/com/ibm/ws/security/acme/docker/BoulderContainer.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMVQxOTo0Nzo1MFrOF_QCvw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMVQxOTo0Nzo1MFrOF_QCvw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTg2NzQ1NQ==", "bodyText": "Lets not require Junit to run this, otherwise running it outside of Junit will be confusing.", "url": "https://github.com/OpenLiberty/open-liberty/pull/11374#discussion_r401867455", "createdAt": "2020-04-01T19:47:50Z", "author": {"login": "jvanhill"}, "path": "dev/com.ibm.ws.security.acme_fat/fat/src/com/ibm/ws/security/acme/docker/BoulderContainer.java", "diffHunk": "@@ -0,0 +1,326 @@\n+/*******************************************************************************\n+ * Copyright (c) 2019, 2020 IBM Corporation and others.\n+ * All rights reserved. This program and the accompanying materials\n+ * are made available under the terms of the Eclipse Public License v1.0\n+ * which accompanies this distribution, and is available at\n+ * http://www.eclipse.org/legal/epl-v10.html\n+ *\n+ * Contributors:\n+ *     IBM Corporation - initial API and implementation\n+ *******************************************************************************/\n+package com.ibm.ws.security.acme.docker;\n+\n+import static junit.framework.Assert.fail;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "556f2bf0d7cd627f526cd95379940eb7d82bf9de"}, "originalPosition": 13}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ5MjI2NTc1OnYy", "diffSide": "RIGHT", "path": "dev/com.ibm.ws.security.acme_fat/fat/src/com/ibm/ws/security/acme/docker/BoulderContainer.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMVQxOTo0ODowN1rOF_QDVw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMVQxOTo0ODowN1rOF_QDVw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTg2NzYwNw==", "bodyText": "Whitespace.", "url": "https://github.com/OpenLiberty/open-liberty/pull/11374#discussion_r401867607", "createdAt": "2020-04-01T19:48:07Z", "author": {"login": "jvanhill"}, "path": "dev/com.ibm.ws.security.acme_fat/fat/src/com/ibm/ws/security/acme/docker/BoulderContainer.java", "diffHunk": "@@ -0,0 +1,326 @@\n+/*******************************************************************************\n+ * Copyright (c) 2019, 2020 IBM Corporation and others.\n+ * All rights reserved. This program and the accompanying materials\n+ * are made available under the terms of the Eclipse Public License v1.0\n+ * which accompanies this distribution, and is available at\n+ * http://www.eclipse.org/legal/epl-v10.html\n+ *\n+ * Contributors:\n+ *     IBM Corporation - initial API and implementation\n+ *******************************************************************************/\n+package com.ibm.ws.security.acme.docker;\n+\n+import static junit.framework.Assert.fail;\n+\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.security.KeyStore;\n+import java.security.cert.Certificate;\n+import java.security.cert.X509Certificate;\n+import java.time.Duration;\n+import java.util.Map.Entry;\n+\n+import org.testcontainers.Testcontainers;\n+import org.testcontainers.containers.GenericContainer;\n+import org.testcontainers.containers.Network;\n+import com.github.dockerjava.api.model.ContainerNetwork;\n+import com.github.dockerjava.api.model.ContainerNetwork.Ipam;\n+import com.ibm.websphere.simplicity.log.Log;\n+import com.ibm.ws.security.acme.AcmeCaException;\n+import com.ibm.ws.security.acme.fat.FATSuite;\n+import com.ibm.ws.security.acme.internal.AcmeClient;\n+import com.ibm.ws.security.acme.utils.AcmeFatUtils;\n+import com.ibm.ws.security.acme.utils.HttpChallengeServer;\n+/**", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "556f2bf0d7cd627f526cd95379940eb7d82bf9de"}, "originalPosition": 37}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ5MjI3MDMzOnYy", "diffSide": "RIGHT", "path": "dev/com.ibm.ws.security.acme_fat/fat/src/com/ibm/ws/security/acme/docker/BoulderContainer.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMVQxOTo0OToxOVrOF_QGGw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMVQxOTo0OToxOVrOF_QGGw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTg2ODMxNQ==", "bodyText": "Can you do a reformat of this file? seems the indenting is not correct.", "url": "https://github.com/OpenLiberty/open-liberty/pull/11374#discussion_r401868315", "createdAt": "2020-04-01T19:49:19Z", "author": {"login": "jvanhill"}, "path": "dev/com.ibm.ws.security.acme_fat/fat/src/com/ibm/ws/security/acme/docker/BoulderContainer.java", "diffHunk": "@@ -0,0 +1,326 @@\n+/*******************************************************************************\n+ * Copyright (c) 2019, 2020 IBM Corporation and others.\n+ * All rights reserved. This program and the accompanying materials\n+ * are made available under the terms of the Eclipse Public License v1.0\n+ * which accompanies this distribution, and is available at\n+ * http://www.eclipse.org/legal/epl-v10.html\n+ *\n+ * Contributors:\n+ *     IBM Corporation - initial API and implementation\n+ *******************************************************************************/\n+package com.ibm.ws.security.acme.docker;\n+\n+import static junit.framework.Assert.fail;\n+\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.security.KeyStore;\n+import java.security.cert.Certificate;\n+import java.security.cert.X509Certificate;\n+import java.time.Duration;\n+import java.util.Map.Entry;\n+\n+import org.testcontainers.Testcontainers;\n+import org.testcontainers.containers.GenericContainer;\n+import org.testcontainers.containers.Network;\n+import com.github.dockerjava.api.model.ContainerNetwork;\n+import com.github.dockerjava.api.model.ContainerNetwork.Ipam;\n+import com.ibm.websphere.simplicity.log.Log;\n+import com.ibm.ws.security.acme.AcmeCaException;\n+import com.ibm.ws.security.acme.fat.FATSuite;\n+import com.ibm.ws.security.acme.internal.AcmeClient;\n+import com.ibm.ws.security.acme.utils.AcmeFatUtils;\n+import com.ibm.ws.security.acme.utils.HttpChallengeServer;\n+/**\n+ * Testcontainer implementation for the letsencrypt/boulder container.\n+ * Boulder is designed to run with docker-compose. In order to integrate\n+ * Boulder into the acme FAT, the docker-compose file from letsencrypt\n+ * was turned into the following GenericContainers. This class consists\n+ * of three containers and two networks. Because Boulder consists of\n+ * many files, a Docker image was created that is built on top of\n+ * letsencrypt/boulder-tools-go and includes all the files that would\n+ * otherwise need to be copied at runtime. This saves 8+ minutes per\n+ * run.\n+ */\n+public class BoulderContainer extends CAContainer {\n+\n+\t/** The port used to listen for incoming ACME requests. */\n+\tpublic static final int LISTEN_PORT = 4001;\n+\n+\tprivate static String TRUSTSTORE_FILE;\n+\tprivate static String FILE_ACCOUNT_KEY;\n+\tprivate static String FILE_DOMAIN_KEY;\n+\tprivate static final String TRUSTSTORE_PASSWORD = \"password\";\n+\tprivate static X509Certificate intermediateCertificate = null;\n+\tprivate static HttpChallengeServer challengeServer = null;\n+\tprivate static final String FILE_MINICA_PEM = \"lib/LibertyFATTestFiles/test-ca2.pem\";\n+\t\n+\n+    \n+    public final Network bluenet = Network.builder()\n+            .createNetworkCmdModifier(cmd -> {\n+                cmd.withDriver(\"bridge\");\n+                cmd.withIpam(new com.github.dockerjava.api.model.Network.Ipam()\n+                        .withDriver(\"default\")\n+                        .withConfig(new com.github.dockerjava.api.model.Network.Ipam.Config()\n+                                .withSubnet(\"10.77.77.0/24\")));\n+            })\n+            .build();\n+\n+    public final Network rednet =  Network.builder()\n+            .createNetworkCmdModifier(cmd -> {\n+                cmd.withDriver(\"bridge\");\n+                cmd.withIpam(new com.github.dockerjava.api.model.Network.Ipam()\n+                        .withDriver(\"default\")\n+                        .withConfig(new com.github.dockerjava.api.model.Network.Ipam.Config()\n+                                .withSubnet(\"10.88.88.0/24\")));\n+            })\n+            .build();\n+    \n+    public final GenericContainer<?> bhsm = new GenericContainer<>(DOCKER_IMAGE)\n+            .withEnv(\"PKCS11_DAEMON_SOCKET\", \"tcp://0.0.0.0:5657\")\n+            .withExposedPorts(5657)\n+            .withNetwork(bluenet)\n+            .withNetworkAliases(\"boulder-hsm\")\n+            .withCommand(\"/usr/local/bin/pkcs11-daemon /usr/lib/softhsm/libsofthsm2.so\")\n+            .withLogConsumer(o -> System.out.print(\"[HSM] \" + o.getUtf8String()));\n+    \n+    public final GenericContainer<?> bmysql = new GenericContainer<>(\"mariadb:10.3\")\n+            .withNetwork(bluenet)\n+            .withExposedPorts(3306)\n+            .withNetworkAliases(\"boulder-mysql\")\n+            .withEnv(\"MYSQL_ALLOW_EMPTY_PASSWORD\", \"yes\")\n+            .withCommand(\"mysqld --bind-address=0.0.0.0 --slow-query-log --log-output=TABLE --log-queries-not-using-indexes=ON\")\n+            .withLogConsumer(o -> System.out.print(\"[SQL] \" + o.getUtf8String()));\n+    \n+    private static final String DOCKER_IMAGE = \"ryanesch/acme-boulder:latest\";\n+    \n+    public BoulderContainer() {\n+        super(DOCKER_IMAGE);\n+\t\t/*", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "556f2bf0d7cd627f526cd95379940eb7d82bf9de"}, "originalPosition": 103}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ5MjI3NDY2OnYy", "diffSide": "RIGHT", "path": "dev/com.ibm.ws.security.acme_fat/fat/src/com/ibm/ws/security/acme/docker/BoulderContainer.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMVQxOTo1MDozNVrOF_QI5A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMVQxOTo1MDozNVrOF_QI5A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTg2OTAyOA==", "bodyText": "Why is this here? Liberty will be the challenge server.", "url": "https://github.com/OpenLiberty/open-liberty/pull/11374#discussion_r401869028", "createdAt": "2020-04-01T19:50:35Z", "author": {"login": "jvanhill"}, "path": "dev/com.ibm.ws.security.acme_fat/fat/src/com/ibm/ws/security/acme/docker/BoulderContainer.java", "diffHunk": "@@ -0,0 +1,326 @@\n+/*******************************************************************************\n+ * Copyright (c) 2019, 2020 IBM Corporation and others.\n+ * All rights reserved. This program and the accompanying materials\n+ * are made available under the terms of the Eclipse Public License v1.0\n+ * which accompanies this distribution, and is available at\n+ * http://www.eclipse.org/legal/epl-v10.html\n+ *\n+ * Contributors:\n+ *     IBM Corporation - initial API and implementation\n+ *******************************************************************************/\n+package com.ibm.ws.security.acme.docker;\n+\n+import static junit.framework.Assert.fail;\n+\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.security.KeyStore;\n+import java.security.cert.Certificate;\n+import java.security.cert.X509Certificate;\n+import java.time.Duration;\n+import java.util.Map.Entry;\n+\n+import org.testcontainers.Testcontainers;\n+import org.testcontainers.containers.GenericContainer;\n+import org.testcontainers.containers.Network;\n+import com.github.dockerjava.api.model.ContainerNetwork;\n+import com.github.dockerjava.api.model.ContainerNetwork.Ipam;\n+import com.ibm.websphere.simplicity.log.Log;\n+import com.ibm.ws.security.acme.AcmeCaException;\n+import com.ibm.ws.security.acme.fat.FATSuite;\n+import com.ibm.ws.security.acme.internal.AcmeClient;\n+import com.ibm.ws.security.acme.utils.AcmeFatUtils;\n+import com.ibm.ws.security.acme.utils.HttpChallengeServer;\n+/**\n+ * Testcontainer implementation for the letsencrypt/boulder container.\n+ * Boulder is designed to run with docker-compose. In order to integrate\n+ * Boulder into the acme FAT, the docker-compose file from letsencrypt\n+ * was turned into the following GenericContainers. This class consists\n+ * of three containers and two networks. Because Boulder consists of\n+ * many files, a Docker image was created that is built on top of\n+ * letsencrypt/boulder-tools-go and includes all the files that would\n+ * otherwise need to be copied at runtime. This saves 8+ minutes per\n+ * run.\n+ */\n+public class BoulderContainer extends CAContainer {\n+\n+\t/** The port used to listen for incoming ACME requests. */\n+\tpublic static final int LISTEN_PORT = 4001;\n+\n+\tprivate static String TRUSTSTORE_FILE;\n+\tprivate static String FILE_ACCOUNT_KEY;\n+\tprivate static String FILE_DOMAIN_KEY;\n+\tprivate static final String TRUSTSTORE_PASSWORD = \"password\";\n+\tprivate static X509Certificate intermediateCertificate = null;\n+\tprivate static HttpChallengeServer challengeServer = null;\n+\tprivate static final String FILE_MINICA_PEM = \"lib/LibertyFATTestFiles/test-ca2.pem\";\n+\t\n+\n+    \n+    public final Network bluenet = Network.builder()\n+            .createNetworkCmdModifier(cmd -> {\n+                cmd.withDriver(\"bridge\");\n+                cmd.withIpam(new com.github.dockerjava.api.model.Network.Ipam()\n+                        .withDriver(\"default\")\n+                        .withConfig(new com.github.dockerjava.api.model.Network.Ipam.Config()\n+                                .withSubnet(\"10.77.77.0/24\")));\n+            })\n+            .build();\n+\n+    public final Network rednet =  Network.builder()\n+            .createNetworkCmdModifier(cmd -> {\n+                cmd.withDriver(\"bridge\");\n+                cmd.withIpam(new com.github.dockerjava.api.model.Network.Ipam()\n+                        .withDriver(\"default\")\n+                        .withConfig(new com.github.dockerjava.api.model.Network.Ipam.Config()\n+                                .withSubnet(\"10.88.88.0/24\")));\n+            })\n+            .build();\n+    \n+    public final GenericContainer<?> bhsm = new GenericContainer<>(DOCKER_IMAGE)\n+            .withEnv(\"PKCS11_DAEMON_SOCKET\", \"tcp://0.0.0.0:5657\")\n+            .withExposedPorts(5657)\n+            .withNetwork(bluenet)\n+            .withNetworkAliases(\"boulder-hsm\")\n+            .withCommand(\"/usr/local/bin/pkcs11-daemon /usr/lib/softhsm/libsofthsm2.so\")\n+            .withLogConsumer(o -> System.out.print(\"[HSM] \" + o.getUtf8String()));\n+    \n+    public final GenericContainer<?> bmysql = new GenericContainer<>(\"mariadb:10.3\")\n+            .withNetwork(bluenet)\n+            .withExposedPorts(3306)\n+            .withNetworkAliases(\"boulder-mysql\")\n+            .withEnv(\"MYSQL_ALLOW_EMPTY_PASSWORD\", \"yes\")\n+            .withCommand(\"mysqld --bind-address=0.0.0.0 --slow-query-log --log-output=TABLE --log-queries-not-using-indexes=ON\")\n+            .withLogConsumer(o -> System.out.print(\"[SQL] \" + o.getUtf8String()));\n+    \n+    private static final String DOCKER_IMAGE = \"ryanesch/acme-boulder:latest\";\n+    \n+    public BoulderContainer() {\n+        super(DOCKER_IMAGE);\n+\t\t/*\n+\t\t * Need to expose the HTTP port that is used to answer the HTTP-01\n+\t\t * challenge.\n+\t\t */\n+\t\tTestcontainers.exposeHostPorts(HTTP_PORT);\n+\n+\t\t/*\n+\t\t * Start a simple HTTP server to respond to challenges.\n+\t\t */\n+\t\tchallengeServer = new HttpChallengeServer(HTTP_PORT);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "556f2bf0d7cd627f526cd95379940eb7d82bf9de"}, "originalPosition": 112}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUwODU0MjIzOnYy", "diffSide": "RIGHT", "path": "dev/com.ibm.ws.security.acme_fat/fat/src/com/ibm/ws/security/acme/docker/CAContainer.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wNlQxNzozMzowMlrOGBiiHg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wNlQxNzozMzowMlrOGBiiHg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDI2NzU1MA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n             * Copyright (c) 2019, 2020 IBM Corporation and others.\n          \n          \n            \n             * Copyright (c) 2020 IBM Corporation and others.", "url": "https://github.com/OpenLiberty/open-liberty/pull/11374#discussion_r404267550", "createdAt": "2020-04-06T17:33:02Z", "author": {"login": "jvanhill"}, "path": "dev/com.ibm.ws.security.acme_fat/fat/src/com/ibm/ws/security/acme/docker/CAContainer.java", "diffHunk": "@@ -0,0 +1,442 @@\n+/*******************************************************************************\n+ * Copyright (c) 2019, 2020 IBM Corporation and others.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3c28406c01e42dd902f376fac4532e84cf17aa5f"}, "originalPosition": 2}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUwODU0NzU4OnYy", "diffSide": "RIGHT", "path": "dev/com.ibm.ws.security.acme_fat/fat/src/com/ibm/ws/security/acme/docker/CAContainer.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wNlQxNzozNDoyOVrOGBilbw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wNlQxNzozNDoyOVrOGBilbw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDI2ODM5OQ==", "bodyText": "weird alignment.", "url": "https://github.com/OpenLiberty/open-liberty/pull/11374#discussion_r404268399", "createdAt": "2020-04-06T17:34:29Z", "author": {"login": "jvanhill"}, "path": "dev/com.ibm.ws.security.acme_fat/fat/src/com/ibm/ws/security/acme/docker/CAContainer.java", "diffHunk": "@@ -0,0 +1,442 @@\n+/*******************************************************************************\n+ * Copyright (c) 2019, 2020 IBM Corporation and others.\n+ * All rights reserved. This program and the accompanying materials\n+ * are made available under the terms of the Eclipse Public License v1.0\n+ * which accompanies this distribution, and is available at\n+ * http://www.eclipse.org/legal/epl-v10.html\n+ *\n+ * Contributors:\n+ *     IBM Corporation - initial API and implementation\n+ *******************************************************************************/\n+package com.ibm.ws.security.acme.docker;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.security.cert.X509Certificate;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import org.apache.http.StatusLine;\n+import org.apache.http.client.methods.CloseableHttpResponse;\n+import org.apache.http.client.methods.HttpGet;\n+import org.apache.http.client.methods.HttpPost;\n+import org.apache.http.entity.ContentType;\n+import org.apache.http.entity.StringEntity;\n+import org.apache.http.impl.client.CloseableHttpClient;\n+import org.apache.http.impl.client.HttpClients;\n+import org.apache.http.util.EntityUtils;\n+import org.testcontainers.containers.GenericContainer;\n+import org.testcontainers.images.builder.ImageFromDockerfile;\n+\n+import com.ibm.websphere.simplicity.log.Log;\n+import com.ibm.ws.security.acme.utils.AcmeFatUtils;\n+\n+/**\n+ * Testcontainer implementation for Pebble and Boulder Certificate Authorities.\n+ * \n+ */\n+public class CAContainer extends GenericContainer<CAContainer> {\n+\n+\tprivate static final String TEST_DOMAIN_1 = \"domain1.com\";\n+\tprivate static final String TEST_DOMAIN_2 = \"domain2.com\";\n+\tprivate static final String TEST_DOMAIN_3 = \"domain3.com\";\n+\tprivate static final String TEST_DOMAIN_4 = \"domain4.com\";\n+\t\n+\t/** Challenge server port. */\n+\tpublic static final int HTTP_PORT = 5002;\n+\t/** The REST management API port. */\n+\tpublic int MANAGEMENT_PORT = 8055;\n+\t\n+\t/**\n+\t * This constructor is used by BoulderContainer\n+\t */\n+\tpublic CAContainer(String image) {\n+\t\tsuper(image);\n+\t}\n+\n+\t/**\n+\t * This constructor is used by PebbleContainer. The\n+\t * management port is different for Pebble, so this\n+\t * is passed in.\n+\t */\n+\tpublic CAContainer(ImageFromDockerfile image, int managementPort) {\n+\t\tsuper(image);\n+\t\tMANAGEMENT_PORT = managementPort;\n+\t}\n+\n+\t/**\n+\t * Get CA's intermediate certificate.\n+\t * \n+\t * @param fileName\n+\t *            The name of the file to save the certificate to.\n+\t * @return CA's intermediate certificate in the form of a PEM file.\n+\t * @throws Exception\n+\t *             If we failed to receive the certificate.\n+\t */\n+\tpublic InputStream getAcmeCaIntermediateCertificate() throws Exception {\n+\t\tfinal String METHOD_NAME = \"getAcmeCaIntermediateCertificate()\";\n+\t\tString url = \"https://\" + this.getContainerIpAddress() + \":\" + this.getMappedPort(MANAGEMENT_PORT)\n+\t\t\t\t+ \"/intermediates/0\";\n+\n+\t\ttry (CloseableHttpClient httpclient = AcmeFatUtils.getInsecureHttpsClient()) {\n+\t\t\t/*\n+\t\t\t * Create a GET request to the ACME CA server.\n+\t\t\t */\n+\t\t\tHttpGet httpGet = new HttpGet(url);\n+\n+\t\t\t/*\n+\t\t\t * Send the GET request and process the response.\n+\t\t\t */\n+\t\t\ttry (final CloseableHttpResponse response = httpclient.execute(httpGet)) {\n+\t\t\t\tAcmeFatUtils.logHttpResponse(CAContainer.class, METHOD_NAME, httpGet, response);\n+\n+\t\t\t\tStatusLine statusLine = response.getStatusLine();\n+\n+\t\t\t\tif (statusLine.getStatusCode() != 200) {\n+\t\t\t\t\tthrow new IOException(\n+\t\t\t\t\t\t\tMETHOD_NAME + \": Expected response 200, but received response: \" + statusLine);\n+\t\t\t\t}\n+\n+\t\t\t\tbyte[] result = EntityUtils.toByteArray(response.getEntity());\n+\n+\t\t\t\tLog.info(CAContainer.class, METHOD_NAME, new String(result));\n+\t\t\t\treturn  new ByteArrayInputStream(result);\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Get the root certificate.\n+\t * \n+\t * @param fileName\n+\t *            The name of the file to save the certificate to.\n+\t * @return Certificate Authority's root certificate in the form of a PEM file.\n+\t * @throws Exception\n+\t *             If we failed to receive the certificate.\n+\t */\n+\tpublic byte[] getAcmeCaRootCertificate() throws Exception {\n+\t\tfinal String METHOD_NAME = \"getAcmeCaRootCertificate()\";\n+\t\tString url = \"https://\" + this.getContainerIpAddress() + \":\" + this.getMappedPort(MANAGEMENT_PORT) + \"/roots/0\";\n+\n+\t\ttry (CloseableHttpClient httpclient = AcmeFatUtils.getInsecureHttpsClient()) {\n+\t\t\t/*\n+\t\t\t * Create a GET request to the ACME CA server.\n+\t\t\t */\n+\t\t\tHttpGet httpGet = new HttpGet(url);\n+\n+\t\t\t/*\n+\t\t\t * Send the GET request and process the response.\n+\t\t\t */\n+\t\t\ttry (final CloseableHttpResponse response = httpclient.execute(httpGet)) {\n+\t\t\t\tAcmeFatUtils.logHttpResponse(CAContainer.class, METHOD_NAME, httpGet, response);\n+\n+\t\t\t\tStatusLine statusLine = response.getStatusLine();\n+\n+\t\t\t\tif (statusLine.getStatusCode() != 200) {\n+\t\t\t\t\tthrow new IOException(\n+\t\t\t\t\t\t\tMETHOD_NAME + \": Expected response 200, but received response: \" + statusLine);\n+\t\t\t\t}\n+\n+\t\t\t\tbyte[] result = EntityUtils.toByteArray(response.getEntity());\n+\n+\t\t\t\tLog.info(CAContainer.class, METHOD_NAME, new String(result));\n+\t\t\t\treturn result;\n+\t\t\t}\n+\t\t}\n+\t}\n+\t\n+\t/**\n+\t * Get the status of the certificate from the ACME CA server.\n+\t * \n+\t * @param certificate\n+\t *            The certificate to check.\n+\t * @return The status of the certificate.\n+\t * @throws Exception\n+\t */\n+\tpublic String getAcmeCertificateStatus(X509Certificate certificate) throws Exception {\n+\t\tfinal String METHOD_NAME = \"getAcmeCertificateStatus()\";\n+\t\tString url = \"https://\" + this.getContainerIpAddress() + \":\" + this.getMappedPort(MANAGEMENT_PORT)\n+\t\t\t\t+ \"/cert-status-by-serial/\" + certificate.getSerialNumber().toString(16);\n+\n+\t\ttry (CloseableHttpClient httpclient = AcmeFatUtils.getInsecureHttpsClient()) {\n+\t\t\t/*\n+\t\t\t * Create a GET request to the ACME CA server.\n+\t\t\t */\n+\t\t\tHttpGet httpGet = new HttpGet(url);\n+\n+\t\t\t/*\n+\t\t\t * Send the GET request and process the response.\n+\t\t\t */\n+\t\t\ttry (final CloseableHttpResponse response = httpclient.execute(httpGet)) {\n+\t\t\t\tAcmeFatUtils.logHttpResponse(CAContainer.class, METHOD_NAME, httpGet, response);\n+\n+\t\t\t\tStatusLine statusLine = response.getStatusLine();\n+\n+\t\t\t\tif (statusLine.getStatusCode() != 200) {\n+\t\t\t\t\tthrow new IOException(\n+\t\t\t\t\t\t\tMETHOD_NAME + \": Expected response 200, but received response: \" + statusLine);\n+\t\t\t\t}\n+\n+\t\t\t\tString result = EntityUtils.toString(response.getEntity());\n+\n+\t\t\t\t/*\n+\t\t\t\t * The result is in JSON, lets just parse out the status.\n+\t\t\t\t */\n+\t\t\t\tPattern p = Pattern.compile(\".*\\\"Status\\\": \\\"(\\\\w+)\\\",.*\", Pattern.DOTALL);\n+\t\t\t\tMatcher m = p.matcher(result);\n+\t\t\t\tif (m.find()) {\n+\t\t\t\t\tresult = m.group(1);\n+\t\t\t\t} else {\n+\t\t\t\t\tthrow new Exception(\n+\t\t\t\t\t\t\t\"Certificate status response was not in expected JSON format. Response: \" + result);\n+\t\t\t\t}\n+\n+\t\t\t\tLog.info(CAContainer.class, METHOD_NAME, new String(result));\n+\t\t\t\treturn result;\n+\t\t\t}\n+\t\t}\n+\t}\n+\t\n+\t/**\n+\t * Retrieves the client host's IP address that is reachable from the\n+\t * container.\n+\t * \n+\t * @return The client host's IP address that is reachable from the\n+\t *         container.\n+\t * @throws IllegalStateException\n+\t *             If the address was not found.\n+\t */\n+\tpublic String getClientHost() throws IllegalStateException {\n+\t\tfor (String extraHost : this.getExtraHosts()) {\n+\t\t\tif (extraHost.startsWith(\"host.testcontainers.internal:\")) {\n+\t\t\t\treturn extraHost.replace(\"host.testcontainers.internal:\", \"\");\n+\t\t\t}\n+\t\t}\n+\n+\t\tthrow new IllegalStateException(\n+\t\t\t\t\"Unable to resolve local host from docker container. Could not find 'host.testcontainers.internal' property.\");\n+\t}\n+\t\n+\t/**\n+\t * Add A and AAAA records.\n+\t */\n+    public void addARecords() {\n+    \ttry {\n+\t\t\tfor (String domain : new String[] { TEST_DOMAIN_1, TEST_DOMAIN_2, TEST_DOMAIN_3, TEST_DOMAIN_4 }) {\n+\t\t\t\t/*\n+\t\t\t\t * Disable the IPv6 responses for this domain. The Boulder CA server\n+\t\t\t\t * responds on AAAA (IPv6) responses before A (IPv4) responses, and\n+\t\t\t\t * we don't currently have the testcontainer host's IPv6 address.\n+\t\t\t\t */\n+\t\t\t\taddARecord(domain, getClientHost());\n+\t\t\t\taddAAAARecord(domain, \"\");\n+\t\t\t}\n+    \t} catch (Exception e) {\n+    \t\tLog.error(CAContainer.class, \"addARecords\", e);\n+    \t}\n+    }\n+    /**\n+     * Convenience method for adding A records.\n+\t * @param host", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3c28406c01e42dd902f376fac4532e84cf17aa5f"}, "originalPosition": 241}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUwODU0ODEyOnYy", "diffSide": "RIGHT", "path": "dev/com.ibm.ws.security.acme_fat/fat/src/com/ibm/ws/security/acme/docker/CAContainer.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wNlQxNzozNDozOVrOGBil0A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wNlQxNzozNDozOVrOGBil0A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDI2ODQ5Ng==", "bodyText": "whitespace", "url": "https://github.com/OpenLiberty/open-liberty/pull/11374#discussion_r404268496", "createdAt": "2020-04-06T17:34:39Z", "author": {"login": "jvanhill"}, "path": "dev/com.ibm.ws.security.acme_fat/fat/src/com/ibm/ws/security/acme/docker/CAContainer.java", "diffHunk": "@@ -0,0 +1,442 @@\n+/*******************************************************************************\n+ * Copyright (c) 2019, 2020 IBM Corporation and others.\n+ * All rights reserved. This program and the accompanying materials\n+ * are made available under the terms of the Eclipse Public License v1.0\n+ * which accompanies this distribution, and is available at\n+ * http://www.eclipse.org/legal/epl-v10.html\n+ *\n+ * Contributors:\n+ *     IBM Corporation - initial API and implementation\n+ *******************************************************************************/\n+package com.ibm.ws.security.acme.docker;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.security.cert.X509Certificate;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import org.apache.http.StatusLine;\n+import org.apache.http.client.methods.CloseableHttpResponse;\n+import org.apache.http.client.methods.HttpGet;\n+import org.apache.http.client.methods.HttpPost;\n+import org.apache.http.entity.ContentType;\n+import org.apache.http.entity.StringEntity;\n+import org.apache.http.impl.client.CloseableHttpClient;\n+import org.apache.http.impl.client.HttpClients;\n+import org.apache.http.util.EntityUtils;\n+import org.testcontainers.containers.GenericContainer;\n+import org.testcontainers.images.builder.ImageFromDockerfile;\n+\n+import com.ibm.websphere.simplicity.log.Log;\n+import com.ibm.ws.security.acme.utils.AcmeFatUtils;\n+\n+/**\n+ * Testcontainer implementation for Pebble and Boulder Certificate Authorities.\n+ * \n+ */\n+public class CAContainer extends GenericContainer<CAContainer> {\n+\n+\tprivate static final String TEST_DOMAIN_1 = \"domain1.com\";\n+\tprivate static final String TEST_DOMAIN_2 = \"domain2.com\";\n+\tprivate static final String TEST_DOMAIN_3 = \"domain3.com\";\n+\tprivate static final String TEST_DOMAIN_4 = \"domain4.com\";\n+\t\n+\t/** Challenge server port. */\n+\tpublic static final int HTTP_PORT = 5002;\n+\t/** The REST management API port. */\n+\tpublic int MANAGEMENT_PORT = 8055;\n+\t\n+\t/**\n+\t * This constructor is used by BoulderContainer\n+\t */\n+\tpublic CAContainer(String image) {\n+\t\tsuper(image);\n+\t}\n+\n+\t/**\n+\t * This constructor is used by PebbleContainer. The\n+\t * management port is different for Pebble, so this\n+\t * is passed in.\n+\t */\n+\tpublic CAContainer(ImageFromDockerfile image, int managementPort) {\n+\t\tsuper(image);\n+\t\tMANAGEMENT_PORT = managementPort;\n+\t}\n+\n+\t/**\n+\t * Get CA's intermediate certificate.\n+\t * \n+\t * @param fileName\n+\t *            The name of the file to save the certificate to.\n+\t * @return CA's intermediate certificate in the form of a PEM file.\n+\t * @throws Exception\n+\t *             If we failed to receive the certificate.\n+\t */\n+\tpublic InputStream getAcmeCaIntermediateCertificate() throws Exception {\n+\t\tfinal String METHOD_NAME = \"getAcmeCaIntermediateCertificate()\";\n+\t\tString url = \"https://\" + this.getContainerIpAddress() + \":\" + this.getMappedPort(MANAGEMENT_PORT)\n+\t\t\t\t+ \"/intermediates/0\";\n+\n+\t\ttry (CloseableHttpClient httpclient = AcmeFatUtils.getInsecureHttpsClient()) {\n+\t\t\t/*\n+\t\t\t * Create a GET request to the ACME CA server.\n+\t\t\t */\n+\t\t\tHttpGet httpGet = new HttpGet(url);\n+\n+\t\t\t/*\n+\t\t\t * Send the GET request and process the response.\n+\t\t\t */\n+\t\t\ttry (final CloseableHttpResponse response = httpclient.execute(httpGet)) {\n+\t\t\t\tAcmeFatUtils.logHttpResponse(CAContainer.class, METHOD_NAME, httpGet, response);\n+\n+\t\t\t\tStatusLine statusLine = response.getStatusLine();\n+\n+\t\t\t\tif (statusLine.getStatusCode() != 200) {\n+\t\t\t\t\tthrow new IOException(\n+\t\t\t\t\t\t\tMETHOD_NAME + \": Expected response 200, but received response: \" + statusLine);\n+\t\t\t\t}\n+\n+\t\t\t\tbyte[] result = EntityUtils.toByteArray(response.getEntity());\n+\n+\t\t\t\tLog.info(CAContainer.class, METHOD_NAME, new String(result));\n+\t\t\t\treturn  new ByteArrayInputStream(result);\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Get the root certificate.\n+\t * \n+\t * @param fileName\n+\t *            The name of the file to save the certificate to.\n+\t * @return Certificate Authority's root certificate in the form of a PEM file.\n+\t * @throws Exception\n+\t *             If we failed to receive the certificate.\n+\t */\n+\tpublic byte[] getAcmeCaRootCertificate() throws Exception {\n+\t\tfinal String METHOD_NAME = \"getAcmeCaRootCertificate()\";\n+\t\tString url = \"https://\" + this.getContainerIpAddress() + \":\" + this.getMappedPort(MANAGEMENT_PORT) + \"/roots/0\";\n+\n+\t\ttry (CloseableHttpClient httpclient = AcmeFatUtils.getInsecureHttpsClient()) {\n+\t\t\t/*\n+\t\t\t * Create a GET request to the ACME CA server.\n+\t\t\t */\n+\t\t\tHttpGet httpGet = new HttpGet(url);\n+\n+\t\t\t/*\n+\t\t\t * Send the GET request and process the response.\n+\t\t\t */\n+\t\t\ttry (final CloseableHttpResponse response = httpclient.execute(httpGet)) {\n+\t\t\t\tAcmeFatUtils.logHttpResponse(CAContainer.class, METHOD_NAME, httpGet, response);\n+\n+\t\t\t\tStatusLine statusLine = response.getStatusLine();\n+\n+\t\t\t\tif (statusLine.getStatusCode() != 200) {\n+\t\t\t\t\tthrow new IOException(\n+\t\t\t\t\t\t\tMETHOD_NAME + \": Expected response 200, but received response: \" + statusLine);\n+\t\t\t\t}\n+\n+\t\t\t\tbyte[] result = EntityUtils.toByteArray(response.getEntity());\n+\n+\t\t\t\tLog.info(CAContainer.class, METHOD_NAME, new String(result));\n+\t\t\t\treturn result;\n+\t\t\t}\n+\t\t}\n+\t}\n+\t\n+\t/**\n+\t * Get the status of the certificate from the ACME CA server.\n+\t * \n+\t * @param certificate\n+\t *            The certificate to check.\n+\t * @return The status of the certificate.\n+\t * @throws Exception\n+\t */\n+\tpublic String getAcmeCertificateStatus(X509Certificate certificate) throws Exception {\n+\t\tfinal String METHOD_NAME = \"getAcmeCertificateStatus()\";\n+\t\tString url = \"https://\" + this.getContainerIpAddress() + \":\" + this.getMappedPort(MANAGEMENT_PORT)\n+\t\t\t\t+ \"/cert-status-by-serial/\" + certificate.getSerialNumber().toString(16);\n+\n+\t\ttry (CloseableHttpClient httpclient = AcmeFatUtils.getInsecureHttpsClient()) {\n+\t\t\t/*\n+\t\t\t * Create a GET request to the ACME CA server.\n+\t\t\t */\n+\t\t\tHttpGet httpGet = new HttpGet(url);\n+\n+\t\t\t/*\n+\t\t\t * Send the GET request and process the response.\n+\t\t\t */\n+\t\t\ttry (final CloseableHttpResponse response = httpclient.execute(httpGet)) {\n+\t\t\t\tAcmeFatUtils.logHttpResponse(CAContainer.class, METHOD_NAME, httpGet, response);\n+\n+\t\t\t\tStatusLine statusLine = response.getStatusLine();\n+\n+\t\t\t\tif (statusLine.getStatusCode() != 200) {\n+\t\t\t\t\tthrow new IOException(\n+\t\t\t\t\t\t\tMETHOD_NAME + \": Expected response 200, but received response: \" + statusLine);\n+\t\t\t\t}\n+\n+\t\t\t\tString result = EntityUtils.toString(response.getEntity());\n+\n+\t\t\t\t/*\n+\t\t\t\t * The result is in JSON, lets just parse out the status.\n+\t\t\t\t */\n+\t\t\t\tPattern p = Pattern.compile(\".*\\\"Status\\\": \\\"(\\\\w+)\\\",.*\", Pattern.DOTALL);\n+\t\t\t\tMatcher m = p.matcher(result);\n+\t\t\t\tif (m.find()) {\n+\t\t\t\t\tresult = m.group(1);\n+\t\t\t\t} else {\n+\t\t\t\t\tthrow new Exception(\n+\t\t\t\t\t\t\t\"Certificate status response was not in expected JSON format. Response: \" + result);\n+\t\t\t\t}\n+\n+\t\t\t\tLog.info(CAContainer.class, METHOD_NAME, new String(result));\n+\t\t\t\treturn result;\n+\t\t\t}\n+\t\t}\n+\t}\n+\t\n+\t/**\n+\t * Retrieves the client host's IP address that is reachable from the\n+\t * container.\n+\t * \n+\t * @return The client host's IP address that is reachable from the\n+\t *         container.\n+\t * @throws IllegalStateException\n+\t *             If the address was not found.\n+\t */\n+\tpublic String getClientHost() throws IllegalStateException {\n+\t\tfor (String extraHost : this.getExtraHosts()) {\n+\t\t\tif (extraHost.startsWith(\"host.testcontainers.internal:\")) {\n+\t\t\t\treturn extraHost.replace(\"host.testcontainers.internal:\", \"\");\n+\t\t\t}\n+\t\t}\n+\n+\t\tthrow new IllegalStateException(\n+\t\t\t\t\"Unable to resolve local host from docker container. Could not find 'host.testcontainers.internal' property.\");\n+\t}\n+\t\n+\t/**\n+\t * Add A and AAAA records.\n+\t */\n+    public void addARecords() {\n+    \ttry {\n+\t\t\tfor (String domain : new String[] { TEST_DOMAIN_1, TEST_DOMAIN_2, TEST_DOMAIN_3, TEST_DOMAIN_4 }) {\n+\t\t\t\t/*\n+\t\t\t\t * Disable the IPv6 responses for this domain. The Boulder CA server\n+\t\t\t\t * responds on AAAA (IPv6) responses before A (IPv4) responses, and\n+\t\t\t\t * we don't currently have the testcontainer host's IPv6 address.\n+\t\t\t\t */\n+\t\t\t\taddARecord(domain, getClientHost());\n+\t\t\t\taddAAAARecord(domain, \"\");\n+\t\t\t}\n+    \t} catch (Exception e) {\n+    \t\tLog.error(CAContainer.class, \"addARecords\", e);\n+    \t}\n+    }\n+    /**\n+     * Convenience method for adding A records.\n+\t * @param host\n+\t *            The host / domain to redirect requests for.\n+     */\n+\tpublic void addARecord(String domain) throws IOException {\n+\t\taddARecord(domain, getClientHost());\n+\t}\n+\t/**", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3c28406c01e42dd902f376fac4532e84cf17aa5f"}, "originalPosition": 247}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUwODU1MDgzOnYy", "diffSide": "RIGHT", "path": "dev/com.ibm.ws.security.acme_fat/fat/src/com/ibm/ws/security/acme/docker/CAContainer.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wNlQxNzozNToxNlrOGBindA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wNlQxNzozNToxNlrOGBindA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDI2ODkxNg==", "bodyText": "whitespace", "url": "https://github.com/OpenLiberty/open-liberty/pull/11374#discussion_r404268916", "createdAt": "2020-04-06T17:35:16Z", "author": {"login": "jvanhill"}, "path": "dev/com.ibm.ws.security.acme_fat/fat/src/com/ibm/ws/security/acme/docker/CAContainer.java", "diffHunk": "@@ -0,0 +1,442 @@\n+/*******************************************************************************\n+ * Copyright (c) 2019, 2020 IBM Corporation and others.\n+ * All rights reserved. This program and the accompanying materials\n+ * are made available under the terms of the Eclipse Public License v1.0\n+ * which accompanies this distribution, and is available at\n+ * http://www.eclipse.org/legal/epl-v10.html\n+ *\n+ * Contributors:\n+ *     IBM Corporation - initial API and implementation\n+ *******************************************************************************/\n+package com.ibm.ws.security.acme.docker;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.security.cert.X509Certificate;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import org.apache.http.StatusLine;\n+import org.apache.http.client.methods.CloseableHttpResponse;\n+import org.apache.http.client.methods.HttpGet;\n+import org.apache.http.client.methods.HttpPost;\n+import org.apache.http.entity.ContentType;\n+import org.apache.http.entity.StringEntity;\n+import org.apache.http.impl.client.CloseableHttpClient;\n+import org.apache.http.impl.client.HttpClients;\n+import org.apache.http.util.EntityUtils;\n+import org.testcontainers.containers.GenericContainer;\n+import org.testcontainers.images.builder.ImageFromDockerfile;\n+\n+import com.ibm.websphere.simplicity.log.Log;\n+import com.ibm.ws.security.acme.utils.AcmeFatUtils;\n+\n+/**\n+ * Testcontainer implementation for Pebble and Boulder Certificate Authorities.\n+ * \n+ */\n+public class CAContainer extends GenericContainer<CAContainer> {\n+\n+\tprivate static final String TEST_DOMAIN_1 = \"domain1.com\";\n+\tprivate static final String TEST_DOMAIN_2 = \"domain2.com\";\n+\tprivate static final String TEST_DOMAIN_3 = \"domain3.com\";\n+\tprivate static final String TEST_DOMAIN_4 = \"domain4.com\";\n+\t\n+\t/** Challenge server port. */\n+\tpublic static final int HTTP_PORT = 5002;\n+\t/** The REST management API port. */\n+\tpublic int MANAGEMENT_PORT = 8055;\n+\t\n+\t/**\n+\t * This constructor is used by BoulderContainer\n+\t */\n+\tpublic CAContainer(String image) {\n+\t\tsuper(image);\n+\t}\n+\n+\t/**\n+\t * This constructor is used by PebbleContainer. The\n+\t * management port is different for Pebble, so this\n+\t * is passed in.\n+\t */\n+\tpublic CAContainer(ImageFromDockerfile image, int managementPort) {\n+\t\tsuper(image);\n+\t\tMANAGEMENT_PORT = managementPort;\n+\t}\n+\n+\t/**\n+\t * Get CA's intermediate certificate.\n+\t * \n+\t * @param fileName\n+\t *            The name of the file to save the certificate to.\n+\t * @return CA's intermediate certificate in the form of a PEM file.\n+\t * @throws Exception\n+\t *             If we failed to receive the certificate.\n+\t */\n+\tpublic InputStream getAcmeCaIntermediateCertificate() throws Exception {\n+\t\tfinal String METHOD_NAME = \"getAcmeCaIntermediateCertificate()\";\n+\t\tString url = \"https://\" + this.getContainerIpAddress() + \":\" + this.getMappedPort(MANAGEMENT_PORT)\n+\t\t\t\t+ \"/intermediates/0\";\n+\n+\t\ttry (CloseableHttpClient httpclient = AcmeFatUtils.getInsecureHttpsClient()) {\n+\t\t\t/*\n+\t\t\t * Create a GET request to the ACME CA server.\n+\t\t\t */\n+\t\t\tHttpGet httpGet = new HttpGet(url);\n+\n+\t\t\t/*\n+\t\t\t * Send the GET request and process the response.\n+\t\t\t */\n+\t\t\ttry (final CloseableHttpResponse response = httpclient.execute(httpGet)) {\n+\t\t\t\tAcmeFatUtils.logHttpResponse(CAContainer.class, METHOD_NAME, httpGet, response);\n+\n+\t\t\t\tStatusLine statusLine = response.getStatusLine();\n+\n+\t\t\t\tif (statusLine.getStatusCode() != 200) {\n+\t\t\t\t\tthrow new IOException(\n+\t\t\t\t\t\t\tMETHOD_NAME + \": Expected response 200, but received response: \" + statusLine);\n+\t\t\t\t}\n+\n+\t\t\t\tbyte[] result = EntityUtils.toByteArray(response.getEntity());\n+\n+\t\t\t\tLog.info(CAContainer.class, METHOD_NAME, new String(result));\n+\t\t\t\treturn  new ByteArrayInputStream(result);\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Get the root certificate.\n+\t * \n+\t * @param fileName\n+\t *            The name of the file to save the certificate to.\n+\t * @return Certificate Authority's root certificate in the form of a PEM file.\n+\t * @throws Exception\n+\t *             If we failed to receive the certificate.\n+\t */\n+\tpublic byte[] getAcmeCaRootCertificate() throws Exception {\n+\t\tfinal String METHOD_NAME = \"getAcmeCaRootCertificate()\";\n+\t\tString url = \"https://\" + this.getContainerIpAddress() + \":\" + this.getMappedPort(MANAGEMENT_PORT) + \"/roots/0\";\n+\n+\t\ttry (CloseableHttpClient httpclient = AcmeFatUtils.getInsecureHttpsClient()) {\n+\t\t\t/*\n+\t\t\t * Create a GET request to the ACME CA server.\n+\t\t\t */\n+\t\t\tHttpGet httpGet = new HttpGet(url);\n+\n+\t\t\t/*\n+\t\t\t * Send the GET request and process the response.\n+\t\t\t */\n+\t\t\ttry (final CloseableHttpResponse response = httpclient.execute(httpGet)) {\n+\t\t\t\tAcmeFatUtils.logHttpResponse(CAContainer.class, METHOD_NAME, httpGet, response);\n+\n+\t\t\t\tStatusLine statusLine = response.getStatusLine();\n+\n+\t\t\t\tif (statusLine.getStatusCode() != 200) {\n+\t\t\t\t\tthrow new IOException(\n+\t\t\t\t\t\t\tMETHOD_NAME + \": Expected response 200, but received response: \" + statusLine);\n+\t\t\t\t}\n+\n+\t\t\t\tbyte[] result = EntityUtils.toByteArray(response.getEntity());\n+\n+\t\t\t\tLog.info(CAContainer.class, METHOD_NAME, new String(result));\n+\t\t\t\treturn result;\n+\t\t\t}\n+\t\t}\n+\t}\n+\t\n+\t/**\n+\t * Get the status of the certificate from the ACME CA server.\n+\t * \n+\t * @param certificate\n+\t *            The certificate to check.\n+\t * @return The status of the certificate.\n+\t * @throws Exception\n+\t */\n+\tpublic String getAcmeCertificateStatus(X509Certificate certificate) throws Exception {\n+\t\tfinal String METHOD_NAME = \"getAcmeCertificateStatus()\";\n+\t\tString url = \"https://\" + this.getContainerIpAddress() + \":\" + this.getMappedPort(MANAGEMENT_PORT)\n+\t\t\t\t+ \"/cert-status-by-serial/\" + certificate.getSerialNumber().toString(16);\n+\n+\t\ttry (CloseableHttpClient httpclient = AcmeFatUtils.getInsecureHttpsClient()) {\n+\t\t\t/*\n+\t\t\t * Create a GET request to the ACME CA server.\n+\t\t\t */\n+\t\t\tHttpGet httpGet = new HttpGet(url);\n+\n+\t\t\t/*\n+\t\t\t * Send the GET request and process the response.\n+\t\t\t */\n+\t\t\ttry (final CloseableHttpResponse response = httpclient.execute(httpGet)) {\n+\t\t\t\tAcmeFatUtils.logHttpResponse(CAContainer.class, METHOD_NAME, httpGet, response);\n+\n+\t\t\t\tStatusLine statusLine = response.getStatusLine();\n+\n+\t\t\t\tif (statusLine.getStatusCode() != 200) {\n+\t\t\t\t\tthrow new IOException(\n+\t\t\t\t\t\t\tMETHOD_NAME + \": Expected response 200, but received response: \" + statusLine);\n+\t\t\t\t}\n+\n+\t\t\t\tString result = EntityUtils.toString(response.getEntity());\n+\n+\t\t\t\t/*\n+\t\t\t\t * The result is in JSON, lets just parse out the status.\n+\t\t\t\t */\n+\t\t\t\tPattern p = Pattern.compile(\".*\\\"Status\\\": \\\"(\\\\w+)\\\",.*\", Pattern.DOTALL);\n+\t\t\t\tMatcher m = p.matcher(result);\n+\t\t\t\tif (m.find()) {\n+\t\t\t\t\tresult = m.group(1);\n+\t\t\t\t} else {\n+\t\t\t\t\tthrow new Exception(\n+\t\t\t\t\t\t\t\"Certificate status response was not in expected JSON format. Response: \" + result);\n+\t\t\t\t}\n+\n+\t\t\t\tLog.info(CAContainer.class, METHOD_NAME, new String(result));\n+\t\t\t\treturn result;\n+\t\t\t}\n+\t\t}\n+\t}\n+\t\n+\t/**\n+\t * Retrieves the client host's IP address that is reachable from the\n+\t * container.\n+\t * \n+\t * @return The client host's IP address that is reachable from the\n+\t *         container.\n+\t * @throws IllegalStateException\n+\t *             If the address was not found.\n+\t */\n+\tpublic String getClientHost() throws IllegalStateException {\n+\t\tfor (String extraHost : this.getExtraHosts()) {\n+\t\t\tif (extraHost.startsWith(\"host.testcontainers.internal:\")) {\n+\t\t\t\treturn extraHost.replace(\"host.testcontainers.internal:\", \"\");\n+\t\t\t}\n+\t\t}\n+\n+\t\tthrow new IllegalStateException(\n+\t\t\t\t\"Unable to resolve local host from docker container. Could not find 'host.testcontainers.internal' property.\");\n+\t}\n+\t\n+\t/**\n+\t * Add A and AAAA records.\n+\t */\n+    public void addARecords() {\n+    \ttry {\n+\t\t\tfor (String domain : new String[] { TEST_DOMAIN_1, TEST_DOMAIN_2, TEST_DOMAIN_3, TEST_DOMAIN_4 }) {\n+\t\t\t\t/*\n+\t\t\t\t * Disable the IPv6 responses for this domain. The Boulder CA server\n+\t\t\t\t * responds on AAAA (IPv6) responses before A (IPv4) responses, and\n+\t\t\t\t * we don't currently have the testcontainer host's IPv6 address.\n+\t\t\t\t */\n+\t\t\t\taddARecord(domain, getClientHost());\n+\t\t\t\taddAAAARecord(domain, \"\");\n+\t\t\t}\n+    \t} catch (Exception e) {\n+    \t\tLog.error(CAContainer.class, \"addARecords\", e);\n+    \t}\n+    }\n+    /**\n+     * Convenience method for adding A records.\n+\t * @param host\n+\t *            The host / domain to redirect requests for.\n+     */\n+\tpublic void addARecord(String domain) throws IOException {\n+\t\taddARecord(domain, getClientHost());\n+\t}\n+\t/**\n+\t * Add an A record to the mock DNS server. This will allow us to redirect\n+\t * requests to a named domain to the IPv4 address of our choice.\n+\t * \n+\t * @param host\n+\t *            The host / domain to redirect requests for.\n+\t * @param address\n+\t *            The address to direct the requests for that host to.\n+\t * @throws IOException\n+\t */\n+\tpublic void addARecord(String host, String address) throws IOException {\n+\t\tfinal String METHOD_NAME = \"addARecord\";\n+\n+\t\ttry (CloseableHttpClient httpclient = HttpClients.createDefault()) {\n+\n+\t\t\t/*\n+\t\t\t * Generate the JSON request. The request can support multiple\n+\t\t\t * addresses but for the time being we will only support sending\n+\t\t\t * one.\n+\t\t\t */\n+\t\t\tString jsonString = \"{\\\"host\\\":\\\"\" + host + \"\\\",\\\"addresses\\\":[\\\"\" + address + \"\\\"]}\";\n+\t\t\tStringEntity requestEntity = new StringEntity(jsonString, ContentType.APPLICATION_JSON);\n+\n+\t\t\t/*\n+\t\t\t * Create a POST request to the mock DNS server.\n+\t\t\t */\n+\t\t\tHttpPost httpPost = new HttpPost(getManagementAddress() + \"/add-a\");\n+\t\t\thttpPost.setEntity(requestEntity);\n+\t\t\t/*\n+\t\t\t * Send the POST request and process the response.\n+\t\t\t */\n+\t\t\ttry (final CloseableHttpResponse response = httpclient.execute(httpPost)) {\n+\t\t\t\tAcmeFatUtils.logHttpResponse(CAContainer.class, METHOD_NAME, httpPost, response);\n+\n+\t\t\t\tStatusLine statusLine = response.getStatusLine();\n+\t\t\t\tif (statusLine.getStatusCode() != 200) {\n+\t\t\t\t\tthrow new IOException(\n+\t\t\t\t\t\t\tMETHOD_NAME + \": Expected response 200, but received response: \" + statusLine);\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t}\n+\t\n+\t/**\n+\t * Add an AAAA record to the mock DNS server. This will allow us to redirect\n+\t * requests to a named domain to the IPv6 address of our choice.\n+\t * \n+\t * @param host\n+\t *            The host / domain to redirect requests for.\n+\t * @param address\n+\t *            The address to direct the requests for that host to.\n+\t * @throws IOException\n+\t */\n+\tpublic void addAAAARecord(String host, String address) throws IOException {\n+\t\tfinal String METHOD_NAME = \"addAAAARecord\";\n+\n+\t\ttry (CloseableHttpClient httpclient = HttpClients.createDefault()) {\n+\n+\t\t\t/*\n+\t\t\t * Generate the JSON request. The request can support multiple\n+\t\t\t * addresses but for the time being we will only support sending\n+\t\t\t * one.\n+\t\t\t */\n+\t\t\tString jsonString = \"{\\\"host\\\":\\\"\" + host + \"\\\",\\\"addresses\\\":[\\\"\" + address + \"\\\"]}\";\n+\t\t\tStringEntity requestEntity = new StringEntity(jsonString, ContentType.APPLICATION_JSON);\n+\n+\t\t\t/*\n+\t\t\t * Create a POST request to the mock DNS server.\n+\t\t\t */\n+\t\t\tHttpPost httpPost = new HttpPost(getManagementAddress() + \"/add-aaaa\");\n+\t\t\thttpPost.setEntity(requestEntity);\n+\n+\t\t\t/*\n+\t\t\t * Send the POST request and process the response.\n+\t\t\t */\n+\t\t\ttry (final CloseableHttpResponse response = httpclient.execute(httpPost)) {\n+\t\t\t\tAcmeFatUtils.logHttpResponse(CAContainer.class, METHOD_NAME, httpPost, response);\n+\n+\t\t\t\tStatusLine statusLine = response.getStatusLine();\n+\t\t\t\tif (statusLine.getStatusCode() != 200) {\n+\t\t\t\t\tthrow new IOException(\n+\t\t\t\t\t\t\tMETHOD_NAME + \": Expected response 200, but received response: \" + statusLine);\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t}\n+\t/**\n+\t * Clear a previously added AAAA record that was added to the mock DNS\n+\t * server.\n+\t * \n+\t * @param host\n+\t *            The host / domain to redirect requests for.\n+\t * @throws IOException\n+\t */\n+\tpublic void clearAAAARecord(String host) throws IOException {\n+\t\tfinal String METHOD_NAME = \"clearAAAARecord(String)\";\n+\n+\t\ttry (CloseableHttpClient httpclient = HttpClients.createDefault()) {\n+\t\t\t/*\n+\t\t\t * Generate the JSON request.\n+\t\t\t */\n+\t\t\tString jsonString = \"{\\\"host\\\":\\\"\" + host + \"\\\"}\";\n+\t\t\tStringEntity requestEntity = new StringEntity(jsonString, ContentType.APPLICATION_JSON);\n+\n+\t\t\t/*\n+\t\t\t * Create a POST request to the mock DNS server.\n+\t\t\t */\n+\t\t\tHttpPost httpPost = new HttpPost(getManagementAddress() + \"/clear-aaaa\");\n+\t\t\thttpPost.setEntity(requestEntity);\n+\n+\t\t\t/*\n+\t\t\t * Send the POST request and process the response.\n+\t\t\t */\n+\t\t\ttry (final CloseableHttpResponse response = httpclient.execute(httpPost)) {\n+\t\t\t\tAcmeFatUtils.logHttpResponse(CAContainer.class, METHOD_NAME, httpPost, response);\n+\n+\t\t\t\tStatusLine statusLine = response.getStatusLine();\n+\t\t\t\tif (statusLine.getStatusCode() != 200) {\n+\t\t\t\t\tthrow new IOException(\n+\t\t\t\t\t\t\tMETHOD_NAME + \": Expected response 200, but received response: \" + statusLine);\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Clear a previously added A record that was added to the mock DNS server.\n+\t * \n+\t * @param host\n+\t *            The host / domain to redirect requests for.\n+\t * @throws IOException\n+\t */\n+\tpublic void clearARecord(String host) throws IOException {\n+\t\tfinal String METHOD_NAME = \"clearMockARecord(String)\";\n+\n+\t\ttry (CloseableHttpClient httpclient = HttpClients.createDefault()) {\n+\t\t\t/*\n+\t\t\t * Generate the JSON request.\n+\t\t\t */\n+\t\t\tString jsonString = \"{\\\"host\\\":\\\"\" + host + \"\\\"}\";\n+\t\t\tStringEntity requestEntity = new StringEntity(jsonString, ContentType.APPLICATION_JSON);\n+\n+\t\t\t/*\n+\t\t\t * Create a POST request to the mock DNS server.\n+\t\t\t */\n+\t\t\tHttpPost httpPost = new HttpPost(getManagementAddress() + \"/clear-a\");\n+\t\t\thttpPost.setEntity(requestEntity);\n+\n+\t\t\t/*\n+\t\t\t * Send the POST request and process the response.\n+\t\t\t */\n+\t\t\ttry (final CloseableHttpResponse response = httpclient.execute(httpPost)) {\n+\t\t\t\tAcmeFatUtils.logHttpResponse(CAContainer.class, METHOD_NAME, httpPost, response);\n+\n+\t\t\t\tStatusLine statusLine = response.getStatusLine();\n+\t\t\t\tif (statusLine.getStatusCode() != 200) {\n+\t\t\t\t\tthrow new IOException(\n+\t\t\t\t\t\t\tMETHOD_NAME + \": Expected response 200, but received response: \" + statusLine);\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t}\n+\t/**", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3c28406c01e42dd902f376fac4532e84cf17aa5f"}, "originalPosition": 409}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUwODU1MTkyOnYy", "diffSide": "RIGHT", "path": "dev/com.ibm.ws.security.acme_fat/fat/src/com/ibm/ws/security/acme/docker/CAContainer.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wNlQxNzozNTozNVrOGBioNg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wNlQxNzozNTozNVrOGBioNg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDI2OTExMA==", "bodyText": "whitespace", "url": "https://github.com/OpenLiberty/open-liberty/pull/11374#discussion_r404269110", "createdAt": "2020-04-06T17:35:35Z", "author": {"login": "jvanhill"}, "path": "dev/com.ibm.ws.security.acme_fat/fat/src/com/ibm/ws/security/acme/docker/CAContainer.java", "diffHunk": "@@ -0,0 +1,442 @@\n+/*******************************************************************************\n+ * Copyright (c) 2019, 2020 IBM Corporation and others.\n+ * All rights reserved. This program and the accompanying materials\n+ * are made available under the terms of the Eclipse Public License v1.0\n+ * which accompanies this distribution, and is available at\n+ * http://www.eclipse.org/legal/epl-v10.html\n+ *\n+ * Contributors:\n+ *     IBM Corporation - initial API and implementation\n+ *******************************************************************************/\n+package com.ibm.ws.security.acme.docker;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.security.cert.X509Certificate;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import org.apache.http.StatusLine;\n+import org.apache.http.client.methods.CloseableHttpResponse;\n+import org.apache.http.client.methods.HttpGet;\n+import org.apache.http.client.methods.HttpPost;\n+import org.apache.http.entity.ContentType;\n+import org.apache.http.entity.StringEntity;\n+import org.apache.http.impl.client.CloseableHttpClient;\n+import org.apache.http.impl.client.HttpClients;\n+import org.apache.http.util.EntityUtils;\n+import org.testcontainers.containers.GenericContainer;\n+import org.testcontainers.images.builder.ImageFromDockerfile;\n+\n+import com.ibm.websphere.simplicity.log.Log;\n+import com.ibm.ws.security.acme.utils.AcmeFatUtils;\n+\n+/**\n+ * Testcontainer implementation for Pebble and Boulder Certificate Authorities.\n+ * \n+ */\n+public class CAContainer extends GenericContainer<CAContainer> {\n+\n+\tprivate static final String TEST_DOMAIN_1 = \"domain1.com\";\n+\tprivate static final String TEST_DOMAIN_2 = \"domain2.com\";\n+\tprivate static final String TEST_DOMAIN_3 = \"domain3.com\";\n+\tprivate static final String TEST_DOMAIN_4 = \"domain4.com\";\n+\t\n+\t/** Challenge server port. */\n+\tpublic static final int HTTP_PORT = 5002;\n+\t/** The REST management API port. */\n+\tpublic int MANAGEMENT_PORT = 8055;\n+\t\n+\t/**\n+\t * This constructor is used by BoulderContainer\n+\t */\n+\tpublic CAContainer(String image) {\n+\t\tsuper(image);\n+\t}\n+\n+\t/**\n+\t * This constructor is used by PebbleContainer. The\n+\t * management port is different for Pebble, so this\n+\t * is passed in.\n+\t */\n+\tpublic CAContainer(ImageFromDockerfile image, int managementPort) {\n+\t\tsuper(image);\n+\t\tMANAGEMENT_PORT = managementPort;\n+\t}\n+\n+\t/**\n+\t * Get CA's intermediate certificate.\n+\t * \n+\t * @param fileName\n+\t *            The name of the file to save the certificate to.\n+\t * @return CA's intermediate certificate in the form of a PEM file.\n+\t * @throws Exception\n+\t *             If we failed to receive the certificate.\n+\t */\n+\tpublic InputStream getAcmeCaIntermediateCertificate() throws Exception {\n+\t\tfinal String METHOD_NAME = \"getAcmeCaIntermediateCertificate()\";\n+\t\tString url = \"https://\" + this.getContainerIpAddress() + \":\" + this.getMappedPort(MANAGEMENT_PORT)\n+\t\t\t\t+ \"/intermediates/0\";\n+\n+\t\ttry (CloseableHttpClient httpclient = AcmeFatUtils.getInsecureHttpsClient()) {\n+\t\t\t/*\n+\t\t\t * Create a GET request to the ACME CA server.\n+\t\t\t */\n+\t\t\tHttpGet httpGet = new HttpGet(url);\n+\n+\t\t\t/*\n+\t\t\t * Send the GET request and process the response.\n+\t\t\t */\n+\t\t\ttry (final CloseableHttpResponse response = httpclient.execute(httpGet)) {\n+\t\t\t\tAcmeFatUtils.logHttpResponse(CAContainer.class, METHOD_NAME, httpGet, response);\n+\n+\t\t\t\tStatusLine statusLine = response.getStatusLine();\n+\n+\t\t\t\tif (statusLine.getStatusCode() != 200) {\n+\t\t\t\t\tthrow new IOException(\n+\t\t\t\t\t\t\tMETHOD_NAME + \": Expected response 200, but received response: \" + statusLine);\n+\t\t\t\t}\n+\n+\t\t\t\tbyte[] result = EntityUtils.toByteArray(response.getEntity());\n+\n+\t\t\t\tLog.info(CAContainer.class, METHOD_NAME, new String(result));\n+\t\t\t\treturn  new ByteArrayInputStream(result);\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Get the root certificate.\n+\t * \n+\t * @param fileName\n+\t *            The name of the file to save the certificate to.\n+\t * @return Certificate Authority's root certificate in the form of a PEM file.\n+\t * @throws Exception\n+\t *             If we failed to receive the certificate.\n+\t */\n+\tpublic byte[] getAcmeCaRootCertificate() throws Exception {\n+\t\tfinal String METHOD_NAME = \"getAcmeCaRootCertificate()\";\n+\t\tString url = \"https://\" + this.getContainerIpAddress() + \":\" + this.getMappedPort(MANAGEMENT_PORT) + \"/roots/0\";\n+\n+\t\ttry (CloseableHttpClient httpclient = AcmeFatUtils.getInsecureHttpsClient()) {\n+\t\t\t/*\n+\t\t\t * Create a GET request to the ACME CA server.\n+\t\t\t */\n+\t\t\tHttpGet httpGet = new HttpGet(url);\n+\n+\t\t\t/*\n+\t\t\t * Send the GET request and process the response.\n+\t\t\t */\n+\t\t\ttry (final CloseableHttpResponse response = httpclient.execute(httpGet)) {\n+\t\t\t\tAcmeFatUtils.logHttpResponse(CAContainer.class, METHOD_NAME, httpGet, response);\n+\n+\t\t\t\tStatusLine statusLine = response.getStatusLine();\n+\n+\t\t\t\tif (statusLine.getStatusCode() != 200) {\n+\t\t\t\t\tthrow new IOException(\n+\t\t\t\t\t\t\tMETHOD_NAME + \": Expected response 200, but received response: \" + statusLine);\n+\t\t\t\t}\n+\n+\t\t\t\tbyte[] result = EntityUtils.toByteArray(response.getEntity());\n+\n+\t\t\t\tLog.info(CAContainer.class, METHOD_NAME, new String(result));\n+\t\t\t\treturn result;\n+\t\t\t}\n+\t\t}\n+\t}\n+\t\n+\t/**\n+\t * Get the status of the certificate from the ACME CA server.\n+\t * \n+\t * @param certificate\n+\t *            The certificate to check.\n+\t * @return The status of the certificate.\n+\t * @throws Exception\n+\t */\n+\tpublic String getAcmeCertificateStatus(X509Certificate certificate) throws Exception {\n+\t\tfinal String METHOD_NAME = \"getAcmeCertificateStatus()\";\n+\t\tString url = \"https://\" + this.getContainerIpAddress() + \":\" + this.getMappedPort(MANAGEMENT_PORT)\n+\t\t\t\t+ \"/cert-status-by-serial/\" + certificate.getSerialNumber().toString(16);\n+\n+\t\ttry (CloseableHttpClient httpclient = AcmeFatUtils.getInsecureHttpsClient()) {\n+\t\t\t/*\n+\t\t\t * Create a GET request to the ACME CA server.\n+\t\t\t */\n+\t\t\tHttpGet httpGet = new HttpGet(url);\n+\n+\t\t\t/*\n+\t\t\t * Send the GET request and process the response.\n+\t\t\t */\n+\t\t\ttry (final CloseableHttpResponse response = httpclient.execute(httpGet)) {\n+\t\t\t\tAcmeFatUtils.logHttpResponse(CAContainer.class, METHOD_NAME, httpGet, response);\n+\n+\t\t\t\tStatusLine statusLine = response.getStatusLine();\n+\n+\t\t\t\tif (statusLine.getStatusCode() != 200) {\n+\t\t\t\t\tthrow new IOException(\n+\t\t\t\t\t\t\tMETHOD_NAME + \": Expected response 200, but received response: \" + statusLine);\n+\t\t\t\t}\n+\n+\t\t\t\tString result = EntityUtils.toString(response.getEntity());\n+\n+\t\t\t\t/*\n+\t\t\t\t * The result is in JSON, lets just parse out the status.\n+\t\t\t\t */\n+\t\t\t\tPattern p = Pattern.compile(\".*\\\"Status\\\": \\\"(\\\\w+)\\\",.*\", Pattern.DOTALL);\n+\t\t\t\tMatcher m = p.matcher(result);\n+\t\t\t\tif (m.find()) {\n+\t\t\t\t\tresult = m.group(1);\n+\t\t\t\t} else {\n+\t\t\t\t\tthrow new Exception(\n+\t\t\t\t\t\t\t\"Certificate status response was not in expected JSON format. Response: \" + result);\n+\t\t\t\t}\n+\n+\t\t\t\tLog.info(CAContainer.class, METHOD_NAME, new String(result));\n+\t\t\t\treturn result;\n+\t\t\t}\n+\t\t}\n+\t}\n+\t\n+\t/**\n+\t * Retrieves the client host's IP address that is reachable from the\n+\t * container.\n+\t * \n+\t * @return The client host's IP address that is reachable from the\n+\t *         container.\n+\t * @throws IllegalStateException\n+\t *             If the address was not found.\n+\t */\n+\tpublic String getClientHost() throws IllegalStateException {\n+\t\tfor (String extraHost : this.getExtraHosts()) {\n+\t\t\tif (extraHost.startsWith(\"host.testcontainers.internal:\")) {\n+\t\t\t\treturn extraHost.replace(\"host.testcontainers.internal:\", \"\");\n+\t\t\t}\n+\t\t}\n+\n+\t\tthrow new IllegalStateException(\n+\t\t\t\t\"Unable to resolve local host from docker container. Could not find 'host.testcontainers.internal' property.\");\n+\t}\n+\t\n+\t/**\n+\t * Add A and AAAA records.\n+\t */\n+    public void addARecords() {\n+    \ttry {\n+\t\t\tfor (String domain : new String[] { TEST_DOMAIN_1, TEST_DOMAIN_2, TEST_DOMAIN_3, TEST_DOMAIN_4 }) {\n+\t\t\t\t/*\n+\t\t\t\t * Disable the IPv6 responses for this domain. The Boulder CA server\n+\t\t\t\t * responds on AAAA (IPv6) responses before A (IPv4) responses, and\n+\t\t\t\t * we don't currently have the testcontainer host's IPv6 address.\n+\t\t\t\t */\n+\t\t\t\taddARecord(domain, getClientHost());\n+\t\t\t\taddAAAARecord(domain, \"\");\n+\t\t\t}\n+    \t} catch (Exception e) {\n+    \t\tLog.error(CAContainer.class, \"addARecords\", e);\n+    \t}\n+    }\n+    /**\n+     * Convenience method for adding A records.\n+\t * @param host\n+\t *            The host / domain to redirect requests for.\n+     */\n+\tpublic void addARecord(String domain) throws IOException {\n+\t\taddARecord(domain, getClientHost());\n+\t}\n+\t/**\n+\t * Add an A record to the mock DNS server. This will allow us to redirect\n+\t * requests to a named domain to the IPv4 address of our choice.\n+\t * \n+\t * @param host\n+\t *            The host / domain to redirect requests for.\n+\t * @param address\n+\t *            The address to direct the requests for that host to.\n+\t * @throws IOException\n+\t */\n+\tpublic void addARecord(String host, String address) throws IOException {\n+\t\tfinal String METHOD_NAME = \"addARecord\";\n+\n+\t\ttry (CloseableHttpClient httpclient = HttpClients.createDefault()) {\n+\n+\t\t\t/*\n+\t\t\t * Generate the JSON request. The request can support multiple\n+\t\t\t * addresses but for the time being we will only support sending\n+\t\t\t * one.\n+\t\t\t */\n+\t\t\tString jsonString = \"{\\\"host\\\":\\\"\" + host + \"\\\",\\\"addresses\\\":[\\\"\" + address + \"\\\"]}\";\n+\t\t\tStringEntity requestEntity = new StringEntity(jsonString, ContentType.APPLICATION_JSON);\n+\n+\t\t\t/*\n+\t\t\t * Create a POST request to the mock DNS server.\n+\t\t\t */\n+\t\t\tHttpPost httpPost = new HttpPost(getManagementAddress() + \"/add-a\");\n+\t\t\thttpPost.setEntity(requestEntity);\n+\t\t\t/*\n+\t\t\t * Send the POST request and process the response.\n+\t\t\t */\n+\t\t\ttry (final CloseableHttpResponse response = httpclient.execute(httpPost)) {\n+\t\t\t\tAcmeFatUtils.logHttpResponse(CAContainer.class, METHOD_NAME, httpPost, response);\n+\n+\t\t\t\tStatusLine statusLine = response.getStatusLine();\n+\t\t\t\tif (statusLine.getStatusCode() != 200) {\n+\t\t\t\t\tthrow new IOException(\n+\t\t\t\t\t\t\tMETHOD_NAME + \": Expected response 200, but received response: \" + statusLine);\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t}\n+\t\n+\t/**\n+\t * Add an AAAA record to the mock DNS server. This will allow us to redirect\n+\t * requests to a named domain to the IPv6 address of our choice.\n+\t * \n+\t * @param host\n+\t *            The host / domain to redirect requests for.\n+\t * @param address\n+\t *            The address to direct the requests for that host to.\n+\t * @throws IOException\n+\t */\n+\tpublic void addAAAARecord(String host, String address) throws IOException {\n+\t\tfinal String METHOD_NAME = \"addAAAARecord\";\n+\n+\t\ttry (CloseableHttpClient httpclient = HttpClients.createDefault()) {\n+\n+\t\t\t/*\n+\t\t\t * Generate the JSON request. The request can support multiple\n+\t\t\t * addresses but for the time being we will only support sending\n+\t\t\t * one.\n+\t\t\t */\n+\t\t\tString jsonString = \"{\\\"host\\\":\\\"\" + host + \"\\\",\\\"addresses\\\":[\\\"\" + address + \"\\\"]}\";\n+\t\t\tStringEntity requestEntity = new StringEntity(jsonString, ContentType.APPLICATION_JSON);\n+\n+\t\t\t/*\n+\t\t\t * Create a POST request to the mock DNS server.\n+\t\t\t */\n+\t\t\tHttpPost httpPost = new HttpPost(getManagementAddress() + \"/add-aaaa\");\n+\t\t\thttpPost.setEntity(requestEntity);\n+\n+\t\t\t/*\n+\t\t\t * Send the POST request and process the response.\n+\t\t\t */\n+\t\t\ttry (final CloseableHttpResponse response = httpclient.execute(httpPost)) {\n+\t\t\t\tAcmeFatUtils.logHttpResponse(CAContainer.class, METHOD_NAME, httpPost, response);\n+\n+\t\t\t\tStatusLine statusLine = response.getStatusLine();\n+\t\t\t\tif (statusLine.getStatusCode() != 200) {\n+\t\t\t\t\tthrow new IOException(\n+\t\t\t\t\t\t\tMETHOD_NAME + \": Expected response 200, but received response: \" + statusLine);\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t}\n+\t/**\n+\t * Clear a previously added AAAA record that was added to the mock DNS\n+\t * server.\n+\t * \n+\t * @param host\n+\t *            The host / domain to redirect requests for.\n+\t * @throws IOException\n+\t */\n+\tpublic void clearAAAARecord(String host) throws IOException {\n+\t\tfinal String METHOD_NAME = \"clearAAAARecord(String)\";\n+\n+\t\ttry (CloseableHttpClient httpclient = HttpClients.createDefault()) {\n+\t\t\t/*\n+\t\t\t * Generate the JSON request.\n+\t\t\t */\n+\t\t\tString jsonString = \"{\\\"host\\\":\\\"\" + host + \"\\\"}\";\n+\t\t\tStringEntity requestEntity = new StringEntity(jsonString, ContentType.APPLICATION_JSON);\n+\n+\t\t\t/*\n+\t\t\t * Create a POST request to the mock DNS server.\n+\t\t\t */\n+\t\t\tHttpPost httpPost = new HttpPost(getManagementAddress() + \"/clear-aaaa\");\n+\t\t\thttpPost.setEntity(requestEntity);\n+\n+\t\t\t/*\n+\t\t\t * Send the POST request and process the response.\n+\t\t\t */\n+\t\t\ttry (final CloseableHttpResponse response = httpclient.execute(httpPost)) {\n+\t\t\t\tAcmeFatUtils.logHttpResponse(CAContainer.class, METHOD_NAME, httpPost, response);\n+\n+\t\t\t\tStatusLine statusLine = response.getStatusLine();\n+\t\t\t\tif (statusLine.getStatusCode() != 200) {\n+\t\t\t\t\tthrow new IOException(\n+\t\t\t\t\t\t\tMETHOD_NAME + \": Expected response 200, but received response: \" + statusLine);\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Clear a previously added A record that was added to the mock DNS server.\n+\t * \n+\t * @param host\n+\t *            The host / domain to redirect requests for.\n+\t * @throws IOException\n+\t */\n+\tpublic void clearARecord(String host) throws IOException {\n+\t\tfinal String METHOD_NAME = \"clearMockARecord(String)\";\n+\n+\t\ttry (CloseableHttpClient httpclient = HttpClients.createDefault()) {\n+\t\t\t/*\n+\t\t\t * Generate the JSON request.\n+\t\t\t */\n+\t\t\tString jsonString = \"{\\\"host\\\":\\\"\" + host + \"\\\"}\";\n+\t\t\tStringEntity requestEntity = new StringEntity(jsonString, ContentType.APPLICATION_JSON);\n+\n+\t\t\t/*\n+\t\t\t * Create a POST request to the mock DNS server.\n+\t\t\t */\n+\t\t\tHttpPost httpPost = new HttpPost(getManagementAddress() + \"/clear-a\");\n+\t\t\thttpPost.setEntity(requestEntity);\n+\n+\t\t\t/*\n+\t\t\t * Send the POST request and process the response.\n+\t\t\t */\n+\t\t\ttry (final CloseableHttpResponse response = httpclient.execute(httpPost)) {\n+\t\t\t\tAcmeFatUtils.logHttpResponse(CAContainer.class, METHOD_NAME, httpPost, response);\n+\n+\t\t\t\tStatusLine statusLine = response.getStatusLine();\n+\t\t\t\tif (statusLine.getStatusCode() != 200) {\n+\t\t\t\t\tthrow new IOException(\n+\t\t\t\t\t\t\tMETHOD_NAME + \": Expected response 200, but received response: \" + statusLine);\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t}\n+\t/**\n+\t * The HTTP address that can be used the reach the REST management API for\n+\t * the server.\n+\t * \n+\t * @return The HTTP address to the REST management endpoint.\n+\t */\n+\tpublic String getManagementAddress() {\n+\t\treturn \"http://\" + this.getContainerIpAddress() + \":\" + this.getMappedPort(MANAGEMENT_PORT);\n+\t}\n+\n+\t/*\n+\t * The following methods should be overridden in the respective container class.\n+\t */\n+\t\n+\t/**\n+\t * Get the URI to the ACME CA's directory.\n+\t * \n+\t * @param usePebbleURI\n+\t *            Use the \"acme://pebble\" style URI instead of the generic\n+\t *            \"https:\" URI. This param is ignored for Boulder.\n+\t * @return The URI to the ACME CA's directory.\n+\t */\n+\tpublic String getAcmeDirectoryURI(boolean usePebbleURI) {\n+\t\treturn null;\n+\t}\n+\t/**", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3c28406c01e42dd902f376fac4532e84cf17aa5f"}, "originalPosition": 434}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUwODU1NDA2OnYy", "diffSide": "RIGHT", "path": "dev/com.ibm.ws.security.acme_fat/fat/src/com/ibm/ws/security/acme/docker/CAContainer.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wNlQxNzozNjoxNlrOGBipkw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wNlQxNzozNjoxNlrOGBipkw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDI2OTQ1OQ==", "bodyText": "Remove this comment. Make the methods abstract to force their implementation in child classes.", "url": "https://github.com/OpenLiberty/open-liberty/pull/11374#discussion_r404269459", "createdAt": "2020-04-06T17:36:16Z", "author": {"login": "jvanhill"}, "path": "dev/com.ibm.ws.security.acme_fat/fat/src/com/ibm/ws/security/acme/docker/CAContainer.java", "diffHunk": "@@ -0,0 +1,442 @@\n+/*******************************************************************************\n+ * Copyright (c) 2019, 2020 IBM Corporation and others.\n+ * All rights reserved. This program and the accompanying materials\n+ * are made available under the terms of the Eclipse Public License v1.0\n+ * which accompanies this distribution, and is available at\n+ * http://www.eclipse.org/legal/epl-v10.html\n+ *\n+ * Contributors:\n+ *     IBM Corporation - initial API and implementation\n+ *******************************************************************************/\n+package com.ibm.ws.security.acme.docker;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.security.cert.X509Certificate;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import org.apache.http.StatusLine;\n+import org.apache.http.client.methods.CloseableHttpResponse;\n+import org.apache.http.client.methods.HttpGet;\n+import org.apache.http.client.methods.HttpPost;\n+import org.apache.http.entity.ContentType;\n+import org.apache.http.entity.StringEntity;\n+import org.apache.http.impl.client.CloseableHttpClient;\n+import org.apache.http.impl.client.HttpClients;\n+import org.apache.http.util.EntityUtils;\n+import org.testcontainers.containers.GenericContainer;\n+import org.testcontainers.images.builder.ImageFromDockerfile;\n+\n+import com.ibm.websphere.simplicity.log.Log;\n+import com.ibm.ws.security.acme.utils.AcmeFatUtils;\n+\n+/**\n+ * Testcontainer implementation for Pebble and Boulder Certificate Authorities.\n+ * \n+ */\n+public class CAContainer extends GenericContainer<CAContainer> {\n+\n+\tprivate static final String TEST_DOMAIN_1 = \"domain1.com\";\n+\tprivate static final String TEST_DOMAIN_2 = \"domain2.com\";\n+\tprivate static final String TEST_DOMAIN_3 = \"domain3.com\";\n+\tprivate static final String TEST_DOMAIN_4 = \"domain4.com\";\n+\t\n+\t/** Challenge server port. */\n+\tpublic static final int HTTP_PORT = 5002;\n+\t/** The REST management API port. */\n+\tpublic int MANAGEMENT_PORT = 8055;\n+\t\n+\t/**\n+\t * This constructor is used by BoulderContainer\n+\t */\n+\tpublic CAContainer(String image) {\n+\t\tsuper(image);\n+\t}\n+\n+\t/**\n+\t * This constructor is used by PebbleContainer. The\n+\t * management port is different for Pebble, so this\n+\t * is passed in.\n+\t */\n+\tpublic CAContainer(ImageFromDockerfile image, int managementPort) {\n+\t\tsuper(image);\n+\t\tMANAGEMENT_PORT = managementPort;\n+\t}\n+\n+\t/**\n+\t * Get CA's intermediate certificate.\n+\t * \n+\t * @param fileName\n+\t *            The name of the file to save the certificate to.\n+\t * @return CA's intermediate certificate in the form of a PEM file.\n+\t * @throws Exception\n+\t *             If we failed to receive the certificate.\n+\t */\n+\tpublic InputStream getAcmeCaIntermediateCertificate() throws Exception {\n+\t\tfinal String METHOD_NAME = \"getAcmeCaIntermediateCertificate()\";\n+\t\tString url = \"https://\" + this.getContainerIpAddress() + \":\" + this.getMappedPort(MANAGEMENT_PORT)\n+\t\t\t\t+ \"/intermediates/0\";\n+\n+\t\ttry (CloseableHttpClient httpclient = AcmeFatUtils.getInsecureHttpsClient()) {\n+\t\t\t/*\n+\t\t\t * Create a GET request to the ACME CA server.\n+\t\t\t */\n+\t\t\tHttpGet httpGet = new HttpGet(url);\n+\n+\t\t\t/*\n+\t\t\t * Send the GET request and process the response.\n+\t\t\t */\n+\t\t\ttry (final CloseableHttpResponse response = httpclient.execute(httpGet)) {\n+\t\t\t\tAcmeFatUtils.logHttpResponse(CAContainer.class, METHOD_NAME, httpGet, response);\n+\n+\t\t\t\tStatusLine statusLine = response.getStatusLine();\n+\n+\t\t\t\tif (statusLine.getStatusCode() != 200) {\n+\t\t\t\t\tthrow new IOException(\n+\t\t\t\t\t\t\tMETHOD_NAME + \": Expected response 200, but received response: \" + statusLine);\n+\t\t\t\t}\n+\n+\t\t\t\tbyte[] result = EntityUtils.toByteArray(response.getEntity());\n+\n+\t\t\t\tLog.info(CAContainer.class, METHOD_NAME, new String(result));\n+\t\t\t\treturn  new ByteArrayInputStream(result);\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Get the root certificate.\n+\t * \n+\t * @param fileName\n+\t *            The name of the file to save the certificate to.\n+\t * @return Certificate Authority's root certificate in the form of a PEM file.\n+\t * @throws Exception\n+\t *             If we failed to receive the certificate.\n+\t */\n+\tpublic byte[] getAcmeCaRootCertificate() throws Exception {\n+\t\tfinal String METHOD_NAME = \"getAcmeCaRootCertificate()\";\n+\t\tString url = \"https://\" + this.getContainerIpAddress() + \":\" + this.getMappedPort(MANAGEMENT_PORT) + \"/roots/0\";\n+\n+\t\ttry (CloseableHttpClient httpclient = AcmeFatUtils.getInsecureHttpsClient()) {\n+\t\t\t/*\n+\t\t\t * Create a GET request to the ACME CA server.\n+\t\t\t */\n+\t\t\tHttpGet httpGet = new HttpGet(url);\n+\n+\t\t\t/*\n+\t\t\t * Send the GET request and process the response.\n+\t\t\t */\n+\t\t\ttry (final CloseableHttpResponse response = httpclient.execute(httpGet)) {\n+\t\t\t\tAcmeFatUtils.logHttpResponse(CAContainer.class, METHOD_NAME, httpGet, response);\n+\n+\t\t\t\tStatusLine statusLine = response.getStatusLine();\n+\n+\t\t\t\tif (statusLine.getStatusCode() != 200) {\n+\t\t\t\t\tthrow new IOException(\n+\t\t\t\t\t\t\tMETHOD_NAME + \": Expected response 200, but received response: \" + statusLine);\n+\t\t\t\t}\n+\n+\t\t\t\tbyte[] result = EntityUtils.toByteArray(response.getEntity());\n+\n+\t\t\t\tLog.info(CAContainer.class, METHOD_NAME, new String(result));\n+\t\t\t\treturn result;\n+\t\t\t}\n+\t\t}\n+\t}\n+\t\n+\t/**\n+\t * Get the status of the certificate from the ACME CA server.\n+\t * \n+\t * @param certificate\n+\t *            The certificate to check.\n+\t * @return The status of the certificate.\n+\t * @throws Exception\n+\t */\n+\tpublic String getAcmeCertificateStatus(X509Certificate certificate) throws Exception {\n+\t\tfinal String METHOD_NAME = \"getAcmeCertificateStatus()\";\n+\t\tString url = \"https://\" + this.getContainerIpAddress() + \":\" + this.getMappedPort(MANAGEMENT_PORT)\n+\t\t\t\t+ \"/cert-status-by-serial/\" + certificate.getSerialNumber().toString(16);\n+\n+\t\ttry (CloseableHttpClient httpclient = AcmeFatUtils.getInsecureHttpsClient()) {\n+\t\t\t/*\n+\t\t\t * Create a GET request to the ACME CA server.\n+\t\t\t */\n+\t\t\tHttpGet httpGet = new HttpGet(url);\n+\n+\t\t\t/*\n+\t\t\t * Send the GET request and process the response.\n+\t\t\t */\n+\t\t\ttry (final CloseableHttpResponse response = httpclient.execute(httpGet)) {\n+\t\t\t\tAcmeFatUtils.logHttpResponse(CAContainer.class, METHOD_NAME, httpGet, response);\n+\n+\t\t\t\tStatusLine statusLine = response.getStatusLine();\n+\n+\t\t\t\tif (statusLine.getStatusCode() != 200) {\n+\t\t\t\t\tthrow new IOException(\n+\t\t\t\t\t\t\tMETHOD_NAME + \": Expected response 200, but received response: \" + statusLine);\n+\t\t\t\t}\n+\n+\t\t\t\tString result = EntityUtils.toString(response.getEntity());\n+\n+\t\t\t\t/*\n+\t\t\t\t * The result is in JSON, lets just parse out the status.\n+\t\t\t\t */\n+\t\t\t\tPattern p = Pattern.compile(\".*\\\"Status\\\": \\\"(\\\\w+)\\\",.*\", Pattern.DOTALL);\n+\t\t\t\tMatcher m = p.matcher(result);\n+\t\t\t\tif (m.find()) {\n+\t\t\t\t\tresult = m.group(1);\n+\t\t\t\t} else {\n+\t\t\t\t\tthrow new Exception(\n+\t\t\t\t\t\t\t\"Certificate status response was not in expected JSON format. Response: \" + result);\n+\t\t\t\t}\n+\n+\t\t\t\tLog.info(CAContainer.class, METHOD_NAME, new String(result));\n+\t\t\t\treturn result;\n+\t\t\t}\n+\t\t}\n+\t}\n+\t\n+\t/**\n+\t * Retrieves the client host's IP address that is reachable from the\n+\t * container.\n+\t * \n+\t * @return The client host's IP address that is reachable from the\n+\t *         container.\n+\t * @throws IllegalStateException\n+\t *             If the address was not found.\n+\t */\n+\tpublic String getClientHost() throws IllegalStateException {\n+\t\tfor (String extraHost : this.getExtraHosts()) {\n+\t\t\tif (extraHost.startsWith(\"host.testcontainers.internal:\")) {\n+\t\t\t\treturn extraHost.replace(\"host.testcontainers.internal:\", \"\");\n+\t\t\t}\n+\t\t}\n+\n+\t\tthrow new IllegalStateException(\n+\t\t\t\t\"Unable to resolve local host from docker container. Could not find 'host.testcontainers.internal' property.\");\n+\t}\n+\t\n+\t/**\n+\t * Add A and AAAA records.\n+\t */\n+    public void addARecords() {\n+    \ttry {\n+\t\t\tfor (String domain : new String[] { TEST_DOMAIN_1, TEST_DOMAIN_2, TEST_DOMAIN_3, TEST_DOMAIN_4 }) {\n+\t\t\t\t/*\n+\t\t\t\t * Disable the IPv6 responses for this domain. The Boulder CA server\n+\t\t\t\t * responds on AAAA (IPv6) responses before A (IPv4) responses, and\n+\t\t\t\t * we don't currently have the testcontainer host's IPv6 address.\n+\t\t\t\t */\n+\t\t\t\taddARecord(domain, getClientHost());\n+\t\t\t\taddAAAARecord(domain, \"\");\n+\t\t\t}\n+    \t} catch (Exception e) {\n+    \t\tLog.error(CAContainer.class, \"addARecords\", e);\n+    \t}\n+    }\n+    /**\n+     * Convenience method for adding A records.\n+\t * @param host\n+\t *            The host / domain to redirect requests for.\n+     */\n+\tpublic void addARecord(String domain) throws IOException {\n+\t\taddARecord(domain, getClientHost());\n+\t}\n+\t/**\n+\t * Add an A record to the mock DNS server. This will allow us to redirect\n+\t * requests to a named domain to the IPv4 address of our choice.\n+\t * \n+\t * @param host\n+\t *            The host / domain to redirect requests for.\n+\t * @param address\n+\t *            The address to direct the requests for that host to.\n+\t * @throws IOException\n+\t */\n+\tpublic void addARecord(String host, String address) throws IOException {\n+\t\tfinal String METHOD_NAME = \"addARecord\";\n+\n+\t\ttry (CloseableHttpClient httpclient = HttpClients.createDefault()) {\n+\n+\t\t\t/*\n+\t\t\t * Generate the JSON request. The request can support multiple\n+\t\t\t * addresses but for the time being we will only support sending\n+\t\t\t * one.\n+\t\t\t */\n+\t\t\tString jsonString = \"{\\\"host\\\":\\\"\" + host + \"\\\",\\\"addresses\\\":[\\\"\" + address + \"\\\"]}\";\n+\t\t\tStringEntity requestEntity = new StringEntity(jsonString, ContentType.APPLICATION_JSON);\n+\n+\t\t\t/*\n+\t\t\t * Create a POST request to the mock DNS server.\n+\t\t\t */\n+\t\t\tHttpPost httpPost = new HttpPost(getManagementAddress() + \"/add-a\");\n+\t\t\thttpPost.setEntity(requestEntity);\n+\t\t\t/*\n+\t\t\t * Send the POST request and process the response.\n+\t\t\t */\n+\t\t\ttry (final CloseableHttpResponse response = httpclient.execute(httpPost)) {\n+\t\t\t\tAcmeFatUtils.logHttpResponse(CAContainer.class, METHOD_NAME, httpPost, response);\n+\n+\t\t\t\tStatusLine statusLine = response.getStatusLine();\n+\t\t\t\tif (statusLine.getStatusCode() != 200) {\n+\t\t\t\t\tthrow new IOException(\n+\t\t\t\t\t\t\tMETHOD_NAME + \": Expected response 200, but received response: \" + statusLine);\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t}\n+\t\n+\t/**\n+\t * Add an AAAA record to the mock DNS server. This will allow us to redirect\n+\t * requests to a named domain to the IPv6 address of our choice.\n+\t * \n+\t * @param host\n+\t *            The host / domain to redirect requests for.\n+\t * @param address\n+\t *            The address to direct the requests for that host to.\n+\t * @throws IOException\n+\t */\n+\tpublic void addAAAARecord(String host, String address) throws IOException {\n+\t\tfinal String METHOD_NAME = \"addAAAARecord\";\n+\n+\t\ttry (CloseableHttpClient httpclient = HttpClients.createDefault()) {\n+\n+\t\t\t/*\n+\t\t\t * Generate the JSON request. The request can support multiple\n+\t\t\t * addresses but for the time being we will only support sending\n+\t\t\t * one.\n+\t\t\t */\n+\t\t\tString jsonString = \"{\\\"host\\\":\\\"\" + host + \"\\\",\\\"addresses\\\":[\\\"\" + address + \"\\\"]}\";\n+\t\t\tStringEntity requestEntity = new StringEntity(jsonString, ContentType.APPLICATION_JSON);\n+\n+\t\t\t/*\n+\t\t\t * Create a POST request to the mock DNS server.\n+\t\t\t */\n+\t\t\tHttpPost httpPost = new HttpPost(getManagementAddress() + \"/add-aaaa\");\n+\t\t\thttpPost.setEntity(requestEntity);\n+\n+\t\t\t/*\n+\t\t\t * Send the POST request and process the response.\n+\t\t\t */\n+\t\t\ttry (final CloseableHttpResponse response = httpclient.execute(httpPost)) {\n+\t\t\t\tAcmeFatUtils.logHttpResponse(CAContainer.class, METHOD_NAME, httpPost, response);\n+\n+\t\t\t\tStatusLine statusLine = response.getStatusLine();\n+\t\t\t\tif (statusLine.getStatusCode() != 200) {\n+\t\t\t\t\tthrow new IOException(\n+\t\t\t\t\t\t\tMETHOD_NAME + \": Expected response 200, but received response: \" + statusLine);\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t}\n+\t/**\n+\t * Clear a previously added AAAA record that was added to the mock DNS\n+\t * server.\n+\t * \n+\t * @param host\n+\t *            The host / domain to redirect requests for.\n+\t * @throws IOException\n+\t */\n+\tpublic void clearAAAARecord(String host) throws IOException {\n+\t\tfinal String METHOD_NAME = \"clearAAAARecord(String)\";\n+\n+\t\ttry (CloseableHttpClient httpclient = HttpClients.createDefault()) {\n+\t\t\t/*\n+\t\t\t * Generate the JSON request.\n+\t\t\t */\n+\t\t\tString jsonString = \"{\\\"host\\\":\\\"\" + host + \"\\\"}\";\n+\t\t\tStringEntity requestEntity = new StringEntity(jsonString, ContentType.APPLICATION_JSON);\n+\n+\t\t\t/*\n+\t\t\t * Create a POST request to the mock DNS server.\n+\t\t\t */\n+\t\t\tHttpPost httpPost = new HttpPost(getManagementAddress() + \"/clear-aaaa\");\n+\t\t\thttpPost.setEntity(requestEntity);\n+\n+\t\t\t/*\n+\t\t\t * Send the POST request and process the response.\n+\t\t\t */\n+\t\t\ttry (final CloseableHttpResponse response = httpclient.execute(httpPost)) {\n+\t\t\t\tAcmeFatUtils.logHttpResponse(CAContainer.class, METHOD_NAME, httpPost, response);\n+\n+\t\t\t\tStatusLine statusLine = response.getStatusLine();\n+\t\t\t\tif (statusLine.getStatusCode() != 200) {\n+\t\t\t\t\tthrow new IOException(\n+\t\t\t\t\t\t\tMETHOD_NAME + \": Expected response 200, but received response: \" + statusLine);\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Clear a previously added A record that was added to the mock DNS server.\n+\t * \n+\t * @param host\n+\t *            The host / domain to redirect requests for.\n+\t * @throws IOException\n+\t */\n+\tpublic void clearARecord(String host) throws IOException {\n+\t\tfinal String METHOD_NAME = \"clearMockARecord(String)\";\n+\n+\t\ttry (CloseableHttpClient httpclient = HttpClients.createDefault()) {\n+\t\t\t/*\n+\t\t\t * Generate the JSON request.\n+\t\t\t */\n+\t\t\tString jsonString = \"{\\\"host\\\":\\\"\" + host + \"\\\"}\";\n+\t\t\tStringEntity requestEntity = new StringEntity(jsonString, ContentType.APPLICATION_JSON);\n+\n+\t\t\t/*\n+\t\t\t * Create a POST request to the mock DNS server.\n+\t\t\t */\n+\t\t\tHttpPost httpPost = new HttpPost(getManagementAddress() + \"/clear-a\");\n+\t\t\thttpPost.setEntity(requestEntity);\n+\n+\t\t\t/*\n+\t\t\t * Send the POST request and process the response.\n+\t\t\t */\n+\t\t\ttry (final CloseableHttpResponse response = httpclient.execute(httpPost)) {\n+\t\t\t\tAcmeFatUtils.logHttpResponse(CAContainer.class, METHOD_NAME, httpPost, response);\n+\n+\t\t\t\tStatusLine statusLine = response.getStatusLine();\n+\t\t\t\tif (statusLine.getStatusCode() != 200) {\n+\t\t\t\t\tthrow new IOException(\n+\t\t\t\t\t\t\tMETHOD_NAME + \": Expected response 200, but received response: \" + statusLine);\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t}\n+\t/**\n+\t * The HTTP address that can be used the reach the REST management API for\n+\t * the server.\n+\t * \n+\t * @return The HTTP address to the REST management endpoint.\n+\t */\n+\tpublic String getManagementAddress() {\n+\t\treturn \"http://\" + this.getContainerIpAddress() + \":\" + this.getMappedPort(MANAGEMENT_PORT);\n+\t}\n+\n+\t/*", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3c28406c01e42dd902f376fac4532e84cf17aa5f"}, "originalPosition": 419}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUwODU1NTM0OnYy", "diffSide": "RIGHT", "path": "dev/com.ibm.ws.security.acme_fat/fat/src/com/ibm/ws/security/acme/docker/CAContainer.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wNlQxNzozNjozOFrOGBiqcw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wNlQxNzozNjozOFrOGBiqcw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDI2OTY4Mw==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \tpublic String getAcmeDirectoryURI(boolean usePebbleURI) {\n          \n          \n            \n            \tpublic abstract String getAcmeDirectoryURI(boolean usePebbleURI);", "url": "https://github.com/OpenLiberty/open-liberty/pull/11374#discussion_r404269683", "createdAt": "2020-04-06T17:36:38Z", "author": {"login": "jvanhill"}, "path": "dev/com.ibm.ws.security.acme_fat/fat/src/com/ibm/ws/security/acme/docker/CAContainer.java", "diffHunk": "@@ -0,0 +1,442 @@\n+/*******************************************************************************\n+ * Copyright (c) 2019, 2020 IBM Corporation and others.\n+ * All rights reserved. This program and the accompanying materials\n+ * are made available under the terms of the Eclipse Public License v1.0\n+ * which accompanies this distribution, and is available at\n+ * http://www.eclipse.org/legal/epl-v10.html\n+ *\n+ * Contributors:\n+ *     IBM Corporation - initial API and implementation\n+ *******************************************************************************/\n+package com.ibm.ws.security.acme.docker;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.security.cert.X509Certificate;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import org.apache.http.StatusLine;\n+import org.apache.http.client.methods.CloseableHttpResponse;\n+import org.apache.http.client.methods.HttpGet;\n+import org.apache.http.client.methods.HttpPost;\n+import org.apache.http.entity.ContentType;\n+import org.apache.http.entity.StringEntity;\n+import org.apache.http.impl.client.CloseableHttpClient;\n+import org.apache.http.impl.client.HttpClients;\n+import org.apache.http.util.EntityUtils;\n+import org.testcontainers.containers.GenericContainer;\n+import org.testcontainers.images.builder.ImageFromDockerfile;\n+\n+import com.ibm.websphere.simplicity.log.Log;\n+import com.ibm.ws.security.acme.utils.AcmeFatUtils;\n+\n+/**\n+ * Testcontainer implementation for Pebble and Boulder Certificate Authorities.\n+ * \n+ */\n+public class CAContainer extends GenericContainer<CAContainer> {\n+\n+\tprivate static final String TEST_DOMAIN_1 = \"domain1.com\";\n+\tprivate static final String TEST_DOMAIN_2 = \"domain2.com\";\n+\tprivate static final String TEST_DOMAIN_3 = \"domain3.com\";\n+\tprivate static final String TEST_DOMAIN_4 = \"domain4.com\";\n+\t\n+\t/** Challenge server port. */\n+\tpublic static final int HTTP_PORT = 5002;\n+\t/** The REST management API port. */\n+\tpublic int MANAGEMENT_PORT = 8055;\n+\t\n+\t/**\n+\t * This constructor is used by BoulderContainer\n+\t */\n+\tpublic CAContainer(String image) {\n+\t\tsuper(image);\n+\t}\n+\n+\t/**\n+\t * This constructor is used by PebbleContainer. The\n+\t * management port is different for Pebble, so this\n+\t * is passed in.\n+\t */\n+\tpublic CAContainer(ImageFromDockerfile image, int managementPort) {\n+\t\tsuper(image);\n+\t\tMANAGEMENT_PORT = managementPort;\n+\t}\n+\n+\t/**\n+\t * Get CA's intermediate certificate.\n+\t * \n+\t * @param fileName\n+\t *            The name of the file to save the certificate to.\n+\t * @return CA's intermediate certificate in the form of a PEM file.\n+\t * @throws Exception\n+\t *             If we failed to receive the certificate.\n+\t */\n+\tpublic InputStream getAcmeCaIntermediateCertificate() throws Exception {\n+\t\tfinal String METHOD_NAME = \"getAcmeCaIntermediateCertificate()\";\n+\t\tString url = \"https://\" + this.getContainerIpAddress() + \":\" + this.getMappedPort(MANAGEMENT_PORT)\n+\t\t\t\t+ \"/intermediates/0\";\n+\n+\t\ttry (CloseableHttpClient httpclient = AcmeFatUtils.getInsecureHttpsClient()) {\n+\t\t\t/*\n+\t\t\t * Create a GET request to the ACME CA server.\n+\t\t\t */\n+\t\t\tHttpGet httpGet = new HttpGet(url);\n+\n+\t\t\t/*\n+\t\t\t * Send the GET request and process the response.\n+\t\t\t */\n+\t\t\ttry (final CloseableHttpResponse response = httpclient.execute(httpGet)) {\n+\t\t\t\tAcmeFatUtils.logHttpResponse(CAContainer.class, METHOD_NAME, httpGet, response);\n+\n+\t\t\t\tStatusLine statusLine = response.getStatusLine();\n+\n+\t\t\t\tif (statusLine.getStatusCode() != 200) {\n+\t\t\t\t\tthrow new IOException(\n+\t\t\t\t\t\t\tMETHOD_NAME + \": Expected response 200, but received response: \" + statusLine);\n+\t\t\t\t}\n+\n+\t\t\t\tbyte[] result = EntityUtils.toByteArray(response.getEntity());\n+\n+\t\t\t\tLog.info(CAContainer.class, METHOD_NAME, new String(result));\n+\t\t\t\treturn  new ByteArrayInputStream(result);\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Get the root certificate.\n+\t * \n+\t * @param fileName\n+\t *            The name of the file to save the certificate to.\n+\t * @return Certificate Authority's root certificate in the form of a PEM file.\n+\t * @throws Exception\n+\t *             If we failed to receive the certificate.\n+\t */\n+\tpublic byte[] getAcmeCaRootCertificate() throws Exception {\n+\t\tfinal String METHOD_NAME = \"getAcmeCaRootCertificate()\";\n+\t\tString url = \"https://\" + this.getContainerIpAddress() + \":\" + this.getMappedPort(MANAGEMENT_PORT) + \"/roots/0\";\n+\n+\t\ttry (CloseableHttpClient httpclient = AcmeFatUtils.getInsecureHttpsClient()) {\n+\t\t\t/*\n+\t\t\t * Create a GET request to the ACME CA server.\n+\t\t\t */\n+\t\t\tHttpGet httpGet = new HttpGet(url);\n+\n+\t\t\t/*\n+\t\t\t * Send the GET request and process the response.\n+\t\t\t */\n+\t\t\ttry (final CloseableHttpResponse response = httpclient.execute(httpGet)) {\n+\t\t\t\tAcmeFatUtils.logHttpResponse(CAContainer.class, METHOD_NAME, httpGet, response);\n+\n+\t\t\t\tStatusLine statusLine = response.getStatusLine();\n+\n+\t\t\t\tif (statusLine.getStatusCode() != 200) {\n+\t\t\t\t\tthrow new IOException(\n+\t\t\t\t\t\t\tMETHOD_NAME + \": Expected response 200, but received response: \" + statusLine);\n+\t\t\t\t}\n+\n+\t\t\t\tbyte[] result = EntityUtils.toByteArray(response.getEntity());\n+\n+\t\t\t\tLog.info(CAContainer.class, METHOD_NAME, new String(result));\n+\t\t\t\treturn result;\n+\t\t\t}\n+\t\t}\n+\t}\n+\t\n+\t/**\n+\t * Get the status of the certificate from the ACME CA server.\n+\t * \n+\t * @param certificate\n+\t *            The certificate to check.\n+\t * @return The status of the certificate.\n+\t * @throws Exception\n+\t */\n+\tpublic String getAcmeCertificateStatus(X509Certificate certificate) throws Exception {\n+\t\tfinal String METHOD_NAME = \"getAcmeCertificateStatus()\";\n+\t\tString url = \"https://\" + this.getContainerIpAddress() + \":\" + this.getMappedPort(MANAGEMENT_PORT)\n+\t\t\t\t+ \"/cert-status-by-serial/\" + certificate.getSerialNumber().toString(16);\n+\n+\t\ttry (CloseableHttpClient httpclient = AcmeFatUtils.getInsecureHttpsClient()) {\n+\t\t\t/*\n+\t\t\t * Create a GET request to the ACME CA server.\n+\t\t\t */\n+\t\t\tHttpGet httpGet = new HttpGet(url);\n+\n+\t\t\t/*\n+\t\t\t * Send the GET request and process the response.\n+\t\t\t */\n+\t\t\ttry (final CloseableHttpResponse response = httpclient.execute(httpGet)) {\n+\t\t\t\tAcmeFatUtils.logHttpResponse(CAContainer.class, METHOD_NAME, httpGet, response);\n+\n+\t\t\t\tStatusLine statusLine = response.getStatusLine();\n+\n+\t\t\t\tif (statusLine.getStatusCode() != 200) {\n+\t\t\t\t\tthrow new IOException(\n+\t\t\t\t\t\t\tMETHOD_NAME + \": Expected response 200, but received response: \" + statusLine);\n+\t\t\t\t}\n+\n+\t\t\t\tString result = EntityUtils.toString(response.getEntity());\n+\n+\t\t\t\t/*\n+\t\t\t\t * The result is in JSON, lets just parse out the status.\n+\t\t\t\t */\n+\t\t\t\tPattern p = Pattern.compile(\".*\\\"Status\\\": \\\"(\\\\w+)\\\",.*\", Pattern.DOTALL);\n+\t\t\t\tMatcher m = p.matcher(result);\n+\t\t\t\tif (m.find()) {\n+\t\t\t\t\tresult = m.group(1);\n+\t\t\t\t} else {\n+\t\t\t\t\tthrow new Exception(\n+\t\t\t\t\t\t\t\"Certificate status response was not in expected JSON format. Response: \" + result);\n+\t\t\t\t}\n+\n+\t\t\t\tLog.info(CAContainer.class, METHOD_NAME, new String(result));\n+\t\t\t\treturn result;\n+\t\t\t}\n+\t\t}\n+\t}\n+\t\n+\t/**\n+\t * Retrieves the client host's IP address that is reachable from the\n+\t * container.\n+\t * \n+\t * @return The client host's IP address that is reachable from the\n+\t *         container.\n+\t * @throws IllegalStateException\n+\t *             If the address was not found.\n+\t */\n+\tpublic String getClientHost() throws IllegalStateException {\n+\t\tfor (String extraHost : this.getExtraHosts()) {\n+\t\t\tif (extraHost.startsWith(\"host.testcontainers.internal:\")) {\n+\t\t\t\treturn extraHost.replace(\"host.testcontainers.internal:\", \"\");\n+\t\t\t}\n+\t\t}\n+\n+\t\tthrow new IllegalStateException(\n+\t\t\t\t\"Unable to resolve local host from docker container. Could not find 'host.testcontainers.internal' property.\");\n+\t}\n+\t\n+\t/**\n+\t * Add A and AAAA records.\n+\t */\n+    public void addARecords() {\n+    \ttry {\n+\t\t\tfor (String domain : new String[] { TEST_DOMAIN_1, TEST_DOMAIN_2, TEST_DOMAIN_3, TEST_DOMAIN_4 }) {\n+\t\t\t\t/*\n+\t\t\t\t * Disable the IPv6 responses for this domain. The Boulder CA server\n+\t\t\t\t * responds on AAAA (IPv6) responses before A (IPv4) responses, and\n+\t\t\t\t * we don't currently have the testcontainer host's IPv6 address.\n+\t\t\t\t */\n+\t\t\t\taddARecord(domain, getClientHost());\n+\t\t\t\taddAAAARecord(domain, \"\");\n+\t\t\t}\n+    \t} catch (Exception e) {\n+    \t\tLog.error(CAContainer.class, \"addARecords\", e);\n+    \t}\n+    }\n+    /**\n+     * Convenience method for adding A records.\n+\t * @param host\n+\t *            The host / domain to redirect requests for.\n+     */\n+\tpublic void addARecord(String domain) throws IOException {\n+\t\taddARecord(domain, getClientHost());\n+\t}\n+\t/**\n+\t * Add an A record to the mock DNS server. This will allow us to redirect\n+\t * requests to a named domain to the IPv4 address of our choice.\n+\t * \n+\t * @param host\n+\t *            The host / domain to redirect requests for.\n+\t * @param address\n+\t *            The address to direct the requests for that host to.\n+\t * @throws IOException\n+\t */\n+\tpublic void addARecord(String host, String address) throws IOException {\n+\t\tfinal String METHOD_NAME = \"addARecord\";\n+\n+\t\ttry (CloseableHttpClient httpclient = HttpClients.createDefault()) {\n+\n+\t\t\t/*\n+\t\t\t * Generate the JSON request. The request can support multiple\n+\t\t\t * addresses but for the time being we will only support sending\n+\t\t\t * one.\n+\t\t\t */\n+\t\t\tString jsonString = \"{\\\"host\\\":\\\"\" + host + \"\\\",\\\"addresses\\\":[\\\"\" + address + \"\\\"]}\";\n+\t\t\tStringEntity requestEntity = new StringEntity(jsonString, ContentType.APPLICATION_JSON);\n+\n+\t\t\t/*\n+\t\t\t * Create a POST request to the mock DNS server.\n+\t\t\t */\n+\t\t\tHttpPost httpPost = new HttpPost(getManagementAddress() + \"/add-a\");\n+\t\t\thttpPost.setEntity(requestEntity);\n+\t\t\t/*\n+\t\t\t * Send the POST request and process the response.\n+\t\t\t */\n+\t\t\ttry (final CloseableHttpResponse response = httpclient.execute(httpPost)) {\n+\t\t\t\tAcmeFatUtils.logHttpResponse(CAContainer.class, METHOD_NAME, httpPost, response);\n+\n+\t\t\t\tStatusLine statusLine = response.getStatusLine();\n+\t\t\t\tif (statusLine.getStatusCode() != 200) {\n+\t\t\t\t\tthrow new IOException(\n+\t\t\t\t\t\t\tMETHOD_NAME + \": Expected response 200, but received response: \" + statusLine);\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t}\n+\t\n+\t/**\n+\t * Add an AAAA record to the mock DNS server. This will allow us to redirect\n+\t * requests to a named domain to the IPv6 address of our choice.\n+\t * \n+\t * @param host\n+\t *            The host / domain to redirect requests for.\n+\t * @param address\n+\t *            The address to direct the requests for that host to.\n+\t * @throws IOException\n+\t */\n+\tpublic void addAAAARecord(String host, String address) throws IOException {\n+\t\tfinal String METHOD_NAME = \"addAAAARecord\";\n+\n+\t\ttry (CloseableHttpClient httpclient = HttpClients.createDefault()) {\n+\n+\t\t\t/*\n+\t\t\t * Generate the JSON request. The request can support multiple\n+\t\t\t * addresses but for the time being we will only support sending\n+\t\t\t * one.\n+\t\t\t */\n+\t\t\tString jsonString = \"{\\\"host\\\":\\\"\" + host + \"\\\",\\\"addresses\\\":[\\\"\" + address + \"\\\"]}\";\n+\t\t\tStringEntity requestEntity = new StringEntity(jsonString, ContentType.APPLICATION_JSON);\n+\n+\t\t\t/*\n+\t\t\t * Create a POST request to the mock DNS server.\n+\t\t\t */\n+\t\t\tHttpPost httpPost = new HttpPost(getManagementAddress() + \"/add-aaaa\");\n+\t\t\thttpPost.setEntity(requestEntity);\n+\n+\t\t\t/*\n+\t\t\t * Send the POST request and process the response.\n+\t\t\t */\n+\t\t\ttry (final CloseableHttpResponse response = httpclient.execute(httpPost)) {\n+\t\t\t\tAcmeFatUtils.logHttpResponse(CAContainer.class, METHOD_NAME, httpPost, response);\n+\n+\t\t\t\tStatusLine statusLine = response.getStatusLine();\n+\t\t\t\tif (statusLine.getStatusCode() != 200) {\n+\t\t\t\t\tthrow new IOException(\n+\t\t\t\t\t\t\tMETHOD_NAME + \": Expected response 200, but received response: \" + statusLine);\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t}\n+\t/**\n+\t * Clear a previously added AAAA record that was added to the mock DNS\n+\t * server.\n+\t * \n+\t * @param host\n+\t *            The host / domain to redirect requests for.\n+\t * @throws IOException\n+\t */\n+\tpublic void clearAAAARecord(String host) throws IOException {\n+\t\tfinal String METHOD_NAME = \"clearAAAARecord(String)\";\n+\n+\t\ttry (CloseableHttpClient httpclient = HttpClients.createDefault()) {\n+\t\t\t/*\n+\t\t\t * Generate the JSON request.\n+\t\t\t */\n+\t\t\tString jsonString = \"{\\\"host\\\":\\\"\" + host + \"\\\"}\";\n+\t\t\tStringEntity requestEntity = new StringEntity(jsonString, ContentType.APPLICATION_JSON);\n+\n+\t\t\t/*\n+\t\t\t * Create a POST request to the mock DNS server.\n+\t\t\t */\n+\t\t\tHttpPost httpPost = new HttpPost(getManagementAddress() + \"/clear-aaaa\");\n+\t\t\thttpPost.setEntity(requestEntity);\n+\n+\t\t\t/*\n+\t\t\t * Send the POST request and process the response.\n+\t\t\t */\n+\t\t\ttry (final CloseableHttpResponse response = httpclient.execute(httpPost)) {\n+\t\t\t\tAcmeFatUtils.logHttpResponse(CAContainer.class, METHOD_NAME, httpPost, response);\n+\n+\t\t\t\tStatusLine statusLine = response.getStatusLine();\n+\t\t\t\tif (statusLine.getStatusCode() != 200) {\n+\t\t\t\t\tthrow new IOException(\n+\t\t\t\t\t\t\tMETHOD_NAME + \": Expected response 200, but received response: \" + statusLine);\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Clear a previously added A record that was added to the mock DNS server.\n+\t * \n+\t * @param host\n+\t *            The host / domain to redirect requests for.\n+\t * @throws IOException\n+\t */\n+\tpublic void clearARecord(String host) throws IOException {\n+\t\tfinal String METHOD_NAME = \"clearMockARecord(String)\";\n+\n+\t\ttry (CloseableHttpClient httpclient = HttpClients.createDefault()) {\n+\t\t\t/*\n+\t\t\t * Generate the JSON request.\n+\t\t\t */\n+\t\t\tString jsonString = \"{\\\"host\\\":\\\"\" + host + \"\\\"}\";\n+\t\t\tStringEntity requestEntity = new StringEntity(jsonString, ContentType.APPLICATION_JSON);\n+\n+\t\t\t/*\n+\t\t\t * Create a POST request to the mock DNS server.\n+\t\t\t */\n+\t\t\tHttpPost httpPost = new HttpPost(getManagementAddress() + \"/clear-a\");\n+\t\t\thttpPost.setEntity(requestEntity);\n+\n+\t\t\t/*\n+\t\t\t * Send the POST request and process the response.\n+\t\t\t */\n+\t\t\ttry (final CloseableHttpResponse response = httpclient.execute(httpPost)) {\n+\t\t\t\tAcmeFatUtils.logHttpResponse(CAContainer.class, METHOD_NAME, httpPost, response);\n+\n+\t\t\t\tStatusLine statusLine = response.getStatusLine();\n+\t\t\t\tif (statusLine.getStatusCode() != 200) {\n+\t\t\t\t\tthrow new IOException(\n+\t\t\t\t\t\t\tMETHOD_NAME + \": Expected response 200, but received response: \" + statusLine);\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t}\n+\t/**\n+\t * The HTTP address that can be used the reach the REST management API for\n+\t * the server.\n+\t * \n+\t * @return The HTTP address to the REST management endpoint.\n+\t */\n+\tpublic String getManagementAddress() {\n+\t\treturn \"http://\" + this.getContainerIpAddress() + \":\" + this.getMappedPort(MANAGEMENT_PORT);\n+\t}\n+\n+\t/*\n+\t * The following methods should be overridden in the respective container class.\n+\t */\n+\t\n+\t/**\n+\t * Get the URI to the ACME CA's directory.\n+\t * \n+\t * @param usePebbleURI\n+\t *            Use the \"acme://pebble\" style URI instead of the generic\n+\t *            \"https:\" URI. This param is ignored for Boulder.\n+\t * @return The URI to the ACME CA's directory.\n+\t */\n+\tpublic String getAcmeDirectoryURI(boolean usePebbleURI) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3c28406c01e42dd902f376fac4532e84cf17aa5f"}, "originalPosition": 431}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUwODU1Njg2OnYy", "diffSide": "RIGHT", "path": "dev/com.ibm.ws.security.acme_fat/fat/src/com/ibm/ws/security/acme/docker/CAContainer.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wNlQxNzozNjo1OFrOGBirXQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wNlQxNzozNjo1OFrOGBirXQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDI2OTkxNw==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t\treturn null;", "url": "https://github.com/OpenLiberty/open-liberty/pull/11374#discussion_r404269917", "createdAt": "2020-04-06T17:36:58Z", "author": {"login": "jvanhill"}, "path": "dev/com.ibm.ws.security.acme_fat/fat/src/com/ibm/ws/security/acme/docker/CAContainer.java", "diffHunk": "@@ -0,0 +1,442 @@\n+/*******************************************************************************\n+ * Copyright (c) 2019, 2020 IBM Corporation and others.\n+ * All rights reserved. This program and the accompanying materials\n+ * are made available under the terms of the Eclipse Public License v1.0\n+ * which accompanies this distribution, and is available at\n+ * http://www.eclipse.org/legal/epl-v10.html\n+ *\n+ * Contributors:\n+ *     IBM Corporation - initial API and implementation\n+ *******************************************************************************/\n+package com.ibm.ws.security.acme.docker;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.security.cert.X509Certificate;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import org.apache.http.StatusLine;\n+import org.apache.http.client.methods.CloseableHttpResponse;\n+import org.apache.http.client.methods.HttpGet;\n+import org.apache.http.client.methods.HttpPost;\n+import org.apache.http.entity.ContentType;\n+import org.apache.http.entity.StringEntity;\n+import org.apache.http.impl.client.CloseableHttpClient;\n+import org.apache.http.impl.client.HttpClients;\n+import org.apache.http.util.EntityUtils;\n+import org.testcontainers.containers.GenericContainer;\n+import org.testcontainers.images.builder.ImageFromDockerfile;\n+\n+import com.ibm.websphere.simplicity.log.Log;\n+import com.ibm.ws.security.acme.utils.AcmeFatUtils;\n+\n+/**\n+ * Testcontainer implementation for Pebble and Boulder Certificate Authorities.\n+ * \n+ */\n+public class CAContainer extends GenericContainer<CAContainer> {\n+\n+\tprivate static final String TEST_DOMAIN_1 = \"domain1.com\";\n+\tprivate static final String TEST_DOMAIN_2 = \"domain2.com\";\n+\tprivate static final String TEST_DOMAIN_3 = \"domain3.com\";\n+\tprivate static final String TEST_DOMAIN_4 = \"domain4.com\";\n+\t\n+\t/** Challenge server port. */\n+\tpublic static final int HTTP_PORT = 5002;\n+\t/** The REST management API port. */\n+\tpublic int MANAGEMENT_PORT = 8055;\n+\t\n+\t/**\n+\t * This constructor is used by BoulderContainer\n+\t */\n+\tpublic CAContainer(String image) {\n+\t\tsuper(image);\n+\t}\n+\n+\t/**\n+\t * This constructor is used by PebbleContainer. The\n+\t * management port is different for Pebble, so this\n+\t * is passed in.\n+\t */\n+\tpublic CAContainer(ImageFromDockerfile image, int managementPort) {\n+\t\tsuper(image);\n+\t\tMANAGEMENT_PORT = managementPort;\n+\t}\n+\n+\t/**\n+\t * Get CA's intermediate certificate.\n+\t * \n+\t * @param fileName\n+\t *            The name of the file to save the certificate to.\n+\t * @return CA's intermediate certificate in the form of a PEM file.\n+\t * @throws Exception\n+\t *             If we failed to receive the certificate.\n+\t */\n+\tpublic InputStream getAcmeCaIntermediateCertificate() throws Exception {\n+\t\tfinal String METHOD_NAME = \"getAcmeCaIntermediateCertificate()\";\n+\t\tString url = \"https://\" + this.getContainerIpAddress() + \":\" + this.getMappedPort(MANAGEMENT_PORT)\n+\t\t\t\t+ \"/intermediates/0\";\n+\n+\t\ttry (CloseableHttpClient httpclient = AcmeFatUtils.getInsecureHttpsClient()) {\n+\t\t\t/*\n+\t\t\t * Create a GET request to the ACME CA server.\n+\t\t\t */\n+\t\t\tHttpGet httpGet = new HttpGet(url);\n+\n+\t\t\t/*\n+\t\t\t * Send the GET request and process the response.\n+\t\t\t */\n+\t\t\ttry (final CloseableHttpResponse response = httpclient.execute(httpGet)) {\n+\t\t\t\tAcmeFatUtils.logHttpResponse(CAContainer.class, METHOD_NAME, httpGet, response);\n+\n+\t\t\t\tStatusLine statusLine = response.getStatusLine();\n+\n+\t\t\t\tif (statusLine.getStatusCode() != 200) {\n+\t\t\t\t\tthrow new IOException(\n+\t\t\t\t\t\t\tMETHOD_NAME + \": Expected response 200, but received response: \" + statusLine);\n+\t\t\t\t}\n+\n+\t\t\t\tbyte[] result = EntityUtils.toByteArray(response.getEntity());\n+\n+\t\t\t\tLog.info(CAContainer.class, METHOD_NAME, new String(result));\n+\t\t\t\treturn  new ByteArrayInputStream(result);\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Get the root certificate.\n+\t * \n+\t * @param fileName\n+\t *            The name of the file to save the certificate to.\n+\t * @return Certificate Authority's root certificate in the form of a PEM file.\n+\t * @throws Exception\n+\t *             If we failed to receive the certificate.\n+\t */\n+\tpublic byte[] getAcmeCaRootCertificate() throws Exception {\n+\t\tfinal String METHOD_NAME = \"getAcmeCaRootCertificate()\";\n+\t\tString url = \"https://\" + this.getContainerIpAddress() + \":\" + this.getMappedPort(MANAGEMENT_PORT) + \"/roots/0\";\n+\n+\t\ttry (CloseableHttpClient httpclient = AcmeFatUtils.getInsecureHttpsClient()) {\n+\t\t\t/*\n+\t\t\t * Create a GET request to the ACME CA server.\n+\t\t\t */\n+\t\t\tHttpGet httpGet = new HttpGet(url);\n+\n+\t\t\t/*\n+\t\t\t * Send the GET request and process the response.\n+\t\t\t */\n+\t\t\ttry (final CloseableHttpResponse response = httpclient.execute(httpGet)) {\n+\t\t\t\tAcmeFatUtils.logHttpResponse(CAContainer.class, METHOD_NAME, httpGet, response);\n+\n+\t\t\t\tStatusLine statusLine = response.getStatusLine();\n+\n+\t\t\t\tif (statusLine.getStatusCode() != 200) {\n+\t\t\t\t\tthrow new IOException(\n+\t\t\t\t\t\t\tMETHOD_NAME + \": Expected response 200, but received response: \" + statusLine);\n+\t\t\t\t}\n+\n+\t\t\t\tbyte[] result = EntityUtils.toByteArray(response.getEntity());\n+\n+\t\t\t\tLog.info(CAContainer.class, METHOD_NAME, new String(result));\n+\t\t\t\treturn result;\n+\t\t\t}\n+\t\t}\n+\t}\n+\t\n+\t/**\n+\t * Get the status of the certificate from the ACME CA server.\n+\t * \n+\t * @param certificate\n+\t *            The certificate to check.\n+\t * @return The status of the certificate.\n+\t * @throws Exception\n+\t */\n+\tpublic String getAcmeCertificateStatus(X509Certificate certificate) throws Exception {\n+\t\tfinal String METHOD_NAME = \"getAcmeCertificateStatus()\";\n+\t\tString url = \"https://\" + this.getContainerIpAddress() + \":\" + this.getMappedPort(MANAGEMENT_PORT)\n+\t\t\t\t+ \"/cert-status-by-serial/\" + certificate.getSerialNumber().toString(16);\n+\n+\t\ttry (CloseableHttpClient httpclient = AcmeFatUtils.getInsecureHttpsClient()) {\n+\t\t\t/*\n+\t\t\t * Create a GET request to the ACME CA server.\n+\t\t\t */\n+\t\t\tHttpGet httpGet = new HttpGet(url);\n+\n+\t\t\t/*\n+\t\t\t * Send the GET request and process the response.\n+\t\t\t */\n+\t\t\ttry (final CloseableHttpResponse response = httpclient.execute(httpGet)) {\n+\t\t\t\tAcmeFatUtils.logHttpResponse(CAContainer.class, METHOD_NAME, httpGet, response);\n+\n+\t\t\t\tStatusLine statusLine = response.getStatusLine();\n+\n+\t\t\t\tif (statusLine.getStatusCode() != 200) {\n+\t\t\t\t\tthrow new IOException(\n+\t\t\t\t\t\t\tMETHOD_NAME + \": Expected response 200, but received response: \" + statusLine);\n+\t\t\t\t}\n+\n+\t\t\t\tString result = EntityUtils.toString(response.getEntity());\n+\n+\t\t\t\t/*\n+\t\t\t\t * The result is in JSON, lets just parse out the status.\n+\t\t\t\t */\n+\t\t\t\tPattern p = Pattern.compile(\".*\\\"Status\\\": \\\"(\\\\w+)\\\",.*\", Pattern.DOTALL);\n+\t\t\t\tMatcher m = p.matcher(result);\n+\t\t\t\tif (m.find()) {\n+\t\t\t\t\tresult = m.group(1);\n+\t\t\t\t} else {\n+\t\t\t\t\tthrow new Exception(\n+\t\t\t\t\t\t\t\"Certificate status response was not in expected JSON format. Response: \" + result);\n+\t\t\t\t}\n+\n+\t\t\t\tLog.info(CAContainer.class, METHOD_NAME, new String(result));\n+\t\t\t\treturn result;\n+\t\t\t}\n+\t\t}\n+\t}\n+\t\n+\t/**\n+\t * Retrieves the client host's IP address that is reachable from the\n+\t * container.\n+\t * \n+\t * @return The client host's IP address that is reachable from the\n+\t *         container.\n+\t * @throws IllegalStateException\n+\t *             If the address was not found.\n+\t */\n+\tpublic String getClientHost() throws IllegalStateException {\n+\t\tfor (String extraHost : this.getExtraHosts()) {\n+\t\t\tif (extraHost.startsWith(\"host.testcontainers.internal:\")) {\n+\t\t\t\treturn extraHost.replace(\"host.testcontainers.internal:\", \"\");\n+\t\t\t}\n+\t\t}\n+\n+\t\tthrow new IllegalStateException(\n+\t\t\t\t\"Unable to resolve local host from docker container. Could not find 'host.testcontainers.internal' property.\");\n+\t}\n+\t\n+\t/**\n+\t * Add A and AAAA records.\n+\t */\n+    public void addARecords() {\n+    \ttry {\n+\t\t\tfor (String domain : new String[] { TEST_DOMAIN_1, TEST_DOMAIN_2, TEST_DOMAIN_3, TEST_DOMAIN_4 }) {\n+\t\t\t\t/*\n+\t\t\t\t * Disable the IPv6 responses for this domain. The Boulder CA server\n+\t\t\t\t * responds on AAAA (IPv6) responses before A (IPv4) responses, and\n+\t\t\t\t * we don't currently have the testcontainer host's IPv6 address.\n+\t\t\t\t */\n+\t\t\t\taddARecord(domain, getClientHost());\n+\t\t\t\taddAAAARecord(domain, \"\");\n+\t\t\t}\n+    \t} catch (Exception e) {\n+    \t\tLog.error(CAContainer.class, \"addARecords\", e);\n+    \t}\n+    }\n+    /**\n+     * Convenience method for adding A records.\n+\t * @param host\n+\t *            The host / domain to redirect requests for.\n+     */\n+\tpublic void addARecord(String domain) throws IOException {\n+\t\taddARecord(domain, getClientHost());\n+\t}\n+\t/**\n+\t * Add an A record to the mock DNS server. This will allow us to redirect\n+\t * requests to a named domain to the IPv4 address of our choice.\n+\t * \n+\t * @param host\n+\t *            The host / domain to redirect requests for.\n+\t * @param address\n+\t *            The address to direct the requests for that host to.\n+\t * @throws IOException\n+\t */\n+\tpublic void addARecord(String host, String address) throws IOException {\n+\t\tfinal String METHOD_NAME = \"addARecord\";\n+\n+\t\ttry (CloseableHttpClient httpclient = HttpClients.createDefault()) {\n+\n+\t\t\t/*\n+\t\t\t * Generate the JSON request. The request can support multiple\n+\t\t\t * addresses but for the time being we will only support sending\n+\t\t\t * one.\n+\t\t\t */\n+\t\t\tString jsonString = \"{\\\"host\\\":\\\"\" + host + \"\\\",\\\"addresses\\\":[\\\"\" + address + \"\\\"]}\";\n+\t\t\tStringEntity requestEntity = new StringEntity(jsonString, ContentType.APPLICATION_JSON);\n+\n+\t\t\t/*\n+\t\t\t * Create a POST request to the mock DNS server.\n+\t\t\t */\n+\t\t\tHttpPost httpPost = new HttpPost(getManagementAddress() + \"/add-a\");\n+\t\t\thttpPost.setEntity(requestEntity);\n+\t\t\t/*\n+\t\t\t * Send the POST request and process the response.\n+\t\t\t */\n+\t\t\ttry (final CloseableHttpResponse response = httpclient.execute(httpPost)) {\n+\t\t\t\tAcmeFatUtils.logHttpResponse(CAContainer.class, METHOD_NAME, httpPost, response);\n+\n+\t\t\t\tStatusLine statusLine = response.getStatusLine();\n+\t\t\t\tif (statusLine.getStatusCode() != 200) {\n+\t\t\t\t\tthrow new IOException(\n+\t\t\t\t\t\t\tMETHOD_NAME + \": Expected response 200, but received response: \" + statusLine);\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t}\n+\t\n+\t/**\n+\t * Add an AAAA record to the mock DNS server. This will allow us to redirect\n+\t * requests to a named domain to the IPv6 address of our choice.\n+\t * \n+\t * @param host\n+\t *            The host / domain to redirect requests for.\n+\t * @param address\n+\t *            The address to direct the requests for that host to.\n+\t * @throws IOException\n+\t */\n+\tpublic void addAAAARecord(String host, String address) throws IOException {\n+\t\tfinal String METHOD_NAME = \"addAAAARecord\";\n+\n+\t\ttry (CloseableHttpClient httpclient = HttpClients.createDefault()) {\n+\n+\t\t\t/*\n+\t\t\t * Generate the JSON request. The request can support multiple\n+\t\t\t * addresses but for the time being we will only support sending\n+\t\t\t * one.\n+\t\t\t */\n+\t\t\tString jsonString = \"{\\\"host\\\":\\\"\" + host + \"\\\",\\\"addresses\\\":[\\\"\" + address + \"\\\"]}\";\n+\t\t\tStringEntity requestEntity = new StringEntity(jsonString, ContentType.APPLICATION_JSON);\n+\n+\t\t\t/*\n+\t\t\t * Create a POST request to the mock DNS server.\n+\t\t\t */\n+\t\t\tHttpPost httpPost = new HttpPost(getManagementAddress() + \"/add-aaaa\");\n+\t\t\thttpPost.setEntity(requestEntity);\n+\n+\t\t\t/*\n+\t\t\t * Send the POST request and process the response.\n+\t\t\t */\n+\t\t\ttry (final CloseableHttpResponse response = httpclient.execute(httpPost)) {\n+\t\t\t\tAcmeFatUtils.logHttpResponse(CAContainer.class, METHOD_NAME, httpPost, response);\n+\n+\t\t\t\tStatusLine statusLine = response.getStatusLine();\n+\t\t\t\tif (statusLine.getStatusCode() != 200) {\n+\t\t\t\t\tthrow new IOException(\n+\t\t\t\t\t\t\tMETHOD_NAME + \": Expected response 200, but received response: \" + statusLine);\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t}\n+\t/**\n+\t * Clear a previously added AAAA record that was added to the mock DNS\n+\t * server.\n+\t * \n+\t * @param host\n+\t *            The host / domain to redirect requests for.\n+\t * @throws IOException\n+\t */\n+\tpublic void clearAAAARecord(String host) throws IOException {\n+\t\tfinal String METHOD_NAME = \"clearAAAARecord(String)\";\n+\n+\t\ttry (CloseableHttpClient httpclient = HttpClients.createDefault()) {\n+\t\t\t/*\n+\t\t\t * Generate the JSON request.\n+\t\t\t */\n+\t\t\tString jsonString = \"{\\\"host\\\":\\\"\" + host + \"\\\"}\";\n+\t\t\tStringEntity requestEntity = new StringEntity(jsonString, ContentType.APPLICATION_JSON);\n+\n+\t\t\t/*\n+\t\t\t * Create a POST request to the mock DNS server.\n+\t\t\t */\n+\t\t\tHttpPost httpPost = new HttpPost(getManagementAddress() + \"/clear-aaaa\");\n+\t\t\thttpPost.setEntity(requestEntity);\n+\n+\t\t\t/*\n+\t\t\t * Send the POST request and process the response.\n+\t\t\t */\n+\t\t\ttry (final CloseableHttpResponse response = httpclient.execute(httpPost)) {\n+\t\t\t\tAcmeFatUtils.logHttpResponse(CAContainer.class, METHOD_NAME, httpPost, response);\n+\n+\t\t\t\tStatusLine statusLine = response.getStatusLine();\n+\t\t\t\tif (statusLine.getStatusCode() != 200) {\n+\t\t\t\t\tthrow new IOException(\n+\t\t\t\t\t\t\tMETHOD_NAME + \": Expected response 200, but received response: \" + statusLine);\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Clear a previously added A record that was added to the mock DNS server.\n+\t * \n+\t * @param host\n+\t *            The host / domain to redirect requests for.\n+\t * @throws IOException\n+\t */\n+\tpublic void clearARecord(String host) throws IOException {\n+\t\tfinal String METHOD_NAME = \"clearMockARecord(String)\";\n+\n+\t\ttry (CloseableHttpClient httpclient = HttpClients.createDefault()) {\n+\t\t\t/*\n+\t\t\t * Generate the JSON request.\n+\t\t\t */\n+\t\t\tString jsonString = \"{\\\"host\\\":\\\"\" + host + \"\\\"}\";\n+\t\t\tStringEntity requestEntity = new StringEntity(jsonString, ContentType.APPLICATION_JSON);\n+\n+\t\t\t/*\n+\t\t\t * Create a POST request to the mock DNS server.\n+\t\t\t */\n+\t\t\tHttpPost httpPost = new HttpPost(getManagementAddress() + \"/clear-a\");\n+\t\t\thttpPost.setEntity(requestEntity);\n+\n+\t\t\t/*\n+\t\t\t * Send the POST request and process the response.\n+\t\t\t */\n+\t\t\ttry (final CloseableHttpResponse response = httpclient.execute(httpPost)) {\n+\t\t\t\tAcmeFatUtils.logHttpResponse(CAContainer.class, METHOD_NAME, httpPost, response);\n+\n+\t\t\t\tStatusLine statusLine = response.getStatusLine();\n+\t\t\t\tif (statusLine.getStatusCode() != 200) {\n+\t\t\t\t\tthrow new IOException(\n+\t\t\t\t\t\t\tMETHOD_NAME + \": Expected response 200, but received response: \" + statusLine);\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t}\n+\t/**\n+\t * The HTTP address that can be used the reach the REST management API for\n+\t * the server.\n+\t * \n+\t * @return The HTTP address to the REST management endpoint.\n+\t */\n+\tpublic String getManagementAddress() {\n+\t\treturn \"http://\" + this.getContainerIpAddress() + \":\" + this.getMappedPort(MANAGEMENT_PORT);\n+\t}\n+\n+\t/*\n+\t * The following methods should be overridden in the respective container class.\n+\t */\n+\t\n+\t/**\n+\t * Get the URI to the ACME CA's directory.\n+\t * \n+\t * @param usePebbleURI\n+\t *            Use the \"acme://pebble\" style URI instead of the generic\n+\t *            \"https:\" URI. This param is ignored for Boulder.\n+\t * @return The URI to the ACME CA's directory.\n+\t */\n+\tpublic String getAcmeDirectoryURI(boolean usePebbleURI) {\n+\t\treturn null;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3c28406c01e42dd902f376fac4532e84cf17aa5f"}, "originalPosition": 432}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUwODU1NzMyOnYy", "diffSide": "RIGHT", "path": "dev/com.ibm.ws.security.acme_fat/fat/src/com/ibm/ws/security/acme/docker/CAContainer.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wNlQxNzozNzowOFrOGBirsQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wNlQxNzozNzowOFrOGBirsQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDI3MDAwMQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t}", "url": "https://github.com/OpenLiberty/open-liberty/pull/11374#discussion_r404270001", "createdAt": "2020-04-06T17:37:08Z", "author": {"login": "jvanhill"}, "path": "dev/com.ibm.ws.security.acme_fat/fat/src/com/ibm/ws/security/acme/docker/CAContainer.java", "diffHunk": "@@ -0,0 +1,442 @@\n+/*******************************************************************************\n+ * Copyright (c) 2019, 2020 IBM Corporation and others.\n+ * All rights reserved. This program and the accompanying materials\n+ * are made available under the terms of the Eclipse Public License v1.0\n+ * which accompanies this distribution, and is available at\n+ * http://www.eclipse.org/legal/epl-v10.html\n+ *\n+ * Contributors:\n+ *     IBM Corporation - initial API and implementation\n+ *******************************************************************************/\n+package com.ibm.ws.security.acme.docker;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.security.cert.X509Certificate;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import org.apache.http.StatusLine;\n+import org.apache.http.client.methods.CloseableHttpResponse;\n+import org.apache.http.client.methods.HttpGet;\n+import org.apache.http.client.methods.HttpPost;\n+import org.apache.http.entity.ContentType;\n+import org.apache.http.entity.StringEntity;\n+import org.apache.http.impl.client.CloseableHttpClient;\n+import org.apache.http.impl.client.HttpClients;\n+import org.apache.http.util.EntityUtils;\n+import org.testcontainers.containers.GenericContainer;\n+import org.testcontainers.images.builder.ImageFromDockerfile;\n+\n+import com.ibm.websphere.simplicity.log.Log;\n+import com.ibm.ws.security.acme.utils.AcmeFatUtils;\n+\n+/**\n+ * Testcontainer implementation for Pebble and Boulder Certificate Authorities.\n+ * \n+ */\n+public class CAContainer extends GenericContainer<CAContainer> {\n+\n+\tprivate static final String TEST_DOMAIN_1 = \"domain1.com\";\n+\tprivate static final String TEST_DOMAIN_2 = \"domain2.com\";\n+\tprivate static final String TEST_DOMAIN_3 = \"domain3.com\";\n+\tprivate static final String TEST_DOMAIN_4 = \"domain4.com\";\n+\t\n+\t/** Challenge server port. */\n+\tpublic static final int HTTP_PORT = 5002;\n+\t/** The REST management API port. */\n+\tpublic int MANAGEMENT_PORT = 8055;\n+\t\n+\t/**\n+\t * This constructor is used by BoulderContainer\n+\t */\n+\tpublic CAContainer(String image) {\n+\t\tsuper(image);\n+\t}\n+\n+\t/**\n+\t * This constructor is used by PebbleContainer. The\n+\t * management port is different for Pebble, so this\n+\t * is passed in.\n+\t */\n+\tpublic CAContainer(ImageFromDockerfile image, int managementPort) {\n+\t\tsuper(image);\n+\t\tMANAGEMENT_PORT = managementPort;\n+\t}\n+\n+\t/**\n+\t * Get CA's intermediate certificate.\n+\t * \n+\t * @param fileName\n+\t *            The name of the file to save the certificate to.\n+\t * @return CA's intermediate certificate in the form of a PEM file.\n+\t * @throws Exception\n+\t *             If we failed to receive the certificate.\n+\t */\n+\tpublic InputStream getAcmeCaIntermediateCertificate() throws Exception {\n+\t\tfinal String METHOD_NAME = \"getAcmeCaIntermediateCertificate()\";\n+\t\tString url = \"https://\" + this.getContainerIpAddress() + \":\" + this.getMappedPort(MANAGEMENT_PORT)\n+\t\t\t\t+ \"/intermediates/0\";\n+\n+\t\ttry (CloseableHttpClient httpclient = AcmeFatUtils.getInsecureHttpsClient()) {\n+\t\t\t/*\n+\t\t\t * Create a GET request to the ACME CA server.\n+\t\t\t */\n+\t\t\tHttpGet httpGet = new HttpGet(url);\n+\n+\t\t\t/*\n+\t\t\t * Send the GET request and process the response.\n+\t\t\t */\n+\t\t\ttry (final CloseableHttpResponse response = httpclient.execute(httpGet)) {\n+\t\t\t\tAcmeFatUtils.logHttpResponse(CAContainer.class, METHOD_NAME, httpGet, response);\n+\n+\t\t\t\tStatusLine statusLine = response.getStatusLine();\n+\n+\t\t\t\tif (statusLine.getStatusCode() != 200) {\n+\t\t\t\t\tthrow new IOException(\n+\t\t\t\t\t\t\tMETHOD_NAME + \": Expected response 200, but received response: \" + statusLine);\n+\t\t\t\t}\n+\n+\t\t\t\tbyte[] result = EntityUtils.toByteArray(response.getEntity());\n+\n+\t\t\t\tLog.info(CAContainer.class, METHOD_NAME, new String(result));\n+\t\t\t\treturn  new ByteArrayInputStream(result);\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Get the root certificate.\n+\t * \n+\t * @param fileName\n+\t *            The name of the file to save the certificate to.\n+\t * @return Certificate Authority's root certificate in the form of a PEM file.\n+\t * @throws Exception\n+\t *             If we failed to receive the certificate.\n+\t */\n+\tpublic byte[] getAcmeCaRootCertificate() throws Exception {\n+\t\tfinal String METHOD_NAME = \"getAcmeCaRootCertificate()\";\n+\t\tString url = \"https://\" + this.getContainerIpAddress() + \":\" + this.getMappedPort(MANAGEMENT_PORT) + \"/roots/0\";\n+\n+\t\ttry (CloseableHttpClient httpclient = AcmeFatUtils.getInsecureHttpsClient()) {\n+\t\t\t/*\n+\t\t\t * Create a GET request to the ACME CA server.\n+\t\t\t */\n+\t\t\tHttpGet httpGet = new HttpGet(url);\n+\n+\t\t\t/*\n+\t\t\t * Send the GET request and process the response.\n+\t\t\t */\n+\t\t\ttry (final CloseableHttpResponse response = httpclient.execute(httpGet)) {\n+\t\t\t\tAcmeFatUtils.logHttpResponse(CAContainer.class, METHOD_NAME, httpGet, response);\n+\n+\t\t\t\tStatusLine statusLine = response.getStatusLine();\n+\n+\t\t\t\tif (statusLine.getStatusCode() != 200) {\n+\t\t\t\t\tthrow new IOException(\n+\t\t\t\t\t\t\tMETHOD_NAME + \": Expected response 200, but received response: \" + statusLine);\n+\t\t\t\t}\n+\n+\t\t\t\tbyte[] result = EntityUtils.toByteArray(response.getEntity());\n+\n+\t\t\t\tLog.info(CAContainer.class, METHOD_NAME, new String(result));\n+\t\t\t\treturn result;\n+\t\t\t}\n+\t\t}\n+\t}\n+\t\n+\t/**\n+\t * Get the status of the certificate from the ACME CA server.\n+\t * \n+\t * @param certificate\n+\t *            The certificate to check.\n+\t * @return The status of the certificate.\n+\t * @throws Exception\n+\t */\n+\tpublic String getAcmeCertificateStatus(X509Certificate certificate) throws Exception {\n+\t\tfinal String METHOD_NAME = \"getAcmeCertificateStatus()\";\n+\t\tString url = \"https://\" + this.getContainerIpAddress() + \":\" + this.getMappedPort(MANAGEMENT_PORT)\n+\t\t\t\t+ \"/cert-status-by-serial/\" + certificate.getSerialNumber().toString(16);\n+\n+\t\ttry (CloseableHttpClient httpclient = AcmeFatUtils.getInsecureHttpsClient()) {\n+\t\t\t/*\n+\t\t\t * Create a GET request to the ACME CA server.\n+\t\t\t */\n+\t\t\tHttpGet httpGet = new HttpGet(url);\n+\n+\t\t\t/*\n+\t\t\t * Send the GET request and process the response.\n+\t\t\t */\n+\t\t\ttry (final CloseableHttpResponse response = httpclient.execute(httpGet)) {\n+\t\t\t\tAcmeFatUtils.logHttpResponse(CAContainer.class, METHOD_NAME, httpGet, response);\n+\n+\t\t\t\tStatusLine statusLine = response.getStatusLine();\n+\n+\t\t\t\tif (statusLine.getStatusCode() != 200) {\n+\t\t\t\t\tthrow new IOException(\n+\t\t\t\t\t\t\tMETHOD_NAME + \": Expected response 200, but received response: \" + statusLine);\n+\t\t\t\t}\n+\n+\t\t\t\tString result = EntityUtils.toString(response.getEntity());\n+\n+\t\t\t\t/*\n+\t\t\t\t * The result is in JSON, lets just parse out the status.\n+\t\t\t\t */\n+\t\t\t\tPattern p = Pattern.compile(\".*\\\"Status\\\": \\\"(\\\\w+)\\\",.*\", Pattern.DOTALL);\n+\t\t\t\tMatcher m = p.matcher(result);\n+\t\t\t\tif (m.find()) {\n+\t\t\t\t\tresult = m.group(1);\n+\t\t\t\t} else {\n+\t\t\t\t\tthrow new Exception(\n+\t\t\t\t\t\t\t\"Certificate status response was not in expected JSON format. Response: \" + result);\n+\t\t\t\t}\n+\n+\t\t\t\tLog.info(CAContainer.class, METHOD_NAME, new String(result));\n+\t\t\t\treturn result;\n+\t\t\t}\n+\t\t}\n+\t}\n+\t\n+\t/**\n+\t * Retrieves the client host's IP address that is reachable from the\n+\t * container.\n+\t * \n+\t * @return The client host's IP address that is reachable from the\n+\t *         container.\n+\t * @throws IllegalStateException\n+\t *             If the address was not found.\n+\t */\n+\tpublic String getClientHost() throws IllegalStateException {\n+\t\tfor (String extraHost : this.getExtraHosts()) {\n+\t\t\tif (extraHost.startsWith(\"host.testcontainers.internal:\")) {\n+\t\t\t\treturn extraHost.replace(\"host.testcontainers.internal:\", \"\");\n+\t\t\t}\n+\t\t}\n+\n+\t\tthrow new IllegalStateException(\n+\t\t\t\t\"Unable to resolve local host from docker container. Could not find 'host.testcontainers.internal' property.\");\n+\t}\n+\t\n+\t/**\n+\t * Add A and AAAA records.\n+\t */\n+    public void addARecords() {\n+    \ttry {\n+\t\t\tfor (String domain : new String[] { TEST_DOMAIN_1, TEST_DOMAIN_2, TEST_DOMAIN_3, TEST_DOMAIN_4 }) {\n+\t\t\t\t/*\n+\t\t\t\t * Disable the IPv6 responses for this domain. The Boulder CA server\n+\t\t\t\t * responds on AAAA (IPv6) responses before A (IPv4) responses, and\n+\t\t\t\t * we don't currently have the testcontainer host's IPv6 address.\n+\t\t\t\t */\n+\t\t\t\taddARecord(domain, getClientHost());\n+\t\t\t\taddAAAARecord(domain, \"\");\n+\t\t\t}\n+    \t} catch (Exception e) {\n+    \t\tLog.error(CAContainer.class, \"addARecords\", e);\n+    \t}\n+    }\n+    /**\n+     * Convenience method for adding A records.\n+\t * @param host\n+\t *            The host / domain to redirect requests for.\n+     */\n+\tpublic void addARecord(String domain) throws IOException {\n+\t\taddARecord(domain, getClientHost());\n+\t}\n+\t/**\n+\t * Add an A record to the mock DNS server. This will allow us to redirect\n+\t * requests to a named domain to the IPv4 address of our choice.\n+\t * \n+\t * @param host\n+\t *            The host / domain to redirect requests for.\n+\t * @param address\n+\t *            The address to direct the requests for that host to.\n+\t * @throws IOException\n+\t */\n+\tpublic void addARecord(String host, String address) throws IOException {\n+\t\tfinal String METHOD_NAME = \"addARecord\";\n+\n+\t\ttry (CloseableHttpClient httpclient = HttpClients.createDefault()) {\n+\n+\t\t\t/*\n+\t\t\t * Generate the JSON request. The request can support multiple\n+\t\t\t * addresses but for the time being we will only support sending\n+\t\t\t * one.\n+\t\t\t */\n+\t\t\tString jsonString = \"{\\\"host\\\":\\\"\" + host + \"\\\",\\\"addresses\\\":[\\\"\" + address + \"\\\"]}\";\n+\t\t\tStringEntity requestEntity = new StringEntity(jsonString, ContentType.APPLICATION_JSON);\n+\n+\t\t\t/*\n+\t\t\t * Create a POST request to the mock DNS server.\n+\t\t\t */\n+\t\t\tHttpPost httpPost = new HttpPost(getManagementAddress() + \"/add-a\");\n+\t\t\thttpPost.setEntity(requestEntity);\n+\t\t\t/*\n+\t\t\t * Send the POST request and process the response.\n+\t\t\t */\n+\t\t\ttry (final CloseableHttpResponse response = httpclient.execute(httpPost)) {\n+\t\t\t\tAcmeFatUtils.logHttpResponse(CAContainer.class, METHOD_NAME, httpPost, response);\n+\n+\t\t\t\tStatusLine statusLine = response.getStatusLine();\n+\t\t\t\tif (statusLine.getStatusCode() != 200) {\n+\t\t\t\t\tthrow new IOException(\n+\t\t\t\t\t\t\tMETHOD_NAME + \": Expected response 200, but received response: \" + statusLine);\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t}\n+\t\n+\t/**\n+\t * Add an AAAA record to the mock DNS server. This will allow us to redirect\n+\t * requests to a named domain to the IPv6 address of our choice.\n+\t * \n+\t * @param host\n+\t *            The host / domain to redirect requests for.\n+\t * @param address\n+\t *            The address to direct the requests for that host to.\n+\t * @throws IOException\n+\t */\n+\tpublic void addAAAARecord(String host, String address) throws IOException {\n+\t\tfinal String METHOD_NAME = \"addAAAARecord\";\n+\n+\t\ttry (CloseableHttpClient httpclient = HttpClients.createDefault()) {\n+\n+\t\t\t/*\n+\t\t\t * Generate the JSON request. The request can support multiple\n+\t\t\t * addresses but for the time being we will only support sending\n+\t\t\t * one.\n+\t\t\t */\n+\t\t\tString jsonString = \"{\\\"host\\\":\\\"\" + host + \"\\\",\\\"addresses\\\":[\\\"\" + address + \"\\\"]}\";\n+\t\t\tStringEntity requestEntity = new StringEntity(jsonString, ContentType.APPLICATION_JSON);\n+\n+\t\t\t/*\n+\t\t\t * Create a POST request to the mock DNS server.\n+\t\t\t */\n+\t\t\tHttpPost httpPost = new HttpPost(getManagementAddress() + \"/add-aaaa\");\n+\t\t\thttpPost.setEntity(requestEntity);\n+\n+\t\t\t/*\n+\t\t\t * Send the POST request and process the response.\n+\t\t\t */\n+\t\t\ttry (final CloseableHttpResponse response = httpclient.execute(httpPost)) {\n+\t\t\t\tAcmeFatUtils.logHttpResponse(CAContainer.class, METHOD_NAME, httpPost, response);\n+\n+\t\t\t\tStatusLine statusLine = response.getStatusLine();\n+\t\t\t\tif (statusLine.getStatusCode() != 200) {\n+\t\t\t\t\tthrow new IOException(\n+\t\t\t\t\t\t\tMETHOD_NAME + \": Expected response 200, but received response: \" + statusLine);\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t}\n+\t/**\n+\t * Clear a previously added AAAA record that was added to the mock DNS\n+\t * server.\n+\t * \n+\t * @param host\n+\t *            The host / domain to redirect requests for.\n+\t * @throws IOException\n+\t */\n+\tpublic void clearAAAARecord(String host) throws IOException {\n+\t\tfinal String METHOD_NAME = \"clearAAAARecord(String)\";\n+\n+\t\ttry (CloseableHttpClient httpclient = HttpClients.createDefault()) {\n+\t\t\t/*\n+\t\t\t * Generate the JSON request.\n+\t\t\t */\n+\t\t\tString jsonString = \"{\\\"host\\\":\\\"\" + host + \"\\\"}\";\n+\t\t\tStringEntity requestEntity = new StringEntity(jsonString, ContentType.APPLICATION_JSON);\n+\n+\t\t\t/*\n+\t\t\t * Create a POST request to the mock DNS server.\n+\t\t\t */\n+\t\t\tHttpPost httpPost = new HttpPost(getManagementAddress() + \"/clear-aaaa\");\n+\t\t\thttpPost.setEntity(requestEntity);\n+\n+\t\t\t/*\n+\t\t\t * Send the POST request and process the response.\n+\t\t\t */\n+\t\t\ttry (final CloseableHttpResponse response = httpclient.execute(httpPost)) {\n+\t\t\t\tAcmeFatUtils.logHttpResponse(CAContainer.class, METHOD_NAME, httpPost, response);\n+\n+\t\t\t\tStatusLine statusLine = response.getStatusLine();\n+\t\t\t\tif (statusLine.getStatusCode() != 200) {\n+\t\t\t\t\tthrow new IOException(\n+\t\t\t\t\t\t\tMETHOD_NAME + \": Expected response 200, but received response: \" + statusLine);\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Clear a previously added A record that was added to the mock DNS server.\n+\t * \n+\t * @param host\n+\t *            The host / domain to redirect requests for.\n+\t * @throws IOException\n+\t */\n+\tpublic void clearARecord(String host) throws IOException {\n+\t\tfinal String METHOD_NAME = \"clearMockARecord(String)\";\n+\n+\t\ttry (CloseableHttpClient httpclient = HttpClients.createDefault()) {\n+\t\t\t/*\n+\t\t\t * Generate the JSON request.\n+\t\t\t */\n+\t\t\tString jsonString = \"{\\\"host\\\":\\\"\" + host + \"\\\"}\";\n+\t\t\tStringEntity requestEntity = new StringEntity(jsonString, ContentType.APPLICATION_JSON);\n+\n+\t\t\t/*\n+\t\t\t * Create a POST request to the mock DNS server.\n+\t\t\t */\n+\t\t\tHttpPost httpPost = new HttpPost(getManagementAddress() + \"/clear-a\");\n+\t\t\thttpPost.setEntity(requestEntity);\n+\n+\t\t\t/*\n+\t\t\t * Send the POST request and process the response.\n+\t\t\t */\n+\t\t\ttry (final CloseableHttpResponse response = httpclient.execute(httpPost)) {\n+\t\t\t\tAcmeFatUtils.logHttpResponse(CAContainer.class, METHOD_NAME, httpPost, response);\n+\n+\t\t\t\tStatusLine statusLine = response.getStatusLine();\n+\t\t\t\tif (statusLine.getStatusCode() != 200) {\n+\t\t\t\t\tthrow new IOException(\n+\t\t\t\t\t\t\tMETHOD_NAME + \": Expected response 200, but received response: \" + statusLine);\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t}\n+\t/**\n+\t * The HTTP address that can be used the reach the REST management API for\n+\t * the server.\n+\t * \n+\t * @return The HTTP address to the REST management endpoint.\n+\t */\n+\tpublic String getManagementAddress() {\n+\t\treturn \"http://\" + this.getContainerIpAddress() + \":\" + this.getMappedPort(MANAGEMENT_PORT);\n+\t}\n+\n+\t/*\n+\t * The following methods should be overridden in the respective container class.\n+\t */\n+\t\n+\t/**\n+\t * Get the URI to the ACME CA's directory.\n+\t * \n+\t * @param usePebbleURI\n+\t *            Use the \"acme://pebble\" style URI instead of the generic\n+\t *            \"https:\" URI. This param is ignored for Boulder.\n+\t * @return The URI to the ACME CA's directory.\n+\t */\n+\tpublic String getAcmeDirectoryURI(boolean usePebbleURI) {\n+\t\treturn null;\n+\t}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3c28406c01e42dd902f376fac4532e84cf17aa5f"}, "originalPosition": 433}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUwODU1ODkwOnYy", "diffSide": "RIGHT", "path": "dev/com.ibm.ws.security.acme_fat/fat/src/com/ibm/ws/security/acme/docker/CAContainer.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wNlQxNzozNzozNFrOGBiszA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wNlQxNzozNzozNFrOGBiszA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDI3MDI4NA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \tpublic String getIntraContainerIP() {\n          \n          \n            \n            \tpublic abstract String getIntraContainerIP();", "url": "https://github.com/OpenLiberty/open-liberty/pull/11374#discussion_r404270284", "createdAt": "2020-04-06T17:37:34Z", "author": {"login": "jvanhill"}, "path": "dev/com.ibm.ws.security.acme_fat/fat/src/com/ibm/ws/security/acme/docker/CAContainer.java", "diffHunk": "@@ -0,0 +1,442 @@\n+/*******************************************************************************\n+ * Copyright (c) 2019, 2020 IBM Corporation and others.\n+ * All rights reserved. This program and the accompanying materials\n+ * are made available under the terms of the Eclipse Public License v1.0\n+ * which accompanies this distribution, and is available at\n+ * http://www.eclipse.org/legal/epl-v10.html\n+ *\n+ * Contributors:\n+ *     IBM Corporation - initial API and implementation\n+ *******************************************************************************/\n+package com.ibm.ws.security.acme.docker;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.security.cert.X509Certificate;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import org.apache.http.StatusLine;\n+import org.apache.http.client.methods.CloseableHttpResponse;\n+import org.apache.http.client.methods.HttpGet;\n+import org.apache.http.client.methods.HttpPost;\n+import org.apache.http.entity.ContentType;\n+import org.apache.http.entity.StringEntity;\n+import org.apache.http.impl.client.CloseableHttpClient;\n+import org.apache.http.impl.client.HttpClients;\n+import org.apache.http.util.EntityUtils;\n+import org.testcontainers.containers.GenericContainer;\n+import org.testcontainers.images.builder.ImageFromDockerfile;\n+\n+import com.ibm.websphere.simplicity.log.Log;\n+import com.ibm.ws.security.acme.utils.AcmeFatUtils;\n+\n+/**\n+ * Testcontainer implementation for Pebble and Boulder Certificate Authorities.\n+ * \n+ */\n+public class CAContainer extends GenericContainer<CAContainer> {\n+\n+\tprivate static final String TEST_DOMAIN_1 = \"domain1.com\";\n+\tprivate static final String TEST_DOMAIN_2 = \"domain2.com\";\n+\tprivate static final String TEST_DOMAIN_3 = \"domain3.com\";\n+\tprivate static final String TEST_DOMAIN_4 = \"domain4.com\";\n+\t\n+\t/** Challenge server port. */\n+\tpublic static final int HTTP_PORT = 5002;\n+\t/** The REST management API port. */\n+\tpublic int MANAGEMENT_PORT = 8055;\n+\t\n+\t/**\n+\t * This constructor is used by BoulderContainer\n+\t */\n+\tpublic CAContainer(String image) {\n+\t\tsuper(image);\n+\t}\n+\n+\t/**\n+\t * This constructor is used by PebbleContainer. The\n+\t * management port is different for Pebble, so this\n+\t * is passed in.\n+\t */\n+\tpublic CAContainer(ImageFromDockerfile image, int managementPort) {\n+\t\tsuper(image);\n+\t\tMANAGEMENT_PORT = managementPort;\n+\t}\n+\n+\t/**\n+\t * Get CA's intermediate certificate.\n+\t * \n+\t * @param fileName\n+\t *            The name of the file to save the certificate to.\n+\t * @return CA's intermediate certificate in the form of a PEM file.\n+\t * @throws Exception\n+\t *             If we failed to receive the certificate.\n+\t */\n+\tpublic InputStream getAcmeCaIntermediateCertificate() throws Exception {\n+\t\tfinal String METHOD_NAME = \"getAcmeCaIntermediateCertificate()\";\n+\t\tString url = \"https://\" + this.getContainerIpAddress() + \":\" + this.getMappedPort(MANAGEMENT_PORT)\n+\t\t\t\t+ \"/intermediates/0\";\n+\n+\t\ttry (CloseableHttpClient httpclient = AcmeFatUtils.getInsecureHttpsClient()) {\n+\t\t\t/*\n+\t\t\t * Create a GET request to the ACME CA server.\n+\t\t\t */\n+\t\t\tHttpGet httpGet = new HttpGet(url);\n+\n+\t\t\t/*\n+\t\t\t * Send the GET request and process the response.\n+\t\t\t */\n+\t\t\ttry (final CloseableHttpResponse response = httpclient.execute(httpGet)) {\n+\t\t\t\tAcmeFatUtils.logHttpResponse(CAContainer.class, METHOD_NAME, httpGet, response);\n+\n+\t\t\t\tStatusLine statusLine = response.getStatusLine();\n+\n+\t\t\t\tif (statusLine.getStatusCode() != 200) {\n+\t\t\t\t\tthrow new IOException(\n+\t\t\t\t\t\t\tMETHOD_NAME + \": Expected response 200, but received response: \" + statusLine);\n+\t\t\t\t}\n+\n+\t\t\t\tbyte[] result = EntityUtils.toByteArray(response.getEntity());\n+\n+\t\t\t\tLog.info(CAContainer.class, METHOD_NAME, new String(result));\n+\t\t\t\treturn  new ByteArrayInputStream(result);\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Get the root certificate.\n+\t * \n+\t * @param fileName\n+\t *            The name of the file to save the certificate to.\n+\t * @return Certificate Authority's root certificate in the form of a PEM file.\n+\t * @throws Exception\n+\t *             If we failed to receive the certificate.\n+\t */\n+\tpublic byte[] getAcmeCaRootCertificate() throws Exception {\n+\t\tfinal String METHOD_NAME = \"getAcmeCaRootCertificate()\";\n+\t\tString url = \"https://\" + this.getContainerIpAddress() + \":\" + this.getMappedPort(MANAGEMENT_PORT) + \"/roots/0\";\n+\n+\t\ttry (CloseableHttpClient httpclient = AcmeFatUtils.getInsecureHttpsClient()) {\n+\t\t\t/*\n+\t\t\t * Create a GET request to the ACME CA server.\n+\t\t\t */\n+\t\t\tHttpGet httpGet = new HttpGet(url);\n+\n+\t\t\t/*\n+\t\t\t * Send the GET request and process the response.\n+\t\t\t */\n+\t\t\ttry (final CloseableHttpResponse response = httpclient.execute(httpGet)) {\n+\t\t\t\tAcmeFatUtils.logHttpResponse(CAContainer.class, METHOD_NAME, httpGet, response);\n+\n+\t\t\t\tStatusLine statusLine = response.getStatusLine();\n+\n+\t\t\t\tif (statusLine.getStatusCode() != 200) {\n+\t\t\t\t\tthrow new IOException(\n+\t\t\t\t\t\t\tMETHOD_NAME + \": Expected response 200, but received response: \" + statusLine);\n+\t\t\t\t}\n+\n+\t\t\t\tbyte[] result = EntityUtils.toByteArray(response.getEntity());\n+\n+\t\t\t\tLog.info(CAContainer.class, METHOD_NAME, new String(result));\n+\t\t\t\treturn result;\n+\t\t\t}\n+\t\t}\n+\t}\n+\t\n+\t/**\n+\t * Get the status of the certificate from the ACME CA server.\n+\t * \n+\t * @param certificate\n+\t *            The certificate to check.\n+\t * @return The status of the certificate.\n+\t * @throws Exception\n+\t */\n+\tpublic String getAcmeCertificateStatus(X509Certificate certificate) throws Exception {\n+\t\tfinal String METHOD_NAME = \"getAcmeCertificateStatus()\";\n+\t\tString url = \"https://\" + this.getContainerIpAddress() + \":\" + this.getMappedPort(MANAGEMENT_PORT)\n+\t\t\t\t+ \"/cert-status-by-serial/\" + certificate.getSerialNumber().toString(16);\n+\n+\t\ttry (CloseableHttpClient httpclient = AcmeFatUtils.getInsecureHttpsClient()) {\n+\t\t\t/*\n+\t\t\t * Create a GET request to the ACME CA server.\n+\t\t\t */\n+\t\t\tHttpGet httpGet = new HttpGet(url);\n+\n+\t\t\t/*\n+\t\t\t * Send the GET request and process the response.\n+\t\t\t */\n+\t\t\ttry (final CloseableHttpResponse response = httpclient.execute(httpGet)) {\n+\t\t\t\tAcmeFatUtils.logHttpResponse(CAContainer.class, METHOD_NAME, httpGet, response);\n+\n+\t\t\t\tStatusLine statusLine = response.getStatusLine();\n+\n+\t\t\t\tif (statusLine.getStatusCode() != 200) {\n+\t\t\t\t\tthrow new IOException(\n+\t\t\t\t\t\t\tMETHOD_NAME + \": Expected response 200, but received response: \" + statusLine);\n+\t\t\t\t}\n+\n+\t\t\t\tString result = EntityUtils.toString(response.getEntity());\n+\n+\t\t\t\t/*\n+\t\t\t\t * The result is in JSON, lets just parse out the status.\n+\t\t\t\t */\n+\t\t\t\tPattern p = Pattern.compile(\".*\\\"Status\\\": \\\"(\\\\w+)\\\",.*\", Pattern.DOTALL);\n+\t\t\t\tMatcher m = p.matcher(result);\n+\t\t\t\tif (m.find()) {\n+\t\t\t\t\tresult = m.group(1);\n+\t\t\t\t} else {\n+\t\t\t\t\tthrow new Exception(\n+\t\t\t\t\t\t\t\"Certificate status response was not in expected JSON format. Response: \" + result);\n+\t\t\t\t}\n+\n+\t\t\t\tLog.info(CAContainer.class, METHOD_NAME, new String(result));\n+\t\t\t\treturn result;\n+\t\t\t}\n+\t\t}\n+\t}\n+\t\n+\t/**\n+\t * Retrieves the client host's IP address that is reachable from the\n+\t * container.\n+\t * \n+\t * @return The client host's IP address that is reachable from the\n+\t *         container.\n+\t * @throws IllegalStateException\n+\t *             If the address was not found.\n+\t */\n+\tpublic String getClientHost() throws IllegalStateException {\n+\t\tfor (String extraHost : this.getExtraHosts()) {\n+\t\t\tif (extraHost.startsWith(\"host.testcontainers.internal:\")) {\n+\t\t\t\treturn extraHost.replace(\"host.testcontainers.internal:\", \"\");\n+\t\t\t}\n+\t\t}\n+\n+\t\tthrow new IllegalStateException(\n+\t\t\t\t\"Unable to resolve local host from docker container. Could not find 'host.testcontainers.internal' property.\");\n+\t}\n+\t\n+\t/**\n+\t * Add A and AAAA records.\n+\t */\n+    public void addARecords() {\n+    \ttry {\n+\t\t\tfor (String domain : new String[] { TEST_DOMAIN_1, TEST_DOMAIN_2, TEST_DOMAIN_3, TEST_DOMAIN_4 }) {\n+\t\t\t\t/*\n+\t\t\t\t * Disable the IPv6 responses for this domain. The Boulder CA server\n+\t\t\t\t * responds on AAAA (IPv6) responses before A (IPv4) responses, and\n+\t\t\t\t * we don't currently have the testcontainer host's IPv6 address.\n+\t\t\t\t */\n+\t\t\t\taddARecord(domain, getClientHost());\n+\t\t\t\taddAAAARecord(domain, \"\");\n+\t\t\t}\n+    \t} catch (Exception e) {\n+    \t\tLog.error(CAContainer.class, \"addARecords\", e);\n+    \t}\n+    }\n+    /**\n+     * Convenience method for adding A records.\n+\t * @param host\n+\t *            The host / domain to redirect requests for.\n+     */\n+\tpublic void addARecord(String domain) throws IOException {\n+\t\taddARecord(domain, getClientHost());\n+\t}\n+\t/**\n+\t * Add an A record to the mock DNS server. This will allow us to redirect\n+\t * requests to a named domain to the IPv4 address of our choice.\n+\t * \n+\t * @param host\n+\t *            The host / domain to redirect requests for.\n+\t * @param address\n+\t *            The address to direct the requests for that host to.\n+\t * @throws IOException\n+\t */\n+\tpublic void addARecord(String host, String address) throws IOException {\n+\t\tfinal String METHOD_NAME = \"addARecord\";\n+\n+\t\ttry (CloseableHttpClient httpclient = HttpClients.createDefault()) {\n+\n+\t\t\t/*\n+\t\t\t * Generate the JSON request. The request can support multiple\n+\t\t\t * addresses but for the time being we will only support sending\n+\t\t\t * one.\n+\t\t\t */\n+\t\t\tString jsonString = \"{\\\"host\\\":\\\"\" + host + \"\\\",\\\"addresses\\\":[\\\"\" + address + \"\\\"]}\";\n+\t\t\tStringEntity requestEntity = new StringEntity(jsonString, ContentType.APPLICATION_JSON);\n+\n+\t\t\t/*\n+\t\t\t * Create a POST request to the mock DNS server.\n+\t\t\t */\n+\t\t\tHttpPost httpPost = new HttpPost(getManagementAddress() + \"/add-a\");\n+\t\t\thttpPost.setEntity(requestEntity);\n+\t\t\t/*\n+\t\t\t * Send the POST request and process the response.\n+\t\t\t */\n+\t\t\ttry (final CloseableHttpResponse response = httpclient.execute(httpPost)) {\n+\t\t\t\tAcmeFatUtils.logHttpResponse(CAContainer.class, METHOD_NAME, httpPost, response);\n+\n+\t\t\t\tStatusLine statusLine = response.getStatusLine();\n+\t\t\t\tif (statusLine.getStatusCode() != 200) {\n+\t\t\t\t\tthrow new IOException(\n+\t\t\t\t\t\t\tMETHOD_NAME + \": Expected response 200, but received response: \" + statusLine);\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t}\n+\t\n+\t/**\n+\t * Add an AAAA record to the mock DNS server. This will allow us to redirect\n+\t * requests to a named domain to the IPv6 address of our choice.\n+\t * \n+\t * @param host\n+\t *            The host / domain to redirect requests for.\n+\t * @param address\n+\t *            The address to direct the requests for that host to.\n+\t * @throws IOException\n+\t */\n+\tpublic void addAAAARecord(String host, String address) throws IOException {\n+\t\tfinal String METHOD_NAME = \"addAAAARecord\";\n+\n+\t\ttry (CloseableHttpClient httpclient = HttpClients.createDefault()) {\n+\n+\t\t\t/*\n+\t\t\t * Generate the JSON request. The request can support multiple\n+\t\t\t * addresses but for the time being we will only support sending\n+\t\t\t * one.\n+\t\t\t */\n+\t\t\tString jsonString = \"{\\\"host\\\":\\\"\" + host + \"\\\",\\\"addresses\\\":[\\\"\" + address + \"\\\"]}\";\n+\t\t\tStringEntity requestEntity = new StringEntity(jsonString, ContentType.APPLICATION_JSON);\n+\n+\t\t\t/*\n+\t\t\t * Create a POST request to the mock DNS server.\n+\t\t\t */\n+\t\t\tHttpPost httpPost = new HttpPost(getManagementAddress() + \"/add-aaaa\");\n+\t\t\thttpPost.setEntity(requestEntity);\n+\n+\t\t\t/*\n+\t\t\t * Send the POST request and process the response.\n+\t\t\t */\n+\t\t\ttry (final CloseableHttpResponse response = httpclient.execute(httpPost)) {\n+\t\t\t\tAcmeFatUtils.logHttpResponse(CAContainer.class, METHOD_NAME, httpPost, response);\n+\n+\t\t\t\tStatusLine statusLine = response.getStatusLine();\n+\t\t\t\tif (statusLine.getStatusCode() != 200) {\n+\t\t\t\t\tthrow new IOException(\n+\t\t\t\t\t\t\tMETHOD_NAME + \": Expected response 200, but received response: \" + statusLine);\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t}\n+\t/**\n+\t * Clear a previously added AAAA record that was added to the mock DNS\n+\t * server.\n+\t * \n+\t * @param host\n+\t *            The host / domain to redirect requests for.\n+\t * @throws IOException\n+\t */\n+\tpublic void clearAAAARecord(String host) throws IOException {\n+\t\tfinal String METHOD_NAME = \"clearAAAARecord(String)\";\n+\n+\t\ttry (CloseableHttpClient httpclient = HttpClients.createDefault()) {\n+\t\t\t/*\n+\t\t\t * Generate the JSON request.\n+\t\t\t */\n+\t\t\tString jsonString = \"{\\\"host\\\":\\\"\" + host + \"\\\"}\";\n+\t\t\tStringEntity requestEntity = new StringEntity(jsonString, ContentType.APPLICATION_JSON);\n+\n+\t\t\t/*\n+\t\t\t * Create a POST request to the mock DNS server.\n+\t\t\t */\n+\t\t\tHttpPost httpPost = new HttpPost(getManagementAddress() + \"/clear-aaaa\");\n+\t\t\thttpPost.setEntity(requestEntity);\n+\n+\t\t\t/*\n+\t\t\t * Send the POST request and process the response.\n+\t\t\t */\n+\t\t\ttry (final CloseableHttpResponse response = httpclient.execute(httpPost)) {\n+\t\t\t\tAcmeFatUtils.logHttpResponse(CAContainer.class, METHOD_NAME, httpPost, response);\n+\n+\t\t\t\tStatusLine statusLine = response.getStatusLine();\n+\t\t\t\tif (statusLine.getStatusCode() != 200) {\n+\t\t\t\t\tthrow new IOException(\n+\t\t\t\t\t\t\tMETHOD_NAME + \": Expected response 200, but received response: \" + statusLine);\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Clear a previously added A record that was added to the mock DNS server.\n+\t * \n+\t * @param host\n+\t *            The host / domain to redirect requests for.\n+\t * @throws IOException\n+\t */\n+\tpublic void clearARecord(String host) throws IOException {\n+\t\tfinal String METHOD_NAME = \"clearMockARecord(String)\";\n+\n+\t\ttry (CloseableHttpClient httpclient = HttpClients.createDefault()) {\n+\t\t\t/*\n+\t\t\t * Generate the JSON request.\n+\t\t\t */\n+\t\t\tString jsonString = \"{\\\"host\\\":\\\"\" + host + \"\\\"}\";\n+\t\t\tStringEntity requestEntity = new StringEntity(jsonString, ContentType.APPLICATION_JSON);\n+\n+\t\t\t/*\n+\t\t\t * Create a POST request to the mock DNS server.\n+\t\t\t */\n+\t\t\tHttpPost httpPost = new HttpPost(getManagementAddress() + \"/clear-a\");\n+\t\t\thttpPost.setEntity(requestEntity);\n+\n+\t\t\t/*\n+\t\t\t * Send the POST request and process the response.\n+\t\t\t */\n+\t\t\ttry (final CloseableHttpResponse response = httpclient.execute(httpPost)) {\n+\t\t\t\tAcmeFatUtils.logHttpResponse(CAContainer.class, METHOD_NAME, httpPost, response);\n+\n+\t\t\t\tStatusLine statusLine = response.getStatusLine();\n+\t\t\t\tif (statusLine.getStatusCode() != 200) {\n+\t\t\t\t\tthrow new IOException(\n+\t\t\t\t\t\t\tMETHOD_NAME + \": Expected response 200, but received response: \" + statusLine);\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t}\n+\t/**\n+\t * The HTTP address that can be used the reach the REST management API for\n+\t * the server.\n+\t * \n+\t * @return The HTTP address to the REST management endpoint.\n+\t */\n+\tpublic String getManagementAddress() {\n+\t\treturn \"http://\" + this.getContainerIpAddress() + \":\" + this.getMappedPort(MANAGEMENT_PORT);\n+\t}\n+\n+\t/*\n+\t * The following methods should be overridden in the respective container class.\n+\t */\n+\t\n+\t/**\n+\t * Get the URI to the ACME CA's directory.\n+\t * \n+\t * @param usePebbleURI\n+\t *            Use the \"acme://pebble\" style URI instead of the generic\n+\t *            \"https:\" URI. This param is ignored for Boulder.\n+\t * @return The URI to the ACME CA's directory.\n+\t */\n+\tpublic String getAcmeDirectoryURI(boolean usePebbleURI) {\n+\t\treturn null;\n+\t}\n+\t/**\n+\t * Get the IP address for the container as seen from the container network.\n+\t * \n+\t * @return The IP address for the container on the container network.\n+\t */\n+\tpublic String getIntraContainerIP() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3c28406c01e42dd902f376fac4532e84cf17aa5f"}, "originalPosition": 439}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUwODU1OTkxOnYy", "diffSide": "RIGHT", "path": "dev/com.ibm.ws.security.acme_fat/fat/src/com/ibm/ws/security/acme/docker/CAContainer.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wNlQxNzozNzo0OFrOGBitZQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wNlQxNzozNzo0OFrOGBitZQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDI3MDQzNw==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t\treturn null;", "url": "https://github.com/OpenLiberty/open-liberty/pull/11374#discussion_r404270437", "createdAt": "2020-04-06T17:37:48Z", "author": {"login": "jvanhill"}, "path": "dev/com.ibm.ws.security.acme_fat/fat/src/com/ibm/ws/security/acme/docker/CAContainer.java", "diffHunk": "@@ -0,0 +1,442 @@\n+/*******************************************************************************\n+ * Copyright (c) 2019, 2020 IBM Corporation and others.\n+ * All rights reserved. This program and the accompanying materials\n+ * are made available under the terms of the Eclipse Public License v1.0\n+ * which accompanies this distribution, and is available at\n+ * http://www.eclipse.org/legal/epl-v10.html\n+ *\n+ * Contributors:\n+ *     IBM Corporation - initial API and implementation\n+ *******************************************************************************/\n+package com.ibm.ws.security.acme.docker;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.security.cert.X509Certificate;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import org.apache.http.StatusLine;\n+import org.apache.http.client.methods.CloseableHttpResponse;\n+import org.apache.http.client.methods.HttpGet;\n+import org.apache.http.client.methods.HttpPost;\n+import org.apache.http.entity.ContentType;\n+import org.apache.http.entity.StringEntity;\n+import org.apache.http.impl.client.CloseableHttpClient;\n+import org.apache.http.impl.client.HttpClients;\n+import org.apache.http.util.EntityUtils;\n+import org.testcontainers.containers.GenericContainer;\n+import org.testcontainers.images.builder.ImageFromDockerfile;\n+\n+import com.ibm.websphere.simplicity.log.Log;\n+import com.ibm.ws.security.acme.utils.AcmeFatUtils;\n+\n+/**\n+ * Testcontainer implementation for Pebble and Boulder Certificate Authorities.\n+ * \n+ */\n+public class CAContainer extends GenericContainer<CAContainer> {\n+\n+\tprivate static final String TEST_DOMAIN_1 = \"domain1.com\";\n+\tprivate static final String TEST_DOMAIN_2 = \"domain2.com\";\n+\tprivate static final String TEST_DOMAIN_3 = \"domain3.com\";\n+\tprivate static final String TEST_DOMAIN_4 = \"domain4.com\";\n+\t\n+\t/** Challenge server port. */\n+\tpublic static final int HTTP_PORT = 5002;\n+\t/** The REST management API port. */\n+\tpublic int MANAGEMENT_PORT = 8055;\n+\t\n+\t/**\n+\t * This constructor is used by BoulderContainer\n+\t */\n+\tpublic CAContainer(String image) {\n+\t\tsuper(image);\n+\t}\n+\n+\t/**\n+\t * This constructor is used by PebbleContainer. The\n+\t * management port is different for Pebble, so this\n+\t * is passed in.\n+\t */\n+\tpublic CAContainer(ImageFromDockerfile image, int managementPort) {\n+\t\tsuper(image);\n+\t\tMANAGEMENT_PORT = managementPort;\n+\t}\n+\n+\t/**\n+\t * Get CA's intermediate certificate.\n+\t * \n+\t * @param fileName\n+\t *            The name of the file to save the certificate to.\n+\t * @return CA's intermediate certificate in the form of a PEM file.\n+\t * @throws Exception\n+\t *             If we failed to receive the certificate.\n+\t */\n+\tpublic InputStream getAcmeCaIntermediateCertificate() throws Exception {\n+\t\tfinal String METHOD_NAME = \"getAcmeCaIntermediateCertificate()\";\n+\t\tString url = \"https://\" + this.getContainerIpAddress() + \":\" + this.getMappedPort(MANAGEMENT_PORT)\n+\t\t\t\t+ \"/intermediates/0\";\n+\n+\t\ttry (CloseableHttpClient httpclient = AcmeFatUtils.getInsecureHttpsClient()) {\n+\t\t\t/*\n+\t\t\t * Create a GET request to the ACME CA server.\n+\t\t\t */\n+\t\t\tHttpGet httpGet = new HttpGet(url);\n+\n+\t\t\t/*\n+\t\t\t * Send the GET request and process the response.\n+\t\t\t */\n+\t\t\ttry (final CloseableHttpResponse response = httpclient.execute(httpGet)) {\n+\t\t\t\tAcmeFatUtils.logHttpResponse(CAContainer.class, METHOD_NAME, httpGet, response);\n+\n+\t\t\t\tStatusLine statusLine = response.getStatusLine();\n+\n+\t\t\t\tif (statusLine.getStatusCode() != 200) {\n+\t\t\t\t\tthrow new IOException(\n+\t\t\t\t\t\t\tMETHOD_NAME + \": Expected response 200, but received response: \" + statusLine);\n+\t\t\t\t}\n+\n+\t\t\t\tbyte[] result = EntityUtils.toByteArray(response.getEntity());\n+\n+\t\t\t\tLog.info(CAContainer.class, METHOD_NAME, new String(result));\n+\t\t\t\treturn  new ByteArrayInputStream(result);\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Get the root certificate.\n+\t * \n+\t * @param fileName\n+\t *            The name of the file to save the certificate to.\n+\t * @return Certificate Authority's root certificate in the form of a PEM file.\n+\t * @throws Exception\n+\t *             If we failed to receive the certificate.\n+\t */\n+\tpublic byte[] getAcmeCaRootCertificate() throws Exception {\n+\t\tfinal String METHOD_NAME = \"getAcmeCaRootCertificate()\";\n+\t\tString url = \"https://\" + this.getContainerIpAddress() + \":\" + this.getMappedPort(MANAGEMENT_PORT) + \"/roots/0\";\n+\n+\t\ttry (CloseableHttpClient httpclient = AcmeFatUtils.getInsecureHttpsClient()) {\n+\t\t\t/*\n+\t\t\t * Create a GET request to the ACME CA server.\n+\t\t\t */\n+\t\t\tHttpGet httpGet = new HttpGet(url);\n+\n+\t\t\t/*\n+\t\t\t * Send the GET request and process the response.\n+\t\t\t */\n+\t\t\ttry (final CloseableHttpResponse response = httpclient.execute(httpGet)) {\n+\t\t\t\tAcmeFatUtils.logHttpResponse(CAContainer.class, METHOD_NAME, httpGet, response);\n+\n+\t\t\t\tStatusLine statusLine = response.getStatusLine();\n+\n+\t\t\t\tif (statusLine.getStatusCode() != 200) {\n+\t\t\t\t\tthrow new IOException(\n+\t\t\t\t\t\t\tMETHOD_NAME + \": Expected response 200, but received response: \" + statusLine);\n+\t\t\t\t}\n+\n+\t\t\t\tbyte[] result = EntityUtils.toByteArray(response.getEntity());\n+\n+\t\t\t\tLog.info(CAContainer.class, METHOD_NAME, new String(result));\n+\t\t\t\treturn result;\n+\t\t\t}\n+\t\t}\n+\t}\n+\t\n+\t/**\n+\t * Get the status of the certificate from the ACME CA server.\n+\t * \n+\t * @param certificate\n+\t *            The certificate to check.\n+\t * @return The status of the certificate.\n+\t * @throws Exception\n+\t */\n+\tpublic String getAcmeCertificateStatus(X509Certificate certificate) throws Exception {\n+\t\tfinal String METHOD_NAME = \"getAcmeCertificateStatus()\";\n+\t\tString url = \"https://\" + this.getContainerIpAddress() + \":\" + this.getMappedPort(MANAGEMENT_PORT)\n+\t\t\t\t+ \"/cert-status-by-serial/\" + certificate.getSerialNumber().toString(16);\n+\n+\t\ttry (CloseableHttpClient httpclient = AcmeFatUtils.getInsecureHttpsClient()) {\n+\t\t\t/*\n+\t\t\t * Create a GET request to the ACME CA server.\n+\t\t\t */\n+\t\t\tHttpGet httpGet = new HttpGet(url);\n+\n+\t\t\t/*\n+\t\t\t * Send the GET request and process the response.\n+\t\t\t */\n+\t\t\ttry (final CloseableHttpResponse response = httpclient.execute(httpGet)) {\n+\t\t\t\tAcmeFatUtils.logHttpResponse(CAContainer.class, METHOD_NAME, httpGet, response);\n+\n+\t\t\t\tStatusLine statusLine = response.getStatusLine();\n+\n+\t\t\t\tif (statusLine.getStatusCode() != 200) {\n+\t\t\t\t\tthrow new IOException(\n+\t\t\t\t\t\t\tMETHOD_NAME + \": Expected response 200, but received response: \" + statusLine);\n+\t\t\t\t}\n+\n+\t\t\t\tString result = EntityUtils.toString(response.getEntity());\n+\n+\t\t\t\t/*\n+\t\t\t\t * The result is in JSON, lets just parse out the status.\n+\t\t\t\t */\n+\t\t\t\tPattern p = Pattern.compile(\".*\\\"Status\\\": \\\"(\\\\w+)\\\",.*\", Pattern.DOTALL);\n+\t\t\t\tMatcher m = p.matcher(result);\n+\t\t\t\tif (m.find()) {\n+\t\t\t\t\tresult = m.group(1);\n+\t\t\t\t} else {\n+\t\t\t\t\tthrow new Exception(\n+\t\t\t\t\t\t\t\"Certificate status response was not in expected JSON format. Response: \" + result);\n+\t\t\t\t}\n+\n+\t\t\t\tLog.info(CAContainer.class, METHOD_NAME, new String(result));\n+\t\t\t\treturn result;\n+\t\t\t}\n+\t\t}\n+\t}\n+\t\n+\t/**\n+\t * Retrieves the client host's IP address that is reachable from the\n+\t * container.\n+\t * \n+\t * @return The client host's IP address that is reachable from the\n+\t *         container.\n+\t * @throws IllegalStateException\n+\t *             If the address was not found.\n+\t */\n+\tpublic String getClientHost() throws IllegalStateException {\n+\t\tfor (String extraHost : this.getExtraHosts()) {\n+\t\t\tif (extraHost.startsWith(\"host.testcontainers.internal:\")) {\n+\t\t\t\treturn extraHost.replace(\"host.testcontainers.internal:\", \"\");\n+\t\t\t}\n+\t\t}\n+\n+\t\tthrow new IllegalStateException(\n+\t\t\t\t\"Unable to resolve local host from docker container. Could not find 'host.testcontainers.internal' property.\");\n+\t}\n+\t\n+\t/**\n+\t * Add A and AAAA records.\n+\t */\n+    public void addARecords() {\n+    \ttry {\n+\t\t\tfor (String domain : new String[] { TEST_DOMAIN_1, TEST_DOMAIN_2, TEST_DOMAIN_3, TEST_DOMAIN_4 }) {\n+\t\t\t\t/*\n+\t\t\t\t * Disable the IPv6 responses for this domain. The Boulder CA server\n+\t\t\t\t * responds on AAAA (IPv6) responses before A (IPv4) responses, and\n+\t\t\t\t * we don't currently have the testcontainer host's IPv6 address.\n+\t\t\t\t */\n+\t\t\t\taddARecord(domain, getClientHost());\n+\t\t\t\taddAAAARecord(domain, \"\");\n+\t\t\t}\n+    \t} catch (Exception e) {\n+    \t\tLog.error(CAContainer.class, \"addARecords\", e);\n+    \t}\n+    }\n+    /**\n+     * Convenience method for adding A records.\n+\t * @param host\n+\t *            The host / domain to redirect requests for.\n+     */\n+\tpublic void addARecord(String domain) throws IOException {\n+\t\taddARecord(domain, getClientHost());\n+\t}\n+\t/**\n+\t * Add an A record to the mock DNS server. This will allow us to redirect\n+\t * requests to a named domain to the IPv4 address of our choice.\n+\t * \n+\t * @param host\n+\t *            The host / domain to redirect requests for.\n+\t * @param address\n+\t *            The address to direct the requests for that host to.\n+\t * @throws IOException\n+\t */\n+\tpublic void addARecord(String host, String address) throws IOException {\n+\t\tfinal String METHOD_NAME = \"addARecord\";\n+\n+\t\ttry (CloseableHttpClient httpclient = HttpClients.createDefault()) {\n+\n+\t\t\t/*\n+\t\t\t * Generate the JSON request. The request can support multiple\n+\t\t\t * addresses but for the time being we will only support sending\n+\t\t\t * one.\n+\t\t\t */\n+\t\t\tString jsonString = \"{\\\"host\\\":\\\"\" + host + \"\\\",\\\"addresses\\\":[\\\"\" + address + \"\\\"]}\";\n+\t\t\tStringEntity requestEntity = new StringEntity(jsonString, ContentType.APPLICATION_JSON);\n+\n+\t\t\t/*\n+\t\t\t * Create a POST request to the mock DNS server.\n+\t\t\t */\n+\t\t\tHttpPost httpPost = new HttpPost(getManagementAddress() + \"/add-a\");\n+\t\t\thttpPost.setEntity(requestEntity);\n+\t\t\t/*\n+\t\t\t * Send the POST request and process the response.\n+\t\t\t */\n+\t\t\ttry (final CloseableHttpResponse response = httpclient.execute(httpPost)) {\n+\t\t\t\tAcmeFatUtils.logHttpResponse(CAContainer.class, METHOD_NAME, httpPost, response);\n+\n+\t\t\t\tStatusLine statusLine = response.getStatusLine();\n+\t\t\t\tif (statusLine.getStatusCode() != 200) {\n+\t\t\t\t\tthrow new IOException(\n+\t\t\t\t\t\t\tMETHOD_NAME + \": Expected response 200, but received response: \" + statusLine);\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t}\n+\t\n+\t/**\n+\t * Add an AAAA record to the mock DNS server. This will allow us to redirect\n+\t * requests to a named domain to the IPv6 address of our choice.\n+\t * \n+\t * @param host\n+\t *            The host / domain to redirect requests for.\n+\t * @param address\n+\t *            The address to direct the requests for that host to.\n+\t * @throws IOException\n+\t */\n+\tpublic void addAAAARecord(String host, String address) throws IOException {\n+\t\tfinal String METHOD_NAME = \"addAAAARecord\";\n+\n+\t\ttry (CloseableHttpClient httpclient = HttpClients.createDefault()) {\n+\n+\t\t\t/*\n+\t\t\t * Generate the JSON request. The request can support multiple\n+\t\t\t * addresses but for the time being we will only support sending\n+\t\t\t * one.\n+\t\t\t */\n+\t\t\tString jsonString = \"{\\\"host\\\":\\\"\" + host + \"\\\",\\\"addresses\\\":[\\\"\" + address + \"\\\"]}\";\n+\t\t\tStringEntity requestEntity = new StringEntity(jsonString, ContentType.APPLICATION_JSON);\n+\n+\t\t\t/*\n+\t\t\t * Create a POST request to the mock DNS server.\n+\t\t\t */\n+\t\t\tHttpPost httpPost = new HttpPost(getManagementAddress() + \"/add-aaaa\");\n+\t\t\thttpPost.setEntity(requestEntity);\n+\n+\t\t\t/*\n+\t\t\t * Send the POST request and process the response.\n+\t\t\t */\n+\t\t\ttry (final CloseableHttpResponse response = httpclient.execute(httpPost)) {\n+\t\t\t\tAcmeFatUtils.logHttpResponse(CAContainer.class, METHOD_NAME, httpPost, response);\n+\n+\t\t\t\tStatusLine statusLine = response.getStatusLine();\n+\t\t\t\tif (statusLine.getStatusCode() != 200) {\n+\t\t\t\t\tthrow new IOException(\n+\t\t\t\t\t\t\tMETHOD_NAME + \": Expected response 200, but received response: \" + statusLine);\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t}\n+\t/**\n+\t * Clear a previously added AAAA record that was added to the mock DNS\n+\t * server.\n+\t * \n+\t * @param host\n+\t *            The host / domain to redirect requests for.\n+\t * @throws IOException\n+\t */\n+\tpublic void clearAAAARecord(String host) throws IOException {\n+\t\tfinal String METHOD_NAME = \"clearAAAARecord(String)\";\n+\n+\t\ttry (CloseableHttpClient httpclient = HttpClients.createDefault()) {\n+\t\t\t/*\n+\t\t\t * Generate the JSON request.\n+\t\t\t */\n+\t\t\tString jsonString = \"{\\\"host\\\":\\\"\" + host + \"\\\"}\";\n+\t\t\tStringEntity requestEntity = new StringEntity(jsonString, ContentType.APPLICATION_JSON);\n+\n+\t\t\t/*\n+\t\t\t * Create a POST request to the mock DNS server.\n+\t\t\t */\n+\t\t\tHttpPost httpPost = new HttpPost(getManagementAddress() + \"/clear-aaaa\");\n+\t\t\thttpPost.setEntity(requestEntity);\n+\n+\t\t\t/*\n+\t\t\t * Send the POST request and process the response.\n+\t\t\t */\n+\t\t\ttry (final CloseableHttpResponse response = httpclient.execute(httpPost)) {\n+\t\t\t\tAcmeFatUtils.logHttpResponse(CAContainer.class, METHOD_NAME, httpPost, response);\n+\n+\t\t\t\tStatusLine statusLine = response.getStatusLine();\n+\t\t\t\tif (statusLine.getStatusCode() != 200) {\n+\t\t\t\t\tthrow new IOException(\n+\t\t\t\t\t\t\tMETHOD_NAME + \": Expected response 200, but received response: \" + statusLine);\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Clear a previously added A record that was added to the mock DNS server.\n+\t * \n+\t * @param host\n+\t *            The host / domain to redirect requests for.\n+\t * @throws IOException\n+\t */\n+\tpublic void clearARecord(String host) throws IOException {\n+\t\tfinal String METHOD_NAME = \"clearMockARecord(String)\";\n+\n+\t\ttry (CloseableHttpClient httpclient = HttpClients.createDefault()) {\n+\t\t\t/*\n+\t\t\t * Generate the JSON request.\n+\t\t\t */\n+\t\t\tString jsonString = \"{\\\"host\\\":\\\"\" + host + \"\\\"}\";\n+\t\t\tStringEntity requestEntity = new StringEntity(jsonString, ContentType.APPLICATION_JSON);\n+\n+\t\t\t/*\n+\t\t\t * Create a POST request to the mock DNS server.\n+\t\t\t */\n+\t\t\tHttpPost httpPost = new HttpPost(getManagementAddress() + \"/clear-a\");\n+\t\t\thttpPost.setEntity(requestEntity);\n+\n+\t\t\t/*\n+\t\t\t * Send the POST request and process the response.\n+\t\t\t */\n+\t\t\ttry (final CloseableHttpResponse response = httpclient.execute(httpPost)) {\n+\t\t\t\tAcmeFatUtils.logHttpResponse(CAContainer.class, METHOD_NAME, httpPost, response);\n+\n+\t\t\t\tStatusLine statusLine = response.getStatusLine();\n+\t\t\t\tif (statusLine.getStatusCode() != 200) {\n+\t\t\t\t\tthrow new IOException(\n+\t\t\t\t\t\t\tMETHOD_NAME + \": Expected response 200, but received response: \" + statusLine);\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t}\n+\t/**\n+\t * The HTTP address that can be used the reach the REST management API for\n+\t * the server.\n+\t * \n+\t * @return The HTTP address to the REST management endpoint.\n+\t */\n+\tpublic String getManagementAddress() {\n+\t\treturn \"http://\" + this.getContainerIpAddress() + \":\" + this.getMappedPort(MANAGEMENT_PORT);\n+\t}\n+\n+\t/*\n+\t * The following methods should be overridden in the respective container class.\n+\t */\n+\t\n+\t/**\n+\t * Get the URI to the ACME CA's directory.\n+\t * \n+\t * @param usePebbleURI\n+\t *            Use the \"acme://pebble\" style URI instead of the generic\n+\t *            \"https:\" URI. This param is ignored for Boulder.\n+\t * @return The URI to the ACME CA's directory.\n+\t */\n+\tpublic String getAcmeDirectoryURI(boolean usePebbleURI) {\n+\t\treturn null;\n+\t}\n+\t/**\n+\t * Get the IP address for the container as seen from the container network.\n+\t * \n+\t * @return The IP address for the container on the container network.\n+\t */\n+\tpublic String getIntraContainerIP() {\n+\t\treturn null;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3c28406c01e42dd902f376fac4532e84cf17aa5f"}, "originalPosition": 440}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUwODU2MDYyOnYy", "diffSide": "RIGHT", "path": "dev/com.ibm.ws.security.acme_fat/fat/src/com/ibm/ws/security/acme/docker/CAContainer.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wNlQxNzozODowMVrOGBit5Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wNlQxNzozODowMVrOGBit5Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDI3MDU2NQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t}", "url": "https://github.com/OpenLiberty/open-liberty/pull/11374#discussion_r404270565", "createdAt": "2020-04-06T17:38:01Z", "author": {"login": "jvanhill"}, "path": "dev/com.ibm.ws.security.acme_fat/fat/src/com/ibm/ws/security/acme/docker/CAContainer.java", "diffHunk": "@@ -0,0 +1,442 @@\n+/*******************************************************************************\n+ * Copyright (c) 2019, 2020 IBM Corporation and others.\n+ * All rights reserved. This program and the accompanying materials\n+ * are made available under the terms of the Eclipse Public License v1.0\n+ * which accompanies this distribution, and is available at\n+ * http://www.eclipse.org/legal/epl-v10.html\n+ *\n+ * Contributors:\n+ *     IBM Corporation - initial API and implementation\n+ *******************************************************************************/\n+package com.ibm.ws.security.acme.docker;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.security.cert.X509Certificate;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import org.apache.http.StatusLine;\n+import org.apache.http.client.methods.CloseableHttpResponse;\n+import org.apache.http.client.methods.HttpGet;\n+import org.apache.http.client.methods.HttpPost;\n+import org.apache.http.entity.ContentType;\n+import org.apache.http.entity.StringEntity;\n+import org.apache.http.impl.client.CloseableHttpClient;\n+import org.apache.http.impl.client.HttpClients;\n+import org.apache.http.util.EntityUtils;\n+import org.testcontainers.containers.GenericContainer;\n+import org.testcontainers.images.builder.ImageFromDockerfile;\n+\n+import com.ibm.websphere.simplicity.log.Log;\n+import com.ibm.ws.security.acme.utils.AcmeFatUtils;\n+\n+/**\n+ * Testcontainer implementation for Pebble and Boulder Certificate Authorities.\n+ * \n+ */\n+public class CAContainer extends GenericContainer<CAContainer> {\n+\n+\tprivate static final String TEST_DOMAIN_1 = \"domain1.com\";\n+\tprivate static final String TEST_DOMAIN_2 = \"domain2.com\";\n+\tprivate static final String TEST_DOMAIN_3 = \"domain3.com\";\n+\tprivate static final String TEST_DOMAIN_4 = \"domain4.com\";\n+\t\n+\t/** Challenge server port. */\n+\tpublic static final int HTTP_PORT = 5002;\n+\t/** The REST management API port. */\n+\tpublic int MANAGEMENT_PORT = 8055;\n+\t\n+\t/**\n+\t * This constructor is used by BoulderContainer\n+\t */\n+\tpublic CAContainer(String image) {\n+\t\tsuper(image);\n+\t}\n+\n+\t/**\n+\t * This constructor is used by PebbleContainer. The\n+\t * management port is different for Pebble, so this\n+\t * is passed in.\n+\t */\n+\tpublic CAContainer(ImageFromDockerfile image, int managementPort) {\n+\t\tsuper(image);\n+\t\tMANAGEMENT_PORT = managementPort;\n+\t}\n+\n+\t/**\n+\t * Get CA's intermediate certificate.\n+\t * \n+\t * @param fileName\n+\t *            The name of the file to save the certificate to.\n+\t * @return CA's intermediate certificate in the form of a PEM file.\n+\t * @throws Exception\n+\t *             If we failed to receive the certificate.\n+\t */\n+\tpublic InputStream getAcmeCaIntermediateCertificate() throws Exception {\n+\t\tfinal String METHOD_NAME = \"getAcmeCaIntermediateCertificate()\";\n+\t\tString url = \"https://\" + this.getContainerIpAddress() + \":\" + this.getMappedPort(MANAGEMENT_PORT)\n+\t\t\t\t+ \"/intermediates/0\";\n+\n+\t\ttry (CloseableHttpClient httpclient = AcmeFatUtils.getInsecureHttpsClient()) {\n+\t\t\t/*\n+\t\t\t * Create a GET request to the ACME CA server.\n+\t\t\t */\n+\t\t\tHttpGet httpGet = new HttpGet(url);\n+\n+\t\t\t/*\n+\t\t\t * Send the GET request and process the response.\n+\t\t\t */\n+\t\t\ttry (final CloseableHttpResponse response = httpclient.execute(httpGet)) {\n+\t\t\t\tAcmeFatUtils.logHttpResponse(CAContainer.class, METHOD_NAME, httpGet, response);\n+\n+\t\t\t\tStatusLine statusLine = response.getStatusLine();\n+\n+\t\t\t\tif (statusLine.getStatusCode() != 200) {\n+\t\t\t\t\tthrow new IOException(\n+\t\t\t\t\t\t\tMETHOD_NAME + \": Expected response 200, but received response: \" + statusLine);\n+\t\t\t\t}\n+\n+\t\t\t\tbyte[] result = EntityUtils.toByteArray(response.getEntity());\n+\n+\t\t\t\tLog.info(CAContainer.class, METHOD_NAME, new String(result));\n+\t\t\t\treturn  new ByteArrayInputStream(result);\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Get the root certificate.\n+\t * \n+\t * @param fileName\n+\t *            The name of the file to save the certificate to.\n+\t * @return Certificate Authority's root certificate in the form of a PEM file.\n+\t * @throws Exception\n+\t *             If we failed to receive the certificate.\n+\t */\n+\tpublic byte[] getAcmeCaRootCertificate() throws Exception {\n+\t\tfinal String METHOD_NAME = \"getAcmeCaRootCertificate()\";\n+\t\tString url = \"https://\" + this.getContainerIpAddress() + \":\" + this.getMappedPort(MANAGEMENT_PORT) + \"/roots/0\";\n+\n+\t\ttry (CloseableHttpClient httpclient = AcmeFatUtils.getInsecureHttpsClient()) {\n+\t\t\t/*\n+\t\t\t * Create a GET request to the ACME CA server.\n+\t\t\t */\n+\t\t\tHttpGet httpGet = new HttpGet(url);\n+\n+\t\t\t/*\n+\t\t\t * Send the GET request and process the response.\n+\t\t\t */\n+\t\t\ttry (final CloseableHttpResponse response = httpclient.execute(httpGet)) {\n+\t\t\t\tAcmeFatUtils.logHttpResponse(CAContainer.class, METHOD_NAME, httpGet, response);\n+\n+\t\t\t\tStatusLine statusLine = response.getStatusLine();\n+\n+\t\t\t\tif (statusLine.getStatusCode() != 200) {\n+\t\t\t\t\tthrow new IOException(\n+\t\t\t\t\t\t\tMETHOD_NAME + \": Expected response 200, but received response: \" + statusLine);\n+\t\t\t\t}\n+\n+\t\t\t\tbyte[] result = EntityUtils.toByteArray(response.getEntity());\n+\n+\t\t\t\tLog.info(CAContainer.class, METHOD_NAME, new String(result));\n+\t\t\t\treturn result;\n+\t\t\t}\n+\t\t}\n+\t}\n+\t\n+\t/**\n+\t * Get the status of the certificate from the ACME CA server.\n+\t * \n+\t * @param certificate\n+\t *            The certificate to check.\n+\t * @return The status of the certificate.\n+\t * @throws Exception\n+\t */\n+\tpublic String getAcmeCertificateStatus(X509Certificate certificate) throws Exception {\n+\t\tfinal String METHOD_NAME = \"getAcmeCertificateStatus()\";\n+\t\tString url = \"https://\" + this.getContainerIpAddress() + \":\" + this.getMappedPort(MANAGEMENT_PORT)\n+\t\t\t\t+ \"/cert-status-by-serial/\" + certificate.getSerialNumber().toString(16);\n+\n+\t\ttry (CloseableHttpClient httpclient = AcmeFatUtils.getInsecureHttpsClient()) {\n+\t\t\t/*\n+\t\t\t * Create a GET request to the ACME CA server.\n+\t\t\t */\n+\t\t\tHttpGet httpGet = new HttpGet(url);\n+\n+\t\t\t/*\n+\t\t\t * Send the GET request and process the response.\n+\t\t\t */\n+\t\t\ttry (final CloseableHttpResponse response = httpclient.execute(httpGet)) {\n+\t\t\t\tAcmeFatUtils.logHttpResponse(CAContainer.class, METHOD_NAME, httpGet, response);\n+\n+\t\t\t\tStatusLine statusLine = response.getStatusLine();\n+\n+\t\t\t\tif (statusLine.getStatusCode() != 200) {\n+\t\t\t\t\tthrow new IOException(\n+\t\t\t\t\t\t\tMETHOD_NAME + \": Expected response 200, but received response: \" + statusLine);\n+\t\t\t\t}\n+\n+\t\t\t\tString result = EntityUtils.toString(response.getEntity());\n+\n+\t\t\t\t/*\n+\t\t\t\t * The result is in JSON, lets just parse out the status.\n+\t\t\t\t */\n+\t\t\t\tPattern p = Pattern.compile(\".*\\\"Status\\\": \\\"(\\\\w+)\\\",.*\", Pattern.DOTALL);\n+\t\t\t\tMatcher m = p.matcher(result);\n+\t\t\t\tif (m.find()) {\n+\t\t\t\t\tresult = m.group(1);\n+\t\t\t\t} else {\n+\t\t\t\t\tthrow new Exception(\n+\t\t\t\t\t\t\t\"Certificate status response was not in expected JSON format. Response: \" + result);\n+\t\t\t\t}\n+\n+\t\t\t\tLog.info(CAContainer.class, METHOD_NAME, new String(result));\n+\t\t\t\treturn result;\n+\t\t\t}\n+\t\t}\n+\t}\n+\t\n+\t/**\n+\t * Retrieves the client host's IP address that is reachable from the\n+\t * container.\n+\t * \n+\t * @return The client host's IP address that is reachable from the\n+\t *         container.\n+\t * @throws IllegalStateException\n+\t *             If the address was not found.\n+\t */\n+\tpublic String getClientHost() throws IllegalStateException {\n+\t\tfor (String extraHost : this.getExtraHosts()) {\n+\t\t\tif (extraHost.startsWith(\"host.testcontainers.internal:\")) {\n+\t\t\t\treturn extraHost.replace(\"host.testcontainers.internal:\", \"\");\n+\t\t\t}\n+\t\t}\n+\n+\t\tthrow new IllegalStateException(\n+\t\t\t\t\"Unable to resolve local host from docker container. Could not find 'host.testcontainers.internal' property.\");\n+\t}\n+\t\n+\t/**\n+\t * Add A and AAAA records.\n+\t */\n+    public void addARecords() {\n+    \ttry {\n+\t\t\tfor (String domain : new String[] { TEST_DOMAIN_1, TEST_DOMAIN_2, TEST_DOMAIN_3, TEST_DOMAIN_4 }) {\n+\t\t\t\t/*\n+\t\t\t\t * Disable the IPv6 responses for this domain. The Boulder CA server\n+\t\t\t\t * responds on AAAA (IPv6) responses before A (IPv4) responses, and\n+\t\t\t\t * we don't currently have the testcontainer host's IPv6 address.\n+\t\t\t\t */\n+\t\t\t\taddARecord(domain, getClientHost());\n+\t\t\t\taddAAAARecord(domain, \"\");\n+\t\t\t}\n+    \t} catch (Exception e) {\n+    \t\tLog.error(CAContainer.class, \"addARecords\", e);\n+    \t}\n+    }\n+    /**\n+     * Convenience method for adding A records.\n+\t * @param host\n+\t *            The host / domain to redirect requests for.\n+     */\n+\tpublic void addARecord(String domain) throws IOException {\n+\t\taddARecord(domain, getClientHost());\n+\t}\n+\t/**\n+\t * Add an A record to the mock DNS server. This will allow us to redirect\n+\t * requests to a named domain to the IPv4 address of our choice.\n+\t * \n+\t * @param host\n+\t *            The host / domain to redirect requests for.\n+\t * @param address\n+\t *            The address to direct the requests for that host to.\n+\t * @throws IOException\n+\t */\n+\tpublic void addARecord(String host, String address) throws IOException {\n+\t\tfinal String METHOD_NAME = \"addARecord\";\n+\n+\t\ttry (CloseableHttpClient httpclient = HttpClients.createDefault()) {\n+\n+\t\t\t/*\n+\t\t\t * Generate the JSON request. The request can support multiple\n+\t\t\t * addresses but for the time being we will only support sending\n+\t\t\t * one.\n+\t\t\t */\n+\t\t\tString jsonString = \"{\\\"host\\\":\\\"\" + host + \"\\\",\\\"addresses\\\":[\\\"\" + address + \"\\\"]}\";\n+\t\t\tStringEntity requestEntity = new StringEntity(jsonString, ContentType.APPLICATION_JSON);\n+\n+\t\t\t/*\n+\t\t\t * Create a POST request to the mock DNS server.\n+\t\t\t */\n+\t\t\tHttpPost httpPost = new HttpPost(getManagementAddress() + \"/add-a\");\n+\t\t\thttpPost.setEntity(requestEntity);\n+\t\t\t/*\n+\t\t\t * Send the POST request and process the response.\n+\t\t\t */\n+\t\t\ttry (final CloseableHttpResponse response = httpclient.execute(httpPost)) {\n+\t\t\t\tAcmeFatUtils.logHttpResponse(CAContainer.class, METHOD_NAME, httpPost, response);\n+\n+\t\t\t\tStatusLine statusLine = response.getStatusLine();\n+\t\t\t\tif (statusLine.getStatusCode() != 200) {\n+\t\t\t\t\tthrow new IOException(\n+\t\t\t\t\t\t\tMETHOD_NAME + \": Expected response 200, but received response: \" + statusLine);\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t}\n+\t\n+\t/**\n+\t * Add an AAAA record to the mock DNS server. This will allow us to redirect\n+\t * requests to a named domain to the IPv6 address of our choice.\n+\t * \n+\t * @param host\n+\t *            The host / domain to redirect requests for.\n+\t * @param address\n+\t *            The address to direct the requests for that host to.\n+\t * @throws IOException\n+\t */\n+\tpublic void addAAAARecord(String host, String address) throws IOException {\n+\t\tfinal String METHOD_NAME = \"addAAAARecord\";\n+\n+\t\ttry (CloseableHttpClient httpclient = HttpClients.createDefault()) {\n+\n+\t\t\t/*\n+\t\t\t * Generate the JSON request. The request can support multiple\n+\t\t\t * addresses but for the time being we will only support sending\n+\t\t\t * one.\n+\t\t\t */\n+\t\t\tString jsonString = \"{\\\"host\\\":\\\"\" + host + \"\\\",\\\"addresses\\\":[\\\"\" + address + \"\\\"]}\";\n+\t\t\tStringEntity requestEntity = new StringEntity(jsonString, ContentType.APPLICATION_JSON);\n+\n+\t\t\t/*\n+\t\t\t * Create a POST request to the mock DNS server.\n+\t\t\t */\n+\t\t\tHttpPost httpPost = new HttpPost(getManagementAddress() + \"/add-aaaa\");\n+\t\t\thttpPost.setEntity(requestEntity);\n+\n+\t\t\t/*\n+\t\t\t * Send the POST request and process the response.\n+\t\t\t */\n+\t\t\ttry (final CloseableHttpResponse response = httpclient.execute(httpPost)) {\n+\t\t\t\tAcmeFatUtils.logHttpResponse(CAContainer.class, METHOD_NAME, httpPost, response);\n+\n+\t\t\t\tStatusLine statusLine = response.getStatusLine();\n+\t\t\t\tif (statusLine.getStatusCode() != 200) {\n+\t\t\t\t\tthrow new IOException(\n+\t\t\t\t\t\t\tMETHOD_NAME + \": Expected response 200, but received response: \" + statusLine);\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t}\n+\t/**\n+\t * Clear a previously added AAAA record that was added to the mock DNS\n+\t * server.\n+\t * \n+\t * @param host\n+\t *            The host / domain to redirect requests for.\n+\t * @throws IOException\n+\t */\n+\tpublic void clearAAAARecord(String host) throws IOException {\n+\t\tfinal String METHOD_NAME = \"clearAAAARecord(String)\";\n+\n+\t\ttry (CloseableHttpClient httpclient = HttpClients.createDefault()) {\n+\t\t\t/*\n+\t\t\t * Generate the JSON request.\n+\t\t\t */\n+\t\t\tString jsonString = \"{\\\"host\\\":\\\"\" + host + \"\\\"}\";\n+\t\t\tStringEntity requestEntity = new StringEntity(jsonString, ContentType.APPLICATION_JSON);\n+\n+\t\t\t/*\n+\t\t\t * Create a POST request to the mock DNS server.\n+\t\t\t */\n+\t\t\tHttpPost httpPost = new HttpPost(getManagementAddress() + \"/clear-aaaa\");\n+\t\t\thttpPost.setEntity(requestEntity);\n+\n+\t\t\t/*\n+\t\t\t * Send the POST request and process the response.\n+\t\t\t */\n+\t\t\ttry (final CloseableHttpResponse response = httpclient.execute(httpPost)) {\n+\t\t\t\tAcmeFatUtils.logHttpResponse(CAContainer.class, METHOD_NAME, httpPost, response);\n+\n+\t\t\t\tStatusLine statusLine = response.getStatusLine();\n+\t\t\t\tif (statusLine.getStatusCode() != 200) {\n+\t\t\t\t\tthrow new IOException(\n+\t\t\t\t\t\t\tMETHOD_NAME + \": Expected response 200, but received response: \" + statusLine);\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Clear a previously added A record that was added to the mock DNS server.\n+\t * \n+\t * @param host\n+\t *            The host / domain to redirect requests for.\n+\t * @throws IOException\n+\t */\n+\tpublic void clearARecord(String host) throws IOException {\n+\t\tfinal String METHOD_NAME = \"clearMockARecord(String)\";\n+\n+\t\ttry (CloseableHttpClient httpclient = HttpClients.createDefault()) {\n+\t\t\t/*\n+\t\t\t * Generate the JSON request.\n+\t\t\t */\n+\t\t\tString jsonString = \"{\\\"host\\\":\\\"\" + host + \"\\\"}\";\n+\t\t\tStringEntity requestEntity = new StringEntity(jsonString, ContentType.APPLICATION_JSON);\n+\n+\t\t\t/*\n+\t\t\t * Create a POST request to the mock DNS server.\n+\t\t\t */\n+\t\t\tHttpPost httpPost = new HttpPost(getManagementAddress() + \"/clear-a\");\n+\t\t\thttpPost.setEntity(requestEntity);\n+\n+\t\t\t/*\n+\t\t\t * Send the POST request and process the response.\n+\t\t\t */\n+\t\t\ttry (final CloseableHttpResponse response = httpclient.execute(httpPost)) {\n+\t\t\t\tAcmeFatUtils.logHttpResponse(CAContainer.class, METHOD_NAME, httpPost, response);\n+\n+\t\t\t\tStatusLine statusLine = response.getStatusLine();\n+\t\t\t\tif (statusLine.getStatusCode() != 200) {\n+\t\t\t\t\tthrow new IOException(\n+\t\t\t\t\t\t\tMETHOD_NAME + \": Expected response 200, but received response: \" + statusLine);\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t}\n+\t/**\n+\t * The HTTP address that can be used the reach the REST management API for\n+\t * the server.\n+\t * \n+\t * @return The HTTP address to the REST management endpoint.\n+\t */\n+\tpublic String getManagementAddress() {\n+\t\treturn \"http://\" + this.getContainerIpAddress() + \":\" + this.getMappedPort(MANAGEMENT_PORT);\n+\t}\n+\n+\t/*\n+\t * The following methods should be overridden in the respective container class.\n+\t */\n+\t\n+\t/**\n+\t * Get the URI to the ACME CA's directory.\n+\t * \n+\t * @param usePebbleURI\n+\t *            Use the \"acme://pebble\" style URI instead of the generic\n+\t *            \"https:\" URI. This param is ignored for Boulder.\n+\t * @return The URI to the ACME CA's directory.\n+\t */\n+\tpublic String getAcmeDirectoryURI(boolean usePebbleURI) {\n+\t\treturn null;\n+\t}\n+\t/**\n+\t * Get the IP address for the container as seen from the container network.\n+\t * \n+\t * @return The IP address for the container on the container network.\n+\t */\n+\tpublic String getIntraContainerIP() {\n+\t\treturn null;\n+\t}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3c28406c01e42dd902f376fac4532e84cf17aa5f"}, "originalPosition": 441}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUwODU2Mzg3OnYy", "diffSide": "RIGHT", "path": "dev/com.ibm.ws.security.acme_fat/fat/src/com/ibm/ws/security/acme/docker/boulder/BoulderContainer.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wNlQxNzozODo1MVrOGBiv-Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wNlQxNzozODo1MVrOGBiv-Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDI3MTA5Nw==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n             * Copyright (c) 2019, 2020 IBM Corporation and others.\n          \n          \n            \n             * Copyright (c) 2020 IBM Corporation and others.", "url": "https://github.com/OpenLiberty/open-liberty/pull/11374#discussion_r404271097", "createdAt": "2020-04-06T17:38:51Z", "author": {"login": "jvanhill"}, "path": "dev/com.ibm.ws.security.acme_fat/fat/src/com/ibm/ws/security/acme/docker/boulder/BoulderContainer.java", "diffHunk": "@@ -0,0 +1,214 @@\n+/*******************************************************************************\n+ * Copyright (c) 2019, 2020 IBM Corporation and others.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3c28406c01e42dd902f376fac4532e84cf17aa5f"}, "originalPosition": 2}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUwODU2OTU0OnYy", "diffSide": "RIGHT", "path": "dev/com.ibm.ws.security.acme_fat/fat/src/com/ibm/ws/security/acme/docker/CAContainer.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wNlQxNzo0MDoyMlrOGBizpQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wNlQxNzo0MDoyMlrOGBizpQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDI3MjAzNw==", "bodyText": "whitespace", "url": "https://github.com/OpenLiberty/open-liberty/pull/11374#discussion_r404272037", "createdAt": "2020-04-06T17:40:22Z", "author": {"login": "jvanhill"}, "path": "dev/com.ibm.ws.security.acme_fat/fat/src/com/ibm/ws/security/acme/docker/CAContainer.java", "diffHunk": "@@ -0,0 +1,442 @@\n+/*******************************************************************************\n+ * Copyright (c) 2019, 2020 IBM Corporation and others.\n+ * All rights reserved. This program and the accompanying materials\n+ * are made available under the terms of the Eclipse Public License v1.0\n+ * which accompanies this distribution, and is available at\n+ * http://www.eclipse.org/legal/epl-v10.html\n+ *\n+ * Contributors:\n+ *     IBM Corporation - initial API and implementation\n+ *******************************************************************************/\n+package com.ibm.ws.security.acme.docker;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.security.cert.X509Certificate;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import org.apache.http.StatusLine;\n+import org.apache.http.client.methods.CloseableHttpResponse;\n+import org.apache.http.client.methods.HttpGet;\n+import org.apache.http.client.methods.HttpPost;\n+import org.apache.http.entity.ContentType;\n+import org.apache.http.entity.StringEntity;\n+import org.apache.http.impl.client.CloseableHttpClient;\n+import org.apache.http.impl.client.HttpClients;\n+import org.apache.http.util.EntityUtils;\n+import org.testcontainers.containers.GenericContainer;\n+import org.testcontainers.images.builder.ImageFromDockerfile;\n+\n+import com.ibm.websphere.simplicity.log.Log;\n+import com.ibm.ws.security.acme.utils.AcmeFatUtils;\n+\n+/**\n+ * Testcontainer implementation for Pebble and Boulder Certificate Authorities.\n+ * \n+ */\n+public class CAContainer extends GenericContainer<CAContainer> {\n+\n+\tprivate static final String TEST_DOMAIN_1 = \"domain1.com\";\n+\tprivate static final String TEST_DOMAIN_2 = \"domain2.com\";\n+\tprivate static final String TEST_DOMAIN_3 = \"domain3.com\";\n+\tprivate static final String TEST_DOMAIN_4 = \"domain4.com\";\n+\t\n+\t/** Challenge server port. */\n+\tpublic static final int HTTP_PORT = 5002;\n+\t/** The REST management API port. */\n+\tpublic int MANAGEMENT_PORT = 8055;\n+\t\n+\t/**\n+\t * This constructor is used by BoulderContainer\n+\t */\n+\tpublic CAContainer(String image) {\n+\t\tsuper(image);\n+\t}\n+\n+\t/**\n+\t * This constructor is used by PebbleContainer. The\n+\t * management port is different for Pebble, so this\n+\t * is passed in.\n+\t */\n+\tpublic CAContainer(ImageFromDockerfile image, int managementPort) {\n+\t\tsuper(image);\n+\t\tMANAGEMENT_PORT = managementPort;\n+\t}\n+\n+\t/**\n+\t * Get CA's intermediate certificate.\n+\t * \n+\t * @param fileName\n+\t *            The name of the file to save the certificate to.\n+\t * @return CA's intermediate certificate in the form of a PEM file.\n+\t * @throws Exception\n+\t *             If we failed to receive the certificate.\n+\t */\n+\tpublic InputStream getAcmeCaIntermediateCertificate() throws Exception {\n+\t\tfinal String METHOD_NAME = \"getAcmeCaIntermediateCertificate()\";\n+\t\tString url = \"https://\" + this.getContainerIpAddress() + \":\" + this.getMappedPort(MANAGEMENT_PORT)\n+\t\t\t\t+ \"/intermediates/0\";\n+\n+\t\ttry (CloseableHttpClient httpclient = AcmeFatUtils.getInsecureHttpsClient()) {\n+\t\t\t/*\n+\t\t\t * Create a GET request to the ACME CA server.\n+\t\t\t */\n+\t\t\tHttpGet httpGet = new HttpGet(url);\n+\n+\t\t\t/*\n+\t\t\t * Send the GET request and process the response.\n+\t\t\t */\n+\t\t\ttry (final CloseableHttpResponse response = httpclient.execute(httpGet)) {\n+\t\t\t\tAcmeFatUtils.logHttpResponse(CAContainer.class, METHOD_NAME, httpGet, response);\n+\n+\t\t\t\tStatusLine statusLine = response.getStatusLine();\n+\n+\t\t\t\tif (statusLine.getStatusCode() != 200) {\n+\t\t\t\t\tthrow new IOException(\n+\t\t\t\t\t\t\tMETHOD_NAME + \": Expected response 200, but received response: \" + statusLine);\n+\t\t\t\t}\n+\n+\t\t\t\tbyte[] result = EntityUtils.toByteArray(response.getEntity());\n+\n+\t\t\t\tLog.info(CAContainer.class, METHOD_NAME, new String(result));\n+\t\t\t\treturn  new ByteArrayInputStream(result);\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Get the root certificate.\n+\t * \n+\t * @param fileName\n+\t *            The name of the file to save the certificate to.\n+\t * @return Certificate Authority's root certificate in the form of a PEM file.\n+\t * @throws Exception\n+\t *             If we failed to receive the certificate.\n+\t */\n+\tpublic byte[] getAcmeCaRootCertificate() throws Exception {\n+\t\tfinal String METHOD_NAME = \"getAcmeCaRootCertificate()\";\n+\t\tString url = \"https://\" + this.getContainerIpAddress() + \":\" + this.getMappedPort(MANAGEMENT_PORT) + \"/roots/0\";\n+\n+\t\ttry (CloseableHttpClient httpclient = AcmeFatUtils.getInsecureHttpsClient()) {\n+\t\t\t/*\n+\t\t\t * Create a GET request to the ACME CA server.\n+\t\t\t */\n+\t\t\tHttpGet httpGet = new HttpGet(url);\n+\n+\t\t\t/*\n+\t\t\t * Send the GET request and process the response.\n+\t\t\t */\n+\t\t\ttry (final CloseableHttpResponse response = httpclient.execute(httpGet)) {\n+\t\t\t\tAcmeFatUtils.logHttpResponse(CAContainer.class, METHOD_NAME, httpGet, response);\n+\n+\t\t\t\tStatusLine statusLine = response.getStatusLine();\n+\n+\t\t\t\tif (statusLine.getStatusCode() != 200) {\n+\t\t\t\t\tthrow new IOException(\n+\t\t\t\t\t\t\tMETHOD_NAME + \": Expected response 200, but received response: \" + statusLine);\n+\t\t\t\t}\n+\n+\t\t\t\tbyte[] result = EntityUtils.toByteArray(response.getEntity());\n+\n+\t\t\t\tLog.info(CAContainer.class, METHOD_NAME, new String(result));\n+\t\t\t\treturn result;\n+\t\t\t}\n+\t\t}\n+\t}\n+\t\n+\t/**\n+\t * Get the status of the certificate from the ACME CA server.\n+\t * \n+\t * @param certificate\n+\t *            The certificate to check.\n+\t * @return The status of the certificate.\n+\t * @throws Exception\n+\t */\n+\tpublic String getAcmeCertificateStatus(X509Certificate certificate) throws Exception {\n+\t\tfinal String METHOD_NAME = \"getAcmeCertificateStatus()\";\n+\t\tString url = \"https://\" + this.getContainerIpAddress() + \":\" + this.getMappedPort(MANAGEMENT_PORT)\n+\t\t\t\t+ \"/cert-status-by-serial/\" + certificate.getSerialNumber().toString(16);\n+\n+\t\ttry (CloseableHttpClient httpclient = AcmeFatUtils.getInsecureHttpsClient()) {\n+\t\t\t/*\n+\t\t\t * Create a GET request to the ACME CA server.\n+\t\t\t */\n+\t\t\tHttpGet httpGet = new HttpGet(url);\n+\n+\t\t\t/*\n+\t\t\t * Send the GET request and process the response.\n+\t\t\t */\n+\t\t\ttry (final CloseableHttpResponse response = httpclient.execute(httpGet)) {\n+\t\t\t\tAcmeFatUtils.logHttpResponse(CAContainer.class, METHOD_NAME, httpGet, response);\n+\n+\t\t\t\tStatusLine statusLine = response.getStatusLine();\n+\n+\t\t\t\tif (statusLine.getStatusCode() != 200) {\n+\t\t\t\t\tthrow new IOException(\n+\t\t\t\t\t\t\tMETHOD_NAME + \": Expected response 200, but received response: \" + statusLine);\n+\t\t\t\t}\n+\n+\t\t\t\tString result = EntityUtils.toString(response.getEntity());\n+\n+\t\t\t\t/*\n+\t\t\t\t * The result is in JSON, lets just parse out the status.\n+\t\t\t\t */\n+\t\t\t\tPattern p = Pattern.compile(\".*\\\"Status\\\": \\\"(\\\\w+)\\\",.*\", Pattern.DOTALL);\n+\t\t\t\tMatcher m = p.matcher(result);\n+\t\t\t\tif (m.find()) {\n+\t\t\t\t\tresult = m.group(1);\n+\t\t\t\t} else {\n+\t\t\t\t\tthrow new Exception(\n+\t\t\t\t\t\t\t\"Certificate status response was not in expected JSON format. Response: \" + result);\n+\t\t\t\t}\n+\n+\t\t\t\tLog.info(CAContainer.class, METHOD_NAME, new String(result));\n+\t\t\t\treturn result;\n+\t\t\t}\n+\t\t}\n+\t}\n+\t\n+\t/**\n+\t * Retrieves the client host's IP address that is reachable from the\n+\t * container.\n+\t * \n+\t * @return The client host's IP address that is reachable from the\n+\t *         container.\n+\t * @throws IllegalStateException\n+\t *             If the address was not found.\n+\t */\n+\tpublic String getClientHost() throws IllegalStateException {\n+\t\tfor (String extraHost : this.getExtraHosts()) {\n+\t\t\tif (extraHost.startsWith(\"host.testcontainers.internal:\")) {\n+\t\t\t\treturn extraHost.replace(\"host.testcontainers.internal:\", \"\");\n+\t\t\t}\n+\t\t}\n+\n+\t\tthrow new IllegalStateException(\n+\t\t\t\t\"Unable to resolve local host from docker container. Could not find 'host.testcontainers.internal' property.\");\n+\t}\n+\t\n+\t/**\n+\t * Add A and AAAA records.\n+\t */\n+    public void addARecords() {\n+    \ttry {\n+\t\t\tfor (String domain : new String[] { TEST_DOMAIN_1, TEST_DOMAIN_2, TEST_DOMAIN_3, TEST_DOMAIN_4 }) {\n+\t\t\t\t/*\n+\t\t\t\t * Disable the IPv6 responses for this domain. The Boulder CA server\n+\t\t\t\t * responds on AAAA (IPv6) responses before A (IPv4) responses, and\n+\t\t\t\t * we don't currently have the testcontainer host's IPv6 address.\n+\t\t\t\t */\n+\t\t\t\taddARecord(domain, getClientHost());\n+\t\t\t\taddAAAARecord(domain, \"\");\n+\t\t\t}\n+    \t} catch (Exception e) {\n+    \t\tLog.error(CAContainer.class, \"addARecords\", e);\n+    \t}\n+    }\n+    /**\n+     * Convenience method for adding A records.\n+\t * @param host\n+\t *            The host / domain to redirect requests for.\n+     */\n+\tpublic void addARecord(String domain) throws IOException {\n+\t\taddARecord(domain, getClientHost());\n+\t}\n+\t/**\n+\t * Add an A record to the mock DNS server. This will allow us to redirect\n+\t * requests to a named domain to the IPv4 address of our choice.\n+\t * \n+\t * @param host\n+\t *            The host / domain to redirect requests for.\n+\t * @param address\n+\t *            The address to direct the requests for that host to.\n+\t * @throws IOException\n+\t */\n+\tpublic void addARecord(String host, String address) throws IOException {\n+\t\tfinal String METHOD_NAME = \"addARecord\";\n+\n+\t\ttry (CloseableHttpClient httpclient = HttpClients.createDefault()) {\n+\n+\t\t\t/*\n+\t\t\t * Generate the JSON request. The request can support multiple\n+\t\t\t * addresses but for the time being we will only support sending\n+\t\t\t * one.\n+\t\t\t */\n+\t\t\tString jsonString = \"{\\\"host\\\":\\\"\" + host + \"\\\",\\\"addresses\\\":[\\\"\" + address + \"\\\"]}\";\n+\t\t\tStringEntity requestEntity = new StringEntity(jsonString, ContentType.APPLICATION_JSON);\n+\n+\t\t\t/*\n+\t\t\t * Create a POST request to the mock DNS server.\n+\t\t\t */\n+\t\t\tHttpPost httpPost = new HttpPost(getManagementAddress() + \"/add-a\");\n+\t\t\thttpPost.setEntity(requestEntity);\n+\t\t\t/*\n+\t\t\t * Send the POST request and process the response.\n+\t\t\t */\n+\t\t\ttry (final CloseableHttpResponse response = httpclient.execute(httpPost)) {\n+\t\t\t\tAcmeFatUtils.logHttpResponse(CAContainer.class, METHOD_NAME, httpPost, response);\n+\n+\t\t\t\tStatusLine statusLine = response.getStatusLine();\n+\t\t\t\tif (statusLine.getStatusCode() != 200) {\n+\t\t\t\t\tthrow new IOException(\n+\t\t\t\t\t\t\tMETHOD_NAME + \": Expected response 200, but received response: \" + statusLine);\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t}\n+\t\n+\t/**\n+\t * Add an AAAA record to the mock DNS server. This will allow us to redirect\n+\t * requests to a named domain to the IPv6 address of our choice.\n+\t * \n+\t * @param host\n+\t *            The host / domain to redirect requests for.\n+\t * @param address\n+\t *            The address to direct the requests for that host to.\n+\t * @throws IOException\n+\t */\n+\tpublic void addAAAARecord(String host, String address) throws IOException {\n+\t\tfinal String METHOD_NAME = \"addAAAARecord\";\n+\n+\t\ttry (CloseableHttpClient httpclient = HttpClients.createDefault()) {\n+\n+\t\t\t/*\n+\t\t\t * Generate the JSON request. The request can support multiple\n+\t\t\t * addresses but for the time being we will only support sending\n+\t\t\t * one.\n+\t\t\t */\n+\t\t\tString jsonString = \"{\\\"host\\\":\\\"\" + host + \"\\\",\\\"addresses\\\":[\\\"\" + address + \"\\\"]}\";\n+\t\t\tStringEntity requestEntity = new StringEntity(jsonString, ContentType.APPLICATION_JSON);\n+\n+\t\t\t/*\n+\t\t\t * Create a POST request to the mock DNS server.\n+\t\t\t */\n+\t\t\tHttpPost httpPost = new HttpPost(getManagementAddress() + \"/add-aaaa\");\n+\t\t\thttpPost.setEntity(requestEntity);\n+\n+\t\t\t/*\n+\t\t\t * Send the POST request and process the response.\n+\t\t\t */\n+\t\t\ttry (final CloseableHttpResponse response = httpclient.execute(httpPost)) {\n+\t\t\t\tAcmeFatUtils.logHttpResponse(CAContainer.class, METHOD_NAME, httpPost, response);\n+\n+\t\t\t\tStatusLine statusLine = response.getStatusLine();\n+\t\t\t\tif (statusLine.getStatusCode() != 200) {\n+\t\t\t\t\tthrow new IOException(\n+\t\t\t\t\t\t\tMETHOD_NAME + \": Expected response 200, but received response: \" + statusLine);\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t}\n+\t/**", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3c28406c01e42dd902f376fac4532e84cf17aa5f"}, "originalPosition": 333}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUwODU5NDAzOnYy", "diffSide": "RIGHT", "path": "dev/com.ibm.ws.security.acme_fat/fat/src/com/ibm/ws/security/acme/docker/boulder/BoulderContainer.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wNlQxNzo0Njo0OFrOGBjC6w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOVQxOTo0Nzo1NVrOGDnAGg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDI3NTk0Nw==", "bodyText": "Should this be static? Doesn't seem that we would want to directly reference BoulderContainer.LISTEN_PORT from outside this class? Maybe we would call CAContainer.getListenPort()....", "url": "https://github.com/OpenLiberty/open-liberty/pull/11374#discussion_r404275947", "createdAt": "2020-04-06T17:46:48Z", "author": {"login": "jvanhill"}, "path": "dev/com.ibm.ws.security.acme_fat/fat/src/com/ibm/ws/security/acme/docker/boulder/BoulderContainer.java", "diffHunk": "@@ -0,0 +1,214 @@\n+/*******************************************************************************\n+ * Copyright (c) 2019, 2020 IBM Corporation and others.\n+ * All rights reserved. This program and the accompanying materials\n+ * are made available under the terms of the Eclipse Public License v1.0\n+ * which accompanies this distribution, and is available at\n+ * http://www.eclipse.org/legal/epl-v10.html\n+ *\n+ * Contributors:\n+ *     IBM Corporation - initial API and implementation\n+ *******************************************************************************/\n+package com.ibm.ws.security.acme.docker.boulder;\n+\n+import static junit.framework.Assert.fail;\n+\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.security.KeyStore;\n+import java.security.cert.Certificate;\n+import java.security.cert.X509Certificate;\n+import java.time.Duration;\n+import java.util.Map.Entry;\n+\n+import org.testcontainers.Testcontainers;\n+import org.testcontainers.containers.GenericContainer;\n+import org.testcontainers.containers.Network;\n+import com.github.dockerjava.api.model.ContainerNetwork;\n+import com.github.dockerjava.api.model.ContainerNetwork.Ipam;\n+import com.ibm.websphere.simplicity.log.Log;\n+import com.ibm.ws.security.acme.AcmeCaException;\n+import com.ibm.ws.security.acme.docker.CAContainer;\n+import com.ibm.ws.security.acme.fat.FATSuite;\n+import com.ibm.ws.security.acme.internal.AcmeClient;\n+import com.ibm.ws.security.acme.utils.AcmeFatUtils;\n+import com.ibm.ws.security.acme.utils.HttpChallengeServer;\n+/**\n+ * Testcontainer implementation for the letsencrypt/boulder container.\n+ * Boulder is designed to run with docker-compose. In order to integrate\n+ * Boulder into the acme FAT, the docker-compose file from letsencrypt\n+ * was turned into the following GenericContainers. This class consists\n+ * of three containers and two networks. Because Boulder consists of\n+ * many files, a Docker image was created that is built on top of\n+ * letsencrypt/boulder-tools-go and includes all the files that would\n+ * otherwise need to be copied at runtime. This saves 8+ minutes per\n+ * run.\n+ */\n+public class BoulderContainer extends CAContainer {\n+\n+\t/** The port used to listen for incoming ACME requests. */\n+\tpublic static final int LISTEN_PORT = 4001;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3c28406c01e42dd902f376fac4532e84cf17aa5f"}, "originalPosition": 52}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjQzNzkxNA==", "bodyText": "I removed the static modifier. Pebble uses a different listen port.", "url": "https://github.com/OpenLiberty/open-liberty/pull/11374#discussion_r406437914", "createdAt": "2020-04-09T19:47:55Z", "author": {"login": "ryanesch"}, "path": "dev/com.ibm.ws.security.acme_fat/fat/src/com/ibm/ws/security/acme/docker/boulder/BoulderContainer.java", "diffHunk": "@@ -0,0 +1,214 @@\n+/*******************************************************************************\n+ * Copyright (c) 2019, 2020 IBM Corporation and others.\n+ * All rights reserved. This program and the accompanying materials\n+ * are made available under the terms of the Eclipse Public License v1.0\n+ * which accompanies this distribution, and is available at\n+ * http://www.eclipse.org/legal/epl-v10.html\n+ *\n+ * Contributors:\n+ *     IBM Corporation - initial API and implementation\n+ *******************************************************************************/\n+package com.ibm.ws.security.acme.docker.boulder;\n+\n+import static junit.framework.Assert.fail;\n+\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.security.KeyStore;\n+import java.security.cert.Certificate;\n+import java.security.cert.X509Certificate;\n+import java.time.Duration;\n+import java.util.Map.Entry;\n+\n+import org.testcontainers.Testcontainers;\n+import org.testcontainers.containers.GenericContainer;\n+import org.testcontainers.containers.Network;\n+import com.github.dockerjava.api.model.ContainerNetwork;\n+import com.github.dockerjava.api.model.ContainerNetwork.Ipam;\n+import com.ibm.websphere.simplicity.log.Log;\n+import com.ibm.ws.security.acme.AcmeCaException;\n+import com.ibm.ws.security.acme.docker.CAContainer;\n+import com.ibm.ws.security.acme.fat.FATSuite;\n+import com.ibm.ws.security.acme.internal.AcmeClient;\n+import com.ibm.ws.security.acme.utils.AcmeFatUtils;\n+import com.ibm.ws.security.acme.utils.HttpChallengeServer;\n+/**\n+ * Testcontainer implementation for the letsencrypt/boulder container.\n+ * Boulder is designed to run with docker-compose. In order to integrate\n+ * Boulder into the acme FAT, the docker-compose file from letsencrypt\n+ * was turned into the following GenericContainers. This class consists\n+ * of three containers and two networks. Because Boulder consists of\n+ * many files, a Docker image was created that is built on top of\n+ * letsencrypt/boulder-tools-go and includes all the files that would\n+ * otherwise need to be copied at runtime. This saves 8+ minutes per\n+ * run.\n+ */\n+public class BoulderContainer extends CAContainer {\n+\n+\t/** The port used to listen for incoming ACME requests. */\n+\tpublic static final int LISTEN_PORT = 4001;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDI3NTk0Nw=="}, "originalCommit": {"oid": "3c28406c01e42dd902f376fac4532e84cf17aa5f"}, "originalPosition": 52}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUwODU5NTE2OnYy", "diffSide": "RIGHT", "path": "dev/com.ibm.ws.security.acme_fat/fat/src/com/ibm/ws/security/acme/docker/boulder/BoulderContainer.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wNlQxNzo0NzoxMlrOGBjDwA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wNlQxNzo0NzoxMlrOGBjDwA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDI3NjE2MA==", "bodyText": "Javadoc", "url": "https://github.com/OpenLiberty/open-liberty/pull/11374#discussion_r404276160", "createdAt": "2020-04-06T17:47:12Z", "author": {"login": "jvanhill"}, "path": "dev/com.ibm.ws.security.acme_fat/fat/src/com/ibm/ws/security/acme/docker/boulder/BoulderContainer.java", "diffHunk": "@@ -0,0 +1,214 @@\n+/*******************************************************************************\n+ * Copyright (c) 2019, 2020 IBM Corporation and others.\n+ * All rights reserved. This program and the accompanying materials\n+ * are made available under the terms of the Eclipse Public License v1.0\n+ * which accompanies this distribution, and is available at\n+ * http://www.eclipse.org/legal/epl-v10.html\n+ *\n+ * Contributors:\n+ *     IBM Corporation - initial API and implementation\n+ *******************************************************************************/\n+package com.ibm.ws.security.acme.docker.boulder;\n+\n+import static junit.framework.Assert.fail;\n+\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.security.KeyStore;\n+import java.security.cert.Certificate;\n+import java.security.cert.X509Certificate;\n+import java.time.Duration;\n+import java.util.Map.Entry;\n+\n+import org.testcontainers.Testcontainers;\n+import org.testcontainers.containers.GenericContainer;\n+import org.testcontainers.containers.Network;\n+import com.github.dockerjava.api.model.ContainerNetwork;\n+import com.github.dockerjava.api.model.ContainerNetwork.Ipam;\n+import com.ibm.websphere.simplicity.log.Log;\n+import com.ibm.ws.security.acme.AcmeCaException;\n+import com.ibm.ws.security.acme.docker.CAContainer;\n+import com.ibm.ws.security.acme.fat.FATSuite;\n+import com.ibm.ws.security.acme.internal.AcmeClient;\n+import com.ibm.ws.security.acme.utils.AcmeFatUtils;\n+import com.ibm.ws.security.acme.utils.HttpChallengeServer;\n+/**\n+ * Testcontainer implementation for the letsencrypt/boulder container.\n+ * Boulder is designed to run with docker-compose. In order to integrate\n+ * Boulder into the acme FAT, the docker-compose file from letsencrypt\n+ * was turned into the following GenericContainers. This class consists\n+ * of three containers and two networks. Because Boulder consists of\n+ * many files, a Docker image was created that is built on top of\n+ * letsencrypt/boulder-tools-go and includes all the files that would\n+ * otherwise need to be copied at runtime. This saves 8+ minutes per\n+ * run.\n+ */\n+public class BoulderContainer extends CAContainer {\n+\n+\t/** The port used to listen for incoming ACME requests. */\n+\tpublic static final int LISTEN_PORT = 4001;\n+\tprivate static final String FILE_MINICA_PEM = \"lib/LibertyFATTestFiles/boulder.minica.pem\";\n+\t\n+\n+    \n+    public final Network bluenet = Network.builder()\n+            .createNetworkCmdModifier(cmd -> {\n+                cmd.withDriver(\"bridge\");\n+                cmd.withIpam(new com.github.dockerjava.api.model.Network.Ipam()\n+                        .withDriver(\"default\")\n+                        .withConfig(new com.github.dockerjava.api.model.Network.Ipam.Config()\n+                                .withSubnet(\"10.77.77.0/24\")));\n+            })\n+            .build();\n+\n+    public final Network rednet =  Network.builder()\n+            .createNetworkCmdModifier(cmd -> {\n+                cmd.withDriver(\"bridge\");\n+                cmd.withIpam(new com.github.dockerjava.api.model.Network.Ipam()\n+                        .withDriver(\"default\")\n+                        .withConfig(new com.github.dockerjava.api.model.Network.Ipam.Config()\n+                                .withSubnet(\"10.88.88.0/24\")));\n+            })\n+            .build();\n+    \n+    public final GenericContainer<?> bhsm = new GenericContainer<>(DOCKER_IMAGE)\n+            .withEnv(\"PKCS11_DAEMON_SOCKET\", \"tcp://0.0.0.0:5657\")\n+            .withExposedPorts(5657)\n+            .withNetwork(bluenet)\n+            .withNetworkAliases(\"boulder-hsm\")\n+            .withCommand(\"/usr/local/bin/pkcs11-daemon /usr/lib/softhsm/libsofthsm2.so\")\n+            .withLogConsumer(o -> System.out.print(\"[HSM] \" + o.getUtf8String()));\n+    \n+    public final GenericContainer<?> bmysql = new GenericContainer<>(\"mariadb:10.3\")\n+            .withNetwork(bluenet)\n+            .withExposedPorts(3306)\n+            .withNetworkAliases(\"boulder-mysql\")\n+            .withEnv(\"MYSQL_ALLOW_EMPTY_PASSWORD\", \"yes\")\n+            .withCommand(\"mysqld --bind-address=0.0.0.0 --slow-query-log --log-output=TABLE --log-queries-not-using-indexes=ON\")\n+            .withLogConsumer(o -> System.out.print(\"[SQL] \" + o.getUtf8String()));\n+    \n+    private static final String DOCKER_IMAGE = \"ryanesch/acme-boulder:1.1\";\n+    \n+    public BoulderContainer() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3c28406c01e42dd902f376fac4532e84cf17aa5f"}, "originalPosition": 95}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUwODU5Nzk2OnYy", "diffSide": "RIGHT", "path": "dev/com.ibm.ws.security.acme_fat/fat/src/com/ibm/ws/security/acme/docker/boulder/BoulderContainer.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wNlQxNzo0Nzo1NFrOGBjFbQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wNlQxNzo0Nzo1NFrOGBjFbQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDI3NjU4OQ==", "bodyText": "I would move this as a comment in the method so we don't override the inherited javadoc.", "url": "https://github.com/OpenLiberty/open-liberty/pull/11374#discussion_r404276589", "createdAt": "2020-04-06T17:47:54Z", "author": {"login": "jvanhill"}, "path": "dev/com.ibm.ws.security.acme_fat/fat/src/com/ibm/ws/security/acme/docker/boulder/BoulderContainer.java", "diffHunk": "@@ -0,0 +1,214 @@\n+/*******************************************************************************\n+ * Copyright (c) 2019, 2020 IBM Corporation and others.\n+ * All rights reserved. This program and the accompanying materials\n+ * are made available under the terms of the Eclipse Public License v1.0\n+ * which accompanies this distribution, and is available at\n+ * http://www.eclipse.org/legal/epl-v10.html\n+ *\n+ * Contributors:\n+ *     IBM Corporation - initial API and implementation\n+ *******************************************************************************/\n+package com.ibm.ws.security.acme.docker.boulder;\n+\n+import static junit.framework.Assert.fail;\n+\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.security.KeyStore;\n+import java.security.cert.Certificate;\n+import java.security.cert.X509Certificate;\n+import java.time.Duration;\n+import java.util.Map.Entry;\n+\n+import org.testcontainers.Testcontainers;\n+import org.testcontainers.containers.GenericContainer;\n+import org.testcontainers.containers.Network;\n+import com.github.dockerjava.api.model.ContainerNetwork;\n+import com.github.dockerjava.api.model.ContainerNetwork.Ipam;\n+import com.ibm.websphere.simplicity.log.Log;\n+import com.ibm.ws.security.acme.AcmeCaException;\n+import com.ibm.ws.security.acme.docker.CAContainer;\n+import com.ibm.ws.security.acme.fat.FATSuite;\n+import com.ibm.ws.security.acme.internal.AcmeClient;\n+import com.ibm.ws.security.acme.utils.AcmeFatUtils;\n+import com.ibm.ws.security.acme.utils.HttpChallengeServer;\n+/**\n+ * Testcontainer implementation for the letsencrypt/boulder container.\n+ * Boulder is designed to run with docker-compose. In order to integrate\n+ * Boulder into the acme FAT, the docker-compose file from letsencrypt\n+ * was turned into the following GenericContainers. This class consists\n+ * of three containers and two networks. Because Boulder consists of\n+ * many files, a Docker image was created that is built on top of\n+ * letsencrypt/boulder-tools-go and includes all the files that would\n+ * otherwise need to be copied at runtime. This saves 8+ minutes per\n+ * run.\n+ */\n+public class BoulderContainer extends CAContainer {\n+\n+\t/** The port used to listen for incoming ACME requests. */\n+\tpublic static final int LISTEN_PORT = 4001;\n+\tprivate static final String FILE_MINICA_PEM = \"lib/LibertyFATTestFiles/boulder.minica.pem\";\n+\t\n+\n+    \n+    public final Network bluenet = Network.builder()\n+            .createNetworkCmdModifier(cmd -> {\n+                cmd.withDriver(\"bridge\");\n+                cmd.withIpam(new com.github.dockerjava.api.model.Network.Ipam()\n+                        .withDriver(\"default\")\n+                        .withConfig(new com.github.dockerjava.api.model.Network.Ipam.Config()\n+                                .withSubnet(\"10.77.77.0/24\")));\n+            })\n+            .build();\n+\n+    public final Network rednet =  Network.builder()\n+            .createNetworkCmdModifier(cmd -> {\n+                cmd.withDriver(\"bridge\");\n+                cmd.withIpam(new com.github.dockerjava.api.model.Network.Ipam()\n+                        .withDriver(\"default\")\n+                        .withConfig(new com.github.dockerjava.api.model.Network.Ipam.Config()\n+                                .withSubnet(\"10.88.88.0/24\")));\n+            })\n+            .build();\n+    \n+    public final GenericContainer<?> bhsm = new GenericContainer<>(DOCKER_IMAGE)\n+            .withEnv(\"PKCS11_DAEMON_SOCKET\", \"tcp://0.0.0.0:5657\")\n+            .withExposedPorts(5657)\n+            .withNetwork(bluenet)\n+            .withNetworkAliases(\"boulder-hsm\")\n+            .withCommand(\"/usr/local/bin/pkcs11-daemon /usr/lib/softhsm/libsofthsm2.so\")\n+            .withLogConsumer(o -> System.out.print(\"[HSM] \" + o.getUtf8String()));\n+    \n+    public final GenericContainer<?> bmysql = new GenericContainer<>(\"mariadb:10.3\")\n+            .withNetwork(bluenet)\n+            .withExposedPorts(3306)\n+            .withNetworkAliases(\"boulder-mysql\")\n+            .withEnv(\"MYSQL_ALLOW_EMPTY_PASSWORD\", \"yes\")\n+            .withCommand(\"mysqld --bind-address=0.0.0.0 --slow-query-log --log-output=TABLE --log-queries-not-using-indexes=ON\")\n+            .withLogConsumer(o -> System.out.print(\"[SQL] \" + o.getUtf8String()));\n+    \n+    private static final String DOCKER_IMAGE = \"ryanesch/acme-boulder:1.1\";\n+    \n+    public BoulderContainer() {\n+        super(DOCKER_IMAGE);\n+\t\t/*\n+\t\t * Need to expose the HTTP port that is used to answer the HTTP-01\n+\t\t * challenge.\n+\t\t */\n+\t\tTestcontainers.exposeHostPorts(HTTP_PORT);\n+    \tstart();\n+    }\n+    \n+    @Override\n+    protected void configure() {\n+            this.withEnv(\"FAKE_DNS\", \"172.17.0.68\")\n+            .withEnv(\"PKCS11_PROXY_SOCKET\", \"tcp://boulder-hsm:5657\")\n+            .withEnv(\"BOULDER_CONFIG_DIR\", \"test/config\")\n+            .withEnv(\"GO111MODULE\", \"on\")\n+            .withEnv(\"GOFLAGS\", \"-mod=vendor\")\n+            .withEnv(\"PYTHONIOENCODING\", \"utf-8\")\n+            .withCreateContainerCmdModifier(cmd -> {\n+                cmd.withDns(\"10.77.77.77\");\n+            })\n+            \n+            .withWorkingDirectory(\"/go/src/github.com/letsencrypt/boulder\")\n+            .withCommand(\"/go/src/github.com/letsencrypt/boulder/test/entrypoint.sh\")\n+            .withNetworkAliases(\"boulder\")\n+            .withCreateContainerCmdModifier(cmd -> cmd.withHostName(\"boulder\"))\n+    \t\t.withExposedPorts(MANAGEMENT_PORT, LISTEN_PORT)\n+            .withLogConsumer(o -> System.out.print(\"[BOL] \" + o.getUtf8String()))\n+            .withStartupTimeout(Duration.ofMinutes(3));\n+    }\n+    \t\t\t\t\t\t\t\t\t\n+    \t\t\t\t\t\t\t\n+    \t\t\t\t\t\t\t\t\t\n+\n+    @Override\n+    protected void containerIsCreated(String containerId) {\n+        getDockerClient().connectToNetworkCmd()\n+                .withNetworkId(bluenet.getId())\n+                .withContainerId(containerId)\n+                .withContainerNetwork(new ContainerNetwork()\n+                        .withIpv4Address(\"10.77.77.77\")\n+                        .withNetworkID(bluenet.getId())\n+                        .withIpamConfig(new Ipam().withIpv4Address(\"10.77.77.77\"))\n+                        .withAliases(\"sa1.boulder\", \"ca1.boulder\", \"ra1.boulder\", \"va1.boulder\", \"publisher1.boulder\", \n+                              \"ocsp-updater.boulder\", \"admin-revoker.boulder\", \"nonce1.boulder\"))\n+                .exec();\n+        \n+        getDockerClient().connectToNetworkCmd()\n+                .withNetworkId(rednet.getId())\n+                .withContainerId(containerId)\n+                .withContainerNetwork(new ContainerNetwork()\n+                        .withIpv4Address(\"10.88.88.88\")\n+                        .withNetworkID(rednet.getId())\n+                        .withIpamConfig(new Ipam().withIpv4Address(\"10.88.88.88\"))\n+                        .withAliases(\"sa2.boulder\", \"ca2.boulder\", \"ra2.boulder\", \"va2.boulder\", \n+                                \"publisher2.boulder\", \"nonce2.boulder\"))\n+                .exec();\n+    }\n+    \n+\t/**\n+\t * We need to start up the containers in an orderly fashion so that we can", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3c28406c01e42dd902f376fac4532e84cf17aa5f"}, "originalPosition": 155}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUwODU5OTU4OnYy", "diffSide": "RIGHT", "path": "dev/com.ibm.ws.security.acme_fat/fat/src/com/ibm/ws/security/acme/docker/boulder/BoulderContainer.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wNlQxNzo0ODoyMlrOGBjGew==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wNlQxNzo0ODoyMlrOGBjGew==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDI3Njg1OQ==", "bodyText": "Move inside the method. Don't override the inherited javadoc.", "url": "https://github.com/OpenLiberty/open-liberty/pull/11374#discussion_r404276859", "createdAt": "2020-04-06T17:48:22Z", "author": {"login": "jvanhill"}, "path": "dev/com.ibm.ws.security.acme_fat/fat/src/com/ibm/ws/security/acme/docker/boulder/BoulderContainer.java", "diffHunk": "@@ -0,0 +1,214 @@\n+/*******************************************************************************\n+ * Copyright (c) 2019, 2020 IBM Corporation and others.\n+ * All rights reserved. This program and the accompanying materials\n+ * are made available under the terms of the Eclipse Public License v1.0\n+ * which accompanies this distribution, and is available at\n+ * http://www.eclipse.org/legal/epl-v10.html\n+ *\n+ * Contributors:\n+ *     IBM Corporation - initial API and implementation\n+ *******************************************************************************/\n+package com.ibm.ws.security.acme.docker.boulder;\n+\n+import static junit.framework.Assert.fail;\n+\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.security.KeyStore;\n+import java.security.cert.Certificate;\n+import java.security.cert.X509Certificate;\n+import java.time.Duration;\n+import java.util.Map.Entry;\n+\n+import org.testcontainers.Testcontainers;\n+import org.testcontainers.containers.GenericContainer;\n+import org.testcontainers.containers.Network;\n+import com.github.dockerjava.api.model.ContainerNetwork;\n+import com.github.dockerjava.api.model.ContainerNetwork.Ipam;\n+import com.ibm.websphere.simplicity.log.Log;\n+import com.ibm.ws.security.acme.AcmeCaException;\n+import com.ibm.ws.security.acme.docker.CAContainer;\n+import com.ibm.ws.security.acme.fat.FATSuite;\n+import com.ibm.ws.security.acme.internal.AcmeClient;\n+import com.ibm.ws.security.acme.utils.AcmeFatUtils;\n+import com.ibm.ws.security.acme.utils.HttpChallengeServer;\n+/**\n+ * Testcontainer implementation for the letsencrypt/boulder container.\n+ * Boulder is designed to run with docker-compose. In order to integrate\n+ * Boulder into the acme FAT, the docker-compose file from letsencrypt\n+ * was turned into the following GenericContainers. This class consists\n+ * of three containers and two networks. Because Boulder consists of\n+ * many files, a Docker image was created that is built on top of\n+ * letsencrypt/boulder-tools-go and includes all the files that would\n+ * otherwise need to be copied at runtime. This saves 8+ minutes per\n+ * run.\n+ */\n+public class BoulderContainer extends CAContainer {\n+\n+\t/** The port used to listen for incoming ACME requests. */\n+\tpublic static final int LISTEN_PORT = 4001;\n+\tprivate static final String FILE_MINICA_PEM = \"lib/LibertyFATTestFiles/boulder.minica.pem\";\n+\t\n+\n+    \n+    public final Network bluenet = Network.builder()\n+            .createNetworkCmdModifier(cmd -> {\n+                cmd.withDriver(\"bridge\");\n+                cmd.withIpam(new com.github.dockerjava.api.model.Network.Ipam()\n+                        .withDriver(\"default\")\n+                        .withConfig(new com.github.dockerjava.api.model.Network.Ipam.Config()\n+                                .withSubnet(\"10.77.77.0/24\")));\n+            })\n+            .build();\n+\n+    public final Network rednet =  Network.builder()\n+            .createNetworkCmdModifier(cmd -> {\n+                cmd.withDriver(\"bridge\");\n+                cmd.withIpam(new com.github.dockerjava.api.model.Network.Ipam()\n+                        .withDriver(\"default\")\n+                        .withConfig(new com.github.dockerjava.api.model.Network.Ipam.Config()\n+                                .withSubnet(\"10.88.88.0/24\")));\n+            })\n+            .build();\n+    \n+    public final GenericContainer<?> bhsm = new GenericContainer<>(DOCKER_IMAGE)\n+            .withEnv(\"PKCS11_DAEMON_SOCKET\", \"tcp://0.0.0.0:5657\")\n+            .withExposedPorts(5657)\n+            .withNetwork(bluenet)\n+            .withNetworkAliases(\"boulder-hsm\")\n+            .withCommand(\"/usr/local/bin/pkcs11-daemon /usr/lib/softhsm/libsofthsm2.so\")\n+            .withLogConsumer(o -> System.out.print(\"[HSM] \" + o.getUtf8String()));\n+    \n+    public final GenericContainer<?> bmysql = new GenericContainer<>(\"mariadb:10.3\")\n+            .withNetwork(bluenet)\n+            .withExposedPorts(3306)\n+            .withNetworkAliases(\"boulder-mysql\")\n+            .withEnv(\"MYSQL_ALLOW_EMPTY_PASSWORD\", \"yes\")\n+            .withCommand(\"mysqld --bind-address=0.0.0.0 --slow-query-log --log-output=TABLE --log-queries-not-using-indexes=ON\")\n+            .withLogConsumer(o -> System.out.print(\"[SQL] \" + o.getUtf8String()));\n+    \n+    private static final String DOCKER_IMAGE = \"ryanesch/acme-boulder:1.1\";\n+    \n+    public BoulderContainer() {\n+        super(DOCKER_IMAGE);\n+\t\t/*\n+\t\t * Need to expose the HTTP port that is used to answer the HTTP-01\n+\t\t * challenge.\n+\t\t */\n+\t\tTestcontainers.exposeHostPorts(HTTP_PORT);\n+    \tstart();\n+    }\n+    \n+    @Override\n+    protected void configure() {\n+            this.withEnv(\"FAKE_DNS\", \"172.17.0.68\")\n+            .withEnv(\"PKCS11_PROXY_SOCKET\", \"tcp://boulder-hsm:5657\")\n+            .withEnv(\"BOULDER_CONFIG_DIR\", \"test/config\")\n+            .withEnv(\"GO111MODULE\", \"on\")\n+            .withEnv(\"GOFLAGS\", \"-mod=vendor\")\n+            .withEnv(\"PYTHONIOENCODING\", \"utf-8\")\n+            .withCreateContainerCmdModifier(cmd -> {\n+                cmd.withDns(\"10.77.77.77\");\n+            })\n+            \n+            .withWorkingDirectory(\"/go/src/github.com/letsencrypt/boulder\")\n+            .withCommand(\"/go/src/github.com/letsencrypt/boulder/test/entrypoint.sh\")\n+            .withNetworkAliases(\"boulder\")\n+            .withCreateContainerCmdModifier(cmd -> cmd.withHostName(\"boulder\"))\n+    \t\t.withExposedPorts(MANAGEMENT_PORT, LISTEN_PORT)\n+            .withLogConsumer(o -> System.out.print(\"[BOL] \" + o.getUtf8String()))\n+            .withStartupTimeout(Duration.ofMinutes(3));\n+    }\n+    \t\t\t\t\t\t\t\t\t\n+    \t\t\t\t\t\t\t\n+    \t\t\t\t\t\t\t\t\t\n+\n+    @Override\n+    protected void containerIsCreated(String containerId) {\n+        getDockerClient().connectToNetworkCmd()\n+                .withNetworkId(bluenet.getId())\n+                .withContainerId(containerId)\n+                .withContainerNetwork(new ContainerNetwork()\n+                        .withIpv4Address(\"10.77.77.77\")\n+                        .withNetworkID(bluenet.getId())\n+                        .withIpamConfig(new Ipam().withIpv4Address(\"10.77.77.77\"))\n+                        .withAliases(\"sa1.boulder\", \"ca1.boulder\", \"ra1.boulder\", \"va1.boulder\", \"publisher1.boulder\", \n+                              \"ocsp-updater.boulder\", \"admin-revoker.boulder\", \"nonce1.boulder\"))\n+                .exec();\n+        \n+        getDockerClient().connectToNetworkCmd()\n+                .withNetworkId(rednet.getId())\n+                .withContainerId(containerId)\n+                .withContainerNetwork(new ContainerNetwork()\n+                        .withIpv4Address(\"10.88.88.88\")\n+                        .withNetworkID(rednet.getId())\n+                        .withIpamConfig(new Ipam().withIpv4Address(\"10.88.88.88\"))\n+                        .withAliases(\"sa2.boulder\", \"ca2.boulder\", \"ra2.boulder\", \"va2.boulder\", \n+                                \"publisher2.boulder\", \"nonce2.boulder\"))\n+                .exec();\n+    }\n+    \n+\t/**\n+\t * We need to start up the containers in an orderly fashion so that we can\n+\t * pass the IP address of the DNS server to the Boulder server.\n+\t * @throws IOException \n+\t */\n+    @Override\n+    public void start() {\n+        bmysql.start();\n+        bhsm.start();\n+        super.start();\n+        addARecords();\n+    }\n+    \n+    /**", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3c28406c01e42dd902f376fac4532e84cf17aa5f"}, "originalPosition": 167}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUwODYwMjEyOnYy", "diffSide": "RIGHT", "path": "dev/com.ibm.ws.security.acme_fat/fat/src/com/ibm/ws/security/acme/docker/boulder/BoulderContainer.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wNlQxNzo0ODo1OVrOGBjH_w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wNlQxNzo0ODo1OVrOGBjH_w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDI3NzI0Nw==", "bodyText": "Is there a reason to override the inherited javadoc?", "url": "https://github.com/OpenLiberty/open-liberty/pull/11374#discussion_r404277247", "createdAt": "2020-04-06T17:48:59Z", "author": {"login": "jvanhill"}, "path": "dev/com.ibm.ws.security.acme_fat/fat/src/com/ibm/ws/security/acme/docker/boulder/BoulderContainer.java", "diffHunk": "@@ -0,0 +1,214 @@\n+/*******************************************************************************\n+ * Copyright (c) 2019, 2020 IBM Corporation and others.\n+ * All rights reserved. This program and the accompanying materials\n+ * are made available under the terms of the Eclipse Public License v1.0\n+ * which accompanies this distribution, and is available at\n+ * http://www.eclipse.org/legal/epl-v10.html\n+ *\n+ * Contributors:\n+ *     IBM Corporation - initial API and implementation\n+ *******************************************************************************/\n+package com.ibm.ws.security.acme.docker.boulder;\n+\n+import static junit.framework.Assert.fail;\n+\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.security.KeyStore;\n+import java.security.cert.Certificate;\n+import java.security.cert.X509Certificate;\n+import java.time.Duration;\n+import java.util.Map.Entry;\n+\n+import org.testcontainers.Testcontainers;\n+import org.testcontainers.containers.GenericContainer;\n+import org.testcontainers.containers.Network;\n+import com.github.dockerjava.api.model.ContainerNetwork;\n+import com.github.dockerjava.api.model.ContainerNetwork.Ipam;\n+import com.ibm.websphere.simplicity.log.Log;\n+import com.ibm.ws.security.acme.AcmeCaException;\n+import com.ibm.ws.security.acme.docker.CAContainer;\n+import com.ibm.ws.security.acme.fat.FATSuite;\n+import com.ibm.ws.security.acme.internal.AcmeClient;\n+import com.ibm.ws.security.acme.utils.AcmeFatUtils;\n+import com.ibm.ws.security.acme.utils.HttpChallengeServer;\n+/**\n+ * Testcontainer implementation for the letsencrypt/boulder container.\n+ * Boulder is designed to run with docker-compose. In order to integrate\n+ * Boulder into the acme FAT, the docker-compose file from letsencrypt\n+ * was turned into the following GenericContainers. This class consists\n+ * of three containers and two networks. Because Boulder consists of\n+ * many files, a Docker image was created that is built on top of\n+ * letsencrypt/boulder-tools-go and includes all the files that would\n+ * otherwise need to be copied at runtime. This saves 8+ minutes per\n+ * run.\n+ */\n+public class BoulderContainer extends CAContainer {\n+\n+\t/** The port used to listen for incoming ACME requests. */\n+\tpublic static final int LISTEN_PORT = 4001;\n+\tprivate static final String FILE_MINICA_PEM = \"lib/LibertyFATTestFiles/boulder.minica.pem\";\n+\t\n+\n+    \n+    public final Network bluenet = Network.builder()\n+            .createNetworkCmdModifier(cmd -> {\n+                cmd.withDriver(\"bridge\");\n+                cmd.withIpam(new com.github.dockerjava.api.model.Network.Ipam()\n+                        .withDriver(\"default\")\n+                        .withConfig(new com.github.dockerjava.api.model.Network.Ipam.Config()\n+                                .withSubnet(\"10.77.77.0/24\")));\n+            })\n+            .build();\n+\n+    public final Network rednet =  Network.builder()\n+            .createNetworkCmdModifier(cmd -> {\n+                cmd.withDriver(\"bridge\");\n+                cmd.withIpam(new com.github.dockerjava.api.model.Network.Ipam()\n+                        .withDriver(\"default\")\n+                        .withConfig(new com.github.dockerjava.api.model.Network.Ipam.Config()\n+                                .withSubnet(\"10.88.88.0/24\")));\n+            })\n+            .build();\n+    \n+    public final GenericContainer<?> bhsm = new GenericContainer<>(DOCKER_IMAGE)\n+            .withEnv(\"PKCS11_DAEMON_SOCKET\", \"tcp://0.0.0.0:5657\")\n+            .withExposedPorts(5657)\n+            .withNetwork(bluenet)\n+            .withNetworkAliases(\"boulder-hsm\")\n+            .withCommand(\"/usr/local/bin/pkcs11-daemon /usr/lib/softhsm/libsofthsm2.so\")\n+            .withLogConsumer(o -> System.out.print(\"[HSM] \" + o.getUtf8String()));\n+    \n+    public final GenericContainer<?> bmysql = new GenericContainer<>(\"mariadb:10.3\")\n+            .withNetwork(bluenet)\n+            .withExposedPorts(3306)\n+            .withNetworkAliases(\"boulder-mysql\")\n+            .withEnv(\"MYSQL_ALLOW_EMPTY_PASSWORD\", \"yes\")\n+            .withCommand(\"mysqld --bind-address=0.0.0.0 --slow-query-log --log-output=TABLE --log-queries-not-using-indexes=ON\")\n+            .withLogConsumer(o -> System.out.print(\"[SQL] \" + o.getUtf8String()));\n+    \n+    private static final String DOCKER_IMAGE = \"ryanesch/acme-boulder:1.1\";\n+    \n+    public BoulderContainer() {\n+        super(DOCKER_IMAGE);\n+\t\t/*\n+\t\t * Need to expose the HTTP port that is used to answer the HTTP-01\n+\t\t * challenge.\n+\t\t */\n+\t\tTestcontainers.exposeHostPorts(HTTP_PORT);\n+    \tstart();\n+    }\n+    \n+    @Override\n+    protected void configure() {\n+            this.withEnv(\"FAKE_DNS\", \"172.17.0.68\")\n+            .withEnv(\"PKCS11_PROXY_SOCKET\", \"tcp://boulder-hsm:5657\")\n+            .withEnv(\"BOULDER_CONFIG_DIR\", \"test/config\")\n+            .withEnv(\"GO111MODULE\", \"on\")\n+            .withEnv(\"GOFLAGS\", \"-mod=vendor\")\n+            .withEnv(\"PYTHONIOENCODING\", \"utf-8\")\n+            .withCreateContainerCmdModifier(cmd -> {\n+                cmd.withDns(\"10.77.77.77\");\n+            })\n+            \n+            .withWorkingDirectory(\"/go/src/github.com/letsencrypt/boulder\")\n+            .withCommand(\"/go/src/github.com/letsencrypt/boulder/test/entrypoint.sh\")\n+            .withNetworkAliases(\"boulder\")\n+            .withCreateContainerCmdModifier(cmd -> cmd.withHostName(\"boulder\"))\n+    \t\t.withExposedPorts(MANAGEMENT_PORT, LISTEN_PORT)\n+            .withLogConsumer(o -> System.out.print(\"[BOL] \" + o.getUtf8String()))\n+            .withStartupTimeout(Duration.ofMinutes(3));\n+    }\n+    \t\t\t\t\t\t\t\t\t\n+    \t\t\t\t\t\t\t\n+    \t\t\t\t\t\t\t\t\t\n+\n+    @Override\n+    protected void containerIsCreated(String containerId) {\n+        getDockerClient().connectToNetworkCmd()\n+                .withNetworkId(bluenet.getId())\n+                .withContainerId(containerId)\n+                .withContainerNetwork(new ContainerNetwork()\n+                        .withIpv4Address(\"10.77.77.77\")\n+                        .withNetworkID(bluenet.getId())\n+                        .withIpamConfig(new Ipam().withIpv4Address(\"10.77.77.77\"))\n+                        .withAliases(\"sa1.boulder\", \"ca1.boulder\", \"ra1.boulder\", \"va1.boulder\", \"publisher1.boulder\", \n+                              \"ocsp-updater.boulder\", \"admin-revoker.boulder\", \"nonce1.boulder\"))\n+                .exec();\n+        \n+        getDockerClient().connectToNetworkCmd()\n+                .withNetworkId(rednet.getId())\n+                .withContainerId(containerId)\n+                .withContainerNetwork(new ContainerNetwork()\n+                        .withIpv4Address(\"10.88.88.88\")\n+                        .withNetworkID(rednet.getId())\n+                        .withIpamConfig(new Ipam().withIpv4Address(\"10.88.88.88\"))\n+                        .withAliases(\"sa2.boulder\", \"ca2.boulder\", \"ra2.boulder\", \"va2.boulder\", \n+                                \"publisher2.boulder\", \"nonce2.boulder\"))\n+                .exec();\n+    }\n+    \n+\t/**\n+\t * We need to start up the containers in an orderly fashion so that we can\n+\t * pass the IP address of the DNS server to the Boulder server.\n+\t * @throws IOException \n+\t */\n+    @Override\n+    public void start() {\n+        bmysql.start();\n+        bhsm.start();\n+        super.start();\n+        addARecords();\n+    }\n+    \n+    /**\n+     * Stop all the containers, the challenge server, and the networks.\n+     */\n+    @Override\n+    public void stop() {\n+        bmysql.stop();\n+        bhsm.stop();\n+        super.stop();\n+\t\tbluenet.close();\n+\t\trednet.close();\n+    }\n+   \n+    /**\n+     * @return the InputStream that points to Boulder's PEM file.\n+     */\n+    @Override\n+\tpublic InputStream getAcmeCaIntermediateCertificate() throws Exception {\n+\t\treturn new FileInputStream(new File(FILE_MINICA_PEM));\n+\t}\n+    /**\n+     * Get Boulder's directory URI. Pebble has two possible URIs to", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3c28406c01e42dd902f376fac4532e84cf17aa5f"}, "originalPosition": 187}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUwODYwMjkyOnYy", "diffSide": "RIGHT", "path": "dev/com.ibm.ws.security.acme_fat/fat/src/com/ibm/ws/security/acme/docker/boulder/BoulderContainer.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wNlQxNzo0OTowOFrOGBjIdA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wNlQxNzo0OTowOFrOGBjIdA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDI3NzM2NA==", "bodyText": "whitespace", "url": "https://github.com/OpenLiberty/open-liberty/pull/11374#discussion_r404277364", "createdAt": "2020-04-06T17:49:08Z", "author": {"login": "jvanhill"}, "path": "dev/com.ibm.ws.security.acme_fat/fat/src/com/ibm/ws/security/acme/docker/boulder/BoulderContainer.java", "diffHunk": "@@ -0,0 +1,214 @@\n+/*******************************************************************************\n+ * Copyright (c) 2019, 2020 IBM Corporation and others.\n+ * All rights reserved. This program and the accompanying materials\n+ * are made available under the terms of the Eclipse Public License v1.0\n+ * which accompanies this distribution, and is available at\n+ * http://www.eclipse.org/legal/epl-v10.html\n+ *\n+ * Contributors:\n+ *     IBM Corporation - initial API and implementation\n+ *******************************************************************************/\n+package com.ibm.ws.security.acme.docker.boulder;\n+\n+import static junit.framework.Assert.fail;\n+\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.security.KeyStore;\n+import java.security.cert.Certificate;\n+import java.security.cert.X509Certificate;\n+import java.time.Duration;\n+import java.util.Map.Entry;\n+\n+import org.testcontainers.Testcontainers;\n+import org.testcontainers.containers.GenericContainer;\n+import org.testcontainers.containers.Network;\n+import com.github.dockerjava.api.model.ContainerNetwork;\n+import com.github.dockerjava.api.model.ContainerNetwork.Ipam;\n+import com.ibm.websphere.simplicity.log.Log;\n+import com.ibm.ws.security.acme.AcmeCaException;\n+import com.ibm.ws.security.acme.docker.CAContainer;\n+import com.ibm.ws.security.acme.fat.FATSuite;\n+import com.ibm.ws.security.acme.internal.AcmeClient;\n+import com.ibm.ws.security.acme.utils.AcmeFatUtils;\n+import com.ibm.ws.security.acme.utils.HttpChallengeServer;\n+/**\n+ * Testcontainer implementation for the letsencrypt/boulder container.\n+ * Boulder is designed to run with docker-compose. In order to integrate\n+ * Boulder into the acme FAT, the docker-compose file from letsencrypt\n+ * was turned into the following GenericContainers. This class consists\n+ * of three containers and two networks. Because Boulder consists of\n+ * many files, a Docker image was created that is built on top of\n+ * letsencrypt/boulder-tools-go and includes all the files that would\n+ * otherwise need to be copied at runtime. This saves 8+ minutes per\n+ * run.\n+ */\n+public class BoulderContainer extends CAContainer {\n+\n+\t/** The port used to listen for incoming ACME requests. */\n+\tpublic static final int LISTEN_PORT = 4001;\n+\tprivate static final String FILE_MINICA_PEM = \"lib/LibertyFATTestFiles/boulder.minica.pem\";\n+\t\n+\n+    \n+    public final Network bluenet = Network.builder()\n+            .createNetworkCmdModifier(cmd -> {\n+                cmd.withDriver(\"bridge\");\n+                cmd.withIpam(new com.github.dockerjava.api.model.Network.Ipam()\n+                        .withDriver(\"default\")\n+                        .withConfig(new com.github.dockerjava.api.model.Network.Ipam.Config()\n+                                .withSubnet(\"10.77.77.0/24\")));\n+            })\n+            .build();\n+\n+    public final Network rednet =  Network.builder()\n+            .createNetworkCmdModifier(cmd -> {\n+                cmd.withDriver(\"bridge\");\n+                cmd.withIpam(new com.github.dockerjava.api.model.Network.Ipam()\n+                        .withDriver(\"default\")\n+                        .withConfig(new com.github.dockerjava.api.model.Network.Ipam.Config()\n+                                .withSubnet(\"10.88.88.0/24\")));\n+            })\n+            .build();\n+    \n+    public final GenericContainer<?> bhsm = new GenericContainer<>(DOCKER_IMAGE)\n+            .withEnv(\"PKCS11_DAEMON_SOCKET\", \"tcp://0.0.0.0:5657\")\n+            .withExposedPorts(5657)\n+            .withNetwork(bluenet)\n+            .withNetworkAliases(\"boulder-hsm\")\n+            .withCommand(\"/usr/local/bin/pkcs11-daemon /usr/lib/softhsm/libsofthsm2.so\")\n+            .withLogConsumer(o -> System.out.print(\"[HSM] \" + o.getUtf8String()));\n+    \n+    public final GenericContainer<?> bmysql = new GenericContainer<>(\"mariadb:10.3\")\n+            .withNetwork(bluenet)\n+            .withExposedPorts(3306)\n+            .withNetworkAliases(\"boulder-mysql\")\n+            .withEnv(\"MYSQL_ALLOW_EMPTY_PASSWORD\", \"yes\")\n+            .withCommand(\"mysqld --bind-address=0.0.0.0 --slow-query-log --log-output=TABLE --log-queries-not-using-indexes=ON\")\n+            .withLogConsumer(o -> System.out.print(\"[SQL] \" + o.getUtf8String()));\n+    \n+    private static final String DOCKER_IMAGE = \"ryanesch/acme-boulder:1.1\";\n+    \n+    public BoulderContainer() {\n+        super(DOCKER_IMAGE);\n+\t\t/*\n+\t\t * Need to expose the HTTP port that is used to answer the HTTP-01\n+\t\t * challenge.\n+\t\t */\n+\t\tTestcontainers.exposeHostPorts(HTTP_PORT);\n+    \tstart();\n+    }\n+    \n+    @Override\n+    protected void configure() {\n+            this.withEnv(\"FAKE_DNS\", \"172.17.0.68\")\n+            .withEnv(\"PKCS11_PROXY_SOCKET\", \"tcp://boulder-hsm:5657\")\n+            .withEnv(\"BOULDER_CONFIG_DIR\", \"test/config\")\n+            .withEnv(\"GO111MODULE\", \"on\")\n+            .withEnv(\"GOFLAGS\", \"-mod=vendor\")\n+            .withEnv(\"PYTHONIOENCODING\", \"utf-8\")\n+            .withCreateContainerCmdModifier(cmd -> {\n+                cmd.withDns(\"10.77.77.77\");\n+            })\n+            \n+            .withWorkingDirectory(\"/go/src/github.com/letsencrypt/boulder\")\n+            .withCommand(\"/go/src/github.com/letsencrypt/boulder/test/entrypoint.sh\")\n+            .withNetworkAliases(\"boulder\")\n+            .withCreateContainerCmdModifier(cmd -> cmd.withHostName(\"boulder\"))\n+    \t\t.withExposedPorts(MANAGEMENT_PORT, LISTEN_PORT)\n+            .withLogConsumer(o -> System.out.print(\"[BOL] \" + o.getUtf8String()))\n+            .withStartupTimeout(Duration.ofMinutes(3));\n+    }\n+    \t\t\t\t\t\t\t\t\t\n+    \t\t\t\t\t\t\t\n+    \t\t\t\t\t\t\t\t\t\n+\n+    @Override\n+    protected void containerIsCreated(String containerId) {\n+        getDockerClient().connectToNetworkCmd()\n+                .withNetworkId(bluenet.getId())\n+                .withContainerId(containerId)\n+                .withContainerNetwork(new ContainerNetwork()\n+                        .withIpv4Address(\"10.77.77.77\")\n+                        .withNetworkID(bluenet.getId())\n+                        .withIpamConfig(new Ipam().withIpv4Address(\"10.77.77.77\"))\n+                        .withAliases(\"sa1.boulder\", \"ca1.boulder\", \"ra1.boulder\", \"va1.boulder\", \"publisher1.boulder\", \n+                              \"ocsp-updater.boulder\", \"admin-revoker.boulder\", \"nonce1.boulder\"))\n+                .exec();\n+        \n+        getDockerClient().connectToNetworkCmd()\n+                .withNetworkId(rednet.getId())\n+                .withContainerId(containerId)\n+                .withContainerNetwork(new ContainerNetwork()\n+                        .withIpv4Address(\"10.88.88.88\")\n+                        .withNetworkID(rednet.getId())\n+                        .withIpamConfig(new Ipam().withIpv4Address(\"10.88.88.88\"))\n+                        .withAliases(\"sa2.boulder\", \"ca2.boulder\", \"ra2.boulder\", \"va2.boulder\", \n+                                \"publisher2.boulder\", \"nonce2.boulder\"))\n+                .exec();\n+    }\n+    \n+\t/**\n+\t * We need to start up the containers in an orderly fashion so that we can\n+\t * pass the IP address of the DNS server to the Boulder server.\n+\t * @throws IOException \n+\t */\n+    @Override\n+    public void start() {\n+        bmysql.start();\n+        bhsm.start();\n+        super.start();\n+        addARecords();\n+    }\n+    \n+    /**\n+     * Stop all the containers, the challenge server, and the networks.\n+     */\n+    @Override\n+    public void stop() {\n+        bmysql.stop();\n+        bhsm.stop();\n+        super.stop();\n+\t\tbluenet.close();\n+\t\trednet.close();\n+    }\n+   \n+    /**\n+     * @return the InputStream that points to Boulder's PEM file.\n+     */\n+    @Override\n+\tpublic InputStream getAcmeCaIntermediateCertificate() throws Exception {\n+\t\treturn new FileInputStream(new File(FILE_MINICA_PEM));\n+\t}\n+    /**", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3c28406c01e42dd902f376fac4532e84cf17aa5f"}, "originalPosition": 186}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUwODYwMzI3OnYy", "diffSide": "RIGHT", "path": "dev/com.ibm.ws.security.acme_fat/fat/src/com/ibm/ws/security/acme/docker/boulder/BoulderContainer.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wNlQxNzo0OToxM1rOGBjIpA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wNlQyMjozMDoyMlrOGBsSVw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDI3NzQxMg==", "bodyText": "Is there a reason to override the inherited javadoc?", "url": "https://github.com/OpenLiberty/open-liberty/pull/11374#discussion_r404277412", "createdAt": "2020-04-06T17:49:13Z", "author": {"login": "jvanhill"}, "path": "dev/com.ibm.ws.security.acme_fat/fat/src/com/ibm/ws/security/acme/docker/boulder/BoulderContainer.java", "diffHunk": "@@ -0,0 +1,214 @@\n+/*******************************************************************************\n+ * Copyright (c) 2019, 2020 IBM Corporation and others.\n+ * All rights reserved. This program and the accompanying materials\n+ * are made available under the terms of the Eclipse Public License v1.0\n+ * which accompanies this distribution, and is available at\n+ * http://www.eclipse.org/legal/epl-v10.html\n+ *\n+ * Contributors:\n+ *     IBM Corporation - initial API and implementation\n+ *******************************************************************************/\n+package com.ibm.ws.security.acme.docker.boulder;\n+\n+import static junit.framework.Assert.fail;\n+\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.security.KeyStore;\n+import java.security.cert.Certificate;\n+import java.security.cert.X509Certificate;\n+import java.time.Duration;\n+import java.util.Map.Entry;\n+\n+import org.testcontainers.Testcontainers;\n+import org.testcontainers.containers.GenericContainer;\n+import org.testcontainers.containers.Network;\n+import com.github.dockerjava.api.model.ContainerNetwork;\n+import com.github.dockerjava.api.model.ContainerNetwork.Ipam;\n+import com.ibm.websphere.simplicity.log.Log;\n+import com.ibm.ws.security.acme.AcmeCaException;\n+import com.ibm.ws.security.acme.docker.CAContainer;\n+import com.ibm.ws.security.acme.fat.FATSuite;\n+import com.ibm.ws.security.acme.internal.AcmeClient;\n+import com.ibm.ws.security.acme.utils.AcmeFatUtils;\n+import com.ibm.ws.security.acme.utils.HttpChallengeServer;\n+/**\n+ * Testcontainer implementation for the letsencrypt/boulder container.\n+ * Boulder is designed to run with docker-compose. In order to integrate\n+ * Boulder into the acme FAT, the docker-compose file from letsencrypt\n+ * was turned into the following GenericContainers. This class consists\n+ * of three containers and two networks. Because Boulder consists of\n+ * many files, a Docker image was created that is built on top of\n+ * letsencrypt/boulder-tools-go and includes all the files that would\n+ * otherwise need to be copied at runtime. This saves 8+ minutes per\n+ * run.\n+ */\n+public class BoulderContainer extends CAContainer {\n+\n+\t/** The port used to listen for incoming ACME requests. */\n+\tpublic static final int LISTEN_PORT = 4001;\n+\tprivate static final String FILE_MINICA_PEM = \"lib/LibertyFATTestFiles/boulder.minica.pem\";\n+\t\n+\n+    \n+    public final Network bluenet = Network.builder()\n+            .createNetworkCmdModifier(cmd -> {\n+                cmd.withDriver(\"bridge\");\n+                cmd.withIpam(new com.github.dockerjava.api.model.Network.Ipam()\n+                        .withDriver(\"default\")\n+                        .withConfig(new com.github.dockerjava.api.model.Network.Ipam.Config()\n+                                .withSubnet(\"10.77.77.0/24\")));\n+            })\n+            .build();\n+\n+    public final Network rednet =  Network.builder()\n+            .createNetworkCmdModifier(cmd -> {\n+                cmd.withDriver(\"bridge\");\n+                cmd.withIpam(new com.github.dockerjava.api.model.Network.Ipam()\n+                        .withDriver(\"default\")\n+                        .withConfig(new com.github.dockerjava.api.model.Network.Ipam.Config()\n+                                .withSubnet(\"10.88.88.0/24\")));\n+            })\n+            .build();\n+    \n+    public final GenericContainer<?> bhsm = new GenericContainer<>(DOCKER_IMAGE)\n+            .withEnv(\"PKCS11_DAEMON_SOCKET\", \"tcp://0.0.0.0:5657\")\n+            .withExposedPorts(5657)\n+            .withNetwork(bluenet)\n+            .withNetworkAliases(\"boulder-hsm\")\n+            .withCommand(\"/usr/local/bin/pkcs11-daemon /usr/lib/softhsm/libsofthsm2.so\")\n+            .withLogConsumer(o -> System.out.print(\"[HSM] \" + o.getUtf8String()));\n+    \n+    public final GenericContainer<?> bmysql = new GenericContainer<>(\"mariadb:10.3\")\n+            .withNetwork(bluenet)\n+            .withExposedPorts(3306)\n+            .withNetworkAliases(\"boulder-mysql\")\n+            .withEnv(\"MYSQL_ALLOW_EMPTY_PASSWORD\", \"yes\")\n+            .withCommand(\"mysqld --bind-address=0.0.0.0 --slow-query-log --log-output=TABLE --log-queries-not-using-indexes=ON\")\n+            .withLogConsumer(o -> System.out.print(\"[SQL] \" + o.getUtf8String()));\n+    \n+    private static final String DOCKER_IMAGE = \"ryanesch/acme-boulder:1.1\";\n+    \n+    public BoulderContainer() {\n+        super(DOCKER_IMAGE);\n+\t\t/*\n+\t\t * Need to expose the HTTP port that is used to answer the HTTP-01\n+\t\t * challenge.\n+\t\t */\n+\t\tTestcontainers.exposeHostPorts(HTTP_PORT);\n+    \tstart();\n+    }\n+    \n+    @Override\n+    protected void configure() {\n+            this.withEnv(\"FAKE_DNS\", \"172.17.0.68\")\n+            .withEnv(\"PKCS11_PROXY_SOCKET\", \"tcp://boulder-hsm:5657\")\n+            .withEnv(\"BOULDER_CONFIG_DIR\", \"test/config\")\n+            .withEnv(\"GO111MODULE\", \"on\")\n+            .withEnv(\"GOFLAGS\", \"-mod=vendor\")\n+            .withEnv(\"PYTHONIOENCODING\", \"utf-8\")\n+            .withCreateContainerCmdModifier(cmd -> {\n+                cmd.withDns(\"10.77.77.77\");\n+            })\n+            \n+            .withWorkingDirectory(\"/go/src/github.com/letsencrypt/boulder\")\n+            .withCommand(\"/go/src/github.com/letsencrypt/boulder/test/entrypoint.sh\")\n+            .withNetworkAliases(\"boulder\")\n+            .withCreateContainerCmdModifier(cmd -> cmd.withHostName(\"boulder\"))\n+    \t\t.withExposedPorts(MANAGEMENT_PORT, LISTEN_PORT)\n+            .withLogConsumer(o -> System.out.print(\"[BOL] \" + o.getUtf8String()))\n+            .withStartupTimeout(Duration.ofMinutes(3));\n+    }\n+    \t\t\t\t\t\t\t\t\t\n+    \t\t\t\t\t\t\t\n+    \t\t\t\t\t\t\t\t\t\n+\n+    @Override\n+    protected void containerIsCreated(String containerId) {\n+        getDockerClient().connectToNetworkCmd()\n+                .withNetworkId(bluenet.getId())\n+                .withContainerId(containerId)\n+                .withContainerNetwork(new ContainerNetwork()\n+                        .withIpv4Address(\"10.77.77.77\")\n+                        .withNetworkID(bluenet.getId())\n+                        .withIpamConfig(new Ipam().withIpv4Address(\"10.77.77.77\"))\n+                        .withAliases(\"sa1.boulder\", \"ca1.boulder\", \"ra1.boulder\", \"va1.boulder\", \"publisher1.boulder\", \n+                              \"ocsp-updater.boulder\", \"admin-revoker.boulder\", \"nonce1.boulder\"))\n+                .exec();\n+        \n+        getDockerClient().connectToNetworkCmd()\n+                .withNetworkId(rednet.getId())\n+                .withContainerId(containerId)\n+                .withContainerNetwork(new ContainerNetwork()\n+                        .withIpv4Address(\"10.88.88.88\")\n+                        .withNetworkID(rednet.getId())\n+                        .withIpamConfig(new Ipam().withIpv4Address(\"10.88.88.88\"))\n+                        .withAliases(\"sa2.boulder\", \"ca2.boulder\", \"ra2.boulder\", \"va2.boulder\", \n+                                \"publisher2.boulder\", \"nonce2.boulder\"))\n+                .exec();\n+    }\n+    \n+\t/**\n+\t * We need to start up the containers in an orderly fashion so that we can\n+\t * pass the IP address of the DNS server to the Boulder server.\n+\t * @throws IOException \n+\t */\n+    @Override\n+    public void start() {\n+        bmysql.start();\n+        bhsm.start();\n+        super.start();\n+        addARecords();\n+    }\n+    \n+    /**\n+     * Stop all the containers, the challenge server, and the networks.\n+     */\n+    @Override\n+    public void stop() {\n+        bmysql.stop();\n+        bhsm.stop();\n+        super.stop();\n+\t\tbluenet.close();\n+\t\trednet.close();\n+    }\n+   \n+    /**\n+     * @return the InputStream that points to Boulder's PEM file.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3c28406c01e42dd902f376fac4532e84cf17aa5f"}, "originalPosition": 180}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDQyNzM1MQ==", "bodyText": "no", "url": "https://github.com/OpenLiberty/open-liberty/pull/11374#discussion_r404427351", "createdAt": "2020-04-06T22:30:22Z", "author": {"login": "ryanesch"}, "path": "dev/com.ibm.ws.security.acme_fat/fat/src/com/ibm/ws/security/acme/docker/boulder/BoulderContainer.java", "diffHunk": "@@ -0,0 +1,214 @@\n+/*******************************************************************************\n+ * Copyright (c) 2019, 2020 IBM Corporation and others.\n+ * All rights reserved. This program and the accompanying materials\n+ * are made available under the terms of the Eclipse Public License v1.0\n+ * which accompanies this distribution, and is available at\n+ * http://www.eclipse.org/legal/epl-v10.html\n+ *\n+ * Contributors:\n+ *     IBM Corporation - initial API and implementation\n+ *******************************************************************************/\n+package com.ibm.ws.security.acme.docker.boulder;\n+\n+import static junit.framework.Assert.fail;\n+\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.security.KeyStore;\n+import java.security.cert.Certificate;\n+import java.security.cert.X509Certificate;\n+import java.time.Duration;\n+import java.util.Map.Entry;\n+\n+import org.testcontainers.Testcontainers;\n+import org.testcontainers.containers.GenericContainer;\n+import org.testcontainers.containers.Network;\n+import com.github.dockerjava.api.model.ContainerNetwork;\n+import com.github.dockerjava.api.model.ContainerNetwork.Ipam;\n+import com.ibm.websphere.simplicity.log.Log;\n+import com.ibm.ws.security.acme.AcmeCaException;\n+import com.ibm.ws.security.acme.docker.CAContainer;\n+import com.ibm.ws.security.acme.fat.FATSuite;\n+import com.ibm.ws.security.acme.internal.AcmeClient;\n+import com.ibm.ws.security.acme.utils.AcmeFatUtils;\n+import com.ibm.ws.security.acme.utils.HttpChallengeServer;\n+/**\n+ * Testcontainer implementation for the letsencrypt/boulder container.\n+ * Boulder is designed to run with docker-compose. In order to integrate\n+ * Boulder into the acme FAT, the docker-compose file from letsencrypt\n+ * was turned into the following GenericContainers. This class consists\n+ * of three containers and two networks. Because Boulder consists of\n+ * many files, a Docker image was created that is built on top of\n+ * letsencrypt/boulder-tools-go and includes all the files that would\n+ * otherwise need to be copied at runtime. This saves 8+ minutes per\n+ * run.\n+ */\n+public class BoulderContainer extends CAContainer {\n+\n+\t/** The port used to listen for incoming ACME requests. */\n+\tpublic static final int LISTEN_PORT = 4001;\n+\tprivate static final String FILE_MINICA_PEM = \"lib/LibertyFATTestFiles/boulder.minica.pem\";\n+\t\n+\n+    \n+    public final Network bluenet = Network.builder()\n+            .createNetworkCmdModifier(cmd -> {\n+                cmd.withDriver(\"bridge\");\n+                cmd.withIpam(new com.github.dockerjava.api.model.Network.Ipam()\n+                        .withDriver(\"default\")\n+                        .withConfig(new com.github.dockerjava.api.model.Network.Ipam.Config()\n+                                .withSubnet(\"10.77.77.0/24\")));\n+            })\n+            .build();\n+\n+    public final Network rednet =  Network.builder()\n+            .createNetworkCmdModifier(cmd -> {\n+                cmd.withDriver(\"bridge\");\n+                cmd.withIpam(new com.github.dockerjava.api.model.Network.Ipam()\n+                        .withDriver(\"default\")\n+                        .withConfig(new com.github.dockerjava.api.model.Network.Ipam.Config()\n+                                .withSubnet(\"10.88.88.0/24\")));\n+            })\n+            .build();\n+    \n+    public final GenericContainer<?> bhsm = new GenericContainer<>(DOCKER_IMAGE)\n+            .withEnv(\"PKCS11_DAEMON_SOCKET\", \"tcp://0.0.0.0:5657\")\n+            .withExposedPorts(5657)\n+            .withNetwork(bluenet)\n+            .withNetworkAliases(\"boulder-hsm\")\n+            .withCommand(\"/usr/local/bin/pkcs11-daemon /usr/lib/softhsm/libsofthsm2.so\")\n+            .withLogConsumer(o -> System.out.print(\"[HSM] \" + o.getUtf8String()));\n+    \n+    public final GenericContainer<?> bmysql = new GenericContainer<>(\"mariadb:10.3\")\n+            .withNetwork(bluenet)\n+            .withExposedPorts(3306)\n+            .withNetworkAliases(\"boulder-mysql\")\n+            .withEnv(\"MYSQL_ALLOW_EMPTY_PASSWORD\", \"yes\")\n+            .withCommand(\"mysqld --bind-address=0.0.0.0 --slow-query-log --log-output=TABLE --log-queries-not-using-indexes=ON\")\n+            .withLogConsumer(o -> System.out.print(\"[SQL] \" + o.getUtf8String()));\n+    \n+    private static final String DOCKER_IMAGE = \"ryanesch/acme-boulder:1.1\";\n+    \n+    public BoulderContainer() {\n+        super(DOCKER_IMAGE);\n+\t\t/*\n+\t\t * Need to expose the HTTP port that is used to answer the HTTP-01\n+\t\t * challenge.\n+\t\t */\n+\t\tTestcontainers.exposeHostPorts(HTTP_PORT);\n+    \tstart();\n+    }\n+    \n+    @Override\n+    protected void configure() {\n+            this.withEnv(\"FAKE_DNS\", \"172.17.0.68\")\n+            .withEnv(\"PKCS11_PROXY_SOCKET\", \"tcp://boulder-hsm:5657\")\n+            .withEnv(\"BOULDER_CONFIG_DIR\", \"test/config\")\n+            .withEnv(\"GO111MODULE\", \"on\")\n+            .withEnv(\"GOFLAGS\", \"-mod=vendor\")\n+            .withEnv(\"PYTHONIOENCODING\", \"utf-8\")\n+            .withCreateContainerCmdModifier(cmd -> {\n+                cmd.withDns(\"10.77.77.77\");\n+            })\n+            \n+            .withWorkingDirectory(\"/go/src/github.com/letsencrypt/boulder\")\n+            .withCommand(\"/go/src/github.com/letsencrypt/boulder/test/entrypoint.sh\")\n+            .withNetworkAliases(\"boulder\")\n+            .withCreateContainerCmdModifier(cmd -> cmd.withHostName(\"boulder\"))\n+    \t\t.withExposedPorts(MANAGEMENT_PORT, LISTEN_PORT)\n+            .withLogConsumer(o -> System.out.print(\"[BOL] \" + o.getUtf8String()))\n+            .withStartupTimeout(Duration.ofMinutes(3));\n+    }\n+    \t\t\t\t\t\t\t\t\t\n+    \t\t\t\t\t\t\t\n+    \t\t\t\t\t\t\t\t\t\n+\n+    @Override\n+    protected void containerIsCreated(String containerId) {\n+        getDockerClient().connectToNetworkCmd()\n+                .withNetworkId(bluenet.getId())\n+                .withContainerId(containerId)\n+                .withContainerNetwork(new ContainerNetwork()\n+                        .withIpv4Address(\"10.77.77.77\")\n+                        .withNetworkID(bluenet.getId())\n+                        .withIpamConfig(new Ipam().withIpv4Address(\"10.77.77.77\"))\n+                        .withAliases(\"sa1.boulder\", \"ca1.boulder\", \"ra1.boulder\", \"va1.boulder\", \"publisher1.boulder\", \n+                              \"ocsp-updater.boulder\", \"admin-revoker.boulder\", \"nonce1.boulder\"))\n+                .exec();\n+        \n+        getDockerClient().connectToNetworkCmd()\n+                .withNetworkId(rednet.getId())\n+                .withContainerId(containerId)\n+                .withContainerNetwork(new ContainerNetwork()\n+                        .withIpv4Address(\"10.88.88.88\")\n+                        .withNetworkID(rednet.getId())\n+                        .withIpamConfig(new Ipam().withIpv4Address(\"10.88.88.88\"))\n+                        .withAliases(\"sa2.boulder\", \"ca2.boulder\", \"ra2.boulder\", \"va2.boulder\", \n+                                \"publisher2.boulder\", \"nonce2.boulder\"))\n+                .exec();\n+    }\n+    \n+\t/**\n+\t * We need to start up the containers in an orderly fashion so that we can\n+\t * pass the IP address of the DNS server to the Boulder server.\n+\t * @throws IOException \n+\t */\n+    @Override\n+    public void start() {\n+        bmysql.start();\n+        bhsm.start();\n+        super.start();\n+        addARecords();\n+    }\n+    \n+    /**\n+     * Stop all the containers, the challenge server, and the networks.\n+     */\n+    @Override\n+    public void stop() {\n+        bmysql.stop();\n+        bhsm.stop();\n+        super.stop();\n+\t\tbluenet.close();\n+\t\trednet.close();\n+    }\n+   \n+    /**\n+     * @return the InputStream that points to Boulder's PEM file.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDI3NzQxMg=="}, "originalCommit": {"oid": "3c28406c01e42dd902f376fac4532e84cf17aa5f"}, "originalPosition": 180}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUwODYwNDEzOnYy", "diffSide": "RIGHT", "path": "dev/com.ibm.ws.security.acme_fat/fat/src/com/ibm/ws/security/acme/docker/boulder/BoulderContainer.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wNlQxNzo0OToyOFrOGBjJMg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wNlQxNzo0OToyOFrOGBjJMg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDI3NzU1NA==", "bodyText": "whitespace", "url": "https://github.com/OpenLiberty/open-liberty/pull/11374#discussion_r404277554", "createdAt": "2020-04-06T17:49:28Z", "author": {"login": "jvanhill"}, "path": "dev/com.ibm.ws.security.acme_fat/fat/src/com/ibm/ws/security/acme/docker/boulder/BoulderContainer.java", "diffHunk": "@@ -0,0 +1,214 @@\n+/*******************************************************************************\n+ * Copyright (c) 2019, 2020 IBM Corporation and others.\n+ * All rights reserved. This program and the accompanying materials\n+ * are made available under the terms of the Eclipse Public License v1.0\n+ * which accompanies this distribution, and is available at\n+ * http://www.eclipse.org/legal/epl-v10.html\n+ *\n+ * Contributors:\n+ *     IBM Corporation - initial API and implementation\n+ *******************************************************************************/\n+package com.ibm.ws.security.acme.docker.boulder;\n+\n+import static junit.framework.Assert.fail;\n+\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.security.KeyStore;\n+import java.security.cert.Certificate;\n+import java.security.cert.X509Certificate;\n+import java.time.Duration;\n+import java.util.Map.Entry;\n+\n+import org.testcontainers.Testcontainers;\n+import org.testcontainers.containers.GenericContainer;\n+import org.testcontainers.containers.Network;\n+import com.github.dockerjava.api.model.ContainerNetwork;\n+import com.github.dockerjava.api.model.ContainerNetwork.Ipam;\n+import com.ibm.websphere.simplicity.log.Log;\n+import com.ibm.ws.security.acme.AcmeCaException;\n+import com.ibm.ws.security.acme.docker.CAContainer;\n+import com.ibm.ws.security.acme.fat.FATSuite;\n+import com.ibm.ws.security.acme.internal.AcmeClient;\n+import com.ibm.ws.security.acme.utils.AcmeFatUtils;\n+import com.ibm.ws.security.acme.utils.HttpChallengeServer;\n+/**\n+ * Testcontainer implementation for the letsencrypt/boulder container.\n+ * Boulder is designed to run with docker-compose. In order to integrate\n+ * Boulder into the acme FAT, the docker-compose file from letsencrypt\n+ * was turned into the following GenericContainers. This class consists\n+ * of three containers and two networks. Because Boulder consists of\n+ * many files, a Docker image was created that is built on top of\n+ * letsencrypt/boulder-tools-go and includes all the files that would\n+ * otherwise need to be copied at runtime. This saves 8+ minutes per\n+ * run.\n+ */\n+public class BoulderContainer extends CAContainer {\n+\n+\t/** The port used to listen for incoming ACME requests. */\n+\tpublic static final int LISTEN_PORT = 4001;\n+\tprivate static final String FILE_MINICA_PEM = \"lib/LibertyFATTestFiles/boulder.minica.pem\";\n+\t\n+\n+    \n+    public final Network bluenet = Network.builder()\n+            .createNetworkCmdModifier(cmd -> {\n+                cmd.withDriver(\"bridge\");\n+                cmd.withIpam(new com.github.dockerjava.api.model.Network.Ipam()\n+                        .withDriver(\"default\")\n+                        .withConfig(new com.github.dockerjava.api.model.Network.Ipam.Config()\n+                                .withSubnet(\"10.77.77.0/24\")));\n+            })\n+            .build();\n+\n+    public final Network rednet =  Network.builder()\n+            .createNetworkCmdModifier(cmd -> {\n+                cmd.withDriver(\"bridge\");\n+                cmd.withIpam(new com.github.dockerjava.api.model.Network.Ipam()\n+                        .withDriver(\"default\")\n+                        .withConfig(new com.github.dockerjava.api.model.Network.Ipam.Config()\n+                                .withSubnet(\"10.88.88.0/24\")));\n+            })\n+            .build();\n+    \n+    public final GenericContainer<?> bhsm = new GenericContainer<>(DOCKER_IMAGE)\n+            .withEnv(\"PKCS11_DAEMON_SOCKET\", \"tcp://0.0.0.0:5657\")\n+            .withExposedPorts(5657)\n+            .withNetwork(bluenet)\n+            .withNetworkAliases(\"boulder-hsm\")\n+            .withCommand(\"/usr/local/bin/pkcs11-daemon /usr/lib/softhsm/libsofthsm2.so\")\n+            .withLogConsumer(o -> System.out.print(\"[HSM] \" + o.getUtf8String()));\n+    \n+    public final GenericContainer<?> bmysql = new GenericContainer<>(\"mariadb:10.3\")\n+            .withNetwork(bluenet)\n+            .withExposedPorts(3306)\n+            .withNetworkAliases(\"boulder-mysql\")\n+            .withEnv(\"MYSQL_ALLOW_EMPTY_PASSWORD\", \"yes\")\n+            .withCommand(\"mysqld --bind-address=0.0.0.0 --slow-query-log --log-output=TABLE --log-queries-not-using-indexes=ON\")\n+            .withLogConsumer(o -> System.out.print(\"[SQL] \" + o.getUtf8String()));\n+    \n+    private static final String DOCKER_IMAGE = \"ryanesch/acme-boulder:1.1\";\n+    \n+    public BoulderContainer() {\n+        super(DOCKER_IMAGE);\n+\t\t/*\n+\t\t * Need to expose the HTTP port that is used to answer the HTTP-01\n+\t\t * challenge.\n+\t\t */\n+\t\tTestcontainers.exposeHostPorts(HTTP_PORT);\n+    \tstart();\n+    }\n+    \n+    @Override\n+    protected void configure() {\n+            this.withEnv(\"FAKE_DNS\", \"172.17.0.68\")\n+            .withEnv(\"PKCS11_PROXY_SOCKET\", \"tcp://boulder-hsm:5657\")\n+            .withEnv(\"BOULDER_CONFIG_DIR\", \"test/config\")\n+            .withEnv(\"GO111MODULE\", \"on\")\n+            .withEnv(\"GOFLAGS\", \"-mod=vendor\")\n+            .withEnv(\"PYTHONIOENCODING\", \"utf-8\")\n+            .withCreateContainerCmdModifier(cmd -> {\n+                cmd.withDns(\"10.77.77.77\");\n+            })\n+            \n+            .withWorkingDirectory(\"/go/src/github.com/letsencrypt/boulder\")\n+            .withCommand(\"/go/src/github.com/letsencrypt/boulder/test/entrypoint.sh\")\n+            .withNetworkAliases(\"boulder\")\n+            .withCreateContainerCmdModifier(cmd -> cmd.withHostName(\"boulder\"))\n+    \t\t.withExposedPorts(MANAGEMENT_PORT, LISTEN_PORT)\n+            .withLogConsumer(o -> System.out.print(\"[BOL] \" + o.getUtf8String()))\n+            .withStartupTimeout(Duration.ofMinutes(3));\n+    }\n+    \t\t\t\t\t\t\t\t\t\n+    \t\t\t\t\t\t\t\n+    \t\t\t\t\t\t\t\t\t\n+\n+    @Override\n+    protected void containerIsCreated(String containerId) {\n+        getDockerClient().connectToNetworkCmd()\n+                .withNetworkId(bluenet.getId())\n+                .withContainerId(containerId)\n+                .withContainerNetwork(new ContainerNetwork()\n+                        .withIpv4Address(\"10.77.77.77\")\n+                        .withNetworkID(bluenet.getId())\n+                        .withIpamConfig(new Ipam().withIpv4Address(\"10.77.77.77\"))\n+                        .withAliases(\"sa1.boulder\", \"ca1.boulder\", \"ra1.boulder\", \"va1.boulder\", \"publisher1.boulder\", \n+                              \"ocsp-updater.boulder\", \"admin-revoker.boulder\", \"nonce1.boulder\"))\n+                .exec();\n+        \n+        getDockerClient().connectToNetworkCmd()\n+                .withNetworkId(rednet.getId())\n+                .withContainerId(containerId)\n+                .withContainerNetwork(new ContainerNetwork()\n+                        .withIpv4Address(\"10.88.88.88\")\n+                        .withNetworkID(rednet.getId())\n+                        .withIpamConfig(new Ipam().withIpv4Address(\"10.88.88.88\"))\n+                        .withAliases(\"sa2.boulder\", \"ca2.boulder\", \"ra2.boulder\", \"va2.boulder\", \n+                                \"publisher2.boulder\", \"nonce2.boulder\"))\n+                .exec();\n+    }\n+    \n+\t/**\n+\t * We need to start up the containers in an orderly fashion so that we can\n+\t * pass the IP address of the DNS server to the Boulder server.\n+\t * @throws IOException \n+\t */\n+    @Override\n+    public void start() {\n+        bmysql.start();\n+        bhsm.start();\n+        super.start();\n+        addARecords();\n+    }\n+    \n+    /**\n+     * Stop all the containers, the challenge server, and the networks.\n+     */\n+    @Override\n+    public void stop() {\n+        bmysql.stop();\n+        bhsm.stop();\n+        super.stop();\n+\t\tbluenet.close();\n+\t\trednet.close();\n+    }\n+   \n+    /**\n+     * @return the InputStream that points to Boulder's PEM file.\n+     */\n+    @Override\n+\tpublic InputStream getAcmeCaIntermediateCertificate() throws Exception {\n+\t\treturn new FileInputStream(new File(FILE_MINICA_PEM));\n+\t}\n+    /**\n+     * Get Boulder's directory URI. Pebble has two possible URIs to\n+     * return, so the method takes a boolean. Boulder will always\n+     * return this URI.\n+     * \n+\t * @return The URI to the ACME CA's directory.\n+     */\n+\t@Override\n+\tpublic String getAcmeDirectoryURI(boolean usePebbleURI) {\n+\t\treturn \"http://\" + this.getContainerIpAddress() + \":\" + this.getMappedPort(LISTEN_PORT) + \"/directory\";\n+\t}\n+\t/**", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3c28406c01e42dd902f376fac4532e84cf17aa5f"}, "originalPosition": 197}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUwODYwODg4OnYy", "diffSide": "RIGHT", "path": "dev/com.ibm.ws.security.acme_fat/fat/src/com/ibm/ws/security/acme/docker/boulder/BoulderContainer.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wNlQxNzo1MDozN1rOGBjMBw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wNlQxNzo1MDozN1rOGBjMBw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDI3ODI3OQ==", "bodyText": "It appears both this and PebbleContianer have this method. Why isn't this defined in the CAContainer class? Either as an abstract method, or if these are the same, then as a concrete method. (That is if this method should be callable publicly, if not make it private.)", "url": "https://github.com/OpenLiberty/open-liberty/pull/11374#discussion_r404278279", "createdAt": "2020-04-06T17:50:37Z", "author": {"login": "jvanhill"}, "path": "dev/com.ibm.ws.security.acme_fat/fat/src/com/ibm/ws/security/acme/docker/boulder/BoulderContainer.java", "diffHunk": "@@ -0,0 +1,214 @@\n+/*******************************************************************************\n+ * Copyright (c) 2019, 2020 IBM Corporation and others.\n+ * All rights reserved. This program and the accompanying materials\n+ * are made available under the terms of the Eclipse Public License v1.0\n+ * which accompanies this distribution, and is available at\n+ * http://www.eclipse.org/legal/epl-v10.html\n+ *\n+ * Contributors:\n+ *     IBM Corporation - initial API and implementation\n+ *******************************************************************************/\n+package com.ibm.ws.security.acme.docker.boulder;\n+\n+import static junit.framework.Assert.fail;\n+\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.security.KeyStore;\n+import java.security.cert.Certificate;\n+import java.security.cert.X509Certificate;\n+import java.time.Duration;\n+import java.util.Map.Entry;\n+\n+import org.testcontainers.Testcontainers;\n+import org.testcontainers.containers.GenericContainer;\n+import org.testcontainers.containers.Network;\n+import com.github.dockerjava.api.model.ContainerNetwork;\n+import com.github.dockerjava.api.model.ContainerNetwork.Ipam;\n+import com.ibm.websphere.simplicity.log.Log;\n+import com.ibm.ws.security.acme.AcmeCaException;\n+import com.ibm.ws.security.acme.docker.CAContainer;\n+import com.ibm.ws.security.acme.fat.FATSuite;\n+import com.ibm.ws.security.acme.internal.AcmeClient;\n+import com.ibm.ws.security.acme.utils.AcmeFatUtils;\n+import com.ibm.ws.security.acme.utils.HttpChallengeServer;\n+/**\n+ * Testcontainer implementation for the letsencrypt/boulder container.\n+ * Boulder is designed to run with docker-compose. In order to integrate\n+ * Boulder into the acme FAT, the docker-compose file from letsencrypt\n+ * was turned into the following GenericContainers. This class consists\n+ * of three containers and two networks. Because Boulder consists of\n+ * many files, a Docker image was created that is built on top of\n+ * letsencrypt/boulder-tools-go and includes all the files that would\n+ * otherwise need to be copied at runtime. This saves 8+ minutes per\n+ * run.\n+ */\n+public class BoulderContainer extends CAContainer {\n+\n+\t/** The port used to listen for incoming ACME requests. */\n+\tpublic static final int LISTEN_PORT = 4001;\n+\tprivate static final String FILE_MINICA_PEM = \"lib/LibertyFATTestFiles/boulder.minica.pem\";\n+\t\n+\n+    \n+    public final Network bluenet = Network.builder()\n+            .createNetworkCmdModifier(cmd -> {\n+                cmd.withDriver(\"bridge\");\n+                cmd.withIpam(new com.github.dockerjava.api.model.Network.Ipam()\n+                        .withDriver(\"default\")\n+                        .withConfig(new com.github.dockerjava.api.model.Network.Ipam.Config()\n+                                .withSubnet(\"10.77.77.0/24\")));\n+            })\n+            .build();\n+\n+    public final Network rednet =  Network.builder()\n+            .createNetworkCmdModifier(cmd -> {\n+                cmd.withDriver(\"bridge\");\n+                cmd.withIpam(new com.github.dockerjava.api.model.Network.Ipam()\n+                        .withDriver(\"default\")\n+                        .withConfig(new com.github.dockerjava.api.model.Network.Ipam.Config()\n+                                .withSubnet(\"10.88.88.0/24\")));\n+            })\n+            .build();\n+    \n+    public final GenericContainer<?> bhsm = new GenericContainer<>(DOCKER_IMAGE)\n+            .withEnv(\"PKCS11_DAEMON_SOCKET\", \"tcp://0.0.0.0:5657\")\n+            .withExposedPorts(5657)\n+            .withNetwork(bluenet)\n+            .withNetworkAliases(\"boulder-hsm\")\n+            .withCommand(\"/usr/local/bin/pkcs11-daemon /usr/lib/softhsm/libsofthsm2.so\")\n+            .withLogConsumer(o -> System.out.print(\"[HSM] \" + o.getUtf8String()));\n+    \n+    public final GenericContainer<?> bmysql = new GenericContainer<>(\"mariadb:10.3\")\n+            .withNetwork(bluenet)\n+            .withExposedPorts(3306)\n+            .withNetworkAliases(\"boulder-mysql\")\n+            .withEnv(\"MYSQL_ALLOW_EMPTY_PASSWORD\", \"yes\")\n+            .withCommand(\"mysqld --bind-address=0.0.0.0 --slow-query-log --log-output=TABLE --log-queries-not-using-indexes=ON\")\n+            .withLogConsumer(o -> System.out.print(\"[SQL] \" + o.getUtf8String()));\n+    \n+    private static final String DOCKER_IMAGE = \"ryanesch/acme-boulder:1.1\";\n+    \n+    public BoulderContainer() {\n+        super(DOCKER_IMAGE);\n+\t\t/*\n+\t\t * Need to expose the HTTP port that is used to answer the HTTP-01\n+\t\t * challenge.\n+\t\t */\n+\t\tTestcontainers.exposeHostPorts(HTTP_PORT);\n+    \tstart();\n+    }\n+    \n+    @Override\n+    protected void configure() {\n+            this.withEnv(\"FAKE_DNS\", \"172.17.0.68\")\n+            .withEnv(\"PKCS11_PROXY_SOCKET\", \"tcp://boulder-hsm:5657\")\n+            .withEnv(\"BOULDER_CONFIG_DIR\", \"test/config\")\n+            .withEnv(\"GO111MODULE\", \"on\")\n+            .withEnv(\"GOFLAGS\", \"-mod=vendor\")\n+            .withEnv(\"PYTHONIOENCODING\", \"utf-8\")\n+            .withCreateContainerCmdModifier(cmd -> {\n+                cmd.withDns(\"10.77.77.77\");\n+            })\n+            \n+            .withWorkingDirectory(\"/go/src/github.com/letsencrypt/boulder\")\n+            .withCommand(\"/go/src/github.com/letsencrypt/boulder/test/entrypoint.sh\")\n+            .withNetworkAliases(\"boulder\")\n+            .withCreateContainerCmdModifier(cmd -> cmd.withHostName(\"boulder\"))\n+    \t\t.withExposedPorts(MANAGEMENT_PORT, LISTEN_PORT)\n+            .withLogConsumer(o -> System.out.print(\"[BOL] \" + o.getUtf8String()))\n+            .withStartupTimeout(Duration.ofMinutes(3));\n+    }\n+    \t\t\t\t\t\t\t\t\t\n+    \t\t\t\t\t\t\t\n+    \t\t\t\t\t\t\t\t\t\n+\n+    @Override\n+    protected void containerIsCreated(String containerId) {\n+        getDockerClient().connectToNetworkCmd()\n+                .withNetworkId(bluenet.getId())\n+                .withContainerId(containerId)\n+                .withContainerNetwork(new ContainerNetwork()\n+                        .withIpv4Address(\"10.77.77.77\")\n+                        .withNetworkID(bluenet.getId())\n+                        .withIpamConfig(new Ipam().withIpv4Address(\"10.77.77.77\"))\n+                        .withAliases(\"sa1.boulder\", \"ca1.boulder\", \"ra1.boulder\", \"va1.boulder\", \"publisher1.boulder\", \n+                              \"ocsp-updater.boulder\", \"admin-revoker.boulder\", \"nonce1.boulder\"))\n+                .exec();\n+        \n+        getDockerClient().connectToNetworkCmd()\n+                .withNetworkId(rednet.getId())\n+                .withContainerId(containerId)\n+                .withContainerNetwork(new ContainerNetwork()\n+                        .withIpv4Address(\"10.88.88.88\")\n+                        .withNetworkID(rednet.getId())\n+                        .withIpamConfig(new Ipam().withIpv4Address(\"10.88.88.88\"))\n+                        .withAliases(\"sa2.boulder\", \"ca2.boulder\", \"ra2.boulder\", \"va2.boulder\", \n+                                \"publisher2.boulder\", \"nonce2.boulder\"))\n+                .exec();\n+    }\n+    \n+\t/**\n+\t * We need to start up the containers in an orderly fashion so that we can\n+\t * pass the IP address of the DNS server to the Boulder server.\n+\t * @throws IOException \n+\t */\n+    @Override\n+    public void start() {\n+        bmysql.start();\n+        bhsm.start();\n+        super.start();\n+        addARecords();\n+    }\n+    \n+    /**\n+     * Stop all the containers, the challenge server, and the networks.\n+     */\n+    @Override\n+    public void stop() {\n+        bmysql.stop();\n+        bhsm.stop();\n+        super.stop();\n+\t\tbluenet.close();\n+\t\trednet.close();\n+    }\n+   \n+    /**\n+     * @return the InputStream that points to Boulder's PEM file.\n+     */\n+    @Override\n+\tpublic InputStream getAcmeCaIntermediateCertificate() throws Exception {\n+\t\treturn new FileInputStream(new File(FILE_MINICA_PEM));\n+\t}\n+    /**\n+     * Get Boulder's directory URI. Pebble has two possible URIs to\n+     * return, so the method takes a boolean. Boulder will always\n+     * return this URI.\n+     * \n+\t * @return The URI to the ACME CA's directory.\n+     */\n+\t@Override\n+\tpublic String getAcmeDirectoryURI(boolean usePebbleURI) {\n+\t\treturn \"http://\" + this.getContainerIpAddress() + \":\" + this.getMappedPort(LISTEN_PORT) + \"/directory\";\n+\t}\n+\t/**\n+\t * Get the IP address for the container as seen from the container network.\n+\t * \n+\t * @return The IP address for the container on the container network.\n+\t */\n+\tpublic String getIntraContainerIP() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3c28406c01e42dd902f376fac4532e84cf17aa5f"}, "originalPosition": 202}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUwODYxNDA0OnYy", "diffSide": "RIGHT", "path": "dev/com.ibm.ws.security.acme_fat/fat/src/com/ibm/ws/security/acme/docker/pebble/PebbleContainer.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wNlQxNzo1MTo1NVrOGBjPPw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wNlQxNzo1MTo1NVrOGBjPPw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDI3OTEwMw==", "bodyText": "whitespace", "url": "https://github.com/OpenLiberty/open-liberty/pull/11374#discussion_r404279103", "createdAt": "2020-04-06T17:51:55Z", "author": {"login": "jvanhill"}, "path": "dev/com.ibm.ws.security.acme_fat/fat/src/com/ibm/ws/security/acme/docker/pebble/PebbleContainer.java", "diffHunk": "@@ -0,0 +1,163 @@\n+/*******************************************************************************\n+ * Copyright (c) 2019, 2020 IBM Corporation and others.\n+ * All rights reserved. This program and the accompanying materials\n+ * are made available under the terms of the Eclipse Public License v1.0\n+ * which accompanies this distribution, and is available at\n+ * http://www.eclipse.org/legal/epl-v10.html\n+ *\n+ * Contributors:\n+ *     IBM Corporation - initial API and implementation\n+ *******************************************************************************/\n+\n+package com.ibm.ws.security.acme.docker.pebble;\n+\n+import static junit.framework.Assert.fail;\n+\n+import java.io.File;\n+import java.util.Map.Entry;\n+import org.testcontainers.Testcontainers;\n+import org.testcontainers.containers.GenericContainer;\n+import org.testcontainers.containers.Network;\n+import org.testcontainers.containers.output.OutputFrame;\n+import org.testcontainers.images.builder.ImageFromDockerfile;\n+\n+import com.github.dockerjava.api.model.ContainerNetwork;\n+import com.ibm.websphere.simplicity.log.Log;\n+import com.ibm.ws.security.acme.docker.CAContainer;\n+\n+/**\n+ * Testcontainer implementation for the letsencrypt/pebble container.\n+ */\n+public class PebbleContainer extends CAContainer {\n+\t\n+\t/** The port used to listen for incoming ACME requests. */\n+\tpublic static final int LISTEN_PORT = 14000;\n+\n+\t/** The REST management API port. */\n+\tpublic static final int MANAGEMENT_PORT = 15000;\n+\t/**\n+\t * The mock DNS server port.\n+\t */\n+\tpublic static final int DNS_PORT = 8053;\n+\n+\t/**\n+\t * The REST management port.\n+\t */\n+\tpublic static final int CHALL_MANAGEMENT_PORT = 8055;\n+\t\n+\t\n+\tprivate Network network = Network.newNetwork();\n+\n+\t\n+    public final GenericContainer<?> challtestsrv = new GenericContainer<>(\"letsencrypt/pebble-challtestsrv\")\n+     .withCommand(\"pebble-challtestsrv\")\n+\t .withExposedPorts(DNS_PORT, CHALL_MANAGEMENT_PORT)\n+     .withNetwork(network)\n+\t .withLogConsumer(o -> System.out.print(\"[CHL] \" + o.getUtf8String()));\n+\t\n+\t/**\n+\t * Log the output from this testcontainer.\n+\t * \n+\t * @param frame\n+\t *            The frame containing log data.\n+\t */\n+\tpublic static void log(OutputFrame frame) {\n+\t\tString msg = frame.getUtf8String();\n+\t\tif (msg.endsWith(\"\\n\"))\n+\t\t\tmsg = msg.substring(0, msg.length() - 1);\n+\t\tLog.info(PebbleContainer.class, \"pebble\", msg);\n+\t}\n+\n+\t/**\n+\t * Instantiate a new {@link PebbleContainer} instance.\n+\t * \n+\t * @param dnsServer\n+\t *            Address of the DNS server to use to make DNS lookups for\n+\t *            domains.\n+\t */\n+\tpublic PebbleContainer() {\n+\t\tsuper(new ImageFromDockerfile()\n+\t\t\t\t.withDockerfileFromBuilder(builder -> builder.from(\"letsencrypt/pebble\")\n+\t\t\t\t\t\t.copy(\"pebble-config.json\", \"/test/config/pebble-config.json\").build())\n+\t\t\t\t.withFileFromFile(\"pebble-config.json\", new File(\"lib/LibertyFATTestFiles/pebble-config.json\")), MANAGEMENT_PORT);\n+\t\t\n+\t\tchalltestsrv.start();\n+\t\t\n+\t\tString dnsServer = getIntraContainerIP() + \":\" + DNS_PORT;\n+\n+\t\tthis.withCommand(\"pebble\", \"-dnsserver\", dnsServer, \"-config\", \"/test/config/pebble-config.json\", \"-strict\",\n+\t\t\t\t\"false\");\n+\t\tthis.withExposedPorts(MANAGEMENT_PORT, LISTEN_PORT);\n+\t\tthis.withNetwork(network);\n+\t\tthis.withLogConsumer(PebbleContainer::log);\n+\n+\t\tTestcontainers.exposeHostPorts(HTTP_PORT);\n+\t\t\n+\t\tstart();\n+\t\t\n+\t\tLog.info(PebbleContainer.class, \"PebbleContainer\", \"ContainerIpAddress: \" + getContainerIpAddress());\n+\t\tLog.info(PebbleContainer.class, \"PebbleContainer\", \"DockerImageName:    \" + getDockerImageName());\n+\t\tLog.info(PebbleContainer.class, \"PebbleContainer\", \"ContainerInfo:      \" + getContainerInfo());\n+\t\t\n+        addARecords();\n+\t}\n+\t@Override", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3c28406c01e42dd902f376fac4532e84cf17aa5f"}, "originalPosition": 104}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUwODYxNTczOnYy", "diffSide": "RIGHT", "path": "dev/com.ibm.ws.security.acme_fat/fat/src/com/ibm/ws/security/acme/docker/pebble/PebbleContainer.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wNlQxNzo1MjoyM1rOGBjQVQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wNlQxNzo1MjoyM1rOGBjQVQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDI3OTM4MQ==", "bodyText": "It appears both this and BoulderContainer have this method. Why isn't this defined in the CAContainer class? Either as an abstract method, or if these are the same, then as a concrete method. (That is if this method should be callable publicly, if not make it private.)", "url": "https://github.com/OpenLiberty/open-liberty/pull/11374#discussion_r404279381", "createdAt": "2020-04-06T17:52:23Z", "author": {"login": "jvanhill"}, "path": "dev/com.ibm.ws.security.acme_fat/fat/src/com/ibm/ws/security/acme/docker/pebble/PebbleContainer.java", "diffHunk": "@@ -0,0 +1,163 @@\n+/*******************************************************************************\n+ * Copyright (c) 2019, 2020 IBM Corporation and others.\n+ * All rights reserved. This program and the accompanying materials\n+ * are made available under the terms of the Eclipse Public License v1.0\n+ * which accompanies this distribution, and is available at\n+ * http://www.eclipse.org/legal/epl-v10.html\n+ *\n+ * Contributors:\n+ *     IBM Corporation - initial API and implementation\n+ *******************************************************************************/\n+\n+package com.ibm.ws.security.acme.docker.pebble;\n+\n+import static junit.framework.Assert.fail;\n+\n+import java.io.File;\n+import java.util.Map.Entry;\n+import org.testcontainers.Testcontainers;\n+import org.testcontainers.containers.GenericContainer;\n+import org.testcontainers.containers.Network;\n+import org.testcontainers.containers.output.OutputFrame;\n+import org.testcontainers.images.builder.ImageFromDockerfile;\n+\n+import com.github.dockerjava.api.model.ContainerNetwork;\n+import com.ibm.websphere.simplicity.log.Log;\n+import com.ibm.ws.security.acme.docker.CAContainer;\n+\n+/**\n+ * Testcontainer implementation for the letsencrypt/pebble container.\n+ */\n+public class PebbleContainer extends CAContainer {\n+\t\n+\t/** The port used to listen for incoming ACME requests. */\n+\tpublic static final int LISTEN_PORT = 14000;\n+\n+\t/** The REST management API port. */\n+\tpublic static final int MANAGEMENT_PORT = 15000;\n+\t/**\n+\t * The mock DNS server port.\n+\t */\n+\tpublic static final int DNS_PORT = 8053;\n+\n+\t/**\n+\t * The REST management port.\n+\t */\n+\tpublic static final int CHALL_MANAGEMENT_PORT = 8055;\n+\t\n+\t\n+\tprivate Network network = Network.newNetwork();\n+\n+\t\n+    public final GenericContainer<?> challtestsrv = new GenericContainer<>(\"letsencrypt/pebble-challtestsrv\")\n+     .withCommand(\"pebble-challtestsrv\")\n+\t .withExposedPorts(DNS_PORT, CHALL_MANAGEMENT_PORT)\n+     .withNetwork(network)\n+\t .withLogConsumer(o -> System.out.print(\"[CHL] \" + o.getUtf8String()));\n+\t\n+\t/**\n+\t * Log the output from this testcontainer.\n+\t * \n+\t * @param frame\n+\t *            The frame containing log data.\n+\t */\n+\tpublic static void log(OutputFrame frame) {\n+\t\tString msg = frame.getUtf8String();\n+\t\tif (msg.endsWith(\"\\n\"))\n+\t\t\tmsg = msg.substring(0, msg.length() - 1);\n+\t\tLog.info(PebbleContainer.class, \"pebble\", msg);\n+\t}\n+\n+\t/**\n+\t * Instantiate a new {@link PebbleContainer} instance.\n+\t * \n+\t * @param dnsServer\n+\t *            Address of the DNS server to use to make DNS lookups for\n+\t *            domains.\n+\t */\n+\tpublic PebbleContainer() {\n+\t\tsuper(new ImageFromDockerfile()\n+\t\t\t\t.withDockerfileFromBuilder(builder -> builder.from(\"letsencrypt/pebble\")\n+\t\t\t\t\t\t.copy(\"pebble-config.json\", \"/test/config/pebble-config.json\").build())\n+\t\t\t\t.withFileFromFile(\"pebble-config.json\", new File(\"lib/LibertyFATTestFiles/pebble-config.json\")), MANAGEMENT_PORT);\n+\t\t\n+\t\tchalltestsrv.start();\n+\t\t\n+\t\tString dnsServer = getIntraContainerIP() + \":\" + DNS_PORT;\n+\n+\t\tthis.withCommand(\"pebble\", \"-dnsserver\", dnsServer, \"-config\", \"/test/config/pebble-config.json\", \"-strict\",\n+\t\t\t\t\"false\");\n+\t\tthis.withExposedPorts(MANAGEMENT_PORT, LISTEN_PORT);\n+\t\tthis.withNetwork(network);\n+\t\tthis.withLogConsumer(PebbleContainer::log);\n+\n+\t\tTestcontainers.exposeHostPorts(HTTP_PORT);\n+\t\t\n+\t\tstart();\n+\t\t\n+\t\tLog.info(PebbleContainer.class, \"PebbleContainer\", \"ContainerIpAddress: \" + getContainerIpAddress());\n+\t\tLog.info(PebbleContainer.class, \"PebbleContainer\", \"DockerImageName:    \" + getDockerImageName());\n+\t\tLog.info(PebbleContainer.class, \"PebbleContainer\", \"ContainerInfo:      \" + getContainerInfo());\n+\t\t\n+        addARecords();\n+\t}\n+\t@Override\n+\tpublic void stop() {\n+\t\tchalltestsrv.stop();\n+\t\tsuper.stop();\n+\t\tnetwork.close();\n+\t}\n+\n+\t/**\n+\t * Get the URI to the ACME CA's directory.\n+\t * \n+\t * @param usePebbleURI\n+\t *            Use the \"acme://pebble\" style URI instead of the generic\n+\t *            \"https:\" URI.\n+\t * @return The URI to the ACME CA's directory.\n+\t */\n+\tpublic String getAcmeDirectoryURI(boolean usePebbleURI) {\n+\t\tif (usePebbleURI) {\n+\t\t\t/*\n+\t\t\t * The \"acme://pebble/<host>:<port>\" will tell acme4j to load the\n+\t\t\t * PebbleAcmeProvider and PebbleHttpConnector, which will trust\n+\t\t\t * Pebble's static self-signed certificate.\n+\t\t\t */\n+\t\t\treturn \"acme://pebble/\" + this.getContainerIpAddress() + \":\" + this.getMappedPort(LISTEN_PORT);\n+\t\t} else {\n+\t\t\t/*\n+\t\t\t * This will cause acme4j to use the GenericAcmeProvider.\n+\t\t\t */\n+\t\t\treturn \"https://\" + this.getContainerIpAddress() + \":\" + this.getMappedPort(LISTEN_PORT) + \"/dir\";\n+\t\t}\n+\t}\n+\t\n+\t/**\n+\t * Get the IP address for the challtestsrv container as seen from the container network.\n+\t * \n+\t * @return The IP address for the challenge test server on the container.\n+\t */\n+\tpublic String getIntraContainerIP() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3c28406c01e42dd902f376fac4532e84cf17aa5f"}, "originalPosition": 140}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUwODYxODgxOnYy", "diffSide": "RIGHT", "path": "dev/com.ibm.ws.security.acme_fat/fat/src/com/ibm/ws/security/acme/docker/pebble/PebbleContainer.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wNlQxNzo1MzoxM1rOGBjSSw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wNlQxNzo1MzoxM1rOGBjSSw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDI3OTg4Mw==", "bodyText": "@OverRide?\nIf so then don't redefine the javadoc.", "url": "https://github.com/OpenLiberty/open-liberty/pull/11374#discussion_r404279883", "createdAt": "2020-04-06T17:53:13Z", "author": {"login": "jvanhill"}, "path": "dev/com.ibm.ws.security.acme_fat/fat/src/com/ibm/ws/security/acme/docker/pebble/PebbleContainer.java", "diffHunk": "@@ -0,0 +1,163 @@\n+/*******************************************************************************\n+ * Copyright (c) 2019, 2020 IBM Corporation and others.\n+ * All rights reserved. This program and the accompanying materials\n+ * are made available under the terms of the Eclipse Public License v1.0\n+ * which accompanies this distribution, and is available at\n+ * http://www.eclipse.org/legal/epl-v10.html\n+ *\n+ * Contributors:\n+ *     IBM Corporation - initial API and implementation\n+ *******************************************************************************/\n+\n+package com.ibm.ws.security.acme.docker.pebble;\n+\n+import static junit.framework.Assert.fail;\n+\n+import java.io.File;\n+import java.util.Map.Entry;\n+import org.testcontainers.Testcontainers;\n+import org.testcontainers.containers.GenericContainer;\n+import org.testcontainers.containers.Network;\n+import org.testcontainers.containers.output.OutputFrame;\n+import org.testcontainers.images.builder.ImageFromDockerfile;\n+\n+import com.github.dockerjava.api.model.ContainerNetwork;\n+import com.ibm.websphere.simplicity.log.Log;\n+import com.ibm.ws.security.acme.docker.CAContainer;\n+\n+/**\n+ * Testcontainer implementation for the letsencrypt/pebble container.\n+ */\n+public class PebbleContainer extends CAContainer {\n+\t\n+\t/** The port used to listen for incoming ACME requests. */\n+\tpublic static final int LISTEN_PORT = 14000;\n+\n+\t/** The REST management API port. */\n+\tpublic static final int MANAGEMENT_PORT = 15000;\n+\t/**\n+\t * The mock DNS server port.\n+\t */\n+\tpublic static final int DNS_PORT = 8053;\n+\n+\t/**\n+\t * The REST management port.\n+\t */\n+\tpublic static final int CHALL_MANAGEMENT_PORT = 8055;\n+\t\n+\t\n+\tprivate Network network = Network.newNetwork();\n+\n+\t\n+    public final GenericContainer<?> challtestsrv = new GenericContainer<>(\"letsencrypt/pebble-challtestsrv\")\n+     .withCommand(\"pebble-challtestsrv\")\n+\t .withExposedPorts(DNS_PORT, CHALL_MANAGEMENT_PORT)\n+     .withNetwork(network)\n+\t .withLogConsumer(o -> System.out.print(\"[CHL] \" + o.getUtf8String()));\n+\t\n+\t/**\n+\t * Log the output from this testcontainer.\n+\t * \n+\t * @param frame\n+\t *            The frame containing log data.\n+\t */\n+\tpublic static void log(OutputFrame frame) {\n+\t\tString msg = frame.getUtf8String();\n+\t\tif (msg.endsWith(\"\\n\"))\n+\t\t\tmsg = msg.substring(0, msg.length() - 1);\n+\t\tLog.info(PebbleContainer.class, \"pebble\", msg);\n+\t}\n+\n+\t/**\n+\t * Instantiate a new {@link PebbleContainer} instance.\n+\t * \n+\t * @param dnsServer\n+\t *            Address of the DNS server to use to make DNS lookups for\n+\t *            domains.\n+\t */\n+\tpublic PebbleContainer() {\n+\t\tsuper(new ImageFromDockerfile()\n+\t\t\t\t.withDockerfileFromBuilder(builder -> builder.from(\"letsencrypt/pebble\")\n+\t\t\t\t\t\t.copy(\"pebble-config.json\", \"/test/config/pebble-config.json\").build())\n+\t\t\t\t.withFileFromFile(\"pebble-config.json\", new File(\"lib/LibertyFATTestFiles/pebble-config.json\")), MANAGEMENT_PORT);\n+\t\t\n+\t\tchalltestsrv.start();\n+\t\t\n+\t\tString dnsServer = getIntraContainerIP() + \":\" + DNS_PORT;\n+\n+\t\tthis.withCommand(\"pebble\", \"-dnsserver\", dnsServer, \"-config\", \"/test/config/pebble-config.json\", \"-strict\",\n+\t\t\t\t\"false\");\n+\t\tthis.withExposedPorts(MANAGEMENT_PORT, LISTEN_PORT);\n+\t\tthis.withNetwork(network);\n+\t\tthis.withLogConsumer(PebbleContainer::log);\n+\n+\t\tTestcontainers.exposeHostPorts(HTTP_PORT);\n+\t\t\n+\t\tstart();\n+\t\t\n+\t\tLog.info(PebbleContainer.class, \"PebbleContainer\", \"ContainerIpAddress: \" + getContainerIpAddress());\n+\t\tLog.info(PebbleContainer.class, \"PebbleContainer\", \"DockerImageName:    \" + getDockerImageName());\n+\t\tLog.info(PebbleContainer.class, \"PebbleContainer\", \"ContainerInfo:      \" + getContainerInfo());\n+\t\t\n+        addARecords();\n+\t}\n+\t@Override\n+\tpublic void stop() {\n+\t\tchalltestsrv.stop();\n+\t\tsuper.stop();\n+\t\tnetwork.close();\n+\t}\n+\n+\t/**\n+\t * Get the URI to the ACME CA's directory.\n+\t * \n+\t * @param usePebbleURI\n+\t *            Use the \"acme://pebble\" style URI instead of the generic\n+\t *            \"https:\" URI.\n+\t * @return The URI to the ACME CA's directory.\n+\t */\n+\tpublic String getAcmeDirectoryURI(boolean usePebbleURI) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3c28406c01e42dd902f376fac4532e84cf17aa5f"}, "originalPosition": 119}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUwODYyMzY3OnYy", "diffSide": "RIGHT", "path": "dev/com.ibm.ws.security.acme_fat/fat/src/com/ibm/ws/security/acme/docker/pebble/PebbleContainer.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wNlQxNzo1NDoyNVrOGBjVPA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wNlQxNzo1NDoyNVrOGBjVPA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDI4MDYzNg==", "bodyText": "Don't override Javadoc.", "url": "https://github.com/OpenLiberty/open-liberty/pull/11374#discussion_r404280636", "createdAt": "2020-04-06T17:54:25Z", "author": {"login": "jvanhill"}, "path": "dev/com.ibm.ws.security.acme_fat/fat/src/com/ibm/ws/security/acme/docker/pebble/PebbleContainer.java", "diffHunk": "@@ -0,0 +1,163 @@\n+/*******************************************************************************\n+ * Copyright (c) 2019, 2020 IBM Corporation and others.\n+ * All rights reserved. This program and the accompanying materials\n+ * are made available under the terms of the Eclipse Public License v1.0\n+ * which accompanies this distribution, and is available at\n+ * http://www.eclipse.org/legal/epl-v10.html\n+ *\n+ * Contributors:\n+ *     IBM Corporation - initial API and implementation\n+ *******************************************************************************/\n+\n+package com.ibm.ws.security.acme.docker.pebble;\n+\n+import static junit.framework.Assert.fail;\n+\n+import java.io.File;\n+import java.util.Map.Entry;\n+import org.testcontainers.Testcontainers;\n+import org.testcontainers.containers.GenericContainer;\n+import org.testcontainers.containers.Network;\n+import org.testcontainers.containers.output.OutputFrame;\n+import org.testcontainers.images.builder.ImageFromDockerfile;\n+\n+import com.github.dockerjava.api.model.ContainerNetwork;\n+import com.ibm.websphere.simplicity.log.Log;\n+import com.ibm.ws.security.acme.docker.CAContainer;\n+\n+/**\n+ * Testcontainer implementation for the letsencrypt/pebble container.\n+ */\n+public class PebbleContainer extends CAContainer {\n+\t\n+\t/** The port used to listen for incoming ACME requests. */\n+\tpublic static final int LISTEN_PORT = 14000;\n+\n+\t/** The REST management API port. */\n+\tpublic static final int MANAGEMENT_PORT = 15000;\n+\t/**\n+\t * The mock DNS server port.\n+\t */\n+\tpublic static final int DNS_PORT = 8053;\n+\n+\t/**\n+\t * The REST management port.\n+\t */\n+\tpublic static final int CHALL_MANAGEMENT_PORT = 8055;\n+\t\n+\t\n+\tprivate Network network = Network.newNetwork();\n+\n+\t\n+    public final GenericContainer<?> challtestsrv = new GenericContainer<>(\"letsencrypt/pebble-challtestsrv\")\n+     .withCommand(\"pebble-challtestsrv\")\n+\t .withExposedPorts(DNS_PORT, CHALL_MANAGEMENT_PORT)\n+     .withNetwork(network)\n+\t .withLogConsumer(o -> System.out.print(\"[CHL] \" + o.getUtf8String()));\n+\t\n+\t/**\n+\t * Log the output from this testcontainer.\n+\t * \n+\t * @param frame\n+\t *            The frame containing log data.\n+\t */\n+\tpublic static void log(OutputFrame frame) {\n+\t\tString msg = frame.getUtf8String();\n+\t\tif (msg.endsWith(\"\\n\"))\n+\t\t\tmsg = msg.substring(0, msg.length() - 1);\n+\t\tLog.info(PebbleContainer.class, \"pebble\", msg);\n+\t}\n+\n+\t/**\n+\t * Instantiate a new {@link PebbleContainer} instance.\n+\t * \n+\t * @param dnsServer\n+\t *            Address of the DNS server to use to make DNS lookups for\n+\t *            domains.\n+\t */\n+\tpublic PebbleContainer() {\n+\t\tsuper(new ImageFromDockerfile()\n+\t\t\t\t.withDockerfileFromBuilder(builder -> builder.from(\"letsencrypt/pebble\")\n+\t\t\t\t\t\t.copy(\"pebble-config.json\", \"/test/config/pebble-config.json\").build())\n+\t\t\t\t.withFileFromFile(\"pebble-config.json\", new File(\"lib/LibertyFATTestFiles/pebble-config.json\")), MANAGEMENT_PORT);\n+\t\t\n+\t\tchalltestsrv.start();\n+\t\t\n+\t\tString dnsServer = getIntraContainerIP() + \":\" + DNS_PORT;\n+\n+\t\tthis.withCommand(\"pebble\", \"-dnsserver\", dnsServer, \"-config\", \"/test/config/pebble-config.json\", \"-strict\",\n+\t\t\t\t\"false\");\n+\t\tthis.withExposedPorts(MANAGEMENT_PORT, LISTEN_PORT);\n+\t\tthis.withNetwork(network);\n+\t\tthis.withLogConsumer(PebbleContainer::log);\n+\n+\t\tTestcontainers.exposeHostPorts(HTTP_PORT);\n+\t\t\n+\t\tstart();\n+\t\t\n+\t\tLog.info(PebbleContainer.class, \"PebbleContainer\", \"ContainerIpAddress: \" + getContainerIpAddress());\n+\t\tLog.info(PebbleContainer.class, \"PebbleContainer\", \"DockerImageName:    \" + getDockerImageName());\n+\t\tLog.info(PebbleContainer.class, \"PebbleContainer\", \"ContainerInfo:      \" + getContainerInfo());\n+\t\t\n+        addARecords();\n+\t}\n+\t@Override\n+\tpublic void stop() {\n+\t\tchalltestsrv.stop();\n+\t\tsuper.stop();\n+\t\tnetwork.close();\n+\t}\n+\n+\t/**\n+\t * Get the URI to the ACME CA's directory.\n+\t * \n+\t * @param usePebbleURI\n+\t *            Use the \"acme://pebble\" style URI instead of the generic\n+\t *            \"https:\" URI.\n+\t * @return The URI to the ACME CA's directory.\n+\t */\n+\tpublic String getAcmeDirectoryURI(boolean usePebbleURI) {\n+\t\tif (usePebbleURI) {\n+\t\t\t/*\n+\t\t\t * The \"acme://pebble/<host>:<port>\" will tell acme4j to load the\n+\t\t\t * PebbleAcmeProvider and PebbleHttpConnector, which will trust\n+\t\t\t * Pebble's static self-signed certificate.\n+\t\t\t */\n+\t\t\treturn \"acme://pebble/\" + this.getContainerIpAddress() + \":\" + this.getMappedPort(LISTEN_PORT);\n+\t\t} else {\n+\t\t\t/*\n+\t\t\t * This will cause acme4j to use the GenericAcmeProvider.\n+\t\t\t */\n+\t\t\treturn \"https://\" + this.getContainerIpAddress() + \":\" + this.getMappedPort(LISTEN_PORT) + \"/dir\";\n+\t\t}\n+\t}\n+\t\n+\t/**\n+\t * Get the IP address for the challtestsrv container as seen from the container network.\n+\t * \n+\t * @return The IP address for the challenge test server on the container.\n+\t */\n+\tpublic String getIntraContainerIP() {\n+\t\tString intraContainerIpAddress = null;\n+\t\tfor (Entry<String, ContainerNetwork> entry : challtestsrv.getContainerInfo().getNetworkSettings().getNetworks().entrySet()) {\n+\t\t\tintraContainerIpAddress = entry.getValue().getIpAddress();\n+\t\t\tbreak;\n+\t\t}\n+\t\tif (intraContainerIpAddress == null) {\n+\t\t\tfail(\"Didn't find IP address for challtestsrv server.\");\n+\t\t}\n+\n+\t\treturn intraContainerIpAddress;\n+\t}\n+    \n+\t/**", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3c28406c01e42dd902f376fac4532e84cf17aa5f"}, "originalPosition": 153}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUwODYzMDMxOnYy", "diffSide": "RIGHT", "path": "dev/com.ibm.ws.security.acme_fat/fat/src/com/ibm/ws/security/acme/docker/CAContainer.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wNlQxNzo1NjoxNFrOGBjZcg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wNlQxNzo1NjoxNFrOGBjZcg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDI4MTcxNA==", "bodyText": "This logic is specific for Boulder. Pebble overrides it. Seems this method should be abstract and this version moved to BoulderContainer.", "url": "https://github.com/OpenLiberty/open-liberty/pull/11374#discussion_r404281714", "createdAt": "2020-04-06T17:56:14Z", "author": {"login": "jvanhill"}, "path": "dev/com.ibm.ws.security.acme_fat/fat/src/com/ibm/ws/security/acme/docker/CAContainer.java", "diffHunk": "@@ -0,0 +1,442 @@\n+/*******************************************************************************\n+ * Copyright (c) 2019, 2020 IBM Corporation and others.\n+ * All rights reserved. This program and the accompanying materials\n+ * are made available under the terms of the Eclipse Public License v1.0\n+ * which accompanies this distribution, and is available at\n+ * http://www.eclipse.org/legal/epl-v10.html\n+ *\n+ * Contributors:\n+ *     IBM Corporation - initial API and implementation\n+ *******************************************************************************/\n+package com.ibm.ws.security.acme.docker;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.security.cert.X509Certificate;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import org.apache.http.StatusLine;\n+import org.apache.http.client.methods.CloseableHttpResponse;\n+import org.apache.http.client.methods.HttpGet;\n+import org.apache.http.client.methods.HttpPost;\n+import org.apache.http.entity.ContentType;\n+import org.apache.http.entity.StringEntity;\n+import org.apache.http.impl.client.CloseableHttpClient;\n+import org.apache.http.impl.client.HttpClients;\n+import org.apache.http.util.EntityUtils;\n+import org.testcontainers.containers.GenericContainer;\n+import org.testcontainers.images.builder.ImageFromDockerfile;\n+\n+import com.ibm.websphere.simplicity.log.Log;\n+import com.ibm.ws.security.acme.utils.AcmeFatUtils;\n+\n+/**\n+ * Testcontainer implementation for Pebble and Boulder Certificate Authorities.\n+ * \n+ */\n+public class CAContainer extends GenericContainer<CAContainer> {\n+\n+\tprivate static final String TEST_DOMAIN_1 = \"domain1.com\";\n+\tprivate static final String TEST_DOMAIN_2 = \"domain2.com\";\n+\tprivate static final String TEST_DOMAIN_3 = \"domain3.com\";\n+\tprivate static final String TEST_DOMAIN_4 = \"domain4.com\";\n+\t\n+\t/** Challenge server port. */\n+\tpublic static final int HTTP_PORT = 5002;\n+\t/** The REST management API port. */\n+\tpublic int MANAGEMENT_PORT = 8055;\n+\t\n+\t/**\n+\t * This constructor is used by BoulderContainer\n+\t */\n+\tpublic CAContainer(String image) {\n+\t\tsuper(image);\n+\t}\n+\n+\t/**\n+\t * This constructor is used by PebbleContainer. The\n+\t * management port is different for Pebble, so this\n+\t * is passed in.\n+\t */\n+\tpublic CAContainer(ImageFromDockerfile image, int managementPort) {\n+\t\tsuper(image);\n+\t\tMANAGEMENT_PORT = managementPort;\n+\t}\n+\n+\t/**\n+\t * Get CA's intermediate certificate.\n+\t * \n+\t * @param fileName\n+\t *            The name of the file to save the certificate to.\n+\t * @return CA's intermediate certificate in the form of a PEM file.\n+\t * @throws Exception\n+\t *             If we failed to receive the certificate.\n+\t */\n+\tpublic InputStream getAcmeCaIntermediateCertificate() throws Exception {\n+\t\tfinal String METHOD_NAME = \"getAcmeCaIntermediateCertificate()\";\n+\t\tString url = \"https://\" + this.getContainerIpAddress() + \":\" + this.getMappedPort(MANAGEMENT_PORT)\n+\t\t\t\t+ \"/intermediates/0\";\n+\n+\t\ttry (CloseableHttpClient httpclient = AcmeFatUtils.getInsecureHttpsClient()) {\n+\t\t\t/*\n+\t\t\t * Create a GET request to the ACME CA server.\n+\t\t\t */\n+\t\t\tHttpGet httpGet = new HttpGet(url);\n+\n+\t\t\t/*\n+\t\t\t * Send the GET request and process the response.\n+\t\t\t */\n+\t\t\ttry (final CloseableHttpResponse response = httpclient.execute(httpGet)) {\n+\t\t\t\tAcmeFatUtils.logHttpResponse(CAContainer.class, METHOD_NAME, httpGet, response);\n+\n+\t\t\t\tStatusLine statusLine = response.getStatusLine();\n+\n+\t\t\t\tif (statusLine.getStatusCode() != 200) {\n+\t\t\t\t\tthrow new IOException(\n+\t\t\t\t\t\t\tMETHOD_NAME + \": Expected response 200, but received response: \" + statusLine);\n+\t\t\t\t}\n+\n+\t\t\t\tbyte[] result = EntityUtils.toByteArray(response.getEntity());\n+\n+\t\t\t\tLog.info(CAContainer.class, METHOD_NAME, new String(result));\n+\t\t\t\treturn  new ByteArrayInputStream(result);\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Get the root certificate.\n+\t * \n+\t * @param fileName\n+\t *            The name of the file to save the certificate to.\n+\t * @return Certificate Authority's root certificate in the form of a PEM file.\n+\t * @throws Exception\n+\t *             If we failed to receive the certificate.\n+\t */\n+\tpublic byte[] getAcmeCaRootCertificate() throws Exception {\n+\t\tfinal String METHOD_NAME = \"getAcmeCaRootCertificate()\";\n+\t\tString url = \"https://\" + this.getContainerIpAddress() + \":\" + this.getMappedPort(MANAGEMENT_PORT) + \"/roots/0\";\n+\n+\t\ttry (CloseableHttpClient httpclient = AcmeFatUtils.getInsecureHttpsClient()) {\n+\t\t\t/*\n+\t\t\t * Create a GET request to the ACME CA server.\n+\t\t\t */\n+\t\t\tHttpGet httpGet = new HttpGet(url);\n+\n+\t\t\t/*\n+\t\t\t * Send the GET request and process the response.\n+\t\t\t */\n+\t\t\ttry (final CloseableHttpResponse response = httpclient.execute(httpGet)) {\n+\t\t\t\tAcmeFatUtils.logHttpResponse(CAContainer.class, METHOD_NAME, httpGet, response);\n+\n+\t\t\t\tStatusLine statusLine = response.getStatusLine();\n+\n+\t\t\t\tif (statusLine.getStatusCode() != 200) {\n+\t\t\t\t\tthrow new IOException(\n+\t\t\t\t\t\t\tMETHOD_NAME + \": Expected response 200, but received response: \" + statusLine);\n+\t\t\t\t}\n+\n+\t\t\t\tbyte[] result = EntityUtils.toByteArray(response.getEntity());\n+\n+\t\t\t\tLog.info(CAContainer.class, METHOD_NAME, new String(result));\n+\t\t\t\treturn result;\n+\t\t\t}\n+\t\t}\n+\t}\n+\t\n+\t/**\n+\t * Get the status of the certificate from the ACME CA server.\n+\t * \n+\t * @param certificate\n+\t *            The certificate to check.\n+\t * @return The status of the certificate.\n+\t * @throws Exception\n+\t */\n+\tpublic String getAcmeCertificateStatus(X509Certificate certificate) throws Exception {\n+\t\tfinal String METHOD_NAME = \"getAcmeCertificateStatus()\";\n+\t\tString url = \"https://\" + this.getContainerIpAddress() + \":\" + this.getMappedPort(MANAGEMENT_PORT)\n+\t\t\t\t+ \"/cert-status-by-serial/\" + certificate.getSerialNumber().toString(16);\n+\n+\t\ttry (CloseableHttpClient httpclient = AcmeFatUtils.getInsecureHttpsClient()) {\n+\t\t\t/*\n+\t\t\t * Create a GET request to the ACME CA server.\n+\t\t\t */\n+\t\t\tHttpGet httpGet = new HttpGet(url);\n+\n+\t\t\t/*\n+\t\t\t * Send the GET request and process the response.\n+\t\t\t */\n+\t\t\ttry (final CloseableHttpResponse response = httpclient.execute(httpGet)) {\n+\t\t\t\tAcmeFatUtils.logHttpResponse(CAContainer.class, METHOD_NAME, httpGet, response);\n+\n+\t\t\t\tStatusLine statusLine = response.getStatusLine();\n+\n+\t\t\t\tif (statusLine.getStatusCode() != 200) {\n+\t\t\t\t\tthrow new IOException(\n+\t\t\t\t\t\t\tMETHOD_NAME + \": Expected response 200, but received response: \" + statusLine);\n+\t\t\t\t}\n+\n+\t\t\t\tString result = EntityUtils.toString(response.getEntity());\n+\n+\t\t\t\t/*\n+\t\t\t\t * The result is in JSON, lets just parse out the status.\n+\t\t\t\t */\n+\t\t\t\tPattern p = Pattern.compile(\".*\\\"Status\\\": \\\"(\\\\w+)\\\",.*\", Pattern.DOTALL);\n+\t\t\t\tMatcher m = p.matcher(result);\n+\t\t\t\tif (m.find()) {\n+\t\t\t\t\tresult = m.group(1);\n+\t\t\t\t} else {\n+\t\t\t\t\tthrow new Exception(\n+\t\t\t\t\t\t\t\"Certificate status response was not in expected JSON format. Response: \" + result);\n+\t\t\t\t}\n+\n+\t\t\t\tLog.info(CAContainer.class, METHOD_NAME, new String(result));\n+\t\t\t\treturn result;\n+\t\t\t}\n+\t\t}\n+\t}\n+\t\n+\t/**\n+\t * Retrieves the client host's IP address that is reachable from the\n+\t * container.\n+\t * \n+\t * @return The client host's IP address that is reachable from the\n+\t *         container.\n+\t * @throws IllegalStateException\n+\t *             If the address was not found.\n+\t */\n+\tpublic String getClientHost() throws IllegalStateException {\n+\t\tfor (String extraHost : this.getExtraHosts()) {\n+\t\t\tif (extraHost.startsWith(\"host.testcontainers.internal:\")) {\n+\t\t\t\treturn extraHost.replace(\"host.testcontainers.internal:\", \"\");\n+\t\t\t}\n+\t\t}\n+\n+\t\tthrow new IllegalStateException(\n+\t\t\t\t\"Unable to resolve local host from docker container. Could not find 'host.testcontainers.internal' property.\");\n+\t}\n+\t\n+\t/**\n+\t * Add A and AAAA records.\n+\t */\n+    public void addARecords() {\n+    \ttry {\n+\t\t\tfor (String domain : new String[] { TEST_DOMAIN_1, TEST_DOMAIN_2, TEST_DOMAIN_3, TEST_DOMAIN_4 }) {\n+\t\t\t\t/*\n+\t\t\t\t * Disable the IPv6 responses for this domain. The Boulder CA server\n+\t\t\t\t * responds on AAAA (IPv6) responses before A (IPv4) responses, and\n+\t\t\t\t * we don't currently have the testcontainer host's IPv6 address.\n+\t\t\t\t */\n+\t\t\t\taddARecord(domain, getClientHost());\n+\t\t\t\taddAAAARecord(domain, \"\");\n+\t\t\t}\n+    \t} catch (Exception e) {\n+    \t\tLog.error(CAContainer.class, \"addARecords\", e);\n+    \t}\n+    }\n+    /**\n+     * Convenience method for adding A records.\n+\t * @param host\n+\t *            The host / domain to redirect requests for.\n+     */\n+\tpublic void addARecord(String domain) throws IOException {\n+\t\taddARecord(domain, getClientHost());\n+\t}\n+\t/**\n+\t * Add an A record to the mock DNS server. This will allow us to redirect\n+\t * requests to a named domain to the IPv4 address of our choice.\n+\t * \n+\t * @param host\n+\t *            The host / domain to redirect requests for.\n+\t * @param address\n+\t *            The address to direct the requests for that host to.\n+\t * @throws IOException\n+\t */\n+\tpublic void addARecord(String host, String address) throws IOException {\n+\t\tfinal String METHOD_NAME = \"addARecord\";\n+\n+\t\ttry (CloseableHttpClient httpclient = HttpClients.createDefault()) {\n+\n+\t\t\t/*\n+\t\t\t * Generate the JSON request. The request can support multiple\n+\t\t\t * addresses but for the time being we will only support sending\n+\t\t\t * one.\n+\t\t\t */\n+\t\t\tString jsonString = \"{\\\"host\\\":\\\"\" + host + \"\\\",\\\"addresses\\\":[\\\"\" + address + \"\\\"]}\";\n+\t\t\tStringEntity requestEntity = new StringEntity(jsonString, ContentType.APPLICATION_JSON);\n+\n+\t\t\t/*\n+\t\t\t * Create a POST request to the mock DNS server.\n+\t\t\t */\n+\t\t\tHttpPost httpPost = new HttpPost(getManagementAddress() + \"/add-a\");\n+\t\t\thttpPost.setEntity(requestEntity);\n+\t\t\t/*\n+\t\t\t * Send the POST request and process the response.\n+\t\t\t */\n+\t\t\ttry (final CloseableHttpResponse response = httpclient.execute(httpPost)) {\n+\t\t\t\tAcmeFatUtils.logHttpResponse(CAContainer.class, METHOD_NAME, httpPost, response);\n+\n+\t\t\t\tStatusLine statusLine = response.getStatusLine();\n+\t\t\t\tif (statusLine.getStatusCode() != 200) {\n+\t\t\t\t\tthrow new IOException(\n+\t\t\t\t\t\t\tMETHOD_NAME + \": Expected response 200, but received response: \" + statusLine);\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t}\n+\t\n+\t/**\n+\t * Add an AAAA record to the mock DNS server. This will allow us to redirect\n+\t * requests to a named domain to the IPv6 address of our choice.\n+\t * \n+\t * @param host\n+\t *            The host / domain to redirect requests for.\n+\t * @param address\n+\t *            The address to direct the requests for that host to.\n+\t * @throws IOException\n+\t */\n+\tpublic void addAAAARecord(String host, String address) throws IOException {\n+\t\tfinal String METHOD_NAME = \"addAAAARecord\";\n+\n+\t\ttry (CloseableHttpClient httpclient = HttpClients.createDefault()) {\n+\n+\t\t\t/*\n+\t\t\t * Generate the JSON request. The request can support multiple\n+\t\t\t * addresses but for the time being we will only support sending\n+\t\t\t * one.\n+\t\t\t */\n+\t\t\tString jsonString = \"{\\\"host\\\":\\\"\" + host + \"\\\",\\\"addresses\\\":[\\\"\" + address + \"\\\"]}\";\n+\t\t\tStringEntity requestEntity = new StringEntity(jsonString, ContentType.APPLICATION_JSON);\n+\n+\t\t\t/*\n+\t\t\t * Create a POST request to the mock DNS server.\n+\t\t\t */\n+\t\t\tHttpPost httpPost = new HttpPost(getManagementAddress() + \"/add-aaaa\");\n+\t\t\thttpPost.setEntity(requestEntity);\n+\n+\t\t\t/*\n+\t\t\t * Send the POST request and process the response.\n+\t\t\t */\n+\t\t\ttry (final CloseableHttpResponse response = httpclient.execute(httpPost)) {\n+\t\t\t\tAcmeFatUtils.logHttpResponse(CAContainer.class, METHOD_NAME, httpPost, response);\n+\n+\t\t\t\tStatusLine statusLine = response.getStatusLine();\n+\t\t\t\tif (statusLine.getStatusCode() != 200) {\n+\t\t\t\t\tthrow new IOException(\n+\t\t\t\t\t\t\tMETHOD_NAME + \": Expected response 200, but received response: \" + statusLine);\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t}\n+\t/**\n+\t * Clear a previously added AAAA record that was added to the mock DNS\n+\t * server.\n+\t * \n+\t * @param host\n+\t *            The host / domain to redirect requests for.\n+\t * @throws IOException\n+\t */\n+\tpublic void clearAAAARecord(String host) throws IOException {\n+\t\tfinal String METHOD_NAME = \"clearAAAARecord(String)\";\n+\n+\t\ttry (CloseableHttpClient httpclient = HttpClients.createDefault()) {\n+\t\t\t/*\n+\t\t\t * Generate the JSON request.\n+\t\t\t */\n+\t\t\tString jsonString = \"{\\\"host\\\":\\\"\" + host + \"\\\"}\";\n+\t\t\tStringEntity requestEntity = new StringEntity(jsonString, ContentType.APPLICATION_JSON);\n+\n+\t\t\t/*\n+\t\t\t * Create a POST request to the mock DNS server.\n+\t\t\t */\n+\t\t\tHttpPost httpPost = new HttpPost(getManagementAddress() + \"/clear-aaaa\");\n+\t\t\thttpPost.setEntity(requestEntity);\n+\n+\t\t\t/*\n+\t\t\t * Send the POST request and process the response.\n+\t\t\t */\n+\t\t\ttry (final CloseableHttpResponse response = httpclient.execute(httpPost)) {\n+\t\t\t\tAcmeFatUtils.logHttpResponse(CAContainer.class, METHOD_NAME, httpPost, response);\n+\n+\t\t\t\tStatusLine statusLine = response.getStatusLine();\n+\t\t\t\tif (statusLine.getStatusCode() != 200) {\n+\t\t\t\t\tthrow new IOException(\n+\t\t\t\t\t\t\tMETHOD_NAME + \": Expected response 200, but received response: \" + statusLine);\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Clear a previously added A record that was added to the mock DNS server.\n+\t * \n+\t * @param host\n+\t *            The host / domain to redirect requests for.\n+\t * @throws IOException\n+\t */\n+\tpublic void clearARecord(String host) throws IOException {\n+\t\tfinal String METHOD_NAME = \"clearMockARecord(String)\";\n+\n+\t\ttry (CloseableHttpClient httpclient = HttpClients.createDefault()) {\n+\t\t\t/*\n+\t\t\t * Generate the JSON request.\n+\t\t\t */\n+\t\t\tString jsonString = \"{\\\"host\\\":\\\"\" + host + \"\\\"}\";\n+\t\t\tStringEntity requestEntity = new StringEntity(jsonString, ContentType.APPLICATION_JSON);\n+\n+\t\t\t/*\n+\t\t\t * Create a POST request to the mock DNS server.\n+\t\t\t */\n+\t\t\tHttpPost httpPost = new HttpPost(getManagementAddress() + \"/clear-a\");\n+\t\t\thttpPost.setEntity(requestEntity);\n+\n+\t\t\t/*\n+\t\t\t * Send the POST request and process the response.\n+\t\t\t */\n+\t\t\ttry (final CloseableHttpResponse response = httpclient.execute(httpPost)) {\n+\t\t\t\tAcmeFatUtils.logHttpResponse(CAContainer.class, METHOD_NAME, httpPost, response);\n+\n+\t\t\t\tStatusLine statusLine = response.getStatusLine();\n+\t\t\t\tif (statusLine.getStatusCode() != 200) {\n+\t\t\t\t\tthrow new IOException(\n+\t\t\t\t\t\t\tMETHOD_NAME + \": Expected response 200, but received response: \" + statusLine);\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t}\n+\t/**\n+\t * The HTTP address that can be used the reach the REST management API for\n+\t * the server.\n+\t * \n+\t * @return The HTTP address to the REST management endpoint.\n+\t */\n+\tpublic String getManagementAddress() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3c28406c01e42dd902f376fac4532e84cf17aa5f"}, "originalPosition": 415}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUwODYzMzU4OnYy", "diffSide": "RIGHT", "path": "dev/com.ibm.ws.security.acme_fat/fat/src/com/ibm/ws/security/acme/docker/pebble/PebbleDriver.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wNlQxNzo1NzowNFrOGBjbdw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wNlQxNzo1NzowNFrOGBjbdw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDI4MjIzMQ==", "bodyText": "If we don't need this, delete it.", "url": "https://github.com/OpenLiberty/open-liberty/pull/11374#discussion_r404282231", "createdAt": "2020-04-06T17:57:04Z", "author": {"login": "jvanhill"}, "path": "dev/com.ibm.ws.security.acme_fat/fat/src/com/ibm/ws/security/acme/docker/pebble/PebbleDriver.java", "diffHunk": "@@ -109,36 +108,19 @@ private static void start() {\n \t\t * challenge.\n \t\t */\n \t\tSystem.out.println(\"Running Testcontainers.exposeHostPorts\");\n-\t\tTestcontainers.exposeHostPorts(PebbleContainer.HTTP_PORT);\n-\n-\t\t/*\n-\t\t * Startup the challtestsrv container first. This container will serve\n-\t\t * as a mock DNS server to the Pebble server that starts on the other\n-\t\t * container.\n-\t\t */\n-\t\tSystem.out.println(\"Starting ChalltestsrvContainer\");\n-\t\tchalltestsrv = new ChalltestsrvContainer();\n-\t\tchalltestsrv.start();\n-\n+\t//\tTestcontainers.exposeHostPorts(PebbleContainer.HTTP_PORT);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3c28406c01e42dd902f376fac4532e84cf17aa5f"}, "originalPosition": 41}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUwODY0NzM0OnYy", "diffSide": "RIGHT", "path": "dev/com.ibm.ws.security.acme_fat/fat/src/com/ibm/ws/security/acme/fat/AcmeClientTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wNlQxODowMDozNlrOGBjkGw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wNlQxODowMDozNlrOGBjkGw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDI4NDQ0Mw==", "bodyText": "Can't we get this from the CAContainer?", "url": "https://github.com/OpenLiberty/open-liberty/pull/11374#discussion_r404284443", "createdAt": "2020-04-06T18:00:36Z", "author": {"login": "jvanhill"}, "path": "dev/com.ibm.ws.security.acme_fat/fat/src/com/ibm/ws/security/acme/fat/AcmeClientTest.java", "diffHunk": "@@ -56,20 +55,38 @@\n \tprivate static final String TEST_DOMAIN_3 = \"domain3.com\";\n \tprivate static final String TEST_DOMAIN_4 = \"domain4.com\";\n \n-\tprivate static final String FILE_MINICA_PEM = \"lib/LibertyFATTestFiles/pebble.minica.pem\";\n-\tprivate static final String TRUSTSTORE_FILE;\n-\tprivate static final String FILE_ACCOUNT_KEY;\n-\tprivate static final String FILE_DOMAIN_KEY;\n-\tprivate static final String TRUSTSTORE_PASSWORD = \"password\";\n-\tprivate static X509Certificate pebbleIntermediateCertificate = null;\n \tprivate static HttpChallengeServer challengeServer = null;\n-\tprivate static final String acmeDirectoryURI = FATSuite.pebble.getAcmeDirectoryURI(true);\n+\t/** Challenge server port. */\n+\tpublic static final int HTTP_PORT = 5002;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3c28406c01e42dd902f376fac4532e84cf17aa5f"}, "originalPosition": 42}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUwODY1MDU1OnYy", "diffSide": "RIGHT", "path": "dev/com.ibm.ws.security.acme_fat/fat/src/com/ibm/ws/security/acme/fat/AcmeClientTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wNlQxODowMToyOFrOGBjmHg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wNlQxODowMToyOFrOGBjmHg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDI4NDk1OA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t\t\t\t\t\"Boulder Intermediate Cert: \" + String.valueOf(intermediateCertificate));\n          \n          \n            \n            \t\t\t\t\t\"Pebble Intermediate Cert: \" + String.valueOf(intermediateCertificate));", "url": "https://github.com/OpenLiberty/open-liberty/pull/11374#discussion_r404284958", "createdAt": "2020-04-06T18:01:28Z", "author": {"login": "jvanhill"}, "path": "dev/com.ibm.ws.security.acme_fat/fat/src/com/ibm/ws/security/acme/fat/AcmeClientTest.java", "diffHunk": "@@ -112,10 +129,10 @@\n \t\t\t * verify that the generated certificate is actually signed by the\n \t\t\t * root and intermediate certificates.\n \t\t\t */\n-\t\t\tpebbleIntermediateCertificate = AcmeFatUtils\n-\t\t\t\t\t.getX509Certificate(new ByteArrayInputStream(FATSuite.pebble.getAcmeCaIntermediateCertificate()));\n+\t\t\tintermediateCertificate = AcmeFatUtils\n+\t\t\t\t\t.getX509Certificate(pebble.getAcmeCaIntermediateCertificate());\n \t\t\tLog.info(AcmeClientTest.class, \"<cinit>\",\n-\t\t\t\t\t\"Pebble Intermediate Cert: \" + String.valueOf(pebbleIntermediateCertificate));\n+\t\t\t\t\t\"Boulder Intermediate Cert: \" + String.valueOf(intermediateCertificate));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3c28406c01e42dd902f376fac4532e84cf17aa5f"}, "originalPosition": 88}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUwODY2NTg3OnYy", "diffSide": "RIGHT", "path": "dev/com.ibm.ws.security.acme_fat/fat/src/com/ibm/ws/security/acme/fat/AcmeURISimpleTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wNlQxODowNTo1MlrOGBjwEA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wNlQxODowNTo1MlrOGBjwEA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDI4NzUwNA==", "bodyText": "Do we need this empty method?", "url": "https://github.com/OpenLiberty/open-liberty/pull/11374#discussion_r404287504", "createdAt": "2020-04-06T18:05:52Z", "author": {"login": "jvanhill"}, "path": "dev/com.ibm.ws.security.acme_fat/fat/src/com/ibm/ws/security/acme/fat/AcmeURISimpleTest.java", "diffHunk": "@@ -29,12 +31,15 @@\n @Mode(TestMode.FULL)\n public class AcmeURISimpleTest extends AcmeSimpleTest {\n \n+\t@AfterClass", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3c28406c01e42dd902f376fac4532e84cf17aa5f"}, "originalPosition": 17}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUwODY2Njc2OnYy", "diffSide": "RIGHT", "path": "dev/com.ibm.ws.security.acme_fat/fat/src/com/ibm/ws/security/acme/fat/AcmeURISimpleTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wNlQxODowNjowOFrOGBjwpw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wNlQxODowNjowOFrOGBjwpw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDI4NzY1NQ==", "bodyText": "Whitespace between methods.", "url": "https://github.com/OpenLiberty/open-liberty/pull/11374#discussion_r404287655", "createdAt": "2020-04-06T18:06:08Z", "author": {"login": "jvanhill"}, "path": "dev/com.ibm.ws.security.acme_fat/fat/src/com/ibm/ws/security/acme/fat/AcmeURISimpleTest.java", "diffHunk": "@@ -29,12 +31,15 @@\n @Mode(TestMode.FULL)\n public class AcmeURISimpleTest extends AcmeSimpleTest {\n \n+\t@AfterClass\n+\tpublic static void afterClass() throws Exception {\n+\t}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3c28406c01e42dd902f376fac4532e84cf17aa5f"}, "originalPosition": 19}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUwODY3MDg2OnYy", "diffSide": "RIGHT", "path": "dev/com.ibm.ws.security.acme_fat/fat/src/com/ibm/ws/security/acme/fat/FATSuite.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wNlQxODowNzoyNlrOGBjzVw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wNlQxODowNzoyNlrOGBjzVw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDI4ODM0Mw==", "bodyText": "Do we still need this since we start our containers in each case separately?", "url": "https://github.com/OpenLiberty/open-liberty/pull/11374#discussion_r404288343", "createdAt": "2020-04-06T18:07:26Z", "author": {"login": "jvanhill"}, "path": "dev/com.ibm.ws.security.acme_fat/fat/src/com/ibm/ws/security/acme/fat/FATSuite.java", "diffHunk": "@@ -43,62 +30,5 @@\n \t\tExternalTestServiceDockerClientStrategy.clearTestcontainersConfig();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3c28406c01e42dd902f376fac4532e84cf17aa5f"}, "originalPosition": 33}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2009, "cost": 1, "resetAt": "2021-11-13T12:10:21Z"}}}