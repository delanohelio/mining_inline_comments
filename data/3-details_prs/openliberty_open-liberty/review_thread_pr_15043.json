{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTIzNDQyNjE0", "number": 15043, "reviewThreads": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOFQyMDoxNTo0M1rOE6v21g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOFQyMDoxNTo0M1rOE6v21g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMwMDM2OTUwOnYy", "diffSide": "RIGHT", "path": "dev/com.ibm.ws.jca_fat/test-applications/fvtweb/src/web/JCAFVTServlet.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOFQyMDoxNTo0M1rOH2AVYg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOFQyMDoxNTo0M1rOH2AVYg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjM5MDYyNg==", "bodyText": "Need to figure out a way to get at the PoolManager so that I can get at the connections in the unshared pool.\nOr need an alternative way to change the state of the connections while purging.", "url": "https://github.com/OpenLiberty/open-liberty/pull/15043#discussion_r526390626", "createdAt": "2020-11-18T20:15:43Z", "author": {"login": "KyleAure"}, "path": "dev/com.ibm.ws.jca_fat/test-applications/fvtweb/src/web/JCAFVTServlet.java", "diffHunk": "@@ -732,6 +745,92 @@ public void testMBeanPurgeTwoResourceRef(HttpServletRequest request, HttpServlet\n         }\n     }\n \n+    /**\n+     * Test race condition between an invalid state change and pool purge setting state to stale\n+     */\n+    public void testMBeanPurgeRaceCondition(HttpServletRequest request, HttpServletResponse response) throws Throwable {\n+        ConnectionFactory cf1 = (ConnectionFactory) new InitialContext().lookup(\"java:comp/env/jms/cf1-unshareable\");\n+        Connection con1 = null;\n+        UserTransaction tran = (UserTransaction) new InitialContext().lookup(\"java:comp/UserTransaction\");\n+        try {\n+            tran.begin();//Starting this removes the LTC\n+            con1 = cf1.createConnection();\n+\n+            MBeanServer mbs = ManagementFactory.getPlatformMBeanServer();\n+            ObjectInstance bean = getMBeanObjectInstance(\"jms/cf1\");\n+\n+            con1.close();\n+            tran.commit();\n+\n+            //Attempt to mark connections stale right before they are purged\n+            ExecutorService exec = Executors.newFixedThreadPool(2);\n+            List<Callable<Boolean>> callables = Arrays.asList(new MarkStale(mbs, bean), new PurgeTask(mbs, bean));\n+            List<Future<Boolean>> futures = exec.invokeAll(callables);\n+            awaitTerminationAfterShutdown(exec);\n+\n+            System.out.println(\"**  Pool contents after purge:\\n\" + getPoolContents(bean));\n+            if (getPoolSize(bean) != 0)\n+                throw new Exception(\"Not all connections were purged from the pool!\");\n+\n+            assertTrue(futures.get(0).get().booleanValue());\n+            assertTrue(futures.get(1).get().booleanValue());\n+        } finally {\n+            if (con1 != null)\n+                con1.close();\n+        }\n+    }\n+\n+    @SuppressWarnings(\"restriction\")\n+    private class MarkStale implements Callable<Boolean> {\n+        MCWrapper[] wrappers;\n+\n+        MarkStale(MBeanServer mbs, ObjectInstance bean) {\n+            //Get at MCWrappers from poolmanager]\n+            try {\n+                // TODO figure out a way to get at the pool manager so that we can call:\n+//                wrappers = pm.getUnSharedPoolConnections(); //NOTE this will get a lock\n+            } catch (Exception e) {\n+                throw new RuntimeException(\"Failed to get wrappers\", e);\n+            }\n+        }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "31412b57d8363f886f19769ff4d6ff71267d0a4c"}, "originalPosition": 85}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2469, "cost": 1, "resetAt": "2021-11-13T12:10:21Z"}}}