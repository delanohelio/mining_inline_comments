{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTAwNzEwNzQ3", "number": 14412, "reviewThreads": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xMlQwOTo1OToxNVrOEsj_Fw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xMlQwOTo1OToxNVrOEsj_Fw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE1MTYyMzkxOnYy", "diffSide": "RIGHT", "path": "dev/com.ibm.ws.microprofile.faulttolerance.1.0/test/src/com/ibm/ws/microprofile/faulttolerance/test/BulkheadTest.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xMlQwOTo1OToxNVrOHf3xiQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xMlQxMTo0MjoyN1rOHf7LqQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzE4MTcwNQ==", "bodyText": "This assertion doesn't actually do anything. Since we're catching BulkheadException, it's guaranteed that e is an instance of BulkheadException.\nThere's a similar assertion in the 2.0 test which does do an important check, because there we're catching ExecutionException and checking the type of its cause.\nIt's not a big problem and if it was the only comment I wouldn't worry about it, but in general, I would try to avoid code which looks like it does something important that it doesn't actually do.", "url": "https://github.com/OpenLiberty/open-liberty/pull/14412#discussion_r503181705", "createdAt": "2020-10-12T09:59:15Z", "author": {"login": "Azquelt"}, "path": "dev/com.ibm.ws.microprofile.faulttolerance.1.0/test/src/com/ibm/ws/microprofile/faulttolerance/test/BulkheadTest.java", "diffHunk": "@@ -249,28 +268,47 @@ public void testAsyncBulkheadQueueFull() throws InterruptedException, ExecutionE\n         Executor<Future<String>> executor = builder.buildAsync(Future.class);\n \n         Future<String>[] futures = new Future[5];\n+        CountDownLatch isRunningLatch = new CountDownLatch(2);\n+        CountDownLatch mayCompleteLatch = new CountDownLatch(1);\n+        CountDownLatch completedLatch = new CountDownLatch(4);\n         try {\n+\n+            // Create and add tasks to the executor which do not exceed the bulkhead limit\n             for (int i = 0; i < 4; i++) {\n                 String id = \"testAsyncBulkheadQueueFull\" + i;\n                 ExecutionContext context = executor.newExecutionContext(id, (Method) null, id);\n-                AsyncTestFunction callable = new AsyncTestFunction(Duration.ofMillis(2000), id);\n+                AsyncTestFunction callable = new AsyncTestFunction(Duration.ofMillis(10000), isRunningLatch, mayCompleteLatch, completedLatch, id);\n                 futures[i] = executor.execute(callable, context);\n-                System.out.println(System.currentTimeMillis() + \" Test \" + context + \" - submitted\");\n-                assertFalse(futures[i].isDone());\n-                Thread.sleep(100);\n+                System.out.println(System.currentTimeMillis() + \" Test \" + id + \" - submitted\");\n             }\n \n+            // Allow running latch to reach 0 - tasks are ready to begin execution\n+            isRunningLatch.await(5000, TimeUnit.MILLISECONDS);\n+            assertEquals(\"all tasks have not started\", 0, isRunningLatch.getCount());\n+\n+            // Non of the tasks are allowed to complete as mayCompleteLatch has not count down\n+            // First two tasks should be running, second two should be in queue\n+            for (int i = 0; i < 4; i++) {\n+                assertFalse(\"task \" + i + \" should not be complete\", futures[i].isDone());\n+            }\n+\n+            // Create and add a final task\n             String id = \"testAsyncBulkheadQueueFull4\";\n             ExecutionContext context = executor.newExecutionContext(id, (Method) null, id);\n-            AsyncTestFunction callable = new AsyncTestFunction(Duration.ofMillis(2000), id);\n+            AsyncTestFunction callable = new AsyncTestFunction(Duration.ofMillis(10000), isRunningLatch, mayCompleteLatch, completedLatch, id);\n+\n+            // Final task should be rejected from queue, and throw a Bulkhead exception\n             try {\n                 futures[4] = executor.execute(callable, context);\n                 System.out.println(System.currentTimeMillis() + \" Test \" + id + \" - submitted\");\n                 fail(\"Exception not thrown\");\n             } catch (BulkheadException e) {\n-                //expected\n+                assertTrue(\"Should fail with bulkhead exception \", e instanceof BulkheadException);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d00810fe51c000ecbc7d96496ed6da22a51d9dd4"}, "originalPosition": 94}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzIyNTEyNg==", "bodyText": "Thank you for noting this, I'll get around to making the changes now!", "url": "https://github.com/OpenLiberty/open-liberty/pull/14412#discussion_r503225126", "createdAt": "2020-10-12T11:18:49Z", "author": {"login": "scottcurtis2605"}, "path": "dev/com.ibm.ws.microprofile.faulttolerance.1.0/test/src/com/ibm/ws/microprofile/faulttolerance/test/BulkheadTest.java", "diffHunk": "@@ -249,28 +268,47 @@ public void testAsyncBulkheadQueueFull() throws InterruptedException, ExecutionE\n         Executor<Future<String>> executor = builder.buildAsync(Future.class);\n \n         Future<String>[] futures = new Future[5];\n+        CountDownLatch isRunningLatch = new CountDownLatch(2);\n+        CountDownLatch mayCompleteLatch = new CountDownLatch(1);\n+        CountDownLatch completedLatch = new CountDownLatch(4);\n         try {\n+\n+            // Create and add tasks to the executor which do not exceed the bulkhead limit\n             for (int i = 0; i < 4; i++) {\n                 String id = \"testAsyncBulkheadQueueFull\" + i;\n                 ExecutionContext context = executor.newExecutionContext(id, (Method) null, id);\n-                AsyncTestFunction callable = new AsyncTestFunction(Duration.ofMillis(2000), id);\n+                AsyncTestFunction callable = new AsyncTestFunction(Duration.ofMillis(10000), isRunningLatch, mayCompleteLatch, completedLatch, id);\n                 futures[i] = executor.execute(callable, context);\n-                System.out.println(System.currentTimeMillis() + \" Test \" + context + \" - submitted\");\n-                assertFalse(futures[i].isDone());\n-                Thread.sleep(100);\n+                System.out.println(System.currentTimeMillis() + \" Test \" + id + \" - submitted\");\n             }\n \n+            // Allow running latch to reach 0 - tasks are ready to begin execution\n+            isRunningLatch.await(5000, TimeUnit.MILLISECONDS);\n+            assertEquals(\"all tasks have not started\", 0, isRunningLatch.getCount());\n+\n+            // Non of the tasks are allowed to complete as mayCompleteLatch has not count down\n+            // First two tasks should be running, second two should be in queue\n+            for (int i = 0; i < 4; i++) {\n+                assertFalse(\"task \" + i + \" should not be complete\", futures[i].isDone());\n+            }\n+\n+            // Create and add a final task\n             String id = \"testAsyncBulkheadQueueFull4\";\n             ExecutionContext context = executor.newExecutionContext(id, (Method) null, id);\n-            AsyncTestFunction callable = new AsyncTestFunction(Duration.ofMillis(2000), id);\n+            AsyncTestFunction callable = new AsyncTestFunction(Duration.ofMillis(10000), isRunningLatch, mayCompleteLatch, completedLatch, id);\n+\n+            // Final task should be rejected from queue, and throw a Bulkhead exception\n             try {\n                 futures[4] = executor.execute(callable, context);\n                 System.out.println(System.currentTimeMillis() + \" Test \" + id + \" - submitted\");\n                 fail(\"Exception not thrown\");\n             } catch (BulkheadException e) {\n-                //expected\n+                assertTrue(\"Should fail with bulkhead exception \", e instanceof BulkheadException);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzE4MTcwNQ=="}, "originalCommit": {"oid": "d00810fe51c000ecbc7d96496ed6da22a51d9dd4"}, "originalPosition": 94}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzIzNzU0NQ==", "bodyText": "Changes have just been made to update the copyright header, and remove the assertion.", "url": "https://github.com/OpenLiberty/open-liberty/pull/14412#discussion_r503237545", "createdAt": "2020-10-12T11:42:27Z", "author": {"login": "scottcurtis2605"}, "path": "dev/com.ibm.ws.microprofile.faulttolerance.1.0/test/src/com/ibm/ws/microprofile/faulttolerance/test/BulkheadTest.java", "diffHunk": "@@ -249,28 +268,47 @@ public void testAsyncBulkheadQueueFull() throws InterruptedException, ExecutionE\n         Executor<Future<String>> executor = builder.buildAsync(Future.class);\n \n         Future<String>[] futures = new Future[5];\n+        CountDownLatch isRunningLatch = new CountDownLatch(2);\n+        CountDownLatch mayCompleteLatch = new CountDownLatch(1);\n+        CountDownLatch completedLatch = new CountDownLatch(4);\n         try {\n+\n+            // Create and add tasks to the executor which do not exceed the bulkhead limit\n             for (int i = 0; i < 4; i++) {\n                 String id = \"testAsyncBulkheadQueueFull\" + i;\n                 ExecutionContext context = executor.newExecutionContext(id, (Method) null, id);\n-                AsyncTestFunction callable = new AsyncTestFunction(Duration.ofMillis(2000), id);\n+                AsyncTestFunction callable = new AsyncTestFunction(Duration.ofMillis(10000), isRunningLatch, mayCompleteLatch, completedLatch, id);\n                 futures[i] = executor.execute(callable, context);\n-                System.out.println(System.currentTimeMillis() + \" Test \" + context + \" - submitted\");\n-                assertFalse(futures[i].isDone());\n-                Thread.sleep(100);\n+                System.out.println(System.currentTimeMillis() + \" Test \" + id + \" - submitted\");\n             }\n \n+            // Allow running latch to reach 0 - tasks are ready to begin execution\n+            isRunningLatch.await(5000, TimeUnit.MILLISECONDS);\n+            assertEquals(\"all tasks have not started\", 0, isRunningLatch.getCount());\n+\n+            // Non of the tasks are allowed to complete as mayCompleteLatch has not count down\n+            // First two tasks should be running, second two should be in queue\n+            for (int i = 0; i < 4; i++) {\n+                assertFalse(\"task \" + i + \" should not be complete\", futures[i].isDone());\n+            }\n+\n+            // Create and add a final task\n             String id = \"testAsyncBulkheadQueueFull4\";\n             ExecutionContext context = executor.newExecutionContext(id, (Method) null, id);\n-            AsyncTestFunction callable = new AsyncTestFunction(Duration.ofMillis(2000), id);\n+            AsyncTestFunction callable = new AsyncTestFunction(Duration.ofMillis(10000), isRunningLatch, mayCompleteLatch, completedLatch, id);\n+\n+            // Final task should be rejected from queue, and throw a Bulkhead exception\n             try {\n                 futures[4] = executor.execute(callable, context);\n                 System.out.println(System.currentTimeMillis() + \" Test \" + id + \" - submitted\");\n                 fail(\"Exception not thrown\");\n             } catch (BulkheadException e) {\n-                //expected\n+                assertTrue(\"Should fail with bulkhead exception \", e instanceof BulkheadException);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzE4MTcwNQ=="}, "originalCommit": {"oid": "d00810fe51c000ecbc7d96496ed6da22a51d9dd4"}, "originalPosition": 94}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2693, "cost": 1, "resetAt": "2021-11-13T12:10:21Z"}}}