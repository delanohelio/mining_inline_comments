{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTE3NzE0MTA3", "number": 14884, "reviewThreads": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wOVQxNTowMzowN1rOE2zprQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wOVQxNTowMzowN1rOE2zprQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI1OTA0ODEzOnYy", "diffSide": "RIGHT", "path": "dev/com.ibm.ws.cdi.weld/src/com/ibm/ws/cdi/impl/CDIContainerImpl.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wOVQxNTowMzowN1rOHvy9Yg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wOVQxNTowNTowNlrOHvzC8Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTg4MDAzNA==", "bodyText": "Can you try to make the two paths a little closer? e.g. surely you can get the spiExtensionClasses from the extensionArchive? So the code would more more like this;\nextensionArchive = runtimeExtensionMap.get(serviceID);\nif (extensionArchive == null) {\n    //only create a new archive, don't register any classes with the deployment\n    extensionArchive = newSPIExtensionArchive(sr, extension.getService(), applicationContext);\n    runtimeExtensionMap.put(serviceID, extensionArchive);\n}\nSet<Extension> spiExtensionClasses = extensionArchive.getExtensions();\napplicationContext.registerSPIExtensions(spiExtensionClasses);", "url": "https://github.com/OpenLiberty/open-liberty/pull/14884#discussion_r519880034", "createdAt": "2020-11-09T15:03:07Z", "author": {"login": "tevans78"}, "path": "dev/com.ibm.ws.cdi.weld/src/com/ibm/ws/cdi/impl/CDIContainerImpl.java", "diffHunk": "@@ -593,17 +593,23 @@ public String getCurrentApplicationContextID() {\n         //Now do the exact same thing for extensions coming from the SPI\n         Iterator<ServiceAndServiceReferencePair<CDIExtensionMetadata>> spiExtensions = cdiRuntime.getSPIExtensionServices();\n         while (spiExtensions.hasNext()) {\n-            ServiceAndServiceReferencePair<CDIExtensionMetadata> extension = spiExtensions.next();\n-            ServiceReference<CDIExtensionMetadata> sr = extension.getServiceReference();\n+            ServiceAndServiceReferencePair<CDIExtensionMetadata> extensionMetaData = spiExtensions.next();\n+            ServiceReference<CDIExtensionMetadata> sr = extensionMetaData.getServiceReference();\n             if (sr != null) {\n                 Long serviceID = ServiceReferenceUtils.getId(sr);\n                 ExtensionArchive extensionArchive = null;\n                 synchronized (this) {\n                     extensionArchive = runtimeExtensionMap.get(serviceID);\n \n                     if (extensionArchive == null) {\n-                        extensionArchive = newSPIExtensionArchive(sr, extension.getService(), applicationContext);\n+                        extensionArchive = newSPIExtensionArchive(sr, extensionMetaData.getService(), applicationContext);\n                         runtimeExtensionMap.put(serviceID, extensionArchive);\n+                    } else {\n+                        // We don't need to create the extension archive but we do need to register the contained extensions into the deploymnet.\n+                        // Since ExtensionArchive doesn't have a method for getting the extension classes, we'll get the extensions from the service.\n+\n+                        Set<Extension> spiExtensionClasses = getExtensionInstancesFromService(extensionMetaData.getService());\n+                        applicationContext.registerSPIExtensions(spiExtensionClasses);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0d22ea0d8ec385198385b920296c0a125b11d410"}, "originalPosition": 23}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTg4MTQ1Nw==", "bodyText": "oh actually, don't call it spiExtensionClasses because they are instances", "url": "https://github.com/OpenLiberty/open-liberty/pull/14884#discussion_r519881457", "createdAt": "2020-11-09T15:05:06Z", "author": {"login": "tevans78"}, "path": "dev/com.ibm.ws.cdi.weld/src/com/ibm/ws/cdi/impl/CDIContainerImpl.java", "diffHunk": "@@ -593,17 +593,23 @@ public String getCurrentApplicationContextID() {\n         //Now do the exact same thing for extensions coming from the SPI\n         Iterator<ServiceAndServiceReferencePair<CDIExtensionMetadata>> spiExtensions = cdiRuntime.getSPIExtensionServices();\n         while (spiExtensions.hasNext()) {\n-            ServiceAndServiceReferencePair<CDIExtensionMetadata> extension = spiExtensions.next();\n-            ServiceReference<CDIExtensionMetadata> sr = extension.getServiceReference();\n+            ServiceAndServiceReferencePair<CDIExtensionMetadata> extensionMetaData = spiExtensions.next();\n+            ServiceReference<CDIExtensionMetadata> sr = extensionMetaData.getServiceReference();\n             if (sr != null) {\n                 Long serviceID = ServiceReferenceUtils.getId(sr);\n                 ExtensionArchive extensionArchive = null;\n                 synchronized (this) {\n                     extensionArchive = runtimeExtensionMap.get(serviceID);\n \n                     if (extensionArchive == null) {\n-                        extensionArchive = newSPIExtensionArchive(sr, extension.getService(), applicationContext);\n+                        extensionArchive = newSPIExtensionArchive(sr, extensionMetaData.getService(), applicationContext);\n                         runtimeExtensionMap.put(serviceID, extensionArchive);\n+                    } else {\n+                        // We don't need to create the extension archive but we do need to register the contained extensions into the deploymnet.\n+                        // Since ExtensionArchive doesn't have a method for getting the extension classes, we'll get the extensions from the service.\n+\n+                        Set<Extension> spiExtensionClasses = getExtensionInstancesFromService(extensionMetaData.getService());\n+                        applicationContext.registerSPIExtensions(spiExtensionClasses);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTg4MDAzNA=="}, "originalCommit": {"oid": "0d22ea0d8ec385198385b920296c0a125b11d410"}, "originalPosition": 23}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2538, "cost": 1, "resetAt": "2021-11-13T12:10:21Z"}}}