{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDU4MDc3NTA1", "number": 1005, "reviewThreads": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMFQyMDoyNjozOVrOET1RzA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMFQyMDoyNjozOVrOET1RzA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg5MjMxMzA4OnYy", "diffSide": "RIGHT", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/RecordQueryPlanner.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMFQyMDoyNjozOVrOG5ynxA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMFQyMDoyNjozOVrOG5ynxA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzI1MTM5Ng==", "bodyText": "Specifically, for FDBInQueryTest.testInQueryIndexSortedDifferently, the old alternative plan was\nIndex(MySimpleRecord$str_value_indexed <,>) | num_value_3_indexed EQUALS 1 \u222a[Field { 'str_value_indexed' None}, Field { 'rec_no' None}] Index(MySimpleRecord$str_value_indexed <,>) | num_value_3_indexed EQUALS 4 \u222a[Field { 'str_value_indexed' None}, Field { 'rec_no' None}] Index(MySimpleRecord$str_value_indexed <,>) | num_value_3_indexed EQUALS 2\n\nand the new one is\nIndex(MySimpleRecord$str_value_indexed <,>) | Or([num_value_3_indexed EQUALS 1, num_value_3_indexed EQUALS 4, num_value_3_indexed EQUALS 2])\n\nbut the winner still is\nIndex(MySimpleRecord$str_value_indexed <,>) | num_value_3_indexed IN [1, 4, 2]\n\nHence no change in that test.", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1005#discussion_r463251396", "createdAt": "2020-07-30T20:26:39Z", "author": {"login": "MMcM"}, "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/RecordQueryPlanner.java", "diffHunk": "@@ -1186,8 +1188,33 @@ private ScoredPlan planOr(@Nonnull PlanContext planContext, @Nonnull OrComponent\n             if (subplan.planOrderingKey == null) {\n                 allHaveOrderingKey = false;\n             }\n+            RecordQueryPlan filteredBasePlan;\n+            if (subplan.plan instanceof RecordQueryFilterPlan) {\n+                filteredBasePlan = ((RecordQueryFilterPlan)subplan.plan).getInner();\n+            } else {\n+                filteredBasePlan = null;\n+            }\n+            if (subplans.isEmpty()) {\n+                commonFilteredBasePlan = filteredBasePlan;\n+                allHaveSameBasePlan = filteredBasePlan != null;\n+            } else if (allHaveSameBasePlan && !Objects.equals(filteredBasePlan, commonFilteredBasePlan)) {\n+                allHaveSameBasePlan = false;\n+            }\n             subplans.add(subplan);\n         }\n+        // If the child plans only differ in their filters, then there is no point in repeating the base\n+        // scan only to evaluate each of the filters. Just evaluate the scan with an OR filter.\n+        // Note that this also improves the _second-best_ plan for planFilterWithInJoin, but an IN filter wins\n+        // out there over the equivalent OR(EQUALS) filters.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6706ba2a8be6c8eecbb5e557dcb1ac2f02e98fd1"}, "originalPosition": 30}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 21, "cost": 1, "resetAt": "2021-11-12T18:49:56Z"}}}