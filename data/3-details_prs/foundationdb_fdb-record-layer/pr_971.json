{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDM0NzEyNDk4", "number": 971, "title": "Resolves #970: improve GML explain exporter to support operator-depen\u2026", "bodyText": "\u2026dent variables and node information\n\nprovides metadata for all physical plan operators to be used for explain export to GML.\nforces all RecordQueryPlan operators to provide their own graph node that now must be NodeWithInfo to ensure that compatible descriptions, names, etc. are exported.\nprovides meaningful nodes for all physical operators\nsmall fixes", "createdAt": "2020-06-15T18:51:35Z", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/971", "merged": true, "mergeCommit": {"oid": "0f9d3c7b24131ff45bc95f3f420e3cd28bfe8e97"}, "closed": true, "closedAt": "2020-06-17T17:28:47Z", "author": {"login": "normen662"}, "timelineItems": {"totalCount": 11, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcrmYiOgBqjM0NDU5ODg1MjQ=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcsNTPgAFqTQzMjYyMDA0Mg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "e45557d2fe3db7f9d404e616688ba9cbafa19cd9", "author": {"user": {"login": "normen662", "name": null}}, "url": "https://github.com/FoundationDB/fdb-record-layer/commit/e45557d2fe3db7f9d404e616688ba9cbafa19cd9", "committedDate": "2020-06-15T18:47:17Z", "message": "Resolves #970: improve GML explain exporter to support operator-dependent variables and node information"}, "afterCommit": {"oid": "5ee261a7da22a5b5d2da9f48d1b0568b95d54ee1", "author": {"user": {"login": "normen662", "name": null}}, "url": "https://github.com/FoundationDB/fdb-record-layer/commit/5ee261a7da22a5b5d2da9f48d1b0568b95d54ee1", "committedDate": "2020-06-15T19:04:07Z", "message": "Resolves #970: improve GML explain exporter to support operator-dependent variables and node information"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "5ee261a7da22a5b5d2da9f48d1b0568b95d54ee1", "author": {"user": {"login": "normen662", "name": null}}, "url": "https://github.com/FoundationDB/fdb-record-layer/commit/5ee261a7da22a5b5d2da9f48d1b0568b95d54ee1", "committedDate": "2020-06-15T19:04:07Z", "message": "Resolves #970: improve GML explain exporter to support operator-dependent variables and node information"}, "afterCommit": {"oid": "ced25340a875aec684a1190d9d11b20134d828da", "author": {"user": {"login": "normen662", "name": null}}, "url": "https://github.com/FoundationDB/fdb-record-layer/commit/ced25340a875aec684a1190d9d11b20134d828da", "committedDate": "2020-06-15T20:56:55Z", "message": "Resolves #970: improve GML explain exporter to support operator-dependent variables and node information"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "ced25340a875aec684a1190d9d11b20134d828da", "author": {"user": {"login": "normen662", "name": null}}, "url": "https://github.com/FoundationDB/fdb-record-layer/commit/ced25340a875aec684a1190d9d11b20134d828da", "committedDate": "2020-06-15T20:56:55Z", "message": "Resolves #970: improve GML explain exporter to support operator-dependent variables and node information"}, "afterCommit": {"oid": "ba09399588c0493bbed69b94f99408a9f8294c22", "author": {"user": {"login": "normen662", "name": null}}, "url": "https://github.com/FoundationDB/fdb-record-layer/commit/ba09399588c0493bbed69b94f99408a9f8294c22", "committedDate": "2020-06-16T20:14:47Z", "message": "Resolves #970: improve GML explain exporter to support operator-dependent variables and node information"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMxOTI1MzI5", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/971#pullrequestreview-431925329", "createdAt": "2020-06-16T22:05:26Z", "commit": {"oid": "ba09399588c0493bbed69b94f99408a9f8294c22"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 38, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNlQyMjowNToyNlrOGkuzGA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xN1QwMDozMToyMlrOGkxnHw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTE2ODY2NA==", "bodyText": "This file should probably be a separate commit, or be removed from the PR entirely.", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/971#discussion_r441168664", "createdAt": "2020-06-16T22:05:26Z", "author": {"login": "nschiefer"}, "path": ".idea/codeStyles/Project.xml", "diffHunk": "@@ -12,6 +12,9 @@\n       <option name=\"GENERATE_FINAL_PARAMETERS\" value=\"true\" />\n       <option name=\"CLASS_COUNT_TO_USE_IMPORT_ON_DEMAND\" value=\"500\" />\n       <option name=\"NAMES_COUNT_TO_USE_IMPORT_ON_DEMAND\" value=\"500\" />\n+      <option name=\"PACKAGES_TO_USE_IMPORT_ON_DEMAND\">\n+        <value />\n+      </option>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ba09399588c0493bbed69b94f99408a9f8294c22"}, "originalPosition": 6}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTE3NDkwMQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n             * Operator infos for all operators and storage objects in the record layer.\n          \n          \n            \n             * Explanatory information about the Record Layer's plan operators and storage objects.", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/971#discussion_r441174901", "createdAt": "2020-06-16T22:21:10Z", "author": {"login": "nschiefer"}, "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/explain/NodeInfo.java", "diffHunk": "@@ -0,0 +1,191 @@\n+/*\n+ * NodeInfo.java\n+ *\n+ * This source file is part of the FoundationDB open source project\n+ *\n+ * Copyright 2015-2020 Apple Inc. and the FoundationDB project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.apple.foundationdb.record.query.plan.temp.explain;\n+\n+import com.google.common.collect.ImmutableMap;\n+\n+import javax.annotation.Nonnull;\n+import java.util.Arrays;\n+import java.util.Map;\n+\n+/**\n+ * Operator infos for all operators and storage objects in the record layer.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ba09399588c0493bbed69b94f99408a9f8294c22"}, "originalPosition": 30}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTE3NTc5Nw==", "bodyText": "I think that this should be a container class with various public static final objects, rather than an enum, so that it can be extended by users of the API.", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/971#discussion_r441175797", "createdAt": "2020-06-16T22:23:39Z", "author": {"login": "nschiefer"}, "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/explain/NodeInfo.java", "diffHunk": "@@ -0,0 +1,191 @@\n+/*\n+ * NodeInfo.java\n+ *\n+ * This source file is part of the FoundationDB open source project\n+ *\n+ * Copyright 2015-2020 Apple Inc. and the FoundationDB project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.apple.foundationdb.record.query.plan.temp.explain;\n+\n+import com.google.common.collect.ImmutableMap;\n+\n+import javax.annotation.Nonnull;\n+import java.util.Arrays;\n+import java.util.Map;\n+\n+/**\n+ * Operator infos for all operators and storage objects in the record layer.\n+ */\n+public enum NodeInfo {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ba09399588c0493bbed69b94f99408a9f8294c22"}, "originalPosition": 32}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTE3NTkxOQ==", "bodyText": "Same with Icon, I think.", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/971#discussion_r441175919", "createdAt": "2020-06-16T22:23:59Z", "author": {"login": "nschiefer"}, "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/explain/NodeInfo.java", "diffHunk": "@@ -0,0 +1,191 @@\n+/*\n+ * NodeInfo.java\n+ *\n+ * This source file is part of the FoundationDB open source project\n+ *\n+ * Copyright 2015-2020 Apple Inc. and the FoundationDB project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.apple.foundationdb.record.query.plan.temp.explain;\n+\n+import com.google.common.collect.ImmutableMap;\n+\n+import javax.annotation.Nonnull;\n+import java.util.Arrays;\n+import java.util.Map;\n+\n+/**\n+ * Operator infos for all operators and storage objects in the record layer.\n+ */\n+public enum NodeInfo {\n+    BASE_DATA(\n+            \"BaseData\",\n+            Icon.BASE_DATA,\n+            \"Primary Storage\",\n+            \"Primary storage is stores the data of all records.\"),\n+    INDEX_DATA(\n+            \"IndexData\",\n+            Icon.INDEX_DATA,\n+            \"Index\",\n+            \"An index is a data structure that is created based on a user-supplied ordering that enables index scans.\"),\n+    TEMPORARY_BUFFER_DATA(\n+            \"TempBufferData\",\n+            Icon.IN_MEMORY_TEMPORARY_DATA,\n+            \"Temporary Buffer\",\n+            \"A temporary buffer is an in-memory temporary data structure storing records to a certain limit.\"),\n+    VALUES_DATA(\n+            \"ValuesData\",\n+            Icon.IN_MEMORY_TEMPORARY_DATA,\n+            \"Values\",\n+            \"A list of values as specified.\"),\n+    COVERING_INDEX_SCAN_OPERATOR(\n+            \"CoveringIndexScanOperator\",\n+            Icon.DATA_ACCESS_OPERATOR,\n+            \"Covering Index Scan\",\n+            \"A covering index scan operator uses a secondary index to quickly find records in a given search range without looking up the base record.\"),\n+    INDEX_SCAN_OPERATOR(\n+            \"IndexScanOperator\",\n+            Icon.DATA_ACCESS_OPERATOR,\n+            \"Index Scan\",\n+            \"An index scan operator uses a secondary index to quickly find records in the index within a given search range.\"),\n+    INTERSECTION_OPERATOR(\n+            \"IntersectionOperator\",\n+            Icon.COMPUTATION_OPERATOR,\n+            \"Intersection\",\n+            \"An intersection operator processes its inputs in a common order and only returns those records that appear in all inputs.\"),\n+    NESTED_LOOP_JOIN_OPERATOR(\n+            \"NestedLoopJoinOperator\",\n+            Icon.COMPUTATION_OPERATOR,\n+            \"Nested Loop Join\",\n+            \"A nested loop join operator performs a relational join between its two input operands by reevaluating the right (inner) side for each left (outer) record.\"),\n+    LOAD_BY_KEYS_OPERATOR(\n+            \"LoadByKeysOperator\",\n+            Icon.DATA_ACCESS_OPERATOR,\n+            \"Load By Keys\",\n+            \"A load by keys operator loads records from the database that match the set of given keys.\"),\n+    PREDICATE_FILTER_OPERATOR(\n+            \"PredicateFilterOperator\",\n+            Icon.COMPUTATION_OPERATOR,\n+            \"Predicate Filter\",\n+            \"A predicate filter operator processes the input and returns only those records for which the predicate expression is true.\"),\n+    SCAN_OPERATOR(\n+            \"ScanOperator\",\n+            Icon.DATA_ACCESS_OPERATOR,\n+            \"Scan\",\n+            \"A scan operator loads a set of records from the database that are within the given range of primary keys.\"),\n+    SCORE_FOR_RANK_OPERATOR(\n+            \"ScoreForRankOperator\",\n+            Icon.DATA_ACCESS_OPERATOR,\n+            \"Score For Rank\",\n+            \"A score for rank operator converts ranks to scores and executes its input plan with the conversion results bound in named parameters.\"),\n+    TABLE_FUNCTION_OPERATOR(\n+            \"TableFunctionOperator\",\n+            Icon.COMPUTATION_OPERATOR,\n+            \"Table Function\",\n+            \"A table function operator returns a table of records each time it is evaluated with a set of arguments that are specific to each individual table function.\"),\n+    TEXT_INDEX_SCAN_OPERATOR(\n+            \"TextIndexScanOperator\",\n+            Icon.DATA_ACCESS_OPERATOR,\n+            \"Text Index Scan\",\n+            \"A text index scan operator uses a text index to quickly find records in the index for a set of given tokens.\"),\n+    TYPE_FILTER_OPERATOR(\n+            \"TypeFilterOperator\",\n+            Icon.COMPUTATION_OPERATOR,\n+            \"Type Filter\",\n+            \"A type filter operator processes the input and returns only those records for whose type is among the set of given types.\"),\n+    UNION_OPERATOR(\n+            \"UnionOperator\",\n+            Icon.COMPUTATION_OPERATOR,\n+            \"Union Distinct\",\n+            \"A union distinct operator processes its two or more inputs and returns the unioned set of all input records (all records are distinct). This operator needs all inputs to be compatibly ordered.\"),\n+    UNORDERED_DISTINCT_OPERATOR(\n+            \"UnorderedDistinct\",\n+            Icon.COMPUTATION_OPERATOR,\n+            \"Unordered Distinct\",\n+            \"An unordered distinct operator processes its input records and returns the set of distinct records. It does not require its input records to be ordered but does impose a memory overhead as it needs to track records it has already encountered.\"),\n+    UNORDERED_PRIMARY_KEY_DISTINCT_OPERATOR(\n+            \"UnorderedPrimaryKeyDistinct\",\n+            Icon.COMPUTATION_OPERATOR,\n+            \"Unordered Primary Key Distinct\",\n+            \"An unordered primary key distinct operator processes its input records and returns the set of distinct records. It does not require its input records to be ordered but does impose a memory overhead as it needs to track primary keys of records it has already encountered.\"),\n+    UNORDERED_UNION_OPERATOR(\n+            \"UnorderedUnionOperator\",\n+            Icon.COMPUTATION_OPERATOR,\n+            \"Union All\",\n+            \"A union all operator processes its two or more inputs and returns the unioned multiset of all input records (duplicates are preserved). The operator does not required its inputs to be compatible ordered.\");\n+\n+    /**\n+     * Icon Ids. Do not change!\n+     */\n+    public enum Icon {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ba09399588c0493bbed69b94f99408a9f8294c22"}, "originalPosition": 132}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTIwNjM0NA==", "bodyText": "I think that the covering index plan should basically look like an index plan, but with a different operator name, rather than having  regular index plan as a child, even though that's how it's implemented.", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/971#discussion_r441206344", "createdAt": "2020-06-17T00:00:33Z", "author": {"login": "nschiefer"}, "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/plans/RecordQueryCoveringIndexPlan.java", "diffHunk": "@@ -193,4 +195,14 @@ public int planHash() {\n     public List<? extends Quantifier> getQuantifiers() {\n         return ImmutableList.of();\n     }\n+\n+    @Nonnull\n+    @Override\n+    public PlannerGraph rewritePlannerGraph(@Nonnull final List<? extends PlannerGraph> childGraphs) {\n+        final PlannerGraph indexPlannerGraph = indexPlan.rewritePlannerGraph(childGraphs);\n+        return PlannerGraph.fromNodeAndChildGraphs(\n+                new PlannerGraph.OperatorNodeWithInfo(this,\n+                        NodeInfo.COVERING_INDEX_SCAN_OPERATOR),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ba09399588c0493bbed69b94f99408a9f8294c22"}, "originalPosition": 20}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTIwNzQ2MQ==", "bodyText": "I think that it is more idiomatic in the Record Layer to return a nullable TupleRange rather than a non null Optional<TupleRange>. With IntelliJ's inspections, we don't even lose the static analysis.", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/971#discussion_r441207461", "createdAt": "2020-06-17T00:04:34Z", "author": {"login": "nschiefer"}, "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/plans/RecordQueryIndexPlan.java", "diffHunk": "@@ -182,14 +186,12 @@ protected void appendScanDetails(StringBuilder str) {\n     }\n \n     @Nonnull\n-    private String getRange() {\n-        String range;\n+    private Optional<TupleRange> getTupleRangeOptional() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ba09399588c0493bbed69b94f99408a9f8294c22"}, "originalPosition": 46}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTIwNzY1NQ==", "bodyText": "I think this should probably be -\u221e or something like that. Alternatively, we could use literals like \"start of range\" or \"end of range\" or something like that.", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/971#discussion_r441207655", "createdAt": "2020-06-17T00:05:21Z", "author": {"login": "nschiefer"}, "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/plans/RecordQueryIndexPlan.java", "diffHunk": "@@ -206,14 +208,39 @@ public int getComplexity() {\n     @Nonnull\n     @Override\n     public PlannerGraph rewritePlannerGraph(@Nonnull final List<? extends PlannerGraph> childGraphs) {\n-        final PlannerGraph.Node root =\n-                new PlannerGraph.Node(this,\n-                        getClass().getSimpleName(),\n-                        getRange() + \"; \" + (scanType == IndexScanType.BY_VALUE ? scanType : \"\") + \"; \" + (reverse ? \"reverse\" : \"\"));\n-        final PlannerGraph.SourceNode source = new PlannerGraph.SourceNode(getIndexName());\n-        return PlannerGraph.builder(root)\n-                .addNode(source)\n-                .addEdge(source, root, new PlannerGraph.Edge())\n-                .build();\n+        final Optional<TupleRange> tupleRangeOptional = getTupleRangeOptional();\n+\n+        final ImmutableList.Builder<String> detailsBuilder = ImmutableList.builder();\n+        final ImmutableMap.Builder<String, Attribute> additionalAttributes = ImmutableMap.builder();\n+\n+        if (scanType != IndexScanType.BY_VALUE) {\n+            detailsBuilder.add(\"scanType: {{scanType}}\");\n+            additionalAttributes.put(\"scanType\", Attribute.gml(scanType.toString()));\n+        }\n+\n+        if (tupleRangeOptional.isPresent()) {\n+            final TupleRange tupleRange = tupleRangeOptional.get();\n+            detailsBuilder.add(\"range: \" + tupleRange.getLowEndpoint().toString(false) + \"{{low}}, {{high}}\" + tupleRange.getHighEndpoint().toString(true));\n+            additionalAttributes.put(\"low\", Attribute.gml(tupleRange.getLow() == null ? \"\u221e\" : tupleRange.getLow().toString()));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ba09399588c0493bbed69b94f99408a9f8294c22"}, "originalPosition": 84}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTIwODAwMg==", "bodyText": "As you know, this isn't my favorite representation of index scans. I would prefer to think of an index scan as a single operator with the index name as an attribute, like the predicate for a predicate filter.\nI'm happy to merge this for now and continue this discussion another time, though. Can you create an issue to track it?", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/971#discussion_r441208002", "createdAt": "2020-06-17T00:06:35Z", "author": {"login": "nschiefer"}, "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/plans/RecordQueryIndexPlan.java", "diffHunk": "@@ -206,14 +208,39 @@ public int getComplexity() {\n     @Nonnull\n     @Override\n     public PlannerGraph rewritePlannerGraph(@Nonnull final List<? extends PlannerGraph> childGraphs) {\n-        final PlannerGraph.Node root =\n-                new PlannerGraph.Node(this,\n-                        getClass().getSimpleName(),\n-                        getRange() + \"; \" + (scanType == IndexScanType.BY_VALUE ? scanType : \"\") + \"; \" + (reverse ? \"reverse\" : \"\"));\n-        final PlannerGraph.SourceNode source = new PlannerGraph.SourceNode(getIndexName());\n-        return PlannerGraph.builder(root)\n-                .addNode(source)\n-                .addEdge(source, root, new PlannerGraph.Edge())\n-                .build();\n+        final Optional<TupleRange> tupleRangeOptional = getTupleRangeOptional();\n+\n+        final ImmutableList.Builder<String> detailsBuilder = ImmutableList.builder();\n+        final ImmutableMap.Builder<String, Attribute> additionalAttributes = ImmutableMap.builder();\n+\n+        if (scanType != IndexScanType.BY_VALUE) {\n+            detailsBuilder.add(\"scanType: {{scanType}}\");\n+            additionalAttributes.put(\"scanType\", Attribute.gml(scanType.toString()));\n+        }\n+\n+        if (tupleRangeOptional.isPresent()) {\n+            final TupleRange tupleRange = tupleRangeOptional.get();\n+            detailsBuilder.add(\"range: \" + tupleRange.getLowEndpoint().toString(false) + \"{{low}}, {{high}}\" + tupleRange.getHighEndpoint().toString(true));\n+            additionalAttributes.put(\"low\", Attribute.gml(tupleRange.getLow() == null ? \"\u221e\" : tupleRange.getLow().toString()));\n+            additionalAttributes.put(\"high\", Attribute.gml(tupleRange.getHigh() == null ? \"\u221e\" : tupleRange.getHigh().toString()));\n+        } else {\n+            detailsBuilder.add(\"comparisons: {{comparisons}}\");\n+            additionalAttributes.put(\"comparisons\", Attribute.gml(comparisons.toString()));\n+        }\n+\n+        if (reverse) {\n+            detailsBuilder.add(\"direction: {{direction}}\");\n+            additionalAttributes.put(\"direction\", Attribute.gml(\"reversed\"));\n+        }\n+\n+        return PlannerGraph.fromNodeAndChildGraphs(\n+                new PlannerGraph.OperatorNodeWithInfo(this,\n+                        NodeInfo.INDEX_SCAN_OPERATOR,\n+                        detailsBuilder.build(),\n+                        additionalAttributes.build()),\n+                ImmutableList.of(\n+                        PlannerGraph.fromNodeAndChildGraphs(\n+                                new PlannerGraph.DataNodeWithInfo(NodeInfo.INDEX_DATA, ImmutableList.copyOf(getUsedIndexes())),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ba09399588c0493bbed69b94f99408a9f8294c22"}, "originalPosition": 103}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTIwODM2NA==", "bodyText": "I think that all of the implementations of RecordQueryPlanWithIndex override this method, so we can delete the default implementation on this interface.", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/971#discussion_r441208364", "createdAt": "2020-06-17T00:07:47Z", "author": {"login": "nschiefer"}, "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/plans/RecordQueryPlanWithIndex.java", "diffHunk": "@@ -84,10 +85,10 @@\n     @Override\n     default PlannerGraph rewritePlannerGraph(@Nonnull final List<? extends PlannerGraph> childGraphs) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ba09399588c0493bbed69b94f99408a9f8294c22"}, "originalPosition": 22}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTIwODc5OA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * Please use the overloaded constructor {@link #RecordQueryScanPlan(Set, ScanComparisons, boolean)}\n          \n          \n            \n                 * Use the overloaded constructor {@link #RecordQueryScanPlan(Set, ScanComparisons, boolean)}", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/971#discussion_r441208798", "createdAt": "2020-06-17T00:09:28Z", "author": {"login": "nschiefer"}, "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/plans/RecordQueryScanPlan.java", "diffHunk": "@@ -32,28 +32,55 @@\n import com.apple.foundationdb.record.query.expressions.Comparisons;\n import com.apple.foundationdb.record.query.plan.ScanComparisons;\n import com.apple.foundationdb.record.query.plan.temp.RelationalExpression;\n+import com.apple.foundationdb.record.query.plan.temp.explain.Attribute;\n+import com.apple.foundationdb.record.query.plan.temp.explain.NodeInfo;\n import com.apple.foundationdb.record.query.plan.temp.explain.PlannerGraph;\n import com.apple.foundationdb.record.query.plan.temp.explain.PlannerGraphRewritable;\n import com.google.common.base.Verify;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.ImmutableSet;\n import com.google.protobuf.Message;\n \n import javax.annotation.Nonnull;\n import javax.annotation.Nullable;\n import java.util.HashSet;\n import java.util.List;\n import java.util.Objects;\n+import java.util.Optional;\n import java.util.Set;\n \n /**\n  * A query plan that scans records directly from the main tree within a range of primary keys.\n  */\n @API(API.Status.MAINTAINED)\n public class RecordQueryScanPlan implements RecordQueryPlanWithNoChildren, RecordQueryPlanWithComparisons, PlannerGraphRewritable {\n+    @Nullable\n+    private final Set<String> recordTypes;\n+\n     @Nonnull\n     private final ScanComparisons comparisons;\n     private boolean reverse;\n \n+    /**\n+     * Overloaded constructor.\n+     * Please use the overloaded constructor {@link #RecordQueryScanPlan(Set, ScanComparisons, boolean)}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ba09399588c0493bbed69b94f99408a9f8294c22"}, "originalPosition": 36}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTIwODkyNQ==", "bodyText": "Same comment about using a nullable TupleRange instead of an Optional<TupleRange>.", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/971#discussion_r441208925", "createdAt": "2020-06-17T00:09:55Z", "author": {"login": "nschiefer"}, "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/plans/RecordQueryScanPlan.java", "diffHunk": "@@ -112,20 +144,17 @@ public boolean hasLoadBykeys() {\n     @Nonnull\n     @Override\n     public String toString() {\n-        String range;\n-        range = getRange();\n+        final String range = getTupleRangeOptional().map(TupleRange::toString).orElse(comparisons.toString());\n         return \"Scan(\" + range + \")\";\n     }\n \n     @Nonnull\n-    private String getRange() {\n-        String range;\n+    private Optional<TupleRange> getTupleRangeOptional() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ba09399588c0493bbed69b94f99408a9f8294c22"}, "originalPosition": 81}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTIwOTA1Ng==", "bodyText": "Same comment about -\u221e or using a different representation.", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/971#discussion_r441209056", "createdAt": "2020-06-17T00:10:25Z", "author": {"login": "nschiefer"}, "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/plans/RecordQueryScanPlan.java", "diffHunk": "@@ -173,16 +203,50 @@ public int getComplexity() {\n      * @return the rewritten planner graph that models scanned storage as a separate node that is connected to the\n      *         actual scan plan node.\n      */\n+    @SuppressWarnings(\"UnstableApiUsage\")\n     @Nonnull\n     @Override\n     public PlannerGraph rewritePlannerGraph(@Nonnull List<? extends PlannerGraph> childGraphs) {\n         Verify.verify(childGraphs.isEmpty());\n-        final PlannerGraph.Node root = new PlannerGraph.Node(this,\n-                getClass().getSimpleName());\n-        final PlannerGraph.SourceNode source = new PlannerGraph.SourceNode(getRange());\n-        return PlannerGraph.builder(root)\n-                .addNode(source)\n-                .addEdge(source, root, new PlannerGraph.Edge())\n-                .build();\n+\n+        final Optional<TupleRange> tupleRangeOptional = getTupleRangeOptional();\n+\n+        final ImmutableList.Builder<String> detailsBuilder = ImmutableList.builder();\n+        final ImmutableMap.Builder<String, Attribute> additionalAttributes = ImmutableMap.builder();\n+\n+        if (tupleRangeOptional.isPresent()) {\n+            final TupleRange tupleRange = tupleRangeOptional.get();\n+            detailsBuilder.add(\"range: \" + tupleRange.getLowEndpoint().toString(false) + \"{{low}}, {{high}}\" + tupleRange.getHighEndpoint().toString(true));\n+            additionalAttributes.put(\"low\", Attribute.gml(tupleRange.getLow() == null ? \"\u221e\" : tupleRange.getLow().toString()));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ba09399588c0493bbed69b94f99408a9f8294c22"}, "originalPosition": 136}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTIwOTI1NQ==", "bodyText": "This tuple range handling code seems to be the same as the code for the index range scans (which makes sense, since they use the same implementation). Could you pull this out into a utility method (possibly on ScanComparisons)?", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/971#discussion_r441209255", "createdAt": "2020-06-17T00:11:09Z", "author": {"login": "nschiefer"}, "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/plans/RecordQueryScanPlan.java", "diffHunk": "@@ -173,16 +203,50 @@ public int getComplexity() {\n      * @return the rewritten planner graph that models scanned storage as a separate node that is connected to the\n      *         actual scan plan node.\n      */\n+    @SuppressWarnings(\"UnstableApiUsage\")\n     @Nonnull\n     @Override\n     public PlannerGraph rewritePlannerGraph(@Nonnull List<? extends PlannerGraph> childGraphs) {\n         Verify.verify(childGraphs.isEmpty());\n-        final PlannerGraph.Node root = new PlannerGraph.Node(this,\n-                getClass().getSimpleName());\n-        final PlannerGraph.SourceNode source = new PlannerGraph.SourceNode(getRange());\n-        return PlannerGraph.builder(root)\n-                .addNode(source)\n-                .addEdge(source, root, new PlannerGraph.Edge())\n-                .build();\n+\n+        final Optional<TupleRange> tupleRangeOptional = getTupleRangeOptional();\n+\n+        final ImmutableList.Builder<String> detailsBuilder = ImmutableList.builder();\n+        final ImmutableMap.Builder<String, Attribute> additionalAttributes = ImmutableMap.builder();\n+\n+        if (tupleRangeOptional.isPresent()) {\n+            final TupleRange tupleRange = tupleRangeOptional.get();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ba09399588c0493bbed69b94f99408a9f8294c22"}, "originalPosition": 134}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTIwOTQyOQ==", "bodyText": "This is really messy but I think it's the best we can do with the current text scan plan. This will be much better someday :-)", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/971#discussion_r441209429", "createdAt": "2020-06-17T00:11:45Z", "author": {"login": "nschiefer"}, "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/plans/RecordQueryTextIndexPlan.java", "diffHunk": "@@ -162,4 +168,40 @@ public int planHash() {\n     public String toString() {\n         return \"TextIndex(\" + textScan.getIndex().getName() + \" \" + textScan.getGroupingComparisons() + \", \" + textScan.getTextComparison() + \", \" + textScan.getSuffixComparisons() + \")\";\n     }\n+\n+    /**\n+     * Rewrite the planner graph for better visualization of a query index plan.\n+     * @param childGraphs planner graphs of children expression that already have been computed\n+     * @return the rewritten planner graph that models the index as a separate node that is connected to the\n+     *         actual index scan plan node.\n+     */\n+    @Nonnull\n+    @Override\n+    public PlannerGraph rewritePlannerGraph(@Nonnull final List<? extends PlannerGraph> childGraphs) {\n+        final ImmutableMap.Builder<String, Attribute> additionalAttributesBuilder = ImmutableMap.builder();\n+        if (textScan.getGroupingComparisons() != null) {\n+            additionalAttributesBuilder.put(\"groupingComparisons\", Attribute.gml(Objects.requireNonNull(textScan.getGroupingComparisons()).toString()));\n+        } else {\n+            additionalAttributesBuilder.put(\"groupingComparisons\", Attribute.gml(\"none\"));\n+        }\n+        if (textScan.getSuffixComparisons() != null) {\n+            additionalAttributesBuilder.put(\"suffixComparisons\", Attribute.gml(Objects.requireNonNull(textScan.getSuffixComparisons()).toString()));\n+        } else {\n+            additionalAttributesBuilder.put(\"suffixComparisons\", Attribute.gml(\"none\"));\n+        }\n+        additionalAttributesBuilder.put(\"textComparisons\", Attribute.gml(Objects.requireNonNull(textScan.getTextComparison()).toString()));\n+\n+        final PlannerGraph.Node root =\n+                new PlannerGraph.OperatorNodeWithInfo(this,\n+                        NodeInfo.TEXT_INDEX_SCAN_OPERATOR,\n+                        ImmutableList.of(\"grouping comparisons: {{groupingComparisons}}\",\n+                                \"text comparisons: {{textComparisons}}\",\n+                                \"suffix comparisons: {{suffixComparisons}}\"),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ba09399588c0493bbed69b94f99408a9f8294c22"}, "originalPosition": 50}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTIwOTc4OA==", "bodyText": "I think that this operator needs to include the comparisonKey, which is what's used to determine distinctness.\nFor now, we can just use KeyExpression.toString() for that.", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/971#discussion_r441209788", "createdAt": "2020-06-17T00:13:00Z", "author": {"login": "nschiefer"}, "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/plans/RecordQueryUnorderedDistinctPlan.java", "diffHunk": "@@ -159,4 +161,12 @@ public void logPlanStructure(StoreTimer timer) {\n     public int getComplexity() {\n         return 1 + getInner().getComplexity();\n     }\n+\n+    @Nonnull\n+    @Override\n+    public PlannerGraph rewritePlannerGraph(@Nonnull final List<? extends PlannerGraph> childGraphs) {\n+        return PlannerGraph.fromNodeAndChildGraphs(\n+                new PlannerGraph.OperatorNodeWithInfo(this, NodeInfo.UNORDERED_DISTINCT_OPERATOR),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ba09399588c0493bbed69b94f99408a9f8294c22"}, "originalPosition": 18}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTIxMDAxMw==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                     * @param identity identity object this node should assume. Two nodes in the graph are considered equal if their\n          \n          \n            \n                     * @param identity object identifying this node. Two nodes in the graph are considered equal if and only if their", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/971#discussion_r441210013", "createdAt": "2020-06-17T00:13:53Z", "author": {"login": "nschiefer"}, "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/explain/AbstractPlannerGraph.java", "diffHunk": "@@ -145,17 +147,29 @@ public N getRoot() {\n         @Nonnull\n         final String name;\n         @Nullable\n-        final String expression;\n+        final List<String> details;\n \n         @SuppressWarnings(\"unused\") // used in clients\n         public AbstractNode(final Object identity, final String name) {\n             this(identity, name, null);\n         }\n \n-        public AbstractNode(final Object identity, final String name, @Nullable final String expression) {\n+        /**\n+         * Overloaded constructor.\n+         * @param identity identity object this node should assume. Two nodes in the graph are considered equal if their", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ba09399588c0493bbed69b94f99408a9f8294c22"}, "originalPosition": 40}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTIxMDA5NQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                     *        identity is equal (using {@code ==})\n          \n          \n            \n                     *        identity is equal (using reference equality)", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/971#discussion_r441210095", "createdAt": "2020-06-17T00:14:11Z", "author": {"login": "nschiefer"}, "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/explain/AbstractPlannerGraph.java", "diffHunk": "@@ -145,17 +147,29 @@ public N getRoot() {\n         @Nonnull\n         final String name;\n         @Nullable\n-        final String expression;\n+        final List<String> details;\n \n         @SuppressWarnings(\"unused\") // used in clients\n         public AbstractNode(final Object identity, final String name) {\n             this(identity, name, null);\n         }\n \n-        public AbstractNode(final Object identity, final String name, @Nullable final String expression) {\n+        /**\n+         * Overloaded constructor.\n+         * @param identity identity object this node should assume. Two nodes in the graph are considered equal if their\n+         *        identity is equal (using {@code ==})", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ba09399588c0493bbed69b94f99408a9f8294c22"}, "originalPosition": 41}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTIxMDQ0OQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                     * @param details list of strings with auxiliary information about the node. These strings are used\n          \n          \n            \n                     *        to construct the label of the node depending on the exporter. This parameter is {@code Nullable}. If\n          \n          \n            \n                     *        null the exporter treats this object as absent, if empty it creates am empty list if the target format\n          \n          \n            \n                     *        supports lists.\n          \n          \n            \n                     * @param details list of strings with auxiliary information about the node. These strings are used\n          \n          \n            \n                     *        to construct the label of the node depending on the exporter. This parameter is {@code Nullable}. If\n          \n          \n            \n                     *        null, the label is omitted. If empty, it creates an empty list if the target format supports lists.", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/971#discussion_r441210449", "createdAt": "2020-06-17T00:15:23Z", "author": {"login": "nschiefer"}, "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/explain/AbstractPlannerGraph.java", "diffHunk": "@@ -145,17 +147,29 @@ public N getRoot() {\n         @Nonnull\n         final String name;\n         @Nullable\n-        final String expression;\n+        final List<String> details;\n \n         @SuppressWarnings(\"unused\") // used in clients\n         public AbstractNode(final Object identity, final String name) {\n             this(identity, name, null);\n         }\n \n-        public AbstractNode(final Object identity, final String name, @Nullable final String expression) {\n+        /**\n+         * Overloaded constructor.\n+         * @param identity identity object this node should assume. Two nodes in the graph are considered equal if their\n+         *        identity is equal (using {@code ==})\n+         * @param name name of the object to be used to construct the label that is displayed\n+         * @param details list of strings with auxiliary information about the node. These strings are used\n+         *        to construct the label of the node depending on the exporter. This parameter is {@code Nullable}. If\n+         *        null the exporter treats this object as absent, if empty it creates am empty list if the target format\n+         *        supports lists.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ba09399588c0493bbed69b94f99408a9f8294c22"}, "originalPosition": 46}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTIxMDY1OA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    public AbstractNode(final Object identity, final String name, @Nullable final List<String> details) {\n          \n          \n            \n                    public AbstractNode(@Nonnull final Object identity, @Nonnull final String name, @Nullable final List<String> details) {", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/971#discussion_r441210658", "createdAt": "2020-06-17T00:16:11Z", "author": {"login": "nschiefer"}, "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/explain/AbstractPlannerGraph.java", "diffHunk": "@@ -145,17 +147,29 @@ public N getRoot() {\n         @Nonnull\n         final String name;\n         @Nullable\n-        final String expression;\n+        final List<String> details;\n \n         @SuppressWarnings(\"unused\") // used in clients\n         public AbstractNode(final Object identity, final String name) {\n             this(identity, name, null);\n         }\n \n-        public AbstractNode(final Object identity, final String name, @Nullable final String expression) {\n+        /**\n+         * Overloaded constructor.\n+         * @param identity identity object this node should assume. Two nodes in the graph are considered equal if their\n+         *        identity is equal (using {@code ==})\n+         * @param name name of the object to be used to construct the label that is displayed\n+         * @param details list of strings with auxiliary information about the node. These strings are used\n+         *        to construct the label of the node depending on the exporter. This parameter is {@code Nullable}. If\n+         *        null the exporter treats this object as absent, if empty it creates am empty list if the target format\n+         *        supports lists.\n+         */\n+        public AbstractNode(final Object identity, final String name, @Nullable final List<String> details) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ba09399588c0493bbed69b94f99408a9f8294c22"}, "originalPosition": 48}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTIxMDgxMA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * as well as {@link AbstractPlannerGraph.AbstractEdge} that are use to serialize to gml.\n          \n          \n            \n                 * as well as {@link AbstractPlannerGraph.AbstractEdge} that are use to serialize to GML.", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/971#discussion_r441210810", "createdAt": "2020-06-17T00:16:50Z", "author": {"login": "nschiefer"}, "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/explain/Attribute.java", "diffHunk": "@@ -21,42 +21,150 @@\n package com.apple.foundationdb.record.query.plan.temp.explain;\n \n import javax.annotation.Nonnull;\n-import javax.annotation.Nullable;\n-import java.util.Objects;\n \n /**\n- * Basic class for all attributes of {@link AbstractPlannerGraph.AbstractNode}\n+ * Basic interface for all attributes of {@link AbstractPlannerGraph.AbstractNode}\n  * as well as {@link AbstractPlannerGraph.AbstractEdge}.\n  *\n  * Represents a tag object that annotates an {@link AbstractPlannerGraph.AbstractNode} or an\n  * {@link AbstractPlannerGraph.AbstractEdge}, providing additional information to a {@link GraphExporter}.\n  */\n-public abstract class Attribute {\n+public interface Attribute {\n+    /**\n+     * Returns whether this method is visible in the given context.\n+     * @param context the exporter context of the exporter being used\n+     * @param <N> node type\n+     * @param <E> edge type\n+     * @return {@code true} if the attribute is semantic, {@code false} otherwise.\n+     */\n+    <N, E> boolean isVisible(GraphExporter<N, E>.ExporterContext context);\n+\n+    /**\n+     * Return the underlying object this attribute refers to.\n+     * @return the object.\n+     */\n     @Nonnull\n-    private final Object reference;\n+    Object getReference();\n+\n+    /**\n+     * Basic interface all attributes of {@link AbstractPlannerGraph.AbstractNode}\n+     * as well as {@link AbstractPlannerGraph.AbstractEdge} that are use to serialize to gml.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ba09399588c0493bbed69b94f99408a9f8294c22"}, "originalPosition": 36}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTIxMTIyMw==", "bodyText": "Is there a reason that these are all anonymous classes, rather than instantiations of some simple implementation class. If this sits on a hot code path, I think that the performance differences might matter?", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/971#discussion_r441211223", "createdAt": "2020-06-17T00:18:23Z", "author": {"login": "nschiefer"}, "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/explain/Attribute.java", "diffHunk": "@@ -21,42 +21,150 @@\n package com.apple.foundationdb.record.query.plan.temp.explain;\n \n import javax.annotation.Nonnull;\n-import javax.annotation.Nullable;\n-import java.util.Objects;\n \n /**\n- * Basic class for all attributes of {@link AbstractPlannerGraph.AbstractNode}\n+ * Basic interface for all attributes of {@link AbstractPlannerGraph.AbstractNode}\n  * as well as {@link AbstractPlannerGraph.AbstractEdge}.\n  *\n  * Represents a tag object that annotates an {@link AbstractPlannerGraph.AbstractNode} or an\n  * {@link AbstractPlannerGraph.AbstractEdge}, providing additional information to a {@link GraphExporter}.\n  */\n-public abstract class Attribute {\n+public interface Attribute {\n+    /**\n+     * Returns whether this method is visible in the given context.\n+     * @param context the exporter context of the exporter being used\n+     * @param <N> node type\n+     * @param <E> edge type\n+     * @return {@code true} if the attribute is semantic, {@code false} otherwise.\n+     */\n+    <N, E> boolean isVisible(GraphExporter<N, E>.ExporterContext context);\n+\n+    /**\n+     * Return the underlying object this attribute refers to.\n+     * @return the object.\n+     */\n     @Nonnull\n-    private final Object reference;\n+    Object getReference();\n+\n+    /**\n+     * Basic interface all attributes of {@link AbstractPlannerGraph.AbstractNode}\n+     * as well as {@link AbstractPlannerGraph.AbstractEdge} that are use to serialize to gml.\n+     */\n+    interface GmlAttribute extends Attribute {\n+        @Override\n+        default <N, E> boolean isVisible(GraphExporter<N, E>.ExporterContext context) {\n+            return context.getExporter() instanceof GmlExporter;\n+        }\n+    }\n \n-    protected Attribute(final Object reference) {\n-        this.reference = reference;\n+    /**\n+     * Interface for attributes of {@link AbstractPlannerGraph.AbstractNode}\n+     * as well as {@link AbstractPlannerGraph.AbstractEdge} that are used to serialize to dot.\n+     */\n+    interface DotAttribute extends Attribute {\n+        @Override\n+        default <N, E> boolean isVisible(GraphExporter<N, E>.ExporterContext context) {\n+            return context.getExporter() instanceof DotExporter;\n+        }\n     }\n \n     /**\n-     * Returns whether this method is semantic of it contains visual cues of other non-semantic information.\n-     *\n-     * @return {@code true} if the attribute is semantic, {@code false} otherwise.\n+     * Interface for attributes of {@link AbstractPlannerGraph.AbstractNode}\n+     * as well as {@link AbstractPlannerGraph.AbstractEdge} that are used to serialize to gml or to dot.\n      */\n-    public abstract boolean isSemanticAttribute();\n+    interface CommonAttribute extends GmlAttribute, DotAttribute {\n+        @Override\n+        default <N, E> boolean isVisible(GraphExporter<N, E>.ExporterContext context) {\n+            return true;\n+        }\n+    }\n \n     /**\n-     * Return the underlying object this attribute refers to.\n-     * @return the object.\n+     * Interface for attributes of {@link AbstractPlannerGraph.AbstractNode}\n+     * as well as {@link AbstractPlannerGraph.AbstractEdge} that are used to neither serialize to gml or to dot.\n+     * Attributes of this kind can only be referred to via variable substitution.\n      */\n-    @Nullable\n-    public Object getReference() {\n-        return reference;\n+    interface InvisibleAttribute extends GmlAttribute, DotAttribute {\n+        @Override\n+        default <N, E> boolean isVisible(GraphExporter<N, E>.ExporterContext context) {\n+            return false;\n+        }\n     }\n \n-    @Override\n-    public String toString() {\n-        return Objects.requireNonNull(reference).toString();\n+    /**\n+     * Static factory method to create a GML attribute based on a reference to some object.\n+     * @param reference the reference\n+     * @return a new attribute that is only visible to the GML exporter\n+     */\n+    static GmlAttribute gml(@Nonnull final Object reference) {\n+        return new GmlAttribute() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ba09399588c0493bbed69b94f99408a9f8294c22"}, "originalPosition": 99}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTIxMTMyOA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        // and expression by creating an html table\n          \n          \n            \n                        // and expression by creating an HTML table.", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/971#discussion_r441211328", "createdAt": "2020-06-17T00:18:48Z", "author": {"login": "nschiefer"}, "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/explain/DotExporter.java", "diffHunk": "@@ -243,16 +246,40 @@ protected void renderNode(final ExporterContext context, final N node, final Map\n         final PrintWriter out = context.getPrintWriter();\n         out.print(INDENT);\n         out.print(getVertexID(node));\n+\n+        out.print(\" [ \");\n+        @Nullable final String htmlLabel;\n+        if (attributes.get(\"label\") == null) {\n+            // We allow a node or edge to override the label; if it's not overridden we build it here from name\n+            // and expression by creating an html table", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ba09399588c0493bbed69b94f99408a9f8294c22"}, "originalPosition": 105}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTIxMTUwNQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private String substituteVariables(final String detail,\n          \n          \n            \n                                                   final Map<String, Attribute> nodeAttributes,\n          \n          \n            \n                                                   final Function<Attribute, String> toStringFn) {\n          \n          \n            \n                private String substituteVariables(@Nonnull final String detail,\n          \n          \n            \n                                                   @Nonnull final Map<String, Attribute> nodeAttributes,\n          \n          \n            \n                                                   @Nonnull final Function<Attribute, String> toStringFn) {", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/971#discussion_r441211505", "createdAt": "2020-06-17T00:19:27Z", "author": {"login": "nschiefer"}, "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/explain/DotExporter.java", "diffHunk": "@@ -303,48 +346,67 @@ protected void renderFooter(final ExporterContext context) {\n      */\n     private void renderAttributes(final ExporterContext context,\n                                   final Map<String, Attribute> attributes) {\n-        final PrintWriter out = context.getPrintWriter();\n-        out.print(\" [ \");\n-        @Nullable final String htmlLabel;\n-        if (attributes.get(\"label\") == null) {\n-            // We allow a node or edge to override the label; if it's not overridden we build it here from name\n-            // and expression by creating an html table\n-            @Nullable final Attribute name = attributes.get(\"name\");\n-            @Nullable final Attribute expression = attributes.get(\"expression\");\n-            htmlLabel = name == null\n-                        ? null\n-                        : getLabel(name, expression);\n-        } else {\n-            htmlLabel = getLabel(attributes.get(\"label\"));\n+        for (Map.Entry<String, Attribute> entry : attributes.entrySet()) {\n+            final Attribute value = entry.getValue();\n+            if (value.isVisible(context)) {\n+                renderAttribute(context, entry.getKey(), value, \" \");\n+            }\n         }\n+    }\n \n-        if (htmlLabel != null) {\n-            out.print(\"label=\");\n-            out.print(htmlLabel);\n-            out.print(\" \");\n+    @SuppressWarnings({\"squid:S3358\", \"unchecked\"})\n+    public String getNodeLabel(@Nonnull final Attribute name, final Attribute details, final Map<String, Attribute> nodeAttributes) {\n+        if (details == null || ((List<?>)details.getReference()).isEmpty()) {\n+            return \"<<table border=\\\"0\\\" cellborder=\\\"1\\\" cellspacing=\\\"0\\\" cellpadding=\\\"8\\\"><tr><td>\" +\n+                   escaper.escape(name.getReference().toString()) +\n+                   \"</td></tr></table>>\";\n         }\n \n-        for (Map.Entry<String, Attribute> entry : attributes.entrySet()) {\n-            final String key = entry.getKey();\n-            if (doNotRenderVerbatim.contains(key)) {\n-                // already handled by special case above\n-                continue;\n-            }\n-            renderAttribute(context, key, entry.getValue(), \" \");\n-        }\n-        out.print(\"]\");\n+        final String detailsString =\n+                ((List<?>)details.getReference())\n+                        .stream()\n+                        .map(Object::toString)\n+                        .map(escaper::escape)\n+                        .map(detail ->\n+                                substituteVariables(detail,\n+                                        nodeAttributes,\n+                                        attribute -> attribute == null\n+                                                     ? \"<b>undefined</b>\"\n+                                                     : (attribute.getReference() instanceof Collection)\n+                                                       ? escapeCollection((Collection<Attribute>)attribute.getReference())\n+                                                       : escaper.escape(attribute.getReference().toString())))\n+                        .map(detail -> \"<tr><td>\" + detail + \"</td></tr>\")\n+                        .collect(Collectors.joining());\n+\n+        return \"<<table border=\\\"0\\\" cellborder=\\\"1\\\" cellspacing=\\\"0\\\" cellpadding=\\\"8\\\"><tr><td>\" +\n+               escaper.escape(name.getReference().toString()) + \"</td></tr>\" +\n+               detailsString + \"</table>>\";\n+    }\n+\n+    private String escapeCollection(final Collection<Attribute> attributes) {\n+        return \"[\" + attributes.stream().map(a -> escaper.escape(a.toString())).collect(Collectors.joining(\", \")) + \"]\";\n     }\n \n-    public String getLabel(@Nonnull final Attribute name, final Attribute expression) {\n-        if (expression == null || expression.toString().isEmpty()) {\n-            return \"<<table border=\\\"0\\\" cellborder=\\\"1\\\" cellspacing=\\\"0\\\" cellpadding=\\\"8\\\"><tr><td>\" + name + \"</td></tr></table>>\";\n+    private String substituteVariables(final String detail,\n+                                       final Map<String, Attribute> nodeAttributes,\n+                                       final Function<Attribute, String> toStringFn) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ba09399588c0493bbed69b94f99408a9f8294c22"}, "originalPosition": 242}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTIxMTgyMg==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        \"Primary storage is stores the data of all records.\"),\n          \n          \n            \n                        \"Primary storage stores the data of all records.\"),", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/971#discussion_r441211822", "createdAt": "2020-06-17T00:20:31Z", "author": {"login": "nschiefer"}, "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/explain/NodeInfo.java", "diffHunk": "@@ -0,0 +1,191 @@\n+/*\n+ * NodeInfo.java\n+ *\n+ * This source file is part of the FoundationDB open source project\n+ *\n+ * Copyright 2015-2020 Apple Inc. and the FoundationDB project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.apple.foundationdb.record.query.plan.temp.explain;\n+\n+import com.google.common.collect.ImmutableMap;\n+\n+import javax.annotation.Nonnull;\n+import java.util.Arrays;\n+import java.util.Map;\n+\n+/**\n+ * Operator infos for all operators and storage objects in the record layer.\n+ */\n+public enum NodeInfo {\n+    BASE_DATA(\n+            \"BaseData\",\n+            Icon.BASE_DATA,\n+            \"Primary Storage\",\n+            \"Primary storage is stores the data of all records.\"),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ba09399588c0493bbed69b94f99408a9f8294c22"}, "originalPosition": 37}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTIxMjA0OA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        \"A temporary buffer is an in-memory temporary data structure storing records to a certain limit.\"),\n          \n          \n            \n                        \"A temporary buffer is a temporary, in-memory structure storing up to a fixed number of records.\"),", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/971#discussion_r441212048", "createdAt": "2020-06-17T00:21:23Z", "author": {"login": "nschiefer"}, "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/explain/NodeInfo.java", "diffHunk": "@@ -0,0 +1,191 @@\n+/*\n+ * NodeInfo.java\n+ *\n+ * This source file is part of the FoundationDB open source project\n+ *\n+ * Copyright 2015-2020 Apple Inc. and the FoundationDB project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.apple.foundationdb.record.query.plan.temp.explain;\n+\n+import com.google.common.collect.ImmutableMap;\n+\n+import javax.annotation.Nonnull;\n+import java.util.Arrays;\n+import java.util.Map;\n+\n+/**\n+ * Operator infos for all operators and storage objects in the record layer.\n+ */\n+public enum NodeInfo {\n+    BASE_DATA(\n+            \"BaseData\",\n+            Icon.BASE_DATA,\n+            \"Primary Storage\",\n+            \"Primary storage is stores the data of all records.\"),\n+    INDEX_DATA(\n+            \"IndexData\",\n+            Icon.INDEX_DATA,\n+            \"Index\",\n+            \"An index is a data structure that is created based on a user-supplied ordering that enables index scans.\"),\n+    TEMPORARY_BUFFER_DATA(\n+            \"TempBufferData\",\n+            Icon.IN_MEMORY_TEMPORARY_DATA,\n+            \"Temporary Buffer\",\n+            \"A temporary buffer is an in-memory temporary data structure storing records to a certain limit.\"),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ba09399588c0493bbed69b94f99408a9f8294c22"}, "originalPosition": 47}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTIxMjEzOA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        \"A list of values as specified.\"),\n          \n          \n            \n                        \"A constant list of values.\"),", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/971#discussion_r441212138", "createdAt": "2020-06-17T00:21:37Z", "author": {"login": "nschiefer"}, "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/explain/NodeInfo.java", "diffHunk": "@@ -0,0 +1,191 @@\n+/*\n+ * NodeInfo.java\n+ *\n+ * This source file is part of the FoundationDB open source project\n+ *\n+ * Copyright 2015-2020 Apple Inc. and the FoundationDB project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.apple.foundationdb.record.query.plan.temp.explain;\n+\n+import com.google.common.collect.ImmutableMap;\n+\n+import javax.annotation.Nonnull;\n+import java.util.Arrays;\n+import java.util.Map;\n+\n+/**\n+ * Operator infos for all operators and storage objects in the record layer.\n+ */\n+public enum NodeInfo {\n+    BASE_DATA(\n+            \"BaseData\",\n+            Icon.BASE_DATA,\n+            \"Primary Storage\",\n+            \"Primary storage is stores the data of all records.\"),\n+    INDEX_DATA(\n+            \"IndexData\",\n+            Icon.INDEX_DATA,\n+            \"Index\",\n+            \"An index is a data structure that is created based on a user-supplied ordering that enables index scans.\"),\n+    TEMPORARY_BUFFER_DATA(\n+            \"TempBufferData\",\n+            Icon.IN_MEMORY_TEMPORARY_DATA,\n+            \"Temporary Buffer\",\n+            \"A temporary buffer is an in-memory temporary data structure storing records to a certain limit.\"),\n+    VALUES_DATA(\n+            \"ValuesData\",\n+            Icon.IN_MEMORY_TEMPORARY_DATA,\n+            \"Values\",\n+            \"A list of values as specified.\"),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ba09399588c0493bbed69b94f99408a9f8294c22"}, "originalPosition": 52}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTIxMjIyMA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        \"A covering index scan operator uses a secondary index to quickly find records in a given search range without looking up the base record.\"),\n          \n          \n            \n                        \"A covering index scan operator uses a secondary index to quickly find records in a given search range without looking up the base records.\"),", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/971#discussion_r441212220", "createdAt": "2020-06-17T00:21:59Z", "author": {"login": "nschiefer"}, "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/explain/NodeInfo.java", "diffHunk": "@@ -0,0 +1,191 @@\n+/*\n+ * NodeInfo.java\n+ *\n+ * This source file is part of the FoundationDB open source project\n+ *\n+ * Copyright 2015-2020 Apple Inc. and the FoundationDB project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.apple.foundationdb.record.query.plan.temp.explain;\n+\n+import com.google.common.collect.ImmutableMap;\n+\n+import javax.annotation.Nonnull;\n+import java.util.Arrays;\n+import java.util.Map;\n+\n+/**\n+ * Operator infos for all operators and storage objects in the record layer.\n+ */\n+public enum NodeInfo {\n+    BASE_DATA(\n+            \"BaseData\",\n+            Icon.BASE_DATA,\n+            \"Primary Storage\",\n+            \"Primary storage is stores the data of all records.\"),\n+    INDEX_DATA(\n+            \"IndexData\",\n+            Icon.INDEX_DATA,\n+            \"Index\",\n+            \"An index is a data structure that is created based on a user-supplied ordering that enables index scans.\"),\n+    TEMPORARY_BUFFER_DATA(\n+            \"TempBufferData\",\n+            Icon.IN_MEMORY_TEMPORARY_DATA,\n+            \"Temporary Buffer\",\n+            \"A temporary buffer is an in-memory temporary data structure storing records to a certain limit.\"),\n+    VALUES_DATA(\n+            \"ValuesData\",\n+            Icon.IN_MEMORY_TEMPORARY_DATA,\n+            \"Values\",\n+            \"A list of values as specified.\"),\n+    COVERING_INDEX_SCAN_OPERATOR(\n+            \"CoveringIndexScanOperator\",\n+            Icon.DATA_ACCESS_OPERATOR,\n+            \"Covering Index Scan\",\n+            \"A covering index scan operator uses a secondary index to quickly find records in a given search range without looking up the base record.\"),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ba09399588c0493bbed69b94f99408a9f8294c22"}, "originalPosition": 57}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTIxMjQwOA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        \"A load by keys operator loads records from the database that match the set of given keys.\"),\n          \n          \n            \n                        \"A load by keys operator loads records from the database that match the given set of primary keys.\"),", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/971#discussion_r441212408", "createdAt": "2020-06-17T00:22:44Z", "author": {"login": "nschiefer"}, "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/explain/NodeInfo.java", "diffHunk": "@@ -0,0 +1,191 @@\n+/*\n+ * NodeInfo.java\n+ *\n+ * This source file is part of the FoundationDB open source project\n+ *\n+ * Copyright 2015-2020 Apple Inc. and the FoundationDB project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.apple.foundationdb.record.query.plan.temp.explain;\n+\n+import com.google.common.collect.ImmutableMap;\n+\n+import javax.annotation.Nonnull;\n+import java.util.Arrays;\n+import java.util.Map;\n+\n+/**\n+ * Operator infos for all operators and storage objects in the record layer.\n+ */\n+public enum NodeInfo {\n+    BASE_DATA(\n+            \"BaseData\",\n+            Icon.BASE_DATA,\n+            \"Primary Storage\",\n+            \"Primary storage is stores the data of all records.\"),\n+    INDEX_DATA(\n+            \"IndexData\",\n+            Icon.INDEX_DATA,\n+            \"Index\",\n+            \"An index is a data structure that is created based on a user-supplied ordering that enables index scans.\"),\n+    TEMPORARY_BUFFER_DATA(\n+            \"TempBufferData\",\n+            Icon.IN_MEMORY_TEMPORARY_DATA,\n+            \"Temporary Buffer\",\n+            \"A temporary buffer is an in-memory temporary data structure storing records to a certain limit.\"),\n+    VALUES_DATA(\n+            \"ValuesData\",\n+            Icon.IN_MEMORY_TEMPORARY_DATA,\n+            \"Values\",\n+            \"A list of values as specified.\"),\n+    COVERING_INDEX_SCAN_OPERATOR(\n+            \"CoveringIndexScanOperator\",\n+            Icon.DATA_ACCESS_OPERATOR,\n+            \"Covering Index Scan\",\n+            \"A covering index scan operator uses a secondary index to quickly find records in a given search range without looking up the base record.\"),\n+    INDEX_SCAN_OPERATOR(\n+            \"IndexScanOperator\",\n+            Icon.DATA_ACCESS_OPERATOR,\n+            \"Index Scan\",\n+            \"An index scan operator uses a secondary index to quickly find records in the index within a given search range.\"),\n+    INTERSECTION_OPERATOR(\n+            \"IntersectionOperator\",\n+            Icon.COMPUTATION_OPERATOR,\n+            \"Intersection\",\n+            \"An intersection operator processes its inputs in a common order and only returns those records that appear in all inputs.\"),\n+    NESTED_LOOP_JOIN_OPERATOR(\n+            \"NestedLoopJoinOperator\",\n+            Icon.COMPUTATION_OPERATOR,\n+            \"Nested Loop Join\",\n+            \"A nested loop join operator performs a relational join between its two input operands by reevaluating the right (inner) side for each left (outer) record.\"),\n+    LOAD_BY_KEYS_OPERATOR(\n+            \"LoadByKeysOperator\",\n+            Icon.DATA_ACCESS_OPERATOR,\n+            \"Load By Keys\",\n+            \"A load by keys operator loads records from the database that match the set of given keys.\"),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ba09399588c0493bbed69b94f99408a9f8294c22"}, "originalPosition": 77}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTIxMjY2OA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        \"A text index scan operator uses a text index to quickly find records in the index for a set of given tokens.\"),\n          \n          \n            \n                        \"A text index scan operator uses a text index to quickly find records in the index for the given full text predicate.\"),\n          \n      \n    \n    \n  \n\nsince our full text scans offer more than just \"find these tokens\".", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/971#discussion_r441212668", "createdAt": "2020-06-17T00:23:47Z", "author": {"login": "nschiefer"}, "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/explain/NodeInfo.java", "diffHunk": "@@ -0,0 +1,191 @@\n+/*\n+ * NodeInfo.java\n+ *\n+ * This source file is part of the FoundationDB open source project\n+ *\n+ * Copyright 2015-2020 Apple Inc. and the FoundationDB project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.apple.foundationdb.record.query.plan.temp.explain;\n+\n+import com.google.common.collect.ImmutableMap;\n+\n+import javax.annotation.Nonnull;\n+import java.util.Arrays;\n+import java.util.Map;\n+\n+/**\n+ * Operator infos for all operators and storage objects in the record layer.\n+ */\n+public enum NodeInfo {\n+    BASE_DATA(\n+            \"BaseData\",\n+            Icon.BASE_DATA,\n+            \"Primary Storage\",\n+            \"Primary storage is stores the data of all records.\"),\n+    INDEX_DATA(\n+            \"IndexData\",\n+            Icon.INDEX_DATA,\n+            \"Index\",\n+            \"An index is a data structure that is created based on a user-supplied ordering that enables index scans.\"),\n+    TEMPORARY_BUFFER_DATA(\n+            \"TempBufferData\",\n+            Icon.IN_MEMORY_TEMPORARY_DATA,\n+            \"Temporary Buffer\",\n+            \"A temporary buffer is an in-memory temporary data structure storing records to a certain limit.\"),\n+    VALUES_DATA(\n+            \"ValuesData\",\n+            Icon.IN_MEMORY_TEMPORARY_DATA,\n+            \"Values\",\n+            \"A list of values as specified.\"),\n+    COVERING_INDEX_SCAN_OPERATOR(\n+            \"CoveringIndexScanOperator\",\n+            Icon.DATA_ACCESS_OPERATOR,\n+            \"Covering Index Scan\",\n+            \"A covering index scan operator uses a secondary index to quickly find records in a given search range without looking up the base record.\"),\n+    INDEX_SCAN_OPERATOR(\n+            \"IndexScanOperator\",\n+            Icon.DATA_ACCESS_OPERATOR,\n+            \"Index Scan\",\n+            \"An index scan operator uses a secondary index to quickly find records in the index within a given search range.\"),\n+    INTERSECTION_OPERATOR(\n+            \"IntersectionOperator\",\n+            Icon.COMPUTATION_OPERATOR,\n+            \"Intersection\",\n+            \"An intersection operator processes its inputs in a common order and only returns those records that appear in all inputs.\"),\n+    NESTED_LOOP_JOIN_OPERATOR(\n+            \"NestedLoopJoinOperator\",\n+            Icon.COMPUTATION_OPERATOR,\n+            \"Nested Loop Join\",\n+            \"A nested loop join operator performs a relational join between its two input operands by reevaluating the right (inner) side for each left (outer) record.\"),\n+    LOAD_BY_KEYS_OPERATOR(\n+            \"LoadByKeysOperator\",\n+            Icon.DATA_ACCESS_OPERATOR,\n+            \"Load By Keys\",\n+            \"A load by keys operator loads records from the database that match the set of given keys.\"),\n+    PREDICATE_FILTER_OPERATOR(\n+            \"PredicateFilterOperator\",\n+            Icon.COMPUTATION_OPERATOR,\n+            \"Predicate Filter\",\n+            \"A predicate filter operator processes the input and returns only those records for which the predicate expression is true.\"),\n+    SCAN_OPERATOR(\n+            \"ScanOperator\",\n+            Icon.DATA_ACCESS_OPERATOR,\n+            \"Scan\",\n+            \"A scan operator loads a set of records from the database that are within the given range of primary keys.\"),\n+    SCORE_FOR_RANK_OPERATOR(\n+            \"ScoreForRankOperator\",\n+            Icon.DATA_ACCESS_OPERATOR,\n+            \"Score For Rank\",\n+            \"A score for rank operator converts ranks to scores and executes its input plan with the conversion results bound in named parameters.\"),\n+    TABLE_FUNCTION_OPERATOR(\n+            \"TableFunctionOperator\",\n+            Icon.COMPUTATION_OPERATOR,\n+            \"Table Function\",\n+            \"A table function operator returns a table of records each time it is evaluated with a set of arguments that are specific to each individual table function.\"),\n+    TEXT_INDEX_SCAN_OPERATOR(\n+            \"TextIndexScanOperator\",\n+            Icon.DATA_ACCESS_OPERATOR,\n+            \"Text Index Scan\",\n+            \"A text index scan operator uses a text index to quickly find records in the index for a set of given tokens.\"),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ba09399588c0493bbed69b94f99408a9f8294c22"}, "originalPosition": 102}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTIxMjc0NA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        \"A type filter operator processes the input and returns only those records for whose type is among the set of given types.\"),\n          \n          \n            \n                        \"A type filter operator processes the input and returns only those records for whose type is among the given set of types.\"),", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/971#discussion_r441212744", "createdAt": "2020-06-17T00:24:02Z", "author": {"login": "nschiefer"}, "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/explain/NodeInfo.java", "diffHunk": "@@ -0,0 +1,191 @@\n+/*\n+ * NodeInfo.java\n+ *\n+ * This source file is part of the FoundationDB open source project\n+ *\n+ * Copyright 2015-2020 Apple Inc. and the FoundationDB project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.apple.foundationdb.record.query.plan.temp.explain;\n+\n+import com.google.common.collect.ImmutableMap;\n+\n+import javax.annotation.Nonnull;\n+import java.util.Arrays;\n+import java.util.Map;\n+\n+/**\n+ * Operator infos for all operators and storage objects in the record layer.\n+ */\n+public enum NodeInfo {\n+    BASE_DATA(\n+            \"BaseData\",\n+            Icon.BASE_DATA,\n+            \"Primary Storage\",\n+            \"Primary storage is stores the data of all records.\"),\n+    INDEX_DATA(\n+            \"IndexData\",\n+            Icon.INDEX_DATA,\n+            \"Index\",\n+            \"An index is a data structure that is created based on a user-supplied ordering that enables index scans.\"),\n+    TEMPORARY_BUFFER_DATA(\n+            \"TempBufferData\",\n+            Icon.IN_MEMORY_TEMPORARY_DATA,\n+            \"Temporary Buffer\",\n+            \"A temporary buffer is an in-memory temporary data structure storing records to a certain limit.\"),\n+    VALUES_DATA(\n+            \"ValuesData\",\n+            Icon.IN_MEMORY_TEMPORARY_DATA,\n+            \"Values\",\n+            \"A list of values as specified.\"),\n+    COVERING_INDEX_SCAN_OPERATOR(\n+            \"CoveringIndexScanOperator\",\n+            Icon.DATA_ACCESS_OPERATOR,\n+            \"Covering Index Scan\",\n+            \"A covering index scan operator uses a secondary index to quickly find records in a given search range without looking up the base record.\"),\n+    INDEX_SCAN_OPERATOR(\n+            \"IndexScanOperator\",\n+            Icon.DATA_ACCESS_OPERATOR,\n+            \"Index Scan\",\n+            \"An index scan operator uses a secondary index to quickly find records in the index within a given search range.\"),\n+    INTERSECTION_OPERATOR(\n+            \"IntersectionOperator\",\n+            Icon.COMPUTATION_OPERATOR,\n+            \"Intersection\",\n+            \"An intersection operator processes its inputs in a common order and only returns those records that appear in all inputs.\"),\n+    NESTED_LOOP_JOIN_OPERATOR(\n+            \"NestedLoopJoinOperator\",\n+            Icon.COMPUTATION_OPERATOR,\n+            \"Nested Loop Join\",\n+            \"A nested loop join operator performs a relational join between its two input operands by reevaluating the right (inner) side for each left (outer) record.\"),\n+    LOAD_BY_KEYS_OPERATOR(\n+            \"LoadByKeysOperator\",\n+            Icon.DATA_ACCESS_OPERATOR,\n+            \"Load By Keys\",\n+            \"A load by keys operator loads records from the database that match the set of given keys.\"),\n+    PREDICATE_FILTER_OPERATOR(\n+            \"PredicateFilterOperator\",\n+            Icon.COMPUTATION_OPERATOR,\n+            \"Predicate Filter\",\n+            \"A predicate filter operator processes the input and returns only those records for which the predicate expression is true.\"),\n+    SCAN_OPERATOR(\n+            \"ScanOperator\",\n+            Icon.DATA_ACCESS_OPERATOR,\n+            \"Scan\",\n+            \"A scan operator loads a set of records from the database that are within the given range of primary keys.\"),\n+    SCORE_FOR_RANK_OPERATOR(\n+            \"ScoreForRankOperator\",\n+            Icon.DATA_ACCESS_OPERATOR,\n+            \"Score For Rank\",\n+            \"A score for rank operator converts ranks to scores and executes its input plan with the conversion results bound in named parameters.\"),\n+    TABLE_FUNCTION_OPERATOR(\n+            \"TableFunctionOperator\",\n+            Icon.COMPUTATION_OPERATOR,\n+            \"Table Function\",\n+            \"A table function operator returns a table of records each time it is evaluated with a set of arguments that are specific to each individual table function.\"),\n+    TEXT_INDEX_SCAN_OPERATOR(\n+            \"TextIndexScanOperator\",\n+            Icon.DATA_ACCESS_OPERATOR,\n+            \"Text Index Scan\",\n+            \"A text index scan operator uses a text index to quickly find records in the index for a set of given tokens.\"),\n+    TYPE_FILTER_OPERATOR(\n+            \"TypeFilterOperator\",\n+            Icon.COMPUTATION_OPERATOR,\n+            \"Type Filter\",\n+            \"A type filter operator processes the input and returns only those records for whose type is among the set of given types.\"),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ba09399588c0493bbed69b94f99408a9f8294c22"}, "originalPosition": 107}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTIxMzg1NA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        \"A union distinct operator processes its two or more inputs and returns the unioned set of all input records (all records are distinct). This operator needs all inputs to be compatibly ordered.\"),\n          \n          \n            \n                        \"An ordered union operator processes produces the set of all input records returned by its two or more inputs (all records are distinct). This operator needs all inputs to be compatibly ordered, and returns them in the same order.\"),", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/971#discussion_r441213854", "createdAt": "2020-06-17T00:28:03Z", "author": {"login": "nschiefer"}, "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/explain/NodeInfo.java", "diffHunk": "@@ -0,0 +1,191 @@\n+/*\n+ * NodeInfo.java\n+ *\n+ * This source file is part of the FoundationDB open source project\n+ *\n+ * Copyright 2015-2020 Apple Inc. and the FoundationDB project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.apple.foundationdb.record.query.plan.temp.explain;\n+\n+import com.google.common.collect.ImmutableMap;\n+\n+import javax.annotation.Nonnull;\n+import java.util.Arrays;\n+import java.util.Map;\n+\n+/**\n+ * Operator infos for all operators and storage objects in the record layer.\n+ */\n+public enum NodeInfo {\n+    BASE_DATA(\n+            \"BaseData\",\n+            Icon.BASE_DATA,\n+            \"Primary Storage\",\n+            \"Primary storage is stores the data of all records.\"),\n+    INDEX_DATA(\n+            \"IndexData\",\n+            Icon.INDEX_DATA,\n+            \"Index\",\n+            \"An index is a data structure that is created based on a user-supplied ordering that enables index scans.\"),\n+    TEMPORARY_BUFFER_DATA(\n+            \"TempBufferData\",\n+            Icon.IN_MEMORY_TEMPORARY_DATA,\n+            \"Temporary Buffer\",\n+            \"A temporary buffer is an in-memory temporary data structure storing records to a certain limit.\"),\n+    VALUES_DATA(\n+            \"ValuesData\",\n+            Icon.IN_MEMORY_TEMPORARY_DATA,\n+            \"Values\",\n+            \"A list of values as specified.\"),\n+    COVERING_INDEX_SCAN_OPERATOR(\n+            \"CoveringIndexScanOperator\",\n+            Icon.DATA_ACCESS_OPERATOR,\n+            \"Covering Index Scan\",\n+            \"A covering index scan operator uses a secondary index to quickly find records in a given search range without looking up the base record.\"),\n+    INDEX_SCAN_OPERATOR(\n+            \"IndexScanOperator\",\n+            Icon.DATA_ACCESS_OPERATOR,\n+            \"Index Scan\",\n+            \"An index scan operator uses a secondary index to quickly find records in the index within a given search range.\"),\n+    INTERSECTION_OPERATOR(\n+            \"IntersectionOperator\",\n+            Icon.COMPUTATION_OPERATOR,\n+            \"Intersection\",\n+            \"An intersection operator processes its inputs in a common order and only returns those records that appear in all inputs.\"),\n+    NESTED_LOOP_JOIN_OPERATOR(\n+            \"NestedLoopJoinOperator\",\n+            Icon.COMPUTATION_OPERATOR,\n+            \"Nested Loop Join\",\n+            \"A nested loop join operator performs a relational join between its two input operands by reevaluating the right (inner) side for each left (outer) record.\"),\n+    LOAD_BY_KEYS_OPERATOR(\n+            \"LoadByKeysOperator\",\n+            Icon.DATA_ACCESS_OPERATOR,\n+            \"Load By Keys\",\n+            \"A load by keys operator loads records from the database that match the set of given keys.\"),\n+    PREDICATE_FILTER_OPERATOR(\n+            \"PredicateFilterOperator\",\n+            Icon.COMPUTATION_OPERATOR,\n+            \"Predicate Filter\",\n+            \"A predicate filter operator processes the input and returns only those records for which the predicate expression is true.\"),\n+    SCAN_OPERATOR(\n+            \"ScanOperator\",\n+            Icon.DATA_ACCESS_OPERATOR,\n+            \"Scan\",\n+            \"A scan operator loads a set of records from the database that are within the given range of primary keys.\"),\n+    SCORE_FOR_RANK_OPERATOR(\n+            \"ScoreForRankOperator\",\n+            Icon.DATA_ACCESS_OPERATOR,\n+            \"Score For Rank\",\n+            \"A score for rank operator converts ranks to scores and executes its input plan with the conversion results bound in named parameters.\"),\n+    TABLE_FUNCTION_OPERATOR(\n+            \"TableFunctionOperator\",\n+            Icon.COMPUTATION_OPERATOR,\n+            \"Table Function\",\n+            \"A table function operator returns a table of records each time it is evaluated with a set of arguments that are specific to each individual table function.\"),\n+    TEXT_INDEX_SCAN_OPERATOR(\n+            \"TextIndexScanOperator\",\n+            Icon.DATA_ACCESS_OPERATOR,\n+            \"Text Index Scan\",\n+            \"A text index scan operator uses a text index to quickly find records in the index for a set of given tokens.\"),\n+    TYPE_FILTER_OPERATOR(\n+            \"TypeFilterOperator\",\n+            Icon.COMPUTATION_OPERATOR,\n+            \"Type Filter\",\n+            \"A type filter operator processes the input and returns only those records for whose type is among the set of given types.\"),\n+    UNION_OPERATOR(\n+            \"UnionOperator\",\n+            Icon.COMPUTATION_OPERATOR,\n+            \"Union Distinct\",\n+            \"A union distinct operator processes its two or more inputs and returns the unioned set of all input records (all records are distinct). This operator needs all inputs to be compatibly ordered.\"),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ba09399588c0493bbed69b94f99408a9f8294c22"}, "originalPosition": 112}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTIxNDA2Mg==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    // is important for e.g. join order, etc.\n          \n          \n            \n                    // is important for join order, among other things.", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/971#discussion_r441214062", "createdAt": "2020-06-17T00:28:52Z", "author": {"login": "nschiefer"}, "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/explain/PlannerGraph.java", "diffHunk": "@@ -20,27 +20,48 @@\n \n package com.apple.foundationdb.record.query.plan.temp.explain;\n \n+import com.apple.foundationdb.record.query.plan.plans.RecordQueryPlan;\n import com.apple.foundationdb.record.query.plan.temp.ExpressionRef;\n import com.apple.foundationdb.record.query.plan.temp.RelationalExpression;\n import com.google.common.collect.ImmutableMap;\n import com.google.common.collect.ImmutableSet;\n-import com.google.common.escape.Escaper;\n import com.google.common.graph.Network;\n-import com.google.common.html.HtmlEscapers;\n \n import javax.annotation.Nonnull;\n import javax.annotation.Nullable;\n+import java.util.List;\n import java.util.Map;\n import java.util.Optional;\n import java.util.Set;\n+import java.util.stream.Collectors;\n \n /**\n  * Lightweight class to save some boilerplate.\n  */\n @SuppressWarnings(\"UnstableApiUsage\")\n public class PlannerGraph extends AbstractPlannerGraph<PlannerGraph.Node, PlannerGraph.Edge> {\n \n-    private static final Escaper escaper = HtmlEscapers.htmlEscaper();\n+    public static PlannerGraph fromNodeAndChildGraphs(@Nonnull final Node node,\n+                                                      @Nonnull final List<? extends PlannerGraph> childGraphs) {\n+        final InternalPlannerGraphBuilder plannerGraphBuilder =\n+                builder(node);\n+\n+        // Traverse results from children and create graph edges. Hand in the directly preceding edge\n+        // in the dependsOn set. That in turn causes the dot exporter to render the graph left to right which\n+        // is important for e.g. join order, etc.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ba09399588c0493bbed69b94f99408a9f8294c22"}, "originalPosition": 35}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTIxNDI3NA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    public Node(final Object identity, final String name, @Nullable final List<String> details) {\n          \n          \n            \n                    public Node(@Nonnull final Object identity, @Nonnull final String name, @Nullable final List<String> details) {", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/971#discussion_r441214274", "createdAt": "2020-06-17T00:29:45Z", "author": {"login": "nschiefer"}, "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/explain/PlannerGraph.java", "diffHunk": "@@ -60,29 +81,42 @@ public PlannerGraph build() {\n     /**\n      * Node class functioning as parent for any nodes in the network.\n      */\n+    @SuppressWarnings(\"squid:S2160\")\n     public static class Node extends AbstractPlannerGraph.AbstractNode {\n+        private final Map<String, Attribute> additionalAttributes;\n+\n         public Node(final Object identity, final String name) {\n             this(identity, name, null);\n         }\n \n-        public Node(final Object identity, final String name, @Nullable final String expression) {\n-            super(identity, name, expression);\n+        public Node(final Object identity, final String name, @Nullable final List<String> details) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ba09399588c0493bbed69b94f99408a9f8294c22"}, "originalPosition": 66}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTIxNDMzMQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    public Node(final Object identity, final String name, @Nullable final List<String> details, final Map<String, Attribute> additionalAttributes) {\n          \n          \n            \n                    public Node(@Nonnull final Object identity, @Nonnull final String name, @Nullable final List<String> details, @Nonnull final Map<String, Attribute> additionalAttributes) {", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/971#discussion_r441214331", "createdAt": "2020-06-17T00:30:00Z", "author": {"login": "nschiefer"}, "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/explain/PlannerGraph.java", "diffHunk": "@@ -60,29 +81,42 @@ public PlannerGraph build() {\n     /**\n      * Node class functioning as parent for any nodes in the network.\n      */\n+    @SuppressWarnings(\"squid:S2160\")\n     public static class Node extends AbstractPlannerGraph.AbstractNode {\n+        private final Map<String, Attribute> additionalAttributes;\n+\n         public Node(final Object identity, final String name) {\n             this(identity, name, null);\n         }\n \n-        public Node(final Object identity, final String name, @Nullable final String expression) {\n-            super(identity, name, expression);\n+        public Node(final Object identity, final String name, @Nullable final List<String> details) {\n+            this(identity, name, details, ImmutableMap.of());\n+        }\n+\n+        public Node(final Object identity, final String name, @Nullable final List<String> details, final Map<String, Attribute> additionalAttributes) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ba09399588c0493bbed69b94f99408a9f8294c22"}, "originalPosition": 70}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTIxNDQ2Nw==", "bodyText": "These constructors need nullability annotations. \ud83d\ude43", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/971#discussion_r441214467", "createdAt": "2020-06-17T00:30:27Z", "author": {"login": "nschiefer"}, "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/explain/PlannerGraph.java", "diffHunk": "@@ -113,22 +147,91 @@ public String getFontName() {\n \n         @Nonnull\n         public String getFontSize() {\n-            return getExpression() == null\n+            return getDetails() == null || getDetails().isEmpty()\n                    ? \"12\"\n                    : \"8\";\n         }\n     }\n \n     /**\n-     * Node class.\n+     * Interface to be implemented by all node classes that need to externalize an info id for exporting global\n+     * information such as names and descriptions.\n      */\n-    public static class SourceNode extends Node {\n-        public SourceNode(final String name) {\n-            this(name, null);\n+    public interface WithInfoId {\n+        String getInfoId();\n+    }\n+\n+    /**\n+     * Node class that additionally captures a reference to a {@link NodeInfo}. {@code NodeInfo}s are used to provide\n+     * names, descriptions, and other cues to the exporter that are specific to the kind of node, not the node itself.\n+     */\n+    @SuppressWarnings(\"squid:S2160\")\n+    public static class NodeWithInfo extends Node implements WithInfoId {\n+        @Nonnull\n+        private NodeInfo nodeInfo;\n+\n+        @SuppressWarnings(\"unused\")\n+        public NodeWithInfo(final Object identity, final NodeInfo nodeInfo) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ba09399588c0493bbed69b94f99408a9f8294c22"}, "originalPosition": 140}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTIxNDU1Nw==", "bodyText": "These constructors, too.", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/971#discussion_r441214557", "createdAt": "2020-06-17T00:30:41Z", "author": {"login": "nschiefer"}, "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/explain/PlannerGraph.java", "diffHunk": "@@ -113,22 +147,91 @@ public String getFontName() {\n \n         @Nonnull\n         public String getFontSize() {\n-            return getExpression() == null\n+            return getDetails() == null || getDetails().isEmpty()\n                    ? \"12\"\n                    : \"8\";\n         }\n     }\n \n     /**\n-     * Node class.\n+     * Interface to be implemented by all node classes that need to externalize an info id for exporting global\n+     * information such as names and descriptions.\n      */\n-    public static class SourceNode extends Node {\n-        public SourceNode(final String name) {\n-            this(name, null);\n+    public interface WithInfoId {\n+        String getInfoId();\n+    }\n+\n+    /**\n+     * Node class that additionally captures a reference to a {@link NodeInfo}. {@code NodeInfo}s are used to provide\n+     * names, descriptions, and other cues to the exporter that are specific to the kind of node, not the node itself.\n+     */\n+    @SuppressWarnings(\"squid:S2160\")\n+    public static class NodeWithInfo extends Node implements WithInfoId {\n+        @Nonnull\n+        private NodeInfo nodeInfo;\n+\n+        @SuppressWarnings(\"unused\")\n+        public NodeWithInfo(final Object identity, final NodeInfo nodeInfo) {\n+            this(identity, nodeInfo, null);\n+        }\n+\n+        public NodeWithInfo(final Object identity, final NodeInfo nodeInfo, @Nullable final List<String> details) {\n+            this(identity, nodeInfo, details, ImmutableMap.of());\n+        }\n+\n+        public NodeWithInfo(final Object identity, final NodeInfo nodeInfo, @Nullable final List<String> details, final Map<String, Attribute> additionalAttributes) {\n+            super(identity, nodeInfo.getName(), details, additionalAttributes);\n+            this.nodeInfo = nodeInfo;\n+        }\n+\n+        @Nonnull\n+        public NodeInfo getNodeInfo() {\n+            return nodeInfo;\n+        }\n+\n+        @Override\n+        public String getInfoId() {\n+            return getNodeInfo().getId();\n+        }\n+\n+        @Nonnull\n+        @Override\n+        public Map<String, Attribute> getAttributes() {\n+            final Map<String, Attribute> attributes = super.getAttributes();\n+            return ImmutableMap\n+                    .<String, Attribute>builder()\n+                    .putAll(attributes)\n+                    .put(\"infoId\", Attribute.gml(nodeInfo.getId()))\n+                    .build();\n+        }\n+    }\n+\n+    /**\n+     * Node class for data objects.\n+     */\n+    @SuppressWarnings(\"squid:S2160\")\n+    public static class DataNodeWithInfo extends NodeWithInfo {\n+        public DataNodeWithInfo(final NodeInfo nodeInfo) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ba09399588c0493bbed69b94f99408a9f8294c22"}, "originalPosition": 180}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTIxNDY4Ng==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public static String explain(final RelationalExpression relationalExpression,\n          \n          \n            \n                                             final Map<String, Attribute> additionalDescriptionMap) {\n          \n          \n            \n                public static String explain(@Nonnull final RelationalExpression relationalExpression,\n          \n          \n            \n                                             @Nonnull final Map<String, Attribute> additionalDescriptionMap) {", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/971#discussion_r441214686", "createdAt": "2020-06-17T00:31:07Z", "author": {"login": "nschiefer"}, "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/explain/PlannerGraphProperty.java", "diffHunk": "@@ -178,10 +183,23 @@ public String apply(final PlannerGraph.Node component) {\n      */\n     @Nonnull\n     public static String explain(final RelationalExpression relationalExpression) {\n+        return explain(relationalExpression, ImmutableMap.of());\n+    }\n+\n+\n+    /**\n+     * Generate the explain of the planner expression that is passed in.\n+     * @param relationalExpression the planner expression to be explained.\n+     * @param additionalDescriptionMap a map used to generate names and descriptions for operators.\n+     * @return the explain of the planner expression handing in as a string in GML format.\n+     */\n+    @Nonnull\n+    public static String explain(final RelationalExpression relationalExpression,\n+                                 final Map<String, Attribute> additionalDescriptionMap) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ba09399588c0493bbed69b94f99408a9f8294c22"}, "originalPosition": 107}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTIxNDc1MQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public static String exportToGml(final PlannerGraph plannerGraph,\n          \n          \n            \n                                                 final Map<String, Attribute> additionalInfoMap) {\n          \n          \n            \n                public static String exportToGml(@Nonnull final PlannerGraph plannerGraph,\n          \n          \n            \n                                                 @Nonnull final Map<String, Attribute> additionalInfoMap) {", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/971#discussion_r441214751", "createdAt": "2020-06-17T00:31:22Z", "author": {"login": "nschiefer"}, "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/explain/PlannerGraphProperty.java", "diffHunk": "@@ -191,36 +209,42 @@ public static String explain(final RelationalExpression relationalExpression) {\n     /**\n      * Creates a serialized format of this graph as a gml-compatible definition.\n      * @param plannerGraph the planner graph to be exported\n-     *\n+     * @param additionalInfoMap a map used to generate names and descriptions for operators.\n      * @return the graph as string in gml format.\n      */\n     @Nonnull\n-    public static String exportToGml(final PlannerGraph plannerGraph) {\n-        final GraphExporter<PlannerGraph.Node, PlannerGraph.Edge> exporter = createGmlExporter();\n+    public static String exportToGml(final PlannerGraph plannerGraph,\n+                                     final Map<String, Attribute> additionalInfoMap) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ba09399588c0493bbed69b94f99408a9f8294c22"}, "originalPosition": 128}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "ba09399588c0493bbed69b94f99408a9f8294c22", "author": {"user": {"login": "normen662", "name": null}}, "url": "https://github.com/FoundationDB/fdb-record-layer/commit/ba09399588c0493bbed69b94f99408a9f8294c22", "committedDate": "2020-06-16T20:14:47Z", "message": "Resolves #970: improve GML explain exporter to support operator-dependent variables and node information"}, "afterCommit": {"oid": "9d1dd5ea5a303266b95d4237270a5fe3542a265c", "author": {"user": {"login": "normen662", "name": null}}, "url": "https://github.com/FoundationDB/fdb-record-layer/commit/9d1dd5ea5a303266b95d4237270a5fe3542a265c", "committedDate": "2020-06-17T02:22:57Z", "message": "Resolves #970: improve GML explain exporter to support operator-dependent variables and node information"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "9d1dd5ea5a303266b95d4237270a5fe3542a265c", "author": {"user": {"login": "normen662", "name": null}}, "url": "https://github.com/FoundationDB/fdb-record-layer/commit/9d1dd5ea5a303266b95d4237270a5fe3542a265c", "committedDate": "2020-06-17T02:22:57Z", "message": "Resolves #970: improve GML explain exporter to support operator-dependent variables and node information"}, "afterCommit": {"oid": "f3c18dea1f7338b087118c65cfcf54d94c2a75d4", "author": {"user": {"login": "normen662", "name": null}}, "url": "https://github.com/FoundationDB/fdb-record-layer/commit/f3c18dea1f7338b087118c65cfcf54d94c2a75d4", "committedDate": "2020-06-17T02:48:23Z", "message": "Resolves #970: improve GML explain exporter to support operator-dependent variables and node information"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "f3c18dea1f7338b087118c65cfcf54d94c2a75d4", "author": {"user": {"login": "normen662", "name": null}}, "url": "https://github.com/FoundationDB/fdb-record-layer/commit/f3c18dea1f7338b087118c65cfcf54d94c2a75d4", "committedDate": "2020-06-17T02:48:23Z", "message": "Resolves #970: improve GML explain exporter to support operator-dependent variables and node information"}, "afterCommit": {"oid": "50d750b2de321d8feee44bb22cdd7e7cd146578c", "author": {"user": {"login": "normen662", "name": null}}, "url": "https://github.com/FoundationDB/fdb-record-layer/commit/50d750b2de321d8feee44bb22cdd7e7cd146578c", "committedDate": "2020-06-17T02:57:16Z", "message": "Resolves #970: improve GML explain exporter to support operator-dependent variables and node information"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMyNDgzOTMz", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/971#pullrequestreview-432483933", "createdAt": "2020-06-17T14:51:34Z", "commit": {"oid": "50d750b2de321d8feee44bb22cdd7e7cd146578c"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xN1QxNDo1MTozNVrOGlJhtA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xN1QxNDo1Mjo0MFrOGlJk1g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTYwNjU4MA==", "bodyText": "I think this needs a more evocative name. Perhaps:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public TupleRange toTupleRangeSafe() {\n          \n          \n            \n                public TupleRange toTupleRangeWithoutContext() {", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/971#discussion_r441606580", "createdAt": "2020-06-17T14:51:35Z", "author": {"login": "nschiefer"}, "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/ScanComparisons.java", "diffHunk": "@@ -260,6 +260,14 @@ public TupleRange toTupleRange(@Nullable FDBRecordStoreBase<?> store, @Nullable\n         return rangeCombiner.toTupleRange();\n     }\n \n+    @Nullable\n+    public TupleRange toTupleRangeSafe() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "50d750b2de321d8feee44bb22cdd7e7cd146578c"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTYwNzM4Mg==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * index scan path. It is called by {@link #rewritePlannerGraph} to create the sub graph but allows for greater\n          \n          \n            \n                 * index scan path. It is called by {@link #rewritePlannerGraph} to create the subgraph but allows for greater", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/971#discussion_r441607382", "createdAt": "2020-06-17T14:52:40Z", "author": {"login": "nschiefer"}, "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/plans/RecordQueryPlanWithIndex.java", "diffHunk": "@@ -83,14 +88,27 @@\n     @Nonnull\n     @Override\n     default PlannerGraph rewritePlannerGraph(@Nonnull final List<? extends PlannerGraph> childGraphs) {\n-        final PlannerGraph.Node root =\n-                new PlannerGraph.Node(this,\n-                        getClass().getSimpleName(),\n-                        toString());\n-        final PlannerGraph.SourceNode source = new PlannerGraph.SourceNode(getIndexName());\n-        return PlannerGraph.builder(root)\n-                .addNode(source)\n-                .addEdge(source, root, new PlannerGraph.Edge())\n-                .build();\n+        Verify.verify(childGraphs.isEmpty());\n+        return createIndexPlannerGraph(this,\n+                NodeInfo.INDEX_SCAN_OPERATOR,\n+                ImmutableList.of(),\n+                ImmutableMap.of());\n     }\n+\n+    /**\n+     * Create an planner graph for this index scan. Note that this method allows for composition with the covering\n+     * index scan path. It is called by {@link #rewritePlannerGraph} to create the sub graph but allows for greater", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "50d750b2de321d8feee44bb22cdd7e7cd146578c"}, "originalPosition": 51}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "90c07b25e3eeb6fd1bda7d52f8caa72ca1edef09", "author": {"user": {"login": "normen662", "name": null}}, "url": "https://github.com/FoundationDB/fdb-record-layer/commit/90c07b25e3eeb6fd1bda7d52f8caa72ca1edef09", "committedDate": "2020-06-17T15:15:55Z", "message": "Resolves #970: improve GML explain exporter to support operator-dependent variables and node information"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "50d750b2de321d8feee44bb22cdd7e7cd146578c", "author": {"user": {"login": "normen662", "name": null}}, "url": "https://github.com/FoundationDB/fdb-record-layer/commit/50d750b2de321d8feee44bb22cdd7e7cd146578c", "committedDate": "2020-06-17T02:57:16Z", "message": "Resolves #970: improve GML explain exporter to support operator-dependent variables and node information"}, "afterCommit": {"oid": "90c07b25e3eeb6fd1bda7d52f8caa72ca1edef09", "author": {"user": {"login": "normen662", "name": null}}, "url": "https://github.com/FoundationDB/fdb-record-layer/commit/90c07b25e3eeb6fd1bda7d52f8caa72ca1edef09", "committedDate": "2020-06-17T15:15:55Z", "message": "Resolves #970: improve GML explain exporter to support operator-dependent variables and node information"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMyNjIwMDQy", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/971#pullrequestreview-432620042", "createdAt": "2020-06-17T17:28:32Z", "commit": {"oid": "90c07b25e3eeb6fd1bda7d52f8caa72ca1edef09"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2637, "cost": 1, "resetAt": "2021-11-01T14:20:25Z"}}}