{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDUxMTk2NjEw", "number": 999, "title": "Resolve #703, OnlineIndexer should limit amount of work by transactio\u2026", "bodyText": "\u2026n size\nWhile interating, limit range to the one record beyond a predefined max write size.\nAdd FDBStoreTimer.Counts.ONLINE_INDEX_BUILDER_RANGE_BY_SIZE/COUNT to count the number of cases\nof terminating a range by size vs. by count limit.", "createdAt": "2020-07-17T15:18:39Z", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/999", "merged": true, "mergeCommit": {"oid": "28eb50f413cded0db52dbeaafadcc9c056eccaa4"}, "closed": true, "closedAt": "2020-07-24T22:54:59Z", "author": {"login": "jjezra"}, "timelineItems": {"totalCount": 13, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABc11WgOgH2gAyNDUxMTk2NjEwOjQ2YWQ0ZGJmNzRlYjViYzkwMzllZWM0MjAxMDg1YTliMTg3MjMzNTU=", "endCursor": "Y3Vyc29yOnYyOpPPAAABc4MG9NAFqTQ1NTIyMzQzNQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "46ad4dbf74eb5bc9039eec4201085a9b18723355", "author": {"user": {"login": "jjezra", "name": "Josef Ezra"}}, "url": "https://github.com/FoundationDB/fdb-record-layer/commit/46ad4dbf74eb5bc9039eec4201085a9b18723355", "committedDate": "2020-07-17T15:13:37Z", "message": "Resolve #703, OnlineIndexer should limit amount of work by transaction size\n\n    While interating, limit range to the one record beyond a predefined max write size.\n    Add FDBStoreTimer.Counts.ONLINE_INDEX_BUILDER_RANGE_BY_SIZE/COUNT to count the number of cases\n    of terminating a range by size vs. by count limit."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDUyOTk0MzI2", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/999#pullrequestreview-452994326", "createdAt": "2020-07-22T04:58:20Z", "commit": {"oid": "46ad4dbf74eb5bc9039eec4201085a9b18723355"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 20, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMlQwNDo1ODoyMFrOG1SuGA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMlQwNjo1MDoyMlrOG1VAjw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODUzNDQyNA==", "bodyText": "Maybe DEFAULT_WRITE_BYTES_LIMIT? It would be nice to tell from the name that this is a \"limit\" and the unit is bytes.", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/999#discussion_r458534424", "createdAt": "2020-07-22T04:58:20Z", "author": {"login": "nblintao"}, "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/provider/foundationdb/OnlineIndexer.java", "diffHunk": "@@ -126,6 +127,10 @@\n      * Default number of records to attempt to run in a single transaction.\n      */\n     public static final int DEFAULT_LIMIT = 100;\n+    /**\n+     * Default transaction write size limit. Note that the actual write might be \"a little\" bigger.\n+     */\n+    public static final int DEFAULT_WRITE_SIZE = 900 * 1024;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "46ad4dbf74eb5bc9039eec4201085a9b18723355"}, "originalPosition": 15}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODUzNjE2NQ==", "bodyText": "This is correct. Nothing need to be changed here.\nJust wonder if you had the same confusion when you first see this. Things like cursor.onNext().thenCompose(result -> {if (!result.hasNext()) { always make me feel it iterated two steps at the first glance. The trick here is that RecordCursorResult is not a \"record\", but an info about the next record. See details at the RecordCursorResult.java.\nIt probably won't happen because it's STABLE but I'd love to see it's renamed to something like NextRecordInfo some day.", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/999#discussion_r458536165", "createdAt": "2020-07-22T05:04:50Z", "author": {"login": "nblintao"}, "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/provider/foundationdb/OnlineIndexer.java", "diffHunk": "@@ -558,27 +563,55 @@ private void increaseLimit() {\n         // Note: This runs all of the updates in serial in order to not invoke a race condition\n         // in the rank code that was causing incorrect results. If everything were thread safe,\n         // a larger pipeline size would be possible.\n-        return cursor.forEachResultAsync(result -> {\n+\n+        final AtomicReference<RecordCursorResult<FDBStoredRecord<Message>>> holder = new AtomicReference<>(RecordCursorResult.exhausted());\n+        final FDBRecordContext context = store.getContext();\n+        return AsyncUtil.whileTrue(() -> cursor.onNext().thenCompose(result -> {\n+\n+            if (!result.hasNext()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "46ad4dbf74eb5bc9039eec4201085a9b18723355"}, "originalPosition": 29}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODUzNjIxMw==", "bodyText": "Is this comment going to be removed?", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/999#discussion_r458536213", "createdAt": "2020-07-22T05:04:56Z", "author": {"login": "nblintao"}, "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/provider/foundationdb/OnlineIndexer.java", "diffHunk": "@@ -558,27 +563,55 @@ private void increaseLimit() {\n         // Note: This runs all of the updates in serial in order to not invoke a race condition\n         // in the rank code that was causing incorrect results. If everything were thread safe,\n         // a larger pipeline size would be possible.\n-        return cursor.forEachResultAsync(result -> {\n+\n+        final AtomicReference<RecordCursorResult<FDBStoredRecord<Message>>> holder = new AtomicReference<>(RecordCursorResult.exhausted());\n+        final FDBRecordContext context = store.getContext();\n+        return AsyncUtil.whileTrue(() -> cursor.onNext().thenCompose(result -> {\n+\n+            if (!result.hasNext()) {\n+                // end of the cursor list\n+                if (timer != null) {\n+                    timer.increment(FDBStoreTimer.Counts.ONLINE_INDEX_BUILDER_RANGE_BY_COUNT);\n+                }\n+                holder.set(result);\n+                return AsyncUtil.READY_FALSE;\n+            }\n+\n+            // here: implement forEachResultAsync", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "46ad4dbf74eb5bc9039eec4201085a9b18723355"}, "originalPosition": 38}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODUzNjgzMA==", "bodyText": "I think it's good to have a comment here. Just remove \"here\".\nConsidering this method is getting larger, maybe you can extract this part as a separate method.", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/999#discussion_r458536830", "createdAt": "2020-07-22T05:07:10Z", "author": {"login": "nblintao"}, "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/provider/foundationdb/OnlineIndexer.java", "diffHunk": "@@ -558,27 +563,55 @@ private void increaseLimit() {\n         // Note: This runs all of the updates in serial in order to not invoke a race condition\n         // in the rank code that was causing incorrect results. If everything were thread safe,\n         // a larger pipeline size would be possible.\n-        return cursor.forEachResultAsync(result -> {\n+\n+        final AtomicReference<RecordCursorResult<FDBStoredRecord<Message>>> holder = new AtomicReference<>(RecordCursorResult.exhausted());\n+        final FDBRecordContext context = store.getContext();\n+        return AsyncUtil.whileTrue(() -> cursor.onNext().thenCompose(result -> {\n+\n+            if (!result.hasNext()) {\n+                // end of the cursor list\n+                if (timer != null) {\n+                    timer.increment(FDBStoreTimer.Counts.ONLINE_INDEX_BUILDER_RANGE_BY_COUNT);\n+                }\n+                holder.set(result);\n+                return AsyncUtil.READY_FALSE;\n+            }\n+\n+            // here: implement forEachResultAsync\n             final FDBStoredRecord<Message> rec = result.get();\n             empty.set(false);\n             if (timer != null) {\n                 timer.increment(FDBStoreTimer.Counts.ONLINE_INDEX_BUILDER_RECORDS_SCANNED);\n             }\n             recordsScannedCounter.incrementAndGet();\n-            if (recordTypes.contains(rec.getRecordType())) {\n-                if (timer != null) {\n-                    timer.increment(FDBStoreTimer.Counts.ONLINE_INDEX_BUILDER_RECORDS_INDEXED);\n-                }\n-                if (syntheticPlan == null) {\n-                    return maintainer.update(null, rec);\n-                } else {\n-                    // Pipeline size is 1, since not all maintainers are thread-safe.\n-                    return syntheticPlan.execute(store, rec).forEachAsync(syntheticRecord -> maintainer.update(null, syntheticRecord), 1);\n-                }\n-            } else {\n-                return AsyncUtil.DONE;\n+            if (!recordTypes.contains(rec.getRecordType())) {\n+                // This record is not our type, swipe left\n+                return AsyncUtil.READY_TRUE;\n             }\n-        }).thenCompose(noNextResult -> {\n+            // here: add this index to the transaction", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "46ad4dbf74eb5bc9039eec4201085a9b18723355"}, "originalPosition": 62}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODUzNzIzMA==", "bodyText": "lol", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/999#discussion_r458537230", "createdAt": "2020-07-22T05:08:43Z", "author": {"login": "nblintao"}, "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/provider/foundationdb/OnlineIndexer.java", "diffHunk": "@@ -558,27 +563,55 @@ private void increaseLimit() {\n         // Note: This runs all of the updates in serial in order to not invoke a race condition\n         // in the rank code that was causing incorrect results. If everything were thread safe,\n         // a larger pipeline size would be possible.\n-        return cursor.forEachResultAsync(result -> {\n+\n+        final AtomicReference<RecordCursorResult<FDBStoredRecord<Message>>> holder = new AtomicReference<>(RecordCursorResult.exhausted());\n+        final FDBRecordContext context = store.getContext();\n+        return AsyncUtil.whileTrue(() -> cursor.onNext().thenCompose(result -> {\n+\n+            if (!result.hasNext()) {\n+                // end of the cursor list\n+                if (timer != null) {\n+                    timer.increment(FDBStoreTimer.Counts.ONLINE_INDEX_BUILDER_RANGE_BY_COUNT);\n+                }\n+                holder.set(result);\n+                return AsyncUtil.READY_FALSE;\n+            }\n+\n+            // here: implement forEachResultAsync\n             final FDBStoredRecord<Message> rec = result.get();\n             empty.set(false);\n             if (timer != null) {\n                 timer.increment(FDBStoreTimer.Counts.ONLINE_INDEX_BUILDER_RECORDS_SCANNED);\n             }\n             recordsScannedCounter.incrementAndGet();\n-            if (recordTypes.contains(rec.getRecordType())) {\n-                if (timer != null) {\n-                    timer.increment(FDBStoreTimer.Counts.ONLINE_INDEX_BUILDER_RECORDS_INDEXED);\n-                }\n-                if (syntheticPlan == null) {\n-                    return maintainer.update(null, rec);\n-                } else {\n-                    // Pipeline size is 1, since not all maintainers are thread-safe.\n-                    return syntheticPlan.execute(store, rec).forEachAsync(syntheticRecord -> maintainer.update(null, syntheticRecord), 1);\n-                }\n-            } else {\n-                return AsyncUtil.DONE;\n+            if (!recordTypes.contains(rec.getRecordType())) {\n+                // This record is not our type, swipe left", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "46ad4dbf74eb5bc9039eec4201085a9b18723355"}, "originalPosition": 58}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODUzODAxNA==", "bodyText": "thenCompose will worth a new line", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/999#discussion_r458538014", "createdAt": "2020-07-22T05:11:33Z", "author": {"login": "nblintao"}, "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/provider/foundationdb/OnlineIndexer.java", "diffHunk": "@@ -558,27 +563,55 @@ private void increaseLimit() {\n         // Note: This runs all of the updates in serial in order to not invoke a race condition\n         // in the rank code that was causing incorrect results. If everything were thread safe,\n         // a larger pipeline size would be possible.\n-        return cursor.forEachResultAsync(result -> {\n+\n+        final AtomicReference<RecordCursorResult<FDBStoredRecord<Message>>> holder = new AtomicReference<>(RecordCursorResult.exhausted());\n+        final FDBRecordContext context = store.getContext();\n+        return AsyncUtil.whileTrue(() -> cursor.onNext().thenCompose(result -> {\n+\n+            if (!result.hasNext()) {\n+                // end of the cursor list\n+                if (timer != null) {\n+                    timer.increment(FDBStoreTimer.Counts.ONLINE_INDEX_BUILDER_RANGE_BY_COUNT);\n+                }\n+                holder.set(result);\n+                return AsyncUtil.READY_FALSE;\n+            }\n+\n+            // here: implement forEachResultAsync\n             final FDBStoredRecord<Message> rec = result.get();\n             empty.set(false);\n             if (timer != null) {\n                 timer.increment(FDBStoreTimer.Counts.ONLINE_INDEX_BUILDER_RECORDS_SCANNED);\n             }\n             recordsScannedCounter.incrementAndGet();\n-            if (recordTypes.contains(rec.getRecordType())) {\n-                if (timer != null) {\n-                    timer.increment(FDBStoreTimer.Counts.ONLINE_INDEX_BUILDER_RECORDS_INDEXED);\n-                }\n-                if (syntheticPlan == null) {\n-                    return maintainer.update(null, rec);\n-                } else {\n-                    // Pipeline size is 1, since not all maintainers are thread-safe.\n-                    return syntheticPlan.execute(store, rec).forEachAsync(syntheticRecord -> maintainer.update(null, syntheticRecord), 1);\n-                }\n-            } else {\n-                return AsyncUtil.DONE;\n+            if (!recordTypes.contains(rec.getRecordType())) {\n+                // This record is not our type, swipe left\n+                return AsyncUtil.READY_TRUE;\n             }\n-        }).thenCompose(noNextResult -> {\n+            // here: add this index to the transaction\n+            if (timer != null) {\n+                timer.increment(FDBStoreTimer.Counts.ONLINE_INDEX_BUILDER_RECORDS_INDEXED);\n+            }\n+            return (syntheticPlan == null ?\n+                    maintainer.update(null, rec) :\n+                    syntheticPlan.execute(store, rec)\n+                            .forEachAsync(syntheticRecord -> maintainer.update(null, syntheticRecord), 1)\n+                    ).thenCompose(vignore ->\n+                    context.getApproximateTransactionSize().thenCompose(size -> {\n+                        if (size >= config.getMaxWriteSize()) {\n+                            // the transaction becomes too big - stop iterating\n+                            if (timer != null) {\n+                                timer.increment(FDBStoreTimer.Counts.ONLINE_INDEX_BUILDER_RANGE_BY_SIZE);\n+                            }\n+                            holder.set(result);\n+                            return AsyncUtil.READY_FALSE;\n+                        }\n+                        return AsyncUtil.READY_TRUE;\n+                    }));\n+\n+        }), cursor.getExecutor()).thenCompose(vIgnore -> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "46ad4dbf74eb5bc9039eec4201085a9b18723355"}, "originalPosition": 83}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODUzOTAyNw==", "bodyText": "Is this comment removed intentionally?", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/999#discussion_r458539027", "createdAt": "2020-07-22T05:15:10Z", "author": {"login": "nblintao"}, "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/provider/foundationdb/OnlineIndexer.java", "diffHunk": "@@ -558,27 +563,55 @@ private void increaseLimit() {\n         // Note: This runs all of the updates in serial in order to not invoke a race condition\n         // in the rank code that was causing incorrect results. If everything were thread safe,\n         // a larger pipeline size would be possible.\n-        return cursor.forEachResultAsync(result -> {\n+\n+        final AtomicReference<RecordCursorResult<FDBStoredRecord<Message>>> holder = new AtomicReference<>(RecordCursorResult.exhausted());\n+        final FDBRecordContext context = store.getContext();\n+        return AsyncUtil.whileTrue(() -> cursor.onNext().thenCompose(result -> {\n+\n+            if (!result.hasNext()) {\n+                // end of the cursor list\n+                if (timer != null) {\n+                    timer.increment(FDBStoreTimer.Counts.ONLINE_INDEX_BUILDER_RANGE_BY_COUNT);\n+                }\n+                holder.set(result);\n+                return AsyncUtil.READY_FALSE;\n+            }\n+\n+            // here: implement forEachResultAsync\n             final FDBStoredRecord<Message> rec = result.get();\n             empty.set(false);\n             if (timer != null) {\n                 timer.increment(FDBStoreTimer.Counts.ONLINE_INDEX_BUILDER_RECORDS_SCANNED);\n             }\n             recordsScannedCounter.incrementAndGet();\n-            if (recordTypes.contains(rec.getRecordType())) {\n-                if (timer != null) {\n-                    timer.increment(FDBStoreTimer.Counts.ONLINE_INDEX_BUILDER_RECORDS_INDEXED);\n-                }\n-                if (syntheticPlan == null) {\n-                    return maintainer.update(null, rec);\n-                } else {\n-                    // Pipeline size is 1, since not all maintainers are thread-safe.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "46ad4dbf74eb5bc9039eec4201085a9b18723355"}, "originalPosition": 52}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODU0MDMyNg==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        return (syntheticPlan == null ?\n          \n          \n            \n                                maintainer.update(null, rec) :\n          \n          \n            \n                                syntheticPlan.execute(store, rec)\n          \n          \n            \n                                        .forEachAsync(syntheticRecord -> maintainer.update(null, syntheticRecord), 1)\n          \n          \n            \n                                ).thenCompose(vignore ->\n          \n          \n            \n                        final CompletableFuture<Void> updateMaintainer;\n          \n          \n            \n                        if (syntheticPlan == null) {\n          \n          \n            \n                            updateMaintainer = maintainer.update(null, rec);\n          \n          \n            \n                        } else {\n          \n          \n            \n                            // Pipeline size is 1, since not all maintainers are thread-safe.\n          \n          \n            \n                            updateMaintainer = syntheticPlan.execute(store, rec).forEachAsync(syntheticRecord -> maintainer.update(null, syntheticRecord), 1);\n          \n          \n            \n                        }\n          \n          \n            \n                        return updateMaintainer. thenCompose(vignore ->\n          \n      \n    \n    \n  \n\nI would probably do something like this to make it faster to read. But it's up to you.", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/999#discussion_r458540326", "createdAt": "2020-07-22T05:19:47Z", "author": {"login": "nblintao"}, "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/provider/foundationdb/OnlineIndexer.java", "diffHunk": "@@ -558,27 +563,55 @@ private void increaseLimit() {\n         // Note: This runs all of the updates in serial in order to not invoke a race condition\n         // in the rank code that was causing incorrect results. If everything were thread safe,\n         // a larger pipeline size would be possible.\n-        return cursor.forEachResultAsync(result -> {\n+\n+        final AtomicReference<RecordCursorResult<FDBStoredRecord<Message>>> holder = new AtomicReference<>(RecordCursorResult.exhausted());\n+        final FDBRecordContext context = store.getContext();\n+        return AsyncUtil.whileTrue(() -> cursor.onNext().thenCompose(result -> {\n+\n+            if (!result.hasNext()) {\n+                // end of the cursor list\n+                if (timer != null) {\n+                    timer.increment(FDBStoreTimer.Counts.ONLINE_INDEX_BUILDER_RANGE_BY_COUNT);\n+                }\n+                holder.set(result);\n+                return AsyncUtil.READY_FALSE;\n+            }\n+\n+            // here: implement forEachResultAsync\n             final FDBStoredRecord<Message> rec = result.get();\n             empty.set(false);\n             if (timer != null) {\n                 timer.increment(FDBStoreTimer.Counts.ONLINE_INDEX_BUILDER_RECORDS_SCANNED);\n             }\n             recordsScannedCounter.incrementAndGet();\n-            if (recordTypes.contains(rec.getRecordType())) {\n-                if (timer != null) {\n-                    timer.increment(FDBStoreTimer.Counts.ONLINE_INDEX_BUILDER_RECORDS_INDEXED);\n-                }\n-                if (syntheticPlan == null) {\n-                    return maintainer.update(null, rec);\n-                } else {\n-                    // Pipeline size is 1, since not all maintainers are thread-safe.\n-                    return syntheticPlan.execute(store, rec).forEachAsync(syntheticRecord -> maintainer.update(null, syntheticRecord), 1);\n-                }\n-            } else {\n-                return AsyncUtil.DONE;\n+            if (!recordTypes.contains(rec.getRecordType())) {\n+                // This record is not our type, swipe left\n+                return AsyncUtil.READY_TRUE;\n             }\n-        }).thenCompose(noNextResult -> {\n+            // here: add this index to the transaction\n+            if (timer != null) {\n+                timer.increment(FDBStoreTimer.Counts.ONLINE_INDEX_BUILDER_RECORDS_INDEXED);\n+            }\n+            return (syntheticPlan == null ?\n+                    maintainer.update(null, rec) :\n+                    syntheticPlan.execute(store, rec)\n+                            .forEachAsync(syntheticRecord -> maintainer.update(null, syntheticRecord), 1)\n+                    ).thenCompose(vignore ->", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "46ad4dbf74eb5bc9039eec4201085a9b18723355"}, "originalPosition": 70}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODU0MjE4Mw==", "bodyText": "A name like lastResult will be more intuitive.", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/999#discussion_r458542183", "createdAt": "2020-07-22T05:26:01Z", "author": {"login": "nblintao"}, "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/provider/foundationdb/OnlineIndexer.java", "diffHunk": "@@ -558,27 +563,55 @@ private void increaseLimit() {\n         // Note: This runs all of the updates in serial in order to not invoke a race condition\n         // in the rank code that was causing incorrect results. If everything were thread safe,\n         // a larger pipeline size would be possible.\n-        return cursor.forEachResultAsync(result -> {\n+\n+        final AtomicReference<RecordCursorResult<FDBStoredRecord<Message>>> holder = new AtomicReference<>(RecordCursorResult.exhausted());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "46ad4dbf74eb5bc9039eec4201085a9b18723355"}, "originalPosition": 25}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODU0MzM4MQ==", "bodyText": "I don't know reason but the codebase uses vignore", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/999#discussion_r458543381", "createdAt": "2020-07-22T05:30:12Z", "author": {"login": "nblintao"}, "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/provider/foundationdb/OnlineIndexer.java", "diffHunk": "@@ -558,27 +563,55 @@ private void increaseLimit() {\n         // Note: This runs all of the updates in serial in order to not invoke a race condition\n         // in the rank code that was causing incorrect results. If everything were thread safe,\n         // a larger pipeline size would be possible.\n-        return cursor.forEachResultAsync(result -> {\n+\n+        final AtomicReference<RecordCursorResult<FDBStoredRecord<Message>>> holder = new AtomicReference<>(RecordCursorResult.exhausted());\n+        final FDBRecordContext context = store.getContext();\n+        return AsyncUtil.whileTrue(() -> cursor.onNext().thenCompose(result -> {\n+\n+            if (!result.hasNext()) {\n+                // end of the cursor list\n+                if (timer != null) {\n+                    timer.increment(FDBStoreTimer.Counts.ONLINE_INDEX_BUILDER_RANGE_BY_COUNT);\n+                }\n+                holder.set(result);\n+                return AsyncUtil.READY_FALSE;\n+            }\n+\n+            // here: implement forEachResultAsync\n             final FDBStoredRecord<Message> rec = result.get();\n             empty.set(false);\n             if (timer != null) {\n                 timer.increment(FDBStoreTimer.Counts.ONLINE_INDEX_BUILDER_RECORDS_SCANNED);\n             }\n             recordsScannedCounter.incrementAndGet();\n-            if (recordTypes.contains(rec.getRecordType())) {\n-                if (timer != null) {\n-                    timer.increment(FDBStoreTimer.Counts.ONLINE_INDEX_BUILDER_RECORDS_INDEXED);\n-                }\n-                if (syntheticPlan == null) {\n-                    return maintainer.update(null, rec);\n-                } else {\n-                    // Pipeline size is 1, since not all maintainers are thread-safe.\n-                    return syntheticPlan.execute(store, rec).forEachAsync(syntheticRecord -> maintainer.update(null, syntheticRecord), 1);\n-                }\n-            } else {\n-                return AsyncUtil.DONE;\n+            if (!recordTypes.contains(rec.getRecordType())) {\n+                // This record is not our type, swipe left\n+                return AsyncUtil.READY_TRUE;\n             }\n-        }).thenCompose(noNextResult -> {\n+            // here: add this index to the transaction\n+            if (timer != null) {\n+                timer.increment(FDBStoreTimer.Counts.ONLINE_INDEX_BUILDER_RECORDS_INDEXED);\n+            }\n+            return (syntheticPlan == null ?\n+                    maintainer.update(null, rec) :\n+                    syntheticPlan.execute(store, rec)\n+                            .forEachAsync(syntheticRecord -> maintainer.update(null, syntheticRecord), 1)\n+                    ).thenCompose(vignore ->\n+                    context.getApproximateTransactionSize().thenCompose(size -> {\n+                        if (size >= config.getMaxWriteSize()) {\n+                            // the transaction becomes too big - stop iterating\n+                            if (timer != null) {\n+                                timer.increment(FDBStoreTimer.Counts.ONLINE_INDEX_BUILDER_RANGE_BY_SIZE);\n+                            }\n+                            holder.set(result);\n+                            return AsyncUtil.READY_FALSE;\n+                        }\n+                        return AsyncUtil.READY_TRUE;\n+                    }));\n+\n+        }), cursor.getExecutor()).thenCompose(vIgnore -> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "46ad4dbf74eb5bc9039eec4201085a9b18723355"}, "originalPosition": 83}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODU0NDQzNg==", "bodyText": "This value is not \"no next\" anymore in RecordCursorResult's definition. Maybe you can just inline it.", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/999#discussion_r458544436", "createdAt": "2020-07-22T05:33:39Z", "author": {"login": "nblintao"}, "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/provider/foundationdb/OnlineIndexer.java", "diffHunk": "@@ -558,27 +563,55 @@ private void increaseLimit() {\n         // Note: This runs all of the updates in serial in order to not invoke a race condition\n         // in the rank code that was causing incorrect results. If everything were thread safe,\n         // a larger pipeline size would be possible.\n-        return cursor.forEachResultAsync(result -> {\n+\n+        final AtomicReference<RecordCursorResult<FDBStoredRecord<Message>>> holder = new AtomicReference<>(RecordCursorResult.exhausted());\n+        final FDBRecordContext context = store.getContext();\n+        return AsyncUtil.whileTrue(() -> cursor.onNext().thenCompose(result -> {\n+\n+            if (!result.hasNext()) {\n+                // end of the cursor list\n+                if (timer != null) {\n+                    timer.increment(FDBStoreTimer.Counts.ONLINE_INDEX_BUILDER_RANGE_BY_COUNT);\n+                }\n+                holder.set(result);\n+                return AsyncUtil.READY_FALSE;\n+            }\n+\n+            // here: implement forEachResultAsync\n             final FDBStoredRecord<Message> rec = result.get();\n             empty.set(false);\n             if (timer != null) {\n                 timer.increment(FDBStoreTimer.Counts.ONLINE_INDEX_BUILDER_RECORDS_SCANNED);\n             }\n             recordsScannedCounter.incrementAndGet();\n-            if (recordTypes.contains(rec.getRecordType())) {\n-                if (timer != null) {\n-                    timer.increment(FDBStoreTimer.Counts.ONLINE_INDEX_BUILDER_RECORDS_INDEXED);\n-                }\n-                if (syntheticPlan == null) {\n-                    return maintainer.update(null, rec);\n-                } else {\n-                    // Pipeline size is 1, since not all maintainers are thread-safe.\n-                    return syntheticPlan.execute(store, rec).forEachAsync(syntheticRecord -> maintainer.update(null, syntheticRecord), 1);\n-                }\n-            } else {\n-                return AsyncUtil.DONE;\n+            if (!recordTypes.contains(rec.getRecordType())) {\n+                // This record is not our type, swipe left\n+                return AsyncUtil.READY_TRUE;\n             }\n-        }).thenCompose(noNextResult -> {\n+            // here: add this index to the transaction\n+            if (timer != null) {\n+                timer.increment(FDBStoreTimer.Counts.ONLINE_INDEX_BUILDER_RECORDS_INDEXED);\n+            }\n+            return (syntheticPlan == null ?\n+                    maintainer.update(null, rec) :\n+                    syntheticPlan.execute(store, rec)\n+                            .forEachAsync(syntheticRecord -> maintainer.update(null, syntheticRecord), 1)\n+                    ).thenCompose(vignore ->\n+                    context.getApproximateTransactionSize().thenCompose(size -> {\n+                        if (size >= config.getMaxWriteSize()) {\n+                            // the transaction becomes too big - stop iterating\n+                            if (timer != null) {\n+                                timer.increment(FDBStoreTimer.Counts.ONLINE_INDEX_BUILDER_RANGE_BY_SIZE);\n+                            }\n+                            holder.set(result);\n+                            return AsyncUtil.READY_FALSE;\n+                        }\n+                        return AsyncUtil.READY_TRUE;\n+                    }));\n+\n+        }), cursor.getExecutor()).thenCompose(vIgnore -> {\n+            RecordCursorResult<FDBStoredRecord<Message>> noNextResult = holder.get();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "46ad4dbf74eb5bc9039eec4201085a9b18723355"}, "originalPosition": 84}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODU0NjY4MA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                     * @return a the efficient write size. Typically a transaction will be submitted when it becomes bigger than\n          \n          \n            \n                     * @return the write size. Typically a transaction will be submitted when it becomes bigger than", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/999#discussion_r458546680", "createdAt": "2020-07-22T05:40:25Z", "author": {"login": "nblintao"}, "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/provider/foundationdb/OnlineIndexer.java", "diffHunk": "@@ -1474,6 +1509,16 @@ public int getIncreaseLimitAfter() {\n             return increaseLimitAfter;\n         }\n \n+        /**\n+         * Get the approximate size limit, represents a desired max transaction message size. Note that the actual write\n+         * might be \"a little\" larger than this limit.\n+         * @return a the efficient write size. Typically a transaction will be submitted when it becomes bigger than", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "46ad4dbf74eb5bc9039eec4201085a9b18723355"}, "originalPosition": 117}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODU0NzE4MQ==", "bodyText": "Same here. I would like to indicate \"bytes\" in the name and/or the comment.", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/999#discussion_r458547181", "createdAt": "2020-07-22T05:41:56Z", "author": {"login": "nblintao"}, "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/provider/foundationdb/OnlineIndexer.java", "diffHunk": "@@ -1807,6 +1868,28 @@ public Builder setLimit(int limit) {\n             return this;\n         }\n \n+        /**\n+         * Get the approximate maximum transaction write size. Note that the actual size might be \"a little\" bigger.\n+         * @return the requested write size. Index iteration stops when exceeding this size.\n+         */\n+        @Nonnull\n+        public int getMaxWriteSize() {\n+            return maxWriteSize;\n+        }\n+\n+        /**\n+         * Set the approximate maximum transaction write size. Note that the actual size might be \"a little\" bigger.\n+         * he default limit is {@link #DEFAULT_WRITE_SIZE} = {@value #DEFAULT_WRITE_SIZE}.\n+         * @param max the desired max write size\n+         * @return this builder\n+         */\n+\n+        @Nonnull\n+        public Builder setMaxWriteSize(int max) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "46ad4dbf74eb5bc9039eec4201085a9b18723355"}, "originalPosition": 201}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODU0NzM5OA==", "bodyText": "f there is going to be a place explaining what \"a little\" means, it's here.", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/999#discussion_r458547398", "createdAt": "2020-07-22T05:42:44Z", "author": {"login": "nblintao"}, "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/provider/foundationdb/OnlineIndexer.java", "diffHunk": "@@ -1807,6 +1868,28 @@ public Builder setLimit(int limit) {\n             return this;\n         }\n \n+        /**\n+         * Get the approximate maximum transaction write size. Note that the actual size might be \"a little\" bigger.\n+         * @return the requested write size. Index iteration stops when exceeding this size.\n+         */\n+        @Nonnull\n+        public int getMaxWriteSize() {\n+            return maxWriteSize;\n+        }\n+\n+        /**\n+         * Set the approximate maximum transaction write size. Note that the actual size might be \"a little\" bigger.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "46ad4dbf74eb5bc9039eec4201085a9b18723355"}, "originalPosition": 194}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODU0OTE1NA==", "bodyText": "There are two sets of get/set here. I wish the comments can be exactly same so you don't have to fix 4 places separately. For the same reason, I would not leave important information in the lines above rather than @return and @params", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/999#discussion_r458549154", "createdAt": "2020-07-22T05:48:48Z", "author": {"login": "nblintao"}, "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/provider/foundationdb/OnlineIndexer.java", "diffHunk": "@@ -1474,6 +1509,16 @@ public int getIncreaseLimitAfter() {\n             return increaseLimitAfter;\n         }\n \n+        /**\n+         * Get the approximate size limit, represents a desired max transaction message size. Note that the actual write\n+         * might be \"a little\" larger than this limit.\n+         * @return a the efficient write size. Typically a transaction will be submitted when it becomes bigger than", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "46ad4dbf74eb5bc9039eec4201085a9b18723355"}, "originalPosition": 117}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODU1MTA4NQ==", "bodyText": "It should better to be in OnlineIndexerSimpleTest.java (if it is easy to move there)", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/999#discussion_r458551085", "createdAt": "2020-07-22T05:54:37Z", "author": {"login": "nblintao"}, "path": "fdb-record-layer-core/src/test/java/com/apple/foundationdb/record/provider/foundationdb/RecordTypeKeyTest.java", "diffHunk": "@@ -697,5 +698,96 @@ private void saveManyRecords(@Nonnull RecordMetaDataHook hook, int count1, int c\n             context.commit();\n         }\n     }\n+    \n+    @Test\n+    public void testOnlineIndexBuilderMaxWrite() throws Exception {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "46ad4dbf74eb5bc9039eec4201085a9b18723355"}, "originalPosition": 14}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODU1MTY2Mw==", "bodyText": "Are these checks relevant?", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/999#discussion_r458551663", "createdAt": "2020-07-22T05:56:19Z", "author": {"login": "nblintao"}, "path": "fdb-record-layer-core/src/test/java/com/apple/foundationdb/record/provider/foundationdb/RecordTypeKeyTest.java", "diffHunk": "@@ -697,5 +698,96 @@ private void saveManyRecords(@Nonnull RecordMetaDataHook hook, int count1, int c\n             context.commit();\n         }\n     }\n+    \n+    @Test\n+    public void testOnlineIndexBuilderMaxWrite() throws Exception {\n+        try (FDBRecordContext context = openContext()) {\n+            uncheckedOpenSimpleRecordStore(context, BASIC_HOOK);\n+            recordStore.checkVersion(null, FDBRecordStoreBase.StoreExistenceCheck.ERROR_IF_EXISTS).join();\n+            context.commit();\n+        }\n+\n+        saveManyRecords(BASIC_HOOK, 250, 250);\n \n+        try (FDBRecordContext context = openContext()) {\n+            uncheckedOpenSimpleRecordStore(context, BASIC_HOOK);\n+            recordStore.checkVersion(null, FDBRecordStoreBase.StoreExistenceCheck.ERROR_IF_NOT_EXISTS).join();\n+\n+            assertEquals(250, recordStore.getSnapshotRecordCountForRecordType(\"MySimpleRecord\").join().intValue());\n+            assertEquals(250, recordStore.getSnapshotRecordCountForRecordType(\"MyOtherRecord\").join().intValue());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "46ad4dbf74eb5bc9039eec4201085a9b18723355"}, "originalPosition": 28}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODU1Mjk1OA==", "bodyText": "I think some old code still calls is indexBuilder (OnlineIndexer used to be called OnlineIndexBuilder) but it'd better to be called indexer because it's weird to have a \"Builder\" for a \"XXXBuilder\".", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/999#discussion_r458552958", "createdAt": "2020-07-22T06:00:10Z", "author": {"login": "nblintao"}, "path": "fdb-record-layer-core/src/test/java/com/apple/foundationdb/record/provider/foundationdb/RecordTypeKeyTest.java", "diffHunk": "@@ -697,5 +698,96 @@ private void saveManyRecords(@Nonnull RecordMetaDataHook hook, int count1, int c\n             context.commit();\n         }\n     }\n+    \n+    @Test\n+    public void testOnlineIndexBuilderMaxWrite() throws Exception {\n+        try (FDBRecordContext context = openContext()) {\n+            uncheckedOpenSimpleRecordStore(context, BASIC_HOOK);\n+            recordStore.checkVersion(null, FDBRecordStoreBase.StoreExistenceCheck.ERROR_IF_EXISTS).join();\n+            context.commit();\n+        }\n+\n+        saveManyRecords(BASIC_HOOK, 250, 250);\n \n+        try (FDBRecordContext context = openContext()) {\n+            uncheckedOpenSimpleRecordStore(context, BASIC_HOOK);\n+            recordStore.checkVersion(null, FDBRecordStoreBase.StoreExistenceCheck.ERROR_IF_NOT_EXISTS).join();\n+\n+            assertEquals(250, recordStore.getSnapshotRecordCountForRecordType(\"MySimpleRecord\").join().intValue());\n+            assertEquals(250, recordStore.getSnapshotRecordCountForRecordType(\"MyOtherRecord\").join().intValue());\n+        }\n+\n+        RecordMetaDataHook hook = metaData -> {\n+            BASIC_HOOK.apply(metaData);\n+            metaData.addIndex(\"MySimpleRecord\", \"newIndex\", \"num_value_2\");\n+        };\n+\n+        try (FDBRecordContext context = openContext()) {\n+            uncheckedOpenSimpleRecordStore(context, hook);\n+            recordStore.checkVersion(null, FDBRecordStoreBase.StoreExistenceCheck.ERROR_IF_NOT_EXISTS).join();\n+\n+            assertTrue(recordStore.isIndexWriteOnly(\"newIndex\"));\n+\n+            timer.reset();\n+\n+            // Build in this transaction.\n+            try (OnlineIndexer indexBuilder =", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "46ad4dbf74eb5bc9039eec4201085a9b18723355"}, "originalPosition": 45}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODU1NjI3Mg==", "bodyText": "Is this comment still true?", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/999#discussion_r458556272", "createdAt": "2020-07-22T06:10:10Z", "author": {"login": "nblintao"}, "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/provider/foundationdb/OnlineIndexer.java", "diffHunk": "@@ -558,27 +563,55 @@ private void increaseLimit() {\n         // Note: This runs all of the updates in serial in order to not invoke a race condition", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "46ad4dbf74eb5bc9039eec4201085a9b18723355"}, "originalPosition": 20}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODU3MTkxOQ==", "bodyText": "Maybe you can explain more about \"range termination\" here.", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/999#discussion_r458571919", "createdAt": "2020-07-22T06:50:22Z", "author": {"login": "nblintao"}, "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/provider/foundationdb/FDBStoreTimer.java", "diffHunk": "@@ -570,6 +570,10 @@ public String logKey() {\n         ONLINE_INDEX_BUILDER_RECORDS_SCANNED(\"number of records scanned by online index build\", false),\n         /** The number of records indexed by {@link OnlineIndexer}. */\n         ONLINE_INDEX_BUILDER_RECORDS_INDEXED(\"number of records indexed by online index build\", false),\n+        /** The number of indexer range termination by scan limit {@link OnlineIndexer}. */", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "46ad4dbf74eb5bc9039eec4201085a9b18723355"}, "originalPosition": 4}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDUzNDcyMzM2", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/999#pullrequestreview-453472336", "createdAt": "2020-07-22T16:13:43Z", "commit": {"oid": "46ad4dbf74eb5bc9039eec4201085a9b18723355"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 9, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMlQxNjoxMzo0M1rOG1pwtQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMlQxNjozOToxNlrOG1q-fA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODkxMTkyNQ==", "bodyText": "Perhaps something more like:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    /** The number of indexer range termination by scan limit {@link OnlineIndexer}. */\n          \n          \n            \n                    /** The number of {@link OnlineIndexer} range scans terminated after hitting the scan limit. */", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/999#discussion_r458911925", "createdAt": "2020-07-22T16:13:43Z", "author": {"login": "alecgrieser"}, "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/provider/foundationdb/FDBStoreTimer.java", "diffHunk": "@@ -570,6 +570,10 @@ public String logKey() {\n         ONLINE_INDEX_BUILDER_RECORDS_SCANNED(\"number of records scanned by online index build\", false),\n         /** The number of records indexed by {@link OnlineIndexer}. */\n         ONLINE_INDEX_BUILDER_RECORDS_INDEXED(\"number of records indexed by online index build\", false),\n+        /** The number of indexer range termination by scan limit {@link OnlineIndexer}. */", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "46ad4dbf74eb5bc9039eec4201085a9b18723355"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODkxNDUxMA==", "bodyText": "Suggested change", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/999#discussion_r458914510", "createdAt": "2020-07-22T16:17:45Z", "author": {"login": "alecgrieser"}, "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/provider/foundationdb/OnlineIndexer.java", "diffHunk": "@@ -1807,6 +1868,28 @@ public Builder setLimit(int limit) {\n             return this;\n         }\n \n+        /**\n+         * Get the approximate maximum transaction write size. Note that the actual size might be \"a little\" bigger.\n+         * @return the requested write size. Index iteration stops when exceeding this size.\n+         */\n+        @Nonnull\n+        public int getMaxWriteSize() {\n+            return maxWriteSize;\n+        }\n+\n+        /**\n+         * Set the approximate maximum transaction write size. Note that the actual size might be \"a little\" bigger.\n+         * he default limit is {@link #DEFAULT_WRITE_SIZE} = {@value #DEFAULT_WRITE_SIZE}.\n+         * @param max the desired max write size\n+         * @return this builder\n+         */\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "46ad4dbf74eb5bc9039eec4201085a9b18723355"}, "originalPosition": 199}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODkxNTM3OQ==", "bodyText": "In general, we try and keep @return statements as a single \"statement\" (without a period), so something like @return the requested write size, and then additional clarifying comments go in the body.\nAlso, looking at \"Index iteration stops when exceeding this size.\", the way I read that is that it stops, like, \"iterating over the index and the build stops\" or something when it hits the limit, which I don't think is what you're getting at. I think something like \"transactions started as part of the index build will be committed after they exceed this size, and a new transaction will be started\", or something like that.", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/999#discussion_r458915379", "createdAt": "2020-07-22T16:19:01Z", "author": {"login": "alecgrieser"}, "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/provider/foundationdb/OnlineIndexer.java", "diffHunk": "@@ -1807,6 +1868,28 @@ public Builder setLimit(int limit) {\n             return this;\n         }\n \n+        /**\n+         * Get the approximate maximum transaction write size. Note that the actual size might be \"a little\" bigger.\n+         * @return the requested write size. Index iteration stops when exceeding this size.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "46ad4dbf74eb5bc9039eec4201085a9b18723355"}, "originalPosition": 186}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODkxNzkxMg==", "bodyText": "In a similar vein (presented mostly for parallelism, but this really should be whatever is decided for the first timer option, but adapted for this one).\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    /** The number of indexer range termination by write limit {@link OnlineIndexer}. */\n          \n          \n            \n                    /** The number of {@OnlineIndexer} range scans terminated after hitting the by write limit. */", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/999#discussion_r458917912", "createdAt": "2020-07-22T16:22:18Z", "author": {"login": "alecgrieser"}, "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/provider/foundationdb/FDBStoreTimer.java", "diffHunk": "@@ -570,6 +570,10 @@ public String logKey() {\n         ONLINE_INDEX_BUILDER_RECORDS_SCANNED(\"number of records scanned by online index build\", false),\n         /** The number of records indexed by {@link OnlineIndexer}. */\n         ONLINE_INDEX_BUILDER_RECORDS_INDEXED(\"number of records indexed by online index build\", false),\n+        /** The number of indexer range termination by scan limit {@link OnlineIndexer}. */\n+        ONLINE_INDEX_BUILDER_RANGE_BY_COUNT(\"number of indexer iterations terminated by scan limit\", false),\n+        /** The number of indexer range termination by write limit {@link OnlineIndexer}. */", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "46ad4dbf74eb5bc9039eec4201085a9b18723355"}, "originalPosition": 6}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODkyMTEwNQ==", "bodyText": "I suppose 900 kiB is a fine enough default size as any, though I believe that the FDB limits use base-1000 rather than base-1024 units in general (that is to say, the absolute maximum transaction size is 10 MB = 10 * 106 B, not 10 MiB = 10 * 220 B).", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/999#discussion_r458921105", "createdAt": "2020-07-22T16:25:21Z", "author": {"login": "alecgrieser"}, "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/provider/foundationdb/OnlineIndexer.java", "diffHunk": "@@ -126,6 +127,10 @@\n      * Default number of records to attempt to run in a single transaction.\n      */\n     public static final int DEFAULT_LIMIT = 100;\n+    /**\n+     * Default transaction write size limit. Note that the actual write might be \"a little\" bigger.\n+     */\n+    public static final int DEFAULT_WRITE_SIZE = 900 * 1024;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "46ad4dbf74eb5bc9039eec4201085a9b18723355"}, "originalPosition": 15}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODkyNTA3NA==", "bodyText": "I think this can be .thenApply instead of .thenCompose, and then it would return false and true instead of READY_FALSE and READY_TRUE.", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/999#discussion_r458925074", "createdAt": "2020-07-22T16:30:12Z", "author": {"login": "alecgrieser"}, "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/provider/foundationdb/OnlineIndexer.java", "diffHunk": "@@ -558,27 +563,55 @@ private void increaseLimit() {\n         // Note: This runs all of the updates in serial in order to not invoke a race condition\n         // in the rank code that was causing incorrect results. If everything were thread safe,\n         // a larger pipeline size would be possible.\n-        return cursor.forEachResultAsync(result -> {\n+\n+        final AtomicReference<RecordCursorResult<FDBStoredRecord<Message>>> holder = new AtomicReference<>(RecordCursorResult.exhausted());\n+        final FDBRecordContext context = store.getContext();\n+        return AsyncUtil.whileTrue(() -> cursor.onNext().thenCompose(result -> {\n+\n+            if (!result.hasNext()) {\n+                // end of the cursor list\n+                if (timer != null) {\n+                    timer.increment(FDBStoreTimer.Counts.ONLINE_INDEX_BUILDER_RANGE_BY_COUNT);\n+                }\n+                holder.set(result);\n+                return AsyncUtil.READY_FALSE;\n+            }\n+\n+            // here: implement forEachResultAsync\n             final FDBStoredRecord<Message> rec = result.get();\n             empty.set(false);\n             if (timer != null) {\n                 timer.increment(FDBStoreTimer.Counts.ONLINE_INDEX_BUILDER_RECORDS_SCANNED);\n             }\n             recordsScannedCounter.incrementAndGet();\n-            if (recordTypes.contains(rec.getRecordType())) {\n-                if (timer != null) {\n-                    timer.increment(FDBStoreTimer.Counts.ONLINE_INDEX_BUILDER_RECORDS_INDEXED);\n-                }\n-                if (syntheticPlan == null) {\n-                    return maintainer.update(null, rec);\n-                } else {\n-                    // Pipeline size is 1, since not all maintainers are thread-safe.\n-                    return syntheticPlan.execute(store, rec).forEachAsync(syntheticRecord -> maintainer.update(null, syntheticRecord), 1);\n-                }\n-            } else {\n-                return AsyncUtil.DONE;\n+            if (!recordTypes.contains(rec.getRecordType())) {\n+                // This record is not our type, swipe left\n+                return AsyncUtil.READY_TRUE;\n             }\n-        }).thenCompose(noNextResult -> {\n+            // here: add this index to the transaction\n+            if (timer != null) {\n+                timer.increment(FDBStoreTimer.Counts.ONLINE_INDEX_BUILDER_RECORDS_INDEXED);\n+            }\n+            return (syntheticPlan == null ?\n+                    maintainer.update(null, rec) :\n+                    syntheticPlan.execute(store, rec)\n+                            .forEachAsync(syntheticRecord -> maintainer.update(null, syntheticRecord), 1)\n+                    ).thenCompose(vignore ->\n+                    context.getApproximateTransactionSize().thenCompose(size -> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "46ad4dbf74eb5bc9039eec4201085a9b18723355"}, "originalPosition": 71}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODkyODMxMA==", "bodyText": "This appears to still be true, at least the way I'm reading the code", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/999#discussion_r458928310", "createdAt": "2020-07-22T16:33:38Z", "author": {"login": "alecgrieser"}, "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/provider/foundationdb/OnlineIndexer.java", "diffHunk": "@@ -558,27 +563,55 @@ private void increaseLimit() {\n         // Note: This runs all of the updates in serial in order to not invoke a race condition", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODU1NjI3Mg=="}, "originalCommit": {"oid": "46ad4dbf74eb5bc9039eec4201085a9b18723355"}, "originalPosition": 20}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODkzMDE3MA==", "bodyText": "Hm, I'm not sure this separate transaction is necessary, though the other OnlineIndexer-related tests in this file are doing it, so \u00af\\_(\u30c4)_/\u00af", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/999#discussion_r458930170", "createdAt": "2020-07-22T16:36:35Z", "author": {"login": "alecgrieser"}, "path": "fdb-record-layer-core/src/test/java/com/apple/foundationdb/record/provider/foundationdb/RecordTypeKeyTest.java", "diffHunk": "@@ -697,5 +698,96 @@ private void saveManyRecords(@Nonnull RecordMetaDataHook hook, int count1, int c\n             context.commit();\n         }\n     }\n+    \n+    @Test\n+    public void testOnlineIndexBuilderMaxWrite() throws Exception {\n+        try (FDBRecordContext context = openContext()) {\n+            uncheckedOpenSimpleRecordStore(context, BASIC_HOOK);\n+            recordStore.checkVersion(null, FDBRecordStoreBase.StoreExistenceCheck.ERROR_IF_EXISTS).join();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "46ad4dbf74eb5bc9039eec4201085a9b18723355"}, "originalPosition": 17}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODkzMTgzNg==", "bodyText": "I could also believe that a separate OnlineIndexerWithRecordTypeKeysTest.java (or something like that) could be a good idea, and that the other tests of the online indexer in this file could be moved there.\nOr, actually, perhaps more holistically, I think we don't (necessarily) want to test this with a test of RecordTypeKeys, but instead probably just want a test with some of the more traditional OnlineIndexer tests in OnlineIndexerSimpleTest.", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/999#discussion_r458931836", "createdAt": "2020-07-22T16:39:16Z", "author": {"login": "alecgrieser"}, "path": "fdb-record-layer-core/src/test/java/com/apple/foundationdb/record/provider/foundationdb/RecordTypeKeyTest.java", "diffHunk": "@@ -697,5 +698,96 @@ private void saveManyRecords(@Nonnull RecordMetaDataHook hook, int count1, int c\n             context.commit();\n         }\n     }\n+    \n+    @Test\n+    public void testOnlineIndexBuilderMaxWrite() throws Exception {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODU1MTA4NQ=="}, "originalCommit": {"oid": "46ad4dbf74eb5bc9039eec4201085a9b18723355"}, "originalPosition": 14}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4ed04378e5b165c38c7e38c0894cf17bc827d9ad", "author": {"user": {"login": "jjezra", "name": "Josef Ezra"}}, "url": "https://github.com/FoundationDB/fdb-record-layer/commit/4ed04378e5b165c38c7e38c0894cf17bc827d9ad", "committedDate": "2020-07-22T20:38:18Z", "message": "Apply changes requested by Tao & Alec."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDUzNzI2NDM0", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/999#pullrequestreview-453726434", "createdAt": "2020-07-22T22:22:36Z", "commit": {"oid": "4ed04378e5b165c38c7e38c0894cf17bc827d9ad"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMlQyMjoyMjozNlrOG12S2A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMlQyMjozMDowMlrOG12deQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTExNzI3Mg==", "bodyText": "I think we still want to have that hypothetical comment. At the moment, we can't do anything in parallel, but at some point we will... It probably doesn't matter too much, and I think the main upshot from this change is that we'd need to think about how to pipeline the .whileTrue, etc.", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/999#discussion_r459117272", "createdAt": "2020-07-22T22:22:36Z", "author": {"login": "alecgrieser"}, "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/provider/foundationdb/OnlineIndexer.java", "diffHunk": "@@ -558,27 +563,55 @@ private void increaseLimit() {\n         // Note: This runs all of the updates in serial in order to not invoke a race condition", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODU1NjI3Mg=="}, "originalCommit": {"oid": "46ad4dbf74eb5bc9039eec4201085a9b18723355"}, "originalPosition": 20}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTExOTc3MA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                // case 2: synatheticPlan - note that Pipeline size is 1, since not all maintainers are thread-safe.\n          \n          \n            \n                                // case 2: syntheticPlan - note that Pipeline size is 1, since not all maintainers are thread-safe.", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/999#discussion_r459119770", "createdAt": "2020-07-22T22:29:24Z", "author": {"login": "alecgrieser"}, "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/provider/foundationdb/OnlineIndexer.java", "diffHunk": "@@ -556,29 +561,57 @@ private void increaseLimit() {\n \n         AtomicLong recordsScannedCounter = new AtomicLong();\n         // Note: This runs all of the updates in serial in order to not invoke a race condition\n-        // in the rank code that was causing incorrect results. If everything were thread safe,\n-        // a larger pipeline size would be possible.\n-        return cursor.forEachResultAsync(result -> {\n+        // in the rank code that was causing incorrect results.\n+\n+        final AtomicReference<RecordCursorResult<FDBStoredRecord<Message>>> lastResult = new AtomicReference<>(RecordCursorResult.exhausted());\n+        final FDBRecordContext context = store.getContext();\n+        return AsyncUtil.whileTrue(() -> cursor.onNext().thenCompose(result -> {\n+\n+            if (!result.hasNext()) {\n+                // end of the cursor list\n+                if (timer != null) {\n+                    timer.increment(FDBStoreTimer.Counts.ONLINE_INDEX_BUILDER_RANGE_BY_COUNT);\n+                }\n+                lastResult.set(result);\n+                return AsyncUtil.READY_FALSE;\n+            }\n+\n             final FDBStoredRecord<Message> rec = result.get();\n             empty.set(false);\n             if (timer != null) {\n                 timer.increment(FDBStoreTimer.Counts.ONLINE_INDEX_BUILDER_RECORDS_SCANNED);\n             }\n             recordsScannedCounter.incrementAndGet();\n-            if (recordTypes.contains(rec.getRecordType())) {\n-                if (timer != null) {\n-                    timer.increment(FDBStoreTimer.Counts.ONLINE_INDEX_BUILDER_RECORDS_INDEXED);\n-                }\n-                if (syntheticPlan == null) {\n-                    return maintainer.update(null, rec);\n-                } else {\n-                    // Pipeline size is 1, since not all maintainers are thread-safe.\n-                    return syntheticPlan.execute(store, rec).forEachAsync(syntheticRecord -> maintainer.update(null, syntheticRecord), 1);\n-                }\n-            } else {\n-                return AsyncUtil.DONE;\n+            if (!recordTypes.contains(rec.getRecordType())) {\n+                // This record is not our type, swipe left\n+                return AsyncUtil.READY_TRUE;\n             }\n-        }).thenCompose(noNextResult -> {\n+            // add this index to the transaction\n+            if (timer != null) {\n+                timer.increment(FDBStoreTimer.Counts.ONLINE_INDEX_BUILDER_RECORDS_INDEXED);\n+            }\n+            return (syntheticPlan == null ?\n+                    // case 1: simple\n+                    maintainer.update(null, rec) :\n+                    // case 2: synatheticPlan - note that Pipeline size is 1, since not all maintainers are thread-safe.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4ed04378e5b165c38c7e38c0894cf17bc827d9ad"}, "originalPosition": 71}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTExOTk5Mw==", "bodyText": "I kind of liked @nblintao's suggestion to remove the ternary operator and make it a real if statement for readability, but I suppose it doesn't really matter", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/999#discussion_r459119993", "createdAt": "2020-07-22T22:30:02Z", "author": {"login": "alecgrieser"}, "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/provider/foundationdb/OnlineIndexer.java", "diffHunk": "@@ -556,29 +561,57 @@ private void increaseLimit() {\n \n         AtomicLong recordsScannedCounter = new AtomicLong();\n         // Note: This runs all of the updates in serial in order to not invoke a race condition\n-        // in the rank code that was causing incorrect results. If everything were thread safe,\n-        // a larger pipeline size would be possible.\n-        return cursor.forEachResultAsync(result -> {\n+        // in the rank code that was causing incorrect results.\n+\n+        final AtomicReference<RecordCursorResult<FDBStoredRecord<Message>>> lastResult = new AtomicReference<>(RecordCursorResult.exhausted());\n+        final FDBRecordContext context = store.getContext();\n+        return AsyncUtil.whileTrue(() -> cursor.onNext().thenCompose(result -> {\n+\n+            if (!result.hasNext()) {\n+                // end of the cursor list\n+                if (timer != null) {\n+                    timer.increment(FDBStoreTimer.Counts.ONLINE_INDEX_BUILDER_RANGE_BY_COUNT);\n+                }\n+                lastResult.set(result);\n+                return AsyncUtil.READY_FALSE;\n+            }\n+\n             final FDBStoredRecord<Message> rec = result.get();\n             empty.set(false);\n             if (timer != null) {\n                 timer.increment(FDBStoreTimer.Counts.ONLINE_INDEX_BUILDER_RECORDS_SCANNED);\n             }\n             recordsScannedCounter.incrementAndGet();\n-            if (recordTypes.contains(rec.getRecordType())) {\n-                if (timer != null) {\n-                    timer.increment(FDBStoreTimer.Counts.ONLINE_INDEX_BUILDER_RECORDS_INDEXED);\n-                }\n-                if (syntheticPlan == null) {\n-                    return maintainer.update(null, rec);\n-                } else {\n-                    // Pipeline size is 1, since not all maintainers are thread-safe.\n-                    return syntheticPlan.execute(store, rec).forEachAsync(syntheticRecord -> maintainer.update(null, syntheticRecord), 1);\n-                }\n-            } else {\n-                return AsyncUtil.DONE;\n+            if (!recordTypes.contains(rec.getRecordType())) {\n+                // This record is not our type, swipe left\n+                return AsyncUtil.READY_TRUE;\n             }\n-        }).thenCompose(noNextResult -> {\n+            // add this index to the transaction\n+            if (timer != null) {\n+                timer.increment(FDBStoreTimer.Counts.ONLINE_INDEX_BUILDER_RECORDS_INDEXED);\n+            }\n+            return (syntheticPlan == null ?\n+                    // case 1: simple\n+                    maintainer.update(null, rec) :\n+                    // case 2: synatheticPlan - note that Pipeline size is 1, since not all maintainers are thread-safe.\n+                    syntheticPlan.execute(store, rec\n+                    ).forEachAsync(syntheticRecord -> maintainer.update(null, syntheticRecord), 1)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4ed04378e5b165c38c7e38c0894cf17bc827d9ad"}, "originalPosition": 73}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "76b313f4067eb326350fca837c1d9ffcba7ba1c4", "author": {"user": {"login": "jjezra", "name": "Josef Ezra"}}, "url": "https://github.com/FoundationDB/fdb-record-layer/commit/76b313f4067eb326350fca837c1d9ffcba7ba1c4", "committedDate": "2020-07-23T00:49:28Z", "message": "Apply (more) change requests"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDU0NTQ3Njcy", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/999#pullrequestreview-454547672", "createdAt": "2020-07-23T22:53:25Z", "commit": {"oid": "76b313f4067eb326350fca837c1d9ffcba7ba1c4"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yM1QyMjo1MzoyNVrOG2eO6g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yM1QyMzowMzozM1rOG2ebhA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTc3MTYyNg==", "bodyText": "I still think these names seem to suggest that they are tracking the number of records scanned or bytes written, when they seem to actually be tracking the number of ranges scanned (by termination type)", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/999#discussion_r459771626", "createdAt": "2020-07-23T22:53:25Z", "author": {"login": "alecgrieser"}, "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/provider/foundationdb/FDBStoreTimer.java", "diffHunk": "@@ -570,6 +570,10 @@ public String logKey() {\n         ONLINE_INDEX_BUILDER_RECORDS_SCANNED(\"number of records scanned by online index build\", false),\n         /** The number of records indexed by {@link OnlineIndexer}. */\n         ONLINE_INDEX_BUILDER_RECORDS_INDEXED(\"number of records indexed by online index build\", false),\n+        /** The number of {@link OnlineIndexer} records scanned in a single iteration/transaction. */\n+        ONLINE_INDEX_BUILDER_RANGE_BY_COUNT(\"number of indexer iterations terminated by scan limit\", false),\n+        /** The number of {@link OnlineIndexer} bytes to write in a single iteration/transaction. */", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "76b313f4067eb326350fca837c1d9ffcba7ba1c4"}, "originalPosition": 6}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTc3MjAzMA==", "bodyText": "I'm still a little suprsed that the inner-most .thenCompose here can't be .thenApply.", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/999#discussion_r459772030", "createdAt": "2020-07-23T22:54:44Z", "author": {"login": "alecgrieser"}, "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/provider/foundationdb/OnlineIndexer.java", "diffHunk": "@@ -558,27 +563,55 @@ private void increaseLimit() {\n         // Note: This runs all of the updates in serial in order to not invoke a race condition\n         // in the rank code that was causing incorrect results. If everything were thread safe,\n         // a larger pipeline size would be possible.\n-        return cursor.forEachResultAsync(result -> {\n+\n+        final AtomicReference<RecordCursorResult<FDBStoredRecord<Message>>> holder = new AtomicReference<>(RecordCursorResult.exhausted());\n+        final FDBRecordContext context = store.getContext();\n+        return AsyncUtil.whileTrue(() -> cursor.onNext().thenCompose(result -> {\n+\n+            if (!result.hasNext()) {\n+                // end of the cursor list\n+                if (timer != null) {\n+                    timer.increment(FDBStoreTimer.Counts.ONLINE_INDEX_BUILDER_RANGE_BY_COUNT);\n+                }\n+                holder.set(result);\n+                return AsyncUtil.READY_FALSE;\n+            }\n+\n+            // here: implement forEachResultAsync\n             final FDBStoredRecord<Message> rec = result.get();\n             empty.set(false);\n             if (timer != null) {\n                 timer.increment(FDBStoreTimer.Counts.ONLINE_INDEX_BUILDER_RECORDS_SCANNED);\n             }\n             recordsScannedCounter.incrementAndGet();\n-            if (recordTypes.contains(rec.getRecordType())) {\n-                if (timer != null) {\n-                    timer.increment(FDBStoreTimer.Counts.ONLINE_INDEX_BUILDER_RECORDS_INDEXED);\n-                }\n-                if (syntheticPlan == null) {\n-                    return maintainer.update(null, rec);\n-                } else {\n-                    // Pipeline size is 1, since not all maintainers are thread-safe.\n-                    return syntheticPlan.execute(store, rec).forEachAsync(syntheticRecord -> maintainer.update(null, syntheticRecord), 1);\n-                }\n-            } else {\n-                return AsyncUtil.DONE;\n+            if (!recordTypes.contains(rec.getRecordType())) {\n+                // This record is not our type, swipe left\n+                return AsyncUtil.READY_TRUE;\n             }\n-        }).thenCompose(noNextResult -> {\n+            // here: add this index to the transaction\n+            if (timer != null) {\n+                timer.increment(FDBStoreTimer.Counts.ONLINE_INDEX_BUILDER_RECORDS_INDEXED);\n+            }\n+            return (syntheticPlan == null ?\n+                    maintainer.update(null, rec) :\n+                    syntheticPlan.execute(store, rec)\n+                            .forEachAsync(syntheticRecord -> maintainer.update(null, syntheticRecord), 1)\n+                    ).thenCompose(vignore ->\n+                    context.getApproximateTransactionSize().thenCompose(size -> {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODkyNTA3NA=="}, "originalCommit": {"oid": "46ad4dbf74eb5bc9039eec4201085a9b18723355"}, "originalPosition": 71}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTc3NDg1Mg==", "bodyText": "I think this probably could use one more test where it calls OnlineIndexer.buildIndex (i.e., building the index across multiple transactions) and makes sure that we get a built index, at the end of it.", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/999#discussion_r459774852", "createdAt": "2020-07-23T23:03:33Z", "author": {"login": "alecgrieser"}, "path": "fdb-record-layer-core/src/test/java/com/apple/foundationdb/record/provider/foundationdb/OnlineIndexerSimpleTest.java", "diffHunk": "@@ -883,4 +883,88 @@ public void testConfigLoader() throws Exception {\n             assertThat(\"Should have done several transactions in a few seconds\", pass, lessThan(100));\n         }\n     }\n+\n+    @Test\n+    public void testOnlineIndexerBuilderWriteLimitBytes() {\n+        List<TestRecords1Proto.MySimpleRecord> records = LongStream.range(0, 200).mapToObj( val ->\n+                TestRecords1Proto.MySimpleRecord.newBuilder().setRecNo(val).setNumValue2((int)val + 1).build()\n+        ).collect(Collectors.toList());\n+        Index index = new Index(\"newIndex\", field(\"num_value_2\").ungrouped(), IndexTypes.SUM);\n+        IndexAggregateFunction aggregateFunction = new IndexAggregateFunction(FunctionNames.SUM, index.getRootExpression(), index.getName());\n+        List<String> indexTypes = Collections.singletonList(\"MySimpleRecord\");\n+        FDBRecordStoreTestBase.RecordMetaDataHook hook = metaDataBuilder -> metaDataBuilder.addIndex(\"MySimpleRecord\", index);\n+\n+        openSimpleMetaData();\n+        try (FDBRecordContext context = openContext()) {\n+            records.forEach(recordStore::saveRecord);\n+            context.commit();\n+        }\n+\n+        final Supplier<Tuple> getAggregate = () -> {\n+            Tuple ret;\n+            try (FDBRecordContext context = openContext()) {\n+                assertTrue(recordStore.uncheckedMarkIndexReadable(index.getName()).join());\n+                FDBRecordStore recordStore2 = recordStore.asBuilder().setContext(context).uncheckedOpen();\n+                ret = recordStore2.evaluateAggregateFunction(indexTypes, aggregateFunction, TupleRange.ALL, IsolationLevel.SERIALIZABLE).join();\n+                // Do NOT commit changes\n+            }\n+            return ret;\n+        };\n+\n+        openSimpleMetaData(hook);\n+        final FDBStoreTimer timer = new FDBStoreTimer();\n+\n+        try (FDBRecordContext context = openContext()) {\n+            recordStore.checkVersion(null, FDBRecordStoreBase.StoreExistenceCheck.ERROR_IF_NOT_EXISTS).join();\n+\n+            timer.reset();\n+\n+            // Build in this transaction.\n+            try (OnlineIndexer indexer =\n+                         OnlineIndexer.newBuilder()\n+                                 .setRecordStore(recordStore)\n+                                 .setTimer(timer)\n+                                 .setIndex(\"newIndex\")\n+                                 .setLimit(100000)\n+                                 .setMaxWriteLimitBytes(1)\n+                                 .build()) {\n+                // this call will \"flatten\" the staccato iterations to a whole range. Testing compatibility.\n+                indexer.rebuildIndex(recordStore);\n+            }\n+            recordStore.markIndexReadable(\"newIndex\").join();\n+\n+            assertEquals(200, timer.getCount(FDBStoreTimer.Counts.ONLINE_INDEX_BUILDER_RECORDS_SCANNED));\n+            assertEquals(200, timer.getCount(FDBStoreTimer.Counts.ONLINE_INDEX_BUILDER_RECORDS_INDEXED));\n+\n+            assertEquals(200, timer.getCount(FDBStoreTimer.Counts.ONLINE_INDEX_BUILDER_RANGE_BY_SIZE));\n+            assertEquals(0, timer.getCount(FDBStoreTimer.Counts.ONLINE_INDEX_BUILDER_RANGE_BY_COUNT));\n+\n+            recordStore.clearAndMarkIndexWriteOnly(\"newIndex\").join();\n+            context.commit();\n+        }\n+\n+        try (FDBRecordContext context = openContext()) {\n+            recordStore.checkVersion(null, FDBRecordStoreBase.StoreExistenceCheck.ERROR_IF_NOT_EXISTS).join();\n+\n+            timer.reset();\n+\n+            // Build in this transaction.\n+            try (OnlineIndexer indexer =\n+                         OnlineIndexer.newBuilder()\n+                                 .setRecordStore(recordStore)\n+                                 .setTimer(timer)\n+                                 .setIndex(\"newIndex\")\n+                                 .setLimit(100000)\n+                                 .setMaxWriteLimitBytes(1)\n+                                 .build()) {\n+\n+                Key.Evaluated key = indexer.buildUnbuiltRange(Key.Evaluated.scalar(0L), Key.Evaluated.scalar(25L)).join();\n+                assertEquals(1, key.getLong(0));\n+                assertEquals(1, timer.getCount(FDBStoreTimer.Counts.ONLINE_INDEX_BUILDER_RANGE_BY_SIZE));\n+                assertEquals(0, timer.getCount(FDBStoreTimer.Counts.ONLINE_INDEX_BUILDER_RANGE_BY_COUNT));\n+            }\n+            recordStore.clearAndMarkIndexWriteOnly(\"newIndex\").join();\n+            context.commit();\n+        }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "76b313f4067eb326350fca837c1d9ffcba7ba1c4"}, "originalPosition": 86}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e4520c538e0dbe6679dd075a7d2472d690bfb26f", "author": {"user": {"login": "jjezra", "name": "Josef Ezra"}}, "url": "https://github.com/FoundationDB/fdb-record-layer/commit/e4520c538e0dbe6679dd075a7d2472d690bfb26f", "committedDate": "2020-07-24T00:08:00Z", "message": "Apply two more changes:\n\n   1. better comments\n   2. thenCompose ==>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "168cd17194d31a6b725a0c2863277ee8cd0ab3b3", "author": {"user": {"login": "jjezra", "name": "Josef Ezra"}}, "url": "https://github.com/FoundationDB/fdb-record-layer/commit/168cd17194d31a6b725a0c2863277ee8cd0ab3b3", "committedDate": "2020-07-24T19:32:04Z", "message": ".._RANGE_.. => .._RANGES_.."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "d1c535139f1f5d604ebcac7d70ed2b3408f92f88", "author": {"user": {"login": "jjezra", "name": "Josef Ezra"}}, "url": "https://github.com/FoundationDB/fdb-record-layer/commit/d1c535139f1f5d604ebcac7d70ed2b3408f92f88", "committedDate": "2020-07-24T19:18:43Z", "message": ".._RANGE_.. => .._RANGES_.."}, "afterCommit": {"oid": "168cd17194d31a6b725a0c2863277ee8cd0ab3b3", "author": {"user": {"login": "jjezra", "name": "Josef Ezra"}}, "url": "https://github.com/FoundationDB/fdb-record-layer/commit/168cd17194d31a6b725a0c2863277ee8cd0ab3b3", "committedDate": "2020-07-24T19:32:04Z", "message": ".._RANGE_.. => .._RANGES_.."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "45095f16528cea8e6a4ed886e609fcc59284ce55", "author": {"user": {"login": "jjezra", "name": "Josef Ezra"}}, "url": "https://github.com/FoundationDB/fdb-record-layer/commit/45095f16528cea8e6a4ed886e609fcc59284ce55", "committedDate": "2020-07-24T21:35:31Z", "message": "Add an indexer.buildIndex test"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDU1MjAwNDEw", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/999#pullrequestreview-455200410", "createdAt": "2020-07-24T21:41:19Z", "commit": {"oid": "45095f16528cea8e6a4ed886e609fcc59284ce55"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDU1MjIzNDM1", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/999#pullrequestreview-455223435", "createdAt": "2020-07-24T22:52:18Z", "commit": {"oid": "45095f16528cea8e6a4ed886e609fcc59284ce55"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2696, "cost": 1, "resetAt": "2021-11-01T14:20:25Z"}}}