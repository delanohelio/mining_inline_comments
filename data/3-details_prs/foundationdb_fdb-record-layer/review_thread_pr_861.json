{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzkwNjc1OTEz", "number": 861, "reviewThreads": {"totalCount": 9, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOVQxNzoyNjo1M1rODpmzpw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNVQxNzo1NzozNFrODrVTAg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ0OTU0MDIzOnYy", "diffSide": "RIGHT", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/RecordQueryPlanner.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOVQxNzoyNjo1M1rOF447sw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNVQxNzozMjo1M1rOF7mgEQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTE5NzM2Mw==", "bodyText": "Do we want to have some switch / threshold in the planner config to allow this to be introduced gracefully?", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/861#discussion_r395197363", "createdAt": "2020-03-19T17:26:53Z", "author": {"login": "MMcM"}, "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/RecordQueryPlanner.java", "diffHunk": "@@ -340,12 +341,27 @@ private ScoredPlan planFilter(@Nonnull PlanContext planContext, @Nonnull QueryCo\n     @Nullable\n     private ScoredPlan planFilter(@Nonnull PlanContext planContext, @Nonnull QueryComponent filter, boolean needOrdering) {\n         final InExtractor inExtractor = new InExtractor(filter);\n+        ScoredPlan withInAsOr = null;\n         if (planContext.query.getSort() != null) {\n-            inExtractor.setSort(planContext.query.getSort(), planContext.query.isSortReverse());\n+            if (!inExtractor.setSort(planContext.query.getSort(), planContext.query.isSortReverse())) {\n+                // Can't implement as an in join because of the sort order. Try as an OR instead.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "916964d87e7551126e234b29d292eb77604d0962"}, "originalPosition": 16}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTIwODgxOA==", "bodyText": "That seems like a reasonable thing to do. I'll add a configuration option to RecordQueryPlanner.", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/861#discussion_r395208818", "createdAt": "2020-03-19T17:44:06Z", "author": {"login": "nschiefer"}, "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/RecordQueryPlanner.java", "diffHunk": "@@ -340,12 +341,27 @@ private ScoredPlan planFilter(@Nonnull PlanContext planContext, @Nonnull QueryCo\n     @Nullable\n     private ScoredPlan planFilter(@Nonnull PlanContext planContext, @Nonnull QueryComponent filter, boolean needOrdering) {\n         final InExtractor inExtractor = new InExtractor(filter);\n+        ScoredPlan withInAsOr = null;\n         if (planContext.query.getSort() != null) {\n-            inExtractor.setSort(planContext.query.getSort(), planContext.query.isSortReverse());\n+            if (!inExtractor.setSort(planContext.query.getSort(), planContext.query.isSortReverse())) {\n+                // Can't implement as an in join because of the sort order. Try as an OR instead.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTE5NzM2Mw=="}, "originalCommit": {"oid": "916964d87e7551126e234b29d292eb77604d0962"}, "originalPosition": 16}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzkzOTIzOA==", "bodyText": "Done, with some slight gymnastics to keep a backwards-compatible API. I don't know if I got the right balance but I tried. \u00af_(\u30c4)_/\u00af", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/861#discussion_r397939238", "createdAt": "2020-03-25T15:20:11Z", "author": {"login": "nschiefer"}, "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/RecordQueryPlanner.java", "diffHunk": "@@ -340,12 +341,27 @@ private ScoredPlan planFilter(@Nonnull PlanContext planContext, @Nonnull QueryCo\n     @Nullable\n     private ScoredPlan planFilter(@Nonnull PlanContext planContext, @Nonnull QueryComponent filter, boolean needOrdering) {\n         final InExtractor inExtractor = new InExtractor(filter);\n+        ScoredPlan withInAsOr = null;\n         if (planContext.query.getSort() != null) {\n-            inExtractor.setSort(planContext.query.getSort(), planContext.query.isSortReverse());\n+            if (!inExtractor.setSort(planContext.query.getSort(), planContext.query.isSortReverse())) {\n+                // Can't implement as an in join because of the sort order. Try as an OR instead.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTE5NzM2Mw=="}, "originalCommit": {"oid": "916964d87e7551126e234b29d292eb77604d0962"}, "originalPosition": 16}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODA0MTEwNQ==", "bodyText": "Looks like you dropped this: \\", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/861#discussion_r398041105", "createdAt": "2020-03-25T17:32:53Z", "author": {"login": "alecgrieser"}, "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/RecordQueryPlanner.java", "diffHunk": "@@ -340,12 +341,27 @@ private ScoredPlan planFilter(@Nonnull PlanContext planContext, @Nonnull QueryCo\n     @Nullable\n     private ScoredPlan planFilter(@Nonnull PlanContext planContext, @Nonnull QueryComponent filter, boolean needOrdering) {\n         final InExtractor inExtractor = new InExtractor(filter);\n+        ScoredPlan withInAsOr = null;\n         if (planContext.query.getSort() != null) {\n-            inExtractor.setSort(planContext.query.getSort(), planContext.query.isSortReverse());\n+            if (!inExtractor.setSort(planContext.query.getSort(), planContext.query.isSortReverse())) {\n+                // Can't implement as an in join because of the sort order. Try as an OR instead.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTE5NzM2Mw=="}, "originalCommit": {"oid": "916964d87e7551126e234b29d292eb77604d0962"}, "originalPosition": 16}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ2NjkyNTI3OnYy", "diffSide": "RIGHT", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/RecordQueryPlanner.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNVQxNToyMjo0MFrOF7gaKg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNVQxNToyNToxN1rOF7giZA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Nzk0MTI5MA==", "bodyText": "I'm not sure whether to gate this behind the config parameter, too. That feels hacky, but is probably safer.", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/861#discussion_r397941290", "createdAt": "2020-03-25T15:22:40Z", "author": {"login": "nschiefer"}, "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/RecordQueryPlanner.java", "diffHunk": "@@ -1195,7 +1236,7 @@ private ScoredPlan planOrderedUnion(@Nonnull PlanContext planContext, @Nonnull L\n         if (unionPlan.getComplexity() > complexityThreshold) {\n             throw new RecordQueryPlanComplexityException(unionPlan);\n         }\n-        return new ScoredPlan(1, unionPlan, Collections.emptyList(), anyDuplicates, includedRankComparisons);\n+        return new ScoredPlan(0, unionPlan, Collections.emptyList(), anyDuplicates, includedRankComparisons);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4ce8f795862004af1d7312b958b0b342d347ea15"}, "originalPosition": 119}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Nzk0MzM5Ng==", "bodyText": "Yeah, that is probably safer, since reasoning about these constant scores is sometimes tricky.", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/861#discussion_r397943396", "createdAt": "2020-03-25T15:25:17Z", "author": {"login": "MMcM"}, "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/RecordQueryPlanner.java", "diffHunk": "@@ -1195,7 +1236,7 @@ private ScoredPlan planOrderedUnion(@Nonnull PlanContext planContext, @Nonnull L\n         if (unionPlan.getComplexity() > complexityThreshold) {\n             throw new RecordQueryPlanComplexityException(unionPlan);\n         }\n-        return new ScoredPlan(1, unionPlan, Collections.emptyList(), anyDuplicates, includedRankComparisons);\n+        return new ScoredPlan(0, unionPlan, Collections.emptyList(), anyDuplicates, includedRankComparisons);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Nzk0MTI5MA=="}, "originalCommit": {"oid": "4ce8f795862004af1d7312b958b0b342d347ea15"}, "originalPosition": 119}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ2NzUyNTQxOnYy", "diffSide": "RIGHT", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/RecordQueryPlanner.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNVQxNzoyOTo1OVrOF7mYZA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNVQxODoxNzowN1rOF7oVTQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODAzOTE0MA==", "bodyText": "Oh, hm. So this essentially relies on the side effect from this operation? I don't love having this happen within the if-condition (rather than it happening on the previous line and capturing the success or failure as an explicit boolean) as I don't think people expect side effects there. But it's probably acceptable if we want to keep it like this and take the PR prior to changing it (and the comment helps).", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/861#discussion_r398039140", "createdAt": "2020-03-25T17:29:59Z", "author": {"login": "alecgrieser"}, "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/RecordQueryPlanner.java", "diffHunk": "@@ -341,12 +366,28 @@ private ScoredPlan planFilter(@Nonnull PlanContext planContext, @Nonnull QueryCo\n     @Nullable\n     private ScoredPlan planFilter(@Nonnull PlanContext planContext, @Nonnull QueryComponent filter, boolean needOrdering) {\n         final InExtractor inExtractor = new InExtractor(filter);\n+        ScoredPlan withInAsOr = null;\n         if (planContext.query.getSort() != null) {\n-            inExtractor.setSort(planContext.query.getSort(), planContext.query.isSortReverse());\n+            if (!inExtractor.setSort(planContext.query.getSort(), planContext.query.isSortReverse()) && // needs to come first, to clear sort", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0546106d225ce2c1e9e61012ad27bb0f6298d4b1"}, "originalPosition": 90}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODA2MjYxMg==", "bodyText": "I'm happy to extract this as a boolean. I don't really want to do a larger refactor, since this was definitely meant to perturb things as little as possible.", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/861#discussion_r398062612", "createdAt": "2020-03-25T18:03:55Z", "author": {"login": "nschiefer"}, "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/RecordQueryPlanner.java", "diffHunk": "@@ -341,12 +366,28 @@ private ScoredPlan planFilter(@Nonnull PlanContext planContext, @Nonnull QueryCo\n     @Nullable\n     private ScoredPlan planFilter(@Nonnull PlanContext planContext, @Nonnull QueryComponent filter, boolean needOrdering) {\n         final InExtractor inExtractor = new InExtractor(filter);\n+        ScoredPlan withInAsOr = null;\n         if (planContext.query.getSort() != null) {\n-            inExtractor.setSort(planContext.query.getSort(), planContext.query.isSortReverse());\n+            if (!inExtractor.setSort(planContext.query.getSort(), planContext.query.isSortReverse()) && // needs to come first, to clear sort", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODAzOTE0MA=="}, "originalCommit": {"oid": "0546106d225ce2c1e9e61012ad27bb0f6298d4b1"}, "originalPosition": 90}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODA2NjQ4OA==", "bodyText": "Yeah, don't really need a larger refactor; was more just asking for it to be on its own line, though maybe that's not actually clearer.", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/861#discussion_r398066488", "createdAt": "2020-03-25T18:10:04Z", "author": {"login": "alecgrieser"}, "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/RecordQueryPlanner.java", "diffHunk": "@@ -341,12 +366,28 @@ private ScoredPlan planFilter(@Nonnull PlanContext planContext, @Nonnull QueryCo\n     @Nullable\n     private ScoredPlan planFilter(@Nonnull PlanContext planContext, @Nonnull QueryComponent filter, boolean needOrdering) {\n         final InExtractor inExtractor = new InExtractor(filter);\n+        ScoredPlan withInAsOr = null;\n         if (planContext.query.getSort() != null) {\n-            inExtractor.setSort(planContext.query.getSort(), planContext.query.isSortReverse());\n+            if (!inExtractor.setSort(planContext.query.getSort(), planContext.query.isSortReverse()) && // needs to come first, to clear sort", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODAzOTE0MA=="}, "originalCommit": {"oid": "0546106d225ce2c1e9e61012ad27bb0f6298d4b1"}, "originalPosition": 90}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODA3MTExNw==", "bodyText": "I think it's a little clearer.", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/861#discussion_r398071117", "createdAt": "2020-03-25T18:17:07Z", "author": {"login": "nschiefer"}, "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/RecordQueryPlanner.java", "diffHunk": "@@ -341,12 +366,28 @@ private ScoredPlan planFilter(@Nonnull PlanContext planContext, @Nonnull QueryCo\n     @Nullable\n     private ScoredPlan planFilter(@Nonnull PlanContext planContext, @Nonnull QueryComponent filter, boolean needOrdering) {\n         final InExtractor inExtractor = new InExtractor(filter);\n+        ScoredPlan withInAsOr = null;\n         if (planContext.query.getSort() != null) {\n-            inExtractor.setSort(planContext.query.getSort(), planContext.query.isSortReverse());\n+            if (!inExtractor.setSort(planContext.query.getSort(), planContext.query.isSortReverse()) && // needs to come first, to clear sort", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODAzOTE0MA=="}, "originalCommit": {"oid": "0546106d225ce2c1e9e61012ad27bb0f6298d4b1"}, "originalPosition": 90}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ2NzUzNDI0OnYy", "diffSide": "RIGHT", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/RecordQueryPlannerConfiguration.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNVQxNzozMjowN1rOF7meCQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNVQxODoxNTo1OVrOF7oScg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODA0MDU4NQ==", "bodyText": "At some point, we'll probably want to document what these configuration parameters actually do, but perhaps not today.", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/861#discussion_r398040585", "createdAt": "2020-03-25T17:32:07Z", "author": {"login": "alecgrieser"}, "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/RecordQueryPlannerConfiguration.java", "diffHunk": "@@ -0,0 +1,91 @@\n+/*\n+ * RecordQueryPlannerConfiguration.java\n+ *\n+ * This source file is part of the FoundationDB open source project\n+ *\n+ * Copyright 2015-2020 Apple Inc. and the FoundationDB project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.apple.foundationdb.record.query.plan;\n+\n+import com.apple.foundationdb.annotation.API;\n+\n+import javax.annotation.Nonnull;\n+\n+/**\n+ * A set of configuration options for the {@link RecordQueryPlanner}.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0546106d225ce2c1e9e61012ad27bb0f6298d4b1"}, "originalPosition": 28}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODA3MDM4Ng==", "bodyText": "Documented.", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/861#discussion_r398070386", "createdAt": "2020-03-25T18:15:59Z", "author": {"login": "nschiefer"}, "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/RecordQueryPlannerConfiguration.java", "diffHunk": "@@ -0,0 +1,91 @@\n+/*\n+ * RecordQueryPlannerConfiguration.java\n+ *\n+ * This source file is part of the FoundationDB open source project\n+ *\n+ * Copyright 2015-2020 Apple Inc. and the FoundationDB project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.apple.foundationdb.record.query.plan;\n+\n+import com.apple.foundationdb.annotation.API;\n+\n+import javax.annotation.Nonnull;\n+\n+/**\n+ * A set of configuration options for the {@link RecordQueryPlanner}.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODA0MDU4NQ=="}, "originalCommit": {"oid": "0546106d225ce2c1e9e61012ad27bb0f6298d4b1"}, "originalPosition": 28}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ2NzYxNTk1OnYy", "diffSide": "RIGHT", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/planning/InExtractor.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNVQxNzo1MToyMlrOF7nRbg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNVQxODowNTo0M1rOF7n4eQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODA1Mzc0Mg==", "bodyText": "It feels a little weird that this still calls cancel, with the new stuff. Like, in theory, it should be able to use the extracted sort components from the IN and then use a UnionPlan for the rest. Though I think it's still safe to do it as it is here, so perhaps an optimization for another time.", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/861#discussion_r398053742", "createdAt": "2020-03-25T17:51:22Z", "author": {"login": "alecgrieser"}, "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/planning/InExtractor.java", "diffHunk": "@@ -157,10 +193,11 @@ public void setSort(@Nonnull KeyExpression key, boolean reverse) {\n             if (!found) {\n                 // There is a requested sort ahead of the ones from the IN's, so we can't do it.\n                 cancel();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0546106d225ce2c1e9e61012ad27bb0f6298d4b1"}, "originalPosition": 101}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODA2MzczNw==", "bodyText": "Agreed, but I'd rather not mess with this code if we don't have to.", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/861#discussion_r398063737", "createdAt": "2020-03-25T18:05:43Z", "author": {"login": "nschiefer"}, "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/planning/InExtractor.java", "diffHunk": "@@ -157,10 +193,11 @@ public void setSort(@Nonnull KeyExpression key, boolean reverse) {\n             if (!found) {\n                 // There is a requested sort ahead of the ones from the IN's, so we can't do it.\n                 cancel();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODA1Mzc0Mg=="}, "originalCommit": {"oid": "0546106d225ce2c1e9e61012ad27bb0f6298d4b1"}, "originalPosition": 101}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ2NzYxOTc3OnYy", "diffSide": "RIGHT", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/RecordQueryPlanner.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNVQxNzo1MjoxNVrOF7nTxQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNVQxODowNjoyNlrOF7n6JQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODA1NDM0MQ==", "bodyText": "Hmm, interesting. Should the logic in the join filter that chooses between the Union and the InJoin be changed then (maybe ignoring the score if we can't trust it?).", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/861#discussion_r398054341", "createdAt": "2020-03-25T17:52:15Z", "author": {"login": "alecgrieser"}, "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/RecordQueryPlanner.java", "diffHunk": "@@ -1196,7 +1237,12 @@ private ScoredPlan planOrderedUnion(@Nonnull PlanContext planContext, @Nonnull L\n         if (unionPlan.getComplexity() > complexityThreshold) {\n             throw new RecordQueryPlanComplexityException(unionPlan);\n         }\n-        return new ScoredPlan(1, unionPlan, Collections.emptyList(), anyDuplicates, includedRankComparisons);\n+\n+        // If we don't change this when shouldAttemptFailedInJoinAsOr() is true, then we _always_ pick the union plan,\n+        // rather than the in join plan.\n+        int score = getConfiguration().shouldAttemptFailedInJoinAsOr() ? 0 : 1;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0546106d225ce2c1e9e61012ad27bb0f6298d4b1"}, "originalPosition": 122}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODA2NDE2NQ==", "bodyText": "Possibly. I'm a bit worried about doing so because I don't really know what the score is trying to capture. If we think that's lower risk, I'm for it.", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/861#discussion_r398064165", "createdAt": "2020-03-25T18:06:26Z", "author": {"login": "nschiefer"}, "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/RecordQueryPlanner.java", "diffHunk": "@@ -1196,7 +1237,12 @@ private ScoredPlan planOrderedUnion(@Nonnull PlanContext planContext, @Nonnull L\n         if (unionPlan.getComplexity() > complexityThreshold) {\n             throw new RecordQueryPlanComplexityException(unionPlan);\n         }\n-        return new ScoredPlan(1, unionPlan, Collections.emptyList(), anyDuplicates, includedRankComparisons);\n+\n+        // If we don't change this when shouldAttemptFailedInJoinAsOr() is true, then we _always_ pick the union plan,\n+        // rather than the in join plan.\n+        int score = getConfiguration().shouldAttemptFailedInJoinAsOr() ? 0 : 1;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODA1NDM0MQ=="}, "originalCommit": {"oid": "0546106d225ce2c1e9e61012ad27bb0f6298d4b1"}, "originalPosition": 122}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ2NzYyNjQ5OnYy", "diffSide": "RIGHT", "path": "fdb-record-layer-core/src/test/java/com/apple/foundationdb/record/provider/foundationdb/query/FDBInQueryTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNVQxNzo1Mzo0NlrOF7nX7Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNVQxODowODozMFrOF7n_bg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODA1NTQwNQ==", "bodyText": "I suppose technically, this could be a @DualPlannerTest, then (though not saying it should).\nOr this could assert the planner type so that if someone were to make it a DualPlannerTest at some point, they get an error rather than it succeeding for the wrong reasons.", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/861#discussion_r398055405", "createdAt": "2020-03-25T17:53:46Z", "author": {"login": "alecgrieser"}, "path": "fdb-record-layer-core/src/test/java/com/apple/foundationdb/record/provider/foundationdb/query/FDBInQueryTest.java", "diffHunk": "@@ -261,6 +267,77 @@ public void testInQueryIndexSortedDifferently() throws Exception {\n                 context -> TestHelpers.assertDiscardedAtMost(40, context)));\n     }\n \n+    /**\n+     * Verify that an IN query with a sort can be implemented as an ordered union of compound indexes that can satisfy\n+     * the sort once the equality predicates from the IN have been pushed onto the indexes.\n+     * @see com.apple.foundationdb.record.query.plan.planning.InExtractor#asOr()\n+     */\n+    @ParameterizedTest\n+    @BooleanSource\n+    public void inQueryWithSortBySecondFieldOfCompoundIndex(boolean shouldAttemptInAsOr) throws Exception {\n+        RecordMetaDataHook hook = metaData ->\n+                metaData.addIndex(\"MySimpleRecord\", \"compoundIndex\",\n+                        concat(field(\"num_value_3_indexed\"), field(\"str_value_indexed\")));\n+        complexQuerySetup(hook);\n+        final List<Integer> inList = asList(1, 4, 2);\n+        RecordQuery query = RecordQuery.newBuilder()\n+                .setRecordType(\"MySimpleRecord\")\n+                .setFilter(Query.field(\"num_value_3_indexed\").in(inList))\n+                .setSort(field(\"str_value_indexed\"))\n+                .build();\n+\n+        if (planner instanceof RecordQueryPlanner) { // will always be true, but it's good to check before casting", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0546106d225ce2c1e9e61012ad27bb0f6298d4b1"}, "originalPosition": 49}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODA2NTUxOA==", "bodyText": "I suppose it could. \ud83d\ude43\nI switched this to an assertion instead.", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/861#discussion_r398065518", "createdAt": "2020-03-25T18:08:30Z", "author": {"login": "nschiefer"}, "path": "fdb-record-layer-core/src/test/java/com/apple/foundationdb/record/provider/foundationdb/query/FDBInQueryTest.java", "diffHunk": "@@ -261,6 +267,77 @@ public void testInQueryIndexSortedDifferently() throws Exception {\n                 context -> TestHelpers.assertDiscardedAtMost(40, context)));\n     }\n \n+    /**\n+     * Verify that an IN query with a sort can be implemented as an ordered union of compound indexes that can satisfy\n+     * the sort once the equality predicates from the IN have been pushed onto the indexes.\n+     * @see com.apple.foundationdb.record.query.plan.planning.InExtractor#asOr()\n+     */\n+    @ParameterizedTest\n+    @BooleanSource\n+    public void inQueryWithSortBySecondFieldOfCompoundIndex(boolean shouldAttemptInAsOr) throws Exception {\n+        RecordMetaDataHook hook = metaData ->\n+                metaData.addIndex(\"MySimpleRecord\", \"compoundIndex\",\n+                        concat(field(\"num_value_3_indexed\"), field(\"str_value_indexed\")));\n+        complexQuerySetup(hook);\n+        final List<Integer> inList = asList(1, 4, 2);\n+        RecordQuery query = RecordQuery.newBuilder()\n+                .setRecordType(\"MySimpleRecord\")\n+                .setFilter(Query.field(\"num_value_3_indexed\").in(inList))\n+                .setSort(field(\"str_value_indexed\"))\n+                .build();\n+\n+        if (planner instanceof RecordQueryPlanner) { // will always be true, but it's good to check before casting", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODA1NTQwNQ=="}, "originalCommit": {"oid": "0546106d225ce2c1e9e61012ad27bb0f6298d4b1"}, "originalPosition": 49}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ2NzYzNzgzOnYy", "diffSide": "RIGHT", "path": "fdb-record-layer-core/src/test/java/com/apple/foundationdb/record/provider/foundationdb/query/FDBInQueryTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNVQxNzo1NjoyMFrOF7nfOg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNVQxODowODo1MVrOF7oAWw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODA1NzI3NA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    // A CNF who's DNF size doesn't fit in an int, expressed with IN predicates.\n          \n          \n            \n                    // A CNF whose DNF size doesn't fit in an int, expressed with IN predicates.\n          \n      \n    \n    \n  \n\nI'm sorry", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/861#discussion_r398057274", "createdAt": "2020-03-25T17:56:20Z", "author": {"login": "alecgrieser"}, "path": "fdb-record-layer-core/src/test/java/com/apple/foundationdb/record/provider/foundationdb/query/FDBInQueryTest.java", "diffHunk": "@@ -261,6 +267,77 @@ public void testInQueryIndexSortedDifferently() throws Exception {\n                 context -> TestHelpers.assertDiscardedAtMost(40, context)));\n     }\n \n+    /**\n+     * Verify that an IN query with a sort can be implemented as an ordered union of compound indexes that can satisfy\n+     * the sort once the equality predicates from the IN have been pushed onto the indexes.\n+     * @see com.apple.foundationdb.record.query.plan.planning.InExtractor#asOr()\n+     */\n+    @ParameterizedTest\n+    @BooleanSource\n+    public void inQueryWithSortBySecondFieldOfCompoundIndex(boolean shouldAttemptInAsOr) throws Exception {\n+        RecordMetaDataHook hook = metaData ->\n+                metaData.addIndex(\"MySimpleRecord\", \"compoundIndex\",\n+                        concat(field(\"num_value_3_indexed\"), field(\"str_value_indexed\")));\n+        complexQuerySetup(hook);\n+        final List<Integer> inList = asList(1, 4, 2);\n+        RecordQuery query = RecordQuery.newBuilder()\n+                .setRecordType(\"MySimpleRecord\")\n+                .setFilter(Query.field(\"num_value_3_indexed\").in(inList))\n+                .setSort(field(\"str_value_indexed\"))\n+                .build();\n+\n+        if (planner instanceof RecordQueryPlanner) { // will always be true, but it's good to check before casting\n+            RecordQueryPlanner recordQueryPlanner = (RecordQueryPlanner)planner;\n+            RecordQueryPlannerConfiguration configuration = recordQueryPlanner.getConfiguration();\n+            recordQueryPlanner.setConfiguration(recordQueryPlanner.getConfiguration().asBuilder()\n+                    .setAttemptFailedInJoinAsOr(shouldAttemptInAsOr)\n+                    .build());\n+\n+            RecordQueryPlan plan = planner.plan(query);\n+            if (shouldAttemptInAsOr) {\n+                // IN join is impossible because of incompatible sorting, but we can still plan as an OR on the compound index.\n+                assertThat(plan, union(inList.stream().map(number -> indexScan(allOf(indexName(\"compoundIndex\"),\n+                        bounds(hasTupleString(String.format(\"[[%d],[%d]]\", number, number)))))).collect(Collectors.toList()),\n+                        equalTo(concat(field(\"str_value_indexed\"), primaryKey(\"MySimpleRecord\")))));\n+                assertEquals(-1813975352, plan.planHash());\n+            } else {\n+                assertThat(plan, filter(equalTo(query.getFilter()), indexScan(allOf(indexName(\"MySimpleRecord$str_value_indexed\"), unbounded()))));\n+                assertEquals(1775865786, plan.planHash());\n+            }\n+\n+            assertEquals(60, querySimpleRecordStore(hook, plan, EvaluationContext::empty,\n+                    record -> assertThat(record.getNumValue3Indexed(), anyOf(is(1), is(2), is(4))),\n+                    context -> TestHelpers.assertDiscardedAtMost(40, context)));\n+        }\n+    }\n+\n+    /**\n+     * Verify that an IN predicate that, when converted to an OR of equality predicates, would lead to a very large DNF\n+     * gets planned as a normal IN query rather than throwing an exception.\n+     */\n+    @Test\n+    public void cnfAsInQuery() throws Exception {\n+        RecordMetaDataHook hook = metaData ->\n+                metaData.addIndex(\"MySimpleRecord\", \"compoundIndex\",\n+                        concat(field(\"num_value_3_indexed\"), field(\"str_value_indexed\")));\n+        complexQuerySetup(hook);\n+\n+        // A CNF who's DNF size doesn't fit in an int, expressed with IN predicates.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0546106d225ce2c1e9e61012ad27bb0f6298d4b1"}, "originalPosition": 85}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODA2NTc1NQ==", "bodyText": "Whoops, fixed.", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/861#discussion_r398065755", "createdAt": "2020-03-25T18:08:51Z", "author": {"login": "nschiefer"}, "path": "fdb-record-layer-core/src/test/java/com/apple/foundationdb/record/provider/foundationdb/query/FDBInQueryTest.java", "diffHunk": "@@ -261,6 +267,77 @@ public void testInQueryIndexSortedDifferently() throws Exception {\n                 context -> TestHelpers.assertDiscardedAtMost(40, context)));\n     }\n \n+    /**\n+     * Verify that an IN query with a sort can be implemented as an ordered union of compound indexes that can satisfy\n+     * the sort once the equality predicates from the IN have been pushed onto the indexes.\n+     * @see com.apple.foundationdb.record.query.plan.planning.InExtractor#asOr()\n+     */\n+    @ParameterizedTest\n+    @BooleanSource\n+    public void inQueryWithSortBySecondFieldOfCompoundIndex(boolean shouldAttemptInAsOr) throws Exception {\n+        RecordMetaDataHook hook = metaData ->\n+                metaData.addIndex(\"MySimpleRecord\", \"compoundIndex\",\n+                        concat(field(\"num_value_3_indexed\"), field(\"str_value_indexed\")));\n+        complexQuerySetup(hook);\n+        final List<Integer> inList = asList(1, 4, 2);\n+        RecordQuery query = RecordQuery.newBuilder()\n+                .setRecordType(\"MySimpleRecord\")\n+                .setFilter(Query.field(\"num_value_3_indexed\").in(inList))\n+                .setSort(field(\"str_value_indexed\"))\n+                .build();\n+\n+        if (planner instanceof RecordQueryPlanner) { // will always be true, but it's good to check before casting\n+            RecordQueryPlanner recordQueryPlanner = (RecordQueryPlanner)planner;\n+            RecordQueryPlannerConfiguration configuration = recordQueryPlanner.getConfiguration();\n+            recordQueryPlanner.setConfiguration(recordQueryPlanner.getConfiguration().asBuilder()\n+                    .setAttemptFailedInJoinAsOr(shouldAttemptInAsOr)\n+                    .build());\n+\n+            RecordQueryPlan plan = planner.plan(query);\n+            if (shouldAttemptInAsOr) {\n+                // IN join is impossible because of incompatible sorting, but we can still plan as an OR on the compound index.\n+                assertThat(plan, union(inList.stream().map(number -> indexScan(allOf(indexName(\"compoundIndex\"),\n+                        bounds(hasTupleString(String.format(\"[[%d],[%d]]\", number, number)))))).collect(Collectors.toList()),\n+                        equalTo(concat(field(\"str_value_indexed\"), primaryKey(\"MySimpleRecord\")))));\n+                assertEquals(-1813975352, plan.planHash());\n+            } else {\n+                assertThat(plan, filter(equalTo(query.getFilter()), indexScan(allOf(indexName(\"MySimpleRecord$str_value_indexed\"), unbounded()))));\n+                assertEquals(1775865786, plan.planHash());\n+            }\n+\n+            assertEquals(60, querySimpleRecordStore(hook, plan, EvaluationContext::empty,\n+                    record -> assertThat(record.getNumValue3Indexed(), anyOf(is(1), is(2), is(4))),\n+                    context -> TestHelpers.assertDiscardedAtMost(40, context)));\n+        }\n+    }\n+\n+    /**\n+     * Verify that an IN predicate that, when converted to an OR of equality predicates, would lead to a very large DNF\n+     * gets planned as a normal IN query rather than throwing an exception.\n+     */\n+    @Test\n+    public void cnfAsInQuery() throws Exception {\n+        RecordMetaDataHook hook = metaData ->\n+                metaData.addIndex(\"MySimpleRecord\", \"compoundIndex\",\n+                        concat(field(\"num_value_3_indexed\"), field(\"str_value_indexed\")));\n+        complexQuerySetup(hook);\n+\n+        // A CNF who's DNF size doesn't fit in an int, expressed with IN predicates.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODA1NzI3NA=="}, "originalCommit": {"oid": "0546106d225ce2c1e9e61012ad27bb0f6298d4b1"}, "originalPosition": 85}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ2NzY0MjkwOnYy", "diffSide": "RIGHT", "path": "fdb-record-layer-core/src/test/java/com/apple/foundationdb/record/query/plan/RecordQueryPlannerConfigurationTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNVQxNzo1NzozNFrOF7nigw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNVQxODowOTo1NVrOF7oC4g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODA1ODExNQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            RecordMetaData.newBuilder().setRecords(TestRecordsEnumProto.getDescriptor()).build(),\n          \n          \n            \n                            RecordMetaData.build(TestRecordsEnumProto.getDescriptor()),\n          \n      \n    \n    \n  \n\nEquivalent, but perhaps more idiomatic", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/861#discussion_r398058115", "createdAt": "2020-03-25T17:57:34Z", "author": {"login": "alecgrieser"}, "path": "fdb-record-layer-core/src/test/java/com/apple/foundationdb/record/query/plan/RecordQueryPlannerConfigurationTest.java", "diffHunk": "@@ -0,0 +1,73 @@\n+/*\n+ * RecordQueryPlannerConfigurationTest.java\n+ *\n+ * This source file is part of the FoundationDB open source project\n+ *\n+ * Copyright 2015-2020 Apple Inc. and the FoundationDB project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.apple.foundationdb.record.query.plan;\n+\n+import com.apple.foundationdb.record.RecordMetaData;\n+import com.apple.foundationdb.record.RecordStoreState;\n+import com.apple.foundationdb.record.TestRecordsEnumProto;\n+import org.junit.jupiter.api.Test;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+/**\n+ * Test of the semantics of setting configuration options on {@link RecordQueryPlanner}.\n+ * This is mostly \"executable documentation\" that makes sure that we never change the contract without meaning to.\n+ */\n+public class RecordQueryPlannerConfigurationTest {\n+    private static RecordQueryPlanner blankPlanner() {\n+        return new RecordQueryPlanner(\n+                RecordMetaData.newBuilder().setRecords(TestRecordsEnumProto.getDescriptor()).build(),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0546106d225ce2c1e9e61012ad27bb0f6298d4b1"}, "originalPosition": 38}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODA2NjQwMg==", "bodyText": "Fixed.", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/861#discussion_r398066402", "createdAt": "2020-03-25T18:09:55Z", "author": {"login": "nschiefer"}, "path": "fdb-record-layer-core/src/test/java/com/apple/foundationdb/record/query/plan/RecordQueryPlannerConfigurationTest.java", "diffHunk": "@@ -0,0 +1,73 @@\n+/*\n+ * RecordQueryPlannerConfigurationTest.java\n+ *\n+ * This source file is part of the FoundationDB open source project\n+ *\n+ * Copyright 2015-2020 Apple Inc. and the FoundationDB project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.apple.foundationdb.record.query.plan;\n+\n+import com.apple.foundationdb.record.RecordMetaData;\n+import com.apple.foundationdb.record.RecordStoreState;\n+import com.apple.foundationdb.record.TestRecordsEnumProto;\n+import org.junit.jupiter.api.Test;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+/**\n+ * Test of the semantics of setting configuration options on {@link RecordQueryPlanner}.\n+ * This is mostly \"executable documentation\" that makes sure that we never change the contract without meaning to.\n+ */\n+public class RecordQueryPlannerConfigurationTest {\n+    private static RecordQueryPlanner blankPlanner() {\n+        return new RecordQueryPlanner(\n+                RecordMetaData.newBuilder().setRecords(TestRecordsEnumProto.getDescriptor()).build(),", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODA1ODExNQ=="}, "originalCommit": {"oid": "0546106d225ce2c1e9e61012ad27bb0f6298d4b1"}, "originalPosition": 38}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4844, "cost": 1, "resetAt": "2021-11-12T19:05:54Z"}}}