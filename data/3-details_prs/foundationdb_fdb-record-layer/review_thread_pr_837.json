{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzgwNTc5Nzg0", "number": 837, "reviewThreads": {"totalCount": 18, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yN1QwMDo0ODoyMFrODjS8QQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMFQwMToxNTozNVrODmg6Ng==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM4MzM3MDg5OnYy", "diffSide": "RIGHT", "path": "fdb-extensions/src/main/java/com/apple/foundationdb/async/RankedSet.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yN1QwMDo0ODoyMFrOFvBpuA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNlQyMTozNDo1OVrOFzIKxw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDg1NDQ1Ng==", "bodyText": "There is a separate commit to relocate this method, which might make it easier to track how it has changed (other than that).", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/837#discussion_r384854456", "createdAt": "2020-02-27T00:48:20Z", "author": {"login": "MMcM"}, "path": "fdb-extensions/src/main/java/com/apple/foundationdb/async/RankedSet.java", "diffHunk": "@@ -246,6 +382,80 @@ public RankedSet(Subspace subspace, Executor executor) {\n         });\n     }\n \n+    /**\n+     * Removes a key from the set.\n+     * @param tc the transaction to use to access the database\n+     * @param key the key to remove\n+     * @return a future that completes to {@code true} if the set was modified, that is, if the key was present before this operation\n+     */\n+    public CompletableFuture<Boolean> remove(TransactionContext tc, byte[] key) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d1b1b6f12150d9e94b768b4c08c62200d1d4a478"}, "originalPosition": 279}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTE1NTUyNw==", "bodyText": "Thanks! That was actually fairly useful when reviewing.", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/837#discussion_r389155527", "createdAt": "2020-03-06T21:34:59Z", "author": {"login": "alecgrieser"}, "path": "fdb-extensions/src/main/java/com/apple/foundationdb/async/RankedSet.java", "diffHunk": "@@ -246,6 +382,80 @@ public RankedSet(Subspace subspace, Executor executor) {\n         });\n     }\n \n+    /**\n+     * Removes a key from the set.\n+     * @param tc the transaction to use to access the database\n+     * @param key the key to remove\n+     * @return a future that completes to {@code true} if the set was modified, that is, if the key was present before this operation\n+     */\n+    public CompletableFuture<Boolean> remove(TransactionContext tc, byte[] key) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDg1NDQ1Ng=="}, "originalCommit": {"oid": "d1b1b6f12150d9e94b768b4c08c62200d1d4a478"}, "originalPosition": 279}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM4MzM3MzQ5OnYy", "diffSide": "RIGHT", "path": "fdb-extensions/src/main/java/com/apple/foundationdb/async/RankedSet.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yN1QwMDo0OToxMlrOFvBrIg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yN1QwMDo0OToxMlrOFvBrIg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDg1NDgxOA==", "bodyText": "If there were a separate RankedMultiset class, this would only be on it, though it seems well-defined everywhere.", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/837#discussion_r384854818", "createdAt": "2020-02-27T00:49:12Z", "author": {"login": "MMcM"}, "path": "fdb-extensions/src/main/java/com/apple/foundationdb/async/RankedSet.java", "diffHunk": "@@ -267,17 +477,30 @@ public RankedSet(Subspace subspace, Executor executor) {\n      */\n     public CompletableFuture<Boolean> contains(ReadTransactionContext tc, byte[] key) {\n         checkKey(key);\n-        return containsCheckedKey(tc, key);\n+        return countCheckedKey(tc, key).thenApply(c -> c != null && c > 0);\n+    }\n+\n+    /**\n+     * Count the number of occurrences of a key in the set.\n+     * @param tc the transaction to use to access the database\n+     * @param key the key to check for\n+     * @return a future that completes to {@code 0} if the key is not present in the ranked set or\n+     * {@code 1} if the key is present in the ranked set and duplicates are not counted or\n+     * the number of occurrences if duplicated are counted separately\n+     */\n+    public CompletableFuture<Long> count(ReadTransactionContext tc, byte[] key) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d1b1b6f12150d9e94b768b4c08c62200d1d4a478"}, "originalPosition": 366}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM4MzM3NDc4OnYy", "diffSide": "RIGHT", "path": "fdb-extensions/src/main/java/com/apple/foundationdb/async/RankedSet.java", "isResolved": true, "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yN1QwMDo0OTo1NVrOFvBr6g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wOVQxODozNDoyMFrOFz0nJA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDg1NTAxOA==", "bodyText": "I don't think there was any reason to do this with a getRange before. I'm also not sure the snapshot is needed any more.", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/837#discussion_r384855018", "createdAt": "2020-02-27T00:49:55Z", "author": {"login": "MMcM"}, "path": "fdb-extensions/src/main/java/com/apple/foundationdb/async/RankedSet.java", "diffHunk": "@@ -643,19 +819,21 @@ private static void checkKey(byte[] key) {\n                         .thenApply(longs -> longs.stream().reduce(0L, Long::sum)));\n     }\n \n-    private CompletableFuture<byte[]> getPreviousKey(TransactionContext tc, int level, byte[] key) {\n+    // Get the key before this one at the given level.\n+    // If orEqual is given, then an exactly matching key is also considered. This is only used when the key is known\n+    // to be a duplicate or an existing key and so should do whatever it did.\n+    private CompletableFuture<byte[]> getPreviousKey(TransactionContext tc, int level, byte[] key, boolean orEqual) {\n         byte[] k = subspace.pack(Tuple.from(level, key));\n         CompletableFuture<byte[]> kf = tc.run(tr ->\n-                tr.snapshot()\n-                        .getRange(KeySelector.lastLessThan(k), KeySelector.firstGreaterOrEqual(k), 1)\n-                        .asList()\n-                        .thenApply(kvs -> {\n-                            byte[] prevk = kvs.get(0).getKey();\n-                            // If another key were inserted after between this and the target key,\n-                            // it wouldn't be the one we should increment any more.\n-                            // But do not conflict when key itself is incremented.\n-                            byte[] exclusiveBegin = ByteArrayUtil.join(prevk, ZERO_ARRAY);\n-                            tr.addReadConflictRange(exclusiveBegin, k);\n+                tr.snapshot().getKey(orEqual ? KeySelector.lastLessOrEqual(k) : KeySelector.lastLessThan(k))", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d1b1b6f12150d9e94b768b4c08c62200d1d4a478"}, "originalPosition": 530}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODY1MDcxOQ==", "bodyText": "I think we still want to do this at snapshot because I think a modification (like an increment) to exactly the read key will cause a conflict...though I could be wrong.\nAs to getRange or getKey, I think it's about six of one, half dozen of the other as it's actually translated to a get range call in the C API anyway. Usually, I think the advice is to not use getKey if you can't guarantee that the key range doesn't \"leak\" out of the subspace, but I think the empty arrays at the beginning of each level should handle that in this case, so I think it's fine.", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/837#discussion_r388650719", "createdAt": "2020-03-06T00:51:04Z", "author": {"login": "alecgrieser"}, "path": "fdb-extensions/src/main/java/com/apple/foundationdb/async/RankedSet.java", "diffHunk": "@@ -643,19 +819,21 @@ private static void checkKey(byte[] key) {\n                         .thenApply(longs -> longs.stream().reduce(0L, Long::sum)));\n     }\n \n-    private CompletableFuture<byte[]> getPreviousKey(TransactionContext tc, int level, byte[] key) {\n+    // Get the key before this one at the given level.\n+    // If orEqual is given, then an exactly matching key is also considered. This is only used when the key is known\n+    // to be a duplicate or an existing key and so should do whatever it did.\n+    private CompletableFuture<byte[]> getPreviousKey(TransactionContext tc, int level, byte[] key, boolean orEqual) {\n         byte[] k = subspace.pack(Tuple.from(level, key));\n         CompletableFuture<byte[]> kf = tc.run(tr ->\n-                tr.snapshot()\n-                        .getRange(KeySelector.lastLessThan(k), KeySelector.firstGreaterOrEqual(k), 1)\n-                        .asList()\n-                        .thenApply(kvs -> {\n-                            byte[] prevk = kvs.get(0).getKey();\n-                            // If another key were inserted after between this and the target key,\n-                            // it wouldn't be the one we should increment any more.\n-                            // But do not conflict when key itself is incremented.\n-                            byte[] exclusiveBegin = ByteArrayUtil.join(prevk, ZERO_ARRAY);\n-                            tr.addReadConflictRange(exclusiveBegin, k);\n+                tr.snapshot().getKey(orEqual ? KeySelector.lastLessOrEqual(k) : KeySelector.lastLessThan(k))", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDg1NTAxOA=="}, "originalCommit": {"oid": "d1b1b6f12150d9e94b768b4c08c62200d1d4a478"}, "originalPosition": 530}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTg2MDIyMA==", "bodyText": "The previous code,\n.getRange(KeySelector.lastLessThan(k), KeySelector.firstGreaterOrEqual(k), 1)\n\ndidn't really have that protection, since it used two key selectors from the same input.\nWould it be better then (that is, protecting against some screwup with the ('',0) entry) to do a reverse getRange with the left the level limit and the right the target?", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/837#discussion_r389860220", "createdAt": "2020-03-09T17:52:14Z", "author": {"login": "MMcM"}, "path": "fdb-extensions/src/main/java/com/apple/foundationdb/async/RankedSet.java", "diffHunk": "@@ -643,19 +819,21 @@ private static void checkKey(byte[] key) {\n                         .thenApply(longs -> longs.stream().reduce(0L, Long::sum)));\n     }\n \n-    private CompletableFuture<byte[]> getPreviousKey(TransactionContext tc, int level, byte[] key) {\n+    // Get the key before this one at the given level.\n+    // If orEqual is given, then an exactly matching key is also considered. This is only used when the key is known\n+    // to be a duplicate or an existing key and so should do whatever it did.\n+    private CompletableFuture<byte[]> getPreviousKey(TransactionContext tc, int level, byte[] key, boolean orEqual) {\n         byte[] k = subspace.pack(Tuple.from(level, key));\n         CompletableFuture<byte[]> kf = tc.run(tr ->\n-                tr.snapshot()\n-                        .getRange(KeySelector.lastLessThan(k), KeySelector.firstGreaterOrEqual(k), 1)\n-                        .asList()\n-                        .thenApply(kvs -> {\n-                            byte[] prevk = kvs.get(0).getKey();\n-                            // If another key were inserted after between this and the target key,\n-                            // it wouldn't be the one we should increment any more.\n-                            // But do not conflict when key itself is incremented.\n-                            byte[] exclusiveBegin = ByteArrayUtil.join(prevk, ZERO_ARRAY);\n-                            tr.addReadConflictRange(exclusiveBegin, k);\n+                tr.snapshot().getKey(orEqual ? KeySelector.lastLessOrEqual(k) : KeySelector.lastLessThan(k))", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDg1NTAxOA=="}, "originalCommit": {"oid": "d1b1b6f12150d9e94b768b4c08c62200d1d4a478"}, "originalPosition": 530}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTg2MjIzNQ==", "bodyText": "Yeah, I think a range read like that would make sense, and it would protect us from exactly that kind of screw up.", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/837#discussion_r389862235", "createdAt": "2020-03-09T17:55:40Z", "author": {"login": "alecgrieser"}, "path": "fdb-extensions/src/main/java/com/apple/foundationdb/async/RankedSet.java", "diffHunk": "@@ -643,19 +819,21 @@ private static void checkKey(byte[] key) {\n                         .thenApply(longs -> longs.stream().reduce(0L, Long::sum)));\n     }\n \n-    private CompletableFuture<byte[]> getPreviousKey(TransactionContext tc, int level, byte[] key) {\n+    // Get the key before this one at the given level.\n+    // If orEqual is given, then an exactly matching key is also considered. This is only used when the key is known\n+    // to be a duplicate or an existing key and so should do whatever it did.\n+    private CompletableFuture<byte[]> getPreviousKey(TransactionContext tc, int level, byte[] key, boolean orEqual) {\n         byte[] k = subspace.pack(Tuple.from(level, key));\n         CompletableFuture<byte[]> kf = tc.run(tr ->\n-                tr.snapshot()\n-                        .getRange(KeySelector.lastLessThan(k), KeySelector.firstGreaterOrEqual(k), 1)\n-                        .asList()\n-                        .thenApply(kvs -> {\n-                            byte[] prevk = kvs.get(0).getKey();\n-                            // If another key were inserted after between this and the target key,\n-                            // it wouldn't be the one we should increment any more.\n-                            // But do not conflict when key itself is incremented.\n-                            byte[] exclusiveBegin = ByteArrayUtil.join(prevk, ZERO_ARRAY);\n-                            tr.addReadConflictRange(exclusiveBegin, k);\n+                tr.snapshot().getKey(orEqual ? KeySelector.lastLessOrEqual(k) : KeySelector.lastLessThan(k))", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDg1NTAxOA=="}, "originalCommit": {"oid": "d1b1b6f12150d9e94b768b4c08c62200d1d4a478"}, "originalPosition": 530}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTg4MzY4NA==", "bodyText": "I switched to not using KeySelectors and doing a limit 1 reverse range scan.", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/837#discussion_r389883684", "createdAt": "2020-03-09T18:34:20Z", "author": {"login": "MMcM"}, "path": "fdb-extensions/src/main/java/com/apple/foundationdb/async/RankedSet.java", "diffHunk": "@@ -643,19 +819,21 @@ private static void checkKey(byte[] key) {\n                         .thenApply(longs -> longs.stream().reduce(0L, Long::sum)));\n     }\n \n-    private CompletableFuture<byte[]> getPreviousKey(TransactionContext tc, int level, byte[] key) {\n+    // Get the key before this one at the given level.\n+    // If orEqual is given, then an exactly matching key is also considered. This is only used when the key is known\n+    // to be a duplicate or an existing key and so should do whatever it did.\n+    private CompletableFuture<byte[]> getPreviousKey(TransactionContext tc, int level, byte[] key, boolean orEqual) {\n         byte[] k = subspace.pack(Tuple.from(level, key));\n         CompletableFuture<byte[]> kf = tc.run(tr ->\n-                tr.snapshot()\n-                        .getRange(KeySelector.lastLessThan(k), KeySelector.firstGreaterOrEqual(k), 1)\n-                        .asList()\n-                        .thenApply(kvs -> {\n-                            byte[] prevk = kvs.get(0).getKey();\n-                            // If another key were inserted after between this and the target key,\n-                            // it wouldn't be the one we should increment any more.\n-                            // But do not conflict when key itself is incremented.\n-                            byte[] exclusiveBegin = ByteArrayUtil.join(prevk, ZERO_ARRAY);\n-                            tr.addReadConflictRange(exclusiveBegin, k);\n+                tr.snapshot().getKey(orEqual ? KeySelector.lastLessOrEqual(k) : KeySelector.lastLessThan(k))", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDg1NTAxOA=="}, "originalCommit": {"oid": "d1b1b6f12150d9e94b768b4c08c62200d1d4a478"}, "originalPosition": 530}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM4NTM1MDQ3OnYy", "diffSide": "RIGHT", "path": "fdb-extensions/src/main/java/com/apple/foundationdb/async/RankedSet.java", "isResolved": false, "comments": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yN1QxNDoyODoxOVrOFvUV_Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMFQwMToyNDozNlrOFz-i3w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTE2MDcwMQ==", "bodyText": "Not much thought went into mixing set and multiset on the same subspace. Other than not violating the consistency invariants. In particular, remove always removes (up to) one occurrence. Would it be better if it removed all when not counting duplicates?", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/837#discussion_r385160701", "createdAt": "2020-02-27T14:28:19Z", "author": {"login": "MMcM"}, "path": "fdb-extensions/src/main/java/com/apple/foundationdb/async/RankedSet.java", "diffHunk": "@@ -246,6 +382,80 @@ public RankedSet(Subspace subspace, Executor executor) {\n         });\n     }\n \n+    /**\n+     * Removes a key from the set.\n+     * @param tc the transaction to use to access the database\n+     * @param key the key to remove\n+     * @return a future that completes to {@code true} if the set was modified, that is, if the key was present before this operation\n+     */\n+    public CompletableFuture<Boolean> remove(TransactionContext tc, byte[] key) {\n+        checkKey(key);\n+        return tc.runAsync(tr ->\n+                countCheckedKey(tr, key)\n+                        .thenCompose(count -> {\n+                            if (count == null || count <= 0) {\n+                                return READY_FALSE;\n+                            }\n+                            // This works even if the current set does not track duplicates but duplicates were added\n+                            // earlier by one that did.\n+                            final boolean duplicate = count > 1;\n+                            final int nlevels = config.getNLevels();\n+                            final List<CompletableFuture<Void>> futures = new ArrayList<>(nlevels);\n+                            for (int li = 0; li < nlevels; ++li) {\n+                                final int level = li;\n+\n+                                final CompletableFuture<Void> future;\n+\n+                                if (duplicate) {\n+                                    // Always subtract one, never clearing a key. It is possible for this to leave\n+                                    // a key with a count of zero, if duplicates were inserted with different hash functions.\n+                                    Function<byte[], Void> decrement = k -> {\n+                                        tr.mutate(MutationType.ADD, subspace.pack(Tuple.from(level, k)), encodeLong(-1));\n+                                        return null;\n+                                    };\n+                                    if (level == 0) {\n+                                        decrement.apply(key);\n+                                        future = DONE;\n+                                    } else {\n+                                        future = getPreviousKey(tr, level, key, true).thenApply(decrement);\n+                                    }\n+                                } else {\n+                                    // This could be optimized to check the hash for which levels should have this key.\n+                                    // That would require that the hash function never changes, though.\n+                                    // This allows for it to change, with the distribution perhaps getting a little uneven\n+                                    // as a result. It even allows for the hash function to return a random number.\n+                                    final byte[] k = subspace.pack(Tuple.from(level, key));\n+                                    final CompletableFuture<byte[]> cf = tr.get(k);\n+\n+                                    if (level == 0) {\n+                                        future = cf.thenApply(c -> {\n+                                            if (c != null) {\n+                                                tr.clear(k);\n+                                            }\n+                                            return null;\n+                                        });\n+                                    } else {\n+                                        final CompletableFuture<byte[]> prevKeyF = getPreviousKey(tr, level, key, false);\n+                                        future = CompletableFuture.allOf(cf, prevKeyF)\n+                                                .thenApply(vignore -> {\n+                                                    final byte[] c = cf.join();\n+                                                    long countChange = -1;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d1b1b6f12150d9e94b768b4c08c62200d1d4a478"}, "originalPosition": 330}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTE1NDAxMQ==", "bodyText": "I think having it always remove 1 is fine, especially as it's generally unsafe to have a ranked set and a multiset in the same space. I guess this (kind of) actually removes all from level 0 and then 1 from the other levels, which is maybe a little weird. I guess also if someone calls remove on a value that isn't actually in the set, it will break the invariants of the range set (in that it will subtract 1 from only the higher levels).\nI suppose it would also be kind of nice if this and the \"duplicates\" case were more similar, though it would require I think changing either the semantics of the existing sets to allow for keys to be present in only the higher levels of the ranked set or to modify the logic in the \"removes duplicates\" case to remove keys that have been zero'd out (including possibly non-empty keys in the higher levels).", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/837#discussion_r389154011", "createdAt": "2020-03-06T21:31:03Z", "author": {"login": "alecgrieser"}, "path": "fdb-extensions/src/main/java/com/apple/foundationdb/async/RankedSet.java", "diffHunk": "@@ -246,6 +382,80 @@ public RankedSet(Subspace subspace, Executor executor) {\n         });\n     }\n \n+    /**\n+     * Removes a key from the set.\n+     * @param tc the transaction to use to access the database\n+     * @param key the key to remove\n+     * @return a future that completes to {@code true} if the set was modified, that is, if the key was present before this operation\n+     */\n+    public CompletableFuture<Boolean> remove(TransactionContext tc, byte[] key) {\n+        checkKey(key);\n+        return tc.runAsync(tr ->\n+                countCheckedKey(tr, key)\n+                        .thenCompose(count -> {\n+                            if (count == null || count <= 0) {\n+                                return READY_FALSE;\n+                            }\n+                            // This works even if the current set does not track duplicates but duplicates were added\n+                            // earlier by one that did.\n+                            final boolean duplicate = count > 1;\n+                            final int nlevels = config.getNLevels();\n+                            final List<CompletableFuture<Void>> futures = new ArrayList<>(nlevels);\n+                            for (int li = 0; li < nlevels; ++li) {\n+                                final int level = li;\n+\n+                                final CompletableFuture<Void> future;\n+\n+                                if (duplicate) {\n+                                    // Always subtract one, never clearing a key. It is possible for this to leave\n+                                    // a key with a count of zero, if duplicates were inserted with different hash functions.\n+                                    Function<byte[], Void> decrement = k -> {\n+                                        tr.mutate(MutationType.ADD, subspace.pack(Tuple.from(level, k)), encodeLong(-1));\n+                                        return null;\n+                                    };\n+                                    if (level == 0) {\n+                                        decrement.apply(key);\n+                                        future = DONE;\n+                                    } else {\n+                                        future = getPreviousKey(tr, level, key, true).thenApply(decrement);\n+                                    }\n+                                } else {\n+                                    // This could be optimized to check the hash for which levels should have this key.\n+                                    // That would require that the hash function never changes, though.\n+                                    // This allows for it to change, with the distribution perhaps getting a little uneven\n+                                    // as a result. It even allows for the hash function to return a random number.\n+                                    final byte[] k = subspace.pack(Tuple.from(level, key));\n+                                    final CompletableFuture<byte[]> cf = tr.get(k);\n+\n+                                    if (level == 0) {\n+                                        future = cf.thenApply(c -> {\n+                                            if (c != null) {\n+                                                tr.clear(k);\n+                                            }\n+                                            return null;\n+                                        });\n+                                    } else {\n+                                        final CompletableFuture<byte[]> prevKeyF = getPreviousKey(tr, level, key, false);\n+                                        future = CompletableFuture.allOf(cf, prevKeyF)\n+                                                .thenApply(vignore -> {\n+                                                    final byte[] c = cf.join();\n+                                                    long countChange = -1;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTE2MDcwMQ=="}, "originalCommit": {"oid": "d1b1b6f12150d9e94b768b4c08c62200d1d4a478"}, "originalPosition": 330}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTg4NDc5Mw==", "bodyText": "I fixed the comments. It should not, in fact, be possible to decrement to zero any more.\nWhich means that if we did decide that remove should mean remove all, it would be consistent in clearing any splits induced by the given key.", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/837#discussion_r389884793", "createdAt": "2020-03-09T18:36:19Z", "author": {"login": "MMcM"}, "path": "fdb-extensions/src/main/java/com/apple/foundationdb/async/RankedSet.java", "diffHunk": "@@ -246,6 +382,80 @@ public RankedSet(Subspace subspace, Executor executor) {\n         });\n     }\n \n+    /**\n+     * Removes a key from the set.\n+     * @param tc the transaction to use to access the database\n+     * @param key the key to remove\n+     * @return a future that completes to {@code true} if the set was modified, that is, if the key was present before this operation\n+     */\n+    public CompletableFuture<Boolean> remove(TransactionContext tc, byte[] key) {\n+        checkKey(key);\n+        return tc.runAsync(tr ->\n+                countCheckedKey(tr, key)\n+                        .thenCompose(count -> {\n+                            if (count == null || count <= 0) {\n+                                return READY_FALSE;\n+                            }\n+                            // This works even if the current set does not track duplicates but duplicates were added\n+                            // earlier by one that did.\n+                            final boolean duplicate = count > 1;\n+                            final int nlevels = config.getNLevels();\n+                            final List<CompletableFuture<Void>> futures = new ArrayList<>(nlevels);\n+                            for (int li = 0; li < nlevels; ++li) {\n+                                final int level = li;\n+\n+                                final CompletableFuture<Void> future;\n+\n+                                if (duplicate) {\n+                                    // Always subtract one, never clearing a key. It is possible for this to leave\n+                                    // a key with a count of zero, if duplicates were inserted with different hash functions.\n+                                    Function<byte[], Void> decrement = k -> {\n+                                        tr.mutate(MutationType.ADD, subspace.pack(Tuple.from(level, k)), encodeLong(-1));\n+                                        return null;\n+                                    };\n+                                    if (level == 0) {\n+                                        decrement.apply(key);\n+                                        future = DONE;\n+                                    } else {\n+                                        future = getPreviousKey(tr, level, key, true).thenApply(decrement);\n+                                    }\n+                                } else {\n+                                    // This could be optimized to check the hash for which levels should have this key.\n+                                    // That would require that the hash function never changes, though.\n+                                    // This allows for it to change, with the distribution perhaps getting a little uneven\n+                                    // as a result. It even allows for the hash function to return a random number.\n+                                    final byte[] k = subspace.pack(Tuple.from(level, key));\n+                                    final CompletableFuture<byte[]> cf = tr.get(k);\n+\n+                                    if (level == 0) {\n+                                        future = cf.thenApply(c -> {\n+                                            if (c != null) {\n+                                                tr.clear(k);\n+                                            }\n+                                            return null;\n+                                        });\n+                                    } else {\n+                                        final CompletableFuture<byte[]> prevKeyF = getPreviousKey(tr, level, key, false);\n+                                        future = CompletableFuture.allOf(cf, prevKeyF)\n+                                                .thenApply(vignore -> {\n+                                                    final byte[] c = cf.join();\n+                                                    long countChange = -1;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTE2MDcwMQ=="}, "originalCommit": {"oid": "d1b1b6f12150d9e94b768b4c08c62200d1d4a478"}, "originalPosition": 330}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDAyMTA2Mg==", "bodyText": "Maybe I'm missing the change, but it looks like one could still decrement a key to zero (in duplicate counting mode), in that it just decrements the value by 1.", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/837#discussion_r390021062", "createdAt": "2020-03-09T23:45:41Z", "author": {"login": "alecgrieser"}, "path": "fdb-extensions/src/main/java/com/apple/foundationdb/async/RankedSet.java", "diffHunk": "@@ -246,6 +382,80 @@ public RankedSet(Subspace subspace, Executor executor) {\n         });\n     }\n \n+    /**\n+     * Removes a key from the set.\n+     * @param tc the transaction to use to access the database\n+     * @param key the key to remove\n+     * @return a future that completes to {@code true} if the set was modified, that is, if the key was present before this operation\n+     */\n+    public CompletableFuture<Boolean> remove(TransactionContext tc, byte[] key) {\n+        checkKey(key);\n+        return tc.runAsync(tr ->\n+                countCheckedKey(tr, key)\n+                        .thenCompose(count -> {\n+                            if (count == null || count <= 0) {\n+                                return READY_FALSE;\n+                            }\n+                            // This works even if the current set does not track duplicates but duplicates were added\n+                            // earlier by one that did.\n+                            final boolean duplicate = count > 1;\n+                            final int nlevels = config.getNLevels();\n+                            final List<CompletableFuture<Void>> futures = new ArrayList<>(nlevels);\n+                            for (int li = 0; li < nlevels; ++li) {\n+                                final int level = li;\n+\n+                                final CompletableFuture<Void> future;\n+\n+                                if (duplicate) {\n+                                    // Always subtract one, never clearing a key. It is possible for this to leave\n+                                    // a key with a count of zero, if duplicates were inserted with different hash functions.\n+                                    Function<byte[], Void> decrement = k -> {\n+                                        tr.mutate(MutationType.ADD, subspace.pack(Tuple.from(level, k)), encodeLong(-1));\n+                                        return null;\n+                                    };\n+                                    if (level == 0) {\n+                                        decrement.apply(key);\n+                                        future = DONE;\n+                                    } else {\n+                                        future = getPreviousKey(tr, level, key, true).thenApply(decrement);\n+                                    }\n+                                } else {\n+                                    // This could be optimized to check the hash for which levels should have this key.\n+                                    // That would require that the hash function never changes, though.\n+                                    // This allows for it to change, with the distribution perhaps getting a little uneven\n+                                    // as a result. It even allows for the hash function to return a random number.\n+                                    final byte[] k = subspace.pack(Tuple.from(level, key));\n+                                    final CompletableFuture<byte[]> cf = tr.get(k);\n+\n+                                    if (level == 0) {\n+                                        future = cf.thenApply(c -> {\n+                                            if (c != null) {\n+                                                tr.clear(k);\n+                                            }\n+                                            return null;\n+                                        });\n+                                    } else {\n+                                        final CompletableFuture<byte[]> prevKeyF = getPreviousKey(tr, level, key, false);\n+                                        future = CompletableFuture.allOf(cf, prevKeyF)\n+                                                .thenApply(vignore -> {\n+                                                    final byte[] c = cf.join();\n+                                                    long countChange = -1;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTE2MDcwMQ=="}, "originalCommit": {"oid": "d1b1b6f12150d9e94b768b4c08c62200d1d4a478"}, "originalPosition": 330}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDAzNjY3Ng==", "bodyText": "Here is my reasoning:\nIn add, if a key is already present (based on checking level 0 != 0), then the hash is ignored and each key that was incremented last time is incremented again. In other words, a duplicate value is counted n times at every level reliably.\nIn remove, if a key is not the last occurrence (based on checking level 0 > 1), then it is safe to simply decrement every level because this key must have contributed at least 2 to each of them. If a key is the last occurrence, then if the key decremented at any level matches exactly (as opposed to being somewhere to the left), it is cleared. This is the only key that might otherwise have been decremented to zero, I believe.\nSimultaneous removes of the same key conflict on level 0.", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/837#discussion_r390036676", "createdAt": "2020-03-10T00:43:51Z", "author": {"login": "MMcM"}, "path": "fdb-extensions/src/main/java/com/apple/foundationdb/async/RankedSet.java", "diffHunk": "@@ -246,6 +382,80 @@ public RankedSet(Subspace subspace, Executor executor) {\n         });\n     }\n \n+    /**\n+     * Removes a key from the set.\n+     * @param tc the transaction to use to access the database\n+     * @param key the key to remove\n+     * @return a future that completes to {@code true} if the set was modified, that is, if the key was present before this operation\n+     */\n+    public CompletableFuture<Boolean> remove(TransactionContext tc, byte[] key) {\n+        checkKey(key);\n+        return tc.runAsync(tr ->\n+                countCheckedKey(tr, key)\n+                        .thenCompose(count -> {\n+                            if (count == null || count <= 0) {\n+                                return READY_FALSE;\n+                            }\n+                            // This works even if the current set does not track duplicates but duplicates were added\n+                            // earlier by one that did.\n+                            final boolean duplicate = count > 1;\n+                            final int nlevels = config.getNLevels();\n+                            final List<CompletableFuture<Void>> futures = new ArrayList<>(nlevels);\n+                            for (int li = 0; li < nlevels; ++li) {\n+                                final int level = li;\n+\n+                                final CompletableFuture<Void> future;\n+\n+                                if (duplicate) {\n+                                    // Always subtract one, never clearing a key. It is possible for this to leave\n+                                    // a key with a count of zero, if duplicates were inserted with different hash functions.\n+                                    Function<byte[], Void> decrement = k -> {\n+                                        tr.mutate(MutationType.ADD, subspace.pack(Tuple.from(level, k)), encodeLong(-1));\n+                                        return null;\n+                                    };\n+                                    if (level == 0) {\n+                                        decrement.apply(key);\n+                                        future = DONE;\n+                                    } else {\n+                                        future = getPreviousKey(tr, level, key, true).thenApply(decrement);\n+                                    }\n+                                } else {\n+                                    // This could be optimized to check the hash for which levels should have this key.\n+                                    // That would require that the hash function never changes, though.\n+                                    // This allows for it to change, with the distribution perhaps getting a little uneven\n+                                    // as a result. It even allows for the hash function to return a random number.\n+                                    final byte[] k = subspace.pack(Tuple.from(level, key));\n+                                    final CompletableFuture<byte[]> cf = tr.get(k);\n+\n+                                    if (level == 0) {\n+                                        future = cf.thenApply(c -> {\n+                                            if (c != null) {\n+                                                tr.clear(k);\n+                                            }\n+                                            return null;\n+                                        });\n+                                    } else {\n+                                        final CompletableFuture<byte[]> prevKeyF = getPreviousKey(tr, level, key, false);\n+                                        future = CompletableFuture.allOf(cf, prevKeyF)\n+                                                .thenApply(vignore -> {\n+                                                    final byte[] c = cf.join();\n+                                                    long countChange = -1;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTE2MDcwMQ=="}, "originalCommit": {"oid": "d1b1b6f12150d9e94b768b4c08c62200d1d4a478"}, "originalPosition": 330}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDA0MjE1Ng==", "bodyText": "Oh, I think I see what I was missing: I had though that the duplicate boolean was determined by the configuration rather than by the count that actually gets read. I'll have to rethink what this is doing with that in mind.", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/837#discussion_r390042156", "createdAt": "2020-03-10T01:06:08Z", "author": {"login": "alecgrieser"}, "path": "fdb-extensions/src/main/java/com/apple/foundationdb/async/RankedSet.java", "diffHunk": "@@ -246,6 +382,80 @@ public RankedSet(Subspace subspace, Executor executor) {\n         });\n     }\n \n+    /**\n+     * Removes a key from the set.\n+     * @param tc the transaction to use to access the database\n+     * @param key the key to remove\n+     * @return a future that completes to {@code true} if the set was modified, that is, if the key was present before this operation\n+     */\n+    public CompletableFuture<Boolean> remove(TransactionContext tc, byte[] key) {\n+        checkKey(key);\n+        return tc.runAsync(tr ->\n+                countCheckedKey(tr, key)\n+                        .thenCompose(count -> {\n+                            if (count == null || count <= 0) {\n+                                return READY_FALSE;\n+                            }\n+                            // This works even if the current set does not track duplicates but duplicates were added\n+                            // earlier by one that did.\n+                            final boolean duplicate = count > 1;\n+                            final int nlevels = config.getNLevels();\n+                            final List<CompletableFuture<Void>> futures = new ArrayList<>(nlevels);\n+                            for (int li = 0; li < nlevels; ++li) {\n+                                final int level = li;\n+\n+                                final CompletableFuture<Void> future;\n+\n+                                if (duplicate) {\n+                                    // Always subtract one, never clearing a key. It is possible for this to leave\n+                                    // a key with a count of zero, if duplicates were inserted with different hash functions.\n+                                    Function<byte[], Void> decrement = k -> {\n+                                        tr.mutate(MutationType.ADD, subspace.pack(Tuple.from(level, k)), encodeLong(-1));\n+                                        return null;\n+                                    };\n+                                    if (level == 0) {\n+                                        decrement.apply(key);\n+                                        future = DONE;\n+                                    } else {\n+                                        future = getPreviousKey(tr, level, key, true).thenApply(decrement);\n+                                    }\n+                                } else {\n+                                    // This could be optimized to check the hash for which levels should have this key.\n+                                    // That would require that the hash function never changes, though.\n+                                    // This allows for it to change, with the distribution perhaps getting a little uneven\n+                                    // as a result. It even allows for the hash function to return a random number.\n+                                    final byte[] k = subspace.pack(Tuple.from(level, key));\n+                                    final CompletableFuture<byte[]> cf = tr.get(k);\n+\n+                                    if (level == 0) {\n+                                        future = cf.thenApply(c -> {\n+                                            if (c != null) {\n+                                                tr.clear(k);\n+                                            }\n+                                            return null;\n+                                        });\n+                                    } else {\n+                                        final CompletableFuture<byte[]> prevKeyF = getPreviousKey(tr, level, key, false);\n+                                        future = CompletableFuture.allOf(cf, prevKeyF)\n+                                                .thenApply(vignore -> {\n+                                                    final byte[] c = cf.join();\n+                                                    long countChange = -1;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTE2MDcwMQ=="}, "originalCommit": {"oid": "d1b1b6f12150d9e94b768b4c08c62200d1d4a478"}, "originalPosition": 330}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDA0NTUwNw==", "bodyText": "Yeah, this now makes sense to me, and I believe you're right--that essentially because all updates contend on their level 0 key, some of the nasty edge cases that can lead to concurrent decrements resulting in there being a count set to zero. I suppose we may need to re-architect if we decide that that's \"too much contention\" or something.", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/837#discussion_r390045507", "createdAt": "2020-03-10T01:20:28Z", "author": {"login": "alecgrieser"}, "path": "fdb-extensions/src/main/java/com/apple/foundationdb/async/RankedSet.java", "diffHunk": "@@ -246,6 +382,80 @@ public RankedSet(Subspace subspace, Executor executor) {\n         });\n     }\n \n+    /**\n+     * Removes a key from the set.\n+     * @param tc the transaction to use to access the database\n+     * @param key the key to remove\n+     * @return a future that completes to {@code true} if the set was modified, that is, if the key was present before this operation\n+     */\n+    public CompletableFuture<Boolean> remove(TransactionContext tc, byte[] key) {\n+        checkKey(key);\n+        return tc.runAsync(tr ->\n+                countCheckedKey(tr, key)\n+                        .thenCompose(count -> {\n+                            if (count == null || count <= 0) {\n+                                return READY_FALSE;\n+                            }\n+                            // This works even if the current set does not track duplicates but duplicates were added\n+                            // earlier by one that did.\n+                            final boolean duplicate = count > 1;\n+                            final int nlevels = config.getNLevels();\n+                            final List<CompletableFuture<Void>> futures = new ArrayList<>(nlevels);\n+                            for (int li = 0; li < nlevels; ++li) {\n+                                final int level = li;\n+\n+                                final CompletableFuture<Void> future;\n+\n+                                if (duplicate) {\n+                                    // Always subtract one, never clearing a key. It is possible for this to leave\n+                                    // a key with a count of zero, if duplicates were inserted with different hash functions.\n+                                    Function<byte[], Void> decrement = k -> {\n+                                        tr.mutate(MutationType.ADD, subspace.pack(Tuple.from(level, k)), encodeLong(-1));\n+                                        return null;\n+                                    };\n+                                    if (level == 0) {\n+                                        decrement.apply(key);\n+                                        future = DONE;\n+                                    } else {\n+                                        future = getPreviousKey(tr, level, key, true).thenApply(decrement);\n+                                    }\n+                                } else {\n+                                    // This could be optimized to check the hash for which levels should have this key.\n+                                    // That would require that the hash function never changes, though.\n+                                    // This allows for it to change, with the distribution perhaps getting a little uneven\n+                                    // as a result. It even allows for the hash function to return a random number.\n+                                    final byte[] k = subspace.pack(Tuple.from(level, key));\n+                                    final CompletableFuture<byte[]> cf = tr.get(k);\n+\n+                                    if (level == 0) {\n+                                        future = cf.thenApply(c -> {\n+                                            if (c != null) {\n+                                                tr.clear(k);\n+                                            }\n+                                            return null;\n+                                        });\n+                                    } else {\n+                                        final CompletableFuture<byte[]> prevKeyF = getPreviousKey(tr, level, key, false);\n+                                        future = CompletableFuture.allOf(cf, prevKeyF)\n+                                                .thenApply(vignore -> {\n+                                                    final byte[] c = cf.join();\n+                                                    long countChange = -1;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTE2MDcwMQ=="}, "originalCommit": {"oid": "d1b1b6f12150d9e94b768b4c08c62200d1d4a478"}, "originalPosition": 330}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDA0NjQzMQ==", "bodyText": "As to the original question, I think that having remove always be \"remove 1\" is fine, and now here my reasoning is: (1) having it that way decreases the number of branches (on the config value) from the code and (2) changing the value of the config parameter is weird enough that we should generally avoid doing it (hence banning changing it at the meta-data level) and shouldn't add complexity to the code to support it.\nBut my feelings aren't particularly strong.", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/837#discussion_r390046431", "createdAt": "2020-03-10T01:24:36Z", "author": {"login": "alecgrieser"}, "path": "fdb-extensions/src/main/java/com/apple/foundationdb/async/RankedSet.java", "diffHunk": "@@ -246,6 +382,80 @@ public RankedSet(Subspace subspace, Executor executor) {\n         });\n     }\n \n+    /**\n+     * Removes a key from the set.\n+     * @param tc the transaction to use to access the database\n+     * @param key the key to remove\n+     * @return a future that completes to {@code true} if the set was modified, that is, if the key was present before this operation\n+     */\n+    public CompletableFuture<Boolean> remove(TransactionContext tc, byte[] key) {\n+        checkKey(key);\n+        return tc.runAsync(tr ->\n+                countCheckedKey(tr, key)\n+                        .thenCompose(count -> {\n+                            if (count == null || count <= 0) {\n+                                return READY_FALSE;\n+                            }\n+                            // This works even if the current set does not track duplicates but duplicates were added\n+                            // earlier by one that did.\n+                            final boolean duplicate = count > 1;\n+                            final int nlevels = config.getNLevels();\n+                            final List<CompletableFuture<Void>> futures = new ArrayList<>(nlevels);\n+                            for (int li = 0; li < nlevels; ++li) {\n+                                final int level = li;\n+\n+                                final CompletableFuture<Void> future;\n+\n+                                if (duplicate) {\n+                                    // Always subtract one, never clearing a key. It is possible for this to leave\n+                                    // a key with a count of zero, if duplicates were inserted with different hash functions.\n+                                    Function<byte[], Void> decrement = k -> {\n+                                        tr.mutate(MutationType.ADD, subspace.pack(Tuple.from(level, k)), encodeLong(-1));\n+                                        return null;\n+                                    };\n+                                    if (level == 0) {\n+                                        decrement.apply(key);\n+                                        future = DONE;\n+                                    } else {\n+                                        future = getPreviousKey(tr, level, key, true).thenApply(decrement);\n+                                    }\n+                                } else {\n+                                    // This could be optimized to check the hash for which levels should have this key.\n+                                    // That would require that the hash function never changes, though.\n+                                    // This allows for it to change, with the distribution perhaps getting a little uneven\n+                                    // as a result. It even allows for the hash function to return a random number.\n+                                    final byte[] k = subspace.pack(Tuple.from(level, key));\n+                                    final CompletableFuture<byte[]> cf = tr.get(k);\n+\n+                                    if (level == 0) {\n+                                        future = cf.thenApply(c -> {\n+                                            if (c != null) {\n+                                                tr.clear(k);\n+                                            }\n+                                            return null;\n+                                        });\n+                                    } else {\n+                                        final CompletableFuture<byte[]> prevKeyF = getPreviousKey(tr, level, key, false);\n+                                        future = CompletableFuture.allOf(cf, prevKeyF)\n+                                                .thenApply(vignore -> {\n+                                                    final byte[] c = cf.join();\n+                                                    long countChange = -1;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTE2MDcwMQ=="}, "originalCommit": {"oid": "d1b1b6f12150d9e94b768b4c08c62200d1d4a478"}, "originalPosition": 330}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM4NTM1MzY0OnYy", "diffSide": "RIGHT", "path": "fdb-extensions/src/main/java/com/apple/foundationdb/async/RankedSet.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yN1QxNDoyOTowM1rOFvUX6g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wOVQxODozNjozMlrOFz0r6Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTE2MTE5NA==", "bodyText": "Is it worth having a RANDOM_HASH_FUNCTION? Roughly, threadLocalRandom.getInt(). And a test to show that it works?", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/837#discussion_r385161194", "createdAt": "2020-02-27T14:29:03Z", "author": {"login": "MMcM"}, "path": "fdb-extensions/src/main/java/com/apple/foundationdb/async/RankedSet.java", "diffHunk": "@@ -246,6 +382,80 @@ public RankedSet(Subspace subspace, Executor executor) {\n         });\n     }\n \n+    /**\n+     * Removes a key from the set.\n+     * @param tc the transaction to use to access the database\n+     * @param key the key to remove\n+     * @return a future that completes to {@code true} if the set was modified, that is, if the key was present before this operation\n+     */\n+    public CompletableFuture<Boolean> remove(TransactionContext tc, byte[] key) {\n+        checkKey(key);\n+        return tc.runAsync(tr ->\n+                countCheckedKey(tr, key)\n+                        .thenCompose(count -> {\n+                            if (count == null || count <= 0) {\n+                                return READY_FALSE;\n+                            }\n+                            // This works even if the current set does not track duplicates but duplicates were added\n+                            // earlier by one that did.\n+                            final boolean duplicate = count > 1;\n+                            final int nlevels = config.getNLevels();\n+                            final List<CompletableFuture<Void>> futures = new ArrayList<>(nlevels);\n+                            for (int li = 0; li < nlevels; ++li) {\n+                                final int level = li;\n+\n+                                final CompletableFuture<Void> future;\n+\n+                                if (duplicate) {\n+                                    // Always subtract one, never clearing a key. It is possible for this to leave\n+                                    // a key with a count of zero, if duplicates were inserted with different hash functions.\n+                                    Function<byte[], Void> decrement = k -> {\n+                                        tr.mutate(MutationType.ADD, subspace.pack(Tuple.from(level, k)), encodeLong(-1));\n+                                        return null;\n+                                    };\n+                                    if (level == 0) {\n+                                        decrement.apply(key);\n+                                        future = DONE;\n+                                    } else {\n+                                        future = getPreviousKey(tr, level, key, true).thenApply(decrement);\n+                                    }\n+                                } else {\n+                                    // This could be optimized to check the hash for which levels should have this key.\n+                                    // That would require that the hash function never changes, though.\n+                                    // This allows for it to change, with the distribution perhaps getting a little uneven\n+                                    // as a result. It even allows for the hash function to return a random number.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d1b1b6f12150d9e94b768b4c08c62200d1d4a478"}, "originalPosition": 314}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODY5MzEzOA==", "bodyText": "I think that would certainly be an interesting test hash function and test, if it's not too hard to add. Hard for me to say that it's necessarily \"worth\" it, though it would be kind of cool.", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/837#discussion_r388693138", "createdAt": "2020-03-06T03:11:41Z", "author": {"login": "alecgrieser"}, "path": "fdb-extensions/src/main/java/com/apple/foundationdb/async/RankedSet.java", "diffHunk": "@@ -246,6 +382,80 @@ public RankedSet(Subspace subspace, Executor executor) {\n         });\n     }\n \n+    /**\n+     * Removes a key from the set.\n+     * @param tc the transaction to use to access the database\n+     * @param key the key to remove\n+     * @return a future that completes to {@code true} if the set was modified, that is, if the key was present before this operation\n+     */\n+    public CompletableFuture<Boolean> remove(TransactionContext tc, byte[] key) {\n+        checkKey(key);\n+        return tc.runAsync(tr ->\n+                countCheckedKey(tr, key)\n+                        .thenCompose(count -> {\n+                            if (count == null || count <= 0) {\n+                                return READY_FALSE;\n+                            }\n+                            // This works even if the current set does not track duplicates but duplicates were added\n+                            // earlier by one that did.\n+                            final boolean duplicate = count > 1;\n+                            final int nlevels = config.getNLevels();\n+                            final List<CompletableFuture<Void>> futures = new ArrayList<>(nlevels);\n+                            for (int li = 0; li < nlevels; ++li) {\n+                                final int level = li;\n+\n+                                final CompletableFuture<Void> future;\n+\n+                                if (duplicate) {\n+                                    // Always subtract one, never clearing a key. It is possible for this to leave\n+                                    // a key with a count of zero, if duplicates were inserted with different hash functions.\n+                                    Function<byte[], Void> decrement = k -> {\n+                                        tr.mutate(MutationType.ADD, subspace.pack(Tuple.from(level, k)), encodeLong(-1));\n+                                        return null;\n+                                    };\n+                                    if (level == 0) {\n+                                        decrement.apply(key);\n+                                        future = DONE;\n+                                    } else {\n+                                        future = getPreviousKey(tr, level, key, true).thenApply(decrement);\n+                                    }\n+                                } else {\n+                                    // This could be optimized to check the hash for which levels should have this key.\n+                                    // That would require that the hash function never changes, though.\n+                                    // This allows for it to change, with the distribution perhaps getting a little uneven\n+                                    // as a result. It even allows for the hash function to return a random number.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTE2MTE5NA=="}, "originalCommit": {"oid": "d1b1b6f12150d9e94b768b4c08c62200d1d4a478"}, "originalPosition": 314}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTg4NDkwNQ==", "bodyText": "I added the basic test for this.", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/837#discussion_r389884905", "createdAt": "2020-03-09T18:36:32Z", "author": {"login": "MMcM"}, "path": "fdb-extensions/src/main/java/com/apple/foundationdb/async/RankedSet.java", "diffHunk": "@@ -246,6 +382,80 @@ public RankedSet(Subspace subspace, Executor executor) {\n         });\n     }\n \n+    /**\n+     * Removes a key from the set.\n+     * @param tc the transaction to use to access the database\n+     * @param key the key to remove\n+     * @return a future that completes to {@code true} if the set was modified, that is, if the key was present before this operation\n+     */\n+    public CompletableFuture<Boolean> remove(TransactionContext tc, byte[] key) {\n+        checkKey(key);\n+        return tc.runAsync(tr ->\n+                countCheckedKey(tr, key)\n+                        .thenCompose(count -> {\n+                            if (count == null || count <= 0) {\n+                                return READY_FALSE;\n+                            }\n+                            // This works even if the current set does not track duplicates but duplicates were added\n+                            // earlier by one that did.\n+                            final boolean duplicate = count > 1;\n+                            final int nlevels = config.getNLevels();\n+                            final List<CompletableFuture<Void>> futures = new ArrayList<>(nlevels);\n+                            for (int li = 0; li < nlevels; ++li) {\n+                                final int level = li;\n+\n+                                final CompletableFuture<Void> future;\n+\n+                                if (duplicate) {\n+                                    // Always subtract one, never clearing a key. It is possible for this to leave\n+                                    // a key with a count of zero, if duplicates were inserted with different hash functions.\n+                                    Function<byte[], Void> decrement = k -> {\n+                                        tr.mutate(MutationType.ADD, subspace.pack(Tuple.from(level, k)), encodeLong(-1));\n+                                        return null;\n+                                    };\n+                                    if (level == 0) {\n+                                        decrement.apply(key);\n+                                        future = DONE;\n+                                    } else {\n+                                        future = getPreviousKey(tr, level, key, true).thenApply(decrement);\n+                                    }\n+                                } else {\n+                                    // This could be optimized to check the hash for which levels should have this key.\n+                                    // That would require that the hash function never changes, though.\n+                                    // This allows for it to change, with the distribution perhaps getting a little uneven\n+                                    // as a result. It even allows for the hash function to return a random number.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTE2MTE5NA=="}, "originalCommit": {"oid": "d1b1b6f12150d9e94b768b4c08c62200d1d4a478"}, "originalPosition": 314}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM4NjM2MTU1OnYy", "diffSide": "RIGHT", "path": "fdb-extensions/src/main/java/com/apple/foundationdb/async/RankedSet.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yN1QxOToyMzoxNVrOFveIFw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wOVQxODozNjo0NlrOFz0scA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTMyMDk4Mw==", "bodyText": "I suppose these overloads could say that they are just synonyms for the overload that takes a full Config object with the defaults/parameters set as appropriate.", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/837#discussion_r385320983", "createdAt": "2020-02-27T19:23:15Z", "author": {"login": "alecgrieser"}, "path": "fdb-extensions/src/main/java/com/apple/foundationdb/async/RankedSet.java", "diffHunk": "@@ -143,30 +144,153 @@ private static long decodeLong(byte[] v) {\n         int hash(byte[] key);\n     }\n \n+    /**\n+     * Configuration settings for a {@link RankedSet}.\n+     */\n+    public static class Config {\n+        private final HashFunction hashFunction;\n+        private final int nlevels;\n+        private final boolean countDuplicates;\n+\n+        protected Config() {\n+            this.hashFunction = DEFAULT_HASH_FUNCTION;\n+            this.nlevels = DEFAULT_LEVELS;\n+            this.countDuplicates = false;\n+        }\n+\n+        protected Config(HashFunction hashFunction, int nlevels, boolean countDuplicates) {\n+            this.hashFunction = hashFunction;\n+            this.nlevels = nlevels;\n+            this.countDuplicates = countDuplicates;\n+        }\n+\n+        /**\n+         * Get the hash function to use.\n+         * @return a {@link HashFunction} used to convert keys to a bit mask used to determine level splits in the skip list\n+         */\n+        public HashFunction getHashFunction() {\n+            return hashFunction;\n+        }\n+\n+        /**\n+         * Get the number of levels to use.\n+         * @return the number of levels in the skip list\n+         */\n+        public int getNLevels() {\n+            return nlevels;\n+        }\n+\n+        /**\n+         * Get whether duplicate entries increase ranks below them.\n+         * @return {@code true} if duplicates are counted separately\n+         */\n+        public boolean isCountDuplicates() {\n+            return countDuplicates;\n+        }\n+    }\n+\n+\n+    /**\n+     * Builder for {@link Config}.\n+     *\n+     * @see #newConfigBuilder\n+     */\n+    public static class ConfigBuilder {\n+        private HashFunction hashFunction = DEFAULT_HASH_FUNCTION;\n+        private int nlevels = DEFAULT_LEVELS;\n+        private boolean countDuplicates = false;\n+\n+        protected ConfigBuilder() {\n+        }\n+\n+        public HashFunction getHashFunction() {\n+            return hashFunction;\n+        }\n+\n+        /**\n+         * Set the hash function to use.\n+         *\n+         * It is possible to change the hash function of an existing ranked set, although this is not recommended since the distribution in the skip list may\n+         * become uneven as a result.\n+         * @param hashFunction the hash function to use\n+         * @return this builder\n+         */\n+        public ConfigBuilder setHashFunction(HashFunction hashFunction) {\n+            this.hashFunction = hashFunction;\n+            return this;\n+        }\n+\n+        public int getNLevels() {\n+            return nlevels;\n+        }\n+\n+        /**\n+         * Set the hash function to use.\n+         *\n+         * It is not currently possible to change the number of levels for an existing ranked set.\n+         * @param nlevels the number of levels to use\n+         * @return this builder\n+         */\n+        public ConfigBuilder setNLevels(int nlevels) {\n+            if (nlevels < 2 || nlevels > MAX_LEVELS) {\n+                throw new IllegalArgumentException(\"levels must be between 2 and \" + MAX_LEVELS);\n+            }\n+            this.nlevels = nlevels;\n+            return this;\n+        }\n+\n+        public boolean isCountDuplicates() {\n+            return countDuplicates;\n+        }\n+\n+        /**\n+         * Set whether to count duplicate keys separately.\n+         *\n+         * If duplicate keys are counted separately, ranks after them are increased by the number of duplicates.\n+         * @param countDuplicates whether to count duplicates\n+         * @return this builder\n+         */\n+        public ConfigBuilder setCountDuplicates(boolean countDuplicates) {\n+            this.countDuplicates = countDuplicates;\n+            return this;\n+        }\n+\n+        public Config build() {\n+            return new Config(hashFunction, nlevels, countDuplicates);\n+        }\n+    }\n+\n+    /**\n+     * Start building a {@link Config}.\n+     * @return a new {@code Config} that can be altered and then built for use with a {@link RankedSet}\n+     * @see ConfigBuilder#build\n+     */\n+    public static ConfigBuilder newConfigBuilder() {\n+        return new ConfigBuilder();\n+    }\n+\n     /**\n      * Initialize a new ranked set.\n      * @param subspace the subspace where the ranked set is stored\n      * @param executor an executor to use when running asynchronous tasks\n-     * @param hashFunction hash function to use to determine which levels a key splits on\n-     * @param nlevels number of skip list levels to maintain\n+     * @param config configuration to use\n      */\n-    public RankedSet(Subspace subspace, Executor executor, HashFunction hashFunction, int nlevels) {\n-        if (nlevels < 2 || nlevels > MAX_LEVELS) {\n-            throw new IllegalArgumentException(\"levels must be between 2 and \" + MAX_LEVELS);\n-        }\n-\n+    public RankedSet(Subspace subspace, Executor executor, Config config) {\n         this.subspace = subspace;\n         this.executor = executor;\n-        this.hashFunction = hashFunction;\n-        this.nlevels = nlevels;\n+        this.config = config;\n+    }\n+\n+    public RankedSet(Subspace subspace, Executor executor, HashFunction hashFunction, int nlevels) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d1b1b6f12150d9e94b768b4c08c62200d1d4a478"}, "originalPosition": 172}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTg4NTA0MA==", "bodyText": "Added such comments.", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/837#discussion_r389885040", "createdAt": "2020-03-09T18:36:46Z", "author": {"login": "MMcM"}, "path": "fdb-extensions/src/main/java/com/apple/foundationdb/async/RankedSet.java", "diffHunk": "@@ -143,30 +144,153 @@ private static long decodeLong(byte[] v) {\n         int hash(byte[] key);\n     }\n \n+    /**\n+     * Configuration settings for a {@link RankedSet}.\n+     */\n+    public static class Config {\n+        private final HashFunction hashFunction;\n+        private final int nlevels;\n+        private final boolean countDuplicates;\n+\n+        protected Config() {\n+            this.hashFunction = DEFAULT_HASH_FUNCTION;\n+            this.nlevels = DEFAULT_LEVELS;\n+            this.countDuplicates = false;\n+        }\n+\n+        protected Config(HashFunction hashFunction, int nlevels, boolean countDuplicates) {\n+            this.hashFunction = hashFunction;\n+            this.nlevels = nlevels;\n+            this.countDuplicates = countDuplicates;\n+        }\n+\n+        /**\n+         * Get the hash function to use.\n+         * @return a {@link HashFunction} used to convert keys to a bit mask used to determine level splits in the skip list\n+         */\n+        public HashFunction getHashFunction() {\n+            return hashFunction;\n+        }\n+\n+        /**\n+         * Get the number of levels to use.\n+         * @return the number of levels in the skip list\n+         */\n+        public int getNLevels() {\n+            return nlevels;\n+        }\n+\n+        /**\n+         * Get whether duplicate entries increase ranks below them.\n+         * @return {@code true} if duplicates are counted separately\n+         */\n+        public boolean isCountDuplicates() {\n+            return countDuplicates;\n+        }\n+    }\n+\n+\n+    /**\n+     * Builder for {@link Config}.\n+     *\n+     * @see #newConfigBuilder\n+     */\n+    public static class ConfigBuilder {\n+        private HashFunction hashFunction = DEFAULT_HASH_FUNCTION;\n+        private int nlevels = DEFAULT_LEVELS;\n+        private boolean countDuplicates = false;\n+\n+        protected ConfigBuilder() {\n+        }\n+\n+        public HashFunction getHashFunction() {\n+            return hashFunction;\n+        }\n+\n+        /**\n+         * Set the hash function to use.\n+         *\n+         * It is possible to change the hash function of an existing ranked set, although this is not recommended since the distribution in the skip list may\n+         * become uneven as a result.\n+         * @param hashFunction the hash function to use\n+         * @return this builder\n+         */\n+        public ConfigBuilder setHashFunction(HashFunction hashFunction) {\n+            this.hashFunction = hashFunction;\n+            return this;\n+        }\n+\n+        public int getNLevels() {\n+            return nlevels;\n+        }\n+\n+        /**\n+         * Set the hash function to use.\n+         *\n+         * It is not currently possible to change the number of levels for an existing ranked set.\n+         * @param nlevels the number of levels to use\n+         * @return this builder\n+         */\n+        public ConfigBuilder setNLevels(int nlevels) {\n+            if (nlevels < 2 || nlevels > MAX_LEVELS) {\n+                throw new IllegalArgumentException(\"levels must be between 2 and \" + MAX_LEVELS);\n+            }\n+            this.nlevels = nlevels;\n+            return this;\n+        }\n+\n+        public boolean isCountDuplicates() {\n+            return countDuplicates;\n+        }\n+\n+        /**\n+         * Set whether to count duplicate keys separately.\n+         *\n+         * If duplicate keys are counted separately, ranks after them are increased by the number of duplicates.\n+         * @param countDuplicates whether to count duplicates\n+         * @return this builder\n+         */\n+        public ConfigBuilder setCountDuplicates(boolean countDuplicates) {\n+            this.countDuplicates = countDuplicates;\n+            return this;\n+        }\n+\n+        public Config build() {\n+            return new Config(hashFunction, nlevels, countDuplicates);\n+        }\n+    }\n+\n+    /**\n+     * Start building a {@link Config}.\n+     * @return a new {@code Config} that can be altered and then built for use with a {@link RankedSet}\n+     * @see ConfigBuilder#build\n+     */\n+    public static ConfigBuilder newConfigBuilder() {\n+        return new ConfigBuilder();\n+    }\n+\n     /**\n      * Initialize a new ranked set.\n      * @param subspace the subspace where the ranked set is stored\n      * @param executor an executor to use when running asynchronous tasks\n-     * @param hashFunction hash function to use to determine which levels a key splits on\n-     * @param nlevels number of skip list levels to maintain\n+     * @param config configuration to use\n      */\n-    public RankedSet(Subspace subspace, Executor executor, HashFunction hashFunction, int nlevels) {\n-        if (nlevels < 2 || nlevels > MAX_LEVELS) {\n-            throw new IllegalArgumentException(\"levels must be between 2 and \" + MAX_LEVELS);\n-        }\n-\n+    public RankedSet(Subspace subspace, Executor executor, Config config) {\n         this.subspace = subspace;\n         this.executor = executor;\n-        this.hashFunction = hashFunction;\n-        this.nlevels = nlevels;\n+        this.config = config;\n+    }\n+\n+    public RankedSet(Subspace subspace, Executor executor, HashFunction hashFunction, int nlevels) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTMyMDk4Mw=="}, "originalCommit": {"oid": "d1b1b6f12150d9e94b768b4c08c62200d1d4a478"}, "originalPosition": 172}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQwNzg4NDg2OnYy", "diffSide": "RIGHT", "path": "fdb-extensions/src/main/java/com/apple/foundationdb/async/RankedSet.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNlQwMDoyMjoyNVrOFyoxGw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wOVQxODozNzoxNFrOFz0tQQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODY0MTA1MQ==", "bodyText": "If I understand this, the duplicate || here is to ensure that we don't split at the same point twice and then (in a world where, for example, the \"hash\" was just random each time instead of based on the data) don't decide to add a split only on the second time we see it (or something). Might be nice to have a comment here about that.", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/837#discussion_r388641051", "createdAt": "2020-03-06T00:22:25Z", "author": {"login": "alecgrieser"}, "path": "fdb-extensions/src/main/java/com/apple/foundationdb/async/RankedSet.java", "diffHunk": "@@ -179,33 +303,39 @@ public RankedSet(Subspace subspace, Executor executor) {\n      * @return {@code true} if this ranked set needs to be initialized\n      */\n     public CompletableFuture<Boolean> initNeeded(ReadTransactionContext tc) {\n-        return containsCheckedKey(tc, EMPTY_ARRAY).thenApply(b -> !b);\n+        return countCheckedKey(tc, EMPTY_ARRAY).thenApply(Objects::isNull);\n     }\n \n     /**\n      * Add a key to the set.\n+     *\n+     * If {@link Config#isCountDuplicates} is {@code false} and {@code key} is already present, the return value is {@code false}.\n+     * If {@link Config#isCountDuplicates} is {@code true}, the return value is never {@code false} and a duplicate will\n+     * cause all {@link #rank}s below it to increase by one.\n      * @param tc the transaction to use to access the database\n      * @param key the key to add\n-     * @return a future that completes to {@code true} if the key was not already present\n+     * @return a future that completes to {@code true} if the ranked set was modified\n      */\n     public CompletableFuture<Boolean> add(TransactionContext tc, byte[] key) {\n         checkKey(key);\n         // Use the hash of the key, instead a p value and randomLevel. The key is likely Tuple-encoded.\n-        long keyHash = hashFunction.hash(key);\n+        final long keyHash = config.getHashFunction().hash(key);\n         return tc.runAsync(tr ->\n-            containsCheckedKey(tr, key)\n-                .thenCompose(exists -> {\n-                    if (exists) {\n+            countCheckedKey(tr, key)\n+                .thenCompose(count -> {\n+                    final boolean duplicate = count != null && count > 0;\n+                    if (duplicate && !config.isCountDuplicates()) {\n                         return READY_FALSE;\n                     }\n+                    final int nlevels = config.getNLevels();\n                     List<CompletableFuture<Void>> futures = new ArrayList<>(nlevels);\n                     for (int li = 0; li < nlevels; ++li) {\n-                        int level = li;\n+                        final int level = li;\n                         CompletableFuture<Void> future;\n                         if (level == 0) {\n-                            future = addLevelZeroKey(tr, key, level);\n-                        } else if ((keyHash & LEVEL_FAN_VALUES[level]) != 0) {\n-                            future = addIncrementLevelKey(tr, key, level);\n+                            future = addLevelZeroKey(tr, key, level, duplicate);\n+                        } else if (duplicate || (keyHash & LEVEL_FAN_VALUES[level]) != 0) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d1b1b6f12150d9e94b768b4c08c62200d1d4a478"}, "originalPosition": 232}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTg4NTI0OQ==", "bodyText": "I amplified these comments.", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/837#discussion_r389885249", "createdAt": "2020-03-09T18:37:14Z", "author": {"login": "MMcM"}, "path": "fdb-extensions/src/main/java/com/apple/foundationdb/async/RankedSet.java", "diffHunk": "@@ -179,33 +303,39 @@ public RankedSet(Subspace subspace, Executor executor) {\n      * @return {@code true} if this ranked set needs to be initialized\n      */\n     public CompletableFuture<Boolean> initNeeded(ReadTransactionContext tc) {\n-        return containsCheckedKey(tc, EMPTY_ARRAY).thenApply(b -> !b);\n+        return countCheckedKey(tc, EMPTY_ARRAY).thenApply(Objects::isNull);\n     }\n \n     /**\n      * Add a key to the set.\n+     *\n+     * If {@link Config#isCountDuplicates} is {@code false} and {@code key} is already present, the return value is {@code false}.\n+     * If {@link Config#isCountDuplicates} is {@code true}, the return value is never {@code false} and a duplicate will\n+     * cause all {@link #rank}s below it to increase by one.\n      * @param tc the transaction to use to access the database\n      * @param key the key to add\n-     * @return a future that completes to {@code true} if the key was not already present\n+     * @return a future that completes to {@code true} if the ranked set was modified\n      */\n     public CompletableFuture<Boolean> add(TransactionContext tc, byte[] key) {\n         checkKey(key);\n         // Use the hash of the key, instead a p value and randomLevel. The key is likely Tuple-encoded.\n-        long keyHash = hashFunction.hash(key);\n+        final long keyHash = config.getHashFunction().hash(key);\n         return tc.runAsync(tr ->\n-            containsCheckedKey(tr, key)\n-                .thenCompose(exists -> {\n-                    if (exists) {\n+            countCheckedKey(tr, key)\n+                .thenCompose(count -> {\n+                    final boolean duplicate = count != null && count > 0;\n+                    if (duplicate && !config.isCountDuplicates()) {\n                         return READY_FALSE;\n                     }\n+                    final int nlevels = config.getNLevels();\n                     List<CompletableFuture<Void>> futures = new ArrayList<>(nlevels);\n                     for (int li = 0; li < nlevels; ++li) {\n-                        int level = li;\n+                        final int level = li;\n                         CompletableFuture<Void> future;\n                         if (level == 0) {\n-                            future = addLevelZeroKey(tr, key, level);\n-                        } else if ((keyHash & LEVEL_FAN_VALUES[level]) != 0) {\n-                            future = addIncrementLevelKey(tr, key, level);\n+                            future = addLevelZeroKey(tr, key, level, duplicate);\n+                        } else if (duplicate || (keyHash & LEVEL_FAN_VALUES[level]) != 0) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODY0MTA1MQ=="}, "originalCommit": {"oid": "d1b1b6f12150d9e94b768b4c08c62200d1d4a478"}, "originalPosition": 232}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQwNzkxNTAyOnYy", "diffSide": "RIGHT", "path": "fdb-extensions/src/main/java/com/apple/foundationdb/async/RankedSet.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNlQwMDozNDoxNVrOFypCHQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNlQwMDozNDoxNVrOFypCHQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODY0NTQwNQ==", "bodyText": "It's a little unfortunate our nullability annotations don't allow us to return an @Nullable Long. IIUC, we do actually check the nullity (rather than treat it as zero) to check if we need to initialize the ranked set, which is a little unfortunate. hmm", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/837#discussion_r388645405", "createdAt": "2020-03-06T00:34:15Z", "author": {"login": "alecgrieser"}, "path": "fdb-extensions/src/main/java/com/apple/foundationdb/async/RankedSet.java", "diffHunk": "@@ -267,17 +477,30 @@ public RankedSet(Subspace subspace, Executor executor) {\n      */\n     public CompletableFuture<Boolean> contains(ReadTransactionContext tc, byte[] key) {\n         checkKey(key);\n-        return containsCheckedKey(tc, key);\n+        return countCheckedKey(tc, key).thenApply(c -> c != null && c > 0);\n+    }\n+\n+    /**\n+     * Count the number of occurrences of a key in the set.\n+     * @param tc the transaction to use to access the database\n+     * @param key the key to check for\n+     * @return a future that completes to {@code 0} if the key is not present in the ranked set or\n+     * {@code 1} if the key is present in the ranked set and duplicates are not counted or\n+     * the number of occurrences if duplicated are counted separately\n+     */\n+    public CompletableFuture<Long> count(ReadTransactionContext tc, byte[] key) {\n+        checkKey(key);\n+        return countCheckedKey(tc, key).thenApply(c -> c == null ? Long.valueOf(0) : c);\n     }\n \n-    private CompletableFuture<Boolean> containsCheckedKey(ReadTransactionContext tc, byte[] key) {\n-        return tc.readAsync(tr -> tr.get(subspace.pack(Tuple.from(0, key))).thenApply(Objects::nonNull));\n+    private CompletableFuture<Long> countCheckedKey(ReadTransactionContext tc, byte[] key) {\n+        return tc.readAsync(tr -> tr.get(subspace.pack(Tuple.from(0, key))).thenApply(b -> b == null ? null : decodeLong(b)));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d1b1b6f12150d9e94b768b4c08c62200d1d4a478"}, "originalPosition": 374}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQwNzk1MTMxOnYy", "diffSide": "RIGHT", "path": "fdb-extensions/src/main/java/com/apple/foundationdb/async/RankedSet.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNlQwMDo1MToyMlrOFypXJw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wOVQxODoxMzowMVrOFzz5qw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODY1MDc5MQ==", "bodyText": "I don't think that this conflict is necessary in multi-set mode, as keys are never removed (at the moment), though I suppose that could change. It also could result in spurious conflicts when the values of those keys are incremented or decremented (but not to 0).\nedit: removed first claim based on re-read of remove code.", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/837#discussion_r388650791", "createdAt": "2020-03-06T00:51:22Z", "author": {"login": "alecgrieser"}, "path": "fdb-extensions/src/main/java/com/apple/foundationdb/async/RankedSet.java", "diffHunk": "@@ -643,19 +819,21 @@ private static void checkKey(byte[] key) {\n                         .thenApply(longs -> longs.stream().reduce(0L, Long::sum)));\n     }\n \n-    private CompletableFuture<byte[]> getPreviousKey(TransactionContext tc, int level, byte[] key) {\n+    // Get the key before this one at the given level.\n+    // If orEqual is given, then an exactly matching key is also considered. This is only used when the key is known\n+    // to be a duplicate or an existing key and so should do whatever it did.\n+    private CompletableFuture<byte[]> getPreviousKey(TransactionContext tc, int level, byte[] key, boolean orEqual) {\n         byte[] k = subspace.pack(Tuple.from(level, key));\n         CompletableFuture<byte[]> kf = tc.run(tr ->\n-                tr.snapshot()\n-                        .getRange(KeySelector.lastLessThan(k), KeySelector.firstGreaterOrEqual(k), 1)\n-                        .asList()\n-                        .thenApply(kvs -> {\n-                            byte[] prevk = kvs.get(0).getKey();\n-                            // If another key were inserted after between this and the target key,\n-                            // it wouldn't be the one we should increment any more.\n-                            // But do not conflict when key itself is incremented.\n-                            byte[] exclusiveBegin = ByteArrayUtil.join(prevk, ZERO_ARRAY);\n-                            tr.addReadConflictRange(exclusiveBegin, k);\n+                tr.snapshot().getKey(orEqual ? KeySelector.lastLessOrEqual(k) : KeySelector.lastLessThan(k))\n+                        .thenApply(prevk -> {\n+                            if (!orEqual || !Arrays.equals(prevk, k)) {\n+                                // If another key were inserted after between this and the target key,\n+                                // it wouldn't be the one we should increment any more.\n+                                // But do not conflict when key itself is incremented.\n+                                byte[] exclusiveBegin = ByteArrayUtil.join(prevk, ZERO_ARRAY);\n+                                tr.addReadConflictRange(exclusiveBegin, k);\n+                            }\n                             // Do conflict if key is removed entirely.\n                             tr.addReadConflictKey(subspace.pack(Tuple.from(0, subspace.unpack(prevk).getBytes(1))));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d1b1b6f12150d9e94b768b4c08c62200d1d4a478"}, "originalPosition": 540}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTg2NDIzMg==", "bodyText": "I believe that in the case where this is a duplicate and matches the key itself, this adds another read conflict for the one that was already added by countCheckedKey to determine that it was a duplicate. So I'm not sure what the case is where this is a totally superfluous read conflict.", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/837#discussion_r389864232", "createdAt": "2020-03-09T17:58:47Z", "author": {"login": "MMcM"}, "path": "fdb-extensions/src/main/java/com/apple/foundationdb/async/RankedSet.java", "diffHunk": "@@ -643,19 +819,21 @@ private static void checkKey(byte[] key) {\n                         .thenApply(longs -> longs.stream().reduce(0L, Long::sum)));\n     }\n \n-    private CompletableFuture<byte[]> getPreviousKey(TransactionContext tc, int level, byte[] key) {\n+    // Get the key before this one at the given level.\n+    // If orEqual is given, then an exactly matching key is also considered. This is only used when the key is known\n+    // to be a duplicate or an existing key and so should do whatever it did.\n+    private CompletableFuture<byte[]> getPreviousKey(TransactionContext tc, int level, byte[] key, boolean orEqual) {\n         byte[] k = subspace.pack(Tuple.from(level, key));\n         CompletableFuture<byte[]> kf = tc.run(tr ->\n-                tr.snapshot()\n-                        .getRange(KeySelector.lastLessThan(k), KeySelector.firstGreaterOrEqual(k), 1)\n-                        .asList()\n-                        .thenApply(kvs -> {\n-                            byte[] prevk = kvs.get(0).getKey();\n-                            // If another key were inserted after between this and the target key,\n-                            // it wouldn't be the one we should increment any more.\n-                            // But do not conflict when key itself is incremented.\n-                            byte[] exclusiveBegin = ByteArrayUtil.join(prevk, ZERO_ARRAY);\n-                            tr.addReadConflictRange(exclusiveBegin, k);\n+                tr.snapshot().getKey(orEqual ? KeySelector.lastLessOrEqual(k) : KeySelector.lastLessThan(k))\n+                        .thenApply(prevk -> {\n+                            if (!orEqual || !Arrays.equals(prevk, k)) {\n+                                // If another key were inserted after between this and the target key,\n+                                // it wouldn't be the one we should increment any more.\n+                                // But do not conflict when key itself is incremented.\n+                                byte[] exclusiveBegin = ByteArrayUtil.join(prevk, ZERO_ARRAY);\n+                                tr.addReadConflictRange(exclusiveBegin, k);\n+                            }\n                             // Do conflict if key is removed entirely.\n                             tr.addReadConflictKey(subspace.pack(Tuple.from(0, subspace.unpack(prevk).getBytes(1))));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODY1MDc5MQ=="}, "originalCommit": {"oid": "d1b1b6f12150d9e94b768b4c08c62200d1d4a478"}, "originalPosition": 540}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTg3MjA0Mw==", "bodyText": "I was thinking something like: you have two entries, a and b in level 0 and only a in level 1. Then if you increment b, that will induce a conflict range on b in level 0 (from countCheckedKey) and the range (a, b] (I think) in level 1 and then on just a in level 0. But a concurrent increment of a would change the value of a in level 0, so the increment on b could be failed as a result, but if this conflict range is removed, I think the conflict induced by the increment of a that fails the increment of b wouldn't happen. I think.", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/837#discussion_r389872043", "createdAt": "2020-03-09T18:13:01Z", "author": {"login": "alecgrieser"}, "path": "fdb-extensions/src/main/java/com/apple/foundationdb/async/RankedSet.java", "diffHunk": "@@ -643,19 +819,21 @@ private static void checkKey(byte[] key) {\n                         .thenApply(longs -> longs.stream().reduce(0L, Long::sum)));\n     }\n \n-    private CompletableFuture<byte[]> getPreviousKey(TransactionContext tc, int level, byte[] key) {\n+    // Get the key before this one at the given level.\n+    // If orEqual is given, then an exactly matching key is also considered. This is only used when the key is known\n+    // to be a duplicate or an existing key and so should do whatever it did.\n+    private CompletableFuture<byte[]> getPreviousKey(TransactionContext tc, int level, byte[] key, boolean orEqual) {\n         byte[] k = subspace.pack(Tuple.from(level, key));\n         CompletableFuture<byte[]> kf = tc.run(tr ->\n-                tr.snapshot()\n-                        .getRange(KeySelector.lastLessThan(k), KeySelector.firstGreaterOrEqual(k), 1)\n-                        .asList()\n-                        .thenApply(kvs -> {\n-                            byte[] prevk = kvs.get(0).getKey();\n-                            // If another key were inserted after between this and the target key,\n-                            // it wouldn't be the one we should increment any more.\n-                            // But do not conflict when key itself is incremented.\n-                            byte[] exclusiveBegin = ByteArrayUtil.join(prevk, ZERO_ARRAY);\n-                            tr.addReadConflictRange(exclusiveBegin, k);\n+                tr.snapshot().getKey(orEqual ? KeySelector.lastLessOrEqual(k) : KeySelector.lastLessThan(k))\n+                        .thenApply(prevk -> {\n+                            if (!orEqual || !Arrays.equals(prevk, k)) {\n+                                // If another key were inserted after between this and the target key,\n+                                // it wouldn't be the one we should increment any more.\n+                                // But do not conflict when key itself is incremented.\n+                                byte[] exclusiveBegin = ByteArrayUtil.join(prevk, ZERO_ARRAY);\n+                                tr.addReadConflictRange(exclusiveBegin, k);\n+                            }\n                             // Do conflict if key is removed entirely.\n                             tr.addReadConflictKey(subspace.pack(Tuple.from(0, subspace.unpack(prevk).getBytes(1))));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODY1MDc5MQ=="}, "originalCommit": {"oid": "d1b1b6f12150d9e94b768b4c08c62200d1d4a478"}, "originalPosition": 540}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQwNzk2MDg5OnYy", "diffSide": "RIGHT", "path": "fdb-extensions/src/main/java/com/apple/foundationdb/async/RankedSet.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNlQwMDo1NDoyMVrOFypckA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMFQwMTowOTo1MFrOFz-Vig==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODY1MjE3Ng==", "bodyText": "Hm, it's a little unfortunate that this would leave around empty keys and signposts. I think we could almost get around this by adding tr.mutate(MutationType.COMPARE_AND_CLEAR, subspace.pack(Tuple.from(level, k)), encodeLong(0)) (probably not serializing the key twice), but there's a case I was thinking through that I think this breaks for.\nSuppose you had a 2-level skip list with something like:\nlevel 1: (0 -> 1)----(1 -> 1)---------------------(5 -> 1)\nlevel 0: (0 -> 1)-------------------(3 -> 1)------(5 -> 1)\n\n(That is 0, 3, and 5 in level 0 and 0, 1, and 5 in level 1. Presumably, there used to be a 1 in the skip list, but it was removed at some point.) Then suppose you had the following three operations: insert 2, remove 3, insert 4, and assume that neither of the two inserts cause a split. And assume the following ordering of GRVs and commits:\n\ninsert 4 GRV\nremove 3 GRV\nremove 3 commit\ninsert 2 GRV\ninsert 2 commit\ninsert 4 commit\n\nAfter the remove 3 has committed, then I think the skip list would look like:\nlevel 1: (0 -> 1)------------------------------(5 -> 1)\nlevel 0: (0 -> 1)------------------------------(5 -> 1)\n\nAs removing 3 also decrements the count of 1 to 0. So when 2 is inserted (and commits), it doesn't see anything at the higher levels before 0. So the skip list it writes looks like:\nlevel 1: (0 -> 2)-------------------------------(5 -> 1)\nlevel 0: (0 -> 1)--------------(2 -> 1)---------(5 -> 1)\n\nBut the insert of 4 happened when 1 still was in level 1, so it will increment that value, which I believes results in this invalid skip list if committed:\nlevel 1: (0 -> 2)---(1 -> 1)------------------------(5 -> 1)\nlevel 0: (0 -> 1)-------------(2 -> 1)---(4 -> 1)---(5 -> 1)\n\nAnd the read conflict set on committing the insert of 4 would be on level 0's key 1 (which was not modified) and on the level 1 range from key 1 (exclusive) to 4 (inclusive), none of which changed. So I think this commit is successful.\nI don't actually think this problem is possible with the code as it is, given that it keeps the zero's around, though I could be convinced that we haven't thought through all of the cases here. (The fatal flaw here is that we add a read conflict on the level 0 key for the sign-post key as a proxy for \"fail this transaction only if the key disappears\", but that isn't necessarily the case in the proposal as I've sketched it. As we never remove any key from the range set, the current code can't hit that pathology as written.)\nI wonder if there might be a way to expand the write conflict range of a delete (maybe) on a key delete or something, of at least the upper levels, and if that would be sufficient, though it may not work with mixed software versions. It's also possible that instead of this fancy \"compare and clear\" business that I suggested, instead, it needs to enforce that if a key is at level k, then that key is present in all levels less than k, which is a property of the current code and also skip lists more generally, but it would probably hurt the concurrency of the multi-set case (though maybe the code paths for set and multi-set are more similar?).", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/837#discussion_r388652176", "createdAt": "2020-03-06T00:54:21Z", "author": {"login": "alecgrieser"}, "path": "fdb-extensions/src/main/java/com/apple/foundationdb/async/RankedSet.java", "diffHunk": "@@ -356,37 +396,59 @@ public RankedSet(Subspace subspace, Executor executor) {\n                             if (count == null || count <= 0) {\n                                 return READY_FALSE;\n                             }\n+                            // This works even if the current set does not track duplicates but duplicates were added\n+                            // earlier by one that did.\n+                            final boolean duplicate = count > 1;\n                             final int nlevels = config.getNLevels();\n                             final List<CompletableFuture<Void>> futures = new ArrayList<>(nlevels);\n                             for (int li = 0; li < nlevels; ++li) {\n                                 final int level = li;\n-                                // This could be optimized to check the hash for which levels should have this key.\n-                                final byte[] k = subspace.pack(Tuple.from(level, key));\n \n                                 final CompletableFuture<Void> future;\n-                                final CompletableFuture<byte[]> cf = tr.get(k);\n \n-                                if (level == 0) {\n-                                    future = cf.thenApply(c -> {\n-                                        if (c != null) {\n-                                            tr.clear(k);\n-                                        }\n+                                if (duplicate) {\n+                                    // Always subtract one, never clearing a key. It is possible for this to leave\n+                                    // a key with a count of zero, if duplicates were inserted with different hash functions.\n+                                    Function<byte[], Void> decrement = k -> {\n+                                        tr.mutate(MutationType.ADD, subspace.pack(Tuple.from(level, k)), encodeLong(-1));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "eaca40e0c8b2079dc59730fa3dd94e7c4ddf4cad"}, "originalPosition": 182}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDA0MzAxOA==", "bodyText": "I see now that as we read the count and, if the count is 1, just remove the key, that this is no longer something to be worried about, though I suppose one could wist hopefully for a data structure with fewer conflicts (e.g., no conflicts when adding or removing the same key). It....might be possible, but it probably requires additional fanciness like conflicts in same \"shadow realm\", and it can be done later if we decide we really want it.", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/837#discussion_r390043018", "createdAt": "2020-03-10T01:09:50Z", "author": {"login": "alecgrieser"}, "path": "fdb-extensions/src/main/java/com/apple/foundationdb/async/RankedSet.java", "diffHunk": "@@ -356,37 +396,59 @@ public RankedSet(Subspace subspace, Executor executor) {\n                             if (count == null || count <= 0) {\n                                 return READY_FALSE;\n                             }\n+                            // This works even if the current set does not track duplicates but duplicates were added\n+                            // earlier by one that did.\n+                            final boolean duplicate = count > 1;\n                             final int nlevels = config.getNLevels();\n                             final List<CompletableFuture<Void>> futures = new ArrayList<>(nlevels);\n                             for (int li = 0; li < nlevels; ++li) {\n                                 final int level = li;\n-                                // This could be optimized to check the hash for which levels should have this key.\n-                                final byte[] k = subspace.pack(Tuple.from(level, key));\n \n                                 final CompletableFuture<Void> future;\n-                                final CompletableFuture<byte[]> cf = tr.get(k);\n \n-                                if (level == 0) {\n-                                    future = cf.thenApply(c -> {\n-                                        if (c != null) {\n-                                            tr.clear(k);\n-                                        }\n+                                if (duplicate) {\n+                                    // Always subtract one, never clearing a key. It is possible for this to leave\n+                                    // a key with a count of zero, if duplicates were inserted with different hash functions.\n+                                    Function<byte[], Void> decrement = k -> {\n+                                        tr.mutate(MutationType.ADD, subspace.pack(Tuple.from(level, k)), encodeLong(-1));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODY1MjE3Ng=="}, "originalCommit": {"oid": "eaca40e0c8b2079dc59730fa3dd94e7c4ddf4cad"}, "originalPosition": 182}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQwODA1MzEzOnYy", "diffSide": "RIGHT", "path": "fdb-extensions/src/main/java/com/apple/foundationdb/async/RankedSet.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNlQwMToxNjo0NVrOFyqNXw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wOVQxODo1MDozMVrOFz1Jcw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODY2NDY3MQ==", "bodyText": "This .allOf isn't new, but I suppose this could be thenCombine or .thenAcceptBoth, and I think it would be cleaner.", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/837#discussion_r388664671", "createdAt": "2020-03-06T01:16:45Z", "author": {"login": "alecgrieser"}, "path": "fdb-extensions/src/main/java/com/apple/foundationdb/async/RankedSet.java", "diffHunk": "@@ -356,37 +396,59 @@ public RankedSet(Subspace subspace, Executor executor) {\n                             if (count == null || count <= 0) {\n                                 return READY_FALSE;\n                             }\n+                            // This works even if the current set does not track duplicates but duplicates were added\n+                            // earlier by one that did.\n+                            final boolean duplicate = count > 1;\n                             final int nlevels = config.getNLevels();\n                             final List<CompletableFuture<Void>> futures = new ArrayList<>(nlevels);\n                             for (int li = 0; li < nlevels; ++li) {\n                                 final int level = li;\n-                                // This could be optimized to check the hash for which levels should have this key.\n-                                final byte[] k = subspace.pack(Tuple.from(level, key));\n \n                                 final CompletableFuture<Void> future;\n-                                final CompletableFuture<byte[]> cf = tr.get(k);\n \n-                                if (level == 0) {\n-                                    future = cf.thenApply(c -> {\n-                                        if (c != null) {\n-                                            tr.clear(k);\n-                                        }\n+                                if (duplicate) {\n+                                    // Always subtract one, never clearing a key. It is possible for this to leave\n+                                    // a key with a count of zero, if duplicates were inserted with different hash functions.\n+                                    Function<byte[], Void> decrement = k -> {\n+                                        tr.mutate(MutationType.ADD, subspace.pack(Tuple.from(level, k)), encodeLong(-1));\n                                         return null;\n-                                    });\n+                                    };\n+                                    if (level == 0) {\n+                                        decrement.apply(key);\n+                                        future = DONE;\n+                                    } else {\n+                                        future = getPreviousKey(tr, level, key, true).thenApply(decrement);\n+                                    }\n                                 } else {\n-                                    final CompletableFuture<byte[]> prevKeyF = getPreviousKey(tr, level, key);\n-                                    future = CompletableFuture.allOf(cf, prevKeyF)\n-                                            .thenApply(vignore -> {\n-                                                final byte[] c = cf.join();\n-                                                long countChange = -1;\n-                                                if (c != null) {\n-                                                    // Give back additional count from the key we are erasing to the neighbor.\n-                                                    countChange += decodeLong(c);\n-                                                    tr.clear(k);\n-                                                }\n-                                                tr.mutate(MutationType.ADD, subspace.pack(Tuple.from(level, prevKeyF.join())), encodeLong(countChange));\n-                                                return null;\n-                                            });\n+                                    // This could be optimized to check the hash for which levels should have this key.\n+                                    // That would require that the hash function never changes, though.\n+                                    // This allows for it to change, with the distribution perhaps getting a little uneven\n+                                    // as a result. It even allows for the hash function to return a random number.\n+                                    final byte[] k = subspace.pack(Tuple.from(level, key));\n+                                    final CompletableFuture<byte[]> cf = tr.get(k);\n+\n+                                    if (level == 0) {\n+                                        future = cf.thenApply(c -> {\n+                                            if (c != null) {\n+                                                tr.clear(k);\n+                                            }\n+                                            return null;\n+                                        });\n+                                    } else {\n+                                        final CompletableFuture<byte[]> prevKeyF = getPreviousKey(tr, level, key, false);\n+                                        future = CompletableFuture.allOf(cf, prevKeyF)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "eaca40e0c8b2079dc59730fa3dd94e7c4ddf4cad"}, "originalPosition": 222}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTg5MjQ2Nw==", "bodyText": "Done", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/837#discussion_r389892467", "createdAt": "2020-03-09T18:50:31Z", "author": {"login": "MMcM"}, "path": "fdb-extensions/src/main/java/com/apple/foundationdb/async/RankedSet.java", "diffHunk": "@@ -356,37 +396,59 @@ public RankedSet(Subspace subspace, Executor executor) {\n                             if (count == null || count <= 0) {\n                                 return READY_FALSE;\n                             }\n+                            // This works even if the current set does not track duplicates but duplicates were added\n+                            // earlier by one that did.\n+                            final boolean duplicate = count > 1;\n                             final int nlevels = config.getNLevels();\n                             final List<CompletableFuture<Void>> futures = new ArrayList<>(nlevels);\n                             for (int li = 0; li < nlevels; ++li) {\n                                 final int level = li;\n-                                // This could be optimized to check the hash for which levels should have this key.\n-                                final byte[] k = subspace.pack(Tuple.from(level, key));\n \n                                 final CompletableFuture<Void> future;\n-                                final CompletableFuture<byte[]> cf = tr.get(k);\n \n-                                if (level == 0) {\n-                                    future = cf.thenApply(c -> {\n-                                        if (c != null) {\n-                                            tr.clear(k);\n-                                        }\n+                                if (duplicate) {\n+                                    // Always subtract one, never clearing a key. It is possible for this to leave\n+                                    // a key with a count of zero, if duplicates were inserted with different hash functions.\n+                                    Function<byte[], Void> decrement = k -> {\n+                                        tr.mutate(MutationType.ADD, subspace.pack(Tuple.from(level, k)), encodeLong(-1));\n                                         return null;\n-                                    });\n+                                    };\n+                                    if (level == 0) {\n+                                        decrement.apply(key);\n+                                        future = DONE;\n+                                    } else {\n+                                        future = getPreviousKey(tr, level, key, true).thenApply(decrement);\n+                                    }\n                                 } else {\n-                                    final CompletableFuture<byte[]> prevKeyF = getPreviousKey(tr, level, key);\n-                                    future = CompletableFuture.allOf(cf, prevKeyF)\n-                                            .thenApply(vignore -> {\n-                                                final byte[] c = cf.join();\n-                                                long countChange = -1;\n-                                                if (c != null) {\n-                                                    // Give back additional count from the key we are erasing to the neighbor.\n-                                                    countChange += decodeLong(c);\n-                                                    tr.clear(k);\n-                                                }\n-                                                tr.mutate(MutationType.ADD, subspace.pack(Tuple.from(level, prevKeyF.join())), encodeLong(countChange));\n-                                                return null;\n-                                            });\n+                                    // This could be optimized to check the hash for which levels should have this key.\n+                                    // That would require that the hash function never changes, though.\n+                                    // This allows for it to change, with the distribution perhaps getting a little uneven\n+                                    // as a result. It even allows for the hash function to return a random number.\n+                                    final byte[] k = subspace.pack(Tuple.from(level, key));\n+                                    final CompletableFuture<byte[]> cf = tr.get(k);\n+\n+                                    if (level == 0) {\n+                                        future = cf.thenApply(c -> {\n+                                            if (c != null) {\n+                                                tr.clear(k);\n+                                            }\n+                                            return null;\n+                                        });\n+                                    } else {\n+                                        final CompletableFuture<byte[]> prevKeyF = getPreviousKey(tr, level, key, false);\n+                                        future = CompletableFuture.allOf(cf, prevKeyF)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODY2NDY3MQ=="}, "originalCommit": {"oid": "eaca40e0c8b2079dc59730fa3dd94e7c4ddf4cad"}, "originalPosition": 222}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQxMTE1ODA3OnYy", "diffSide": "RIGHT", "path": "fdb-extensions/src/main/java/com/apple/foundationdb/async/RankedSet.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNlQyMToyMTowNFrOFzH1Jw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wOVQyMjoxNDoyN1rOFz7L7w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTE0OTk5MQ==", "bodyText": "With the exception of HashFunction, I think it is the case that none of these are really a good idea to change midstream on an existing ranked set. It's probably good to document that here. Ideally, it would be good to also enforce that with some validation, but I don't think there's a way of doing that without extra latency, which we may want to avoid.", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/837#discussion_r389149991", "createdAt": "2020-03-06T21:21:04Z", "author": {"login": "alecgrieser"}, "path": "fdb-extensions/src/main/java/com/apple/foundationdb/async/RankedSet.java", "diffHunk": "@@ -143,30 +144,153 @@ private static long decodeLong(byte[] v) {\n         int hash(byte[] key);\n     }\n \n+    /**\n+     * Configuration settings for a {@link RankedSet}.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d1b1b6f12150d9e94b768b4c08c62200d1d4a478"}, "originalPosition": 27}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTg4NjI5Mw==", "bodyText": "It is enforced at the index level, which has old and new meta-data that can be compared.", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/837#discussion_r389886293", "createdAt": "2020-03-09T18:39:07Z", "author": {"login": "MMcM"}, "path": "fdb-extensions/src/main/java/com/apple/foundationdb/async/RankedSet.java", "diffHunk": "@@ -143,30 +144,153 @@ private static long decodeLong(byte[] v) {\n         int hash(byte[] key);\n     }\n \n+    /**\n+     * Configuration settings for a {@link RankedSet}.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTE0OTk5MQ=="}, "originalCommit": {"oid": "d1b1b6f12150d9e94b768b4c08c62200d1d4a478"}, "originalPosition": 27}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTk5MTQwNw==", "bodyText": "Yeah, and that's probably as good as we're gonna get.", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/837#discussion_r389991407", "createdAt": "2020-03-09T22:14:27Z", "author": {"login": "alecgrieser"}, "path": "fdb-extensions/src/main/java/com/apple/foundationdb/async/RankedSet.java", "diffHunk": "@@ -143,30 +144,153 @@ private static long decodeLong(byte[] v) {\n         int hash(byte[] key);\n     }\n \n+    /**\n+     * Configuration settings for a {@link RankedSet}.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTE0OTk5MQ=="}, "originalCommit": {"oid": "d1b1b6f12150d9e94b768b4c08c62200d1d4a478"}, "originalPosition": 27}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQxMTIwMjIxOnYy", "diffSide": "RIGHT", "path": "fdb-extensions/src/test/java/com/apple/foundationdb/async/RankedSetTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNlQyMTozODoyNlrOFzIQNQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMFQwMjozOTo0OFrOFz_qTQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTE1NjkxNw==", "bodyText": "Though I'm not sure how I feel about the randomSingleThread and randomFiveThreads tests in general (or as unit tests), it might be good to see if running them with duplicates counted and see if they find anything.\nAlso, as much time as they take, I could see there being possibly weird edge cases when building a ranked set with duplicates turned on (particularly with regard to parallelism).", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/837#discussion_r389156917", "createdAt": "2020-03-06T21:38:26Z", "author": {"login": "alecgrieser"}, "path": "fdb-extensions/src/test/java/com/apple/foundationdb/async/RankedSetTest.java", "diffHunk": "@@ -118,6 +119,49 @@ private void basicOperations(RankedSet.HashFunction firstHashFunction, RankedSet\n                 boolean wasOld = rs.remove(tr, k).join();\n                 assertTrue(wasOld);\n             }\n+            assertFalse(rs.remove(tr, keys[20]).join());\n+            return null;\n+        });\n+    }\n+\n+    @Test\n+    public void duplicates() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d1b1b6f12150d9e94b768b4c08c62200d1d4a478"}, "originalPosition": 45}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDA2NDcxNw==", "bodyText": "I  don't much care for those tests, either. But I added one with duplicates.\nNote that the test already has knowledge of some invariants which are changed in the duplicates case, so some of the checks need to be conditional on the config.", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/837#discussion_r390064717", "createdAt": "2020-03-10T02:39:48Z", "author": {"login": "MMcM"}, "path": "fdb-extensions/src/test/java/com/apple/foundationdb/async/RankedSetTest.java", "diffHunk": "@@ -118,6 +119,49 @@ private void basicOperations(RankedSet.HashFunction firstHashFunction, RankedSet\n                 boolean wasOld = rs.remove(tr, k).join();\n                 assertTrue(wasOld);\n             }\n+            assertFalse(rs.remove(tr, keys[20]).join());\n+            return null;\n+        });\n+    }\n+\n+    @Test\n+    public void duplicates() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTE1NjkxNw=="}, "originalCommit": {"oid": "d1b1b6f12150d9e94b768b4c08c62200d1d4a478"}, "originalPosition": 45}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQxMTIxNDAxOnYy", "diffSide": "RIGHT", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/provider/foundationdb/indexes/RankIndexMaintainerFactory.java", "isResolved": true, "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNlQyMTo0Mjo1M1rOFzIXWw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wOVQyMzo0NDozNVrOFz8-pg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTE1ODc0Nw==", "bodyText": "Should this allow going from not setting RANK_COUNT_DUPLICATES to setting it to false, or is that already allowed somehow?\nI also suppose that the TimeWindowLeaderboardMaintainerFactory could benefit from similar logic here (but I guess not for n-levels). I suppose it also isn't super necessary, though, as the default is to reject any option changes, which is conservative.", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/837#discussion_r389158747", "createdAt": "2020-03-06T21:42:53Z", "author": {"login": "alecgrieser"}, "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/provider/foundationdb/indexes/RankIndexMaintainerFactory.java", "diffHunk": "@@ -65,24 +65,24 @@ public void validate(@Nonnull MetaDataValidator metaDataValidator) {\n \n             @Override\n             public void validateChangedOptions(@Nonnull Index oldIndex, @Nonnull Set<String> changedOptions) {\n-                // Allow changing from unspecified to the default (or vice versa), but not otherwise.\n-                if (changedOptions.contains(IndexOptions.RANK_NLEVELS)) {\n-                    int oldLevels = RankedSetIndexHelper.getNLevels(oldIndex);\n-                    int newLevels = RankedSetIndexHelper.getNLevels(index);\n-                    if (oldLevels != newLevels) {\n-                        throw new MetaDataException(\"rank levels changed\",\n-                                LogMessageKeys.INDEX_NAME, index.getName());\n+                if (!changedOptions.isEmpty()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d1b1b6f12150d9e94b768b4c08c62200d1d4a478"}, "originalPosition": 11}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTg4NjcwMg==", "bodyText": "I disallowed changing duplicates, in keeping with the conservative nature of the existing checks.", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/837#discussion_r389886702", "createdAt": "2020-03-09T18:39:51Z", "author": {"login": "MMcM"}, "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/provider/foundationdb/indexes/RankIndexMaintainerFactory.java", "diffHunk": "@@ -65,24 +65,24 @@ public void validate(@Nonnull MetaDataValidator metaDataValidator) {\n \n             @Override\n             public void validateChangedOptions(@Nonnull Index oldIndex, @Nonnull Set<String> changedOptions) {\n-                // Allow changing from unspecified to the default (or vice versa), but not otherwise.\n-                if (changedOptions.contains(IndexOptions.RANK_NLEVELS)) {\n-                    int oldLevels = RankedSetIndexHelper.getNLevels(oldIndex);\n-                    int newLevels = RankedSetIndexHelper.getNLevels(index);\n-                    if (oldLevels != newLevels) {\n-                        throw new MetaDataException(\"rank levels changed\",\n-                                LogMessageKeys.INDEX_NAME, index.getName());\n+                if (!changedOptions.isEmpty()) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTE1ODc0Nw=="}, "originalCommit": {"oid": "d1b1b6f12150d9e94b768b4c08c62200d1d4a478"}, "originalPosition": 11}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTk5MjE1Nw==", "bodyText": "That sounds right. I'd be tempted to say that even the most liberal of changes shouldn't allow that particular option to change ever (because the data won't be correct if you switch, even if it's understandable).", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/837#discussion_r389992157", "createdAt": "2020-03-09T22:16:39Z", "author": {"login": "alecgrieser"}, "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/provider/foundationdb/indexes/RankIndexMaintainerFactory.java", "diffHunk": "@@ -65,24 +65,24 @@ public void validate(@Nonnull MetaDataValidator metaDataValidator) {\n \n             @Override\n             public void validateChangedOptions(@Nonnull Index oldIndex, @Nonnull Set<String> changedOptions) {\n-                // Allow changing from unspecified to the default (or vice versa), but not otherwise.\n-                if (changedOptions.contains(IndexOptions.RANK_NLEVELS)) {\n-                    int oldLevels = RankedSetIndexHelper.getNLevels(oldIndex);\n-                    int newLevels = RankedSetIndexHelper.getNLevels(index);\n-                    if (oldLevels != newLevels) {\n-                        throw new MetaDataException(\"rank levels changed\",\n-                                LogMessageKeys.INDEX_NAME, index.getName());\n+                if (!changedOptions.isEmpty()) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTE1ODc0Nw=="}, "originalCommit": {"oid": "d1b1b6f12150d9e94b768b4c08c62200d1d4a478"}, "originalPosition": 11}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDAwOTIxMA==", "bodyText": "Hmm. There are, I think, two points of view:\n\nThe option defines a fundamental characteristic of the skip list, viz., whether the finest level has counts greater than one.\nThe option refines the behavior of the add method to either maintain counts or return false for things already present.\n\nWhich of those makes more sense also probably informs whether remove always removes one occurrence or is similarly influenced by the config option.", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/837#discussion_r390009210", "createdAt": "2020-03-09T23:06:40Z", "author": {"login": "MMcM"}, "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/provider/foundationdb/indexes/RankIndexMaintainerFactory.java", "diffHunk": "@@ -65,24 +65,24 @@ public void validate(@Nonnull MetaDataValidator metaDataValidator) {\n \n             @Override\n             public void validateChangedOptions(@Nonnull Index oldIndex, @Nonnull Set<String> changedOptions) {\n-                // Allow changing from unspecified to the default (or vice versa), but not otherwise.\n-                if (changedOptions.contains(IndexOptions.RANK_NLEVELS)) {\n-                    int oldLevels = RankedSetIndexHelper.getNLevels(oldIndex);\n-                    int newLevels = RankedSetIndexHelper.getNLevels(index);\n-                    if (oldLevels != newLevels) {\n-                        throw new MetaDataException(\"rank levels changed\",\n-                                LogMessageKeys.INDEX_NAME, index.getName());\n+                if (!changedOptions.isEmpty()) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTE1ODc0Nw=="}, "originalCommit": {"oid": "d1b1b6f12150d9e94b768b4c08c62200d1d4a478"}, "originalPosition": 11}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDAxODQ5Nw==", "bodyText": "Interesting. I had kind of been coming from the first point of view. It kind of seems like the second point of view makes sense from the point of view of the skip list itself, though it's harder to see how that is a sensible \"index\" over data. (In that with duplicate tracking off, it is just a data structure for optimizing \"rank without counting duplicates\" queries; with duplicate tracking on, it is a data structure for optimizing \"rank with duplicates counted\" queries; but with it changed half-way through, then I don't know if it answers any reasonable queries other than \"what is the state of skip list\".)", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/837#discussion_r390018497", "createdAt": "2020-03-09T23:36:46Z", "author": {"login": "alecgrieser"}, "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/provider/foundationdb/indexes/RankIndexMaintainerFactory.java", "diffHunk": "@@ -65,24 +65,24 @@ public void validate(@Nonnull MetaDataValidator metaDataValidator) {\n \n             @Override\n             public void validateChangedOptions(@Nonnull Index oldIndex, @Nonnull Set<String> changedOptions) {\n-                // Allow changing from unspecified to the default (or vice versa), but not otherwise.\n-                if (changedOptions.contains(IndexOptions.RANK_NLEVELS)) {\n-                    int oldLevels = RankedSetIndexHelper.getNLevels(oldIndex);\n-                    int newLevels = RankedSetIndexHelper.getNLevels(index);\n-                    if (oldLevels != newLevels) {\n-                        throw new MetaDataException(\"rank levels changed\",\n-                                LogMessageKeys.INDEX_NAME, index.getName());\n+                if (!changedOptions.isEmpty()) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTE1ODc0Nw=="}, "originalCommit": {"oid": "d1b1b6f12150d9e94b768b4c08c62200d1d4a478"}, "originalPosition": 11}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDAyMDc3NA==", "bodyText": "Yes, agreed. I don't have a great (not implementation based) idea of why a user of the index would want to change the answers to the rank / select operations it optimizes.", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/837#discussion_r390020774", "createdAt": "2020-03-09T23:44:35Z", "author": {"login": "MMcM"}, "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/provider/foundationdb/indexes/RankIndexMaintainerFactory.java", "diffHunk": "@@ -65,24 +65,24 @@ public void validate(@Nonnull MetaDataValidator metaDataValidator) {\n \n             @Override\n             public void validateChangedOptions(@Nonnull Index oldIndex, @Nonnull Set<String> changedOptions) {\n-                // Allow changing from unspecified to the default (or vice versa), but not otherwise.\n-                if (changedOptions.contains(IndexOptions.RANK_NLEVELS)) {\n-                    int oldLevels = RankedSetIndexHelper.getNLevels(oldIndex);\n-                    int newLevels = RankedSetIndexHelper.getNLevels(index);\n-                    if (oldLevels != newLevels) {\n-                        throw new MetaDataException(\"rank levels changed\",\n-                                LogMessageKeys.INDEX_NAME, index.getName());\n+                if (!changedOptions.isEmpty()) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTE1ODc0Nw=="}, "originalCommit": {"oid": "d1b1b6f12150d9e94b768b4c08c62200d1d4a478"}, "originalPosition": 11}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQxMTIzNjA1OnYy", "diffSide": "RIGHT", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/provider/foundationdb/leaderboard/TimeWindowLeaderboardIndexMaintainer.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNlQyMTo1Mjo1OFrOFzIlaA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wOVQxODo0MDowOVrOFz0ziw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTE2MjM0NA==", "bodyText": "I'm not sure if we care, but this isn't thread safe (in that two threads can modify and set the number of levels to different values). I think the alternative would be to either copy the builder before setting the levels or create a new one from the index and the leaderboard (for the levels) from scratch each time. (I think there are other things about using ranked sets that are also unsafe, but I think this one is also easy to fix, unlike the others, so might be worth doing.)", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/837#discussion_r389162344", "createdAt": "2020-03-06T21:52:58Z", "author": {"login": "alecgrieser"}, "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/provider/foundationdb/leaderboard/TimeWindowLeaderboardIndexMaintainer.java", "diffHunk": "@@ -197,8 +197,9 @@ protected void saveSubDirectory(@Nonnull TimeWindowLeaderboardSubDirectory subdi\n                 }\n                 final Subspace extraSubspace = getSecondarySubspace();\n                 final Subspace leaderboardSubspace = extraSubspace.subspace(leaderboard.getSubspaceKey());\n+                final RankedSet.Config config = configBuilder.setNLevels(leaderboard.getNLevels()).build();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d1b1b6f12150d9e94b768b4c08c62200d1d4a478"}, "originalPosition": 18}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTg4Njg1OQ==", "bodyText": "I switched from a shared builder to toBuilder.", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/837#discussion_r389886859", "createdAt": "2020-03-09T18:40:09Z", "author": {"login": "MMcM"}, "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/provider/foundationdb/leaderboard/TimeWindowLeaderboardIndexMaintainer.java", "diffHunk": "@@ -197,8 +197,9 @@ protected void saveSubDirectory(@Nonnull TimeWindowLeaderboardSubDirectory subdi\n                 }\n                 final Subspace extraSubspace = getSecondarySubspace();\n                 final Subspace leaderboardSubspace = extraSubspace.subspace(leaderboard.getSubspaceKey());\n+                final RankedSet.Config config = configBuilder.setNLevels(leaderboard.getNLevels()).build();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTE2MjM0NA=="}, "originalCommit": {"oid": "d1b1b6f12150d9e94b768b4c08c62200d1d4a478"}, "originalPosition": 18}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQxMTMwNDg0OnYy", "diffSide": "RIGHT", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/provider/foundationdb/indexes/RankedSetIndexHelper.java", "isResolved": false, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNlQyMjoyMzozM1rOFzJPag==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMlQyMDozNzowMlrOF1ufSw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTE3MzA5OA==", "bodyText": "I, um, am not sure this comment is true, or at least doesn't seem right given one of the comments I made in the remove function for RankedSet. On the other hand, we do test write only indexes as part of index builds, so I'm not entirely sure. (Understanding that this is a pre-existing comment that I probably wrote.)", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/837#discussion_r389173098", "createdAt": "2020-03-06T22:23:33Z", "author": {"login": "alecgrieser"}, "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/provider/foundationdb/indexes/RankedSetIndexHelper.java", "diffHunk": "@@ -233,38 +244,41 @@ private static Number extractRank(int groupPrefixSize, @Nullable Tuple maybeRank\n     @Nonnull\n     public static CompletableFuture<Void> updateRankedSet(@Nonnull IndexMaintainerState state,\n                                                           @Nonnull Subspace rankSubspace,\n-                                                          @Nonnull RankedSet.HashFunction hashFunction,\n-                                                          int nlevels,\n+                                                          @Nonnull RankedSet.Config config,\n                                                           @Nonnull Tuple valueKey,\n                                                           @Nonnull Tuple scoreKey,\n                                                           boolean remove) {\n-        final RankedSet rankedSet = new InstrumentedRankedSet(state, rankSubspace, hashFunction, nlevels);\n+        final RankedSet rankedSet = new InstrumentedRankedSet(state, rankSubspace, config);\n         final byte[] score = scoreKey.pack();\n         CompletableFuture<Void> result = init(state, rankedSet).thenCompose(v -> {\n             if (remove) {\n-                // If no one else has this score, remove from ranked set.\n-                return state.transaction.getRange(state.indexSubspace.range(valueKey)).iterator().onHasNext().thenCompose(hasNext -> {\n-                    if (hasNext) {\n-                        return AsyncUtil.DONE;\n-                    } else {\n-                        return rankedSet.remove(state.transaction, score).thenApply(exists -> {\n-                            // It is okay if the score isn't in the ranked set yet if the index is\n-                            // write only because this means that the score just hasn't yet\n-                            // been added by some record. We still want the conflict ranges, though.\n-                            if (!exists && !state.store.isIndexWriteOnly(state.index)) {\n-                                throw new RecordCoreException(\"Score was not present in ranked set.\");\n-                            }\n-                            return null;\n-                        });\n-                    }\n-                });\n+                if (config.isCountDuplicates()) {\n+                    // Decrement count and possibly remove.\n+                    return removeFromRankedSet(state, rankedSet, score);\n+                } else {\n+                    // If no one else has this score, remove from ranked set.\n+                    return state.transaction.getRange(state.indexSubspace.range(valueKey)).iterator().onHasNext()\n+                            .thenCompose(hasNext -> hasNext ? AsyncUtil.DONE : removeFromRankedSet(state, rankedSet, score));\n+                }\n             } else {\n                 return rankedSet.add(state.transaction, score).thenApply(added -> null);\n             }\n         });\n         return state.store.instrument(Events.RANKED_SET_UPDATE, result);\n     }\n \n+    private static CompletableFuture<Void> removeFromRankedSet(@Nonnull IndexMaintainerState state, @Nonnull RankedSet rankedSet, @Nonnull byte[] score) {\n+        return rankedSet.remove(state.transaction, score).thenApply(exists -> {\n+            // It is okay if the score isn't in the ranked set yet if the index is\n+            // write only because this means that the score just hasn't yet\n+            // been added by some record. We still want the conflict ranges, though.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d1b1b6f12150d9e94b768b4c08c62200d1d4a478"}, "originalPosition": 103}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDA0ODUyOA==", "bodyText": "I somehow missed the part of the code in RankedSet that checks to make sure that the score isn't zero before decrementing. I am now more confident in this comment in at least the case of not duplicate tracking (so that's good).\nI'm trying to think, however, if there are pathologies in the count duplicates case. I think the answer is \"yes\" because adding to a ranked set index with duplicate counting isn't idempotent. In particular:\n\nImagine having two records with a rank index on field foo, both of which have the value foo = bar.\nAn index build indexes the first record. Now the count corresponding to bar in the foo rank index is 1.\nSomeone removes the second record. Now the count corresponding to bar in the foo rank index is 0 (i.e., it is removed from the ranked set).\nThe index build completes, never having indexed the second record.\n\nSo now bar has an incorrect rank. This is somewhat of a worst case in that bar is missing entirely from the ranked set, but I think one can also be in a position where the rank is wrong, but not removed entirely.\nI think this can be fixed by checking if the record is in the built range and only updating the ranked set if it is. It also seems to me like this would be safe for the regular ranked set, though perhaps would induce more conflicts.", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/837#discussion_r390048528", "createdAt": "2020-03-10T01:33:41Z", "author": {"login": "alecgrieser"}, "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/provider/foundationdb/indexes/RankedSetIndexHelper.java", "diffHunk": "@@ -233,38 +244,41 @@ private static Number extractRank(int groupPrefixSize, @Nullable Tuple maybeRank\n     @Nonnull\n     public static CompletableFuture<Void> updateRankedSet(@Nonnull IndexMaintainerState state,\n                                                           @Nonnull Subspace rankSubspace,\n-                                                          @Nonnull RankedSet.HashFunction hashFunction,\n-                                                          int nlevels,\n+                                                          @Nonnull RankedSet.Config config,\n                                                           @Nonnull Tuple valueKey,\n                                                           @Nonnull Tuple scoreKey,\n                                                           boolean remove) {\n-        final RankedSet rankedSet = new InstrumentedRankedSet(state, rankSubspace, hashFunction, nlevels);\n+        final RankedSet rankedSet = new InstrumentedRankedSet(state, rankSubspace, config);\n         final byte[] score = scoreKey.pack();\n         CompletableFuture<Void> result = init(state, rankedSet).thenCompose(v -> {\n             if (remove) {\n-                // If no one else has this score, remove from ranked set.\n-                return state.transaction.getRange(state.indexSubspace.range(valueKey)).iterator().onHasNext().thenCompose(hasNext -> {\n-                    if (hasNext) {\n-                        return AsyncUtil.DONE;\n-                    } else {\n-                        return rankedSet.remove(state.transaction, score).thenApply(exists -> {\n-                            // It is okay if the score isn't in the ranked set yet if the index is\n-                            // write only because this means that the score just hasn't yet\n-                            // been added by some record. We still want the conflict ranges, though.\n-                            if (!exists && !state.store.isIndexWriteOnly(state.index)) {\n-                                throw new RecordCoreException(\"Score was not present in ranked set.\");\n-                            }\n-                            return null;\n-                        });\n-                    }\n-                });\n+                if (config.isCountDuplicates()) {\n+                    // Decrement count and possibly remove.\n+                    return removeFromRankedSet(state, rankedSet, score);\n+                } else {\n+                    // If no one else has this score, remove from ranked set.\n+                    return state.transaction.getRange(state.indexSubspace.range(valueKey)).iterator().onHasNext()\n+                            .thenCompose(hasNext -> hasNext ? AsyncUtil.DONE : removeFromRankedSet(state, rankedSet, score));\n+                }\n             } else {\n                 return rankedSet.add(state.transaction, score).thenApply(added -> null);\n             }\n         });\n         return state.store.instrument(Events.RANKED_SET_UPDATE, result);\n     }\n \n+    private static CompletableFuture<Void> removeFromRankedSet(@Nonnull IndexMaintainerState state, @Nonnull RankedSet rankedSet, @Nonnull byte[] score) {\n+        return rankedSet.remove(state.transaction, score).thenApply(exists -> {\n+            // It is okay if the score isn't in the ranked set yet if the index is\n+            // write only because this means that the score just hasn't yet\n+            // been added by some record. We still want the conflict ranges, though.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTE3MzA5OA=="}, "originalCommit": {"oid": "d1b1b6f12150d9e94b768b4c08c62200d1d4a478"}, "originalPosition": 103}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDA1NjA4Nw==", "bodyText": "That would be accomplished by having isIdempotent check the option, correct? There is no need for a new instance of such built range checking code.", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/837#discussion_r390056087", "createdAt": "2020-03-10T02:03:34Z", "author": {"login": "MMcM"}, "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/provider/foundationdb/indexes/RankedSetIndexHelper.java", "diffHunk": "@@ -233,38 +244,41 @@ private static Number extractRank(int groupPrefixSize, @Nullable Tuple maybeRank\n     @Nonnull\n     public static CompletableFuture<Void> updateRankedSet(@Nonnull IndexMaintainerState state,\n                                                           @Nonnull Subspace rankSubspace,\n-                                                          @Nonnull RankedSet.HashFunction hashFunction,\n-                                                          int nlevels,\n+                                                          @Nonnull RankedSet.Config config,\n                                                           @Nonnull Tuple valueKey,\n                                                           @Nonnull Tuple scoreKey,\n                                                           boolean remove) {\n-        final RankedSet rankedSet = new InstrumentedRankedSet(state, rankSubspace, hashFunction, nlevels);\n+        final RankedSet rankedSet = new InstrumentedRankedSet(state, rankSubspace, config);\n         final byte[] score = scoreKey.pack();\n         CompletableFuture<Void> result = init(state, rankedSet).thenCompose(v -> {\n             if (remove) {\n-                // If no one else has this score, remove from ranked set.\n-                return state.transaction.getRange(state.indexSubspace.range(valueKey)).iterator().onHasNext().thenCompose(hasNext -> {\n-                    if (hasNext) {\n-                        return AsyncUtil.DONE;\n-                    } else {\n-                        return rankedSet.remove(state.transaction, score).thenApply(exists -> {\n-                            // It is okay if the score isn't in the ranked set yet if the index is\n-                            // write only because this means that the score just hasn't yet\n-                            // been added by some record. We still want the conflict ranges, though.\n-                            if (!exists && !state.store.isIndexWriteOnly(state.index)) {\n-                                throw new RecordCoreException(\"Score was not present in ranked set.\");\n-                            }\n-                            return null;\n-                        });\n-                    }\n-                });\n+                if (config.isCountDuplicates()) {\n+                    // Decrement count and possibly remove.\n+                    return removeFromRankedSet(state, rankedSet, score);\n+                } else {\n+                    // If no one else has this score, remove from ranked set.\n+                    return state.transaction.getRange(state.indexSubspace.range(valueKey)).iterator().onHasNext()\n+                            .thenCompose(hasNext -> hasNext ? AsyncUtil.DONE : removeFromRankedSet(state, rankedSet, score));\n+                }\n             } else {\n                 return rankedSet.add(state.transaction, score).thenApply(added -> null);\n             }\n         });\n         return state.store.instrument(Events.RANKED_SET_UPDATE, result);\n     }\n \n+    private static CompletableFuture<Void> removeFromRankedSet(@Nonnull IndexMaintainerState state, @Nonnull RankedSet rankedSet, @Nonnull byte[] score) {\n+        return rankedSet.remove(state.transaction, score).thenApply(exists -> {\n+            // It is okay if the score isn't in the ranked set yet if the index is\n+            // write only because this means that the score just hasn't yet\n+            // been added by some record. We still want the conflict ranges, though.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTE3MzA5OA=="}, "originalCommit": {"oid": "d1b1b6f12150d9e94b768b4c08c62200d1d4a478"}, "originalPosition": 103}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTg4MDUyMw==", "bodyText": "Yeah, I believe so--that no new mechanism is necessary because what I sketched out is already done by isIdempotent.", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/837#discussion_r391880523", "createdAt": "2020-03-12T20:37:02Z", "author": {"login": "alecgrieser"}, "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/provider/foundationdb/indexes/RankedSetIndexHelper.java", "diffHunk": "@@ -233,38 +244,41 @@ private static Number extractRank(int groupPrefixSize, @Nullable Tuple maybeRank\n     @Nonnull\n     public static CompletableFuture<Void> updateRankedSet(@Nonnull IndexMaintainerState state,\n                                                           @Nonnull Subspace rankSubspace,\n-                                                          @Nonnull RankedSet.HashFunction hashFunction,\n-                                                          int nlevels,\n+                                                          @Nonnull RankedSet.Config config,\n                                                           @Nonnull Tuple valueKey,\n                                                           @Nonnull Tuple scoreKey,\n                                                           boolean remove) {\n-        final RankedSet rankedSet = new InstrumentedRankedSet(state, rankSubspace, hashFunction, nlevels);\n+        final RankedSet rankedSet = new InstrumentedRankedSet(state, rankSubspace, config);\n         final byte[] score = scoreKey.pack();\n         CompletableFuture<Void> result = init(state, rankedSet).thenCompose(v -> {\n             if (remove) {\n-                // If no one else has this score, remove from ranked set.\n-                return state.transaction.getRange(state.indexSubspace.range(valueKey)).iterator().onHasNext().thenCompose(hasNext -> {\n-                    if (hasNext) {\n-                        return AsyncUtil.DONE;\n-                    } else {\n-                        return rankedSet.remove(state.transaction, score).thenApply(exists -> {\n-                            // It is okay if the score isn't in the ranked set yet if the index is\n-                            // write only because this means that the score just hasn't yet\n-                            // been added by some record. We still want the conflict ranges, though.\n-                            if (!exists && !state.store.isIndexWriteOnly(state.index)) {\n-                                throw new RecordCoreException(\"Score was not present in ranked set.\");\n-                            }\n-                            return null;\n-                        });\n-                    }\n-                });\n+                if (config.isCountDuplicates()) {\n+                    // Decrement count and possibly remove.\n+                    return removeFromRankedSet(state, rankedSet, score);\n+                } else {\n+                    // If no one else has this score, remove from ranked set.\n+                    return state.transaction.getRange(state.indexSubspace.range(valueKey)).iterator().onHasNext()\n+                            .thenCompose(hasNext -> hasNext ? AsyncUtil.DONE : removeFromRankedSet(state, rankedSet, score));\n+                }\n             } else {\n                 return rankedSet.add(state.transaction, score).thenApply(added -> null);\n             }\n         });\n         return state.store.instrument(Events.RANKED_SET_UPDATE, result);\n     }\n \n+    private static CompletableFuture<Void> removeFromRankedSet(@Nonnull IndexMaintainerState state, @Nonnull RankedSet rankedSet, @Nonnull byte[] score) {\n+        return rankedSet.remove(state.transaction, score).thenApply(exists -> {\n+            // It is okay if the score isn't in the ranked set yet if the index is\n+            // write only because this means that the score just hasn't yet\n+            // been added by some record. We still want the conflict ranges, though.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTE3MzA5OA=="}, "originalCommit": {"oid": "d1b1b6f12150d9e94b768b4c08c62200d1d4a478"}, "originalPosition": 103}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQxNzExNDIxOnYy", "diffSide": "RIGHT", "path": "fdb-extensions/src/main/java/com/apple/foundationdb/async/RankedSet.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMFQwMToxNDowM1rOFz-ZZA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMFQwMjowMzo1MlrOFz_I4g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDA0NDAwNA==", "bodyText": "It seems weird (though perhaps) harmless that this re-reads the key for level zero rather than, say, just clearing the key. For one, it almost gives the impression that the key could be null at this point...which seems wrong.", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/837#discussion_r390044004", "createdAt": "2020-03-10T01:14:03Z", "author": {"login": "alecgrieser"}, "path": "fdb-extensions/src/main/java/com/apple/foundationdb/async/RankedSet.java", "diffHunk": "@@ -220,32 +391,110 @@ public RankedSet(Subspace subspace, Executor executor) {\n                 }));\n     }\n \n-    protected CompletableFuture<Void> addLevelZeroKey(Transaction tr, byte[] key, int level) {\n-        tr.set(subspace.pack(Tuple.from(level, key)), encodeLong(1));\n+    protected CompletableFuture<Void> addLevelZeroKey(Transaction tr, byte[] key, int level, boolean increment) {\n+        final byte[] k = subspace.pack(Tuple.from(level, key));\n+        final byte[] v = encodeLong(1);\n+        if (increment) {\n+            tr.mutate(MutationType.ADD, k, v);\n+        } else {\n+            tr.set(k, v);\n+        }\n         return DONE;\n     }\n \n-    protected CompletableFuture<Void> addIncrementLevelKey(Transaction tr, byte[] key, int level) {\n-        return getPreviousKey(tr, level, key).thenApply(prevKey -> {\n+    protected CompletableFuture<Void> addIncrementLevelKey(Transaction tr, byte[] key, int level, boolean orEqual) {\n+        return getPreviousKey(tr, level, key, orEqual).thenApply(prevKey -> {\n             tr.mutate(MutationType.ADD, subspace.pack(Tuple.from(level, prevKey)), encodeLong(1));\n             return null;\n         });\n     }\n \n     protected CompletableFuture<Void> addInsertLevelKey(Transaction tr, byte[] key, int level) {\n-        return getPreviousKey(tr, level, key).thenCompose(prevKey -> {\n+        return getPreviousKey(tr, level, key, false).thenCompose(prevKey -> {\n             CompletableFuture<Long> prevCount = tr.get(subspace.pack(Tuple.from(level, prevKey))).thenApply(RankedSet::decodeLong);\n             CompletableFuture<Long> newPrevCount = countRange(tr, level - 1, prevKey, key);\n-            return CompletableFuture.allOf(prevCount, newPrevCount)\n-                    .thenApply(vignore2 -> {\n-                        long count = prevCount.join() - newPrevCount.join() + 1;\n-                        tr.set(subspace.pack(Tuple.from(level, prevKey)), encodeLong(newPrevCount.join()));\n-                        tr.set(subspace.pack(Tuple.from(level, key)), encodeLong(count));\n-                        return null;\n-                    });\n+            return prevCount.thenAcceptBoth(newPrevCount, (prev, newPrev) -> {\n+                long count = prev - newPrev + 1;\n+                tr.set(subspace.pack(Tuple.from(level, prevKey)), encodeLong(newPrev));\n+                tr.set(subspace.pack(Tuple.from(level, key)), encodeLong(count));\n+            });\n         });\n     }\n \n+    /**\n+     * Removes a key from the set.\n+     * @param tc the transaction to use to access the database\n+     * @param key the key to remove\n+     * @return a future that completes to {@code true} if the set was modified, that is, if the key was present before this operation\n+     */\n+    public CompletableFuture<Boolean> remove(TransactionContext tc, byte[] key) {\n+        checkKey(key);\n+        return tc.runAsync(tr ->\n+                countCheckedKey(tr, key)\n+                        .thenCompose(count -> {\n+                            if (count == null || count <= 0) {\n+                                return READY_FALSE;\n+                            }\n+                            // This works even if the current set does not track duplicates but duplicates were added\n+                            // earlier by one that did.\n+                            final boolean duplicate = count > 1;\n+                            final int nlevels = config.getNLevels();\n+                            final List<CompletableFuture<Void>> futures = new ArrayList<>(nlevels);\n+                            for (int li = 0; li < nlevels; ++li) {\n+                                final int level = li;\n+\n+                                final CompletableFuture<Void> future;\n+\n+                                if (duplicate) {\n+                                    // Always subtract one, never clearing a level count key.\n+                                    // Concurrent requests both subtracting one when the count is two will conflict\n+                                    // on the level zero key, which was read to detect that this is a duplicate.\n+                                    // So it should not be possible for a count to go to zero.\n+                                    Function<byte[], Void> decrement = k -> {\n+                                        tr.mutate(MutationType.ADD, subspace.pack(Tuple.from(level, k)), encodeLong(-1));\n+                                        return null;\n+                                    };\n+                                    if (level == 0) {\n+                                        decrement.apply(key);\n+                                        future = DONE;\n+                                    } else {\n+                                        future = getPreviousKey(tr, level, key, true).thenApply(decrement);\n+                                    }\n+                                } else {\n+                                    // This could be optimized to check the hash for which levels should have this key.\n+                                    // That would require that the hash function never changes, though.\n+                                    // This allows for it to change, with the distribution perhaps getting a little uneven\n+                                    // as a result. It even allows for the hash function to return a random number.\n+                                    // It also further guarantees that counts never go to zero.\n+                                    final byte[] k = subspace.pack(Tuple.from(level, key));\n+                                    final CompletableFuture<byte[]> cf = tr.get(k);\n+\n+                                    if (level == 0) {\n+                                        future = cf.thenApply(c -> {\n+                                            if (c != null) {\n+                                                tr.clear(k);\n+                                            }\n+                                            return null;\n+                                        });", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d15c7b81796741126f4bda96716ba744fa95f2ec"}, "originalPosition": 401}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDA1NjE2Mg==", "bodyText": "Yes, it is simpler to just clear unconditionally.", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/837#discussion_r390056162", "createdAt": "2020-03-10T02:03:52Z", "author": {"login": "MMcM"}, "path": "fdb-extensions/src/main/java/com/apple/foundationdb/async/RankedSet.java", "diffHunk": "@@ -220,32 +391,110 @@ public RankedSet(Subspace subspace, Executor executor) {\n                 }));\n     }\n \n-    protected CompletableFuture<Void> addLevelZeroKey(Transaction tr, byte[] key, int level) {\n-        tr.set(subspace.pack(Tuple.from(level, key)), encodeLong(1));\n+    protected CompletableFuture<Void> addLevelZeroKey(Transaction tr, byte[] key, int level, boolean increment) {\n+        final byte[] k = subspace.pack(Tuple.from(level, key));\n+        final byte[] v = encodeLong(1);\n+        if (increment) {\n+            tr.mutate(MutationType.ADD, k, v);\n+        } else {\n+            tr.set(k, v);\n+        }\n         return DONE;\n     }\n \n-    protected CompletableFuture<Void> addIncrementLevelKey(Transaction tr, byte[] key, int level) {\n-        return getPreviousKey(tr, level, key).thenApply(prevKey -> {\n+    protected CompletableFuture<Void> addIncrementLevelKey(Transaction tr, byte[] key, int level, boolean orEqual) {\n+        return getPreviousKey(tr, level, key, orEqual).thenApply(prevKey -> {\n             tr.mutate(MutationType.ADD, subspace.pack(Tuple.from(level, prevKey)), encodeLong(1));\n             return null;\n         });\n     }\n \n     protected CompletableFuture<Void> addInsertLevelKey(Transaction tr, byte[] key, int level) {\n-        return getPreviousKey(tr, level, key).thenCompose(prevKey -> {\n+        return getPreviousKey(tr, level, key, false).thenCompose(prevKey -> {\n             CompletableFuture<Long> prevCount = tr.get(subspace.pack(Tuple.from(level, prevKey))).thenApply(RankedSet::decodeLong);\n             CompletableFuture<Long> newPrevCount = countRange(tr, level - 1, prevKey, key);\n-            return CompletableFuture.allOf(prevCount, newPrevCount)\n-                    .thenApply(vignore2 -> {\n-                        long count = prevCount.join() - newPrevCount.join() + 1;\n-                        tr.set(subspace.pack(Tuple.from(level, prevKey)), encodeLong(newPrevCount.join()));\n-                        tr.set(subspace.pack(Tuple.from(level, key)), encodeLong(count));\n-                        return null;\n-                    });\n+            return prevCount.thenAcceptBoth(newPrevCount, (prev, newPrev) -> {\n+                long count = prev - newPrev + 1;\n+                tr.set(subspace.pack(Tuple.from(level, prevKey)), encodeLong(newPrev));\n+                tr.set(subspace.pack(Tuple.from(level, key)), encodeLong(count));\n+            });\n         });\n     }\n \n+    /**\n+     * Removes a key from the set.\n+     * @param tc the transaction to use to access the database\n+     * @param key the key to remove\n+     * @return a future that completes to {@code true} if the set was modified, that is, if the key was present before this operation\n+     */\n+    public CompletableFuture<Boolean> remove(TransactionContext tc, byte[] key) {\n+        checkKey(key);\n+        return tc.runAsync(tr ->\n+                countCheckedKey(tr, key)\n+                        .thenCompose(count -> {\n+                            if (count == null || count <= 0) {\n+                                return READY_FALSE;\n+                            }\n+                            // This works even if the current set does not track duplicates but duplicates were added\n+                            // earlier by one that did.\n+                            final boolean duplicate = count > 1;\n+                            final int nlevels = config.getNLevels();\n+                            final List<CompletableFuture<Void>> futures = new ArrayList<>(nlevels);\n+                            for (int li = 0; li < nlevels; ++li) {\n+                                final int level = li;\n+\n+                                final CompletableFuture<Void> future;\n+\n+                                if (duplicate) {\n+                                    // Always subtract one, never clearing a level count key.\n+                                    // Concurrent requests both subtracting one when the count is two will conflict\n+                                    // on the level zero key, which was read to detect that this is a duplicate.\n+                                    // So it should not be possible for a count to go to zero.\n+                                    Function<byte[], Void> decrement = k -> {\n+                                        tr.mutate(MutationType.ADD, subspace.pack(Tuple.from(level, k)), encodeLong(-1));\n+                                        return null;\n+                                    };\n+                                    if (level == 0) {\n+                                        decrement.apply(key);\n+                                        future = DONE;\n+                                    } else {\n+                                        future = getPreviousKey(tr, level, key, true).thenApply(decrement);\n+                                    }\n+                                } else {\n+                                    // This could be optimized to check the hash for which levels should have this key.\n+                                    // That would require that the hash function never changes, though.\n+                                    // This allows for it to change, with the distribution perhaps getting a little uneven\n+                                    // as a result. It even allows for the hash function to return a random number.\n+                                    // It also further guarantees that counts never go to zero.\n+                                    final byte[] k = subspace.pack(Tuple.from(level, key));\n+                                    final CompletableFuture<byte[]> cf = tr.get(k);\n+\n+                                    if (level == 0) {\n+                                        future = cf.thenApply(c -> {\n+                                            if (c != null) {\n+                                                tr.clear(k);\n+                                            }\n+                                            return null;\n+                                        });", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDA0NDAwNA=="}, "originalCommit": {"oid": "d15c7b81796741126f4bda96716ba744fa95f2ec"}, "originalPosition": 401}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQxNzExNjcwOnYy", "diffSide": "RIGHT", "path": "fdb-extensions/src/main/java/com/apple/foundationdb/async/RankedSet.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMFQwMToxNTozNVrOFz-a2Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMFQwMjowNDoxN1rOFz_JPA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDA0NDM3Nw==", "bodyText": "I suppose rather than decrementing, this could explicitly set the key to encodeLong(count - 1). I think the only thing this would do is underscore that we aren't actually making use of the ability of atomic operations to allow for concurrent updates to the level 0 keys.", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/837#discussion_r390044377", "createdAt": "2020-03-10T01:15:35Z", "author": {"login": "alecgrieser"}, "path": "fdb-extensions/src/main/java/com/apple/foundationdb/async/RankedSet.java", "diffHunk": "@@ -220,32 +391,110 @@ public RankedSet(Subspace subspace, Executor executor) {\n                 }));\n     }\n \n-    protected CompletableFuture<Void> addLevelZeroKey(Transaction tr, byte[] key, int level) {\n-        tr.set(subspace.pack(Tuple.from(level, key)), encodeLong(1));\n+    protected CompletableFuture<Void> addLevelZeroKey(Transaction tr, byte[] key, int level, boolean increment) {\n+        final byte[] k = subspace.pack(Tuple.from(level, key));\n+        final byte[] v = encodeLong(1);\n+        if (increment) {\n+            tr.mutate(MutationType.ADD, k, v);\n+        } else {\n+            tr.set(k, v);\n+        }\n         return DONE;\n     }\n \n-    protected CompletableFuture<Void> addIncrementLevelKey(Transaction tr, byte[] key, int level) {\n-        return getPreviousKey(tr, level, key).thenApply(prevKey -> {\n+    protected CompletableFuture<Void> addIncrementLevelKey(Transaction tr, byte[] key, int level, boolean orEqual) {\n+        return getPreviousKey(tr, level, key, orEqual).thenApply(prevKey -> {\n             tr.mutate(MutationType.ADD, subspace.pack(Tuple.from(level, prevKey)), encodeLong(1));\n             return null;\n         });\n     }\n \n     protected CompletableFuture<Void> addInsertLevelKey(Transaction tr, byte[] key, int level) {\n-        return getPreviousKey(tr, level, key).thenCompose(prevKey -> {\n+        return getPreviousKey(tr, level, key, false).thenCompose(prevKey -> {\n             CompletableFuture<Long> prevCount = tr.get(subspace.pack(Tuple.from(level, prevKey))).thenApply(RankedSet::decodeLong);\n             CompletableFuture<Long> newPrevCount = countRange(tr, level - 1, prevKey, key);\n-            return CompletableFuture.allOf(prevCount, newPrevCount)\n-                    .thenApply(vignore2 -> {\n-                        long count = prevCount.join() - newPrevCount.join() + 1;\n-                        tr.set(subspace.pack(Tuple.from(level, prevKey)), encodeLong(newPrevCount.join()));\n-                        tr.set(subspace.pack(Tuple.from(level, key)), encodeLong(count));\n-                        return null;\n-                    });\n+            return prevCount.thenAcceptBoth(newPrevCount, (prev, newPrev) -> {\n+                long count = prev - newPrev + 1;\n+                tr.set(subspace.pack(Tuple.from(level, prevKey)), encodeLong(newPrev));\n+                tr.set(subspace.pack(Tuple.from(level, key)), encodeLong(count));\n+            });\n         });\n     }\n \n+    /**\n+     * Removes a key from the set.\n+     * @param tc the transaction to use to access the database\n+     * @param key the key to remove\n+     * @return a future that completes to {@code true} if the set was modified, that is, if the key was present before this operation\n+     */\n+    public CompletableFuture<Boolean> remove(TransactionContext tc, byte[] key) {\n+        checkKey(key);\n+        return tc.runAsync(tr ->\n+                countCheckedKey(tr, key)\n+                        .thenCompose(count -> {\n+                            if (count == null || count <= 0) {\n+                                return READY_FALSE;\n+                            }\n+                            // This works even if the current set does not track duplicates but duplicates were added\n+                            // earlier by one that did.\n+                            final boolean duplicate = count > 1;\n+                            final int nlevels = config.getNLevels();\n+                            final List<CompletableFuture<Void>> futures = new ArrayList<>(nlevels);\n+                            for (int li = 0; li < nlevels; ++li) {\n+                                final int level = li;\n+\n+                                final CompletableFuture<Void> future;\n+\n+                                if (duplicate) {\n+                                    // Always subtract one, never clearing a level count key.\n+                                    // Concurrent requests both subtracting one when the count is two will conflict\n+                                    // on the level zero key, which was read to detect that this is a duplicate.\n+                                    // So it should not be possible for a count to go to zero.\n+                                    Function<byte[], Void> decrement = k -> {\n+                                        tr.mutate(MutationType.ADD, subspace.pack(Tuple.from(level, k)), encodeLong(-1));\n+                                        return null;\n+                                    };\n+                                    if (level == 0) {\n+                                        decrement.apply(key);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d15c7b81796741126f4bda96716ba744fa95f2ec"}, "originalPosition": 381}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDA1NjI1Mg==", "bodyText": "Yes, that does seem more obvious and in line with the preceding comment.", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/837#discussion_r390056252", "createdAt": "2020-03-10T02:04:17Z", "author": {"login": "MMcM"}, "path": "fdb-extensions/src/main/java/com/apple/foundationdb/async/RankedSet.java", "diffHunk": "@@ -220,32 +391,110 @@ public RankedSet(Subspace subspace, Executor executor) {\n                 }));\n     }\n \n-    protected CompletableFuture<Void> addLevelZeroKey(Transaction tr, byte[] key, int level) {\n-        tr.set(subspace.pack(Tuple.from(level, key)), encodeLong(1));\n+    protected CompletableFuture<Void> addLevelZeroKey(Transaction tr, byte[] key, int level, boolean increment) {\n+        final byte[] k = subspace.pack(Tuple.from(level, key));\n+        final byte[] v = encodeLong(1);\n+        if (increment) {\n+            tr.mutate(MutationType.ADD, k, v);\n+        } else {\n+            tr.set(k, v);\n+        }\n         return DONE;\n     }\n \n-    protected CompletableFuture<Void> addIncrementLevelKey(Transaction tr, byte[] key, int level) {\n-        return getPreviousKey(tr, level, key).thenApply(prevKey -> {\n+    protected CompletableFuture<Void> addIncrementLevelKey(Transaction tr, byte[] key, int level, boolean orEqual) {\n+        return getPreviousKey(tr, level, key, orEqual).thenApply(prevKey -> {\n             tr.mutate(MutationType.ADD, subspace.pack(Tuple.from(level, prevKey)), encodeLong(1));\n             return null;\n         });\n     }\n \n     protected CompletableFuture<Void> addInsertLevelKey(Transaction tr, byte[] key, int level) {\n-        return getPreviousKey(tr, level, key).thenCompose(prevKey -> {\n+        return getPreviousKey(tr, level, key, false).thenCompose(prevKey -> {\n             CompletableFuture<Long> prevCount = tr.get(subspace.pack(Tuple.from(level, prevKey))).thenApply(RankedSet::decodeLong);\n             CompletableFuture<Long> newPrevCount = countRange(tr, level - 1, prevKey, key);\n-            return CompletableFuture.allOf(prevCount, newPrevCount)\n-                    .thenApply(vignore2 -> {\n-                        long count = prevCount.join() - newPrevCount.join() + 1;\n-                        tr.set(subspace.pack(Tuple.from(level, prevKey)), encodeLong(newPrevCount.join()));\n-                        tr.set(subspace.pack(Tuple.from(level, key)), encodeLong(count));\n-                        return null;\n-                    });\n+            return prevCount.thenAcceptBoth(newPrevCount, (prev, newPrev) -> {\n+                long count = prev - newPrev + 1;\n+                tr.set(subspace.pack(Tuple.from(level, prevKey)), encodeLong(newPrev));\n+                tr.set(subspace.pack(Tuple.from(level, key)), encodeLong(count));\n+            });\n         });\n     }\n \n+    /**\n+     * Removes a key from the set.\n+     * @param tc the transaction to use to access the database\n+     * @param key the key to remove\n+     * @return a future that completes to {@code true} if the set was modified, that is, if the key was present before this operation\n+     */\n+    public CompletableFuture<Boolean> remove(TransactionContext tc, byte[] key) {\n+        checkKey(key);\n+        return tc.runAsync(tr ->\n+                countCheckedKey(tr, key)\n+                        .thenCompose(count -> {\n+                            if (count == null || count <= 0) {\n+                                return READY_FALSE;\n+                            }\n+                            // This works even if the current set does not track duplicates but duplicates were added\n+                            // earlier by one that did.\n+                            final boolean duplicate = count > 1;\n+                            final int nlevels = config.getNLevels();\n+                            final List<CompletableFuture<Void>> futures = new ArrayList<>(nlevels);\n+                            for (int li = 0; li < nlevels; ++li) {\n+                                final int level = li;\n+\n+                                final CompletableFuture<Void> future;\n+\n+                                if (duplicate) {\n+                                    // Always subtract one, never clearing a level count key.\n+                                    // Concurrent requests both subtracting one when the count is two will conflict\n+                                    // on the level zero key, which was read to detect that this is a duplicate.\n+                                    // So it should not be possible for a count to go to zero.\n+                                    Function<byte[], Void> decrement = k -> {\n+                                        tr.mutate(MutationType.ADD, subspace.pack(Tuple.from(level, k)), encodeLong(-1));\n+                                        return null;\n+                                    };\n+                                    if (level == 0) {\n+                                        decrement.apply(key);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDA0NDM3Nw=="}, "originalCommit": {"oid": "d15c7b81796741126f4bda96716ba744fa95f2ec"}, "originalPosition": 381}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 88, "cost": 1, "resetAt": "2021-11-12T18:49:56Z"}}}