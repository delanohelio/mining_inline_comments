{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzgwNTc5Nzg0", "number": 837, "title": "Resolves #806: Rank index could have option for how to handle ties", "bodyText": "Note that this doesn't actually introduce a RankedMultiset class, because that was hard with the current InstrumentedRankset class. It would be possible by creating an interface and making that a wrapper instead of a subclass. But I'm not sure it's worth it.\nThis moves all the Rankset config options, including the recently added hash function, into a separate Config class so that the constructors don't continue to get out of hand. At some point (but not in this PR) some of them could presumably be deprecated.", "createdAt": "2020-02-27T00:47:00Z", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/837", "merged": true, "mergeCommit": {"oid": "7cae994842173d3fe84a480b7e08a859b7a796b7"}, "closed": true, "closedAt": "2020-03-17T01:20:00Z", "author": {"login": "MMcM"}, "timelineItems": {"totalCount": 24, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcIQdpCAFqTM2NTM0NzU2Ng==", "endCursor": "Y3Vyc29yOnYyOpPPAAABcOYTO2gFqTM3NTY4MDMzNQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY1MzQ3NTY2", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/837#pullrequestreview-365347566", "createdAt": "2020-02-27T00:48:20Z", "commit": {"oid": "d1b1b6f12150d9e94b768b4c08c62200d1d4a478"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yN1QwMDo0ODoyMFrOFvBpuA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yN1QwMDo0ODoyMFrOFvBpuA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDg1NDQ1Ng==", "bodyText": "There is a separate commit to relocate this method, which might make it easier to track how it has changed (other than that).", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/837#discussion_r384854456", "createdAt": "2020-02-27T00:48:20Z", "author": {"login": "MMcM"}, "path": "fdb-extensions/src/main/java/com/apple/foundationdb/async/RankedSet.java", "diffHunk": "@@ -246,6 +382,80 @@ public RankedSet(Subspace subspace, Executor executor) {\n         });\n     }\n \n+    /**\n+     * Removes a key from the set.\n+     * @param tc the transaction to use to access the database\n+     * @param key the key to remove\n+     * @return a future that completes to {@code true} if the set was modified, that is, if the key was present before this operation\n+     */\n+    public CompletableFuture<Boolean> remove(TransactionContext tc, byte[] key) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d1b1b6f12150d9e94b768b4c08c62200d1d4a478"}, "originalPosition": 279}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY1MzQ3ODc2", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/837#pullrequestreview-365347876", "createdAt": "2020-02-27T00:49:12Z", "commit": {"oid": "d1b1b6f12150d9e94b768b4c08c62200d1d4a478"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yN1QwMDo0OToxMlrOFvBrIg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yN1QwMDo0OToxMlrOFvBrIg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDg1NDgxOA==", "bodyText": "If there were a separate RankedMultiset class, this would only be on it, though it seems well-defined everywhere.", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/837#discussion_r384854818", "createdAt": "2020-02-27T00:49:12Z", "author": {"login": "MMcM"}, "path": "fdb-extensions/src/main/java/com/apple/foundationdb/async/RankedSet.java", "diffHunk": "@@ -267,17 +477,30 @@ public RankedSet(Subspace subspace, Executor executor) {\n      */\n     public CompletableFuture<Boolean> contains(ReadTransactionContext tc, byte[] key) {\n         checkKey(key);\n-        return containsCheckedKey(tc, key);\n+        return countCheckedKey(tc, key).thenApply(c -> c != null && c > 0);\n+    }\n+\n+    /**\n+     * Count the number of occurrences of a key in the set.\n+     * @param tc the transaction to use to access the database\n+     * @param key the key to check for\n+     * @return a future that completes to {@code 0} if the key is not present in the ranked set or\n+     * {@code 1} if the key is present in the ranked set and duplicates are not counted or\n+     * the number of occurrences if duplicated are counted separately\n+     */\n+    public CompletableFuture<Long> count(ReadTransactionContext tc, byte[] key) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d1b1b6f12150d9e94b768b4c08c62200d1d4a478"}, "originalPosition": 366}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY1MzQ4MTE4", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/837#pullrequestreview-365348118", "createdAt": "2020-02-27T00:49:55Z", "commit": {"oid": "d1b1b6f12150d9e94b768b4c08c62200d1d4a478"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yN1QwMDo0OTo1NVrOFvBr6g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yN1QwMDo0OTo1NVrOFvBr6g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDg1NTAxOA==", "bodyText": "I don't think there was any reason to do this with a getRange before. I'm also not sure the snapshot is needed any more.", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/837#discussion_r384855018", "createdAt": "2020-02-27T00:49:55Z", "author": {"login": "MMcM"}, "path": "fdb-extensions/src/main/java/com/apple/foundationdb/async/RankedSet.java", "diffHunk": "@@ -643,19 +819,21 @@ private static void checkKey(byte[] key) {\n                         .thenApply(longs -> longs.stream().reduce(0L, Long::sum)));\n     }\n \n-    private CompletableFuture<byte[]> getPreviousKey(TransactionContext tc, int level, byte[] key) {\n+    // Get the key before this one at the given level.\n+    // If orEqual is given, then an exactly matching key is also considered. This is only used when the key is known\n+    // to be a duplicate or an existing key and so should do whatever it did.\n+    private CompletableFuture<byte[]> getPreviousKey(TransactionContext tc, int level, byte[] key, boolean orEqual) {\n         byte[] k = subspace.pack(Tuple.from(level, key));\n         CompletableFuture<byte[]> kf = tc.run(tr ->\n-                tr.snapshot()\n-                        .getRange(KeySelector.lastLessThan(k), KeySelector.firstGreaterOrEqual(k), 1)\n-                        .asList()\n-                        .thenApply(kvs -> {\n-                            byte[] prevk = kvs.get(0).getKey();\n-                            // If another key were inserted after between this and the target key,\n-                            // it wouldn't be the one we should increment any more.\n-                            // But do not conflict when key itself is incremented.\n-                            byte[] exclusiveBegin = ByteArrayUtil.join(prevk, ZERO_ARRAY);\n-                            tr.addReadConflictRange(exclusiveBegin, k);\n+                tr.snapshot().getKey(orEqual ? KeySelector.lastLessOrEqual(k) : KeySelector.lastLessThan(k))", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d1b1b6f12150d9e94b768b4c08c62200d1d4a478"}, "originalPosition": 530}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY1NzI0NTYx", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/837#pullrequestreview-365724561", "createdAt": "2020-02-27T14:28:18Z", "commit": {"oid": "d1b1b6f12150d9e94b768b4c08c62200d1d4a478"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yN1QxNDoyODoxOVrOFvUV_Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yN1QxNDoyODoxOVrOFvUV_Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTE2MDcwMQ==", "bodyText": "Not much thought went into mixing set and multiset on the same subspace. Other than not violating the consistency invariants. In particular, remove always removes (up to) one occurrence. Would it be better if it removed all when not counting duplicates?", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/837#discussion_r385160701", "createdAt": "2020-02-27T14:28:19Z", "author": {"login": "MMcM"}, "path": "fdb-extensions/src/main/java/com/apple/foundationdb/async/RankedSet.java", "diffHunk": "@@ -246,6 +382,80 @@ public RankedSet(Subspace subspace, Executor executor) {\n         });\n     }\n \n+    /**\n+     * Removes a key from the set.\n+     * @param tc the transaction to use to access the database\n+     * @param key the key to remove\n+     * @return a future that completes to {@code true} if the set was modified, that is, if the key was present before this operation\n+     */\n+    public CompletableFuture<Boolean> remove(TransactionContext tc, byte[] key) {\n+        checkKey(key);\n+        return tc.runAsync(tr ->\n+                countCheckedKey(tr, key)\n+                        .thenCompose(count -> {\n+                            if (count == null || count <= 0) {\n+                                return READY_FALSE;\n+                            }\n+                            // This works even if the current set does not track duplicates but duplicates were added\n+                            // earlier by one that did.\n+                            final boolean duplicate = count > 1;\n+                            final int nlevels = config.getNLevels();\n+                            final List<CompletableFuture<Void>> futures = new ArrayList<>(nlevels);\n+                            for (int li = 0; li < nlevels; ++li) {\n+                                final int level = li;\n+\n+                                final CompletableFuture<Void> future;\n+\n+                                if (duplicate) {\n+                                    // Always subtract one, never clearing a key. It is possible for this to leave\n+                                    // a key with a count of zero, if duplicates were inserted with different hash functions.\n+                                    Function<byte[], Void> decrement = k -> {\n+                                        tr.mutate(MutationType.ADD, subspace.pack(Tuple.from(level, k)), encodeLong(-1));\n+                                        return null;\n+                                    };\n+                                    if (level == 0) {\n+                                        decrement.apply(key);\n+                                        future = DONE;\n+                                    } else {\n+                                        future = getPreviousKey(tr, level, key, true).thenApply(decrement);\n+                                    }\n+                                } else {\n+                                    // This could be optimized to check the hash for which levels should have this key.\n+                                    // That would require that the hash function never changes, though.\n+                                    // This allows for it to change, with the distribution perhaps getting a little uneven\n+                                    // as a result. It even allows for the hash function to return a random number.\n+                                    final byte[] k = subspace.pack(Tuple.from(level, key));\n+                                    final CompletableFuture<byte[]> cf = tr.get(k);\n+\n+                                    if (level == 0) {\n+                                        future = cf.thenApply(c -> {\n+                                            if (c != null) {\n+                                                tr.clear(k);\n+                                            }\n+                                            return null;\n+                                        });\n+                                    } else {\n+                                        final CompletableFuture<byte[]> prevKeyF = getPreviousKey(tr, level, key, false);\n+                                        future = CompletableFuture.allOf(cf, prevKeyF)\n+                                                .thenApply(vignore -> {\n+                                                    final byte[] c = cf.join();\n+                                                    long countChange = -1;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d1b1b6f12150d9e94b768b4c08c62200d1d4a478"}, "originalPosition": 330}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY1NzI1MjE3", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/837#pullrequestreview-365725217", "createdAt": "2020-02-27T14:29:03Z", "commit": {"oid": "d1b1b6f12150d9e94b768b4c08c62200d1d4a478"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yN1QxNDoyOTowM1rOFvUX6g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yN1QxNDoyOTowM1rOFvUX6g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTE2MTE5NA==", "bodyText": "Is it worth having a RANDOM_HASH_FUNCTION? Roughly, threadLocalRandom.getInt(). And a test to show that it works?", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/837#discussion_r385161194", "createdAt": "2020-02-27T14:29:03Z", "author": {"login": "MMcM"}, "path": "fdb-extensions/src/main/java/com/apple/foundationdb/async/RankedSet.java", "diffHunk": "@@ -246,6 +382,80 @@ public RankedSet(Subspace subspace, Executor executor) {\n         });\n     }\n \n+    /**\n+     * Removes a key from the set.\n+     * @param tc the transaction to use to access the database\n+     * @param key the key to remove\n+     * @return a future that completes to {@code true} if the set was modified, that is, if the key was present before this operation\n+     */\n+    public CompletableFuture<Boolean> remove(TransactionContext tc, byte[] key) {\n+        checkKey(key);\n+        return tc.runAsync(tr ->\n+                countCheckedKey(tr, key)\n+                        .thenCompose(count -> {\n+                            if (count == null || count <= 0) {\n+                                return READY_FALSE;\n+                            }\n+                            // This works even if the current set does not track duplicates but duplicates were added\n+                            // earlier by one that did.\n+                            final boolean duplicate = count > 1;\n+                            final int nlevels = config.getNLevels();\n+                            final List<CompletableFuture<Void>> futures = new ArrayList<>(nlevels);\n+                            for (int li = 0; li < nlevels; ++li) {\n+                                final int level = li;\n+\n+                                final CompletableFuture<Void> future;\n+\n+                                if (duplicate) {\n+                                    // Always subtract one, never clearing a key. It is possible for this to leave\n+                                    // a key with a count of zero, if duplicates were inserted with different hash functions.\n+                                    Function<byte[], Void> decrement = k -> {\n+                                        tr.mutate(MutationType.ADD, subspace.pack(Tuple.from(level, k)), encodeLong(-1));\n+                                        return null;\n+                                    };\n+                                    if (level == 0) {\n+                                        decrement.apply(key);\n+                                        future = DONE;\n+                                    } else {\n+                                        future = getPreviousKey(tr, level, key, true).thenApply(decrement);\n+                                    }\n+                                } else {\n+                                    // This could be optimized to check the hash for which levels should have this key.\n+                                    // That would require that the hash function never changes, though.\n+                                    // This allows for it to change, with the distribution perhaps getting a little uneven\n+                                    // as a result. It even allows for the hash function to return a random number.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d1b1b6f12150d9e94b768b4c08c62200d1d4a478"}, "originalPosition": 314}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY1OTMzNTMy", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/837#pullrequestreview-365933532", "createdAt": "2020-02-27T19:23:15Z", "commit": {"oid": "d1b1b6f12150d9e94b768b4c08c62200d1d4a478"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 15, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yN1QxOToyMzoxNVrOFveIFw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNlQyMjoyMzozM1rOFzJPag==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTMyMDk4Mw==", "bodyText": "I suppose these overloads could say that they are just synonyms for the overload that takes a full Config object with the defaults/parameters set as appropriate.", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/837#discussion_r385320983", "createdAt": "2020-02-27T19:23:15Z", "author": {"login": "alecgrieser"}, "path": "fdb-extensions/src/main/java/com/apple/foundationdb/async/RankedSet.java", "diffHunk": "@@ -143,30 +144,153 @@ private static long decodeLong(byte[] v) {\n         int hash(byte[] key);\n     }\n \n+    /**\n+     * Configuration settings for a {@link RankedSet}.\n+     */\n+    public static class Config {\n+        private final HashFunction hashFunction;\n+        private final int nlevels;\n+        private final boolean countDuplicates;\n+\n+        protected Config() {\n+            this.hashFunction = DEFAULT_HASH_FUNCTION;\n+            this.nlevels = DEFAULT_LEVELS;\n+            this.countDuplicates = false;\n+        }\n+\n+        protected Config(HashFunction hashFunction, int nlevels, boolean countDuplicates) {\n+            this.hashFunction = hashFunction;\n+            this.nlevels = nlevels;\n+            this.countDuplicates = countDuplicates;\n+        }\n+\n+        /**\n+         * Get the hash function to use.\n+         * @return a {@link HashFunction} used to convert keys to a bit mask used to determine level splits in the skip list\n+         */\n+        public HashFunction getHashFunction() {\n+            return hashFunction;\n+        }\n+\n+        /**\n+         * Get the number of levels to use.\n+         * @return the number of levels in the skip list\n+         */\n+        public int getNLevels() {\n+            return nlevels;\n+        }\n+\n+        /**\n+         * Get whether duplicate entries increase ranks below them.\n+         * @return {@code true} if duplicates are counted separately\n+         */\n+        public boolean isCountDuplicates() {\n+            return countDuplicates;\n+        }\n+    }\n+\n+\n+    /**\n+     * Builder for {@link Config}.\n+     *\n+     * @see #newConfigBuilder\n+     */\n+    public static class ConfigBuilder {\n+        private HashFunction hashFunction = DEFAULT_HASH_FUNCTION;\n+        private int nlevels = DEFAULT_LEVELS;\n+        private boolean countDuplicates = false;\n+\n+        protected ConfigBuilder() {\n+        }\n+\n+        public HashFunction getHashFunction() {\n+            return hashFunction;\n+        }\n+\n+        /**\n+         * Set the hash function to use.\n+         *\n+         * It is possible to change the hash function of an existing ranked set, although this is not recommended since the distribution in the skip list may\n+         * become uneven as a result.\n+         * @param hashFunction the hash function to use\n+         * @return this builder\n+         */\n+        public ConfigBuilder setHashFunction(HashFunction hashFunction) {\n+            this.hashFunction = hashFunction;\n+            return this;\n+        }\n+\n+        public int getNLevels() {\n+            return nlevels;\n+        }\n+\n+        /**\n+         * Set the hash function to use.\n+         *\n+         * It is not currently possible to change the number of levels for an existing ranked set.\n+         * @param nlevels the number of levels to use\n+         * @return this builder\n+         */\n+        public ConfigBuilder setNLevels(int nlevels) {\n+            if (nlevels < 2 || nlevels > MAX_LEVELS) {\n+                throw new IllegalArgumentException(\"levels must be between 2 and \" + MAX_LEVELS);\n+            }\n+            this.nlevels = nlevels;\n+            return this;\n+        }\n+\n+        public boolean isCountDuplicates() {\n+            return countDuplicates;\n+        }\n+\n+        /**\n+         * Set whether to count duplicate keys separately.\n+         *\n+         * If duplicate keys are counted separately, ranks after them are increased by the number of duplicates.\n+         * @param countDuplicates whether to count duplicates\n+         * @return this builder\n+         */\n+        public ConfigBuilder setCountDuplicates(boolean countDuplicates) {\n+            this.countDuplicates = countDuplicates;\n+            return this;\n+        }\n+\n+        public Config build() {\n+            return new Config(hashFunction, nlevels, countDuplicates);\n+        }\n+    }\n+\n+    /**\n+     * Start building a {@link Config}.\n+     * @return a new {@code Config} that can be altered and then built for use with a {@link RankedSet}\n+     * @see ConfigBuilder#build\n+     */\n+    public static ConfigBuilder newConfigBuilder() {\n+        return new ConfigBuilder();\n+    }\n+\n     /**\n      * Initialize a new ranked set.\n      * @param subspace the subspace where the ranked set is stored\n      * @param executor an executor to use when running asynchronous tasks\n-     * @param hashFunction hash function to use to determine which levels a key splits on\n-     * @param nlevels number of skip list levels to maintain\n+     * @param config configuration to use\n      */\n-    public RankedSet(Subspace subspace, Executor executor, HashFunction hashFunction, int nlevels) {\n-        if (nlevels < 2 || nlevels > MAX_LEVELS) {\n-            throw new IllegalArgumentException(\"levels must be between 2 and \" + MAX_LEVELS);\n-        }\n-\n+    public RankedSet(Subspace subspace, Executor executor, Config config) {\n         this.subspace = subspace;\n         this.executor = executor;\n-        this.hashFunction = hashFunction;\n-        this.nlevels = nlevels;\n+        this.config = config;\n+    }\n+\n+    public RankedSet(Subspace subspace, Executor executor, HashFunction hashFunction, int nlevels) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d1b1b6f12150d9e94b768b4c08c62200d1d4a478"}, "originalPosition": 172}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODY0MTA1MQ==", "bodyText": "If I understand this, the duplicate || here is to ensure that we don't split at the same point twice and then (in a world where, for example, the \"hash\" was just random each time instead of based on the data) don't decide to add a split only on the second time we see it (or something). Might be nice to have a comment here about that.", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/837#discussion_r388641051", "createdAt": "2020-03-06T00:22:25Z", "author": {"login": "alecgrieser"}, "path": "fdb-extensions/src/main/java/com/apple/foundationdb/async/RankedSet.java", "diffHunk": "@@ -179,33 +303,39 @@ public RankedSet(Subspace subspace, Executor executor) {\n      * @return {@code true} if this ranked set needs to be initialized\n      */\n     public CompletableFuture<Boolean> initNeeded(ReadTransactionContext tc) {\n-        return containsCheckedKey(tc, EMPTY_ARRAY).thenApply(b -> !b);\n+        return countCheckedKey(tc, EMPTY_ARRAY).thenApply(Objects::isNull);\n     }\n \n     /**\n      * Add a key to the set.\n+     *\n+     * If {@link Config#isCountDuplicates} is {@code false} and {@code key} is already present, the return value is {@code false}.\n+     * If {@link Config#isCountDuplicates} is {@code true}, the return value is never {@code false} and a duplicate will\n+     * cause all {@link #rank}s below it to increase by one.\n      * @param tc the transaction to use to access the database\n      * @param key the key to add\n-     * @return a future that completes to {@code true} if the key was not already present\n+     * @return a future that completes to {@code true} if the ranked set was modified\n      */\n     public CompletableFuture<Boolean> add(TransactionContext tc, byte[] key) {\n         checkKey(key);\n         // Use the hash of the key, instead a p value and randomLevel. The key is likely Tuple-encoded.\n-        long keyHash = hashFunction.hash(key);\n+        final long keyHash = config.getHashFunction().hash(key);\n         return tc.runAsync(tr ->\n-            containsCheckedKey(tr, key)\n-                .thenCompose(exists -> {\n-                    if (exists) {\n+            countCheckedKey(tr, key)\n+                .thenCompose(count -> {\n+                    final boolean duplicate = count != null && count > 0;\n+                    if (duplicate && !config.isCountDuplicates()) {\n                         return READY_FALSE;\n                     }\n+                    final int nlevels = config.getNLevels();\n                     List<CompletableFuture<Void>> futures = new ArrayList<>(nlevels);\n                     for (int li = 0; li < nlevels; ++li) {\n-                        int level = li;\n+                        final int level = li;\n                         CompletableFuture<Void> future;\n                         if (level == 0) {\n-                            future = addLevelZeroKey(tr, key, level);\n-                        } else if ((keyHash & LEVEL_FAN_VALUES[level]) != 0) {\n-                            future = addIncrementLevelKey(tr, key, level);\n+                            future = addLevelZeroKey(tr, key, level, duplicate);\n+                        } else if (duplicate || (keyHash & LEVEL_FAN_VALUES[level]) != 0) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d1b1b6f12150d9e94b768b4c08c62200d1d4a478"}, "originalPosition": 232}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODY0NTQwNQ==", "bodyText": "It's a little unfortunate our nullability annotations don't allow us to return an @Nullable Long. IIUC, we do actually check the nullity (rather than treat it as zero) to check if we need to initialize the ranked set, which is a little unfortunate. hmm", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/837#discussion_r388645405", "createdAt": "2020-03-06T00:34:15Z", "author": {"login": "alecgrieser"}, "path": "fdb-extensions/src/main/java/com/apple/foundationdb/async/RankedSet.java", "diffHunk": "@@ -267,17 +477,30 @@ public RankedSet(Subspace subspace, Executor executor) {\n      */\n     public CompletableFuture<Boolean> contains(ReadTransactionContext tc, byte[] key) {\n         checkKey(key);\n-        return containsCheckedKey(tc, key);\n+        return countCheckedKey(tc, key).thenApply(c -> c != null && c > 0);\n+    }\n+\n+    /**\n+     * Count the number of occurrences of a key in the set.\n+     * @param tc the transaction to use to access the database\n+     * @param key the key to check for\n+     * @return a future that completes to {@code 0} if the key is not present in the ranked set or\n+     * {@code 1} if the key is present in the ranked set and duplicates are not counted or\n+     * the number of occurrences if duplicated are counted separately\n+     */\n+    public CompletableFuture<Long> count(ReadTransactionContext tc, byte[] key) {\n+        checkKey(key);\n+        return countCheckedKey(tc, key).thenApply(c -> c == null ? Long.valueOf(0) : c);\n     }\n \n-    private CompletableFuture<Boolean> containsCheckedKey(ReadTransactionContext tc, byte[] key) {\n-        return tc.readAsync(tr -> tr.get(subspace.pack(Tuple.from(0, key))).thenApply(Objects::nonNull));\n+    private CompletableFuture<Long> countCheckedKey(ReadTransactionContext tc, byte[] key) {\n+        return tc.readAsync(tr -> tr.get(subspace.pack(Tuple.from(0, key))).thenApply(b -> b == null ? null : decodeLong(b)));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d1b1b6f12150d9e94b768b4c08c62200d1d4a478"}, "originalPosition": 374}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODY1MDcxOQ==", "bodyText": "I think we still want to do this at snapshot because I think a modification (like an increment) to exactly the read key will cause a conflict...though I could be wrong.\nAs to getRange or getKey, I think it's about six of one, half dozen of the other as it's actually translated to a get range call in the C API anyway. Usually, I think the advice is to not use getKey if you can't guarantee that the key range doesn't \"leak\" out of the subspace, but I think the empty arrays at the beginning of each level should handle that in this case, so I think it's fine.", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/837#discussion_r388650719", "createdAt": "2020-03-06T00:51:04Z", "author": {"login": "alecgrieser"}, "path": "fdb-extensions/src/main/java/com/apple/foundationdb/async/RankedSet.java", "diffHunk": "@@ -643,19 +819,21 @@ private static void checkKey(byte[] key) {\n                         .thenApply(longs -> longs.stream().reduce(0L, Long::sum)));\n     }\n \n-    private CompletableFuture<byte[]> getPreviousKey(TransactionContext tc, int level, byte[] key) {\n+    // Get the key before this one at the given level.\n+    // If orEqual is given, then an exactly matching key is also considered. This is only used when the key is known\n+    // to be a duplicate or an existing key and so should do whatever it did.\n+    private CompletableFuture<byte[]> getPreviousKey(TransactionContext tc, int level, byte[] key, boolean orEqual) {\n         byte[] k = subspace.pack(Tuple.from(level, key));\n         CompletableFuture<byte[]> kf = tc.run(tr ->\n-                tr.snapshot()\n-                        .getRange(KeySelector.lastLessThan(k), KeySelector.firstGreaterOrEqual(k), 1)\n-                        .asList()\n-                        .thenApply(kvs -> {\n-                            byte[] prevk = kvs.get(0).getKey();\n-                            // If another key were inserted after between this and the target key,\n-                            // it wouldn't be the one we should increment any more.\n-                            // But do not conflict when key itself is incremented.\n-                            byte[] exclusiveBegin = ByteArrayUtil.join(prevk, ZERO_ARRAY);\n-                            tr.addReadConflictRange(exclusiveBegin, k);\n+                tr.snapshot().getKey(orEqual ? KeySelector.lastLessOrEqual(k) : KeySelector.lastLessThan(k))", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDg1NTAxOA=="}, "originalCommit": {"oid": "d1b1b6f12150d9e94b768b4c08c62200d1d4a478"}, "originalPosition": 530}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODY1MDc5MQ==", "bodyText": "I don't think that this conflict is necessary in multi-set mode, as keys are never removed (at the moment), though I suppose that could change. It also could result in spurious conflicts when the values of those keys are incremented or decremented (but not to 0).\nedit: removed first claim based on re-read of remove code.", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/837#discussion_r388650791", "createdAt": "2020-03-06T00:51:22Z", "author": {"login": "alecgrieser"}, "path": "fdb-extensions/src/main/java/com/apple/foundationdb/async/RankedSet.java", "diffHunk": "@@ -643,19 +819,21 @@ private static void checkKey(byte[] key) {\n                         .thenApply(longs -> longs.stream().reduce(0L, Long::sum)));\n     }\n \n-    private CompletableFuture<byte[]> getPreviousKey(TransactionContext tc, int level, byte[] key) {\n+    // Get the key before this one at the given level.\n+    // If orEqual is given, then an exactly matching key is also considered. This is only used when the key is known\n+    // to be a duplicate or an existing key and so should do whatever it did.\n+    private CompletableFuture<byte[]> getPreviousKey(TransactionContext tc, int level, byte[] key, boolean orEqual) {\n         byte[] k = subspace.pack(Tuple.from(level, key));\n         CompletableFuture<byte[]> kf = tc.run(tr ->\n-                tr.snapshot()\n-                        .getRange(KeySelector.lastLessThan(k), KeySelector.firstGreaterOrEqual(k), 1)\n-                        .asList()\n-                        .thenApply(kvs -> {\n-                            byte[] prevk = kvs.get(0).getKey();\n-                            // If another key were inserted after between this and the target key,\n-                            // it wouldn't be the one we should increment any more.\n-                            // But do not conflict when key itself is incremented.\n-                            byte[] exclusiveBegin = ByteArrayUtil.join(prevk, ZERO_ARRAY);\n-                            tr.addReadConflictRange(exclusiveBegin, k);\n+                tr.snapshot().getKey(orEqual ? KeySelector.lastLessOrEqual(k) : KeySelector.lastLessThan(k))\n+                        .thenApply(prevk -> {\n+                            if (!orEqual || !Arrays.equals(prevk, k)) {\n+                                // If another key were inserted after between this and the target key,\n+                                // it wouldn't be the one we should increment any more.\n+                                // But do not conflict when key itself is incremented.\n+                                byte[] exclusiveBegin = ByteArrayUtil.join(prevk, ZERO_ARRAY);\n+                                tr.addReadConflictRange(exclusiveBegin, k);\n+                            }\n                             // Do conflict if key is removed entirely.\n                             tr.addReadConflictKey(subspace.pack(Tuple.from(0, subspace.unpack(prevk).getBytes(1))));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d1b1b6f12150d9e94b768b4c08c62200d1d4a478"}, "originalPosition": 540}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODY1MjE3Ng==", "bodyText": "Hm, it's a little unfortunate that this would leave around empty keys and signposts. I think we could almost get around this by adding tr.mutate(MutationType.COMPARE_AND_CLEAR, subspace.pack(Tuple.from(level, k)), encodeLong(0)) (probably not serializing the key twice), but there's a case I was thinking through that I think this breaks for.\nSuppose you had a 2-level skip list with something like:\nlevel 1: (0 -> 1)----(1 -> 1)---------------------(5 -> 1)\nlevel 0: (0 -> 1)-------------------(3 -> 1)------(5 -> 1)\n\n(That is 0, 3, and 5 in level 0 and 0, 1, and 5 in level 1. Presumably, there used to be a 1 in the skip list, but it was removed at some point.) Then suppose you had the following three operations: insert 2, remove 3, insert 4, and assume that neither of the two inserts cause a split. And assume the following ordering of GRVs and commits:\n\ninsert 4 GRV\nremove 3 GRV\nremove 3 commit\ninsert 2 GRV\ninsert 2 commit\ninsert 4 commit\n\nAfter the remove 3 has committed, then I think the skip list would look like:\nlevel 1: (0 -> 1)------------------------------(5 -> 1)\nlevel 0: (0 -> 1)------------------------------(5 -> 1)\n\nAs removing 3 also decrements the count of 1 to 0. So when 2 is inserted (and commits), it doesn't see anything at the higher levels before 0. So the skip list it writes looks like:\nlevel 1: (0 -> 2)-------------------------------(5 -> 1)\nlevel 0: (0 -> 1)--------------(2 -> 1)---------(5 -> 1)\n\nBut the insert of 4 happened when 1 still was in level 1, so it will increment that value, which I believes results in this invalid skip list if committed:\nlevel 1: (0 -> 2)---(1 -> 1)------------------------(5 -> 1)\nlevel 0: (0 -> 1)-------------(2 -> 1)---(4 -> 1)---(5 -> 1)\n\nAnd the read conflict set on committing the insert of 4 would be on level 0's key 1 (which was not modified) and on the level 1 range from key 1 (exclusive) to 4 (inclusive), none of which changed. So I think this commit is successful.\nI don't actually think this problem is possible with the code as it is, given that it keeps the zero's around, though I could be convinced that we haven't thought through all of the cases here. (The fatal flaw here is that we add a read conflict on the level 0 key for the sign-post key as a proxy for \"fail this transaction only if the key disappears\", but that isn't necessarily the case in the proposal as I've sketched it. As we never remove any key from the range set, the current code can't hit that pathology as written.)\nI wonder if there might be a way to expand the write conflict range of a delete (maybe) on a key delete or something, of at least the upper levels, and if that would be sufficient, though it may not work with mixed software versions. It's also possible that instead of this fancy \"compare and clear\" business that I suggested, instead, it needs to enforce that if a key is at level k, then that key is present in all levels less than k, which is a property of the current code and also skip lists more generally, but it would probably hurt the concurrency of the multi-set case (though maybe the code paths for set and multi-set are more similar?).", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/837#discussion_r388652176", "createdAt": "2020-03-06T00:54:21Z", "author": {"login": "alecgrieser"}, "path": "fdb-extensions/src/main/java/com/apple/foundationdb/async/RankedSet.java", "diffHunk": "@@ -356,37 +396,59 @@ public RankedSet(Subspace subspace, Executor executor) {\n                             if (count == null || count <= 0) {\n                                 return READY_FALSE;\n                             }\n+                            // This works even if the current set does not track duplicates but duplicates were added\n+                            // earlier by one that did.\n+                            final boolean duplicate = count > 1;\n                             final int nlevels = config.getNLevels();\n                             final List<CompletableFuture<Void>> futures = new ArrayList<>(nlevels);\n                             for (int li = 0; li < nlevels; ++li) {\n                                 final int level = li;\n-                                // This could be optimized to check the hash for which levels should have this key.\n-                                final byte[] k = subspace.pack(Tuple.from(level, key));\n \n                                 final CompletableFuture<Void> future;\n-                                final CompletableFuture<byte[]> cf = tr.get(k);\n \n-                                if (level == 0) {\n-                                    future = cf.thenApply(c -> {\n-                                        if (c != null) {\n-                                            tr.clear(k);\n-                                        }\n+                                if (duplicate) {\n+                                    // Always subtract one, never clearing a key. It is possible for this to leave\n+                                    // a key with a count of zero, if duplicates were inserted with different hash functions.\n+                                    Function<byte[], Void> decrement = k -> {\n+                                        tr.mutate(MutationType.ADD, subspace.pack(Tuple.from(level, k)), encodeLong(-1));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "eaca40e0c8b2079dc59730fa3dd94e7c4ddf4cad"}, "originalPosition": 182}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODY2NDY3MQ==", "bodyText": "This .allOf isn't new, but I suppose this could be thenCombine or .thenAcceptBoth, and I think it would be cleaner.", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/837#discussion_r388664671", "createdAt": "2020-03-06T01:16:45Z", "author": {"login": "alecgrieser"}, "path": "fdb-extensions/src/main/java/com/apple/foundationdb/async/RankedSet.java", "diffHunk": "@@ -356,37 +396,59 @@ public RankedSet(Subspace subspace, Executor executor) {\n                             if (count == null || count <= 0) {\n                                 return READY_FALSE;\n                             }\n+                            // This works even if the current set does not track duplicates but duplicates were added\n+                            // earlier by one that did.\n+                            final boolean duplicate = count > 1;\n                             final int nlevels = config.getNLevels();\n                             final List<CompletableFuture<Void>> futures = new ArrayList<>(nlevels);\n                             for (int li = 0; li < nlevels; ++li) {\n                                 final int level = li;\n-                                // This could be optimized to check the hash for which levels should have this key.\n-                                final byte[] k = subspace.pack(Tuple.from(level, key));\n \n                                 final CompletableFuture<Void> future;\n-                                final CompletableFuture<byte[]> cf = tr.get(k);\n \n-                                if (level == 0) {\n-                                    future = cf.thenApply(c -> {\n-                                        if (c != null) {\n-                                            tr.clear(k);\n-                                        }\n+                                if (duplicate) {\n+                                    // Always subtract one, never clearing a key. It is possible for this to leave\n+                                    // a key with a count of zero, if duplicates were inserted with different hash functions.\n+                                    Function<byte[], Void> decrement = k -> {\n+                                        tr.mutate(MutationType.ADD, subspace.pack(Tuple.from(level, k)), encodeLong(-1));\n                                         return null;\n-                                    });\n+                                    };\n+                                    if (level == 0) {\n+                                        decrement.apply(key);\n+                                        future = DONE;\n+                                    } else {\n+                                        future = getPreviousKey(tr, level, key, true).thenApply(decrement);\n+                                    }\n                                 } else {\n-                                    final CompletableFuture<byte[]> prevKeyF = getPreviousKey(tr, level, key);\n-                                    future = CompletableFuture.allOf(cf, prevKeyF)\n-                                            .thenApply(vignore -> {\n-                                                final byte[] c = cf.join();\n-                                                long countChange = -1;\n-                                                if (c != null) {\n-                                                    // Give back additional count from the key we are erasing to the neighbor.\n-                                                    countChange += decodeLong(c);\n-                                                    tr.clear(k);\n-                                                }\n-                                                tr.mutate(MutationType.ADD, subspace.pack(Tuple.from(level, prevKeyF.join())), encodeLong(countChange));\n-                                                return null;\n-                                            });\n+                                    // This could be optimized to check the hash for which levels should have this key.\n+                                    // That would require that the hash function never changes, though.\n+                                    // This allows for it to change, with the distribution perhaps getting a little uneven\n+                                    // as a result. It even allows for the hash function to return a random number.\n+                                    final byte[] k = subspace.pack(Tuple.from(level, key));\n+                                    final CompletableFuture<byte[]> cf = tr.get(k);\n+\n+                                    if (level == 0) {\n+                                        future = cf.thenApply(c -> {\n+                                            if (c != null) {\n+                                                tr.clear(k);\n+                                            }\n+                                            return null;\n+                                        });\n+                                    } else {\n+                                        final CompletableFuture<byte[]> prevKeyF = getPreviousKey(tr, level, key, false);\n+                                        future = CompletableFuture.allOf(cf, prevKeyF)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "eaca40e0c8b2079dc59730fa3dd94e7c4ddf4cad"}, "originalPosition": 222}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODY5MzEzOA==", "bodyText": "I think that would certainly be an interesting test hash function and test, if it's not too hard to add. Hard for me to say that it's necessarily \"worth\" it, though it would be kind of cool.", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/837#discussion_r388693138", "createdAt": "2020-03-06T03:11:41Z", "author": {"login": "alecgrieser"}, "path": "fdb-extensions/src/main/java/com/apple/foundationdb/async/RankedSet.java", "diffHunk": "@@ -246,6 +382,80 @@ public RankedSet(Subspace subspace, Executor executor) {\n         });\n     }\n \n+    /**\n+     * Removes a key from the set.\n+     * @param tc the transaction to use to access the database\n+     * @param key the key to remove\n+     * @return a future that completes to {@code true} if the set was modified, that is, if the key was present before this operation\n+     */\n+    public CompletableFuture<Boolean> remove(TransactionContext tc, byte[] key) {\n+        checkKey(key);\n+        return tc.runAsync(tr ->\n+                countCheckedKey(tr, key)\n+                        .thenCompose(count -> {\n+                            if (count == null || count <= 0) {\n+                                return READY_FALSE;\n+                            }\n+                            // This works even if the current set does not track duplicates but duplicates were added\n+                            // earlier by one that did.\n+                            final boolean duplicate = count > 1;\n+                            final int nlevels = config.getNLevels();\n+                            final List<CompletableFuture<Void>> futures = new ArrayList<>(nlevels);\n+                            for (int li = 0; li < nlevels; ++li) {\n+                                final int level = li;\n+\n+                                final CompletableFuture<Void> future;\n+\n+                                if (duplicate) {\n+                                    // Always subtract one, never clearing a key. It is possible for this to leave\n+                                    // a key with a count of zero, if duplicates were inserted with different hash functions.\n+                                    Function<byte[], Void> decrement = k -> {\n+                                        tr.mutate(MutationType.ADD, subspace.pack(Tuple.from(level, k)), encodeLong(-1));\n+                                        return null;\n+                                    };\n+                                    if (level == 0) {\n+                                        decrement.apply(key);\n+                                        future = DONE;\n+                                    } else {\n+                                        future = getPreviousKey(tr, level, key, true).thenApply(decrement);\n+                                    }\n+                                } else {\n+                                    // This could be optimized to check the hash for which levels should have this key.\n+                                    // That would require that the hash function never changes, though.\n+                                    // This allows for it to change, with the distribution perhaps getting a little uneven\n+                                    // as a result. It even allows for the hash function to return a random number.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTE2MTE5NA=="}, "originalCommit": {"oid": "d1b1b6f12150d9e94b768b4c08c62200d1d4a478"}, "originalPosition": 314}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTE0OTk5MQ==", "bodyText": "With the exception of HashFunction, I think it is the case that none of these are really a good idea to change midstream on an existing ranked set. It's probably good to document that here. Ideally, it would be good to also enforce that with some validation, but I don't think there's a way of doing that without extra latency, which we may want to avoid.", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/837#discussion_r389149991", "createdAt": "2020-03-06T21:21:04Z", "author": {"login": "alecgrieser"}, "path": "fdb-extensions/src/main/java/com/apple/foundationdb/async/RankedSet.java", "diffHunk": "@@ -143,30 +144,153 @@ private static long decodeLong(byte[] v) {\n         int hash(byte[] key);\n     }\n \n+    /**\n+     * Configuration settings for a {@link RankedSet}.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d1b1b6f12150d9e94b768b4c08c62200d1d4a478"}, "originalPosition": 27}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTE1NDAxMQ==", "bodyText": "I think having it always remove 1 is fine, especially as it's generally unsafe to have a ranked set and a multiset in the same space. I guess this (kind of) actually removes all from level 0 and then 1 from the other levels, which is maybe a little weird. I guess also if someone calls remove on a value that isn't actually in the set, it will break the invariants of the range set (in that it will subtract 1 from only the higher levels).\nI suppose it would also be kind of nice if this and the \"duplicates\" case were more similar, though it would require I think changing either the semantics of the existing sets to allow for keys to be present in only the higher levels of the ranked set or to modify the logic in the \"removes duplicates\" case to remove keys that have been zero'd out (including possibly non-empty keys in the higher levels).", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/837#discussion_r389154011", "createdAt": "2020-03-06T21:31:03Z", "author": {"login": "alecgrieser"}, "path": "fdb-extensions/src/main/java/com/apple/foundationdb/async/RankedSet.java", "diffHunk": "@@ -246,6 +382,80 @@ public RankedSet(Subspace subspace, Executor executor) {\n         });\n     }\n \n+    /**\n+     * Removes a key from the set.\n+     * @param tc the transaction to use to access the database\n+     * @param key the key to remove\n+     * @return a future that completes to {@code true} if the set was modified, that is, if the key was present before this operation\n+     */\n+    public CompletableFuture<Boolean> remove(TransactionContext tc, byte[] key) {\n+        checkKey(key);\n+        return tc.runAsync(tr ->\n+                countCheckedKey(tr, key)\n+                        .thenCompose(count -> {\n+                            if (count == null || count <= 0) {\n+                                return READY_FALSE;\n+                            }\n+                            // This works even if the current set does not track duplicates but duplicates were added\n+                            // earlier by one that did.\n+                            final boolean duplicate = count > 1;\n+                            final int nlevels = config.getNLevels();\n+                            final List<CompletableFuture<Void>> futures = new ArrayList<>(nlevels);\n+                            for (int li = 0; li < nlevels; ++li) {\n+                                final int level = li;\n+\n+                                final CompletableFuture<Void> future;\n+\n+                                if (duplicate) {\n+                                    // Always subtract one, never clearing a key. It is possible for this to leave\n+                                    // a key with a count of zero, if duplicates were inserted with different hash functions.\n+                                    Function<byte[], Void> decrement = k -> {\n+                                        tr.mutate(MutationType.ADD, subspace.pack(Tuple.from(level, k)), encodeLong(-1));\n+                                        return null;\n+                                    };\n+                                    if (level == 0) {\n+                                        decrement.apply(key);\n+                                        future = DONE;\n+                                    } else {\n+                                        future = getPreviousKey(tr, level, key, true).thenApply(decrement);\n+                                    }\n+                                } else {\n+                                    // This could be optimized to check the hash for which levels should have this key.\n+                                    // That would require that the hash function never changes, though.\n+                                    // This allows for it to change, with the distribution perhaps getting a little uneven\n+                                    // as a result. It even allows for the hash function to return a random number.\n+                                    final byte[] k = subspace.pack(Tuple.from(level, key));\n+                                    final CompletableFuture<byte[]> cf = tr.get(k);\n+\n+                                    if (level == 0) {\n+                                        future = cf.thenApply(c -> {\n+                                            if (c != null) {\n+                                                tr.clear(k);\n+                                            }\n+                                            return null;\n+                                        });\n+                                    } else {\n+                                        final CompletableFuture<byte[]> prevKeyF = getPreviousKey(tr, level, key, false);\n+                                        future = CompletableFuture.allOf(cf, prevKeyF)\n+                                                .thenApply(vignore -> {\n+                                                    final byte[] c = cf.join();\n+                                                    long countChange = -1;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTE2MDcwMQ=="}, "originalCommit": {"oid": "d1b1b6f12150d9e94b768b4c08c62200d1d4a478"}, "originalPosition": 330}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTE1NTUyNw==", "bodyText": "Thanks! That was actually fairly useful when reviewing.", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/837#discussion_r389155527", "createdAt": "2020-03-06T21:34:59Z", "author": {"login": "alecgrieser"}, "path": "fdb-extensions/src/main/java/com/apple/foundationdb/async/RankedSet.java", "diffHunk": "@@ -246,6 +382,80 @@ public RankedSet(Subspace subspace, Executor executor) {\n         });\n     }\n \n+    /**\n+     * Removes a key from the set.\n+     * @param tc the transaction to use to access the database\n+     * @param key the key to remove\n+     * @return a future that completes to {@code true} if the set was modified, that is, if the key was present before this operation\n+     */\n+    public CompletableFuture<Boolean> remove(TransactionContext tc, byte[] key) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDg1NDQ1Ng=="}, "originalCommit": {"oid": "d1b1b6f12150d9e94b768b4c08c62200d1d4a478"}, "originalPosition": 279}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTE1NjkxNw==", "bodyText": "Though I'm not sure how I feel about the randomSingleThread and randomFiveThreads tests in general (or as unit tests), it might be good to see if running them with duplicates counted and see if they find anything.\nAlso, as much time as they take, I could see there being possibly weird edge cases when building a ranked set with duplicates turned on (particularly with regard to parallelism).", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/837#discussion_r389156917", "createdAt": "2020-03-06T21:38:26Z", "author": {"login": "alecgrieser"}, "path": "fdb-extensions/src/test/java/com/apple/foundationdb/async/RankedSetTest.java", "diffHunk": "@@ -118,6 +119,49 @@ private void basicOperations(RankedSet.HashFunction firstHashFunction, RankedSet\n                 boolean wasOld = rs.remove(tr, k).join();\n                 assertTrue(wasOld);\n             }\n+            assertFalse(rs.remove(tr, keys[20]).join());\n+            return null;\n+        });\n+    }\n+\n+    @Test\n+    public void duplicates() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d1b1b6f12150d9e94b768b4c08c62200d1d4a478"}, "originalPosition": 45}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTE1ODc0Nw==", "bodyText": "Should this allow going from not setting RANK_COUNT_DUPLICATES to setting it to false, or is that already allowed somehow?\nI also suppose that the TimeWindowLeaderboardMaintainerFactory could benefit from similar logic here (but I guess not for n-levels). I suppose it also isn't super necessary, though, as the default is to reject any option changes, which is conservative.", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/837#discussion_r389158747", "createdAt": "2020-03-06T21:42:53Z", "author": {"login": "alecgrieser"}, "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/provider/foundationdb/indexes/RankIndexMaintainerFactory.java", "diffHunk": "@@ -65,24 +65,24 @@ public void validate(@Nonnull MetaDataValidator metaDataValidator) {\n \n             @Override\n             public void validateChangedOptions(@Nonnull Index oldIndex, @Nonnull Set<String> changedOptions) {\n-                // Allow changing from unspecified to the default (or vice versa), but not otherwise.\n-                if (changedOptions.contains(IndexOptions.RANK_NLEVELS)) {\n-                    int oldLevels = RankedSetIndexHelper.getNLevels(oldIndex);\n-                    int newLevels = RankedSetIndexHelper.getNLevels(index);\n-                    if (oldLevels != newLevels) {\n-                        throw new MetaDataException(\"rank levels changed\",\n-                                LogMessageKeys.INDEX_NAME, index.getName());\n+                if (!changedOptions.isEmpty()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d1b1b6f12150d9e94b768b4c08c62200d1d4a478"}, "originalPosition": 11}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTE2MjM0NA==", "bodyText": "I'm not sure if we care, but this isn't thread safe (in that two threads can modify and set the number of levels to different values). I think the alternative would be to either copy the builder before setting the levels or create a new one from the index and the leaderboard (for the levels) from scratch each time. (I think there are other things about using ranked sets that are also unsafe, but I think this one is also easy to fix, unlike the others, so might be worth doing.)", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/837#discussion_r389162344", "createdAt": "2020-03-06T21:52:58Z", "author": {"login": "alecgrieser"}, "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/provider/foundationdb/leaderboard/TimeWindowLeaderboardIndexMaintainer.java", "diffHunk": "@@ -197,8 +197,9 @@ protected void saveSubDirectory(@Nonnull TimeWindowLeaderboardSubDirectory subdi\n                 }\n                 final Subspace extraSubspace = getSecondarySubspace();\n                 final Subspace leaderboardSubspace = extraSubspace.subspace(leaderboard.getSubspaceKey());\n+                final RankedSet.Config config = configBuilder.setNLevels(leaderboard.getNLevels()).build();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d1b1b6f12150d9e94b768b4c08c62200d1d4a478"}, "originalPosition": 18}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTE3MzA5OA==", "bodyText": "I, um, am not sure this comment is true, or at least doesn't seem right given one of the comments I made in the remove function for RankedSet. On the other hand, we do test write only indexes as part of index builds, so I'm not entirely sure. (Understanding that this is a pre-existing comment that I probably wrote.)", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/837#discussion_r389173098", "createdAt": "2020-03-06T22:23:33Z", "author": {"login": "alecgrieser"}, "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/provider/foundationdb/indexes/RankedSetIndexHelper.java", "diffHunk": "@@ -233,38 +244,41 @@ private static Number extractRank(int groupPrefixSize, @Nullable Tuple maybeRank\n     @Nonnull\n     public static CompletableFuture<Void> updateRankedSet(@Nonnull IndexMaintainerState state,\n                                                           @Nonnull Subspace rankSubspace,\n-                                                          @Nonnull RankedSet.HashFunction hashFunction,\n-                                                          int nlevels,\n+                                                          @Nonnull RankedSet.Config config,\n                                                           @Nonnull Tuple valueKey,\n                                                           @Nonnull Tuple scoreKey,\n                                                           boolean remove) {\n-        final RankedSet rankedSet = new InstrumentedRankedSet(state, rankSubspace, hashFunction, nlevels);\n+        final RankedSet rankedSet = new InstrumentedRankedSet(state, rankSubspace, config);\n         final byte[] score = scoreKey.pack();\n         CompletableFuture<Void> result = init(state, rankedSet).thenCompose(v -> {\n             if (remove) {\n-                // If no one else has this score, remove from ranked set.\n-                return state.transaction.getRange(state.indexSubspace.range(valueKey)).iterator().onHasNext().thenCompose(hasNext -> {\n-                    if (hasNext) {\n-                        return AsyncUtil.DONE;\n-                    } else {\n-                        return rankedSet.remove(state.transaction, score).thenApply(exists -> {\n-                            // It is okay if the score isn't in the ranked set yet if the index is\n-                            // write only because this means that the score just hasn't yet\n-                            // been added by some record. We still want the conflict ranges, though.\n-                            if (!exists && !state.store.isIndexWriteOnly(state.index)) {\n-                                throw new RecordCoreException(\"Score was not present in ranked set.\");\n-                            }\n-                            return null;\n-                        });\n-                    }\n-                });\n+                if (config.isCountDuplicates()) {\n+                    // Decrement count and possibly remove.\n+                    return removeFromRankedSet(state, rankedSet, score);\n+                } else {\n+                    // If no one else has this score, remove from ranked set.\n+                    return state.transaction.getRange(state.indexSubspace.range(valueKey)).iterator().onHasNext()\n+                            .thenCompose(hasNext -> hasNext ? AsyncUtil.DONE : removeFromRankedSet(state, rankedSet, score));\n+                }\n             } else {\n                 return rankedSet.add(state.transaction, score).thenApply(added -> null);\n             }\n         });\n         return state.store.instrument(Events.RANKED_SET_UPDATE, result);\n     }\n \n+    private static CompletableFuture<Void> removeFromRankedSet(@Nonnull IndexMaintainerState state, @Nonnull RankedSet rankedSet, @Nonnull byte[] score) {\n+        return rankedSet.remove(state.transaction, score).thenApply(exists -> {\n+            // It is okay if the score isn't in the ranked set yet if the index is\n+            // write only because this means that the score just hasn't yet\n+            // been added by some record. We still want the conflict ranges, though.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d1b1b6f12150d9e94b768b4c08c62200d1d4a478"}, "originalPosition": 103}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "d1b1b6f12150d9e94b768b4c08c62200d1d4a478", "author": {"user": {"login": "MMcM", "name": "Mike McMahon"}}, "url": "https://github.com/FoundationDB/fdb-record-layer/commit/d1b1b6f12150d9e94b768b4c08c62200d1d4a478", "committedDate": "2020-02-26T22:39:39Z", "message": "Resolves #806: Rank index could have option for how to handle ties"}, "afterCommit": {"oid": "831639ef7eee7f50e160633c895c378b66e2dcdf", "author": {"user": {"login": "MMcM", "name": "Mike McMahon"}}, "url": "https://github.com/FoundationDB/fdb-record-layer/commit/831639ef7eee7f50e160633c895c378b66e2dcdf", "committedDate": "2020-03-09T18:30:38Z", "message": "Instead of getKey() or getRange() with two KeySelector derived from the target,\ndo a reverse range read limited by the level start.\nThis is no more expensive and adds another safety check."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzcxNjIzMTg2", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/837#pullrequestreview-371623186", "createdAt": "2020-03-10T01:09:50Z", "commit": {"oid": "d15c7b81796741126f4bda96716ba744fa95f2ec"}, "state": "COMMENTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMFQwMTowOTo1MFrOFz-Vig==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMFQwMToxNTozNVrOFz-a2Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDA0MzAxOA==", "bodyText": "I see now that as we read the count and, if the count is 1, just remove the key, that this is no longer something to be worried about, though I suppose one could wist hopefully for a data structure with fewer conflicts (e.g., no conflicts when adding or removing the same key). It....might be possible, but it probably requires additional fanciness like conflicts in same \"shadow realm\", and it can be done later if we decide we really want it.", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/837#discussion_r390043018", "createdAt": "2020-03-10T01:09:50Z", "author": {"login": "alecgrieser"}, "path": "fdb-extensions/src/main/java/com/apple/foundationdb/async/RankedSet.java", "diffHunk": "@@ -356,37 +396,59 @@ public RankedSet(Subspace subspace, Executor executor) {\n                             if (count == null || count <= 0) {\n                                 return READY_FALSE;\n                             }\n+                            // This works even if the current set does not track duplicates but duplicates were added\n+                            // earlier by one that did.\n+                            final boolean duplicate = count > 1;\n                             final int nlevels = config.getNLevels();\n                             final List<CompletableFuture<Void>> futures = new ArrayList<>(nlevels);\n                             for (int li = 0; li < nlevels; ++li) {\n                                 final int level = li;\n-                                // This could be optimized to check the hash for which levels should have this key.\n-                                final byte[] k = subspace.pack(Tuple.from(level, key));\n \n                                 final CompletableFuture<Void> future;\n-                                final CompletableFuture<byte[]> cf = tr.get(k);\n \n-                                if (level == 0) {\n-                                    future = cf.thenApply(c -> {\n-                                        if (c != null) {\n-                                            tr.clear(k);\n-                                        }\n+                                if (duplicate) {\n+                                    // Always subtract one, never clearing a key. It is possible for this to leave\n+                                    // a key with a count of zero, if duplicates were inserted with different hash functions.\n+                                    Function<byte[], Void> decrement = k -> {\n+                                        tr.mutate(MutationType.ADD, subspace.pack(Tuple.from(level, k)), encodeLong(-1));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODY1MjE3Ng=="}, "originalCommit": {"oid": "eaca40e0c8b2079dc59730fa3dd94e7c4ddf4cad"}, "originalPosition": 182}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDA0NDAwNA==", "bodyText": "It seems weird (though perhaps) harmless that this re-reads the key for level zero rather than, say, just clearing the key. For one, it almost gives the impression that the key could be null at this point...which seems wrong.", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/837#discussion_r390044004", "createdAt": "2020-03-10T01:14:03Z", "author": {"login": "alecgrieser"}, "path": "fdb-extensions/src/main/java/com/apple/foundationdb/async/RankedSet.java", "diffHunk": "@@ -220,32 +391,110 @@ public RankedSet(Subspace subspace, Executor executor) {\n                 }));\n     }\n \n-    protected CompletableFuture<Void> addLevelZeroKey(Transaction tr, byte[] key, int level) {\n-        tr.set(subspace.pack(Tuple.from(level, key)), encodeLong(1));\n+    protected CompletableFuture<Void> addLevelZeroKey(Transaction tr, byte[] key, int level, boolean increment) {\n+        final byte[] k = subspace.pack(Tuple.from(level, key));\n+        final byte[] v = encodeLong(1);\n+        if (increment) {\n+            tr.mutate(MutationType.ADD, k, v);\n+        } else {\n+            tr.set(k, v);\n+        }\n         return DONE;\n     }\n \n-    protected CompletableFuture<Void> addIncrementLevelKey(Transaction tr, byte[] key, int level) {\n-        return getPreviousKey(tr, level, key).thenApply(prevKey -> {\n+    protected CompletableFuture<Void> addIncrementLevelKey(Transaction tr, byte[] key, int level, boolean orEqual) {\n+        return getPreviousKey(tr, level, key, orEqual).thenApply(prevKey -> {\n             tr.mutate(MutationType.ADD, subspace.pack(Tuple.from(level, prevKey)), encodeLong(1));\n             return null;\n         });\n     }\n \n     protected CompletableFuture<Void> addInsertLevelKey(Transaction tr, byte[] key, int level) {\n-        return getPreviousKey(tr, level, key).thenCompose(prevKey -> {\n+        return getPreviousKey(tr, level, key, false).thenCompose(prevKey -> {\n             CompletableFuture<Long> prevCount = tr.get(subspace.pack(Tuple.from(level, prevKey))).thenApply(RankedSet::decodeLong);\n             CompletableFuture<Long> newPrevCount = countRange(tr, level - 1, prevKey, key);\n-            return CompletableFuture.allOf(prevCount, newPrevCount)\n-                    .thenApply(vignore2 -> {\n-                        long count = prevCount.join() - newPrevCount.join() + 1;\n-                        tr.set(subspace.pack(Tuple.from(level, prevKey)), encodeLong(newPrevCount.join()));\n-                        tr.set(subspace.pack(Tuple.from(level, key)), encodeLong(count));\n-                        return null;\n-                    });\n+            return prevCount.thenAcceptBoth(newPrevCount, (prev, newPrev) -> {\n+                long count = prev - newPrev + 1;\n+                tr.set(subspace.pack(Tuple.from(level, prevKey)), encodeLong(newPrev));\n+                tr.set(subspace.pack(Tuple.from(level, key)), encodeLong(count));\n+            });\n         });\n     }\n \n+    /**\n+     * Removes a key from the set.\n+     * @param tc the transaction to use to access the database\n+     * @param key the key to remove\n+     * @return a future that completes to {@code true} if the set was modified, that is, if the key was present before this operation\n+     */\n+    public CompletableFuture<Boolean> remove(TransactionContext tc, byte[] key) {\n+        checkKey(key);\n+        return tc.runAsync(tr ->\n+                countCheckedKey(tr, key)\n+                        .thenCompose(count -> {\n+                            if (count == null || count <= 0) {\n+                                return READY_FALSE;\n+                            }\n+                            // This works even if the current set does not track duplicates but duplicates were added\n+                            // earlier by one that did.\n+                            final boolean duplicate = count > 1;\n+                            final int nlevels = config.getNLevels();\n+                            final List<CompletableFuture<Void>> futures = new ArrayList<>(nlevels);\n+                            for (int li = 0; li < nlevels; ++li) {\n+                                final int level = li;\n+\n+                                final CompletableFuture<Void> future;\n+\n+                                if (duplicate) {\n+                                    // Always subtract one, never clearing a level count key.\n+                                    // Concurrent requests both subtracting one when the count is two will conflict\n+                                    // on the level zero key, which was read to detect that this is a duplicate.\n+                                    // So it should not be possible for a count to go to zero.\n+                                    Function<byte[], Void> decrement = k -> {\n+                                        tr.mutate(MutationType.ADD, subspace.pack(Tuple.from(level, k)), encodeLong(-1));\n+                                        return null;\n+                                    };\n+                                    if (level == 0) {\n+                                        decrement.apply(key);\n+                                        future = DONE;\n+                                    } else {\n+                                        future = getPreviousKey(tr, level, key, true).thenApply(decrement);\n+                                    }\n+                                } else {\n+                                    // This could be optimized to check the hash for which levels should have this key.\n+                                    // That would require that the hash function never changes, though.\n+                                    // This allows for it to change, with the distribution perhaps getting a little uneven\n+                                    // as a result. It even allows for the hash function to return a random number.\n+                                    // It also further guarantees that counts never go to zero.\n+                                    final byte[] k = subspace.pack(Tuple.from(level, key));\n+                                    final CompletableFuture<byte[]> cf = tr.get(k);\n+\n+                                    if (level == 0) {\n+                                        future = cf.thenApply(c -> {\n+                                            if (c != null) {\n+                                                tr.clear(k);\n+                                            }\n+                                            return null;\n+                                        });", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d15c7b81796741126f4bda96716ba744fa95f2ec"}, "originalPosition": 401}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDA0NDM3Nw==", "bodyText": "I suppose rather than decrementing, this could explicitly set the key to encodeLong(count - 1). I think the only thing this would do is underscore that we aren't actually making use of the ability of atomic operations to allow for concurrent updates to the level 0 keys.", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/837#discussion_r390044377", "createdAt": "2020-03-10T01:15:35Z", "author": {"login": "alecgrieser"}, "path": "fdb-extensions/src/main/java/com/apple/foundationdb/async/RankedSet.java", "diffHunk": "@@ -220,32 +391,110 @@ public RankedSet(Subspace subspace, Executor executor) {\n                 }));\n     }\n \n-    protected CompletableFuture<Void> addLevelZeroKey(Transaction tr, byte[] key, int level) {\n-        tr.set(subspace.pack(Tuple.from(level, key)), encodeLong(1));\n+    protected CompletableFuture<Void> addLevelZeroKey(Transaction tr, byte[] key, int level, boolean increment) {\n+        final byte[] k = subspace.pack(Tuple.from(level, key));\n+        final byte[] v = encodeLong(1);\n+        if (increment) {\n+            tr.mutate(MutationType.ADD, k, v);\n+        } else {\n+            tr.set(k, v);\n+        }\n         return DONE;\n     }\n \n-    protected CompletableFuture<Void> addIncrementLevelKey(Transaction tr, byte[] key, int level) {\n-        return getPreviousKey(tr, level, key).thenApply(prevKey -> {\n+    protected CompletableFuture<Void> addIncrementLevelKey(Transaction tr, byte[] key, int level, boolean orEqual) {\n+        return getPreviousKey(tr, level, key, orEqual).thenApply(prevKey -> {\n             tr.mutate(MutationType.ADD, subspace.pack(Tuple.from(level, prevKey)), encodeLong(1));\n             return null;\n         });\n     }\n \n     protected CompletableFuture<Void> addInsertLevelKey(Transaction tr, byte[] key, int level) {\n-        return getPreviousKey(tr, level, key).thenCompose(prevKey -> {\n+        return getPreviousKey(tr, level, key, false).thenCompose(prevKey -> {\n             CompletableFuture<Long> prevCount = tr.get(subspace.pack(Tuple.from(level, prevKey))).thenApply(RankedSet::decodeLong);\n             CompletableFuture<Long> newPrevCount = countRange(tr, level - 1, prevKey, key);\n-            return CompletableFuture.allOf(prevCount, newPrevCount)\n-                    .thenApply(vignore2 -> {\n-                        long count = prevCount.join() - newPrevCount.join() + 1;\n-                        tr.set(subspace.pack(Tuple.from(level, prevKey)), encodeLong(newPrevCount.join()));\n-                        tr.set(subspace.pack(Tuple.from(level, key)), encodeLong(count));\n-                        return null;\n-                    });\n+            return prevCount.thenAcceptBoth(newPrevCount, (prev, newPrev) -> {\n+                long count = prev - newPrev + 1;\n+                tr.set(subspace.pack(Tuple.from(level, prevKey)), encodeLong(newPrev));\n+                tr.set(subspace.pack(Tuple.from(level, key)), encodeLong(count));\n+            });\n         });\n     }\n \n+    /**\n+     * Removes a key from the set.\n+     * @param tc the transaction to use to access the database\n+     * @param key the key to remove\n+     * @return a future that completes to {@code true} if the set was modified, that is, if the key was present before this operation\n+     */\n+    public CompletableFuture<Boolean> remove(TransactionContext tc, byte[] key) {\n+        checkKey(key);\n+        return tc.runAsync(tr ->\n+                countCheckedKey(tr, key)\n+                        .thenCompose(count -> {\n+                            if (count == null || count <= 0) {\n+                                return READY_FALSE;\n+                            }\n+                            // This works even if the current set does not track duplicates but duplicates were added\n+                            // earlier by one that did.\n+                            final boolean duplicate = count > 1;\n+                            final int nlevels = config.getNLevels();\n+                            final List<CompletableFuture<Void>> futures = new ArrayList<>(nlevels);\n+                            for (int li = 0; li < nlevels; ++li) {\n+                                final int level = li;\n+\n+                                final CompletableFuture<Void> future;\n+\n+                                if (duplicate) {\n+                                    // Always subtract one, never clearing a level count key.\n+                                    // Concurrent requests both subtracting one when the count is two will conflict\n+                                    // on the level zero key, which was read to detect that this is a duplicate.\n+                                    // So it should not be possible for a count to go to zero.\n+                                    Function<byte[], Void> decrement = k -> {\n+                                        tr.mutate(MutationType.ADD, subspace.pack(Tuple.from(level, k)), encodeLong(-1));\n+                                        return null;\n+                                    };\n+                                    if (level == 0) {\n+                                        decrement.apply(key);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d15c7b81796741126f4bda96716ba744fa95f2ec"}, "originalPosition": 381}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzcxNjI5NDM3", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/837#pullrequestreview-371629437", "createdAt": "2020-03-10T01:33:41Z", "commit": {"oid": "d15c7b81796741126f4bda96716ba744fa95f2ec"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMFQwMTozMzo0MVrOFz-rEA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMFQwMTozMzo0MVrOFz-rEA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDA0ODUyOA==", "bodyText": "I somehow missed the part of the code in RankedSet that checks to make sure that the score isn't zero before decrementing. I am now more confident in this comment in at least the case of not duplicate tracking (so that's good).\nI'm trying to think, however, if there are pathologies in the count duplicates case. I think the answer is \"yes\" because adding to a ranked set index with duplicate counting isn't idempotent. In particular:\n\nImagine having two records with a rank index on field foo, both of which have the value foo = bar.\nAn index build indexes the first record. Now the count corresponding to bar in the foo rank index is 1.\nSomeone removes the second record. Now the count corresponding to bar in the foo rank index is 0 (i.e., it is removed from the ranked set).\nThe index build completes, never having indexed the second record.\n\nSo now bar has an incorrect rank. This is somewhat of a worst case in that bar is missing entirely from the ranked set, but I think one can also be in a position where the rank is wrong, but not removed entirely.\nI think this can be fixed by checking if the record is in the built range and only updating the ranked set if it is. It also seems to me like this would be safe for the regular ranked set, though perhaps would induce more conflicts.", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/837#discussion_r390048528", "createdAt": "2020-03-10T01:33:41Z", "author": {"login": "alecgrieser"}, "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/provider/foundationdb/indexes/RankedSetIndexHelper.java", "diffHunk": "@@ -233,38 +244,41 @@ private static Number extractRank(int groupPrefixSize, @Nullable Tuple maybeRank\n     @Nonnull\n     public static CompletableFuture<Void> updateRankedSet(@Nonnull IndexMaintainerState state,\n                                                           @Nonnull Subspace rankSubspace,\n-                                                          @Nonnull RankedSet.HashFunction hashFunction,\n-                                                          int nlevels,\n+                                                          @Nonnull RankedSet.Config config,\n                                                           @Nonnull Tuple valueKey,\n                                                           @Nonnull Tuple scoreKey,\n                                                           boolean remove) {\n-        final RankedSet rankedSet = new InstrumentedRankedSet(state, rankSubspace, hashFunction, nlevels);\n+        final RankedSet rankedSet = new InstrumentedRankedSet(state, rankSubspace, config);\n         final byte[] score = scoreKey.pack();\n         CompletableFuture<Void> result = init(state, rankedSet).thenCompose(v -> {\n             if (remove) {\n-                // If no one else has this score, remove from ranked set.\n-                return state.transaction.getRange(state.indexSubspace.range(valueKey)).iterator().onHasNext().thenCompose(hasNext -> {\n-                    if (hasNext) {\n-                        return AsyncUtil.DONE;\n-                    } else {\n-                        return rankedSet.remove(state.transaction, score).thenApply(exists -> {\n-                            // It is okay if the score isn't in the ranked set yet if the index is\n-                            // write only because this means that the score just hasn't yet\n-                            // been added by some record. We still want the conflict ranges, though.\n-                            if (!exists && !state.store.isIndexWriteOnly(state.index)) {\n-                                throw new RecordCoreException(\"Score was not present in ranked set.\");\n-                            }\n-                            return null;\n-                        });\n-                    }\n-                });\n+                if (config.isCountDuplicates()) {\n+                    // Decrement count and possibly remove.\n+                    return removeFromRankedSet(state, rankedSet, score);\n+                } else {\n+                    // If no one else has this score, remove from ranked set.\n+                    return state.transaction.getRange(state.indexSubspace.range(valueKey)).iterator().onHasNext()\n+                            .thenCompose(hasNext -> hasNext ? AsyncUtil.DONE : removeFromRankedSet(state, rankedSet, score));\n+                }\n             } else {\n                 return rankedSet.add(state.transaction, score).thenApply(added -> null);\n             }\n         });\n         return state.store.instrument(Events.RANKED_SET_UPDATE, result);\n     }\n \n+    private static CompletableFuture<Void> removeFromRankedSet(@Nonnull IndexMaintainerState state, @Nonnull RankedSet rankedSet, @Nonnull byte[] score) {\n+        return rankedSet.remove(state.transaction, score).thenApply(exists -> {\n+            // It is okay if the score isn't in the ranked set yet if the index is\n+            // write only because this means that the score just hasn't yet\n+            // been added by some record. We still want the conflict ranges, though.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTE3MzA5OA=="}, "originalCommit": {"oid": "d1b1b6f12150d9e94b768b4c08c62200d1d4a478"}, "originalPosition": 103}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzczODg1OTM0", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/837#pullrequestreview-373885934", "createdAt": "2020-03-12T20:41:37Z", "commit": {"oid": "75f78e7443eb79ffd949efbaa121e2a99b65ac43"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d36de3ca1c6bc9128bbfc15091b120cceb3515fe", "author": {"user": {"login": "MMcM", "name": "Mike McMahon"}}, "url": "https://github.com/FoundationDB/fdb-record-layer/commit/d36de3ca1c6bc9128bbfc15091b120cceb3515fe", "committedDate": "2020-03-12T22:19:49Z", "message": "Move add and remove next to one another"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f8c313c178b594c6496e181f0a2d327d5ae39e03", "author": {"user": {"login": "MMcM", "name": "Mike McMahon"}}, "url": "https://github.com/FoundationDB/fdb-record-layer/commit/f8c313c178b594c6496e181f0a2d327d5ae39e03", "committedDate": "2020-03-12T22:19:49Z", "message": "Change an internal helper to return count"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9a3e7483bb97e3cc6a2c665e2d76f049d9e74840", "author": {"user": {"login": "MMcM", "name": "Mike McMahon"}}, "url": "https://github.com/FoundationDB/fdb-record-layer/commit/9a3e7483bb97e3cc6a2c665e2d76f049d9e74840", "committedDate": "2020-03-12T22:19:49Z", "message": "Move RankedSet settings out into own Config class"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2123ef39a69749fc3a8a3e4252b085ce90dfdb7c", "author": {"user": {"login": "MMcM", "name": "Mike McMahon"}}, "url": "https://github.com/FoundationDB/fdb-record-layer/commit/2123ef39a69749fc3a8a3e4252b085ce90dfdb7c", "committedDate": "2020-03-12T22:19:49Z", "message": "Add countDuplicates option to RankedSet."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "594e63daf5a561c6c895231a38e8da68ab23e57a", "author": {"user": {"login": "MMcM", "name": "Mike McMahon"}}, "url": "https://github.com/FoundationDB/fdb-record-layer/commit/594e63daf5a561c6c895231a38e8da68ab23e57a", "committedDate": "2020-03-12T22:19:49Z", "message": "Resolves #806: Rank index could have option for how to handle ties"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6b7d3bc285babc4f4b0271b28bb8fb916f444f13", "author": {"user": {"login": "MMcM", "name": "Mike McMahon"}}, "url": "https://github.com/FoundationDB/fdb-record-layer/commit/6b7d3bc285babc4f4b0271b28bb8fb916f444f13", "committedDate": "2020-03-12T22:19:49Z", "message": "Add a random hash function to test that this works.\nClarify some comments."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a1106be02030c02571b487882e913c76a34128d1", "author": {"user": {"login": "MMcM", "name": "Mike McMahon"}}, "url": "https://github.com/FoundationDB/fdb-record-layer/commit/a1106be02030c02571b487882e913c76a34128d1", "committedDate": "2020-03-12T22:19:49Z", "message": "Stop sharing a ConfigBuilder, since it isn't thread safe"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b09aff2068a957279ffd567517f6d5e7bbb8a9e6", "author": {"user": {"login": "MMcM", "name": "Mike McMahon"}}, "url": "https://github.com/FoundationDB/fdb-record-layer/commit/b09aff2068a957279ffd567517f6d5e7bbb8a9e6", "committedDate": "2020-03-12T22:19:49Z", "message": "Instead of getKey() or getRange() with two KeySelector derived from the target,\ndo a reverse range read limited by the level start.\nThis is no more expensive and adds another safety check."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8de90e4d486fe93575f2c7343b2c28084f1eacbf", "author": {"user": {"login": "MMcM", "name": "Mike McMahon"}}, "url": "https://github.com/FoundationDB/fdb-record-layer/commit/8de90e4d486fe93575f2c7343b2c28084f1eacbf", "committedDate": "2020-03-12T22:19:49Z", "message": "Switch from allOf to thenAcceptBoth"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "dab2979c2d0e5b73136846a14351f40f62846a83", "author": {"user": {"login": "MMcM", "name": "Mike McMahon"}}, "url": "https://github.com/FoundationDB/fdb-record-layer/commit/dab2979c2d0e5b73136846a14351f40f62846a83", "committedDate": "2020-03-12T22:19:49Z", "message": "Simplify some futures"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "122363674095f5fd98309165e4c7c6a800376ddb", "author": {"user": {"login": "MMcM", "name": "Mike McMahon"}}, "url": "https://github.com/FoundationDB/fdb-record-layer/commit/122363674095f5fd98309165e4c7c6a800376ddb", "committedDate": "2020-03-12T22:19:49Z", "message": "Add a random test with duplicates, too"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "54fc11ff361d4c6cfe56bd29f742459021fc329e", "author": {"user": {"login": "MMcM", "name": "Mike McMahon"}}, "url": "https://github.com/FoundationDB/fdb-record-layer/commit/54fc11ff361d4c6cfe56bd29f742459021fc329e", "committedDate": "2020-03-12T22:19:58Z", "message": "Not idempotent if counting duplicates"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "75f78e7443eb79ffd949efbaa121e2a99b65ac43", "author": {"user": {"login": "MMcM", "name": "Mike McMahon"}}, "url": "https://github.com/FoundationDB/fdb-record-layer/commit/75f78e7443eb79ffd949efbaa121e2a99b65ac43", "committedDate": "2020-03-10T02:36:18Z", "message": "Add a random test with duplicates, too"}, "afterCommit": {"oid": "54fc11ff361d4c6cfe56bd29f742459021fc329e", "author": {"user": {"login": "MMcM", "name": "Mike McMahon"}}, "url": "https://github.com/FoundationDB/fdb-record-layer/commit/54fc11ff361d4c6cfe56bd29f742459021fc329e", "committedDate": "2020-03-12T22:19:58Z", "message": "Not idempotent if counting duplicates"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzc1NjgwMzM1", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/837#pullrequestreview-375680335", "createdAt": "2020-03-17T01:19:45Z", "commit": {"oid": "54fc11ff361d4c6cfe56bd29f742459021fc329e"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2777, "cost": 1, "resetAt": "2021-11-01T14:20:25Z"}}}