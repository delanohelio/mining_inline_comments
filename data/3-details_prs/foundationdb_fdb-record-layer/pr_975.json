{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDM2MDYzMzc4", "number": 975, "title": "Fixes #974: OrElseCursor doesn't properly support continuations.", "bodyText": "Use a new structured continuation object and protobuf serialization to record the complete state of the OrElseCursor, including which branch was chosen. Rewrite OrElseCursor's logic in a simpler state-machine style, which makes it easy to resume the cursor before it has made a decision about which branch to take.\nTo avoid problems like we saw with the FlatMapPipelinedCursor's continuations, deprecate the RecordCursor.orElse() fluent method and replace it with a static method that interprets the continuation.\nBecause this changes the continuation format, this is a breaking change.", "createdAt": "2020-06-17T19:55:56Z", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/975", "merged": true, "mergeCommit": {"oid": "9eb96fcb145d5b7b12f498077e8d271ae84014e4"}, "closed": true, "closedAt": "2020-06-17T22:18:00Z", "author": {"login": "nschiefer"}, "timelineItems": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcsQQmpAFqTQzMjc0NDEwNg==", "endCursor": "Y3Vyc29yOnYyOpPPAAABcsRE0cAFqTQzMjgwMzE0Ng==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMyNzQ0MTA2", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/975#pullrequestreview-432744106", "createdAt": "2020-06-17T20:20:19Z", "commit": {"oid": "8fbb4025a8590c561b511e5daa799d1f86241c11"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xN1QyMDoyMDoxOVrOGlV66Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xN1QyMDo1MToyNlrOGlW-Ew==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTgwOTY0MQ==", "bodyText": "These two new methods could probably use javadoc comments", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/975#discussion_r441809641", "createdAt": "2020-06-17T20:20:19Z", "author": {"login": "alecgrieser"}, "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/RecordCursor.java", "diffHunk": "@@ -781,12 +781,23 @@ public boolean isLimitReached() {\n      * @param func function to be called if the cursor is empty to give another source of records\n      * @return a new cursor that returns the same records as this cursor \n      * or the result of {@code func} if this cursor does not produce any records\n+     * @deprecated because it does not support continuations and is easy to misuse.\n+     *             Use {@link #flatMapPipelined(Function, BiFunction, byte[], int)} instead.\n      */\n+    @API(API.Status.DEPRECATED)\n+    @Deprecated\n     @Nonnull\n     default RecordCursor<T> orElse(@Nonnull Function<Executor, RecordCursor<T>> func) {\n         return new OrElseCursor<>(this, func);\n     }\n \n+    @Nonnull", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8fbb4025a8590c561b511e5daa799d1f86241c11"}, "originalPosition": 14}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTgxMDQ2NQ==", "bodyText": "Given that this is private anyway, is there a reason to not use the proto-generated enum?", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/975#discussion_r441810465", "createdAt": "2020-06-17T20:21:58Z", "author": {"login": "alecgrieser"}, "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/cursors/OrElseCursor.java", "diffHunk": "@@ -154,4 +214,76 @@ public boolean accept(@Nonnull RecordCursorVisitor visitor) {\n         }\n         return visitor.visitLeave(this);\n     }\n+\n+    private enum State {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8fbb4025a8590c561b511e5daa799d1f86241c11"}, "originalPosition": 137}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTgxMTQ1Mg==", "bodyText": "Should this constructor be deprecated, too?", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/975#discussion_r441811452", "createdAt": "2020-06-17T20:23:57Z", "author": {"login": "alecgrieser"}, "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/cursors/OrElseCursor.java", "diffHunk": "@@ -57,7 +65,44 @@\n     public OrElseCursor(@Nonnull RecordCursor<T> inner, @Nonnull Function<Executor, RecordCursor<T>> func) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8fbb4025a8590c561b511e5daa799d1f86241c11"}, "originalPosition": 34}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTgxMTc0Ng==", "bodyText": "This feels like it should be INTERNAL, but I could be wrong", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/975#discussion_r441811746", "createdAt": "2020-06-17T20:24:33Z", "author": {"login": "alecgrieser"}, "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/cursors/OrElseCursor.java", "diffHunk": "@@ -57,7 +65,44 @@\n     public OrElseCursor(@Nonnull RecordCursor<T> inner, @Nonnull Function<Executor, RecordCursor<T>> func) {\n         this.inner = inner;\n         this.func = func;\n-        this.first = true;\n+        this.state = State.UNDECIDED;\n+    }\n+\n+    public OrElseCursor(@Nonnull Function<byte[], ? extends RecordCursor<T>> innerFunc,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8fbb4025a8590c561b511e5daa799d1f86241c11"}, "originalPosition": 41}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTgxNjk1NQ==", "bodyText": "Okay, trying to think about how this interacts with in-band vs out of band limits. I...think it's right that if the child hits an in-band limit (which would only happen if, say, one had a filter over a row limited cursor, and the inner child of that filter stopped hit its limit prior to it no longer returning results) without hitting a value, then it goes down the else path, but I'm not actually sure if that's right. I guess it's consistent with the prior behavior.", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/975#discussion_r441816955", "createdAt": "2020-06-17T20:34:22Z", "author": {"login": "alecgrieser"}, "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/cursors/OrElseCursor.java", "diffHunk": "@@ -66,22 +111,37 @@ public OrElseCursor(@Nonnull RecordCursor<T> inner, @Nonnull Function<Executor,\n         if (nextResult != null && !nextResult.hasNext()) {\n             return CompletableFuture.completedFuture(nextResult);\n         }\n-        if (first) {\n-            return inner.onNext().thenCompose(result -> {\n-                first = false;\n-                if (result.hasNext() || result.getNoNextReason().isOutOfBand()) {\n-                    // Either have result or do not know whether to select else yet or not.\n-                    return CompletableFuture.completedFuture(result);\n-                } else {\n-                    other = func.apply(getExecutor());\n-                    return other.onNext();\n-                }\n-            }).thenApply(this::postProcess);\n-        }\n-        if (other != null) {\n-            return other.onNext().thenApply(this::postProcess);\n+        final CompletableFuture<RecordCursorResult<T>> innerFuture;\n+        switch (state) {\n+            case USE_INNER:\n+                innerFuture = inner.onNext();\n+                break;\n+            case USE_OTHER:\n+                innerFuture = other.onNext();\n+                break;\n+            case UNDECIDED:\n+                innerFuture = inner.onNext().thenCompose(result -> {\n+                    if (result.hasNext()) {\n+                        // Inner cursor has produced a value, so we take the inner branch.\n+                        state = State.USE_INNER;\n+                        return CompletableFuture.completedFuture(result);\n+                    } else if (result.getNoNextReason().isOutOfBand()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8fbb4025a8590c561b511e5daa799d1f86241c11"}, "originalPosition": 111}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTgyMzg4Mg==", "bodyText": "Given that the continuations for the cursors from the JoinedRecordPlan won't be valid any more, it seems like the planHash on this class should change (at least--perhaps ideally--if there are any outer joined types in joinedTypes).", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/975#discussion_r441823882", "createdAt": "2020-06-17T20:45:43Z", "author": {"login": "alecgrieser"}, "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/synthetic/JoinedRecordPlan.java", "diffHunk": "@@ -222,10 +222,14 @@ public JoinedRecordPlan(@Nonnull JoinedRecordType joinedRecordType, @Nonnull Lis\n \n     private RecordCursor<EvaluationContext> query(int depth, @Nonnull FDBRecordStore store, @Nonnull EvaluationContext context,\n                                                   @Nullable byte[] continuation, @Nonnull ExecuteProperties executeProperties) {\n-        RecordCursor<FDBQueriedRecord<Message>> records = queries.get(depth).execute(store, context, continuation, executeProperties);\n+        final RecordCursor<FDBQueriedRecord<Message>> records;\n         final JoinedType joinedType = joinedTypes.get(depth + 1);\n         if (joinedType.constituent.isOuterJoined()) {\n-            records = records.orElse(executor -> RecordCursor.fromFuture(executor, CompletableFuture.completedFuture(null)));\n+            records = RecordCursor.orElse(innerContinuation -> queries.get(depth).execute(store, context, innerContinuation, executeProperties),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8fbb4025a8590c561b511e5daa799d1f86241c11"}, "originalPosition": 9}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTgyNjQzNQ==", "bodyText": "The name here should probably reflect the fact that it returns on OrElse cursor", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/975#discussion_r441826435", "createdAt": "2020-06-17T20:50:35Z", "author": {"login": "alecgrieser"}, "path": "fdb-record-layer-core/src/test/java/com/apple/foundationdb/record/RecordCursorTest.java", "diffHunk": "@@ -1012,21 +1014,97 @@ public void testFlatMapReasons() throws Exception {\n     public void testOrElseReasons() throws Exception {\n         // Don't take else path if inside stops prematurely.\n         final List<Integer> list = Arrays.asList(1, 2, 3, 4, 5);\n-        final Function<Executor, RecordCursor<Integer>> orElse = x -> RecordCursor.fromList(Collections.singletonList(0));\n-        RecordCursor<Integer> cursor = new FakeOutOfBandCursor<>(RecordCursor.fromList(list), 3)\n-                .filter(i -> false)\n-                .orElse(orElse);\n+        final BiFunction<Executor, byte[], RecordCursor<Integer>> orElse = (x, cont) -> RecordCursor.fromList(Collections.singletonList(0), cont);\n+        RecordCursor<Integer> cursor = RecordCursor.orElse(cont -> new FakeOutOfBandCursor<>(RecordCursor.fromList(list, cont), 3)\n+                .filter(i -> false), orElse, null);\n         assertEquals(Collections.emptyList(), cursor.asList().join());\n         RecordCursorResult<Integer> noNextResult = cursor.getNext();\n         assertEquals(RecordCursor.NoNextReason.TIME_LIMIT_REACHED, noNextResult.getNoNextReason());\n-        cursor = new FakeOutOfBandCursor<>(RecordCursor.fromList(list, noNextResult.getContinuation().toBytes()), 3)\n-                .filter(i -> false)\n-                .orElse(orElse);\n+\n+        cursor = RecordCursor.orElse(cont -> new FakeOutOfBandCursor<>(RecordCursor.fromList(list, cont), 3)\n+                .filter(i -> false), orElse, noNextResult.getContinuation().toBytes());\n         assertEquals(Collections.singletonList(0), cursor.asList().join());\n         noNextResult = cursor.getNext();\n         assertEquals(RecordCursor.NoNextReason.SOURCE_EXHAUSTED, noNextResult.getNoNextReason());\n     }\n \n+    @Test\n+    public void orElseWithEventuallyNonEmptyInner() {\n+        final List<Integer> list = Arrays.asList(1, 2, 3, 4, 5);\n+        RecordCursor<Integer> cursor = getFilteredFakeOutOfBandCursor(list, 3, 4, null);\n+        assertEquals(Collections.emptyList(), cursor.asList().join());\n+        RecordCursorResult<Integer> nextResult = cursor.getNext();\n+        assertEquals(RecordCursor.NoNextReason.TIME_LIMIT_REACHED, nextResult.getNoNextReason());\n+        cursor = getFilteredFakeOutOfBandCursor(list, 3, 4, nextResult.getContinuation().toBytes());\n+\n+        // Choose the inner branch since we eventually get a value\n+        assertEquals(Collections.singletonList(5), cursor.asList().join());\n+        nextResult = cursor.getNext();\n+        assertEquals(RecordCursor.NoNextReason.SOURCE_EXHAUSTED, nextResult.getNoNextReason());\n+    }\n+\n+    @Test\n+    public void orElseContinueWithInnerBranchAfterDecision() {\n+        final List<Integer> longList = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18);\n+        RecordCursor<Integer> cursor = getFilteredFakeOutOfBandCursor(longList, 3, 10, null);\n+\n+        RecordCursorResult<Integer> nextResult = null;\n+        for (int i = 0; i < 3; i++) { // three rounds with no results\n+            nextResult = cursor.getNext();\n+            assertEquals(RecordCursor.NoNextReason.TIME_LIMIT_REACHED, nextResult.getNoNextReason());\n+            cursor = getFilteredFakeOutOfBandCursor(longList, 3, 10, nextResult.getContinuation().toBytes());\n+        }\n+\n+        // Choose the inner branch\n+        assertEquals(ImmutableList.of(11, 12), cursor.asList().join());\n+        nextResult = cursor.getNext();\n+        assertEquals(RecordCursor.NoNextReason.TIME_LIMIT_REACHED, nextResult.getNoNextReason());\n+\n+        byte[] continuation = nextResult.getContinuation().toBytes();\n+        while (continuation != null) {\n+            cursor = getFilteredFakeOutOfBandCursor(longList, 3, 10, continuation);\n+            nextResult = cursor.getNext();\n+            continuation = nextResult.getContinuation().toBytes();\n+        }\n+    }\n+\n+    @Test\n+    public void orElseContinueWithElseBranchAfterDecision() {\n+        final List<Integer> innerList = Arrays.asList(1, 2, 3, 4, 5);\n+        final List<Integer> elseList = Arrays.asList(-1, -2, -3, -4, -5);\n+        final BiFunction<Executor, byte[], RecordCursor<Integer>> orElse = (x, cont) ->\n+                new FakeOutOfBandCursor<>(RecordCursor.fromList(elseList, cont), 3, RecordCursor.NoNextReason.TIME_LIMIT_REACHED);\n+\n+        // Go through inner cursor to determine that it's empty.\n+        RecordCursor<Integer> cursor = RecordCursor.orElse(cont -> new FakeOutOfBandCursor<>(RecordCursor.fromList(innerList, cont), 3)\n+                .filter(i -> false), orElse, null);\n+        assertEquals(Collections.emptyList(), cursor.asList().join());\n+        RecordCursorResult<Integer> nextResult = cursor.getNext();\n+        assertEquals(RecordCursor.NoNextReason.TIME_LIMIT_REACHED, nextResult.getNoNextReason());\n+        cursor = RecordCursor.orElse(cont -> new FakeOutOfBandCursor<>(RecordCursor.fromList(innerList, cont), 3)\n+                .filter(i -> false), orElse, nextResult.getContinuation().toBytes());\n+\n+        // Switch to else branch, but get stuck with an out-of-band limit.\n+        assertEquals(ImmutableList.of(-1, -2, -3), cursor.asList().join());\n+        nextResult = cursor.getNext();\n+        assertEquals(RecordCursor.NoNextReason.TIME_LIMIT_REACHED, nextResult.getNoNextReason());\n+\n+        // Continue else branch\n+        cursor = RecordCursor.orElse(cont -> new FakeOutOfBandCursor<>(RecordCursor.fromList(innerList, cont), 3)\n+                .filter(i -> false), orElse, nextResult.getContinuation().toBytes());\n+        assertEquals(ImmutableList.of(-4, -5), cursor.asList().join());\n+        nextResult = cursor.getNext();\n+        assertEquals(RecordCursor.NoNextReason.SOURCE_EXHAUSTED, nextResult.getNoNextReason());\n+    }\n+\n+    @Nonnull\n+    private static RecordCursor<Integer> getFilteredFakeOutOfBandCursor(@Nonnull List<Integer> list, int limit, int threshold,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8fbb4025a8590c561b511e5daa799d1f86241c11"}, "originalPosition": 129}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTgyNjgzNQ==", "bodyText": "It feels like this loop should assert something, even if it's just that it never gets \"0\" back (so that we know it never hits the else branch), though having it assert about the real contents would be better.", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/975#discussion_r441826835", "createdAt": "2020-06-17T20:51:26Z", "author": {"login": "alecgrieser"}, "path": "fdb-record-layer-core/src/test/java/com/apple/foundationdb/record/RecordCursorTest.java", "diffHunk": "@@ -1012,21 +1014,97 @@ public void testFlatMapReasons() throws Exception {\n     public void testOrElseReasons() throws Exception {\n         // Don't take else path if inside stops prematurely.\n         final List<Integer> list = Arrays.asList(1, 2, 3, 4, 5);\n-        final Function<Executor, RecordCursor<Integer>> orElse = x -> RecordCursor.fromList(Collections.singletonList(0));\n-        RecordCursor<Integer> cursor = new FakeOutOfBandCursor<>(RecordCursor.fromList(list), 3)\n-                .filter(i -> false)\n-                .orElse(orElse);\n+        final BiFunction<Executor, byte[], RecordCursor<Integer>> orElse = (x, cont) -> RecordCursor.fromList(Collections.singletonList(0), cont);\n+        RecordCursor<Integer> cursor = RecordCursor.orElse(cont -> new FakeOutOfBandCursor<>(RecordCursor.fromList(list, cont), 3)\n+                .filter(i -> false), orElse, null);\n         assertEquals(Collections.emptyList(), cursor.asList().join());\n         RecordCursorResult<Integer> noNextResult = cursor.getNext();\n         assertEquals(RecordCursor.NoNextReason.TIME_LIMIT_REACHED, noNextResult.getNoNextReason());\n-        cursor = new FakeOutOfBandCursor<>(RecordCursor.fromList(list, noNextResult.getContinuation().toBytes()), 3)\n-                .filter(i -> false)\n-                .orElse(orElse);\n+\n+        cursor = RecordCursor.orElse(cont -> new FakeOutOfBandCursor<>(RecordCursor.fromList(list, cont), 3)\n+                .filter(i -> false), orElse, noNextResult.getContinuation().toBytes());\n         assertEquals(Collections.singletonList(0), cursor.asList().join());\n         noNextResult = cursor.getNext();\n         assertEquals(RecordCursor.NoNextReason.SOURCE_EXHAUSTED, noNextResult.getNoNextReason());\n     }\n \n+    @Test\n+    public void orElseWithEventuallyNonEmptyInner() {\n+        final List<Integer> list = Arrays.asList(1, 2, 3, 4, 5);\n+        RecordCursor<Integer> cursor = getFilteredFakeOutOfBandCursor(list, 3, 4, null);\n+        assertEquals(Collections.emptyList(), cursor.asList().join());\n+        RecordCursorResult<Integer> nextResult = cursor.getNext();\n+        assertEquals(RecordCursor.NoNextReason.TIME_LIMIT_REACHED, nextResult.getNoNextReason());\n+        cursor = getFilteredFakeOutOfBandCursor(list, 3, 4, nextResult.getContinuation().toBytes());\n+\n+        // Choose the inner branch since we eventually get a value\n+        assertEquals(Collections.singletonList(5), cursor.asList().join());\n+        nextResult = cursor.getNext();\n+        assertEquals(RecordCursor.NoNextReason.SOURCE_EXHAUSTED, nextResult.getNoNextReason());\n+    }\n+\n+    @Test\n+    public void orElseContinueWithInnerBranchAfterDecision() {\n+        final List<Integer> longList = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18);\n+        RecordCursor<Integer> cursor = getFilteredFakeOutOfBandCursor(longList, 3, 10, null);\n+\n+        RecordCursorResult<Integer> nextResult = null;\n+        for (int i = 0; i < 3; i++) { // three rounds with no results\n+            nextResult = cursor.getNext();\n+            assertEquals(RecordCursor.NoNextReason.TIME_LIMIT_REACHED, nextResult.getNoNextReason());\n+            cursor = getFilteredFakeOutOfBandCursor(longList, 3, 10, nextResult.getContinuation().toBytes());\n+        }\n+\n+        // Choose the inner branch\n+        assertEquals(ImmutableList.of(11, 12), cursor.asList().join());\n+        nextResult = cursor.getNext();\n+        assertEquals(RecordCursor.NoNextReason.TIME_LIMIT_REACHED, nextResult.getNoNextReason());\n+\n+        byte[] continuation = nextResult.getContinuation().toBytes();\n+        while (continuation != null) {\n+            cursor = getFilteredFakeOutOfBandCursor(longList, 3, 10, continuation);\n+            nextResult = cursor.getNext();\n+            continuation = nextResult.getContinuation().toBytes();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8fbb4025a8590c561b511e5daa799d1f86241c11"}, "originalPosition": 95}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f034a282e40428c450e82cd72d902fd73b6e5cdb", "author": {"user": {"login": "nschiefer", "name": "Nicholas Schiefer"}}, "url": "https://github.com/FoundationDB/fdb-record-layer/commit/f034a282e40428c450e82cd72d902fd73b6e5cdb", "committedDate": "2020-06-17T21:46:26Z", "message": "Fixes #974: OrElseCursor doesn't properly support continuations.\n\nUse a new structured continuation object and protobuf serialization to\nrecord the complete state of the OrElseCursor, including which branch\nwas chosen. Rewrite OrElseCursor's logic in a simpler state-machine\nstyle, which makes it easy to resume the cursor before it has made a\ndecision about which branch to take.\n\nTo avoid problems like we saw with the FlatMapPipelinedCursor's\ncontinuations, deprecate the RecordCursor.orElse() fluent method and\nreplace it with a static method that interprets the continuation.\n\nBecause this changes the continuation format, this is a breaking change."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "8fbb4025a8590c561b511e5daa799d1f86241c11", "author": {"user": {"login": "nschiefer", "name": "Nicholas Schiefer"}}, "url": "https://github.com/FoundationDB/fdb-record-layer/commit/8fbb4025a8590c561b511e5daa799d1f86241c11", "committedDate": "2020-06-17T19:54:19Z", "message": "Fixes #974: OrElseCursor doesn't properly support continuations.\n\nUse a new structured continuation object and protobuf serialization to\nrecord the complete state of the OrElseCursor, including which branch\nwas chosen. Rewrite OrElseCursor's logic in a simpler state-machine\nstyle, which makes it easy to resume the cursor before it has made a\ndecision about which branch to take.\n\nTo avoid problems like we saw with the FlatMapPipelinedCursor's\ncontinuations, deprecate the RecordCursor.orElse() fluent method and\nreplace it with a static method that interprets the continuation.\n\nBecause this changes the continuation format, this is a breaking change."}, "afterCommit": {"oid": "f034a282e40428c450e82cd72d902fd73b6e5cdb", "author": {"user": {"login": "nschiefer", "name": "Nicholas Schiefer"}}, "url": "https://github.com/FoundationDB/fdb-record-layer/commit/f034a282e40428c450e82cd72d902fd73b6e5cdb", "committedDate": "2020-06-17T21:46:26Z", "message": "Fixes #974: OrElseCursor doesn't properly support continuations.\n\nUse a new structured continuation object and protobuf serialization to\nrecord the complete state of the OrElseCursor, including which branch\nwas chosen. Rewrite OrElseCursor's logic in a simpler state-machine\nstyle, which makes it easy to resume the cursor before it has made a\ndecision about which branch to take.\n\nTo avoid problems like we saw with the FlatMapPipelinedCursor's\ncontinuations, deprecate the RecordCursor.orElse() fluent method and\nreplace it with a static method that interprets the continuation.\n\nBecause this changes the continuation format, this is a breaking change."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMyODAzMTQ2", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/975#pullrequestreview-432803146", "createdAt": "2020-06-17T21:52:25Z", "commit": {"oid": "f034a282e40428c450e82cd72d902fd73b6e5cdb"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2639, "cost": 1, "resetAt": "2021-11-01T14:20:25Z"}}}