{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDA2MzgwNzMz", "number": 914, "reviewThreads": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yM1QxNTo0MToxNFrOD1V1Kw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yM1QxNTo0Mzo1NFrOD1V6vQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU3MjU4Nzk1OnYy", "diffSide": "RIGHT", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/provider/foundationdb/indexes/RankIndexMaintainer.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yM1QxNTo0MToxNFrOGKu3tA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yM1QxNzo0NDowMlrOGK0Y6g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzkwNjg2OA==", "bodyText": "Does this mean that it is unsafe to write two records concurrently, if they both touch the same rank index?", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/914#discussion_r413906868", "createdAt": "2020-04-23T15:41:14Z", "author": {"login": "ScottDugas"}, "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/provider/foundationdb/indexes/RankIndexMaintainer.java", "diffHunk": "@@ -127,10 +129,19 @@ public RankIndexMaintainer(IndexMaintainerState state) {\n                 rankSubspace = extraSubspace;\n                 scoreKey = indexEntry.getKey();\n             }\n-            futures.add(RankedSetIndexHelper.updateRankedSet(state, rankSubspace, config, indexEntry.getKey(),\n-                    scoreKey, remove));\n+            // It is unsafe to have two concurrent updates to the same ranked set, so ensure that at most", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "11c436ebfdf76e567b15678dbef48017039a163f"}, "originalPosition": 32}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzk5NzI5MA==", "bodyText": "Yeah, that's right. I'm, um, not sure we document this in all of the right places, but it is true. At one point, I had a, like, almost solution, that used a rather complicated (and not quite tested) locking mechanism, but we didn't merge that for a few different reasons.", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/914#discussion_r413997290", "createdAt": "2020-04-23T17:44:02Z", "author": {"login": "alecgrieser"}, "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/provider/foundationdb/indexes/RankIndexMaintainer.java", "diffHunk": "@@ -127,10 +129,19 @@ public RankIndexMaintainer(IndexMaintainerState state) {\n                 rankSubspace = extraSubspace;\n                 scoreKey = indexEntry.getKey();\n             }\n-            futures.add(RankedSetIndexHelper.updateRankedSet(state, rankSubspace, config, indexEntry.getKey(),\n-                    scoreKey, remove));\n+            // It is unsafe to have two concurrent updates to the same ranked set, so ensure that at most", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzkwNjg2OA=="}, "originalCommit": {"oid": "11c436ebfdf76e567b15678dbef48017039a163f"}, "originalPosition": 32}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU3MjYwMjIxOnYy", "diffSide": "RIGHT", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/provider/foundationdb/indexes/RankIndexMaintainer.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yM1QxNTo0Mzo1NFrOGKvAAA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yM1QxNzo0NTowNVrOGK0bbA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzkwODk5Mg==", "bodyText": "Just checking on my understanding, this means that if you have an ungrouped rank, the record updates will be done serially, if you have a grouped rank index, each group will be done in parallel, but the updates within a group will be done serially, correct?", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/914#discussion_r413908992", "createdAt": "2020-04-23T15:43:54Z", "author": {"login": "ScottDugas"}, "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/provider/foundationdb/indexes/RankIndexMaintainer.java", "diffHunk": "@@ -127,10 +129,19 @@ public RankIndexMaintainer(IndexMaintainerState state) {\n                 rankSubspace = extraSubspace;\n                 scoreKey = indexEntry.getKey();\n             }\n-            futures.add(RankedSetIndexHelper.updateRankedSet(state, rankSubspace, config, indexEntry.getKey(),\n-                    scoreKey, remove));\n+            // It is unsafe to have two concurrent updates to the same ranked set, so ensure that at most\n+            // one update per grouping key is ongoing at any given time\n+            final Function<Void, CompletableFuture<Void>> futureSupplier = vignore -> RankedSetIndexHelper.updateRankedSet(\n+                    state, rankSubspace, config, indexEntry.getKey(), scoreKey, remove\n+            );\n+            CompletableFuture<Void> existingFuture = futures.get(rankSubspace);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "11c436ebfdf76e567b15678dbef48017039a163f"}, "originalPosition": 37}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzk5NzkzMg==", "bodyText": "Yeah, each group will be done in parallel, but if you have a single group (or are ungrouped), then updates happen serially. I think that's the best we can do with the way the RankedSet is at the moment.", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/914#discussion_r413997932", "createdAt": "2020-04-23T17:45:05Z", "author": {"login": "alecgrieser"}, "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/provider/foundationdb/indexes/RankIndexMaintainer.java", "diffHunk": "@@ -127,10 +129,19 @@ public RankIndexMaintainer(IndexMaintainerState state) {\n                 rankSubspace = extraSubspace;\n                 scoreKey = indexEntry.getKey();\n             }\n-            futures.add(RankedSetIndexHelper.updateRankedSet(state, rankSubspace, config, indexEntry.getKey(),\n-                    scoreKey, remove));\n+            // It is unsafe to have two concurrent updates to the same ranked set, so ensure that at most\n+            // one update per grouping key is ongoing at any given time\n+            final Function<Void, CompletableFuture<Void>> futureSupplier = vignore -> RankedSetIndexHelper.updateRankedSet(\n+                    state, rankSubspace, config, indexEntry.getKey(), scoreKey, remove\n+            );\n+            CompletableFuture<Void> existingFuture = futures.get(rankSubspace);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzkwODk5Mg=="}, "originalCommit": {"oid": "11c436ebfdf76e567b15678dbef48017039a163f"}, "originalPosition": 37}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4874, "cost": 1, "resetAt": "2021-11-12T19:05:54Z"}}}