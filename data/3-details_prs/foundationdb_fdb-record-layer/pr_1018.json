{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDY5NzI3ODMy", "number": 1018, "title": "Resolves #1016: Covering filters on legs of unions/intersections.", "bodyText": "In #1001, we added an optimization that allows filters to be executed on partial records produced by covering index scans. In #992, we also added the ability to perform union/intersection/primary key distinct operations before fetching the base records by primary key.\nThis refactors the work from #1001 into a substitution visitor that can work in concert with the union/intersection/distinct visitors. It also corrects some (untriggered) bugs in the existing visitors.\nThis also fixes #1017; full text fields now require looking at the primary records and are not \"satisfied\" by the tokens in the full text index entries.", "createdAt": "2020-08-18T20:30:39Z", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1018", "merged": true, "mergeCommit": {"oid": "770409dd1d7053ffb2a1e060dc6d076b47e4cff5"}, "closed": true, "closedAt": "2020-08-28T00:07:25Z", "author": {"login": "nschiefer"}, "timelineItems": {"totalCount": 11, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdASTDKABqjM2Njg4MTA3MDI=", "endCursor": "Y3Vyc29yOnYyOpPPAAABdDJjq_gFqTQ3NzE2MTA2Mw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "42be591022b1de01cf65af7af50baf5d691867a9", "author": {"user": {"login": "nschiefer", "name": "Nicholas Schiefer"}}, "url": "https://github.com/FoundationDB/fdb-record-layer/commit/42be591022b1de01cf65af7af50baf5d691867a9", "committedDate": "2020-08-18T20:20:51Z", "message": "Resolves #1016: Covering filters on legs of unions/intersections.\n\nIn #1001, we added an optimization that allows filters to be executed\non partial records produced by covering index scans. In #992, we also\nadded the ability to perform union/intersection/primary key distinct\noperations before fetching the base records by primary key.\n\nThis refactors the work from #1001 into a substitution visitor that can\nwork in concert with the union/intersection/distinct visitors. It also\ncorrects some (untriggered) bugs in the existing visitors.\n\nThis also fixes #1017; full text fields now require looking at the\nprimary records and are not \"satisfied\" by the tokens in the full text\nindex entries."}, "afterCommit": {"oid": "86be71c95c98e46b8dee430ba206d8e96d75d7f8", "author": {"user": {"login": "nschiefer", "name": "Nicholas Schiefer"}}, "url": "https://github.com/FoundationDB/fdb-record-layer/commit/86be71c95c98e46b8dee430ba206d8e96d75d7f8", "committedDate": "2020-08-19T02:36:08Z", "message": "Resolves #1016: Covering filters on legs of unions/intersections.\n\nIn #1001, we added an optimization that allows filters to be executed\non partial records produced by covering index scans. In #992, we also\nadded the ability to perform union/intersection/primary key distinct\noperations before fetching the base records by primary key.\n\nThis refactors the work from #1001 into a substitution visitor that can\nwork in concert with the union/intersection/distinct visitors. It also\ncorrects some (untriggered) bugs in the existing visitors.\n\nThis also fixes #1017; full text fields now require looking at the\nprimary records and are not \"satisfied\" by the tokens in the full text\nindex entries."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDcwOTk5NzU0", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1018#pullrequestreview-470999754", "createdAt": "2020-08-19T22:09:36Z", "commit": {"oid": "86be71c95c98e46b8dee430ba206d8e96d75d7f8"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOVQyMjowOTozNlrOHDcbGg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOVQyMjozMTozNlrOHDddBQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzM3MzQ2Ng==", "bodyText": "Does this mean full (not-partial) records, where all fields are available by navigation of said record?\nI guess I am unclear whether this comment is speaking generally of scan streams or more specifically of how this class is used.", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1018#discussion_r473373466", "createdAt": "2020-08-19T22:09:36Z", "author": {"login": "MMcM"}, "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/AvailableFields.java", "diffHunk": "@@ -0,0 +1,211 @@\n+/*\n+ * AvailableFields.java\n+ *\n+ * This source file is part of the FoundationDB open source project\n+ *\n+ * Copyright 2015-2020 Apple Inc. and the FoundationDB project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.apple.foundationdb.record.query.plan;\n+\n+import com.apple.foundationdb.record.metadata.Index;\n+import com.apple.foundationdb.record.metadata.Key;\n+import com.apple.foundationdb.record.metadata.RecordType;\n+import com.apple.foundationdb.record.metadata.expressions.FieldKeyExpression;\n+import com.apple.foundationdb.record.metadata.expressions.GroupingKeyExpression;\n+import com.apple.foundationdb.record.metadata.expressions.KeyExpression;\n+import com.apple.foundationdb.record.metadata.expressions.NestingKeyExpression;\n+import com.apple.foundationdb.record.query.plan.planning.TextScanPlanner;\n+import com.google.common.collect.Sets;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+/**\n+ * Represents a subset of the fields available in a stream of records, including partial records.\n+ *\n+ * If a stream includes partial records, all fields are available; they are not represented individually.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "86be71c95c98e46b8dee430ba206d8e96d75d7f8"}, "originalPosition": 47}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzM3ODE2Nw==", "bodyText": "Map.keySet is backed by the map itself, so I think retainAll should work here.", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1018#discussion_r473378167", "createdAt": "2020-08-19T22:15:37Z", "author": {"login": "MMcM"}, "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/AvailableFields.java", "diffHunk": "@@ -0,0 +1,211 @@\n+/*\n+ * AvailableFields.java\n+ *\n+ * This source file is part of the FoundationDB open source project\n+ *\n+ * Copyright 2015-2020 Apple Inc. and the FoundationDB project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.apple.foundationdb.record.query.plan;\n+\n+import com.apple.foundationdb.record.metadata.Index;\n+import com.apple.foundationdb.record.metadata.Key;\n+import com.apple.foundationdb.record.metadata.RecordType;\n+import com.apple.foundationdb.record.metadata.expressions.FieldKeyExpression;\n+import com.apple.foundationdb.record.metadata.expressions.GroupingKeyExpression;\n+import com.apple.foundationdb.record.metadata.expressions.KeyExpression;\n+import com.apple.foundationdb.record.metadata.expressions.NestingKeyExpression;\n+import com.apple.foundationdb.record.query.plan.planning.TextScanPlanner;\n+import com.google.common.collect.Sets;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+/**\n+ * Represents a subset of the fields available in a stream of records, including partial records.\n+ *\n+ * If a stream includes partial records, all fields are available; they are not represented individually.\n+ * For partial records, this class tracks a (non-strict) subset of the fields that are actually available.\n+ * For example, all repeated fields are currently dropped. It is extremely important that no field every be included\n+ * when it is not actually available on a partial record.\n+ */\n+public class AvailableFields {\n+    @Nonnull\n+    public static final AvailableFields ALL_FIELDS = new AvailableFields(null);\n+    @Nonnull\n+    public static final AvailableFields NO_FIELDS = new AvailableFields(Collections.emptyMap());\n+\n+    @Nullable\n+    private final Map<KeyExpression, FieldData> fields;\n+\n+    private AvailableFields(@Nullable Map<KeyExpression, FieldData> fields) {\n+        this.fields = fields;\n+    }\n+\n+\n+    public boolean hasAllFields() {\n+        return fields == null;\n+    }\n+\n+    public boolean containsAll(@Nonnull Collection<KeyExpression> requiredFields) {\n+        if (fields == null) {\n+            return true;\n+        }\n+        return fields.keySet().containsAll(requiredFields);\n+    }\n+\n+    @Nullable\n+    public IndexKeyValueToPartialRecord.Builder buildIndexKeyValueToPartialRecord(@Nonnull RecordType recordType) {\n+        if (fields == null) {\n+            return null;\n+        }\n+\n+        final IndexKeyValueToPartialRecord.Builder builder = IndexKeyValueToPartialRecord.newBuilder(recordType);\n+        for (Map.Entry<KeyExpression, FieldData> entry : fields.entrySet()) {\n+            if (!addCoveringField(entry.getKey(), entry.getValue(), builder)) {\n+                return null;\n+            }\n+        }\n+        if (!builder.isValid()) {\n+            return null;\n+        }\n+\n+        return builder;\n+    }\n+\n+    @Nonnull\n+    public static AvailableFields fromIndex(@Nonnull RecordType recordType,\n+                                            @Nonnull Index index,\n+                                            @Nonnull PlannableIndexTypes indexTypes,\n+                                            @Nullable KeyExpression commonPrimaryKey) {\n+        final KeyExpression rootExpression = index.getRootExpression();\n+\n+        final List<KeyExpression> keyFields = new ArrayList<>();\n+        final List<KeyExpression> valueFields = new ArrayList<>();\n+        if (indexTypes.getTextTypes().contains(index.getType())) {\n+            // Full text index entries have all of their fields except the tokenized one.\n+            keyFields.addAll(TextScanPlanner.getOtherFields(rootExpression));\n+        } else if (indexTypes.getValueTypes().contains(index.getType()) ||\n+                   indexTypes.getRankTypes().contains(index.getType())) {\n+            keyFields.addAll(KeyExpression.getKeyFields(rootExpression));\n+            valueFields.addAll(KeyExpression.getValueFields(rootExpression));\n+        } else {\n+            // Aggregate index\n+            if (rootExpression instanceof GroupingKeyExpression) {\n+                GroupingKeyExpression groupingKeyExpression = (GroupingKeyExpression) rootExpression;\n+                keyFields.addAll(groupingKeyExpression.getGroupingSubKey().normalizeKeyForPositions());\n+            }\n+        }\n+\n+        // Like FDBRecordStoreBase.indexEntryKey(), but with key expressions instead of actual values.\n+        final List<KeyExpression> primaryKeys = commonPrimaryKey == null\n+                                                ? Collections.emptyList()\n+                                                : commonPrimaryKey.normalizeKeyForPositions();\n+        index.trimPrimaryKey(primaryKeys);\n+        keyFields.addAll(primaryKeys);\n+\n+        Map<KeyExpression, FieldData> fields = new HashMap<>();\n+        final IndexKeyValueToPartialRecord.Builder builder = IndexKeyValueToPartialRecord.newBuilder(recordType);\n+        for (int i = 0; i < keyFields.size(); i++) {\n+            KeyExpression keyField = keyFields.get(i);\n+            FieldData fieldData = FieldData.of(IndexKeyValueToPartialRecord.TupleSource.KEY, i);\n+            if (!keyField.createsDuplicates() && addCoveringField(keyField, fieldData, builder)) {\n+                fields.put(keyField, fieldData);\n+            }\n+        }\n+        for (int i = 0; i < valueFields.size(); i++) {\n+            KeyExpression valueField = valueFields.get(i);\n+            FieldData fieldData = FieldData.of(IndexKeyValueToPartialRecord.TupleSource.VALUE, i);\n+            if (!valueField.createsDuplicates() && addCoveringField(valueField, fieldData, builder)) {\n+                fields.put(valueField, fieldData);\n+            }\n+        }\n+\n+        if (!builder.isValid()) {\n+            return NO_FIELDS;\n+        }\n+        return new AvailableFields(fields);\n+    }\n+\n+    public static boolean addCoveringField(@Nonnull KeyExpression requiredExpr,\n+                                           @Nonnull FieldData fieldData,\n+                                           @Nonnull IndexKeyValueToPartialRecord.Builder builder) {\n+        while (requiredExpr instanceof NestingKeyExpression) {\n+            NestingKeyExpression nesting = (NestingKeyExpression)requiredExpr;\n+            String fieldName = nesting.getParent().getFieldName();\n+            requiredExpr = nesting.getChild();\n+            builder = builder.getFieldBuilder(fieldName);\n+        }\n+        if (requiredExpr instanceof FieldKeyExpression) {\n+            FieldKeyExpression fieldKeyExpression = (FieldKeyExpression)requiredExpr;\n+            if (!fieldKeyExpression.getNullStandin().equals(Key.Evaluated.NullStandin.NULL) ||\n+                    fieldKeyExpression.getFanType().equals(KeyExpression.FanType.FanOut)) {\n+                return false;\n+            }\n+            builder.addField(fieldKeyExpression.getFieldName(), fieldData.source, fieldData.index);\n+            return true;\n+        } else {\n+            return false;\n+        }\n+    }\n+\n+    @Nonnull\n+    public static AvailableFields intersection(@Nonnull List<AvailableFields> toIntersect) {\n+        Map<KeyExpression, FieldData> intersection = null;\n+        for (AvailableFields fields : toIntersect) {\n+            if (!fields.hasAllFields()) {\n+                if (intersection == null) {\n+                    intersection = new HashMap<>(fields.fields);\n+                } else {\n+                    Set<KeyExpression> keysToRemove = new HashSet<>(Sets.difference(intersection.keySet(),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "86be71c95c98e46b8dee430ba206d8e96d75d7f8"}, "originalPosition": 180}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzM5MDM0MQ==", "bodyText": "Maybe a helper here in this fixture for that?", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1018#discussion_r473390341", "createdAt": "2020-08-19T22:31:36Z", "author": {"login": "MMcM"}, "path": "fdb-record-layer-core/src/test/java/com/apple/foundationdb/record/provider/foundationdb/indexes/RankIndexTest.java", "diffHunk": "@@ -1015,10 +1023,12 @@ public void twoRankPredicates() throws Exception {\n                         Query.rank(Key.Expressions.field(\"score\").groupBy(Key.Expressions.field(\"gender\"))).equalsValue(1L)))\n                 .build();\n         RecordQueryPlan plan = planner.plan(query);\n-        assertEquals(\"Index(rank_by_gender [[M, 1],[M, 1]] BY_RANK)\" +\n-                        \" | score LESS_THAN $__rank_0\" +\n-                        \" WHERE __rank_0 = BasicRankedRecord$score.score_for_rank_else_skip(3)\",\n-                plan.toString());\n+        assertThat(plan, scoreForRank(contains(\n+                hasToString(\"__rank_0 = BasicRankedRecord$score.score_for_rank_else_skip(3)\")),\n+                // need to explicitly construct QueryComponent because we're using an internal parameter", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "86be71c95c98e46b8dee430ba206d8e96d75d7f8"}, "originalPosition": 48}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDcxNzYzNjMx", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1018#pullrequestreview-471763631", "createdAt": "2020-08-20T16:01:00Z", "commit": {"oid": "86be71c95c98e46b8dee430ba206d8e96d75d7f8"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMFQxNjowMTowMVrOHEIiAA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMVQxNjo0OTowOFrOHE0QBA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDA5NjEyOA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n             * For example, all repeated fields are currently dropped. It is extremely important that no field every be included\n          \n          \n            \n             * For example, all repeated fields are currently dropped. It is extremely important that no field ever be included", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1018#discussion_r474096128", "createdAt": "2020-08-20T16:01:01Z", "author": {"login": "normen662"}, "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/AvailableFields.java", "diffHunk": "@@ -0,0 +1,211 @@\n+/*\n+ * AvailableFields.java\n+ *\n+ * This source file is part of the FoundationDB open source project\n+ *\n+ * Copyright 2015-2020 Apple Inc. and the FoundationDB project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.apple.foundationdb.record.query.plan;\n+\n+import com.apple.foundationdb.record.metadata.Index;\n+import com.apple.foundationdb.record.metadata.Key;\n+import com.apple.foundationdb.record.metadata.RecordType;\n+import com.apple.foundationdb.record.metadata.expressions.FieldKeyExpression;\n+import com.apple.foundationdb.record.metadata.expressions.GroupingKeyExpression;\n+import com.apple.foundationdb.record.metadata.expressions.KeyExpression;\n+import com.apple.foundationdb.record.metadata.expressions.NestingKeyExpression;\n+import com.apple.foundationdb.record.query.plan.planning.TextScanPlanner;\n+import com.google.common.collect.Sets;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+/**\n+ * Represents a subset of the fields available in a stream of records, including partial records.\n+ *\n+ * If a stream includes partial records, all fields are available; they are not represented individually.\n+ * For partial records, this class tracks a (non-strict) subset of the fields that are actually available.\n+ * For example, all repeated fields are currently dropped. It is extremely important that no field every be included", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "86be71c95c98e46b8dee430ba206d8e96d75d7f8"}, "originalPosition": 49}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDA5OTMzNQ==", "bodyText": "Not sure if that would be useful, but is this worth logging?", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1018#discussion_r474099335", "createdAt": "2020-08-20T16:06:01Z", "author": {"login": "normen662"}, "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/AvailableFields.java", "diffHunk": "@@ -0,0 +1,211 @@\n+/*\n+ * AvailableFields.java\n+ *\n+ * This source file is part of the FoundationDB open source project\n+ *\n+ * Copyright 2015-2020 Apple Inc. and the FoundationDB project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.apple.foundationdb.record.query.plan;\n+\n+import com.apple.foundationdb.record.metadata.Index;\n+import com.apple.foundationdb.record.metadata.Key;\n+import com.apple.foundationdb.record.metadata.RecordType;\n+import com.apple.foundationdb.record.metadata.expressions.FieldKeyExpression;\n+import com.apple.foundationdb.record.metadata.expressions.GroupingKeyExpression;\n+import com.apple.foundationdb.record.metadata.expressions.KeyExpression;\n+import com.apple.foundationdb.record.metadata.expressions.NestingKeyExpression;\n+import com.apple.foundationdb.record.query.plan.planning.TextScanPlanner;\n+import com.google.common.collect.Sets;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+/**\n+ * Represents a subset of the fields available in a stream of records, including partial records.\n+ *\n+ * If a stream includes partial records, all fields are available; they are not represented individually.\n+ * For partial records, this class tracks a (non-strict) subset of the fields that are actually available.\n+ * For example, all repeated fields are currently dropped. It is extremely important that no field every be included\n+ * when it is not actually available on a partial record.\n+ */\n+public class AvailableFields {\n+    @Nonnull\n+    public static final AvailableFields ALL_FIELDS = new AvailableFields(null);\n+    @Nonnull\n+    public static final AvailableFields NO_FIELDS = new AvailableFields(Collections.emptyMap());\n+\n+    @Nullable\n+    private final Map<KeyExpression, FieldData> fields;\n+\n+    private AvailableFields(@Nullable Map<KeyExpression, FieldData> fields) {\n+        this.fields = fields;\n+    }\n+\n+\n+    public boolean hasAllFields() {\n+        return fields == null;\n+    }\n+\n+    public boolean containsAll(@Nonnull Collection<KeyExpression> requiredFields) {\n+        if (fields == null) {\n+            return true;\n+        }\n+        return fields.keySet().containsAll(requiredFields);\n+    }\n+\n+    @Nullable\n+    public IndexKeyValueToPartialRecord.Builder buildIndexKeyValueToPartialRecord(@Nonnull RecordType recordType) {\n+        if (fields == null) {\n+            return null;\n+        }\n+\n+        final IndexKeyValueToPartialRecord.Builder builder = IndexKeyValueToPartialRecord.newBuilder(recordType);\n+        for (Map.Entry<KeyExpression, FieldData> entry : fields.entrySet()) {\n+            if (!addCoveringField(entry.getKey(), entry.getValue(), builder)) {\n+                return null;\n+            }\n+        }\n+        if (!builder.isValid()) {\n+            return null;\n+        }\n+\n+        return builder;\n+    }\n+\n+    @Nonnull\n+    public static AvailableFields fromIndex(@Nonnull RecordType recordType,\n+                                            @Nonnull Index index,\n+                                            @Nonnull PlannableIndexTypes indexTypes,\n+                                            @Nullable KeyExpression commonPrimaryKey) {\n+        final KeyExpression rootExpression = index.getRootExpression();\n+\n+        final List<KeyExpression> keyFields = new ArrayList<>();\n+        final List<KeyExpression> valueFields = new ArrayList<>();\n+        if (indexTypes.getTextTypes().contains(index.getType())) {\n+            // Full text index entries have all of their fields except the tokenized one.\n+            keyFields.addAll(TextScanPlanner.getOtherFields(rootExpression));\n+        } else if (indexTypes.getValueTypes().contains(index.getType()) ||\n+                   indexTypes.getRankTypes().contains(index.getType())) {\n+            keyFields.addAll(KeyExpression.getKeyFields(rootExpression));\n+            valueFields.addAll(KeyExpression.getValueFields(rootExpression));\n+        } else {\n+            // Aggregate index\n+            if (rootExpression instanceof GroupingKeyExpression) {\n+                GroupingKeyExpression groupingKeyExpression = (GroupingKeyExpression) rootExpression;\n+                keyFields.addAll(groupingKeyExpression.getGroupingSubKey().normalizeKeyForPositions());\n+            }\n+        }\n+\n+        // Like FDBRecordStoreBase.indexEntryKey(), but with key expressions instead of actual values.\n+        final List<KeyExpression> primaryKeys = commonPrimaryKey == null\n+                                                ? Collections.emptyList()\n+                                                : commonPrimaryKey.normalizeKeyForPositions();\n+        index.trimPrimaryKey(primaryKeys);\n+        keyFields.addAll(primaryKeys);\n+\n+        Map<KeyExpression, FieldData> fields = new HashMap<>();\n+        final IndexKeyValueToPartialRecord.Builder builder = IndexKeyValueToPartialRecord.newBuilder(recordType);\n+        for (int i = 0; i < keyFields.size(); i++) {\n+            KeyExpression keyField = keyFields.get(i);\n+            FieldData fieldData = FieldData.of(IndexKeyValueToPartialRecord.TupleSource.KEY, i);\n+            if (!keyField.createsDuplicates() && addCoveringField(keyField, fieldData, builder)) {\n+                fields.put(keyField, fieldData);\n+            }\n+        }\n+        for (int i = 0; i < valueFields.size(); i++) {\n+            KeyExpression valueField = valueFields.get(i);\n+            FieldData fieldData = FieldData.of(IndexKeyValueToPartialRecord.TupleSource.VALUE, i);\n+            if (!valueField.createsDuplicates() && addCoveringField(valueField, fieldData, builder)) {\n+                fields.put(valueField, fieldData);\n+            }\n+        }\n+\n+        if (!builder.isValid()) {\n+            return NO_FIELDS;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "86be71c95c98e46b8dee430ba206d8e96d75d7f8"}, "originalPosition": 145}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDExMTEzMw==", "bodyText": "Hmm, let me just list out two thoughts I have here:\n\nIn a perfect world, we should always know the universe of fields that actually comprise all fields. Since we presumably don't know that in all cases, we use a special value to represent all fields. If that assumption on my side is true, then I guess we cannot do better, however, this may be error prone going forward or just straight out lose information. I mean ALL intersection set should not be set as ALL may be a superset or a subset of set in the most general case.\nThis intersection has a weird behavioral knack when it comes to an empty list of fields to intersect which would return all fields which feels counterintuitive. I am not sure if this can happen but if it cannot happen through callers, maybe this case should be verified and this should bail or return something else. I only see intersection and union base plans to call this, maybe I missed one.", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1018#discussion_r474111133", "createdAt": "2020-08-20T16:24:41Z", "author": {"login": "normen662"}, "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/AvailableFields.java", "diffHunk": "@@ -0,0 +1,211 @@\n+/*\n+ * AvailableFields.java\n+ *\n+ * This source file is part of the FoundationDB open source project\n+ *\n+ * Copyright 2015-2020 Apple Inc. and the FoundationDB project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.apple.foundationdb.record.query.plan;\n+\n+import com.apple.foundationdb.record.metadata.Index;\n+import com.apple.foundationdb.record.metadata.Key;\n+import com.apple.foundationdb.record.metadata.RecordType;\n+import com.apple.foundationdb.record.metadata.expressions.FieldKeyExpression;\n+import com.apple.foundationdb.record.metadata.expressions.GroupingKeyExpression;\n+import com.apple.foundationdb.record.metadata.expressions.KeyExpression;\n+import com.apple.foundationdb.record.metadata.expressions.NestingKeyExpression;\n+import com.apple.foundationdb.record.query.plan.planning.TextScanPlanner;\n+import com.google.common.collect.Sets;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+/**\n+ * Represents a subset of the fields available in a stream of records, including partial records.\n+ *\n+ * If a stream includes partial records, all fields are available; they are not represented individually.\n+ * For partial records, this class tracks a (non-strict) subset of the fields that are actually available.\n+ * For example, all repeated fields are currently dropped. It is extremely important that no field every be included\n+ * when it is not actually available on a partial record.\n+ */\n+public class AvailableFields {\n+    @Nonnull\n+    public static final AvailableFields ALL_FIELDS = new AvailableFields(null);\n+    @Nonnull\n+    public static final AvailableFields NO_FIELDS = new AvailableFields(Collections.emptyMap());\n+\n+    @Nullable\n+    private final Map<KeyExpression, FieldData> fields;\n+\n+    private AvailableFields(@Nullable Map<KeyExpression, FieldData> fields) {\n+        this.fields = fields;\n+    }\n+\n+\n+    public boolean hasAllFields() {\n+        return fields == null;\n+    }\n+\n+    public boolean containsAll(@Nonnull Collection<KeyExpression> requiredFields) {\n+        if (fields == null) {\n+            return true;\n+        }\n+        return fields.keySet().containsAll(requiredFields);\n+    }\n+\n+    @Nullable\n+    public IndexKeyValueToPartialRecord.Builder buildIndexKeyValueToPartialRecord(@Nonnull RecordType recordType) {\n+        if (fields == null) {\n+            return null;\n+        }\n+\n+        final IndexKeyValueToPartialRecord.Builder builder = IndexKeyValueToPartialRecord.newBuilder(recordType);\n+        for (Map.Entry<KeyExpression, FieldData> entry : fields.entrySet()) {\n+            if (!addCoveringField(entry.getKey(), entry.getValue(), builder)) {\n+                return null;\n+            }\n+        }\n+        if (!builder.isValid()) {\n+            return null;\n+        }\n+\n+        return builder;\n+    }\n+\n+    @Nonnull\n+    public static AvailableFields fromIndex(@Nonnull RecordType recordType,\n+                                            @Nonnull Index index,\n+                                            @Nonnull PlannableIndexTypes indexTypes,\n+                                            @Nullable KeyExpression commonPrimaryKey) {\n+        final KeyExpression rootExpression = index.getRootExpression();\n+\n+        final List<KeyExpression> keyFields = new ArrayList<>();\n+        final List<KeyExpression> valueFields = new ArrayList<>();\n+        if (indexTypes.getTextTypes().contains(index.getType())) {\n+            // Full text index entries have all of their fields except the tokenized one.\n+            keyFields.addAll(TextScanPlanner.getOtherFields(rootExpression));\n+        } else if (indexTypes.getValueTypes().contains(index.getType()) ||\n+                   indexTypes.getRankTypes().contains(index.getType())) {\n+            keyFields.addAll(KeyExpression.getKeyFields(rootExpression));\n+            valueFields.addAll(KeyExpression.getValueFields(rootExpression));\n+        } else {\n+            // Aggregate index\n+            if (rootExpression instanceof GroupingKeyExpression) {\n+                GroupingKeyExpression groupingKeyExpression = (GroupingKeyExpression) rootExpression;\n+                keyFields.addAll(groupingKeyExpression.getGroupingSubKey().normalizeKeyForPositions());\n+            }\n+        }\n+\n+        // Like FDBRecordStoreBase.indexEntryKey(), but with key expressions instead of actual values.\n+        final List<KeyExpression> primaryKeys = commonPrimaryKey == null\n+                                                ? Collections.emptyList()\n+                                                : commonPrimaryKey.normalizeKeyForPositions();\n+        index.trimPrimaryKey(primaryKeys);\n+        keyFields.addAll(primaryKeys);\n+\n+        Map<KeyExpression, FieldData> fields = new HashMap<>();\n+        final IndexKeyValueToPartialRecord.Builder builder = IndexKeyValueToPartialRecord.newBuilder(recordType);\n+        for (int i = 0; i < keyFields.size(); i++) {\n+            KeyExpression keyField = keyFields.get(i);\n+            FieldData fieldData = FieldData.of(IndexKeyValueToPartialRecord.TupleSource.KEY, i);\n+            if (!keyField.createsDuplicates() && addCoveringField(keyField, fieldData, builder)) {\n+                fields.put(keyField, fieldData);\n+            }\n+        }\n+        for (int i = 0; i < valueFields.size(); i++) {\n+            KeyExpression valueField = valueFields.get(i);\n+            FieldData fieldData = FieldData.of(IndexKeyValueToPartialRecord.TupleSource.VALUE, i);\n+            if (!valueField.createsDuplicates() && addCoveringField(valueField, fieldData, builder)) {\n+                fields.put(valueField, fieldData);\n+            }\n+        }\n+\n+        if (!builder.isValid()) {\n+            return NO_FIELDS;\n+        }\n+        return new AvailableFields(fields);\n+    }\n+\n+    public static boolean addCoveringField(@Nonnull KeyExpression requiredExpr,\n+                                           @Nonnull FieldData fieldData,\n+                                           @Nonnull IndexKeyValueToPartialRecord.Builder builder) {\n+        while (requiredExpr instanceof NestingKeyExpression) {\n+            NestingKeyExpression nesting = (NestingKeyExpression)requiredExpr;\n+            String fieldName = nesting.getParent().getFieldName();\n+            requiredExpr = nesting.getChild();\n+            builder = builder.getFieldBuilder(fieldName);\n+        }\n+        if (requiredExpr instanceof FieldKeyExpression) {\n+            FieldKeyExpression fieldKeyExpression = (FieldKeyExpression)requiredExpr;\n+            if (!fieldKeyExpression.getNullStandin().equals(Key.Evaluated.NullStandin.NULL) ||\n+                    fieldKeyExpression.getFanType().equals(KeyExpression.FanType.FanOut)) {\n+                return false;\n+            }\n+            builder.addField(fieldKeyExpression.getFieldName(), fieldData.source, fieldData.index);\n+            return true;\n+        } else {\n+            return false;\n+        }\n+    }\n+\n+    @Nonnull\n+    public static AvailableFields intersection(@Nonnull List<AvailableFields> toIntersect) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "86be71c95c98e46b8dee430ba206d8e96d75d7f8"}, "originalPosition": 173}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDgxMTYwMw==", "bodyText": "This cannot be empty, I don't think the other callers can be empty either -- maybe let's not allow intersections of zero number of operands.", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1018#discussion_r474811603", "createdAt": "2020-08-21T16:47:16Z", "author": {"login": "normen662"}, "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/plans/RecordQueryIntersectionPlan.java", "diffHunk": "@@ -202,8 +203,16 @@ public boolean equalsWithoutChildren(@Nonnull RelationalExpression otherExpressi\n                comparisonKey.equals(other.comparisonKey);\n     }\n \n-    @SuppressWarnings(\"EqualsWhichDoesntCheckParameterClass\")\n+    @Nonnull\n+    @Override\n+    public AvailableFields getAvailableFields() {\n+        return AvailableFields.intersection(quantifiers.stream()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "86be71c95c98e46b8dee430ba206d8e96d75d7f8"}, "originalPosition": 16}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDgxMjQyMA==", "bodyText": "property visitor?", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1018#discussion_r474812420", "createdAt": "2020-08-21T16:49:08Z", "author": {"login": "normen662"}, "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/visitor/FilterVisitor.java", "diffHunk": "@@ -0,0 +1,116 @@\n+/*\n+ * FilterVisitor.java\n+ *\n+ * This source file is part of the FoundationDB open source project\n+ *\n+ * Copyright 2015-2020 Apple Inc. and the FoundationDB project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.apple.foundationdb.record.query.plan.visitor;\n+\n+import com.apple.foundationdb.record.RecordMetaData;\n+import com.apple.foundationdb.record.metadata.Key;\n+import com.apple.foundationdb.record.metadata.expressions.FunctionKeyExpression;\n+import com.apple.foundationdb.record.metadata.expressions.KeyExpression;\n+import com.apple.foundationdb.record.metadata.expressions.LiteralKeyExpression;\n+import com.apple.foundationdb.record.metadata.expressions.QueryableKeyExpression;\n+import com.apple.foundationdb.record.metadata.expressions.ThenKeyExpression;\n+import com.apple.foundationdb.record.query.expressions.AndOrComponent;\n+import com.apple.foundationdb.record.query.expressions.FieldWithComparison;\n+import com.apple.foundationdb.record.query.expressions.QueryComponent;\n+import com.apple.foundationdb.record.query.expressions.QueryKeyExpressionWithComparison;\n+import com.apple.foundationdb.record.query.plan.PlannableIndexTypes;\n+import com.apple.foundationdb.record.query.plan.plans.RecordQueryFetchFromPartialRecordPlan;\n+import com.apple.foundationdb.record.query.plan.plans.RecordQueryFilterPlan;\n+import com.apple.foundationdb.record.query.plan.plans.RecordQueryPlan;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+import java.util.HashSet;\n+import java.util.Set;\n+\n+/**\n+ * A substitution visitor that pushes a filter below a record fetch if all of the (non-repeated) field are available\n+ * in a covering scan.\n+ */\n+public class FilterVisitor extends RecordQueryPlannerSubstitutionVisitor {\n+    public FilterVisitor(@Nonnull final RecordMetaData recordMetadata, @Nonnull final PlannableIndexTypes indexTypes, @Nullable final KeyExpression commonPrimaryKey) {\n+        super(recordMetadata, indexTypes, commonPrimaryKey);\n+    }\n+\n+    @Nonnull\n+    @Override\n+    public RecordQueryPlan postVisit(@Nonnull final RecordQueryPlan recordQueryPlan) {\n+        if (recordQueryPlan instanceof RecordQueryFilterPlan) {\n+            final RecordQueryFilterPlan filterPlan = (RecordQueryFilterPlan)recordQueryPlan;\n+            final QueryComponent filter = filterPlan.getFilter();\n+            final Set<KeyExpression> filterFields = new HashSet<>();\n+            boolean canCollectFilterFields = findFilterCoveredFields(filter, filterFields);\n+\n+            if (canCollectFilterFields) {\n+                @Nullable RecordQueryPlan newPlan = removeIndexFetch(filterPlan.getChild(), filterFields);\n+                if (newPlan != null) {\n+                    return new RecordQueryFetchFromPartialRecordPlan(new RecordQueryFilterPlan(newPlan, filter));\n+                }\n+            }\n+        }\n+        return recordQueryPlan;\n+    }\n+\n+    // Find equivalent key expressions for fields used by the given filter.\n+    // Does not attempt to deal with OneOfThemWithComponent, as the repeated nested field will be spread across multiple\n+    // index entries. Reconstituting that as a singleton in a partial record might work for the simplest case, but\n+    // could not for multiple such filter conditions.\n+    private static boolean findFilterCoveredFields(@Nonnull QueryComponent filter, @Nonnull Set<KeyExpression> filterFields) {\n+        if (filter instanceof FieldWithComparison) {\n+            filterFields.add(Key.Expressions.field(((FieldWithComparison)filter).getFieldName()));\n+            return true;\n+        }\n+        if (filter instanceof AndOrComponent) {\n+            for (QueryComponent child : ((AndOrComponent)filter).getChildren()) {\n+                if (!findFilterCoveredFields(child, filterFields)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "86be71c95c98e46b8dee430ba206d8e96d75d7f8"}, "originalPosition": 83}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "86be71c95c98e46b8dee430ba206d8e96d75d7f8", "author": {"user": {"login": "nschiefer", "name": "Nicholas Schiefer"}}, "url": "https://github.com/FoundationDB/fdb-record-layer/commit/86be71c95c98e46b8dee430ba206d8e96d75d7f8", "committedDate": "2020-08-19T02:36:08Z", "message": "Resolves #1016: Covering filters on legs of unions/intersections.\n\nIn #1001, we added an optimization that allows filters to be executed\non partial records produced by covering index scans. In #992, we also\nadded the ability to perform union/intersection/primary key distinct\noperations before fetching the base records by primary key.\n\nThis refactors the work from #1001 into a substitution visitor that can\nwork in concert with the union/intersection/distinct visitors. It also\ncorrects some (untriggered) bugs in the existing visitors.\n\nThis also fixes #1017; full text fields now require looking at the\nprimary records and are not \"satisfied\" by the tokens in the full text\nindex entries."}, "afterCommit": {"oid": "02fec496f356304442fca35decd053cd06202c08", "author": {"user": {"login": "nschiefer", "name": "Nicholas Schiefer"}}, "url": "https://github.com/FoundationDB/fdb-record-layer/commit/02fec496f356304442fca35decd053cd06202c08", "committedDate": "2020-08-26T18:39:49Z", "message": "Resolves #1016: Covering filters on legs of unions/intersections.\n\nIn #1001, we added an optimization that allows filters to be executed\non partial records produced by covering index scans. In #992, we also\nadded the ability to perform union/intersection/primary key distinct\noperations before fetching the base records by primary key.\n\nThis refactors the work from #1001 into a substitution visitor that can\nwork in concert with the union/intersection/distinct visitors. It also\ncorrects some (untriggered) bugs in the existing visitors.\n\nThis also fixes #1017; full text fields now require looking at the\nprimary records and are not \"satisfied\" by the tokens in the full text\nindex entries."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "02fec496f356304442fca35decd053cd06202c08", "author": {"user": {"login": "nschiefer", "name": "Nicholas Schiefer"}}, "url": "https://github.com/FoundationDB/fdb-record-layer/commit/02fec496f356304442fca35decd053cd06202c08", "committedDate": "2020-08-26T18:39:49Z", "message": "Resolves #1016: Covering filters on legs of unions/intersections.\n\nIn #1001, we added an optimization that allows filters to be executed\non partial records produced by covering index scans. In #992, we also\nadded the ability to perform union/intersection/primary key distinct\noperations before fetching the base records by primary key.\n\nThis refactors the work from #1001 into a substitution visitor that can\nwork in concert with the union/intersection/distinct visitors. It also\ncorrects some (untriggered) bugs in the existing visitors.\n\nThis also fixes #1017; full text fields now require looking at the\nprimary records and are not \"satisfied\" by the tokens in the full text\nindex entries."}, "afterCommit": {"oid": "ba532f63a0773e2f5b700d516700af053f7854cd", "author": {"user": {"login": "nschiefer", "name": "Nicholas Schiefer"}}, "url": "https://github.com/FoundationDB/fdb-record-layer/commit/ba532f63a0773e2f5b700d516700af053f7854cd", "committedDate": "2020-08-26T18:58:14Z", "message": "Resolves #1016: Covering filters on legs of unions/intersections.\n\nIn #1001, we added an optimization that allows filters to be executed\non partial records produced by covering index scans. In #992, we also\nadded the ability to perform union/intersection/primary key distinct\noperations before fetching the base records by primary key.\n\nThis refactors the work from #1001 into a substitution visitor that can\nwork in concert with the union/intersection/distinct visitors. It also\ncorrects some (untriggered) bugs in the existing visitors.\n\nThis also fixes #1017; full text fields now require looking at the\nprimary records and are not \"satisfied\" by the tokens in the full text\nindex entries."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7657afbfacc42ab452078e203749342b8a1f6ff0", "author": {"user": {"login": "nschiefer", "name": "Nicholas Schiefer"}}, "url": "https://github.com/FoundationDB/fdb-record-layer/commit/7657afbfacc42ab452078e203749342b8a1f6ff0", "committedDate": "2020-08-27T19:13:41Z", "message": "Resolves #1016: Covering filters on legs of unions/intersections.\n\nIn #1001, we added an optimization that allows filters to be executed\non partial records produced by covering index scans. In #992, we also\nadded the ability to perform union/intersection/primary key distinct\noperations before fetching the base records by primary key.\n\nThis refactors the work from #1001 into a substitution visitor that can\nwork in concert with the union/intersection/distinct visitors. It also\ncorrects some (untriggered) bugs in the existing visitors.\n\nThis also fixes #1017; full text fields now require looking at the\nprimary records and are not \"satisfied\" by the tokens in the full text\nindex entries."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "ba532f63a0773e2f5b700d516700af053f7854cd", "author": {"user": {"login": "nschiefer", "name": "Nicholas Schiefer"}}, "url": "https://github.com/FoundationDB/fdb-record-layer/commit/ba532f63a0773e2f5b700d516700af053f7854cd", "committedDate": "2020-08-26T18:58:14Z", "message": "Resolves #1016: Covering filters on legs of unions/intersections.\n\nIn #1001, we added an optimization that allows filters to be executed\non partial records produced by covering index scans. In #992, we also\nadded the ability to perform union/intersection/primary key distinct\noperations before fetching the base records by primary key.\n\nThis refactors the work from #1001 into a substitution visitor that can\nwork in concert with the union/intersection/distinct visitors. It also\ncorrects some (untriggered) bugs in the existing visitors.\n\nThis also fixes #1017; full text fields now require looking at the\nprimary records and are not \"satisfied\" by the tokens in the full text\nindex entries."}, "afterCommit": {"oid": "7657afbfacc42ab452078e203749342b8a1f6ff0", "author": {"user": {"login": "nschiefer", "name": "Nicholas Schiefer"}}, "url": "https://github.com/FoundationDB/fdb-record-layer/commit/7657afbfacc42ab452078e203749342b8a1f6ff0", "committedDate": "2020-08-27T19:13:41Z", "message": "Resolves #1016: Covering filters on legs of unions/intersections.\n\nIn #1001, we added an optimization that allows filters to be executed\non partial records produced by covering index scans. In #992, we also\nadded the ability to perform union/intersection/primary key distinct\noperations before fetching the base records by primary key.\n\nThis refactors the work from #1001 into a substitution visitor that can\nwork in concert with the union/intersection/distinct visitors. It also\ncorrects some (untriggered) bugs in the existing visitors.\n\nThis also fixes #1017; full text fields now require looking at the\nprimary records and are not \"satisfied\" by the tokens in the full text\nindex entries."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDc3MDg0NjQ3", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1018#pullrequestreview-477084647", "createdAt": "2020-08-27T21:09:25Z", "commit": {"oid": "7657afbfacc42ab452078e203749342b8a1f6ff0"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yN1QyMTowOToyNVrOHIhWXg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yN1QyMTowOToyNVrOHIhWXg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODY5NzA1NA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * A pair of a representing a tuple source (key or value) and an index within that tuple source.\n          \n          \n            \n                 * A pair of a tuple source (key or value) and an index within that tuple source.", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1018#discussion_r478697054", "createdAt": "2020-08-27T21:09:25Z", "author": {"login": "MMcM"}, "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/AvailableFields.java", "diffHunk": "@@ -0,0 +1,215 @@\n+/*\n+ * AvailableFields.java\n+ *\n+ * This source file is part of the FoundationDB open source project\n+ *\n+ * Copyright 2015-2020 Apple Inc. and the FoundationDB project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.apple.foundationdb.record.query.plan;\n+\n+import com.apple.foundationdb.annotation.API;\n+import com.apple.foundationdb.record.RecordCoreException;\n+import com.apple.foundationdb.record.metadata.Index;\n+import com.apple.foundationdb.record.metadata.Key;\n+import com.apple.foundationdb.record.metadata.RecordType;\n+import com.apple.foundationdb.record.metadata.expressions.FieldKeyExpression;\n+import com.apple.foundationdb.record.metadata.expressions.GroupingKeyExpression;\n+import com.apple.foundationdb.record.metadata.expressions.KeyExpression;\n+import com.apple.foundationdb.record.metadata.expressions.NestingKeyExpression;\n+import com.apple.foundationdb.record.query.plan.planning.TextScanPlanner;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+/**\n+ * Represents a subset of the fields available in a stream of records, including partial records.\n+ *\n+ * If a stream includes full records, all fields are available; they are not represented individually.\n+ * For partial records, this class tracks a (non-strict) subset of the fields that are actually available.\n+ * For example, all repeated fields are currently dropped. It is extremely important that no field ever be included\n+ * when it is not actually available on a partial record.\n+ */\n+public class AvailableFields {\n+    @Nonnull\n+    public static final AvailableFields ALL_FIELDS = new AvailableFields(null);\n+    @Nonnull\n+    public static final AvailableFields NO_FIELDS = new AvailableFields(Collections.emptyMap());\n+\n+    @Nullable\n+    private final Map<KeyExpression, FieldData> fields;\n+\n+    private AvailableFields(@Nullable Map<KeyExpression, FieldData> fields) {\n+        this.fields = fields;\n+    }\n+\n+\n+    public boolean hasAllFields() {\n+        return fields == null;\n+    }\n+\n+    public boolean containsAll(@Nonnull Collection<KeyExpression> requiredFields) {\n+        if (fields == null) {\n+            return true;\n+        }\n+        return fields.keySet().containsAll(requiredFields);\n+    }\n+\n+    @Nullable\n+    public IndexKeyValueToPartialRecord.Builder buildIndexKeyValueToPartialRecord(@Nonnull RecordType recordType) {\n+        if (fields == null) {\n+            return null;\n+        }\n+\n+        final IndexKeyValueToPartialRecord.Builder builder = IndexKeyValueToPartialRecord.newBuilder(recordType);\n+        for (Map.Entry<KeyExpression, FieldData> entry : fields.entrySet()) {\n+            if (!addCoveringField(entry.getKey(), entry.getValue(), builder)) {\n+                return null;\n+            }\n+        }\n+        if (!builder.isValid()) {\n+            return null;\n+        }\n+\n+        return builder;\n+    }\n+\n+    @Nonnull\n+    public static AvailableFields fromIndex(@Nonnull RecordType recordType,\n+                                            @Nonnull Index index,\n+                                            @Nonnull PlannableIndexTypes indexTypes,\n+                                            @Nullable KeyExpression commonPrimaryKey) {\n+        final KeyExpression rootExpression = index.getRootExpression();\n+\n+        final List<KeyExpression> keyFields = new ArrayList<>();\n+        final List<KeyExpression> valueFields = new ArrayList<>();\n+        if (indexTypes.getTextTypes().contains(index.getType())) {\n+            // Full text index entries have all of their fields except the tokenized one.\n+            keyFields.addAll(TextScanPlanner.getOtherFields(rootExpression));\n+        } else if (indexTypes.getValueTypes().contains(index.getType()) ||\n+                   indexTypes.getRankTypes().contains(index.getType())) {\n+            keyFields.addAll(KeyExpression.getKeyFields(rootExpression));\n+            valueFields.addAll(KeyExpression.getValueFields(rootExpression));\n+        } else {\n+            // Aggregate index\n+            if (rootExpression instanceof GroupingKeyExpression) {\n+                GroupingKeyExpression groupingKeyExpression = (GroupingKeyExpression) rootExpression;\n+                keyFields.addAll(groupingKeyExpression.getGroupingSubKey().normalizeKeyForPositions());\n+            }\n+        }\n+\n+        // Like FDBRecordStoreBase.indexEntryKey(), but with key expressions instead of actual values.\n+        final List<KeyExpression> primaryKeys = commonPrimaryKey == null\n+                                                ? Collections.emptyList()\n+                                                : commonPrimaryKey.normalizeKeyForPositions();\n+        index.trimPrimaryKey(primaryKeys);\n+        keyFields.addAll(primaryKeys);\n+\n+        Map<KeyExpression, FieldData> fields = new HashMap<>();\n+        final IndexKeyValueToPartialRecord.Builder builder = IndexKeyValueToPartialRecord.newBuilder(recordType);\n+        for (int i = 0; i < keyFields.size(); i++) {\n+            KeyExpression keyField = keyFields.get(i);\n+            FieldData fieldData = FieldData.of(IndexKeyValueToPartialRecord.TupleSource.KEY, i);\n+            if (!keyField.createsDuplicates() && addCoveringField(keyField, fieldData, builder)) {\n+                fields.put(keyField, fieldData);\n+            }\n+        }\n+        for (int i = 0; i < valueFields.size(); i++) {\n+            KeyExpression valueField = valueFields.get(i);\n+            FieldData fieldData = FieldData.of(IndexKeyValueToPartialRecord.TupleSource.VALUE, i);\n+            if (!valueField.createsDuplicates() && addCoveringField(valueField, fieldData, builder)) {\n+                fields.put(valueField, fieldData);\n+            }\n+        }\n+\n+        if (!builder.isValid()) {\n+            return NO_FIELDS;\n+        }\n+        return new AvailableFields(fields);\n+    }\n+\n+    public static boolean addCoveringField(@Nonnull KeyExpression requiredExpr,\n+                                           @Nonnull FieldData fieldData,\n+                                           @Nonnull IndexKeyValueToPartialRecord.Builder builder) {\n+        while (requiredExpr instanceof NestingKeyExpression) {\n+            NestingKeyExpression nesting = (NestingKeyExpression)requiredExpr;\n+            String fieldName = nesting.getParent().getFieldName();\n+            requiredExpr = nesting.getChild();\n+            builder = builder.getFieldBuilder(fieldName);\n+        }\n+        if (requiredExpr instanceof FieldKeyExpression) {\n+            FieldKeyExpression fieldKeyExpression = (FieldKeyExpression)requiredExpr;\n+            if (!fieldKeyExpression.getNullStandin().equals(Key.Evaluated.NullStandin.NULL) ||\n+                    fieldKeyExpression.getFanType().equals(KeyExpression.FanType.FanOut)) {\n+                return false;\n+            }\n+            builder.addField(fieldKeyExpression.getFieldName(), fieldData.source, fieldData.index);\n+            return true;\n+        } else {\n+            return false;\n+        }\n+    }\n+\n+    @Nonnull\n+    public static AvailableFields intersection(@Nonnull List<AvailableFields> toIntersect) {\n+        if (toIntersect.isEmpty()) {\n+            throw new RecordCoreException(\"tried to find intersection of an empty list of available fields\");\n+        }\n+\n+        Map<KeyExpression, FieldData> intersection = null;\n+        for (AvailableFields fields : toIntersect) {\n+            if (!fields.hasAllFields()) {\n+                if (intersection == null) {\n+                    intersection = new HashMap<>(fields.fields);\n+                } else {\n+                    // keySet() is backed by the map itself\n+                    intersection.keySet().retainAll(fields.fields.keySet());\n+                }\n+            }\n+        }\n+        if (intersection == null) {\n+            return ALL_FIELDS;\n+        } else {\n+            return new AvailableFields(intersection);\n+        }\n+    }\n+\n+    /**\n+     * A pair of a representing a tuple source (key or value) and an index within that tuple source.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7657afbfacc42ab452078e203749342b8a1f6ff0"}, "originalPosition": 196}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "33541e2711e0c33c61892b67e4335bd636c99ce4", "author": {"user": {"login": "nschiefer", "name": "Nicholas Schiefer"}}, "url": "https://github.com/FoundationDB/fdb-record-layer/commit/33541e2711e0c33c61892b67e4335bd636c99ce4", "committedDate": "2020-08-27T22:29:41Z", "message": "Respond to review comments.\n\nCo-authored-by: Mike McMahon <mmcm@comcast.net>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDc3MTI4NzE2", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1018#pullrequestreview-477128716", "createdAt": "2020-08-27T22:32:52Z", "commit": {"oid": "33541e2711e0c33c61892b67e4335bd636c99ce4"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDc3MTYxMDYz", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1018#pullrequestreview-477161063", "createdAt": "2020-08-28T00:07:07Z", "commit": {"oid": "33541e2711e0c33c61892b67e4335bd636c99ce4"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2723, "cost": 1, "resetAt": "2021-11-01T14:20:25Z"}}}