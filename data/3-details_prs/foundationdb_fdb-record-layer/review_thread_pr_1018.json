{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDY5NzI3ODMy", "number": 1018, "reviewThreads": {"totalCount": 9, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOVQyMjowOTozNlrOEaLj3Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yN1QyMTowOToyNVrOEdY4gQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk1ODg3ODM3OnYy", "diffSide": "RIGHT", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/AvailableFields.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOVQyMjowOTozNlrOHDcbGg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNlQxODoxMjoxMFrOHHX5Mg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzM3MzQ2Ng==", "bodyText": "Does this mean full (not-partial) records, where all fields are available by navigation of said record?\nI guess I am unclear whether this comment is speaking generally of scan streams or more specifically of how this class is used.", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1018#discussion_r473373466", "createdAt": "2020-08-19T22:09:36Z", "author": {"login": "MMcM"}, "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/AvailableFields.java", "diffHunk": "@@ -0,0 +1,211 @@\n+/*\n+ * AvailableFields.java\n+ *\n+ * This source file is part of the FoundationDB open source project\n+ *\n+ * Copyright 2015-2020 Apple Inc. and the FoundationDB project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.apple.foundationdb.record.query.plan;\n+\n+import com.apple.foundationdb.record.metadata.Index;\n+import com.apple.foundationdb.record.metadata.Key;\n+import com.apple.foundationdb.record.metadata.RecordType;\n+import com.apple.foundationdb.record.metadata.expressions.FieldKeyExpression;\n+import com.apple.foundationdb.record.metadata.expressions.GroupingKeyExpression;\n+import com.apple.foundationdb.record.metadata.expressions.KeyExpression;\n+import com.apple.foundationdb.record.metadata.expressions.NestingKeyExpression;\n+import com.apple.foundationdb.record.query.plan.planning.TextScanPlanner;\n+import com.google.common.collect.Sets;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+/**\n+ * Represents a subset of the fields available in a stream of records, including partial records.\n+ *\n+ * If a stream includes partial records, all fields are available; they are not represented individually.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "86be71c95c98e46b8dee430ba206d8e96d75d7f8"}, "originalPosition": 47}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzQ5MzU1NA==", "bodyText": "Yes, this should be full records, not partial ones.", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1018#discussion_r477493554", "createdAt": "2020-08-26T18:12:10Z", "author": {"login": "nschiefer"}, "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/AvailableFields.java", "diffHunk": "@@ -0,0 +1,211 @@\n+/*\n+ * AvailableFields.java\n+ *\n+ * This source file is part of the FoundationDB open source project\n+ *\n+ * Copyright 2015-2020 Apple Inc. and the FoundationDB project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.apple.foundationdb.record.query.plan;\n+\n+import com.apple.foundationdb.record.metadata.Index;\n+import com.apple.foundationdb.record.metadata.Key;\n+import com.apple.foundationdb.record.metadata.RecordType;\n+import com.apple.foundationdb.record.metadata.expressions.FieldKeyExpression;\n+import com.apple.foundationdb.record.metadata.expressions.GroupingKeyExpression;\n+import com.apple.foundationdb.record.metadata.expressions.KeyExpression;\n+import com.apple.foundationdb.record.metadata.expressions.NestingKeyExpression;\n+import com.apple.foundationdb.record.query.plan.planning.TextScanPlanner;\n+import com.google.common.collect.Sets;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+/**\n+ * Represents a subset of the fields available in a stream of records, including partial records.\n+ *\n+ * If a stream includes partial records, all fields are available; they are not represented individually.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzM3MzQ2Ng=="}, "originalCommit": {"oid": "86be71c95c98e46b8dee430ba206d8e96d75d7f8"}, "originalPosition": 47}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk1ODkwNjc5OnYy", "diffSide": "RIGHT", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/AvailableFields.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOVQyMjoxNTozN1rOHDctdw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNlQxODoxMzoyOVrOHHX8Lg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzM3ODE2Nw==", "bodyText": "Map.keySet is backed by the map itself, so I think retainAll should work here.", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1018#discussion_r473378167", "createdAt": "2020-08-19T22:15:37Z", "author": {"login": "MMcM"}, "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/AvailableFields.java", "diffHunk": "@@ -0,0 +1,211 @@\n+/*\n+ * AvailableFields.java\n+ *\n+ * This source file is part of the FoundationDB open source project\n+ *\n+ * Copyright 2015-2020 Apple Inc. and the FoundationDB project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.apple.foundationdb.record.query.plan;\n+\n+import com.apple.foundationdb.record.metadata.Index;\n+import com.apple.foundationdb.record.metadata.Key;\n+import com.apple.foundationdb.record.metadata.RecordType;\n+import com.apple.foundationdb.record.metadata.expressions.FieldKeyExpression;\n+import com.apple.foundationdb.record.metadata.expressions.GroupingKeyExpression;\n+import com.apple.foundationdb.record.metadata.expressions.KeyExpression;\n+import com.apple.foundationdb.record.metadata.expressions.NestingKeyExpression;\n+import com.apple.foundationdb.record.query.plan.planning.TextScanPlanner;\n+import com.google.common.collect.Sets;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+/**\n+ * Represents a subset of the fields available in a stream of records, including partial records.\n+ *\n+ * If a stream includes partial records, all fields are available; they are not represented individually.\n+ * For partial records, this class tracks a (non-strict) subset of the fields that are actually available.\n+ * For example, all repeated fields are currently dropped. It is extremely important that no field every be included\n+ * when it is not actually available on a partial record.\n+ */\n+public class AvailableFields {\n+    @Nonnull\n+    public static final AvailableFields ALL_FIELDS = new AvailableFields(null);\n+    @Nonnull\n+    public static final AvailableFields NO_FIELDS = new AvailableFields(Collections.emptyMap());\n+\n+    @Nullable\n+    private final Map<KeyExpression, FieldData> fields;\n+\n+    private AvailableFields(@Nullable Map<KeyExpression, FieldData> fields) {\n+        this.fields = fields;\n+    }\n+\n+\n+    public boolean hasAllFields() {\n+        return fields == null;\n+    }\n+\n+    public boolean containsAll(@Nonnull Collection<KeyExpression> requiredFields) {\n+        if (fields == null) {\n+            return true;\n+        }\n+        return fields.keySet().containsAll(requiredFields);\n+    }\n+\n+    @Nullable\n+    public IndexKeyValueToPartialRecord.Builder buildIndexKeyValueToPartialRecord(@Nonnull RecordType recordType) {\n+        if (fields == null) {\n+            return null;\n+        }\n+\n+        final IndexKeyValueToPartialRecord.Builder builder = IndexKeyValueToPartialRecord.newBuilder(recordType);\n+        for (Map.Entry<KeyExpression, FieldData> entry : fields.entrySet()) {\n+            if (!addCoveringField(entry.getKey(), entry.getValue(), builder)) {\n+                return null;\n+            }\n+        }\n+        if (!builder.isValid()) {\n+            return null;\n+        }\n+\n+        return builder;\n+    }\n+\n+    @Nonnull\n+    public static AvailableFields fromIndex(@Nonnull RecordType recordType,\n+                                            @Nonnull Index index,\n+                                            @Nonnull PlannableIndexTypes indexTypes,\n+                                            @Nullable KeyExpression commonPrimaryKey) {\n+        final KeyExpression rootExpression = index.getRootExpression();\n+\n+        final List<KeyExpression> keyFields = new ArrayList<>();\n+        final List<KeyExpression> valueFields = new ArrayList<>();\n+        if (indexTypes.getTextTypes().contains(index.getType())) {\n+            // Full text index entries have all of their fields except the tokenized one.\n+            keyFields.addAll(TextScanPlanner.getOtherFields(rootExpression));\n+        } else if (indexTypes.getValueTypes().contains(index.getType()) ||\n+                   indexTypes.getRankTypes().contains(index.getType())) {\n+            keyFields.addAll(KeyExpression.getKeyFields(rootExpression));\n+            valueFields.addAll(KeyExpression.getValueFields(rootExpression));\n+        } else {\n+            // Aggregate index\n+            if (rootExpression instanceof GroupingKeyExpression) {\n+                GroupingKeyExpression groupingKeyExpression = (GroupingKeyExpression) rootExpression;\n+                keyFields.addAll(groupingKeyExpression.getGroupingSubKey().normalizeKeyForPositions());\n+            }\n+        }\n+\n+        // Like FDBRecordStoreBase.indexEntryKey(), but with key expressions instead of actual values.\n+        final List<KeyExpression> primaryKeys = commonPrimaryKey == null\n+                                                ? Collections.emptyList()\n+                                                : commonPrimaryKey.normalizeKeyForPositions();\n+        index.trimPrimaryKey(primaryKeys);\n+        keyFields.addAll(primaryKeys);\n+\n+        Map<KeyExpression, FieldData> fields = new HashMap<>();\n+        final IndexKeyValueToPartialRecord.Builder builder = IndexKeyValueToPartialRecord.newBuilder(recordType);\n+        for (int i = 0; i < keyFields.size(); i++) {\n+            KeyExpression keyField = keyFields.get(i);\n+            FieldData fieldData = FieldData.of(IndexKeyValueToPartialRecord.TupleSource.KEY, i);\n+            if (!keyField.createsDuplicates() && addCoveringField(keyField, fieldData, builder)) {\n+                fields.put(keyField, fieldData);\n+            }\n+        }\n+        for (int i = 0; i < valueFields.size(); i++) {\n+            KeyExpression valueField = valueFields.get(i);\n+            FieldData fieldData = FieldData.of(IndexKeyValueToPartialRecord.TupleSource.VALUE, i);\n+            if (!valueField.createsDuplicates() && addCoveringField(valueField, fieldData, builder)) {\n+                fields.put(valueField, fieldData);\n+            }\n+        }\n+\n+        if (!builder.isValid()) {\n+            return NO_FIELDS;\n+        }\n+        return new AvailableFields(fields);\n+    }\n+\n+    public static boolean addCoveringField(@Nonnull KeyExpression requiredExpr,\n+                                           @Nonnull FieldData fieldData,\n+                                           @Nonnull IndexKeyValueToPartialRecord.Builder builder) {\n+        while (requiredExpr instanceof NestingKeyExpression) {\n+            NestingKeyExpression nesting = (NestingKeyExpression)requiredExpr;\n+            String fieldName = nesting.getParent().getFieldName();\n+            requiredExpr = nesting.getChild();\n+            builder = builder.getFieldBuilder(fieldName);\n+        }\n+        if (requiredExpr instanceof FieldKeyExpression) {\n+            FieldKeyExpression fieldKeyExpression = (FieldKeyExpression)requiredExpr;\n+            if (!fieldKeyExpression.getNullStandin().equals(Key.Evaluated.NullStandin.NULL) ||\n+                    fieldKeyExpression.getFanType().equals(KeyExpression.FanType.FanOut)) {\n+                return false;\n+            }\n+            builder.addField(fieldKeyExpression.getFieldName(), fieldData.source, fieldData.index);\n+            return true;\n+        } else {\n+            return false;\n+        }\n+    }\n+\n+    @Nonnull\n+    public static AvailableFields intersection(@Nonnull List<AvailableFields> toIntersect) {\n+        Map<KeyExpression, FieldData> intersection = null;\n+        for (AvailableFields fields : toIntersect) {\n+            if (!fields.hasAllFields()) {\n+                if (intersection == null) {\n+                    intersection = new HashMap<>(fields.fields);\n+                } else {\n+                    Set<KeyExpression> keysToRemove = new HashSet<>(Sets.difference(intersection.keySet(),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "86be71c95c98e46b8dee430ba206d8e96d75d7f8"}, "originalPosition": 180}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzQ5NDMxOA==", "bodyText": "Ah, great, that makes this much tidier.", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1018#discussion_r477494318", "createdAt": "2020-08-26T18:13:29Z", "author": {"login": "nschiefer"}, "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/AvailableFields.java", "diffHunk": "@@ -0,0 +1,211 @@\n+/*\n+ * AvailableFields.java\n+ *\n+ * This source file is part of the FoundationDB open source project\n+ *\n+ * Copyright 2015-2020 Apple Inc. and the FoundationDB project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.apple.foundationdb.record.query.plan;\n+\n+import com.apple.foundationdb.record.metadata.Index;\n+import com.apple.foundationdb.record.metadata.Key;\n+import com.apple.foundationdb.record.metadata.RecordType;\n+import com.apple.foundationdb.record.metadata.expressions.FieldKeyExpression;\n+import com.apple.foundationdb.record.metadata.expressions.GroupingKeyExpression;\n+import com.apple.foundationdb.record.metadata.expressions.KeyExpression;\n+import com.apple.foundationdb.record.metadata.expressions.NestingKeyExpression;\n+import com.apple.foundationdb.record.query.plan.planning.TextScanPlanner;\n+import com.google.common.collect.Sets;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+/**\n+ * Represents a subset of the fields available in a stream of records, including partial records.\n+ *\n+ * If a stream includes partial records, all fields are available; they are not represented individually.\n+ * For partial records, this class tracks a (non-strict) subset of the fields that are actually available.\n+ * For example, all repeated fields are currently dropped. It is extremely important that no field every be included\n+ * when it is not actually available on a partial record.\n+ */\n+public class AvailableFields {\n+    @Nonnull\n+    public static final AvailableFields ALL_FIELDS = new AvailableFields(null);\n+    @Nonnull\n+    public static final AvailableFields NO_FIELDS = new AvailableFields(Collections.emptyMap());\n+\n+    @Nullable\n+    private final Map<KeyExpression, FieldData> fields;\n+\n+    private AvailableFields(@Nullable Map<KeyExpression, FieldData> fields) {\n+        this.fields = fields;\n+    }\n+\n+\n+    public boolean hasAllFields() {\n+        return fields == null;\n+    }\n+\n+    public boolean containsAll(@Nonnull Collection<KeyExpression> requiredFields) {\n+        if (fields == null) {\n+            return true;\n+        }\n+        return fields.keySet().containsAll(requiredFields);\n+    }\n+\n+    @Nullable\n+    public IndexKeyValueToPartialRecord.Builder buildIndexKeyValueToPartialRecord(@Nonnull RecordType recordType) {\n+        if (fields == null) {\n+            return null;\n+        }\n+\n+        final IndexKeyValueToPartialRecord.Builder builder = IndexKeyValueToPartialRecord.newBuilder(recordType);\n+        for (Map.Entry<KeyExpression, FieldData> entry : fields.entrySet()) {\n+            if (!addCoveringField(entry.getKey(), entry.getValue(), builder)) {\n+                return null;\n+            }\n+        }\n+        if (!builder.isValid()) {\n+            return null;\n+        }\n+\n+        return builder;\n+    }\n+\n+    @Nonnull\n+    public static AvailableFields fromIndex(@Nonnull RecordType recordType,\n+                                            @Nonnull Index index,\n+                                            @Nonnull PlannableIndexTypes indexTypes,\n+                                            @Nullable KeyExpression commonPrimaryKey) {\n+        final KeyExpression rootExpression = index.getRootExpression();\n+\n+        final List<KeyExpression> keyFields = new ArrayList<>();\n+        final List<KeyExpression> valueFields = new ArrayList<>();\n+        if (indexTypes.getTextTypes().contains(index.getType())) {\n+            // Full text index entries have all of their fields except the tokenized one.\n+            keyFields.addAll(TextScanPlanner.getOtherFields(rootExpression));\n+        } else if (indexTypes.getValueTypes().contains(index.getType()) ||\n+                   indexTypes.getRankTypes().contains(index.getType())) {\n+            keyFields.addAll(KeyExpression.getKeyFields(rootExpression));\n+            valueFields.addAll(KeyExpression.getValueFields(rootExpression));\n+        } else {\n+            // Aggregate index\n+            if (rootExpression instanceof GroupingKeyExpression) {\n+                GroupingKeyExpression groupingKeyExpression = (GroupingKeyExpression) rootExpression;\n+                keyFields.addAll(groupingKeyExpression.getGroupingSubKey().normalizeKeyForPositions());\n+            }\n+        }\n+\n+        // Like FDBRecordStoreBase.indexEntryKey(), but with key expressions instead of actual values.\n+        final List<KeyExpression> primaryKeys = commonPrimaryKey == null\n+                                                ? Collections.emptyList()\n+                                                : commonPrimaryKey.normalizeKeyForPositions();\n+        index.trimPrimaryKey(primaryKeys);\n+        keyFields.addAll(primaryKeys);\n+\n+        Map<KeyExpression, FieldData> fields = new HashMap<>();\n+        final IndexKeyValueToPartialRecord.Builder builder = IndexKeyValueToPartialRecord.newBuilder(recordType);\n+        for (int i = 0; i < keyFields.size(); i++) {\n+            KeyExpression keyField = keyFields.get(i);\n+            FieldData fieldData = FieldData.of(IndexKeyValueToPartialRecord.TupleSource.KEY, i);\n+            if (!keyField.createsDuplicates() && addCoveringField(keyField, fieldData, builder)) {\n+                fields.put(keyField, fieldData);\n+            }\n+        }\n+        for (int i = 0; i < valueFields.size(); i++) {\n+            KeyExpression valueField = valueFields.get(i);\n+            FieldData fieldData = FieldData.of(IndexKeyValueToPartialRecord.TupleSource.VALUE, i);\n+            if (!valueField.createsDuplicates() && addCoveringField(valueField, fieldData, builder)) {\n+                fields.put(valueField, fieldData);\n+            }\n+        }\n+\n+        if (!builder.isValid()) {\n+            return NO_FIELDS;\n+        }\n+        return new AvailableFields(fields);\n+    }\n+\n+    public static boolean addCoveringField(@Nonnull KeyExpression requiredExpr,\n+                                           @Nonnull FieldData fieldData,\n+                                           @Nonnull IndexKeyValueToPartialRecord.Builder builder) {\n+        while (requiredExpr instanceof NestingKeyExpression) {\n+            NestingKeyExpression nesting = (NestingKeyExpression)requiredExpr;\n+            String fieldName = nesting.getParent().getFieldName();\n+            requiredExpr = nesting.getChild();\n+            builder = builder.getFieldBuilder(fieldName);\n+        }\n+        if (requiredExpr instanceof FieldKeyExpression) {\n+            FieldKeyExpression fieldKeyExpression = (FieldKeyExpression)requiredExpr;\n+            if (!fieldKeyExpression.getNullStandin().equals(Key.Evaluated.NullStandin.NULL) ||\n+                    fieldKeyExpression.getFanType().equals(KeyExpression.FanType.FanOut)) {\n+                return false;\n+            }\n+            builder.addField(fieldKeyExpression.getFieldName(), fieldData.source, fieldData.index);\n+            return true;\n+        } else {\n+            return false;\n+        }\n+    }\n+\n+    @Nonnull\n+    public static AvailableFields intersection(@Nonnull List<AvailableFields> toIntersect) {\n+        Map<KeyExpression, FieldData> intersection = null;\n+        for (AvailableFields fields : toIntersect) {\n+            if (!fields.hasAllFields()) {\n+                if (intersection == null) {\n+                    intersection = new HashMap<>(fields.fields);\n+                } else {\n+                    Set<KeyExpression> keysToRemove = new HashSet<>(Sets.difference(intersection.keySet(),", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzM3ODE2Nw=="}, "originalCommit": {"oid": "86be71c95c98e46b8dee430ba206d8e96d75d7f8"}, "originalPosition": 180}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk1ODk3ODM4OnYy", "diffSide": "RIGHT", "path": "fdb-record-layer-core/src/test/java/com/apple/foundationdb/record/provider/foundationdb/indexes/RankIndexTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOVQyMjozMTozNlrOHDddBQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNlQxODoyMToyNFrOHHYMow==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzM5MDM0MQ==", "bodyText": "Maybe a helper here in this fixture for that?", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1018#discussion_r473390341", "createdAt": "2020-08-19T22:31:36Z", "author": {"login": "MMcM"}, "path": "fdb-record-layer-core/src/test/java/com/apple/foundationdb/record/provider/foundationdb/indexes/RankIndexTest.java", "diffHunk": "@@ -1015,10 +1023,12 @@ public void twoRankPredicates() throws Exception {\n                         Query.rank(Key.Expressions.field(\"score\").groupBy(Key.Expressions.field(\"gender\"))).equalsValue(1L)))\n                 .build();\n         RecordQueryPlan plan = planner.plan(query);\n-        assertEquals(\"Index(rank_by_gender [[M, 1],[M, 1]] BY_RANK)\" +\n-                        \" | score LESS_THAN $__rank_0\" +\n-                        \" WHERE __rank_0 = BasicRankedRecord$score.score_for_rank_else_skip(3)\",\n-                plan.toString());\n+        assertThat(plan, scoreForRank(contains(\n+                hasToString(\"__rank_0 = BasicRankedRecord$score.score_for_rank_else_skip(3)\")),\n+                // need to explicitly construct QueryComponent because we're using an internal parameter", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "86be71c95c98e46b8dee430ba206d8e96d75d7f8"}, "originalPosition": 48}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzQ5ODUzMQ==", "bodyText": "Yes, good idea. Fixed.", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1018#discussion_r477498531", "createdAt": "2020-08-26T18:21:24Z", "author": {"login": "nschiefer"}, "path": "fdb-record-layer-core/src/test/java/com/apple/foundationdb/record/provider/foundationdb/indexes/RankIndexTest.java", "diffHunk": "@@ -1015,10 +1023,12 @@ public void twoRankPredicates() throws Exception {\n                         Query.rank(Key.Expressions.field(\"score\").groupBy(Key.Expressions.field(\"gender\"))).equalsValue(1L)))\n                 .build();\n         RecordQueryPlan plan = planner.plan(query);\n-        assertEquals(\"Index(rank_by_gender [[M, 1],[M, 1]] BY_RANK)\" +\n-                        \" | score LESS_THAN $__rank_0\" +\n-                        \" WHERE __rank_0 = BasicRankedRecord$score.score_for_rank_else_skip(3)\",\n-                plan.toString());\n+        assertThat(plan, scoreForRank(contains(\n+                hasToString(\"__rank_0 = BasicRankedRecord$score.score_for_rank_else_skip(3)\")),\n+                // need to explicitly construct QueryComponent because we're using an internal parameter", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzM5MDM0MQ=="}, "originalCommit": {"oid": "86be71c95c98e46b8dee430ba206d8e96d75d7f8"}, "originalPosition": 48}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk2MzI5MDI3OnYy", "diffSide": "RIGHT", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/AvailableFields.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMFQxNjowMTowMVrOHEIiAA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMFQxNjowMTowMVrOHEIiAA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDA5NjEyOA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n             * For example, all repeated fields are currently dropped. It is extremely important that no field every be included\n          \n          \n            \n             * For example, all repeated fields are currently dropped. It is extremely important that no field ever be included", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1018#discussion_r474096128", "createdAt": "2020-08-20T16:01:01Z", "author": {"login": "normen662"}, "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/AvailableFields.java", "diffHunk": "@@ -0,0 +1,211 @@\n+/*\n+ * AvailableFields.java\n+ *\n+ * This source file is part of the FoundationDB open source project\n+ *\n+ * Copyright 2015-2020 Apple Inc. and the FoundationDB project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.apple.foundationdb.record.query.plan;\n+\n+import com.apple.foundationdb.record.metadata.Index;\n+import com.apple.foundationdb.record.metadata.Key;\n+import com.apple.foundationdb.record.metadata.RecordType;\n+import com.apple.foundationdb.record.metadata.expressions.FieldKeyExpression;\n+import com.apple.foundationdb.record.metadata.expressions.GroupingKeyExpression;\n+import com.apple.foundationdb.record.metadata.expressions.KeyExpression;\n+import com.apple.foundationdb.record.metadata.expressions.NestingKeyExpression;\n+import com.apple.foundationdb.record.query.plan.planning.TextScanPlanner;\n+import com.google.common.collect.Sets;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+/**\n+ * Represents a subset of the fields available in a stream of records, including partial records.\n+ *\n+ * If a stream includes partial records, all fields are available; they are not represented individually.\n+ * For partial records, this class tracks a (non-strict) subset of the fields that are actually available.\n+ * For example, all repeated fields are currently dropped. It is extremely important that no field every be included", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "86be71c95c98e46b8dee430ba206d8e96d75d7f8"}, "originalPosition": 49}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk2MzMxMDIwOnYy", "diffSide": "RIGHT", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/AvailableFields.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMFQxNjowNjowMVrOHEIuhw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNlQxODoyMjoyOFrOHHYO8g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDA5OTMzNQ==", "bodyText": "Not sure if that would be useful, but is this worth logging?", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1018#discussion_r474099335", "createdAt": "2020-08-20T16:06:01Z", "author": {"login": "normen662"}, "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/AvailableFields.java", "diffHunk": "@@ -0,0 +1,211 @@\n+/*\n+ * AvailableFields.java\n+ *\n+ * This source file is part of the FoundationDB open source project\n+ *\n+ * Copyright 2015-2020 Apple Inc. and the FoundationDB project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.apple.foundationdb.record.query.plan;\n+\n+import com.apple.foundationdb.record.metadata.Index;\n+import com.apple.foundationdb.record.metadata.Key;\n+import com.apple.foundationdb.record.metadata.RecordType;\n+import com.apple.foundationdb.record.metadata.expressions.FieldKeyExpression;\n+import com.apple.foundationdb.record.metadata.expressions.GroupingKeyExpression;\n+import com.apple.foundationdb.record.metadata.expressions.KeyExpression;\n+import com.apple.foundationdb.record.metadata.expressions.NestingKeyExpression;\n+import com.apple.foundationdb.record.query.plan.planning.TextScanPlanner;\n+import com.google.common.collect.Sets;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+/**\n+ * Represents a subset of the fields available in a stream of records, including partial records.\n+ *\n+ * If a stream includes partial records, all fields are available; they are not represented individually.\n+ * For partial records, this class tracks a (non-strict) subset of the fields that are actually available.\n+ * For example, all repeated fields are currently dropped. It is extremely important that no field every be included\n+ * when it is not actually available on a partial record.\n+ */\n+public class AvailableFields {\n+    @Nonnull\n+    public static final AvailableFields ALL_FIELDS = new AvailableFields(null);\n+    @Nonnull\n+    public static final AvailableFields NO_FIELDS = new AvailableFields(Collections.emptyMap());\n+\n+    @Nullable\n+    private final Map<KeyExpression, FieldData> fields;\n+\n+    private AvailableFields(@Nullable Map<KeyExpression, FieldData> fields) {\n+        this.fields = fields;\n+    }\n+\n+\n+    public boolean hasAllFields() {\n+        return fields == null;\n+    }\n+\n+    public boolean containsAll(@Nonnull Collection<KeyExpression> requiredFields) {\n+        if (fields == null) {\n+            return true;\n+        }\n+        return fields.keySet().containsAll(requiredFields);\n+    }\n+\n+    @Nullable\n+    public IndexKeyValueToPartialRecord.Builder buildIndexKeyValueToPartialRecord(@Nonnull RecordType recordType) {\n+        if (fields == null) {\n+            return null;\n+        }\n+\n+        final IndexKeyValueToPartialRecord.Builder builder = IndexKeyValueToPartialRecord.newBuilder(recordType);\n+        for (Map.Entry<KeyExpression, FieldData> entry : fields.entrySet()) {\n+            if (!addCoveringField(entry.getKey(), entry.getValue(), builder)) {\n+                return null;\n+            }\n+        }\n+        if (!builder.isValid()) {\n+            return null;\n+        }\n+\n+        return builder;\n+    }\n+\n+    @Nonnull\n+    public static AvailableFields fromIndex(@Nonnull RecordType recordType,\n+                                            @Nonnull Index index,\n+                                            @Nonnull PlannableIndexTypes indexTypes,\n+                                            @Nullable KeyExpression commonPrimaryKey) {\n+        final KeyExpression rootExpression = index.getRootExpression();\n+\n+        final List<KeyExpression> keyFields = new ArrayList<>();\n+        final List<KeyExpression> valueFields = new ArrayList<>();\n+        if (indexTypes.getTextTypes().contains(index.getType())) {\n+            // Full text index entries have all of their fields except the tokenized one.\n+            keyFields.addAll(TextScanPlanner.getOtherFields(rootExpression));\n+        } else if (indexTypes.getValueTypes().contains(index.getType()) ||\n+                   indexTypes.getRankTypes().contains(index.getType())) {\n+            keyFields.addAll(KeyExpression.getKeyFields(rootExpression));\n+            valueFields.addAll(KeyExpression.getValueFields(rootExpression));\n+        } else {\n+            // Aggregate index\n+            if (rootExpression instanceof GroupingKeyExpression) {\n+                GroupingKeyExpression groupingKeyExpression = (GroupingKeyExpression) rootExpression;\n+                keyFields.addAll(groupingKeyExpression.getGroupingSubKey().normalizeKeyForPositions());\n+            }\n+        }\n+\n+        // Like FDBRecordStoreBase.indexEntryKey(), but with key expressions instead of actual values.\n+        final List<KeyExpression> primaryKeys = commonPrimaryKey == null\n+                                                ? Collections.emptyList()\n+                                                : commonPrimaryKey.normalizeKeyForPositions();\n+        index.trimPrimaryKey(primaryKeys);\n+        keyFields.addAll(primaryKeys);\n+\n+        Map<KeyExpression, FieldData> fields = new HashMap<>();\n+        final IndexKeyValueToPartialRecord.Builder builder = IndexKeyValueToPartialRecord.newBuilder(recordType);\n+        for (int i = 0; i < keyFields.size(); i++) {\n+            KeyExpression keyField = keyFields.get(i);\n+            FieldData fieldData = FieldData.of(IndexKeyValueToPartialRecord.TupleSource.KEY, i);\n+            if (!keyField.createsDuplicates() && addCoveringField(keyField, fieldData, builder)) {\n+                fields.put(keyField, fieldData);\n+            }\n+        }\n+        for (int i = 0; i < valueFields.size(); i++) {\n+            KeyExpression valueField = valueFields.get(i);\n+            FieldData fieldData = FieldData.of(IndexKeyValueToPartialRecord.TupleSource.VALUE, i);\n+            if (!valueField.createsDuplicates() && addCoveringField(valueField, fieldData, builder)) {\n+                fields.put(valueField, fieldData);\n+            }\n+        }\n+\n+        if (!builder.isValid()) {\n+            return NO_FIELDS;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "86be71c95c98e46b8dee430ba206d8e96d75d7f8"}, "originalPosition": 145}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzQ5OTEyMg==", "bodyText": "No, this can happen for fairly pedestrian reasons, such as having a repeated field. isValid() is a bit harsh sounding, but I didn't want to change the existing method name.", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1018#discussion_r477499122", "createdAt": "2020-08-26T18:22:28Z", "author": {"login": "nschiefer"}, "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/AvailableFields.java", "diffHunk": "@@ -0,0 +1,211 @@\n+/*\n+ * AvailableFields.java\n+ *\n+ * This source file is part of the FoundationDB open source project\n+ *\n+ * Copyright 2015-2020 Apple Inc. and the FoundationDB project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.apple.foundationdb.record.query.plan;\n+\n+import com.apple.foundationdb.record.metadata.Index;\n+import com.apple.foundationdb.record.metadata.Key;\n+import com.apple.foundationdb.record.metadata.RecordType;\n+import com.apple.foundationdb.record.metadata.expressions.FieldKeyExpression;\n+import com.apple.foundationdb.record.metadata.expressions.GroupingKeyExpression;\n+import com.apple.foundationdb.record.metadata.expressions.KeyExpression;\n+import com.apple.foundationdb.record.metadata.expressions.NestingKeyExpression;\n+import com.apple.foundationdb.record.query.plan.planning.TextScanPlanner;\n+import com.google.common.collect.Sets;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+/**\n+ * Represents a subset of the fields available in a stream of records, including partial records.\n+ *\n+ * If a stream includes partial records, all fields are available; they are not represented individually.\n+ * For partial records, this class tracks a (non-strict) subset of the fields that are actually available.\n+ * For example, all repeated fields are currently dropped. It is extremely important that no field every be included\n+ * when it is not actually available on a partial record.\n+ */\n+public class AvailableFields {\n+    @Nonnull\n+    public static final AvailableFields ALL_FIELDS = new AvailableFields(null);\n+    @Nonnull\n+    public static final AvailableFields NO_FIELDS = new AvailableFields(Collections.emptyMap());\n+\n+    @Nullable\n+    private final Map<KeyExpression, FieldData> fields;\n+\n+    private AvailableFields(@Nullable Map<KeyExpression, FieldData> fields) {\n+        this.fields = fields;\n+    }\n+\n+\n+    public boolean hasAllFields() {\n+        return fields == null;\n+    }\n+\n+    public boolean containsAll(@Nonnull Collection<KeyExpression> requiredFields) {\n+        if (fields == null) {\n+            return true;\n+        }\n+        return fields.keySet().containsAll(requiredFields);\n+    }\n+\n+    @Nullable\n+    public IndexKeyValueToPartialRecord.Builder buildIndexKeyValueToPartialRecord(@Nonnull RecordType recordType) {\n+        if (fields == null) {\n+            return null;\n+        }\n+\n+        final IndexKeyValueToPartialRecord.Builder builder = IndexKeyValueToPartialRecord.newBuilder(recordType);\n+        for (Map.Entry<KeyExpression, FieldData> entry : fields.entrySet()) {\n+            if (!addCoveringField(entry.getKey(), entry.getValue(), builder)) {\n+                return null;\n+            }\n+        }\n+        if (!builder.isValid()) {\n+            return null;\n+        }\n+\n+        return builder;\n+    }\n+\n+    @Nonnull\n+    public static AvailableFields fromIndex(@Nonnull RecordType recordType,\n+                                            @Nonnull Index index,\n+                                            @Nonnull PlannableIndexTypes indexTypes,\n+                                            @Nullable KeyExpression commonPrimaryKey) {\n+        final KeyExpression rootExpression = index.getRootExpression();\n+\n+        final List<KeyExpression> keyFields = new ArrayList<>();\n+        final List<KeyExpression> valueFields = new ArrayList<>();\n+        if (indexTypes.getTextTypes().contains(index.getType())) {\n+            // Full text index entries have all of their fields except the tokenized one.\n+            keyFields.addAll(TextScanPlanner.getOtherFields(rootExpression));\n+        } else if (indexTypes.getValueTypes().contains(index.getType()) ||\n+                   indexTypes.getRankTypes().contains(index.getType())) {\n+            keyFields.addAll(KeyExpression.getKeyFields(rootExpression));\n+            valueFields.addAll(KeyExpression.getValueFields(rootExpression));\n+        } else {\n+            // Aggregate index\n+            if (rootExpression instanceof GroupingKeyExpression) {\n+                GroupingKeyExpression groupingKeyExpression = (GroupingKeyExpression) rootExpression;\n+                keyFields.addAll(groupingKeyExpression.getGroupingSubKey().normalizeKeyForPositions());\n+            }\n+        }\n+\n+        // Like FDBRecordStoreBase.indexEntryKey(), but with key expressions instead of actual values.\n+        final List<KeyExpression> primaryKeys = commonPrimaryKey == null\n+                                                ? Collections.emptyList()\n+                                                : commonPrimaryKey.normalizeKeyForPositions();\n+        index.trimPrimaryKey(primaryKeys);\n+        keyFields.addAll(primaryKeys);\n+\n+        Map<KeyExpression, FieldData> fields = new HashMap<>();\n+        final IndexKeyValueToPartialRecord.Builder builder = IndexKeyValueToPartialRecord.newBuilder(recordType);\n+        for (int i = 0; i < keyFields.size(); i++) {\n+            KeyExpression keyField = keyFields.get(i);\n+            FieldData fieldData = FieldData.of(IndexKeyValueToPartialRecord.TupleSource.KEY, i);\n+            if (!keyField.createsDuplicates() && addCoveringField(keyField, fieldData, builder)) {\n+                fields.put(keyField, fieldData);\n+            }\n+        }\n+        for (int i = 0; i < valueFields.size(); i++) {\n+            KeyExpression valueField = valueFields.get(i);\n+            FieldData fieldData = FieldData.of(IndexKeyValueToPartialRecord.TupleSource.VALUE, i);\n+            if (!valueField.createsDuplicates() && addCoveringField(valueField, fieldData, builder)) {\n+                fields.put(valueField, fieldData);\n+            }\n+        }\n+\n+        if (!builder.isValid()) {\n+            return NO_FIELDS;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDA5OTMzNQ=="}, "originalCommit": {"oid": "86be71c95c98e46b8dee430ba206d8e96d75d7f8"}, "originalPosition": 145}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk2MzM4NDU5OnYy", "diffSide": "RIGHT", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/AvailableFields.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMFQxNjoyNDo0MVrOHEJcnQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNlQxODoyNToyNlrOHHYVhQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDExMTEzMw==", "bodyText": "Hmm, let me just list out two thoughts I have here:\n\nIn a perfect world, we should always know the universe of fields that actually comprise all fields. Since we presumably don't know that in all cases, we use a special value to represent all fields. If that assumption on my side is true, then I guess we cannot do better, however, this may be error prone going forward or just straight out lose information. I mean ALL intersection set should not be set as ALL may be a superset or a subset of set in the most general case.\nThis intersection has a weird behavioral knack when it comes to an empty list of fields to intersect which would return all fields which feels counterintuitive. I am not sure if this can happen but if it cannot happen through callers, maybe this case should be verified and this should bail or return something else. I only see intersection and union base plans to call this, maybe I missed one.", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1018#discussion_r474111133", "createdAt": "2020-08-20T16:24:41Z", "author": {"login": "normen662"}, "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/AvailableFields.java", "diffHunk": "@@ -0,0 +1,211 @@\n+/*\n+ * AvailableFields.java\n+ *\n+ * This source file is part of the FoundationDB open source project\n+ *\n+ * Copyright 2015-2020 Apple Inc. and the FoundationDB project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.apple.foundationdb.record.query.plan;\n+\n+import com.apple.foundationdb.record.metadata.Index;\n+import com.apple.foundationdb.record.metadata.Key;\n+import com.apple.foundationdb.record.metadata.RecordType;\n+import com.apple.foundationdb.record.metadata.expressions.FieldKeyExpression;\n+import com.apple.foundationdb.record.metadata.expressions.GroupingKeyExpression;\n+import com.apple.foundationdb.record.metadata.expressions.KeyExpression;\n+import com.apple.foundationdb.record.metadata.expressions.NestingKeyExpression;\n+import com.apple.foundationdb.record.query.plan.planning.TextScanPlanner;\n+import com.google.common.collect.Sets;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+/**\n+ * Represents a subset of the fields available in a stream of records, including partial records.\n+ *\n+ * If a stream includes partial records, all fields are available; they are not represented individually.\n+ * For partial records, this class tracks a (non-strict) subset of the fields that are actually available.\n+ * For example, all repeated fields are currently dropped. It is extremely important that no field every be included\n+ * when it is not actually available on a partial record.\n+ */\n+public class AvailableFields {\n+    @Nonnull\n+    public static final AvailableFields ALL_FIELDS = new AvailableFields(null);\n+    @Nonnull\n+    public static final AvailableFields NO_FIELDS = new AvailableFields(Collections.emptyMap());\n+\n+    @Nullable\n+    private final Map<KeyExpression, FieldData> fields;\n+\n+    private AvailableFields(@Nullable Map<KeyExpression, FieldData> fields) {\n+        this.fields = fields;\n+    }\n+\n+\n+    public boolean hasAllFields() {\n+        return fields == null;\n+    }\n+\n+    public boolean containsAll(@Nonnull Collection<KeyExpression> requiredFields) {\n+        if (fields == null) {\n+            return true;\n+        }\n+        return fields.keySet().containsAll(requiredFields);\n+    }\n+\n+    @Nullable\n+    public IndexKeyValueToPartialRecord.Builder buildIndexKeyValueToPartialRecord(@Nonnull RecordType recordType) {\n+        if (fields == null) {\n+            return null;\n+        }\n+\n+        final IndexKeyValueToPartialRecord.Builder builder = IndexKeyValueToPartialRecord.newBuilder(recordType);\n+        for (Map.Entry<KeyExpression, FieldData> entry : fields.entrySet()) {\n+            if (!addCoveringField(entry.getKey(), entry.getValue(), builder)) {\n+                return null;\n+            }\n+        }\n+        if (!builder.isValid()) {\n+            return null;\n+        }\n+\n+        return builder;\n+    }\n+\n+    @Nonnull\n+    public static AvailableFields fromIndex(@Nonnull RecordType recordType,\n+                                            @Nonnull Index index,\n+                                            @Nonnull PlannableIndexTypes indexTypes,\n+                                            @Nullable KeyExpression commonPrimaryKey) {\n+        final KeyExpression rootExpression = index.getRootExpression();\n+\n+        final List<KeyExpression> keyFields = new ArrayList<>();\n+        final List<KeyExpression> valueFields = new ArrayList<>();\n+        if (indexTypes.getTextTypes().contains(index.getType())) {\n+            // Full text index entries have all of their fields except the tokenized one.\n+            keyFields.addAll(TextScanPlanner.getOtherFields(rootExpression));\n+        } else if (indexTypes.getValueTypes().contains(index.getType()) ||\n+                   indexTypes.getRankTypes().contains(index.getType())) {\n+            keyFields.addAll(KeyExpression.getKeyFields(rootExpression));\n+            valueFields.addAll(KeyExpression.getValueFields(rootExpression));\n+        } else {\n+            // Aggregate index\n+            if (rootExpression instanceof GroupingKeyExpression) {\n+                GroupingKeyExpression groupingKeyExpression = (GroupingKeyExpression) rootExpression;\n+                keyFields.addAll(groupingKeyExpression.getGroupingSubKey().normalizeKeyForPositions());\n+            }\n+        }\n+\n+        // Like FDBRecordStoreBase.indexEntryKey(), but with key expressions instead of actual values.\n+        final List<KeyExpression> primaryKeys = commonPrimaryKey == null\n+                                                ? Collections.emptyList()\n+                                                : commonPrimaryKey.normalizeKeyForPositions();\n+        index.trimPrimaryKey(primaryKeys);\n+        keyFields.addAll(primaryKeys);\n+\n+        Map<KeyExpression, FieldData> fields = new HashMap<>();\n+        final IndexKeyValueToPartialRecord.Builder builder = IndexKeyValueToPartialRecord.newBuilder(recordType);\n+        for (int i = 0; i < keyFields.size(); i++) {\n+            KeyExpression keyField = keyFields.get(i);\n+            FieldData fieldData = FieldData.of(IndexKeyValueToPartialRecord.TupleSource.KEY, i);\n+            if (!keyField.createsDuplicates() && addCoveringField(keyField, fieldData, builder)) {\n+                fields.put(keyField, fieldData);\n+            }\n+        }\n+        for (int i = 0; i < valueFields.size(); i++) {\n+            KeyExpression valueField = valueFields.get(i);\n+            FieldData fieldData = FieldData.of(IndexKeyValueToPartialRecord.TupleSource.VALUE, i);\n+            if (!valueField.createsDuplicates() && addCoveringField(valueField, fieldData, builder)) {\n+                fields.put(valueField, fieldData);\n+            }\n+        }\n+\n+        if (!builder.isValid()) {\n+            return NO_FIELDS;\n+        }\n+        return new AvailableFields(fields);\n+    }\n+\n+    public static boolean addCoveringField(@Nonnull KeyExpression requiredExpr,\n+                                           @Nonnull FieldData fieldData,\n+                                           @Nonnull IndexKeyValueToPartialRecord.Builder builder) {\n+        while (requiredExpr instanceof NestingKeyExpression) {\n+            NestingKeyExpression nesting = (NestingKeyExpression)requiredExpr;\n+            String fieldName = nesting.getParent().getFieldName();\n+            requiredExpr = nesting.getChild();\n+            builder = builder.getFieldBuilder(fieldName);\n+        }\n+        if (requiredExpr instanceof FieldKeyExpression) {\n+            FieldKeyExpression fieldKeyExpression = (FieldKeyExpression)requiredExpr;\n+            if (!fieldKeyExpression.getNullStandin().equals(Key.Evaluated.NullStandin.NULL) ||\n+                    fieldKeyExpression.getFanType().equals(KeyExpression.FanType.FanOut)) {\n+                return false;\n+            }\n+            builder.addField(fieldKeyExpression.getFieldName(), fieldData.source, fieldData.index);\n+            return true;\n+        } else {\n+            return false;\n+        }\n+    }\n+\n+    @Nonnull\n+    public static AvailableFields intersection(@Nonnull List<AvailableFields> toIntersect) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "86be71c95c98e46b8dee430ba206d8e96d75d7f8"}, "originalPosition": 173}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzUwMDgwNQ==", "bodyText": "With regard to the first thought, I agree in principle but think this should be handled in a more systematic way. Right now, it's remarkably difficult to say exactly what fields are present, because the way that \"present\" is defined varies by context. For example, is a repeated field \"present\"? For the purposes of covering optimizations, it is not, but in general it probably is. I believe that the logic we have here is circumstantially correct and also fairly simple. The join-based framework you're working on will clarify a lot of these issues.\nRegarding the second point, that's an oversight on my part. This is only ever called by union and intersection plans, w which are required to have a least two children. I've added a check that throws an exception if this gets called on an empty list.", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1018#discussion_r477500805", "createdAt": "2020-08-26T18:25:26Z", "author": {"login": "nschiefer"}, "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/AvailableFields.java", "diffHunk": "@@ -0,0 +1,211 @@\n+/*\n+ * AvailableFields.java\n+ *\n+ * This source file is part of the FoundationDB open source project\n+ *\n+ * Copyright 2015-2020 Apple Inc. and the FoundationDB project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.apple.foundationdb.record.query.plan;\n+\n+import com.apple.foundationdb.record.metadata.Index;\n+import com.apple.foundationdb.record.metadata.Key;\n+import com.apple.foundationdb.record.metadata.RecordType;\n+import com.apple.foundationdb.record.metadata.expressions.FieldKeyExpression;\n+import com.apple.foundationdb.record.metadata.expressions.GroupingKeyExpression;\n+import com.apple.foundationdb.record.metadata.expressions.KeyExpression;\n+import com.apple.foundationdb.record.metadata.expressions.NestingKeyExpression;\n+import com.apple.foundationdb.record.query.plan.planning.TextScanPlanner;\n+import com.google.common.collect.Sets;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+/**\n+ * Represents a subset of the fields available in a stream of records, including partial records.\n+ *\n+ * If a stream includes partial records, all fields are available; they are not represented individually.\n+ * For partial records, this class tracks a (non-strict) subset of the fields that are actually available.\n+ * For example, all repeated fields are currently dropped. It is extremely important that no field every be included\n+ * when it is not actually available on a partial record.\n+ */\n+public class AvailableFields {\n+    @Nonnull\n+    public static final AvailableFields ALL_FIELDS = new AvailableFields(null);\n+    @Nonnull\n+    public static final AvailableFields NO_FIELDS = new AvailableFields(Collections.emptyMap());\n+\n+    @Nullable\n+    private final Map<KeyExpression, FieldData> fields;\n+\n+    private AvailableFields(@Nullable Map<KeyExpression, FieldData> fields) {\n+        this.fields = fields;\n+    }\n+\n+\n+    public boolean hasAllFields() {\n+        return fields == null;\n+    }\n+\n+    public boolean containsAll(@Nonnull Collection<KeyExpression> requiredFields) {\n+        if (fields == null) {\n+            return true;\n+        }\n+        return fields.keySet().containsAll(requiredFields);\n+    }\n+\n+    @Nullable\n+    public IndexKeyValueToPartialRecord.Builder buildIndexKeyValueToPartialRecord(@Nonnull RecordType recordType) {\n+        if (fields == null) {\n+            return null;\n+        }\n+\n+        final IndexKeyValueToPartialRecord.Builder builder = IndexKeyValueToPartialRecord.newBuilder(recordType);\n+        for (Map.Entry<KeyExpression, FieldData> entry : fields.entrySet()) {\n+            if (!addCoveringField(entry.getKey(), entry.getValue(), builder)) {\n+                return null;\n+            }\n+        }\n+        if (!builder.isValid()) {\n+            return null;\n+        }\n+\n+        return builder;\n+    }\n+\n+    @Nonnull\n+    public static AvailableFields fromIndex(@Nonnull RecordType recordType,\n+                                            @Nonnull Index index,\n+                                            @Nonnull PlannableIndexTypes indexTypes,\n+                                            @Nullable KeyExpression commonPrimaryKey) {\n+        final KeyExpression rootExpression = index.getRootExpression();\n+\n+        final List<KeyExpression> keyFields = new ArrayList<>();\n+        final List<KeyExpression> valueFields = new ArrayList<>();\n+        if (indexTypes.getTextTypes().contains(index.getType())) {\n+            // Full text index entries have all of their fields except the tokenized one.\n+            keyFields.addAll(TextScanPlanner.getOtherFields(rootExpression));\n+        } else if (indexTypes.getValueTypes().contains(index.getType()) ||\n+                   indexTypes.getRankTypes().contains(index.getType())) {\n+            keyFields.addAll(KeyExpression.getKeyFields(rootExpression));\n+            valueFields.addAll(KeyExpression.getValueFields(rootExpression));\n+        } else {\n+            // Aggregate index\n+            if (rootExpression instanceof GroupingKeyExpression) {\n+                GroupingKeyExpression groupingKeyExpression = (GroupingKeyExpression) rootExpression;\n+                keyFields.addAll(groupingKeyExpression.getGroupingSubKey().normalizeKeyForPositions());\n+            }\n+        }\n+\n+        // Like FDBRecordStoreBase.indexEntryKey(), but with key expressions instead of actual values.\n+        final List<KeyExpression> primaryKeys = commonPrimaryKey == null\n+                                                ? Collections.emptyList()\n+                                                : commonPrimaryKey.normalizeKeyForPositions();\n+        index.trimPrimaryKey(primaryKeys);\n+        keyFields.addAll(primaryKeys);\n+\n+        Map<KeyExpression, FieldData> fields = new HashMap<>();\n+        final IndexKeyValueToPartialRecord.Builder builder = IndexKeyValueToPartialRecord.newBuilder(recordType);\n+        for (int i = 0; i < keyFields.size(); i++) {\n+            KeyExpression keyField = keyFields.get(i);\n+            FieldData fieldData = FieldData.of(IndexKeyValueToPartialRecord.TupleSource.KEY, i);\n+            if (!keyField.createsDuplicates() && addCoveringField(keyField, fieldData, builder)) {\n+                fields.put(keyField, fieldData);\n+            }\n+        }\n+        for (int i = 0; i < valueFields.size(); i++) {\n+            KeyExpression valueField = valueFields.get(i);\n+            FieldData fieldData = FieldData.of(IndexKeyValueToPartialRecord.TupleSource.VALUE, i);\n+            if (!valueField.createsDuplicates() && addCoveringField(valueField, fieldData, builder)) {\n+                fields.put(valueField, fieldData);\n+            }\n+        }\n+\n+        if (!builder.isValid()) {\n+            return NO_FIELDS;\n+        }\n+        return new AvailableFields(fields);\n+    }\n+\n+    public static boolean addCoveringField(@Nonnull KeyExpression requiredExpr,\n+                                           @Nonnull FieldData fieldData,\n+                                           @Nonnull IndexKeyValueToPartialRecord.Builder builder) {\n+        while (requiredExpr instanceof NestingKeyExpression) {\n+            NestingKeyExpression nesting = (NestingKeyExpression)requiredExpr;\n+            String fieldName = nesting.getParent().getFieldName();\n+            requiredExpr = nesting.getChild();\n+            builder = builder.getFieldBuilder(fieldName);\n+        }\n+        if (requiredExpr instanceof FieldKeyExpression) {\n+            FieldKeyExpression fieldKeyExpression = (FieldKeyExpression)requiredExpr;\n+            if (!fieldKeyExpression.getNullStandin().equals(Key.Evaluated.NullStandin.NULL) ||\n+                    fieldKeyExpression.getFanType().equals(KeyExpression.FanType.FanOut)) {\n+                return false;\n+            }\n+            builder.addField(fieldKeyExpression.getFieldName(), fieldData.source, fieldData.index);\n+            return true;\n+        } else {\n+            return false;\n+        }\n+    }\n+\n+    @Nonnull\n+    public static AvailableFields intersection(@Nonnull List<AvailableFields> toIntersect) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDExMTEzMw=="}, "originalCommit": {"oid": "86be71c95c98e46b8dee430ba206d8e96d75d7f8"}, "originalPosition": 173}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk2Nzg1MDY4OnYy", "diffSide": "RIGHT", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/plans/RecordQueryIntersectionPlan.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMVQxNjo0NzoxNlrOHE0M0w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNlQxODoyNjoyOVrOHHYX3w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDgxMTYwMw==", "bodyText": "This cannot be empty, I don't think the other callers can be empty either -- maybe let's not allow intersections of zero number of operands.", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1018#discussion_r474811603", "createdAt": "2020-08-21T16:47:16Z", "author": {"login": "normen662"}, "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/plans/RecordQueryIntersectionPlan.java", "diffHunk": "@@ -202,8 +203,16 @@ public boolean equalsWithoutChildren(@Nonnull RelationalExpression otherExpressi\n                comparisonKey.equals(other.comparisonKey);\n     }\n \n-    @SuppressWarnings(\"EqualsWhichDoesntCheckParameterClass\")\n+    @Nonnull\n+    @Override\n+    public AvailableFields getAvailableFields() {\n+        return AvailableFields.intersection(quantifiers.stream()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "86be71c95c98e46b8dee430ba206d8e96d75d7f8"}, "originalPosition": 16}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzUwMTQwNw==", "bodyText": "RecordQueryIntersectionPlan requires at least two children (see line 294). However, I've added a check to AvailableFields so that it can't be misused.", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1018#discussion_r477501407", "createdAt": "2020-08-26T18:26:29Z", "author": {"login": "nschiefer"}, "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/plans/RecordQueryIntersectionPlan.java", "diffHunk": "@@ -202,8 +203,16 @@ public boolean equalsWithoutChildren(@Nonnull RelationalExpression otherExpressi\n                comparisonKey.equals(other.comparisonKey);\n     }\n \n-    @SuppressWarnings(\"EqualsWhichDoesntCheckParameterClass\")\n+    @Nonnull\n+    @Override\n+    public AvailableFields getAvailableFields() {\n+        return AvailableFields.intersection(quantifiers.stream()", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDgxMTYwMw=="}, "originalCommit": {"oid": "86be71c95c98e46b8dee430ba206d8e96d75d7f8"}, "originalPosition": 16}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk2Nzg1NTkyOnYy", "diffSide": "RIGHT", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/visitor/FilterVisitor.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMVQxNjo0OTowOFrOHE0QBA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNlQxODoyNzoyNVrOHHYZ4g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDgxMjQyMA==", "bodyText": "property visitor?", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1018#discussion_r474812420", "createdAt": "2020-08-21T16:49:08Z", "author": {"login": "normen662"}, "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/visitor/FilterVisitor.java", "diffHunk": "@@ -0,0 +1,116 @@\n+/*\n+ * FilterVisitor.java\n+ *\n+ * This source file is part of the FoundationDB open source project\n+ *\n+ * Copyright 2015-2020 Apple Inc. and the FoundationDB project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.apple.foundationdb.record.query.plan.visitor;\n+\n+import com.apple.foundationdb.record.RecordMetaData;\n+import com.apple.foundationdb.record.metadata.Key;\n+import com.apple.foundationdb.record.metadata.expressions.FunctionKeyExpression;\n+import com.apple.foundationdb.record.metadata.expressions.KeyExpression;\n+import com.apple.foundationdb.record.metadata.expressions.LiteralKeyExpression;\n+import com.apple.foundationdb.record.metadata.expressions.QueryableKeyExpression;\n+import com.apple.foundationdb.record.metadata.expressions.ThenKeyExpression;\n+import com.apple.foundationdb.record.query.expressions.AndOrComponent;\n+import com.apple.foundationdb.record.query.expressions.FieldWithComparison;\n+import com.apple.foundationdb.record.query.expressions.QueryComponent;\n+import com.apple.foundationdb.record.query.expressions.QueryKeyExpressionWithComparison;\n+import com.apple.foundationdb.record.query.plan.PlannableIndexTypes;\n+import com.apple.foundationdb.record.query.plan.plans.RecordQueryFetchFromPartialRecordPlan;\n+import com.apple.foundationdb.record.query.plan.plans.RecordQueryFilterPlan;\n+import com.apple.foundationdb.record.query.plan.plans.RecordQueryPlan;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+import java.util.HashSet;\n+import java.util.Set;\n+\n+/**\n+ * A substitution visitor that pushes a filter below a record fetch if all of the (non-repeated) field are available\n+ * in a covering scan.\n+ */\n+public class FilterVisitor extends RecordQueryPlannerSubstitutionVisitor {\n+    public FilterVisitor(@Nonnull final RecordMetaData recordMetadata, @Nonnull final PlannableIndexTypes indexTypes, @Nullable final KeyExpression commonPrimaryKey) {\n+        super(recordMetadata, indexTypes, commonPrimaryKey);\n+    }\n+\n+    @Nonnull\n+    @Override\n+    public RecordQueryPlan postVisit(@Nonnull final RecordQueryPlan recordQueryPlan) {\n+        if (recordQueryPlan instanceof RecordQueryFilterPlan) {\n+            final RecordQueryFilterPlan filterPlan = (RecordQueryFilterPlan)recordQueryPlan;\n+            final QueryComponent filter = filterPlan.getFilter();\n+            final Set<KeyExpression> filterFields = new HashSet<>();\n+            boolean canCollectFilterFields = findFilterCoveredFields(filter, filterFields);\n+\n+            if (canCollectFilterFields) {\n+                @Nullable RecordQueryPlan newPlan = removeIndexFetch(filterPlan.getChild(), filterFields);\n+                if (newPlan != null) {\n+                    return new RecordQueryFetchFromPartialRecordPlan(new RecordQueryFilterPlan(newPlan, filter));\n+                }\n+            }\n+        }\n+        return recordQueryPlan;\n+    }\n+\n+    // Find equivalent key expressions for fields used by the given filter.\n+    // Does not attempt to deal with OneOfThemWithComponent, as the repeated nested field will be spread across multiple\n+    // index entries. Reconstituting that as a singleton in a partial record might work for the simplest case, but\n+    // could not for multiple such filter conditions.\n+    private static boolean findFilterCoveredFields(@Nonnull QueryComponent filter, @Nonnull Set<KeyExpression> filterFields) {\n+        if (filter instanceof FieldWithComparison) {\n+            filterFields.add(Key.Expressions.field(((FieldWithComparison)filter).getFieldName()));\n+            return true;\n+        }\n+        if (filter instanceof AndOrComponent) {\n+            for (QueryComponent child : ((AndOrComponent)filter).getChildren()) {\n+                if (!findFilterCoveredFields(child, filterFields)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "86be71c95c98e46b8dee430ba206d8e96d75d7f8"}, "originalPosition": 83}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzUwMTkyMg==", "bodyText": "It can't quite be a property visitor because the property visitors no longer visit QueryComponents (and probably never will, because the new planner uses QueryPredicate instead). It's the same concept, but I think we should leave anything like this for a future refactor.", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1018#discussion_r477501922", "createdAt": "2020-08-26T18:27:25Z", "author": {"login": "nschiefer"}, "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/visitor/FilterVisitor.java", "diffHunk": "@@ -0,0 +1,116 @@\n+/*\n+ * FilterVisitor.java\n+ *\n+ * This source file is part of the FoundationDB open source project\n+ *\n+ * Copyright 2015-2020 Apple Inc. and the FoundationDB project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.apple.foundationdb.record.query.plan.visitor;\n+\n+import com.apple.foundationdb.record.RecordMetaData;\n+import com.apple.foundationdb.record.metadata.Key;\n+import com.apple.foundationdb.record.metadata.expressions.FunctionKeyExpression;\n+import com.apple.foundationdb.record.metadata.expressions.KeyExpression;\n+import com.apple.foundationdb.record.metadata.expressions.LiteralKeyExpression;\n+import com.apple.foundationdb.record.metadata.expressions.QueryableKeyExpression;\n+import com.apple.foundationdb.record.metadata.expressions.ThenKeyExpression;\n+import com.apple.foundationdb.record.query.expressions.AndOrComponent;\n+import com.apple.foundationdb.record.query.expressions.FieldWithComparison;\n+import com.apple.foundationdb.record.query.expressions.QueryComponent;\n+import com.apple.foundationdb.record.query.expressions.QueryKeyExpressionWithComparison;\n+import com.apple.foundationdb.record.query.plan.PlannableIndexTypes;\n+import com.apple.foundationdb.record.query.plan.plans.RecordQueryFetchFromPartialRecordPlan;\n+import com.apple.foundationdb.record.query.plan.plans.RecordQueryFilterPlan;\n+import com.apple.foundationdb.record.query.plan.plans.RecordQueryPlan;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+import java.util.HashSet;\n+import java.util.Set;\n+\n+/**\n+ * A substitution visitor that pushes a filter below a record fetch if all of the (non-repeated) field are available\n+ * in a covering scan.\n+ */\n+public class FilterVisitor extends RecordQueryPlannerSubstitutionVisitor {\n+    public FilterVisitor(@Nonnull final RecordMetaData recordMetadata, @Nonnull final PlannableIndexTypes indexTypes, @Nullable final KeyExpression commonPrimaryKey) {\n+        super(recordMetadata, indexTypes, commonPrimaryKey);\n+    }\n+\n+    @Nonnull\n+    @Override\n+    public RecordQueryPlan postVisit(@Nonnull final RecordQueryPlan recordQueryPlan) {\n+        if (recordQueryPlan instanceof RecordQueryFilterPlan) {\n+            final RecordQueryFilterPlan filterPlan = (RecordQueryFilterPlan)recordQueryPlan;\n+            final QueryComponent filter = filterPlan.getFilter();\n+            final Set<KeyExpression> filterFields = new HashSet<>();\n+            boolean canCollectFilterFields = findFilterCoveredFields(filter, filterFields);\n+\n+            if (canCollectFilterFields) {\n+                @Nullable RecordQueryPlan newPlan = removeIndexFetch(filterPlan.getChild(), filterFields);\n+                if (newPlan != null) {\n+                    return new RecordQueryFetchFromPartialRecordPlan(new RecordQueryFilterPlan(newPlan, filter));\n+                }\n+            }\n+        }\n+        return recordQueryPlan;\n+    }\n+\n+    // Find equivalent key expressions for fields used by the given filter.\n+    // Does not attempt to deal with OneOfThemWithComponent, as the repeated nested field will be spread across multiple\n+    // index entries. Reconstituting that as a singleton in a partial record might work for the simplest case, but\n+    // could not for multiple such filter conditions.\n+    private static boolean findFilterCoveredFields(@Nonnull QueryComponent filter, @Nonnull Set<KeyExpression> filterFields) {\n+        if (filter instanceof FieldWithComparison) {\n+            filterFields.add(Key.Expressions.field(((FieldWithComparison)filter).getFieldName()));\n+            return true;\n+        }\n+        if (filter instanceof AndOrComponent) {\n+            for (QueryComponent child : ((AndOrComponent)filter).getChildren()) {\n+                if (!findFilterCoveredFields(child, filterFields)) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDgxMjQyMA=="}, "originalCommit": {"oid": "86be71c95c98e46b8dee430ba206d8e96d75d7f8"}, "originalPosition": 83}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk5MjUxODQxOnYy", "diffSide": "RIGHT", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/AvailableFields.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yN1QyMTowOToyNVrOHIhWXg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yN1QyMTowOToyNVrOHIhWXg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODY5NzA1NA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * A pair of a representing a tuple source (key or value) and an index within that tuple source.\n          \n          \n            \n                 * A pair of a tuple source (key or value) and an index within that tuple source.", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1018#discussion_r478697054", "createdAt": "2020-08-27T21:09:25Z", "author": {"login": "MMcM"}, "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/AvailableFields.java", "diffHunk": "@@ -0,0 +1,215 @@\n+/*\n+ * AvailableFields.java\n+ *\n+ * This source file is part of the FoundationDB open source project\n+ *\n+ * Copyright 2015-2020 Apple Inc. and the FoundationDB project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.apple.foundationdb.record.query.plan;\n+\n+import com.apple.foundationdb.annotation.API;\n+import com.apple.foundationdb.record.RecordCoreException;\n+import com.apple.foundationdb.record.metadata.Index;\n+import com.apple.foundationdb.record.metadata.Key;\n+import com.apple.foundationdb.record.metadata.RecordType;\n+import com.apple.foundationdb.record.metadata.expressions.FieldKeyExpression;\n+import com.apple.foundationdb.record.metadata.expressions.GroupingKeyExpression;\n+import com.apple.foundationdb.record.metadata.expressions.KeyExpression;\n+import com.apple.foundationdb.record.metadata.expressions.NestingKeyExpression;\n+import com.apple.foundationdb.record.query.plan.planning.TextScanPlanner;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+/**\n+ * Represents a subset of the fields available in a stream of records, including partial records.\n+ *\n+ * If a stream includes full records, all fields are available; they are not represented individually.\n+ * For partial records, this class tracks a (non-strict) subset of the fields that are actually available.\n+ * For example, all repeated fields are currently dropped. It is extremely important that no field ever be included\n+ * when it is not actually available on a partial record.\n+ */\n+public class AvailableFields {\n+    @Nonnull\n+    public static final AvailableFields ALL_FIELDS = new AvailableFields(null);\n+    @Nonnull\n+    public static final AvailableFields NO_FIELDS = new AvailableFields(Collections.emptyMap());\n+\n+    @Nullable\n+    private final Map<KeyExpression, FieldData> fields;\n+\n+    private AvailableFields(@Nullable Map<KeyExpression, FieldData> fields) {\n+        this.fields = fields;\n+    }\n+\n+\n+    public boolean hasAllFields() {\n+        return fields == null;\n+    }\n+\n+    public boolean containsAll(@Nonnull Collection<KeyExpression> requiredFields) {\n+        if (fields == null) {\n+            return true;\n+        }\n+        return fields.keySet().containsAll(requiredFields);\n+    }\n+\n+    @Nullable\n+    public IndexKeyValueToPartialRecord.Builder buildIndexKeyValueToPartialRecord(@Nonnull RecordType recordType) {\n+        if (fields == null) {\n+            return null;\n+        }\n+\n+        final IndexKeyValueToPartialRecord.Builder builder = IndexKeyValueToPartialRecord.newBuilder(recordType);\n+        for (Map.Entry<KeyExpression, FieldData> entry : fields.entrySet()) {\n+            if (!addCoveringField(entry.getKey(), entry.getValue(), builder)) {\n+                return null;\n+            }\n+        }\n+        if (!builder.isValid()) {\n+            return null;\n+        }\n+\n+        return builder;\n+    }\n+\n+    @Nonnull\n+    public static AvailableFields fromIndex(@Nonnull RecordType recordType,\n+                                            @Nonnull Index index,\n+                                            @Nonnull PlannableIndexTypes indexTypes,\n+                                            @Nullable KeyExpression commonPrimaryKey) {\n+        final KeyExpression rootExpression = index.getRootExpression();\n+\n+        final List<KeyExpression> keyFields = new ArrayList<>();\n+        final List<KeyExpression> valueFields = new ArrayList<>();\n+        if (indexTypes.getTextTypes().contains(index.getType())) {\n+            // Full text index entries have all of their fields except the tokenized one.\n+            keyFields.addAll(TextScanPlanner.getOtherFields(rootExpression));\n+        } else if (indexTypes.getValueTypes().contains(index.getType()) ||\n+                   indexTypes.getRankTypes().contains(index.getType())) {\n+            keyFields.addAll(KeyExpression.getKeyFields(rootExpression));\n+            valueFields.addAll(KeyExpression.getValueFields(rootExpression));\n+        } else {\n+            // Aggregate index\n+            if (rootExpression instanceof GroupingKeyExpression) {\n+                GroupingKeyExpression groupingKeyExpression = (GroupingKeyExpression) rootExpression;\n+                keyFields.addAll(groupingKeyExpression.getGroupingSubKey().normalizeKeyForPositions());\n+            }\n+        }\n+\n+        // Like FDBRecordStoreBase.indexEntryKey(), but with key expressions instead of actual values.\n+        final List<KeyExpression> primaryKeys = commonPrimaryKey == null\n+                                                ? Collections.emptyList()\n+                                                : commonPrimaryKey.normalizeKeyForPositions();\n+        index.trimPrimaryKey(primaryKeys);\n+        keyFields.addAll(primaryKeys);\n+\n+        Map<KeyExpression, FieldData> fields = new HashMap<>();\n+        final IndexKeyValueToPartialRecord.Builder builder = IndexKeyValueToPartialRecord.newBuilder(recordType);\n+        for (int i = 0; i < keyFields.size(); i++) {\n+            KeyExpression keyField = keyFields.get(i);\n+            FieldData fieldData = FieldData.of(IndexKeyValueToPartialRecord.TupleSource.KEY, i);\n+            if (!keyField.createsDuplicates() && addCoveringField(keyField, fieldData, builder)) {\n+                fields.put(keyField, fieldData);\n+            }\n+        }\n+        for (int i = 0; i < valueFields.size(); i++) {\n+            KeyExpression valueField = valueFields.get(i);\n+            FieldData fieldData = FieldData.of(IndexKeyValueToPartialRecord.TupleSource.VALUE, i);\n+            if (!valueField.createsDuplicates() && addCoveringField(valueField, fieldData, builder)) {\n+                fields.put(valueField, fieldData);\n+            }\n+        }\n+\n+        if (!builder.isValid()) {\n+            return NO_FIELDS;\n+        }\n+        return new AvailableFields(fields);\n+    }\n+\n+    public static boolean addCoveringField(@Nonnull KeyExpression requiredExpr,\n+                                           @Nonnull FieldData fieldData,\n+                                           @Nonnull IndexKeyValueToPartialRecord.Builder builder) {\n+        while (requiredExpr instanceof NestingKeyExpression) {\n+            NestingKeyExpression nesting = (NestingKeyExpression)requiredExpr;\n+            String fieldName = nesting.getParent().getFieldName();\n+            requiredExpr = nesting.getChild();\n+            builder = builder.getFieldBuilder(fieldName);\n+        }\n+        if (requiredExpr instanceof FieldKeyExpression) {\n+            FieldKeyExpression fieldKeyExpression = (FieldKeyExpression)requiredExpr;\n+            if (!fieldKeyExpression.getNullStandin().equals(Key.Evaluated.NullStandin.NULL) ||\n+                    fieldKeyExpression.getFanType().equals(KeyExpression.FanType.FanOut)) {\n+                return false;\n+            }\n+            builder.addField(fieldKeyExpression.getFieldName(), fieldData.source, fieldData.index);\n+            return true;\n+        } else {\n+            return false;\n+        }\n+    }\n+\n+    @Nonnull\n+    public static AvailableFields intersection(@Nonnull List<AvailableFields> toIntersect) {\n+        if (toIntersect.isEmpty()) {\n+            throw new RecordCoreException(\"tried to find intersection of an empty list of available fields\");\n+        }\n+\n+        Map<KeyExpression, FieldData> intersection = null;\n+        for (AvailableFields fields : toIntersect) {\n+            if (!fields.hasAllFields()) {\n+                if (intersection == null) {\n+                    intersection = new HashMap<>(fields.fields);\n+                } else {\n+                    // keySet() is backed by the map itself\n+                    intersection.keySet().retainAll(fields.fields.keySet());\n+                }\n+            }\n+        }\n+        if (intersection == null) {\n+            return ALL_FIELDS;\n+        } else {\n+            return new AvailableFields(intersection);\n+        }\n+    }\n+\n+    /**\n+     * A pair of a representing a tuple source (key or value) and an index within that tuple source.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7657afbfacc42ab452078e203749342b8a1f6ff0"}, "originalPosition": 196}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 36, "cost": 1, "resetAt": "2021-11-12T18:49:56Z"}}}