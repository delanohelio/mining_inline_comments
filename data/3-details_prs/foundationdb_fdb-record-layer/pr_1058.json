{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTExODUyMDcz", "number": 1058, "title": "Resolves #1057: Composed bitmaps from map-like fields", "bodyText": "Don't pick a splice point in the middle of a nested concat.\nAllow for partial record with incomplete repeated field for special case of composed bitmap.", "createdAt": "2020-10-28T21:36:18Z", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1058", "merged": true, "mergeCommit": {"oid": "671bea227b8fbb3f3d24eb5fa054ac32aaa6a108"}, "closed": true, "closedAt": "2020-10-30T21:07:45Z", "author": {"login": "MMcM"}, "timelineItems": {"totalCount": 12, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdXElP-ABqjM5MzM1MDk0MTM=", "endCursor": "Y3Vyc29yOnYyOpPPAAABdXtVjnAFqTUyMTAzNjM0Mg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "677585e2b5bb8aa96e49b1199fbca3c196d1fa67", "author": {"user": {"login": "MMcM", "name": "Mike McMahon"}}, "url": "https://github.com/FoundationDB/fdb-record-layer/commit/677585e2b5bb8aa96e49b1199fbca3c196d1fa67", "committedDate": "2020-10-28T21:31:55Z", "message": "Allow for partial record with incomplete repeated field for special case of composed bitmap."}, "afterCommit": {"oid": "5f3b95c7e8d959e0ab0e40b249fe84b30a376cfb", "author": {"user": {"login": "MMcM", "name": "Mike McMahon"}}, "url": "https://github.com/FoundationDB/fdb-record-layer/commit/5f3b95c7e8d959e0ab0e40b249fe84b30a376cfb", "committedDate": "2020-10-28T21:37:41Z", "message": "Allow for partial record with incomplete repeated field for special case of composed bitmap."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "5f3b95c7e8d959e0ab0e40b249fe84b30a376cfb", "author": {"user": {"login": "MMcM", "name": "Mike McMahon"}}, "url": "https://github.com/FoundationDB/fdb-record-layer/commit/5f3b95c7e8d959e0ab0e40b249fe84b30a376cfb", "committedDate": "2020-10-28T21:37:41Z", "message": "Allow for partial record with incomplete repeated field for special case of composed bitmap."}, "afterCommit": {"oid": "d2eded10aabf538655393dfdf4a976ccd368f8b4", "author": {"user": {"login": "MMcM", "name": "Mike McMahon"}}, "url": "https://github.com/FoundationDB/fdb-record-layer/commit/d2eded10aabf538655393dfdf4a976ccd368f8b4", "committedDate": "2020-10-29T19:35:30Z", "message": "Allow for partial record with incomplete repeated field for special case of composed bitmap."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIwMDkxNDM3", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1058#pullrequestreview-520091437", "createdAt": "2020-10-29T21:12:26Z", "commit": {"oid": "d2eded10aabf538655393dfdf4a976ccd368f8b4"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yOVQyMToxMjoyNlrOHqu6Rw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yOVQyMzozMDoyNFrOHqyOdg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDU3MDgyMw==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                                                               @Nonnull KeyExpression indexExpr, Boolean allowRepeated) {\n          \n          \n            \n                                                                               @Nonnull KeyExpression indexExpr, boolean allowRepeated) {\n          \n      \n    \n    \n  \n\nUnless I'm missing something and there's a reason why this needs to be a Boolean object.", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1058#discussion_r514570823", "createdAt": "2020-10-29T21:12:26Z", "author": {"login": "alecgrieser"}, "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/RecordQueryPlanner.java", "diffHunk": "@@ -1527,6 +1528,12 @@ public RecordQueryCoveringIndexPlan planCoveringAggregateIndex(@Nonnull RecordQu\n \n     @Nullable\n     public RecordQueryCoveringIndexPlan planCoveringAggregateIndex(@Nonnull RecordQuery query, @Nonnull Index index, @Nonnull KeyExpression indexExpr) {\n+        return planCoveringAggregateIndex(query, index, indexExpr, false);\n+    }\n+\n+    @Nullable\n+    public RecordQueryCoveringIndexPlan planCoveringAggregateIndex(@Nonnull RecordQuery query, @Nonnull Index index,\n+                                                                   @Nonnull KeyExpression indexExpr, Boolean allowRepeated) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d2eded10aabf538655393dfdf4a976ccd368f8b4"}, "originalPosition": 17}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDYxNTk3NA==", "bodyText": "There's something about this where it seems like the right thing is to have a key expression or something like a key expression that means \"one entry from a repeated field\" to avoid having a Boolean special case, but I suppose that's a much larger discussion. cc @normen662", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1058#discussion_r514615974", "createdAt": "2020-10-29T23:02:34Z", "author": {"login": "alecgrieser"}, "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/IndexKeyValueToPartialRecord.java", "diffHunk": "@@ -298,16 +303,20 @@ public void addRequiredMessageFields() {\n          * @return whether this is a valid use\n          */\n         public boolean isValid() {\n+            return isValid(false);\n+        }\n+\n+        public boolean isValid(boolean allowRepeated) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d2eded10aabf538655393dfdf4a976ccd368f8b4"}, "originalPosition": 21}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDYyMjc0Mw==", "bodyText": "Can this still end up splicing up a nested concat? I'm thinking of something like if groupKey.getGroupedCount() == 2 and groupKey is something like concat(nest(a, concat(b, c)), d)?", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1058#discussion_r514622743", "createdAt": "2020-10-29T23:22:53Z", "author": {"login": "alecgrieser"}, "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/bitmap/ComposedBitmapIndexAggregate.java", "diffHunk": "@@ -319,9 +321,26 @@ private static boolean separateGroupFilters(@Nonnull QueryComponent filter,\n                 return Optional.empty();\n             }\n             // Splice the index's key between the common grouping key and the position.\n-            GroupingKeyExpression groupKeyExpression = (GroupingKeyExpression)indexAggregateFunction.getOperand();\n-            GroupingKeyExpression fullKey = Key.Expressions.concat(groupKeyExpression.getGroupingSubKey(), indexKey, groupKeyExpression.getGroupedSubKey())\n-                    .group(groupKeyExpression.getGroupedCount());\n+            // The simplest place is directly before the position.\n+            // But if part of the group is a nested concat, breaking that up would need support in QueryToKeyMatcher.\n+            // Moreover, the caller needs to have arranged for a compatible index to exist, which requires new support.\n+            // (https://github.com/FoundationDB/fdb-record-layer/issues/1056)\n+            final GroupingKeyExpression groupKey = (GroupingKeyExpression)indexAggregateFunction.getOperand();\n+            int lastKeySize = 1;\n+            if (groupKey.getWholeKey() instanceof ThenKeyExpression) {\n+                ThenKeyExpression thenKey = (ThenKeyExpression)groupKey.getWholeKey();\n+                lastKeySize = thenKey.getChildren().get(thenKey.getChildren().size() - 1).getColumnSize();\n+            }\n+            final ThenKeyExpression splicedKey;\n+            if (lastKeySize > groupKey.getGroupedCount()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d2eded10aabf538655393dfdf4a976ccd368f8b4"}, "originalPosition": 36}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDYyNTE0Mg==", "bodyText": "It's a little unclear to me why this is a legal transformation. Why is it okay if some of the grouping columns from the operand end up in the grouped columns?", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1058#discussion_r514625142", "createdAt": "2020-10-29T23:30:24Z", "author": {"login": "alecgrieser"}, "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/bitmap/ComposedBitmapIndexAggregate.java", "diffHunk": "@@ -319,9 +321,26 @@ private static boolean separateGroupFilters(@Nonnull QueryComponent filter,\n                 return Optional.empty();\n             }\n             // Splice the index's key between the common grouping key and the position.\n-            GroupingKeyExpression groupKeyExpression = (GroupingKeyExpression)indexAggregateFunction.getOperand();\n-            GroupingKeyExpression fullKey = Key.Expressions.concat(groupKeyExpression.getGroupingSubKey(), indexKey, groupKeyExpression.getGroupedSubKey())\n-                    .group(groupKeyExpression.getGroupedCount());\n+            // The simplest place is directly before the position.\n+            // But if part of the group is a nested concat, breaking that up would need support in QueryToKeyMatcher.\n+            // Moreover, the caller needs to have arranged for a compatible index to exist, which requires new support.\n+            // (https://github.com/FoundationDB/fdb-record-layer/issues/1056)\n+            final GroupingKeyExpression groupKey = (GroupingKeyExpression)indexAggregateFunction.getOperand();\n+            int lastKeySize = 1;\n+            if (groupKey.getWholeKey() instanceof ThenKeyExpression) {\n+                ThenKeyExpression thenKey = (ThenKeyExpression)groupKey.getWholeKey();\n+                lastKeySize = thenKey.getChildren().get(thenKey.getChildren().size() - 1).getColumnSize();\n+            }\n+            final ThenKeyExpression splicedKey;\n+            if (lastKeySize > groupKey.getGroupedCount()) {\n+                final KeyExpression wholeKey = groupKey.getWholeKey();\n+                final int wholeSize = wholeKey.getColumnSize();\n+                final int splicePoint = wholeSize - lastKeySize;\n+                splicedKey = Key.Expressions.concat(wholeKey.getSubKey(0, splicePoint), indexKey, wholeKey.getSubKey(splicePoint, wholeSize));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d2eded10aabf538655393dfdf4a976ccd368f8b4"}, "originalPosition": 40}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "13751c65b927a3c26cdda850809c48d41ed2ed78", "author": {"user": {"login": "MMcM", "name": "Mike McMahon"}}, "url": "https://github.com/FoundationDB/fdb-record-layer/commit/13751c65b927a3c26cdda850809c48d41ed2ed78", "committedDate": "2020-10-29T23:56:26Z", "message": "Don't pick a splice point in the middle of a nested concat."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "48f7943940bf99689cc8292a04a2233c56e7764b", "author": {"user": {"login": "MMcM", "name": "Mike McMahon"}}, "url": "https://github.com/FoundationDB/fdb-record-layer/commit/48f7943940bf99689cc8292a04a2233c56e7764b", "committedDate": "2020-10-29T23:56:26Z", "message": "Allow for partial record with incomplete repeated field for special case of composed bitmap."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "815940a91a2c94773501424eaf0e8c058fcdd604", "author": {"user": {"login": "MMcM", "name": "Mike McMahon"}}, "url": "https://github.com/FoundationDB/fdb-record-layer/commit/815940a91a2c94773501424eaf0e8c058fcdd604", "committedDate": "2020-10-29T23:56:26Z", "message": "Update fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/RecordQueryPlanner.java\n\nCo-authored-by: Alec Grieser <alloc@apple.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "630dffad8e1bb085047ab4b927b6b223403caf0f", "author": {"user": {"login": "MMcM", "name": "Mike McMahon"}}, "url": "https://github.com/FoundationDB/fdb-record-layer/commit/630dffad8e1bb085047ab4b927b6b223403caf0f", "committedDate": "2020-10-30T00:45:42Z", "message": "Redo splicing to always take whole children, no matter how many"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "938dead06a29750a52e3dac92b2fc68e193219ac", "author": {"user": {"login": "MMcM", "name": "Mike McMahon"}}, "url": "https://github.com/FoundationDB/fdb-record-layer/commit/938dead06a29750a52e3dac92b2fc68e193219ac", "committedDate": "2020-10-29T23:35:26Z", "message": "Update fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/RecordQueryPlanner.java\n\nCo-authored-by: Alec Grieser <alloc@apple.com>"}, "afterCommit": {"oid": "630dffad8e1bb085047ab4b927b6b223403caf0f", "author": {"user": {"login": "MMcM", "name": "Mike McMahon"}}, "url": "https://github.com/FoundationDB/fdb-record-layer/commit/630dffad8e1bb085047ab4b927b6b223403caf0f", "committedDate": "2020-10-30T00:45:42Z", "message": "Redo splicing to always take whole children, no matter how many"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "13c6c329dc0688ae8c861e15077262bc6f5fff3e", "author": {"user": {"login": "MMcM", "name": "Mike McMahon"}}, "url": "https://github.com/FoundationDB/fdb-record-layer/commit/13c6c329dc0688ae8c861e15077262bc6f5fff3e", "committedDate": "2020-10-30T02:49:55Z", "message": "Add a test case that shows complex splicing"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIwODI4MDI4", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1058#pullrequestreview-520828028", "createdAt": "2020-10-30T16:20:12Z", "commit": {"oid": "13c6c329dc0688ae8c861e15077262bc6f5fff3e"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0zMFQxNjoyMDoxM1rOHrWZ3Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0zMFQxODozMToyMFrOHrbg3g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTIxNzg4NQ==", "bodyText": "Probably should call fail() rather than creating an IllegalStateException as a more idiomatic way to indicate test failure.", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1058#discussion_r515217885", "createdAt": "2020-10-30T16:20:13Z", "author": {"login": "alecgrieser"}, "path": "fdb-record-layer-core/src/test/java/com/apple/foundationdb/record/provider/foundationdb/indexes/BitmapValueIndexTest.java", "diffHunk": "@@ -483,9 +488,65 @@ public void nonOverlappingOrQuery() {\n         }\n     }\n \n-    protected static final KeyExpression REC_NO_BY_STR = concatenateFields(\"str_value_indexed\", \"rec_no\").group(1);\n-    protected static final KeyExpression REC_NO_BY_STR_NUM2 = concatenateFields(\"str_value_indexed\", \"num_value_2\", \"rec_no\").group(1);\n-    protected static final KeyExpression REC_NO_BY_STR_NUM3 = concatenateFields(\"str_value_indexed\", \"num_value_3_indexed\", \"rec_no\").group(1);\n+    @Test\n+    public void nestedAndQuery() {\n+        final KeyExpression num_by_str = field(\"nested\").nest(field(\"entry\", FanOut).nest(concatenateFields(\"str_value\", \"num_value\")));\n+        final KeyExpression nested_num_by_str = concat(field(\"num_value_1\"), num_by_str).group(1);\n+        final KeyExpression nested_num_by_str_num2 = concat(field(\"num_value_1\"), field(\"num_value_2\"), num_by_str).group(1);\n+        final KeyExpression nested_num_by_str_num3 = concat(field(\"num_value_1\"), field(\"num_value_3\"), num_by_str).group(1);\n+        final RecordMetaDataHook nested_rec_no_by_str_nums_hook = metadata -> {\n+            final RecordTypeBuilder recordType = metadata.getRecordType(\"MyNestedRecord\");\n+            metadata.addIndex(recordType, new Index(\"nested_num_by_str_num2\", nested_num_by_str_num2, IndexTypes.BITMAP_VALUE, SMALL_BITMAP_OPTIONS));\n+            metadata.addIndex(recordType, new Index(\"nested_num_by_str_num3\", nested_num_by_str_num3, IndexTypes.BITMAP_VALUE, SMALL_BITMAP_OPTIONS));\n+        };\n+        final IndexAggregateFunction bitmap_value_nested_num_by_str = new IndexAggregateFunction(FunctionNames.BITMAP_VALUE, nested_num_by_str, null);\n+        try (FDBRecordContext context = openContext()) {\n+            createOrOpenRecordStore(context, metaData(nested_rec_no_by_str_nums_hook));\n+            for (int recNo = 100; recNo < 200; recNo++) {\n+                recordStore.saveRecord(TestRecordsBitmapProto.MyNestedRecord.newBuilder()\n+                        .setRecNo(recNo)\n+                        .setNumValue1(1)\n+                        .setNested(TestRecordsBitmapProto.MyNestedRecord.Nested.newBuilder()\n+                                .addEntry(TestRecordsBitmapProto.MyNestedRecord.Nested.Entry.newBuilder()\n+                                        .setStrValue((recNo & 1) == 1 ? \"odd\" : \"even\")\n+                                        .setNumValue(recNo + 1000)))\n+                        .setNumValue2(recNo % 7)\n+                        .setNumValue3(recNo % 5)\n+                        .build());\n+            }\n+            commit(context);\n+        }\n+        try (FDBRecordContext context = openContext()) {\n+            createOrOpenRecordStore(context, metaData(nested_rec_no_by_str_nums_hook));\n+            setupPlanner(null);\n+            final RecordQuery recordQuery = RecordQuery.newBuilder()\n+                    .setRecordType(\"MyNestedRecord\")\n+                    .setFilter(Query.and(\n+                            Query.field(\"num_value_1\").equalsValue(1),\n+                            Query.field(\"nested\").matches(Query.field(\"entry\").oneOfThem().matches(Query.field(\"str_value\").equalsValue(\"odd\"))),\n+                            Query.field(\"num_value_2\").equalsValue(3),\n+                            Query.field(\"num_value_3\").equalsValue(4)))\n+                    .setRequiredResults(Collections.singletonList(field(\"nested\").nest(field(\"entry\", FanOut).nest(\"num_value\"))))\n+                    .build();\n+            final RecordQueryPlan queryPlan =  ComposedBitmapIndexAggregate.tryPlan((RecordQueryPlanner)planner, recordQuery, bitmap_value_nested_num_by_str)\n+                    .orElseThrow(() -> new IllegalStateException(\"Cannot plan query\"));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "13c6c329dc0688ae8c861e15077262bc6f5fff3e"}, "originalPosition": 413}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTIxOTEwMg==", "bodyText": "If the required results also included the str_value field, would this still plan? And should it? (I assume if it returns, the str_value associated with each bitmap array?) Similarly, if this were missing the predicate on str_value but it were present in the required results, would it return results grouped together by str_value?", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1058#discussion_r515219102", "createdAt": "2020-10-30T16:22:16Z", "author": {"login": "alecgrieser"}, "path": "fdb-record-layer-core/src/test/java/com/apple/foundationdb/record/provider/foundationdb/indexes/BitmapValueIndexTest.java", "diffHunk": "@@ -483,9 +488,65 @@ public void nonOverlappingOrQuery() {\n         }\n     }\n \n-    protected static final KeyExpression REC_NO_BY_STR = concatenateFields(\"str_value_indexed\", \"rec_no\").group(1);\n-    protected static final KeyExpression REC_NO_BY_STR_NUM2 = concatenateFields(\"str_value_indexed\", \"num_value_2\", \"rec_no\").group(1);\n-    protected static final KeyExpression REC_NO_BY_STR_NUM3 = concatenateFields(\"str_value_indexed\", \"num_value_3_indexed\", \"rec_no\").group(1);\n+    @Test\n+    public void nestedAndQuery() {\n+        final KeyExpression num_by_str = field(\"nested\").nest(field(\"entry\", FanOut).nest(concatenateFields(\"str_value\", \"num_value\")));\n+        final KeyExpression nested_num_by_str = concat(field(\"num_value_1\"), num_by_str).group(1);\n+        final KeyExpression nested_num_by_str_num2 = concat(field(\"num_value_1\"), field(\"num_value_2\"), num_by_str).group(1);\n+        final KeyExpression nested_num_by_str_num3 = concat(field(\"num_value_1\"), field(\"num_value_3\"), num_by_str).group(1);\n+        final RecordMetaDataHook nested_rec_no_by_str_nums_hook = metadata -> {\n+            final RecordTypeBuilder recordType = metadata.getRecordType(\"MyNestedRecord\");\n+            metadata.addIndex(recordType, new Index(\"nested_num_by_str_num2\", nested_num_by_str_num2, IndexTypes.BITMAP_VALUE, SMALL_BITMAP_OPTIONS));\n+            metadata.addIndex(recordType, new Index(\"nested_num_by_str_num3\", nested_num_by_str_num3, IndexTypes.BITMAP_VALUE, SMALL_BITMAP_OPTIONS));\n+        };\n+        final IndexAggregateFunction bitmap_value_nested_num_by_str = new IndexAggregateFunction(FunctionNames.BITMAP_VALUE, nested_num_by_str, null);\n+        try (FDBRecordContext context = openContext()) {\n+            createOrOpenRecordStore(context, metaData(nested_rec_no_by_str_nums_hook));\n+            for (int recNo = 100; recNo < 200; recNo++) {\n+                recordStore.saveRecord(TestRecordsBitmapProto.MyNestedRecord.newBuilder()\n+                        .setRecNo(recNo)\n+                        .setNumValue1(1)\n+                        .setNested(TestRecordsBitmapProto.MyNestedRecord.Nested.newBuilder()\n+                                .addEntry(TestRecordsBitmapProto.MyNestedRecord.Nested.Entry.newBuilder()\n+                                        .setStrValue((recNo & 1) == 1 ? \"odd\" : \"even\")\n+                                        .setNumValue(recNo + 1000)))\n+                        .setNumValue2(recNo % 7)\n+                        .setNumValue3(recNo % 5)\n+                        .build());\n+            }\n+            commit(context);\n+        }\n+        try (FDBRecordContext context = openContext()) {\n+            createOrOpenRecordStore(context, metaData(nested_rec_no_by_str_nums_hook));\n+            setupPlanner(null);\n+            final RecordQuery recordQuery = RecordQuery.newBuilder()\n+                    .setRecordType(\"MyNestedRecord\")\n+                    .setFilter(Query.and(\n+                            Query.field(\"num_value_1\").equalsValue(1),\n+                            Query.field(\"nested\").matches(Query.field(\"entry\").oneOfThem().matches(Query.field(\"str_value\").equalsValue(\"odd\"))),\n+                            Query.field(\"num_value_2\").equalsValue(3),\n+                            Query.field(\"num_value_3\").equalsValue(4)))\n+                    .setRequiredResults(Collections.singletonList(field(\"nested\").nest(field(\"entry\", FanOut).nest(\"num_value\"))))", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "13c6c329dc0688ae8c861e15077262bc6f5fff3e"}, "originalPosition": 410}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTI4MzMxOA==", "bodyText": "Yeah, I think maybe by \"key expression\", I should have said, like, \"query expression\", so that you can say that you want back in your required results the \"matching\" entry from some nested expression, if that makes sense. I think something similar was discussed before, when discussing how to better expression more complicated queries.\nIn any case, not something for this PR or to block this PR on.", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1058#discussion_r515283318", "createdAt": "2020-10-30T17:56:49Z", "author": {"login": "alecgrieser"}, "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/IndexKeyValueToPartialRecord.java", "diffHunk": "@@ -298,16 +303,20 @@ public void addRequiredMessageFields() {\n          * @return whether this is a valid use\n          */\n         public boolean isValid() {\n+            return isValid(false);\n+        }\n+\n+        public boolean isValid(boolean allowRepeated) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDYxNTk3NA=="}, "originalCommit": {"oid": "d2eded10aabf538655393dfdf4a976ccd368f8b4"}, "originalPosition": 21}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTMwMTU5OA==", "bodyText": "Okay, it took me a while to refamiliarize myself with this code, but I think I understand now the basic approach here.\nThis part of the code is essentially trying out different candidate grouping expressions to match each predicate and seeing if a particular index matching that expression exists. So the important invariant is that the grouped key remains the same (and this does that), and then the grouping keys can be changed kind of at will. So, I think I understand how this works, I think.\nI guess the remaining question is that it seems like the grouping key order shouldn't really matter (at least for the keys with equality predicates), and that we \"should\" be able to just place the indexKey at the beginning of the expression. But I'd also buy that the planner isn't quite sophisticated enough for that (yet?).", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1058#discussion_r515301598", "createdAt": "2020-10-30T18:31:20Z", "author": {"login": "alecgrieser"}, "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/bitmap/ComposedBitmapIndexAggregate.java", "diffHunk": "@@ -319,9 +321,37 @@ private static boolean separateGroupFilters(@Nonnull QueryComponent filter,\n                 return Optional.empty();\n             }\n             // Splice the index's key between the common grouping key and the position.\n-            GroupingKeyExpression groupKeyExpression = (GroupingKeyExpression)indexAggregateFunction.getOperand();\n-            GroupingKeyExpression fullKey = Key.Expressions.concat(groupKeyExpression.getGroupingSubKey(), indexKey, groupKeyExpression.getGroupedSubKey())\n-                    .group(groupKeyExpression.getGroupedCount());\n+            // The simplest place is directly before the position.\n+            // But if part of the group is a nested concat, breaking that up would need support in QueryToKeyMatcher.\n+            // Moreover, the caller needs to have arranged for a compatible index to exist, which requires new support to define.\n+            // (https://github.com/FoundationDB/fdb-record-layer/issues/1056)\n+            final GroupingKeyExpression groupKey = (GroupingKeyExpression)indexAggregateFunction.getOperand();\n+            final int groupedCount = groupKey.getGroupedCount();\n+            final int wholeCount = groupKey.getColumnSize();\n+            int afterSpliceCount = groupedCount;\n+            if (groupKey.getWholeKey() instanceof ThenKeyExpression) {\n+                final List<KeyExpression> thenChildren = ((ThenKeyExpression)groupKey.getWholeKey()).getChildren();\n+                int childPosition = thenChildren.size();\n+                // Compute the minimum number that includes all grouped fields and keeps involved children intact.\n+                afterSpliceCount = 0;\n+                while (afterSpliceCount < groupedCount) {\n+                    afterSpliceCount += thenChildren.get(--childPosition).getColumnSize();\n+                }\n+            }\n+            final ThenKeyExpression splicedKey;\n+            if (afterSpliceCount == groupedCount) {\n+                // Preferred position at end of grouping keys.\n+                splicedKey = Key.Expressions.concat(groupKey.getGroupingSubKey(), indexKey, groupKey.getGroupedSubKey());\n+            } else {\n+                final KeyExpression wholeKey = groupKey.getWholeKey();\n+                final int splicePoint = wholeCount - afterSpliceCount;\n+                if (splicePoint == 0) {\n+                    splicedKey = Key.Expressions.concat(indexKey, wholeKey);\n+                } else {\n+                    splicedKey = Key.Expressions.concat(wholeKey.getSubKey(0, splicePoint), indexKey, wholeKey.getSubKey(splicePoint, wholeCount));\n+                }\n+            }\n+            GroupingKeyExpression fullKey = splicedKey.group(groupedCount);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "13c6c329dc0688ae8c861e15077262bc6f5fff3e"}, "originalPosition": 55}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9823547308649a40ba9d24198afe83f72b5595e0", "author": {"user": {"login": "MMcM", "name": "Mike McMahon"}}, "url": "https://github.com/FoundationDB/fdb-record-layer/commit/9823547308649a40ba9d24198afe83f72b5595e0", "committedDate": "2020-10-30T19:39:10Z", "message": "Use `fail` instead"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIxMDM2MzQy", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1058#pullrequestreview-521036342", "createdAt": "2020-10-30T21:06:46Z", "commit": {"oid": "9823547308649a40ba9d24198afe83f72b5595e0"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2483, "cost": 1, "resetAt": "2021-11-01T14:20:25Z"}}}