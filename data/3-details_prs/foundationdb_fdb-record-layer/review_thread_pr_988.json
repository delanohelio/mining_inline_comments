{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDQzMjE5ODIx", "number": 988, "reviewThreads": {"totalCount": 239, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wM1QyMDoyOTo0OVrOEUv0oQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNlQxODoxNTo0N1rOEV8Kdw==", "hasNextPage": false, "hasPreviousPage": true}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkwMTkwNDk3OnYy", "diffSide": "RIGHT", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/AliasMap.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wM1QyMDoyOTo0OVrOG7HsFw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wM1QyMDoyOTo0OVrOG7HsFw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDY0NTE0Mw==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    public AliasMap build() {\n          \n          \n            \n                    @Nonnull\n          \n          \n            \n                    public AliasMap build() {", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/988#discussion_r464645143", "createdAt": "2020-08-03T20:29:49Z", "author": {"login": "nschiefer"}, "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/AliasMap.java", "diffHunk": "@@ -0,0 +1,369 @@\n+/*\n+ * AliasMap.java\n+ *\n+ * This source file is part of the FoundationDB open source project\n+ *\n+ * Copyright 2015-2020 Apple Inc. and the FoundationDB project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.apple.foundationdb.record.query.plan.temp;\n+\n+import com.google.common.base.Verify;\n+import com.google.common.collect.AbstractIterator;\n+import com.google.common.collect.BiMap;\n+import com.google.common.collect.HashBiMap;\n+import com.google.common.collect.ImmutableBiMap;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.Streams;\n+import org.apache.commons.lang3.tuple.Pair;\n+\n+import javax.annotation.Nonnull;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.function.Function;\n+\n+/**\n+ * This class encapsulates mappings between {@link CorrelationIdentifier}s and helpers to create and maintain\n+ * these mappings.\n+ *\n+ * While various operations or in general algorithms traverse the query graph(s) it is important to keep track of\n+ * what alias (of a quantifier) should be considered to what other alias (of another quantifier). A quantifier\n+ * ({@link Quantifier} is referred to via {@link CorrelationIdentifier}. In this way there are no direct pointers\n+ * to objects which is desirable while the graph is mutated through transformations. At various points during\n+ * the planning of a query we may want to determine e.g. if a sub-graph would produce the same result as some other\n+ * sub-graph. Similarly, we may want to determine whether a sub-graph is already properly memoized or not. In general,\n+ * we need to theorize if two sub-graphs are related to each other (usually equality but also subsumption, etc.)\n+ *\n+ * All of that is rather straightforward if both sub-graphs are completely uncorrelated and therefore independent to\n+ * each other, to some other record producer, or even to some external parameter that is being passed in. In these\n+ * cases the {@code AliasMap} implemented here would effectively be trivial, i.e. the map would be\n+ * conceptually empty.\n+ *\n+ * There are cases, however, that need some care to establish the relationships mentioned before.\n+ *\n+ * Example 1:\n+ *    sub graph 1\n+ *        SELECT T.* FROM T WHERE T.x = c1\n+ *\n+ *    sub graph 2\n+ *        SELECT T.* FROM T WHERE T.x = c2\n+ *\n+ *    We wold like to establish, if these graphs are equal or not. Both of them are not complete, i.e. we wouldn't\n+ *    be able to execute them as is. If we asked if these sub graphs where equal, we certainly would need to say that\n+ *    that depends. If they, however, are embedded in some surrounding query that binds c1 and c2 respectively, we\n+ *    would be able to say if in the greater context of the surrounding query these sub query do the same thing.\n+ *\n+ *            SELECT * FROM R AS c1, (SELECT T.* FROM T WHERE T.x = c1)\n+ *\n+ *        is the same as\n+ *\n+ *            SELECT * FROM R AS c2, (SELECT T.* FROM T WHERE T.x = c2)\n+ *\n+ *    whereas\n+ *            SELECT * FROM R AS c1, (SELECT T.* FROM T WHERE T.x = c1)\n+ *\n+ *        is definitely not the same as\n+ *\n+ *            SELECT * FROM S AS c2, (SELECT T.* FROM T WHERE T.x = c2)\n+ *\n+ *    In short, a sub-graph can only be considered equal to another sub-graph if we assume an equality over their\n+ *    correlated references. In other words the sub-graphs define two functions f(x) and g(y). While we can determine\n+ *    if f and g are structurally equivalent we con only determine actual result equivalence if we assume x = y for\n+ *    the entire domain of x and y.\n+ *\n+ * Example 2:\n+ *    sub graph 1\n+ *        SELECT T.* FROM T WHERE T.x = c1 AND T.y = c2\n+ *\n+ *    sub graph 2\n+ *        SELECT T.* FROM T WHERE T.x = c2 AND T.y = c1\n+ *\n+ *    This scenario is somewhat more complicated as it offers more degrees of freedom.\n+ *\n+ *            SELECT * FROM R AS c1, S AS c2, (SELECT T.* FROM T WHERE T.x = c1 AND T.y = c2)\n+ *\n+ *        is the same as\n+ *\n+ *            SELECT * FROM R AS c2, S AS c1, (SELECT T.* FROM T WHERE T.x = c2 AND T.y = c1)\n+ *\n+ *    This observation is identical to the one in example 1. Due to the commutative nature we also would like to\n+ *    be able to realize that even this is the same:\n+ *\n+ *    SELECT * FROM R AS c1, S AS c2, (SELECT T.* FROM T WHERE T.x = c2 AND T.y = c1)\n+ *\n+ * In any case we need to keep track of what's currently considered bound and equal while we traverse the query graph.\n+ * When we descend into correlated sub-graphs during an algorithm while we e.g. determine {@link Correlated#resultEquals}\n+ * we need to have all outside references bound and mapped in some way: Should we treat c1 on the left as c2 on the right\n+ * or the other way around? It is the job of an object of this class to facilitate the construction and the lookup of\n+ * these mappings. Algorithms walking the graph make use of this map, construct and reconstruct assumed equality while\n+ * traversing e.g. permutations of possible mappings.\n+ *\n+ * Another \n+ *\n+ * Note: This class is immutable, all perceived \"mutations\" cause a new object to be created.\n+ *\n+ */\n+public class AliasMap {\n+    private final ImmutableBiMap<CorrelationIdentifier, CorrelationIdentifier> map;\n+\n+    private AliasMap(final ImmutableBiMap<CorrelationIdentifier, CorrelationIdentifier> map) {\n+        this.map = map;\n+    }\n+\n+    public boolean containsSource(@Nonnull final CorrelationIdentifier alias) {\n+        return map.containsKey(alias);\n+    }\n+\n+    public boolean containsTarget(@Nonnull final CorrelationIdentifier alias) {\n+        return map.containsValue(alias);\n+    }\n+\n+    /**\n+     * Returns the set of {@link CorrelationIdentifier}s that are mapped by this {@code AliasMap}.\n+     * @return a set of {@link CorrelationIdentifier}s that this map contains mappings for.\n+     */\n+    @Nonnull\n+    public Set<CorrelationIdentifier> sources() {\n+        return map.keySet();\n+    }\n+\n+    /**\n+     * Returns the set of all {@link CorrelationIdentifier}s that this map maps to using the set of {@link CorrelationIdentifier}s\n+     * returned by {@link #sources()}.\n+     * @return a set of {@link CorrelationIdentifier}s that this map maps to.\n+     */\n+    @Nonnull\n+    public Set<CorrelationIdentifier> targets() {\n+        return map.values();\n+    }\n+\n+    public int size() {\n+        return map.size();\n+    }\n+\n+    @Nonnull\n+    public Builder derived() {\n+        return new Builder(map);\n+    }\n+\n+    @Nonnull\n+    public Builder derived(int expectedAdditionalElements) {\n+        return new Builder(size() + expectedAdditionalElements).putAll(this);\n+    }\n+\n+    /**\n+     * Compute the composition of two {@link AliasMap}s.\n+     * @param other second alias map\n+     * @return a translation map that maps {@code a -> c} for {@code a, b, c} if {@code a -> b} is contained in {@code first} and {@code b -> c} is contained in {@code second},\n+     *         {@code a -> b} for {@code a, b} if {@code a -> b} in {@code first} and no {@code b -> x} for any {@code x} is contained in {@code second}, and\n+     *         {@code b -> c} for {@code b, c} if {@code a -> x} for any {@code x} is not contained in {@code first} and {@code b -> c} is contained in {@code second}\n+     */\n+    @Nonnull\n+    public AliasMap compose(@Nonnull final AliasMap other) {\n+        final Builder builder =\n+                AliasMap.builder(size() + other.size());\n+\n+        final ImmutableBiMap<CorrelationIdentifier, CorrelationIdentifier> otherMap = other.map;\n+        this.map.forEach((key, value) -> builder.put(key, otherMap.getOrDefault(value, value)));\n+\n+        otherMap.forEach((key, value) -> {\n+            if (!containsSource(key)) {\n+                builder.put(key, value);\n+            }\n+        });\n+        return builder.build();\n+    }\n+\n+    /**\n+     * Method to match up the given sets of correlation identifiers (using an already given equivalence map).\n+     *\n+     * @param aliases aliases of _this_ set\n+     * @param dependsOnFn function yielding the dependsOn set for an alias of _this_ set\n+     * @param otherAliases aliases of _the other_ set\n+     * @param otherDependsOnFn function yielding the dependsOn set for an alias of _the other_ set\n+     * @param canCorrelate {@code true} if _this_ set (and the _other_ set) can be the source of correlations themselves.\n+     * @param predicate that tests if two aliases match\n+     * @return An iterable iterating alias maps containing mappings from the correlation identifiers ({@code aliases}) to\n+     *         correlations identifiers {@code otherAliases} according to the given predicate. Note that these mappings\n+     *         are bijective and can therefore be inverted.\n+     */\n+    @SuppressWarnings({\"squid:S135\"})\n+    @Nonnull\n+    public Iterable<AliasMap> match(@Nonnull final Set<CorrelationIdentifier> aliases,\n+                                    @Nonnull final Function<CorrelationIdentifier, Set<CorrelationIdentifier>> dependsOnFn,\n+                                    @Nonnull final Set<CorrelationIdentifier> otherAliases,\n+                                    @Nonnull final Function<CorrelationIdentifier, Set<CorrelationIdentifier>> otherDependsOnFn,\n+                                    final boolean canCorrelate,\n+                                    @Nonnull final MatchingIdPredicate predicate) {\n+        if (aliases.size() != otherAliases.size()) {\n+            return ImmutableList.of();\n+        }\n+\n+        if (aliases.isEmpty()) {\n+            return ImmutableList.of(empty());\n+        }\n+\n+        //\n+        // We do not know which id in \"this\" maps to which in \"other\". In fact, we cannot know as it is\n+        // intentionally modeled this way. We need to find _a_ feasible ordering that matches. In reality, the\n+        // quantifiers owned by an expression imposes a more or less a complete order leaving no room for many\n+        // permutations among unrelated quantifiers. In the worst case, we must enumerate them all. Luckily, most\n+        // algorithms for children have short-circuit semantics, so the uninteresting case where sub-graphs underneath\n+        // quantifiers do not match should be skipped quickly.\n+        //\n+        // get _a_ topologically-sound permutation from other\n+        final Optional<List<CorrelationIdentifier>> otherOrderedOptional =\n+                TopologicalSort.anyTopologicalOrderPermutation(\n+                        otherAliases,\n+                        alias -> Objects.requireNonNull(otherDependsOnFn.apply(alias)));\n+\n+        // There should always be a topologically sound ordering that we can use.\n+        Verify.verify(otherOrderedOptional.isPresent());\n+\n+        final List<CorrelationIdentifier> otherOrdered = otherOrderedOptional.get();\n+\n+        final TopologicalSort.TopologicalOrderPermutationIterable<CorrelationIdentifier> iterable =\n+                TopologicalSort.topologicalOrderPermutations(\n+                        aliases,\n+                        alias -> Objects.requireNonNull(dependsOnFn.apply(alias)));\n+\n+        return () -> {\n+            final TopologicalSort.TopologicalOrderPermutationIterator<CorrelationIdentifier> iterator = iterable.iterator();\n+\n+            return new AbstractIterator<AliasMap>() {\n+                @Override\n+                protected AliasMap computeNext() {\n+                    while (iterator.hasNext()) {\n+                        final Builder equivalenceMapBuilder = derived(aliases.size());\n+\n+                        final List<CorrelationIdentifier> ordered = iterator.next();\n+                        int i;\n+                        for (i = 0; i < aliases.size(); i++) {\n+                            final CorrelationIdentifier alias = ordered.get(i);\n+                            final CorrelationIdentifier otherAlias = otherOrdered.get(i);\n+\n+                            if (canCorrelate) {\n+                                // We now amend the equivalences passed in by adding the already known bound aliases left\n+                                // of i and make them equivalent as well\n+                                equivalenceMapBuilder.put(alias, otherAlias);\n+                            }\n+\n+                            if (!predicate.test(alias, otherAlias, equivalenceMapBuilder.build())) {\n+                                break;\n+                            }\n+                        }\n+\n+                        if (i == aliases.size()) {\n+                            // zip ordered and otherOrdered as they now match\n+                            return zip(ordered, otherOrdered);\n+                        } else {\n+                            // we can skip all permutations where the i-th value is bound the way it currently is\n+                            iterator.skip(i);\n+                        }\n+                    }\n+\n+                    return endOfData();\n+                }\n+            };\n+        };\n+    }\n+\n+    @Nonnull\n+    public static Builder builder() {\n+        return new Builder();\n+    }\n+\n+    @Nonnull\n+    public static Builder builder(final int expectedSize) {\n+        return new Builder(expectedSize);\n+    }\n+\n+    @Nonnull\n+    public static AliasMap empty() {\n+        return new AliasMap(ImmutableBiMap.of());\n+    }\n+\n+    @Nonnull\n+    public static AliasMap of(@Nonnull final CorrelationIdentifier source, @Nonnull final CorrelationIdentifier target) {\n+        return new AliasMap(ImmutableBiMap.of(source, target));\n+    }\n+\n+    @Nonnull\n+    public static AliasMap of(@Nonnull final BiMap<CorrelationIdentifier, CorrelationIdentifier> map) {\n+        return new AliasMap(ImmutableBiMap.copyOf(map));\n+    }\n+\n+    @Nonnull\n+    public static AliasMap identitiesFor(final Set<CorrelationIdentifier> correlationIdentifiers) {\n+        return new AliasMap(correlationIdentifiers.stream()\n+                .collect(ImmutableBiMap.toImmutableBiMap(Function.identity(), Function.identity())));\n+    }\n+\n+    @SuppressWarnings(\"UnstableApiUsage\")\n+    @Nonnull\n+    public static AliasMap zip(@Nonnull final List<CorrelationIdentifier> left, @Nonnull final List<CorrelationIdentifier> right) {\n+        return new AliasMap(Streams.zip(left.stream(), right.stream(),\n+                (l, r) -> Pair.of(Objects.requireNonNull(l), Objects.requireNonNull(r)))\n+                .collect(ImmutableBiMap.toImmutableBiMap(Pair::getLeft, Pair::getRight)));\n+    }\n+\n+    /**\n+     * Builder class for the {@link AliasMap}.\n+     */\n+    public static class Builder {\n+        private final HashBiMap<CorrelationIdentifier, CorrelationIdentifier> map;\n+\n+        private Builder() {\n+            this.map = HashBiMap.create();\n+        }\n+\n+        private Builder(final int expectedSize) {\n+            this.map = HashBiMap.create(expectedSize);\n+        }\n+\n+        private Builder(final BiMap<CorrelationIdentifier, CorrelationIdentifier> map) {\n+            this.map = HashBiMap.create(map);\n+        }\n+\n+        @Nonnull\n+        public Builder put(@Nonnull final CorrelationIdentifier source, @Nonnull final CorrelationIdentifier target) {\n+            map.put(source, target);\n+            return this;\n+        }\n+\n+        @Nonnull\n+        public Builder putAll(@Nonnull final AliasMap other) {\n+            map.putAll(other.map);\n+            return this;\n+        }\n+\n+        public AliasMap build() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b64d4eb60de5c3a4be0b4dc0f779ff2f15e47355"}, "originalPosition": 354}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkwMTk0MDQ1OnYy", "diffSide": "RIGHT", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/RelationalExpressionWithPredicate.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wM1QyMDo0MDo1M1rOG7IA5w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wM1QyMDo0MDo1M1rOG7IA5w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDY1MDQ3MQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                RelationalExpression rebaseWithRebasedQuantifiers(final AliasMap translationMap, final List<Quantifier> rebasedQuantifiers);\n          \n          \n            \n                RelationalExpression rebaseWithRebasedQuantifiers(@Nonnull final AliasMap translationMap, @Nonnull final List<Quantifier> rebasedQuantifiers);\n          \n      \n    \n    \n  \n\nSame for all implementations", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/988#discussion_r464650471", "createdAt": "2020-08-03T20:40:53Z", "author": {"login": "nschiefer"}, "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/RelationalExpressionWithPredicate.java", "diffHunk": "@@ -23,11 +23,15 @@\n import com.apple.foundationdb.record.query.predicates.QueryPredicate;\n \n import javax.annotation.Nonnull;\n+import java.util.List;\n \n /**\n  * A (relational) expression that has a predicate on it.\n  */\n public interface RelationalExpressionWithPredicate extends RelationalExpression {\n     @Nonnull\n     QueryPredicate getPredicate();\n+\n+    @Nonnull\n+    RelationalExpression rebaseWithRebasedQuantifiers(final AliasMap translationMap, final List<Quantifier> rebasedQuantifiers);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b64d4eb60de5c3a4be0b4dc0f779ff2f15e47355"}, "originalPosition": 14}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkwMTk0MzUwOnYy", "diffSide": "RIGHT", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/TopologicalSort.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wM1QyMDo0MTo1MFrOG7ICsw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wM1QyMDo0MTo1MFrOG7ICsw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDY1MDkzMQ==", "bodyText": "Let's format this as an <ol> so that it looks nice in the Javadocs.", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/988#discussion_r464650931", "createdAt": "2020-08-03T20:41:50Z", "author": {"login": "nschiefer"}, "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/TopologicalSort.java", "diffHunk": "@@ -0,0 +1,716 @@\n+/*\n+ * TopologicalSort.java\n+ *\n+ * This source file is part of the FoundationDB open source project\n+ *\n+ * Copyright 2015-2020 Apple Inc. and the FoundationDB project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.apple.foundationdb.record.query.plan.temp;\n+\n+import com.google.common.base.Verify;\n+import com.google.common.collect.AbstractIterator;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.collect.Iterables;\n+import com.google.common.collect.Iterators;\n+import com.google.common.collect.Lists;\n+import com.google.common.collect.Maps;\n+import com.google.common.collect.Multimaps;\n+import com.google.common.collect.PeekingIterator;\n+import com.google.common.collect.SetMultimap;\n+import com.google.common.collect.Sets;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.function.Function;\n+\n+/**\n+ * Utility class to provide helpers related to topological sorts.\n+ *\n+ * The main purpose on this class is to provide a specific iterable that can efficiently traverse\n+ * all possible permutations of the input set that do not violate the given dependency constraints.\n+ *\n+ * The iterable {@link TopologicalOrderPermutationIterable} adheres to the following requirements:\n+ * 1. it does not violate the given constraints\n+ * 2. it produces all possible orderings under the given constraints\n+ * 3. it reacts appropriately to give circular dependency constraints between elements (i.e., no infinite loops)\n+ * 4. it iterates all orderings on the fly. That is, it stores only the position of the iteration and does not (pre)create\n+ *    the orderings in memory.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b64d4eb60de5c3a4be0b4dc0f779ff2f15e47355"}, "originalPosition": 59}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkwMTk0NzM4OnYy", "diffSide": "RIGHT", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/TopologicalSort.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wM1QyMDo0MzoxNlrOG7IFRQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNFQwMDoyNTo0NlrOG7M45A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDY1MTU4OQ==", "bodyText": "I assume this is leftover from various performance experiments?", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/988#discussion_r464651589", "createdAt": "2020-08-03T20:43:16Z", "author": {"login": "nschiefer"}, "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/TopologicalSort.java", "diffHunk": "@@ -0,0 +1,716 @@\n+/*\n+ * TopologicalSort.java\n+ *\n+ * This source file is part of the FoundationDB open source project\n+ *\n+ * Copyright 2015-2020 Apple Inc. and the FoundationDB project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.apple.foundationdb.record.query.plan.temp;\n+\n+import com.google.common.base.Verify;\n+import com.google.common.collect.AbstractIterator;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.collect.Iterables;\n+import com.google.common.collect.Iterators;\n+import com.google.common.collect.Lists;\n+import com.google.common.collect.Maps;\n+import com.google.common.collect.Multimaps;\n+import com.google.common.collect.PeekingIterator;\n+import com.google.common.collect.SetMultimap;\n+import com.google.common.collect.Sets;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.function.Function;\n+\n+/**\n+ * Utility class to provide helpers related to topological sorts.\n+ *\n+ * The main purpose on this class is to provide a specific iterable that can efficiently traverse\n+ * all possible permutations of the input set that do not violate the given dependency constraints.\n+ *\n+ * The iterable {@link TopologicalOrderPermutationIterable} adheres to the following requirements:\n+ * 1. it does not violate the given constraints\n+ * 2. it produces all possible orderings under the given constraints\n+ * 3. it reacts appropriately to give circular dependency constraints between elements (i.e., no infinite loops)\n+ * 4. it iterates all orderings on the fly. That is, it stores only the position of the iteration and does not (pre)create\n+ *    the orderings in memory.\n+ *\n+ * {@link TopologicalOrderPermutationIterable} subclasses {@link Iterable} in order to provide an additional feature\n+ * that allows for skipping. Assume we have a set\n+ * <pre>\n+ * {@code\n+ * { a, b, c, d } with constraints { b -> c, b -> d } (c depends on b, d depends on b)\n+ * }\n+ * </pre>\n+ *\n+ * Possible orderings are\n+ * <pre>\n+ * {@code\n+ * (a, b, c, d)\n+ * (a, b, d, c)\n+ * (b, a, c, d)\n+ * (b, a, d, c)\n+ * (b, c, a, d)\n+ * (b, c, d, a)\n+ * (b, d, a, c)\n+ * (b, d, c, a)\n+ * }\n+ * </pre>\n+ *\n+ * Frequently we test for a certain property or perform a particular operation given one possible ordering but it is clear\n+ * that it is not necessary to consider more such orderings that share a common prefix. In the example, it may be\n+ * beneficial to skip the rest of the {@code (b, a, ...)} orderings after the first one was returned\n+ * ({@code (b, a, c, d}). In this case we would like to instruct the iterator to skip all such orderings and continue\n+ * iteration at {@code (b, c, a, d)}. Similarly, we want to skip all orderings starting with {@code (b, ...)} once we\n+ * encountered the first such ordering. This the iterators created by the provided {@link TopologicalOrderPermutationIterable}\n+ * of type {@link TopologicalOrderPermutationIterator} provide a method {@link TopologicalOrderPermutationIterator#skip}\n+ * to allow skipping to a given prefix.\n+ *\n+ */\n+public class TopologicalSort {\n+    /**\n+     * Iterable that provides special iterators of type {@link TopologicalOrderPermutationIterator}.\n+     * @param <T> type\n+     */\n+    public interface TopologicalOrderPermutationIterable<T> extends Iterable<List<T>> {\n+        @Nonnull\n+        @Override\n+        TopologicalOrderPermutationIterator<T> iterator();\n+    }\n+\n+    /**\n+     * An iterator extending {@link Iterator} providing the ability to skip a certain prefix.\n+     * @param <T> type\n+     */\n+    public interface TopologicalOrderPermutationIterator<T> extends Iterator<List<T>> {\n+        /**\n+         * Instructs the iterator to advance to the next possible ordering using the given zero-indexed level.\n+         *\n+         * Example 1: If the last returned ordering of the iterator {@code it} is {@code (e0, e1, e2, e3)} and\n+         *            {@code it.skip(2)} is called, the state of the iterator is advanced in a way that either\n+         *            reaches the end of iteration or the next item that is returned is {@code (e0', e1', e3', e4')}\n+         *            where the prefix {@code (e1', e2', e3')} is not equal to {code (e1, e2, e3)}.\n+         * Example 2: If the last returned ordering of the iterator {@code it} is {@code (e1, e2, e3, e4)} and\n+         *            {@code it.skip(1)} is called, the state of the iterator is advanced in a way that either reaches\n+         *            the end of iteration or the next item that is returned is {@code (e1', e2', e3', e4')} where\n+         *            the prefix {@code (e1', e2')} is not equal to {code (e1, e2)}.\n+         *\n+         * @param level skip level\n+         */\n+        void skip(int level);\n+    }\n+\n+    /**\n+     * A complex iterable implementing {@link TopologicalOrderPermutationIterable} that is used for sets of cardinality greater\n+     * than 1 (i.e., the regular case).\n+     * @param <T> type\n+     */\n+    private static class BacktrackIterable<T> implements TopologicalOrderPermutationIterable<T> {\n+        @Nonnull\n+        private final ImmutableSet<T> set;\n+        @Nonnull\n+        private final SetMultimap<T, T> dependsOnMap;\n+\n+        private class BacktrackIterator extends AbstractIterator<List<T>> implements TopologicalSort.TopologicalOrderPermutationIterator<T> {\n+            // state\n+            private final Set<T> bound;\n+            private final List<PeekingIterator<T>> state;\n+\n+            private BacktrackIterator() {\n+                this.bound = Sets.newHashSetWithExpectedSize(set.size());\n+                this.state = Lists.newArrayListWithCapacity(set.size());\n+                for (int i = 0; i < set.size(); i ++ ) {\n+                    this.state.add(null);\n+                }\n+            }\n+\n+            @Nullable\n+            @Override\n+            protected List<T> computeNext() {\n+                //\n+                // Iterating through all possible correct orderings of set is inherently easier to encode recursively,\n+                // however, this being an iterator together with the requirement to skip subtrees of iterations warrants\n+                // an iterative solution. All hail the Church-Turing thesis!\n+                //\n+                if (set.isEmpty()) {\n+                    return endOfData();\n+                }\n+\n+                //\n+                // If nothing is bound yet, we are at the beginning and should start at level 0, otherwise\n+                // we conceptually start at the level of the finest granularity bound. Note that that finest\n+                // granularity is usually the granularity of the last element in the set, but it is possible\n+                // for fewer elements to be bound if this is the first call after a skip.\n+                //\n+                int currentLevel = bound.isEmpty() ? 0 : bound.size() - 1;\n+\n+                //\n+                // For each permutation of elements we return, we need to bind n elements (n == set.size()).\n+                // We maintain an iterator through the set (that is stable) for each level up to currentLevel.\n+                // That's the state! The iterator for levels greater than currentLevel must be null. The iterators\n+                // for levels below current level must be on a valid element. The iterator for the currentLevel\n+                // maybe null or a valid element.\n+                //\n+\n+                //\n+                // We also use a set \"bound\" that keeps elements that are currently bound by iterators.\n+                // \"bound\" is solely kept for convenience and is entirely computable from the current\n+                // state of all iterators. We must keep it in sync with the state of the iterators at all times.\n+                //\n+                do {\n+                    //\n+                    // Set the currentIterator. That is the iterator at level currentLevel. If it is null,\n+                    // we create a new iterator over the set.\n+                    //\n+                    final PeekingIterator<T> currentIterator;\n+                    if (state.get(currentLevel) == null) {\n+                        currentIterator = Iterators.peekingIterator(set.iterator());\n+                        state.set(currentLevel, currentIterator);\n+                    } else {\n+                        currentIterator = state.get(currentLevel);\n+                        unbind(currentLevel);\n+                        currentIterator.next();\n+                    }\n+\n+                    //\n+                    // Search currentLevel for a next item that does not violate any constraints. Doing so\n+                    // may exhaust currentIterator in which case we couldn't find another element on the current level.\n+                    // In that case we need to abandon the current level and search on the level above (making that\n+                    // level the current level). If we reach level -1 (i.e., we reach the end of the iterator at level 0\n+                    // we are done.\n+                    // If we do find an element not violating any constraints on the current level we conceptually\n+                    // bind it the element we found and continue on downward.\n+                    //\n+                    final boolean isDown = searchLevel(currentIterator);\n+                    if (!isDown) {\n+                        // back tracking -- need to clear out the current iterator\n+                        state.set(currentLevel, null);\n+                    }\n+                    currentLevel = isDown\n+                                   ? currentLevel + 1\n+                                   : currentLevel - 1;\n+                    \n+                    if (currentLevel == -1) {\n+                        return endOfData();\n+                    }\n+                } while (bound.size() < set.size()); // as long as we still have to find a binding\n+\n+                return state.stream()\n+                        .map(PeekingIterator::peek)\n+                        .collect(ImmutableList.toImmutableList());\n+            }\n+\n+            @SuppressWarnings({\"squid:S135\", \"PMD.AvoidBranchingStatementAsLastInLoop\"})\n+            private boolean searchLevel(final PeekingIterator<T> currentIterator) {\n+                while (currentIterator.hasNext()) {\n+                    final T next = currentIterator.peek();\n+\n+                    // check if it is bound already; t is invisible to this loop if it is bound\n+                    if (bound.contains(next)) {\n+                        currentIterator.next();\n+                        continue;\n+                    }\n+\n+                    //\n+                    // Check if t is only dependent on elements in the current bound set, if it is not it must come later.\n+                    // Note that the intersection removes elements the current element depends on that are not in set.\n+                    // That behavior is for convenience reasons and and specifically not an error.\n+                    //\n+                    final Set<T> dependsOn = Sets.intersection(set, dependsOnMap.get(next));\n+                    if (!bound.containsAll(dependsOn)) {\n+                        currentIterator.next();\n+                        continue;\n+                    }\n+\n+                    // this level can be bound now\n+                    bound.add(next);\n+                    return true; // go down\n+                }\n+                return false; // go up\n+            }\n+\n+            private void unbind(final int level) {\n+                // reset all the following ones\n+                for (int i = level; i < set.size(); i ++ ) {\n+                    // either iterator is on a valid item or iterator is null\n+                    if (state.get(i) != null) {\n+                        bound.remove(state.get(i).peek());\n+                    } else {\n+                        break;\n+                    }\n+                }\n+            }\n+\n+            /**\n+             * Method that skips advances to the next element on the given zero-indexed level.\n+             * @param level level to advance\n+             */\n+            @Override\n+            public void skip(final int level) {\n+                if (level >= set.size()) {\n+                    throw new IndexOutOfBoundsException();\n+                }\n+\n+                if (state.get(level) == null) {\n+                    throw new UnsupportedOperationException(\"cannot skip/unbind as level is not bound at all\");\n+                }\n+\n+                // reset all the following ones\n+                for (int i = level + 1; i < set.size(); i ++ ) {\n+                    // either iterator is on a valid item or iterator is null\n+                    if (state.get(i) != null) {\n+                        bound.remove(state.get(i).peek());\n+                        state.set(i, null);\n+                    } else {\n+                        break;\n+                    }\n+                }\n+            }\n+        }\n+\n+        private BacktrackIterable(@Nonnull final Set<T> set, @Nonnull final SetMultimap<T, T> dependsOnMap) {\n+            Verify.verify(set.size() > 1);\n+            this.set = ImmutableSet.copyOf(set);\n+            this.dependsOnMap = dependsOnMap;\n+        }\n+\n+        @Nonnull\n+        @Override\n+        public TopologicalOrderPermutationIterator<T> iterator() {\n+            return new BacktrackIterator();\n+        }\n+    }\n+\n+    /**\n+     * A complex iterable implementing a {@link TopologicalOrderPermutationIterable} that is used for sets of cardinality greater\n+     * than 1 (i.e., the regular case).\n+     * @param <T> type\n+     */\n+    private static class KahnIterable<T> implements TopologicalOrderPermutationIterable<T> {\n+        @Nonnull\n+        private final ImmutableSet<T> set;\n+        @Nonnull\n+        private final SetMultimap<T, T> usedByMap;\n+\n+        private class KahnIterator extends AbstractIterator<List<T>> implements TopologicalOrderPermutationIterator<T> {\n+            // state\n+            private final Set<T> bound;\n+            private final Map<T, Integer> inDegreeMap;\n+            private final List<Set<T>> eligibleElementSets;\n+            private final List<PeekingIterator<T>> iterators;\n+\n+            private KahnIterator() {\n+                this.bound = Sets.newHashSetWithExpectedSize(set.size());\n+                this.inDegreeMap = computeInDegreeMap();\n+                this.eligibleElementSets = Lists.newArrayListWithCapacity(set.size());\n+                // add the set of immediately satisfiable sets\n+                this.eligibleElementSets\n+                        .add(this.inDegreeMap\n+                                .entrySet()\n+                                .stream()\n+                                .filter(entry -> entry.getValue() == 0)\n+                                .map(Map.Entry::getKey)\n+                                .collect(ImmutableSet.toImmutableSet()));\n+                for (int i = 1; i < set.size(); i ++ ) {\n+                    this.eligibleElementSets.add(null);\n+                }\n+                this.iterators = Lists.newArrayListWithCapacity(set.size());\n+                for (int i = 0; i < set.size(); i ++ ) {\n+                    this.iterators.add(null);\n+                }\n+            }\n+\n+            @Nullable\n+            @Override\n+            protected List<T> computeNext() {\n+                //\n+                // Iterating through all possible correct orderings of set is inherently easier to encode recursively,\n+                // however, this being an iterator together with the requirement to skip subtrees of iterations warrants\n+                // an iterative solution. All hail the Church-Turing thesis!\n+                //\n+                if (set.isEmpty()) {\n+                    return endOfData();\n+                }\n+\n+                //\n+                // If nothing is bound yet, we are at the beginning and should start at level 0, otherwise\n+                // we conceptually start at the level of the finest granularity bound. Note that that finest\n+                // granularity is usually the granularity of the last element in the set, but it is possible\n+                // for fewer elements to be bound if this is the first call after a skip.\n+                //\n+                int currentLevel = bound.isEmpty() ? 0 : bound.size() - 1;\n+\n+                //\n+                // For each permutation of elements we return, we need to bind n elements (n == set.size()).\n+                // We maintain an iterator through the set (that is stable) for each level up to currentLevel.\n+                // That's the state! The iterator for levels greater than currentLevel must be null. The iterators\n+                // for levels below current level must be on a valid element. The iterator for the currentLevel\n+                // maybe null or a valid element.\n+                //\n+\n+                //\n+                // We also use a set \"bound\" that keeps elements that are currently bound by iterators.\n+                // \"bound\" is solely kept for convenience and is entirely computable from the current\n+                // state of all iterators. We must keep it in sync with the state of the iterators at all times.\n+                //\n+                do {\n+                    //\n+                    // Set the currentIterator. That is the iterator at level currentLevel. If it is null,\n+                    // we create a new iterator over the set.\n+                    //\n+                    final PeekingIterator<T> currentIterator;\n+                    if (iterators.get(currentLevel) == null) {\n+                        currentIterator = Iterators.peekingIterator(eligibleElementSets.get(currentLevel).iterator());\n+                        iterators.set(currentLevel, currentIterator);\n+                    } else {\n+                        currentIterator = iterators.get(currentLevel);\n+                        unbindTail(currentLevel);\n+                        currentIterator.next();\n+                    }\n+\n+                    //\n+                    // Search currentLevel for a next item that does not violate any constraints. Doing so\n+                    // may exhaust currentIterator in which case we couldn't find another element on the current level.\n+                    // In that case we need to abandon the current level and search on the level above (making that\n+                    // level the current level). If we reach level -1 (i.e., we reach the end of the iterator at level 0\n+                    // we are done.\n+                    // If we do find an element not violating any constraints on the current level we conceptually\n+                    // bind it the element we found and continue on downward.\n+                    //\n+                    final boolean foundOnLevel = nextOnLevel(currentIterator);\n+                    if (!foundOnLevel) {\n+                        // back tracking -- need to clear out the current iterator\n+                        iterators.set(currentLevel, null);\n+                    }\n+                    currentLevel = foundOnLevel\n+                                   ? currentLevel + 1\n+                                   : currentLevel - 1;\n+\n+                    if (currentLevel == -1) {\n+                        return endOfData();\n+                    }\n+                } while (bound.size() < set.size()); // as long as we still have to find a binding\n+\n+                return iterators.stream()\n+                        .map(PeekingIterator::peek)\n+                        .collect(ImmutableList.toImmutableList());\n+            }\n+\n+            @SuppressWarnings({\"squid:S135\", \"UnstableApiUsage\", \"PMD.AvoidBranchingStatementAsLastInLoop\"})\n+            private boolean nextOnLevel(final PeekingIterator<T> currentIterator) {\n+                while (currentIterator.hasNext()) {\n+                    final T next = currentIterator.peek();\n+\n+                    // check if it is bound already; t is invisible to this loop if it is bound\n+                    if (bound.contains(next)) {\n+                        currentIterator.next();\n+                        continue;\n+                    }\n+\n+                    // this level can be bound now\n+                    bound.add(next);\n+\n+                    final Set<T> targets = usedByMap.get(next);\n+                    final ImmutableSet.Builder<T> newlyEligibleElementsBuilder = ImmutableSet.builderWithExpectedSize(targets.size());\n+                    for (final T target : targets) {\n+                        final int newInDegree = inDegreeMap.compute(target, (k, v) -> Objects.requireNonNull(v) - 1);\n+                        Verify.verify(newInDegree >= 0);\n+                        if (newInDegree == 0) {\n+                            newlyEligibleElementsBuilder.add(target);\n+                        }\n+                    }\n+\n+                    if (bound.size() < set.size()) {\n+                        newlyEligibleElementsBuilder\n+                                .addAll(eligibleElementSets.get(bound.size() - 1))\n+                                .build();\n+\n+                        //eligibleElementSets.set(bound.size(), Sets.union(eligibleElementSets.get(bound.size() - 1), newlyEligibleElements));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b64d4eb60de5c3a4be0b4dc0f779ff2f15e47355"}, "originalPosition": 451}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDczMDM0MA==", "bodyText": "Yes, as it turns out, creating sets that are views (unions) of other sets are a bad idea if they are the equivalent nesting dolls as your set then turns into a linked list and look ups are effectively linear instead of effectively constant.", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/988#discussion_r464730340", "createdAt": "2020-08-04T00:25:46Z", "author": {"login": "normen662"}, "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/TopologicalSort.java", "diffHunk": "@@ -0,0 +1,716 @@\n+/*\n+ * TopologicalSort.java\n+ *\n+ * This source file is part of the FoundationDB open source project\n+ *\n+ * Copyright 2015-2020 Apple Inc. and the FoundationDB project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.apple.foundationdb.record.query.plan.temp;\n+\n+import com.google.common.base.Verify;\n+import com.google.common.collect.AbstractIterator;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.collect.Iterables;\n+import com.google.common.collect.Iterators;\n+import com.google.common.collect.Lists;\n+import com.google.common.collect.Maps;\n+import com.google.common.collect.Multimaps;\n+import com.google.common.collect.PeekingIterator;\n+import com.google.common.collect.SetMultimap;\n+import com.google.common.collect.Sets;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.function.Function;\n+\n+/**\n+ * Utility class to provide helpers related to topological sorts.\n+ *\n+ * The main purpose on this class is to provide a specific iterable that can efficiently traverse\n+ * all possible permutations of the input set that do not violate the given dependency constraints.\n+ *\n+ * The iterable {@link TopologicalOrderPermutationIterable} adheres to the following requirements:\n+ * 1. it does not violate the given constraints\n+ * 2. it produces all possible orderings under the given constraints\n+ * 3. it reacts appropriately to give circular dependency constraints between elements (i.e., no infinite loops)\n+ * 4. it iterates all orderings on the fly. That is, it stores only the position of the iteration and does not (pre)create\n+ *    the orderings in memory.\n+ *\n+ * {@link TopologicalOrderPermutationIterable} subclasses {@link Iterable} in order to provide an additional feature\n+ * that allows for skipping. Assume we have a set\n+ * <pre>\n+ * {@code\n+ * { a, b, c, d } with constraints { b -> c, b -> d } (c depends on b, d depends on b)\n+ * }\n+ * </pre>\n+ *\n+ * Possible orderings are\n+ * <pre>\n+ * {@code\n+ * (a, b, c, d)\n+ * (a, b, d, c)\n+ * (b, a, c, d)\n+ * (b, a, d, c)\n+ * (b, c, a, d)\n+ * (b, c, d, a)\n+ * (b, d, a, c)\n+ * (b, d, c, a)\n+ * }\n+ * </pre>\n+ *\n+ * Frequently we test for a certain property or perform a particular operation given one possible ordering but it is clear\n+ * that it is not necessary to consider more such orderings that share a common prefix. In the example, it may be\n+ * beneficial to skip the rest of the {@code (b, a, ...)} orderings after the first one was returned\n+ * ({@code (b, a, c, d}). In this case we would like to instruct the iterator to skip all such orderings and continue\n+ * iteration at {@code (b, c, a, d)}. Similarly, we want to skip all orderings starting with {@code (b, ...)} once we\n+ * encountered the first such ordering. This the iterators created by the provided {@link TopologicalOrderPermutationIterable}\n+ * of type {@link TopologicalOrderPermutationIterator} provide a method {@link TopologicalOrderPermutationIterator#skip}\n+ * to allow skipping to a given prefix.\n+ *\n+ */\n+public class TopologicalSort {\n+    /**\n+     * Iterable that provides special iterators of type {@link TopologicalOrderPermutationIterator}.\n+     * @param <T> type\n+     */\n+    public interface TopologicalOrderPermutationIterable<T> extends Iterable<List<T>> {\n+        @Nonnull\n+        @Override\n+        TopologicalOrderPermutationIterator<T> iterator();\n+    }\n+\n+    /**\n+     * An iterator extending {@link Iterator} providing the ability to skip a certain prefix.\n+     * @param <T> type\n+     */\n+    public interface TopologicalOrderPermutationIterator<T> extends Iterator<List<T>> {\n+        /**\n+         * Instructs the iterator to advance to the next possible ordering using the given zero-indexed level.\n+         *\n+         * Example 1: If the last returned ordering of the iterator {@code it} is {@code (e0, e1, e2, e3)} and\n+         *            {@code it.skip(2)} is called, the state of the iterator is advanced in a way that either\n+         *            reaches the end of iteration or the next item that is returned is {@code (e0', e1', e3', e4')}\n+         *            where the prefix {@code (e1', e2', e3')} is not equal to {code (e1, e2, e3)}.\n+         * Example 2: If the last returned ordering of the iterator {@code it} is {@code (e1, e2, e3, e4)} and\n+         *            {@code it.skip(1)} is called, the state of the iterator is advanced in a way that either reaches\n+         *            the end of iteration or the next item that is returned is {@code (e1', e2', e3', e4')} where\n+         *            the prefix {@code (e1', e2')} is not equal to {code (e1, e2)}.\n+         *\n+         * @param level skip level\n+         */\n+        void skip(int level);\n+    }\n+\n+    /**\n+     * A complex iterable implementing {@link TopologicalOrderPermutationIterable} that is used for sets of cardinality greater\n+     * than 1 (i.e., the regular case).\n+     * @param <T> type\n+     */\n+    private static class BacktrackIterable<T> implements TopologicalOrderPermutationIterable<T> {\n+        @Nonnull\n+        private final ImmutableSet<T> set;\n+        @Nonnull\n+        private final SetMultimap<T, T> dependsOnMap;\n+\n+        private class BacktrackIterator extends AbstractIterator<List<T>> implements TopologicalSort.TopologicalOrderPermutationIterator<T> {\n+            // state\n+            private final Set<T> bound;\n+            private final List<PeekingIterator<T>> state;\n+\n+            private BacktrackIterator() {\n+                this.bound = Sets.newHashSetWithExpectedSize(set.size());\n+                this.state = Lists.newArrayListWithCapacity(set.size());\n+                for (int i = 0; i < set.size(); i ++ ) {\n+                    this.state.add(null);\n+                }\n+            }\n+\n+            @Nullable\n+            @Override\n+            protected List<T> computeNext() {\n+                //\n+                // Iterating through all possible correct orderings of set is inherently easier to encode recursively,\n+                // however, this being an iterator together with the requirement to skip subtrees of iterations warrants\n+                // an iterative solution. All hail the Church-Turing thesis!\n+                //\n+                if (set.isEmpty()) {\n+                    return endOfData();\n+                }\n+\n+                //\n+                // If nothing is bound yet, we are at the beginning and should start at level 0, otherwise\n+                // we conceptually start at the level of the finest granularity bound. Note that that finest\n+                // granularity is usually the granularity of the last element in the set, but it is possible\n+                // for fewer elements to be bound if this is the first call after a skip.\n+                //\n+                int currentLevel = bound.isEmpty() ? 0 : bound.size() - 1;\n+\n+                //\n+                // For each permutation of elements we return, we need to bind n elements (n == set.size()).\n+                // We maintain an iterator through the set (that is stable) for each level up to currentLevel.\n+                // That's the state! The iterator for levels greater than currentLevel must be null. The iterators\n+                // for levels below current level must be on a valid element. The iterator for the currentLevel\n+                // maybe null or a valid element.\n+                //\n+\n+                //\n+                // We also use a set \"bound\" that keeps elements that are currently bound by iterators.\n+                // \"bound\" is solely kept for convenience and is entirely computable from the current\n+                // state of all iterators. We must keep it in sync with the state of the iterators at all times.\n+                //\n+                do {\n+                    //\n+                    // Set the currentIterator. That is the iterator at level currentLevel. If it is null,\n+                    // we create a new iterator over the set.\n+                    //\n+                    final PeekingIterator<T> currentIterator;\n+                    if (state.get(currentLevel) == null) {\n+                        currentIterator = Iterators.peekingIterator(set.iterator());\n+                        state.set(currentLevel, currentIterator);\n+                    } else {\n+                        currentIterator = state.get(currentLevel);\n+                        unbind(currentLevel);\n+                        currentIterator.next();\n+                    }\n+\n+                    //\n+                    // Search currentLevel for a next item that does not violate any constraints. Doing so\n+                    // may exhaust currentIterator in which case we couldn't find another element on the current level.\n+                    // In that case we need to abandon the current level and search on the level above (making that\n+                    // level the current level). If we reach level -1 (i.e., we reach the end of the iterator at level 0\n+                    // we are done.\n+                    // If we do find an element not violating any constraints on the current level we conceptually\n+                    // bind it the element we found and continue on downward.\n+                    //\n+                    final boolean isDown = searchLevel(currentIterator);\n+                    if (!isDown) {\n+                        // back tracking -- need to clear out the current iterator\n+                        state.set(currentLevel, null);\n+                    }\n+                    currentLevel = isDown\n+                                   ? currentLevel + 1\n+                                   : currentLevel - 1;\n+                    \n+                    if (currentLevel == -1) {\n+                        return endOfData();\n+                    }\n+                } while (bound.size() < set.size()); // as long as we still have to find a binding\n+\n+                return state.stream()\n+                        .map(PeekingIterator::peek)\n+                        .collect(ImmutableList.toImmutableList());\n+            }\n+\n+            @SuppressWarnings({\"squid:S135\", \"PMD.AvoidBranchingStatementAsLastInLoop\"})\n+            private boolean searchLevel(final PeekingIterator<T> currentIterator) {\n+                while (currentIterator.hasNext()) {\n+                    final T next = currentIterator.peek();\n+\n+                    // check if it is bound already; t is invisible to this loop if it is bound\n+                    if (bound.contains(next)) {\n+                        currentIterator.next();\n+                        continue;\n+                    }\n+\n+                    //\n+                    // Check if t is only dependent on elements in the current bound set, if it is not it must come later.\n+                    // Note that the intersection removes elements the current element depends on that are not in set.\n+                    // That behavior is for convenience reasons and and specifically not an error.\n+                    //\n+                    final Set<T> dependsOn = Sets.intersection(set, dependsOnMap.get(next));\n+                    if (!bound.containsAll(dependsOn)) {\n+                        currentIterator.next();\n+                        continue;\n+                    }\n+\n+                    // this level can be bound now\n+                    bound.add(next);\n+                    return true; // go down\n+                }\n+                return false; // go up\n+            }\n+\n+            private void unbind(final int level) {\n+                // reset all the following ones\n+                for (int i = level; i < set.size(); i ++ ) {\n+                    // either iterator is on a valid item or iterator is null\n+                    if (state.get(i) != null) {\n+                        bound.remove(state.get(i).peek());\n+                    } else {\n+                        break;\n+                    }\n+                }\n+            }\n+\n+            /**\n+             * Method that skips advances to the next element on the given zero-indexed level.\n+             * @param level level to advance\n+             */\n+            @Override\n+            public void skip(final int level) {\n+                if (level >= set.size()) {\n+                    throw new IndexOutOfBoundsException();\n+                }\n+\n+                if (state.get(level) == null) {\n+                    throw new UnsupportedOperationException(\"cannot skip/unbind as level is not bound at all\");\n+                }\n+\n+                // reset all the following ones\n+                for (int i = level + 1; i < set.size(); i ++ ) {\n+                    // either iterator is on a valid item or iterator is null\n+                    if (state.get(i) != null) {\n+                        bound.remove(state.get(i).peek());\n+                        state.set(i, null);\n+                    } else {\n+                        break;\n+                    }\n+                }\n+            }\n+        }\n+\n+        private BacktrackIterable(@Nonnull final Set<T> set, @Nonnull final SetMultimap<T, T> dependsOnMap) {\n+            Verify.verify(set.size() > 1);\n+            this.set = ImmutableSet.copyOf(set);\n+            this.dependsOnMap = dependsOnMap;\n+        }\n+\n+        @Nonnull\n+        @Override\n+        public TopologicalOrderPermutationIterator<T> iterator() {\n+            return new BacktrackIterator();\n+        }\n+    }\n+\n+    /**\n+     * A complex iterable implementing a {@link TopologicalOrderPermutationIterable} that is used for sets of cardinality greater\n+     * than 1 (i.e., the regular case).\n+     * @param <T> type\n+     */\n+    private static class KahnIterable<T> implements TopologicalOrderPermutationIterable<T> {\n+        @Nonnull\n+        private final ImmutableSet<T> set;\n+        @Nonnull\n+        private final SetMultimap<T, T> usedByMap;\n+\n+        private class KahnIterator extends AbstractIterator<List<T>> implements TopologicalOrderPermutationIterator<T> {\n+            // state\n+            private final Set<T> bound;\n+            private final Map<T, Integer> inDegreeMap;\n+            private final List<Set<T>> eligibleElementSets;\n+            private final List<PeekingIterator<T>> iterators;\n+\n+            private KahnIterator() {\n+                this.bound = Sets.newHashSetWithExpectedSize(set.size());\n+                this.inDegreeMap = computeInDegreeMap();\n+                this.eligibleElementSets = Lists.newArrayListWithCapacity(set.size());\n+                // add the set of immediately satisfiable sets\n+                this.eligibleElementSets\n+                        .add(this.inDegreeMap\n+                                .entrySet()\n+                                .stream()\n+                                .filter(entry -> entry.getValue() == 0)\n+                                .map(Map.Entry::getKey)\n+                                .collect(ImmutableSet.toImmutableSet()));\n+                for (int i = 1; i < set.size(); i ++ ) {\n+                    this.eligibleElementSets.add(null);\n+                }\n+                this.iterators = Lists.newArrayListWithCapacity(set.size());\n+                for (int i = 0; i < set.size(); i ++ ) {\n+                    this.iterators.add(null);\n+                }\n+            }\n+\n+            @Nullable\n+            @Override\n+            protected List<T> computeNext() {\n+                //\n+                // Iterating through all possible correct orderings of set is inherently easier to encode recursively,\n+                // however, this being an iterator together with the requirement to skip subtrees of iterations warrants\n+                // an iterative solution. All hail the Church-Turing thesis!\n+                //\n+                if (set.isEmpty()) {\n+                    return endOfData();\n+                }\n+\n+                //\n+                // If nothing is bound yet, we are at the beginning and should start at level 0, otherwise\n+                // we conceptually start at the level of the finest granularity bound. Note that that finest\n+                // granularity is usually the granularity of the last element in the set, but it is possible\n+                // for fewer elements to be bound if this is the first call after a skip.\n+                //\n+                int currentLevel = bound.isEmpty() ? 0 : bound.size() - 1;\n+\n+                //\n+                // For each permutation of elements we return, we need to bind n elements (n == set.size()).\n+                // We maintain an iterator through the set (that is stable) for each level up to currentLevel.\n+                // That's the state! The iterator for levels greater than currentLevel must be null. The iterators\n+                // for levels below current level must be on a valid element. The iterator for the currentLevel\n+                // maybe null or a valid element.\n+                //\n+\n+                //\n+                // We also use a set \"bound\" that keeps elements that are currently bound by iterators.\n+                // \"bound\" is solely kept for convenience and is entirely computable from the current\n+                // state of all iterators. We must keep it in sync with the state of the iterators at all times.\n+                //\n+                do {\n+                    //\n+                    // Set the currentIterator. That is the iterator at level currentLevel. If it is null,\n+                    // we create a new iterator over the set.\n+                    //\n+                    final PeekingIterator<T> currentIterator;\n+                    if (iterators.get(currentLevel) == null) {\n+                        currentIterator = Iterators.peekingIterator(eligibleElementSets.get(currentLevel).iterator());\n+                        iterators.set(currentLevel, currentIterator);\n+                    } else {\n+                        currentIterator = iterators.get(currentLevel);\n+                        unbindTail(currentLevel);\n+                        currentIterator.next();\n+                    }\n+\n+                    //\n+                    // Search currentLevel for a next item that does not violate any constraints. Doing so\n+                    // may exhaust currentIterator in which case we couldn't find another element on the current level.\n+                    // In that case we need to abandon the current level and search on the level above (making that\n+                    // level the current level). If we reach level -1 (i.e., we reach the end of the iterator at level 0\n+                    // we are done.\n+                    // If we do find an element not violating any constraints on the current level we conceptually\n+                    // bind it the element we found and continue on downward.\n+                    //\n+                    final boolean foundOnLevel = nextOnLevel(currentIterator);\n+                    if (!foundOnLevel) {\n+                        // back tracking -- need to clear out the current iterator\n+                        iterators.set(currentLevel, null);\n+                    }\n+                    currentLevel = foundOnLevel\n+                                   ? currentLevel + 1\n+                                   : currentLevel - 1;\n+\n+                    if (currentLevel == -1) {\n+                        return endOfData();\n+                    }\n+                } while (bound.size() < set.size()); // as long as we still have to find a binding\n+\n+                return iterators.stream()\n+                        .map(PeekingIterator::peek)\n+                        .collect(ImmutableList.toImmutableList());\n+            }\n+\n+            @SuppressWarnings({\"squid:S135\", \"UnstableApiUsage\", \"PMD.AvoidBranchingStatementAsLastInLoop\"})\n+            private boolean nextOnLevel(final PeekingIterator<T> currentIterator) {\n+                while (currentIterator.hasNext()) {\n+                    final T next = currentIterator.peek();\n+\n+                    // check if it is bound already; t is invisible to this loop if it is bound\n+                    if (bound.contains(next)) {\n+                        currentIterator.next();\n+                        continue;\n+                    }\n+\n+                    // this level can be bound now\n+                    bound.add(next);\n+\n+                    final Set<T> targets = usedByMap.get(next);\n+                    final ImmutableSet.Builder<T> newlyEligibleElementsBuilder = ImmutableSet.builderWithExpectedSize(targets.size());\n+                    for (final T target : targets) {\n+                        final int newInDegree = inDegreeMap.compute(target, (k, v) -> Objects.requireNonNull(v) - 1);\n+                        Verify.verify(newInDegree >= 0);\n+                        if (newInDegree == 0) {\n+                            newlyEligibleElementsBuilder.add(target);\n+                        }\n+                    }\n+\n+                    if (bound.size() < set.size()) {\n+                        newlyEligibleElementsBuilder\n+                                .addAll(eligibleElementSets.get(bound.size() - 1))\n+                                .build();\n+\n+                        //eligibleElementSets.set(bound.size(), Sets.union(eligibleElementSets.get(bound.size() - 1), newlyEligibleElements));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDY1MTU4OQ=="}, "originalCommit": {"oid": "b64d4eb60de5c3a4be0b4dc0f779ff2f15e47355"}, "originalPosition": 451}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkwMTk2MDMzOnYy", "diffSide": "RIGHT", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/RelationalExpression.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wM1QyMDo0NzozM1rOG7INXg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wM1QyMDo0NzozM1rOG7INXg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDY1MzY2Mg==", "bodyText": "Let's convert this to an <ul>.", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/988#discussion_r464653662", "createdAt": "2020-08-03T20:47:33Z", "author": {"login": "nschiefer"}, "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/RelationalExpression.java", "diffHunk": "@@ -136,7 +144,106 @@ static RelationalExpression fromRecordQuery(@Nonnull RecordQuery query, @Nonnull\n     @Nonnull\n     List<? extends Quantifier> getQuantifiers();\n \n-    boolean equalsWithoutChildren(@Nonnull RelationalExpression otherExpression);\n+    /**\n+     * Returns if this expression can be the anchor of a correlation.\n+     *\n+     * A correlation is always formed between three entities:\n+     * 1. the {@link Quantifier} that flows data\n+     * 2. the anchor (which is a {@link RelationalExpression} that ranges directly over the source\n+     * 3. the consumers (or dependents) of the correlation which must be a descendant of the anchor.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b64d4eb60de5c3a4be0b4dc0f779ff2f15e47355"}, "originalPosition": 87}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkwMTk2MjIwOnYy", "diffSide": "RIGHT", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/RelationalExpression.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wM1QyMDo0ODoxNlrOG7IOiQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wM1QyMDo0ODoxNlrOG7IOiQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDY1Mzk2MQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * cannot correlate (this method returns {@code false}) because it is not meaningful e.g. to bind a record\n          \n          \n            \n                 * from the left child of the union and provide bound values to the evaluation of the right child.\n          \n          \n            \n                 * cannot correlate (this method returns {@code false}) because it is not meaningful to bind a record from one child of the union while providing bound values to another.", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/988#discussion_r464653961", "createdAt": "2020-08-03T20:48:16Z", "author": {"login": "nschiefer"}, "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/RelationalExpression.java", "diffHunk": "@@ -136,7 +144,106 @@ static RelationalExpression fromRecordQuery(@Nonnull RecordQuery query, @Nonnull\n     @Nonnull\n     List<? extends Quantifier> getQuantifiers();\n \n-    boolean equalsWithoutChildren(@Nonnull RelationalExpression otherExpression);\n+    /**\n+     * Returns if this expression can be the anchor of a correlation.\n+     *\n+     * A correlation is always formed between three entities:\n+     * 1. the {@link Quantifier} that flows data\n+     * 2. the anchor (which is a {@link RelationalExpression} that ranges directly over the source\n+     * 3. the consumers (or dependents) of the correlation which must be a descendant of the anchor.\n+     *\n+     * In order for a correlation to be meaningful, the anchor must define how data is bound and used by all\n+     * dependents. For most expressions it is not meaningful or even possible to define correlation in such a way.\n+     *\n+     * For instance, a {@link com.apple.foundationdb.record.query.plan.temp.expressions.LogicalUnorderedUnionExpression}\n+     * cannot correlate (this method returns {@code false}) because it is not meaningful e.g. to bind a record\n+     * from the left child of the union and provide bound values to the evaluation of the right child.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b64d4eb60de5c3a4be0b4dc0f779ff2f15e47355"}, "originalPosition": 94}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkwMTk2NDQ5OnYy", "diffSide": "RIGHT", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/RelationalExpression.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wM1QyMDo0ODo1M1rOG7IP0Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wM1QyMDo0ODo1M1rOG7IP0Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDY1NDI4OQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * can be evaluated and the resulting records can bound individually one after another. For each bound flowing\n          \n          \n            \n                 * record along that quantifier the other children of the SELECT expression can be evaluated, potentially causing\n          \n          \n            \n                 * can be evaluated and the resulting records can bound individually one after another. For each bound record\n          \n          \n            \n                 * flowing along that quantifier the other children of the SELECT expression can be evaluated, potentially causing", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/988#discussion_r464654289", "createdAt": "2020-08-03T20:48:53Z", "author": {"login": "nschiefer"}, "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/RelationalExpression.java", "diffHunk": "@@ -136,7 +144,106 @@ static RelationalExpression fromRecordQuery(@Nonnull RecordQuery query, @Nonnull\n     @Nonnull\n     List<? extends Quantifier> getQuantifiers();\n \n-    boolean equalsWithoutChildren(@Nonnull RelationalExpression otherExpression);\n+    /**\n+     * Returns if this expression can be the anchor of a correlation.\n+     *\n+     * A correlation is always formed between three entities:\n+     * 1. the {@link Quantifier} that flows data\n+     * 2. the anchor (which is a {@link RelationalExpression} that ranges directly over the source\n+     * 3. the consumers (or dependents) of the correlation which must be a descendant of the anchor.\n+     *\n+     * In order for a correlation to be meaningful, the anchor must define how data is bound and used by all\n+     * dependents. For most expressions it is not meaningful or even possible to define correlation in such a way.\n+     *\n+     * For instance, a {@link com.apple.foundationdb.record.query.plan.temp.expressions.LogicalUnorderedUnionExpression}\n+     * cannot correlate (this method returns {@code false}) because it is not meaningful e.g. to bind a record\n+     * from the left child of the union and provide bound values to the evaluation of the right child.\n+     *\n+     * In another example, a logical select expression can correlate which means that one child of the SELECT expression\n+     * can be evaluated and the resulting records can bound individually one after another. For each bound flowing\n+     * record along that quantifier the other children of the SELECT expression can be evaluated, potentially causing", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b64d4eb60de5c3a4be0b4dc0f779ff2f15e47355"}, "originalPosition": 98}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkwMTk2NTYwOnYy", "diffSide": "RIGHT", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/RelationalExpression.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wM1QyMDo0OToxN1rOG7IQmA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wM1QyMDo0OToxN1rOG7IQmA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDY1NDQ4OA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * The existence of a correlation between source, anchor, and dependents may adversely affect planning in a way that\n          \n          \n            \n                 * a correlation always imposes order between the evaluated of children of e.g. a select expression. This may or may\n          \n          \n            \n                 * The existence of a correlation between source, anchor, and dependents may adversely affect planning because\n          \n          \n            \n                  * a correlation always imposes order between the evaluated of children of an expression. This may or may", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/988#discussion_r464654488", "createdAt": "2020-08-03T20:49:17Z", "author": {"login": "nschiefer"}, "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/RelationalExpression.java", "diffHunk": "@@ -136,7 +144,106 @@ static RelationalExpression fromRecordQuery(@Nonnull RecordQuery query, @Nonnull\n     @Nonnull\n     List<? extends Quantifier> getQuantifiers();\n \n-    boolean equalsWithoutChildren(@Nonnull RelationalExpression otherExpression);\n+    /**\n+     * Returns if this expression can be the anchor of a correlation.\n+     *\n+     * A correlation is always formed between three entities:\n+     * 1. the {@link Quantifier} that flows data\n+     * 2. the anchor (which is a {@link RelationalExpression} that ranges directly over the source\n+     * 3. the consumers (or dependents) of the correlation which must be a descendant of the anchor.\n+     *\n+     * In order for a correlation to be meaningful, the anchor must define how data is bound and used by all\n+     * dependents. For most expressions it is not meaningful or even possible to define correlation in such a way.\n+     *\n+     * For instance, a {@link com.apple.foundationdb.record.query.plan.temp.expressions.LogicalUnorderedUnionExpression}\n+     * cannot correlate (this method returns {@code false}) because it is not meaningful e.g. to bind a record\n+     * from the left child of the union and provide bound values to the evaluation of the right child.\n+     *\n+     * In another example, a logical select expression can correlate which means that one child of the SELECT expression\n+     * can be evaluated and the resulting records can bound individually one after another. For each bound flowing\n+     * record along that quantifier the other children of the SELECT expression can be evaluated, potentially causing\n+     * more correlation values to be bound, etc. These concepts follow closely to the mechanics of what SQL calls a query\n+     * block.\n+     *\n+     * The existence of a correlation between source, anchor, and dependents may adversely affect planning in a way that\n+     * a correlation always imposes order between the evaluated of children of e.g. a select expression. This may or may", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b64d4eb60de5c3a4be0b4dc0f779ff2f15e47355"}, "originalPosition": 103}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkwMTk3MDI2OnYy", "diffSide": "RIGHT", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/ExpressionRefTraversal.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wM1QyMDo1MDo1MFrOG7ITUw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wM1QyMDo1MDo1MFrOG7ITUw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDY1NTE4Nw==", "bodyText": "We should fill in this Javadoc before merging.", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/988#discussion_r464655187", "createdAt": "2020-08-03T20:50:50Z", "author": {"login": "nschiefer"}, "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/ExpressionRefTraversal.java", "diffHunk": "@@ -0,0 +1,142 @@\n+/*\n+ * ExpressionRefTraversal.java\n+ *\n+ * This source file is part of the FoundationDB open source project\n+ *\n+ * Copyright 2015-2020 Apple Inc. and the FoundationDB project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.apple.foundationdb.record.query.plan.temp;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.graph.EndpointPair;\n+import com.google.common.graph.ImmutableNetwork;\n+import com.google.common.graph.MutableNetwork;\n+import com.google.common.graph.Network;\n+import com.google.common.graph.NetworkBuilder;\n+\n+import javax.annotation.Nonnull;\n+import java.util.List;\n+import java.util.Set;\n+\n+/**\n+ * TDB.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b64d4eb60de5c3a4be0b4dc0f779ff2f15e47355"}, "originalPosition": 36}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkwMTk3MzA0OnYy", "diffSide": "RIGHT", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/ExpressionRefTraversal.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wM1QyMDo1MTo0MVrOG7IU7A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wM1QyMDo1MTo0MVrOG7IU7A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDY1NTU5Ng==", "bodyText": "?", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/988#discussion_r464655596", "createdAt": "2020-08-03T20:51:41Z", "author": {"login": "nschiefer"}, "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/ExpressionRefTraversal.java", "diffHunk": "@@ -0,0 +1,142 @@\n+/*\n+ * ExpressionRefTraversal.java\n+ *\n+ * This source file is part of the FoundationDB open source project\n+ *\n+ * Copyright 2015-2020 Apple Inc. and the FoundationDB project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.apple.foundationdb.record.query.plan.temp;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.graph.EndpointPair;\n+import com.google.common.graph.ImmutableNetwork;\n+import com.google.common.graph.MutableNetwork;\n+import com.google.common.graph.Network;\n+import com.google.common.graph.NetworkBuilder;\n+\n+import javax.annotation.Nonnull;\n+import java.util.List;\n+import java.util.Set;\n+\n+/**\n+ * TDB.\n+\n+ */\n+@SuppressWarnings(\"UnstableApiUsage\")\n+public class ExpressionRefTraversal {\n+\n+    @Nonnull\n+    private final ExpressionRef<? extends RelationalExpression> rootRef;\n+    @Nonnull\n+    private final Network<ExpressionRef<? extends RelationalExpression>, RefPath> network;\n+\n+    private ExpressionRefTraversal(@Nonnull final ExpressionRef<? extends RelationalExpression> rootRef,\n+                                   @Nonnull final Network<ExpressionRef<? extends RelationalExpression>, RefPath> network) {\n+        this.rootRef = rootRef;\n+        this.network = network;\n+    }\n+\n+    @Nonnull\n+    public FullyTraversableExpressionRef<? extends RelationalExpression> getRoot() {\n+        return new FullyTraversableExpressionRef<>(rootRef);\n+    }\n+\n+    @Nonnull\n+    public <T extends RelationalExpression> ExpressionRefDelegate<T> from(@Nonnull final ExpressionRef<T> regularRef) {\n+        return new ExpressionRefDelegate<>(regularRef);\n+    }\n+\n+    public List<FullyTraversableExpressionRef<? extends RelationalExpression>> getLeaves() {\n+        return ImmutableList.of();\n+    }\n+\n+    public static ExpressionRefTraversal withRoot(final ExpressionRef<? extends RelationalExpression> rootRef) {\n+        final MutableNetwork<ExpressionRef<? extends RelationalExpression>, RefPath> network =\n+                NetworkBuilder.directed()\n+                        .allowsParallelEdges(true)\n+                        .allowsSelfLoops(true)\n+                        .build();\n+\n+        return new ExpressionRefTraversal(rootRef, ImmutableNetwork.copyOf(collectNetwork(network, rootRef)));\n+    }\n+\n+    private static MutableNetwork<ExpressionRef<? extends RelationalExpression>, RefPath> collectNetwork(@Nonnull final MutableNetwork<ExpressionRef<? extends RelationalExpression>, RefPath> network,\n+                                                                                                         @Nonnull final ExpressionRef<? extends RelationalExpression> currentRef) {\n+        if (network.addNode(currentRef)) {\n+            for (final RelationalExpression expression : currentRef.getMembers()) {\n+                for (final Quantifier quantifier : expression.getQuantifiers()) {\n+                    final ExpressionRef<? extends RelationalExpression> rangesOverRef = quantifier.getRangesOver();\n+                    collectNetwork(network, rangesOverRef);\n+                    network.addEdge(rangesOverRef, currentRef, new RefPath(expression, quantifier));\n+                }\n+            }\n+        }\n+        return network;\n+    }\n+\n+    /**\n+     * BLA.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b64d4eb60de5c3a4be0b4dc0f779ff2f15e47355"}, "originalPosition": 92}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkwMTk3MzUwOnYy", "diffSide": "RIGHT", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/ExpressionRefTraversal.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wM1QyMDo1MTo1MlrOG7IVMQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNFQwMDoyMjoxM1rOG7M0kA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDY1NTY2NQ==", "bodyText": "?", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/988#discussion_r464655665", "createdAt": "2020-08-03T20:51:52Z", "author": {"login": "nschiefer"}, "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/ExpressionRefTraversal.java", "diffHunk": "@@ -0,0 +1,142 @@\n+/*\n+ * ExpressionRefTraversal.java\n+ *\n+ * This source file is part of the FoundationDB open source project\n+ *\n+ * Copyright 2015-2020 Apple Inc. and the FoundationDB project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.apple.foundationdb.record.query.plan.temp;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.graph.EndpointPair;\n+import com.google.common.graph.ImmutableNetwork;\n+import com.google.common.graph.MutableNetwork;\n+import com.google.common.graph.Network;\n+import com.google.common.graph.NetworkBuilder;\n+\n+import javax.annotation.Nonnull;\n+import java.util.List;\n+import java.util.Set;\n+\n+/**\n+ * TDB.\n+\n+ */\n+@SuppressWarnings(\"UnstableApiUsage\")\n+public class ExpressionRefTraversal {\n+\n+    @Nonnull\n+    private final ExpressionRef<? extends RelationalExpression> rootRef;\n+    @Nonnull\n+    private final Network<ExpressionRef<? extends RelationalExpression>, RefPath> network;\n+\n+    private ExpressionRefTraversal(@Nonnull final ExpressionRef<? extends RelationalExpression> rootRef,\n+                                   @Nonnull final Network<ExpressionRef<? extends RelationalExpression>, RefPath> network) {\n+        this.rootRef = rootRef;\n+        this.network = network;\n+    }\n+\n+    @Nonnull\n+    public FullyTraversableExpressionRef<? extends RelationalExpression> getRoot() {\n+        return new FullyTraversableExpressionRef<>(rootRef);\n+    }\n+\n+    @Nonnull\n+    public <T extends RelationalExpression> ExpressionRefDelegate<T> from(@Nonnull final ExpressionRef<T> regularRef) {\n+        return new ExpressionRefDelegate<>(regularRef);\n+    }\n+\n+    public List<FullyTraversableExpressionRef<? extends RelationalExpression>> getLeaves() {\n+        return ImmutableList.of();\n+    }\n+\n+    public static ExpressionRefTraversal withRoot(final ExpressionRef<? extends RelationalExpression> rootRef) {\n+        final MutableNetwork<ExpressionRef<? extends RelationalExpression>, RefPath> network =\n+                NetworkBuilder.directed()\n+                        .allowsParallelEdges(true)\n+                        .allowsSelfLoops(true)\n+                        .build();\n+\n+        return new ExpressionRefTraversal(rootRef, ImmutableNetwork.copyOf(collectNetwork(network, rootRef)));\n+    }\n+\n+    private static MutableNetwork<ExpressionRef<? extends RelationalExpression>, RefPath> collectNetwork(@Nonnull final MutableNetwork<ExpressionRef<? extends RelationalExpression>, RefPath> network,\n+                                                                                                         @Nonnull final ExpressionRef<? extends RelationalExpression> currentRef) {\n+        if (network.addNode(currentRef)) {\n+            for (final RelationalExpression expression : currentRef.getMembers()) {\n+                for (final Quantifier quantifier : expression.getQuantifiers()) {\n+                    final ExpressionRef<? extends RelationalExpression> rangesOverRef = quantifier.getRangesOver();\n+                    collectNetwork(network, rangesOverRef);\n+                    network.addEdge(rangesOverRef, currentRef, new RefPath(expression, quantifier));\n+                }\n+            }\n+        }\n+        return network;\n+    }\n+\n+    /**\n+     * BLA.\n+     */\n+    public static class RefPath {\n+        @Nonnull\n+        private final RelationalExpression expression;\n+        @Nonnull\n+        private final Quantifier quantifier;\n+\n+        public RefPath(@Nonnull final RelationalExpression expression, @Nonnull final Quantifier quantifier) {\n+            this.expression = expression;\n+            this.quantifier = quantifier;\n+        }\n+\n+        @Nonnull\n+        public RelationalExpression getExpression() {\n+            return expression;\n+        }\n+\n+        @Nonnull\n+        public Quantifier getQuantifier() {\n+            return quantifier;\n+        }\n+    }\n+\n+    /**\n+     * BLA.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b64d4eb60de5c3a4be0b4dc0f779ff2f15e47355"}, "originalPosition": 117}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDcyOTIzMg==", "bodyText": "the alter ego of TBD and YADDA. Fixed. Sorry!", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/988#discussion_r464729232", "createdAt": "2020-08-04T00:22:13Z", "author": {"login": "normen662"}, "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/ExpressionRefTraversal.java", "diffHunk": "@@ -0,0 +1,142 @@\n+/*\n+ * ExpressionRefTraversal.java\n+ *\n+ * This source file is part of the FoundationDB open source project\n+ *\n+ * Copyright 2015-2020 Apple Inc. and the FoundationDB project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.apple.foundationdb.record.query.plan.temp;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.graph.EndpointPair;\n+import com.google.common.graph.ImmutableNetwork;\n+import com.google.common.graph.MutableNetwork;\n+import com.google.common.graph.Network;\n+import com.google.common.graph.NetworkBuilder;\n+\n+import javax.annotation.Nonnull;\n+import java.util.List;\n+import java.util.Set;\n+\n+/**\n+ * TDB.\n+\n+ */\n+@SuppressWarnings(\"UnstableApiUsage\")\n+public class ExpressionRefTraversal {\n+\n+    @Nonnull\n+    private final ExpressionRef<? extends RelationalExpression> rootRef;\n+    @Nonnull\n+    private final Network<ExpressionRef<? extends RelationalExpression>, RefPath> network;\n+\n+    private ExpressionRefTraversal(@Nonnull final ExpressionRef<? extends RelationalExpression> rootRef,\n+                                   @Nonnull final Network<ExpressionRef<? extends RelationalExpression>, RefPath> network) {\n+        this.rootRef = rootRef;\n+        this.network = network;\n+    }\n+\n+    @Nonnull\n+    public FullyTraversableExpressionRef<? extends RelationalExpression> getRoot() {\n+        return new FullyTraversableExpressionRef<>(rootRef);\n+    }\n+\n+    @Nonnull\n+    public <T extends RelationalExpression> ExpressionRefDelegate<T> from(@Nonnull final ExpressionRef<T> regularRef) {\n+        return new ExpressionRefDelegate<>(regularRef);\n+    }\n+\n+    public List<FullyTraversableExpressionRef<? extends RelationalExpression>> getLeaves() {\n+        return ImmutableList.of();\n+    }\n+\n+    public static ExpressionRefTraversal withRoot(final ExpressionRef<? extends RelationalExpression> rootRef) {\n+        final MutableNetwork<ExpressionRef<? extends RelationalExpression>, RefPath> network =\n+                NetworkBuilder.directed()\n+                        .allowsParallelEdges(true)\n+                        .allowsSelfLoops(true)\n+                        .build();\n+\n+        return new ExpressionRefTraversal(rootRef, ImmutableNetwork.copyOf(collectNetwork(network, rootRef)));\n+    }\n+\n+    private static MutableNetwork<ExpressionRef<? extends RelationalExpression>, RefPath> collectNetwork(@Nonnull final MutableNetwork<ExpressionRef<? extends RelationalExpression>, RefPath> network,\n+                                                                                                         @Nonnull final ExpressionRef<? extends RelationalExpression> currentRef) {\n+        if (network.addNode(currentRef)) {\n+            for (final RelationalExpression expression : currentRef.getMembers()) {\n+                for (final Quantifier quantifier : expression.getQuantifiers()) {\n+                    final ExpressionRef<? extends RelationalExpression> rangesOverRef = quantifier.getRangesOver();\n+                    collectNetwork(network, rangesOverRef);\n+                    network.addEdge(rangesOverRef, currentRef, new RefPath(expression, quantifier));\n+                }\n+            }\n+        }\n+        return network;\n+    }\n+\n+    /**\n+     * BLA.\n+     */\n+    public static class RefPath {\n+        @Nonnull\n+        private final RelationalExpression expression;\n+        @Nonnull\n+        private final Quantifier quantifier;\n+\n+        public RefPath(@Nonnull final RelationalExpression expression, @Nonnull final Quantifier quantifier) {\n+            this.expression = expression;\n+            this.quantifier = quantifier;\n+        }\n+\n+        @Nonnull\n+        public RelationalExpression getExpression() {\n+            return expression;\n+        }\n+\n+        @Nonnull\n+        public Quantifier getQuantifier() {\n+            return quantifier;\n+        }\n+    }\n+\n+    /**\n+     * BLA.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDY1NTY2NQ=="}, "originalCommit": {"oid": "b64d4eb60de5c3a4be0b4dc0f779ff2f15e47355"}, "originalPosition": 117}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkwMTk3NDk0OnYy", "diffSide": "RIGHT", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/ExpressionRefDelegate.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wM1QyMDo1MjoyNFrOG7IWHw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wM1QyMDo1MjoyNFrOG7IWHw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDY1NTkwMw==", "bodyText": "Let's fill this in.", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/988#discussion_r464655903", "createdAt": "2020-08-03T20:52:24Z", "author": {"login": "nschiefer"}, "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/ExpressionRefDelegate.java", "diffHunk": "@@ -0,0 +1,115 @@\n+/*\n+ * ExpressionRefDelegate.java\n+ *\n+ * This source file is part of the FoundationDB open source project\n+ *\n+ * Copyright 2015-2020 Apple Inc. and the FoundationDB project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.apple.foundationdb.record.query.plan.temp;\n+\n+import com.apple.foundationdb.record.query.plan.temp.matchers.ExpressionMatcher;\n+import com.apple.foundationdb.record.query.plan.temp.matchers.PlannerBindings;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+import java.util.Set;\n+import java.util.function.Function;\n+import java.util.stream.Stream;\n+\n+/**\n+ * TBD.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b64d4eb60de5c3a4be0b4dc0f779ff2f15e47355"}, "originalPosition": 33}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkwMTk4Mjg5OnYy", "diffSide": "RIGHT", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/ExpressionRefDelegate.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wM1QyMDo1NToxOFrOG7Ia6A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wM1QyMDo1NToxOFrOG7Ia6A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDY1NzEyOA==", "bodyText": "This needs an EXPERIMENTAL API annotation.", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/988#discussion_r464657128", "createdAt": "2020-08-03T20:55:18Z", "author": {"login": "nschiefer"}, "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/ExpressionRefDelegate.java", "diffHunk": "@@ -0,0 +1,115 @@\n+/*\n+ * ExpressionRefDelegate.java\n+ *\n+ * This source file is part of the FoundationDB open source project\n+ *\n+ * Copyright 2015-2020 Apple Inc. and the FoundationDB project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.apple.foundationdb.record.query.plan.temp;\n+\n+import com.apple.foundationdb.record.query.plan.temp.matchers.ExpressionMatcher;\n+import com.apple.foundationdb.record.query.plan.temp.matchers.PlannerBindings;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+import java.util.Set;\n+import java.util.function.Function;\n+import java.util.stream.Stream;\n+\n+/**\n+ * TBD.\n+ * @param <T> the type\n+ */\n+public class ExpressionRefDelegate<T extends RelationalExpression> implements ExpressionRef<T> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b64d4eb60de5c3a4be0b4dc0f779ff2f15e47355"}, "originalPosition": 36}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkwMTk4NDEwOnYy", "diffSide": "RIGHT", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/ExpressionRefTraversal.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wM1QyMDo1NTozNVrOG7Iblw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wM1QyMDo1NTozNVrOG7Iblw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDY1NzMwMw==", "bodyText": "This also needs and EXPERIMENTAL annotation.", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/988#discussion_r464657303", "createdAt": "2020-08-03T20:55:35Z", "author": {"login": "nschiefer"}, "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/ExpressionRefTraversal.java", "diffHunk": "@@ -0,0 +1,142 @@\n+/*\n+ * ExpressionRefTraversal.java\n+ *\n+ * This source file is part of the FoundationDB open source project\n+ *\n+ * Copyright 2015-2020 Apple Inc. and the FoundationDB project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.apple.foundationdb.record.query.plan.temp;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.graph.EndpointPair;\n+import com.google.common.graph.ImmutableNetwork;\n+import com.google.common.graph.MutableNetwork;\n+import com.google.common.graph.Network;\n+import com.google.common.graph.NetworkBuilder;\n+\n+import javax.annotation.Nonnull;\n+import java.util.List;\n+import java.util.Set;\n+\n+/**\n+ * TDB.\n+\n+ */", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b64d4eb60de5c3a4be0b4dc0f779ff2f15e47355"}, "originalPosition": 38}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkwMTk5Nzk0OnYy", "diffSide": "RIGHT", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/Quantifier.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wM1QyMTowMDoxNlrOG7IkMQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wM1QyMTowMDoxNlrOG7IkMQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDY1OTUwNQ==", "bodyText": "Needs an EXPERIMENTAL API annotation.", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/988#discussion_r464659505", "createdAt": "2020-08-03T21:00:16Z", "author": {"login": "nschiefer"}, "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/Quantifier.java", "diffHunk": "@@ -54,16 +57,69 @@\n  * at the owning (join) expression.\n  * </p>\n  */\n-public abstract class Quantifier implements Bindable {\n+@SuppressWarnings(\"unused\")\n+public abstract class Quantifier implements Bindable, Correlated<Quantifier> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b64d4eb60de5c3a4be0b4dc0f779ff2f15e47355"}, "originalPosition": 25}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkwOTcxNjI5OnYy", "diffSide": "RIGHT", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/plans/RecordQueryCoveringIndexPlan.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNVQxNjo0MToxM1rOG8R2Eg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNVQxNjo0MToxM1rOG8R2Eg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTg2MDExNA==", "bodyText": "should be structuralEquals()", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/988#discussion_r465860114", "createdAt": "2020-08-05T16:41:13Z", "author": {"login": "normen662"}, "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/plans/RecordQueryCoveringIndexPlan.java", "diffHunk": "@@ -135,56 +137,66 @@ public boolean hasLoadBykeys() {\n     @Nonnull\n     @Override\n     public String toString() {\n-        return \"Covering(\" + getChild() + \" -> \" + toRecord + \")\";\n+        return \"Covering(\" + indexPlan + \" -> \" + toRecord + \")\";\n+    }\n+\n+    @Nonnull\n+    @Override\n+    @API(API.Status.EXPERIMENTAL)\n+    public Set<CorrelationIdentifier> getCorrelatedTo() {\n+        return ImmutableSet.of();\n+    }\n+\n+    @Nonnull\n+    @Override\n+    @API(API.Status.EXPERIMENTAL)\n+    public RecordQueryCoveringIndexPlan rebase(@Nonnull final AliasMap translationMap) {\n+        return new RecordQueryCoveringIndexPlan(indexPlan, recordTypeName, toRecord);\n     }\n \n     @Override\n     @API(API.Status.EXPERIMENTAL)\n-    public boolean equalsWithoutChildren(@Nonnull RelationalExpression otherExpression) {\n-        if (!(otherExpression instanceof RecordQueryCoveringIndexPlan)) {\n+    public boolean equalsWithoutChildren(@Nonnull RelationalExpression otherExpression,\n+                                         @Nonnull final AliasMap equivalencesMap) {\n+        if (!RecordQueryPlanWithNoChildren.super.equalsWithoutChildren(otherExpression, equivalencesMap)) {\n             return false;\n         }\n+\n         final RecordQueryCoveringIndexPlan other = (RecordQueryCoveringIndexPlan) otherExpression;\n-        return recordTypeName.equals(other.recordTypeName) && toRecord.equals(other.toRecord);\n+        return indexPlan.semanticEquals(other.indexPlan, equivalencesMap) &&", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1c6f5d91e302d610963a6f9a05e530cff79457f9"}, "originalPosition": 109}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkwOTc3ODcyOnYy", "diffSide": "RIGHT", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/plans/RecordQueryTypeFilterPlan.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNVQxNjo1NzoyN1rOG8Sdbg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNVQyMDo0NzoyOFrOG8aCIw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTg3MDE5MA==", "bodyText": "Where did equalsWithoutChildren go?", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/988#discussion_r465870190", "createdAt": "2020-08-05T16:57:27Z", "author": {"login": "normen662"}, "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/plans/RecordQueryTypeFilterPlan.java", "diffHunk": "@@ -113,29 +113,30 @@ public String toString() {\n         return getInner() + \" | \" + recordTypes;\n     }\n \n+    @Nonnull\n     @Override\n     @API(API.Status.EXPERIMENTAL)\n-    public boolean equalsWithoutChildren(@Nonnull RelationalExpression otherExpression) {\n-        return otherExpression instanceof RecordQueryTypeFilterPlan &&\n-               recordTypes.equals(((RecordQueryTypeFilterPlan)otherExpression).recordTypes);\n+    public RecordQueryTypeFilterPlan rebaseWithRebasedQuantifiers(@Nonnull final AliasMap translationMap,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1c6f5d91e302d610963a6f9a05e530cff79457f9"}, "originalPosition": 61}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTkzMjUzMg==", "bodyText": "Alright this is done in the super class now as the record types are exposed through an abstract getter.", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/988#discussion_r465932532", "createdAt": "2020-08-05T18:49:00Z", "author": {"login": "normen662"}, "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/plans/RecordQueryTypeFilterPlan.java", "diffHunk": "@@ -113,29 +113,30 @@ public String toString() {\n         return getInner() + \" | \" + recordTypes;\n     }\n \n+    @Nonnull\n     @Override\n     @API(API.Status.EXPERIMENTAL)\n-    public boolean equalsWithoutChildren(@Nonnull RelationalExpression otherExpression) {\n-        return otherExpression instanceof RecordQueryTypeFilterPlan &&\n-               recordTypes.equals(((RecordQueryTypeFilterPlan)otherExpression).recordTypes);\n+    public RecordQueryTypeFilterPlan rebaseWithRebasedQuantifiers(@Nonnull final AliasMap translationMap,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTg3MDE5MA=="}, "originalCommit": {"oid": "1c6f5d91e302d610963a6f9a05e530cff79457f9"}, "originalPosition": 61}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTk5NDI3NQ==", "bodyText": "This might illustrate my concern about having equalsWithoutChildren() as a default method rather than something that you just have to add as boilerplate in every implementation.", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/988#discussion_r465994275", "createdAt": "2020-08-05T20:47:28Z", "author": {"login": "nschiefer"}, "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/plans/RecordQueryTypeFilterPlan.java", "diffHunk": "@@ -113,29 +113,30 @@ public String toString() {\n         return getInner() + \" | \" + recordTypes;\n     }\n \n+    @Nonnull\n     @Override\n     @API(API.Status.EXPERIMENTAL)\n-    public boolean equalsWithoutChildren(@Nonnull RelationalExpression otherExpression) {\n-        return otherExpression instanceof RecordQueryTypeFilterPlan &&\n-               recordTypes.equals(((RecordQueryTypeFilterPlan)otherExpression).recordTypes);\n+    public RecordQueryTypeFilterPlan rebaseWithRebasedQuantifiers(@Nonnull final AliasMap translationMap,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTg3MDE5MA=="}, "originalCommit": {"oid": "1c6f5d91e302d610963a6f9a05e530cff79457f9"}, "originalPosition": 61}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkxMDE1MzA3OnYy", "diffSide": "RIGHT", "path": "docs/ReleaseNotes.md", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNVQxODo0NjowN1rOG8WK4A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNVQxODo0NjowN1rOG8WK4A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTkzMDk3Ng==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            * **Breaking change** RecordQueryCoveringIndexPlan does not implement RecordQueryPlanWithChild anymore [(Issue #987)](https://github.com/FoundationDB/fdb-record-layer/issues/987)\n          \n          \n            \n            * **Breaking change** `RecordQueryCoveringIndexPlan` no longer implements `RecordQueryPlanWithChild` [(Issue #987)](https://github.com/FoundationDB/fdb-record-layer/issues/987)", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/988#discussion_r465930976", "createdAt": "2020-08-05T18:46:07Z", "author": {"login": "nschiefer"}, "path": "docs/ReleaseNotes.md", "diffHunk": "@@ -35,9 +35,9 @@ Additionally, builds for the project now require JDK 11. The project is still ta\n * **Feature** Feature 3 [(Issue #NNN)](https://github.com/FoundationDB/fdb-record-layer/issues/NNN)\n * **Feature** Feature 4 [(Issue #NNN)](https://github.com/FoundationDB/fdb-record-layer/issues/NNN)\n * **Feature** Feature 5 [(Issue #NNN)](https://github.com/FoundationDB/fdb-record-layer/issues/NNN)\n-* **Breaking change** Change 1 [(Issue #NNN)](https://github.com/FoundationDB/fdb-record-layer/issues/NNN)\n-* **Breaking change** Change 2 [(Issue #NNN)](https://github.com/FoundationDB/fdb-record-layer/issues/NNN)\n-* **Breaking change** Change 3 [(Issue #NNN)](https://github.com/FoundationDB/fdb-record-layer/issues/NNN)\n+* **Breaking change** RecordQueryCoveringIndexPlan does not implement RecordQueryPlanWithChild anymore [(Issue #987)](https://github.com/FoundationDB/fdb-record-layer/issues/987)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1c6f5d91e302d610963a6f9a05e530cff79457f9"}, "originalPosition": 7}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkxMDQ2Mjc5OnYy", "diffSide": "RIGHT", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/Correlated.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNVQyMDoyMDo0OVrOG8ZNNw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNVQyMDoyMDo0OVrOG8ZNNw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTk4MDcyNw==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * semantic equality which is usually defined as equality of the result of evaluating the plan fragment\n          \n          \n            \n                 * implementing this interface under the given bound correlations.\n          \n          \n            \n                 * semantic equality: equality of the plan fragments implementing under the given correlation bindings.", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/988#discussion_r465980727", "createdAt": "2020-08-05T20:20:49Z", "author": {"login": "nschiefer"}, "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/Correlated.java", "diffHunk": "@@ -0,0 +1,172 @@\n+/*\n+ * Correlated.java\n+ *\n+ * This source file is part of the FoundationDB open source project\n+ *\n+ * Copyright 2015-2020 Apple Inc. and the FoundationDB project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.apple.foundationdb.record.query.plan.temp;\n+\n+import com.apple.foundationdb.annotation.API;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+import java.util.Set;\n+\n+/**\n+ * A <em>correlated</em> entity is one which can only be evaluated as a function of some input (usually a {@link Quantifier}\n+ * from its relational parent).\n+ * Since a correlated entity can have multiple correlations to similar quantifiers, a correlation is disambiguated by a\n+ * {@link CorrelationIdentifier}. Correlated entities are said to be correlated to a quantifier {@code q} if the identifiers\n+ * returned by {@link #getCorrelatedTo()} set contain\n+ * the correlation identifier that {@code q} uses.\n+ *\n+ * Distinguishing the correlation identifier from the identity of the quantifier object simplifies modifications of the\n+ * graph, for example while applying transformations during query planning.\n+\n+ * An correlated object can be <em>rebased</em> using {@link #rebase} and a map of translations from one\n+ * correlation identifier to another, resulting in a new object of type {@code S} that is\n+ * identical to {@code this} except that all correlated references in the subtree rooted at this entity\n+ * (i.e., this object's relational children, predicates, etc.) are replaced with their corresponding identifiers\n+ * per the map.\n+ *\n+ * Since translations are associative we allow to rebase many identifiers in the same {@link #rebase} invocation.\n+ *\n+ * As the planner DAG objects are immutable, a rebase operation can be expensive as objects have to be recreated\n+ * as needed. We follow the ideas of other persistent data structures as we do not require a copy to be made.\n+ * It is perfectly acceptable to return {@code this} if {@code this} is not correlated to any identifier participating\n+ * in the translation.\n+ *\n+ * This interface defines a {@link #semanticEquals} method that also takes an equivalence map, and determines equality up\n+ * to the equivalences defined therein. Two correlated entities are equivalent even if they use different names, as long\n+ * as un-bound correlations can be aligned. For example, in:\n+ *\n+ * <pre>\n+ * {@code\n+ * SELECT *\n+ * FROM T1 a, T2 b\n+ * WHERE a.x = b.y\n+ * UNION (SELECT *\n+ *        FROM T1 c, T2 d\n+ *        WHERE c.x = d.y)\n+ * }\n+ * </pre>\n+ *\n+ * The two SELECT blocks should be considered equal even though they use different correlation names. The\n+ * {@link #semanticEquals} introduced here considers these blocks equal using a bi-map that allows for the definition\n+ * of equivalences among correlation identifiers. In this case\n+ *\n+ * <pre>\n+ * {@code\n+ * (SELECT * FROM T1 a, T2 b WHERE a.x = b.y).equals(SELECT * FROM T1 c, T2 d WHERE c.x = d.y, ImmutableBiMap.of())\n+ * }\n+ * </pre>\n+ *\n+ * result (through a series of other steps) in an invocation of\n+ *\n+ * <pre>\n+ * {@code\n+ * (WHERE a.x = b.y).equals(WHERE c.x = d.y, ImmutableBiMap.of(a -> b, c -> d))\n+ * }\n+ * </pre>\n+ *\n+ * which then results in a {@code true} as {@code a} is considered to be equal to {@code c} and {@code b} is considered\n+ * to be equal to {@code d}.\n+ *\n+ * @param <S> self type of this. Needed for rebasing to a proper constrained at-least type\n+ */\n+@API(API.Status.EXPERIMENTAL)\n+public interface Correlated<S extends Correlated<S>> {\n+    /**\n+     * Returns the set of {@link CorrelationIdentifier}s this entity is correlated to.\n+     * This means that without a process that binds these correlations to values, the {@link RelationalExpression}\n+     * (or others that implement this interface) cannot even in principle produce a meaningful result. As often times\n+     * entities that implement this interface use composition and effectively describe trees or DAGs, this method should\n+     * be the set union of the {@link CorrelationIdentifier}s this object is correlated to as well as all children,\n+     * constituent parts, etc.\n+     * @return the set of {@link CorrelationIdentifier}s this entity is correlated to\n+     */\n+    @Nonnull\n+    Set<CorrelationIdentifier> getCorrelatedTo();\n+\n+    /**\n+     * Rebases this and all other objects this objects is composed of using a given translation map.\n+     * @param translationMap a map defining a translation from {@link CorrelationIdentifier}s {@code ids} to\n+     *        {@link CorrelationIdentifier}s {@code ids'}. After the rebase, every correlation to an {@code id}\n+     *        contained {@code ids} that is contained or referred to directly or indirectly by {@code this} must have\n+     *        been transformed to use the mapped counterpart of {@code id} {@code id'} in {@code ids'}. IDs not\n+     *        contained in the translation map must remain unmodified by the rebase operation.\n+     * @return a new entity that has been rebased\n+     */\n+    @Nonnull\n+    S rebase(@Nonnull AliasMap translationMap);\n+\n+    /**\n+     * Determine equality with respect to an equivalence map between {@link CorrelationIdentifier}s based on\n+     * semantic equality which is usually defined as equality of the result of evaluating the plan fragment\n+     * implementing this interface under the given bound correlations.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1c6f5d91e302d610963a6f9a05e530cff79457f9"}, "originalPosition": 120}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkxMDQ2MzYzOnYy", "diffSide": "RIGHT", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/Correlated.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNVQyMDoyMTowN1rOG8ZNyw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNVQyMDoyMTowN1rOG8ZNyw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTk4MDg3NQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * (correlated) structure, e.g. a filter. For instance {@code q1.x = 5} uses a correlation to {@code q1}.\n          \n          \n            \n                 * (correlated) structure such as a filter. For instance {@code q1.x = 5} uses a correlation to {@code q1}.", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/988#discussion_r465980875", "createdAt": "2020-08-05T20:21:07Z", "author": {"login": "nschiefer"}, "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/Correlated.java", "diffHunk": "@@ -0,0 +1,172 @@\n+/*\n+ * Correlated.java\n+ *\n+ * This source file is part of the FoundationDB open source project\n+ *\n+ * Copyright 2015-2020 Apple Inc. and the FoundationDB project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.apple.foundationdb.record.query.plan.temp;\n+\n+import com.apple.foundationdb.annotation.API;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+import java.util.Set;\n+\n+/**\n+ * A <em>correlated</em> entity is one which can only be evaluated as a function of some input (usually a {@link Quantifier}\n+ * from its relational parent).\n+ * Since a correlated entity can have multiple correlations to similar quantifiers, a correlation is disambiguated by a\n+ * {@link CorrelationIdentifier}. Correlated entities are said to be correlated to a quantifier {@code q} if the identifiers\n+ * returned by {@link #getCorrelatedTo()} set contain\n+ * the correlation identifier that {@code q} uses.\n+ *\n+ * Distinguishing the correlation identifier from the identity of the quantifier object simplifies modifications of the\n+ * graph, for example while applying transformations during query planning.\n+\n+ * An correlated object can be <em>rebased</em> using {@link #rebase} and a map of translations from one\n+ * correlation identifier to another, resulting in a new object of type {@code S} that is\n+ * identical to {@code this} except that all correlated references in the subtree rooted at this entity\n+ * (i.e., this object's relational children, predicates, etc.) are replaced with their corresponding identifiers\n+ * per the map.\n+ *\n+ * Since translations are associative we allow to rebase many identifiers in the same {@link #rebase} invocation.\n+ *\n+ * As the planner DAG objects are immutable, a rebase operation can be expensive as objects have to be recreated\n+ * as needed. We follow the ideas of other persistent data structures as we do not require a copy to be made.\n+ * It is perfectly acceptable to return {@code this} if {@code this} is not correlated to any identifier participating\n+ * in the translation.\n+ *\n+ * This interface defines a {@link #semanticEquals} method that also takes an equivalence map, and determines equality up\n+ * to the equivalences defined therein. Two correlated entities are equivalent even if they use different names, as long\n+ * as un-bound correlations can be aligned. For example, in:\n+ *\n+ * <pre>\n+ * {@code\n+ * SELECT *\n+ * FROM T1 a, T2 b\n+ * WHERE a.x = b.y\n+ * UNION (SELECT *\n+ *        FROM T1 c, T2 d\n+ *        WHERE c.x = d.y)\n+ * }\n+ * </pre>\n+ *\n+ * The two SELECT blocks should be considered equal even though they use different correlation names. The\n+ * {@link #semanticEquals} introduced here considers these blocks equal using a bi-map that allows for the definition\n+ * of equivalences among correlation identifiers. In this case\n+ *\n+ * <pre>\n+ * {@code\n+ * (SELECT * FROM T1 a, T2 b WHERE a.x = b.y).equals(SELECT * FROM T1 c, T2 d WHERE c.x = d.y, ImmutableBiMap.of())\n+ * }\n+ * </pre>\n+ *\n+ * result (through a series of other steps) in an invocation of\n+ *\n+ * <pre>\n+ * {@code\n+ * (WHERE a.x = b.y).equals(WHERE c.x = d.y, ImmutableBiMap.of(a -> b, c -> d))\n+ * }\n+ * </pre>\n+ *\n+ * which then results in a {@code true} as {@code a} is considered to be equal to {@code c} and {@code b} is considered\n+ * to be equal to {@code d}.\n+ *\n+ * @param <S> self type of this. Needed for rebasing to a proper constrained at-least type\n+ */\n+@API(API.Status.EXPERIMENTAL)\n+public interface Correlated<S extends Correlated<S>> {\n+    /**\n+     * Returns the set of {@link CorrelationIdentifier}s this entity is correlated to.\n+     * This means that without a process that binds these correlations to values, the {@link RelationalExpression}\n+     * (or others that implement this interface) cannot even in principle produce a meaningful result. As often times\n+     * entities that implement this interface use composition and effectively describe trees or DAGs, this method should\n+     * be the set union of the {@link CorrelationIdentifier}s this object is correlated to as well as all children,\n+     * constituent parts, etc.\n+     * @return the set of {@link CorrelationIdentifier}s this entity is correlated to\n+     */\n+    @Nonnull\n+    Set<CorrelationIdentifier> getCorrelatedTo();\n+\n+    /**\n+     * Rebases this and all other objects this objects is composed of using a given translation map.\n+     * @param translationMap a map defining a translation from {@link CorrelationIdentifier}s {@code ids} to\n+     *        {@link CorrelationIdentifier}s {@code ids'}. After the rebase, every correlation to an {@code id}\n+     *        contained {@code ids} that is contained or referred to directly or indirectly by {@code this} must have\n+     *        been transformed to use the mapped counterpart of {@code id} {@code id'} in {@code ids'}. IDs not\n+     *        contained in the translation map must remain unmodified by the rebase operation.\n+     * @return a new entity that has been rebased\n+     */\n+    @Nonnull\n+    S rebase(@Nonnull AliasMap translationMap);\n+\n+    /**\n+     * Determine equality with respect to an equivalence map between {@link CorrelationIdentifier}s based on\n+     * semantic equality which is usually defined as equality of the result of evaluating the plan fragment\n+     * implementing this interface under the given bound correlations.\n+     * The contract of this variant of {@code equals()} differs from its regular Java counterpart.\n+     * A correlation is mostly just one part inside of composition of objects that expresses a more complicated\n+     * (correlated) structure, e.g. a filter. For instance {@code q1.x = 5} uses a correlation to {@code q1}.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1c6f5d91e302d610963a6f9a05e530cff79457f9"}, "originalPosition": 123}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkxMDQ2NDg0OnYy", "diffSide": "RIGHT", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/Correlated.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNVQyMDoyMTozNFrOG8ZOmw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNVQyMDoyMTozNFrOG8ZOmw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTk4MTA4Mw==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * That entity representing the filter is correlated to {@code q1} for obvious reasons. Also obvious is that\n          \n          \n            \n                 * That entity representing the filter is said to be correlated to {@code q1}. Similarly,", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/988#discussion_r465981083", "createdAt": "2020-08-05T20:21:34Z", "author": {"login": "nschiefer"}, "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/Correlated.java", "diffHunk": "@@ -0,0 +1,172 @@\n+/*\n+ * Correlated.java\n+ *\n+ * This source file is part of the FoundationDB open source project\n+ *\n+ * Copyright 2015-2020 Apple Inc. and the FoundationDB project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.apple.foundationdb.record.query.plan.temp;\n+\n+import com.apple.foundationdb.annotation.API;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+import java.util.Set;\n+\n+/**\n+ * A <em>correlated</em> entity is one which can only be evaluated as a function of some input (usually a {@link Quantifier}\n+ * from its relational parent).\n+ * Since a correlated entity can have multiple correlations to similar quantifiers, a correlation is disambiguated by a\n+ * {@link CorrelationIdentifier}. Correlated entities are said to be correlated to a quantifier {@code q} if the identifiers\n+ * returned by {@link #getCorrelatedTo()} set contain\n+ * the correlation identifier that {@code q} uses.\n+ *\n+ * Distinguishing the correlation identifier from the identity of the quantifier object simplifies modifications of the\n+ * graph, for example while applying transformations during query planning.\n+\n+ * An correlated object can be <em>rebased</em> using {@link #rebase} and a map of translations from one\n+ * correlation identifier to another, resulting in a new object of type {@code S} that is\n+ * identical to {@code this} except that all correlated references in the subtree rooted at this entity\n+ * (i.e., this object's relational children, predicates, etc.) are replaced with their corresponding identifiers\n+ * per the map.\n+ *\n+ * Since translations are associative we allow to rebase many identifiers in the same {@link #rebase} invocation.\n+ *\n+ * As the planner DAG objects are immutable, a rebase operation can be expensive as objects have to be recreated\n+ * as needed. We follow the ideas of other persistent data structures as we do not require a copy to be made.\n+ * It is perfectly acceptable to return {@code this} if {@code this} is not correlated to any identifier participating\n+ * in the translation.\n+ *\n+ * This interface defines a {@link #semanticEquals} method that also takes an equivalence map, and determines equality up\n+ * to the equivalences defined therein. Two correlated entities are equivalent even if they use different names, as long\n+ * as un-bound correlations can be aligned. For example, in:\n+ *\n+ * <pre>\n+ * {@code\n+ * SELECT *\n+ * FROM T1 a, T2 b\n+ * WHERE a.x = b.y\n+ * UNION (SELECT *\n+ *        FROM T1 c, T2 d\n+ *        WHERE c.x = d.y)\n+ * }\n+ * </pre>\n+ *\n+ * The two SELECT blocks should be considered equal even though they use different correlation names. The\n+ * {@link #semanticEquals} introduced here considers these blocks equal using a bi-map that allows for the definition\n+ * of equivalences among correlation identifiers. In this case\n+ *\n+ * <pre>\n+ * {@code\n+ * (SELECT * FROM T1 a, T2 b WHERE a.x = b.y).equals(SELECT * FROM T1 c, T2 d WHERE c.x = d.y, ImmutableBiMap.of())\n+ * }\n+ * </pre>\n+ *\n+ * result (through a series of other steps) in an invocation of\n+ *\n+ * <pre>\n+ * {@code\n+ * (WHERE a.x = b.y).equals(WHERE c.x = d.y, ImmutableBiMap.of(a -> b, c -> d))\n+ * }\n+ * </pre>\n+ *\n+ * which then results in a {@code true} as {@code a} is considered to be equal to {@code c} and {@code b} is considered\n+ * to be equal to {@code d}.\n+ *\n+ * @param <S> self type of this. Needed for rebasing to a proper constrained at-least type\n+ */\n+@API(API.Status.EXPERIMENTAL)\n+public interface Correlated<S extends Correlated<S>> {\n+    /**\n+     * Returns the set of {@link CorrelationIdentifier}s this entity is correlated to.\n+     * This means that without a process that binds these correlations to values, the {@link RelationalExpression}\n+     * (or others that implement this interface) cannot even in principle produce a meaningful result. As often times\n+     * entities that implement this interface use composition and effectively describe trees or DAGs, this method should\n+     * be the set union of the {@link CorrelationIdentifier}s this object is correlated to as well as all children,\n+     * constituent parts, etc.\n+     * @return the set of {@link CorrelationIdentifier}s this entity is correlated to\n+     */\n+    @Nonnull\n+    Set<CorrelationIdentifier> getCorrelatedTo();\n+\n+    /**\n+     * Rebases this and all other objects this objects is composed of using a given translation map.\n+     * @param translationMap a map defining a translation from {@link CorrelationIdentifier}s {@code ids} to\n+     *        {@link CorrelationIdentifier}s {@code ids'}. After the rebase, every correlation to an {@code id}\n+     *        contained {@code ids} that is contained or referred to directly or indirectly by {@code this} must have\n+     *        been transformed to use the mapped counterpart of {@code id} {@code id'} in {@code ids'}. IDs not\n+     *        contained in the translation map must remain unmodified by the rebase operation.\n+     * @return a new entity that has been rebased\n+     */\n+    @Nonnull\n+    S rebase(@Nonnull AliasMap translationMap);\n+\n+    /**\n+     * Determine equality with respect to an equivalence map between {@link CorrelationIdentifier}s based on\n+     * semantic equality which is usually defined as equality of the result of evaluating the plan fragment\n+     * implementing this interface under the given bound correlations.\n+     * The contract of this variant of {@code equals()} differs from its regular Java counterpart.\n+     * A correlation is mostly just one part inside of composition of objects that expresses a more complicated\n+     * (correlated) structure, e.g. a filter. For instance {@code q1.x = 5} uses a correlation to {@code q1}.\n+     * That entity representing the filter is correlated to {@code q1} for obvious reasons. Also obvious is that", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1c6f5d91e302d610963a6f9a05e530cff79457f9"}, "originalPosition": 124}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkxMDQ2NjI0OnYy", "diffSide": "RIGHT", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/Correlated.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNVQyMDoyMTo1N1rOG8ZPfA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNVQyMDoyMTo1N1rOG8ZPfA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTk4MTMwOA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * {@code q1.x = 6} is a different filter and should not be considered equal at all. The same is true if we\n          \n          \n            \n                 * {@code q1.x = 6} is a different filter and is not equal under any correlation mapping.", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/988#discussion_r465981308", "createdAt": "2020-08-05T20:21:57Z", "author": {"login": "nschiefer"}, "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/Correlated.java", "diffHunk": "@@ -0,0 +1,172 @@\n+/*\n+ * Correlated.java\n+ *\n+ * This source file is part of the FoundationDB open source project\n+ *\n+ * Copyright 2015-2020 Apple Inc. and the FoundationDB project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.apple.foundationdb.record.query.plan.temp;\n+\n+import com.apple.foundationdb.annotation.API;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+import java.util.Set;\n+\n+/**\n+ * A <em>correlated</em> entity is one which can only be evaluated as a function of some input (usually a {@link Quantifier}\n+ * from its relational parent).\n+ * Since a correlated entity can have multiple correlations to similar quantifiers, a correlation is disambiguated by a\n+ * {@link CorrelationIdentifier}. Correlated entities are said to be correlated to a quantifier {@code q} if the identifiers\n+ * returned by {@link #getCorrelatedTo()} set contain\n+ * the correlation identifier that {@code q} uses.\n+ *\n+ * Distinguishing the correlation identifier from the identity of the quantifier object simplifies modifications of the\n+ * graph, for example while applying transformations during query planning.\n+\n+ * An correlated object can be <em>rebased</em> using {@link #rebase} and a map of translations from one\n+ * correlation identifier to another, resulting in a new object of type {@code S} that is\n+ * identical to {@code this} except that all correlated references in the subtree rooted at this entity\n+ * (i.e., this object's relational children, predicates, etc.) are replaced with their corresponding identifiers\n+ * per the map.\n+ *\n+ * Since translations are associative we allow to rebase many identifiers in the same {@link #rebase} invocation.\n+ *\n+ * As the planner DAG objects are immutable, a rebase operation can be expensive as objects have to be recreated\n+ * as needed. We follow the ideas of other persistent data structures as we do not require a copy to be made.\n+ * It is perfectly acceptable to return {@code this} if {@code this} is not correlated to any identifier participating\n+ * in the translation.\n+ *\n+ * This interface defines a {@link #semanticEquals} method that also takes an equivalence map, and determines equality up\n+ * to the equivalences defined therein. Two correlated entities are equivalent even if they use different names, as long\n+ * as un-bound correlations can be aligned. For example, in:\n+ *\n+ * <pre>\n+ * {@code\n+ * SELECT *\n+ * FROM T1 a, T2 b\n+ * WHERE a.x = b.y\n+ * UNION (SELECT *\n+ *        FROM T1 c, T2 d\n+ *        WHERE c.x = d.y)\n+ * }\n+ * </pre>\n+ *\n+ * The two SELECT blocks should be considered equal even though they use different correlation names. The\n+ * {@link #semanticEquals} introduced here considers these blocks equal using a bi-map that allows for the definition\n+ * of equivalences among correlation identifiers. In this case\n+ *\n+ * <pre>\n+ * {@code\n+ * (SELECT * FROM T1 a, T2 b WHERE a.x = b.y).equals(SELECT * FROM T1 c, T2 d WHERE c.x = d.y, ImmutableBiMap.of())\n+ * }\n+ * </pre>\n+ *\n+ * result (through a series of other steps) in an invocation of\n+ *\n+ * <pre>\n+ * {@code\n+ * (WHERE a.x = b.y).equals(WHERE c.x = d.y, ImmutableBiMap.of(a -> b, c -> d))\n+ * }\n+ * </pre>\n+ *\n+ * which then results in a {@code true} as {@code a} is considered to be equal to {@code c} and {@code b} is considered\n+ * to be equal to {@code d}.\n+ *\n+ * @param <S> self type of this. Needed for rebasing to a proper constrained at-least type\n+ */\n+@API(API.Status.EXPERIMENTAL)\n+public interface Correlated<S extends Correlated<S>> {\n+    /**\n+     * Returns the set of {@link CorrelationIdentifier}s this entity is correlated to.\n+     * This means that without a process that binds these correlations to values, the {@link RelationalExpression}\n+     * (or others that implement this interface) cannot even in principle produce a meaningful result. As often times\n+     * entities that implement this interface use composition and effectively describe trees or DAGs, this method should\n+     * be the set union of the {@link CorrelationIdentifier}s this object is correlated to as well as all children,\n+     * constituent parts, etc.\n+     * @return the set of {@link CorrelationIdentifier}s this entity is correlated to\n+     */\n+    @Nonnull\n+    Set<CorrelationIdentifier> getCorrelatedTo();\n+\n+    /**\n+     * Rebases this and all other objects this objects is composed of using a given translation map.\n+     * @param translationMap a map defining a translation from {@link CorrelationIdentifier}s {@code ids} to\n+     *        {@link CorrelationIdentifier}s {@code ids'}. After the rebase, every correlation to an {@code id}\n+     *        contained {@code ids} that is contained or referred to directly or indirectly by {@code this} must have\n+     *        been transformed to use the mapped counterpart of {@code id} {@code id'} in {@code ids'}. IDs not\n+     *        contained in the translation map must remain unmodified by the rebase operation.\n+     * @return a new entity that has been rebased\n+     */\n+    @Nonnull\n+    S rebase(@Nonnull AliasMap translationMap);\n+\n+    /**\n+     * Determine equality with respect to an equivalence map between {@link CorrelationIdentifier}s based on\n+     * semantic equality which is usually defined as equality of the result of evaluating the plan fragment\n+     * implementing this interface under the given bound correlations.\n+     * The contract of this variant of {@code equals()} differs from its regular Java counterpart.\n+     * A correlation is mostly just one part inside of composition of objects that expresses a more complicated\n+     * (correlated) structure, e.g. a filter. For instance {@code q1.x = 5} uses a correlation to {@code q1}.\n+     * That entity representing the filter is correlated to {@code q1} for obvious reasons. Also obvious is that\n+     * {@code q1.x = 6} is a different filter and should not be considered equal at all. The same is true if we", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1c6f5d91e302d610963a6f9a05e530cff79457f9"}, "originalPosition": 125}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkxMDQ3MDc1OnYy", "diffSide": "RIGHT", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/Correlated.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNVQyMDoyMzoyMFrOG8ZSSg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNVQyMDoyMzoyMFrOG8ZSSg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTk4MjAyNg==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * consider {@code q2.x = 5} (i.e. a filter where everything but the correlation is equal. Without further context\n          \n          \n            \n                 * these two filters are not the same. However, the filters may be a part of some other entity that can express\n          \n          \n            \n                 * correlations:\n          \n          \n            \n                 * In contrast, consider a predicate where everything except the correlation is the same, such as {@code q2.x = 5}.\n          \n          \n            \n                 * Without a binding, these two filters are not the same. However, the filters may be a part of some other entity that can express\n          \n          \n            \n                 * correlations:", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/988#discussion_r465982026", "createdAt": "2020-08-05T20:23:20Z", "author": {"login": "nschiefer"}, "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/Correlated.java", "diffHunk": "@@ -0,0 +1,172 @@\n+/*\n+ * Correlated.java\n+ *\n+ * This source file is part of the FoundationDB open source project\n+ *\n+ * Copyright 2015-2020 Apple Inc. and the FoundationDB project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.apple.foundationdb.record.query.plan.temp;\n+\n+import com.apple.foundationdb.annotation.API;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+import java.util.Set;\n+\n+/**\n+ * A <em>correlated</em> entity is one which can only be evaluated as a function of some input (usually a {@link Quantifier}\n+ * from its relational parent).\n+ * Since a correlated entity can have multiple correlations to similar quantifiers, a correlation is disambiguated by a\n+ * {@link CorrelationIdentifier}. Correlated entities are said to be correlated to a quantifier {@code q} if the identifiers\n+ * returned by {@link #getCorrelatedTo()} set contain\n+ * the correlation identifier that {@code q} uses.\n+ *\n+ * Distinguishing the correlation identifier from the identity of the quantifier object simplifies modifications of the\n+ * graph, for example while applying transformations during query planning.\n+\n+ * An correlated object can be <em>rebased</em> using {@link #rebase} and a map of translations from one\n+ * correlation identifier to another, resulting in a new object of type {@code S} that is\n+ * identical to {@code this} except that all correlated references in the subtree rooted at this entity\n+ * (i.e., this object's relational children, predicates, etc.) are replaced with their corresponding identifiers\n+ * per the map.\n+ *\n+ * Since translations are associative we allow to rebase many identifiers in the same {@link #rebase} invocation.\n+ *\n+ * As the planner DAG objects are immutable, a rebase operation can be expensive as objects have to be recreated\n+ * as needed. We follow the ideas of other persistent data structures as we do not require a copy to be made.\n+ * It is perfectly acceptable to return {@code this} if {@code this} is not correlated to any identifier participating\n+ * in the translation.\n+ *\n+ * This interface defines a {@link #semanticEquals} method that also takes an equivalence map, and determines equality up\n+ * to the equivalences defined therein. Two correlated entities are equivalent even if they use different names, as long\n+ * as un-bound correlations can be aligned. For example, in:\n+ *\n+ * <pre>\n+ * {@code\n+ * SELECT *\n+ * FROM T1 a, T2 b\n+ * WHERE a.x = b.y\n+ * UNION (SELECT *\n+ *        FROM T1 c, T2 d\n+ *        WHERE c.x = d.y)\n+ * }\n+ * </pre>\n+ *\n+ * The two SELECT blocks should be considered equal even though they use different correlation names. The\n+ * {@link #semanticEquals} introduced here considers these blocks equal using a bi-map that allows for the definition\n+ * of equivalences among correlation identifiers. In this case\n+ *\n+ * <pre>\n+ * {@code\n+ * (SELECT * FROM T1 a, T2 b WHERE a.x = b.y).equals(SELECT * FROM T1 c, T2 d WHERE c.x = d.y, ImmutableBiMap.of())\n+ * }\n+ * </pre>\n+ *\n+ * result (through a series of other steps) in an invocation of\n+ *\n+ * <pre>\n+ * {@code\n+ * (WHERE a.x = b.y).equals(WHERE c.x = d.y, ImmutableBiMap.of(a -> b, c -> d))\n+ * }\n+ * </pre>\n+ *\n+ * which then results in a {@code true} as {@code a} is considered to be equal to {@code c} and {@code b} is considered\n+ * to be equal to {@code d}.\n+ *\n+ * @param <S> self type of this. Needed for rebasing to a proper constrained at-least type\n+ */\n+@API(API.Status.EXPERIMENTAL)\n+public interface Correlated<S extends Correlated<S>> {\n+    /**\n+     * Returns the set of {@link CorrelationIdentifier}s this entity is correlated to.\n+     * This means that without a process that binds these correlations to values, the {@link RelationalExpression}\n+     * (or others that implement this interface) cannot even in principle produce a meaningful result. As often times\n+     * entities that implement this interface use composition and effectively describe trees or DAGs, this method should\n+     * be the set union of the {@link CorrelationIdentifier}s this object is correlated to as well as all children,\n+     * constituent parts, etc.\n+     * @return the set of {@link CorrelationIdentifier}s this entity is correlated to\n+     */\n+    @Nonnull\n+    Set<CorrelationIdentifier> getCorrelatedTo();\n+\n+    /**\n+     * Rebases this and all other objects this objects is composed of using a given translation map.\n+     * @param translationMap a map defining a translation from {@link CorrelationIdentifier}s {@code ids} to\n+     *        {@link CorrelationIdentifier}s {@code ids'}. After the rebase, every correlation to an {@code id}\n+     *        contained {@code ids} that is contained or referred to directly or indirectly by {@code this} must have\n+     *        been transformed to use the mapped counterpart of {@code id} {@code id'} in {@code ids'}. IDs not\n+     *        contained in the translation map must remain unmodified by the rebase operation.\n+     * @return a new entity that has been rebased\n+     */\n+    @Nonnull\n+    S rebase(@Nonnull AliasMap translationMap);\n+\n+    /**\n+     * Determine equality with respect to an equivalence map between {@link CorrelationIdentifier}s based on\n+     * semantic equality which is usually defined as equality of the result of evaluating the plan fragment\n+     * implementing this interface under the given bound correlations.\n+     * The contract of this variant of {@code equals()} differs from its regular Java counterpart.\n+     * A correlation is mostly just one part inside of composition of objects that expresses a more complicated\n+     * (correlated) structure, e.g. a filter. For instance {@code q1.x = 5} uses a correlation to {@code q1}.\n+     * That entity representing the filter is correlated to {@code q1} for obvious reasons. Also obvious is that\n+     * {@code q1.x = 6} is a different filter and should not be considered equal at all. The same is true if we\n+     * consider {@code q2.x = 5} (i.e. a filter where everything but the correlation is equal. Without further context\n+     * these two filters are not the same. However, the filters may be a part of some other entity that can express\n+     * correlations:", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1c6f5d91e302d610963a6f9a05e530cff79457f9"}, "originalPosition": 128}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkxMDQ3MjE5OnYy", "diffSide": "RIGHT", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/Correlated.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNVQyMDoyMzo1MVrOG8ZTNA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNVQyMDoyMzo1MVrOG8ZTNA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTk4MjI2MA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * query blocks <em>are</em> the same.\n          \n          \n            \n                 * query blocks <em>are</em> the same, even though they are labelled differently.", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/988#discussion_r465982260", "createdAt": "2020-08-05T20:23:51Z", "author": {"login": "nschiefer"}, "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/Correlated.java", "diffHunk": "@@ -0,0 +1,172 @@\n+/*\n+ * Correlated.java\n+ *\n+ * This source file is part of the FoundationDB open source project\n+ *\n+ * Copyright 2015-2020 Apple Inc. and the FoundationDB project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.apple.foundationdb.record.query.plan.temp;\n+\n+import com.apple.foundationdb.annotation.API;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+import java.util.Set;\n+\n+/**\n+ * A <em>correlated</em> entity is one which can only be evaluated as a function of some input (usually a {@link Quantifier}\n+ * from its relational parent).\n+ * Since a correlated entity can have multiple correlations to similar quantifiers, a correlation is disambiguated by a\n+ * {@link CorrelationIdentifier}. Correlated entities are said to be correlated to a quantifier {@code q} if the identifiers\n+ * returned by {@link #getCorrelatedTo()} set contain\n+ * the correlation identifier that {@code q} uses.\n+ *\n+ * Distinguishing the correlation identifier from the identity of the quantifier object simplifies modifications of the\n+ * graph, for example while applying transformations during query planning.\n+\n+ * An correlated object can be <em>rebased</em> using {@link #rebase} and a map of translations from one\n+ * correlation identifier to another, resulting in a new object of type {@code S} that is\n+ * identical to {@code this} except that all correlated references in the subtree rooted at this entity\n+ * (i.e., this object's relational children, predicates, etc.) are replaced with their corresponding identifiers\n+ * per the map.\n+ *\n+ * Since translations are associative we allow to rebase many identifiers in the same {@link #rebase} invocation.\n+ *\n+ * As the planner DAG objects are immutable, a rebase operation can be expensive as objects have to be recreated\n+ * as needed. We follow the ideas of other persistent data structures as we do not require a copy to be made.\n+ * It is perfectly acceptable to return {@code this} if {@code this} is not correlated to any identifier participating\n+ * in the translation.\n+ *\n+ * This interface defines a {@link #semanticEquals} method that also takes an equivalence map, and determines equality up\n+ * to the equivalences defined therein. Two correlated entities are equivalent even if they use different names, as long\n+ * as un-bound correlations can be aligned. For example, in:\n+ *\n+ * <pre>\n+ * {@code\n+ * SELECT *\n+ * FROM T1 a, T2 b\n+ * WHERE a.x = b.y\n+ * UNION (SELECT *\n+ *        FROM T1 c, T2 d\n+ *        WHERE c.x = d.y)\n+ * }\n+ * </pre>\n+ *\n+ * The two SELECT blocks should be considered equal even though they use different correlation names. The\n+ * {@link #semanticEquals} introduced here considers these blocks equal using a bi-map that allows for the definition\n+ * of equivalences among correlation identifiers. In this case\n+ *\n+ * <pre>\n+ * {@code\n+ * (SELECT * FROM T1 a, T2 b WHERE a.x = b.y).equals(SELECT * FROM T1 c, T2 d WHERE c.x = d.y, ImmutableBiMap.of())\n+ * }\n+ * </pre>\n+ *\n+ * result (through a series of other steps) in an invocation of\n+ *\n+ * <pre>\n+ * {@code\n+ * (WHERE a.x = b.y).equals(WHERE c.x = d.y, ImmutableBiMap.of(a -> b, c -> d))\n+ * }\n+ * </pre>\n+ *\n+ * which then results in a {@code true} as {@code a} is considered to be equal to {@code c} and {@code b} is considered\n+ * to be equal to {@code d}.\n+ *\n+ * @param <S> self type of this. Needed for rebasing to a proper constrained at-least type\n+ */\n+@API(API.Status.EXPERIMENTAL)\n+public interface Correlated<S extends Correlated<S>> {\n+    /**\n+     * Returns the set of {@link CorrelationIdentifier}s this entity is correlated to.\n+     * This means that without a process that binds these correlations to values, the {@link RelationalExpression}\n+     * (or others that implement this interface) cannot even in principle produce a meaningful result. As often times\n+     * entities that implement this interface use composition and effectively describe trees or DAGs, this method should\n+     * be the set union of the {@link CorrelationIdentifier}s this object is correlated to as well as all children,\n+     * constituent parts, etc.\n+     * @return the set of {@link CorrelationIdentifier}s this entity is correlated to\n+     */\n+    @Nonnull\n+    Set<CorrelationIdentifier> getCorrelatedTo();\n+\n+    /**\n+     * Rebases this and all other objects this objects is composed of using a given translation map.\n+     * @param translationMap a map defining a translation from {@link CorrelationIdentifier}s {@code ids} to\n+     *        {@link CorrelationIdentifier}s {@code ids'}. After the rebase, every correlation to an {@code id}\n+     *        contained {@code ids} that is contained or referred to directly or indirectly by {@code this} must have\n+     *        been transformed to use the mapped counterpart of {@code id} {@code id'} in {@code ids'}. IDs not\n+     *        contained in the translation map must remain unmodified by the rebase operation.\n+     * @return a new entity that has been rebased\n+     */\n+    @Nonnull\n+    S rebase(@Nonnull AliasMap translationMap);\n+\n+    /**\n+     * Determine equality with respect to an equivalence map between {@link CorrelationIdentifier}s based on\n+     * semantic equality which is usually defined as equality of the result of evaluating the plan fragment\n+     * implementing this interface under the given bound correlations.\n+     * The contract of this variant of {@code equals()} differs from its regular Java counterpart.\n+     * A correlation is mostly just one part inside of composition of objects that expresses a more complicated\n+     * (correlated) structure, e.g. a filter. For instance {@code q1.x = 5} uses a correlation to {@code q1}.\n+     * That entity representing the filter is correlated to {@code q1} for obvious reasons. Also obvious is that\n+     * {@code q1.x = 6} is a different filter and should not be considered equal at all. The same is true if we\n+     * consider {@code q2.x = 5} (i.e. a filter where everything but the correlation is equal. Without further context\n+     * these two filters are not the same. However, the filters may be a part of some other entity that can express\n+     * correlations:\n+     * {@code SELECT * FROM T as q1 WHERE q1.x = 5} is equal to\n+     * {@code SELECT * FROM T as q2 WHERE q2.x = 5}. It does not matter that {@code q1} and {@code q2} are named\n+     * differently. It is important, however, that their semantic meaning is the same. In the example both {@code q1}\n+     * and {@code q2} refer to a record type {@code T} which presumably is the same record type. Therefore, these two\n+     * query blocks <em>are</em> the same.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1c6f5d91e302d610963a6f9a05e530cff79457f9"}, "originalPosition": 133}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkxMDQ3NTM4OnYy", "diffSide": "RIGHT", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/Correlated.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNVQyMDoyNDo0OFrOG8ZVOw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNVQyMDoyNDo0OFrOG8ZVOw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTk4Mjc3OQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * for these two objects the plan fragments are considered to produce the same result under the given bound\n          \n          \n            \n                 * correlations.\n          \n          \n            \n                 * for these two objects the plan fragments are considered to produce the same result under the given correlation\n          \n          \n            \n                 * bindings.", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/988#discussion_r465982779", "createdAt": "2020-08-05T20:24:48Z", "author": {"login": "nschiefer"}, "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/Correlated.java", "diffHunk": "@@ -0,0 +1,172 @@\n+/*\n+ * Correlated.java\n+ *\n+ * This source file is part of the FoundationDB open source project\n+ *\n+ * Copyright 2015-2020 Apple Inc. and the FoundationDB project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.apple.foundationdb.record.query.plan.temp;\n+\n+import com.apple.foundationdb.annotation.API;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+import java.util.Set;\n+\n+/**\n+ * A <em>correlated</em> entity is one which can only be evaluated as a function of some input (usually a {@link Quantifier}\n+ * from its relational parent).\n+ * Since a correlated entity can have multiple correlations to similar quantifiers, a correlation is disambiguated by a\n+ * {@link CorrelationIdentifier}. Correlated entities are said to be correlated to a quantifier {@code q} if the identifiers\n+ * returned by {@link #getCorrelatedTo()} set contain\n+ * the correlation identifier that {@code q} uses.\n+ *\n+ * Distinguishing the correlation identifier from the identity of the quantifier object simplifies modifications of the\n+ * graph, for example while applying transformations during query planning.\n+\n+ * An correlated object can be <em>rebased</em> using {@link #rebase} and a map of translations from one\n+ * correlation identifier to another, resulting in a new object of type {@code S} that is\n+ * identical to {@code this} except that all correlated references in the subtree rooted at this entity\n+ * (i.e., this object's relational children, predicates, etc.) are replaced with their corresponding identifiers\n+ * per the map.\n+ *\n+ * Since translations are associative we allow to rebase many identifiers in the same {@link #rebase} invocation.\n+ *\n+ * As the planner DAG objects are immutable, a rebase operation can be expensive as objects have to be recreated\n+ * as needed. We follow the ideas of other persistent data structures as we do not require a copy to be made.\n+ * It is perfectly acceptable to return {@code this} if {@code this} is not correlated to any identifier participating\n+ * in the translation.\n+ *\n+ * This interface defines a {@link #semanticEquals} method that also takes an equivalence map, and determines equality up\n+ * to the equivalences defined therein. Two correlated entities are equivalent even if they use different names, as long\n+ * as un-bound correlations can be aligned. For example, in:\n+ *\n+ * <pre>\n+ * {@code\n+ * SELECT *\n+ * FROM T1 a, T2 b\n+ * WHERE a.x = b.y\n+ * UNION (SELECT *\n+ *        FROM T1 c, T2 d\n+ *        WHERE c.x = d.y)\n+ * }\n+ * </pre>\n+ *\n+ * The two SELECT blocks should be considered equal even though they use different correlation names. The\n+ * {@link #semanticEquals} introduced here considers these blocks equal using a bi-map that allows for the definition\n+ * of equivalences among correlation identifiers. In this case\n+ *\n+ * <pre>\n+ * {@code\n+ * (SELECT * FROM T1 a, T2 b WHERE a.x = b.y).equals(SELECT * FROM T1 c, T2 d WHERE c.x = d.y, ImmutableBiMap.of())\n+ * }\n+ * </pre>\n+ *\n+ * result (through a series of other steps) in an invocation of\n+ *\n+ * <pre>\n+ * {@code\n+ * (WHERE a.x = b.y).equals(WHERE c.x = d.y, ImmutableBiMap.of(a -> b, c -> d))\n+ * }\n+ * </pre>\n+ *\n+ * which then results in a {@code true} as {@code a} is considered to be equal to {@code c} and {@code b} is considered\n+ * to be equal to {@code d}.\n+ *\n+ * @param <S> self type of this. Needed for rebasing to a proper constrained at-least type\n+ */\n+@API(API.Status.EXPERIMENTAL)\n+public interface Correlated<S extends Correlated<S>> {\n+    /**\n+     * Returns the set of {@link CorrelationIdentifier}s this entity is correlated to.\n+     * This means that without a process that binds these correlations to values, the {@link RelationalExpression}\n+     * (or others that implement this interface) cannot even in principle produce a meaningful result. As often times\n+     * entities that implement this interface use composition and effectively describe trees or DAGs, this method should\n+     * be the set union of the {@link CorrelationIdentifier}s this object is correlated to as well as all children,\n+     * constituent parts, etc.\n+     * @return the set of {@link CorrelationIdentifier}s this entity is correlated to\n+     */\n+    @Nonnull\n+    Set<CorrelationIdentifier> getCorrelatedTo();\n+\n+    /**\n+     * Rebases this and all other objects this objects is composed of using a given translation map.\n+     * @param translationMap a map defining a translation from {@link CorrelationIdentifier}s {@code ids} to\n+     *        {@link CorrelationIdentifier}s {@code ids'}. After the rebase, every correlation to an {@code id}\n+     *        contained {@code ids} that is contained or referred to directly or indirectly by {@code this} must have\n+     *        been transformed to use the mapped counterpart of {@code id} {@code id'} in {@code ids'}. IDs not\n+     *        contained in the translation map must remain unmodified by the rebase operation.\n+     * @return a new entity that has been rebased\n+     */\n+    @Nonnull\n+    S rebase(@Nonnull AliasMap translationMap);\n+\n+    /**\n+     * Determine equality with respect to an equivalence map between {@link CorrelationIdentifier}s based on\n+     * semantic equality which is usually defined as equality of the result of evaluating the plan fragment\n+     * implementing this interface under the given bound correlations.\n+     * The contract of this variant of {@code equals()} differs from its regular Java counterpart.\n+     * A correlation is mostly just one part inside of composition of objects that expresses a more complicated\n+     * (correlated) structure, e.g. a filter. For instance {@code q1.x = 5} uses a correlation to {@code q1}.\n+     * That entity representing the filter is correlated to {@code q1} for obvious reasons. Also obvious is that\n+     * {@code q1.x = 6} is a different filter and should not be considered equal at all. The same is true if we\n+     * consider {@code q2.x = 5} (i.e. a filter where everything but the correlation is equal. Without further context\n+     * these two filters are not the same. However, the filters may be a part of some other entity that can express\n+     * correlations:\n+     * {@code SELECT * FROM T as q1 WHERE q1.x = 5} is equal to\n+     * {@code SELECT * FROM T as q2 WHERE q2.x = 5}. It does not matter that {@code q1} and {@code q2} are named\n+     * differently. It is important, however, that their semantic meaning is the same. In the example both {@code q1}\n+     * and {@code q2} refer to a record type {@code T} which presumably is the same record type. Therefore, these two\n+     * query blocks <em>are</em> the same.\n+     * In the context of this method, we can establish equality between {@code q1.x = 5} and {@code q2.x = 5} if\n+     * we know that {@code q1} and {@code q2} refer to the same underlying entity. The equivalence map passed in\n+     * encodes that equality between {@link CorrelationIdentifier}s.\n+     *\n+     * Note: This method has the same interaction with {@link Object#hashCode()} as the regular {@code equals()}\n+     *       method. As we can only ever establish true equality using equivalence maps, {@code hashCode()}\n+     *       implementations in implementors of this interface <em>must not</em> be dependent on any correlation identifiers\n+     *       used in the structure of the entity. Doing so might violate the fundamental property of hash codes:\n+     *       {@code e1.equals(e2, ...) => e1.hashCode() == e2.hashCode()}\n+     *\n+     * @param other the other object to establish equality with\n+     * @param equivalenceMap a map of {@link CorrelationIdentifier}s {@code ids} to {@code ids'}. A correlation\n+     *        identifier {@code id} used in {@code this} should be considered equal to another correlation identifier\n+     *        {@code id'} used in {@code other} if either they are the same by {@link Object#equals}\n+     *        of if there is a mapping from {@code id} to {@code id'}.\n+     * @return {@code true} if both entities are considered equal using the equivalences passed in, {@code false}\n+     *         otherwise\n+     */\n+    boolean semanticEquals(@Nullable Object other, @Nonnull AliasMap equivalenceMap);\n+\n+    /**\n+     * Return a semantic hash code for this object. The hash code must obey the convention that for any two objects\n+     * {@code o1} and {@code o2} and for every {@link AliasMap} {@code aliasMap}:\n+     *\n+     * <pre>\n+     * {@code o1.semanticEquals(o1, aliasMap)} follows {@code o1.semanticHash() == o2.semanticHash()}\n+     * </pre>\n+     *\n+     * If the semantic hash code of two implementing objects is equal and {@link #semanticEquals} returns {@code true}\n+     * for these two objects the plan fragments are considered to produce the same result under the given bound\n+     * correlations.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1c6f5d91e302d610963a6f9a05e530cff79457f9"}, "originalPosition": 164}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkxMDQ3NzczOnYy", "diffSide": "RIGHT", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/Correlated.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNVQyMDoyNToyMlrOG8ZWkA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNVQyMTo1OTo0OFrOG8cHsg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTk4MzEyMA==", "bodyText": "I don't get what this is trying to say.", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/988#discussion_r465983120", "createdAt": "2020-08-05T20:25:22Z", "author": {"login": "nschiefer"}, "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/Correlated.java", "diffHunk": "@@ -0,0 +1,172 @@\n+/*\n+ * Correlated.java\n+ *\n+ * This source file is part of the FoundationDB open source project\n+ *\n+ * Copyright 2015-2020 Apple Inc. and the FoundationDB project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.apple.foundationdb.record.query.plan.temp;\n+\n+import com.apple.foundationdb.annotation.API;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+import java.util.Set;\n+\n+/**\n+ * A <em>correlated</em> entity is one which can only be evaluated as a function of some input (usually a {@link Quantifier}\n+ * from its relational parent).\n+ * Since a correlated entity can have multiple correlations to similar quantifiers, a correlation is disambiguated by a\n+ * {@link CorrelationIdentifier}. Correlated entities are said to be correlated to a quantifier {@code q} if the identifiers\n+ * returned by {@link #getCorrelatedTo()} set contain\n+ * the correlation identifier that {@code q} uses.\n+ *\n+ * Distinguishing the correlation identifier from the identity of the quantifier object simplifies modifications of the\n+ * graph, for example while applying transformations during query planning.\n+\n+ * An correlated object can be <em>rebased</em> using {@link #rebase} and a map of translations from one\n+ * correlation identifier to another, resulting in a new object of type {@code S} that is\n+ * identical to {@code this} except that all correlated references in the subtree rooted at this entity\n+ * (i.e., this object's relational children, predicates, etc.) are replaced with their corresponding identifiers\n+ * per the map.\n+ *\n+ * Since translations are associative we allow to rebase many identifiers in the same {@link #rebase} invocation.\n+ *\n+ * As the planner DAG objects are immutable, a rebase operation can be expensive as objects have to be recreated\n+ * as needed. We follow the ideas of other persistent data structures as we do not require a copy to be made.\n+ * It is perfectly acceptable to return {@code this} if {@code this} is not correlated to any identifier participating\n+ * in the translation.\n+ *\n+ * This interface defines a {@link #semanticEquals} method that also takes an equivalence map, and determines equality up\n+ * to the equivalences defined therein. Two correlated entities are equivalent even if they use different names, as long\n+ * as un-bound correlations can be aligned. For example, in:\n+ *\n+ * <pre>\n+ * {@code\n+ * SELECT *\n+ * FROM T1 a, T2 b\n+ * WHERE a.x = b.y\n+ * UNION (SELECT *\n+ *        FROM T1 c, T2 d\n+ *        WHERE c.x = d.y)\n+ * }\n+ * </pre>\n+ *\n+ * The two SELECT blocks should be considered equal even though they use different correlation names. The\n+ * {@link #semanticEquals} introduced here considers these blocks equal using a bi-map that allows for the definition\n+ * of equivalences among correlation identifiers. In this case\n+ *\n+ * <pre>\n+ * {@code\n+ * (SELECT * FROM T1 a, T2 b WHERE a.x = b.y).equals(SELECT * FROM T1 c, T2 d WHERE c.x = d.y, ImmutableBiMap.of())\n+ * }\n+ * </pre>\n+ *\n+ * result (through a series of other steps) in an invocation of\n+ *\n+ * <pre>\n+ * {@code\n+ * (WHERE a.x = b.y).equals(WHERE c.x = d.y, ImmutableBiMap.of(a -> b, c -> d))\n+ * }\n+ * </pre>\n+ *\n+ * which then results in a {@code true} as {@code a} is considered to be equal to {@code c} and {@code b} is considered\n+ * to be equal to {@code d}.\n+ *\n+ * @param <S> self type of this. Needed for rebasing to a proper constrained at-least type\n+ */\n+@API(API.Status.EXPERIMENTAL)\n+public interface Correlated<S extends Correlated<S>> {\n+    /**\n+     * Returns the set of {@link CorrelationIdentifier}s this entity is correlated to.\n+     * This means that without a process that binds these correlations to values, the {@link RelationalExpression}\n+     * (or others that implement this interface) cannot even in principle produce a meaningful result. As often times\n+     * entities that implement this interface use composition and effectively describe trees or DAGs, this method should\n+     * be the set union of the {@link CorrelationIdentifier}s this object is correlated to as well as all children,\n+     * constituent parts, etc.\n+     * @return the set of {@link CorrelationIdentifier}s this entity is correlated to\n+     */\n+    @Nonnull\n+    Set<CorrelationIdentifier> getCorrelatedTo();\n+\n+    /**\n+     * Rebases this and all other objects this objects is composed of using a given translation map.\n+     * @param translationMap a map defining a translation from {@link CorrelationIdentifier}s {@code ids} to\n+     *        {@link CorrelationIdentifier}s {@code ids'}. After the rebase, every correlation to an {@code id}\n+     *        contained {@code ids} that is contained or referred to directly or indirectly by {@code this} must have\n+     *        been transformed to use the mapped counterpart of {@code id} {@code id'} in {@code ids'}. IDs not\n+     *        contained in the translation map must remain unmodified by the rebase operation.\n+     * @return a new entity that has been rebased\n+     */\n+    @Nonnull\n+    S rebase(@Nonnull AliasMap translationMap);\n+\n+    /**\n+     * Determine equality with respect to an equivalence map between {@link CorrelationIdentifier}s based on\n+     * semantic equality which is usually defined as equality of the result of evaluating the plan fragment\n+     * implementing this interface under the given bound correlations.\n+     * The contract of this variant of {@code equals()} differs from its regular Java counterpart.\n+     * A correlation is mostly just one part inside of composition of objects that expresses a more complicated\n+     * (correlated) structure, e.g. a filter. For instance {@code q1.x = 5} uses a correlation to {@code q1}.\n+     * That entity representing the filter is correlated to {@code q1} for obvious reasons. Also obvious is that\n+     * {@code q1.x = 6} is a different filter and should not be considered equal at all. The same is true if we\n+     * consider {@code q2.x = 5} (i.e. a filter where everything but the correlation is equal. Without further context\n+     * these two filters are not the same. However, the filters may be a part of some other entity that can express\n+     * correlations:\n+     * {@code SELECT * FROM T as q1 WHERE q1.x = 5} is equal to\n+     * {@code SELECT * FROM T as q2 WHERE q2.x = 5}. It does not matter that {@code q1} and {@code q2} are named\n+     * differently. It is important, however, that their semantic meaning is the same. In the example both {@code q1}\n+     * and {@code q2} refer to a record type {@code T} which presumably is the same record type. Therefore, these two\n+     * query blocks <em>are</em> the same.\n+     * In the context of this method, we can establish equality between {@code q1.x = 5} and {@code q2.x = 5} if\n+     * we know that {@code q1} and {@code q2} refer to the same underlying entity. The equivalence map passed in\n+     * encodes that equality between {@link CorrelationIdentifier}s.\n+     *\n+     * Note: This method has the same interaction with {@link Object#hashCode()} as the regular {@code equals()}\n+     *       method. As we can only ever establish true equality using equivalence maps, {@code hashCode()}\n+     *       implementations in implementors of this interface <em>must not</em> be dependent on any correlation identifiers\n+     *       used in the structure of the entity. Doing so might violate the fundamental property of hash codes:\n+     *       {@code e1.equals(e2, ...) => e1.hashCode() == e2.hashCode()}\n+     *\n+     * @param other the other object to establish equality with\n+     * @param equivalenceMap a map of {@link CorrelationIdentifier}s {@code ids} to {@code ids'}. A correlation\n+     *        identifier {@code id} used in {@code this} should be considered equal to another correlation identifier\n+     *        {@code id'} used in {@code other} if either they are the same by {@link Object#equals}\n+     *        of if there is a mapping from {@code id} to {@code id'}.\n+     * @return {@code true} if both entities are considered equal using the equivalences passed in, {@code false}\n+     *         otherwise\n+     */\n+    boolean semanticEquals(@Nullable Object other, @Nonnull AliasMap equivalenceMap);\n+\n+    /**\n+     * Return a semantic hash code for this object. The hash code must obey the convention that for any two objects\n+     * {@code o1} and {@code o2} and for every {@link AliasMap} {@code aliasMap}:\n+     *\n+     * <pre>\n+     * {@code o1.semanticEquals(o1, aliasMap)} follows {@code o1.semanticHash() == o2.semanticHash()}\n+     * </pre>\n+     *\n+     * If the semantic hash code of two implementing objects is equal and {@link #semanticEquals} returns {@code true}\n+     * for these two objects the plan fragments are considered to produce the same result under the given bound\n+     * correlations.\n+     *\n+     * As the right side of the follows does not include the alias map passed into {@link #semanticEquals} it is implied\n+     * that this method cannot depend on a correlation mapping.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1c6f5d91e302d610963a6f9a05e530cff79457f9"}, "originalPosition": 167}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjAyODQ2Ng==", "bodyText": "The left side semanticEquals() depends on an AliasMap while semanticHash() does not. Hence, the hash is computed is identical regardless of possible bindings. Will make this more expressive.", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/988#discussion_r466028466", "createdAt": "2020-08-05T21:59:48Z", "author": {"login": "normen662"}, "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/Correlated.java", "diffHunk": "@@ -0,0 +1,172 @@\n+/*\n+ * Correlated.java\n+ *\n+ * This source file is part of the FoundationDB open source project\n+ *\n+ * Copyright 2015-2020 Apple Inc. and the FoundationDB project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.apple.foundationdb.record.query.plan.temp;\n+\n+import com.apple.foundationdb.annotation.API;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+import java.util.Set;\n+\n+/**\n+ * A <em>correlated</em> entity is one which can only be evaluated as a function of some input (usually a {@link Quantifier}\n+ * from its relational parent).\n+ * Since a correlated entity can have multiple correlations to similar quantifiers, a correlation is disambiguated by a\n+ * {@link CorrelationIdentifier}. Correlated entities are said to be correlated to a quantifier {@code q} if the identifiers\n+ * returned by {@link #getCorrelatedTo()} set contain\n+ * the correlation identifier that {@code q} uses.\n+ *\n+ * Distinguishing the correlation identifier from the identity of the quantifier object simplifies modifications of the\n+ * graph, for example while applying transformations during query planning.\n+\n+ * An correlated object can be <em>rebased</em> using {@link #rebase} and a map of translations from one\n+ * correlation identifier to another, resulting in a new object of type {@code S} that is\n+ * identical to {@code this} except that all correlated references in the subtree rooted at this entity\n+ * (i.e., this object's relational children, predicates, etc.) are replaced with their corresponding identifiers\n+ * per the map.\n+ *\n+ * Since translations are associative we allow to rebase many identifiers in the same {@link #rebase} invocation.\n+ *\n+ * As the planner DAG objects are immutable, a rebase operation can be expensive as objects have to be recreated\n+ * as needed. We follow the ideas of other persistent data structures as we do not require a copy to be made.\n+ * It is perfectly acceptable to return {@code this} if {@code this} is not correlated to any identifier participating\n+ * in the translation.\n+ *\n+ * This interface defines a {@link #semanticEquals} method that also takes an equivalence map, and determines equality up\n+ * to the equivalences defined therein. Two correlated entities are equivalent even if they use different names, as long\n+ * as un-bound correlations can be aligned. For example, in:\n+ *\n+ * <pre>\n+ * {@code\n+ * SELECT *\n+ * FROM T1 a, T2 b\n+ * WHERE a.x = b.y\n+ * UNION (SELECT *\n+ *        FROM T1 c, T2 d\n+ *        WHERE c.x = d.y)\n+ * }\n+ * </pre>\n+ *\n+ * The two SELECT blocks should be considered equal even though they use different correlation names. The\n+ * {@link #semanticEquals} introduced here considers these blocks equal using a bi-map that allows for the definition\n+ * of equivalences among correlation identifiers. In this case\n+ *\n+ * <pre>\n+ * {@code\n+ * (SELECT * FROM T1 a, T2 b WHERE a.x = b.y).equals(SELECT * FROM T1 c, T2 d WHERE c.x = d.y, ImmutableBiMap.of())\n+ * }\n+ * </pre>\n+ *\n+ * result (through a series of other steps) in an invocation of\n+ *\n+ * <pre>\n+ * {@code\n+ * (WHERE a.x = b.y).equals(WHERE c.x = d.y, ImmutableBiMap.of(a -> b, c -> d))\n+ * }\n+ * </pre>\n+ *\n+ * which then results in a {@code true} as {@code a} is considered to be equal to {@code c} and {@code b} is considered\n+ * to be equal to {@code d}.\n+ *\n+ * @param <S> self type of this. Needed for rebasing to a proper constrained at-least type\n+ */\n+@API(API.Status.EXPERIMENTAL)\n+public interface Correlated<S extends Correlated<S>> {\n+    /**\n+     * Returns the set of {@link CorrelationIdentifier}s this entity is correlated to.\n+     * This means that without a process that binds these correlations to values, the {@link RelationalExpression}\n+     * (or others that implement this interface) cannot even in principle produce a meaningful result. As often times\n+     * entities that implement this interface use composition and effectively describe trees or DAGs, this method should\n+     * be the set union of the {@link CorrelationIdentifier}s this object is correlated to as well as all children,\n+     * constituent parts, etc.\n+     * @return the set of {@link CorrelationIdentifier}s this entity is correlated to\n+     */\n+    @Nonnull\n+    Set<CorrelationIdentifier> getCorrelatedTo();\n+\n+    /**\n+     * Rebases this and all other objects this objects is composed of using a given translation map.\n+     * @param translationMap a map defining a translation from {@link CorrelationIdentifier}s {@code ids} to\n+     *        {@link CorrelationIdentifier}s {@code ids'}. After the rebase, every correlation to an {@code id}\n+     *        contained {@code ids} that is contained or referred to directly or indirectly by {@code this} must have\n+     *        been transformed to use the mapped counterpart of {@code id} {@code id'} in {@code ids'}. IDs not\n+     *        contained in the translation map must remain unmodified by the rebase operation.\n+     * @return a new entity that has been rebased\n+     */\n+    @Nonnull\n+    S rebase(@Nonnull AliasMap translationMap);\n+\n+    /**\n+     * Determine equality with respect to an equivalence map between {@link CorrelationIdentifier}s based on\n+     * semantic equality which is usually defined as equality of the result of evaluating the plan fragment\n+     * implementing this interface under the given bound correlations.\n+     * The contract of this variant of {@code equals()} differs from its regular Java counterpart.\n+     * A correlation is mostly just one part inside of composition of objects that expresses a more complicated\n+     * (correlated) structure, e.g. a filter. For instance {@code q1.x = 5} uses a correlation to {@code q1}.\n+     * That entity representing the filter is correlated to {@code q1} for obvious reasons. Also obvious is that\n+     * {@code q1.x = 6} is a different filter and should not be considered equal at all. The same is true if we\n+     * consider {@code q2.x = 5} (i.e. a filter where everything but the correlation is equal. Without further context\n+     * these two filters are not the same. However, the filters may be a part of some other entity that can express\n+     * correlations:\n+     * {@code SELECT * FROM T as q1 WHERE q1.x = 5} is equal to\n+     * {@code SELECT * FROM T as q2 WHERE q2.x = 5}. It does not matter that {@code q1} and {@code q2} are named\n+     * differently. It is important, however, that their semantic meaning is the same. In the example both {@code q1}\n+     * and {@code q2} refer to a record type {@code T} which presumably is the same record type. Therefore, these two\n+     * query blocks <em>are</em> the same.\n+     * In the context of this method, we can establish equality between {@code q1.x = 5} and {@code q2.x = 5} if\n+     * we know that {@code q1} and {@code q2} refer to the same underlying entity. The equivalence map passed in\n+     * encodes that equality between {@link CorrelationIdentifier}s.\n+     *\n+     * Note: This method has the same interaction with {@link Object#hashCode()} as the regular {@code equals()}\n+     *       method. As we can only ever establish true equality using equivalence maps, {@code hashCode()}\n+     *       implementations in implementors of this interface <em>must not</em> be dependent on any correlation identifiers\n+     *       used in the structure of the entity. Doing so might violate the fundamental property of hash codes:\n+     *       {@code e1.equals(e2, ...) => e1.hashCode() == e2.hashCode()}\n+     *\n+     * @param other the other object to establish equality with\n+     * @param equivalenceMap a map of {@link CorrelationIdentifier}s {@code ids} to {@code ids'}. A correlation\n+     *        identifier {@code id} used in {@code this} should be considered equal to another correlation identifier\n+     *        {@code id'} used in {@code other} if either they are the same by {@link Object#equals}\n+     *        of if there is a mapping from {@code id} to {@code id'}.\n+     * @return {@code true} if both entities are considered equal using the equivalences passed in, {@code false}\n+     *         otherwise\n+     */\n+    boolean semanticEquals(@Nullable Object other, @Nonnull AliasMap equivalenceMap);\n+\n+    /**\n+     * Return a semantic hash code for this object. The hash code must obey the convention that for any two objects\n+     * {@code o1} and {@code o2} and for every {@link AliasMap} {@code aliasMap}:\n+     *\n+     * <pre>\n+     * {@code o1.semanticEquals(o1, aliasMap)} follows {@code o1.semanticHash() == o2.semanticHash()}\n+     * </pre>\n+     *\n+     * If the semantic hash code of two implementing objects is equal and {@link #semanticEquals} returns {@code true}\n+     * for these two objects the plan fragments are considered to produce the same result under the given bound\n+     * correlations.\n+     *\n+     * As the right side of the follows does not include the alias map passed into {@link #semanticEquals} it is implied\n+     * that this method cannot depend on a correlation mapping.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTk4MzEyMA=="}, "originalCommit": {"oid": "1c6f5d91e302d610963a6f9a05e530cff79457f9"}, "originalPosition": 167}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkxMDUwMTAwOnYy", "diffSide": "RIGHT", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/GroupExpressionRef.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNVQyMDozMjo1MFrOG8ZleA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNVQyMjozODo1MFrOG8c_jg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTk4NjkzNg==", "bodyText": "Is this right? It would seem to me that if canCorrelate() doesn't match then we should just return false rather than throwing an exception?", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/988#discussion_r465986936", "createdAt": "2020-08-05T20:32:50Z", "author": {"login": "nschiefer"}, "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/GroupExpressionRef.java", "diffHunk": "@@ -84,73 +92,99 @@ public T get() {\n     }\n \n     @Override\n-    public void insert(@Nonnull T newValue) {\n+    public boolean insert(@Nonnull T newValue) {\n         if (!containsInMemo(newValue)) {\n             members.add(newValue);\n+            return true;\n         }\n+        return false;\n     }\n-\n-    public void insertAll(@Nonnull GroupExpressionRef<T> newValues) {\n-        for (T member : newValues.members) {\n-            insert(member);\n-        }\n-    }\n-\n-    public void removeMemberIfPresent(@Nonnull T member) {\n-        members.remove(member);\n-    }\n-\n-    public void removeMember(@Nonnull T member) {\n-        if (!members.remove(member)) {\n-            throw new RecordCoreArgumentException(\"tried to remove member that isn't present\")\n-                    .addLogInfo(\"member\", member);\n-        }\n-    }\n-\n+    \n+    @SuppressWarnings(\"BooleanMethodIsAlwaysInverted\")\n     public boolean containsExactly(@Nonnull T expression) {\n         return members.contains(expression);\n     }\n \n     @Override\n-    public boolean containsAllInMemo(@Nonnull ExpressionRef<? extends RelationalExpression> otherRef) {\n-        for (RelationalExpression otherMember : otherRef.getMembers()) {\n-            if (!containsInMemo(otherMember)) {\n+    public boolean containsAllInMemo(@Nonnull final ExpressionRef<? extends RelationalExpression> otherRef,\n+                                     @Nonnull final AliasMap equivalenceMap) {\n+        for (final RelationalExpression otherMember : otherRef.getMembers()) {\n+            if (!containsInMemo(otherMember, equivalenceMap)) {\n                 return false;\n             }\n         }\n         return true;\n     }\n \n-    public boolean containsInMemo(@Nonnull RelationalExpression expression) {\n-        for (RelationalExpression member : members) {\n-            if (containsInMember(member, expression)) {\n+    public boolean containsInMemo(@Nonnull final RelationalExpression expression) {\n+        final Set<CorrelationIdentifier> correlatedTo = getCorrelatedTo();\n+        final Set<CorrelationIdentifier> otherCorrelatedTo = expression.getCorrelatedTo();\n+\n+        final Sets.SetView<CorrelationIdentifier> commonUnbound = Sets.intersection(correlatedTo, otherCorrelatedTo);\n+        final AliasMap identityMap = AliasMap.identitiesFor(commonUnbound);\n+\n+        return containsInMemo(expression, identityMap);\n+    }\n+\n+    private boolean containsInMemo(@Nonnull final RelationalExpression expression,\n+                                   @Nonnull final AliasMap equivalenceMap) {\n+        for (final RelationalExpression member : members) {\n+            if (containsInMember(member, expression, equivalenceMap)) {\n                 return true;\n             }\n         }\n         return false;\n     }\n \n-    private boolean containsInMember(@Nonnull RelationalExpression member, @Nonnull RelationalExpression otherMember) {\n-        if (!member.equalsWithoutChildren(otherMember)) {\n-            return false;\n-        }\n-\n-        final List<? extends Quantifier> memberQuantifiers = member.getQuantifiers();\n-        final List<? extends Quantifier> otherMemberQuantifiers = otherMember.getQuantifiers();\n-        if (memberQuantifiers.size() != otherMemberQuantifiers.size()) {\n+    private static boolean containsInMember(@Nonnull RelationalExpression member,\n+                                            @Nonnull RelationalExpression otherMember,\n+                                            @Nonnull final AliasMap equivalenceMap) {\n+        if (member.getClass() != otherMember.getClass()) {\n             return false;\n         }\n \n-        for (int i = 0; i < memberQuantifiers.size(); i++) {\n-            final ExpressionRef<? extends RelationalExpression> memberRangesOver = memberQuantifiers.get(i).getRangesOver();\n-            final ExpressionRef<? extends RelationalExpression> otherMemberRangesOver = otherMemberQuantifiers.get(i).getRangesOver();\n+        Verify.verify(member.canCorrelate() == otherMember.canCorrelate());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1c6f5d91e302d610963a6f9a05e530cff79457f9"}, "originalPosition": 119}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjA0MjcxMw==", "bodyText": "When this verify happens we have already established that member and otherMember are of the same class. It is not allowed to have different objects of the class return different values.", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/988#discussion_r466042713", "createdAt": "2020-08-05T22:38:42Z", "author": {"login": "normen662"}, "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/GroupExpressionRef.java", "diffHunk": "@@ -84,73 +92,99 @@ public T get() {\n     }\n \n     @Override\n-    public void insert(@Nonnull T newValue) {\n+    public boolean insert(@Nonnull T newValue) {\n         if (!containsInMemo(newValue)) {\n             members.add(newValue);\n+            return true;\n         }\n+        return false;\n     }\n-\n-    public void insertAll(@Nonnull GroupExpressionRef<T> newValues) {\n-        for (T member : newValues.members) {\n-            insert(member);\n-        }\n-    }\n-\n-    public void removeMemberIfPresent(@Nonnull T member) {\n-        members.remove(member);\n-    }\n-\n-    public void removeMember(@Nonnull T member) {\n-        if (!members.remove(member)) {\n-            throw new RecordCoreArgumentException(\"tried to remove member that isn't present\")\n-                    .addLogInfo(\"member\", member);\n-        }\n-    }\n-\n+    \n+    @SuppressWarnings(\"BooleanMethodIsAlwaysInverted\")\n     public boolean containsExactly(@Nonnull T expression) {\n         return members.contains(expression);\n     }\n \n     @Override\n-    public boolean containsAllInMemo(@Nonnull ExpressionRef<? extends RelationalExpression> otherRef) {\n-        for (RelationalExpression otherMember : otherRef.getMembers()) {\n-            if (!containsInMemo(otherMember)) {\n+    public boolean containsAllInMemo(@Nonnull final ExpressionRef<? extends RelationalExpression> otherRef,\n+                                     @Nonnull final AliasMap equivalenceMap) {\n+        for (final RelationalExpression otherMember : otherRef.getMembers()) {\n+            if (!containsInMemo(otherMember, equivalenceMap)) {\n                 return false;\n             }\n         }\n         return true;\n     }\n \n-    public boolean containsInMemo(@Nonnull RelationalExpression expression) {\n-        for (RelationalExpression member : members) {\n-            if (containsInMember(member, expression)) {\n+    public boolean containsInMemo(@Nonnull final RelationalExpression expression) {\n+        final Set<CorrelationIdentifier> correlatedTo = getCorrelatedTo();\n+        final Set<CorrelationIdentifier> otherCorrelatedTo = expression.getCorrelatedTo();\n+\n+        final Sets.SetView<CorrelationIdentifier> commonUnbound = Sets.intersection(correlatedTo, otherCorrelatedTo);\n+        final AliasMap identityMap = AliasMap.identitiesFor(commonUnbound);\n+\n+        return containsInMemo(expression, identityMap);\n+    }\n+\n+    private boolean containsInMemo(@Nonnull final RelationalExpression expression,\n+                                   @Nonnull final AliasMap equivalenceMap) {\n+        for (final RelationalExpression member : members) {\n+            if (containsInMember(member, expression, equivalenceMap)) {\n                 return true;\n             }\n         }\n         return false;\n     }\n \n-    private boolean containsInMember(@Nonnull RelationalExpression member, @Nonnull RelationalExpression otherMember) {\n-        if (!member.equalsWithoutChildren(otherMember)) {\n-            return false;\n-        }\n-\n-        final List<? extends Quantifier> memberQuantifiers = member.getQuantifiers();\n-        final List<? extends Quantifier> otherMemberQuantifiers = otherMember.getQuantifiers();\n-        if (memberQuantifiers.size() != otherMemberQuantifiers.size()) {\n+    private static boolean containsInMember(@Nonnull RelationalExpression member,\n+                                            @Nonnull RelationalExpression otherMember,\n+                                            @Nonnull final AliasMap equivalenceMap) {\n+        if (member.getClass() != otherMember.getClass()) {\n             return false;\n         }\n \n-        for (int i = 0; i < memberQuantifiers.size(); i++) {\n-            final ExpressionRef<? extends RelationalExpression> memberRangesOver = memberQuantifiers.get(i).getRangesOver();\n-            final ExpressionRef<? extends RelationalExpression> otherMemberRangesOver = otherMemberQuantifiers.get(i).getRangesOver();\n+        Verify.verify(member.canCorrelate() == otherMember.canCorrelate());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTk4NjkzNg=="}, "originalCommit": {"oid": "1c6f5d91e302d610963a6f9a05e530cff79457f9"}, "originalPosition": 119}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjA0Mjc2Ng==", "bodyText": "Will add a comment.", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/988#discussion_r466042766", "createdAt": "2020-08-05T22:38:50Z", "author": {"login": "normen662"}, "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/GroupExpressionRef.java", "diffHunk": "@@ -84,73 +92,99 @@ public T get() {\n     }\n \n     @Override\n-    public void insert(@Nonnull T newValue) {\n+    public boolean insert(@Nonnull T newValue) {\n         if (!containsInMemo(newValue)) {\n             members.add(newValue);\n+            return true;\n         }\n+        return false;\n     }\n-\n-    public void insertAll(@Nonnull GroupExpressionRef<T> newValues) {\n-        for (T member : newValues.members) {\n-            insert(member);\n-        }\n-    }\n-\n-    public void removeMemberIfPresent(@Nonnull T member) {\n-        members.remove(member);\n-    }\n-\n-    public void removeMember(@Nonnull T member) {\n-        if (!members.remove(member)) {\n-            throw new RecordCoreArgumentException(\"tried to remove member that isn't present\")\n-                    .addLogInfo(\"member\", member);\n-        }\n-    }\n-\n+    \n+    @SuppressWarnings(\"BooleanMethodIsAlwaysInverted\")\n     public boolean containsExactly(@Nonnull T expression) {\n         return members.contains(expression);\n     }\n \n     @Override\n-    public boolean containsAllInMemo(@Nonnull ExpressionRef<? extends RelationalExpression> otherRef) {\n-        for (RelationalExpression otherMember : otherRef.getMembers()) {\n-            if (!containsInMemo(otherMember)) {\n+    public boolean containsAllInMemo(@Nonnull final ExpressionRef<? extends RelationalExpression> otherRef,\n+                                     @Nonnull final AliasMap equivalenceMap) {\n+        for (final RelationalExpression otherMember : otherRef.getMembers()) {\n+            if (!containsInMemo(otherMember, equivalenceMap)) {\n                 return false;\n             }\n         }\n         return true;\n     }\n \n-    public boolean containsInMemo(@Nonnull RelationalExpression expression) {\n-        for (RelationalExpression member : members) {\n-            if (containsInMember(member, expression)) {\n+    public boolean containsInMemo(@Nonnull final RelationalExpression expression) {\n+        final Set<CorrelationIdentifier> correlatedTo = getCorrelatedTo();\n+        final Set<CorrelationIdentifier> otherCorrelatedTo = expression.getCorrelatedTo();\n+\n+        final Sets.SetView<CorrelationIdentifier> commonUnbound = Sets.intersection(correlatedTo, otherCorrelatedTo);\n+        final AliasMap identityMap = AliasMap.identitiesFor(commonUnbound);\n+\n+        return containsInMemo(expression, identityMap);\n+    }\n+\n+    private boolean containsInMemo(@Nonnull final RelationalExpression expression,\n+                                   @Nonnull final AliasMap equivalenceMap) {\n+        for (final RelationalExpression member : members) {\n+            if (containsInMember(member, expression, equivalenceMap)) {\n                 return true;\n             }\n         }\n         return false;\n     }\n \n-    private boolean containsInMember(@Nonnull RelationalExpression member, @Nonnull RelationalExpression otherMember) {\n-        if (!member.equalsWithoutChildren(otherMember)) {\n-            return false;\n-        }\n-\n-        final List<? extends Quantifier> memberQuantifiers = member.getQuantifiers();\n-        final List<? extends Quantifier> otherMemberQuantifiers = otherMember.getQuantifiers();\n-        if (memberQuantifiers.size() != otherMemberQuantifiers.size()) {\n+    private static boolean containsInMember(@Nonnull RelationalExpression member,\n+                                            @Nonnull RelationalExpression otherMember,\n+                                            @Nonnull final AliasMap equivalenceMap) {\n+        if (member.getClass() != otherMember.getClass()) {\n             return false;\n         }\n \n-        for (int i = 0; i < memberQuantifiers.size(); i++) {\n-            final ExpressionRef<? extends RelationalExpression> memberRangesOver = memberQuantifiers.get(i).getRangesOver();\n-            final ExpressionRef<? extends RelationalExpression> otherMemberRangesOver = otherMemberQuantifiers.get(i).getRangesOver();\n+        Verify.verify(member.canCorrelate() == otherMember.canCorrelate());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTk4NjkzNg=="}, "originalCommit": {"oid": "1c6f5d91e302d610963a6f9a05e530cff79457f9"}, "originalPosition": 119}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkxMDUwNzA1OnYy", "diffSide": "RIGHT", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/RelationalExpression.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNVQyMDozNDo1N1rOG8ZpUA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNVQyMDozNDo1N1rOG8ZpUA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTk4NzkyMA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * <li>2. the anchor (which is a {@link RelationalExpression} that ranges directly over the source</li>\n          \n          \n            \n                 * <li>2. the anchor (which is a {@link RelationalExpression}) that ranges directly over the source</li>", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/988#discussion_r465987920", "createdAt": "2020-08-05T20:34:57Z", "author": {"login": "nschiefer"}, "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/RelationalExpression.java", "diffHunk": "@@ -136,7 +145,130 @@ static RelationalExpression fromRecordQuery(@Nonnull RecordQuery query, @Nonnull\n     @Nonnull\n     List<? extends Quantifier> getQuantifiers();\n \n-    boolean equalsWithoutChildren(@Nonnull RelationalExpression otherExpression);\n+    /**\n+     * Returns if this expression can be the anchor of a correlation.\n+     *\n+     * A correlation is always formed between three entities:\n+     * <ol>\n+     * <li>the {@link Quantifier} that flows data</li>\n+     * <li>2. the anchor (which is a {@link RelationalExpression} that ranges directly over the source</li>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1c6f5d91e302d610963a6f9a05e530cff79457f9"}, "originalPosition": 88}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkxMDUxMjEwOnYy", "diffSide": "RIGHT", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/RelationalExpression.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNVQyMDozNjozNlrOG8ZsYQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNVQyMDozNjozNlrOG8ZsYQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTk4ODcwNQ==", "bodyText": "Hmmm, I'm not sure if I like having this as a default method. It seems like a potent foot-gun for someone who might add a new type of relational expression without understanding the details of the planner. How bad is it to have every implementation include one of these?", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/988#discussion_r465988705", "createdAt": "2020-08-05T20:36:36Z", "author": {"login": "nschiefer"}, "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/RelationalExpression.java", "diffHunk": "@@ -136,7 +145,130 @@ static RelationalExpression fromRecordQuery(@Nonnull RecordQuery query, @Nonnull\n     @Nonnull\n     List<? extends Quantifier> getQuantifiers();\n \n-    boolean equalsWithoutChildren(@Nonnull RelationalExpression otherExpression);\n+    /**\n+     * Returns if this expression can be the anchor of a correlation.\n+     *\n+     * A correlation is always formed between three entities:\n+     * <ol>\n+     * <li>the {@link Quantifier} that flows data</li>\n+     * <li>2. the anchor (which is a {@link RelationalExpression} that ranges directly over the source</li>\n+     * <li>3. the consumers (or dependents) of the correlation which must be a descendant of the anchor.</li>\n+     * </ol>\n+     *\n+     * In order for a correlation to be meaningful, the anchor must define how data is bound and used by all\n+     * dependents. For most expressions it is not meaningful or even possible to define correlation in such a way.\n+     *\n+     * For instance, a {@link com.apple.foundationdb.record.query.plan.temp.expressions.LogicalUnorderedUnionExpression}\n+     * cannot correlate (this method returns {@code false}) because it is not meaningful to bind a record from one child\n+     * of the union while providing bound values to another.\n+     *\n+     * In another example, a logical select expression can correlate which means that one child of the SELECT expression\n+     * can be evaluated and the resulting records can bound individually one after another. For each bound record\n+     * flowing along that quantifier the other children of the SELECT expression can be evaluated, potentially causing\n+     * more correlation values to be bound, etc. These concepts follow closely to the mechanics of what SQL calls a query\n+     * block.\n+     *\n+     * The existence of a correlation between source, anchor, and dependents may adversely affect planning because\n+     * a correlation always imposes order between the evaluated of children of an expression. This may or may\n+     * not tie the hands of the planner to produce an optimal plan. In certain cases, queries written in a correlated\n+     * way can be <em>de-correlated</em> to allow for better optimization techniques.\n+     *\n+     * @return {@code true} if this expression can be the anchor of a correlation, {@code false} otherwise.\n+     */\n+    default boolean canCorrelate() {\n+        return false;\n+    }\n+\n+    default boolean equalsWithoutChildren(@Nonnull final RelationalExpression other,\n+                                          @Nonnull final AliasMap equivalences) {\n+        if (this == other) {\n+            return true;\n+        }\n+        return other.getClass() == getClass();\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1c6f5d91e302d610963a6f9a05e530cff79457f9"}, "originalPosition": 122}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkxMDUxMzk4OnYy", "diffSide": "RIGHT", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/RelationalExpression.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNVQyMDozNzowOVrOG8ZtfQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNVQyMjo0MTo0OFrOG8dDUg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTk4ODk4OQ==", "bodyText": "Like in other places, I'm not sure why this is a verified fast rather than something that just short-circuits to false.", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/988#discussion_r465988989", "createdAt": "2020-08-05T20:37:09Z", "author": {"login": "nschiefer"}, "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/RelationalExpression.java", "diffHunk": "@@ -136,7 +145,130 @@ static RelationalExpression fromRecordQuery(@Nonnull RecordQuery query, @Nonnull\n     @Nonnull\n     List<? extends Quantifier> getQuantifiers();\n \n-    boolean equalsWithoutChildren(@Nonnull RelationalExpression otherExpression);\n+    /**\n+     * Returns if this expression can be the anchor of a correlation.\n+     *\n+     * A correlation is always formed between three entities:\n+     * <ol>\n+     * <li>the {@link Quantifier} that flows data</li>\n+     * <li>2. the anchor (which is a {@link RelationalExpression} that ranges directly over the source</li>\n+     * <li>3. the consumers (or dependents) of the correlation which must be a descendant of the anchor.</li>\n+     * </ol>\n+     *\n+     * In order for a correlation to be meaningful, the anchor must define how data is bound and used by all\n+     * dependents. For most expressions it is not meaningful or even possible to define correlation in such a way.\n+     *\n+     * For instance, a {@link com.apple.foundationdb.record.query.plan.temp.expressions.LogicalUnorderedUnionExpression}\n+     * cannot correlate (this method returns {@code false}) because it is not meaningful to bind a record from one child\n+     * of the union while providing bound values to another.\n+     *\n+     * In another example, a logical select expression can correlate which means that one child of the SELECT expression\n+     * can be evaluated and the resulting records can bound individually one after another. For each bound record\n+     * flowing along that quantifier the other children of the SELECT expression can be evaluated, potentially causing\n+     * more correlation values to be bound, etc. These concepts follow closely to the mechanics of what SQL calls a query\n+     * block.\n+     *\n+     * The existence of a correlation between source, anchor, and dependents may adversely affect planning because\n+     * a correlation always imposes order between the evaluated of children of an expression. This may or may\n+     * not tie the hands of the planner to produce an optimal plan. In certain cases, queries written in a correlated\n+     * way can be <em>de-correlated</em> to allow for better optimization techniques.\n+     *\n+     * @return {@code true} if this expression can be the anchor of a correlation, {@code false} otherwise.\n+     */\n+    default boolean canCorrelate() {\n+        return false;\n+    }\n+\n+    default boolean equalsWithoutChildren(@Nonnull final RelationalExpression other,\n+                                          @Nonnull final AliasMap equivalences) {\n+        if (this == other) {\n+            return true;\n+        }\n+        return other.getClass() == getClass();\n+    }\n+\n+    int hashCodeWithoutChildren();\n+\n+    /**\n+     * Overloaded method to call {@link #semanticEquals} with an empty alias map.\n+     * @param other object to compare to this expression\n+     * @return {@code true} if this object is semantically equal to {@code other} that is {@code this} and {@code other}\n+     *         produce the same result when invoked with no bindings, {@code false} otherwise.\n+     */\n+    default boolean semanticEquals(@Nullable final Object other) {\n+        return semanticEquals(other, AliasMap.empty());\n+    }\n+\n+    @Override\n+    default boolean semanticEquals(@Nullable final Object other,\n+                                   @Nonnull final AliasMap equivalenceMap) {\n+        if (this == other) {\n+            return true;\n+        }\n+\n+        if (other == null || getClass() != other.getClass()) {\n+            return false;\n+        }\n+\n+        final RelationalExpression otherExpression = (RelationalExpression)other;\n+\n+        Verify.verify(canCorrelate() == otherExpression.canCorrelate());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1c6f5d91e302d610963a6f9a05e530cff79457f9"}, "originalPosition": 149}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjA0MzczMA==", "bodyText": "It is not correct to return different values for objects of the same class which at that point has been established already.", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/988#discussion_r466043730", "createdAt": "2020-08-05T22:41:48Z", "author": {"login": "normen662"}, "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/RelationalExpression.java", "diffHunk": "@@ -136,7 +145,130 @@ static RelationalExpression fromRecordQuery(@Nonnull RecordQuery query, @Nonnull\n     @Nonnull\n     List<? extends Quantifier> getQuantifiers();\n \n-    boolean equalsWithoutChildren(@Nonnull RelationalExpression otherExpression);\n+    /**\n+     * Returns if this expression can be the anchor of a correlation.\n+     *\n+     * A correlation is always formed between three entities:\n+     * <ol>\n+     * <li>the {@link Quantifier} that flows data</li>\n+     * <li>2. the anchor (which is a {@link RelationalExpression} that ranges directly over the source</li>\n+     * <li>3. the consumers (or dependents) of the correlation which must be a descendant of the anchor.</li>\n+     * </ol>\n+     *\n+     * In order for a correlation to be meaningful, the anchor must define how data is bound and used by all\n+     * dependents. For most expressions it is not meaningful or even possible to define correlation in such a way.\n+     *\n+     * For instance, a {@link com.apple.foundationdb.record.query.plan.temp.expressions.LogicalUnorderedUnionExpression}\n+     * cannot correlate (this method returns {@code false}) because it is not meaningful to bind a record from one child\n+     * of the union while providing bound values to another.\n+     *\n+     * In another example, a logical select expression can correlate which means that one child of the SELECT expression\n+     * can be evaluated and the resulting records can bound individually one after another. For each bound record\n+     * flowing along that quantifier the other children of the SELECT expression can be evaluated, potentially causing\n+     * more correlation values to be bound, etc. These concepts follow closely to the mechanics of what SQL calls a query\n+     * block.\n+     *\n+     * The existence of a correlation between source, anchor, and dependents may adversely affect planning because\n+     * a correlation always imposes order between the evaluated of children of an expression. This may or may\n+     * not tie the hands of the planner to produce an optimal plan. In certain cases, queries written in a correlated\n+     * way can be <em>de-correlated</em> to allow for better optimization techniques.\n+     *\n+     * @return {@code true} if this expression can be the anchor of a correlation, {@code false} otherwise.\n+     */\n+    default boolean canCorrelate() {\n+        return false;\n+    }\n+\n+    default boolean equalsWithoutChildren(@Nonnull final RelationalExpression other,\n+                                          @Nonnull final AliasMap equivalences) {\n+        if (this == other) {\n+            return true;\n+        }\n+        return other.getClass() == getClass();\n+    }\n+\n+    int hashCodeWithoutChildren();\n+\n+    /**\n+     * Overloaded method to call {@link #semanticEquals} with an empty alias map.\n+     * @param other object to compare to this expression\n+     * @return {@code true} if this object is semantically equal to {@code other} that is {@code this} and {@code other}\n+     *         produce the same result when invoked with no bindings, {@code false} otherwise.\n+     */\n+    default boolean semanticEquals(@Nullable final Object other) {\n+        return semanticEquals(other, AliasMap.empty());\n+    }\n+\n+    @Override\n+    default boolean semanticEquals(@Nullable final Object other,\n+                                   @Nonnull final AliasMap equivalenceMap) {\n+        if (this == other) {\n+            return true;\n+        }\n+\n+        if (other == null || getClass() != other.getClass()) {\n+            return false;\n+        }\n+\n+        final RelationalExpression otherExpression = (RelationalExpression)other;\n+\n+        Verify.verify(canCorrelate() == otherExpression.canCorrelate());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTk4ODk4OQ=="}, "originalCommit": {"oid": "1c6f5d91e302d610963a6f9a05e530cff79457f9"}, "originalPosition": 149}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkxMDUxOTk5OnYy", "diffSide": "RIGHT", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/expressions/FullUnorderedScanExpression.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNVQyMDozOTowNVrOG8ZxIA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNVQyMjo0NDoxMVrOG8dGSA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTk4OTkyMA==", "bodyText": "If this is the common use case, perhaps we can pull out RelationExpression.equalsWithoutChildren() into a static utility method somewhere rather than a default instance method?", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/988#discussion_r465989920", "createdAt": "2020-08-05T20:39:05Z", "author": {"login": "nschiefer"}, "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/expressions/FullUnorderedScanExpression.java", "diffHunk": "@@ -68,27 +71,48 @@ public FullUnorderedScanExpression(final Set<String> recordTypes) {\n         return ImmutableList.of();\n     }\n \n+    @Nonnull\n+    @Override\n+    public Set<CorrelationIdentifier> getCorrelatedTo() {\n+        return ImmutableSet.of();\n+    }\n+\n+    @Nonnull\n+    @Override\n+    public FullUnorderedScanExpression rebase(@Nonnull final AliasMap translationMap) {\n+        return this;\n+    }\n+\n     @Override\n-    public boolean equalsWithoutChildren(@Nonnull RelationalExpression otherExpression) {\n-        return equals(otherExpression);\n+    public boolean equalsWithoutChildren(@Nonnull RelationalExpression otherExpression, @Nonnull final AliasMap equivalencesMap) {\n+        if (!RelationalExpression.super.equalsWithoutChildren(otherExpression, equivalencesMap)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1c6f5d91e302d610963a6f9a05e530cff79457f9"}, "originalPosition": 37}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjA0NDQ4OA==", "bodyText": "Unfortunately, that's not useful as there is actually a short circuit in that method. I have replaced the convoluted super call with what it's actually doing in the super which now also allows us to short circuit.", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/988#discussion_r466044488", "createdAt": "2020-08-05T22:44:11Z", "author": {"login": "normen662"}, "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/expressions/FullUnorderedScanExpression.java", "diffHunk": "@@ -68,27 +71,48 @@ public FullUnorderedScanExpression(final Set<String> recordTypes) {\n         return ImmutableList.of();\n     }\n \n+    @Nonnull\n+    @Override\n+    public Set<CorrelationIdentifier> getCorrelatedTo() {\n+        return ImmutableSet.of();\n+    }\n+\n+    @Nonnull\n+    @Override\n+    public FullUnorderedScanExpression rebase(@Nonnull final AliasMap translationMap) {\n+        return this;\n+    }\n+\n     @Override\n-    public boolean equalsWithoutChildren(@Nonnull RelationalExpression otherExpression) {\n-        return equals(otherExpression);\n+    public boolean equalsWithoutChildren(@Nonnull RelationalExpression otherExpression, @Nonnull final AliasMap equivalencesMap) {\n+        if (!RelationalExpression.super.equalsWithoutChildren(otherExpression, equivalencesMap)) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTk4OTkyMA=="}, "originalCommit": {"oid": "1c6f5d91e302d610963a6f9a05e530cff79457f9"}, "originalPosition": 37}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkxMDU0MTUwOnYy", "diffSide": "RIGHT", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/plans/RecordQueryPlan.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNVQyMDo0NTozNlrOG8Z-XA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNVQyMjo0NToyN1rOG8dICA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTk5MzMwOA==", "bodyText": "There seems to be a lot of code in here that's shared with RelationalExpression.semanticEquals(). Can you pull out some shared abstractions, or at least add some comments illustrating where the difference is? This seems especially prudent since QueryPlan implements RelationalExpression.", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/988#discussion_r465993308", "createdAt": "2020-08-05T20:45:36Z", "author": {"login": "nschiefer"}, "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/plans/RecordQueryPlan.java", "diffHunk": "@@ -157,4 +165,119 @@ default RecordQueryPlan accept(@Nonnull RecordQueryPlannerSubstitutionVisitor vi\n         }\n         return visitor.postVisit(this, requiredFields);\n     }\n+\n+    /**\n+     * Return a hash code for this plan which is defined based on the structural layout of a plan. This differs from\n+     * the semantic hash code defined in {@link RelationalExpression}. For instance this method would not necessarily return\n+     * the same hash code for a union {@code UNION(p1, p2)} of two sub-plans {@code p1} and {@code p2} and it's reversed\n+     * {@code UNION(p2, p1)}. In contrast to that the semantic hash of these two plans is the same.\n+     * @return a hash code for this objects that is defined on the structural layout of the plan\n+     */\n+    default int structuralHashCode() {\n+        return Objects.hash(getQuantifiers(), hashCodeWithoutChildren());\n+    }\n+\n+\n+    /**\n+     * Overloaded method to determine structural equality between two different plans using an empty {@link AliasMap}.\n+     * @param other object to compare this object with\n+     * @return {@code true} if {@code this} is structurally equal to {@code other}, {@code false} otherwise\n+     */\n+    @API(API.Status.EXPERIMENTAL)\n+    default boolean structuralEquals(@Nullable final Object other) {\n+        return structuralEquals(other, AliasMap.empty());\n+    }\n+\n+    /**\n+     * Determine if two plans are structurally equal. This differs from the semantic equality defined in\n+     * {@link RelationalExpression}. For instance this method would return false\n+     * for two given plans {@code UNION(p1, p2)} and {@code UNION(p2, p1)} of two different sub-plans {@code p1} and\n+     * {@code p2}. In contrast to that these plans are considered semantically equal.\n+     * @param other object to compare this object with\n+     * @param equivalenceMap alias map to indicate aliases that should be considered as equal when {@code other} is\n+     *        compared to {@code this}. For instance {@code q1.x = 1} is only structurally equal with {@code q2.x = 1}\n+     *        if there is a mapping {@code q1 -> q2} in the alias map passed in\n+     * @return {@code true} if {@code this} is structurally equal to {@code other}, {@code false} otherwise\n+     */\n+    @API(API.Status.EXPERIMENTAL)\n+    default boolean structuralEquals(@Nullable final Object other,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1c6f5d91e302d610963a6f9a05e530cff79457f9"}, "originalPosition": 65}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjA0NDkzNg==", "bodyText": "That's done in the follow up matching code. In fact I have already rebased and the code duplication between these two methods is now much less. Don't want to do it in this PR as there are other changes in that follow up work that I don't want to pull in.", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/988#discussion_r466044936", "createdAt": "2020-08-05T22:45:27Z", "author": {"login": "normen662"}, "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/plans/RecordQueryPlan.java", "diffHunk": "@@ -157,4 +165,119 @@ default RecordQueryPlan accept(@Nonnull RecordQueryPlannerSubstitutionVisitor vi\n         }\n         return visitor.postVisit(this, requiredFields);\n     }\n+\n+    /**\n+     * Return a hash code for this plan which is defined based on the structural layout of a plan. This differs from\n+     * the semantic hash code defined in {@link RelationalExpression}. For instance this method would not necessarily return\n+     * the same hash code for a union {@code UNION(p1, p2)} of two sub-plans {@code p1} and {@code p2} and it's reversed\n+     * {@code UNION(p2, p1)}. In contrast to that the semantic hash of these two plans is the same.\n+     * @return a hash code for this objects that is defined on the structural layout of the plan\n+     */\n+    default int structuralHashCode() {\n+        return Objects.hash(getQuantifiers(), hashCodeWithoutChildren());\n+    }\n+\n+\n+    /**\n+     * Overloaded method to determine structural equality between two different plans using an empty {@link AliasMap}.\n+     * @param other object to compare this object with\n+     * @return {@code true} if {@code this} is structurally equal to {@code other}, {@code false} otherwise\n+     */\n+    @API(API.Status.EXPERIMENTAL)\n+    default boolean structuralEquals(@Nullable final Object other) {\n+        return structuralEquals(other, AliasMap.empty());\n+    }\n+\n+    /**\n+     * Determine if two plans are structurally equal. This differs from the semantic equality defined in\n+     * {@link RelationalExpression}. For instance this method would return false\n+     * for two given plans {@code UNION(p1, p2)} and {@code UNION(p2, p1)} of two different sub-plans {@code p1} and\n+     * {@code p2}. In contrast to that these plans are considered semantically equal.\n+     * @param other object to compare this object with\n+     * @param equivalenceMap alias map to indicate aliases that should be considered as equal when {@code other} is\n+     *        compared to {@code this}. For instance {@code q1.x = 1} is only structurally equal with {@code q2.x = 1}\n+     *        if there is a mapping {@code q1 -> q2} in the alias map passed in\n+     * @return {@code true} if {@code this} is structurally equal to {@code other}, {@code false} otherwise\n+     */\n+    @API(API.Status.EXPERIMENTAL)\n+    default boolean structuralEquals(@Nullable final Object other,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTk5MzMwOA=="}, "originalCommit": {"oid": "1c6f5d91e302d610963a6f9a05e530cff79457f9"}, "originalPosition": 65}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkxMDU1OTA0OnYy", "diffSide": "RIGHT", "path": "fdb-record-layer-core/src/test/java/com/apple/foundationdb/record/query/plan/planning/RecordQueryPlanEqualityTest.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNVQyMDo1MTowMlrOG8aJBA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNlQxNjoxMzoyOVrOG86ijA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTk5NjAzNg==", "bodyText": "Can you add a similar block here for unordered unions?", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/988#discussion_r465996036", "createdAt": "2020-08-05T20:51:02Z", "author": {"login": "nschiefer"}, "path": "fdb-record-layer-core/src/test/java/com/apple/foundationdb/record/query/plan/planning/RecordQueryPlanEqualityTest.java", "diffHunk": "@@ -132,12 +133,17 @@ public void differentPlanClassesNotEqual() {\n     public void childOrderDoesNotMatter() {\n         final RecordQueryPlan unionPlan1 = unionPlan(2, 4);\n         final RecordQueryPlan unionPlan2 = unionPlan(4, 2);\n-        assertEquals(unionPlan1, unionPlan2);\n-        assertEquals(unionPlan1.hashCode(), unionPlan2.hashCode());\n+        assertNotEquals(unionPlan1, unionPlan2);\n+        assertNotEquals(unionPlan1.hashCode(), unionPlan2.hashCode());\n+        assertTrue(unionPlan1.semanticEquals(unionPlan2));\n+        assertEquals(unionPlan1.semanticHashCode(), unionPlan2.semanticHashCode());\n+\n \n         final RecordQueryPlan intersectionPlan1 = intersectionPlan(2, 4);\n         final RecordQueryPlan intersectionPlan2 = intersectionPlan(4, 2);\n-        assertEquals(intersectionPlan1, intersectionPlan2);\n-        assertEquals(intersectionPlan1.hashCode(), intersectionPlan2.hashCode());\n+        assertNotEquals(intersectionPlan1, intersectionPlan2);\n+        assertNotEquals(intersectionPlan1.hashCode(), intersectionPlan2.hashCode());\n+        assertTrue(intersectionPlan1.semanticEquals(intersectionPlan2));\n+        assertEquals(intersectionPlan1.semanticHashCode(), intersectionPlan2.semanticHashCode());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1c6f5d91e302d610963a6f9a05e530cff79457f9"}, "originalPosition": 37}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjA0NTc3OA==", "bodyText": "Hmm -- see line 136-139", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/988#discussion_r466045778", "createdAt": "2020-08-05T22:47:58Z", "author": {"login": "normen662"}, "path": "fdb-record-layer-core/src/test/java/com/apple/foundationdb/record/query/plan/planning/RecordQueryPlanEqualityTest.java", "diffHunk": "@@ -132,12 +133,17 @@ public void differentPlanClassesNotEqual() {\n     public void childOrderDoesNotMatter() {\n         final RecordQueryPlan unionPlan1 = unionPlan(2, 4);\n         final RecordQueryPlan unionPlan2 = unionPlan(4, 2);\n-        assertEquals(unionPlan1, unionPlan2);\n-        assertEquals(unionPlan1.hashCode(), unionPlan2.hashCode());\n+        assertNotEquals(unionPlan1, unionPlan2);\n+        assertNotEquals(unionPlan1.hashCode(), unionPlan2.hashCode());\n+        assertTrue(unionPlan1.semanticEquals(unionPlan2));\n+        assertEquals(unionPlan1.semanticHashCode(), unionPlan2.semanticHashCode());\n+\n \n         final RecordQueryPlan intersectionPlan1 = intersectionPlan(2, 4);\n         final RecordQueryPlan intersectionPlan2 = intersectionPlan(4, 2);\n-        assertEquals(intersectionPlan1, intersectionPlan2);\n-        assertEquals(intersectionPlan1.hashCode(), intersectionPlan2.hashCode());\n+        assertNotEquals(intersectionPlan1, intersectionPlan2);\n+        assertNotEquals(intersectionPlan1.hashCode(), intersectionPlan2.hashCode());\n+        assertTrue(intersectionPlan1.semanticEquals(intersectionPlan2));\n+        assertEquals(intersectionPlan1.semanticHashCode(), intersectionPlan2.semanticHashCode());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTk5NjAzNg=="}, "originalCommit": {"oid": "1c6f5d91e302d610963a6f9a05e530cff79457f9"}, "originalPosition": 37}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjUyNjg2MA==", "bodyText": "Right, those are ordered unions. I was hoping we could do a similar one for RecordQueryUnorderedUnionPlans.", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/988#discussion_r466526860", "createdAt": "2020-08-06T16:13:29Z", "author": {"login": "nschiefer"}, "path": "fdb-record-layer-core/src/test/java/com/apple/foundationdb/record/query/plan/planning/RecordQueryPlanEqualityTest.java", "diffHunk": "@@ -132,12 +133,17 @@ public void differentPlanClassesNotEqual() {\n     public void childOrderDoesNotMatter() {\n         final RecordQueryPlan unionPlan1 = unionPlan(2, 4);\n         final RecordQueryPlan unionPlan2 = unionPlan(4, 2);\n-        assertEquals(unionPlan1, unionPlan2);\n-        assertEquals(unionPlan1.hashCode(), unionPlan2.hashCode());\n+        assertNotEquals(unionPlan1, unionPlan2);\n+        assertNotEquals(unionPlan1.hashCode(), unionPlan2.hashCode());\n+        assertTrue(unionPlan1.semanticEquals(unionPlan2));\n+        assertEquals(unionPlan1.semanticHashCode(), unionPlan2.semanticHashCode());\n+\n \n         final RecordQueryPlan intersectionPlan1 = intersectionPlan(2, 4);\n         final RecordQueryPlan intersectionPlan2 = intersectionPlan(4, 2);\n-        assertEquals(intersectionPlan1, intersectionPlan2);\n-        assertEquals(intersectionPlan1.hashCode(), intersectionPlan2.hashCode());\n+        assertNotEquals(intersectionPlan1, intersectionPlan2);\n+        assertNotEquals(intersectionPlan1.hashCode(), intersectionPlan2.hashCode());\n+        assertTrue(intersectionPlan1.semanticEquals(intersectionPlan2));\n+        assertEquals(intersectionPlan1.semanticHashCode(), intersectionPlan2.semanticHashCode());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTk5NjAzNg=="}, "originalCommit": {"oid": "1c6f5d91e302d610963a6f9a05e530cff79457f9"}, "originalPosition": 37}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkxMDU2MzQ0OnYy", "diffSide": "LEFT", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/expressions/LogicalTypeFilterExpression.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNVQyMDo1MjoyMVrOG8aLnw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNVQyMjozMjoxN1rOG8c20A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTk5NjcwMw==", "bodyText": "I think we still need this equalsWithoutChildren(). I think these are easy enough to drop and important enough to have that we should remove the default implementation.", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/988#discussion_r465996703", "createdAt": "2020-08-05T20:52:21Z", "author": {"login": "nschiefer"}, "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/expressions/LogicalTypeFilterExpression.java", "diffHunk": "@@ -80,31 +81,37 @@ private Quantifier getInner() {\n         return inner;\n     }\n \n+    @Nonnull\n+    @Override\n+    public LogicalTypeFilterExpression rebase(@Nonnull final AliasMap translationMap) {\n+        // we know the following is correct, just Java doesn't\n+        return (LogicalTypeFilterExpression)TypeFilterExpression.super.rebase(translationMap);\n+    }\n+\n     @Override\n-    public boolean equalsWithoutChildren(@Nonnull RelationalExpression otherExpression) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1c6f5d91e302d610963a6f9a05e530cff79457f9"}, "originalPosition": 56}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjA0MDUyOA==", "bodyText": "Removed the default implementation. Also verified that this expression is correctly doing equalsWithoutChildren through its superclass.", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/988#discussion_r466040528", "createdAt": "2020-08-05T22:32:17Z", "author": {"login": "normen662"}, "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/expressions/LogicalTypeFilterExpression.java", "diffHunk": "@@ -80,31 +81,37 @@ private Quantifier getInner() {\n         return inner;\n     }\n \n+    @Nonnull\n+    @Override\n+    public LogicalTypeFilterExpression rebase(@Nonnull final AliasMap translationMap) {\n+        // we know the following is correct, just Java doesn't\n+        return (LogicalTypeFilterExpression)TypeFilterExpression.super.rebase(translationMap);\n+    }\n+\n     @Override\n-    public boolean equalsWithoutChildren(@Nonnull RelationalExpression otherExpression) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTk5NjcwMw=="}, "originalCommit": {"oid": "1c6f5d91e302d610963a6f9a05e530cff79457f9"}, "originalPosition": 56}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkxMDU3ODIxOnYy", "diffSide": "RIGHT", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/plans/RecordQueryPlan.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNVQyMDo1NzowNFrOG8aUwA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNVQyMDo1NzowNFrOG8aUwA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTk5OTA0MA==", "bodyText": "This method should be EXPERIMENTAL so that we don't have to maintain it. :-)", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/988#discussion_r465999040", "createdAt": "2020-08-05T20:57:04Z", "author": {"login": "nschiefer"}, "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/plans/RecordQueryPlan.java", "diffHunk": "@@ -157,4 +165,119 @@ default RecordQueryPlan accept(@Nonnull RecordQueryPlannerSubstitutionVisitor vi\n         }\n         return visitor.postVisit(this, requiredFields);\n     }\n+\n+    /**\n+     * Return a hash code for this plan which is defined based on the structural layout of a plan. This differs from\n+     * the semantic hash code defined in {@link RelationalExpression}. For instance this method would not necessarily return\n+     * the same hash code for a union {@code UNION(p1, p2)} of two sub-plans {@code p1} and {@code p2} and it's reversed\n+     * {@code UNION(p2, p1)}. In contrast to that the semantic hash of these two plans is the same.\n+     * @return a hash code for this objects that is defined on the structural layout of the plan\n+     */\n+    default int structuralHashCode() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1c6f5d91e302d610963a6f9a05e530cff79457f9"}, "originalPosition": 38}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkxMDU4NzE2OnYy", "diffSide": "RIGHT", "path": "docs/ReleaseNotes.md", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNVQyMDo1OTo0OFrOG8aaNg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNVQyMjowMzoxOFrOG8cNVg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjAwMDQzOA==", "bodyText": "I don't think that this one needs a callout separate from the previous line.", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/988#discussion_r466000438", "createdAt": "2020-08-05T20:59:48Z", "author": {"login": "nschiefer"}, "path": "docs/ReleaseNotes.md", "diffHunk": "@@ -35,9 +35,9 @@ Additionally, builds for the project now require JDK 11. The project is still ta\n * **Feature** Feature 3 [(Issue #NNN)](https://github.com/FoundationDB/fdb-record-layer/issues/NNN)\n * **Feature** Feature 4 [(Issue #NNN)](https://github.com/FoundationDB/fdb-record-layer/issues/NNN)\n * **Feature** Feature 5 [(Issue #NNN)](https://github.com/FoundationDB/fdb-record-layer/issues/NNN)\n-* **Breaking change** Change 1 [(Issue #NNN)](https://github.com/FoundationDB/fdb-record-layer/issues/NNN)\n-* **Breaking change** Change 2 [(Issue #NNN)](https://github.com/FoundationDB/fdb-record-layer/issues/NNN)\n-* **Breaking change** Change 3 [(Issue #NNN)](https://github.com/FoundationDB/fdb-record-layer/issues/NNN)\n+* **Breaking change** RecordQueryCoveringIndexPlan does not implement RecordQueryPlanWithChild anymore [(Issue #987)](https://github.com/FoundationDB/fdb-record-layer/issues/987)\n+* **Breaking change** Removed overloaded constructor tp RecordQueryCoveringIndexPlan that implicitly creates the underlying index scan plan [(Issue #987)](https://github.com/FoundationDB/fdb-record-layer/issues/987)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1c6f5d91e302d610963a6f9a05e530cff79457f9"}, "originalPosition": 8}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjAyOTkxMA==", "bodyText": "okay", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/988#discussion_r466029910", "createdAt": "2020-08-05T22:03:18Z", "author": {"login": "normen662"}, "path": "docs/ReleaseNotes.md", "diffHunk": "@@ -35,9 +35,9 @@ Additionally, builds for the project now require JDK 11. The project is still ta\n * **Feature** Feature 3 [(Issue #NNN)](https://github.com/FoundationDB/fdb-record-layer/issues/NNN)\n * **Feature** Feature 4 [(Issue #NNN)](https://github.com/FoundationDB/fdb-record-layer/issues/NNN)\n * **Feature** Feature 5 [(Issue #NNN)](https://github.com/FoundationDB/fdb-record-layer/issues/NNN)\n-* **Breaking change** Change 1 [(Issue #NNN)](https://github.com/FoundationDB/fdb-record-layer/issues/NNN)\n-* **Breaking change** Change 2 [(Issue #NNN)](https://github.com/FoundationDB/fdb-record-layer/issues/NNN)\n-* **Breaking change** Change 3 [(Issue #NNN)](https://github.com/FoundationDB/fdb-record-layer/issues/NNN)\n+* **Breaking change** RecordQueryCoveringIndexPlan does not implement RecordQueryPlanWithChild anymore [(Issue #987)](https://github.com/FoundationDB/fdb-record-layer/issues/987)\n+* **Breaking change** Removed overloaded constructor tp RecordQueryCoveringIndexPlan that implicitly creates the underlying index scan plan [(Issue #987)](https://github.com/FoundationDB/fdb-record-layer/issues/987)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjAwMDQzOA=="}, "originalCommit": {"oid": "1c6f5d91e302d610963a6f9a05e530cff79457f9"}, "originalPosition": 8}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkxMDU4OTQyOnYy", "diffSide": "RIGHT", "path": "docs/ReleaseNotes.md", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNVQyMTowMDoyOFrOG8abiw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNVQyMjowMzowNFrOG8cM8w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjAwMDc3OQ==", "bodyText": "That said, this affects more than just RecordQueryFitlerPlanBase (at the very least, it also affects RecordQueryInJoinPlan. Can you go through and make a list of which query plans are affect here?", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/988#discussion_r466000779", "createdAt": "2020-08-05T21:00:28Z", "author": {"login": "nschiefer"}, "path": "docs/ReleaseNotes.md", "diffHunk": "@@ -35,9 +35,9 @@ Additionally, builds for the project now require JDK 11. The project is still ta\n * **Feature** Feature 3 [(Issue #NNN)](https://github.com/FoundationDB/fdb-record-layer/issues/NNN)\n * **Feature** Feature 4 [(Issue #NNN)](https://github.com/FoundationDB/fdb-record-layer/issues/NNN)\n * **Feature** Feature 5 [(Issue #NNN)](https://github.com/FoundationDB/fdb-record-layer/issues/NNN)\n-* **Breaking change** Change 1 [(Issue #NNN)](https://github.com/FoundationDB/fdb-record-layer/issues/NNN)\n-* **Breaking change** Change 2 [(Issue #NNN)](https://github.com/FoundationDB/fdb-record-layer/issues/NNN)\n-* **Breaking change** Change 3 [(Issue #NNN)](https://github.com/FoundationDB/fdb-record-layer/issues/NNN)\n+* **Breaking change** RecordQueryCoveringIndexPlan does not implement RecordQueryPlanWithChild anymore [(Issue #987)](https://github.com/FoundationDB/fdb-record-layer/issues/987)\n+* **Breaking change** Removed overloaded constructor tp RecordQueryCoveringIndexPlan that implicitly creates the underlying index scan plan [(Issue #987)](https://github.com/FoundationDB/fdb-record-layer/issues/987)\n+* **Breaking change** Renamed method RecordQueryFilterPlanBase.getInner() to getInnerPlan() in order to differentiate inner quantifier and the plan that the quantifier ranges over [(Issue #987)](https://github.com/FoundationDB/fdb-record-layer/issues/987)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1c6f5d91e302d610963a6f9a05e530cff79457f9"}, "originalPosition": 9}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjAyOTgxMQ==", "bodyText": "Will make this INTERNAL", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/988#discussion_r466029811", "createdAt": "2020-08-05T22:03:04Z", "author": {"login": "normen662"}, "path": "docs/ReleaseNotes.md", "diffHunk": "@@ -35,9 +35,9 @@ Additionally, builds for the project now require JDK 11. The project is still ta\n * **Feature** Feature 3 [(Issue #NNN)](https://github.com/FoundationDB/fdb-record-layer/issues/NNN)\n * **Feature** Feature 4 [(Issue #NNN)](https://github.com/FoundationDB/fdb-record-layer/issues/NNN)\n * **Feature** Feature 5 [(Issue #NNN)](https://github.com/FoundationDB/fdb-record-layer/issues/NNN)\n-* **Breaking change** Change 1 [(Issue #NNN)](https://github.com/FoundationDB/fdb-record-layer/issues/NNN)\n-* **Breaking change** Change 2 [(Issue #NNN)](https://github.com/FoundationDB/fdb-record-layer/issues/NNN)\n-* **Breaking change** Change 3 [(Issue #NNN)](https://github.com/FoundationDB/fdb-record-layer/issues/NNN)\n+* **Breaking change** RecordQueryCoveringIndexPlan does not implement RecordQueryPlanWithChild anymore [(Issue #987)](https://github.com/FoundationDB/fdb-record-layer/issues/987)\n+* **Breaking change** Removed overloaded constructor tp RecordQueryCoveringIndexPlan that implicitly creates the underlying index scan plan [(Issue #987)](https://github.com/FoundationDB/fdb-record-layer/issues/987)\n+* **Breaking change** Renamed method RecordQueryFilterPlanBase.getInner() to getInnerPlan() in order to differentiate inner quantifier and the plan that the quantifier ranges over [(Issue #987)](https://github.com/FoundationDB/fdb-record-layer/issues/987)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjAwMDc3OQ=="}, "originalCommit": {"oid": "1c6f5d91e302d610963a6f9a05e530cff79457f9"}, "originalPosition": 9}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkxNDEzMDI2OnYy", "diffSide": "RIGHT", "path": "docs/ReleaseNotes.md", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNlQxNjo1OToxOVrOG88L1g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNlQxNzoyNjowMVrOG89PPQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjU1MzgxNA==", "bodyText": "Let's also call out that there are API-level breaking changes here.\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            * **Breaking change** Implementors of RecordQueryPlan use API.INTERNAL [(Issue #987)](https://github.com/FoundationDB/fdb-record-layer/issues/987)\n          \n          \n            \n            * **Breaking change** Several API changes in `RecordQueryPlan` implementors, which are also now `INTERNAL` APIs. [(Issue #987)](https://github.com/FoundationDB/fdb-record-layer/issues/987)", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/988#discussion_r466553814", "createdAt": "2020-08-06T16:59:19Z", "author": {"login": "nschiefer"}, "path": "docs/ReleaseNotes.md", "diffHunk": "@@ -35,7 +35,7 @@ Additionally, builds for the project now require JDK 11. The project is still ta\n * **Feature** Feature 3 [(Issue #NNN)](https://github.com/FoundationDB/fdb-record-layer/issues/NNN)\n * **Feature** Feature 4 [(Issue #NNN)](https://github.com/FoundationDB/fdb-record-layer/issues/NNN)\n * **Feature** Feature 5 [(Issue #NNN)](https://github.com/FoundationDB/fdb-record-layer/issues/NNN)\n-* **Breaking change** Change 1 [(Issue #NNN)](https://github.com/FoundationDB/fdb-record-layer/issues/NNN)\n+* **Breaking change** Implementors of RecordQueryPlan use API.INTERNAL [(Issue #987)](https://github.com/FoundationDB/fdb-record-layer/issues/987)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6971f3b44d3c6f6717475921c4f0df32dae0ec20"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjU3MTA2OQ==", "bodyText": "done", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/988#discussion_r466571069", "createdAt": "2020-08-06T17:26:01Z", "author": {"login": "normen662"}, "path": "docs/ReleaseNotes.md", "diffHunk": "@@ -35,7 +35,7 @@ Additionally, builds for the project now require JDK 11. The project is still ta\n * **Feature** Feature 3 [(Issue #NNN)](https://github.com/FoundationDB/fdb-record-layer/issues/NNN)\n * **Feature** Feature 4 [(Issue #NNN)](https://github.com/FoundationDB/fdb-record-layer/issues/NNN)\n * **Feature** Feature 5 [(Issue #NNN)](https://github.com/FoundationDB/fdb-record-layer/issues/NNN)\n-* **Breaking change** Change 1 [(Issue #NNN)](https://github.com/FoundationDB/fdb-record-layer/issues/NNN)\n+* **Breaking change** Implementors of RecordQueryPlan use API.INTERNAL [(Issue #987)](https://github.com/FoundationDB/fdb-record-layer/issues/987)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjU1MzgxNA=="}, "originalCommit": {"oid": "6971f3b44d3c6f6717475921c4f0df32dae0ec20"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkxNDQxMjcxOnYy", "diffSide": "RIGHT", "path": "docs/ReleaseNotes.md", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNlQxODoxNTo0N1rOG8-8vw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNlQxODoxNTo0N1rOG8-8vw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjU5OTEwMw==", "bodyText": "I meant to suggest that we replace this with the other one. So:\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            * **Breaking change** Implementors of RecordQueryPlan use API.INTERNAL [(Issue #987)](https://github.com/FoundationDB/fdb-record-layer/issues/987)", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/988#discussion_r466599103", "createdAt": "2020-08-06T18:15:47Z", "author": {"login": "nschiefer"}, "path": "docs/ReleaseNotes.md", "diffHunk": "@@ -35,8 +35,8 @@ Additionally, builds for the project now require JDK 11. The project is still ta\n * **Feature** Feature 3 [(Issue #NNN)](https://github.com/FoundationDB/fdb-record-layer/issues/NNN)\n * **Feature** Feature 4 [(Issue #NNN)](https://github.com/FoundationDB/fdb-record-layer/issues/NNN)\n * **Feature** Feature 5 [(Issue #NNN)](https://github.com/FoundationDB/fdb-record-layer/issues/NNN)\n-* **Breaking change** Change 1 [(Issue #NNN)](https://github.com/FoundationDB/fdb-record-layer/issues/NNN)\n-* **Breaking change** Change 2 [(Issue #NNN)](https://github.com/FoundationDB/fdb-record-layer/issues/NNN)\n+* **Breaking change** Implementors of RecordQueryPlan use API.INTERNAL [(Issue #987)](https://github.com/FoundationDB/fdb-record-layer/issues/987)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "05f568735ecda54915227c69b68d0d433921d6e5"}, "originalPosition": 6}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgzMTMwODM2OnYy", "diffSide": "RIGHT", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/Quantifier.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xM1QyMjowOTo0MlrOGw8CdA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xM1QyMjowOTo0MlrOGw8CdA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mzk2ODUwMA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        public PhysicalBuilder morphFrom(final ForEach quantifier) {\n          \n          \n            \n                        public PhysicalBuilder morphFrom(@Nonnull final ForEach quantifier) {", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/988#discussion_r453968500", "createdAt": "2020-07-13T22:09:42Z", "author": {"login": "nschiefer"}, "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/Quantifier.java", "diffHunk": "@@ -137,9 +268,32 @@ public static Existential existential(@Nonnull final ExpressionRef<? extends Rel\n      */\n     @SuppressWarnings(\"squid:S2160\") // sonarqube thinks .equals() and hashCode() should be overwritten which is not necessary\n     public static final class Physical extends Quantifier {\n-        private final ExpressionRef<? extends RecordQueryPlan> rangesOver;\n+        @Nonnull private final ExpressionRef<? extends RecordQueryPlan> rangesOver;\n+\n+        /**\n+         * Builder subclass for physical quantifiers.\n+         */\n+        public static class PhysicalBuilder extends Builder<Physical, PhysicalBuilder> {\n+            @Nonnull\n+            public Physical build(@Nonnull final ExpressionRef<? extends RecordQueryPlan> rangesOver) {\n+                return new Physical(alias == null ? CorrelationIdentifier.randomId() : alias, rangesOver);\n+            }\n+\n+            /**\n+             * Often times a for-each quantifier needs to \"turn\" into a physical quantifier e.g. when a logical\n+             * operator is implemented by a physical one.\n+             * @param quantifier for each quantifier to morph from\n+             * @return the new physical quantifier\n+             */\n+            @Nonnull\n+            public PhysicalBuilder morphFrom(final ForEach quantifier) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6eb7142ab316ffbec53e375804118f722f1d2bcc"}, "originalPosition": 249}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgzMTMwOTkxOnYy", "diffSide": "RIGHT", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/Quantifier.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xM1QyMjowOTo1OFrOGw8DPA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xM1QyMjowOTo1OFrOGw8DPA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mzk2ODcwMA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    public Physical rebase(final Map<CorrelationIdentifier, CorrelationIdentifier> translationMap) {\n          \n          \n            \n                    public Physical rebase(@Nonnull final Map<CorrelationIdentifier, CorrelationIdentifier> translationMap) {", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/988#discussion_r453968700", "createdAt": "2020-07-13T22:09:58Z", "author": {"login": "nschiefer"}, "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/Quantifier.java", "diffHunk": "@@ -149,32 +303,60 @@ private Physical(@Nonnull final ExpressionRef<? extends RecordQueryPlan> rangesO\n             return rangesOver;\n         }\n \n+        @Nonnull\n+        public RecordQueryPlan getRangesOverPlan() {\n+            return getRangesOver().get();\n+        }\n+\n         @Override\n         @Nonnull\n         public String getShorthand() {\n             return \"\ud835\udcc5\";\n         }\n+\n+        @Override\n+        @Nonnull\n+        public String toString() {\n+            return rangesOver.toString();\n+        }\n+\n+        @Override\n+        @Nonnull\n+        public Physical rebase(final Map<CorrelationIdentifier, CorrelationIdentifier> translationMap) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6eb7142ab316ffbec53e375804118f722f1d2bcc"}, "originalPosition": 284}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgzMTMxMjk2OnYy", "diffSide": "RIGHT", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/Quantifier.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xM1QyMjoxMDozMlrOGw8ExQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMFQxNzowNDowMVrOG0XTaA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mzk2OTA5Mw==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * Create a builder for a physical quantifier containing record query plans.\n          \n          \n            \n                 * Create a builder for a physical quantifier over a {@link RecordQueryPlan}.", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/988#discussion_r453969093", "createdAt": "2020-07-13T22:10:32Z", "author": {"login": "nschiefer"}, "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/Quantifier.java", "diffHunk": "@@ -149,32 +303,60 @@ private Physical(@Nonnull final ExpressionRef<? extends RecordQueryPlan> rangesO\n             return rangesOver;\n         }\n \n+        @Nonnull\n+        public RecordQueryPlan getRangesOverPlan() {\n+            return getRangesOver().get();\n+        }\n+\n         @Override\n         @Nonnull\n         public String getShorthand() {\n             return \"\ud835\udcc5\";\n         }\n+\n+        @Override\n+        @Nonnull\n+        public String toString() {\n+            return rangesOver.toString();\n+        }\n+\n+        @Override\n+        @Nonnull\n+        public Physical rebase(final Map<CorrelationIdentifier, CorrelationIdentifier> translationMap) {\n+            return Quantifier.physicalBuilder()\n+                    .from(this)\n+                    .build(needsRebase(translationMap) ? getRangesOver().rebase(translationMap) : getRangesOver());\n+        }\n     }\n \n     /**\n-     * Factory method to create a physical quantifier over a given expression reference containing query plans.\n-     * @param rangesOver expression reference to {@link RecordQueryPlan}s\n-     * @return a physical quantifier ranging over the given reference\n+     * Create a builder for a physical quantifier containing record query plans.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6eb7142ab316ffbec53e375804118f722f1d2bcc"}, "originalPosition": 295}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzU2MDkzNg==", "bodyText": "The terminology is usually the expression on top contains the quantifier while the quantifier ranges over references and indirectly over other expressions.", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/988#discussion_r457560936", "createdAt": "2020-07-20T17:04:01Z", "author": {"login": "normen662"}, "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/Quantifier.java", "diffHunk": "@@ -149,32 +303,60 @@ private Physical(@Nonnull final ExpressionRef<? extends RecordQueryPlan> rangesO\n             return rangesOver;\n         }\n \n+        @Nonnull\n+        public RecordQueryPlan getRangesOverPlan() {\n+            return getRangesOver().get();\n+        }\n+\n         @Override\n         @Nonnull\n         public String getShorthand() {\n             return \"\ud835\udcc5\";\n         }\n+\n+        @Override\n+        @Nonnull\n+        public String toString() {\n+            return rangesOver.toString();\n+        }\n+\n+        @Override\n+        @Nonnull\n+        public Physical rebase(final Map<CorrelationIdentifier, CorrelationIdentifier> translationMap) {\n+            return Quantifier.physicalBuilder()\n+                    .from(this)\n+                    .build(needsRebase(translationMap) ? getRangesOver().rebase(translationMap) : getRangesOver());\n+        }\n     }\n \n     /**\n-     * Factory method to create a physical quantifier over a given expression reference containing query plans.\n-     * @param rangesOver expression reference to {@link RecordQueryPlan}s\n-     * @return a physical quantifier ranging over the given reference\n+     * Create a builder for a physical quantifier containing record query plans.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mzk2OTA5Mw=="}, "originalCommit": {"oid": "6eb7142ab316ffbec53e375804118f722f1d2bcc"}, "originalPosition": 295}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgzMTMxMzk3OnYy", "diffSide": "RIGHT", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/Quantifier.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xM1QyMjoxMDo0NVrOGw8FTw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xM1QyMjoxMDo0NVrOGw8FTw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mzk2OTIzMQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public static Physical physical(final ExpressionRef<? extends RecordQueryPlan> ref) {\n          \n          \n            \n                public static Physical physical(@Nonnull final ExpressionRef<? extends RecordQueryPlan> ref) {", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/988#discussion_r453969231", "createdAt": "2020-07-13T22:10:45Z", "author": {"login": "nschiefer"}, "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/Quantifier.java", "diffHunk": "@@ -149,32 +303,60 @@ private Physical(@Nonnull final ExpressionRef<? extends RecordQueryPlan> rangesO\n             return rangesOver;\n         }\n \n+        @Nonnull\n+        public RecordQueryPlan getRangesOverPlan() {\n+            return getRangesOver().get();\n+        }\n+\n         @Override\n         @Nonnull\n         public String getShorthand() {\n             return \"\ud835\udcc5\";\n         }\n+\n+        @Override\n+        @Nonnull\n+        public String toString() {\n+            return rangesOver.toString();\n+        }\n+\n+        @Override\n+        @Nonnull\n+        public Physical rebase(final Map<CorrelationIdentifier, CorrelationIdentifier> translationMap) {\n+            return Quantifier.physicalBuilder()\n+                    .from(this)\n+                    .build(needsRebase(translationMap) ? getRangesOver().rebase(translationMap) : getRangesOver());\n+        }\n     }\n \n     /**\n-     * Factory method to create a physical quantifier over a given expression reference containing query plans.\n-     * @param rangesOver expression reference to {@link RecordQueryPlan}s\n-     * @return a physical quantifier ranging over the given reference\n+     * Create a builder for a physical quantifier containing record query plans.\n+     * @return a physical quantifier builder\n      */\n+    public static Physical.PhysicalBuilder physicalBuilder() {\n+        return new Physical.PhysicalBuilder();\n+    }\n+\n+    public static Physical physical(final ExpressionRef<? extends RecordQueryPlan> ref) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6eb7142ab316ffbec53e375804118f722f1d2bcc"}, "originalPosition": 302}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgzMTMxNTIzOnYy", "diffSide": "RIGHT", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/Quantifier.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xM1QyMjoxMDo1OVrOGw8F6A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xM1QyMjoxMDo1OVrOGw8F6A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mzk2OTM4NA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public static Physical physical(final ExpressionRef<? extends RecordQueryPlan> ref, final CorrelationIdentifier alias) {\n          \n          \n            \n                public static Physical physical(@Nonnull final ExpressionRef<? extends RecordQueryPlan> ref, @Nonnull final CorrelationIdentifier alias) {", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/988#discussion_r453969384", "createdAt": "2020-07-13T22:10:59Z", "author": {"login": "nschiefer"}, "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/Quantifier.java", "diffHunk": "@@ -149,32 +303,60 @@ private Physical(@Nonnull final ExpressionRef<? extends RecordQueryPlan> rangesO\n             return rangesOver;\n         }\n \n+        @Nonnull\n+        public RecordQueryPlan getRangesOverPlan() {\n+            return getRangesOver().get();\n+        }\n+\n         @Override\n         @Nonnull\n         public String getShorthand() {\n             return \"\ud835\udcc5\";\n         }\n+\n+        @Override\n+        @Nonnull\n+        public String toString() {\n+            return rangesOver.toString();\n+        }\n+\n+        @Override\n+        @Nonnull\n+        public Physical rebase(final Map<CorrelationIdentifier, CorrelationIdentifier> translationMap) {\n+            return Quantifier.physicalBuilder()\n+                    .from(this)\n+                    .build(needsRebase(translationMap) ? getRangesOver().rebase(translationMap) : getRangesOver());\n+        }\n     }\n \n     /**\n-     * Factory method to create a physical quantifier over a given expression reference containing query plans.\n-     * @param rangesOver expression reference to {@link RecordQueryPlan}s\n-     * @return a physical quantifier ranging over the given reference\n+     * Create a builder for a physical quantifier containing record query plans.\n+     * @return a physical quantifier builder\n      */\n+    public static Physical.PhysicalBuilder physicalBuilder() {\n+        return new Physical.PhysicalBuilder();\n+    }\n+\n+    public static Physical physical(final ExpressionRef<? extends RecordQueryPlan> ref) {\n+        return physicalBuilder()\n+                .build(ref);\n+    }\n+\n     @Nonnull\n-    public static Physical physical(@Nonnull final ExpressionRef<? extends RecordQueryPlan> rangesOver) {\n-        return new Physical(rangesOver);\n+    public static Physical physical(final ExpressionRef<? extends RecordQueryPlan> ref, final CorrelationIdentifier alias) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6eb7142ab316ffbec53e375804118f722f1d2bcc"}, "originalPosition": 310}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgzMTMxNzM3OnYy", "diffSide": "RIGHT", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/Quantifier.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xM1QyMjoxMToyNFrOGw8G_A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xM1QyMjoxMToyNFrOGw8G_A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mzk2OTY2MA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public boolean resultEquals(final Object other, final BiMap<CorrelationIdentifier, CorrelationIdentifier> equivalenceMap) {\n          \n          \n            \n                public boolean resultEquals(@Nullable final Object other, @Nonnull final BiMap<CorrelationIdentifier, CorrelationIdentifier> equivalenceMap) {", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/988#discussion_r453969660", "createdAt": "2020-07-13T22:11:24Z", "author": {"login": "nschiefer"}, "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/Quantifier.java", "diffHunk": "@@ -214,20 +396,64 @@ public static Physical physical(@Nonnull final RecordQueryPlan rangesOverPlan) {\n         return null;\n     }\n \n+    @SuppressWarnings(\"EqualsWhichDoesntCheckParameterClass\")\n     @Override\n-    public boolean equals(final Object o) {\n-        if (this == o) {\n+    public boolean equals(final Object other) {\n+        return resultEquals(other, ImmutableBiMap.of());\n+    }\n+\n+    @Override\n+    public boolean resultEquals(final Object other, final BiMap<CorrelationIdentifier, CorrelationIdentifier> equivalenceMap) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6eb7142ab316ffbec53e375804118f722f1d2bcc"}, "originalPosition": 348}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgzMTMyMzgyOnYy", "diffSide": "RIGHT", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/Quantifier.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xM1QyMjoxMjo0OVrOGw8Klw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xM1QyMjoxMjo0OVrOGw8Klw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mzk3MDU4Mw==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                protected boolean needsRebase(final Map<CorrelationIdentifier, CorrelationIdentifier> translationMap) {\n          \n          \n            \n                protected boolean needsRebase(@Nonnull final Map<CorrelationIdentifier, CorrelationIdentifier> translationMap) {", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/988#discussion_r453970583", "createdAt": "2020-07-13T22:12:49Z", "author": {"login": "nschiefer"}, "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/Quantifier.java", "diffHunk": "@@ -214,20 +396,64 @@ public static Physical physical(@Nonnull final RecordQueryPlan rangesOverPlan) {\n         return null;\n     }\n \n+    @SuppressWarnings(\"EqualsWhichDoesntCheckParameterClass\")\n     @Override\n-    public boolean equals(final Object o) {\n-        if (this == o) {\n+    public boolean equals(final Object other) {\n+        return resultEquals(other, ImmutableBiMap.of());\n+    }\n+\n+    @Override\n+    public boolean resultEquals(final Object other, final BiMap<CorrelationIdentifier, CorrelationIdentifier> equivalenceMap) {\n+        if (this == other) {\n             return true;\n         }\n-        if (o == null || getClass() != o.getClass()) {\n+        if (other == null || getClass() != other.getClass()) {\n             return false;\n         }\n-        final Quantifier that = (Quantifier)o;\n-        return Objects.equals(getRangesOver(), that.getRangesOver());\n+        final Quantifier that = (Quantifier)other;\n+        return getRangesOver().resultEquals(that.getRangesOver(), equivalenceMap);\n+    }\n+\n+    public boolean equalsOnKind(final Object o) {\n+        if (this == o) {\n+            return true;\n+        }\n+        return o != null && getClass() == o.getClass();\n     }\n \n     @Override\n     public int hashCode() {\n-        return Objects.hash(getRangesOver());\n+        final ImmutableList<? extends RelationalExpression> relationalExpressions =\n+                ImmutableList.copyOf(getRangesOver().getMembers().iterator());\n+        return relationalExpressions.hashCode();\n+    }\n+\n+    @Override\n+    @Nonnull\n+    public String toString() {\n+        return getShorthand() + \" \" + getRangesOver().toString();\n+    }\n+\n+    @Nonnull\n+    @Override\n+    public Set<CorrelationIdentifier> getCorrelatedTo() {\n+        return correlatedToSupplier.get();\n+    }\n+\n+    /**\n+     * Helper to determine if anything that this quantifier ranges over is correlated to something that needs to be\n+     * rebased.\n+     * @param translationMap a map that expresses translations from correlations identifiers to correlation identifiers.\n+     * @return {@code true} if the graph this quantifier ranges over needs to be rebased given the translation map\n+     *         passed in, {@code false} otherwise\n+     */\n+    protected boolean needsRebase(final Map<CorrelationIdentifier, CorrelationIdentifier> translationMap) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6eb7142ab316ffbec53e375804118f722f1d2bcc"}, "originalPosition": 396}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgzMTMyNTIxOnYy", "diffSide": "RIGHT", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/Quantifier.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xM1QyMjoxMzowM1rOGw8LSQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xM1QyMjoxMzowM1rOGw8LSQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mzk3MDc2MQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    // translations are usually smaller, we may want to flip this around if needed later\n          \n          \n            \n                    // TODO translations are usually smaller, we may want to flip this around if needed later", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/988#discussion_r453970761", "createdAt": "2020-07-13T22:13:03Z", "author": {"login": "nschiefer"}, "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/Quantifier.java", "diffHunk": "@@ -214,20 +396,64 @@ public static Physical physical(@Nonnull final RecordQueryPlan rangesOverPlan) {\n         return null;\n     }\n \n+    @SuppressWarnings(\"EqualsWhichDoesntCheckParameterClass\")\n     @Override\n-    public boolean equals(final Object o) {\n-        if (this == o) {\n+    public boolean equals(final Object other) {\n+        return resultEquals(other, ImmutableBiMap.of());\n+    }\n+\n+    @Override\n+    public boolean resultEquals(final Object other, final BiMap<CorrelationIdentifier, CorrelationIdentifier> equivalenceMap) {\n+        if (this == other) {\n             return true;\n         }\n-        if (o == null || getClass() != o.getClass()) {\n+        if (other == null || getClass() != other.getClass()) {\n             return false;\n         }\n-        final Quantifier that = (Quantifier)o;\n-        return Objects.equals(getRangesOver(), that.getRangesOver());\n+        final Quantifier that = (Quantifier)other;\n+        return getRangesOver().resultEquals(that.getRangesOver(), equivalenceMap);\n+    }\n+\n+    public boolean equalsOnKind(final Object o) {\n+        if (this == o) {\n+            return true;\n+        }\n+        return o != null && getClass() == o.getClass();\n     }\n \n     @Override\n     public int hashCode() {\n-        return Objects.hash(getRangesOver());\n+        final ImmutableList<? extends RelationalExpression> relationalExpressions =\n+                ImmutableList.copyOf(getRangesOver().getMembers().iterator());\n+        return relationalExpressions.hashCode();\n+    }\n+\n+    @Override\n+    @Nonnull\n+    public String toString() {\n+        return getShorthand() + \" \" + getRangesOver().toString();\n+    }\n+\n+    @Nonnull\n+    @Override\n+    public Set<CorrelationIdentifier> getCorrelatedTo() {\n+        return correlatedToSupplier.get();\n+    }\n+\n+    /**\n+     * Helper to determine if anything that this quantifier ranges over is correlated to something that needs to be\n+     * rebased.\n+     * @param translationMap a map that expresses translations from correlations identifiers to correlation identifiers.\n+     * @return {@code true} if the graph this quantifier ranges over needs to be rebased given the translation map\n+     *         passed in, {@code false} otherwise\n+     */\n+    protected boolean needsRebase(final Map<CorrelationIdentifier, CorrelationIdentifier> translationMap) {\n+\n+        final Set<CorrelationIdentifier> correlatedTo = getCorrelatedTo();\n+\n+        // translations are usually smaller, we may want to flip this around if needed later", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6eb7142ab316ffbec53e375804118f722f1d2bcc"}, "originalPosition": 400}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgzMTM2Mjg4OnYy", "diffSide": "RIGHT", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/Quantifiers.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xM1QyMjoyMDowM1rOGw8d-Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xM1QyMjoyMDowM1rOGw8d-Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mzk3NTU0NQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * Convenience helper to create a single id translation map from the alias of one quantifier to the alias\n          \n          \n            \n                 * Convenience helper to create a single ID translation map from the alias of one quantifier to the alias", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/988#discussion_r453975545", "createdAt": "2020-07-13T22:20:03Z", "author": {"login": "nschiefer"}, "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/Quantifiers.java", "diffHunk": "@@ -87,6 +89,56 @@\n                 .collect(Collectors.toList());\n     }\n \n+    /**\n+     * Convenience helper to create a single id translation map from the alias of one quantifier to the alias", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6eb7142ab316ffbec53e375804118f722f1d2bcc"}, "originalPosition": 14}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgzMTM2NjIyOnYy", "diffSide": "RIGHT", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/Quantifiers.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xM1QyMjoyMDo0NlrOGw8fwQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMFQxNzowODowNVrOG0XcEw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mzk3NjAwMQ==", "bodyText": "I think that toIDMap is more idiomatic.\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public static BiMap<CorrelationIdentifier, CorrelationIdentifier> toIdMap(@Nonnull final BiMap<Quantifier, Quantifier> map) {\n          \n          \n            \n                public static BiMap<CorrelationIdentifier, CorrelationIdentifier> toIDMap(@Nonnull final BiMap<Quantifier, Quantifier> map) {", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/988#discussion_r453976001", "createdAt": "2020-07-13T22:20:46Z", "author": {"login": "nschiefer"}, "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/Quantifiers.java", "diffHunk": "@@ -87,6 +89,56 @@\n                 .collect(Collectors.toList());\n     }\n \n+    /**\n+     * Convenience helper to create a single id translation map from the alias of one quantifier to the alias\n+     * of another quantifier.\n+     * @param from quantifier\n+     * @param to quantifier\n+     * @return a new translation map mapping from {@code from.getAlias()} to {@code to.getAlias()}\n+     */\n+    @Nonnull\n+    public static BiMap<CorrelationIdentifier, CorrelationIdentifier> translate(@Nonnull final Quantifier from, @Nonnull final Quantifier to) {\n+        return ImmutableBiMap.of(from.getAlias(), to.getAlias());\n+    }\n+\n+    /**\n+     * Convenience helper to create an alias translation map based on a translation map using quantifiers.\n+     * of another quantifier.\n+     * @param map quantifier to quantifier bi-map\n+     * @return a new translation map mapping from {@code from.getAlias()} to {@code to.getAlias()}\n+     */\n+    @Nonnull\n+    public static BiMap<CorrelationIdentifier, CorrelationIdentifier> toIdMap(@Nonnull final BiMap<Quantifier, Quantifier> map) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6eb7142ab316ffbec53e375804118f722f1d2bcc"}, "originalPosition": 32}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mzk3ODI3Mw==", "bodyText": "These methods would all really benefit from an idiomatic name for the translation maps (see comments on Correlated).", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/988#discussion_r453978273", "createdAt": "2020-07-13T22:24:42Z", "author": {"login": "nschiefer"}, "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/Quantifiers.java", "diffHunk": "@@ -87,6 +89,56 @@\n                 .collect(Collectors.toList());\n     }\n \n+    /**\n+     * Convenience helper to create a single id translation map from the alias of one quantifier to the alias\n+     * of another quantifier.\n+     * @param from quantifier\n+     * @param to quantifier\n+     * @return a new translation map mapping from {@code from.getAlias()} to {@code to.getAlias()}\n+     */\n+    @Nonnull\n+    public static BiMap<CorrelationIdentifier, CorrelationIdentifier> translate(@Nonnull final Quantifier from, @Nonnull final Quantifier to) {\n+        return ImmutableBiMap.of(from.getAlias(), to.getAlias());\n+    }\n+\n+    /**\n+     * Convenience helper to create an alias translation map based on a translation map using quantifiers.\n+     * of another quantifier.\n+     * @param map quantifier to quantifier bi-map\n+     * @return a new translation map mapping from {@code from.getAlias()} to {@code to.getAlias()}\n+     */\n+    @Nonnull\n+    public static BiMap<CorrelationIdentifier, CorrelationIdentifier> toIdMap(@Nonnull final BiMap<Quantifier, Quantifier> map) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mzk3NjAwMQ=="}, "originalCommit": {"oid": "6eb7142ab316ffbec53e375804118f722f1d2bcc"}, "originalPosition": 32}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzU2MzE1NQ==", "bodyText": "It's called AliasMap now.", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/988#discussion_r457563155", "createdAt": "2020-07-20T17:08:05Z", "author": {"login": "normen662"}, "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/Quantifiers.java", "diffHunk": "@@ -87,6 +89,56 @@\n                 .collect(Collectors.toList());\n     }\n \n+    /**\n+     * Convenience helper to create a single id translation map from the alias of one quantifier to the alias\n+     * of another quantifier.\n+     * @param from quantifier\n+     * @param to quantifier\n+     * @return a new translation map mapping from {@code from.getAlias()} to {@code to.getAlias()}\n+     */\n+    @Nonnull\n+    public static BiMap<CorrelationIdentifier, CorrelationIdentifier> translate(@Nonnull final Quantifier from, @Nonnull final Quantifier to) {\n+        return ImmutableBiMap.of(from.getAlias(), to.getAlias());\n+    }\n+\n+    /**\n+     * Convenience helper to create an alias translation map based on a translation map using quantifiers.\n+     * of another quantifier.\n+     * @param map quantifier to quantifier bi-map\n+     * @return a new translation map mapping from {@code from.getAlias()} to {@code to.getAlias()}\n+     */\n+    @Nonnull\n+    public static BiMap<CorrelationIdentifier, CorrelationIdentifier> toIdMap(@Nonnull final BiMap<Quantifier, Quantifier> map) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mzk3NjAwMQ=="}, "originalCommit": {"oid": "6eb7142ab316ffbec53e375804118f722f1d2bcc"}, "originalPosition": 32}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgzMTM4OTM5OnYy", "diffSide": "RIGHT", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/RelationalExpression.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xM1QyMjoyNjoxNFrOGw8scw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMFQxOTo1NjoxNVrOG0dGig==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mzk3OTI1MQ==", "bodyText": "I think this method could use a Javadoc.", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/988#discussion_r453979251", "createdAt": "2020-07-13T22:26:14Z", "author": {"login": "nschiefer"}, "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/RelationalExpression.java", "diffHunk": "@@ -136,7 +148,160 @@ static RelationalExpression fromRecordQuery(@Nonnull RecordQuery query, @Nonnull\n     @Nonnull\n     List<? extends Quantifier> getQuantifiers();\n \n-    boolean equalsWithoutChildren(@Nonnull RelationalExpression otherExpression);\n+    default boolean canCorrelate() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6eb7142ab316ffbec53e375804118f722f1d2bcc"}, "originalPosition": 82}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzY1NTk0Ng==", "bodyText": "Done.", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/988#discussion_r457655946", "createdAt": "2020-07-20T19:56:15Z", "author": {"login": "normen662"}, "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/RelationalExpression.java", "diffHunk": "@@ -136,7 +148,160 @@ static RelationalExpression fromRecordQuery(@Nonnull RecordQuery query, @Nonnull\n     @Nonnull\n     List<? extends Quantifier> getQuantifiers();\n \n-    boolean equalsWithoutChildren(@Nonnull RelationalExpression otherExpression);\n+    default boolean canCorrelate() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mzk3OTI1MQ=="}, "originalCommit": {"oid": "6eb7142ab316ffbec53e375804118f722f1d2bcc"}, "originalPosition": 82}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgzMTQxNzExOnYy", "diffSide": "RIGHT", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/RelationalExpression.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xM1QyMjozMTozMlrOGw86dg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xM1QyMjozMTozMlrOGw86dg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mzk4MjgzOA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    // quantifier impose more or less a complete order leaving no room for many permutations among unrelated\n          \n          \n            \n                    // quantifier imposes more or less a complete order leaving no room for many permutations among unrelated", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/988#discussion_r453982838", "createdAt": "2020-07-13T22:31:32Z", "author": {"login": "nschiefer"}, "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/RelationalExpression.java", "diffHunk": "@@ -136,7 +148,160 @@ static RelationalExpression fromRecordQuery(@Nonnull RecordQuery query, @Nonnull\n     @Nonnull\n     List<? extends Quantifier> getQuantifiers();\n \n-    boolean equalsWithoutChildren(@Nonnull RelationalExpression otherExpression);\n+    default boolean canCorrelate() {\n+        return false;\n+    }\n+\n+    boolean equalsWithoutChildren(@Nonnull RelationalExpression otherExpression, final BiMap<CorrelationIdentifier, CorrelationIdentifier> equivalencesMap);\n+\n+    default Optional<BiMap<Quantifier, Quantifier>> resultEqualsQuantifiers(@Nonnull final Set<? extends Quantifier> otherQuantifiers,\n+                                                                            @Nonnull final BiMap<CorrelationIdentifier, CorrelationIdentifier> equivalenceMap) {\n+        return matchQuantifiers(otherQuantifiers,\n+                equivalenceMap,\n+                (quantifier, otherQuantifier, nestedEquivalenceMap) -> {\n+                    if (quantifier.hashCode() != otherQuantifier.hashCode()) {\n+                        return false;\n+                    }\n+                    return quantifier.resultEquals(otherQuantifier, nestedEquivalenceMap);\n+                });\n+    }\n+\n+    /**\n+     * An predicate that tests for a match between quantifiers also taking into account an equivalence maps between\n+     * {@link CorrelationIdentifier}s.\n+     */\n+    @FunctionalInterface\n+    interface MatchingPredicate {\n+        boolean test(@Nonnull Quantifier quantifier,\n+                     @Nonnull Quantifier otherQuantifier,\n+                     @Nonnull final BiMap<CorrelationIdentifier, CorrelationIdentifier> equivalencesMap);\n+    }\n+\n+\n+    /**\n+     * Method to match up the quantifiers this expression owns with the given set of other quantifiers and an\n+     * equivalence map.\n+     *\n+     * Two quantifiers can be considered equal if their extended equality method {@link Quantifier#resultEquals} returns\n+     * {@code true} for the given the correct equality map. This method attempts to match up each quantifier from the\n+     * set of quantifiers this expression owns to the given other set of quantifiers.\n+     *\n+     * Now this method returns an empty mapping if e.g. the number quantifiers in the respetive sets doesn't match.\n+     *\n+     * For expressions that cannot introduce correlations, this method is simply {@code O(n!)} where is the\n+     * number of quantifiers (which is equal for both sets). This path is taken by UNIONs and other set operations.\n+     *\n+     * For expressions that introduce correlations, the matching process is more complicated. First, we determine one\n+     * topologically correct ordering. Then we iterate through all topologically correct orderings of the set of\n+     * quantifiers this expression owns. For each element in the permutation of quantifiers that is returned by\n+     * the {@link com.apple.foundationdb.record.query.plan.temp.TopologicalSort.TopologicalOrderPermutationIterator}\n+     * we try to math the quantifiers between the sets topologically from left to right (using {@code predicate}).\n+     * For each match we find we add an equivalence between the alias of this and the other quantifier that matched\n+     * in an equivalence map that extends the given equivalence map.\n+     * @param otherQuantifiers other quantifiers\n+     * @param equivalencesMap equivalence map\n+     * @param predicate that tests if two quantifiers and their graph they range over can be considered equivalent\n+     * @return A bi-map containing a mapping from the quantifiers this expression owns to the quantifiers in\n+     *         {@code otherQuantifiers}. Note that the mapping is bijective and can therefore be inverted.\n+     */\n+    @SuppressWarnings({\"UnstableApiUsage\", \"squid:S135\"})\n+    default Optional<BiMap<Quantifier, Quantifier>> matchQuantifiers(@Nonnull Set<? extends Quantifier> otherQuantifiers,\n+                                                                     @Nonnull final BiMap<CorrelationIdentifier, CorrelationIdentifier> equivalencesMap,\n+                                                                     @Nonnull final MatchingPredicate predicate) {\n+        final List<? extends Quantifier> quantifiers = getQuantifiers();\n+        if (quantifiers.size() != otherQuantifiers.size()) {\n+            return Optional.empty();\n+        }\n+\n+        if (quantifiers.isEmpty()) {\n+            return Optional.of(ImmutableBiMap.of());\n+        }\n+\n+        //\n+        // We do not know which quantifier in \"this\" maps to which in \"other\". In fact, we cannot know as it is\n+        // intentionally modeled this way. We need to find _a_ feasible ordering that matches. In reality, the\n+        // quantifier impose more or less a complete order leaving no room for many permutations among unrelated", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6eb7142ab316ffbec53e375804118f722f1d2bcc"}, "originalPosition": 154}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgzMTQyMTI2OnYy", "diffSide": "RIGHT", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/RelationalExpression.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xM1QyMjozMjoyNFrOGw88qw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xM1QyMjozMjoyNFrOGw88qw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mzk4MzQwMw==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    // quantifiers. In the worst case, we must enumerate them all. Luckily, containsXXX() for children follow\n          \n          \n            \n                    // an early out approach, so the uninteresting case where sub-graphs underneath quantifiers do not match\n          \n          \n            \n                    // quantifiers. In the worst case, we must enumerate them all. Luckily, containsXXX() for children have\n          \n          \n            \n                    // short-circuit semantics, so the uninteresting case where sub-graphs underneath quantifiers do not match", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/988#discussion_r453983403", "createdAt": "2020-07-13T22:32:24Z", "author": {"login": "nschiefer"}, "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/RelationalExpression.java", "diffHunk": "@@ -136,7 +148,160 @@ static RelationalExpression fromRecordQuery(@Nonnull RecordQuery query, @Nonnull\n     @Nonnull\n     List<? extends Quantifier> getQuantifiers();\n \n-    boolean equalsWithoutChildren(@Nonnull RelationalExpression otherExpression);\n+    default boolean canCorrelate() {\n+        return false;\n+    }\n+\n+    boolean equalsWithoutChildren(@Nonnull RelationalExpression otherExpression, final BiMap<CorrelationIdentifier, CorrelationIdentifier> equivalencesMap);\n+\n+    default Optional<BiMap<Quantifier, Quantifier>> resultEqualsQuantifiers(@Nonnull final Set<? extends Quantifier> otherQuantifiers,\n+                                                                            @Nonnull final BiMap<CorrelationIdentifier, CorrelationIdentifier> equivalenceMap) {\n+        return matchQuantifiers(otherQuantifiers,\n+                equivalenceMap,\n+                (quantifier, otherQuantifier, nestedEquivalenceMap) -> {\n+                    if (quantifier.hashCode() != otherQuantifier.hashCode()) {\n+                        return false;\n+                    }\n+                    return quantifier.resultEquals(otherQuantifier, nestedEquivalenceMap);\n+                });\n+    }\n+\n+    /**\n+     * An predicate that tests for a match between quantifiers also taking into account an equivalence maps between\n+     * {@link CorrelationIdentifier}s.\n+     */\n+    @FunctionalInterface\n+    interface MatchingPredicate {\n+        boolean test(@Nonnull Quantifier quantifier,\n+                     @Nonnull Quantifier otherQuantifier,\n+                     @Nonnull final BiMap<CorrelationIdentifier, CorrelationIdentifier> equivalencesMap);\n+    }\n+\n+\n+    /**\n+     * Method to match up the quantifiers this expression owns with the given set of other quantifiers and an\n+     * equivalence map.\n+     *\n+     * Two quantifiers can be considered equal if their extended equality method {@link Quantifier#resultEquals} returns\n+     * {@code true} for the given the correct equality map. This method attempts to match up each quantifier from the\n+     * set of quantifiers this expression owns to the given other set of quantifiers.\n+     *\n+     * Now this method returns an empty mapping if e.g. the number quantifiers in the respetive sets doesn't match.\n+     *\n+     * For expressions that cannot introduce correlations, this method is simply {@code O(n!)} where is the\n+     * number of quantifiers (which is equal for both sets). This path is taken by UNIONs and other set operations.\n+     *\n+     * For expressions that introduce correlations, the matching process is more complicated. First, we determine one\n+     * topologically correct ordering. Then we iterate through all topologically correct orderings of the set of\n+     * quantifiers this expression owns. For each element in the permutation of quantifiers that is returned by\n+     * the {@link com.apple.foundationdb.record.query.plan.temp.TopologicalSort.TopologicalOrderPermutationIterator}\n+     * we try to math the quantifiers between the sets topologically from left to right (using {@code predicate}).\n+     * For each match we find we add an equivalence between the alias of this and the other quantifier that matched\n+     * in an equivalence map that extends the given equivalence map.\n+     * @param otherQuantifiers other quantifiers\n+     * @param equivalencesMap equivalence map\n+     * @param predicate that tests if two quantifiers and their graph they range over can be considered equivalent\n+     * @return A bi-map containing a mapping from the quantifiers this expression owns to the quantifiers in\n+     *         {@code otherQuantifiers}. Note that the mapping is bijective and can therefore be inverted.\n+     */\n+    @SuppressWarnings({\"UnstableApiUsage\", \"squid:S135\"})\n+    default Optional<BiMap<Quantifier, Quantifier>> matchQuantifiers(@Nonnull Set<? extends Quantifier> otherQuantifiers,\n+                                                                     @Nonnull final BiMap<CorrelationIdentifier, CorrelationIdentifier> equivalencesMap,\n+                                                                     @Nonnull final MatchingPredicate predicate) {\n+        final List<? extends Quantifier> quantifiers = getQuantifiers();\n+        if (quantifiers.size() != otherQuantifiers.size()) {\n+            return Optional.empty();\n+        }\n+\n+        if (quantifiers.isEmpty()) {\n+            return Optional.of(ImmutableBiMap.of());\n+        }\n+\n+        //\n+        // We do not know which quantifier in \"this\" maps to which in \"other\". In fact, we cannot know as it is\n+        // intentionally modeled this way. We need to find _a_ feasible ordering that matches. In reality, the\n+        // quantifier impose more or less a complete order leaving no room for many permutations among unrelated\n+        // quantifiers. In the worst case, we must enumerate them all. Luckily, containsXXX() for children follow\n+        // an early out approach, so the uninteresting case where sub-graphs underneath quantifiers do not match", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6eb7142ab316ffbec53e375804118f722f1d2bcc"}, "originalPosition": 156}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgzMTQyMzQ3OnYy", "diffSide": "RIGHT", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/RelationalExpression.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xM1QyMjozMjo1NlrOGw898Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMFQxOTo1OToyM1rOG0dNLg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mzk4MzcyOQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            otherQuantifiers.stream()\n          \n          \n            \n                                    .collect(Collectors.toMap(Quantifier::getAlias, Function.identity()));\n          \n          \n            \n                            otherQuantifiers.stream().collect(Collectors.toMap(Quantifier::getAlias, Function.identity()));", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/988#discussion_r453983729", "createdAt": "2020-07-13T22:32:56Z", "author": {"login": "nschiefer"}, "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/RelationalExpression.java", "diffHunk": "@@ -136,7 +148,160 @@ static RelationalExpression fromRecordQuery(@Nonnull RecordQuery query, @Nonnull\n     @Nonnull\n     List<? extends Quantifier> getQuantifiers();\n \n-    boolean equalsWithoutChildren(@Nonnull RelationalExpression otherExpression);\n+    default boolean canCorrelate() {\n+        return false;\n+    }\n+\n+    boolean equalsWithoutChildren(@Nonnull RelationalExpression otherExpression, final BiMap<CorrelationIdentifier, CorrelationIdentifier> equivalencesMap);\n+\n+    default Optional<BiMap<Quantifier, Quantifier>> resultEqualsQuantifiers(@Nonnull final Set<? extends Quantifier> otherQuantifiers,\n+                                                                            @Nonnull final BiMap<CorrelationIdentifier, CorrelationIdentifier> equivalenceMap) {\n+        return matchQuantifiers(otherQuantifiers,\n+                equivalenceMap,\n+                (quantifier, otherQuantifier, nestedEquivalenceMap) -> {\n+                    if (quantifier.hashCode() != otherQuantifier.hashCode()) {\n+                        return false;\n+                    }\n+                    return quantifier.resultEquals(otherQuantifier, nestedEquivalenceMap);\n+                });\n+    }\n+\n+    /**\n+     * An predicate that tests for a match between quantifiers also taking into account an equivalence maps between\n+     * {@link CorrelationIdentifier}s.\n+     */\n+    @FunctionalInterface\n+    interface MatchingPredicate {\n+        boolean test(@Nonnull Quantifier quantifier,\n+                     @Nonnull Quantifier otherQuantifier,\n+                     @Nonnull final BiMap<CorrelationIdentifier, CorrelationIdentifier> equivalencesMap);\n+    }\n+\n+\n+    /**\n+     * Method to match up the quantifiers this expression owns with the given set of other quantifiers and an\n+     * equivalence map.\n+     *\n+     * Two quantifiers can be considered equal if their extended equality method {@link Quantifier#resultEquals} returns\n+     * {@code true} for the given the correct equality map. This method attempts to match up each quantifier from the\n+     * set of quantifiers this expression owns to the given other set of quantifiers.\n+     *\n+     * Now this method returns an empty mapping if e.g. the number quantifiers in the respetive sets doesn't match.\n+     *\n+     * For expressions that cannot introduce correlations, this method is simply {@code O(n!)} where is the\n+     * number of quantifiers (which is equal for both sets). This path is taken by UNIONs and other set operations.\n+     *\n+     * For expressions that introduce correlations, the matching process is more complicated. First, we determine one\n+     * topologically correct ordering. Then we iterate through all topologically correct orderings of the set of\n+     * quantifiers this expression owns. For each element in the permutation of quantifiers that is returned by\n+     * the {@link com.apple.foundationdb.record.query.plan.temp.TopologicalSort.TopologicalOrderPermutationIterator}\n+     * we try to math the quantifiers between the sets topologically from left to right (using {@code predicate}).\n+     * For each match we find we add an equivalence between the alias of this and the other quantifier that matched\n+     * in an equivalence map that extends the given equivalence map.\n+     * @param otherQuantifiers other quantifiers\n+     * @param equivalencesMap equivalence map\n+     * @param predicate that tests if two quantifiers and their graph they range over can be considered equivalent\n+     * @return A bi-map containing a mapping from the quantifiers this expression owns to the quantifiers in\n+     *         {@code otherQuantifiers}. Note that the mapping is bijective and can therefore be inverted.\n+     */\n+    @SuppressWarnings({\"UnstableApiUsage\", \"squid:S135\"})\n+    default Optional<BiMap<Quantifier, Quantifier>> matchQuantifiers(@Nonnull Set<? extends Quantifier> otherQuantifiers,\n+                                                                     @Nonnull final BiMap<CorrelationIdentifier, CorrelationIdentifier> equivalencesMap,\n+                                                                     @Nonnull final MatchingPredicate predicate) {\n+        final List<? extends Quantifier> quantifiers = getQuantifiers();\n+        if (quantifiers.size() != otherQuantifiers.size()) {\n+            return Optional.empty();\n+        }\n+\n+        if (quantifiers.isEmpty()) {\n+            return Optional.of(ImmutableBiMap.of());\n+        }\n+\n+        //\n+        // We do not know which quantifier in \"this\" maps to which in \"other\". In fact, we cannot know as it is\n+        // intentionally modeled this way. We need to find _a_ feasible ordering that matches. In reality, the\n+        // quantifier impose more or less a complete order leaving no room for many permutations among unrelated\n+        // quantifiers. In the worst case, we must enumerate them all. Luckily, containsXXX() for children follow\n+        // an early out approach, so the uninteresting case where sub-graphs underneath quantifiers do not match\n+        // should be skipped quickly.\n+        //\n+        // Note: quantifiers implement equals() and hashCode() using the entire sub-graph they range over. That is\n+        // overkill here, since the quantifiers are owned by only one expression on each side, we should just use\n+        // alias-based equivalence.\n+        //\n+        \n+        // get _a_ topologically-sound permutation from other\n+        final Map<CorrelationIdentifier, ? extends Quantifier> otherAliasToQuantifierMap =\n+                otherQuantifiers.stream()\n+                        .collect(Collectors.toMap(Quantifier::getAlias, Function.identity()));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6eb7142ab316ffbec53e375804118f722f1d2bcc"}, "originalPosition": 167}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzY1NzY0Ng==", "bodyText": "Is it acceptable to leave it as such?", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/988#discussion_r457657646", "createdAt": "2020-07-20T19:59:23Z", "author": {"login": "normen662"}, "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/RelationalExpression.java", "diffHunk": "@@ -136,7 +148,160 @@ static RelationalExpression fromRecordQuery(@Nonnull RecordQuery query, @Nonnull\n     @Nonnull\n     List<? extends Quantifier> getQuantifiers();\n \n-    boolean equalsWithoutChildren(@Nonnull RelationalExpression otherExpression);\n+    default boolean canCorrelate() {\n+        return false;\n+    }\n+\n+    boolean equalsWithoutChildren(@Nonnull RelationalExpression otherExpression, final BiMap<CorrelationIdentifier, CorrelationIdentifier> equivalencesMap);\n+\n+    default Optional<BiMap<Quantifier, Quantifier>> resultEqualsQuantifiers(@Nonnull final Set<? extends Quantifier> otherQuantifiers,\n+                                                                            @Nonnull final BiMap<CorrelationIdentifier, CorrelationIdentifier> equivalenceMap) {\n+        return matchQuantifiers(otherQuantifiers,\n+                equivalenceMap,\n+                (quantifier, otherQuantifier, nestedEquivalenceMap) -> {\n+                    if (quantifier.hashCode() != otherQuantifier.hashCode()) {\n+                        return false;\n+                    }\n+                    return quantifier.resultEquals(otherQuantifier, nestedEquivalenceMap);\n+                });\n+    }\n+\n+    /**\n+     * An predicate that tests for a match between quantifiers also taking into account an equivalence maps between\n+     * {@link CorrelationIdentifier}s.\n+     */\n+    @FunctionalInterface\n+    interface MatchingPredicate {\n+        boolean test(@Nonnull Quantifier quantifier,\n+                     @Nonnull Quantifier otherQuantifier,\n+                     @Nonnull final BiMap<CorrelationIdentifier, CorrelationIdentifier> equivalencesMap);\n+    }\n+\n+\n+    /**\n+     * Method to match up the quantifiers this expression owns with the given set of other quantifiers and an\n+     * equivalence map.\n+     *\n+     * Two quantifiers can be considered equal if their extended equality method {@link Quantifier#resultEquals} returns\n+     * {@code true} for the given the correct equality map. This method attempts to match up each quantifier from the\n+     * set of quantifiers this expression owns to the given other set of quantifiers.\n+     *\n+     * Now this method returns an empty mapping if e.g. the number quantifiers in the respetive sets doesn't match.\n+     *\n+     * For expressions that cannot introduce correlations, this method is simply {@code O(n!)} where is the\n+     * number of quantifiers (which is equal for both sets). This path is taken by UNIONs and other set operations.\n+     *\n+     * For expressions that introduce correlations, the matching process is more complicated. First, we determine one\n+     * topologically correct ordering. Then we iterate through all topologically correct orderings of the set of\n+     * quantifiers this expression owns. For each element in the permutation of quantifiers that is returned by\n+     * the {@link com.apple.foundationdb.record.query.plan.temp.TopologicalSort.TopologicalOrderPermutationIterator}\n+     * we try to math the quantifiers between the sets topologically from left to right (using {@code predicate}).\n+     * For each match we find we add an equivalence between the alias of this and the other quantifier that matched\n+     * in an equivalence map that extends the given equivalence map.\n+     * @param otherQuantifiers other quantifiers\n+     * @param equivalencesMap equivalence map\n+     * @param predicate that tests if two quantifiers and their graph they range over can be considered equivalent\n+     * @return A bi-map containing a mapping from the quantifiers this expression owns to the quantifiers in\n+     *         {@code otherQuantifiers}. Note that the mapping is bijective and can therefore be inverted.\n+     */\n+    @SuppressWarnings({\"UnstableApiUsage\", \"squid:S135\"})\n+    default Optional<BiMap<Quantifier, Quantifier>> matchQuantifiers(@Nonnull Set<? extends Quantifier> otherQuantifiers,\n+                                                                     @Nonnull final BiMap<CorrelationIdentifier, CorrelationIdentifier> equivalencesMap,\n+                                                                     @Nonnull final MatchingPredicate predicate) {\n+        final List<? extends Quantifier> quantifiers = getQuantifiers();\n+        if (quantifiers.size() != otherQuantifiers.size()) {\n+            return Optional.empty();\n+        }\n+\n+        if (quantifiers.isEmpty()) {\n+            return Optional.of(ImmutableBiMap.of());\n+        }\n+\n+        //\n+        // We do not know which quantifier in \"this\" maps to which in \"other\". In fact, we cannot know as it is\n+        // intentionally modeled this way. We need to find _a_ feasible ordering that matches. In reality, the\n+        // quantifier impose more or less a complete order leaving no room for many permutations among unrelated\n+        // quantifiers. In the worst case, we must enumerate them all. Luckily, containsXXX() for children follow\n+        // an early out approach, so the uninteresting case where sub-graphs underneath quantifiers do not match\n+        // should be skipped quickly.\n+        //\n+        // Note: quantifiers implement equals() and hashCode() using the entire sub-graph they range over. That is\n+        // overkill here, since the quantifiers are owned by only one expression on each side, we should just use\n+        // alias-based equivalence.\n+        //\n+        \n+        // get _a_ topologically-sound permutation from other\n+        final Map<CorrelationIdentifier, ? extends Quantifier> otherAliasToQuantifierMap =\n+                otherQuantifiers.stream()\n+                        .collect(Collectors.toMap(Quantifier::getAlias, Function.identity()));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mzk4MzcyOQ=="}, "originalCommit": {"oid": "6eb7142ab316ffbec53e375804118f722f1d2bcc"}, "originalPosition": 167}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgzMTQ0NTQzOnYy", "diffSide": "RIGHT", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/RelationalExpression.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xM1QyMjozNzozMlrOGw9Jdg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMFQyMDowMDo1M1rOG0dQUw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mzk4NjY3OA==", "bodyText": "Perhaps we can get this from otherAliasToQuantifierMap.getKeySet()?", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/988#discussion_r453986678", "createdAt": "2020-07-13T22:37:32Z", "author": {"login": "nschiefer"}, "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/RelationalExpression.java", "diffHunk": "@@ -136,7 +148,160 @@ static RelationalExpression fromRecordQuery(@Nonnull RecordQuery query, @Nonnull\n     @Nonnull\n     List<? extends Quantifier> getQuantifiers();\n \n-    boolean equalsWithoutChildren(@Nonnull RelationalExpression otherExpression);\n+    default boolean canCorrelate() {\n+        return false;\n+    }\n+\n+    boolean equalsWithoutChildren(@Nonnull RelationalExpression otherExpression, final BiMap<CorrelationIdentifier, CorrelationIdentifier> equivalencesMap);\n+\n+    default Optional<BiMap<Quantifier, Quantifier>> resultEqualsQuantifiers(@Nonnull final Set<? extends Quantifier> otherQuantifiers,\n+                                                                            @Nonnull final BiMap<CorrelationIdentifier, CorrelationIdentifier> equivalenceMap) {\n+        return matchQuantifiers(otherQuantifiers,\n+                equivalenceMap,\n+                (quantifier, otherQuantifier, nestedEquivalenceMap) -> {\n+                    if (quantifier.hashCode() != otherQuantifier.hashCode()) {\n+                        return false;\n+                    }\n+                    return quantifier.resultEquals(otherQuantifier, nestedEquivalenceMap);\n+                });\n+    }\n+\n+    /**\n+     * An predicate that tests for a match between quantifiers also taking into account an equivalence maps between\n+     * {@link CorrelationIdentifier}s.\n+     */\n+    @FunctionalInterface\n+    interface MatchingPredicate {\n+        boolean test(@Nonnull Quantifier quantifier,\n+                     @Nonnull Quantifier otherQuantifier,\n+                     @Nonnull final BiMap<CorrelationIdentifier, CorrelationIdentifier> equivalencesMap);\n+    }\n+\n+\n+    /**\n+     * Method to match up the quantifiers this expression owns with the given set of other quantifiers and an\n+     * equivalence map.\n+     *\n+     * Two quantifiers can be considered equal if their extended equality method {@link Quantifier#resultEquals} returns\n+     * {@code true} for the given the correct equality map. This method attempts to match up each quantifier from the\n+     * set of quantifiers this expression owns to the given other set of quantifiers.\n+     *\n+     * Now this method returns an empty mapping if e.g. the number quantifiers in the respetive sets doesn't match.\n+     *\n+     * For expressions that cannot introduce correlations, this method is simply {@code O(n!)} where is the\n+     * number of quantifiers (which is equal for both sets). This path is taken by UNIONs and other set operations.\n+     *\n+     * For expressions that introduce correlations, the matching process is more complicated. First, we determine one\n+     * topologically correct ordering. Then we iterate through all topologically correct orderings of the set of\n+     * quantifiers this expression owns. For each element in the permutation of quantifiers that is returned by\n+     * the {@link com.apple.foundationdb.record.query.plan.temp.TopologicalSort.TopologicalOrderPermutationIterator}\n+     * we try to math the quantifiers between the sets topologically from left to right (using {@code predicate}).\n+     * For each match we find we add an equivalence between the alias of this and the other quantifier that matched\n+     * in an equivalence map that extends the given equivalence map.\n+     * @param otherQuantifiers other quantifiers\n+     * @param equivalencesMap equivalence map\n+     * @param predicate that tests if two quantifiers and their graph they range over can be considered equivalent\n+     * @return A bi-map containing a mapping from the quantifiers this expression owns to the quantifiers in\n+     *         {@code otherQuantifiers}. Note that the mapping is bijective and can therefore be inverted.\n+     */\n+    @SuppressWarnings({\"UnstableApiUsage\", \"squid:S135\"})\n+    default Optional<BiMap<Quantifier, Quantifier>> matchQuantifiers(@Nonnull Set<? extends Quantifier> otherQuantifiers,\n+                                                                     @Nonnull final BiMap<CorrelationIdentifier, CorrelationIdentifier> equivalencesMap,\n+                                                                     @Nonnull final MatchingPredicate predicate) {\n+        final List<? extends Quantifier> quantifiers = getQuantifiers();\n+        if (quantifiers.size() != otherQuantifiers.size()) {\n+            return Optional.empty();\n+        }\n+\n+        if (quantifiers.isEmpty()) {\n+            return Optional.of(ImmutableBiMap.of());\n+        }\n+\n+        //\n+        // We do not know which quantifier in \"this\" maps to which in \"other\". In fact, we cannot know as it is\n+        // intentionally modeled this way. We need to find _a_ feasible ordering that matches. In reality, the\n+        // quantifier impose more or less a complete order leaving no room for many permutations among unrelated\n+        // quantifiers. In the worst case, we must enumerate them all. Luckily, containsXXX() for children follow\n+        // an early out approach, so the uninteresting case where sub-graphs underneath quantifiers do not match\n+        // should be skipped quickly.\n+        //\n+        // Note: quantifiers implement equals() and hashCode() using the entire sub-graph they range over. That is\n+        // overkill here, since the quantifiers are owned by only one expression on each side, we should just use\n+        // alias-based equivalence.\n+        //\n+        \n+        // get _a_ topologically-sound permutation from other\n+        final Map<CorrelationIdentifier, ? extends Quantifier> otherAliasToQuantifierMap =\n+                otherQuantifiers.stream()\n+                        .collect(Collectors.toMap(Quantifier::getAlias, Function.identity()));\n+\n+        final Optional<List<CorrelationIdentifier>> otherOrderedOptional =\n+                TopologicalSort.anyTopologicalOrderPermutation(\n+                        otherQuantifiers.stream()\n+                                .map(Quantifier::getAlias)\n+                                .collect(Collectors.toSet()),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6eb7142ab316ffbec53e375804118f722f1d2bcc"}, "originalPosition": 173}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzY1ODQ1MQ==", "bodyText": "It's done.", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/988#discussion_r457658451", "createdAt": "2020-07-20T20:00:53Z", "author": {"login": "normen662"}, "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/RelationalExpression.java", "diffHunk": "@@ -136,7 +148,160 @@ static RelationalExpression fromRecordQuery(@Nonnull RecordQuery query, @Nonnull\n     @Nonnull\n     List<? extends Quantifier> getQuantifiers();\n \n-    boolean equalsWithoutChildren(@Nonnull RelationalExpression otherExpression);\n+    default boolean canCorrelate() {\n+        return false;\n+    }\n+\n+    boolean equalsWithoutChildren(@Nonnull RelationalExpression otherExpression, final BiMap<CorrelationIdentifier, CorrelationIdentifier> equivalencesMap);\n+\n+    default Optional<BiMap<Quantifier, Quantifier>> resultEqualsQuantifiers(@Nonnull final Set<? extends Quantifier> otherQuantifiers,\n+                                                                            @Nonnull final BiMap<CorrelationIdentifier, CorrelationIdentifier> equivalenceMap) {\n+        return matchQuantifiers(otherQuantifiers,\n+                equivalenceMap,\n+                (quantifier, otherQuantifier, nestedEquivalenceMap) -> {\n+                    if (quantifier.hashCode() != otherQuantifier.hashCode()) {\n+                        return false;\n+                    }\n+                    return quantifier.resultEquals(otherQuantifier, nestedEquivalenceMap);\n+                });\n+    }\n+\n+    /**\n+     * An predicate that tests for a match between quantifiers also taking into account an equivalence maps between\n+     * {@link CorrelationIdentifier}s.\n+     */\n+    @FunctionalInterface\n+    interface MatchingPredicate {\n+        boolean test(@Nonnull Quantifier quantifier,\n+                     @Nonnull Quantifier otherQuantifier,\n+                     @Nonnull final BiMap<CorrelationIdentifier, CorrelationIdentifier> equivalencesMap);\n+    }\n+\n+\n+    /**\n+     * Method to match up the quantifiers this expression owns with the given set of other quantifiers and an\n+     * equivalence map.\n+     *\n+     * Two quantifiers can be considered equal if their extended equality method {@link Quantifier#resultEquals} returns\n+     * {@code true} for the given the correct equality map. This method attempts to match up each quantifier from the\n+     * set of quantifiers this expression owns to the given other set of quantifiers.\n+     *\n+     * Now this method returns an empty mapping if e.g. the number quantifiers in the respetive sets doesn't match.\n+     *\n+     * For expressions that cannot introduce correlations, this method is simply {@code O(n!)} where is the\n+     * number of quantifiers (which is equal for both sets). This path is taken by UNIONs and other set operations.\n+     *\n+     * For expressions that introduce correlations, the matching process is more complicated. First, we determine one\n+     * topologically correct ordering. Then we iterate through all topologically correct orderings of the set of\n+     * quantifiers this expression owns. For each element in the permutation of quantifiers that is returned by\n+     * the {@link com.apple.foundationdb.record.query.plan.temp.TopologicalSort.TopologicalOrderPermutationIterator}\n+     * we try to math the quantifiers between the sets topologically from left to right (using {@code predicate}).\n+     * For each match we find we add an equivalence between the alias of this and the other quantifier that matched\n+     * in an equivalence map that extends the given equivalence map.\n+     * @param otherQuantifiers other quantifiers\n+     * @param equivalencesMap equivalence map\n+     * @param predicate that tests if two quantifiers and their graph they range over can be considered equivalent\n+     * @return A bi-map containing a mapping from the quantifiers this expression owns to the quantifiers in\n+     *         {@code otherQuantifiers}. Note that the mapping is bijective and can therefore be inverted.\n+     */\n+    @SuppressWarnings({\"UnstableApiUsage\", \"squid:S135\"})\n+    default Optional<BiMap<Quantifier, Quantifier>> matchQuantifiers(@Nonnull Set<? extends Quantifier> otherQuantifiers,\n+                                                                     @Nonnull final BiMap<CorrelationIdentifier, CorrelationIdentifier> equivalencesMap,\n+                                                                     @Nonnull final MatchingPredicate predicate) {\n+        final List<? extends Quantifier> quantifiers = getQuantifiers();\n+        if (quantifiers.size() != otherQuantifiers.size()) {\n+            return Optional.empty();\n+        }\n+\n+        if (quantifiers.isEmpty()) {\n+            return Optional.of(ImmutableBiMap.of());\n+        }\n+\n+        //\n+        // We do not know which quantifier in \"this\" maps to which in \"other\". In fact, we cannot know as it is\n+        // intentionally modeled this way. We need to find _a_ feasible ordering that matches. In reality, the\n+        // quantifier impose more or less a complete order leaving no room for many permutations among unrelated\n+        // quantifiers. In the worst case, we must enumerate them all. Luckily, containsXXX() for children follow\n+        // an early out approach, so the uninteresting case where sub-graphs underneath quantifiers do not match\n+        // should be skipped quickly.\n+        //\n+        // Note: quantifiers implement equals() and hashCode() using the entire sub-graph they range over. That is\n+        // overkill here, since the quantifiers are owned by only one expression on each side, we should just use\n+        // alias-based equivalence.\n+        //\n+        \n+        // get _a_ topologically-sound permutation from other\n+        final Map<CorrelationIdentifier, ? extends Quantifier> otherAliasToQuantifierMap =\n+                otherQuantifiers.stream()\n+                        .collect(Collectors.toMap(Quantifier::getAlias, Function.identity()));\n+\n+        final Optional<List<CorrelationIdentifier>> otherOrderedOptional =\n+                TopologicalSort.anyTopologicalOrderPermutation(\n+                        otherQuantifiers.stream()\n+                                .map(Quantifier::getAlias)\n+                                .collect(Collectors.toSet()),", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mzk4NjY3OA=="}, "originalCommit": {"oid": "6eb7142ab316ffbec53e375804118f722f1d2bcc"}, "originalPosition": 173}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgzMTQ0Njg4OnYy", "diffSide": "RIGHT", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/RelationalExpression.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xM1QyMjozODowM1rOGw9KVA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xM1QyMjozODowM1rOGw9KVA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mzk4NjkwMA==", "bodyText": "I think we should add a comment here explaining why this exists (that is, because a topological order always exists).", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/988#discussion_r453986900", "createdAt": "2020-07-13T22:38:03Z", "author": {"login": "nschiefer"}, "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/RelationalExpression.java", "diffHunk": "@@ -136,7 +148,160 @@ static RelationalExpression fromRecordQuery(@Nonnull RecordQuery query, @Nonnull\n     @Nonnull\n     List<? extends Quantifier> getQuantifiers();\n \n-    boolean equalsWithoutChildren(@Nonnull RelationalExpression otherExpression);\n+    default boolean canCorrelate() {\n+        return false;\n+    }\n+\n+    boolean equalsWithoutChildren(@Nonnull RelationalExpression otherExpression, final BiMap<CorrelationIdentifier, CorrelationIdentifier> equivalencesMap);\n+\n+    default Optional<BiMap<Quantifier, Quantifier>> resultEqualsQuantifiers(@Nonnull final Set<? extends Quantifier> otherQuantifiers,\n+                                                                            @Nonnull final BiMap<CorrelationIdentifier, CorrelationIdentifier> equivalenceMap) {\n+        return matchQuantifiers(otherQuantifiers,\n+                equivalenceMap,\n+                (quantifier, otherQuantifier, nestedEquivalenceMap) -> {\n+                    if (quantifier.hashCode() != otherQuantifier.hashCode()) {\n+                        return false;\n+                    }\n+                    return quantifier.resultEquals(otherQuantifier, nestedEquivalenceMap);\n+                });\n+    }\n+\n+    /**\n+     * An predicate that tests for a match between quantifiers also taking into account an equivalence maps between\n+     * {@link CorrelationIdentifier}s.\n+     */\n+    @FunctionalInterface\n+    interface MatchingPredicate {\n+        boolean test(@Nonnull Quantifier quantifier,\n+                     @Nonnull Quantifier otherQuantifier,\n+                     @Nonnull final BiMap<CorrelationIdentifier, CorrelationIdentifier> equivalencesMap);\n+    }\n+\n+\n+    /**\n+     * Method to match up the quantifiers this expression owns with the given set of other quantifiers and an\n+     * equivalence map.\n+     *\n+     * Two quantifiers can be considered equal if their extended equality method {@link Quantifier#resultEquals} returns\n+     * {@code true} for the given the correct equality map. This method attempts to match up each quantifier from the\n+     * set of quantifiers this expression owns to the given other set of quantifiers.\n+     *\n+     * Now this method returns an empty mapping if e.g. the number quantifiers in the respetive sets doesn't match.\n+     *\n+     * For expressions that cannot introduce correlations, this method is simply {@code O(n!)} where is the\n+     * number of quantifiers (which is equal for both sets). This path is taken by UNIONs and other set operations.\n+     *\n+     * For expressions that introduce correlations, the matching process is more complicated. First, we determine one\n+     * topologically correct ordering. Then we iterate through all topologically correct orderings of the set of\n+     * quantifiers this expression owns. For each element in the permutation of quantifiers that is returned by\n+     * the {@link com.apple.foundationdb.record.query.plan.temp.TopologicalSort.TopologicalOrderPermutationIterator}\n+     * we try to math the quantifiers between the sets topologically from left to right (using {@code predicate}).\n+     * For each match we find we add an equivalence between the alias of this and the other quantifier that matched\n+     * in an equivalence map that extends the given equivalence map.\n+     * @param otherQuantifiers other quantifiers\n+     * @param equivalencesMap equivalence map\n+     * @param predicate that tests if two quantifiers and their graph they range over can be considered equivalent\n+     * @return A bi-map containing a mapping from the quantifiers this expression owns to the quantifiers in\n+     *         {@code otherQuantifiers}. Note that the mapping is bijective and can therefore be inverted.\n+     */\n+    @SuppressWarnings({\"UnstableApiUsage\", \"squid:S135\"})\n+    default Optional<BiMap<Quantifier, Quantifier>> matchQuantifiers(@Nonnull Set<? extends Quantifier> otherQuantifiers,\n+                                                                     @Nonnull final BiMap<CorrelationIdentifier, CorrelationIdentifier> equivalencesMap,\n+                                                                     @Nonnull final MatchingPredicate predicate) {\n+        final List<? extends Quantifier> quantifiers = getQuantifiers();\n+        if (quantifiers.size() != otherQuantifiers.size()) {\n+            return Optional.empty();\n+        }\n+\n+        if (quantifiers.isEmpty()) {\n+            return Optional.of(ImmutableBiMap.of());\n+        }\n+\n+        //\n+        // We do not know which quantifier in \"this\" maps to which in \"other\". In fact, we cannot know as it is\n+        // intentionally modeled this way. We need to find _a_ feasible ordering that matches. In reality, the\n+        // quantifier impose more or less a complete order leaving no room for many permutations among unrelated\n+        // quantifiers. In the worst case, we must enumerate them all. Luckily, containsXXX() for children follow\n+        // an early out approach, so the uninteresting case where sub-graphs underneath quantifiers do not match\n+        // should be skipped quickly.\n+        //\n+        // Note: quantifiers implement equals() and hashCode() using the entire sub-graph they range over. That is\n+        // overkill here, since the quantifiers are owned by only one expression on each side, we should just use\n+        // alias-based equivalence.\n+        //\n+        \n+        // get _a_ topologically-sound permutation from other\n+        final Map<CorrelationIdentifier, ? extends Quantifier> otherAliasToQuantifierMap =\n+                otherQuantifiers.stream()\n+                        .collect(Collectors.toMap(Quantifier::getAlias, Function.identity()));\n+\n+        final Optional<List<CorrelationIdentifier>> otherOrderedOptional =\n+                TopologicalSort.anyTopologicalOrderPermutation(\n+                        otherQuantifiers.stream()\n+                                .map(Quantifier::getAlias)\n+                                .collect(Collectors.toSet()),\n+                        alias -> Objects.requireNonNull(otherAliasToQuantifierMap.get(alias)).getCorrelatedTo());\n+\n+        Verify.verify(otherOrderedOptional.isPresent());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6eb7142ab316ffbec53e375804118f722f1d2bcc"}, "originalPosition": 176}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgzMTQ0ODM1OnYy", "diffSide": "RIGHT", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/RelationalExpression.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xM1QyMjozODo0M1rOGw9LOg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xM1QyMjozODo0M1rOGw9LOg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mzk4NzEzMA==", "bodyText": "I think this can be aliasToQuantifierMap.getKeySet().", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/988#discussion_r453987130", "createdAt": "2020-07-13T22:38:43Z", "author": {"login": "nschiefer"}, "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/RelationalExpression.java", "diffHunk": "@@ -136,7 +148,160 @@ static RelationalExpression fromRecordQuery(@Nonnull RecordQuery query, @Nonnull\n     @Nonnull\n     List<? extends Quantifier> getQuantifiers();\n \n-    boolean equalsWithoutChildren(@Nonnull RelationalExpression otherExpression);\n+    default boolean canCorrelate() {\n+        return false;\n+    }\n+\n+    boolean equalsWithoutChildren(@Nonnull RelationalExpression otherExpression, final BiMap<CorrelationIdentifier, CorrelationIdentifier> equivalencesMap);\n+\n+    default Optional<BiMap<Quantifier, Quantifier>> resultEqualsQuantifiers(@Nonnull final Set<? extends Quantifier> otherQuantifiers,\n+                                                                            @Nonnull final BiMap<CorrelationIdentifier, CorrelationIdentifier> equivalenceMap) {\n+        return matchQuantifiers(otherQuantifiers,\n+                equivalenceMap,\n+                (quantifier, otherQuantifier, nestedEquivalenceMap) -> {\n+                    if (quantifier.hashCode() != otherQuantifier.hashCode()) {\n+                        return false;\n+                    }\n+                    return quantifier.resultEquals(otherQuantifier, nestedEquivalenceMap);\n+                });\n+    }\n+\n+    /**\n+     * An predicate that tests for a match between quantifiers also taking into account an equivalence maps between\n+     * {@link CorrelationIdentifier}s.\n+     */\n+    @FunctionalInterface\n+    interface MatchingPredicate {\n+        boolean test(@Nonnull Quantifier quantifier,\n+                     @Nonnull Quantifier otherQuantifier,\n+                     @Nonnull final BiMap<CorrelationIdentifier, CorrelationIdentifier> equivalencesMap);\n+    }\n+\n+\n+    /**\n+     * Method to match up the quantifiers this expression owns with the given set of other quantifiers and an\n+     * equivalence map.\n+     *\n+     * Two quantifiers can be considered equal if their extended equality method {@link Quantifier#resultEquals} returns\n+     * {@code true} for the given the correct equality map. This method attempts to match up each quantifier from the\n+     * set of quantifiers this expression owns to the given other set of quantifiers.\n+     *\n+     * Now this method returns an empty mapping if e.g. the number quantifiers in the respetive sets doesn't match.\n+     *\n+     * For expressions that cannot introduce correlations, this method is simply {@code O(n!)} where is the\n+     * number of quantifiers (which is equal for both sets). This path is taken by UNIONs and other set operations.\n+     *\n+     * For expressions that introduce correlations, the matching process is more complicated. First, we determine one\n+     * topologically correct ordering. Then we iterate through all topologically correct orderings of the set of\n+     * quantifiers this expression owns. For each element in the permutation of quantifiers that is returned by\n+     * the {@link com.apple.foundationdb.record.query.plan.temp.TopologicalSort.TopologicalOrderPermutationIterator}\n+     * we try to math the quantifiers between the sets topologically from left to right (using {@code predicate}).\n+     * For each match we find we add an equivalence between the alias of this and the other quantifier that matched\n+     * in an equivalence map that extends the given equivalence map.\n+     * @param otherQuantifiers other quantifiers\n+     * @param equivalencesMap equivalence map\n+     * @param predicate that tests if two quantifiers and their graph they range over can be considered equivalent\n+     * @return A bi-map containing a mapping from the quantifiers this expression owns to the quantifiers in\n+     *         {@code otherQuantifiers}. Note that the mapping is bijective and can therefore be inverted.\n+     */\n+    @SuppressWarnings({\"UnstableApiUsage\", \"squid:S135\"})\n+    default Optional<BiMap<Quantifier, Quantifier>> matchQuantifiers(@Nonnull Set<? extends Quantifier> otherQuantifiers,\n+                                                                     @Nonnull final BiMap<CorrelationIdentifier, CorrelationIdentifier> equivalencesMap,\n+                                                                     @Nonnull final MatchingPredicate predicate) {\n+        final List<? extends Quantifier> quantifiers = getQuantifiers();\n+        if (quantifiers.size() != otherQuantifiers.size()) {\n+            return Optional.empty();\n+        }\n+\n+        if (quantifiers.isEmpty()) {\n+            return Optional.of(ImmutableBiMap.of());\n+        }\n+\n+        //\n+        // We do not know which quantifier in \"this\" maps to which in \"other\". In fact, we cannot know as it is\n+        // intentionally modeled this way. We need to find _a_ feasible ordering that matches. In reality, the\n+        // quantifier impose more or less a complete order leaving no room for many permutations among unrelated\n+        // quantifiers. In the worst case, we must enumerate them all. Luckily, containsXXX() for children follow\n+        // an early out approach, so the uninteresting case where sub-graphs underneath quantifiers do not match\n+        // should be skipped quickly.\n+        //\n+        // Note: quantifiers implement equals() and hashCode() using the entire sub-graph they range over. That is\n+        // overkill here, since the quantifiers are owned by only one expression on each side, we should just use\n+        // alias-based equivalence.\n+        //\n+        \n+        // get _a_ topologically-sound permutation from other\n+        final Map<CorrelationIdentifier, ? extends Quantifier> otherAliasToQuantifierMap =\n+                otherQuantifiers.stream()\n+                        .collect(Collectors.toMap(Quantifier::getAlias, Function.identity()));\n+\n+        final Optional<List<CorrelationIdentifier>> otherOrderedOptional =\n+                TopologicalSort.anyTopologicalOrderPermutation(\n+                        otherQuantifiers.stream()\n+                                .map(Quantifier::getAlias)\n+                                .collect(Collectors.toSet()),\n+                        alias -> Objects.requireNonNull(otherAliasToQuantifierMap.get(alias)).getCorrelatedTo());\n+\n+        Verify.verify(otherOrderedOptional.isPresent());\n+\n+        final List<CorrelationIdentifier> otherOrdered = otherOrderedOptional.get();\n+\n+        // iterate through all sound permutations in order to establish equivalence\n+        final Map<CorrelationIdentifier, ? extends Quantifier> aliasToQuantifierMap =\n+                quantifiers.stream()\n+                        .collect(Collectors.toMap(Quantifier::getAlias, Function.identity()));\n+\n+        final TopologicalSort.TopologicalOrderPermutationIterable<CorrelationIdentifier> iterable =\n+                TopologicalSort.topologicalOrderPermutations(\n+                        quantifiers.stream()\n+                                .map(Quantifier::getAlias)\n+                                .collect(Collectors.toSet()),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6eb7142ab316ffbec53e375804118f722f1d2bcc"}, "originalPosition": 189}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgzMTQ0OTk1OnYy", "diffSide": "RIGHT", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/RelationalExpression.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xM1QyMjozOTowOFrOGw9MDg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xM1QyMjozOTowOFrOGw9MDg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mzk4NzM0Mg==", "bodyText": "Oh, Java...", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/988#discussion_r453987342", "createdAt": "2020-07-13T22:39:08Z", "author": {"login": "nschiefer"}, "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/RelationalExpression.java", "diffHunk": "@@ -136,7 +148,160 @@ static RelationalExpression fromRecordQuery(@Nonnull RecordQuery query, @Nonnull\n     @Nonnull\n     List<? extends Quantifier> getQuantifiers();\n \n-    boolean equalsWithoutChildren(@Nonnull RelationalExpression otherExpression);\n+    default boolean canCorrelate() {\n+        return false;\n+    }\n+\n+    boolean equalsWithoutChildren(@Nonnull RelationalExpression otherExpression, final BiMap<CorrelationIdentifier, CorrelationIdentifier> equivalencesMap);\n+\n+    default Optional<BiMap<Quantifier, Quantifier>> resultEqualsQuantifiers(@Nonnull final Set<? extends Quantifier> otherQuantifiers,\n+                                                                            @Nonnull final BiMap<CorrelationIdentifier, CorrelationIdentifier> equivalenceMap) {\n+        return matchQuantifiers(otherQuantifiers,\n+                equivalenceMap,\n+                (quantifier, otherQuantifier, nestedEquivalenceMap) -> {\n+                    if (quantifier.hashCode() != otherQuantifier.hashCode()) {\n+                        return false;\n+                    }\n+                    return quantifier.resultEquals(otherQuantifier, nestedEquivalenceMap);\n+                });\n+    }\n+\n+    /**\n+     * An predicate that tests for a match between quantifiers also taking into account an equivalence maps between\n+     * {@link CorrelationIdentifier}s.\n+     */\n+    @FunctionalInterface\n+    interface MatchingPredicate {\n+        boolean test(@Nonnull Quantifier quantifier,\n+                     @Nonnull Quantifier otherQuantifier,\n+                     @Nonnull final BiMap<CorrelationIdentifier, CorrelationIdentifier> equivalencesMap);\n+    }\n+\n+\n+    /**\n+     * Method to match up the quantifiers this expression owns with the given set of other quantifiers and an\n+     * equivalence map.\n+     *\n+     * Two quantifiers can be considered equal if their extended equality method {@link Quantifier#resultEquals} returns\n+     * {@code true} for the given the correct equality map. This method attempts to match up each quantifier from the\n+     * set of quantifiers this expression owns to the given other set of quantifiers.\n+     *\n+     * Now this method returns an empty mapping if e.g. the number quantifiers in the respetive sets doesn't match.\n+     *\n+     * For expressions that cannot introduce correlations, this method is simply {@code O(n!)} where is the\n+     * number of quantifiers (which is equal for both sets). This path is taken by UNIONs and other set operations.\n+     *\n+     * For expressions that introduce correlations, the matching process is more complicated. First, we determine one\n+     * topologically correct ordering. Then we iterate through all topologically correct orderings of the set of\n+     * quantifiers this expression owns. For each element in the permutation of quantifiers that is returned by\n+     * the {@link com.apple.foundationdb.record.query.plan.temp.TopologicalSort.TopologicalOrderPermutationIterator}\n+     * we try to math the quantifiers between the sets topologically from left to right (using {@code predicate}).\n+     * For each match we find we add an equivalence between the alias of this and the other quantifier that matched\n+     * in an equivalence map that extends the given equivalence map.\n+     * @param otherQuantifiers other quantifiers\n+     * @param equivalencesMap equivalence map\n+     * @param predicate that tests if two quantifiers and their graph they range over can be considered equivalent\n+     * @return A bi-map containing a mapping from the quantifiers this expression owns to the quantifiers in\n+     *         {@code otherQuantifiers}. Note that the mapping is bijective and can therefore be inverted.\n+     */\n+    @SuppressWarnings({\"UnstableApiUsage\", \"squid:S135\"})\n+    default Optional<BiMap<Quantifier, Quantifier>> matchQuantifiers(@Nonnull Set<? extends Quantifier> otherQuantifiers,\n+                                                                     @Nonnull final BiMap<CorrelationIdentifier, CorrelationIdentifier> equivalencesMap,\n+                                                                     @Nonnull final MatchingPredicate predicate) {\n+        final List<? extends Quantifier> quantifiers = getQuantifiers();\n+        if (quantifiers.size() != otherQuantifiers.size()) {\n+            return Optional.empty();\n+        }\n+\n+        if (quantifiers.isEmpty()) {\n+            return Optional.of(ImmutableBiMap.of());\n+        }\n+\n+        //\n+        // We do not know which quantifier in \"this\" maps to which in \"other\". In fact, we cannot know as it is\n+        // intentionally modeled this way. We need to find _a_ feasible ordering that matches. In reality, the\n+        // quantifier impose more or less a complete order leaving no room for many permutations among unrelated\n+        // quantifiers. In the worst case, we must enumerate them all. Luckily, containsXXX() for children follow\n+        // an early out approach, so the uninteresting case where sub-graphs underneath quantifiers do not match\n+        // should be skipped quickly.\n+        //\n+        // Note: quantifiers implement equals() and hashCode() using the entire sub-graph they range over. That is\n+        // overkill here, since the quantifiers are owned by only one expression on each side, we should just use\n+        // alias-based equivalence.\n+        //\n+        \n+        // get _a_ topologically-sound permutation from other\n+        final Map<CorrelationIdentifier, ? extends Quantifier> otherAliasToQuantifierMap =\n+                otherQuantifiers.stream()\n+                        .collect(Collectors.toMap(Quantifier::getAlias, Function.identity()));\n+\n+        final Optional<List<CorrelationIdentifier>> otherOrderedOptional =\n+                TopologicalSort.anyTopologicalOrderPermutation(\n+                        otherQuantifiers.stream()\n+                                .map(Quantifier::getAlias)\n+                                .collect(Collectors.toSet()),\n+                        alias -> Objects.requireNonNull(otherAliasToQuantifierMap.get(alias)).getCorrelatedTo());\n+\n+        Verify.verify(otherOrderedOptional.isPresent());\n+\n+        final List<CorrelationIdentifier> otherOrdered = otherOrderedOptional.get();\n+\n+        // iterate through all sound permutations in order to establish equivalence\n+        final Map<CorrelationIdentifier, ? extends Quantifier> aliasToQuantifierMap =\n+                quantifiers.stream()\n+                        .collect(Collectors.toMap(Quantifier::getAlias, Function.identity()));\n+\n+        final TopologicalSort.TopologicalOrderPermutationIterable<CorrelationIdentifier> iterable =\n+                TopologicalSort.topologicalOrderPermutations(\n+                        quantifiers.stream()\n+                                .map(Quantifier::getAlias)\n+                                .collect(Collectors.toSet()),\n+                        alias -> Objects.requireNonNull(aliasToQuantifierMap.get(alias)).getCorrelatedTo());\n+\n+        final TopologicalSort.TopologicalOrderPermutationIterator<CorrelationIdentifier> iterator = iterable.iterator();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6eb7142ab316ffbec53e375804118f722f1d2bcc"}, "originalPosition": 192}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgzMTQ3MTkwOnYy", "diffSide": "RIGHT", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/TopologicalSort.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xM1QyMjo0ODoxM1rOGw9Y4w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xM1QyMjo0ODoxM1rOGw9Y4w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mzk5MDYyNw==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n             * 3. it reacts appropriately to give circular dependency constraints between elements (i.e. no infinite loops)\n          \n          \n            \n             * 3. it reacts appropriately to give circular dependency constraints between elements (i.e., no infinite loops)", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/988#discussion_r453990627", "createdAt": "2020-07-13T22:48:13Z", "author": {"login": "nschiefer"}, "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/TopologicalSort.java", "diffHunk": "@@ -0,0 +1,416 @@\n+/*\n+ * TopologicalSort.java\n+ *\n+ * This source file is part of the FoundationDB open source project\n+ *\n+ * Copyright 2015-2020 Apple Inc. and the FoundationDB project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.apple.foundationdb.record.query.plan.temp;\n+\n+import com.google.common.base.Verify;\n+import com.google.common.collect.AbstractIterator;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.collect.Iterables;\n+import com.google.common.collect.Iterators;\n+import com.google.common.collect.Lists;\n+import com.google.common.collect.PeekingIterator;\n+import com.google.common.collect.Sets;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.function.Function;\n+\n+/**\n+ * Utility class to provide helpers related to topological sorts.\n+ *\n+ * The main purpose on this class is to provide a specific iterable that can efficiently traverse\n+ * all possible permutations of the input set that do not violate the given dependency constraints.\n+ *\n+ * The iterable {@link TopologicalOrderPermutationIterable} adheres to the following requirements:\n+ * 1. it does not violate the given constraints\n+ * 2. it produces all possible orderings under the given constraints\n+ * 3. it reacts appropriately to give circular dependency constraints between elements (i.e. no infinite loops)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6eb7142ab316ffbec53e375804118f722f1d2bcc"}, "originalPosition": 50}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgzMTQ3MzE3OnYy", "diffSide": "RIGHT", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/TopologicalSort.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xM1QyMjo0ODo1MVrOGw9Zqg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xM1QyMjo0ODo1MVrOGw9Zqg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mzk5MDgyNg==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n             * 4. it iterates all orderings on the fly, i.e. it only stores state (i.e. does not (pre)create the orderings in memory).\n          \n          \n            \n             * 4. it iterates all orderings on the fly. That is, it stores only the position of the iteration and does not (pre)create the orderings in memory.", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/988#discussion_r453990826", "createdAt": "2020-07-13T22:48:51Z", "author": {"login": "nschiefer"}, "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/TopologicalSort.java", "diffHunk": "@@ -0,0 +1,416 @@\n+/*\n+ * TopologicalSort.java\n+ *\n+ * This source file is part of the FoundationDB open source project\n+ *\n+ * Copyright 2015-2020 Apple Inc. and the FoundationDB project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.apple.foundationdb.record.query.plan.temp;\n+\n+import com.google.common.base.Verify;\n+import com.google.common.collect.AbstractIterator;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.collect.Iterables;\n+import com.google.common.collect.Iterators;\n+import com.google.common.collect.Lists;\n+import com.google.common.collect.PeekingIterator;\n+import com.google.common.collect.Sets;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.function.Function;\n+\n+/**\n+ * Utility class to provide helpers related to topological sorts.\n+ *\n+ * The main purpose on this class is to provide a specific iterable that can efficiently traverse\n+ * all possible permutations of the input set that do not violate the given dependency constraints.\n+ *\n+ * The iterable {@link TopologicalOrderPermutationIterable} adheres to the following requirements:\n+ * 1. it does not violate the given constraints\n+ * 2. it produces all possible orderings under the given constraints\n+ * 3. it reacts appropriately to give circular dependency constraints between elements (i.e. no infinite loops)\n+ * 4. it iterates all orderings on the fly, i.e. it only stores state (i.e. does not (pre)create the orderings in memory).", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6eb7142ab316ffbec53e375804118f722f1d2bcc"}, "originalPosition": 51}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgzMTUwMjcyOnYy", "diffSide": "RIGHT", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/TopologicalSort.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xM1QyMzowMjowMFrOGw9rPA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xM1QyMzowMjowMFrOGw9rPA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mzk5NTMyNA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                     * Instructs the iterator to advance to the next possible ordering using the given level.\n          \n          \n            \n                     * Instructs the iterator to advance to the next possible ordering using the given zero-indexed level.", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/988#discussion_r453995324", "createdAt": "2020-07-13T23:02:00Z", "author": {"login": "nschiefer"}, "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/TopologicalSort.java", "diffHunk": "@@ -0,0 +1,416 @@\n+/*\n+ * TopologicalSort.java\n+ *\n+ * This source file is part of the FoundationDB open source project\n+ *\n+ * Copyright 2015-2020 Apple Inc. and the FoundationDB project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.apple.foundationdb.record.query.plan.temp;\n+\n+import com.google.common.base.Verify;\n+import com.google.common.collect.AbstractIterator;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.collect.Iterables;\n+import com.google.common.collect.Iterators;\n+import com.google.common.collect.Lists;\n+import com.google.common.collect.PeekingIterator;\n+import com.google.common.collect.Sets;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.function.Function;\n+\n+/**\n+ * Utility class to provide helpers related to topological sorts.\n+ *\n+ * The main purpose on this class is to provide a specific iterable that can efficiently traverse\n+ * all possible permutations of the input set that do not violate the given dependency constraints.\n+ *\n+ * The iterable {@link TopologicalOrderPermutationIterable} adheres to the following requirements:\n+ * 1. it does not violate the given constraints\n+ * 2. it produces all possible orderings under the given constraints\n+ * 3. it reacts appropriately to give circular dependency constraints between elements (i.e. no infinite loops)\n+ * 4. it iterates all orderings on the fly, i.e. it only stores state (i.e. does not (pre)create the orderings in memory).\n+ *\n+ * {@link TopologicalOrderPermutationIterable} subclasses {@link Iterable} in order to provide an additional feature\n+ * that allows for skipping. Assume we have a set\n+ * <pre>\n+ * {@code\n+ * { a, b, c, d } with constraints { b -> c, b -> d } (c depends on b, d depends on b)\n+ * }\n+ * </pre>\n+ *\n+ * Possible orderings are\n+ * <pre>\n+ * {@code\n+ * (a, b, c, d)\n+ * (a, b, d, c)\n+ * (b, a, c, d)\n+ * (b, a, d, c)\n+ * (b, c, a, d)\n+ * (b, c, d, a)\n+ * (b, d, a, c)\n+ * (b, d, c, a)\n+ * }\n+ * </pre>\n+ *\n+ * Frequently we test for a certain property or perform a particular operation given one possible ordering but it is clear\n+ * that it is not necessary to consider more such orderings that share a common prefix. In the example, it may be\n+ * beneficial to skip the rest of the {@code (b, a, ...)} orderings after the first one was returned\n+ * ({@code (b, a, c, d}). In this case we would like to instruct the iterator to skip all such orderings and continue\n+ * iteration at {@code (b, c, a, d)}. Similarly, we want to skip all orderings starting with {@code (b, ...)} once we\n+ * encountered the first such ordering. This the iterators created by the provided {@link TopologicalOrderPermutationIterable}\n+ * of type {@link TopologicalOrderPermutationIterator} provide a method {@link TopologicalOrderPermutationIterator#skip}\n+ * to allow skipping at a provided prefix.\n+ *\n+ */\n+public class TopologicalSort {\n+    /**\n+     * Iterable that provides special iterators of type {@link TopologicalOrderPermutationIterator}.\n+     * @param <T> type\n+     */\n+    public interface TopologicalOrderPermutationIterable<T> extends Iterable<List<T>> {\n+        @Nonnull\n+        @Override\n+        TopologicalOrderPermutationIterator<T> iterator();\n+    }\n+\n+    /**\n+     * An iterator extending {@link Iterator} providing the ability to skip a certain prefix.\n+     * @param <T> type\n+     */\n+    public interface TopologicalOrderPermutationIterator<T> extends Iterator<List<T>> {\n+        /**\n+         * Instructs the iterator to advance to the next possible ordering using the given level.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6eb7142ab316ffbec53e375804118f722f1d2bcc"}, "originalPosition": 102}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgzMTUwNDk5OnYy", "diffSide": "RIGHT", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/TopologicalSort.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xM1QyMzowMzowOVrOGw9snQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xM1QyMzowMzowOVrOGw9snQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mzk5NTY3Nw==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * than 1 (i.e. the regular case).\n          \n          \n            \n                 * than 1 (i.e., the regular case).", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/988#discussion_r453995677", "createdAt": "2020-07-13T23:03:09Z", "author": {"login": "nschiefer"}, "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/TopologicalSort.java", "diffHunk": "@@ -0,0 +1,416 @@\n+/*\n+ * TopologicalSort.java\n+ *\n+ * This source file is part of the FoundationDB open source project\n+ *\n+ * Copyright 2015-2020 Apple Inc. and the FoundationDB project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.apple.foundationdb.record.query.plan.temp;\n+\n+import com.google.common.base.Verify;\n+import com.google.common.collect.AbstractIterator;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.collect.Iterables;\n+import com.google.common.collect.Iterators;\n+import com.google.common.collect.Lists;\n+import com.google.common.collect.PeekingIterator;\n+import com.google.common.collect.Sets;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.function.Function;\n+\n+/**\n+ * Utility class to provide helpers related to topological sorts.\n+ *\n+ * The main purpose on this class is to provide a specific iterable that can efficiently traverse\n+ * all possible permutations of the input set that do not violate the given dependency constraints.\n+ *\n+ * The iterable {@link TopologicalOrderPermutationIterable} adheres to the following requirements:\n+ * 1. it does not violate the given constraints\n+ * 2. it produces all possible orderings under the given constraints\n+ * 3. it reacts appropriately to give circular dependency constraints between elements (i.e. no infinite loops)\n+ * 4. it iterates all orderings on the fly, i.e. it only stores state (i.e. does not (pre)create the orderings in memory).\n+ *\n+ * {@link TopologicalOrderPermutationIterable} subclasses {@link Iterable} in order to provide an additional feature\n+ * that allows for skipping. Assume we have a set\n+ * <pre>\n+ * {@code\n+ * { a, b, c, d } with constraints { b -> c, b -> d } (c depends on b, d depends on b)\n+ * }\n+ * </pre>\n+ *\n+ * Possible orderings are\n+ * <pre>\n+ * {@code\n+ * (a, b, c, d)\n+ * (a, b, d, c)\n+ * (b, a, c, d)\n+ * (b, a, d, c)\n+ * (b, c, a, d)\n+ * (b, c, d, a)\n+ * (b, d, a, c)\n+ * (b, d, c, a)\n+ * }\n+ * </pre>\n+ *\n+ * Frequently we test for a certain property or perform a particular operation given one possible ordering but it is clear\n+ * that it is not necessary to consider more such orderings that share a common prefix. In the example, it may be\n+ * beneficial to skip the rest of the {@code (b, a, ...)} orderings after the first one was returned\n+ * ({@code (b, a, c, d}). In this case we would like to instruct the iterator to skip all such orderings and continue\n+ * iteration at {@code (b, c, a, d)}. Similarly, we want to skip all orderings starting with {@code (b, ...)} once we\n+ * encountered the first such ordering. This the iterators created by the provided {@link TopologicalOrderPermutationIterable}\n+ * of type {@link TopologicalOrderPermutationIterator} provide a method {@link TopologicalOrderPermutationIterator#skip}\n+ * to allow skipping at a provided prefix.\n+ *\n+ */\n+public class TopologicalSort {\n+    /**\n+     * Iterable that provides special iterators of type {@link TopologicalOrderPermutationIterator}.\n+     * @param <T> type\n+     */\n+    public interface TopologicalOrderPermutationIterable<T> extends Iterable<List<T>> {\n+        @Nonnull\n+        @Override\n+        TopologicalOrderPermutationIterator<T> iterator();\n+    }\n+\n+    /**\n+     * An iterator extending {@link Iterator} providing the ability to skip a certain prefix.\n+     * @param <T> type\n+     */\n+    public interface TopologicalOrderPermutationIterator<T> extends Iterator<List<T>> {\n+        /**\n+         * Instructs the iterator to advance to the next possible ordering using the given level.\n+         *\n+         * Example 1: If the last returned ordering of the iterator {@code it} is {@code (e0, e1, e2, e3)} and\n+         *            {@code it.skip(2)} is called, the state of the iterator is advanced in a way that either\n+         *            reaches the end of iteration or the next item that is returned is {@code (e0', e1', e3', e4')}\n+         *            where the prefix {@code (e1', e2', e3')} is not equal to {code (e1, e2, e3)}.\n+         * Example 2: If the last returned ordering of the iterator {@code it} is {@code (e1, e2, e3, e4)} and\n+         *            {@code it.skip(1)} is called, the state of the iterator is advanced in a way that either reaches\n+         *            the end of iteration or the next item that is returned is {@code (e1', e2', e3', e4')} where\n+         *            the prefix {@code (e1', e2')} is not equal to {code (e1, e2)}.\n+         *\n+         * @param level skip level\n+         */\n+        void skip(int level);\n+    }\n+\n+    /**\n+     * A complex iterable it a {@link TopologicalOrderPermutationIterable} that is used for sets of cardinality greater\n+     * than 1 (i.e. the regular case).", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6eb7142ab316ffbec53e375804118f722f1d2bcc"}, "originalPosition": 120}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgzMTUwNjU0OnYy", "diffSide": "RIGHT", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/TopologicalSort.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xM1QyMzowMzo1NlrOGw9tiw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xM1QyMzowMzo1NlrOGw9tiw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mzk5NTkxNQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            // The problem to iterate through all possible correct orderings of set is inherently easier to\n          \n          \n            \n                            // Iterating through all possible correct orderings of set is inherently easier to", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/988#discussion_r453995915", "createdAt": "2020-07-13T23:03:56Z", "author": {"login": "nschiefer"}, "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/TopologicalSort.java", "diffHunk": "@@ -0,0 +1,416 @@\n+/*\n+ * TopologicalSort.java\n+ *\n+ * This source file is part of the FoundationDB open source project\n+ *\n+ * Copyright 2015-2020 Apple Inc. and the FoundationDB project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.apple.foundationdb.record.query.plan.temp;\n+\n+import com.google.common.base.Verify;\n+import com.google.common.collect.AbstractIterator;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.collect.Iterables;\n+import com.google.common.collect.Iterators;\n+import com.google.common.collect.Lists;\n+import com.google.common.collect.PeekingIterator;\n+import com.google.common.collect.Sets;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.function.Function;\n+\n+/**\n+ * Utility class to provide helpers related to topological sorts.\n+ *\n+ * The main purpose on this class is to provide a specific iterable that can efficiently traverse\n+ * all possible permutations of the input set that do not violate the given dependency constraints.\n+ *\n+ * The iterable {@link TopologicalOrderPermutationIterable} adheres to the following requirements:\n+ * 1. it does not violate the given constraints\n+ * 2. it produces all possible orderings under the given constraints\n+ * 3. it reacts appropriately to give circular dependency constraints between elements (i.e. no infinite loops)\n+ * 4. it iterates all orderings on the fly, i.e. it only stores state (i.e. does not (pre)create the orderings in memory).\n+ *\n+ * {@link TopologicalOrderPermutationIterable} subclasses {@link Iterable} in order to provide an additional feature\n+ * that allows for skipping. Assume we have a set\n+ * <pre>\n+ * {@code\n+ * { a, b, c, d } with constraints { b -> c, b -> d } (c depends on b, d depends on b)\n+ * }\n+ * </pre>\n+ *\n+ * Possible orderings are\n+ * <pre>\n+ * {@code\n+ * (a, b, c, d)\n+ * (a, b, d, c)\n+ * (b, a, c, d)\n+ * (b, a, d, c)\n+ * (b, c, a, d)\n+ * (b, c, d, a)\n+ * (b, d, a, c)\n+ * (b, d, c, a)\n+ * }\n+ * </pre>\n+ *\n+ * Frequently we test for a certain property or perform a particular operation given one possible ordering but it is clear\n+ * that it is not necessary to consider more such orderings that share a common prefix. In the example, it may be\n+ * beneficial to skip the rest of the {@code (b, a, ...)} orderings after the first one was returned\n+ * ({@code (b, a, c, d}). In this case we would like to instruct the iterator to skip all such orderings and continue\n+ * iteration at {@code (b, c, a, d)}. Similarly, we want to skip all orderings starting with {@code (b, ...)} once we\n+ * encountered the first such ordering. This the iterators created by the provided {@link TopologicalOrderPermutationIterable}\n+ * of type {@link TopologicalOrderPermutationIterator} provide a method {@link TopologicalOrderPermutationIterator#skip}\n+ * to allow skipping at a provided prefix.\n+ *\n+ */\n+public class TopologicalSort {\n+    /**\n+     * Iterable that provides special iterators of type {@link TopologicalOrderPermutationIterator}.\n+     * @param <T> type\n+     */\n+    public interface TopologicalOrderPermutationIterable<T> extends Iterable<List<T>> {\n+        @Nonnull\n+        @Override\n+        TopologicalOrderPermutationIterator<T> iterator();\n+    }\n+\n+    /**\n+     * An iterator extending {@link Iterator} providing the ability to skip a certain prefix.\n+     * @param <T> type\n+     */\n+    public interface TopologicalOrderPermutationIterator<T> extends Iterator<List<T>> {\n+        /**\n+         * Instructs the iterator to advance to the next possible ordering using the given level.\n+         *\n+         * Example 1: If the last returned ordering of the iterator {@code it} is {@code (e0, e1, e2, e3)} and\n+         *            {@code it.skip(2)} is called, the state of the iterator is advanced in a way that either\n+         *            reaches the end of iteration or the next item that is returned is {@code (e0', e1', e3', e4')}\n+         *            where the prefix {@code (e1', e2', e3')} is not equal to {code (e1, e2, e3)}.\n+         * Example 2: If the last returned ordering of the iterator {@code it} is {@code (e1, e2, e3, e4)} and\n+         *            {@code it.skip(1)} is called, the state of the iterator is advanced in a way that either reaches\n+         *            the end of iteration or the next item that is returned is {@code (e1', e2', e3', e4')} where\n+         *            the prefix {@code (e1', e2')} is not equal to {code (e1, e2)}.\n+         *\n+         * @param level skip level\n+         */\n+        void skip(int level);\n+    }\n+\n+    /**\n+     * A complex iterable it a {@link TopologicalOrderPermutationIterable} that is used for sets of cardinality greater\n+     * than 1 (i.e. the regular case).\n+     * @param <T> type\n+     */\n+    private static class ComplexIterable<T> implements TopologicalOrderPermutationIterable<T> {\n+        @Nonnull\n+        private final ImmutableSet<T> set;\n+        @Nonnull\n+        private final Function<T, Set<T>> dependsOnFn;\n+\n+        private class ComplexIterator extends AbstractIterator<List<T>> implements TopologicalSort.TopologicalOrderPermutationIterator<T> {\n+            // state\n+            private final Set<T> bound;\n+            private final List<PeekingIterator<T>> state;\n+\n+            private ComplexIterator() {\n+                this.bound = Sets.newHashSetWithExpectedSize(set.size());\n+                this.state = Lists.newArrayListWithCapacity(set.size());\n+                for (int i = 0; i < set.size(); i ++ ) {\n+                    this.state.add(null);\n+                }\n+            }\n+\n+            @Nullable\n+            @Override\n+            protected List<T> computeNext() {\n+                //\n+                // The problem to iterate through all possible correct orderings of set is inherently easier to", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6eb7142ab316ffbec53e375804118f722f1d2bcc"}, "originalPosition": 146}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgzNTY4NzY0OnYy", "diffSide": "RIGHT", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/TopologicalSort.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNFQyMTowNjowNFrOGxlVaQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMFQyMDoxNjowMFrOG0duEQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDY0NTA5Nw==", "bodyText": "Is there a reason to use a back-tracking algorithm here (which I believe runs in \u03a9(|V|^2) time even if there is a unique topological order), rather than an adaption of Kahn's algorithm (which would run in O(|V| + |E|) time)? Does it have to do with the level-skipping? I think one can adapt Kahn's algorithm using a similar trick, but perhaps there's something I've missed.\nOr, perhaps this isn't a concern at all?", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/988#discussion_r454645097", "createdAt": "2020-07-14T21:06:04Z", "author": {"login": "nschiefer"}, "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/TopologicalSort.java", "diffHunk": "@@ -0,0 +1,416 @@\n+/*\n+ * TopologicalSort.java\n+ *\n+ * This source file is part of the FoundationDB open source project\n+ *\n+ * Copyright 2015-2020 Apple Inc. and the FoundationDB project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.apple.foundationdb.record.query.plan.temp;\n+\n+import com.google.common.base.Verify;\n+import com.google.common.collect.AbstractIterator;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.collect.Iterables;\n+import com.google.common.collect.Iterators;\n+import com.google.common.collect.Lists;\n+import com.google.common.collect.PeekingIterator;\n+import com.google.common.collect.Sets;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.function.Function;\n+\n+/**\n+ * Utility class to provide helpers related to topological sorts.\n+ *\n+ * The main purpose on this class is to provide a specific iterable that can efficiently traverse\n+ * all possible permutations of the input set that do not violate the given dependency constraints.\n+ *\n+ * The iterable {@link TopologicalOrderPermutationIterable} adheres to the following requirements:\n+ * 1. it does not violate the given constraints\n+ * 2. it produces all possible orderings under the given constraints\n+ * 3. it reacts appropriately to give circular dependency constraints between elements (i.e. no infinite loops)\n+ * 4. it iterates all orderings on the fly, i.e. it only stores state (i.e. does not (pre)create the orderings in memory).\n+ *\n+ * {@link TopologicalOrderPermutationIterable} subclasses {@link Iterable} in order to provide an additional feature\n+ * that allows for skipping. Assume we have a set\n+ * <pre>\n+ * {@code\n+ * { a, b, c, d } with constraints { b -> c, b -> d } (c depends on b, d depends on b)\n+ * }\n+ * </pre>\n+ *\n+ * Possible orderings are\n+ * <pre>\n+ * {@code\n+ * (a, b, c, d)\n+ * (a, b, d, c)\n+ * (b, a, c, d)\n+ * (b, a, d, c)\n+ * (b, c, a, d)\n+ * (b, c, d, a)\n+ * (b, d, a, c)\n+ * (b, d, c, a)\n+ * }\n+ * </pre>\n+ *\n+ * Frequently we test for a certain property or perform a particular operation given one possible ordering but it is clear\n+ * that it is not necessary to consider more such orderings that share a common prefix. In the example, it may be\n+ * beneficial to skip the rest of the {@code (b, a, ...)} orderings after the first one was returned\n+ * ({@code (b, a, c, d}). In this case we would like to instruct the iterator to skip all such orderings and continue\n+ * iteration at {@code (b, c, a, d)}. Similarly, we want to skip all orderings starting with {@code (b, ...)} once we\n+ * encountered the first such ordering. This the iterators created by the provided {@link TopologicalOrderPermutationIterable}\n+ * of type {@link TopologicalOrderPermutationIterator} provide a method {@link TopologicalOrderPermutationIterator#skip}\n+ * to allow skipping at a provided prefix.\n+ *\n+ */\n+public class TopologicalSort {\n+    /**\n+     * Iterable that provides special iterators of type {@link TopologicalOrderPermutationIterator}.\n+     * @param <T> type\n+     */\n+    public interface TopologicalOrderPermutationIterable<T> extends Iterable<List<T>> {\n+        @Nonnull\n+        @Override\n+        TopologicalOrderPermutationIterator<T> iterator();\n+    }\n+\n+    /**\n+     * An iterator extending {@link Iterator} providing the ability to skip a certain prefix.\n+     * @param <T> type\n+     */\n+    public interface TopologicalOrderPermutationIterator<T> extends Iterator<List<T>> {\n+        /**\n+         * Instructs the iterator to advance to the next possible ordering using the given level.\n+         *\n+         * Example 1: If the last returned ordering of the iterator {@code it} is {@code (e0, e1, e2, e3)} and\n+         *            {@code it.skip(2)} is called, the state of the iterator is advanced in a way that either\n+         *            reaches the end of iteration or the next item that is returned is {@code (e0', e1', e3', e4')}\n+         *            where the prefix {@code (e1', e2', e3')} is not equal to {code (e1, e2, e3)}.\n+         * Example 2: If the last returned ordering of the iterator {@code it} is {@code (e1, e2, e3, e4)} and\n+         *            {@code it.skip(1)} is called, the state of the iterator is advanced in a way that either reaches\n+         *            the end of iteration or the next item that is returned is {@code (e1', e2', e3', e4')} where\n+         *            the prefix {@code (e1', e2')} is not equal to {code (e1, e2)}.\n+         *\n+         * @param level skip level\n+         */\n+        void skip(int level);\n+    }\n+\n+    /**\n+     * A complex iterable it a {@link TopologicalOrderPermutationIterable} that is used for sets of cardinality greater\n+     * than 1 (i.e. the regular case).\n+     * @param <T> type\n+     */\n+    private static class ComplexIterable<T> implements TopologicalOrderPermutationIterable<T> {\n+        @Nonnull\n+        private final ImmutableSet<T> set;\n+        @Nonnull\n+        private final Function<T, Set<T>> dependsOnFn;\n+\n+        private class ComplexIterator extends AbstractIterator<List<T>> implements TopologicalSort.TopologicalOrderPermutationIterator<T> {\n+            // state\n+            private final Set<T> bound;\n+            private final List<PeekingIterator<T>> state;\n+\n+            private ComplexIterator() {\n+                this.bound = Sets.newHashSetWithExpectedSize(set.size());\n+                this.state = Lists.newArrayListWithCapacity(set.size());\n+                for (int i = 0; i < set.size(); i ++ ) {\n+                    this.state.add(null);\n+                }\n+            }\n+\n+            @Nullable\n+            @Override\n+            protected List<T> computeNext() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6eb7142ab316ffbec53e375804118f722f1d2bcc"}, "originalPosition": 144}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzY2NjA2NQ==", "bodyText": "I reimplemented topological sort based on Kahn's algorithm. The main difference here is that we\ndo not have to reiterate through our original set for each level of bindings but precompute the eligibility set after we bind a level. That is great for cases where a lot of correlations between quantifiers cause us to limit the set of permutations. In those cases finding a candidate is linear O(|V| + |E|). Finding all permutations can be faster using Kahn's algorithm if the space is limited by correlations. If we need to enumerate all permutations without any correlations, Kahn's algorithm does not perform well, as we need to create and forget eligibility sets the entire time. Object creations and presumably GC trumps savings due to the improvement of the actual algorithm. Maybe we should have both algorithms at our disposal and chose heuristically.", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/988#discussion_r457666065", "createdAt": "2020-07-20T20:16:00Z", "author": {"login": "normen662"}, "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/TopologicalSort.java", "diffHunk": "@@ -0,0 +1,416 @@\n+/*\n+ * TopologicalSort.java\n+ *\n+ * This source file is part of the FoundationDB open source project\n+ *\n+ * Copyright 2015-2020 Apple Inc. and the FoundationDB project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.apple.foundationdb.record.query.plan.temp;\n+\n+import com.google.common.base.Verify;\n+import com.google.common.collect.AbstractIterator;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.collect.Iterables;\n+import com.google.common.collect.Iterators;\n+import com.google.common.collect.Lists;\n+import com.google.common.collect.PeekingIterator;\n+import com.google.common.collect.Sets;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.function.Function;\n+\n+/**\n+ * Utility class to provide helpers related to topological sorts.\n+ *\n+ * The main purpose on this class is to provide a specific iterable that can efficiently traverse\n+ * all possible permutations of the input set that do not violate the given dependency constraints.\n+ *\n+ * The iterable {@link TopologicalOrderPermutationIterable} adheres to the following requirements:\n+ * 1. it does not violate the given constraints\n+ * 2. it produces all possible orderings under the given constraints\n+ * 3. it reacts appropriately to give circular dependency constraints between elements (i.e. no infinite loops)\n+ * 4. it iterates all orderings on the fly, i.e. it only stores state (i.e. does not (pre)create the orderings in memory).\n+ *\n+ * {@link TopologicalOrderPermutationIterable} subclasses {@link Iterable} in order to provide an additional feature\n+ * that allows for skipping. Assume we have a set\n+ * <pre>\n+ * {@code\n+ * { a, b, c, d } with constraints { b -> c, b -> d } (c depends on b, d depends on b)\n+ * }\n+ * </pre>\n+ *\n+ * Possible orderings are\n+ * <pre>\n+ * {@code\n+ * (a, b, c, d)\n+ * (a, b, d, c)\n+ * (b, a, c, d)\n+ * (b, a, d, c)\n+ * (b, c, a, d)\n+ * (b, c, d, a)\n+ * (b, d, a, c)\n+ * (b, d, c, a)\n+ * }\n+ * </pre>\n+ *\n+ * Frequently we test for a certain property or perform a particular operation given one possible ordering but it is clear\n+ * that it is not necessary to consider more such orderings that share a common prefix. In the example, it may be\n+ * beneficial to skip the rest of the {@code (b, a, ...)} orderings after the first one was returned\n+ * ({@code (b, a, c, d}). In this case we would like to instruct the iterator to skip all such orderings and continue\n+ * iteration at {@code (b, c, a, d)}. Similarly, we want to skip all orderings starting with {@code (b, ...)} once we\n+ * encountered the first such ordering. This the iterators created by the provided {@link TopologicalOrderPermutationIterable}\n+ * of type {@link TopologicalOrderPermutationIterator} provide a method {@link TopologicalOrderPermutationIterator#skip}\n+ * to allow skipping at a provided prefix.\n+ *\n+ */\n+public class TopologicalSort {\n+    /**\n+     * Iterable that provides special iterators of type {@link TopologicalOrderPermutationIterator}.\n+     * @param <T> type\n+     */\n+    public interface TopologicalOrderPermutationIterable<T> extends Iterable<List<T>> {\n+        @Nonnull\n+        @Override\n+        TopologicalOrderPermutationIterator<T> iterator();\n+    }\n+\n+    /**\n+     * An iterator extending {@link Iterator} providing the ability to skip a certain prefix.\n+     * @param <T> type\n+     */\n+    public interface TopologicalOrderPermutationIterator<T> extends Iterator<List<T>> {\n+        /**\n+         * Instructs the iterator to advance to the next possible ordering using the given level.\n+         *\n+         * Example 1: If the last returned ordering of the iterator {@code it} is {@code (e0, e1, e2, e3)} and\n+         *            {@code it.skip(2)} is called, the state of the iterator is advanced in a way that either\n+         *            reaches the end of iteration or the next item that is returned is {@code (e0', e1', e3', e4')}\n+         *            where the prefix {@code (e1', e2', e3')} is not equal to {code (e1, e2, e3)}.\n+         * Example 2: If the last returned ordering of the iterator {@code it} is {@code (e1, e2, e3, e4)} and\n+         *            {@code it.skip(1)} is called, the state of the iterator is advanced in a way that either reaches\n+         *            the end of iteration or the next item that is returned is {@code (e1', e2', e3', e4')} where\n+         *            the prefix {@code (e1', e2')} is not equal to {code (e1, e2)}.\n+         *\n+         * @param level skip level\n+         */\n+        void skip(int level);\n+    }\n+\n+    /**\n+     * A complex iterable it a {@link TopologicalOrderPermutationIterable} that is used for sets of cardinality greater\n+     * than 1 (i.e. the regular case).\n+     * @param <T> type\n+     */\n+    private static class ComplexIterable<T> implements TopologicalOrderPermutationIterable<T> {\n+        @Nonnull\n+        private final ImmutableSet<T> set;\n+        @Nonnull\n+        private final Function<T, Set<T>> dependsOnFn;\n+\n+        private class ComplexIterator extends AbstractIterator<List<T>> implements TopologicalSort.TopologicalOrderPermutationIterator<T> {\n+            // state\n+            private final Set<T> bound;\n+            private final List<PeekingIterator<T>> state;\n+\n+            private ComplexIterator() {\n+                this.bound = Sets.newHashSetWithExpectedSize(set.size());\n+                this.state = Lists.newArrayListWithCapacity(set.size());\n+                for (int i = 0; i < set.size(); i ++ ) {\n+                    this.state.add(null);\n+                }\n+            }\n+\n+            @Nullable\n+            @Override\n+            protected List<T> computeNext() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDY0NTA5Nw=="}, "originalCommit": {"oid": "6eb7142ab316ffbec53e375804118f722f1d2bcc"}, "originalPosition": 144}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgzNTY4OTMxOnYy", "diffSide": "RIGHT", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/TopologicalSort.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNFQyMTowNjo0M1rOGxlWjQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNFQyMTowNjo0M1rOGxlWjQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDY0NTM4OQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * inputs sets. The case where the input set is exactly one item is trivial and also properly handled by\n          \n          \n            \n                 * input sets. The case where the input set is exactly one item is trivial and also properly handled by", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/988#discussion_r454645389", "createdAt": "2020-07-14T21:06:43Z", "author": {"login": "nschiefer"}, "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/TopologicalSort.java", "diffHunk": "@@ -0,0 +1,416 @@\n+/*\n+ * TopologicalSort.java\n+ *\n+ * This source file is part of the FoundationDB open source project\n+ *\n+ * Copyright 2015-2020 Apple Inc. and the FoundationDB project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.apple.foundationdb.record.query.plan.temp;\n+\n+import com.google.common.base.Verify;\n+import com.google.common.collect.AbstractIterator;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.collect.Iterables;\n+import com.google.common.collect.Iterators;\n+import com.google.common.collect.Lists;\n+import com.google.common.collect.PeekingIterator;\n+import com.google.common.collect.Sets;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.function.Function;\n+\n+/**\n+ * Utility class to provide helpers related to topological sorts.\n+ *\n+ * The main purpose on this class is to provide a specific iterable that can efficiently traverse\n+ * all possible permutations of the input set that do not violate the given dependency constraints.\n+ *\n+ * The iterable {@link TopologicalOrderPermutationIterable} adheres to the following requirements:\n+ * 1. it does not violate the given constraints\n+ * 2. it produces all possible orderings under the given constraints\n+ * 3. it reacts appropriately to give circular dependency constraints between elements (i.e. no infinite loops)\n+ * 4. it iterates all orderings on the fly, i.e. it only stores state (i.e. does not (pre)create the orderings in memory).\n+ *\n+ * {@link TopologicalOrderPermutationIterable} subclasses {@link Iterable} in order to provide an additional feature\n+ * that allows for skipping. Assume we have a set\n+ * <pre>\n+ * {@code\n+ * { a, b, c, d } with constraints { b -> c, b -> d } (c depends on b, d depends on b)\n+ * }\n+ * </pre>\n+ *\n+ * Possible orderings are\n+ * <pre>\n+ * {@code\n+ * (a, b, c, d)\n+ * (a, b, d, c)\n+ * (b, a, c, d)\n+ * (b, a, d, c)\n+ * (b, c, a, d)\n+ * (b, c, d, a)\n+ * (b, d, a, c)\n+ * (b, d, c, a)\n+ * }\n+ * </pre>\n+ *\n+ * Frequently we test for a certain property or perform a particular operation given one possible ordering but it is clear\n+ * that it is not necessary to consider more such orderings that share a common prefix. In the example, it may be\n+ * beneficial to skip the rest of the {@code (b, a, ...)} orderings after the first one was returned\n+ * ({@code (b, a, c, d}). In this case we would like to instruct the iterator to skip all such orderings and continue\n+ * iteration at {@code (b, c, a, d)}. Similarly, we want to skip all orderings starting with {@code (b, ...)} once we\n+ * encountered the first such ordering. This the iterators created by the provided {@link TopologicalOrderPermutationIterable}\n+ * of type {@link TopologicalOrderPermutationIterator} provide a method {@link TopologicalOrderPermutationIterator#skip}\n+ * to allow skipping at a provided prefix.\n+ *\n+ */\n+public class TopologicalSort {\n+    /**\n+     * Iterable that provides special iterators of type {@link TopologicalOrderPermutationIterator}.\n+     * @param <T> type\n+     */\n+    public interface TopologicalOrderPermutationIterable<T> extends Iterable<List<T>> {\n+        @Nonnull\n+        @Override\n+        TopologicalOrderPermutationIterator<T> iterator();\n+    }\n+\n+    /**\n+     * An iterator extending {@link Iterator} providing the ability to skip a certain prefix.\n+     * @param <T> type\n+     */\n+    public interface TopologicalOrderPermutationIterator<T> extends Iterator<List<T>> {\n+        /**\n+         * Instructs the iterator to advance to the next possible ordering using the given level.\n+         *\n+         * Example 1: If the last returned ordering of the iterator {@code it} is {@code (e0, e1, e2, e3)} and\n+         *            {@code it.skip(2)} is called, the state of the iterator is advanced in a way that either\n+         *            reaches the end of iteration or the next item that is returned is {@code (e0', e1', e3', e4')}\n+         *            where the prefix {@code (e1', e2', e3')} is not equal to {code (e1, e2, e3)}.\n+         * Example 2: If the last returned ordering of the iterator {@code it} is {@code (e1, e2, e3, e4)} and\n+         *            {@code it.skip(1)} is called, the state of the iterator is advanced in a way that either reaches\n+         *            the end of iteration or the next item that is returned is {@code (e1', e2', e3', e4')} where\n+         *            the prefix {@code (e1', e2')} is not equal to {code (e1, e2)}.\n+         *\n+         * @param level skip level\n+         */\n+        void skip(int level);\n+    }\n+\n+    /**\n+     * A complex iterable it a {@link TopologicalOrderPermutationIterable} that is used for sets of cardinality greater\n+     * than 1 (i.e. the regular case).\n+     * @param <T> type\n+     */\n+    private static class ComplexIterable<T> implements TopologicalOrderPermutationIterable<T> {\n+        @Nonnull\n+        private final ImmutableSet<T> set;\n+        @Nonnull\n+        private final Function<T, Set<T>> dependsOnFn;\n+\n+        private class ComplexIterator extends AbstractIterator<List<T>> implements TopologicalSort.TopologicalOrderPermutationIterator<T> {\n+            // state\n+            private final Set<T> bound;\n+            private final List<PeekingIterator<T>> state;\n+\n+            private ComplexIterator() {\n+                this.bound = Sets.newHashSetWithExpectedSize(set.size());\n+                this.state = Lists.newArrayListWithCapacity(set.size());\n+                for (int i = 0; i < set.size(); i ++ ) {\n+                    this.state.add(null);\n+                }\n+            }\n+\n+            @Nullable\n+            @Override\n+            protected List<T> computeNext() {\n+                //\n+                // The problem to iterate through all possible correct orderings of set is inherently easier to\n+                // encode recursively, however, this being an iterator together with the requirement to skip subtrees\n+                // of iterations warrants an iterative solution. All hail the Church-Turing thesis!\n+                //\n+                if (set.isEmpty()) {\n+                    return endOfData();\n+                }\n+\n+                //\n+                // If nothing is bound yet, we are at the beginning and should start at level 0, otherwise\n+                // we conceptually start at the level of the finest granularity bound. Note that that finest\n+                // granularity is usually the granularity of the last element in the set, but it is possible\n+                // for fewer elements to be bound if this is the first call after a skip.\n+                //\n+                int currentLevel = bound.isEmpty() ? 0 : bound.size() - 1;\n+\n+                //\n+                // For each permutation of elements we return, we need to bind n elements (n == set.size()).\n+                // We maintain an iterator through the set (that is stable) for each level up to currentLevel.\n+                // That's the state! The iterator for levels greater than currentLevel must be null. The iterators\n+                // for levels below current level must be on a valid element. The iterator for the currentLevel\n+                // maybe null or a valid element.\n+                //\n+\n+                //\n+                // We also use a set \"bound\" that keeps elements that are currently bound by iterators.\n+                // \"bound\" is solely kept for convenience and is entirely computable from the current\n+                // state of all iterators. We must keep it in sync with the state of the iterators at all times.\n+                //\n+                do {\n+                    //\n+                    // Set the currentIterator. That is the iterator at level currentLevel. If it is null,\n+                    // we create a new iterator over the set.\n+                    //\n+                    final PeekingIterator<T> currentIterator;\n+                    if (state.get(currentLevel) == null) {\n+                        currentIterator = Iterators.peekingIterator(set.iterator());\n+                        state.set(currentLevel, currentIterator);\n+                    } else {\n+                        currentIterator = state.get(currentLevel);\n+                        unbind(currentLevel);\n+                        currentIterator.next();\n+                    }\n+\n+                    //\n+                    // Search currentLevel for a next item that does not violate any constraints. Doing so\n+                    // may exhaust currentIterator in which case we couldn't find another element on the current level.\n+                    // In that case we need to abandon the current level and search on the level above (making that\n+                    // level the current level). If we reach level -1 (i.e. we reach the end of the iterator at level 0\n+                    // we are done.\n+                    // If we do find an element not violating any constraints on the current level we conceptually\n+                    // bind it the element we found and continue on downward.\n+                    //\n+                    final boolean isDown = searchLevel(currentIterator);\n+                    if (!isDown) {\n+                        // back tracking -- need to clear out the current iterator\n+                        state.set(currentLevel, null);\n+                    }\n+                    currentLevel = isDown\n+                                   ? currentLevel + 1\n+                                   : currentLevel - 1;\n+                    \n+                    if (currentLevel == -1) {\n+                        return endOfData();\n+                    }\n+                } while (bound.size() < set.size()); // as long as we still have to find a binding\n+\n+                return state.stream()\n+                        .map(PeekingIterator::peek)\n+                        .collect(ImmutableList.toImmutableList());\n+            }\n+\n+            @SuppressWarnings(\"squid:S135\")\n+            private boolean searchLevel(final PeekingIterator<T> currentIterator) {\n+                while (currentIterator.hasNext()) {\n+                    final T next = currentIterator.peek();\n+\n+                    // check if it is bound already; t is invisible to this loop if it is bound\n+                    if (bound.contains(next)) {\n+                        currentIterator.next();\n+                        continue;\n+                    }\n+\n+                    //\n+                    // Check if t is only dependent on elements in the current bound set, if it is not it must come later.\n+                    // Note that the intersection removes elements the current element depends on that are not in set.\n+                    // That behavior is for convenience reasons and and specifically not an error.\n+                    //\n+                    final Set<T> dependsOn = Sets.intersection(set, dependsOnFn.apply(next));\n+                    if (!bound.containsAll(dependsOn)) {\n+                        currentIterator.next();\n+                        continue;\n+                    }\n+\n+                    // this level can be bound now\n+                    bound.add(next);\n+                    return true; // go down\n+                }\n+                return false; // go up\n+            }\n+\n+            private void unbind(final int level) {\n+                // reset all the following ones\n+                for (int i = level; i < set.size(); i ++ ) {\n+                    // either iterator is on a valid item or iterator is null\n+                    if (state.get(i) != null) {\n+                        bound.remove(state.get(i).peek());\n+                    } else {\n+                        break;\n+                    }\n+                }\n+            }\n+\n+            /**\n+             * Method that skips advances to the next element on the given level.\n+             * @param level level to advance\n+             */\n+            @Override\n+            public void skip(final int level) {\n+                if (level >= set.size()) {\n+                    throw new IndexOutOfBoundsException();\n+                }\n+\n+                if (state.get(level) == null) {\n+                    throw new UnsupportedOperationException(\"cannot skip/unbind as level is not bound at all\");\n+                }\n+\n+                // reset all the following ones\n+                for (int i = level + 1; i < set.size(); i ++ ) {\n+                    // either iterator is on a valid item or iterator is null\n+                    if (state.get(i) != null) {\n+                        bound.remove(state.get(i).peek());\n+                        state.set(i, null);\n+                    } else {\n+                        break;\n+                    }\n+                }\n+            }\n+        }\n+\n+        private ComplexIterable(@Nonnull final Set<T> set, @Nonnull final Function<T, Set<T>> dependsOnFn) {\n+            Verify.verify(set.size() > 1);\n+            this.set = ImmutableSet.copyOf(set);\n+            this.dependsOnFn = dependsOnFn;\n+        }\n+\n+        @Nonnull\n+        @Override\n+        public TopologicalOrderPermutationIterator<T> iterator() {\n+            return new ComplexIterator();\n+        }\n+    }\n+\n+    /**\n+     * An implementation of {@link TopologicalOrderPermutationIterable} that is optimized to work for empty\n+     * inputs sets. The case where the input set is empty is trivial and also properly handled by {@link ComplexIterable}.\n+     * Iterators created by this class, however, avoid to build complex state objects during their lifecycle.\n+     *\n+     * @param <T> type\n+     */\n+    private static class EmptyIterable<T> implements TopologicalOrderPermutationIterable<T> {\n+        private class EmptyIterator extends AbstractIterator<List<T>> implements TopologicalOrderPermutationIterator<T> {\n+            @Override\n+            public void skip(final int level) {\n+                throw new UnsupportedOperationException(\"cannot skip on empty iterator\");\n+            }\n+\n+            @Nullable\n+            @Override\n+            protected List<T> computeNext() {\n+                return endOfData();\n+            }\n+        }\n+\n+        @Nonnull\n+        @Override\n+        public TopologicalOrderPermutationIterator<T> iterator() {\n+            return new EmptyIterator();\n+        }\n+    }\n+\n+    /**\n+     * An implementation of {@link TopologicalOrderPermutationIterable} that is optimized to work for single item\n+     * inputs sets. The case where the input set is exactly one item is trivial and also properly handled by", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6eb7142ab316ffbec53e375804118f722f1d2bcc"}, "originalPosition": 329}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgzNTY5MjI0OnYy", "diffSide": "RIGHT", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/TopologicalSort.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNFQyMTowNzozOVrOGxlYRQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNFQyMTowNzozOVrOGxlYRQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDY0NTgyOQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 *        underlying algorithm (as in the dependency is instantly considered to be satisfied by all orderings).\n          \n          \n            \n                 *        underlying algorithm (that is, they are satisfied by every ordering).", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/988#discussion_r454645829", "createdAt": "2020-07-14T21:07:39Z", "author": {"login": "nschiefer"}, "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/TopologicalSort.java", "diffHunk": "@@ -0,0 +1,416 @@\n+/*\n+ * TopologicalSort.java\n+ *\n+ * This source file is part of the FoundationDB open source project\n+ *\n+ * Copyright 2015-2020 Apple Inc. and the FoundationDB project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.apple.foundationdb.record.query.plan.temp;\n+\n+import com.google.common.base.Verify;\n+import com.google.common.collect.AbstractIterator;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.collect.Iterables;\n+import com.google.common.collect.Iterators;\n+import com.google.common.collect.Lists;\n+import com.google.common.collect.PeekingIterator;\n+import com.google.common.collect.Sets;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.function.Function;\n+\n+/**\n+ * Utility class to provide helpers related to topological sorts.\n+ *\n+ * The main purpose on this class is to provide a specific iterable that can efficiently traverse\n+ * all possible permutations of the input set that do not violate the given dependency constraints.\n+ *\n+ * The iterable {@link TopologicalOrderPermutationIterable} adheres to the following requirements:\n+ * 1. it does not violate the given constraints\n+ * 2. it produces all possible orderings under the given constraints\n+ * 3. it reacts appropriately to give circular dependency constraints between elements (i.e. no infinite loops)\n+ * 4. it iterates all orderings on the fly, i.e. it only stores state (i.e. does not (pre)create the orderings in memory).\n+ *\n+ * {@link TopologicalOrderPermutationIterable} subclasses {@link Iterable} in order to provide an additional feature\n+ * that allows for skipping. Assume we have a set\n+ * <pre>\n+ * {@code\n+ * { a, b, c, d } with constraints { b -> c, b -> d } (c depends on b, d depends on b)\n+ * }\n+ * </pre>\n+ *\n+ * Possible orderings are\n+ * <pre>\n+ * {@code\n+ * (a, b, c, d)\n+ * (a, b, d, c)\n+ * (b, a, c, d)\n+ * (b, a, d, c)\n+ * (b, c, a, d)\n+ * (b, c, d, a)\n+ * (b, d, a, c)\n+ * (b, d, c, a)\n+ * }\n+ * </pre>\n+ *\n+ * Frequently we test for a certain property or perform a particular operation given one possible ordering but it is clear\n+ * that it is not necessary to consider more such orderings that share a common prefix. In the example, it may be\n+ * beneficial to skip the rest of the {@code (b, a, ...)} orderings after the first one was returned\n+ * ({@code (b, a, c, d}). In this case we would like to instruct the iterator to skip all such orderings and continue\n+ * iteration at {@code (b, c, a, d)}. Similarly, we want to skip all orderings starting with {@code (b, ...)} once we\n+ * encountered the first such ordering. This the iterators created by the provided {@link TopologicalOrderPermutationIterable}\n+ * of type {@link TopologicalOrderPermutationIterator} provide a method {@link TopologicalOrderPermutationIterator#skip}\n+ * to allow skipping at a provided prefix.\n+ *\n+ */\n+public class TopologicalSort {\n+    /**\n+     * Iterable that provides special iterators of type {@link TopologicalOrderPermutationIterator}.\n+     * @param <T> type\n+     */\n+    public interface TopologicalOrderPermutationIterable<T> extends Iterable<List<T>> {\n+        @Nonnull\n+        @Override\n+        TopologicalOrderPermutationIterator<T> iterator();\n+    }\n+\n+    /**\n+     * An iterator extending {@link Iterator} providing the ability to skip a certain prefix.\n+     * @param <T> type\n+     */\n+    public interface TopologicalOrderPermutationIterator<T> extends Iterator<List<T>> {\n+        /**\n+         * Instructs the iterator to advance to the next possible ordering using the given level.\n+         *\n+         * Example 1: If the last returned ordering of the iterator {@code it} is {@code (e0, e1, e2, e3)} and\n+         *            {@code it.skip(2)} is called, the state of the iterator is advanced in a way that either\n+         *            reaches the end of iteration or the next item that is returned is {@code (e0', e1', e3', e4')}\n+         *            where the prefix {@code (e1', e2', e3')} is not equal to {code (e1, e2, e3)}.\n+         * Example 2: If the last returned ordering of the iterator {@code it} is {@code (e1, e2, e3, e4)} and\n+         *            {@code it.skip(1)} is called, the state of the iterator is advanced in a way that either reaches\n+         *            the end of iteration or the next item that is returned is {@code (e1', e2', e3', e4')} where\n+         *            the prefix {@code (e1', e2')} is not equal to {code (e1, e2)}.\n+         *\n+         * @param level skip level\n+         */\n+        void skip(int level);\n+    }\n+\n+    /**\n+     * A complex iterable it a {@link TopologicalOrderPermutationIterable} that is used for sets of cardinality greater\n+     * than 1 (i.e. the regular case).\n+     * @param <T> type\n+     */\n+    private static class ComplexIterable<T> implements TopologicalOrderPermutationIterable<T> {\n+        @Nonnull\n+        private final ImmutableSet<T> set;\n+        @Nonnull\n+        private final Function<T, Set<T>> dependsOnFn;\n+\n+        private class ComplexIterator extends AbstractIterator<List<T>> implements TopologicalSort.TopologicalOrderPermutationIterator<T> {\n+            // state\n+            private final Set<T> bound;\n+            private final List<PeekingIterator<T>> state;\n+\n+            private ComplexIterator() {\n+                this.bound = Sets.newHashSetWithExpectedSize(set.size());\n+                this.state = Lists.newArrayListWithCapacity(set.size());\n+                for (int i = 0; i < set.size(); i ++ ) {\n+                    this.state.add(null);\n+                }\n+            }\n+\n+            @Nullable\n+            @Override\n+            protected List<T> computeNext() {\n+                //\n+                // The problem to iterate through all possible correct orderings of set is inherently easier to\n+                // encode recursively, however, this being an iterator together with the requirement to skip subtrees\n+                // of iterations warrants an iterative solution. All hail the Church-Turing thesis!\n+                //\n+                if (set.isEmpty()) {\n+                    return endOfData();\n+                }\n+\n+                //\n+                // If nothing is bound yet, we are at the beginning and should start at level 0, otherwise\n+                // we conceptually start at the level of the finest granularity bound. Note that that finest\n+                // granularity is usually the granularity of the last element in the set, but it is possible\n+                // for fewer elements to be bound if this is the first call after a skip.\n+                //\n+                int currentLevel = bound.isEmpty() ? 0 : bound.size() - 1;\n+\n+                //\n+                // For each permutation of elements we return, we need to bind n elements (n == set.size()).\n+                // We maintain an iterator through the set (that is stable) for each level up to currentLevel.\n+                // That's the state! The iterator for levels greater than currentLevel must be null. The iterators\n+                // for levels below current level must be on a valid element. The iterator for the currentLevel\n+                // maybe null or a valid element.\n+                //\n+\n+                //\n+                // We also use a set \"bound\" that keeps elements that are currently bound by iterators.\n+                // \"bound\" is solely kept for convenience and is entirely computable from the current\n+                // state of all iterators. We must keep it in sync with the state of the iterators at all times.\n+                //\n+                do {\n+                    //\n+                    // Set the currentIterator. That is the iterator at level currentLevel. If it is null,\n+                    // we create a new iterator over the set.\n+                    //\n+                    final PeekingIterator<T> currentIterator;\n+                    if (state.get(currentLevel) == null) {\n+                        currentIterator = Iterators.peekingIterator(set.iterator());\n+                        state.set(currentLevel, currentIterator);\n+                    } else {\n+                        currentIterator = state.get(currentLevel);\n+                        unbind(currentLevel);\n+                        currentIterator.next();\n+                    }\n+\n+                    //\n+                    // Search currentLevel for a next item that does not violate any constraints. Doing so\n+                    // may exhaust currentIterator in which case we couldn't find another element on the current level.\n+                    // In that case we need to abandon the current level and search on the level above (making that\n+                    // level the current level). If we reach level -1 (i.e. we reach the end of the iterator at level 0\n+                    // we are done.\n+                    // If we do find an element not violating any constraints on the current level we conceptually\n+                    // bind it the element we found and continue on downward.\n+                    //\n+                    final boolean isDown = searchLevel(currentIterator);\n+                    if (!isDown) {\n+                        // back tracking -- need to clear out the current iterator\n+                        state.set(currentLevel, null);\n+                    }\n+                    currentLevel = isDown\n+                                   ? currentLevel + 1\n+                                   : currentLevel - 1;\n+                    \n+                    if (currentLevel == -1) {\n+                        return endOfData();\n+                    }\n+                } while (bound.size() < set.size()); // as long as we still have to find a binding\n+\n+                return state.stream()\n+                        .map(PeekingIterator::peek)\n+                        .collect(ImmutableList.toImmutableList());\n+            }\n+\n+            @SuppressWarnings(\"squid:S135\")\n+            private boolean searchLevel(final PeekingIterator<T> currentIterator) {\n+                while (currentIterator.hasNext()) {\n+                    final T next = currentIterator.peek();\n+\n+                    // check if it is bound already; t is invisible to this loop if it is bound\n+                    if (bound.contains(next)) {\n+                        currentIterator.next();\n+                        continue;\n+                    }\n+\n+                    //\n+                    // Check if t is only dependent on elements in the current bound set, if it is not it must come later.\n+                    // Note that the intersection removes elements the current element depends on that are not in set.\n+                    // That behavior is for convenience reasons and and specifically not an error.\n+                    //\n+                    final Set<T> dependsOn = Sets.intersection(set, dependsOnFn.apply(next));\n+                    if (!bound.containsAll(dependsOn)) {\n+                        currentIterator.next();\n+                        continue;\n+                    }\n+\n+                    // this level can be bound now\n+                    bound.add(next);\n+                    return true; // go down\n+                }\n+                return false; // go up\n+            }\n+\n+            private void unbind(final int level) {\n+                // reset all the following ones\n+                for (int i = level; i < set.size(); i ++ ) {\n+                    // either iterator is on a valid item or iterator is null\n+                    if (state.get(i) != null) {\n+                        bound.remove(state.get(i).peek());\n+                    } else {\n+                        break;\n+                    }\n+                }\n+            }\n+\n+            /**\n+             * Method that skips advances to the next element on the given level.\n+             * @param level level to advance\n+             */\n+            @Override\n+            public void skip(final int level) {\n+                if (level >= set.size()) {\n+                    throw new IndexOutOfBoundsException();\n+                }\n+\n+                if (state.get(level) == null) {\n+                    throw new UnsupportedOperationException(\"cannot skip/unbind as level is not bound at all\");\n+                }\n+\n+                // reset all the following ones\n+                for (int i = level + 1; i < set.size(); i ++ ) {\n+                    // either iterator is on a valid item or iterator is null\n+                    if (state.get(i) != null) {\n+                        bound.remove(state.get(i).peek());\n+                        state.set(i, null);\n+                    } else {\n+                        break;\n+                    }\n+                }\n+            }\n+        }\n+\n+        private ComplexIterable(@Nonnull final Set<T> set, @Nonnull final Function<T, Set<T>> dependsOnFn) {\n+            Verify.verify(set.size() > 1);\n+            this.set = ImmutableSet.copyOf(set);\n+            this.dependsOnFn = dependsOnFn;\n+        }\n+\n+        @Nonnull\n+        @Override\n+        public TopologicalOrderPermutationIterator<T> iterator() {\n+            return new ComplexIterator();\n+        }\n+    }\n+\n+    /**\n+     * An implementation of {@link TopologicalOrderPermutationIterable} that is optimized to work for empty\n+     * inputs sets. The case where the input set is empty is trivial and also properly handled by {@link ComplexIterable}.\n+     * Iterators created by this class, however, avoid to build complex state objects during their lifecycle.\n+     *\n+     * @param <T> type\n+     */\n+    private static class EmptyIterable<T> implements TopologicalOrderPermutationIterable<T> {\n+        private class EmptyIterator extends AbstractIterator<List<T>> implements TopologicalOrderPermutationIterator<T> {\n+            @Override\n+            public void skip(final int level) {\n+                throw new UnsupportedOperationException(\"cannot skip on empty iterator\");\n+            }\n+\n+            @Nullable\n+            @Override\n+            protected List<T> computeNext() {\n+                return endOfData();\n+            }\n+        }\n+\n+        @Nonnull\n+        @Override\n+        public TopologicalOrderPermutationIterator<T> iterator() {\n+            return new EmptyIterator();\n+        }\n+    }\n+\n+    /**\n+     * An implementation of {@link TopologicalOrderPermutationIterable} that is optimized to work for single item\n+     * inputs sets. The case where the input set is exactly one item is trivial and also properly handled by\n+     * {@link ComplexIterable}. Iterators created by this class, however, avoid to build complex state objects\n+     * during their lifecycle.\n+     *\n+     * @param <T> type\n+     */\n+    private static class SingleIterable<T> implements TopologicalOrderPermutationIterable<T> {\n+        private final T singleElement;\n+\n+        private SingleIterable(final T singleElement) {\n+            this.singleElement = singleElement;\n+        }\n+\n+        private class SingleIterator extends AbstractIterator<List<T>> implements TopologicalOrderPermutationIterator<T> {\n+            boolean atFirst = true;\n+\n+            @Override\n+            public void skip(final int level) {\n+                if (atFirst) {\n+                    throw new UnsupportedOperationException(\"cannot skip on before first element\");\n+                }\n+                // no op, we are at the end\n+            }\n+\n+            @Override\n+            protected List<T> computeNext() {\n+                if (!atFirst) {\n+                    return endOfData();\n+                }\n+\n+                atFirst = false;\n+\n+                return ImmutableList.of(singleElement);\n+            }\n+        }\n+\n+        @Nonnull\n+        @Override\n+        public TopologicalOrderPermutationIterator<T> iterator() {\n+            return new SingleIterator();\n+        }\n+    }\n+\n+    /**\n+     * Method to create a {@link TopologicalOrderPermutationIterable} based on a set and a function describing\n+     * the depends-on relationships between items in the given set.\n+     * @param set the set to create the iterable over\n+     * @param dependsOnFn a function from {@code T} to {@code Set<T>} that can be called during the lifecycle of all\n+     *        iterators multiple times repeatedly or not at all for any given element in {@code set}. This method is\n+     *        expected to return instantly and must be stable. Note it is allowed for the set the given function returns\n+     *        to contain elements of type {@code T} that are not in {@code set}. These items are ignored by the\n+     *        underlying algorithm (as in the dependency is instantly considered to be satisfied by all orderings).", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6eb7142ab316ffbec53e375804118f722f1d2bcc"}, "originalPosition": 380}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgzNTY5MzY0OnYy", "diffSide": "RIGHT", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/TopologicalSort.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNFQyMTowODowNlrOGxlZHg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNFQyMTowODowNlrOGxlZHg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDY0NjA0Ng==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public static <T> TopologicalOrderPermutationIterable<T> topologicalOrderPermutations(final Set<T> set, final Function<T, Set<T>> dependsOnFn) {\n          \n          \n            \n                public static <T> TopologicalOrderPermutationIterable<T> topologicalOrderPermutations(@Nonnull final Set<T> set, @Nonnull final Function<T, Set<T>> dependsOnFn) {", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/988#discussion_r454646046", "createdAt": "2020-07-14T21:08:06Z", "author": {"login": "nschiefer"}, "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/TopologicalSort.java", "diffHunk": "@@ -0,0 +1,416 @@\n+/*\n+ * TopologicalSort.java\n+ *\n+ * This source file is part of the FoundationDB open source project\n+ *\n+ * Copyright 2015-2020 Apple Inc. and the FoundationDB project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.apple.foundationdb.record.query.plan.temp;\n+\n+import com.google.common.base.Verify;\n+import com.google.common.collect.AbstractIterator;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.collect.Iterables;\n+import com.google.common.collect.Iterators;\n+import com.google.common.collect.Lists;\n+import com.google.common.collect.PeekingIterator;\n+import com.google.common.collect.Sets;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.function.Function;\n+\n+/**\n+ * Utility class to provide helpers related to topological sorts.\n+ *\n+ * The main purpose on this class is to provide a specific iterable that can efficiently traverse\n+ * all possible permutations of the input set that do not violate the given dependency constraints.\n+ *\n+ * The iterable {@link TopologicalOrderPermutationIterable} adheres to the following requirements:\n+ * 1. it does not violate the given constraints\n+ * 2. it produces all possible orderings under the given constraints\n+ * 3. it reacts appropriately to give circular dependency constraints between elements (i.e. no infinite loops)\n+ * 4. it iterates all orderings on the fly, i.e. it only stores state (i.e. does not (pre)create the orderings in memory).\n+ *\n+ * {@link TopologicalOrderPermutationIterable} subclasses {@link Iterable} in order to provide an additional feature\n+ * that allows for skipping. Assume we have a set\n+ * <pre>\n+ * {@code\n+ * { a, b, c, d } with constraints { b -> c, b -> d } (c depends on b, d depends on b)\n+ * }\n+ * </pre>\n+ *\n+ * Possible orderings are\n+ * <pre>\n+ * {@code\n+ * (a, b, c, d)\n+ * (a, b, d, c)\n+ * (b, a, c, d)\n+ * (b, a, d, c)\n+ * (b, c, a, d)\n+ * (b, c, d, a)\n+ * (b, d, a, c)\n+ * (b, d, c, a)\n+ * }\n+ * </pre>\n+ *\n+ * Frequently we test for a certain property or perform a particular operation given one possible ordering but it is clear\n+ * that it is not necessary to consider more such orderings that share a common prefix. In the example, it may be\n+ * beneficial to skip the rest of the {@code (b, a, ...)} orderings after the first one was returned\n+ * ({@code (b, a, c, d}). In this case we would like to instruct the iterator to skip all such orderings and continue\n+ * iteration at {@code (b, c, a, d)}. Similarly, we want to skip all orderings starting with {@code (b, ...)} once we\n+ * encountered the first such ordering. This the iterators created by the provided {@link TopologicalOrderPermutationIterable}\n+ * of type {@link TopologicalOrderPermutationIterator} provide a method {@link TopologicalOrderPermutationIterator#skip}\n+ * to allow skipping at a provided prefix.\n+ *\n+ */\n+public class TopologicalSort {\n+    /**\n+     * Iterable that provides special iterators of type {@link TopologicalOrderPermutationIterator}.\n+     * @param <T> type\n+     */\n+    public interface TopologicalOrderPermutationIterable<T> extends Iterable<List<T>> {\n+        @Nonnull\n+        @Override\n+        TopologicalOrderPermutationIterator<T> iterator();\n+    }\n+\n+    /**\n+     * An iterator extending {@link Iterator} providing the ability to skip a certain prefix.\n+     * @param <T> type\n+     */\n+    public interface TopologicalOrderPermutationIterator<T> extends Iterator<List<T>> {\n+        /**\n+         * Instructs the iterator to advance to the next possible ordering using the given level.\n+         *\n+         * Example 1: If the last returned ordering of the iterator {@code it} is {@code (e0, e1, e2, e3)} and\n+         *            {@code it.skip(2)} is called, the state of the iterator is advanced in a way that either\n+         *            reaches the end of iteration or the next item that is returned is {@code (e0', e1', e3', e4')}\n+         *            where the prefix {@code (e1', e2', e3')} is not equal to {code (e1, e2, e3)}.\n+         * Example 2: If the last returned ordering of the iterator {@code it} is {@code (e1, e2, e3, e4)} and\n+         *            {@code it.skip(1)} is called, the state of the iterator is advanced in a way that either reaches\n+         *            the end of iteration or the next item that is returned is {@code (e1', e2', e3', e4')} where\n+         *            the prefix {@code (e1', e2')} is not equal to {code (e1, e2)}.\n+         *\n+         * @param level skip level\n+         */\n+        void skip(int level);\n+    }\n+\n+    /**\n+     * A complex iterable it a {@link TopologicalOrderPermutationIterable} that is used for sets of cardinality greater\n+     * than 1 (i.e. the regular case).\n+     * @param <T> type\n+     */\n+    private static class ComplexIterable<T> implements TopologicalOrderPermutationIterable<T> {\n+        @Nonnull\n+        private final ImmutableSet<T> set;\n+        @Nonnull\n+        private final Function<T, Set<T>> dependsOnFn;\n+\n+        private class ComplexIterator extends AbstractIterator<List<T>> implements TopologicalSort.TopologicalOrderPermutationIterator<T> {\n+            // state\n+            private final Set<T> bound;\n+            private final List<PeekingIterator<T>> state;\n+\n+            private ComplexIterator() {\n+                this.bound = Sets.newHashSetWithExpectedSize(set.size());\n+                this.state = Lists.newArrayListWithCapacity(set.size());\n+                for (int i = 0; i < set.size(); i ++ ) {\n+                    this.state.add(null);\n+                }\n+            }\n+\n+            @Nullable\n+            @Override\n+            protected List<T> computeNext() {\n+                //\n+                // The problem to iterate through all possible correct orderings of set is inherently easier to\n+                // encode recursively, however, this being an iterator together with the requirement to skip subtrees\n+                // of iterations warrants an iterative solution. All hail the Church-Turing thesis!\n+                //\n+                if (set.isEmpty()) {\n+                    return endOfData();\n+                }\n+\n+                //\n+                // If nothing is bound yet, we are at the beginning and should start at level 0, otherwise\n+                // we conceptually start at the level of the finest granularity bound. Note that that finest\n+                // granularity is usually the granularity of the last element in the set, but it is possible\n+                // for fewer elements to be bound if this is the first call after a skip.\n+                //\n+                int currentLevel = bound.isEmpty() ? 0 : bound.size() - 1;\n+\n+                //\n+                // For each permutation of elements we return, we need to bind n elements (n == set.size()).\n+                // We maintain an iterator through the set (that is stable) for each level up to currentLevel.\n+                // That's the state! The iterator for levels greater than currentLevel must be null. The iterators\n+                // for levels below current level must be on a valid element. The iterator for the currentLevel\n+                // maybe null or a valid element.\n+                //\n+\n+                //\n+                // We also use a set \"bound\" that keeps elements that are currently bound by iterators.\n+                // \"bound\" is solely kept for convenience and is entirely computable from the current\n+                // state of all iterators. We must keep it in sync with the state of the iterators at all times.\n+                //\n+                do {\n+                    //\n+                    // Set the currentIterator. That is the iterator at level currentLevel. If it is null,\n+                    // we create a new iterator over the set.\n+                    //\n+                    final PeekingIterator<T> currentIterator;\n+                    if (state.get(currentLevel) == null) {\n+                        currentIterator = Iterators.peekingIterator(set.iterator());\n+                        state.set(currentLevel, currentIterator);\n+                    } else {\n+                        currentIterator = state.get(currentLevel);\n+                        unbind(currentLevel);\n+                        currentIterator.next();\n+                    }\n+\n+                    //\n+                    // Search currentLevel for a next item that does not violate any constraints. Doing so\n+                    // may exhaust currentIterator in which case we couldn't find another element on the current level.\n+                    // In that case we need to abandon the current level and search on the level above (making that\n+                    // level the current level). If we reach level -1 (i.e. we reach the end of the iterator at level 0\n+                    // we are done.\n+                    // If we do find an element not violating any constraints on the current level we conceptually\n+                    // bind it the element we found and continue on downward.\n+                    //\n+                    final boolean isDown = searchLevel(currentIterator);\n+                    if (!isDown) {\n+                        // back tracking -- need to clear out the current iterator\n+                        state.set(currentLevel, null);\n+                    }\n+                    currentLevel = isDown\n+                                   ? currentLevel + 1\n+                                   : currentLevel - 1;\n+                    \n+                    if (currentLevel == -1) {\n+                        return endOfData();\n+                    }\n+                } while (bound.size() < set.size()); // as long as we still have to find a binding\n+\n+                return state.stream()\n+                        .map(PeekingIterator::peek)\n+                        .collect(ImmutableList.toImmutableList());\n+            }\n+\n+            @SuppressWarnings(\"squid:S135\")\n+            private boolean searchLevel(final PeekingIterator<T> currentIterator) {\n+                while (currentIterator.hasNext()) {\n+                    final T next = currentIterator.peek();\n+\n+                    // check if it is bound already; t is invisible to this loop if it is bound\n+                    if (bound.contains(next)) {\n+                        currentIterator.next();\n+                        continue;\n+                    }\n+\n+                    //\n+                    // Check if t is only dependent on elements in the current bound set, if it is not it must come later.\n+                    // Note that the intersection removes elements the current element depends on that are not in set.\n+                    // That behavior is for convenience reasons and and specifically not an error.\n+                    //\n+                    final Set<T> dependsOn = Sets.intersection(set, dependsOnFn.apply(next));\n+                    if (!bound.containsAll(dependsOn)) {\n+                        currentIterator.next();\n+                        continue;\n+                    }\n+\n+                    // this level can be bound now\n+                    bound.add(next);\n+                    return true; // go down\n+                }\n+                return false; // go up\n+            }\n+\n+            private void unbind(final int level) {\n+                // reset all the following ones\n+                for (int i = level; i < set.size(); i ++ ) {\n+                    // either iterator is on a valid item or iterator is null\n+                    if (state.get(i) != null) {\n+                        bound.remove(state.get(i).peek());\n+                    } else {\n+                        break;\n+                    }\n+                }\n+            }\n+\n+            /**\n+             * Method that skips advances to the next element on the given level.\n+             * @param level level to advance\n+             */\n+            @Override\n+            public void skip(final int level) {\n+                if (level >= set.size()) {\n+                    throw new IndexOutOfBoundsException();\n+                }\n+\n+                if (state.get(level) == null) {\n+                    throw new UnsupportedOperationException(\"cannot skip/unbind as level is not bound at all\");\n+                }\n+\n+                // reset all the following ones\n+                for (int i = level + 1; i < set.size(); i ++ ) {\n+                    // either iterator is on a valid item or iterator is null\n+                    if (state.get(i) != null) {\n+                        bound.remove(state.get(i).peek());\n+                        state.set(i, null);\n+                    } else {\n+                        break;\n+                    }\n+                }\n+            }\n+        }\n+\n+        private ComplexIterable(@Nonnull final Set<T> set, @Nonnull final Function<T, Set<T>> dependsOnFn) {\n+            Verify.verify(set.size() > 1);\n+            this.set = ImmutableSet.copyOf(set);\n+            this.dependsOnFn = dependsOnFn;\n+        }\n+\n+        @Nonnull\n+        @Override\n+        public TopologicalOrderPermutationIterator<T> iterator() {\n+            return new ComplexIterator();\n+        }\n+    }\n+\n+    /**\n+     * An implementation of {@link TopologicalOrderPermutationIterable} that is optimized to work for empty\n+     * inputs sets. The case where the input set is empty is trivial and also properly handled by {@link ComplexIterable}.\n+     * Iterators created by this class, however, avoid to build complex state objects during their lifecycle.\n+     *\n+     * @param <T> type\n+     */\n+    private static class EmptyIterable<T> implements TopologicalOrderPermutationIterable<T> {\n+        private class EmptyIterator extends AbstractIterator<List<T>> implements TopologicalOrderPermutationIterator<T> {\n+            @Override\n+            public void skip(final int level) {\n+                throw new UnsupportedOperationException(\"cannot skip on empty iterator\");\n+            }\n+\n+            @Nullable\n+            @Override\n+            protected List<T> computeNext() {\n+                return endOfData();\n+            }\n+        }\n+\n+        @Nonnull\n+        @Override\n+        public TopologicalOrderPermutationIterator<T> iterator() {\n+            return new EmptyIterator();\n+        }\n+    }\n+\n+    /**\n+     * An implementation of {@link TopologicalOrderPermutationIterable} that is optimized to work for single item\n+     * inputs sets. The case where the input set is exactly one item is trivial and also properly handled by\n+     * {@link ComplexIterable}. Iterators created by this class, however, avoid to build complex state objects\n+     * during their lifecycle.\n+     *\n+     * @param <T> type\n+     */\n+    private static class SingleIterable<T> implements TopologicalOrderPermutationIterable<T> {\n+        private final T singleElement;\n+\n+        private SingleIterable(final T singleElement) {\n+            this.singleElement = singleElement;\n+        }\n+\n+        private class SingleIterator extends AbstractIterator<List<T>> implements TopologicalOrderPermutationIterator<T> {\n+            boolean atFirst = true;\n+\n+            @Override\n+            public void skip(final int level) {\n+                if (atFirst) {\n+                    throw new UnsupportedOperationException(\"cannot skip on before first element\");\n+                }\n+                // no op, we are at the end\n+            }\n+\n+            @Override\n+            protected List<T> computeNext() {\n+                if (!atFirst) {\n+                    return endOfData();\n+                }\n+\n+                atFirst = false;\n+\n+                return ImmutableList.of(singleElement);\n+            }\n+        }\n+\n+        @Nonnull\n+        @Override\n+        public TopologicalOrderPermutationIterator<T> iterator() {\n+            return new SingleIterator();\n+        }\n+    }\n+\n+    /**\n+     * Method to create a {@link TopologicalOrderPermutationIterable} based on a set and a function describing\n+     * the depends-on relationships between items in the given set.\n+     * @param set the set to create the iterable over\n+     * @param dependsOnFn a function from {@code T} to {@code Set<T>} that can be called during the lifecycle of all\n+     *        iterators multiple times repeatedly or not at all for any given element in {@code set}. This method is\n+     *        expected to return instantly and must be stable. Note it is allowed for the set the given function returns\n+     *        to contain elements of type {@code T} that are not in {@code set}. These items are ignored by the\n+     *        underlying algorithm (as in the dependency is instantly considered to be satisfied by all orderings).\n+     * @param <T> type\n+     * @return a new {@link TopologicalOrderPermutationIterable} that obeys the constraints as expressed in\n+     *         {@code dependsOnFn} in a sense that the iterators created by this iterator will not return\n+     *         orderings that violate the given depends-on constraints.\n+     */\n+    public static <T> TopologicalOrderPermutationIterable<T> topologicalOrderPermutations(final Set<T> set, final Function<T, Set<T>> dependsOnFn) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6eb7142ab316ffbec53e375804118f722f1d2bcc"}, "originalPosition": 386}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgzNTcyMDc1OnYy", "diffSide": "RIGHT", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/TopologicalSort.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNFQyMToxNjoxM1rOGxlpeA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNFQyMToxNjoxM1rOGxlpeA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDY1MDIzMg==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * Method to create a correct topological ordering based on a set and a function describing\n          \n          \n            \n                 *Create a correct topological ordering based on a set and a function describing", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/988#discussion_r454650232", "createdAt": "2020-07-14T21:16:13Z", "author": {"login": "nschiefer"}, "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/TopologicalSort.java", "diffHunk": "@@ -0,0 +1,416 @@\n+/*\n+ * TopologicalSort.java\n+ *\n+ * This source file is part of the FoundationDB open source project\n+ *\n+ * Copyright 2015-2020 Apple Inc. and the FoundationDB project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.apple.foundationdb.record.query.plan.temp;\n+\n+import com.google.common.base.Verify;\n+import com.google.common.collect.AbstractIterator;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.collect.Iterables;\n+import com.google.common.collect.Iterators;\n+import com.google.common.collect.Lists;\n+import com.google.common.collect.PeekingIterator;\n+import com.google.common.collect.Sets;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.function.Function;\n+\n+/**\n+ * Utility class to provide helpers related to topological sorts.\n+ *\n+ * The main purpose on this class is to provide a specific iterable that can efficiently traverse\n+ * all possible permutations of the input set that do not violate the given dependency constraints.\n+ *\n+ * The iterable {@link TopologicalOrderPermutationIterable} adheres to the following requirements:\n+ * 1. it does not violate the given constraints\n+ * 2. it produces all possible orderings under the given constraints\n+ * 3. it reacts appropriately to give circular dependency constraints between elements (i.e. no infinite loops)\n+ * 4. it iterates all orderings on the fly, i.e. it only stores state (i.e. does not (pre)create the orderings in memory).\n+ *\n+ * {@link TopologicalOrderPermutationIterable} subclasses {@link Iterable} in order to provide an additional feature\n+ * that allows for skipping. Assume we have a set\n+ * <pre>\n+ * {@code\n+ * { a, b, c, d } with constraints { b -> c, b -> d } (c depends on b, d depends on b)\n+ * }\n+ * </pre>\n+ *\n+ * Possible orderings are\n+ * <pre>\n+ * {@code\n+ * (a, b, c, d)\n+ * (a, b, d, c)\n+ * (b, a, c, d)\n+ * (b, a, d, c)\n+ * (b, c, a, d)\n+ * (b, c, d, a)\n+ * (b, d, a, c)\n+ * (b, d, c, a)\n+ * }\n+ * </pre>\n+ *\n+ * Frequently we test for a certain property or perform a particular operation given one possible ordering but it is clear\n+ * that it is not necessary to consider more such orderings that share a common prefix. In the example, it may be\n+ * beneficial to skip the rest of the {@code (b, a, ...)} orderings after the first one was returned\n+ * ({@code (b, a, c, d}). In this case we would like to instruct the iterator to skip all such orderings and continue\n+ * iteration at {@code (b, c, a, d)}. Similarly, we want to skip all orderings starting with {@code (b, ...)} once we\n+ * encountered the first such ordering. This the iterators created by the provided {@link TopologicalOrderPermutationIterable}\n+ * of type {@link TopologicalOrderPermutationIterator} provide a method {@link TopologicalOrderPermutationIterator#skip}\n+ * to allow skipping at a provided prefix.\n+ *\n+ */\n+public class TopologicalSort {\n+    /**\n+     * Iterable that provides special iterators of type {@link TopologicalOrderPermutationIterator}.\n+     * @param <T> type\n+     */\n+    public interface TopologicalOrderPermutationIterable<T> extends Iterable<List<T>> {\n+        @Nonnull\n+        @Override\n+        TopologicalOrderPermutationIterator<T> iterator();\n+    }\n+\n+    /**\n+     * An iterator extending {@link Iterator} providing the ability to skip a certain prefix.\n+     * @param <T> type\n+     */\n+    public interface TopologicalOrderPermutationIterator<T> extends Iterator<List<T>> {\n+        /**\n+         * Instructs the iterator to advance to the next possible ordering using the given level.\n+         *\n+         * Example 1: If the last returned ordering of the iterator {@code it} is {@code (e0, e1, e2, e3)} and\n+         *            {@code it.skip(2)} is called, the state of the iterator is advanced in a way that either\n+         *            reaches the end of iteration or the next item that is returned is {@code (e0', e1', e3', e4')}\n+         *            where the prefix {@code (e1', e2', e3')} is not equal to {code (e1, e2, e3)}.\n+         * Example 2: If the last returned ordering of the iterator {@code it} is {@code (e1, e2, e3, e4)} and\n+         *            {@code it.skip(1)} is called, the state of the iterator is advanced in a way that either reaches\n+         *            the end of iteration or the next item that is returned is {@code (e1', e2', e3', e4')} where\n+         *            the prefix {@code (e1', e2')} is not equal to {code (e1, e2)}.\n+         *\n+         * @param level skip level\n+         */\n+        void skip(int level);\n+    }\n+\n+    /**\n+     * A complex iterable it a {@link TopologicalOrderPermutationIterable} that is used for sets of cardinality greater\n+     * than 1 (i.e. the regular case).\n+     * @param <T> type\n+     */\n+    private static class ComplexIterable<T> implements TopologicalOrderPermutationIterable<T> {\n+        @Nonnull\n+        private final ImmutableSet<T> set;\n+        @Nonnull\n+        private final Function<T, Set<T>> dependsOnFn;\n+\n+        private class ComplexIterator extends AbstractIterator<List<T>> implements TopologicalSort.TopologicalOrderPermutationIterator<T> {\n+            // state\n+            private final Set<T> bound;\n+            private final List<PeekingIterator<T>> state;\n+\n+            private ComplexIterator() {\n+                this.bound = Sets.newHashSetWithExpectedSize(set.size());\n+                this.state = Lists.newArrayListWithCapacity(set.size());\n+                for (int i = 0; i < set.size(); i ++ ) {\n+                    this.state.add(null);\n+                }\n+            }\n+\n+            @Nullable\n+            @Override\n+            protected List<T> computeNext() {\n+                //\n+                // The problem to iterate through all possible correct orderings of set is inherently easier to\n+                // encode recursively, however, this being an iterator together with the requirement to skip subtrees\n+                // of iterations warrants an iterative solution. All hail the Church-Turing thesis!\n+                //\n+                if (set.isEmpty()) {\n+                    return endOfData();\n+                }\n+\n+                //\n+                // If nothing is bound yet, we are at the beginning and should start at level 0, otherwise\n+                // we conceptually start at the level of the finest granularity bound. Note that that finest\n+                // granularity is usually the granularity of the last element in the set, but it is possible\n+                // for fewer elements to be bound if this is the first call after a skip.\n+                //\n+                int currentLevel = bound.isEmpty() ? 0 : bound.size() - 1;\n+\n+                //\n+                // For each permutation of elements we return, we need to bind n elements (n == set.size()).\n+                // We maintain an iterator through the set (that is stable) for each level up to currentLevel.\n+                // That's the state! The iterator for levels greater than currentLevel must be null. The iterators\n+                // for levels below current level must be on a valid element. The iterator for the currentLevel\n+                // maybe null or a valid element.\n+                //\n+\n+                //\n+                // We also use a set \"bound\" that keeps elements that are currently bound by iterators.\n+                // \"bound\" is solely kept for convenience and is entirely computable from the current\n+                // state of all iterators. We must keep it in sync with the state of the iterators at all times.\n+                //\n+                do {\n+                    //\n+                    // Set the currentIterator. That is the iterator at level currentLevel. If it is null,\n+                    // we create a new iterator over the set.\n+                    //\n+                    final PeekingIterator<T> currentIterator;\n+                    if (state.get(currentLevel) == null) {\n+                        currentIterator = Iterators.peekingIterator(set.iterator());\n+                        state.set(currentLevel, currentIterator);\n+                    } else {\n+                        currentIterator = state.get(currentLevel);\n+                        unbind(currentLevel);\n+                        currentIterator.next();\n+                    }\n+\n+                    //\n+                    // Search currentLevel for a next item that does not violate any constraints. Doing so\n+                    // may exhaust currentIterator in which case we couldn't find another element on the current level.\n+                    // In that case we need to abandon the current level and search on the level above (making that\n+                    // level the current level). If we reach level -1 (i.e. we reach the end of the iterator at level 0\n+                    // we are done.\n+                    // If we do find an element not violating any constraints on the current level we conceptually\n+                    // bind it the element we found and continue on downward.\n+                    //\n+                    final boolean isDown = searchLevel(currentIterator);\n+                    if (!isDown) {\n+                        // back tracking -- need to clear out the current iterator\n+                        state.set(currentLevel, null);\n+                    }\n+                    currentLevel = isDown\n+                                   ? currentLevel + 1\n+                                   : currentLevel - 1;\n+                    \n+                    if (currentLevel == -1) {\n+                        return endOfData();\n+                    }\n+                } while (bound.size() < set.size()); // as long as we still have to find a binding\n+\n+                return state.stream()\n+                        .map(PeekingIterator::peek)\n+                        .collect(ImmutableList.toImmutableList());\n+            }\n+\n+            @SuppressWarnings(\"squid:S135\")\n+            private boolean searchLevel(final PeekingIterator<T> currentIterator) {\n+                while (currentIterator.hasNext()) {\n+                    final T next = currentIterator.peek();\n+\n+                    // check if it is bound already; t is invisible to this loop if it is bound\n+                    if (bound.contains(next)) {\n+                        currentIterator.next();\n+                        continue;\n+                    }\n+\n+                    //\n+                    // Check if t is only dependent on elements in the current bound set, if it is not it must come later.\n+                    // Note that the intersection removes elements the current element depends on that are not in set.\n+                    // That behavior is for convenience reasons and and specifically not an error.\n+                    //\n+                    final Set<T> dependsOn = Sets.intersection(set, dependsOnFn.apply(next));\n+                    if (!bound.containsAll(dependsOn)) {\n+                        currentIterator.next();\n+                        continue;\n+                    }\n+\n+                    // this level can be bound now\n+                    bound.add(next);\n+                    return true; // go down\n+                }\n+                return false; // go up\n+            }\n+\n+            private void unbind(final int level) {\n+                // reset all the following ones\n+                for (int i = level; i < set.size(); i ++ ) {\n+                    // either iterator is on a valid item or iterator is null\n+                    if (state.get(i) != null) {\n+                        bound.remove(state.get(i).peek());\n+                    } else {\n+                        break;\n+                    }\n+                }\n+            }\n+\n+            /**\n+             * Method that skips advances to the next element on the given level.\n+             * @param level level to advance\n+             */\n+            @Override\n+            public void skip(final int level) {\n+                if (level >= set.size()) {\n+                    throw new IndexOutOfBoundsException();\n+                }\n+\n+                if (state.get(level) == null) {\n+                    throw new UnsupportedOperationException(\"cannot skip/unbind as level is not bound at all\");\n+                }\n+\n+                // reset all the following ones\n+                for (int i = level + 1; i < set.size(); i ++ ) {\n+                    // either iterator is on a valid item or iterator is null\n+                    if (state.get(i) != null) {\n+                        bound.remove(state.get(i).peek());\n+                        state.set(i, null);\n+                    } else {\n+                        break;\n+                    }\n+                }\n+            }\n+        }\n+\n+        private ComplexIterable(@Nonnull final Set<T> set, @Nonnull final Function<T, Set<T>> dependsOnFn) {\n+            Verify.verify(set.size() > 1);\n+            this.set = ImmutableSet.copyOf(set);\n+            this.dependsOnFn = dependsOnFn;\n+        }\n+\n+        @Nonnull\n+        @Override\n+        public TopologicalOrderPermutationIterator<T> iterator() {\n+            return new ComplexIterator();\n+        }\n+    }\n+\n+    /**\n+     * An implementation of {@link TopologicalOrderPermutationIterable} that is optimized to work for empty\n+     * inputs sets. The case where the input set is empty is trivial and also properly handled by {@link ComplexIterable}.\n+     * Iterators created by this class, however, avoid to build complex state objects during their lifecycle.\n+     *\n+     * @param <T> type\n+     */\n+    private static class EmptyIterable<T> implements TopologicalOrderPermutationIterable<T> {\n+        private class EmptyIterator extends AbstractIterator<List<T>> implements TopologicalOrderPermutationIterator<T> {\n+            @Override\n+            public void skip(final int level) {\n+                throw new UnsupportedOperationException(\"cannot skip on empty iterator\");\n+            }\n+\n+            @Nullable\n+            @Override\n+            protected List<T> computeNext() {\n+                return endOfData();\n+            }\n+        }\n+\n+        @Nonnull\n+        @Override\n+        public TopologicalOrderPermutationIterator<T> iterator() {\n+            return new EmptyIterator();\n+        }\n+    }\n+\n+    /**\n+     * An implementation of {@link TopologicalOrderPermutationIterable} that is optimized to work for single item\n+     * inputs sets. The case where the input set is exactly one item is trivial and also properly handled by\n+     * {@link ComplexIterable}. Iterators created by this class, however, avoid to build complex state objects\n+     * during their lifecycle.\n+     *\n+     * @param <T> type\n+     */\n+    private static class SingleIterable<T> implements TopologicalOrderPermutationIterable<T> {\n+        private final T singleElement;\n+\n+        private SingleIterable(final T singleElement) {\n+            this.singleElement = singleElement;\n+        }\n+\n+        private class SingleIterator extends AbstractIterator<List<T>> implements TopologicalOrderPermutationIterator<T> {\n+            boolean atFirst = true;\n+\n+            @Override\n+            public void skip(final int level) {\n+                if (atFirst) {\n+                    throw new UnsupportedOperationException(\"cannot skip on before first element\");\n+                }\n+                // no op, we are at the end\n+            }\n+\n+            @Override\n+            protected List<T> computeNext() {\n+                if (!atFirst) {\n+                    return endOfData();\n+                }\n+\n+                atFirst = false;\n+\n+                return ImmutableList.of(singleElement);\n+            }\n+        }\n+\n+        @Nonnull\n+        @Override\n+        public TopologicalOrderPermutationIterator<T> iterator() {\n+            return new SingleIterator();\n+        }\n+    }\n+\n+    /**\n+     * Method to create a {@link TopologicalOrderPermutationIterable} based on a set and a function describing\n+     * the depends-on relationships between items in the given set.\n+     * @param set the set to create the iterable over\n+     * @param dependsOnFn a function from {@code T} to {@code Set<T>} that can be called during the lifecycle of all\n+     *        iterators multiple times repeatedly or not at all for any given element in {@code set}. This method is\n+     *        expected to return instantly and must be stable. Note it is allowed for the set the given function returns\n+     *        to contain elements of type {@code T} that are not in {@code set}. These items are ignored by the\n+     *        underlying algorithm (as in the dependency is instantly considered to be satisfied by all orderings).\n+     * @param <T> type\n+     * @return a new {@link TopologicalOrderPermutationIterable} that obeys the constraints as expressed in\n+     *         {@code dependsOnFn} in a sense that the iterators created by this iterator will not return\n+     *         orderings that violate the given depends-on constraints.\n+     */\n+    public static <T> TopologicalOrderPermutationIterable<T> topologicalOrderPermutations(final Set<T> set, final Function<T, Set<T>> dependsOnFn) {\n+        if (set.isEmpty()) {\n+            return new EmptyIterable<>();\n+        } else if (set.size() == 1) {\n+            return new SingleIterable<>(Iterables.getOnlyElement(set));\n+        }\n+        return new ComplexIterable<>(set, dependsOnFn);\n+    }\n+\n+    /**\n+     * Method to create a correct topological ordering based on a set and a function describing", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6eb7142ab316ffbec53e375804118f722f1d2bcc"}, "originalPosition": 396}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgzNTcyMTcwOnYy", "diffSide": "RIGHT", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/TopologicalSort.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNFQyMToxNjoyOFrOGxlqCQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNFQyMToxNjoyOFrOGxlqCQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDY1MDM3Nw==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * @return A permutation the set that is topologically correctly ordered with respect to {@code dependsOnFn}.\n          \n          \n            \n                 * @return a permutation of the set that is topologically correctly ordered with respect to {@code dependsOnFn}", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/988#discussion_r454650377", "createdAt": "2020-07-14T21:16:28Z", "author": {"login": "nschiefer"}, "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/TopologicalSort.java", "diffHunk": "@@ -0,0 +1,416 @@\n+/*\n+ * TopologicalSort.java\n+ *\n+ * This source file is part of the FoundationDB open source project\n+ *\n+ * Copyright 2015-2020 Apple Inc. and the FoundationDB project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.apple.foundationdb.record.query.plan.temp;\n+\n+import com.google.common.base.Verify;\n+import com.google.common.collect.AbstractIterator;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.collect.Iterables;\n+import com.google.common.collect.Iterators;\n+import com.google.common.collect.Lists;\n+import com.google.common.collect.PeekingIterator;\n+import com.google.common.collect.Sets;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.function.Function;\n+\n+/**\n+ * Utility class to provide helpers related to topological sorts.\n+ *\n+ * The main purpose on this class is to provide a specific iterable that can efficiently traverse\n+ * all possible permutations of the input set that do not violate the given dependency constraints.\n+ *\n+ * The iterable {@link TopologicalOrderPermutationIterable} adheres to the following requirements:\n+ * 1. it does not violate the given constraints\n+ * 2. it produces all possible orderings under the given constraints\n+ * 3. it reacts appropriately to give circular dependency constraints between elements (i.e. no infinite loops)\n+ * 4. it iterates all orderings on the fly, i.e. it only stores state (i.e. does not (pre)create the orderings in memory).\n+ *\n+ * {@link TopologicalOrderPermutationIterable} subclasses {@link Iterable} in order to provide an additional feature\n+ * that allows for skipping. Assume we have a set\n+ * <pre>\n+ * {@code\n+ * { a, b, c, d } with constraints { b -> c, b -> d } (c depends on b, d depends on b)\n+ * }\n+ * </pre>\n+ *\n+ * Possible orderings are\n+ * <pre>\n+ * {@code\n+ * (a, b, c, d)\n+ * (a, b, d, c)\n+ * (b, a, c, d)\n+ * (b, a, d, c)\n+ * (b, c, a, d)\n+ * (b, c, d, a)\n+ * (b, d, a, c)\n+ * (b, d, c, a)\n+ * }\n+ * </pre>\n+ *\n+ * Frequently we test for a certain property or perform a particular operation given one possible ordering but it is clear\n+ * that it is not necessary to consider more such orderings that share a common prefix. In the example, it may be\n+ * beneficial to skip the rest of the {@code (b, a, ...)} orderings after the first one was returned\n+ * ({@code (b, a, c, d}). In this case we would like to instruct the iterator to skip all such orderings and continue\n+ * iteration at {@code (b, c, a, d)}. Similarly, we want to skip all orderings starting with {@code (b, ...)} once we\n+ * encountered the first such ordering. This the iterators created by the provided {@link TopologicalOrderPermutationIterable}\n+ * of type {@link TopologicalOrderPermutationIterator} provide a method {@link TopologicalOrderPermutationIterator#skip}\n+ * to allow skipping at a provided prefix.\n+ *\n+ */\n+public class TopologicalSort {\n+    /**\n+     * Iterable that provides special iterators of type {@link TopologicalOrderPermutationIterator}.\n+     * @param <T> type\n+     */\n+    public interface TopologicalOrderPermutationIterable<T> extends Iterable<List<T>> {\n+        @Nonnull\n+        @Override\n+        TopologicalOrderPermutationIterator<T> iterator();\n+    }\n+\n+    /**\n+     * An iterator extending {@link Iterator} providing the ability to skip a certain prefix.\n+     * @param <T> type\n+     */\n+    public interface TopologicalOrderPermutationIterator<T> extends Iterator<List<T>> {\n+        /**\n+         * Instructs the iterator to advance to the next possible ordering using the given level.\n+         *\n+         * Example 1: If the last returned ordering of the iterator {@code it} is {@code (e0, e1, e2, e3)} and\n+         *            {@code it.skip(2)} is called, the state of the iterator is advanced in a way that either\n+         *            reaches the end of iteration or the next item that is returned is {@code (e0', e1', e3', e4')}\n+         *            where the prefix {@code (e1', e2', e3')} is not equal to {code (e1, e2, e3)}.\n+         * Example 2: If the last returned ordering of the iterator {@code it} is {@code (e1, e2, e3, e4)} and\n+         *            {@code it.skip(1)} is called, the state of the iterator is advanced in a way that either reaches\n+         *            the end of iteration or the next item that is returned is {@code (e1', e2', e3', e4')} where\n+         *            the prefix {@code (e1', e2')} is not equal to {code (e1, e2)}.\n+         *\n+         * @param level skip level\n+         */\n+        void skip(int level);\n+    }\n+\n+    /**\n+     * A complex iterable it a {@link TopologicalOrderPermutationIterable} that is used for sets of cardinality greater\n+     * than 1 (i.e. the regular case).\n+     * @param <T> type\n+     */\n+    private static class ComplexIterable<T> implements TopologicalOrderPermutationIterable<T> {\n+        @Nonnull\n+        private final ImmutableSet<T> set;\n+        @Nonnull\n+        private final Function<T, Set<T>> dependsOnFn;\n+\n+        private class ComplexIterator extends AbstractIterator<List<T>> implements TopologicalSort.TopologicalOrderPermutationIterator<T> {\n+            // state\n+            private final Set<T> bound;\n+            private final List<PeekingIterator<T>> state;\n+\n+            private ComplexIterator() {\n+                this.bound = Sets.newHashSetWithExpectedSize(set.size());\n+                this.state = Lists.newArrayListWithCapacity(set.size());\n+                for (int i = 0; i < set.size(); i ++ ) {\n+                    this.state.add(null);\n+                }\n+            }\n+\n+            @Nullable\n+            @Override\n+            protected List<T> computeNext() {\n+                //\n+                // The problem to iterate through all possible correct orderings of set is inherently easier to\n+                // encode recursively, however, this being an iterator together with the requirement to skip subtrees\n+                // of iterations warrants an iterative solution. All hail the Church-Turing thesis!\n+                //\n+                if (set.isEmpty()) {\n+                    return endOfData();\n+                }\n+\n+                //\n+                // If nothing is bound yet, we are at the beginning and should start at level 0, otherwise\n+                // we conceptually start at the level of the finest granularity bound. Note that that finest\n+                // granularity is usually the granularity of the last element in the set, but it is possible\n+                // for fewer elements to be bound if this is the first call after a skip.\n+                //\n+                int currentLevel = bound.isEmpty() ? 0 : bound.size() - 1;\n+\n+                //\n+                // For each permutation of elements we return, we need to bind n elements (n == set.size()).\n+                // We maintain an iterator through the set (that is stable) for each level up to currentLevel.\n+                // That's the state! The iterator for levels greater than currentLevel must be null. The iterators\n+                // for levels below current level must be on a valid element. The iterator for the currentLevel\n+                // maybe null or a valid element.\n+                //\n+\n+                //\n+                // We also use a set \"bound\" that keeps elements that are currently bound by iterators.\n+                // \"bound\" is solely kept for convenience and is entirely computable from the current\n+                // state of all iterators. We must keep it in sync with the state of the iterators at all times.\n+                //\n+                do {\n+                    //\n+                    // Set the currentIterator. That is the iterator at level currentLevel. If it is null,\n+                    // we create a new iterator over the set.\n+                    //\n+                    final PeekingIterator<T> currentIterator;\n+                    if (state.get(currentLevel) == null) {\n+                        currentIterator = Iterators.peekingIterator(set.iterator());\n+                        state.set(currentLevel, currentIterator);\n+                    } else {\n+                        currentIterator = state.get(currentLevel);\n+                        unbind(currentLevel);\n+                        currentIterator.next();\n+                    }\n+\n+                    //\n+                    // Search currentLevel for a next item that does not violate any constraints. Doing so\n+                    // may exhaust currentIterator in which case we couldn't find another element on the current level.\n+                    // In that case we need to abandon the current level and search on the level above (making that\n+                    // level the current level). If we reach level -1 (i.e. we reach the end of the iterator at level 0\n+                    // we are done.\n+                    // If we do find an element not violating any constraints on the current level we conceptually\n+                    // bind it the element we found and continue on downward.\n+                    //\n+                    final boolean isDown = searchLevel(currentIterator);\n+                    if (!isDown) {\n+                        // back tracking -- need to clear out the current iterator\n+                        state.set(currentLevel, null);\n+                    }\n+                    currentLevel = isDown\n+                                   ? currentLevel + 1\n+                                   : currentLevel - 1;\n+                    \n+                    if (currentLevel == -1) {\n+                        return endOfData();\n+                    }\n+                } while (bound.size() < set.size()); // as long as we still have to find a binding\n+\n+                return state.stream()\n+                        .map(PeekingIterator::peek)\n+                        .collect(ImmutableList.toImmutableList());\n+            }\n+\n+            @SuppressWarnings(\"squid:S135\")\n+            private boolean searchLevel(final PeekingIterator<T> currentIterator) {\n+                while (currentIterator.hasNext()) {\n+                    final T next = currentIterator.peek();\n+\n+                    // check if it is bound already; t is invisible to this loop if it is bound\n+                    if (bound.contains(next)) {\n+                        currentIterator.next();\n+                        continue;\n+                    }\n+\n+                    //\n+                    // Check if t is only dependent on elements in the current bound set, if it is not it must come later.\n+                    // Note that the intersection removes elements the current element depends on that are not in set.\n+                    // That behavior is for convenience reasons and and specifically not an error.\n+                    //\n+                    final Set<T> dependsOn = Sets.intersection(set, dependsOnFn.apply(next));\n+                    if (!bound.containsAll(dependsOn)) {\n+                        currentIterator.next();\n+                        continue;\n+                    }\n+\n+                    // this level can be bound now\n+                    bound.add(next);\n+                    return true; // go down\n+                }\n+                return false; // go up\n+            }\n+\n+            private void unbind(final int level) {\n+                // reset all the following ones\n+                for (int i = level; i < set.size(); i ++ ) {\n+                    // either iterator is on a valid item or iterator is null\n+                    if (state.get(i) != null) {\n+                        bound.remove(state.get(i).peek());\n+                    } else {\n+                        break;\n+                    }\n+                }\n+            }\n+\n+            /**\n+             * Method that skips advances to the next element on the given level.\n+             * @param level level to advance\n+             */\n+            @Override\n+            public void skip(final int level) {\n+                if (level >= set.size()) {\n+                    throw new IndexOutOfBoundsException();\n+                }\n+\n+                if (state.get(level) == null) {\n+                    throw new UnsupportedOperationException(\"cannot skip/unbind as level is not bound at all\");\n+                }\n+\n+                // reset all the following ones\n+                for (int i = level + 1; i < set.size(); i ++ ) {\n+                    // either iterator is on a valid item or iterator is null\n+                    if (state.get(i) != null) {\n+                        bound.remove(state.get(i).peek());\n+                        state.set(i, null);\n+                    } else {\n+                        break;\n+                    }\n+                }\n+            }\n+        }\n+\n+        private ComplexIterable(@Nonnull final Set<T> set, @Nonnull final Function<T, Set<T>> dependsOnFn) {\n+            Verify.verify(set.size() > 1);\n+            this.set = ImmutableSet.copyOf(set);\n+            this.dependsOnFn = dependsOnFn;\n+        }\n+\n+        @Nonnull\n+        @Override\n+        public TopologicalOrderPermutationIterator<T> iterator() {\n+            return new ComplexIterator();\n+        }\n+    }\n+\n+    /**\n+     * An implementation of {@link TopologicalOrderPermutationIterable} that is optimized to work for empty\n+     * inputs sets. The case where the input set is empty is trivial and also properly handled by {@link ComplexIterable}.\n+     * Iterators created by this class, however, avoid to build complex state objects during their lifecycle.\n+     *\n+     * @param <T> type\n+     */\n+    private static class EmptyIterable<T> implements TopologicalOrderPermutationIterable<T> {\n+        private class EmptyIterator extends AbstractIterator<List<T>> implements TopologicalOrderPermutationIterator<T> {\n+            @Override\n+            public void skip(final int level) {\n+                throw new UnsupportedOperationException(\"cannot skip on empty iterator\");\n+            }\n+\n+            @Nullable\n+            @Override\n+            protected List<T> computeNext() {\n+                return endOfData();\n+            }\n+        }\n+\n+        @Nonnull\n+        @Override\n+        public TopologicalOrderPermutationIterator<T> iterator() {\n+            return new EmptyIterator();\n+        }\n+    }\n+\n+    /**\n+     * An implementation of {@link TopologicalOrderPermutationIterable} that is optimized to work for single item\n+     * inputs sets. The case where the input set is exactly one item is trivial and also properly handled by\n+     * {@link ComplexIterable}. Iterators created by this class, however, avoid to build complex state objects\n+     * during their lifecycle.\n+     *\n+     * @param <T> type\n+     */\n+    private static class SingleIterable<T> implements TopologicalOrderPermutationIterable<T> {\n+        private final T singleElement;\n+\n+        private SingleIterable(final T singleElement) {\n+            this.singleElement = singleElement;\n+        }\n+\n+        private class SingleIterator extends AbstractIterator<List<T>> implements TopologicalOrderPermutationIterator<T> {\n+            boolean atFirst = true;\n+\n+            @Override\n+            public void skip(final int level) {\n+                if (atFirst) {\n+                    throw new UnsupportedOperationException(\"cannot skip on before first element\");\n+                }\n+                // no op, we are at the end\n+            }\n+\n+            @Override\n+            protected List<T> computeNext() {\n+                if (!atFirst) {\n+                    return endOfData();\n+                }\n+\n+                atFirst = false;\n+\n+                return ImmutableList.of(singleElement);\n+            }\n+        }\n+\n+        @Nonnull\n+        @Override\n+        public TopologicalOrderPermutationIterator<T> iterator() {\n+            return new SingleIterator();\n+        }\n+    }\n+\n+    /**\n+     * Method to create a {@link TopologicalOrderPermutationIterable} based on a set and a function describing\n+     * the depends-on relationships between items in the given set.\n+     * @param set the set to create the iterable over\n+     * @param dependsOnFn a function from {@code T} to {@code Set<T>} that can be called during the lifecycle of all\n+     *        iterators multiple times repeatedly or not at all for any given element in {@code set}. This method is\n+     *        expected to return instantly and must be stable. Note it is allowed for the set the given function returns\n+     *        to contain elements of type {@code T} that are not in {@code set}. These items are ignored by the\n+     *        underlying algorithm (as in the dependency is instantly considered to be satisfied by all orderings).\n+     * @param <T> type\n+     * @return a new {@link TopologicalOrderPermutationIterable} that obeys the constraints as expressed in\n+     *         {@code dependsOnFn} in a sense that the iterators created by this iterator will not return\n+     *         orderings that violate the given depends-on constraints.\n+     */\n+    public static <T> TopologicalOrderPermutationIterable<T> topologicalOrderPermutations(final Set<T> set, final Function<T, Set<T>> dependsOnFn) {\n+        if (set.isEmpty()) {\n+            return new EmptyIterable<>();\n+        } else if (set.size() == 1) {\n+            return new SingleIterable<>(Iterables.getOnlyElement(set));\n+        }\n+        return new ComplexIterable<>(set, dependsOnFn);\n+    }\n+\n+    /**\n+     * Method to create a correct topological ordering based on a set and a function describing\n+     * the depends-on relationships between items in the given set.\n+     * @param set the set to create the iterable over\n+     * @param dependsOnFn a function from {@code T} to {@code Set<T>} that can be called during the lifecycle of all\n+     *        iterators multiple times repeatedly or not at all for any given element in {@code set}. This method is\n+     *        expected to return instantly and must be stable. Note it is allowed for the set the given function returns\n+     *        to contain elements of type {@code T} that are not in {@code set}. These items are ignored by the\n+     *        underlying algorithm (as in the dependency is instantly considered to be satisfied by all orderings).\n+     * @param <T> type\n+     * @return A permutation the set that is topologically correctly ordered with respect to {@code dependsOnFn}.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6eb7142ab316ffbec53e375804118f722f1d2bcc"}, "originalPosition": 405}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgzNTcyMzQ0OnYy", "diffSide": "RIGHT", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/TopologicalSort.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNFQyMToxNjo1NlrOGxlrCA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNFQyMToxNjo1NlrOGxlrCA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDY1MDYzMg==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public static <T> Optional<List<T>> anyTopologicalOrderPermutation(final Set<T> set, final Function<T, Set<T>> dependsOnFn) {\n          \n          \n            \n                public static <T> Optional<List<T>> anyTopologicalOrderPermutation(@Nonnull final Set<T> set, @Nonnull final Function<T, Set<T>> dependsOnFn) {", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/988#discussion_r454650632", "createdAt": "2020-07-14T21:16:56Z", "author": {"login": "nschiefer"}, "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/TopologicalSort.java", "diffHunk": "@@ -0,0 +1,416 @@\n+/*\n+ * TopologicalSort.java\n+ *\n+ * This source file is part of the FoundationDB open source project\n+ *\n+ * Copyright 2015-2020 Apple Inc. and the FoundationDB project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.apple.foundationdb.record.query.plan.temp;\n+\n+import com.google.common.base.Verify;\n+import com.google.common.collect.AbstractIterator;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.collect.Iterables;\n+import com.google.common.collect.Iterators;\n+import com.google.common.collect.Lists;\n+import com.google.common.collect.PeekingIterator;\n+import com.google.common.collect.Sets;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.function.Function;\n+\n+/**\n+ * Utility class to provide helpers related to topological sorts.\n+ *\n+ * The main purpose on this class is to provide a specific iterable that can efficiently traverse\n+ * all possible permutations of the input set that do not violate the given dependency constraints.\n+ *\n+ * The iterable {@link TopologicalOrderPermutationIterable} adheres to the following requirements:\n+ * 1. it does not violate the given constraints\n+ * 2. it produces all possible orderings under the given constraints\n+ * 3. it reacts appropriately to give circular dependency constraints between elements (i.e. no infinite loops)\n+ * 4. it iterates all orderings on the fly, i.e. it only stores state (i.e. does not (pre)create the orderings in memory).\n+ *\n+ * {@link TopologicalOrderPermutationIterable} subclasses {@link Iterable} in order to provide an additional feature\n+ * that allows for skipping. Assume we have a set\n+ * <pre>\n+ * {@code\n+ * { a, b, c, d } with constraints { b -> c, b -> d } (c depends on b, d depends on b)\n+ * }\n+ * </pre>\n+ *\n+ * Possible orderings are\n+ * <pre>\n+ * {@code\n+ * (a, b, c, d)\n+ * (a, b, d, c)\n+ * (b, a, c, d)\n+ * (b, a, d, c)\n+ * (b, c, a, d)\n+ * (b, c, d, a)\n+ * (b, d, a, c)\n+ * (b, d, c, a)\n+ * }\n+ * </pre>\n+ *\n+ * Frequently we test for a certain property or perform a particular operation given one possible ordering but it is clear\n+ * that it is not necessary to consider more such orderings that share a common prefix. In the example, it may be\n+ * beneficial to skip the rest of the {@code (b, a, ...)} orderings after the first one was returned\n+ * ({@code (b, a, c, d}). In this case we would like to instruct the iterator to skip all such orderings and continue\n+ * iteration at {@code (b, c, a, d)}. Similarly, we want to skip all orderings starting with {@code (b, ...)} once we\n+ * encountered the first such ordering. This the iterators created by the provided {@link TopologicalOrderPermutationIterable}\n+ * of type {@link TopologicalOrderPermutationIterator} provide a method {@link TopologicalOrderPermutationIterator#skip}\n+ * to allow skipping at a provided prefix.\n+ *\n+ */\n+public class TopologicalSort {\n+    /**\n+     * Iterable that provides special iterators of type {@link TopologicalOrderPermutationIterator}.\n+     * @param <T> type\n+     */\n+    public interface TopologicalOrderPermutationIterable<T> extends Iterable<List<T>> {\n+        @Nonnull\n+        @Override\n+        TopologicalOrderPermutationIterator<T> iterator();\n+    }\n+\n+    /**\n+     * An iterator extending {@link Iterator} providing the ability to skip a certain prefix.\n+     * @param <T> type\n+     */\n+    public interface TopologicalOrderPermutationIterator<T> extends Iterator<List<T>> {\n+        /**\n+         * Instructs the iterator to advance to the next possible ordering using the given level.\n+         *\n+         * Example 1: If the last returned ordering of the iterator {@code it} is {@code (e0, e1, e2, e3)} and\n+         *            {@code it.skip(2)} is called, the state of the iterator is advanced in a way that either\n+         *            reaches the end of iteration or the next item that is returned is {@code (e0', e1', e3', e4')}\n+         *            where the prefix {@code (e1', e2', e3')} is not equal to {code (e1, e2, e3)}.\n+         * Example 2: If the last returned ordering of the iterator {@code it} is {@code (e1, e2, e3, e4)} and\n+         *            {@code it.skip(1)} is called, the state of the iterator is advanced in a way that either reaches\n+         *            the end of iteration or the next item that is returned is {@code (e1', e2', e3', e4')} where\n+         *            the prefix {@code (e1', e2')} is not equal to {code (e1, e2)}.\n+         *\n+         * @param level skip level\n+         */\n+        void skip(int level);\n+    }\n+\n+    /**\n+     * A complex iterable it a {@link TopologicalOrderPermutationIterable} that is used for sets of cardinality greater\n+     * than 1 (i.e. the regular case).\n+     * @param <T> type\n+     */\n+    private static class ComplexIterable<T> implements TopologicalOrderPermutationIterable<T> {\n+        @Nonnull\n+        private final ImmutableSet<T> set;\n+        @Nonnull\n+        private final Function<T, Set<T>> dependsOnFn;\n+\n+        private class ComplexIterator extends AbstractIterator<List<T>> implements TopologicalSort.TopologicalOrderPermutationIterator<T> {\n+            // state\n+            private final Set<T> bound;\n+            private final List<PeekingIterator<T>> state;\n+\n+            private ComplexIterator() {\n+                this.bound = Sets.newHashSetWithExpectedSize(set.size());\n+                this.state = Lists.newArrayListWithCapacity(set.size());\n+                for (int i = 0; i < set.size(); i ++ ) {\n+                    this.state.add(null);\n+                }\n+            }\n+\n+            @Nullable\n+            @Override\n+            protected List<T> computeNext() {\n+                //\n+                // The problem to iterate through all possible correct orderings of set is inherently easier to\n+                // encode recursively, however, this being an iterator together with the requirement to skip subtrees\n+                // of iterations warrants an iterative solution. All hail the Church-Turing thesis!\n+                //\n+                if (set.isEmpty()) {\n+                    return endOfData();\n+                }\n+\n+                //\n+                // If nothing is bound yet, we are at the beginning and should start at level 0, otherwise\n+                // we conceptually start at the level of the finest granularity bound. Note that that finest\n+                // granularity is usually the granularity of the last element in the set, but it is possible\n+                // for fewer elements to be bound if this is the first call after a skip.\n+                //\n+                int currentLevel = bound.isEmpty() ? 0 : bound.size() - 1;\n+\n+                //\n+                // For each permutation of elements we return, we need to bind n elements (n == set.size()).\n+                // We maintain an iterator through the set (that is stable) for each level up to currentLevel.\n+                // That's the state! The iterator for levels greater than currentLevel must be null. The iterators\n+                // for levels below current level must be on a valid element. The iterator for the currentLevel\n+                // maybe null or a valid element.\n+                //\n+\n+                //\n+                // We also use a set \"bound\" that keeps elements that are currently bound by iterators.\n+                // \"bound\" is solely kept for convenience and is entirely computable from the current\n+                // state of all iterators. We must keep it in sync with the state of the iterators at all times.\n+                //\n+                do {\n+                    //\n+                    // Set the currentIterator. That is the iterator at level currentLevel. If it is null,\n+                    // we create a new iterator over the set.\n+                    //\n+                    final PeekingIterator<T> currentIterator;\n+                    if (state.get(currentLevel) == null) {\n+                        currentIterator = Iterators.peekingIterator(set.iterator());\n+                        state.set(currentLevel, currentIterator);\n+                    } else {\n+                        currentIterator = state.get(currentLevel);\n+                        unbind(currentLevel);\n+                        currentIterator.next();\n+                    }\n+\n+                    //\n+                    // Search currentLevel for a next item that does not violate any constraints. Doing so\n+                    // may exhaust currentIterator in which case we couldn't find another element on the current level.\n+                    // In that case we need to abandon the current level and search on the level above (making that\n+                    // level the current level). If we reach level -1 (i.e. we reach the end of the iterator at level 0\n+                    // we are done.\n+                    // If we do find an element not violating any constraints on the current level we conceptually\n+                    // bind it the element we found and continue on downward.\n+                    //\n+                    final boolean isDown = searchLevel(currentIterator);\n+                    if (!isDown) {\n+                        // back tracking -- need to clear out the current iterator\n+                        state.set(currentLevel, null);\n+                    }\n+                    currentLevel = isDown\n+                                   ? currentLevel + 1\n+                                   : currentLevel - 1;\n+                    \n+                    if (currentLevel == -1) {\n+                        return endOfData();\n+                    }\n+                } while (bound.size() < set.size()); // as long as we still have to find a binding\n+\n+                return state.stream()\n+                        .map(PeekingIterator::peek)\n+                        .collect(ImmutableList.toImmutableList());\n+            }\n+\n+            @SuppressWarnings(\"squid:S135\")\n+            private boolean searchLevel(final PeekingIterator<T> currentIterator) {\n+                while (currentIterator.hasNext()) {\n+                    final T next = currentIterator.peek();\n+\n+                    // check if it is bound already; t is invisible to this loop if it is bound\n+                    if (bound.contains(next)) {\n+                        currentIterator.next();\n+                        continue;\n+                    }\n+\n+                    //\n+                    // Check if t is only dependent on elements in the current bound set, if it is not it must come later.\n+                    // Note that the intersection removes elements the current element depends on that are not in set.\n+                    // That behavior is for convenience reasons and and specifically not an error.\n+                    //\n+                    final Set<T> dependsOn = Sets.intersection(set, dependsOnFn.apply(next));\n+                    if (!bound.containsAll(dependsOn)) {\n+                        currentIterator.next();\n+                        continue;\n+                    }\n+\n+                    // this level can be bound now\n+                    bound.add(next);\n+                    return true; // go down\n+                }\n+                return false; // go up\n+            }\n+\n+            private void unbind(final int level) {\n+                // reset all the following ones\n+                for (int i = level; i < set.size(); i ++ ) {\n+                    // either iterator is on a valid item or iterator is null\n+                    if (state.get(i) != null) {\n+                        bound.remove(state.get(i).peek());\n+                    } else {\n+                        break;\n+                    }\n+                }\n+            }\n+\n+            /**\n+             * Method that skips advances to the next element on the given level.\n+             * @param level level to advance\n+             */\n+            @Override\n+            public void skip(final int level) {\n+                if (level >= set.size()) {\n+                    throw new IndexOutOfBoundsException();\n+                }\n+\n+                if (state.get(level) == null) {\n+                    throw new UnsupportedOperationException(\"cannot skip/unbind as level is not bound at all\");\n+                }\n+\n+                // reset all the following ones\n+                for (int i = level + 1; i < set.size(); i ++ ) {\n+                    // either iterator is on a valid item or iterator is null\n+                    if (state.get(i) != null) {\n+                        bound.remove(state.get(i).peek());\n+                        state.set(i, null);\n+                    } else {\n+                        break;\n+                    }\n+                }\n+            }\n+        }\n+\n+        private ComplexIterable(@Nonnull final Set<T> set, @Nonnull final Function<T, Set<T>> dependsOnFn) {\n+            Verify.verify(set.size() > 1);\n+            this.set = ImmutableSet.copyOf(set);\n+            this.dependsOnFn = dependsOnFn;\n+        }\n+\n+        @Nonnull\n+        @Override\n+        public TopologicalOrderPermutationIterator<T> iterator() {\n+            return new ComplexIterator();\n+        }\n+    }\n+\n+    /**\n+     * An implementation of {@link TopologicalOrderPermutationIterable} that is optimized to work for empty\n+     * inputs sets. The case where the input set is empty is trivial and also properly handled by {@link ComplexIterable}.\n+     * Iterators created by this class, however, avoid to build complex state objects during their lifecycle.\n+     *\n+     * @param <T> type\n+     */\n+    private static class EmptyIterable<T> implements TopologicalOrderPermutationIterable<T> {\n+        private class EmptyIterator extends AbstractIterator<List<T>> implements TopologicalOrderPermutationIterator<T> {\n+            @Override\n+            public void skip(final int level) {\n+                throw new UnsupportedOperationException(\"cannot skip on empty iterator\");\n+            }\n+\n+            @Nullable\n+            @Override\n+            protected List<T> computeNext() {\n+                return endOfData();\n+            }\n+        }\n+\n+        @Nonnull\n+        @Override\n+        public TopologicalOrderPermutationIterator<T> iterator() {\n+            return new EmptyIterator();\n+        }\n+    }\n+\n+    /**\n+     * An implementation of {@link TopologicalOrderPermutationIterable} that is optimized to work for single item\n+     * inputs sets. The case where the input set is exactly one item is trivial and also properly handled by\n+     * {@link ComplexIterable}. Iterators created by this class, however, avoid to build complex state objects\n+     * during their lifecycle.\n+     *\n+     * @param <T> type\n+     */\n+    private static class SingleIterable<T> implements TopologicalOrderPermutationIterable<T> {\n+        private final T singleElement;\n+\n+        private SingleIterable(final T singleElement) {\n+            this.singleElement = singleElement;\n+        }\n+\n+        private class SingleIterator extends AbstractIterator<List<T>> implements TopologicalOrderPermutationIterator<T> {\n+            boolean atFirst = true;\n+\n+            @Override\n+            public void skip(final int level) {\n+                if (atFirst) {\n+                    throw new UnsupportedOperationException(\"cannot skip on before first element\");\n+                }\n+                // no op, we are at the end\n+            }\n+\n+            @Override\n+            protected List<T> computeNext() {\n+                if (!atFirst) {\n+                    return endOfData();\n+                }\n+\n+                atFirst = false;\n+\n+                return ImmutableList.of(singleElement);\n+            }\n+        }\n+\n+        @Nonnull\n+        @Override\n+        public TopologicalOrderPermutationIterator<T> iterator() {\n+            return new SingleIterator();\n+        }\n+    }\n+\n+    /**\n+     * Method to create a {@link TopologicalOrderPermutationIterable} based on a set and a function describing\n+     * the depends-on relationships between items in the given set.\n+     * @param set the set to create the iterable over\n+     * @param dependsOnFn a function from {@code T} to {@code Set<T>} that can be called during the lifecycle of all\n+     *        iterators multiple times repeatedly or not at all for any given element in {@code set}. This method is\n+     *        expected to return instantly and must be stable. Note it is allowed for the set the given function returns\n+     *        to contain elements of type {@code T} that are not in {@code set}. These items are ignored by the\n+     *        underlying algorithm (as in the dependency is instantly considered to be satisfied by all orderings).\n+     * @param <T> type\n+     * @return a new {@link TopologicalOrderPermutationIterable} that obeys the constraints as expressed in\n+     *         {@code dependsOnFn} in a sense that the iterators created by this iterator will not return\n+     *         orderings that violate the given depends-on constraints.\n+     */\n+    public static <T> TopologicalOrderPermutationIterable<T> topologicalOrderPermutations(final Set<T> set, final Function<T, Set<T>> dependsOnFn) {\n+        if (set.isEmpty()) {\n+            return new EmptyIterable<>();\n+        } else if (set.size() == 1) {\n+            return new SingleIterable<>(Iterables.getOnlyElement(set));\n+        }\n+        return new ComplexIterable<>(set, dependsOnFn);\n+    }\n+\n+    /**\n+     * Method to create a correct topological ordering based on a set and a function describing\n+     * the depends-on relationships between items in the given set.\n+     * @param set the set to create the iterable over\n+     * @param dependsOnFn a function from {@code T} to {@code Set<T>} that can be called during the lifecycle of all\n+     *        iterators multiple times repeatedly or not at all for any given element in {@code set}. This method is\n+     *        expected to return instantly and must be stable. Note it is allowed for the set the given function returns\n+     *        to contain elements of type {@code T} that are not in {@code set}. These items are ignored by the\n+     *        underlying algorithm (as in the dependency is instantly considered to be satisfied by all orderings).\n+     * @param <T> type\n+     * @return A permutation the set that is topologically correctly ordered with respect to {@code dependsOnFn}.\n+     */\n+    public static <T> Optional<List<T>> anyTopologicalOrderPermutation(final Set<T> set, final Function<T, Set<T>> dependsOnFn) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6eb7142ab316ffbec53e375804118f722f1d2bcc"}, "originalPosition": 407}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgzNTcyNDMyOnYy", "diffSide": "RIGHT", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/TopologicalSort.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNFQyMToxNzoxNVrOGxlrjg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNFQyMToxNzoxNVrOGxlrjg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDY1MDc2Ng==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * Method to create a {@link TopologicalOrderPermutationIterable} based on a set and a function describing\n          \n          \n            \n                 * Create a {@link TopologicalOrderPermutationIterable} based on a set and a function describing", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/988#discussion_r454650766", "createdAt": "2020-07-14T21:17:15Z", "author": {"login": "nschiefer"}, "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/TopologicalSort.java", "diffHunk": "@@ -0,0 +1,416 @@\n+/*\n+ * TopologicalSort.java\n+ *\n+ * This source file is part of the FoundationDB open source project\n+ *\n+ * Copyright 2015-2020 Apple Inc. and the FoundationDB project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.apple.foundationdb.record.query.plan.temp;\n+\n+import com.google.common.base.Verify;\n+import com.google.common.collect.AbstractIterator;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.collect.Iterables;\n+import com.google.common.collect.Iterators;\n+import com.google.common.collect.Lists;\n+import com.google.common.collect.PeekingIterator;\n+import com.google.common.collect.Sets;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.function.Function;\n+\n+/**\n+ * Utility class to provide helpers related to topological sorts.\n+ *\n+ * The main purpose on this class is to provide a specific iterable that can efficiently traverse\n+ * all possible permutations of the input set that do not violate the given dependency constraints.\n+ *\n+ * The iterable {@link TopologicalOrderPermutationIterable} adheres to the following requirements:\n+ * 1. it does not violate the given constraints\n+ * 2. it produces all possible orderings under the given constraints\n+ * 3. it reacts appropriately to give circular dependency constraints between elements (i.e. no infinite loops)\n+ * 4. it iterates all orderings on the fly, i.e. it only stores state (i.e. does not (pre)create the orderings in memory).\n+ *\n+ * {@link TopologicalOrderPermutationIterable} subclasses {@link Iterable} in order to provide an additional feature\n+ * that allows for skipping. Assume we have a set\n+ * <pre>\n+ * {@code\n+ * { a, b, c, d } with constraints { b -> c, b -> d } (c depends on b, d depends on b)\n+ * }\n+ * </pre>\n+ *\n+ * Possible orderings are\n+ * <pre>\n+ * {@code\n+ * (a, b, c, d)\n+ * (a, b, d, c)\n+ * (b, a, c, d)\n+ * (b, a, d, c)\n+ * (b, c, a, d)\n+ * (b, c, d, a)\n+ * (b, d, a, c)\n+ * (b, d, c, a)\n+ * }\n+ * </pre>\n+ *\n+ * Frequently we test for a certain property or perform a particular operation given one possible ordering but it is clear\n+ * that it is not necessary to consider more such orderings that share a common prefix. In the example, it may be\n+ * beneficial to skip the rest of the {@code (b, a, ...)} orderings after the first one was returned\n+ * ({@code (b, a, c, d}). In this case we would like to instruct the iterator to skip all such orderings and continue\n+ * iteration at {@code (b, c, a, d)}. Similarly, we want to skip all orderings starting with {@code (b, ...)} once we\n+ * encountered the first such ordering. This the iterators created by the provided {@link TopologicalOrderPermutationIterable}\n+ * of type {@link TopologicalOrderPermutationIterator} provide a method {@link TopologicalOrderPermutationIterator#skip}\n+ * to allow skipping at a provided prefix.\n+ *\n+ */\n+public class TopologicalSort {\n+    /**\n+     * Iterable that provides special iterators of type {@link TopologicalOrderPermutationIterator}.\n+     * @param <T> type\n+     */\n+    public interface TopologicalOrderPermutationIterable<T> extends Iterable<List<T>> {\n+        @Nonnull\n+        @Override\n+        TopologicalOrderPermutationIterator<T> iterator();\n+    }\n+\n+    /**\n+     * An iterator extending {@link Iterator} providing the ability to skip a certain prefix.\n+     * @param <T> type\n+     */\n+    public interface TopologicalOrderPermutationIterator<T> extends Iterator<List<T>> {\n+        /**\n+         * Instructs the iterator to advance to the next possible ordering using the given level.\n+         *\n+         * Example 1: If the last returned ordering of the iterator {@code it} is {@code (e0, e1, e2, e3)} and\n+         *            {@code it.skip(2)} is called, the state of the iterator is advanced in a way that either\n+         *            reaches the end of iteration or the next item that is returned is {@code (e0', e1', e3', e4')}\n+         *            where the prefix {@code (e1', e2', e3')} is not equal to {code (e1, e2, e3)}.\n+         * Example 2: If the last returned ordering of the iterator {@code it} is {@code (e1, e2, e3, e4)} and\n+         *            {@code it.skip(1)} is called, the state of the iterator is advanced in a way that either reaches\n+         *            the end of iteration or the next item that is returned is {@code (e1', e2', e3', e4')} where\n+         *            the prefix {@code (e1', e2')} is not equal to {code (e1, e2)}.\n+         *\n+         * @param level skip level\n+         */\n+        void skip(int level);\n+    }\n+\n+    /**\n+     * A complex iterable it a {@link TopologicalOrderPermutationIterable} that is used for sets of cardinality greater\n+     * than 1 (i.e. the regular case).\n+     * @param <T> type\n+     */\n+    private static class ComplexIterable<T> implements TopologicalOrderPermutationIterable<T> {\n+        @Nonnull\n+        private final ImmutableSet<T> set;\n+        @Nonnull\n+        private final Function<T, Set<T>> dependsOnFn;\n+\n+        private class ComplexIterator extends AbstractIterator<List<T>> implements TopologicalSort.TopologicalOrderPermutationIterator<T> {\n+            // state\n+            private final Set<T> bound;\n+            private final List<PeekingIterator<T>> state;\n+\n+            private ComplexIterator() {\n+                this.bound = Sets.newHashSetWithExpectedSize(set.size());\n+                this.state = Lists.newArrayListWithCapacity(set.size());\n+                for (int i = 0; i < set.size(); i ++ ) {\n+                    this.state.add(null);\n+                }\n+            }\n+\n+            @Nullable\n+            @Override\n+            protected List<T> computeNext() {\n+                //\n+                // The problem to iterate through all possible correct orderings of set is inherently easier to\n+                // encode recursively, however, this being an iterator together with the requirement to skip subtrees\n+                // of iterations warrants an iterative solution. All hail the Church-Turing thesis!\n+                //\n+                if (set.isEmpty()) {\n+                    return endOfData();\n+                }\n+\n+                //\n+                // If nothing is bound yet, we are at the beginning and should start at level 0, otherwise\n+                // we conceptually start at the level of the finest granularity bound. Note that that finest\n+                // granularity is usually the granularity of the last element in the set, but it is possible\n+                // for fewer elements to be bound if this is the first call after a skip.\n+                //\n+                int currentLevel = bound.isEmpty() ? 0 : bound.size() - 1;\n+\n+                //\n+                // For each permutation of elements we return, we need to bind n elements (n == set.size()).\n+                // We maintain an iterator through the set (that is stable) for each level up to currentLevel.\n+                // That's the state! The iterator for levels greater than currentLevel must be null. The iterators\n+                // for levels below current level must be on a valid element. The iterator for the currentLevel\n+                // maybe null or a valid element.\n+                //\n+\n+                //\n+                // We also use a set \"bound\" that keeps elements that are currently bound by iterators.\n+                // \"bound\" is solely kept for convenience and is entirely computable from the current\n+                // state of all iterators. We must keep it in sync with the state of the iterators at all times.\n+                //\n+                do {\n+                    //\n+                    // Set the currentIterator. That is the iterator at level currentLevel. If it is null,\n+                    // we create a new iterator over the set.\n+                    //\n+                    final PeekingIterator<T> currentIterator;\n+                    if (state.get(currentLevel) == null) {\n+                        currentIterator = Iterators.peekingIterator(set.iterator());\n+                        state.set(currentLevel, currentIterator);\n+                    } else {\n+                        currentIterator = state.get(currentLevel);\n+                        unbind(currentLevel);\n+                        currentIterator.next();\n+                    }\n+\n+                    //\n+                    // Search currentLevel for a next item that does not violate any constraints. Doing so\n+                    // may exhaust currentIterator in which case we couldn't find another element on the current level.\n+                    // In that case we need to abandon the current level and search on the level above (making that\n+                    // level the current level). If we reach level -1 (i.e. we reach the end of the iterator at level 0\n+                    // we are done.\n+                    // If we do find an element not violating any constraints on the current level we conceptually\n+                    // bind it the element we found and continue on downward.\n+                    //\n+                    final boolean isDown = searchLevel(currentIterator);\n+                    if (!isDown) {\n+                        // back tracking -- need to clear out the current iterator\n+                        state.set(currentLevel, null);\n+                    }\n+                    currentLevel = isDown\n+                                   ? currentLevel + 1\n+                                   : currentLevel - 1;\n+                    \n+                    if (currentLevel == -1) {\n+                        return endOfData();\n+                    }\n+                } while (bound.size() < set.size()); // as long as we still have to find a binding\n+\n+                return state.stream()\n+                        .map(PeekingIterator::peek)\n+                        .collect(ImmutableList.toImmutableList());\n+            }\n+\n+            @SuppressWarnings(\"squid:S135\")\n+            private boolean searchLevel(final PeekingIterator<T> currentIterator) {\n+                while (currentIterator.hasNext()) {\n+                    final T next = currentIterator.peek();\n+\n+                    // check if it is bound already; t is invisible to this loop if it is bound\n+                    if (bound.contains(next)) {\n+                        currentIterator.next();\n+                        continue;\n+                    }\n+\n+                    //\n+                    // Check if t is only dependent on elements in the current bound set, if it is not it must come later.\n+                    // Note that the intersection removes elements the current element depends on that are not in set.\n+                    // That behavior is for convenience reasons and and specifically not an error.\n+                    //\n+                    final Set<T> dependsOn = Sets.intersection(set, dependsOnFn.apply(next));\n+                    if (!bound.containsAll(dependsOn)) {\n+                        currentIterator.next();\n+                        continue;\n+                    }\n+\n+                    // this level can be bound now\n+                    bound.add(next);\n+                    return true; // go down\n+                }\n+                return false; // go up\n+            }\n+\n+            private void unbind(final int level) {\n+                // reset all the following ones\n+                for (int i = level; i < set.size(); i ++ ) {\n+                    // either iterator is on a valid item or iterator is null\n+                    if (state.get(i) != null) {\n+                        bound.remove(state.get(i).peek());\n+                    } else {\n+                        break;\n+                    }\n+                }\n+            }\n+\n+            /**\n+             * Method that skips advances to the next element on the given level.\n+             * @param level level to advance\n+             */\n+            @Override\n+            public void skip(final int level) {\n+                if (level >= set.size()) {\n+                    throw new IndexOutOfBoundsException();\n+                }\n+\n+                if (state.get(level) == null) {\n+                    throw new UnsupportedOperationException(\"cannot skip/unbind as level is not bound at all\");\n+                }\n+\n+                // reset all the following ones\n+                for (int i = level + 1; i < set.size(); i ++ ) {\n+                    // either iterator is on a valid item or iterator is null\n+                    if (state.get(i) != null) {\n+                        bound.remove(state.get(i).peek());\n+                        state.set(i, null);\n+                    } else {\n+                        break;\n+                    }\n+                }\n+            }\n+        }\n+\n+        private ComplexIterable(@Nonnull final Set<T> set, @Nonnull final Function<T, Set<T>> dependsOnFn) {\n+            Verify.verify(set.size() > 1);\n+            this.set = ImmutableSet.copyOf(set);\n+            this.dependsOnFn = dependsOnFn;\n+        }\n+\n+        @Nonnull\n+        @Override\n+        public TopologicalOrderPermutationIterator<T> iterator() {\n+            return new ComplexIterator();\n+        }\n+    }\n+\n+    /**\n+     * An implementation of {@link TopologicalOrderPermutationIterable} that is optimized to work for empty\n+     * inputs sets. The case where the input set is empty is trivial and also properly handled by {@link ComplexIterable}.\n+     * Iterators created by this class, however, avoid to build complex state objects during their lifecycle.\n+     *\n+     * @param <T> type\n+     */\n+    private static class EmptyIterable<T> implements TopologicalOrderPermutationIterable<T> {\n+        private class EmptyIterator extends AbstractIterator<List<T>> implements TopologicalOrderPermutationIterator<T> {\n+            @Override\n+            public void skip(final int level) {\n+                throw new UnsupportedOperationException(\"cannot skip on empty iterator\");\n+            }\n+\n+            @Nullable\n+            @Override\n+            protected List<T> computeNext() {\n+                return endOfData();\n+            }\n+        }\n+\n+        @Nonnull\n+        @Override\n+        public TopologicalOrderPermutationIterator<T> iterator() {\n+            return new EmptyIterator();\n+        }\n+    }\n+\n+    /**\n+     * An implementation of {@link TopologicalOrderPermutationIterable} that is optimized to work for single item\n+     * inputs sets. The case where the input set is exactly one item is trivial and also properly handled by\n+     * {@link ComplexIterable}. Iterators created by this class, however, avoid to build complex state objects\n+     * during their lifecycle.\n+     *\n+     * @param <T> type\n+     */\n+    private static class SingleIterable<T> implements TopologicalOrderPermutationIterable<T> {\n+        private final T singleElement;\n+\n+        private SingleIterable(final T singleElement) {\n+            this.singleElement = singleElement;\n+        }\n+\n+        private class SingleIterator extends AbstractIterator<List<T>> implements TopologicalOrderPermutationIterator<T> {\n+            boolean atFirst = true;\n+\n+            @Override\n+            public void skip(final int level) {\n+                if (atFirst) {\n+                    throw new UnsupportedOperationException(\"cannot skip on before first element\");\n+                }\n+                // no op, we are at the end\n+            }\n+\n+            @Override\n+            protected List<T> computeNext() {\n+                if (!atFirst) {\n+                    return endOfData();\n+                }\n+\n+                atFirst = false;\n+\n+                return ImmutableList.of(singleElement);\n+            }\n+        }\n+\n+        @Nonnull\n+        @Override\n+        public TopologicalOrderPermutationIterator<T> iterator() {\n+            return new SingleIterator();\n+        }\n+    }\n+\n+    /**\n+     * Method to create a {@link TopologicalOrderPermutationIterable} based on a set and a function describing", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6eb7142ab316ffbec53e375804118f722f1d2bcc"}, "originalPosition": 373}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgzNTcyNTAwOnYy", "diffSide": "RIGHT", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/TopologicalSort.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNFQyMToxNzoyNlrOGxlr8Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNFQyMToxNzoyNlrOGxlr8Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDY1MDg2NQ==", "bodyText": "See above.", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/988#discussion_r454650865", "createdAt": "2020-07-14T21:17:26Z", "author": {"login": "nschiefer"}, "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/TopologicalSort.java", "diffHunk": "@@ -0,0 +1,416 @@\n+/*\n+ * TopologicalSort.java\n+ *\n+ * This source file is part of the FoundationDB open source project\n+ *\n+ * Copyright 2015-2020 Apple Inc. and the FoundationDB project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.apple.foundationdb.record.query.plan.temp;\n+\n+import com.google.common.base.Verify;\n+import com.google.common.collect.AbstractIterator;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.collect.Iterables;\n+import com.google.common.collect.Iterators;\n+import com.google.common.collect.Lists;\n+import com.google.common.collect.PeekingIterator;\n+import com.google.common.collect.Sets;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.function.Function;\n+\n+/**\n+ * Utility class to provide helpers related to topological sorts.\n+ *\n+ * The main purpose on this class is to provide a specific iterable that can efficiently traverse\n+ * all possible permutations of the input set that do not violate the given dependency constraints.\n+ *\n+ * The iterable {@link TopologicalOrderPermutationIterable} adheres to the following requirements:\n+ * 1. it does not violate the given constraints\n+ * 2. it produces all possible orderings under the given constraints\n+ * 3. it reacts appropriately to give circular dependency constraints between elements (i.e. no infinite loops)\n+ * 4. it iterates all orderings on the fly, i.e. it only stores state (i.e. does not (pre)create the orderings in memory).\n+ *\n+ * {@link TopologicalOrderPermutationIterable} subclasses {@link Iterable} in order to provide an additional feature\n+ * that allows for skipping. Assume we have a set\n+ * <pre>\n+ * {@code\n+ * { a, b, c, d } with constraints { b -> c, b -> d } (c depends on b, d depends on b)\n+ * }\n+ * </pre>\n+ *\n+ * Possible orderings are\n+ * <pre>\n+ * {@code\n+ * (a, b, c, d)\n+ * (a, b, d, c)\n+ * (b, a, c, d)\n+ * (b, a, d, c)\n+ * (b, c, a, d)\n+ * (b, c, d, a)\n+ * (b, d, a, c)\n+ * (b, d, c, a)\n+ * }\n+ * </pre>\n+ *\n+ * Frequently we test for a certain property or perform a particular operation given one possible ordering but it is clear\n+ * that it is not necessary to consider more such orderings that share a common prefix. In the example, it may be\n+ * beneficial to skip the rest of the {@code (b, a, ...)} orderings after the first one was returned\n+ * ({@code (b, a, c, d}). In this case we would like to instruct the iterator to skip all such orderings and continue\n+ * iteration at {@code (b, c, a, d)}. Similarly, we want to skip all orderings starting with {@code (b, ...)} once we\n+ * encountered the first such ordering. This the iterators created by the provided {@link TopologicalOrderPermutationIterable}\n+ * of type {@link TopologicalOrderPermutationIterator} provide a method {@link TopologicalOrderPermutationIterator#skip}\n+ * to allow skipping at a provided prefix.\n+ *\n+ */\n+public class TopologicalSort {\n+    /**\n+     * Iterable that provides special iterators of type {@link TopologicalOrderPermutationIterator}.\n+     * @param <T> type\n+     */\n+    public interface TopologicalOrderPermutationIterable<T> extends Iterable<List<T>> {\n+        @Nonnull\n+        @Override\n+        TopologicalOrderPermutationIterator<T> iterator();\n+    }\n+\n+    /**\n+     * An iterator extending {@link Iterator} providing the ability to skip a certain prefix.\n+     * @param <T> type\n+     */\n+    public interface TopologicalOrderPermutationIterator<T> extends Iterator<List<T>> {\n+        /**\n+         * Instructs the iterator to advance to the next possible ordering using the given level.\n+         *\n+         * Example 1: If the last returned ordering of the iterator {@code it} is {@code (e0, e1, e2, e3)} and\n+         *            {@code it.skip(2)} is called, the state of the iterator is advanced in a way that either\n+         *            reaches the end of iteration or the next item that is returned is {@code (e0', e1', e3', e4')}\n+         *            where the prefix {@code (e1', e2', e3')} is not equal to {code (e1, e2, e3)}.\n+         * Example 2: If the last returned ordering of the iterator {@code it} is {@code (e1, e2, e3, e4)} and\n+         *            {@code it.skip(1)} is called, the state of the iterator is advanced in a way that either reaches\n+         *            the end of iteration or the next item that is returned is {@code (e1', e2', e3', e4')} where\n+         *            the prefix {@code (e1', e2')} is not equal to {code (e1, e2)}.\n+         *\n+         * @param level skip level\n+         */\n+        void skip(int level);\n+    }\n+\n+    /**\n+     * A complex iterable it a {@link TopologicalOrderPermutationIterable} that is used for sets of cardinality greater\n+     * than 1 (i.e. the regular case).\n+     * @param <T> type\n+     */\n+    private static class ComplexIterable<T> implements TopologicalOrderPermutationIterable<T> {\n+        @Nonnull\n+        private final ImmutableSet<T> set;\n+        @Nonnull\n+        private final Function<T, Set<T>> dependsOnFn;\n+\n+        private class ComplexIterator extends AbstractIterator<List<T>> implements TopologicalSort.TopologicalOrderPermutationIterator<T> {\n+            // state\n+            private final Set<T> bound;\n+            private final List<PeekingIterator<T>> state;\n+\n+            private ComplexIterator() {\n+                this.bound = Sets.newHashSetWithExpectedSize(set.size());\n+                this.state = Lists.newArrayListWithCapacity(set.size());\n+                for (int i = 0; i < set.size(); i ++ ) {\n+                    this.state.add(null);\n+                }\n+            }\n+\n+            @Nullable\n+            @Override\n+            protected List<T> computeNext() {\n+                //\n+                // The problem to iterate through all possible correct orderings of set is inherently easier to\n+                // encode recursively, however, this being an iterator together with the requirement to skip subtrees\n+                // of iterations warrants an iterative solution. All hail the Church-Turing thesis!\n+                //\n+                if (set.isEmpty()) {\n+                    return endOfData();\n+                }\n+\n+                //\n+                // If nothing is bound yet, we are at the beginning and should start at level 0, otherwise\n+                // we conceptually start at the level of the finest granularity bound. Note that that finest\n+                // granularity is usually the granularity of the last element in the set, but it is possible\n+                // for fewer elements to be bound if this is the first call after a skip.\n+                //\n+                int currentLevel = bound.isEmpty() ? 0 : bound.size() - 1;\n+\n+                //\n+                // For each permutation of elements we return, we need to bind n elements (n == set.size()).\n+                // We maintain an iterator through the set (that is stable) for each level up to currentLevel.\n+                // That's the state! The iterator for levels greater than currentLevel must be null. The iterators\n+                // for levels below current level must be on a valid element. The iterator for the currentLevel\n+                // maybe null or a valid element.\n+                //\n+\n+                //\n+                // We also use a set \"bound\" that keeps elements that are currently bound by iterators.\n+                // \"bound\" is solely kept for convenience and is entirely computable from the current\n+                // state of all iterators. We must keep it in sync with the state of the iterators at all times.\n+                //\n+                do {\n+                    //\n+                    // Set the currentIterator. That is the iterator at level currentLevel. If it is null,\n+                    // we create a new iterator over the set.\n+                    //\n+                    final PeekingIterator<T> currentIterator;\n+                    if (state.get(currentLevel) == null) {\n+                        currentIterator = Iterators.peekingIterator(set.iterator());\n+                        state.set(currentLevel, currentIterator);\n+                    } else {\n+                        currentIterator = state.get(currentLevel);\n+                        unbind(currentLevel);\n+                        currentIterator.next();\n+                    }\n+\n+                    //\n+                    // Search currentLevel for a next item that does not violate any constraints. Doing so\n+                    // may exhaust currentIterator in which case we couldn't find another element on the current level.\n+                    // In that case we need to abandon the current level and search on the level above (making that\n+                    // level the current level). If we reach level -1 (i.e. we reach the end of the iterator at level 0\n+                    // we are done.\n+                    // If we do find an element not violating any constraints on the current level we conceptually\n+                    // bind it the element we found and continue on downward.\n+                    //\n+                    final boolean isDown = searchLevel(currentIterator);\n+                    if (!isDown) {\n+                        // back tracking -- need to clear out the current iterator\n+                        state.set(currentLevel, null);\n+                    }\n+                    currentLevel = isDown\n+                                   ? currentLevel + 1\n+                                   : currentLevel - 1;\n+                    \n+                    if (currentLevel == -1) {\n+                        return endOfData();\n+                    }\n+                } while (bound.size() < set.size()); // as long as we still have to find a binding\n+\n+                return state.stream()\n+                        .map(PeekingIterator::peek)\n+                        .collect(ImmutableList.toImmutableList());\n+            }\n+\n+            @SuppressWarnings(\"squid:S135\")\n+            private boolean searchLevel(final PeekingIterator<T> currentIterator) {\n+                while (currentIterator.hasNext()) {\n+                    final T next = currentIterator.peek();\n+\n+                    // check if it is bound already; t is invisible to this loop if it is bound\n+                    if (bound.contains(next)) {\n+                        currentIterator.next();\n+                        continue;\n+                    }\n+\n+                    //\n+                    // Check if t is only dependent on elements in the current bound set, if it is not it must come later.\n+                    // Note that the intersection removes elements the current element depends on that are not in set.\n+                    // That behavior is for convenience reasons and and specifically not an error.\n+                    //\n+                    final Set<T> dependsOn = Sets.intersection(set, dependsOnFn.apply(next));\n+                    if (!bound.containsAll(dependsOn)) {\n+                        currentIterator.next();\n+                        continue;\n+                    }\n+\n+                    // this level can be bound now\n+                    bound.add(next);\n+                    return true; // go down\n+                }\n+                return false; // go up\n+            }\n+\n+            private void unbind(final int level) {\n+                // reset all the following ones\n+                for (int i = level; i < set.size(); i ++ ) {\n+                    // either iterator is on a valid item or iterator is null\n+                    if (state.get(i) != null) {\n+                        bound.remove(state.get(i).peek());\n+                    } else {\n+                        break;\n+                    }\n+                }\n+            }\n+\n+            /**\n+             * Method that skips advances to the next element on the given level.\n+             * @param level level to advance\n+             */\n+            @Override\n+            public void skip(final int level) {\n+                if (level >= set.size()) {\n+                    throw new IndexOutOfBoundsException();\n+                }\n+\n+                if (state.get(level) == null) {\n+                    throw new UnsupportedOperationException(\"cannot skip/unbind as level is not bound at all\");\n+                }\n+\n+                // reset all the following ones\n+                for (int i = level + 1; i < set.size(); i ++ ) {\n+                    // either iterator is on a valid item or iterator is null\n+                    if (state.get(i) != null) {\n+                        bound.remove(state.get(i).peek());\n+                        state.set(i, null);\n+                    } else {\n+                        break;\n+                    }\n+                }\n+            }\n+        }\n+\n+        private ComplexIterable(@Nonnull final Set<T> set, @Nonnull final Function<T, Set<T>> dependsOnFn) {\n+            Verify.verify(set.size() > 1);\n+            this.set = ImmutableSet.copyOf(set);\n+            this.dependsOnFn = dependsOnFn;\n+        }\n+\n+        @Nonnull\n+        @Override\n+        public TopologicalOrderPermutationIterator<T> iterator() {\n+            return new ComplexIterator();\n+        }\n+    }\n+\n+    /**\n+     * An implementation of {@link TopologicalOrderPermutationIterable} that is optimized to work for empty\n+     * inputs sets. The case where the input set is empty is trivial and also properly handled by {@link ComplexIterable}.\n+     * Iterators created by this class, however, avoid to build complex state objects during their lifecycle.\n+     *\n+     * @param <T> type\n+     */\n+    private static class EmptyIterable<T> implements TopologicalOrderPermutationIterable<T> {\n+        private class EmptyIterator extends AbstractIterator<List<T>> implements TopologicalOrderPermutationIterator<T> {\n+            @Override\n+            public void skip(final int level) {\n+                throw new UnsupportedOperationException(\"cannot skip on empty iterator\");\n+            }\n+\n+            @Nullable\n+            @Override\n+            protected List<T> computeNext() {\n+                return endOfData();\n+            }\n+        }\n+\n+        @Nonnull\n+        @Override\n+        public TopologicalOrderPermutationIterator<T> iterator() {\n+            return new EmptyIterator();\n+        }\n+    }\n+\n+    /**\n+     * An implementation of {@link TopologicalOrderPermutationIterable} that is optimized to work for single item\n+     * inputs sets. The case where the input set is exactly one item is trivial and also properly handled by\n+     * {@link ComplexIterable}. Iterators created by this class, however, avoid to build complex state objects\n+     * during their lifecycle.\n+     *\n+     * @param <T> type\n+     */\n+    private static class SingleIterable<T> implements TopologicalOrderPermutationIterable<T> {\n+        private final T singleElement;\n+\n+        private SingleIterable(final T singleElement) {\n+            this.singleElement = singleElement;\n+        }\n+\n+        private class SingleIterator extends AbstractIterator<List<T>> implements TopologicalOrderPermutationIterator<T> {\n+            boolean atFirst = true;\n+\n+            @Override\n+            public void skip(final int level) {\n+                if (atFirst) {\n+                    throw new UnsupportedOperationException(\"cannot skip on before first element\");\n+                }\n+                // no op, we are at the end\n+            }\n+\n+            @Override\n+            protected List<T> computeNext() {\n+                if (!atFirst) {\n+                    return endOfData();\n+                }\n+\n+                atFirst = false;\n+\n+                return ImmutableList.of(singleElement);\n+            }\n+        }\n+\n+        @Nonnull\n+        @Override\n+        public TopologicalOrderPermutationIterator<T> iterator() {\n+            return new SingleIterator();\n+        }\n+    }\n+\n+    /**\n+     * Method to create a {@link TopologicalOrderPermutationIterable} based on a set and a function describing\n+     * the depends-on relationships between items in the given set.\n+     * @param set the set to create the iterable over\n+     * @param dependsOnFn a function from {@code T} to {@code Set<T>} that can be called during the lifecycle of all\n+     *        iterators multiple times repeatedly or not at all for any given element in {@code set}. This method is\n+     *        expected to return instantly and must be stable. Note it is allowed for the set the given function returns\n+     *        to contain elements of type {@code T} that are not in {@code set}. These items are ignored by the\n+     *        underlying algorithm (as in the dependency is instantly considered to be satisfied by all orderings).\n+     * @param <T> type\n+     * @return a new {@link TopologicalOrderPermutationIterable} that obeys the constraints as expressed in\n+     *         {@code dependsOnFn} in a sense that the iterators created by this iterator will not return\n+     *         orderings that violate the given depends-on constraints.\n+     */\n+    public static <T> TopologicalOrderPermutationIterable<T> topologicalOrderPermutations(final Set<T> set, final Function<T, Set<T>> dependsOnFn) {\n+        if (set.isEmpty()) {\n+            return new EmptyIterable<>();\n+        } else if (set.size() == 1) {\n+            return new SingleIterable<>(Iterables.getOnlyElement(set));\n+        }\n+        return new ComplexIterable<>(set, dependsOnFn);\n+    }\n+\n+    /**\n+     * Method to create a correct topological ordering based on a set and a function describing\n+     * the depends-on relationships between items in the given set.\n+     * @param set the set to create the iterable over\n+     * @param dependsOnFn a function from {@code T} to {@code Set<T>} that can be called during the lifecycle of all\n+     *        iterators multiple times repeatedly or not at all for any given element in {@code set}. This method is\n+     *        expected to return instantly and must be stable. Note it is allowed for the set the given function returns\n+     *        to contain elements of type {@code T} that are not in {@code set}. These items are ignored by the\n+     *        underlying algorithm (as in the dependency is instantly considered to be satisfied by all orderings).", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6eb7142ab316ffbec53e375804118f722f1d2bcc"}, "originalPosition": 403}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgzNTcyNjAwOnYy", "diffSide": "RIGHT", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/TopologicalSort.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNFQyMToxNzo0N1rOGxlskA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNFQyMToxNzo0N1rOGxlskA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDY1MTAyNA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 *         orderings that violate the given depends-on constraints.\n          \n          \n            \n                 *         orderings that violate the given depends-on constraints", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/988#discussion_r454651024", "createdAt": "2020-07-14T21:17:47Z", "author": {"login": "nschiefer"}, "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/TopologicalSort.java", "diffHunk": "@@ -0,0 +1,416 @@\n+/*\n+ * TopologicalSort.java\n+ *\n+ * This source file is part of the FoundationDB open source project\n+ *\n+ * Copyright 2015-2020 Apple Inc. and the FoundationDB project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.apple.foundationdb.record.query.plan.temp;\n+\n+import com.google.common.base.Verify;\n+import com.google.common.collect.AbstractIterator;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.collect.Iterables;\n+import com.google.common.collect.Iterators;\n+import com.google.common.collect.Lists;\n+import com.google.common.collect.PeekingIterator;\n+import com.google.common.collect.Sets;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.function.Function;\n+\n+/**\n+ * Utility class to provide helpers related to topological sorts.\n+ *\n+ * The main purpose on this class is to provide a specific iterable that can efficiently traverse\n+ * all possible permutations of the input set that do not violate the given dependency constraints.\n+ *\n+ * The iterable {@link TopologicalOrderPermutationIterable} adheres to the following requirements:\n+ * 1. it does not violate the given constraints\n+ * 2. it produces all possible orderings under the given constraints\n+ * 3. it reacts appropriately to give circular dependency constraints between elements (i.e. no infinite loops)\n+ * 4. it iterates all orderings on the fly, i.e. it only stores state (i.e. does not (pre)create the orderings in memory).\n+ *\n+ * {@link TopologicalOrderPermutationIterable} subclasses {@link Iterable} in order to provide an additional feature\n+ * that allows for skipping. Assume we have a set\n+ * <pre>\n+ * {@code\n+ * { a, b, c, d } with constraints { b -> c, b -> d } (c depends on b, d depends on b)\n+ * }\n+ * </pre>\n+ *\n+ * Possible orderings are\n+ * <pre>\n+ * {@code\n+ * (a, b, c, d)\n+ * (a, b, d, c)\n+ * (b, a, c, d)\n+ * (b, a, d, c)\n+ * (b, c, a, d)\n+ * (b, c, d, a)\n+ * (b, d, a, c)\n+ * (b, d, c, a)\n+ * }\n+ * </pre>\n+ *\n+ * Frequently we test for a certain property or perform a particular operation given one possible ordering but it is clear\n+ * that it is not necessary to consider more such orderings that share a common prefix. In the example, it may be\n+ * beneficial to skip the rest of the {@code (b, a, ...)} orderings after the first one was returned\n+ * ({@code (b, a, c, d}). In this case we would like to instruct the iterator to skip all such orderings and continue\n+ * iteration at {@code (b, c, a, d)}. Similarly, we want to skip all orderings starting with {@code (b, ...)} once we\n+ * encountered the first such ordering. This the iterators created by the provided {@link TopologicalOrderPermutationIterable}\n+ * of type {@link TopologicalOrderPermutationIterator} provide a method {@link TopologicalOrderPermutationIterator#skip}\n+ * to allow skipping at a provided prefix.\n+ *\n+ */\n+public class TopologicalSort {\n+    /**\n+     * Iterable that provides special iterators of type {@link TopologicalOrderPermutationIterator}.\n+     * @param <T> type\n+     */\n+    public interface TopologicalOrderPermutationIterable<T> extends Iterable<List<T>> {\n+        @Nonnull\n+        @Override\n+        TopologicalOrderPermutationIterator<T> iterator();\n+    }\n+\n+    /**\n+     * An iterator extending {@link Iterator} providing the ability to skip a certain prefix.\n+     * @param <T> type\n+     */\n+    public interface TopologicalOrderPermutationIterator<T> extends Iterator<List<T>> {\n+        /**\n+         * Instructs the iterator to advance to the next possible ordering using the given level.\n+         *\n+         * Example 1: If the last returned ordering of the iterator {@code it} is {@code (e0, e1, e2, e3)} and\n+         *            {@code it.skip(2)} is called, the state of the iterator is advanced in a way that either\n+         *            reaches the end of iteration or the next item that is returned is {@code (e0', e1', e3', e4')}\n+         *            where the prefix {@code (e1', e2', e3')} is not equal to {code (e1, e2, e3)}.\n+         * Example 2: If the last returned ordering of the iterator {@code it} is {@code (e1, e2, e3, e4)} and\n+         *            {@code it.skip(1)} is called, the state of the iterator is advanced in a way that either reaches\n+         *            the end of iteration or the next item that is returned is {@code (e1', e2', e3', e4')} where\n+         *            the prefix {@code (e1', e2')} is not equal to {code (e1, e2)}.\n+         *\n+         * @param level skip level\n+         */\n+        void skip(int level);\n+    }\n+\n+    /**\n+     * A complex iterable it a {@link TopologicalOrderPermutationIterable} that is used for sets of cardinality greater\n+     * than 1 (i.e. the regular case).\n+     * @param <T> type\n+     */\n+    private static class ComplexIterable<T> implements TopologicalOrderPermutationIterable<T> {\n+        @Nonnull\n+        private final ImmutableSet<T> set;\n+        @Nonnull\n+        private final Function<T, Set<T>> dependsOnFn;\n+\n+        private class ComplexIterator extends AbstractIterator<List<T>> implements TopologicalSort.TopologicalOrderPermutationIterator<T> {\n+            // state\n+            private final Set<T> bound;\n+            private final List<PeekingIterator<T>> state;\n+\n+            private ComplexIterator() {\n+                this.bound = Sets.newHashSetWithExpectedSize(set.size());\n+                this.state = Lists.newArrayListWithCapacity(set.size());\n+                for (int i = 0; i < set.size(); i ++ ) {\n+                    this.state.add(null);\n+                }\n+            }\n+\n+            @Nullable\n+            @Override\n+            protected List<T> computeNext() {\n+                //\n+                // The problem to iterate through all possible correct orderings of set is inherently easier to\n+                // encode recursively, however, this being an iterator together with the requirement to skip subtrees\n+                // of iterations warrants an iterative solution. All hail the Church-Turing thesis!\n+                //\n+                if (set.isEmpty()) {\n+                    return endOfData();\n+                }\n+\n+                //\n+                // If nothing is bound yet, we are at the beginning and should start at level 0, otherwise\n+                // we conceptually start at the level of the finest granularity bound. Note that that finest\n+                // granularity is usually the granularity of the last element in the set, but it is possible\n+                // for fewer elements to be bound if this is the first call after a skip.\n+                //\n+                int currentLevel = bound.isEmpty() ? 0 : bound.size() - 1;\n+\n+                //\n+                // For each permutation of elements we return, we need to bind n elements (n == set.size()).\n+                // We maintain an iterator through the set (that is stable) for each level up to currentLevel.\n+                // That's the state! The iterator for levels greater than currentLevel must be null. The iterators\n+                // for levels below current level must be on a valid element. The iterator for the currentLevel\n+                // maybe null or a valid element.\n+                //\n+\n+                //\n+                // We also use a set \"bound\" that keeps elements that are currently bound by iterators.\n+                // \"bound\" is solely kept for convenience and is entirely computable from the current\n+                // state of all iterators. We must keep it in sync with the state of the iterators at all times.\n+                //\n+                do {\n+                    //\n+                    // Set the currentIterator. That is the iterator at level currentLevel. If it is null,\n+                    // we create a new iterator over the set.\n+                    //\n+                    final PeekingIterator<T> currentIterator;\n+                    if (state.get(currentLevel) == null) {\n+                        currentIterator = Iterators.peekingIterator(set.iterator());\n+                        state.set(currentLevel, currentIterator);\n+                    } else {\n+                        currentIterator = state.get(currentLevel);\n+                        unbind(currentLevel);\n+                        currentIterator.next();\n+                    }\n+\n+                    //\n+                    // Search currentLevel for a next item that does not violate any constraints. Doing so\n+                    // may exhaust currentIterator in which case we couldn't find another element on the current level.\n+                    // In that case we need to abandon the current level and search on the level above (making that\n+                    // level the current level). If we reach level -1 (i.e. we reach the end of the iterator at level 0\n+                    // we are done.\n+                    // If we do find an element not violating any constraints on the current level we conceptually\n+                    // bind it the element we found and continue on downward.\n+                    //\n+                    final boolean isDown = searchLevel(currentIterator);\n+                    if (!isDown) {\n+                        // back tracking -- need to clear out the current iterator\n+                        state.set(currentLevel, null);\n+                    }\n+                    currentLevel = isDown\n+                                   ? currentLevel + 1\n+                                   : currentLevel - 1;\n+                    \n+                    if (currentLevel == -1) {\n+                        return endOfData();\n+                    }\n+                } while (bound.size() < set.size()); // as long as we still have to find a binding\n+\n+                return state.stream()\n+                        .map(PeekingIterator::peek)\n+                        .collect(ImmutableList.toImmutableList());\n+            }\n+\n+            @SuppressWarnings(\"squid:S135\")\n+            private boolean searchLevel(final PeekingIterator<T> currentIterator) {\n+                while (currentIterator.hasNext()) {\n+                    final T next = currentIterator.peek();\n+\n+                    // check if it is bound already; t is invisible to this loop if it is bound\n+                    if (bound.contains(next)) {\n+                        currentIterator.next();\n+                        continue;\n+                    }\n+\n+                    //\n+                    // Check if t is only dependent on elements in the current bound set, if it is not it must come later.\n+                    // Note that the intersection removes elements the current element depends on that are not in set.\n+                    // That behavior is for convenience reasons and and specifically not an error.\n+                    //\n+                    final Set<T> dependsOn = Sets.intersection(set, dependsOnFn.apply(next));\n+                    if (!bound.containsAll(dependsOn)) {\n+                        currentIterator.next();\n+                        continue;\n+                    }\n+\n+                    // this level can be bound now\n+                    bound.add(next);\n+                    return true; // go down\n+                }\n+                return false; // go up\n+            }\n+\n+            private void unbind(final int level) {\n+                // reset all the following ones\n+                for (int i = level; i < set.size(); i ++ ) {\n+                    // either iterator is on a valid item or iterator is null\n+                    if (state.get(i) != null) {\n+                        bound.remove(state.get(i).peek());\n+                    } else {\n+                        break;\n+                    }\n+                }\n+            }\n+\n+            /**\n+             * Method that skips advances to the next element on the given level.\n+             * @param level level to advance\n+             */\n+            @Override\n+            public void skip(final int level) {\n+                if (level >= set.size()) {\n+                    throw new IndexOutOfBoundsException();\n+                }\n+\n+                if (state.get(level) == null) {\n+                    throw new UnsupportedOperationException(\"cannot skip/unbind as level is not bound at all\");\n+                }\n+\n+                // reset all the following ones\n+                for (int i = level + 1; i < set.size(); i ++ ) {\n+                    // either iterator is on a valid item or iterator is null\n+                    if (state.get(i) != null) {\n+                        bound.remove(state.get(i).peek());\n+                        state.set(i, null);\n+                    } else {\n+                        break;\n+                    }\n+                }\n+            }\n+        }\n+\n+        private ComplexIterable(@Nonnull final Set<T> set, @Nonnull final Function<T, Set<T>> dependsOnFn) {\n+            Verify.verify(set.size() > 1);\n+            this.set = ImmutableSet.copyOf(set);\n+            this.dependsOnFn = dependsOnFn;\n+        }\n+\n+        @Nonnull\n+        @Override\n+        public TopologicalOrderPermutationIterator<T> iterator() {\n+            return new ComplexIterator();\n+        }\n+    }\n+\n+    /**\n+     * An implementation of {@link TopologicalOrderPermutationIterable} that is optimized to work for empty\n+     * inputs sets. The case where the input set is empty is trivial and also properly handled by {@link ComplexIterable}.\n+     * Iterators created by this class, however, avoid to build complex state objects during their lifecycle.\n+     *\n+     * @param <T> type\n+     */\n+    private static class EmptyIterable<T> implements TopologicalOrderPermutationIterable<T> {\n+        private class EmptyIterator extends AbstractIterator<List<T>> implements TopologicalOrderPermutationIterator<T> {\n+            @Override\n+            public void skip(final int level) {\n+                throw new UnsupportedOperationException(\"cannot skip on empty iterator\");\n+            }\n+\n+            @Nullable\n+            @Override\n+            protected List<T> computeNext() {\n+                return endOfData();\n+            }\n+        }\n+\n+        @Nonnull\n+        @Override\n+        public TopologicalOrderPermutationIterator<T> iterator() {\n+            return new EmptyIterator();\n+        }\n+    }\n+\n+    /**\n+     * An implementation of {@link TopologicalOrderPermutationIterable} that is optimized to work for single item\n+     * inputs sets. The case where the input set is exactly one item is trivial and also properly handled by\n+     * {@link ComplexIterable}. Iterators created by this class, however, avoid to build complex state objects\n+     * during their lifecycle.\n+     *\n+     * @param <T> type\n+     */\n+    private static class SingleIterable<T> implements TopologicalOrderPermutationIterable<T> {\n+        private final T singleElement;\n+\n+        private SingleIterable(final T singleElement) {\n+            this.singleElement = singleElement;\n+        }\n+\n+        private class SingleIterator extends AbstractIterator<List<T>> implements TopologicalOrderPermutationIterator<T> {\n+            boolean atFirst = true;\n+\n+            @Override\n+            public void skip(final int level) {\n+                if (atFirst) {\n+                    throw new UnsupportedOperationException(\"cannot skip on before first element\");\n+                }\n+                // no op, we are at the end\n+            }\n+\n+            @Override\n+            protected List<T> computeNext() {\n+                if (!atFirst) {\n+                    return endOfData();\n+                }\n+\n+                atFirst = false;\n+\n+                return ImmutableList.of(singleElement);\n+            }\n+        }\n+\n+        @Nonnull\n+        @Override\n+        public TopologicalOrderPermutationIterator<T> iterator() {\n+            return new SingleIterator();\n+        }\n+    }\n+\n+    /**\n+     * Method to create a {@link TopologicalOrderPermutationIterable} based on a set and a function describing\n+     * the depends-on relationships between items in the given set.\n+     * @param set the set to create the iterable over\n+     * @param dependsOnFn a function from {@code T} to {@code Set<T>} that can be called during the lifecycle of all\n+     *        iterators multiple times repeatedly or not at all for any given element in {@code set}. This method is\n+     *        expected to return instantly and must be stable. Note it is allowed for the set the given function returns\n+     *        to contain elements of type {@code T} that are not in {@code set}. These items are ignored by the\n+     *        underlying algorithm (as in the dependency is instantly considered to be satisfied by all orderings).\n+     * @param <T> type\n+     * @return a new {@link TopologicalOrderPermutationIterable} that obeys the constraints as expressed in\n+     *         {@code dependsOnFn} in a sense that the iterators created by this iterator will not return\n+     *         orderings that violate the given depends-on constraints.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6eb7142ab316ffbec53e375804118f722f1d2bcc"}, "originalPosition": 384}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgzNTcyNzI4OnYy", "diffSide": "RIGHT", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/expressions/FullUnorderedScanExpression.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNFQyMToxODoxNlrOGxltYw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNFQyMToxODoxNlrOGxltYw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDY1MTIzNQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public FullUnorderedScanExpression rebase(final Map<CorrelationIdentifier, CorrelationIdentifier> translationMap) {\n          \n          \n            \n                public FullUnorderedScanExpression rebase(@Nonnull final Map<CorrelationIdentifier, CorrelationIdentifier> translationMap) {", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/988#discussion_r454651235", "createdAt": "2020-07-14T21:18:16Z", "author": {"login": "nschiefer"}, "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/expressions/FullUnorderedScanExpression.java", "diffHunk": "@@ -68,14 +72,37 @@ public FullUnorderedScanExpression(final Set<String> recordTypes) {\n         return ImmutableList.of();\n     }\n \n+    @Nonnull\n+    @Override\n+    public Set<CorrelationIdentifier> getCorrelatedTo() {\n+        return ImmutableSet.of();\n+    }\n+\n+    @Nonnull\n+    @Override\n+    public FullUnorderedScanExpression rebase(final Map<CorrelationIdentifier, CorrelationIdentifier> translationMap) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6eb7142ab316ffbec53e375804118f722f1d2bcc"}, "originalPosition": 37}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgzNTcyNzgxOnYy", "diffSide": "RIGHT", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/expressions/FullUnorderedScanExpression.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNFQyMToxODoyNlrOGxltsw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNFQyMToxODoyNlrOGxltsw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDY1MTMxNQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public boolean equalsWithoutChildren(@Nonnull RelationalExpression otherExpression, final BiMap<CorrelationIdentifier, CorrelationIdentifier> equivalencesMap) {\n          \n          \n            \n                public boolean equalsWithoutChildren(@Nonnull RelationalExpression otherExpression, @Nonnull final BiMap<CorrelationIdentifier, CorrelationIdentifier> equivalencesMap) {", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/988#discussion_r454651315", "createdAt": "2020-07-14T21:18:26Z", "author": {"login": "nschiefer"}, "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/expressions/FullUnorderedScanExpression.java", "diffHunk": "@@ -68,14 +72,37 @@ public FullUnorderedScanExpression(final Set<String> recordTypes) {\n         return ImmutableList.of();\n     }\n \n+    @Nonnull\n+    @Override\n+    public Set<CorrelationIdentifier> getCorrelatedTo() {\n+        return ImmutableSet.of();\n+    }\n+\n+    @Nonnull\n+    @Override\n+    public FullUnorderedScanExpression rebase(final Map<CorrelationIdentifier, CorrelationIdentifier> translationMap) {\n+        return this;\n+    }\n+\n+    @Override\n+    public boolean equalsWithoutChildren(@Nonnull RelationalExpression otherExpression, final BiMap<CorrelationIdentifier, CorrelationIdentifier> equivalencesMap) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6eb7142ab316ffbec53e375804118f722f1d2bcc"}, "originalPosition": 42}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgzNTcyODYxOnYy", "diffSide": "RIGHT", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/expressions/FullUnorderedScanExpression.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNFQyMToxODo0MVrOGxluJw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNFQyMToxODo0MVrOGxluJw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDY1MTQzMQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public boolean resultEquals(final Object other, final BiMap<CorrelationIdentifier, CorrelationIdentifier> equivalencesMap) {\n          \n          \n            \n                public boolean resultEquals(@Nullable final Object other, @Nonnull final BiMap<CorrelationIdentifier, CorrelationIdentifier> equivalencesMap) {", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/988#discussion_r454651431", "createdAt": "2020-07-14T21:18:41Z", "author": {"login": "nschiefer"}, "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/expressions/FullUnorderedScanExpression.java", "diffHunk": "@@ -68,14 +72,37 @@ public FullUnorderedScanExpression(final Set<String> recordTypes) {\n         return ImmutableList.of();\n     }\n \n+    @Nonnull\n+    @Override\n+    public Set<CorrelationIdentifier> getCorrelatedTo() {\n+        return ImmutableSet.of();\n+    }\n+\n+    @Nonnull\n+    @Override\n+    public FullUnorderedScanExpression rebase(final Map<CorrelationIdentifier, CorrelationIdentifier> translationMap) {\n+        return this;\n+    }\n+\n+    @Override\n+    public boolean equalsWithoutChildren(@Nonnull RelationalExpression otherExpression, final BiMap<CorrelationIdentifier, CorrelationIdentifier> equivalencesMap) {\n+        if (this == otherExpression) {\n+            return true;\n+        }\n+        return getClass() == otherExpression.getClass();\n+    }\n+\n     @Override\n-    public boolean equalsWithoutChildren(@Nonnull RelationalExpression otherExpression) {\n-        return equals(otherExpression);\n+    public boolean resultEquals(final Object other, final BiMap<CorrelationIdentifier, CorrelationIdentifier> equivalencesMap) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6eb7142ab316ffbec53e375804118f722f1d2bcc"}, "originalPosition": 52}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgzNTczMDA2OnYy", "diffSide": "RIGHT", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/expressions/IndexEntrySourceScanExpression.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNFQyMToxOToxMlrOGxlvEQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNFQyMToxOToxMlrOGxlvEQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDY1MTY2NQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public IndexEntrySourceScanExpression rebase(final Map<CorrelationIdentifier, CorrelationIdentifier> translationMap) {\n          \n          \n            \n                public IndexEntrySourceScanExpression rebase(@Nonnull final Map<CorrelationIdentifier, CorrelationIdentifier> translationMap) {", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/988#discussion_r454651665", "createdAt": "2020-07-14T21:19:12Z", "author": {"login": "nschiefer"}, "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/expressions/IndexEntrySourceScanExpression.java", "diffHunk": "@@ -91,11 +97,30 @@ public boolean isReverse() {\n         return reverse;\n     }\n \n+    @Nonnull\n+    @Override\n+    public Set<CorrelationIdentifier> getCorrelatedTo() {\n+        // TODO this may actually be correlated\n+        return ImmutableSet.of();\n+    }\n+\n+    @Nonnull\n     @Override\n-    public boolean equalsWithoutChildren(@Nonnull RelationalExpression otherExpression) {\n-        if (!(otherExpression instanceof IndexEntrySourceScanExpression)) {\n+    public IndexEntrySourceScanExpression rebase(final Map<CorrelationIdentifier, CorrelationIdentifier> translationMap) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6eb7142ab316ffbec53e375804118f722f1d2bcc"}, "originalPosition": 39}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgzNTczMDY5OnYy", "diffSide": "RIGHT", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/expressions/IndexEntrySourceScanExpression.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNFQyMToxOToyMlrOGxlveA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNFQyMToxOToyMlrOGxlveA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDY1MTc2OA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public boolean equalsWithoutChildren(@Nonnull RelationalExpression otherExpression, final BiMap<CorrelationIdentifier, CorrelationIdentifier> equivalencesMap) {\n          \n          \n            \n                public boolean equalsWithoutChildren(@Nonnull RelationalExpression otherExpression, @Nonnull final BiMap<CorrelationIdentifier, CorrelationIdentifier> equivalencesMap) {", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/988#discussion_r454651768", "createdAt": "2020-07-14T21:19:22Z", "author": {"login": "nschiefer"}, "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/expressions/IndexEntrySourceScanExpression.java", "diffHunk": "@@ -91,11 +97,30 @@ public boolean isReverse() {\n         return reverse;\n     }\n \n+    @Nonnull\n+    @Override\n+    public Set<CorrelationIdentifier> getCorrelatedTo() {\n+        // TODO this may actually be correlated\n+        return ImmutableSet.of();\n+    }\n+\n+    @Nonnull\n     @Override\n-    public boolean equalsWithoutChildren(@Nonnull RelationalExpression otherExpression) {\n-        if (!(otherExpression instanceof IndexEntrySourceScanExpression)) {\n+    public IndexEntrySourceScanExpression rebase(final Map<CorrelationIdentifier, CorrelationIdentifier> translationMap) {\n+        // TODO this may actually be correlated in this expression and we must rebase() properly here\n+        return this;\n+    }\n+\n+    @Override\n+    public boolean equalsWithoutChildren(@Nonnull RelationalExpression otherExpression, final BiMap<CorrelationIdentifier, CorrelationIdentifier> equivalencesMap) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6eb7142ab316ffbec53e375804118f722f1d2bcc"}, "originalPosition": 45}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgzNTczMTU5OnYy", "diffSide": "RIGHT", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/expressions/IndexEntrySourceScanExpression.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNFQyMToxOTo0NFrOGxlwIg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNFQyMToxOTo0NFrOGxlwIg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDY1MTkzOA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public boolean resultEquals(final Object other, final BiMap<CorrelationIdentifier, CorrelationIdentifier> equivalenceMap) {\n          \n          \n            \n                public boolean resultEquals(@Nullable final Object other, @Nonnull final BiMap<CorrelationIdentifier, CorrelationIdentifier> equivalenceMap) {", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/988#discussion_r454651938", "createdAt": "2020-07-14T21:19:44Z", "author": {"login": "nschiefer"}, "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/expressions/IndexEntrySourceScanExpression.java", "diffHunk": "@@ -104,18 +129,17 @@ public boolean equalsWithoutChildren(@Nonnull RelationalExpression otherExpressi\n     }\n \n     @Override\n-    public boolean equals(Object o) {\n-        if (this == o) {\n-            return true;\n-        }\n-        if (o == null || getClass() != o.getClass()) {\n+    public boolean resultEquals(final Object other, final BiMap<CorrelationIdentifier, CorrelationIdentifier> equivalenceMap) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6eb7142ab316ffbec53e375804118f722f1d2bcc"}, "originalPosition": 66}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgzNTczNDUzOnYy", "diffSide": "RIGHT", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/expressions/LogicalDistinctExpression.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNFQyMToyMDozNlrOGxlx3Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNFQyMToyMDozNlrOGxlx3Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDY1MjM4MQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public LogicalDistinctExpression rebase(final Map<CorrelationIdentifier, CorrelationIdentifier> translationMap) {\n          \n          \n            \n                public LogicalDistinctExpression rebase(@Nonnull final Map<CorrelationIdentifier, CorrelationIdentifier> translationMap) {", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/988#discussion_r454652381", "createdAt": "2020-07-14T21:20:36Z", "author": {"login": "nschiefer"}, "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/expressions/LogicalDistinctExpression.java", "diffHunk": "@@ -61,21 +71,29 @@ public int getRelationalChildCount() {\n         return ImmutableList.of(inner);\n     }\n \n+    @Nonnull\n+    @Override\n+    public Set<CorrelationIdentifier> getCorrelatedToWithoutChildren() {\n+        return ImmutableSet.of();\n+    }\n+\n+    @Nonnull\n+    @Override\n+    public LogicalDistinctExpression rebase(final Map<CorrelationIdentifier, CorrelationIdentifier> translationMap) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6eb7142ab316ffbec53e375804118f722f1d2bcc"}, "originalPosition": 55}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgzNTczNTc5OnYy", "diffSide": "RIGHT", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/expressions/LogicalDistinctExpression.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNFQyMToyMDo1NlrOGxlyoA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNFQyMToyMDo1NlrOGxlyoA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDY1MjU3Ng==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public LogicalDistinctExpression rebaseWithRebasedQuantifiers(final Map<CorrelationIdentifier, CorrelationIdentifier> translationMap, final List<Quantifier> rebasedChildren) {\n          \n          \n            \n                public LogicalDistinctExpression rebaseWithRebasedQuantifiers(@Nonnull final Map<CorrelationIdentifier, CorrelationIdentifier> translationMap, @Nonnull final List<Quantifier> rebasedChildren) {", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/988#discussion_r454652576", "createdAt": "2020-07-14T21:20:56Z", "author": {"login": "nschiefer"}, "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/expressions/LogicalDistinctExpression.java", "diffHunk": "@@ -61,21 +71,29 @@ public int getRelationalChildCount() {\n         return ImmutableList.of(inner);\n     }\n \n+    @Nonnull\n+    @Override\n+    public Set<CorrelationIdentifier> getCorrelatedToWithoutChildren() {\n+        return ImmutableSet.of();\n+    }\n+\n+    @Nonnull\n+    @Override\n+    public LogicalDistinctExpression rebase(final Map<CorrelationIdentifier, CorrelationIdentifier> translationMap) {\n+        // we know the following is correct, just Java doesn't\n+        return (LogicalDistinctExpression)RelationalExpressionWithChildren.super.rebase(translationMap);\n+    }\n+\n+    @Nonnull\n     @Override\n-    public boolean equalsWithoutChildren(@Nonnull RelationalExpression otherExpression) {\n-        return otherExpression instanceof LogicalDistinctExpression;\n+    public LogicalDistinctExpression rebaseWithRebasedQuantifiers(final Map<CorrelationIdentifier, CorrelationIdentifier> translationMap, final List<Quantifier> rebasedChildren) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6eb7142ab316ffbec53e375804118f722f1d2bcc"}, "originalPosition": 64}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgzNTc0MTYwOnYy", "diffSide": "RIGHT", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/expressions/LogicalFilterExpression.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNFQyMToyMjo1OVrOGxl2UQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNFQyMToyMjo1OVrOGxl2UQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDY1MzUyMQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public LogicalFilterExpression rebase(final Map<CorrelationIdentifier, CorrelationIdentifier> translationMap) {\n          \n          \n            \n                public LogicalFilterExpression rebase(@Nonnull final Map<CorrelationIdentifier, CorrelationIdentifier> translationMap) {", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/988#discussion_r454653521", "createdAt": "2020-07-14T21:22:59Z", "author": {"login": "nschiefer"}, "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/expressions/LogicalFilterExpression.java", "diffHunk": "@@ -96,22 +103,37 @@ public Quantifier getInner() {\n         return inner;\n     }\n \n+    @Nonnull\n+    @Override\n+    public Set<CorrelationIdentifier> getCorrelatedToWithoutChildren() {\n+        return filter.getCorrelatedTo();\n+    }\n+\n+    @Nonnull\n+    @Override\n+    public LogicalFilterExpression rebase(final Map<CorrelationIdentifier, CorrelationIdentifier> translationMap) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6eb7142ab316ffbec53e375804118f722f1d2bcc"}, "originalPosition": 68}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgzNTc0MjE4OnYy", "diffSide": "RIGHT", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/expressions/LogicalFilterExpression.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNFQyMToyMzoxMlrOGxl2rA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNFQyMToyMzoxMlrOGxl2rA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDY1MzYxMg==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public LogicalFilterExpression rebaseWithRebasedQuantifiers(final Map<CorrelationIdentifier, CorrelationIdentifier> translationMap, final List<Quantifier> rebasedQuantifiers) {\n          \n          \n            \n                public LogicalFilterExpression rebaseWithRebasedQuantifiers(@Nonnull final Map<CorrelationIdentifier, CorrelationIdentifier> translationMap, @Nonnull final List<Quantifier> rebasedQuantifiers) {", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/988#discussion_r454653612", "createdAt": "2020-07-14T21:23:12Z", "author": {"login": "nschiefer"}, "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/expressions/LogicalFilterExpression.java", "diffHunk": "@@ -96,22 +103,37 @@ public Quantifier getInner() {\n         return inner;\n     }\n \n+    @Nonnull\n+    @Override\n+    public Set<CorrelationIdentifier> getCorrelatedToWithoutChildren() {\n+        return filter.getCorrelatedTo();\n+    }\n+\n+    @Nonnull\n+    @Override\n+    public LogicalFilterExpression rebase(final Map<CorrelationIdentifier, CorrelationIdentifier> translationMap) {\n+        // we know the following is correct, just Java doesn't\n+        return (LogicalFilterExpression)RelationalExpressionWithChildren.super.rebase(translationMap);\n+    }\n+\n+    @Nonnull\n+    @Override\n+    public LogicalFilterExpression rebaseWithRebasedQuantifiers(final Map<CorrelationIdentifier, CorrelationIdentifier> translationMap, final List<Quantifier> rebasedQuantifiers) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6eb7142ab316ffbec53e375804118f722f1d2bcc"}, "originalPosition": 75}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgzNTc0MzE5OnYy", "diffSide": "RIGHT", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/expressions/LogicalFilterExpression.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNFQyMToyMzozM1rOGxl3WQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNFQyMToyMzozM1rOGxl3WQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDY1Mzc4NQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public boolean equalsWithoutChildren(@Nonnull RelationalExpression otherExpression, final BiMap<CorrelationIdentifier, CorrelationIdentifier> equivalencesMap) {\n          \n          \n            \n                public boolean equalsWithoutChildren(@Nonnull RelationalExpression otherExpression, @Nonnull final BiMap<CorrelationIdentifier, CorrelationIdentifier> equivalencesMap) {", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/988#discussion_r454653785", "createdAt": "2020-07-14T21:23:33Z", "author": {"login": "nschiefer"}, "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/expressions/LogicalFilterExpression.java", "diffHunk": "@@ -96,22 +103,37 @@ public Quantifier getInner() {\n         return inner;\n     }\n \n+    @Nonnull\n+    @Override\n+    public Set<CorrelationIdentifier> getCorrelatedToWithoutChildren() {\n+        return filter.getCorrelatedTo();\n+    }\n+\n+    @Nonnull\n+    @Override\n+    public LogicalFilterExpression rebase(final Map<CorrelationIdentifier, CorrelationIdentifier> translationMap) {\n+        // we know the following is correct, just Java doesn't\n+        return (LogicalFilterExpression)RelationalExpressionWithChildren.super.rebase(translationMap);\n+    }\n+\n+    @Nonnull\n+    @Override\n+    public LogicalFilterExpression rebaseWithRebasedQuantifiers(final Map<CorrelationIdentifier, CorrelationIdentifier> translationMap, final List<Quantifier> rebasedQuantifiers) {\n+        return new LogicalFilterExpression(getBaseSource(),\n+                getPredicate().rebase(translationMap),\n+                Iterables.getOnlyElement(rebasedQuantifiers));\n+    }\n+\n     @Override\n-    public boolean equalsWithoutChildren(@Nonnull RelationalExpression otherExpression) {\n-        return otherExpression instanceof LogicalFilterExpression && filter.equals(((LogicalFilterExpression)otherExpression).getPredicate());\n+    public boolean equalsWithoutChildren(@Nonnull RelationalExpression otherExpression, final BiMap<CorrelationIdentifier, CorrelationIdentifier> equivalencesMap) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6eb7142ab316ffbec53e375804118f722f1d2bcc"}, "originalPosition": 84}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgzNTc0NzY5OnYy", "diffSide": "RIGHT", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/expressions/LogicalSortExpression.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNFQyMToyNTowM1rOGxl6Lg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNFQyMToyNTowM1rOGxl6Lg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDY1NDUxMA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public LogicalSortExpression rebase(final Map<CorrelationIdentifier, CorrelationIdentifier> translationMap) {\n          \n          \n            \n                public LogicalSortExpression rebase(@Nonnull final Map<CorrelationIdentifier, CorrelationIdentifier> translationMap) {", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/988#discussion_r454654510", "createdAt": "2020-07-14T21:25:03Z", "author": {"login": "nschiefer"}, "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/expressions/LogicalSortExpression.java", "diffHunk": "@@ -111,28 +115,60 @@ private Quantifier getInner() {\n         return inner;\n     }\n \n+    @Nonnull\n+    @Override\n+    public Set<CorrelationIdentifier> getCorrelatedToWithoutChildren() {\n+        return ImmutableSet.of();\n+    }\n+\n+    @Nonnull\n+    @Override\n+    public LogicalSortExpression rebase(final Map<CorrelationIdentifier, CorrelationIdentifier> translationMap) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6eb7142ab316ffbec53e375804118f722f1d2bcc"}, "originalPosition": 79}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgzNTc0ODQ4OnYy", "diffSide": "RIGHT", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/expressions/LogicalSortExpression.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNFQyMToyNToxNVrOGxl6mg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNFQyMToyNToxNVrOGxl6mg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDY1NDYxOA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public LogicalSortExpression rebaseWithRebasedQuantifiers(final Map<CorrelationIdentifier, CorrelationIdentifier> translationMap,\n          \n          \n            \n                public LogicalSortExpression rebaseWithRebasedQuantifiers(@Nonnull final Map<CorrelationIdentifier, CorrelationIdentifier> translationMap,", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/988#discussion_r454654618", "createdAt": "2020-07-14T21:25:15Z", "author": {"login": "nschiefer"}, "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/expressions/LogicalSortExpression.java", "diffHunk": "@@ -111,28 +115,60 @@ private Quantifier getInner() {\n         return inner;\n     }\n \n+    @Nonnull\n+    @Override\n+    public Set<CorrelationIdentifier> getCorrelatedToWithoutChildren() {\n+        return ImmutableSet.of();\n+    }\n+\n+    @Nonnull\n+    @Override\n+    public LogicalSortExpression rebase(final Map<CorrelationIdentifier, CorrelationIdentifier> translationMap) {\n+        // we know the following is correct, just Java doesn't\n+        return (LogicalSortExpression)RelationalExpressionWithChildren.super.rebase(translationMap);\n+    }\n+\n+    @Nonnull\n+    @Override\n+    public LogicalSortExpression rebaseWithRebasedQuantifiers(final Map<CorrelationIdentifier, CorrelationIdentifier> translationMap,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6eb7142ab316ffbec53e375804118f722f1d2bcc"}, "originalPosition": 86}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgzNTc0OTA4OnYy", "diffSide": "RIGHT", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/expressions/LogicalSortExpression.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNFQyMToyNToyOFrOGxl7AQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNFQyMToyNToyOFrOGxl7AQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDY1NDcyMQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                                                          final List<Quantifier> rebasedQuantifiers) {\n          \n          \n            \n                                                                          @Nonnull final List<Quantifier> rebasedQuantifiers) {", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/988#discussion_r454654721", "createdAt": "2020-07-14T21:25:28Z", "author": {"login": "nschiefer"}, "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/expressions/LogicalSortExpression.java", "diffHunk": "@@ -111,28 +115,60 @@ private Quantifier getInner() {\n         return inner;\n     }\n \n+    @Nonnull\n+    @Override\n+    public Set<CorrelationIdentifier> getCorrelatedToWithoutChildren() {\n+        return ImmutableSet.of();\n+    }\n+\n+    @Nonnull\n+    @Override\n+    public LogicalSortExpression rebase(final Map<CorrelationIdentifier, CorrelationIdentifier> translationMap) {\n+        // we know the following is correct, just Java doesn't\n+        return (LogicalSortExpression)RelationalExpressionWithChildren.super.rebase(translationMap);\n+    }\n+\n+    @Nonnull\n+    @Override\n+    public LogicalSortExpression rebaseWithRebasedQuantifiers(final Map<CorrelationIdentifier, CorrelationIdentifier> translationMap,\n+                                                              final List<Quantifier> rebasedQuantifiers) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6eb7142ab316ffbec53e375804118f722f1d2bcc"}, "originalPosition": 87}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgzNTc1MDI1OnYy", "diffSide": "RIGHT", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/expressions/LogicalSortExpression.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNFQyMToyNTo1MlrOGxl7yw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNFQyMToyNTo1MlrOGxl7yw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDY1NDkyMw==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public boolean equalsWithoutChildren(@Nonnull RelationalExpression otherExpression, final BiMap<CorrelationIdentifier, CorrelationIdentifier> equivalencesMap) {\n          \n          \n            \n                public boolean equalsWithoutChildren(@Nonnull RelationalExpression otherExpression, @Nonnull final BiMap<CorrelationIdentifier, CorrelationIdentifier> equivalencesMap) {", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/988#discussion_r454654923", "createdAt": "2020-07-14T21:25:52Z", "author": {"login": "nschiefer"}, "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/expressions/LogicalSortExpression.java", "diffHunk": "@@ -111,28 +115,60 @@ private Quantifier getInner() {\n         return inner;\n     }\n \n+    @Nonnull\n+    @Override\n+    public Set<CorrelationIdentifier> getCorrelatedToWithoutChildren() {\n+        return ImmutableSet.of();\n+    }\n+\n+    @Nonnull\n+    @Override\n+    public LogicalSortExpression rebase(final Map<CorrelationIdentifier, CorrelationIdentifier> translationMap) {\n+        // we know the following is correct, just Java doesn't\n+        return (LogicalSortExpression)RelationalExpressionWithChildren.super.rebase(translationMap);\n+    }\n+\n+    @Nonnull\n+    @Override\n+    public LogicalSortExpression rebaseWithRebasedQuantifiers(final Map<CorrelationIdentifier, CorrelationIdentifier> translationMap,\n+                                                              final List<Quantifier> rebasedQuantifiers) {\n+        return new LogicalSortExpression(\n+                getGrouping()\n+                        .stream()\n+                        .map(element -> element.rebase(translationMap))\n+                        .collect(Collectors.toList()),\n+                getSort()\n+                        .stream()\n+                        .map(element -> element.rebase(translationMap))\n+                        .collect(Collectors.toList()),\n+                isReverse(),\n+                Iterables.getOnlyElement(rebasedQuantifiers));\n+    }\n+\n+    @SuppressWarnings(\"UnstableApiUsage\")\n     @Override\n     @API(API.Status.EXPERIMENTAL)\n-    public boolean equalsWithoutChildren(@Nonnull RelationalExpression otherExpression) {\n-        if (!(otherExpression instanceof LogicalSortExpression)) {\n+    public boolean equalsWithoutChildren(@Nonnull RelationalExpression otherExpression, final BiMap<CorrelationIdentifier, CorrelationIdentifier> equivalencesMap) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6eb7142ab316ffbec53e375804118f722f1d2bcc"}, "originalPosition": 106}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgzNTc1NzMwOnYy", "diffSide": "RIGHT", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/expressions/LogicalTypeFilterExpression.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNFQyMToyODowM1rOGxmAGQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNFQyMToyODowM1rOGxmAGQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDY1NjAyNQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public LogicalTypeFilterExpression rebase(final Map<CorrelationIdentifier, CorrelationIdentifier> translationMap) {\n          \n          \n            \n                public LogicalTypeFilterExpression rebase(@Nonnull final Map<CorrelationIdentifier, CorrelationIdentifier> translationMap) {", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/988#discussion_r454656025", "createdAt": "2020-07-14T21:28:03Z", "author": {"login": "nschiefer"}, "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/expressions/LogicalTypeFilterExpression.java", "diffHunk": "@@ -80,23 +83,24 @@ private Quantifier getInner() {\n         return inner;\n     }\n \n+    @Nonnull\n     @Override\n-    public boolean equalsWithoutChildren(@Nonnull RelationalExpression otherExpression) {\n-        return otherExpression instanceof LogicalTypeFilterExpression &&\n-               ((LogicalTypeFilterExpression)otherExpression).getRecordTypes().equals(getRecordTypes());\n+    public LogicalTypeFilterExpression rebase(final Map<CorrelationIdentifier, CorrelationIdentifier> translationMap) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6eb7142ab316ffbec53e375804118f722f1d2bcc"}, "originalPosition": 53}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgzNTc1ODAxOnYy", "diffSide": "RIGHT", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/expressions/LogicalTypeFilterExpression.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNFQyMToyODoyMFrOGxmAlA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNFQyMToyODoyMFrOGxmAlA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDY1NjE0OA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public LogicalTypeFilterExpression rebaseWithRebasedQuantifiers(final Map<CorrelationIdentifier, CorrelationIdentifier> translationMap, final List<Quantifier> rebasedQuantifiers) {\n          \n          \n            \n                public LogicalTypeFilterExpression rebaseWithRebasedQuantifiers(@Nonnull final Map<CorrelationIdentifier, CorrelationIdentifier> translationMap, @Nonnull final List<Quantifier> rebasedQuantifiers) {", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/988#discussion_r454656148", "createdAt": "2020-07-14T21:28:20Z", "author": {"login": "nschiefer"}, "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/expressions/LogicalTypeFilterExpression.java", "diffHunk": "@@ -80,23 +83,24 @@ private Quantifier getInner() {\n         return inner;\n     }\n \n+    @Nonnull\n     @Override\n-    public boolean equalsWithoutChildren(@Nonnull RelationalExpression otherExpression) {\n-        return otherExpression instanceof LogicalTypeFilterExpression &&\n-               ((LogicalTypeFilterExpression)otherExpression).getRecordTypes().equals(getRecordTypes());\n+    public LogicalTypeFilterExpression rebase(final Map<CorrelationIdentifier, CorrelationIdentifier> translationMap) {\n+        // we know the following is correct, just Java doesn't\n+        return (LogicalTypeFilterExpression)TypeFilterExpression.super.rebase(translationMap);\n+    }\n+\n+    @Override\n+    @Nonnull\n+    public LogicalTypeFilterExpression rebaseWithRebasedQuantifiers(final Map<CorrelationIdentifier, CorrelationIdentifier> translationMap, final List<Quantifier> rebasedQuantifiers) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6eb7142ab316ffbec53e375804118f722f1d2bcc"}, "originalPosition": 60}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgzNTc1OTM1OnYy", "diffSide": "RIGHT", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/expressions/LogicalUnorderedUnionExpression.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNFQyMToyODo1MlrOGxmBfQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNFQyMToyODo1MlrOGxmBfQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDY1NjM4MQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public LogicalUnorderedUnionExpression rebase(final Map<CorrelationIdentifier, CorrelationIdentifier> translationMap) {\n          \n          \n            \n                public LogicalUnorderedUnionExpression rebase(@Nonnull final Map<CorrelationIdentifier, CorrelationIdentifier> translationMap) {", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/988#discussion_r454656381", "createdAt": "2020-07-14T21:28:52Z", "author": {"login": "nschiefer"}, "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/expressions/LogicalUnorderedUnionExpression.java", "diffHunk": "@@ -37,42 +39,51 @@\n @API(API.Status.EXPERIMENTAL)\n public class LogicalUnorderedUnionExpression implements RelationalExpressionWithChildren {\n     @Nonnull\n-    private List<Quantifier.ForEach> children;\n+    private List<? extends Quantifier> quantifiers;\n \n-    public LogicalUnorderedUnionExpression(@Nonnull List<ExpressionRef<RelationalExpression>> expressionChildren) {\n-        this.children = Quantifiers.forEachQuantifiers(expressionChildren);\n+    public LogicalUnorderedUnionExpression(@Nonnull List<? extends Quantifier> quantifiers) {\n+        this.quantifiers = quantifiers;\n     }\n \n     @Override\n     public int getRelationalChildCount() {\n-        return children.size();\n+        return quantifiers.size();\n     }\n \n     @Nonnull\n     @Override\n     public List<? extends Quantifier> getQuantifiers() {\n-        return children;\n+        return quantifiers;\n     }\n \n+    @Nonnull\n+    @Override\n+    public Set<CorrelationIdentifier> getCorrelatedToWithoutChildren() {\n+        return ImmutableSet.of();\n+    }\n+\n+    @Nonnull\n+    @Override\n+    public LogicalUnorderedUnionExpression rebase(final Map<CorrelationIdentifier, CorrelationIdentifier> translationMap) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6eb7142ab316ffbec53e375804118f722f1d2bcc"}, "originalPosition": 54}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgzNTc2MDE5OnYy", "diffSide": "RIGHT", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/expressions/LogicalUnorderedUnionExpression.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNFQyMToyOToxMlrOGxmCEg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNFQyMToyOToxMlrOGxmCEg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDY1NjUzMA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public LogicalUnorderedUnionExpression rebaseWithRebasedQuantifiers(final Map<CorrelationIdentifier, CorrelationIdentifier> translationMap,\n          \n          \n            \n                                                                                    final List<Quantifier> rebasedQuantifiers) {\n          \n          \n            \n                public LogicalUnorderedUnionExpression rebaseWithRebasedQuantifiers(@Nonnull final Map<CorrelationIdentifier, CorrelationIdentifier> translationMap,\n          \n          \n            \n                                                                                    @Nonnull final List<Quantifier> rebasedQuantifiers) {", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/988#discussion_r454656530", "createdAt": "2020-07-14T21:29:12Z", "author": {"login": "nschiefer"}, "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/expressions/LogicalUnorderedUnionExpression.java", "diffHunk": "@@ -37,42 +39,51 @@\n @API(API.Status.EXPERIMENTAL)\n public class LogicalUnorderedUnionExpression implements RelationalExpressionWithChildren {\n     @Nonnull\n-    private List<Quantifier.ForEach> children;\n+    private List<? extends Quantifier> quantifiers;\n \n-    public LogicalUnorderedUnionExpression(@Nonnull List<ExpressionRef<RelationalExpression>> expressionChildren) {\n-        this.children = Quantifiers.forEachQuantifiers(expressionChildren);\n+    public LogicalUnorderedUnionExpression(@Nonnull List<? extends Quantifier> quantifiers) {\n+        this.quantifiers = quantifiers;\n     }\n \n     @Override\n     public int getRelationalChildCount() {\n-        return children.size();\n+        return quantifiers.size();\n     }\n \n     @Nonnull\n     @Override\n     public List<? extends Quantifier> getQuantifiers() {\n-        return children;\n+        return quantifiers;\n     }\n \n+    @Nonnull\n+    @Override\n+    public Set<CorrelationIdentifier> getCorrelatedToWithoutChildren() {\n+        return ImmutableSet.of();\n+    }\n+\n+    @Nonnull\n+    @Override\n+    public LogicalUnorderedUnionExpression rebase(final Map<CorrelationIdentifier, CorrelationIdentifier> translationMap) {\n+        // we know the following is correct, just Java doesn't\n+        return (LogicalUnorderedUnionExpression)RelationalExpressionWithChildren.super.rebase(translationMap);\n+    }\n+\n+    @Nonnull\n     @Override\n-    public boolean equalsWithoutChildren(@Nonnull RelationalExpression otherExpression) {\n-        return otherExpression instanceof LogicalUnorderedUnionExpression;\n+    public LogicalUnorderedUnionExpression rebaseWithRebasedQuantifiers(final Map<CorrelationIdentifier, CorrelationIdentifier> translationMap,\n+                                                                        final List<Quantifier> rebasedQuantifiers) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6eb7142ab316ffbec53e375804118f722f1d2bcc"}, "originalPosition": 64}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgzNTc2MTU5OnYy", "diffSide": "RIGHT", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/expressions/RelationalExpressionWithChildren.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNFQyMToyOTo0MFrOGxmC7g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNFQyMToyOTo0MFrOGxmC7g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDY1Njc1MA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    final Map<CorrelationIdentifier, ? extends Quantifier> aliasToQuantifierMap =\n          \n          \n            \n                            quantifiers.stream()\n          \n          \n            \n                    final Map<CorrelationIdentifier, ? extends Quantifier> aliasToQuantifierMap = quantifiers.stream()", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/988#discussion_r454656750", "createdAt": "2020-07-14T21:29:40Z", "author": {"login": "nschiefer"}, "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/expressions/RelationalExpressionWithChildren.java", "diffHunk": "@@ -30,4 +45,87 @@\n @API(API.Status.EXPERIMENTAL)\n public interface RelationalExpressionWithChildren extends RelationalExpression {\n     int getRelationalChildCount();\n+\n+    @Nonnull\n+    @SuppressWarnings(\"squid:S2201\")\n+    default Set<CorrelationIdentifier> getCorrelatedTo() {\n+        final ImmutableSet.Builder<CorrelationIdentifier> builder = ImmutableSet.builder();\n+        final List<? extends Quantifier> quantifiers = getQuantifiers();\n+\n+        final Map<CorrelationIdentifier, ? extends Quantifier> aliasToQuantifierMap =\n+                quantifiers.stream()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6eb7142ab316ffbec53e375804118f722f1d2bcc"}, "originalPosition": 35}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgzNTc4Njk2OnYy", "diffSide": "RIGHT", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/expressions/RelationalExpressionWithChildren.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNFQyMTozODowNFrOGxmS9Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMFQyMToyMzoyN1rOG0fx1g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDY2MDg1Mw==", "bodyText": "This is using the property that every topological permutation removes the same set of (now) bound correlations, right? I think that's worth a comment.", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/988#discussion_r454660853", "createdAt": "2020-07-14T21:38:04Z", "author": {"login": "nschiefer"}, "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/expressions/RelationalExpressionWithChildren.java", "diffHunk": "@@ -30,4 +45,87 @@\n @API(API.Status.EXPERIMENTAL)\n public interface RelationalExpressionWithChildren extends RelationalExpression {\n     int getRelationalChildCount();\n+\n+    @Nonnull\n+    @SuppressWarnings(\"squid:S2201\")\n+    default Set<CorrelationIdentifier> getCorrelatedTo() {\n+        final ImmutableSet.Builder<CorrelationIdentifier> builder = ImmutableSet.builder();\n+        final List<? extends Quantifier> quantifiers = getQuantifiers();\n+\n+        final Map<CorrelationIdentifier, ? extends Quantifier> aliasToQuantifierMap =\n+                quantifiers.stream()\n+                        .collect(Collectors.toMap(Quantifier::getAlias, Function.identity()));\n+\n+        final Optional<List<CorrelationIdentifier>> orderedOptional =", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6eb7142ab316ffbec53e375804118f722f1d2bcc"}, "originalPosition": 38}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzY5OTc5OA==", "bodyText": "Added a comment.", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/988#discussion_r457699798", "createdAt": "2020-07-20T21:23:27Z", "author": {"login": "normen662"}, "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/expressions/RelationalExpressionWithChildren.java", "diffHunk": "@@ -30,4 +45,87 @@\n @API(API.Status.EXPERIMENTAL)\n public interface RelationalExpressionWithChildren extends RelationalExpression {\n     int getRelationalChildCount();\n+\n+    @Nonnull\n+    @SuppressWarnings(\"squid:S2201\")\n+    default Set<CorrelationIdentifier> getCorrelatedTo() {\n+        final ImmutableSet.Builder<CorrelationIdentifier> builder = ImmutableSet.builder();\n+        final List<? extends Quantifier> quantifiers = getQuantifiers();\n+\n+        final Map<CorrelationIdentifier, ? extends Quantifier> aliasToQuantifierMap =\n+                quantifiers.stream()\n+                        .collect(Collectors.toMap(Quantifier::getAlias, Function.identity()));\n+\n+        final Optional<List<CorrelationIdentifier>> orderedOptional =", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDY2MDg1Mw=="}, "originalCommit": {"oid": "6eb7142ab316ffbec53e375804118f722f1d2bcc"}, "originalPosition": 38}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgzNTc4NzY2OnYy", "diffSide": "RIGHT", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/expressions/RelationalExpressionWithChildren.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNFQyMTozODoxOVrOGxmTcA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNFQyMTozODoxOVrOGxmTcA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDY2MDk3Ng==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                default RelationalExpressionWithChildren rebase(final Map<CorrelationIdentifier, CorrelationIdentifier> translationMap) {\n          \n          \n            \n                default RelationalExpressionWithChildren rebase(@Nonnull final Map<CorrelationIdentifier, CorrelationIdentifier> translationMap) {", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/988#discussion_r454660976", "createdAt": "2020-07-14T21:38:19Z", "author": {"login": "nschiefer"}, "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/expressions/RelationalExpressionWithChildren.java", "diffHunk": "@@ -30,4 +45,87 @@\n @API(API.Status.EXPERIMENTAL)\n public interface RelationalExpressionWithChildren extends RelationalExpression {\n     int getRelationalChildCount();\n+\n+    @Nonnull\n+    @SuppressWarnings(\"squid:S2201\")\n+    default Set<CorrelationIdentifier> getCorrelatedTo() {\n+        final ImmutableSet.Builder<CorrelationIdentifier> builder = ImmutableSet.builder();\n+        final List<? extends Quantifier> quantifiers = getQuantifiers();\n+\n+        final Map<CorrelationIdentifier, ? extends Quantifier> aliasToQuantifierMap =\n+                quantifiers.stream()\n+                        .collect(Collectors.toMap(Quantifier::getAlias, Function.identity()));\n+\n+        final Optional<List<CorrelationIdentifier>> orderedOptional =\n+                TopologicalSort.anyTopologicalOrderPermutation(\n+                        quantifiers.stream()\n+                                .map(Quantifier::getAlias)\n+                                .collect(Collectors.toSet()),\n+                        alias -> Objects.requireNonNull(aliasToQuantifierMap.get(alias)).getCorrelatedTo());\n+\n+        orderedOptional.orElseThrow(() -> new IllegalArgumentException(\"correlations are cyclic\"));\n+\n+        for (final Quantifier quantifier : quantifiers) {\n+            quantifier.getCorrelatedTo()\n+                    .stream()\n+                    // Filter out the correlations that are satisfied by this expression if this expression can\n+                    // correlate.\n+                    .filter(correlationIdentifier -> !canCorrelate() || !aliasToQuantifierMap.containsKey(correlationIdentifier))\n+                    .forEach(builder::add);\n+        }\n+\n+        return builder.addAll(getCorrelatedToWithoutChildren())\n+                .build();\n+    }\n+\n+    @Nonnull\n+    Set<CorrelationIdentifier> getCorrelatedToWithoutChildren();\n+\n+    @Nonnull\n+    @Override\n+    default RelationalExpressionWithChildren rebase(final Map<CorrelationIdentifier, CorrelationIdentifier> translationMap) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6eb7142ab316ffbec53e375804118f722f1d2bcc"}, "originalPosition": 65}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgzNTgzMTIyOnYy", "diffSide": "RIGHT", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/expressions/RelationalExpressionWithChildren.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNFQyMTo1NDowM1rOGxmucA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNFQyMTo1NDowM1rOGxmucA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDY2Nzg4OA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                RelationalExpressionWithChildren rebaseWithRebasedQuantifiers(final Map<CorrelationIdentifier, CorrelationIdentifier> translationMap,\n          \n          \n            \n                                                                              final List<Quantifier> rebasedQuantifiers);\n          \n          \n            \n                RelationalExpressionWithChildren rebaseWithRebasedQuantifiers(@Nonnull final Map<CorrelationIdentifier, CorrelationIdentifier> translationMap,\n          \n          \n            \n                                                                              @Nonnull final List<Quantifier> rebasedQuantifiers);", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/988#discussion_r454667888", "createdAt": "2020-07-14T21:54:03Z", "author": {"login": "nschiefer"}, "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/expressions/RelationalExpressionWithChildren.java", "diffHunk": "@@ -30,4 +45,87 @@\n @API(API.Status.EXPERIMENTAL)\n public interface RelationalExpressionWithChildren extends RelationalExpression {\n     int getRelationalChildCount();\n+\n+    @Nonnull\n+    @SuppressWarnings(\"squid:S2201\")\n+    default Set<CorrelationIdentifier> getCorrelatedTo() {\n+        final ImmutableSet.Builder<CorrelationIdentifier> builder = ImmutableSet.builder();\n+        final List<? extends Quantifier> quantifiers = getQuantifiers();\n+\n+        final Map<CorrelationIdentifier, ? extends Quantifier> aliasToQuantifierMap =\n+                quantifiers.stream()\n+                        .collect(Collectors.toMap(Quantifier::getAlias, Function.identity()));\n+\n+        final Optional<List<CorrelationIdentifier>> orderedOptional =\n+                TopologicalSort.anyTopologicalOrderPermutation(\n+                        quantifiers.stream()\n+                                .map(Quantifier::getAlias)\n+                                .collect(Collectors.toSet()),\n+                        alias -> Objects.requireNonNull(aliasToQuantifierMap.get(alias)).getCorrelatedTo());\n+\n+        orderedOptional.orElseThrow(() -> new IllegalArgumentException(\"correlations are cyclic\"));\n+\n+        for (final Quantifier quantifier : quantifiers) {\n+            quantifier.getCorrelatedTo()\n+                    .stream()\n+                    // Filter out the correlations that are satisfied by this expression if this expression can\n+                    // correlate.\n+                    .filter(correlationIdentifier -> !canCorrelate() || !aliasToQuantifierMap.containsKey(correlationIdentifier))\n+                    .forEach(builder::add);\n+        }\n+\n+        return builder.addAll(getCorrelatedToWithoutChildren())\n+                .build();\n+    }\n+\n+    @Nonnull\n+    Set<CorrelationIdentifier> getCorrelatedToWithoutChildren();\n+\n+    @Nonnull\n+    @Override\n+    default RelationalExpressionWithChildren rebase(final Map<CorrelationIdentifier, CorrelationIdentifier> translationMap) {\n+        final List<Quantifier> rebasedQuantifiers = getQuantifiers().stream()\n+                .map(quantifier -> quantifier.rebase(translationMap))\n+                .collect(Collectors.toList());\n+        return rebaseWithRebasedQuantifiers(translationMap,\n+                rebasedQuantifiers);\n+    }\n+\n+    @Nonnull\n+    RelationalExpressionWithChildren rebaseWithRebasedQuantifiers(final Map<CorrelationIdentifier, CorrelationIdentifier> translationMap,\n+                                                                  final List<Quantifier> rebasedQuantifiers);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6eb7142ab316ffbec53e375804118f722f1d2bcc"}, "originalPosition": 75}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgzNTgzMjA4OnYy", "diffSide": "RIGHT", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/expressions/RelationalExpressionWithChildren.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNFQyMTo1NDoxOFrOGxmu6A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNFQyMTo1NDoxOFrOGxmu6A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDY2ODAwOA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                default boolean resultEquals(final Object other, final BiMap<CorrelationIdentifier, CorrelationIdentifier> equivalenceMap) {\n          \n          \n            \n                default boolean resultEquals(@Nullable final Object other, @Nonnull final BiMap<CorrelationIdentifier, CorrelationIdentifier> equivalenceMap) {", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/988#discussion_r454668008", "createdAt": "2020-07-14T21:54:18Z", "author": {"login": "nschiefer"}, "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/expressions/RelationalExpressionWithChildren.java", "diffHunk": "@@ -30,4 +45,87 @@\n @API(API.Status.EXPERIMENTAL)\n public interface RelationalExpressionWithChildren extends RelationalExpression {\n     int getRelationalChildCount();\n+\n+    @Nonnull\n+    @SuppressWarnings(\"squid:S2201\")\n+    default Set<CorrelationIdentifier> getCorrelatedTo() {\n+        final ImmutableSet.Builder<CorrelationIdentifier> builder = ImmutableSet.builder();\n+        final List<? extends Quantifier> quantifiers = getQuantifiers();\n+\n+        final Map<CorrelationIdentifier, ? extends Quantifier> aliasToQuantifierMap =\n+                quantifiers.stream()\n+                        .collect(Collectors.toMap(Quantifier::getAlias, Function.identity()));\n+\n+        final Optional<List<CorrelationIdentifier>> orderedOptional =\n+                TopologicalSort.anyTopologicalOrderPermutation(\n+                        quantifiers.stream()\n+                                .map(Quantifier::getAlias)\n+                                .collect(Collectors.toSet()),\n+                        alias -> Objects.requireNonNull(aliasToQuantifierMap.get(alias)).getCorrelatedTo());\n+\n+        orderedOptional.orElseThrow(() -> new IllegalArgumentException(\"correlations are cyclic\"));\n+\n+        for (final Quantifier quantifier : quantifiers) {\n+            quantifier.getCorrelatedTo()\n+                    .stream()\n+                    // Filter out the correlations that are satisfied by this expression if this expression can\n+                    // correlate.\n+                    .filter(correlationIdentifier -> !canCorrelate() || !aliasToQuantifierMap.containsKey(correlationIdentifier))\n+                    .forEach(builder::add);\n+        }\n+\n+        return builder.addAll(getCorrelatedToWithoutChildren())\n+                .build();\n+    }\n+\n+    @Nonnull\n+    Set<CorrelationIdentifier> getCorrelatedToWithoutChildren();\n+\n+    @Nonnull\n+    @Override\n+    default RelationalExpressionWithChildren rebase(final Map<CorrelationIdentifier, CorrelationIdentifier> translationMap) {\n+        final List<Quantifier> rebasedQuantifiers = getQuantifiers().stream()\n+                .map(quantifier -> quantifier.rebase(translationMap))\n+                .collect(Collectors.toList());\n+        return rebaseWithRebasedQuantifiers(translationMap,\n+                rebasedQuantifiers);\n+    }\n+\n+    @Nonnull\n+    RelationalExpressionWithChildren rebaseWithRebasedQuantifiers(final Map<CorrelationIdentifier, CorrelationIdentifier> translationMap,\n+                                                                  final List<Quantifier> rebasedQuantifiers);\n+\n+    @SuppressWarnings(\"UnstableApiUsage\")\n+    @Override\n+    default boolean resultEquals(final Object other, final BiMap<CorrelationIdentifier, CorrelationIdentifier> equivalenceMap) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6eb7142ab316ffbec53e375804118f722f1d2bcc"}, "originalPosition": 79}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgzNTgzMzI0OnYy", "diffSide": "RIGHT", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/expressions/RelationalExpressionWithChildren.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNFQyMTo1NDo0MlrOGxmvmA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNFQyMTo1NDo0MlrOGxmvmA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDY2ODE4NA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                                      final BiMap<CorrelationIdentifier, CorrelationIdentifier> equivalences) {\n          \n          \n            \n                                                      @Nonnull final BiMap<CorrelationIdentifier, CorrelationIdentifier> equivalences) {", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/988#discussion_r454668184", "createdAt": "2020-07-14T21:54:42Z", "author": {"login": "nschiefer"}, "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/expressions/RelationalExpressionWithChildren.java", "diffHunk": "@@ -30,4 +45,87 @@\n @API(API.Status.EXPERIMENTAL)\n public interface RelationalExpressionWithChildren extends RelationalExpression {\n     int getRelationalChildCount();\n+\n+    @Nonnull\n+    @SuppressWarnings(\"squid:S2201\")\n+    default Set<CorrelationIdentifier> getCorrelatedTo() {\n+        final ImmutableSet.Builder<CorrelationIdentifier> builder = ImmutableSet.builder();\n+        final List<? extends Quantifier> quantifiers = getQuantifiers();\n+\n+        final Map<CorrelationIdentifier, ? extends Quantifier> aliasToQuantifierMap =\n+                quantifiers.stream()\n+                        .collect(Collectors.toMap(Quantifier::getAlias, Function.identity()));\n+\n+        final Optional<List<CorrelationIdentifier>> orderedOptional =\n+                TopologicalSort.anyTopologicalOrderPermutation(\n+                        quantifiers.stream()\n+                                .map(Quantifier::getAlias)\n+                                .collect(Collectors.toSet()),\n+                        alias -> Objects.requireNonNull(aliasToQuantifierMap.get(alias)).getCorrelatedTo());\n+\n+        orderedOptional.orElseThrow(() -> new IllegalArgumentException(\"correlations are cyclic\"));\n+\n+        for (final Quantifier quantifier : quantifiers) {\n+            quantifier.getCorrelatedTo()\n+                    .stream()\n+                    // Filter out the correlations that are satisfied by this expression if this expression can\n+                    // correlate.\n+                    .filter(correlationIdentifier -> !canCorrelate() || !aliasToQuantifierMap.containsKey(correlationIdentifier))\n+                    .forEach(builder::add);\n+        }\n+\n+        return builder.addAll(getCorrelatedToWithoutChildren())\n+                .build();\n+    }\n+\n+    @Nonnull\n+    Set<CorrelationIdentifier> getCorrelatedToWithoutChildren();\n+\n+    @Nonnull\n+    @Override\n+    default RelationalExpressionWithChildren rebase(final Map<CorrelationIdentifier, CorrelationIdentifier> translationMap) {\n+        final List<Quantifier> rebasedQuantifiers = getQuantifiers().stream()\n+                .map(quantifier -> quantifier.rebase(translationMap))\n+                .collect(Collectors.toList());\n+        return rebaseWithRebasedQuantifiers(translationMap,\n+                rebasedQuantifiers);\n+    }\n+\n+    @Nonnull\n+    RelationalExpressionWithChildren rebaseWithRebasedQuantifiers(final Map<CorrelationIdentifier, CorrelationIdentifier> translationMap,\n+                                                                  final List<Quantifier> rebasedQuantifiers);\n+\n+    @SuppressWarnings(\"UnstableApiUsage\")\n+    @Override\n+    default boolean resultEquals(final Object other, final BiMap<CorrelationIdentifier, CorrelationIdentifier> equivalenceMap) {\n+        if (this == other) {\n+            return true;\n+        }\n+\n+        if (other == null || getClass() != other.getClass()) {\n+            return false;\n+        }\n+        final RelationalExpression otherExpression = (RelationalExpression)other;\n+\n+        final Optional<BiMap<Quantifier, Quantifier>> quantifierMapOptional =\n+                resultEqualsQuantifiers(ImmutableSet.copyOf(otherExpression.getQuantifiers()),\n+                        equivalenceMap);\n+\n+        if (!quantifierMapOptional.isPresent()) {\n+            return false;\n+        }\n+        final BiMap<Quantifier, Quantifier> quantifierMap = quantifierMapOptional.get();\n+\n+        return equalsWithoutChildren(otherExpression,\n+                Quantifiers.compose(equivalenceMap, Quantifiers.toIdMap(quantifierMap)));\n+    }\n+\n+    @Override\n+    default boolean equalsWithoutChildren(@Nonnull final RelationalExpression other,\n+                                          final BiMap<CorrelationIdentifier, CorrelationIdentifier> equivalences) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6eb7142ab316ffbec53e375804118f722f1d2bcc"}, "originalPosition": 104}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgzNTgzNDUxOnYy", "diffSide": "RIGHT", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/expressions/TypeFilterExpression.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNFQyMTo1NTowOVrOGxmwWw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNFQyMTo1NTowOVrOGxmwWw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDY2ODM3OQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                default TypeFilterExpression rebase(final Map<CorrelationIdentifier, CorrelationIdentifier> translationMap) {\n          \n          \n            \n                default TypeFilterExpression rebase(@Nonnull final Map<CorrelationIdentifier, CorrelationIdentifier> translationMap) {", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/988#discussion_r454668379", "createdAt": "2020-07-14T21:55:09Z", "author": {"login": "nschiefer"}, "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/expressions/TypeFilterExpression.java", "diffHunk": "@@ -33,4 +39,25 @@\n public interface TypeFilterExpression extends RelationalExpressionWithChildren {\n     @Nonnull\n     Collection<String> getRecordTypes();\n+\n+    @Nonnull\n+    @Override\n+    default Set<CorrelationIdentifier> getCorrelatedToWithoutChildren() {\n+        return ImmutableSet.of();\n+    }\n+\n+    @Nonnull\n+    @Override\n+    default TypeFilterExpression rebase(final Map<CorrelationIdentifier, CorrelationIdentifier> translationMap) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6eb7142ab316ffbec53e375804118f722f1d2bcc"}, "originalPosition": 29}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgzNTgzNTMwOnYy", "diffSide": "RIGHT", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/expressions/TypeFilterExpression.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNFQyMTo1NToyMVrOGxmwyA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNFQyMTo1NToyMVrOGxmwyA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDY2ODQ4OA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                default boolean equalsWithoutChildren(@Nonnull RelationalExpression otherExpression, final BiMap<CorrelationIdentifier, CorrelationIdentifier> equivalencesMap) {\n          \n          \n            \n                default boolean equalsWithoutChildren(@Nonnull RelationalExpression otherExpression, @Nonnull final BiMap<CorrelationIdentifier, CorrelationIdentifier> equivalencesMap) {", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/988#discussion_r454668488", "createdAt": "2020-07-14T21:55:21Z", "author": {"login": "nschiefer"}, "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/expressions/TypeFilterExpression.java", "diffHunk": "@@ -33,4 +39,25 @@\n public interface TypeFilterExpression extends RelationalExpressionWithChildren {\n     @Nonnull\n     Collection<String> getRecordTypes();\n+\n+    @Nonnull\n+    @Override\n+    default Set<CorrelationIdentifier> getCorrelatedToWithoutChildren() {\n+        return ImmutableSet.of();\n+    }\n+\n+    @Nonnull\n+    @Override\n+    default TypeFilterExpression rebase(final Map<CorrelationIdentifier, CorrelationIdentifier> translationMap) {\n+        // we know the following is correct, just Java doesn't\n+        return (TypeFilterExpression)RelationalExpressionWithChildren.super.rebase(translationMap);\n+    }\n+\n+    @Override\n+    default boolean equalsWithoutChildren(@Nonnull RelationalExpression otherExpression, final BiMap<CorrelationIdentifier, CorrelationIdentifier> equivalencesMap) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6eb7142ab316ffbec53e375804118f722f1d2bcc"}, "originalPosition": 35}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgzNTgzOTAzOnYy", "diffSide": "RIGHT", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/rules/CombineFilterRule.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNFQyMTo1NjoxOVrOGxmy5g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNFQyMTo1NjoxOVrOGxmy5g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDY2OTAzMA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n             * where lowerPred has been rebased (pulled up through upperQun). upperQun on the right side is still a duplicated\n          \n          \n            \n             * where lowerPred has been rebased (pulled up through upperQun). upperQun' on the right side is still a duplicated", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/988#discussion_r454669030", "createdAt": "2020-07-14T21:56:19Z", "author": {"login": "nschiefer"}, "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/rules/CombineFilterRule.java", "diffHunk": "@@ -41,33 +43,75 @@\n /**\n  * A simple rule that combines two nested filter plans and combines them into a single filter plan with a conjunction\n  * of the two filters.\n+ *\n+ * <pre>\n+ * {@code\n+ *     +----------------------------+                               +-------------------------------------+\n+ *     |                            |                               |                                     |\n+ *     |  LogicalFilterExpression   |                               |  LogicalFilterExpression            |\n+ *     |                 upperPred  |                               |             lowerPred' ^ upperPred  |\n+ *     |                            |                               |                                     |\n+ *     +-------------+--------------+                               +------------------+------------------+\n+ *                   |                                                                 |\n+ *                   |  upperQun                                                       |\n+ *                   |                    +------------------->                        |\n+ *     +-------------+--------------+                                                  |\n+ *     |                            |                                                  |\n+ *     |  LogicalFilterExpression   |                                                  |\n+ *     |                 lowerPred  |                                                  |\n+ *     |                            |                                                  |\n+ *     +-------------+--------------+                                                  |\n+ *                   |                                                                 | upperQun'\n+ *                   |  lowerQun                                                       |\n+ *                   |                                                                 |\n+ *             +-----+-----+                                                           |\n+ *             |           |                                                           |\n+ *             |  anyRef   |   +-------------------------------------------------------+\n+ *             |           |\n+ *             +-----------+\n+ * }\n+ * </pre>\n+ *\n+ * where lowerPred has been rebased (pulled up through upperQun). upperQun on the right side is still a duplicated", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6eb7142ab316ffbec53e375804118f722f1d2bcc"}, "originalPosition": 45}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgzNTg0Mzg1OnYy", "diffSide": "RIGHT", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/rules/FilterWithElementWithComparisonRule.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNFQyMTo1ODowNFrOGxm1xg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNFQyMTo1ODowNFrOGxm1xg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDY2OTc2Ng==", "bodyText": "I think you would agree that this isn't quite right. Let's stamp a TODO on this to indicate that it will change once we've fixed up index matching.", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/988#discussion_r454669766", "createdAt": "2020-07-14T21:58:04Z", "author": {"login": "nschiefer"}, "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/rules/FilterWithElementWithComparisonRule.java", "diffHunk": "@@ -43,31 +43,56 @@\n  * A rewrite rule that turns a logical filter on the results of a full scan (without a sort) into an index scan on\n  * a compatibly ordered index.\n  *\n+ * <pre>\n+ * {@code\n+ *      +----------------------------+                               +-------------------------------------+\n+ *      |                            |                               |                                     |\n+ *      |  LogicalFilterExpression   |                               |  IndexEntrySourceScanExpression     |\n+ *      |          element <>= val   |                               |                        scan ranges  |\n+ *      |                            |                               |                                     |\n+ *      +-------------+--------------+                               +-------------------------------------+\n+ *                    |                    +------------------>\n+ *                    |\n+ *                    |\n+ *     +--------------+----------------+\n+ *     |                               |\n+ *     |  FullUnorderedScanExpression  |\n+ *     |                               |\n+ *     +-------------------------------+\n+ * }\n+ * </pre>\n+ *\n  * Like the {@link com.apple.foundationdb.record.query.plan.RecordQueryPlanner}\n  */\n @API(API.Status.EXPERIMENTAL)\n public class FilterWithElementWithComparisonRule extends PlannerRule<LogicalFilterExpression> {\n-    private static final ExpressionMatcher<ElementPredicate> filterMatcher = TypeMatcher.of(ElementPredicate.class);\n     private static final ExpressionMatcher<FullUnorderedScanExpression> scanMatcher = TypeMatcher.of(FullUnorderedScanExpression.class);\n-    private static final ExpressionMatcher<LogicalFilterExpression> root =\n+    private static final ExpressionMatcher<ElementPredicate> predMatcher = TypeMatcher.of(ElementPredicate.class);\n+    private static final ExpressionMatcher<LogicalFilterExpression> rootMatcher =\n             TypeWithPredicateMatcher.ofPredicate(LogicalFilterExpression.class,\n-                    filterMatcher,\n+                    predMatcher,\n                     QuantifierMatcher.forEach(scanMatcher));\n \n     public FilterWithElementWithComparisonRule() {\n-        super(root);\n+        super(rootMatcher);\n     }\n \n     @Override\n     public void onMatch(@Nonnull PlannerRuleCall call) {\n-        final ElementPredicate elementWithComparison = call.get(filterMatcher);\n-        if (ScanComparisons.getComparisonType(elementWithComparison.getComparison()).equals(ScanComparisons.ComparisonType.NONE)) {\n+        final ElementPredicate pred = call.get(predMatcher);\n+        if (ScanComparisons.getComparisonType(pred.getComparison()).equals(ScanComparisons.ComparisonType.NONE)) {\n             // This comparison cannot be accomplished with a single scan.\n             return;\n         }\n+        final LogicalFilterExpression logicalFilterExpression = call.get(rootMatcher);\n+        if (!logicalFilterExpression.getCorrelatedTo().isEmpty()) {\n+            // LogicalFilterExpressions can express correlations while IndexEntrySourceScanExpressions cannot,\n+            // Do not transform if the root is correlated!\n+            return;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6eb7142ab316ffbec53e375804118f722f1d2bcc"}, "originalPosition": 55}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgzNTg0Njc3OnYy", "diffSide": "RIGHT", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/rules/FindPossibleIndexForAndPredicateRule.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNFQyMTo1OToxOVrOGxm3nQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNFQyMTo1OToxOVrOGxm3nQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDY3MDIzNw==", "bodyText": "Again, I don't think this is quite right in general; we support index selection for in-join correlations, for example. Perhaps this just need a TODO?", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/988#discussion_r454670237", "createdAt": "2020-07-14T21:59:19Z", "author": {"login": "nschiefer"}, "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/rules/FindPossibleIndexForAndPredicateRule.java", "diffHunk": "@@ -67,21 +93,36 @@ public FindPossibleIndexForAndPredicateRule() {\n     @Override\n     public void onMatch(@Nonnull PlannerRuleCall call) {\n         final LogicalFilterExpression filterExpression = call.get(root);\n-        ElementPredicate field = call.getBindings().get(fieldMatcher);\n+        final ElementPredicate field = call.get(elementPredMatcher);\n+        final Quantifier.ForEach qun = call.get(qunMatcher);\n+\n         for (IndexEntrySource indexEntrySource : call.getContext().getIndexEntrySources()) {\n             final ViewExpressionComparisons comparisons = indexEntrySource.getEmptyComparisons();\n             final Optional<ViewExpressionComparisons> matchedKeyComparisons = comparisons.matchWith(field);\n+\n+            if (!field.getCorrelatedTo().isEmpty()) {\n+                continue;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6eb7142ab316ffbec53e375804118f722f1d2bcc"}, "originalPosition": 82}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgzNTg1Mzk1OnYy", "diffSide": "RIGHT", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/rules/FlattenNestedAndPredicateRule.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNFQyMjowMTozMFrOGxm7kQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMFQyMjowODoyNVrOG0g-VQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDY3MTI0OQ==", "bodyText": "This is more for my own understanding, but: why can't we just use innerQuantifier here directly?", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/988#discussion_r454671249", "createdAt": "2020-07-14T22:01:30Z", "author": {"login": "nschiefer"}, "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/rules/FlattenNestedAndPredicateRule.java", "diffHunk": "@@ -79,13 +81,19 @@ public FlattenNestedAndPredicateRule() {\n \n     @Override\n     public void onMatch(@Nonnull PlannerRuleCall call) {\n-        LogicalFilterExpression rootFilter = call.getBindings().get(root);\n-        ExpressionRef<RelationalExpression> innerPlan = call.getBindings().get(inner);\n-        List<QueryPredicate> innerAndChildren = call.getBindings().getAll(andChildrenMatcher);\n-        List<QueryPredicate> otherOuterAndChildren = call.getBindings().getAll(otherInnerComponentsMatcher);\n+        final List<QueryPredicate> innerAndChildren = call.getBindings().getAll(andChildrenMatcher);\n+        final List<QueryPredicate> otherOuterAndChildren = call.getBindings().getAll(otherInnerComponentsMatcher);\n+        final ExpressionRef<RelationalExpression> inner = call.get(innerMatcher);\n+        final Quantifier.ForEach innerQuantifier = call.get(innerQuantifierMatcher);\n+        final LogicalFilterExpression rootFilter = call.get(root);\n         List<QueryPredicate> allConjuncts = new ArrayList<>(innerAndChildren);\n         allConjuncts.addAll(otherOuterAndChildren);\n \n-        call.yield(call.ref(new LogicalFilterExpression(rootFilter.getBaseSource(), new AndPredicate(allConjuncts), innerPlan)));\n+        call.yield(call.ref(new LogicalFilterExpression(\n+                rootFilter.getBaseSource(),\n+                new AndPredicate(allConjuncts),\n+                Quantifier.forEachBuilder()\n+                        .from(innerQuantifier)\n+                        .build(inner))));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6eb7142ab316ffbec53e375804118f722f1d2bcc"}, "originalPosition": 50}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzcxOTM4MQ==", "bodyText": "You can. I think for quantifiers I rather clone them than to reuse them. It's ok to use them as is. Changed this!", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/988#discussion_r457719381", "createdAt": "2020-07-20T22:08:25Z", "author": {"login": "normen662"}, "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/rules/FlattenNestedAndPredicateRule.java", "diffHunk": "@@ -79,13 +81,19 @@ public FlattenNestedAndPredicateRule() {\n \n     @Override\n     public void onMatch(@Nonnull PlannerRuleCall call) {\n-        LogicalFilterExpression rootFilter = call.getBindings().get(root);\n-        ExpressionRef<RelationalExpression> innerPlan = call.getBindings().get(inner);\n-        List<QueryPredicate> innerAndChildren = call.getBindings().getAll(andChildrenMatcher);\n-        List<QueryPredicate> otherOuterAndChildren = call.getBindings().getAll(otherInnerComponentsMatcher);\n+        final List<QueryPredicate> innerAndChildren = call.getBindings().getAll(andChildrenMatcher);\n+        final List<QueryPredicate> otherOuterAndChildren = call.getBindings().getAll(otherInnerComponentsMatcher);\n+        final ExpressionRef<RelationalExpression> inner = call.get(innerMatcher);\n+        final Quantifier.ForEach innerQuantifier = call.get(innerQuantifierMatcher);\n+        final LogicalFilterExpression rootFilter = call.get(root);\n         List<QueryPredicate> allConjuncts = new ArrayList<>(innerAndChildren);\n         allConjuncts.addAll(otherOuterAndChildren);\n \n-        call.yield(call.ref(new LogicalFilterExpression(rootFilter.getBaseSource(), new AndPredicate(allConjuncts), innerPlan)));\n+        call.yield(call.ref(new LogicalFilterExpression(\n+                rootFilter.getBaseSource(),\n+                new AndPredicate(allConjuncts),\n+                Quantifier.forEachBuilder()\n+                        .from(innerQuantifier)\n+                        .build(inner))));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDY3MTI0OQ=="}, "originalCommit": {"oid": "6eb7142ab316ffbec53e375804118f722f1d2bcc"}, "originalPosition": 50}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgzNTk0ODQ5OnYy", "diffSide": "RIGHT", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/rules/SortToIndexRule.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNFQyMjozOTo0OVrOGxn0OQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNFQyMjozOTo0OVrOGxn0OQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDY4NTc1Mw==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                    call.ref( new IndexEntrySourceScanExpression(\n          \n          \n            \n                                    call.ref(new IndexEntrySourceScanExpression(", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/988#discussion_r454685753", "createdAt": "2020-07-14T22:39:49Z", "author": {"login": "nschiefer"}, "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/rules/SortToIndexRule.java", "diffHunk": "@@ -22,55 +22,124 @@\n \n import com.apple.foundationdb.annotation.API;\n import com.apple.foundationdb.record.IndexScanType;\n+import com.apple.foundationdb.record.query.plan.temp.CorrelationIdentifier;\n+import com.apple.foundationdb.record.query.plan.temp.ExpressionRef;\n import com.apple.foundationdb.record.query.plan.temp.IndexEntrySource;\n import com.apple.foundationdb.record.query.plan.temp.PlannerRule;\n import com.apple.foundationdb.record.query.plan.temp.PlannerRuleCall;\n+import com.apple.foundationdb.record.query.plan.temp.Quantifier;\n+import com.apple.foundationdb.record.query.plan.temp.Quantifiers;\n import com.apple.foundationdb.record.query.plan.temp.expressions.FullUnorderedScanExpression;\n import com.apple.foundationdb.record.query.plan.temp.expressions.IndexEntrySourceScanExpression;\n import com.apple.foundationdb.record.query.plan.temp.expressions.LogicalSortExpression;\n import com.apple.foundationdb.record.query.plan.temp.RelationalExpression;\n import com.apple.foundationdb.record.query.plan.temp.matchers.ExpressionMatcher;\n import com.apple.foundationdb.record.query.plan.temp.matchers.QuantifierMatcher;\n import com.apple.foundationdb.record.query.plan.temp.matchers.TypeMatcher;\n+import com.apple.foundationdb.record.query.plan.temp.view.Element;\n import com.apple.foundationdb.record.query.plan.temp.view.ViewExpressionComparisons;\n+import com.google.common.collect.BiMap;\n \n import javax.annotation.Nonnull;\n+import java.util.List;\n import java.util.Optional;\n+import java.util.stream.Collectors;\n \n /**\n  * A rule for implementing a {@link LogicalSortExpression} as a scan of any appropriately-ordered index.\n  * The rule's logic mirrors {@link FilterWithElementWithComparisonRule}, but applied to sorts rather than filters.\n+ *\n+ * <pre>\n+ * {@code\n+ *       +-----------------------------+                 +---------------------------+\n+ *       |                             |                 |                           |\n+ *       |  LogicalSortExpression      |                 |  LogicalSortExpression    |\n+ *       |            prefix, suffix   |                 |                  suffix   |\n+ *       |                             |                 |                           |\n+ *       +-------------+---------------+                 +-------------+-------------+\n+ *                     |                     +------>                  |\n+ *                     | qun                                           | newQun\n+ *                     |                                               |\n+ *     +---------------+------------------+            +---------------+------------------+\n+ *     |                                  |            |                                  |\n+ *     |  FullUnorderedScanExpression     |            |  IndexEntrySourceScanExpression  |\n+ *     |                                  |            |                     order|prefix |\n+ *     +----------------------------------+            |                                  |\n+ *                                                     +----------------------------------+\n+ * }\n+ * </pre>\n+ *\n+ * or if there is no suffix:\n+ *\n+ * <pre>\n+ * {@code\n+ *       +-----------------------------+               +----------------------------------+\n+ *       |                             |               |                                  |\n+ *       |    LogicalSortExpression    |     +------>  |  IndexEntrySourceScanExpression  |\n+ *       |                     prefix  |               |                           orders |\n+ *       |                             |               |                                  |\n+ *       +-------------+---------------+               +----------------------------------+\n+ *                     |\n+ *                     | qun\n+ *                     |\n+ *     +---------------+------------------+\n+ *     |                                  |\n+ *     |  FullUnorderedScanExpression     |\n+ *     |                                  |\n+ *     +----------------------------------+\n+ * }\n+ * </pre>\n  */\n @API(API.Status.EXPERIMENTAL)\n public class SortToIndexRule extends PlannerRule<LogicalSortExpression> {\n     private static final ExpressionMatcher<FullUnorderedScanExpression> innerMatcher = TypeMatcher.of(FullUnorderedScanExpression.class);\n+    private static final QuantifierMatcher<Quantifier.ForEach> qunMatcher = QuantifierMatcher.forEach(innerMatcher);\n     private static final ExpressionMatcher<LogicalSortExpression> root =\n-            TypeMatcher.of(LogicalSortExpression.class, QuantifierMatcher.forEach(innerMatcher));\n+            TypeMatcher.of(LogicalSortExpression.class, qunMatcher);\n \n     public SortToIndexRule() {\n         super(root);\n     }\n \n     @Override\n     public void onMatch(@Nonnull PlannerRuleCall call) {\n-        final LogicalSortExpression logicalSort = call.get(root);\n+        final LogicalSortExpression sortExpression = call.get(root);\n+        final Quantifier.ForEach qun = call.get(qunMatcher);\n         final boolean reverse = call.get(root).isReverse();\n \n         for (IndexEntrySource indexEntrySource : call.getContext().getIndexEntrySources()) {\n-            final ViewExpressionComparisons sortExpression = indexEntrySource.getEmptyComparisons();\n-            final Optional<ViewExpressionComparisons> matchedViewExpression = sortExpression.matchWithSort(logicalSort.getSortPrefix());\n+            final ViewExpressionComparisons comparisons = indexEntrySource.getEmptyComparisons();\n+            final Optional<ViewExpressionComparisons> matchedViewExpression = comparisons.matchWithSort(sortExpression.getSortPrefix());\n             if (matchedViewExpression.isPresent()) {\n-                RelationalExpression indexScan = new IndexEntrySourceScanExpression(\n-                        indexEntrySource, IndexScanType.BY_VALUE, matchedViewExpression.get(), reverse);\n-                if (logicalSort.getSortSuffix().isEmpty()) {\n-                    call.yield(call.ref(indexScan));\n+                final ExpressionRef<? extends RelationalExpression> indexScanRef =\n+                        call.ref( new IndexEntrySourceScanExpression(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6eb7142ab316ffbec53e375804118f722f1d2bcc"}, "originalPosition": 102}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgzNTk1OTEyOnYy", "diffSide": "RIGHT", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/predicates/AndOrPredicate.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNFQyMjo0NDoxN1rOGxn6eA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNFQyMjo0NDoxN1rOGxn6eA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDY4NzM1Mg==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public AndOrPredicate rebase(final Map<CorrelationIdentifier, CorrelationIdentifier> translationMap) {\n          \n          \n            \n                public AndOrPredicate rebase(@Nonnull final Map<CorrelationIdentifier, CorrelationIdentifier> translationMap) {", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/988#discussion_r454687352", "createdAt": "2020-07-14T22:44:17Z", "author": {"login": "nschiefer"}, "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/predicates/AndOrPredicate.java", "diffHunk": "@@ -59,4 +68,57 @@ protected AndOrPredicate(@Nonnull List<QueryPredicate> operands) {\n                 .map(outerBindings::mergedWith));\n     }\n \n+    @Nonnull\n+    @Override\n+    public Set<CorrelationIdentifier> getCorrelatedTo() {\n+        final ImmutableSet.Builder<CorrelationIdentifier> builder = ImmutableSet.builder();\n+        for (final QueryPredicate child : getChildren()) {\n+            builder.addAll(child.getCorrelatedTo());\n+        }\n+        return builder.build();\n+    }\n+\n+    @Nonnull\n+    @Override\n+    public AndOrPredicate rebase(final Map<CorrelationIdentifier, CorrelationIdentifier> translationMap) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6eb7142ab316ffbec53e375804118f722f1d2bcc"}, "originalPosition": 53}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgzNTk1OTc4OnYy", "diffSide": "RIGHT", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/predicates/AndOrPredicate.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNFQyMjo0NDozNVrOGxn64A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNFQyMjo0NDozNVrOGxn64A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDY4NzQ1Ng==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public abstract AndOrPredicate rebaseWithRebasedChildren(final Map<CorrelationIdentifier, CorrelationIdentifier> translationMap,\n          \n          \n            \n                                                                         final List<QueryPredicate> rebasedChildren);\n          \n          \n            \n                public abstract AndOrPredicate rebaseWithRebasedChildren(@Nonnull final Map<CorrelationIdentifier, CorrelationIdentifier> translationMap,\n          \n          \n            \n                                                                         @Nonnull final List<QueryPredicate> rebasedChildren);", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/988#discussion_r454687456", "createdAt": "2020-07-14T22:44:35Z", "author": {"login": "nschiefer"}, "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/predicates/AndOrPredicate.java", "diffHunk": "@@ -59,4 +68,57 @@ protected AndOrPredicate(@Nonnull List<QueryPredicate> operands) {\n                 .map(outerBindings::mergedWith));\n     }\n \n+    @Nonnull\n+    @Override\n+    public Set<CorrelationIdentifier> getCorrelatedTo() {\n+        final ImmutableSet.Builder<CorrelationIdentifier> builder = ImmutableSet.builder();\n+        for (final QueryPredicate child : getChildren()) {\n+            builder.addAll(child.getCorrelatedTo());\n+        }\n+        return builder.build();\n+    }\n+\n+    @Nonnull\n+    @Override\n+    public AndOrPredicate rebase(final Map<CorrelationIdentifier, CorrelationIdentifier> translationMap) {\n+        return rebaseWithRebasedChildren(translationMap,\n+                getChildren().stream()\n+                        .map(child -> child.rebase(translationMap))\n+                        .collect(Collectors.toList()));\n+    }\n+\n+    public abstract AndOrPredicate rebaseWithRebasedChildren(final Map<CorrelationIdentifier, CorrelationIdentifier> translationMap,\n+                                                             final List<QueryPredicate> rebasedChildren);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6eb7142ab316ffbec53e375804118f722f1d2bcc"}, "originalPosition": 61}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgzNTk2MDM0OnYy", "diffSide": "RIGHT", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/predicates/AndOrPredicate.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNFQyMjo0NDo1M1rOGxn7MA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNFQyMjo0NDo1M1rOGxn7MA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDY4NzUzNg==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public boolean resultEquals(final Object other,\n          \n          \n            \n                                            final BiMap<CorrelationIdentifier, CorrelationIdentifier> equivalenceMap) {\n          \n          \n            \n                public boolean resultEquals(@Nullable final Object other,\n          \n          \n            \n                                            @Nonnull final BiMap<CorrelationIdentifier, CorrelationIdentifier> equivalenceMap) {", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/988#discussion_r454687536", "createdAt": "2020-07-14T22:44:53Z", "author": {"login": "nschiefer"}, "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/predicates/AndOrPredicate.java", "diffHunk": "@@ -59,4 +68,57 @@ protected AndOrPredicate(@Nonnull List<QueryPredicate> operands) {\n                 .map(outerBindings::mergedWith));\n     }\n \n+    @Nonnull\n+    @Override\n+    public Set<CorrelationIdentifier> getCorrelatedTo() {\n+        final ImmutableSet.Builder<CorrelationIdentifier> builder = ImmutableSet.builder();\n+        for (final QueryPredicate child : getChildren()) {\n+            builder.addAll(child.getCorrelatedTo());\n+        }\n+        return builder.build();\n+    }\n+\n+    @Nonnull\n+    @Override\n+    public AndOrPredicate rebase(final Map<CorrelationIdentifier, CorrelationIdentifier> translationMap) {\n+        return rebaseWithRebasedChildren(translationMap,\n+                getChildren().stream()\n+                        .map(child -> child.rebase(translationMap))\n+                        .collect(Collectors.toList()));\n+    }\n+\n+    public abstract AndOrPredicate rebaseWithRebasedChildren(final Map<CorrelationIdentifier, CorrelationIdentifier> translationMap,\n+                                                             final List<QueryPredicate> rebasedChildren);\n+\n+    @Override\n+    public boolean equals(final Object other) {\n+        return resultEquals(other, ImmutableBiMap.of());\n+    }\n+\n+    @SuppressWarnings(\"UnstableApiUsage\")\n+    @Override\n+    public boolean resultEquals(final Object other,\n+                                final BiMap<CorrelationIdentifier, CorrelationIdentifier> equivalenceMap) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6eb7142ab316ffbec53e375804118f722f1d2bcc"}, "originalPosition": 71}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgzNTk2MTIzOnYy", "diffSide": "RIGHT", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/predicates/AndOrPredicate.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNFQyMjo0NToxMFrOGxn7sA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNFQyMjo0NToxMFrOGxn7sA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDY4NzY2NA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                protected boolean equalsWithoutChildren(final Object other,\n          \n          \n            \n                                                        final Map<CorrelationIdentifier, CorrelationIdentifier> equivalences) {\n          \n          \n            \n                protected boolean equalsWithoutChildren(@Nullable final Object other,\n          \n          \n            \n                                                        @Nonnull final Map<CorrelationIdentifier, CorrelationIdentifier> equivalences) {", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/988#discussion_r454687664", "createdAt": "2020-07-14T22:45:10Z", "author": {"login": "nschiefer"}, "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/predicates/AndOrPredicate.java", "diffHunk": "@@ -59,4 +68,57 @@ protected AndOrPredicate(@Nonnull List<QueryPredicate> operands) {\n                 .map(outerBindings::mergedWith));\n     }\n \n+    @Nonnull\n+    @Override\n+    public Set<CorrelationIdentifier> getCorrelatedTo() {\n+        final ImmutableSet.Builder<CorrelationIdentifier> builder = ImmutableSet.builder();\n+        for (final QueryPredicate child : getChildren()) {\n+            builder.addAll(child.getCorrelatedTo());\n+        }\n+        return builder.build();\n+    }\n+\n+    @Nonnull\n+    @Override\n+    public AndOrPredicate rebase(final Map<CorrelationIdentifier, CorrelationIdentifier> translationMap) {\n+        return rebaseWithRebasedChildren(translationMap,\n+                getChildren().stream()\n+                        .map(child -> child.rebase(translationMap))\n+                        .collect(Collectors.toList()));\n+    }\n+\n+    public abstract AndOrPredicate rebaseWithRebasedChildren(final Map<CorrelationIdentifier, CorrelationIdentifier> translationMap,\n+                                                             final List<QueryPredicate> rebasedChildren);\n+\n+    @Override\n+    public boolean equals(final Object other) {\n+        return resultEquals(other, ImmutableBiMap.of());\n+    }\n+\n+    @SuppressWarnings(\"UnstableApiUsage\")\n+    @Override\n+    public boolean resultEquals(final Object other,\n+                                final BiMap<CorrelationIdentifier, CorrelationIdentifier> equivalenceMap) {\n+        if (!equalsWithoutChildren(other, equivalenceMap)) {\n+            return false;\n+        }\n+\n+        final AndOrPredicate otherAndOrPred = (AndOrPredicate)other;\n+        final List<QueryPredicate> preds = getChildren();\n+        final List<QueryPredicate> otherPreds = otherAndOrPred.getChildren();\n+        if (preds.size() != otherPreds.size()) {\n+            return false;\n+        }\n+        return Streams\n+                .zip(preds.stream(), otherPreds.stream(), Pair::of)\n+                .allMatch(pair -> pair.getLeft().resultEquals(pair.getRight(), equivalenceMap));\n+    }\n+\n+    protected boolean equalsWithoutChildren(final Object other,\n+                                            final Map<CorrelationIdentifier, CorrelationIdentifier> equivalences) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6eb7142ab316ffbec53e375804118f722f1d2bcc"}, "originalPosition": 88}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgzNTk2MzA1OnYy", "diffSide": "RIGHT", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/predicates/AndPredicate.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNFQyMjo0NTo1MFrOGxn8rg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNFQyMjo0NTo1MFrOGxn8rg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDY4NzkxOA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public AndPredicate rebaseWithRebasedChildren(final Map<CorrelationIdentifier, CorrelationIdentifier> translationMap, final List<QueryPredicate> rebasedChildren) {\n          \n          \n            \n                public AndPredicate rebaseWithRebasedChildren(@Nonnull final Map<CorrelationIdentifier, CorrelationIdentifier> translationMap, @Nonnull final List<QueryPredicate> rebasedChildren) {", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/988#discussion_r454687918", "createdAt": "2020-07-14T22:45:50Z", "author": {"login": "nschiefer"}, "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/predicates/AndPredicate.java", "diffHunk": "@@ -88,4 +78,9 @@ public int hashCode() {\n     public int planHash() {\n         return PlanHashable.planHash(getChildren());\n     }\n+\n+    @Override\n+    public AndPredicate rebaseWithRebasedChildren(final Map<CorrelationIdentifier, CorrelationIdentifier> translationMap, final List<QueryPredicate> rebasedChildren) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6eb7142ab316ffbec53e375804118f722f1d2bcc"}, "originalPosition": 40}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgzNTk2NDI2OnYy", "diffSide": "RIGHT", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/predicates/ElementPredicate.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNFQyMjo0NjoxOVrOGxn9ZA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNFQyMjo0NjoxOVrOGxn9ZA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDY4ODEwMA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public boolean resultEquals(final Object other, final BiMap<CorrelationIdentifier, CorrelationIdentifier> equivalenceMap) {\n          \n          \n            \n                public boolean resultEquals(@Nullable final Object other, @Nonnull final BiMap<CorrelationIdentifier, CorrelationIdentifier> equivalenceMap) {", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/988#discussion_r454688100", "createdAt": "2020-07-14T22:46:19Z", "author": {"login": "nschiefer"}, "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/predicates/ElementPredicate.java", "diffHunk": "@@ -86,15 +92,20 @@ public String toString() {\n     }\n \n     @Override\n-    public boolean equals(Object o) {\n-        if (this == o) {\n+    public boolean equals(final Object other) {\n+        return resultEquals(other, ImmutableBiMap.of());\n+    }\n+\n+    @Override\n+    public boolean resultEquals(final Object other, final BiMap<CorrelationIdentifier, CorrelationIdentifier> equivalenceMap) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6eb7142ab316ffbec53e375804118f722f1d2bcc"}, "originalPosition": 33}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgzNTk2NDc4OnYy", "diffSide": "RIGHT", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/predicates/ElementPredicate.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNFQyMjo0NjozMlrOGxn9qA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNFQyMjo0NjozMlrOGxn9qA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDY4ODE2OA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public ElementPredicate rebase(final Map<CorrelationIdentifier, CorrelationIdentifier> translationMap) {\n          \n          \n            \n                public ElementPredicate rebase(@Nonnull final Map<CorrelationIdentifier, CorrelationIdentifier> translationMap) {", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/988#discussion_r454688168", "createdAt": "2020-07-14T22:46:32Z", "author": {"login": "nschiefer"}, "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/predicates/ElementPredicate.java", "diffHunk": "@@ -107,4 +118,18 @@ public int hashCode() {\n     public int planHash() {\n         return element.planHash() + comparison.planHash();\n     }\n+\n+    @Nonnull\n+    @Override\n+    public Set<CorrelationIdentifier> getCorrelatedTo() {\n+        // TODO needs to return a correlation identifier synthesized from the element\n+        return ImmutableSet.of();\n+    }\n+\n+    @Nonnull\n+    @Override\n+    public ElementPredicate rebase(final Map<CorrelationIdentifier, CorrelationIdentifier> translationMap) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6eb7142ab316ffbec53e375804118f722f1d2bcc"}, "originalPosition": 62}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgzNTk2NTkzOnYy", "diffSide": "RIGHT", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/predicates/NotPredicate.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNFQyMjo0Njo1OFrOGxn-VA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNFQyMjo0Njo1OFrOGxn-VA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDY4ODM0MA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public boolean resultEquals(final Object other, final BiMap<CorrelationIdentifier, CorrelationIdentifier> equivalenceMap) {\n          \n          \n            \n                public boolean resultEquals(@Nullable final Object other, @Nonnull final BiMap<CorrelationIdentifier, CorrelationIdentifier> equivalenceMap) {", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/988#discussion_r454688340", "createdAt": "2020-07-14T22:46:58Z", "author": {"login": "nschiefer"}, "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/predicates/NotPredicate.java", "diffHunk": "@@ -83,15 +88,20 @@ public String toString() {\n     }\n \n     @Override\n-    public boolean equals(Object o) {\n-        if (this == o) {\n+    public boolean equals(final Object other) {\n+        return resultEquals(other, ImmutableBiMap.of());\n+    }\n+\n+    @Override\n+    public boolean resultEquals(final Object other, final BiMap<CorrelationIdentifier, CorrelationIdentifier> equivalenceMap) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6eb7142ab316ffbec53e375804118f722f1d2bcc"}, "originalPosition": 32}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgzNTk2NjQzOnYy", "diffSide": "RIGHT", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/predicates/NotPredicate.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNFQyMjo0NzoxNVrOGxn-pQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNFQyMjo0NzoxNVrOGxn-pQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDY4ODQyMQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public NotPredicate rebase(final Map<CorrelationIdentifier, CorrelationIdentifier> translationMap) {\n          \n          \n            \n                public NotPredicate rebase(@Nonnull final Map<CorrelationIdentifier, CorrelationIdentifier> translationMap) {", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/988#discussion_r454688421", "createdAt": "2020-07-14T22:47:15Z", "author": {"login": "nschiefer"}, "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/predicates/NotPredicate.java", "diffHunk": "@@ -103,4 +113,16 @@ public int hashCode() {\n     public int planHash() {\n         return getChild().planHash() + 1;\n     }\n+\n+    @Nonnull\n+    @Override\n+    public Set<CorrelationIdentifier> getCorrelatedTo() {\n+        return getChild().getCorrelatedTo();\n+    }\n+\n+    @Nonnull\n+    @Override\n+    public NotPredicate rebase(final Map<CorrelationIdentifier, CorrelationIdentifier> translationMap) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6eb7142ab316ffbec53e375804118f722f1d2bcc"}, "originalPosition": 60}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgzNTk2ODA3OnYy", "diffSide": "RIGHT", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/predicates/OrPredicate.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNFQyMjo0Nzo1N1rOGxn_lw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNFQyMjo0Nzo1N1rOGxn_lw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDY4ODY2Mw==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public OrPredicate rebaseWithRebasedChildren(final Map<CorrelationIdentifier, CorrelationIdentifier> translationMap, final List<QueryPredicate> rebasedChildren) {\n          \n          \n            \n                public OrPredicate rebaseWithRebasedChildren(@Nonnull final Map<CorrelationIdentifier, CorrelationIdentifier> translationMap, @Nonnull final List<QueryPredicate> rebasedChildren) {", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/988#discussion_r454688663", "createdAt": "2020-07-14T22:47:57Z", "author": {"login": "nschiefer"}, "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/predicates/OrPredicate.java", "diffHunk": "@@ -90,4 +80,9 @@ public int hashCode() {\n     public int planHash() {\n         return PlanHashable.planHash(getChildren());\n     }\n+\n+    @Override\n+    public OrPredicate rebaseWithRebasedChildren(final Map<CorrelationIdentifier, CorrelationIdentifier> translationMap, final List<QueryPredicate> rebasedChildren) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6eb7142ab316ffbec53e375804118f722f1d2bcc"}, "originalPosition": 40}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgzNTk3MjExOnYy", "diffSide": "RIGHT", "path": "fdb-record-layer-core/src/test/java/com/apple/foundationdb/record/provider/foundationdb/indexes/TextIndexTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNFQyMjo0OTozOVrOGxoCDA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMFQyMjoxMToxOFrOG0hDHg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDY4OTI5Mg==", "bodyText": "What's up with the refactoring here? Is it actually related to this change, or related to something else?", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/988#discussion_r454689292", "createdAt": "2020-07-14T22:49:39Z", "author": {"login": "nschiefer"}, "path": "fdb-record-layer-core/src/test/java/com/apple/foundationdb/record/provider/foundationdb/indexes/TextIndexTest.java", "diffHunk": "@@ -1360,28 +1360,32 @@ public void invalidScans() throws Exception {\n     }\n \n     @Nonnull\n-    private List<Long> querySimpleDocumentsWithIndex(@Nonnull QueryComponent filter, @Nonnull String indexName, int planHash,\n+    private List<Long> querySimpleDocumentsWithIndex(@Nonnull QueryComponent filter, @Nonnull String indexName, int planHash, boolean isCoveringIndexExpected,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6eb7142ab316ffbec53e375804118f722f1d2bcc"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzcyMDYwNg==", "bodyText": "I think what's happening here is (IIRC), is the I saw plan regressions due to my interim changes without actually bombing the test. I changed this to make sure that we get the plan we intend to get.", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/988#discussion_r457720606", "createdAt": "2020-07-20T22:11:18Z", "author": {"login": "normen662"}, "path": "fdb-record-layer-core/src/test/java/com/apple/foundationdb/record/provider/foundationdb/indexes/TextIndexTest.java", "diffHunk": "@@ -1360,28 +1360,32 @@ public void invalidScans() throws Exception {\n     }\n \n     @Nonnull\n-    private List<Long> querySimpleDocumentsWithIndex(@Nonnull QueryComponent filter, @Nonnull String indexName, int planHash,\n+    private List<Long> querySimpleDocumentsWithIndex(@Nonnull QueryComponent filter, @Nonnull String indexName, int planHash, boolean isCoveringIndexExpected,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDY4OTI5Mg=="}, "originalCommit": {"oid": "6eb7142ab316ffbec53e375804118f722f1d2bcc"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgzNTk4NzM4OnYy", "diffSide": "RIGHT", "path": "fdb-record-layer-spatial/src/main/java/com/apple/foundationdb/record/spatial/geophile/GeophilePointWithinDistanceQueryPlan.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNFQyMjo1NTo1OFrOGxoLEg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNFQyMjo1NTo1OFrOGxoLEg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDY5MTYwMg==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                                     final BiMap<CorrelationIdentifier, CorrelationIdentifier> equivalencesMap) {\n          \n          \n            \n                                                     @Nonnull final BiMap<CorrelationIdentifier, CorrelationIdentifier> equivalencesMap) {", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/988#discussion_r454691602", "createdAt": "2020-07-14T22:55:58Z", "author": {"login": "nschiefer"}, "path": "fdb-record-layer-spatial/src/main/java/com/apple/foundationdb/record/spatial/geophile/GeophilePointWithinDistanceQueryPlan.java", "diffHunk": "@@ -122,17 +126,13 @@ public int planHash() {\n     }\n \n     @Override\n-    public boolean equals(Object o) {\n-        if (this == o) {\n-            return true;\n-        }\n-        if (o == null || getClass() != o.getClass()) {\n-            return false;\n-        }\n-        if (!super.equals(o)) {\n+    public boolean equalsWithoutChildren(@Nonnull final RelationalExpression otherExpression,\n+                                         final BiMap<CorrelationIdentifier, CorrelationIdentifier> equivalencesMap) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6eb7142ab316ffbec53e375804118f722f1d2bcc"}, "originalPosition": 38}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgzNTk4ODM3OnYy", "diffSide": "RIGHT", "path": "fdb-record-layer-spatial/src/main/java/com/apple/foundationdb/record/spatial/geophile/GeophileSpatialObjectQueryPlan.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNFQyMjo1NjoyNVrOGxoLqw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNFQyMjo1NjoyNVrOGxoLqw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDY5MTc1NQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public GeophileSpatialObjectQueryPlan rebase(final Map<CorrelationIdentifier, CorrelationIdentifier> translationMap) {\n          \n          \n            \n                public GeophileSpatialObjectQueryPlan rebase(@Nonnull final Map<CorrelationIdentifier, CorrelationIdentifier> translationMap) {", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/988#discussion_r454691755", "createdAt": "2020-07-14T22:56:25Z", "author": {"login": "nschiefer"}, "path": "fdb-record-layer-spatial/src/main/java/com/apple/foundationdb/record/spatial/geophile/GeophileSpatialObjectQueryPlan.java", "diffHunk": "@@ -183,24 +188,45 @@ public int getComplexity() {\n         return Collections.emptyList();\n     }\n \n+    @Nonnull\n     @Override\n-    public boolean equalsWithoutChildren(@Nonnull RelationalExpression otherExpression) {\n-        return equals(otherExpression);\n+    public Set<CorrelationIdentifier> getCorrelatedTo() {\n+        return ImmutableSet.of();\n     }\n \n+    @Nonnull\n     @Override\n-    public boolean equals(Object o) {\n-        if (this == o) {\n+    public GeophileSpatialObjectQueryPlan rebase(final Map<CorrelationIdentifier, CorrelationIdentifier> translationMap) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6eb7142ab316ffbec53e375804118f722f1d2bcc"}, "originalPosition": 41}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgzNTk4OTAzOnYy", "diffSide": "RIGHT", "path": "fdb-record-layer-spatial/src/main/java/com/apple/foundationdb/record/spatial/geophile/GeophileSpatialObjectQueryPlan.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNFQyMjo1Njo0NFrOGxoMFg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNFQyMjo1Njo0NFrOGxoMFg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDY5MTg2Mg==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public boolean equalsWithoutChildren(@Nonnull RelationalExpression otherExpression, final BiMap<CorrelationIdentifier, CorrelationIdentifier> equivalencesMap) {\n          \n          \n            \n                public boolean equalsWithoutChildren(@Nonnull RelationalExpression otherExpression, @Nonnull final BiMap<CorrelationIdentifier, CorrelationIdentifier> equivalencesMap) {", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/988#discussion_r454691862", "createdAt": "2020-07-14T22:56:44Z", "author": {"login": "nschiefer"}, "path": "fdb-record-layer-spatial/src/main/java/com/apple/foundationdb/record/spatial/geophile/GeophileSpatialObjectQueryPlan.java", "diffHunk": "@@ -183,24 +188,45 @@ public int getComplexity() {\n         return Collections.emptyList();\n     }\n \n+    @Nonnull\n     @Override\n-    public boolean equalsWithoutChildren(@Nonnull RelationalExpression otherExpression) {\n-        return equals(otherExpression);\n+    public Set<CorrelationIdentifier> getCorrelatedTo() {\n+        return ImmutableSet.of();\n     }\n \n+    @Nonnull\n     @Override\n-    public boolean equals(Object o) {\n-        if (this == o) {\n+    public GeophileSpatialObjectQueryPlan rebase(final Map<CorrelationIdentifier, CorrelationIdentifier> translationMap) {\n+        return this;\n+    }\n+\n+    @Override\n+    public boolean equalsWithoutChildren(@Nonnull RelationalExpression otherExpression, final BiMap<CorrelationIdentifier, CorrelationIdentifier> equivalencesMap) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6eb7142ab316ffbec53e375804118f722f1d2bcc"}, "originalPosition": 46}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgzNTk4OTgxOnYy", "diffSide": "RIGHT", "path": "fdb-record-layer-spatial/src/main/java/com/apple/foundationdb/record/spatial/geophile/GeophileSpatialObjectQueryPlan.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNFQyMjo1NzowOVrOGxoMlw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNFQyMjo1NzowOVrOGxoMlw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDY5MTk5MQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public boolean resultEquals(final Object other, final BiMap<CorrelationIdentifier, CorrelationIdentifier> equivalenceMap) {\n          \n          \n            \n                public boolean resultEquals(@Nullable final Object other, @Nonnull final BiMap<CorrelationIdentifier, CorrelationIdentifier> equivalenceMap) {", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/988#discussion_r454691991", "createdAt": "2020-07-14T22:57:09Z", "author": {"login": "nschiefer"}, "path": "fdb-record-layer-spatial/src/main/java/com/apple/foundationdb/record/spatial/geophile/GeophileSpatialObjectQueryPlan.java", "diffHunk": "@@ -183,24 +188,45 @@ public int getComplexity() {\n         return Collections.emptyList();\n     }\n \n+    @Nonnull\n     @Override\n-    public boolean equalsWithoutChildren(@Nonnull RelationalExpression otherExpression) {\n-        return equals(otherExpression);\n+    public Set<CorrelationIdentifier> getCorrelatedTo() {\n+        return ImmutableSet.of();\n     }\n \n+    @Nonnull\n     @Override\n-    public boolean equals(Object o) {\n-        if (this == o) {\n+    public GeophileSpatialObjectQueryPlan rebase(final Map<CorrelationIdentifier, CorrelationIdentifier> translationMap) {\n+        return this;\n+    }\n+\n+    @Override\n+    public boolean equalsWithoutChildren(@Nonnull RelationalExpression otherExpression, final BiMap<CorrelationIdentifier, CorrelationIdentifier> equivalencesMap) {\n+        if (this == otherExpression) {\n             return true;\n         }\n-        if (o == null || getClass() != o.getClass()) {\n+        if (getClass() != otherExpression.getClass()) {\n             return false;\n         }\n-        GeophileSpatialObjectQueryPlan that = (GeophileSpatialObjectQueryPlan)o;\n+        GeophileSpatialObjectQueryPlan that = (GeophileSpatialObjectQueryPlan)otherExpression;\n         return indexName.equals(that.indexName) &&\n                prefixComparisons.equals(that.prefixComparisons);\n     }\n \n+    @SuppressWarnings(\"EqualsWhichDoesntCheckParameterClass\")\n+    @Override\n+    public boolean equals(final Object other) {\n+        return resultEquals(other, ImmutableBiMap.of());\n+    }\n+\n+    @Override\n+    public boolean resultEquals(final Object other, final BiMap<CorrelationIdentifier, CorrelationIdentifier> equivalenceMap) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6eb7142ab316ffbec53e375804118f722f1d2bcc"}, "originalPosition": 67}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkwMTg2ODAwOnYy", "diffSide": "RIGHT", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/AliasMap.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wM1QyMDoxNzoxNlrOG7HVuw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wM1QyMDoxNzoxNlrOG7HVuw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDYzOTQxOQ==", "bodyText": "I think you accidentally a word here.\nPerhaps:\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n             * what alias (of a quantifier) should be considered to what other alias (of another quantifier). A quantifier\n          \n          \n            \n             * what alias (of a quantifier) should be considered equivalent to what other alias (of another quantifier). A quantifier", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/988#discussion_r464639419", "createdAt": "2020-08-03T20:17:16Z", "author": {"login": "nschiefer"}, "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/AliasMap.java", "diffHunk": "@@ -0,0 +1,369 @@\n+/*\n+ * AliasMap.java\n+ *\n+ * This source file is part of the FoundationDB open source project\n+ *\n+ * Copyright 2015-2020 Apple Inc. and the FoundationDB project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.apple.foundationdb.record.query.plan.temp;\n+\n+import com.google.common.base.Verify;\n+import com.google.common.collect.AbstractIterator;\n+import com.google.common.collect.BiMap;\n+import com.google.common.collect.HashBiMap;\n+import com.google.common.collect.ImmutableBiMap;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.Streams;\n+import org.apache.commons.lang3.tuple.Pair;\n+\n+import javax.annotation.Nonnull;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.function.Function;\n+\n+/**\n+ * This class encapsulates mappings between {@link CorrelationIdentifier}s and helpers to create and maintain\n+ * these mappings.\n+ *\n+ * While various operations or in general algorithms traverse the query graph(s) it is important to keep track of\n+ * what alias (of a quantifier) should be considered to what other alias (of another quantifier). A quantifier", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b64d4eb60de5c3a4be0b4dc0f779ff2f15e47355"}, "originalPosition": 44}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkwMTg2OTAyOnYy", "diffSide": "RIGHT", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/AliasMap.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wM1QyMDoxNzozOVrOG7HWWQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wM1QyMDoxNzozOVrOG7HWWQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDYzOTU3Nw==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n             * to objects which is desirable while the graph is mutated through transformations. At various points during\n          \n          \n            \n             * to objects, which is desirable as the graph is mutated through transformations. At various points during", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/988#discussion_r464639577", "createdAt": "2020-08-03T20:17:39Z", "author": {"login": "nschiefer"}, "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/AliasMap.java", "diffHunk": "@@ -0,0 +1,369 @@\n+/*\n+ * AliasMap.java\n+ *\n+ * This source file is part of the FoundationDB open source project\n+ *\n+ * Copyright 2015-2020 Apple Inc. and the FoundationDB project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.apple.foundationdb.record.query.plan.temp;\n+\n+import com.google.common.base.Verify;\n+import com.google.common.collect.AbstractIterator;\n+import com.google.common.collect.BiMap;\n+import com.google.common.collect.HashBiMap;\n+import com.google.common.collect.ImmutableBiMap;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.Streams;\n+import org.apache.commons.lang3.tuple.Pair;\n+\n+import javax.annotation.Nonnull;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.function.Function;\n+\n+/**\n+ * This class encapsulates mappings between {@link CorrelationIdentifier}s and helpers to create and maintain\n+ * these mappings.\n+ *\n+ * While various operations or in general algorithms traverse the query graph(s) it is important to keep track of\n+ * what alias (of a quantifier) should be considered to what other alias (of another quantifier). A quantifier\n+ * ({@link Quantifier} is referred to via {@link CorrelationIdentifier}. In this way there are no direct pointers\n+ * to objects which is desirable while the graph is mutated through transformations. At various points during", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b64d4eb60de5c3a4be0b4dc0f779ff2f15e47355"}, "originalPosition": 46}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkwMTg3MDQ4OnYy", "diffSide": "RIGHT", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/AliasMap.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wM1QyMDoxODoxMVrOG7HXNA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wM1QyMDoxODoxMVrOG7HXNA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDYzOTc5Ng==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n             * the planning of a query we may want to determine e.g. if a sub-graph would produce the same result as some other\n          \n          \n            \n             * the planning of a query we may want to perform various structural equality comparisons. For example, we might determine if a sub-graph would produce the same result as some other", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/988#discussion_r464639796", "createdAt": "2020-08-03T20:18:11Z", "author": {"login": "nschiefer"}, "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/AliasMap.java", "diffHunk": "@@ -0,0 +1,369 @@\n+/*\n+ * AliasMap.java\n+ *\n+ * This source file is part of the FoundationDB open source project\n+ *\n+ * Copyright 2015-2020 Apple Inc. and the FoundationDB project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.apple.foundationdb.record.query.plan.temp;\n+\n+import com.google.common.base.Verify;\n+import com.google.common.collect.AbstractIterator;\n+import com.google.common.collect.BiMap;\n+import com.google.common.collect.HashBiMap;\n+import com.google.common.collect.ImmutableBiMap;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.Streams;\n+import org.apache.commons.lang3.tuple.Pair;\n+\n+import javax.annotation.Nonnull;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.function.Function;\n+\n+/**\n+ * This class encapsulates mappings between {@link CorrelationIdentifier}s and helpers to create and maintain\n+ * these mappings.\n+ *\n+ * While various operations or in general algorithms traverse the query graph(s) it is important to keep track of\n+ * what alias (of a quantifier) should be considered to what other alias (of another quantifier). A quantifier\n+ * ({@link Quantifier} is referred to via {@link CorrelationIdentifier}. In this way there are no direct pointers\n+ * to objects which is desirable while the graph is mutated through transformations. At various points during\n+ * the planning of a query we may want to determine e.g. if a sub-graph would produce the same result as some other", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b64d4eb60de5c3a4be0b4dc0f779ff2f15e47355"}, "originalPosition": 47}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkwMTg3MTE2OnYy", "diffSide": "RIGHT", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/AliasMap.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wM1QyMDoxODoyOFrOG7HXqg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wM1QyMDoxODoyOFrOG7HXqg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDYzOTkxNA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n             * we need to theorize if two sub-graphs are related to each other (usually equality but also subsumption, etc.)\n          \n          \n            \n             * we need to determine how two sub-graphs are related to each other (usually equality but also subsumption, etc.).", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/988#discussion_r464639914", "createdAt": "2020-08-03T20:18:28Z", "author": {"login": "nschiefer"}, "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/AliasMap.java", "diffHunk": "@@ -0,0 +1,369 @@\n+/*\n+ * AliasMap.java\n+ *\n+ * This source file is part of the FoundationDB open source project\n+ *\n+ * Copyright 2015-2020 Apple Inc. and the FoundationDB project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.apple.foundationdb.record.query.plan.temp;\n+\n+import com.google.common.base.Verify;\n+import com.google.common.collect.AbstractIterator;\n+import com.google.common.collect.BiMap;\n+import com.google.common.collect.HashBiMap;\n+import com.google.common.collect.ImmutableBiMap;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.Streams;\n+import org.apache.commons.lang3.tuple.Pair;\n+\n+import javax.annotation.Nonnull;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.function.Function;\n+\n+/**\n+ * This class encapsulates mappings between {@link CorrelationIdentifier}s and helpers to create and maintain\n+ * these mappings.\n+ *\n+ * While various operations or in general algorithms traverse the query graph(s) it is important to keep track of\n+ * what alias (of a quantifier) should be considered to what other alias (of another quantifier). A quantifier\n+ * ({@link Quantifier} is referred to via {@link CorrelationIdentifier}. In this way there are no direct pointers\n+ * to objects which is desirable while the graph is mutated through transformations. At various points during\n+ * the planning of a query we may want to determine e.g. if a sub-graph would produce the same result as some other\n+ * sub-graph. Similarly, we may want to determine whether a sub-graph is already properly memoized or not. In general,\n+ * we need to theorize if two sub-graphs are related to each other (usually equality but also subsumption, etc.)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b64d4eb60de5c3a4be0b4dc0f779ff2f15e47355"}, "originalPosition": 49}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkwMTg3MTk5OnYy", "diffSide": "RIGHT", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/AliasMap.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wM1QyMDoxODo0NlrOG7HYNg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wM1QyMDoxODo0NlrOG7HYNg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDY0MDA1NA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n             * All of that is rather straightforward if both sub-graphs are completely uncorrelated and therefore independent to\n          \n          \n            \n             * All of that is rather straightforward if both sub-graphs are completely uncorrelated and therefore independent of", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/988#discussion_r464640054", "createdAt": "2020-08-03T20:18:46Z", "author": {"login": "nschiefer"}, "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/AliasMap.java", "diffHunk": "@@ -0,0 +1,369 @@\n+/*\n+ * AliasMap.java\n+ *\n+ * This source file is part of the FoundationDB open source project\n+ *\n+ * Copyright 2015-2020 Apple Inc. and the FoundationDB project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.apple.foundationdb.record.query.plan.temp;\n+\n+import com.google.common.base.Verify;\n+import com.google.common.collect.AbstractIterator;\n+import com.google.common.collect.BiMap;\n+import com.google.common.collect.HashBiMap;\n+import com.google.common.collect.ImmutableBiMap;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.Streams;\n+import org.apache.commons.lang3.tuple.Pair;\n+\n+import javax.annotation.Nonnull;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.function.Function;\n+\n+/**\n+ * This class encapsulates mappings between {@link CorrelationIdentifier}s and helpers to create and maintain\n+ * these mappings.\n+ *\n+ * While various operations or in general algorithms traverse the query graph(s) it is important to keep track of\n+ * what alias (of a quantifier) should be considered to what other alias (of another quantifier). A quantifier\n+ * ({@link Quantifier} is referred to via {@link CorrelationIdentifier}. In this way there are no direct pointers\n+ * to objects which is desirable while the graph is mutated through transformations. At various points during\n+ * the planning of a query we may want to determine e.g. if a sub-graph would produce the same result as some other\n+ * sub-graph. Similarly, we may want to determine whether a sub-graph is already properly memoized or not. In general,\n+ * we need to theorize if two sub-graphs are related to each other (usually equality but also subsumption, etc.)\n+ *\n+ * All of that is rather straightforward if both sub-graphs are completely uncorrelated and therefore independent to", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b64d4eb60de5c3a4be0b4dc0f779ff2f15e47355"}, "originalPosition": 51}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkwMTg3MzI5OnYy", "diffSide": "RIGHT", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/AliasMap.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wM1QyMDoxOToxMlrOG7HY9Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wM1QyMDoxOToxMlrOG7HY9Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDY0MDI0NQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n             * each other, to some other record producer, or even to some external parameter that is being passed in. In these\n          \n          \n            \n             * each other, or if they are correlated to a mutually external parameter. In these", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/988#discussion_r464640245", "createdAt": "2020-08-03T20:19:12Z", "author": {"login": "nschiefer"}, "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/AliasMap.java", "diffHunk": "@@ -0,0 +1,369 @@\n+/*\n+ * AliasMap.java\n+ *\n+ * This source file is part of the FoundationDB open source project\n+ *\n+ * Copyright 2015-2020 Apple Inc. and the FoundationDB project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.apple.foundationdb.record.query.plan.temp;\n+\n+import com.google.common.base.Verify;\n+import com.google.common.collect.AbstractIterator;\n+import com.google.common.collect.BiMap;\n+import com.google.common.collect.HashBiMap;\n+import com.google.common.collect.ImmutableBiMap;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.Streams;\n+import org.apache.commons.lang3.tuple.Pair;\n+\n+import javax.annotation.Nonnull;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.function.Function;\n+\n+/**\n+ * This class encapsulates mappings between {@link CorrelationIdentifier}s and helpers to create and maintain\n+ * these mappings.\n+ *\n+ * While various operations or in general algorithms traverse the query graph(s) it is important to keep track of\n+ * what alias (of a quantifier) should be considered to what other alias (of another quantifier). A quantifier\n+ * ({@link Quantifier} is referred to via {@link CorrelationIdentifier}. In this way there are no direct pointers\n+ * to objects which is desirable while the graph is mutated through transformations. At various points during\n+ * the planning of a query we may want to determine e.g. if a sub-graph would produce the same result as some other\n+ * sub-graph. Similarly, we may want to determine whether a sub-graph is already properly memoized or not. In general,\n+ * we need to theorize if two sub-graphs are related to each other (usually equality but also subsumption, etc.)\n+ *\n+ * All of that is rather straightforward if both sub-graphs are completely uncorrelated and therefore independent to\n+ * each other, to some other record producer, or even to some external parameter that is being passed in. In these", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b64d4eb60de5c3a4be0b4dc0f779ff2f15e47355"}, "originalPosition": 52}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkwMTg3NDM2OnYy", "diffSide": "RIGHT", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/AliasMap.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wM1QyMDoxOTozMlrOG7HZkA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wM1QyMDoxOTozMlrOG7HZkA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDY0MDQwMA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n             * cases the {@code AliasMap} implemented here would effectively be trivial, i.e. the map would be\n          \n          \n            \n             * conceptually empty.\n          \n          \n            \n             * cases the {@code AliasMap} implemented here would be trivial (conceptually empty).", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/988#discussion_r464640400", "createdAt": "2020-08-03T20:19:32Z", "author": {"login": "nschiefer"}, "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/AliasMap.java", "diffHunk": "@@ -0,0 +1,369 @@\n+/*\n+ * AliasMap.java\n+ *\n+ * This source file is part of the FoundationDB open source project\n+ *\n+ * Copyright 2015-2020 Apple Inc. and the FoundationDB project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.apple.foundationdb.record.query.plan.temp;\n+\n+import com.google.common.base.Verify;\n+import com.google.common.collect.AbstractIterator;\n+import com.google.common.collect.BiMap;\n+import com.google.common.collect.HashBiMap;\n+import com.google.common.collect.ImmutableBiMap;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.Streams;\n+import org.apache.commons.lang3.tuple.Pair;\n+\n+import javax.annotation.Nonnull;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.function.Function;\n+\n+/**\n+ * This class encapsulates mappings between {@link CorrelationIdentifier}s and helpers to create and maintain\n+ * these mappings.\n+ *\n+ * While various operations or in general algorithms traverse the query graph(s) it is important to keep track of\n+ * what alias (of a quantifier) should be considered to what other alias (of another quantifier). A quantifier\n+ * ({@link Quantifier} is referred to via {@link CorrelationIdentifier}. In this way there are no direct pointers\n+ * to objects which is desirable while the graph is mutated through transformations. At various points during\n+ * the planning of a query we may want to determine e.g. if a sub-graph would produce the same result as some other\n+ * sub-graph. Similarly, we may want to determine whether a sub-graph is already properly memoized or not. In general,\n+ * we need to theorize if two sub-graphs are related to each other (usually equality but also subsumption, etc.)\n+ *\n+ * All of that is rather straightforward if both sub-graphs are completely uncorrelated and therefore independent to\n+ * each other, to some other record producer, or even to some external parameter that is being passed in. In these\n+ * cases the {@code AliasMap} implemented here would effectively be trivial, i.e. the map would be\n+ * conceptually empty.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b64d4eb60de5c3a4be0b4dc0f779ff2f15e47355"}, "originalPosition": 54}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkwMTg3NzIzOnYy", "diffSide": "RIGHT", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/AliasMap.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wM1QyMDoyMDoyNVrOG7HbPA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wM1QyMDoyMDoyNVrOG7HbPA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDY0MDgyOA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n             * There are cases, however, that need some care to establish the relationships mentioned before.\n          \n          \n            \n             * There are cases, however, that need some care to establish more complex relationships such as those mentioned above.", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/988#discussion_r464640828", "createdAt": "2020-08-03T20:20:25Z", "author": {"login": "nschiefer"}, "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/AliasMap.java", "diffHunk": "@@ -0,0 +1,369 @@\n+/*\n+ * AliasMap.java\n+ *\n+ * This source file is part of the FoundationDB open source project\n+ *\n+ * Copyright 2015-2020 Apple Inc. and the FoundationDB project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.apple.foundationdb.record.query.plan.temp;\n+\n+import com.google.common.base.Verify;\n+import com.google.common.collect.AbstractIterator;\n+import com.google.common.collect.BiMap;\n+import com.google.common.collect.HashBiMap;\n+import com.google.common.collect.ImmutableBiMap;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.Streams;\n+import org.apache.commons.lang3.tuple.Pair;\n+\n+import javax.annotation.Nonnull;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.function.Function;\n+\n+/**\n+ * This class encapsulates mappings between {@link CorrelationIdentifier}s and helpers to create and maintain\n+ * these mappings.\n+ *\n+ * While various operations or in general algorithms traverse the query graph(s) it is important to keep track of\n+ * what alias (of a quantifier) should be considered to what other alias (of another quantifier). A quantifier\n+ * ({@link Quantifier} is referred to via {@link CorrelationIdentifier}. In this way there are no direct pointers\n+ * to objects which is desirable while the graph is mutated through transformations. At various points during\n+ * the planning of a query we may want to determine e.g. if a sub-graph would produce the same result as some other\n+ * sub-graph. Similarly, we may want to determine whether a sub-graph is already properly memoized or not. In general,\n+ * we need to theorize if two sub-graphs are related to each other (usually equality but also subsumption, etc.)\n+ *\n+ * All of that is rather straightforward if both sub-graphs are completely uncorrelated and therefore independent to\n+ * each other, to some other record producer, or even to some external parameter that is being passed in. In these\n+ * cases the {@code AliasMap} implemented here would effectively be trivial, i.e. the map would be\n+ * conceptually empty.\n+ *\n+ * There are cases, however, that need some care to establish the relationships mentioned before.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b64d4eb60de5c3a4be0b4dc0f779ff2f15e47355"}, "originalPosition": 56}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkwMTg3ODg2OnYy", "diffSide": "RIGHT", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/AliasMap.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wM1QyMDoyMDo1OFrOG7HcKQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wM1QyMDoyMDo1OFrOG7HcKQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDY0MTA2NQ==", "bodyText": "This (and other parts like it) need some kind of Javadoc HTML markup. At the very least, we should throw some <pre> tags in there.", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/988#discussion_r464641065", "createdAt": "2020-08-03T20:20:58Z", "author": {"login": "nschiefer"}, "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/AliasMap.java", "diffHunk": "@@ -0,0 +1,369 @@\n+/*\n+ * AliasMap.java\n+ *\n+ * This source file is part of the FoundationDB open source project\n+ *\n+ * Copyright 2015-2020 Apple Inc. and the FoundationDB project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.apple.foundationdb.record.query.plan.temp;\n+\n+import com.google.common.base.Verify;\n+import com.google.common.collect.AbstractIterator;\n+import com.google.common.collect.BiMap;\n+import com.google.common.collect.HashBiMap;\n+import com.google.common.collect.ImmutableBiMap;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.Streams;\n+import org.apache.commons.lang3.tuple.Pair;\n+\n+import javax.annotation.Nonnull;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.function.Function;\n+\n+/**\n+ * This class encapsulates mappings between {@link CorrelationIdentifier}s and helpers to create and maintain\n+ * these mappings.\n+ *\n+ * While various operations or in general algorithms traverse the query graph(s) it is important to keep track of\n+ * what alias (of a quantifier) should be considered to what other alias (of another quantifier). A quantifier\n+ * ({@link Quantifier} is referred to via {@link CorrelationIdentifier}. In this way there are no direct pointers\n+ * to objects which is desirable while the graph is mutated through transformations. At various points during\n+ * the planning of a query we may want to determine e.g. if a sub-graph would produce the same result as some other\n+ * sub-graph. Similarly, we may want to determine whether a sub-graph is already properly memoized or not. In general,\n+ * we need to theorize if two sub-graphs are related to each other (usually equality but also subsumption, etc.)\n+ *\n+ * All of that is rather straightforward if both sub-graphs are completely uncorrelated and therefore independent to\n+ * each other, to some other record producer, or even to some external parameter that is being passed in. In these\n+ * cases the {@code AliasMap} implemented here would effectively be trivial, i.e. the map would be\n+ * conceptually empty.\n+ *\n+ * There are cases, however, that need some care to establish the relationships mentioned before.\n+ *\n+ * Example 1:\n+ *    sub graph 1\n+ *        SELECT T.* FROM T WHERE T.x = c1\n+ *\n+ *    sub graph 2\n+ *        SELECT T.* FROM T WHERE T.x = c2", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b64d4eb60de5c3a4be0b4dc0f779ff2f15e47355"}, "originalPosition": 63}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkwMTg4MTkxOnYy", "diffSide": "RIGHT", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/AliasMap.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wM1QyMDoyMTo1NVrOG7Hd3A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wM1QyMDoyMTo1NVrOG7Hd3A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDY0MTUwMA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n             *    We wold like to establish, if these graphs are equal or not. Both of them are not complete, i.e. we wouldn't\n          \n          \n            \n             *    be able to execute them as is. If we asked if these sub graphs where equal, we certainly would need to say that\n          \n          \n            \n             *    We wold like to establish, if these graphs are equal or not. Both of them are not complete; that is, we wouldn't\n          \n          \n            \n             *    be able to execute them as-is. The graphs can only be equal with respect to a particular relationship between {@code c1} and {@code c2}.", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/988#discussion_r464641500", "createdAt": "2020-08-03T20:21:55Z", "author": {"login": "nschiefer"}, "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/AliasMap.java", "diffHunk": "@@ -0,0 +1,369 @@\n+/*\n+ * AliasMap.java\n+ *\n+ * This source file is part of the FoundationDB open source project\n+ *\n+ * Copyright 2015-2020 Apple Inc. and the FoundationDB project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.apple.foundationdb.record.query.plan.temp;\n+\n+import com.google.common.base.Verify;\n+import com.google.common.collect.AbstractIterator;\n+import com.google.common.collect.BiMap;\n+import com.google.common.collect.HashBiMap;\n+import com.google.common.collect.ImmutableBiMap;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.Streams;\n+import org.apache.commons.lang3.tuple.Pair;\n+\n+import javax.annotation.Nonnull;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.function.Function;\n+\n+/**\n+ * This class encapsulates mappings between {@link CorrelationIdentifier}s and helpers to create and maintain\n+ * these mappings.\n+ *\n+ * While various operations or in general algorithms traverse the query graph(s) it is important to keep track of\n+ * what alias (of a quantifier) should be considered to what other alias (of another quantifier). A quantifier\n+ * ({@link Quantifier} is referred to via {@link CorrelationIdentifier}. In this way there are no direct pointers\n+ * to objects which is desirable while the graph is mutated through transformations. At various points during\n+ * the planning of a query we may want to determine e.g. if a sub-graph would produce the same result as some other\n+ * sub-graph. Similarly, we may want to determine whether a sub-graph is already properly memoized or not. In general,\n+ * we need to theorize if two sub-graphs are related to each other (usually equality but also subsumption, etc.)\n+ *\n+ * All of that is rather straightforward if both sub-graphs are completely uncorrelated and therefore independent to\n+ * each other, to some other record producer, or even to some external parameter that is being passed in. In these\n+ * cases the {@code AliasMap} implemented here would effectively be trivial, i.e. the map would be\n+ * conceptually empty.\n+ *\n+ * There are cases, however, that need some care to establish the relationships mentioned before.\n+ *\n+ * Example 1:\n+ *    sub graph 1\n+ *        SELECT T.* FROM T WHERE T.x = c1\n+ *\n+ *    sub graph 2\n+ *        SELECT T.* FROM T WHERE T.x = c2\n+ *\n+ *    We wold like to establish, if these graphs are equal or not. Both of them are not complete, i.e. we wouldn't\n+ *    be able to execute them as is. If we asked if these sub graphs where equal, we certainly would need to say that", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b64d4eb60de5c3a4be0b4dc0f779ff2f15e47355"}, "originalPosition": 66}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkwMTg4MzY2OnYy", "diffSide": "RIGHT", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/AliasMap.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wM1QyMDoyMjozMVrOG7He9A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wM1QyMDoyMjozMVrOG7He9A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDY0MTc4MA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n             *    that depends. If they, however, are embedded in some surrounding query that binds c1 and c2 respectively, we\n          \n          \n            \n             *    would be able to say if in the greater context of the surrounding query these sub query do the same thing.", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/988#discussion_r464641780", "createdAt": "2020-08-03T20:22:31Z", "author": {"login": "nschiefer"}, "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/AliasMap.java", "diffHunk": "@@ -0,0 +1,369 @@\n+/*\n+ * AliasMap.java\n+ *\n+ * This source file is part of the FoundationDB open source project\n+ *\n+ * Copyright 2015-2020 Apple Inc. and the FoundationDB project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.apple.foundationdb.record.query.plan.temp;\n+\n+import com.google.common.base.Verify;\n+import com.google.common.collect.AbstractIterator;\n+import com.google.common.collect.BiMap;\n+import com.google.common.collect.HashBiMap;\n+import com.google.common.collect.ImmutableBiMap;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.Streams;\n+import org.apache.commons.lang3.tuple.Pair;\n+\n+import javax.annotation.Nonnull;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.function.Function;\n+\n+/**\n+ * This class encapsulates mappings between {@link CorrelationIdentifier}s and helpers to create and maintain\n+ * these mappings.\n+ *\n+ * While various operations or in general algorithms traverse the query graph(s) it is important to keep track of\n+ * what alias (of a quantifier) should be considered to what other alias (of another quantifier). A quantifier\n+ * ({@link Quantifier} is referred to via {@link CorrelationIdentifier}. In this way there are no direct pointers\n+ * to objects which is desirable while the graph is mutated through transformations. At various points during\n+ * the planning of a query we may want to determine e.g. if a sub-graph would produce the same result as some other\n+ * sub-graph. Similarly, we may want to determine whether a sub-graph is already properly memoized or not. In general,\n+ * we need to theorize if two sub-graphs are related to each other (usually equality but also subsumption, etc.)\n+ *\n+ * All of that is rather straightforward if both sub-graphs are completely uncorrelated and therefore independent to\n+ * each other, to some other record producer, or even to some external parameter that is being passed in. In these\n+ * cases the {@code AliasMap} implemented here would effectively be trivial, i.e. the map would be\n+ * conceptually empty.\n+ *\n+ * There are cases, however, that need some care to establish the relationships mentioned before.\n+ *\n+ * Example 1:\n+ *    sub graph 1\n+ *        SELECT T.* FROM T WHERE T.x = c1\n+ *\n+ *    sub graph 2\n+ *        SELECT T.* FROM T WHERE T.x = c2\n+ *\n+ *    We wold like to establish, if these graphs are equal or not. Both of them are not complete, i.e. we wouldn't\n+ *    be able to execute them as is. If we asked if these sub graphs where equal, we certainly would need to say that\n+ *    that depends. If they, however, are embedded in some surrounding query that binds c1 and c2 respectively, we\n+ *    would be able to say if in the greater context of the surrounding query these sub query do the same thing.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b64d4eb60de5c3a4be0b4dc0f779ff2f15e47355"}, "originalPosition": 68}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkwMTg4OTAxOnYy", "diffSide": "RIGHT", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/AliasMap.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wM1QyMDoyNDoxOFrOG7HiNA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wM1QyMDoyNDoxOFrOG7HiNA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDY0MjYxMg==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n             *    correlated references. In other words the sub-graphs define two functions f(x) and g(y). While we can determine\n          \n          \n            \n             *    if f and g are structurally equivalent we con only determine actual result equivalence if we assume x = y for\n          \n          \n            \n             *    the entire domain of x and y.\n          \n          \n            \n             *    correlated references. If we view a correlated expression as a function of its correlations, then two sub-graph are equivalent if and only if they are identically equal (i.e., equal on their entire domain) when viewed as functions.", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/988#discussion_r464642612", "createdAt": "2020-08-03T20:24:18Z", "author": {"login": "nschiefer"}, "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/AliasMap.java", "diffHunk": "@@ -0,0 +1,369 @@\n+/*\n+ * AliasMap.java\n+ *\n+ * This source file is part of the FoundationDB open source project\n+ *\n+ * Copyright 2015-2020 Apple Inc. and the FoundationDB project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.apple.foundationdb.record.query.plan.temp;\n+\n+import com.google.common.base.Verify;\n+import com.google.common.collect.AbstractIterator;\n+import com.google.common.collect.BiMap;\n+import com.google.common.collect.HashBiMap;\n+import com.google.common.collect.ImmutableBiMap;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.Streams;\n+import org.apache.commons.lang3.tuple.Pair;\n+\n+import javax.annotation.Nonnull;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.function.Function;\n+\n+/**\n+ * This class encapsulates mappings between {@link CorrelationIdentifier}s and helpers to create and maintain\n+ * these mappings.\n+ *\n+ * While various operations or in general algorithms traverse the query graph(s) it is important to keep track of\n+ * what alias (of a quantifier) should be considered to what other alias (of another quantifier). A quantifier\n+ * ({@link Quantifier} is referred to via {@link CorrelationIdentifier}. In this way there are no direct pointers\n+ * to objects which is desirable while the graph is mutated through transformations. At various points during\n+ * the planning of a query we may want to determine e.g. if a sub-graph would produce the same result as some other\n+ * sub-graph. Similarly, we may want to determine whether a sub-graph is already properly memoized or not. In general,\n+ * we need to theorize if two sub-graphs are related to each other (usually equality but also subsumption, etc.)\n+ *\n+ * All of that is rather straightforward if both sub-graphs are completely uncorrelated and therefore independent to\n+ * each other, to some other record producer, or even to some external parameter that is being passed in. In these\n+ * cases the {@code AliasMap} implemented here would effectively be trivial, i.e. the map would be\n+ * conceptually empty.\n+ *\n+ * There are cases, however, that need some care to establish the relationships mentioned before.\n+ *\n+ * Example 1:\n+ *    sub graph 1\n+ *        SELECT T.* FROM T WHERE T.x = c1\n+ *\n+ *    sub graph 2\n+ *        SELECT T.* FROM T WHERE T.x = c2\n+ *\n+ *    We wold like to establish, if these graphs are equal or not. Both of them are not complete, i.e. we wouldn't\n+ *    be able to execute them as is. If we asked if these sub graphs where equal, we certainly would need to say that\n+ *    that depends. If they, however, are embedded in some surrounding query that binds c1 and c2 respectively, we\n+ *    would be able to say if in the greater context of the surrounding query these sub query do the same thing.\n+ *\n+ *            SELECT * FROM R AS c1, (SELECT T.* FROM T WHERE T.x = c1)\n+ *\n+ *        is the same as\n+ *\n+ *            SELECT * FROM R AS c2, (SELECT T.* FROM T WHERE T.x = c2)\n+ *\n+ *    whereas\n+ *            SELECT * FROM R AS c1, (SELECT T.* FROM T WHERE T.x = c1)\n+ *\n+ *        is definitely not the same as\n+ *\n+ *            SELECT * FROM S AS c2, (SELECT T.* FROM T WHERE T.x = c2)\n+ *\n+ *    In short, a sub-graph can only be considered equal to another sub-graph if we assume an equality over their\n+ *    correlated references. In other words the sub-graphs define two functions f(x) and g(y). While we can determine\n+ *    if f and g are structurally equivalent we con only determine actual result equivalence if we assume x = y for\n+ *    the entire domain of x and y.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b64d4eb60de5c3a4be0b4dc0f779ff2f15e47355"}, "originalPosition": 86}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkwMTg5MDcyOnYy", "diffSide": "RIGHT", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/AliasMap.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wM1QyMDoyNDo1NFrOG7HjTQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wM1QyMDoyNDo1NFrOG7HjTQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDY0Mjg5Mw==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n             * When we descend into correlated sub-graphs during an algorithm while we e.g. determine {@link Correlated#resultEquals}\n          \n          \n            \n             * When we descend into correlated sub-graphs during an algorithm while we compute a function like {@link Correlated#resultEquals}", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/988#discussion_r464642893", "createdAt": "2020-08-03T20:24:54Z", "author": {"login": "nschiefer"}, "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/AliasMap.java", "diffHunk": "@@ -0,0 +1,369 @@\n+/*\n+ * AliasMap.java\n+ *\n+ * This source file is part of the FoundationDB open source project\n+ *\n+ * Copyright 2015-2020 Apple Inc. and the FoundationDB project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.apple.foundationdb.record.query.plan.temp;\n+\n+import com.google.common.base.Verify;\n+import com.google.common.collect.AbstractIterator;\n+import com.google.common.collect.BiMap;\n+import com.google.common.collect.HashBiMap;\n+import com.google.common.collect.ImmutableBiMap;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.Streams;\n+import org.apache.commons.lang3.tuple.Pair;\n+\n+import javax.annotation.Nonnull;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.function.Function;\n+\n+/**\n+ * This class encapsulates mappings between {@link CorrelationIdentifier}s and helpers to create and maintain\n+ * these mappings.\n+ *\n+ * While various operations or in general algorithms traverse the query graph(s) it is important to keep track of\n+ * what alias (of a quantifier) should be considered to what other alias (of another quantifier). A quantifier\n+ * ({@link Quantifier} is referred to via {@link CorrelationIdentifier}. In this way there are no direct pointers\n+ * to objects which is desirable while the graph is mutated through transformations. At various points during\n+ * the planning of a query we may want to determine e.g. if a sub-graph would produce the same result as some other\n+ * sub-graph. Similarly, we may want to determine whether a sub-graph is already properly memoized or not. In general,\n+ * we need to theorize if two sub-graphs are related to each other (usually equality but also subsumption, etc.)\n+ *\n+ * All of that is rather straightforward if both sub-graphs are completely uncorrelated and therefore independent to\n+ * each other, to some other record producer, or even to some external parameter that is being passed in. In these\n+ * cases the {@code AliasMap} implemented here would effectively be trivial, i.e. the map would be\n+ * conceptually empty.\n+ *\n+ * There are cases, however, that need some care to establish the relationships mentioned before.\n+ *\n+ * Example 1:\n+ *    sub graph 1\n+ *        SELECT T.* FROM T WHERE T.x = c1\n+ *\n+ *    sub graph 2\n+ *        SELECT T.* FROM T WHERE T.x = c2\n+ *\n+ *    We wold like to establish, if these graphs are equal or not. Both of them are not complete, i.e. we wouldn't\n+ *    be able to execute them as is. If we asked if these sub graphs where equal, we certainly would need to say that\n+ *    that depends. If they, however, are embedded in some surrounding query that binds c1 and c2 respectively, we\n+ *    would be able to say if in the greater context of the surrounding query these sub query do the same thing.\n+ *\n+ *            SELECT * FROM R AS c1, (SELECT T.* FROM T WHERE T.x = c1)\n+ *\n+ *        is the same as\n+ *\n+ *            SELECT * FROM R AS c2, (SELECT T.* FROM T WHERE T.x = c2)\n+ *\n+ *    whereas\n+ *            SELECT * FROM R AS c1, (SELECT T.* FROM T WHERE T.x = c1)\n+ *\n+ *        is definitely not the same as\n+ *\n+ *            SELECT * FROM S AS c2, (SELECT T.* FROM T WHERE T.x = c2)\n+ *\n+ *    In short, a sub-graph can only be considered equal to another sub-graph if we assume an equality over their\n+ *    correlated references. In other words the sub-graphs define two functions f(x) and g(y). While we can determine\n+ *    if f and g are structurally equivalent we con only determine actual result equivalence if we assume x = y for\n+ *    the entire domain of x and y.\n+ *\n+ * Example 2:\n+ *    sub graph 1\n+ *        SELECT T.* FROM T WHERE T.x = c1 AND T.y = c2\n+ *\n+ *    sub graph 2\n+ *        SELECT T.* FROM T WHERE T.x = c2 AND T.y = c1\n+ *\n+ *    This scenario is somewhat more complicated as it offers more degrees of freedom.\n+ *\n+ *            SELECT * FROM R AS c1, S AS c2, (SELECT T.* FROM T WHERE T.x = c1 AND T.y = c2)\n+ *\n+ *        is the same as\n+ *\n+ *            SELECT * FROM R AS c2, S AS c1, (SELECT T.* FROM T WHERE T.x = c2 AND T.y = c1)\n+ *\n+ *    This observation is identical to the one in example 1. Due to the commutative nature we also would like to\n+ *    be able to realize that even this is the same:\n+ *\n+ *    SELECT * FROM R AS c1, S AS c2, (SELECT T.* FROM T WHERE T.x = c2 AND T.y = c1)\n+ *\n+ * In any case we need to keep track of what's currently considered bound and equal while we traverse the query graph.\n+ * When we descend into correlated sub-graphs during an algorithm while we e.g. determine {@link Correlated#resultEquals}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b64d4eb60de5c3a4be0b4dc0f779ff2f15e47355"}, "originalPosition": 109}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkwMTg5MTcwOnYy", "diffSide": "RIGHT", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/AliasMap.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wM1QyMDoyNToxMFrOG7Hj2Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wM1QyMDoyNToxMFrOG7Hj2Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDY0MzAzMw==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n             * we need to have all outside references bound and mapped in some way: Should we treat c1 on the left as c2 on the right\n          \n          \n            \n             * we need to have all outside references bound and mapped in some way: should we treat {@code c1} on the left as {@code c2} on the right", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/988#discussion_r464643033", "createdAt": "2020-08-03T20:25:10Z", "author": {"login": "nschiefer"}, "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/AliasMap.java", "diffHunk": "@@ -0,0 +1,369 @@\n+/*\n+ * AliasMap.java\n+ *\n+ * This source file is part of the FoundationDB open source project\n+ *\n+ * Copyright 2015-2020 Apple Inc. and the FoundationDB project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.apple.foundationdb.record.query.plan.temp;\n+\n+import com.google.common.base.Verify;\n+import com.google.common.collect.AbstractIterator;\n+import com.google.common.collect.BiMap;\n+import com.google.common.collect.HashBiMap;\n+import com.google.common.collect.ImmutableBiMap;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.Streams;\n+import org.apache.commons.lang3.tuple.Pair;\n+\n+import javax.annotation.Nonnull;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.function.Function;\n+\n+/**\n+ * This class encapsulates mappings between {@link CorrelationIdentifier}s and helpers to create and maintain\n+ * these mappings.\n+ *\n+ * While various operations or in general algorithms traverse the query graph(s) it is important to keep track of\n+ * what alias (of a quantifier) should be considered to what other alias (of another quantifier). A quantifier\n+ * ({@link Quantifier} is referred to via {@link CorrelationIdentifier}. In this way there are no direct pointers\n+ * to objects which is desirable while the graph is mutated through transformations. At various points during\n+ * the planning of a query we may want to determine e.g. if a sub-graph would produce the same result as some other\n+ * sub-graph. Similarly, we may want to determine whether a sub-graph is already properly memoized or not. In general,\n+ * we need to theorize if two sub-graphs are related to each other (usually equality but also subsumption, etc.)\n+ *\n+ * All of that is rather straightforward if both sub-graphs are completely uncorrelated and therefore independent to\n+ * each other, to some other record producer, or even to some external parameter that is being passed in. In these\n+ * cases the {@code AliasMap} implemented here would effectively be trivial, i.e. the map would be\n+ * conceptually empty.\n+ *\n+ * There are cases, however, that need some care to establish the relationships mentioned before.\n+ *\n+ * Example 1:\n+ *    sub graph 1\n+ *        SELECT T.* FROM T WHERE T.x = c1\n+ *\n+ *    sub graph 2\n+ *        SELECT T.* FROM T WHERE T.x = c2\n+ *\n+ *    We wold like to establish, if these graphs are equal or not. Both of them are not complete, i.e. we wouldn't\n+ *    be able to execute them as is. If we asked if these sub graphs where equal, we certainly would need to say that\n+ *    that depends. If they, however, are embedded in some surrounding query that binds c1 and c2 respectively, we\n+ *    would be able to say if in the greater context of the surrounding query these sub query do the same thing.\n+ *\n+ *            SELECT * FROM R AS c1, (SELECT T.* FROM T WHERE T.x = c1)\n+ *\n+ *        is the same as\n+ *\n+ *            SELECT * FROM R AS c2, (SELECT T.* FROM T WHERE T.x = c2)\n+ *\n+ *    whereas\n+ *            SELECT * FROM R AS c1, (SELECT T.* FROM T WHERE T.x = c1)\n+ *\n+ *        is definitely not the same as\n+ *\n+ *            SELECT * FROM S AS c2, (SELECT T.* FROM T WHERE T.x = c2)\n+ *\n+ *    In short, a sub-graph can only be considered equal to another sub-graph if we assume an equality over their\n+ *    correlated references. In other words the sub-graphs define two functions f(x) and g(y). While we can determine\n+ *    if f and g are structurally equivalent we con only determine actual result equivalence if we assume x = y for\n+ *    the entire domain of x and y.\n+ *\n+ * Example 2:\n+ *    sub graph 1\n+ *        SELECT T.* FROM T WHERE T.x = c1 AND T.y = c2\n+ *\n+ *    sub graph 2\n+ *        SELECT T.* FROM T WHERE T.x = c2 AND T.y = c1\n+ *\n+ *    This scenario is somewhat more complicated as it offers more degrees of freedom.\n+ *\n+ *            SELECT * FROM R AS c1, S AS c2, (SELECT T.* FROM T WHERE T.x = c1 AND T.y = c2)\n+ *\n+ *        is the same as\n+ *\n+ *            SELECT * FROM R AS c2, S AS c1, (SELECT T.* FROM T WHERE T.x = c2 AND T.y = c1)\n+ *\n+ *    This observation is identical to the one in example 1. Due to the commutative nature we also would like to\n+ *    be able to realize that even this is the same:\n+ *\n+ *    SELECT * FROM R AS c1, S AS c2, (SELECT T.* FROM T WHERE T.x = c2 AND T.y = c1)\n+ *\n+ * In any case we need to keep track of what's currently considered bound and equal while we traverse the query graph.\n+ * When we descend into correlated sub-graphs during an algorithm while we e.g. determine {@link Correlated#resultEquals}\n+ * we need to have all outside references bound and mapped in some way: Should we treat c1 on the left as c2 on the right", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b64d4eb60de5c3a4be0b4dc0f779ff2f15e47355"}, "originalPosition": 110}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkwMTg5MzYyOnYy", "diffSide": "RIGHT", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/AliasMap.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wM1QyMDoyNTo0OVrOG7HlEA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wM1QyMDoyNTo0OVrOG7HlEA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDY0MzM0NA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n             * traversing e.g. permutations of possible mappings.\n          \n          \n            \n             * traversing variation (such as permutations) of possible mappings.", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/988#discussion_r464643344", "createdAt": "2020-08-03T20:25:49Z", "author": {"login": "nschiefer"}, "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/AliasMap.java", "diffHunk": "@@ -0,0 +1,369 @@\n+/*\n+ * AliasMap.java\n+ *\n+ * This source file is part of the FoundationDB open source project\n+ *\n+ * Copyright 2015-2020 Apple Inc. and the FoundationDB project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.apple.foundationdb.record.query.plan.temp;\n+\n+import com.google.common.base.Verify;\n+import com.google.common.collect.AbstractIterator;\n+import com.google.common.collect.BiMap;\n+import com.google.common.collect.HashBiMap;\n+import com.google.common.collect.ImmutableBiMap;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.Streams;\n+import org.apache.commons.lang3.tuple.Pair;\n+\n+import javax.annotation.Nonnull;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.function.Function;\n+\n+/**\n+ * This class encapsulates mappings between {@link CorrelationIdentifier}s and helpers to create and maintain\n+ * these mappings.\n+ *\n+ * While various operations or in general algorithms traverse the query graph(s) it is important to keep track of\n+ * what alias (of a quantifier) should be considered to what other alias (of another quantifier). A quantifier\n+ * ({@link Quantifier} is referred to via {@link CorrelationIdentifier}. In this way there are no direct pointers\n+ * to objects which is desirable while the graph is mutated through transformations. At various points during\n+ * the planning of a query we may want to determine e.g. if a sub-graph would produce the same result as some other\n+ * sub-graph. Similarly, we may want to determine whether a sub-graph is already properly memoized or not. In general,\n+ * we need to theorize if two sub-graphs are related to each other (usually equality but also subsumption, etc.)\n+ *\n+ * All of that is rather straightforward if both sub-graphs are completely uncorrelated and therefore independent to\n+ * each other, to some other record producer, or even to some external parameter that is being passed in. In these\n+ * cases the {@code AliasMap} implemented here would effectively be trivial, i.e. the map would be\n+ * conceptually empty.\n+ *\n+ * There are cases, however, that need some care to establish the relationships mentioned before.\n+ *\n+ * Example 1:\n+ *    sub graph 1\n+ *        SELECT T.* FROM T WHERE T.x = c1\n+ *\n+ *    sub graph 2\n+ *        SELECT T.* FROM T WHERE T.x = c2\n+ *\n+ *    We wold like to establish, if these graphs are equal or not. Both of them are not complete, i.e. we wouldn't\n+ *    be able to execute them as is. If we asked if these sub graphs where equal, we certainly would need to say that\n+ *    that depends. If they, however, are embedded in some surrounding query that binds c1 and c2 respectively, we\n+ *    would be able to say if in the greater context of the surrounding query these sub query do the same thing.\n+ *\n+ *            SELECT * FROM R AS c1, (SELECT T.* FROM T WHERE T.x = c1)\n+ *\n+ *        is the same as\n+ *\n+ *            SELECT * FROM R AS c2, (SELECT T.* FROM T WHERE T.x = c2)\n+ *\n+ *    whereas\n+ *            SELECT * FROM R AS c1, (SELECT T.* FROM T WHERE T.x = c1)\n+ *\n+ *        is definitely not the same as\n+ *\n+ *            SELECT * FROM S AS c2, (SELECT T.* FROM T WHERE T.x = c2)\n+ *\n+ *    In short, a sub-graph can only be considered equal to another sub-graph if we assume an equality over their\n+ *    correlated references. In other words the sub-graphs define two functions f(x) and g(y). While we can determine\n+ *    if f and g are structurally equivalent we con only determine actual result equivalence if we assume x = y for\n+ *    the entire domain of x and y.\n+ *\n+ * Example 2:\n+ *    sub graph 1\n+ *        SELECT T.* FROM T WHERE T.x = c1 AND T.y = c2\n+ *\n+ *    sub graph 2\n+ *        SELECT T.* FROM T WHERE T.x = c2 AND T.y = c1\n+ *\n+ *    This scenario is somewhat more complicated as it offers more degrees of freedom.\n+ *\n+ *            SELECT * FROM R AS c1, S AS c2, (SELECT T.* FROM T WHERE T.x = c1 AND T.y = c2)\n+ *\n+ *        is the same as\n+ *\n+ *            SELECT * FROM R AS c2, S AS c1, (SELECT T.* FROM T WHERE T.x = c2 AND T.y = c1)\n+ *\n+ *    This observation is identical to the one in example 1. Due to the commutative nature we also would like to\n+ *    be able to realize that even this is the same:\n+ *\n+ *    SELECT * FROM R AS c1, S AS c2, (SELECT T.* FROM T WHERE T.x = c2 AND T.y = c1)\n+ *\n+ * In any case we need to keep track of what's currently considered bound and equal while we traverse the query graph.\n+ * When we descend into correlated sub-graphs during an algorithm while we e.g. determine {@link Correlated#resultEquals}\n+ * we need to have all outside references bound and mapped in some way: Should we treat c1 on the left as c2 on the right\n+ * or the other way around? It is the job of an object of this class to facilitate the construction and the lookup of\n+ * these mappings. Algorithms walking the graph make use of this map, construct and reconstruct assumed equality while\n+ * traversing e.g. permutations of possible mappings.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b64d4eb60de5c3a4be0b4dc0f779ff2f15e47355"}, "originalPosition": 113}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkwMTg5NDE2OnYy", "diffSide": "RIGHT", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/AliasMap.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wM1QyMDoyNjowMVrOG7HlYA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wM1QyMDoyNjowMVrOG7HlYA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDY0MzQyNA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n             * Another \n          \n          \n            \n             *", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/988#discussion_r464643424", "createdAt": "2020-08-03T20:26:01Z", "author": {"login": "nschiefer"}, "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/AliasMap.java", "diffHunk": "@@ -0,0 +1,369 @@\n+/*\n+ * AliasMap.java\n+ *\n+ * This source file is part of the FoundationDB open source project\n+ *\n+ * Copyright 2015-2020 Apple Inc. and the FoundationDB project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.apple.foundationdb.record.query.plan.temp;\n+\n+import com.google.common.base.Verify;\n+import com.google.common.collect.AbstractIterator;\n+import com.google.common.collect.BiMap;\n+import com.google.common.collect.HashBiMap;\n+import com.google.common.collect.ImmutableBiMap;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.Streams;\n+import org.apache.commons.lang3.tuple.Pair;\n+\n+import javax.annotation.Nonnull;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.function.Function;\n+\n+/**\n+ * This class encapsulates mappings between {@link CorrelationIdentifier}s and helpers to create and maintain\n+ * these mappings.\n+ *\n+ * While various operations or in general algorithms traverse the query graph(s) it is important to keep track of\n+ * what alias (of a quantifier) should be considered to what other alias (of another quantifier). A quantifier\n+ * ({@link Quantifier} is referred to via {@link CorrelationIdentifier}. In this way there are no direct pointers\n+ * to objects which is desirable while the graph is mutated through transformations. At various points during\n+ * the planning of a query we may want to determine e.g. if a sub-graph would produce the same result as some other\n+ * sub-graph. Similarly, we may want to determine whether a sub-graph is already properly memoized or not. In general,\n+ * we need to theorize if two sub-graphs are related to each other (usually equality but also subsumption, etc.)\n+ *\n+ * All of that is rather straightforward if both sub-graphs are completely uncorrelated and therefore independent to\n+ * each other, to some other record producer, or even to some external parameter that is being passed in. In these\n+ * cases the {@code AliasMap} implemented here would effectively be trivial, i.e. the map would be\n+ * conceptually empty.\n+ *\n+ * There are cases, however, that need some care to establish the relationships mentioned before.\n+ *\n+ * Example 1:\n+ *    sub graph 1\n+ *        SELECT T.* FROM T WHERE T.x = c1\n+ *\n+ *    sub graph 2\n+ *        SELECT T.* FROM T WHERE T.x = c2\n+ *\n+ *    We wold like to establish, if these graphs are equal or not. Both of them are not complete, i.e. we wouldn't\n+ *    be able to execute them as is. If we asked if these sub graphs where equal, we certainly would need to say that\n+ *    that depends. If they, however, are embedded in some surrounding query that binds c1 and c2 respectively, we\n+ *    would be able to say if in the greater context of the surrounding query these sub query do the same thing.\n+ *\n+ *            SELECT * FROM R AS c1, (SELECT T.* FROM T WHERE T.x = c1)\n+ *\n+ *        is the same as\n+ *\n+ *            SELECT * FROM R AS c2, (SELECT T.* FROM T WHERE T.x = c2)\n+ *\n+ *    whereas\n+ *            SELECT * FROM R AS c1, (SELECT T.* FROM T WHERE T.x = c1)\n+ *\n+ *        is definitely not the same as\n+ *\n+ *            SELECT * FROM S AS c2, (SELECT T.* FROM T WHERE T.x = c2)\n+ *\n+ *    In short, a sub-graph can only be considered equal to another sub-graph if we assume an equality over their\n+ *    correlated references. In other words the sub-graphs define two functions f(x) and g(y). While we can determine\n+ *    if f and g are structurally equivalent we con only determine actual result equivalence if we assume x = y for\n+ *    the entire domain of x and y.\n+ *\n+ * Example 2:\n+ *    sub graph 1\n+ *        SELECT T.* FROM T WHERE T.x = c1 AND T.y = c2\n+ *\n+ *    sub graph 2\n+ *        SELECT T.* FROM T WHERE T.x = c2 AND T.y = c1\n+ *\n+ *    This scenario is somewhat more complicated as it offers more degrees of freedom.\n+ *\n+ *            SELECT * FROM R AS c1, S AS c2, (SELECT T.* FROM T WHERE T.x = c1 AND T.y = c2)\n+ *\n+ *        is the same as\n+ *\n+ *            SELECT * FROM R AS c2, S AS c1, (SELECT T.* FROM T WHERE T.x = c2 AND T.y = c1)\n+ *\n+ *    This observation is identical to the one in example 1. Due to the commutative nature we also would like to\n+ *    be able to realize that even this is the same:\n+ *\n+ *    SELECT * FROM R AS c1, S AS c2, (SELECT T.* FROM T WHERE T.x = c2 AND T.y = c1)\n+ *\n+ * In any case we need to keep track of what's currently considered bound and equal while we traverse the query graph.\n+ * When we descend into correlated sub-graphs during an algorithm while we e.g. determine {@link Correlated#resultEquals}\n+ * we need to have all outside references bound and mapped in some way: Should we treat c1 on the left as c2 on the right\n+ * or the other way around? It is the job of an object of this class to facilitate the construction and the lookup of\n+ * these mappings. Algorithms walking the graph make use of this map, construct and reconstruct assumed equality while\n+ * traversing e.g. permutations of possible mappings.\n+ *\n+ * Another \n+ *", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b64d4eb60de5c3a4be0b4dc0f779ff2f15e47355"}, "originalPosition": 116}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkwMTg5NDQ1OnYy", "diffSide": "RIGHT", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/AliasMap.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wM1QyMDoyNjoxMVrOG7HlmA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wM1QyMDoyNjoxMVrOG7HlmA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDY0MzQ4MA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n             * Note: This class is immutable, all perceived \"mutations\" cause a new object to be created.\n          \n          \n            \n             * This class is immutable, all perceived \"mutations\" cause a new object to be created.", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/988#discussion_r464643480", "createdAt": "2020-08-03T20:26:11Z", "author": {"login": "nschiefer"}, "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/AliasMap.java", "diffHunk": "@@ -0,0 +1,369 @@\n+/*\n+ * AliasMap.java\n+ *\n+ * This source file is part of the FoundationDB open source project\n+ *\n+ * Copyright 2015-2020 Apple Inc. and the FoundationDB project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.apple.foundationdb.record.query.plan.temp;\n+\n+import com.google.common.base.Verify;\n+import com.google.common.collect.AbstractIterator;\n+import com.google.common.collect.BiMap;\n+import com.google.common.collect.HashBiMap;\n+import com.google.common.collect.ImmutableBiMap;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.Streams;\n+import org.apache.commons.lang3.tuple.Pair;\n+\n+import javax.annotation.Nonnull;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.function.Function;\n+\n+/**\n+ * This class encapsulates mappings between {@link CorrelationIdentifier}s and helpers to create and maintain\n+ * these mappings.\n+ *\n+ * While various operations or in general algorithms traverse the query graph(s) it is important to keep track of\n+ * what alias (of a quantifier) should be considered to what other alias (of another quantifier). A quantifier\n+ * ({@link Quantifier} is referred to via {@link CorrelationIdentifier}. In this way there are no direct pointers\n+ * to objects which is desirable while the graph is mutated through transformations. At various points during\n+ * the planning of a query we may want to determine e.g. if a sub-graph would produce the same result as some other\n+ * sub-graph. Similarly, we may want to determine whether a sub-graph is already properly memoized or not. In general,\n+ * we need to theorize if two sub-graphs are related to each other (usually equality but also subsumption, etc.)\n+ *\n+ * All of that is rather straightforward if both sub-graphs are completely uncorrelated and therefore independent to\n+ * each other, to some other record producer, or even to some external parameter that is being passed in. In these\n+ * cases the {@code AliasMap} implemented here would effectively be trivial, i.e. the map would be\n+ * conceptually empty.\n+ *\n+ * There are cases, however, that need some care to establish the relationships mentioned before.\n+ *\n+ * Example 1:\n+ *    sub graph 1\n+ *        SELECT T.* FROM T WHERE T.x = c1\n+ *\n+ *    sub graph 2\n+ *        SELECT T.* FROM T WHERE T.x = c2\n+ *\n+ *    We wold like to establish, if these graphs are equal or not. Both of them are not complete, i.e. we wouldn't\n+ *    be able to execute them as is. If we asked if these sub graphs where equal, we certainly would need to say that\n+ *    that depends. If they, however, are embedded in some surrounding query that binds c1 and c2 respectively, we\n+ *    would be able to say if in the greater context of the surrounding query these sub query do the same thing.\n+ *\n+ *            SELECT * FROM R AS c1, (SELECT T.* FROM T WHERE T.x = c1)\n+ *\n+ *        is the same as\n+ *\n+ *            SELECT * FROM R AS c2, (SELECT T.* FROM T WHERE T.x = c2)\n+ *\n+ *    whereas\n+ *            SELECT * FROM R AS c1, (SELECT T.* FROM T WHERE T.x = c1)\n+ *\n+ *        is definitely not the same as\n+ *\n+ *            SELECT * FROM S AS c2, (SELECT T.* FROM T WHERE T.x = c2)\n+ *\n+ *    In short, a sub-graph can only be considered equal to another sub-graph if we assume an equality over their\n+ *    correlated references. In other words the sub-graphs define two functions f(x) and g(y). While we can determine\n+ *    if f and g are structurally equivalent we con only determine actual result equivalence if we assume x = y for\n+ *    the entire domain of x and y.\n+ *\n+ * Example 2:\n+ *    sub graph 1\n+ *        SELECT T.* FROM T WHERE T.x = c1 AND T.y = c2\n+ *\n+ *    sub graph 2\n+ *        SELECT T.* FROM T WHERE T.x = c2 AND T.y = c1\n+ *\n+ *    This scenario is somewhat more complicated as it offers more degrees of freedom.\n+ *\n+ *            SELECT * FROM R AS c1, S AS c2, (SELECT T.* FROM T WHERE T.x = c1 AND T.y = c2)\n+ *\n+ *        is the same as\n+ *\n+ *            SELECT * FROM R AS c2, S AS c1, (SELECT T.* FROM T WHERE T.x = c2 AND T.y = c1)\n+ *\n+ *    This observation is identical to the one in example 1. Due to the commutative nature we also would like to\n+ *    be able to realize that even this is the same:\n+ *\n+ *    SELECT * FROM R AS c1, S AS c2, (SELECT T.* FROM T WHERE T.x = c2 AND T.y = c1)\n+ *\n+ * In any case we need to keep track of what's currently considered bound and equal while we traverse the query graph.\n+ * When we descend into correlated sub-graphs during an algorithm while we e.g. determine {@link Correlated#resultEquals}\n+ * we need to have all outside references bound and mapped in some way: Should we treat c1 on the left as c2 on the right\n+ * or the other way around? It is the job of an object of this class to facilitate the construction and the lookup of\n+ * these mappings. Algorithms walking the graph make use of this map, construct and reconstruct assumed equality while\n+ * traversing e.g. permutations of possible mappings.\n+ *\n+ * Another \n+ *\n+ * Note: This class is immutable, all perceived \"mutations\" cause a new object to be created.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b64d4eb60de5c3a4be0b4dc0f779ff2f15e47355"}, "originalPosition": 117}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkwMTg5NjkzOnYy", "diffSide": "RIGHT", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/AliasMap.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wM1QyMDoyNzowOFrOG7HnMw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wM1QyMDoyNzowOFrOG7HnMw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDY0Mzg5MQ==", "bodyText": "Here and elsewhere, it's not conventional to put any formatting (and especially Markdown formatting) in parameter descriptions. In my experience, it leads to funky Javadocs.", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/988#discussion_r464643891", "createdAt": "2020-08-03T20:27:08Z", "author": {"login": "nschiefer"}, "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/AliasMap.java", "diffHunk": "@@ -0,0 +1,369 @@\n+/*\n+ * AliasMap.java\n+ *\n+ * This source file is part of the FoundationDB open source project\n+ *\n+ * Copyright 2015-2020 Apple Inc. and the FoundationDB project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.apple.foundationdb.record.query.plan.temp;\n+\n+import com.google.common.base.Verify;\n+import com.google.common.collect.AbstractIterator;\n+import com.google.common.collect.BiMap;\n+import com.google.common.collect.HashBiMap;\n+import com.google.common.collect.ImmutableBiMap;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.Streams;\n+import org.apache.commons.lang3.tuple.Pair;\n+\n+import javax.annotation.Nonnull;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.function.Function;\n+\n+/**\n+ * This class encapsulates mappings between {@link CorrelationIdentifier}s and helpers to create and maintain\n+ * these mappings.\n+ *\n+ * While various operations or in general algorithms traverse the query graph(s) it is important to keep track of\n+ * what alias (of a quantifier) should be considered to what other alias (of another quantifier). A quantifier\n+ * ({@link Quantifier} is referred to via {@link CorrelationIdentifier}. In this way there are no direct pointers\n+ * to objects which is desirable while the graph is mutated through transformations. At various points during\n+ * the planning of a query we may want to determine e.g. if a sub-graph would produce the same result as some other\n+ * sub-graph. Similarly, we may want to determine whether a sub-graph is already properly memoized or not. In general,\n+ * we need to theorize if two sub-graphs are related to each other (usually equality but also subsumption, etc.)\n+ *\n+ * All of that is rather straightforward if both sub-graphs are completely uncorrelated and therefore independent to\n+ * each other, to some other record producer, or even to some external parameter that is being passed in. In these\n+ * cases the {@code AliasMap} implemented here would effectively be trivial, i.e. the map would be\n+ * conceptually empty.\n+ *\n+ * There are cases, however, that need some care to establish the relationships mentioned before.\n+ *\n+ * Example 1:\n+ *    sub graph 1\n+ *        SELECT T.* FROM T WHERE T.x = c1\n+ *\n+ *    sub graph 2\n+ *        SELECT T.* FROM T WHERE T.x = c2\n+ *\n+ *    We wold like to establish, if these graphs are equal or not. Both of them are not complete, i.e. we wouldn't\n+ *    be able to execute them as is. If we asked if these sub graphs where equal, we certainly would need to say that\n+ *    that depends. If they, however, are embedded in some surrounding query that binds c1 and c2 respectively, we\n+ *    would be able to say if in the greater context of the surrounding query these sub query do the same thing.\n+ *\n+ *            SELECT * FROM R AS c1, (SELECT T.* FROM T WHERE T.x = c1)\n+ *\n+ *        is the same as\n+ *\n+ *            SELECT * FROM R AS c2, (SELECT T.* FROM T WHERE T.x = c2)\n+ *\n+ *    whereas\n+ *            SELECT * FROM R AS c1, (SELECT T.* FROM T WHERE T.x = c1)\n+ *\n+ *        is definitely not the same as\n+ *\n+ *            SELECT * FROM S AS c2, (SELECT T.* FROM T WHERE T.x = c2)\n+ *\n+ *    In short, a sub-graph can only be considered equal to another sub-graph if we assume an equality over their\n+ *    correlated references. In other words the sub-graphs define two functions f(x) and g(y). While we can determine\n+ *    if f and g are structurally equivalent we con only determine actual result equivalence if we assume x = y for\n+ *    the entire domain of x and y.\n+ *\n+ * Example 2:\n+ *    sub graph 1\n+ *        SELECT T.* FROM T WHERE T.x = c1 AND T.y = c2\n+ *\n+ *    sub graph 2\n+ *        SELECT T.* FROM T WHERE T.x = c2 AND T.y = c1\n+ *\n+ *    This scenario is somewhat more complicated as it offers more degrees of freedom.\n+ *\n+ *            SELECT * FROM R AS c1, S AS c2, (SELECT T.* FROM T WHERE T.x = c1 AND T.y = c2)\n+ *\n+ *        is the same as\n+ *\n+ *            SELECT * FROM R AS c2, S AS c1, (SELECT T.* FROM T WHERE T.x = c2 AND T.y = c1)\n+ *\n+ *    This observation is identical to the one in example 1. Due to the commutative nature we also would like to\n+ *    be able to realize that even this is the same:\n+ *\n+ *    SELECT * FROM R AS c1, S AS c2, (SELECT T.* FROM T WHERE T.x = c2 AND T.y = c1)\n+ *\n+ * In any case we need to keep track of what's currently considered bound and equal while we traverse the query graph.\n+ * When we descend into correlated sub-graphs during an algorithm while we e.g. determine {@link Correlated#resultEquals}\n+ * we need to have all outside references bound and mapped in some way: Should we treat c1 on the left as c2 on the right\n+ * or the other way around? It is the job of an object of this class to facilitate the construction and the lookup of\n+ * these mappings. Algorithms walking the graph make use of this map, construct and reconstruct assumed equality while\n+ * traversing e.g. permutations of possible mappings.\n+ *\n+ * Another \n+ *\n+ * Note: This class is immutable, all perceived \"mutations\" cause a new object to be created.\n+ *\n+ */\n+public class AliasMap {\n+    private final ImmutableBiMap<CorrelationIdentifier, CorrelationIdentifier> map;\n+\n+    private AliasMap(final ImmutableBiMap<CorrelationIdentifier, CorrelationIdentifier> map) {\n+        this.map = map;\n+    }\n+\n+    public boolean containsSource(@Nonnull final CorrelationIdentifier alias) {\n+        return map.containsKey(alias);\n+    }\n+\n+    public boolean containsTarget(@Nonnull final CorrelationIdentifier alias) {\n+        return map.containsValue(alias);\n+    }\n+\n+    /**\n+     * Returns the set of {@link CorrelationIdentifier}s that are mapped by this {@code AliasMap}.\n+     * @return a set of {@link CorrelationIdentifier}s that this map contains mappings for.\n+     */\n+    @Nonnull\n+    public Set<CorrelationIdentifier> sources() {\n+        return map.keySet();\n+    }\n+\n+    /**\n+     * Returns the set of all {@link CorrelationIdentifier}s that this map maps to using the set of {@link CorrelationIdentifier}s\n+     * returned by {@link #sources()}.\n+     * @return a set of {@link CorrelationIdentifier}s that this map maps to.\n+     */\n+    @Nonnull\n+    public Set<CorrelationIdentifier> targets() {\n+        return map.values();\n+    }\n+\n+    public int size() {\n+        return map.size();\n+    }\n+\n+    @Nonnull\n+    public Builder derived() {\n+        return new Builder(map);\n+    }\n+\n+    @Nonnull\n+    public Builder derived(int expectedAdditionalElements) {\n+        return new Builder(size() + expectedAdditionalElements).putAll(this);\n+    }\n+\n+    /**\n+     * Compute the composition of two {@link AliasMap}s.\n+     * @param other second alias map\n+     * @return a translation map that maps {@code a -> c} for {@code a, b, c} if {@code a -> b} is contained in {@code first} and {@code b -> c} is contained in {@code second},\n+     *         {@code a -> b} for {@code a, b} if {@code a -> b} in {@code first} and no {@code b -> x} for any {@code x} is contained in {@code second}, and\n+     *         {@code b -> c} for {@code b, c} if {@code a -> x} for any {@code x} is not contained in {@code first} and {@code b -> c} is contained in {@code second}\n+     */\n+    @Nonnull\n+    public AliasMap compose(@Nonnull final AliasMap other) {\n+        final Builder builder =\n+                AliasMap.builder(size() + other.size());\n+\n+        final ImmutableBiMap<CorrelationIdentifier, CorrelationIdentifier> otherMap = other.map;\n+        this.map.forEach((key, value) -> builder.put(key, otherMap.getOrDefault(value, value)));\n+\n+        otherMap.forEach((key, value) -> {\n+            if (!containsSource(key)) {\n+                builder.put(key, value);\n+            }\n+        });\n+        return builder.build();\n+    }\n+\n+    /**\n+     * Method to match up the given sets of correlation identifiers (using an already given equivalence map).\n+     *\n+     * @param aliases aliases of _this_ set", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b64d4eb60de5c3a4be0b4dc0f779ff2f15e47355"}, "originalPosition": 194}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkwMTkwMjA4OnYy", "diffSide": "RIGHT", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/AliasMap.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wM1QyMDoyODo1NFrOG7HqXw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNFQwMDoyNjo1NFrOG7M6Iw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDY0NDcwMw==", "bodyText": "Can we pull this into a named (inner) class? I think it'll ease debugging if this someday shows up in a stack trace or something like that.", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/988#discussion_r464644703", "createdAt": "2020-08-03T20:28:54Z", "author": {"login": "nschiefer"}, "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/AliasMap.java", "diffHunk": "@@ -0,0 +1,369 @@\n+/*\n+ * AliasMap.java\n+ *\n+ * This source file is part of the FoundationDB open source project\n+ *\n+ * Copyright 2015-2020 Apple Inc. and the FoundationDB project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.apple.foundationdb.record.query.plan.temp;\n+\n+import com.google.common.base.Verify;\n+import com.google.common.collect.AbstractIterator;\n+import com.google.common.collect.BiMap;\n+import com.google.common.collect.HashBiMap;\n+import com.google.common.collect.ImmutableBiMap;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.Streams;\n+import org.apache.commons.lang3.tuple.Pair;\n+\n+import javax.annotation.Nonnull;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.function.Function;\n+\n+/**\n+ * This class encapsulates mappings between {@link CorrelationIdentifier}s and helpers to create and maintain\n+ * these mappings.\n+ *\n+ * While various operations or in general algorithms traverse the query graph(s) it is important to keep track of\n+ * what alias (of a quantifier) should be considered to what other alias (of another quantifier). A quantifier\n+ * ({@link Quantifier} is referred to via {@link CorrelationIdentifier}. In this way there are no direct pointers\n+ * to objects which is desirable while the graph is mutated through transformations. At various points during\n+ * the planning of a query we may want to determine e.g. if a sub-graph would produce the same result as some other\n+ * sub-graph. Similarly, we may want to determine whether a sub-graph is already properly memoized or not. In general,\n+ * we need to theorize if two sub-graphs are related to each other (usually equality but also subsumption, etc.)\n+ *\n+ * All of that is rather straightforward if both sub-graphs are completely uncorrelated and therefore independent to\n+ * each other, to some other record producer, or even to some external parameter that is being passed in. In these\n+ * cases the {@code AliasMap} implemented here would effectively be trivial, i.e. the map would be\n+ * conceptually empty.\n+ *\n+ * There are cases, however, that need some care to establish the relationships mentioned before.\n+ *\n+ * Example 1:\n+ *    sub graph 1\n+ *        SELECT T.* FROM T WHERE T.x = c1\n+ *\n+ *    sub graph 2\n+ *        SELECT T.* FROM T WHERE T.x = c2\n+ *\n+ *    We wold like to establish, if these graphs are equal or not. Both of them are not complete, i.e. we wouldn't\n+ *    be able to execute them as is. If we asked if these sub graphs where equal, we certainly would need to say that\n+ *    that depends. If they, however, are embedded in some surrounding query that binds c1 and c2 respectively, we\n+ *    would be able to say if in the greater context of the surrounding query these sub query do the same thing.\n+ *\n+ *            SELECT * FROM R AS c1, (SELECT T.* FROM T WHERE T.x = c1)\n+ *\n+ *        is the same as\n+ *\n+ *            SELECT * FROM R AS c2, (SELECT T.* FROM T WHERE T.x = c2)\n+ *\n+ *    whereas\n+ *            SELECT * FROM R AS c1, (SELECT T.* FROM T WHERE T.x = c1)\n+ *\n+ *        is definitely not the same as\n+ *\n+ *            SELECT * FROM S AS c2, (SELECT T.* FROM T WHERE T.x = c2)\n+ *\n+ *    In short, a sub-graph can only be considered equal to another sub-graph if we assume an equality over their\n+ *    correlated references. In other words the sub-graphs define two functions f(x) and g(y). While we can determine\n+ *    if f and g are structurally equivalent we con only determine actual result equivalence if we assume x = y for\n+ *    the entire domain of x and y.\n+ *\n+ * Example 2:\n+ *    sub graph 1\n+ *        SELECT T.* FROM T WHERE T.x = c1 AND T.y = c2\n+ *\n+ *    sub graph 2\n+ *        SELECT T.* FROM T WHERE T.x = c2 AND T.y = c1\n+ *\n+ *    This scenario is somewhat more complicated as it offers more degrees of freedom.\n+ *\n+ *            SELECT * FROM R AS c1, S AS c2, (SELECT T.* FROM T WHERE T.x = c1 AND T.y = c2)\n+ *\n+ *        is the same as\n+ *\n+ *            SELECT * FROM R AS c2, S AS c1, (SELECT T.* FROM T WHERE T.x = c2 AND T.y = c1)\n+ *\n+ *    This observation is identical to the one in example 1. Due to the commutative nature we also would like to\n+ *    be able to realize that even this is the same:\n+ *\n+ *    SELECT * FROM R AS c1, S AS c2, (SELECT T.* FROM T WHERE T.x = c2 AND T.y = c1)\n+ *\n+ * In any case we need to keep track of what's currently considered bound and equal while we traverse the query graph.\n+ * When we descend into correlated sub-graphs during an algorithm while we e.g. determine {@link Correlated#resultEquals}\n+ * we need to have all outside references bound and mapped in some way: Should we treat c1 on the left as c2 on the right\n+ * or the other way around? It is the job of an object of this class to facilitate the construction and the lookup of\n+ * these mappings. Algorithms walking the graph make use of this map, construct and reconstruct assumed equality while\n+ * traversing e.g. permutations of possible mappings.\n+ *\n+ * Another \n+ *\n+ * Note: This class is immutable, all perceived \"mutations\" cause a new object to be created.\n+ *\n+ */\n+public class AliasMap {\n+    private final ImmutableBiMap<CorrelationIdentifier, CorrelationIdentifier> map;\n+\n+    private AliasMap(final ImmutableBiMap<CorrelationIdentifier, CorrelationIdentifier> map) {\n+        this.map = map;\n+    }\n+\n+    public boolean containsSource(@Nonnull final CorrelationIdentifier alias) {\n+        return map.containsKey(alias);\n+    }\n+\n+    public boolean containsTarget(@Nonnull final CorrelationIdentifier alias) {\n+        return map.containsValue(alias);\n+    }\n+\n+    /**\n+     * Returns the set of {@link CorrelationIdentifier}s that are mapped by this {@code AliasMap}.\n+     * @return a set of {@link CorrelationIdentifier}s that this map contains mappings for.\n+     */\n+    @Nonnull\n+    public Set<CorrelationIdentifier> sources() {\n+        return map.keySet();\n+    }\n+\n+    /**\n+     * Returns the set of all {@link CorrelationIdentifier}s that this map maps to using the set of {@link CorrelationIdentifier}s\n+     * returned by {@link #sources()}.\n+     * @return a set of {@link CorrelationIdentifier}s that this map maps to.\n+     */\n+    @Nonnull\n+    public Set<CorrelationIdentifier> targets() {\n+        return map.values();\n+    }\n+\n+    public int size() {\n+        return map.size();\n+    }\n+\n+    @Nonnull\n+    public Builder derived() {\n+        return new Builder(map);\n+    }\n+\n+    @Nonnull\n+    public Builder derived(int expectedAdditionalElements) {\n+        return new Builder(size() + expectedAdditionalElements).putAll(this);\n+    }\n+\n+    /**\n+     * Compute the composition of two {@link AliasMap}s.\n+     * @param other second alias map\n+     * @return a translation map that maps {@code a -> c} for {@code a, b, c} if {@code a -> b} is contained in {@code first} and {@code b -> c} is contained in {@code second},\n+     *         {@code a -> b} for {@code a, b} if {@code a -> b} in {@code first} and no {@code b -> x} for any {@code x} is contained in {@code second}, and\n+     *         {@code b -> c} for {@code b, c} if {@code a -> x} for any {@code x} is not contained in {@code first} and {@code b -> c} is contained in {@code second}\n+     */\n+    @Nonnull\n+    public AliasMap compose(@Nonnull final AliasMap other) {\n+        final Builder builder =\n+                AliasMap.builder(size() + other.size());\n+\n+        final ImmutableBiMap<CorrelationIdentifier, CorrelationIdentifier> otherMap = other.map;\n+        this.map.forEach((key, value) -> builder.put(key, otherMap.getOrDefault(value, value)));\n+\n+        otherMap.forEach((key, value) -> {\n+            if (!containsSource(key)) {\n+                builder.put(key, value);\n+            }\n+        });\n+        return builder.build();\n+    }\n+\n+    /**\n+     * Method to match up the given sets of correlation identifiers (using an already given equivalence map).\n+     *\n+     * @param aliases aliases of _this_ set\n+     * @param dependsOnFn function yielding the dependsOn set for an alias of _this_ set\n+     * @param otherAliases aliases of _the other_ set\n+     * @param otherDependsOnFn function yielding the dependsOn set for an alias of _the other_ set\n+     * @param canCorrelate {@code true} if _this_ set (and the _other_ set) can be the source of correlations themselves.\n+     * @param predicate that tests if two aliases match\n+     * @return An iterable iterating alias maps containing mappings from the correlation identifiers ({@code aliases}) to\n+     *         correlations identifiers {@code otherAliases} according to the given predicate. Note that these mappings\n+     *         are bijective and can therefore be inverted.\n+     */\n+    @SuppressWarnings({\"squid:S135\"})\n+    @Nonnull\n+    public Iterable<AliasMap> match(@Nonnull final Set<CorrelationIdentifier> aliases,\n+                                    @Nonnull final Function<CorrelationIdentifier, Set<CorrelationIdentifier>> dependsOnFn,\n+                                    @Nonnull final Set<CorrelationIdentifier> otherAliases,\n+                                    @Nonnull final Function<CorrelationIdentifier, Set<CorrelationIdentifier>> otherDependsOnFn,\n+                                    final boolean canCorrelate,\n+                                    @Nonnull final MatchingIdPredicate predicate) {\n+        if (aliases.size() != otherAliases.size()) {\n+            return ImmutableList.of();\n+        }\n+\n+        if (aliases.isEmpty()) {\n+            return ImmutableList.of(empty());\n+        }\n+\n+        //\n+        // We do not know which id in \"this\" maps to which in \"other\". In fact, we cannot know as it is\n+        // intentionally modeled this way. We need to find _a_ feasible ordering that matches. In reality, the\n+        // quantifiers owned by an expression imposes a more or less a complete order leaving no room for many\n+        // permutations among unrelated quantifiers. In the worst case, we must enumerate them all. Luckily, most\n+        // algorithms for children have short-circuit semantics, so the uninteresting case where sub-graphs underneath\n+        // quantifiers do not match should be skipped quickly.\n+        //\n+        // get _a_ topologically-sound permutation from other\n+        final Optional<List<CorrelationIdentifier>> otherOrderedOptional =\n+                TopologicalSort.anyTopologicalOrderPermutation(\n+                        otherAliases,\n+                        alias -> Objects.requireNonNull(otherDependsOnFn.apply(alias)));\n+\n+        // There should always be a topologically sound ordering that we can use.\n+        Verify.verify(otherOrderedOptional.isPresent());\n+\n+        final List<CorrelationIdentifier> otherOrdered = otherOrderedOptional.get();\n+\n+        final TopologicalSort.TopologicalOrderPermutationIterable<CorrelationIdentifier> iterable =\n+                TopologicalSort.topologicalOrderPermutations(\n+                        aliases,\n+                        alias -> Objects.requireNonNull(dependsOnFn.apply(alias)));\n+\n+        return () -> {\n+            final TopologicalSort.TopologicalOrderPermutationIterator<CorrelationIdentifier> iterator = iterable.iterator();\n+\n+            return new AbstractIterator<AliasMap>() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b64d4eb60de5c3a4be0b4dc0f779ff2f15e47355"}, "originalPosition": 247}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDczMDY1OQ==", "bodyText": "The follow up to this PR uses this approach much more heavily. I would prefer to go with it for now and then rethink this if necessary.", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/988#discussion_r464730659", "createdAt": "2020-08-04T00:26:54Z", "author": {"login": "normen662"}, "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/AliasMap.java", "diffHunk": "@@ -0,0 +1,369 @@\n+/*\n+ * AliasMap.java\n+ *\n+ * This source file is part of the FoundationDB open source project\n+ *\n+ * Copyright 2015-2020 Apple Inc. and the FoundationDB project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.apple.foundationdb.record.query.plan.temp;\n+\n+import com.google.common.base.Verify;\n+import com.google.common.collect.AbstractIterator;\n+import com.google.common.collect.BiMap;\n+import com.google.common.collect.HashBiMap;\n+import com.google.common.collect.ImmutableBiMap;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.Streams;\n+import org.apache.commons.lang3.tuple.Pair;\n+\n+import javax.annotation.Nonnull;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.function.Function;\n+\n+/**\n+ * This class encapsulates mappings between {@link CorrelationIdentifier}s and helpers to create and maintain\n+ * these mappings.\n+ *\n+ * While various operations or in general algorithms traverse the query graph(s) it is important to keep track of\n+ * what alias (of a quantifier) should be considered to what other alias (of another quantifier). A quantifier\n+ * ({@link Quantifier} is referred to via {@link CorrelationIdentifier}. In this way there are no direct pointers\n+ * to objects which is desirable while the graph is mutated through transformations. At various points during\n+ * the planning of a query we may want to determine e.g. if a sub-graph would produce the same result as some other\n+ * sub-graph. Similarly, we may want to determine whether a sub-graph is already properly memoized or not. In general,\n+ * we need to theorize if two sub-graphs are related to each other (usually equality but also subsumption, etc.)\n+ *\n+ * All of that is rather straightforward if both sub-graphs are completely uncorrelated and therefore independent to\n+ * each other, to some other record producer, or even to some external parameter that is being passed in. In these\n+ * cases the {@code AliasMap} implemented here would effectively be trivial, i.e. the map would be\n+ * conceptually empty.\n+ *\n+ * There are cases, however, that need some care to establish the relationships mentioned before.\n+ *\n+ * Example 1:\n+ *    sub graph 1\n+ *        SELECT T.* FROM T WHERE T.x = c1\n+ *\n+ *    sub graph 2\n+ *        SELECT T.* FROM T WHERE T.x = c2\n+ *\n+ *    We wold like to establish, if these graphs are equal or not. Both of them are not complete, i.e. we wouldn't\n+ *    be able to execute them as is. If we asked if these sub graphs where equal, we certainly would need to say that\n+ *    that depends. If they, however, are embedded in some surrounding query that binds c1 and c2 respectively, we\n+ *    would be able to say if in the greater context of the surrounding query these sub query do the same thing.\n+ *\n+ *            SELECT * FROM R AS c1, (SELECT T.* FROM T WHERE T.x = c1)\n+ *\n+ *        is the same as\n+ *\n+ *            SELECT * FROM R AS c2, (SELECT T.* FROM T WHERE T.x = c2)\n+ *\n+ *    whereas\n+ *            SELECT * FROM R AS c1, (SELECT T.* FROM T WHERE T.x = c1)\n+ *\n+ *        is definitely not the same as\n+ *\n+ *            SELECT * FROM S AS c2, (SELECT T.* FROM T WHERE T.x = c2)\n+ *\n+ *    In short, a sub-graph can only be considered equal to another sub-graph if we assume an equality over their\n+ *    correlated references. In other words the sub-graphs define two functions f(x) and g(y). While we can determine\n+ *    if f and g are structurally equivalent we con only determine actual result equivalence if we assume x = y for\n+ *    the entire domain of x and y.\n+ *\n+ * Example 2:\n+ *    sub graph 1\n+ *        SELECT T.* FROM T WHERE T.x = c1 AND T.y = c2\n+ *\n+ *    sub graph 2\n+ *        SELECT T.* FROM T WHERE T.x = c2 AND T.y = c1\n+ *\n+ *    This scenario is somewhat more complicated as it offers more degrees of freedom.\n+ *\n+ *            SELECT * FROM R AS c1, S AS c2, (SELECT T.* FROM T WHERE T.x = c1 AND T.y = c2)\n+ *\n+ *        is the same as\n+ *\n+ *            SELECT * FROM R AS c2, S AS c1, (SELECT T.* FROM T WHERE T.x = c2 AND T.y = c1)\n+ *\n+ *    This observation is identical to the one in example 1. Due to the commutative nature we also would like to\n+ *    be able to realize that even this is the same:\n+ *\n+ *    SELECT * FROM R AS c1, S AS c2, (SELECT T.* FROM T WHERE T.x = c2 AND T.y = c1)\n+ *\n+ * In any case we need to keep track of what's currently considered bound and equal while we traverse the query graph.\n+ * When we descend into correlated sub-graphs during an algorithm while we e.g. determine {@link Correlated#resultEquals}\n+ * we need to have all outside references bound and mapped in some way: Should we treat c1 on the left as c2 on the right\n+ * or the other way around? It is the job of an object of this class to facilitate the construction and the lookup of\n+ * these mappings. Algorithms walking the graph make use of this map, construct and reconstruct assumed equality while\n+ * traversing e.g. permutations of possible mappings.\n+ *\n+ * Another \n+ *\n+ * Note: This class is immutable, all perceived \"mutations\" cause a new object to be created.\n+ *\n+ */\n+public class AliasMap {\n+    private final ImmutableBiMap<CorrelationIdentifier, CorrelationIdentifier> map;\n+\n+    private AliasMap(final ImmutableBiMap<CorrelationIdentifier, CorrelationIdentifier> map) {\n+        this.map = map;\n+    }\n+\n+    public boolean containsSource(@Nonnull final CorrelationIdentifier alias) {\n+        return map.containsKey(alias);\n+    }\n+\n+    public boolean containsTarget(@Nonnull final CorrelationIdentifier alias) {\n+        return map.containsValue(alias);\n+    }\n+\n+    /**\n+     * Returns the set of {@link CorrelationIdentifier}s that are mapped by this {@code AliasMap}.\n+     * @return a set of {@link CorrelationIdentifier}s that this map contains mappings for.\n+     */\n+    @Nonnull\n+    public Set<CorrelationIdentifier> sources() {\n+        return map.keySet();\n+    }\n+\n+    /**\n+     * Returns the set of all {@link CorrelationIdentifier}s that this map maps to using the set of {@link CorrelationIdentifier}s\n+     * returned by {@link #sources()}.\n+     * @return a set of {@link CorrelationIdentifier}s that this map maps to.\n+     */\n+    @Nonnull\n+    public Set<CorrelationIdentifier> targets() {\n+        return map.values();\n+    }\n+\n+    public int size() {\n+        return map.size();\n+    }\n+\n+    @Nonnull\n+    public Builder derived() {\n+        return new Builder(map);\n+    }\n+\n+    @Nonnull\n+    public Builder derived(int expectedAdditionalElements) {\n+        return new Builder(size() + expectedAdditionalElements).putAll(this);\n+    }\n+\n+    /**\n+     * Compute the composition of two {@link AliasMap}s.\n+     * @param other second alias map\n+     * @return a translation map that maps {@code a -> c} for {@code a, b, c} if {@code a -> b} is contained in {@code first} and {@code b -> c} is contained in {@code second},\n+     *         {@code a -> b} for {@code a, b} if {@code a -> b} in {@code first} and no {@code b -> x} for any {@code x} is contained in {@code second}, and\n+     *         {@code b -> c} for {@code b, c} if {@code a -> x} for any {@code x} is not contained in {@code first} and {@code b -> c} is contained in {@code second}\n+     */\n+    @Nonnull\n+    public AliasMap compose(@Nonnull final AliasMap other) {\n+        final Builder builder =\n+                AliasMap.builder(size() + other.size());\n+\n+        final ImmutableBiMap<CorrelationIdentifier, CorrelationIdentifier> otherMap = other.map;\n+        this.map.forEach((key, value) -> builder.put(key, otherMap.getOrDefault(value, value)));\n+\n+        otherMap.forEach((key, value) -> {\n+            if (!containsSource(key)) {\n+                builder.put(key, value);\n+            }\n+        });\n+        return builder.build();\n+    }\n+\n+    /**\n+     * Method to match up the given sets of correlation identifiers (using an already given equivalence map).\n+     *\n+     * @param aliases aliases of _this_ set\n+     * @param dependsOnFn function yielding the dependsOn set for an alias of _this_ set\n+     * @param otherAliases aliases of _the other_ set\n+     * @param otherDependsOnFn function yielding the dependsOn set for an alias of _the other_ set\n+     * @param canCorrelate {@code true} if _this_ set (and the _other_ set) can be the source of correlations themselves.\n+     * @param predicate that tests if two aliases match\n+     * @return An iterable iterating alias maps containing mappings from the correlation identifiers ({@code aliases}) to\n+     *         correlations identifiers {@code otherAliases} according to the given predicate. Note that these mappings\n+     *         are bijective and can therefore be inverted.\n+     */\n+    @SuppressWarnings({\"squid:S135\"})\n+    @Nonnull\n+    public Iterable<AliasMap> match(@Nonnull final Set<CorrelationIdentifier> aliases,\n+                                    @Nonnull final Function<CorrelationIdentifier, Set<CorrelationIdentifier>> dependsOnFn,\n+                                    @Nonnull final Set<CorrelationIdentifier> otherAliases,\n+                                    @Nonnull final Function<CorrelationIdentifier, Set<CorrelationIdentifier>> otherDependsOnFn,\n+                                    final boolean canCorrelate,\n+                                    @Nonnull final MatchingIdPredicate predicate) {\n+        if (aliases.size() != otherAliases.size()) {\n+            return ImmutableList.of();\n+        }\n+\n+        if (aliases.isEmpty()) {\n+            return ImmutableList.of(empty());\n+        }\n+\n+        //\n+        // We do not know which id in \"this\" maps to which in \"other\". In fact, we cannot know as it is\n+        // intentionally modeled this way. We need to find _a_ feasible ordering that matches. In reality, the\n+        // quantifiers owned by an expression imposes a more or less a complete order leaving no room for many\n+        // permutations among unrelated quantifiers. In the worst case, we must enumerate them all. Luckily, most\n+        // algorithms for children have short-circuit semantics, so the uninteresting case where sub-graphs underneath\n+        // quantifiers do not match should be skipped quickly.\n+        //\n+        // get _a_ topologically-sound permutation from other\n+        final Optional<List<CorrelationIdentifier>> otherOrderedOptional =\n+                TopologicalSort.anyTopologicalOrderPermutation(\n+                        otherAliases,\n+                        alias -> Objects.requireNonNull(otherDependsOnFn.apply(alias)));\n+\n+        // There should always be a topologically sound ordering that we can use.\n+        Verify.verify(otherOrderedOptional.isPresent());\n+\n+        final List<CorrelationIdentifier> otherOrdered = otherOrderedOptional.get();\n+\n+        final TopologicalSort.TopologicalOrderPermutationIterable<CorrelationIdentifier> iterable =\n+                TopologicalSort.topologicalOrderPermutations(\n+                        aliases,\n+                        alias -> Objects.requireNonNull(dependsOnFn.apply(alias)));\n+\n+        return () -> {\n+            final TopologicalSort.TopologicalOrderPermutationIterator<CorrelationIdentifier> iterator = iterable.iterator();\n+\n+            return new AbstractIterator<AliasMap>() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDY0NDcwMw=="}, "originalCommit": {"oid": "b64d4eb60de5c3a4be0b4dc0f779ff2f15e47355"}, "originalPosition": 247}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkwMTkwMzk4OnYy", "diffSide": "RIGHT", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/AliasMap.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wM1QyMDoyOTozMFrOG7Hrfg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wM1QyMDoyOTozMFrOG7Hrfg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDY0NDk5MA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public static AliasMap identitiesFor(final Set<CorrelationIdentifier> correlationIdentifiers) {\n          \n          \n            \n                public static AliasMap identitiesFor(@Nonnull final Set<CorrelationIdentifier> correlationIdentifiers) {", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/988#discussion_r464644990", "createdAt": "2020-08-03T20:29:30Z", "author": {"login": "nschiefer"}, "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/AliasMap.java", "diffHunk": "@@ -0,0 +1,369 @@\n+/*\n+ * AliasMap.java\n+ *\n+ * This source file is part of the FoundationDB open source project\n+ *\n+ * Copyright 2015-2020 Apple Inc. and the FoundationDB project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.apple.foundationdb.record.query.plan.temp;\n+\n+import com.google.common.base.Verify;\n+import com.google.common.collect.AbstractIterator;\n+import com.google.common.collect.BiMap;\n+import com.google.common.collect.HashBiMap;\n+import com.google.common.collect.ImmutableBiMap;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.Streams;\n+import org.apache.commons.lang3.tuple.Pair;\n+\n+import javax.annotation.Nonnull;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.function.Function;\n+\n+/**\n+ * This class encapsulates mappings between {@link CorrelationIdentifier}s and helpers to create and maintain\n+ * these mappings.\n+ *\n+ * While various operations or in general algorithms traverse the query graph(s) it is important to keep track of\n+ * what alias (of a quantifier) should be considered to what other alias (of another quantifier). A quantifier\n+ * ({@link Quantifier} is referred to via {@link CorrelationIdentifier}. In this way there are no direct pointers\n+ * to objects which is desirable while the graph is mutated through transformations. At various points during\n+ * the planning of a query we may want to determine e.g. if a sub-graph would produce the same result as some other\n+ * sub-graph. Similarly, we may want to determine whether a sub-graph is already properly memoized or not. In general,\n+ * we need to theorize if two sub-graphs are related to each other (usually equality but also subsumption, etc.)\n+ *\n+ * All of that is rather straightforward if both sub-graphs are completely uncorrelated and therefore independent to\n+ * each other, to some other record producer, or even to some external parameter that is being passed in. In these\n+ * cases the {@code AliasMap} implemented here would effectively be trivial, i.e. the map would be\n+ * conceptually empty.\n+ *\n+ * There are cases, however, that need some care to establish the relationships mentioned before.\n+ *\n+ * Example 1:\n+ *    sub graph 1\n+ *        SELECT T.* FROM T WHERE T.x = c1\n+ *\n+ *    sub graph 2\n+ *        SELECT T.* FROM T WHERE T.x = c2\n+ *\n+ *    We wold like to establish, if these graphs are equal or not. Both of them are not complete, i.e. we wouldn't\n+ *    be able to execute them as is. If we asked if these sub graphs where equal, we certainly would need to say that\n+ *    that depends. If they, however, are embedded in some surrounding query that binds c1 and c2 respectively, we\n+ *    would be able to say if in the greater context of the surrounding query these sub query do the same thing.\n+ *\n+ *            SELECT * FROM R AS c1, (SELECT T.* FROM T WHERE T.x = c1)\n+ *\n+ *        is the same as\n+ *\n+ *            SELECT * FROM R AS c2, (SELECT T.* FROM T WHERE T.x = c2)\n+ *\n+ *    whereas\n+ *            SELECT * FROM R AS c1, (SELECT T.* FROM T WHERE T.x = c1)\n+ *\n+ *        is definitely not the same as\n+ *\n+ *            SELECT * FROM S AS c2, (SELECT T.* FROM T WHERE T.x = c2)\n+ *\n+ *    In short, a sub-graph can only be considered equal to another sub-graph if we assume an equality over their\n+ *    correlated references. In other words the sub-graphs define two functions f(x) and g(y). While we can determine\n+ *    if f and g are structurally equivalent we con only determine actual result equivalence if we assume x = y for\n+ *    the entire domain of x and y.\n+ *\n+ * Example 2:\n+ *    sub graph 1\n+ *        SELECT T.* FROM T WHERE T.x = c1 AND T.y = c2\n+ *\n+ *    sub graph 2\n+ *        SELECT T.* FROM T WHERE T.x = c2 AND T.y = c1\n+ *\n+ *    This scenario is somewhat more complicated as it offers more degrees of freedom.\n+ *\n+ *            SELECT * FROM R AS c1, S AS c2, (SELECT T.* FROM T WHERE T.x = c1 AND T.y = c2)\n+ *\n+ *        is the same as\n+ *\n+ *            SELECT * FROM R AS c2, S AS c1, (SELECT T.* FROM T WHERE T.x = c2 AND T.y = c1)\n+ *\n+ *    This observation is identical to the one in example 1. Due to the commutative nature we also would like to\n+ *    be able to realize that even this is the same:\n+ *\n+ *    SELECT * FROM R AS c1, S AS c2, (SELECT T.* FROM T WHERE T.x = c2 AND T.y = c1)\n+ *\n+ * In any case we need to keep track of what's currently considered bound and equal while we traverse the query graph.\n+ * When we descend into correlated sub-graphs during an algorithm while we e.g. determine {@link Correlated#resultEquals}\n+ * we need to have all outside references bound and mapped in some way: Should we treat c1 on the left as c2 on the right\n+ * or the other way around? It is the job of an object of this class to facilitate the construction and the lookup of\n+ * these mappings. Algorithms walking the graph make use of this map, construct and reconstruct assumed equality while\n+ * traversing e.g. permutations of possible mappings.\n+ *\n+ * Another \n+ *\n+ * Note: This class is immutable, all perceived \"mutations\" cause a new object to be created.\n+ *\n+ */\n+public class AliasMap {\n+    private final ImmutableBiMap<CorrelationIdentifier, CorrelationIdentifier> map;\n+\n+    private AliasMap(final ImmutableBiMap<CorrelationIdentifier, CorrelationIdentifier> map) {\n+        this.map = map;\n+    }\n+\n+    public boolean containsSource(@Nonnull final CorrelationIdentifier alias) {\n+        return map.containsKey(alias);\n+    }\n+\n+    public boolean containsTarget(@Nonnull final CorrelationIdentifier alias) {\n+        return map.containsValue(alias);\n+    }\n+\n+    /**\n+     * Returns the set of {@link CorrelationIdentifier}s that are mapped by this {@code AliasMap}.\n+     * @return a set of {@link CorrelationIdentifier}s that this map contains mappings for.\n+     */\n+    @Nonnull\n+    public Set<CorrelationIdentifier> sources() {\n+        return map.keySet();\n+    }\n+\n+    /**\n+     * Returns the set of all {@link CorrelationIdentifier}s that this map maps to using the set of {@link CorrelationIdentifier}s\n+     * returned by {@link #sources()}.\n+     * @return a set of {@link CorrelationIdentifier}s that this map maps to.\n+     */\n+    @Nonnull\n+    public Set<CorrelationIdentifier> targets() {\n+        return map.values();\n+    }\n+\n+    public int size() {\n+        return map.size();\n+    }\n+\n+    @Nonnull\n+    public Builder derived() {\n+        return new Builder(map);\n+    }\n+\n+    @Nonnull\n+    public Builder derived(int expectedAdditionalElements) {\n+        return new Builder(size() + expectedAdditionalElements).putAll(this);\n+    }\n+\n+    /**\n+     * Compute the composition of two {@link AliasMap}s.\n+     * @param other second alias map\n+     * @return a translation map that maps {@code a -> c} for {@code a, b, c} if {@code a -> b} is contained in {@code first} and {@code b -> c} is contained in {@code second},\n+     *         {@code a -> b} for {@code a, b} if {@code a -> b} in {@code first} and no {@code b -> x} for any {@code x} is contained in {@code second}, and\n+     *         {@code b -> c} for {@code b, c} if {@code a -> x} for any {@code x} is not contained in {@code first} and {@code b -> c} is contained in {@code second}\n+     */\n+    @Nonnull\n+    public AliasMap compose(@Nonnull final AliasMap other) {\n+        final Builder builder =\n+                AliasMap.builder(size() + other.size());\n+\n+        final ImmutableBiMap<CorrelationIdentifier, CorrelationIdentifier> otherMap = other.map;\n+        this.map.forEach((key, value) -> builder.put(key, otherMap.getOrDefault(value, value)));\n+\n+        otherMap.forEach((key, value) -> {\n+            if (!containsSource(key)) {\n+                builder.put(key, value);\n+            }\n+        });\n+        return builder.build();\n+    }\n+\n+    /**\n+     * Method to match up the given sets of correlation identifiers (using an already given equivalence map).\n+     *\n+     * @param aliases aliases of _this_ set\n+     * @param dependsOnFn function yielding the dependsOn set for an alias of _this_ set\n+     * @param otherAliases aliases of _the other_ set\n+     * @param otherDependsOnFn function yielding the dependsOn set for an alias of _the other_ set\n+     * @param canCorrelate {@code true} if _this_ set (and the _other_ set) can be the source of correlations themselves.\n+     * @param predicate that tests if two aliases match\n+     * @return An iterable iterating alias maps containing mappings from the correlation identifiers ({@code aliases}) to\n+     *         correlations identifiers {@code otherAliases} according to the given predicate. Note that these mappings\n+     *         are bijective and can therefore be inverted.\n+     */\n+    @SuppressWarnings({\"squid:S135\"})\n+    @Nonnull\n+    public Iterable<AliasMap> match(@Nonnull final Set<CorrelationIdentifier> aliases,\n+                                    @Nonnull final Function<CorrelationIdentifier, Set<CorrelationIdentifier>> dependsOnFn,\n+                                    @Nonnull final Set<CorrelationIdentifier> otherAliases,\n+                                    @Nonnull final Function<CorrelationIdentifier, Set<CorrelationIdentifier>> otherDependsOnFn,\n+                                    final boolean canCorrelate,\n+                                    @Nonnull final MatchingIdPredicate predicate) {\n+        if (aliases.size() != otherAliases.size()) {\n+            return ImmutableList.of();\n+        }\n+\n+        if (aliases.isEmpty()) {\n+            return ImmutableList.of(empty());\n+        }\n+\n+        //\n+        // We do not know which id in \"this\" maps to which in \"other\". In fact, we cannot know as it is\n+        // intentionally modeled this way. We need to find _a_ feasible ordering that matches. In reality, the\n+        // quantifiers owned by an expression imposes a more or less a complete order leaving no room for many\n+        // permutations among unrelated quantifiers. In the worst case, we must enumerate them all. Luckily, most\n+        // algorithms for children have short-circuit semantics, so the uninteresting case where sub-graphs underneath\n+        // quantifiers do not match should be skipped quickly.\n+        //\n+        // get _a_ topologically-sound permutation from other\n+        final Optional<List<CorrelationIdentifier>> otherOrderedOptional =\n+                TopologicalSort.anyTopologicalOrderPermutation(\n+                        otherAliases,\n+                        alias -> Objects.requireNonNull(otherDependsOnFn.apply(alias)));\n+\n+        // There should always be a topologically sound ordering that we can use.\n+        Verify.verify(otherOrderedOptional.isPresent());\n+\n+        final List<CorrelationIdentifier> otherOrdered = otherOrderedOptional.get();\n+\n+        final TopologicalSort.TopologicalOrderPermutationIterable<CorrelationIdentifier> iterable =\n+                TopologicalSort.topologicalOrderPermutations(\n+                        aliases,\n+                        alias -> Objects.requireNonNull(dependsOnFn.apply(alias)));\n+\n+        return () -> {\n+            final TopologicalSort.TopologicalOrderPermutationIterator<CorrelationIdentifier> iterator = iterable.iterator();\n+\n+            return new AbstractIterator<AliasMap>() {\n+                @Override\n+                protected AliasMap computeNext() {\n+                    while (iterator.hasNext()) {\n+                        final Builder equivalenceMapBuilder = derived(aliases.size());\n+\n+                        final List<CorrelationIdentifier> ordered = iterator.next();\n+                        int i;\n+                        for (i = 0; i < aliases.size(); i++) {\n+                            final CorrelationIdentifier alias = ordered.get(i);\n+                            final CorrelationIdentifier otherAlias = otherOrdered.get(i);\n+\n+                            if (canCorrelate) {\n+                                // We now amend the equivalences passed in by adding the already known bound aliases left\n+                                // of i and make them equivalent as well\n+                                equivalenceMapBuilder.put(alias, otherAlias);\n+                            }\n+\n+                            if (!predicate.test(alias, otherAlias, equivalenceMapBuilder.build())) {\n+                                break;\n+                            }\n+                        }\n+\n+                        if (i == aliases.size()) {\n+                            // zip ordered and otherOrdered as they now match\n+                            return zip(ordered, otherOrdered);\n+                        } else {\n+                            // we can skip all permutations where the i-th value is bound the way it currently is\n+                            iterator.skip(i);\n+                        }\n+                    }\n+\n+                    return endOfData();\n+                }\n+            };\n+        };\n+    }\n+\n+    @Nonnull\n+    public static Builder builder() {\n+        return new Builder();\n+    }\n+\n+    @Nonnull\n+    public static Builder builder(final int expectedSize) {\n+        return new Builder(expectedSize);\n+    }\n+\n+    @Nonnull\n+    public static AliasMap empty() {\n+        return new AliasMap(ImmutableBiMap.of());\n+    }\n+\n+    @Nonnull\n+    public static AliasMap of(@Nonnull final CorrelationIdentifier source, @Nonnull final CorrelationIdentifier target) {\n+        return new AliasMap(ImmutableBiMap.of(source, target));\n+    }\n+\n+    @Nonnull\n+    public static AliasMap of(@Nonnull final BiMap<CorrelationIdentifier, CorrelationIdentifier> map) {\n+        return new AliasMap(ImmutableBiMap.copyOf(map));\n+    }\n+\n+    @Nonnull\n+    public static AliasMap identitiesFor(final Set<CorrelationIdentifier> correlationIdentifiers) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b64d4eb60de5c3a4be0b4dc0f779ff2f15e47355"}, "originalPosition": 311}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgyMDU2NjAwOnYy", "diffSide": "RIGHT", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/plans/RecordQueryCoveringIndexPlan.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOVQxNzoyOTo1OFrOGva_ow==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMFQxNTo1MzoxOVrOG0UiZw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjM3ODUzMQ==", "bodyText": "Technically, I think changing this interface is breaking enough that we need to increment the minor version. Hmmm...", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/988#discussion_r452378531", "createdAt": "2020-07-09T17:29:58Z", "author": {"login": "nschiefer"}, "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/plans/RecordQueryCoveringIndexPlan.java", "diffHunk": "@@ -33,27 +33,31 @@\n import com.apple.foundationdb.record.provider.foundationdb.FDBRecordStoreBase;\n import com.apple.foundationdb.record.provider.foundationdb.FDBStoreTimer;\n import com.apple.foundationdb.record.query.plan.IndexKeyValueToPartialRecord;\n-import com.apple.foundationdb.record.query.plan.ScanComparisons;\n+import com.apple.foundationdb.record.query.plan.temp.CorrelationIdentifier;\n import com.apple.foundationdb.record.query.plan.temp.Quantifier;\n import com.apple.foundationdb.record.query.plan.temp.RelationalExpression;\n import com.apple.foundationdb.record.query.plan.temp.explain.NodeInfo;\n import com.apple.foundationdb.record.query.plan.temp.explain.PlannerGraph;\n+import com.google.common.collect.BiMap;\n+import com.google.common.collect.ImmutableBiMap;\n import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableSet;\n import com.google.common.collect.ImmutableMap;\n import com.google.protobuf.Descriptors;\n import com.google.protobuf.Message;\n \n import javax.annotation.Nonnull;\n import javax.annotation.Nullable;\n import java.util.List;\n+import java.util.Map;\n import java.util.Objects;\n import java.util.Set;\n \n /**\n  * A query plan that reconstructs records from the entries in a covering index.\n  */\n @API(API.Status.MAINTAINED)\n-public class RecordQueryCoveringIndexPlan implements RecordQueryPlanWithChild {\n+public class RecordQueryCoveringIndexPlan implements RecordQueryPlanWithNoChildren {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6eb7142ab316ffbec53e375804118f722f1d2bcc"}, "originalPosition": 30}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzUxNTYyMw==", "bodyText": "Will keep that in mind!", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/988#discussion_r457515623", "createdAt": "2020-07-20T15:53:19Z", "author": {"login": "normen662"}, "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/plans/RecordQueryCoveringIndexPlan.java", "diffHunk": "@@ -33,27 +33,31 @@\n import com.apple.foundationdb.record.provider.foundationdb.FDBRecordStoreBase;\n import com.apple.foundationdb.record.provider.foundationdb.FDBStoreTimer;\n import com.apple.foundationdb.record.query.plan.IndexKeyValueToPartialRecord;\n-import com.apple.foundationdb.record.query.plan.ScanComparisons;\n+import com.apple.foundationdb.record.query.plan.temp.CorrelationIdentifier;\n import com.apple.foundationdb.record.query.plan.temp.Quantifier;\n import com.apple.foundationdb.record.query.plan.temp.RelationalExpression;\n import com.apple.foundationdb.record.query.plan.temp.explain.NodeInfo;\n import com.apple.foundationdb.record.query.plan.temp.explain.PlannerGraph;\n+import com.google.common.collect.BiMap;\n+import com.google.common.collect.ImmutableBiMap;\n import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableSet;\n import com.google.common.collect.ImmutableMap;\n import com.google.protobuf.Descriptors;\n import com.google.protobuf.Message;\n \n import javax.annotation.Nonnull;\n import javax.annotation.Nullable;\n import java.util.List;\n+import java.util.Map;\n import java.util.Objects;\n import java.util.Set;\n \n /**\n  * A query plan that reconstructs records from the entries in a covering index.\n  */\n @API(API.Status.MAINTAINED)\n-public class RecordQueryCoveringIndexPlan implements RecordQueryPlanWithChild {\n+public class RecordQueryCoveringIndexPlan implements RecordQueryPlanWithNoChildren {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjM3ODUzMQ=="}, "originalCommit": {"oid": "6eb7142ab316ffbec53e375804118f722f1d2bcc"}, "originalPosition": 30}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgyMDU2NzU1OnYy", "diffSide": "LEFT", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/plans/RecordQueryCoveringIndexPlan.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOVQxNzozMDoyMlrOGvbAow==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOVQxNzozMDoyMlrOGvbAow==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjM3ODc4Nw==", "bodyText": "Similarly, eliminating this method is technically a breaking change.", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/988#discussion_r452378787", "createdAt": "2020-07-09T17:30:22Z", "author": {"login": "nschiefer"}, "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/plans/RecordQueryCoveringIndexPlan.java", "diffHunk": "@@ -177,17 +197,12 @@ public void logPlanStructure(StoreTimer timer) {\n \n     @Override\n     public int getComplexity() {\n-        return getChild().getComplexity();\n-    }\n-\n-    @Override\n-    public RecordQueryPlan getChild() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6eb7142ab316ffbec53e375804118f722f1d2bcc"}, "originalPosition": 163}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgyMDU3MTc4OnYy", "diffSide": "LEFT", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/plans/RecordQueryFilterPlanBase.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOVQxNzozMTozNFrOGvbDPQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOVQxNzozMTozNFrOGvbDPQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjM3OTQ1Mw==", "bodyText": "Likewise, this is also technically a breaking change.", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/988#discussion_r452379453", "createdAt": "2020-07-09T17:31:34Z", "author": {"login": "nschiefer"}, "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/plans/RecordQueryFilterPlanBase.java", "diffHunk": "@@ -98,56 +97,56 @@ protected RecordQueryFilterPlanBase(@Nonnull ExpressionRef<RecordQueryPlan> inne\n     }\n \n     @Nonnull\n-    public RecordQueryPlan getInner() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6eb7142ab316ffbec53e375804118f722f1d2bcc"}, "originalPosition": 39}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgyMDU3MzE3OnYy", "diffSide": "RIGHT", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/plans/RecordQueryInJoinPlan.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOVQxNzozMTo1NlrOGvbEGA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOVQxNzozMTo1NlrOGvbEGA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjM3OTY3Mg==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                protected RecordQueryInJoinPlan(final Quantifier.Physical inner,\n          \n          \n            \n                                                final String bindingName,\n          \n          \n            \n                protected RecordQueryInJoinPlan(@Nonnull final Quantifier.Physical inner,\n          \n          \n            \n                                                @Nonnull final String bindingName,", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/988#discussion_r452379672", "createdAt": "2020-07-09T17:31:56Z", "author": {"login": "nschiefer"}, "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/plans/RecordQueryInJoinPlan.java", "diffHunk": "@@ -52,13 +53,16 @@\n     @SuppressWarnings(\"unchecked\")\n     protected static final Comparator<Object> VALUE_COMPARATOR = (o1, o2) -> ((Comparable)o1).compareTo((Comparable)o2);\n \n-    protected final ExpressionRef<RecordQueryPlan> plan;\n+    protected final Quantifier.Physical inner;\n     protected final String bindingName;\n     protected final boolean sortValuesNeeded;\n     protected final boolean sortReverse;\n \n-    public RecordQueryInJoinPlan(RecordQueryPlan plan, String bindingName, boolean sortValuesNeeded, boolean sortReverse) {\n-        this.plan = GroupExpressionRef.of(plan);\n+    protected RecordQueryInJoinPlan(final Quantifier.Physical inner,\n+                                    final String bindingName,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6eb7142ab316ffbec53e375804118f722f1d2bcc"}, "originalPosition": 28}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgyMDU3NDI4OnYy", "diffSide": "RIGHT", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/plans/RecordQueryInJoinPlan.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOVQxNzozMjoxOFrOGvbE0A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOVQxNzozMjoxOFrOGvbE0A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjM3OTg1Ng==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                protected final Quantifier.Physical inner;\n          \n          \n            \n                @Nonnull\n          \n          \n            \n                protected final Quantifier.Physical inner;", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/988#discussion_r452379856", "createdAt": "2020-07-09T17:32:18Z", "author": {"login": "nschiefer"}, "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/plans/RecordQueryInJoinPlan.java", "diffHunk": "@@ -52,13 +53,16 @@\n     @SuppressWarnings(\"unchecked\")\n     protected static final Comparator<Object> VALUE_COMPARATOR = (o1, o2) -> ((Comparable)o1).compareTo((Comparable)o2);\n \n-    protected final ExpressionRef<RecordQueryPlan> plan;\n+    protected final Quantifier.Physical inner;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6eb7142ab316ffbec53e375804118f722f1d2bcc"}, "originalPosition": 20}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgyMDU3NjM2OnYy", "diffSide": "RIGHT", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/plans/RecordQueryCoveringIndexPlan.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOVQxNzozMjo1MlrOGvbGDw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMFQxNjowNjo1OFrOG0VKjQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjM4MDE3NQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public RecordQueryCoveringIndexPlan rebase(final Map<CorrelationIdentifier, CorrelationIdentifier> translationMap) {\n          \n          \n            \n                public RecordQueryCoveringIndexPlan rebase(@Nonnull final Map<CorrelationIdentifier, CorrelationIdentifier> translationMap) {", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/988#discussion_r452380175", "createdAt": "2020-07-09T17:32:52Z", "author": {"login": "nschiefer"}, "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/plans/RecordQueryCoveringIndexPlan.java", "diffHunk": "@@ -135,39 +139,55 @@ public boolean hasLoadBykeys() {\n     @Nonnull\n     @Override\n     public String toString() {\n-        return \"Covering(\" + getChild() + \" -> \" + toRecord + \")\";\n+        return \"Covering(\" + indexPlan + \" -> \" + toRecord + \")\";\n     }\n \n+    @Nonnull\n     @Override\n     @API(API.Status.EXPERIMENTAL)\n-    public boolean equalsWithoutChildren(@Nonnull RelationalExpression otherExpression) {\n-        if (!(otherExpression instanceof RecordQueryCoveringIndexPlan)) {\n-            return false;\n-        }\n-        final RecordQueryCoveringIndexPlan other = (RecordQueryCoveringIndexPlan) otherExpression;\n-        return recordTypeName.equals(other.recordTypeName) && toRecord.equals(other.toRecord);\n+    public Set<CorrelationIdentifier> getCorrelatedTo() {\n+        return ImmutableSet.of();\n+    }\n+\n+    @Nonnull\n+    @Override\n+    @API(API.Status.EXPERIMENTAL)\n+    public RecordQueryCoveringIndexPlan rebase(final Map<CorrelationIdentifier, CorrelationIdentifier> translationMap) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6eb7142ab316ffbec53e375804118f722f1d2bcc"}, "originalPosition": 107}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzUyNTkwMQ==", "bodyText": "Done.", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/988#discussion_r457525901", "createdAt": "2020-07-20T16:06:58Z", "author": {"login": "normen662"}, "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/plans/RecordQueryCoveringIndexPlan.java", "diffHunk": "@@ -135,39 +139,55 @@ public boolean hasLoadBykeys() {\n     @Nonnull\n     @Override\n     public String toString() {\n-        return \"Covering(\" + getChild() + \" -> \" + toRecord + \")\";\n+        return \"Covering(\" + indexPlan + \" -> \" + toRecord + \")\";\n     }\n \n+    @Nonnull\n     @Override\n     @API(API.Status.EXPERIMENTAL)\n-    public boolean equalsWithoutChildren(@Nonnull RelationalExpression otherExpression) {\n-        if (!(otherExpression instanceof RecordQueryCoveringIndexPlan)) {\n-            return false;\n-        }\n-        final RecordQueryCoveringIndexPlan other = (RecordQueryCoveringIndexPlan) otherExpression;\n-        return recordTypeName.equals(other.recordTypeName) && toRecord.equals(other.toRecord);\n+    public Set<CorrelationIdentifier> getCorrelatedTo() {\n+        return ImmutableSet.of();\n+    }\n+\n+    @Nonnull\n+    @Override\n+    @API(API.Status.EXPERIMENTAL)\n+    public RecordQueryCoveringIndexPlan rebase(final Map<CorrelationIdentifier, CorrelationIdentifier> translationMap) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjM4MDE3NQ=="}, "originalCommit": {"oid": "6eb7142ab316ffbec53e375804118f722f1d2bcc"}, "originalPosition": 107}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgyMDU3Njk1OnYy", "diffSide": "RIGHT", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/plans/RecordQueryCoveringIndexPlan.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOVQxNzozMzowMVrOGvbGag==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMFQxNjoxMzo1NlrOG0Vb0w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjM4MDI2Ng==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public boolean equalsWithoutChildren(@Nonnull RelationalExpression otherExpression, final BiMap<CorrelationIdentifier, CorrelationIdentifier> equivalencesMap) {\n          \n          \n            \n                public boolean equalsWithoutChildren(@Nonnull RelationalExpression otherExpression, @Nonnull final BiMap<CorrelationIdentifier, CorrelationIdentifier> equivalencesMap) {", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/988#discussion_r452380266", "createdAt": "2020-07-09T17:33:01Z", "author": {"login": "nschiefer"}, "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/plans/RecordQueryCoveringIndexPlan.java", "diffHunk": "@@ -135,39 +139,55 @@ public boolean hasLoadBykeys() {\n     @Nonnull\n     @Override\n     public String toString() {\n-        return \"Covering(\" + getChild() + \" -> \" + toRecord + \")\";\n+        return \"Covering(\" + indexPlan + \" -> \" + toRecord + \")\";\n     }\n \n+    @Nonnull\n     @Override\n     @API(API.Status.EXPERIMENTAL)\n-    public boolean equalsWithoutChildren(@Nonnull RelationalExpression otherExpression) {\n-        if (!(otherExpression instanceof RecordQueryCoveringIndexPlan)) {\n-            return false;\n-        }\n-        final RecordQueryCoveringIndexPlan other = (RecordQueryCoveringIndexPlan) otherExpression;\n-        return recordTypeName.equals(other.recordTypeName) && toRecord.equals(other.toRecord);\n+    public Set<CorrelationIdentifier> getCorrelatedTo() {\n+        return ImmutableSet.of();\n+    }\n+\n+    @Nonnull\n+    @Override\n+    @API(API.Status.EXPERIMENTAL)\n+    public RecordQueryCoveringIndexPlan rebase(final Map<CorrelationIdentifier, CorrelationIdentifier> translationMap) {\n+        return new RecordQueryCoveringIndexPlan(indexPlan, recordTypeName, toRecord);\n     }\n \n     @Override\n-    public boolean equals(Object o) {\n-        if (this == o) {\n+    @API(API.Status.EXPERIMENTAL)\n+    public boolean equalsWithoutChildren(@Nonnull RelationalExpression otherExpression, final BiMap<CorrelationIdentifier, CorrelationIdentifier> equivalencesMap) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6eb7142ab316ffbec53e375804118f722f1d2bcc"}, "originalPosition": 115}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzUzMDMyMw==", "bodyText": "Done.", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/988#discussion_r457530323", "createdAt": "2020-07-20T16:13:56Z", "author": {"login": "normen662"}, "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/plans/RecordQueryCoveringIndexPlan.java", "diffHunk": "@@ -135,39 +139,55 @@ public boolean hasLoadBykeys() {\n     @Nonnull\n     @Override\n     public String toString() {\n-        return \"Covering(\" + getChild() + \" -> \" + toRecord + \")\";\n+        return \"Covering(\" + indexPlan + \" -> \" + toRecord + \")\";\n     }\n \n+    @Nonnull\n     @Override\n     @API(API.Status.EXPERIMENTAL)\n-    public boolean equalsWithoutChildren(@Nonnull RelationalExpression otherExpression) {\n-        if (!(otherExpression instanceof RecordQueryCoveringIndexPlan)) {\n-            return false;\n-        }\n-        final RecordQueryCoveringIndexPlan other = (RecordQueryCoveringIndexPlan) otherExpression;\n-        return recordTypeName.equals(other.recordTypeName) && toRecord.equals(other.toRecord);\n+    public Set<CorrelationIdentifier> getCorrelatedTo() {\n+        return ImmutableSet.of();\n+    }\n+\n+    @Nonnull\n+    @Override\n+    @API(API.Status.EXPERIMENTAL)\n+    public RecordQueryCoveringIndexPlan rebase(final Map<CorrelationIdentifier, CorrelationIdentifier> translationMap) {\n+        return new RecordQueryCoveringIndexPlan(indexPlan, recordTypeName, toRecord);\n     }\n \n     @Override\n-    public boolean equals(Object o) {\n-        if (this == o) {\n+    @API(API.Status.EXPERIMENTAL)\n+    public boolean equalsWithoutChildren(@Nonnull RelationalExpression otherExpression, final BiMap<CorrelationIdentifier, CorrelationIdentifier> equivalencesMap) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjM4MDI2Ng=="}, "originalCommit": {"oid": "6eb7142ab316ffbec53e375804118f722f1d2bcc"}, "originalPosition": 115}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgyMDU3Nzg5OnYy", "diffSide": "RIGHT", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/plans/RecordQueryCoveringIndexPlan.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOVQxNzozMzoyMVrOGvbHAQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOVQxNzozMzoyMVrOGvbHAQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjM4MDQxNw==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public boolean resultEquals(final Object other, final BiMap<CorrelationIdentifier, CorrelationIdentifier> equivalenceMap) {\n          \n          \n            \n                public boolean resultEquals(@Nullable final Object other, @Nonnull final BiMap<CorrelationIdentifier, CorrelationIdentifier> equivalenceMap) {", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/988#discussion_r452380417", "createdAt": "2020-07-09T17:33:21Z", "author": {"login": "nschiefer"}, "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/plans/RecordQueryCoveringIndexPlan.java", "diffHunk": "@@ -135,39 +139,55 @@ public boolean hasLoadBykeys() {\n     @Nonnull\n     @Override\n     public String toString() {\n-        return \"Covering(\" + getChild() + \" -> \" + toRecord + \")\";\n+        return \"Covering(\" + indexPlan + \" -> \" + toRecord + \")\";\n     }\n \n+    @Nonnull\n     @Override\n     @API(API.Status.EXPERIMENTAL)\n-    public boolean equalsWithoutChildren(@Nonnull RelationalExpression otherExpression) {\n-        if (!(otherExpression instanceof RecordQueryCoveringIndexPlan)) {\n-            return false;\n-        }\n-        final RecordQueryCoveringIndexPlan other = (RecordQueryCoveringIndexPlan) otherExpression;\n-        return recordTypeName.equals(other.recordTypeName) && toRecord.equals(other.toRecord);\n+    public Set<CorrelationIdentifier> getCorrelatedTo() {\n+        return ImmutableSet.of();\n+    }\n+\n+    @Nonnull\n+    @Override\n+    @API(API.Status.EXPERIMENTAL)\n+    public RecordQueryCoveringIndexPlan rebase(final Map<CorrelationIdentifier, CorrelationIdentifier> translationMap) {\n+        return new RecordQueryCoveringIndexPlan(indexPlan, recordTypeName, toRecord);\n     }\n \n     @Override\n-    public boolean equals(Object o) {\n-        if (this == o) {\n+    @API(API.Status.EXPERIMENTAL)\n+    public boolean equalsWithoutChildren(@Nonnull RelationalExpression otherExpression, final BiMap<CorrelationIdentifier, CorrelationIdentifier> equivalencesMap) {\n+        if (otherExpression == this) {\n             return true;\n         }\n-        if (o == null || getClass() != o.getClass()) {\n+        if (otherExpression.getClass() != getClass()) {\n             return false;\n         }\n-        if (!super.equals(o)) {\n+        final RecordQueryCoveringIndexPlan other = (RecordQueryCoveringIndexPlan) otherExpression;\n+        return indexPlan.resultEquals(other.indexPlan, equivalencesMap) &&\n+               recordTypeName.equals(other.recordTypeName) &&\n+               toRecord.equals(other.toRecord);\n+    }\n+\n+    @Override\n+    public boolean resultEquals(final Object other, final BiMap<CorrelationIdentifier, CorrelationIdentifier> equivalenceMap) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6eb7142ab316ffbec53e375804118f722f1d2bcc"}, "originalPosition": 131}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgyMDU4MTU5OnYy", "diffSide": "RIGHT", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/plans/RecordQueryFilterPlan.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOVQxNzozNDoyN1rOGvbJXg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOVQxNzozNDoyN1rOGvbJXg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjM4MTAyMg==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public RecordQueryFilterPlan rebaseWithRebasedQuantifiers(final Map<CorrelationIdentifier, CorrelationIdentifier> translationMap, final List<Quantifier> rebasedQuantifiers) {\n          \n          \n            \n                public RecordQueryFilterPlan rebaseWithRebasedQuantifiers(@Nonnull final Map<CorrelationIdentifier, CorrelationIdentifier> translationMap, @Nonnull final List<Quantifier> rebasedQuantifiers) {", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/988#discussion_r452381022", "createdAt": "2020-07-09T17:34:27Z", "author": {"login": "nschiefer"}, "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/plans/RecordQueryFilterPlan.java", "diffHunk": "@@ -91,42 +98,54 @@ protected boolean hasAsyncFilter() {\n \n     @Override\n     public boolean isReverse() {\n-        return getInner().isReverse();\n+        return getInnerPlan().isReverse();\n     }\n \n     @Nonnull\n     @Override\n     public String toString() {\n-        return getInner() + \" | \" + getFilter();\n+        return getInnerPlan() + \" | \" + getFilter();\n     }\n \n+    @Nonnull\n     @Override\n-    public boolean equalsWithoutChildren(@Nonnull RelationalExpression otherExpression) {\n-        return otherExpression instanceof RecordQueryFilterPlan &&\n-               filter.equals(((RecordQueryFilterPlan)otherExpression).getFilter());\n+    @API(API.Status.EXPERIMENTAL)\n+    public Set<CorrelationIdentifier> getCorrelatedToWithoutChildren() {\n+        return ImmutableSet.of();\n     }\n \n+    @Nonnull\n     @Override\n-    public boolean equals(Object o) {\n-        if (this == o) {\n-            return true;\n-        }\n-        if (o == null || getClass() != o.getClass()) {\n+    @API(API.Status.EXPERIMENTAL)\n+    public RecordQueryFilterPlan rebaseWithRebasedQuantifiers(final Map<CorrelationIdentifier, CorrelationIdentifier> translationMap, final List<Quantifier> rebasedQuantifiers) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6eb7142ab316ffbec53e375804118f722f1d2bcc"}, "originalPosition": 86}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgyMDU4MjIwOnYy", "diffSide": "RIGHT", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/plans/RecordQueryFilterPlan.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOVQxNzozNDo0MlrOGvbJzw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOVQxNzozNDo0MlrOGvbJzw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjM4MTEzNQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public boolean equalsWithoutChildren(@Nonnull RelationalExpression otherExpression, final BiMap<CorrelationIdentifier, CorrelationIdentifier> equivalencesMap) {\n          \n          \n            \n                public boolean equalsWithoutChildren(@Nonnull RelationalExpression otherExpression, @Nonnull final BiMap<CorrelationIdentifier, CorrelationIdentifier> equivalencesMap) {", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/988#discussion_r452381135", "createdAt": "2020-07-09T17:34:42Z", "author": {"login": "nschiefer"}, "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/plans/RecordQueryFilterPlan.java", "diffHunk": "@@ -91,42 +98,54 @@ protected boolean hasAsyncFilter() {\n \n     @Override\n     public boolean isReverse() {\n-        return getInner().isReverse();\n+        return getInnerPlan().isReverse();\n     }\n \n     @Nonnull\n     @Override\n     public String toString() {\n-        return getInner() + \" | \" + getFilter();\n+        return getInnerPlan() + \" | \" + getFilter();\n     }\n \n+    @Nonnull\n     @Override\n-    public boolean equalsWithoutChildren(@Nonnull RelationalExpression otherExpression) {\n-        return otherExpression instanceof RecordQueryFilterPlan &&\n-               filter.equals(((RecordQueryFilterPlan)otherExpression).getFilter());\n+    @API(API.Status.EXPERIMENTAL)\n+    public Set<CorrelationIdentifier> getCorrelatedToWithoutChildren() {\n+        return ImmutableSet.of();\n     }\n \n+    @Nonnull\n     @Override\n-    public boolean equals(Object o) {\n-        if (this == o) {\n-            return true;\n-        }\n-        if (o == null || getClass() != o.getClass()) {\n+    @API(API.Status.EXPERIMENTAL)\n+    public RecordQueryFilterPlan rebaseWithRebasedQuantifiers(final Map<CorrelationIdentifier, CorrelationIdentifier> translationMap, final List<Quantifier> rebasedQuantifiers) {\n+        return new RecordQueryFilterPlan((Quantifier.Physical)Iterables.getOnlyElement(rebasedQuantifiers),\n+                getFilter());\n+    }\n+\n+    @Override\n+    public boolean equalsWithoutChildren(@Nonnull RelationalExpression otherExpression, final BiMap<CorrelationIdentifier, CorrelationIdentifier> equivalencesMap) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6eb7142ab316ffbec53e375804118f722f1d2bcc"}, "originalPosition": 92}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgyMDU4NjY3OnYy", "diffSide": "RIGHT", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/plans/RecordQueryInJoinPlan.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOVQxNzozNTo1OVrOGvbMoQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOVQxNzozNTo1OVrOGvbMoQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjM4MTg1Nw==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public boolean equalsWithoutChildren(@Nonnull RelationalExpression otherExpression, final BiMap<CorrelationIdentifier, CorrelationIdentifier> equivalencesMap) {\n          \n          \n            \n                public boolean equalsWithoutChildren(@Nonnull RelationalExpression otherExpression, @Nonnull final BiMap<CorrelationIdentifier, CorrelationIdentifier> equivalencesMap) {", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/988#discussion_r452381857", "createdAt": "2020-07-09T17:35:59Z", "author": {"login": "nschiefer"}, "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/plans/RecordQueryInJoinPlan.java", "diffHunk": "@@ -120,8 +124,8 @@ public boolean isReverse() {\n \n     @Override\n     @API(API.Status.EXPERIMENTAL)\n-    public boolean equalsWithoutChildren(@Nonnull RelationalExpression otherExpression) {\n-        if (!(otherExpression instanceof RecordQueryInJoinPlan)) {\n+    public boolean equalsWithoutChildren(@Nonnull RelationalExpression otherExpression, final BiMap<CorrelationIdentifier, CorrelationIdentifier> equivalencesMap) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6eb7142ab316ffbec53e375804118f722f1d2bcc"}, "originalPosition": 77}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgyMDU4OTkxOnYy", "diffSide": "RIGHT", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/plans/RecordQueryInJoinPlan.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOVQxNzozNjo1MFrOGvbOiw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMFQxNjoxOTo1NFrOG0VqoA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjM4MjM0Nw==", "bodyText": "This one is interesting because it's logically correlated, but that correlation doesn't show up in the data structure. I think you have this right, but we probably have to iterate on it.", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/988#discussion_r452382347", "createdAt": "2020-07-09T17:36:50Z", "author": {"login": "nschiefer"}, "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/plans/RecordQueryInJoinPlan.java", "diffHunk": "@@ -106,7 +110,7 @@ public boolean isSorted() {\n     @Override\n     @API(API.Status.EXPERIMENTAL)\n     public List<? extends Quantifier> getQuantifiers() {\n-        return ImmutableList.of(Quantifier.physical(plan));\n+        return ImmutableList.of(inner);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6eb7142ab316ffbec53e375804118f722f1d2bcc"}, "originalPosition": 67}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzUzNDExMg==", "bodyText": "+1", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/988#discussion_r457534112", "createdAt": "2020-07-20T16:19:54Z", "author": {"login": "normen662"}, "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/plans/RecordQueryInJoinPlan.java", "diffHunk": "@@ -106,7 +110,7 @@ public boolean isSorted() {\n     @Override\n     @API(API.Status.EXPERIMENTAL)\n     public List<? extends Quantifier> getQuantifiers() {\n-        return ImmutableList.of(Quantifier.physical(plan));\n+        return ImmutableList.of(inner);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjM4MjM0Nw=="}, "originalCommit": {"oid": "6eb7142ab316ffbec53e375804118f722f1d2bcc"}, "originalPosition": 67}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgyMDU5MTQ5OnYy", "diffSide": "RIGHT", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/plans/RecordQueryInParameterJoinPlan.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOVQxNzozNzoyM1rOGvbPpw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOVQxNzozNzoyM1rOGvbPpw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjM4MjYzMQ==", "bodyText": "I agree wholeheartedly with this TODO.", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/988#discussion_r452382631", "createdAt": "2020-07-09T17:37:23Z", "author": {"login": "nschiefer"}, "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/plans/RecordQueryInParameterJoinPlan.java", "diffHunk": "@@ -75,26 +100,29 @@ public String toString() {\n         return str.toString();\n     }\n \n+    @Nonnull\n     @Override\n-    public boolean equalsWithoutChildren(@Nonnull RelationalExpression otherExpression) {\n-        return otherExpression instanceof RecordQueryInParameterJoinPlan &&\n-               super.equalsWithoutChildren(otherExpression) &&\n-               externalBinding.equals(((RecordQueryInParameterJoinPlan)otherExpression).externalBinding);\n+    @API(API.Status.EXPERIMENTAL)\n+    public Set<CorrelationIdentifier> getCorrelatedToWithoutChildren() {\n+        return ImmutableSet.of(); // TODO this should be reconsidered when we have selects", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6eb7142ab316ffbec53e375804118f722f1d2bcc"}, "originalPosition": 81}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgyMDU5MzI5OnYy", "diffSide": "RIGHT", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/plans/RecordQueryInParameterJoinPlan.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOVQxNzozNzo1NFrOGvbQug==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOVQxNzozNzo1NFrOGvbQug==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjM4MjkwNg==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public RecordQueryInParameterJoinPlan rebaseWithRebasedQuantifiers(final Map<CorrelationIdentifier, CorrelationIdentifier> translationMap, final List<Quantifier> rebasedQuantifiers) {\n          \n          \n            \n                public RecordQueryInParameterJoinPlan rebaseWithRebasedQuantifiers(@Nonnull final Map<CorrelationIdentifier, CorrelationIdentifier> translationMap, @Nonnull final List<Quantifier> rebasedQuantifiers) {", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/988#discussion_r452382906", "createdAt": "2020-07-09T17:37:54Z", "author": {"login": "nschiefer"}, "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/plans/RecordQueryInParameterJoinPlan.java", "diffHunk": "@@ -75,26 +100,29 @@ public String toString() {\n         return str.toString();\n     }\n \n+    @Nonnull\n     @Override\n-    public boolean equalsWithoutChildren(@Nonnull RelationalExpression otherExpression) {\n-        return otherExpression instanceof RecordQueryInParameterJoinPlan &&\n-               super.equalsWithoutChildren(otherExpression) &&\n-               externalBinding.equals(((RecordQueryInParameterJoinPlan)otherExpression).externalBinding);\n+    @API(API.Status.EXPERIMENTAL)\n+    public Set<CorrelationIdentifier> getCorrelatedToWithoutChildren() {\n+        return ImmutableSet.of(); // TODO this should be reconsidered when we have selects\n+    }\n+\n+    @Nonnull\n+    @Override\n+    @API(API.Status.EXPERIMENTAL)\n+    public RecordQueryInParameterJoinPlan rebaseWithRebasedQuantifiers(final Map<CorrelationIdentifier, CorrelationIdentifier> translationMap, final List<Quantifier> rebasedQuantifiers) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6eb7142ab316ffbec53e375804118f722f1d2bcc"}, "originalPosition": 87}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgyMDYwMDg5OnYy", "diffSide": "RIGHT", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/plans/RecordQueryInValuesJoinPlan.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOVQxNzo0MDoyM1rOGvbVzg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOVQxNzo0MDoyM1rOGvbVzg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjM4NDIwNg==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public RecordQueryInValuesJoinPlan rebaseWithRebasedQuantifiers(final Map<CorrelationIdentifier, CorrelationIdentifier> translationMap, final List<Quantifier> rebasedQuantifiers) {\n          \n          \n            \n                public RecordQueryInValuesJoinPlan rebaseWithRebasedQuantifiers(@Nonnull final Map<CorrelationIdentifier, CorrelationIdentifier> translationMap, @Nonnull final List<Quantifier> rebasedQuantifiers) {", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/988#discussion_r452384206", "createdAt": "2020-07-09T17:40:23Z", "author": {"login": "nschiefer"}, "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/plans/RecordQueryInValuesJoinPlan.java", "diffHunk": "@@ -73,27 +97,29 @@ public String toString() {\n         return str.toString();\n     }\n \n+    @Nonnull\n     @Override\n     @API(API.Status.EXPERIMENTAL)\n-    public boolean equalsWithoutChildren(@Nonnull RelationalExpression otherExpression) {\n-        return otherExpression instanceof RecordQueryInValuesJoinPlan &&\n-               super.equalsWithoutChildren(otherExpression) &&\n-               Objects.equals(values, ((RecordQueryInValuesJoinPlan)otherExpression).values);\n+    public Set<CorrelationIdentifier> getCorrelatedToWithoutChildren() {\n+        return ImmutableSet.of(); // TODO this should be reconsidered when we have selects\n     }\n \n+    @Nonnull\n     @Override\n-    public boolean equals(Object o) {\n-        if (this == o) {\n-            return true;\n-        }\n-        if (o == null || getClass() != o.getClass()) {\n-            return false;\n-        }\n-        if (!super.equals(o)) {\n-            return false;\n-        }\n-        RecordQueryInValuesJoinPlan that = (RecordQueryInValuesJoinPlan)o;\n-        return Objects.equals(values, that.values);\n+    public RecordQueryInValuesJoinPlan rebaseWithRebasedQuantifiers(final Map<CorrelationIdentifier, CorrelationIdentifier> translationMap, final List<Quantifier> rebasedQuantifiers) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6eb7142ab316ffbec53e375804118f722f1d2bcc"}, "originalPosition": 99}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgyMDYwMTQxOnYy", "diffSide": "RIGHT", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/plans/RecordQueryInValuesJoinPlan.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOVQxNzo0MDozNFrOGvbWIA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOVQxNzo0MDozNFrOGvbWIA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjM4NDI4OA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public boolean equalsWithoutChildren(@Nonnull RelationalExpression otherExpression, final BiMap<CorrelationIdentifier, CorrelationIdentifier> equivalencesMap) {\n          \n          \n            \n                public boolean equalsWithoutChildren(@Nonnull RelationalExpression otherExpression, @Nonnull final BiMap<CorrelationIdentifier, CorrelationIdentifier> equivalencesMap) {", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/988#discussion_r452384288", "createdAt": "2020-07-09T17:40:34Z", "author": {"login": "nschiefer"}, "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/plans/RecordQueryInValuesJoinPlan.java", "diffHunk": "@@ -73,27 +97,29 @@ public String toString() {\n         return str.toString();\n     }\n \n+    @Nonnull\n     @Override\n     @API(API.Status.EXPERIMENTAL)\n-    public boolean equalsWithoutChildren(@Nonnull RelationalExpression otherExpression) {\n-        return otherExpression instanceof RecordQueryInValuesJoinPlan &&\n-               super.equalsWithoutChildren(otherExpression) &&\n-               Objects.equals(values, ((RecordQueryInValuesJoinPlan)otherExpression).values);\n+    public Set<CorrelationIdentifier> getCorrelatedToWithoutChildren() {\n+        return ImmutableSet.of(); // TODO this should be reconsidered when we have selects\n     }\n \n+    @Nonnull\n     @Override\n-    public boolean equals(Object o) {\n-        if (this == o) {\n-            return true;\n-        }\n-        if (o == null || getClass() != o.getClass()) {\n-            return false;\n-        }\n-        if (!super.equals(o)) {\n-            return false;\n-        }\n-        RecordQueryInValuesJoinPlan that = (RecordQueryInValuesJoinPlan)o;\n-        return Objects.equals(values, that.values);\n+    public RecordQueryInValuesJoinPlan rebaseWithRebasedQuantifiers(final Map<CorrelationIdentifier, CorrelationIdentifier> translationMap, final List<Quantifier> rebasedQuantifiers) {\n+        return new RecordQueryInValuesJoinPlan((Quantifier.Physical)Iterables.getOnlyElement(rebasedQuantifiers),\n+                bindingName,\n+                values,\n+                sortValuesNeeded,\n+                sortReverse);\n+    }\n+\n+    @Override\n+    @API(API.Status.EXPERIMENTAL)\n+    public boolean equalsWithoutChildren(@Nonnull RelationalExpression otherExpression, final BiMap<CorrelationIdentifier, CorrelationIdentifier> equivalencesMap) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6eb7142ab316ffbec53e375804118f722f1d2bcc"}, "originalPosition": 109}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgyMDYwMjY4OnYy", "diffSide": "RIGHT", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/plans/RecordQueryIndexPlan.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOVQxNzo0MDo1NlrOGvbW3w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOVQxNzo0MDo1NlrOGvbW3w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjM4NDQ3OQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public RecordQueryIndexPlan rebase(final Map<CorrelationIdentifier, CorrelationIdentifier> translationMap) {\n          \n          \n            \n                public RecordQueryIndexPlan rebase(@Nonnull final Map<CorrelationIdentifier, CorrelationIdentifier> translationMap) {", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/988#discussion_r452384479", "createdAt": "2020-07-09T17:40:56Z", "author": {"login": "nschiefer"}, "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/plans/RecordQueryIndexPlan.java", "diffHunk": "@@ -127,25 +131,51 @@ public boolean hasLoadBykeys() {\n         return false;\n     }\n \n+    @Nonnull\n+    @Override\n+    @API(API.Status.EXPERIMENTAL)\n+    public Set<CorrelationIdentifier> getCorrelatedTo() {\n+        return ImmutableSet.of();\n+    }\n+\n+    @Nonnull\n     @Override\n     @API(API.Status.EXPERIMENTAL)\n-    public boolean equalsWithoutChildren(@Nonnull RelationalExpression otherExpression) {\n-        return equals(otherExpression);\n+    public RecordQueryIndexPlan rebase(final Map<CorrelationIdentifier, CorrelationIdentifier> translationMap) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6eb7142ab316ffbec53e375804118f722f1d2bcc"}, "originalPosition": 32}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgyMDYwMzEyOnYy", "diffSide": "RIGHT", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/plans/RecordQueryIndexPlan.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOVQxNzo0MTowNlrOGvbXNw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOVQxNzo0MTowNlrOGvbXNw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjM4NDU2Nw==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public boolean equalsWithoutChildren(@Nonnull RelationalExpression otherExpression, final BiMap<CorrelationIdentifier, CorrelationIdentifier> equivalencesMap) {\n          \n          \n            \n                public boolean equalsWithoutChildren(@Nonnull RelationalExpression otherExpression, @Nonnull final BiMap<CorrelationIdentifier, CorrelationIdentifier> equivalencesMap) {", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/988#discussion_r452384567", "createdAt": "2020-07-09T17:41:06Z", "author": {"login": "nschiefer"}, "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/plans/RecordQueryIndexPlan.java", "diffHunk": "@@ -127,25 +131,51 @@ public boolean hasLoadBykeys() {\n         return false;\n     }\n \n+    @Nonnull\n+    @Override\n+    @API(API.Status.EXPERIMENTAL)\n+    public Set<CorrelationIdentifier> getCorrelatedTo() {\n+        return ImmutableSet.of();\n+    }\n+\n+    @Nonnull\n     @Override\n     @API(API.Status.EXPERIMENTAL)\n-    public boolean equalsWithoutChildren(@Nonnull RelationalExpression otherExpression) {\n-        return equals(otherExpression);\n+    public RecordQueryIndexPlan rebase(final Map<CorrelationIdentifier, CorrelationIdentifier> translationMap) {\n+        return new RecordQueryIndexPlan(getIndexName(),\n+                getScanType(),\n+                getComparisons(),\n+                isReverse());\n     }\n \n     @Override\n-    public boolean equals(Object o) {\n-        if (this == o) {\n+    @API(API.Status.EXPERIMENTAL)\n+    public boolean equalsWithoutChildren(@Nonnull RelationalExpression otherExpression, final BiMap<CorrelationIdentifier, CorrelationIdentifier> equivalencesMap) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6eb7142ab316ffbec53e375804118f722f1d2bcc"}, "originalPosition": 43}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgyMDYwNDAwOnYy", "diffSide": "RIGHT", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/plans/RecordQueryIndexPlan.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOVQxNzo0MToyNFrOGvbXzw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOVQxNzo0MToyNFrOGvbXzw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjM4NDcxOQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public boolean resultEquals(final Object other, final BiMap<CorrelationIdentifier, CorrelationIdentifier> equivalenceMap) {\n          \n          \n            \n                public boolean resultEquals(@Nullable final Object other, @Nonnull final BiMap<CorrelationIdentifier, CorrelationIdentifier> equivalenceMap) {", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/988#discussion_r452384719", "createdAt": "2020-07-09T17:41:24Z", "author": {"login": "nschiefer"}, "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/plans/RecordQueryIndexPlan.java", "diffHunk": "@@ -127,25 +131,51 @@ public boolean hasLoadBykeys() {\n         return false;\n     }\n \n+    @Nonnull\n+    @Override\n+    @API(API.Status.EXPERIMENTAL)\n+    public Set<CorrelationIdentifier> getCorrelatedTo() {\n+        return ImmutableSet.of();\n+    }\n+\n+    @Nonnull\n     @Override\n     @API(API.Status.EXPERIMENTAL)\n-    public boolean equalsWithoutChildren(@Nonnull RelationalExpression otherExpression) {\n-        return equals(otherExpression);\n+    public RecordQueryIndexPlan rebase(final Map<CorrelationIdentifier, CorrelationIdentifier> translationMap) {\n+        return new RecordQueryIndexPlan(getIndexName(),\n+                getScanType(),\n+                getComparisons(),\n+                isReverse());\n     }\n \n     @Override\n-    public boolean equals(Object o) {\n-        if (this == o) {\n+    @API(API.Status.EXPERIMENTAL)\n+    public boolean equalsWithoutChildren(@Nonnull RelationalExpression otherExpression, final BiMap<CorrelationIdentifier, CorrelationIdentifier> equivalencesMap) {\n+        if (this == otherExpression) {\n             return true;\n         }\n-        if (!(o instanceof RecordQueryIndexPlan)) {\n+        if (getClass() != otherExpression.getClass()) {\n             return false;\n         }\n-        RecordQueryIndexPlan that = (RecordQueryIndexPlan) o;\n+        RecordQueryIndexPlan that = (RecordQueryIndexPlan) otherExpression;\n         return reverse == that.reverse &&\n-                Objects.equals(indexName, that.indexName) &&\n-                Objects.equals(scanType, that.scanType) &&\n-                Objects.equals(comparisons, that.comparisons);\n+               Objects.equals(indexName, that.indexName) &&\n+               Objects.equals(scanType, that.scanType) &&\n+               Objects.equals(comparisons, that.comparisons);\n+    }\n+\n+    @Override\n+    public boolean resultEquals(final Object other, final BiMap<CorrelationIdentifier, CorrelationIdentifier> equivalenceMap) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6eb7142ab316ffbec53e375804118f722f1d2bcc"}, "originalPosition": 63}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgyMDYxMDI3OnYy", "diffSide": "RIGHT", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/plans/RecordQueryIntersectionPlan.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOVQxNzo0MzoxMlrOGvbb4w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOVQxNzo0MzoxMlrOGvbb4w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjM4NTc2Mw==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public RecordQueryIntersectionPlan rebaseWithRebasedQuantifiers(final Map<CorrelationIdentifier, CorrelationIdentifier> translationMap,\n          \n          \n            \n                                                                                final List<Quantifier> rebasedQuantifiers) {\n          \n          \n            \n                public RecordQueryIntersectionPlan rebaseWithRebasedQuantifiers(@Nonnull final Map<CorrelationIdentifier, CorrelationIdentifier> translationMap,\n          \n          \n            \n                                                                                @Nonnull final List<Quantifier> rebasedQuantifiers) {", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/988#discussion_r452385763", "createdAt": "2020-07-09T17:43:12Z", "author": {"login": "nschiefer"}, "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/plans/RecordQueryIntersectionPlan.java", "diffHunk": "@@ -166,9 +178,31 @@ public String toString() {\n         return getChildStream().map(RecordQueryPlan::toString).collect(Collectors.joining(\" \" + INTERSECT + \" \"));\n     }\n \n+    @Nonnull\n+    @Override\n+    @API(API.Status.EXPERIMENTAL)\n+    public Set<CorrelationIdentifier> getCorrelatedToWithoutChildren() {\n+        return ImmutableSet.of();\n+    }\n+\n+    @Nonnull\n+    @Override\n+    @API(API.Status.EXPERIMENTAL)\n+    public RecordQueryIntersectionPlan rebaseWithRebasedQuantifiers(final Map<CorrelationIdentifier, CorrelationIdentifier> translationMap,\n+                                                                    final List<Quantifier> rebasedQuantifiers) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6eb7142ab316ffbec53e375804118f722f1d2bcc"}, "originalPosition": 134}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgyMDYxMTA0OnYy", "diffSide": "RIGHT", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/plans/RecordQueryIntersectionPlan.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOVQxNzo0MzoyN1rOGvbcXA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOVQxNzo0MzoyN1rOGvbcXA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjM4NTg4NA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public boolean equalsWithoutChildren(@Nonnull RelationalExpression otherExpression, final BiMap<CorrelationIdentifier, CorrelationIdentifier> equivalencesMap) {\n          \n          \n            \n                public boolean equalsWithoutChildren(@Nonnull RelationalExpression otherExpression, @Nonnull final BiMap<CorrelationIdentifier, CorrelationIdentifier> equivalencesMap) {", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/988#discussion_r452385884", "createdAt": "2020-07-09T17:43:27Z", "author": {"login": "nschiefer"}, "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/plans/RecordQueryIntersectionPlan.java", "diffHunk": "@@ -166,9 +178,31 @@ public String toString() {\n         return getChildStream().map(RecordQueryPlan::toString).collect(Collectors.joining(\" \" + INTERSECT + \" \"));\n     }\n \n+    @Nonnull\n+    @Override\n+    @API(API.Status.EXPERIMENTAL)\n+    public Set<CorrelationIdentifier> getCorrelatedToWithoutChildren() {\n+        return ImmutableSet.of();\n+    }\n+\n+    @Nonnull\n+    @Override\n+    @API(API.Status.EXPERIMENTAL)\n+    public RecordQueryIntersectionPlan rebaseWithRebasedQuantifiers(final Map<CorrelationIdentifier, CorrelationIdentifier> translationMap,\n+                                                                    final List<Quantifier> rebasedQuantifiers) {\n+        return new RecordQueryIntersectionPlan(\n+                rebasedQuantifiers\n+                        .stream()\n+                        .map(quantifier -> (Quantifier.Physical)quantifier)\n+                        .collect(Collectors.toList()),\n+                getComparisonKey(),\n+                isReverse(),\n+                false);\n+    }\n+\n     @Override\n     @API(API.Status.EXPERIMENTAL)\n-    public boolean equalsWithoutChildren(@Nonnull RelationalExpression otherExpression) {\n+    public boolean equalsWithoutChildren(@Nonnull RelationalExpression otherExpression, final BiMap<CorrelationIdentifier, CorrelationIdentifier> equivalencesMap) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6eb7142ab316ffbec53e375804118f722f1d2bcc"}, "originalPosition": 148}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgyMDYxMTc2OnYy", "diffSide": "RIGHT", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/plans/RecordQueryIntersectionPlan.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOVQxNzo0Mzo0MlrOGvbc2w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOVQxNzo0Mzo0MlrOGvbc2w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjM4NjAxMQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public boolean resultEquals(final Object other, final BiMap<CorrelationIdentifier, CorrelationIdentifier> equivalenceMap) {\n          \n          \n            \n                public boolean resultEquals(@Nullable final Object other, @Nonnull final BiMap<CorrelationIdentifier, CorrelationIdentifier> equivalenceMap) {", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/988#discussion_r452386011", "createdAt": "2020-07-09T17:43:42Z", "author": {"login": "nschiefer"}, "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/plans/RecordQueryIntersectionPlan.java", "diffHunk": "@@ -178,17 +212,30 @@ public boolean equalsWithoutChildren(@Nonnull RelationalExpression otherExpressi\n     }\n \n     @Override\n-    public boolean equals(Object o) {\n-        if (this == o) {\n-            return true;\n+    public boolean resultEquals(final Object other, final BiMap<CorrelationIdentifier, CorrelationIdentifier> equivalenceMap) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6eb7142ab316ffbec53e375804118f722f1d2bcc"}, "originalPosition": 159}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgyMDYxNDYwOnYy", "diffSide": "RIGHT", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/plans/RecordQueryLoadByKeysPlan.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOVQxNzo0NDozNVrOGvbeuQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOVQxNzo0NDozNVrOGvbeuQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjM4NjQ4OQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public RecordQueryLoadByKeysPlan rebase(final Map<CorrelationIdentifier, CorrelationIdentifier> translationMap) {\n          \n          \n            \n                public RecordQueryLoadByKeysPlan rebase(@Nonnull final Map<CorrelationIdentifier, CorrelationIdentifier> translationMap) {", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/988#discussion_r452386489", "createdAt": "2020-07-09T17:44:35Z", "author": {"login": "nschiefer"}, "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/plans/RecordQueryLoadByKeysPlan.java", "diffHunk": "@@ -130,22 +135,47 @@ public String toString() {\n         return \"ByKeys(\" + getKeysSource() + \")\";\n     }\n \n+    @Nonnull\n+    @Override\n+    @API(API.Status.EXPERIMENTAL)\n+    public Set<CorrelationIdentifier> getCorrelatedTo() {\n+        return ImmutableSet.of(); // TODO this should be reconsidered when we have selects\n+    }\n+\n+    @Nonnull\n+    @Override\n+    @API(API.Status.EXPERIMENTAL)\n+    public RecordQueryLoadByKeysPlan rebase(final Map<CorrelationIdentifier, CorrelationIdentifier> translationMap) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6eb7142ab316ffbec53e375804118f722f1d2bcc"}, "originalPosition": 39}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgyMDYxNTQxOnYy", "diffSide": "RIGHT", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/plans/RecordQueryLoadByKeysPlan.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOVQxNzo0NDo0OVrOGvbfRw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOVQxNzo0NDo0OVrOGvbfRw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjM4NjYzMQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public boolean equalsWithoutChildren(@Nonnull RelationalExpression otherExpression, final BiMap<CorrelationIdentifier, CorrelationIdentifier> equivalencesMap) {\n          \n          \n            \n                public boolean equalsWithoutChildren(@Nonnull RelationalExpression otherExpression, @Nonnull final BiMap<CorrelationIdentifier, CorrelationIdentifier> equivalencesMap) {", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/988#discussion_r452386631", "createdAt": "2020-07-09T17:44:49Z", "author": {"login": "nschiefer"}, "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/plans/RecordQueryLoadByKeysPlan.java", "diffHunk": "@@ -130,22 +135,47 @@ public String toString() {\n         return \"ByKeys(\" + getKeysSource() + \")\";\n     }\n \n+    @Nonnull\n+    @Override\n+    @API(API.Status.EXPERIMENTAL)\n+    public Set<CorrelationIdentifier> getCorrelatedTo() {\n+        return ImmutableSet.of(); // TODO this should be reconsidered when we have selects\n+    }\n+\n+    @Nonnull\n+    @Override\n+    @API(API.Status.EXPERIMENTAL)\n+    public RecordQueryLoadByKeysPlan rebase(final Map<CorrelationIdentifier, CorrelationIdentifier> translationMap) {\n+        return this;\n+    }\n+\n     @Override\n     @API(API.Status.EXPERIMENTAL)\n-    public boolean equalsWithoutChildren(@Nonnull RelationalExpression otherExpression) {\n-        return otherExpression instanceof RecordQueryLoadByKeysPlan;\n+    public boolean equalsWithoutChildren(@Nonnull RelationalExpression otherExpression, final BiMap<CorrelationIdentifier, CorrelationIdentifier> equivalencesMap) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6eb7142ab316ffbec53e375804118f722f1d2bcc"}, "originalPosition": 47}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgyMDYxNjg0OnYy", "diffSide": "RIGHT", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/plans/RecordQueryLoadByKeysPlan.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOVQxNzo0NToxNlrOGvbgOQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOVQxNzo0NToxNlrOGvbgOQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjM4Njg3Mw==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public boolean resultEquals(final Object other, final BiMap<CorrelationIdentifier, CorrelationIdentifier> equivalenceMap) {\n          \n          \n            \n                public boolean resultEquals(@Nullable final Object other, @Nonnull final BiMap<CorrelationIdentifier, CorrelationIdentifier> equivalenceMap) {", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/988#discussion_r452386873", "createdAt": "2020-07-09T17:45:16Z", "author": {"login": "nschiefer"}, "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/plans/RecordQueryLoadByKeysPlan.java", "diffHunk": "@@ -130,22 +135,47 @@ public String toString() {\n         return \"ByKeys(\" + getKeysSource() + \")\";\n     }\n \n+    @Nonnull\n+    @Override\n+    @API(API.Status.EXPERIMENTAL)\n+    public Set<CorrelationIdentifier> getCorrelatedTo() {\n+        return ImmutableSet.of(); // TODO this should be reconsidered when we have selects\n+    }\n+\n+    @Nonnull\n+    @Override\n+    @API(API.Status.EXPERIMENTAL)\n+    public RecordQueryLoadByKeysPlan rebase(final Map<CorrelationIdentifier, CorrelationIdentifier> translationMap) {\n+        return this;\n+    }\n+\n     @Override\n     @API(API.Status.EXPERIMENTAL)\n-    public boolean equalsWithoutChildren(@Nonnull RelationalExpression otherExpression) {\n-        return otherExpression instanceof RecordQueryLoadByKeysPlan;\n+    public boolean equalsWithoutChildren(@Nonnull RelationalExpression otherExpression, final BiMap<CorrelationIdentifier, CorrelationIdentifier> equivalencesMap) {\n+        if (!(otherExpression instanceof RecordQueryLoadByKeysPlan)) {\n+            return false;\n+        }\n+\n+        return Objects.equals(getKeysSource(), ((RecordQueryLoadByKeysPlan)otherExpression).getKeysSource());\n     }\n \n     @Override\n-    public boolean equals(Object o) {\n-        if (this == o) {\n+    @API(API.Status.EXPERIMENTAL)\n+    public boolean resultEquals(final Object other, final BiMap<CorrelationIdentifier, CorrelationIdentifier> equivalenceMap) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6eb7142ab316ffbec53e375804118f722f1d2bcc"}, "originalPosition": 59}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgyMDYxODYyOnYy", "diffSide": "RIGHT", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/plans/RecordQueryPredicateFilterPlan.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOVQxNzo0NTo1MFrOGvbhbQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOVQxNzo0NTo1MFrOGvbhbQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjM4NzE4MQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public RecordQueryPredicateFilterPlan rebaseWithRebasedQuantifiers(final Map<CorrelationIdentifier, CorrelationIdentifier> translationMap, final List<Quantifier> rebasedQuantifiers) {\n          \n          \n            \n                public RecordQueryPredicateFilterPlan rebaseWithRebasedQuantifiers(@Nonnull final Map<CorrelationIdentifier, CorrelationIdentifier> translationMap, @Nonnull final List<Quantifier> rebasedQuantifiers) {", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/988#discussion_r452387181", "createdAt": "2020-07-09T17:45:50Z", "author": {"login": "nschiefer"}, "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/plans/RecordQueryPredicateFilterPlan.java", "diffHunk": "@@ -110,39 +109,50 @@ public QueryPredicate getPredicate() {\n         return filter;\n     }\n \n-\n+    @Nonnull\n     @Override\n-    public boolean equalsWithoutChildren(@Nonnull RelationalExpression otherExpression) {\n-        return otherExpression instanceof RecordQueryPredicateFilterPlan;\n+    public Set<CorrelationIdentifier> getCorrelatedToWithoutChildren() {\n+        return filter.getCorrelatedTo();\n     }\n \n+    @Nonnull\n     @Override\n-    public String toString() {\n-        return getInner() + \" | \" + getPredicate();\n+    public RecordQueryPredicateFilterPlan rebaseWithRebasedQuantifiers(final Map<CorrelationIdentifier, CorrelationIdentifier> translationMap, final List<Quantifier> rebasedQuantifiers) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6eb7142ab316ffbec53e375804118f722f1d2bcc"}, "originalPosition": 63}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgyMDYyMDIzOnYy", "diffSide": "RIGHT", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/plans/RecordQueryPredicateFilterPlan.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOVQxNzo0NjoxOFrOGvbibA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOVQxNzo0NjoxOFrOGvbibA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjM4NzQzNg==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public boolean equalsWithoutChildren(@Nonnull RelationalExpression otherExpression, final BiMap<CorrelationIdentifier, CorrelationIdentifier> equivalencesMap) {\n          \n          \n            \n                public boolean equalsWithoutChildren(@Nonnull RelationalExpression otherExpression, @Nonnull final BiMap<CorrelationIdentifier, CorrelationIdentifier> equivalencesMap) {", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/988#discussion_r452387436", "createdAt": "2020-07-09T17:46:18Z", "author": {"login": "nschiefer"}, "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/plans/RecordQueryPredicateFilterPlan.java", "diffHunk": "@@ -110,39 +109,50 @@ public QueryPredicate getPredicate() {\n         return filter;\n     }\n \n-\n+    @Nonnull\n     @Override\n-    public boolean equalsWithoutChildren(@Nonnull RelationalExpression otherExpression) {\n-        return otherExpression instanceof RecordQueryPredicateFilterPlan;\n+    public Set<CorrelationIdentifier> getCorrelatedToWithoutChildren() {\n+        return filter.getCorrelatedTo();\n     }\n \n+    @Nonnull\n     @Override\n-    public String toString() {\n-        return getInner() + \" | \" + getPredicate();\n+    public RecordQueryPredicateFilterPlan rebaseWithRebasedQuantifiers(final Map<CorrelationIdentifier, CorrelationIdentifier> translationMap, final List<Quantifier> rebasedQuantifiers) {\n+        return new RecordQueryPredicateFilterPlan((Quantifier.Physical)Iterables.getOnlyElement(rebasedQuantifiers),\n+                getBaseSource(),\n+                getPredicate().rebase(translationMap));\n     }\n \n     @Override\n-    public boolean equals(Object o) {\n-        if (this == o) {\n-            return true;\n-        }\n-        if (o == null || getClass() != o.getClass()) {\n+    public boolean equalsWithoutChildren(@Nonnull RelationalExpression otherExpression, final BiMap<CorrelationIdentifier, CorrelationIdentifier> equivalencesMap) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6eb7142ab316ffbec53e375804118f722f1d2bcc"}, "originalPosition": 75}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgyMDYyMzYxOnYy", "diffSide": "RIGHT", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/plans/RecordQueryScanPlan.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOVQxNzo0NzoxOFrOGvbkjQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOVQxNzo0NzoxOFrOGvbkjQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjM4Nzk4MQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public RecordQueryScanPlan rebase(final Map<CorrelationIdentifier, CorrelationIdentifier> translationMap) {\n          \n          \n            \n                public RecordQueryScanPlan rebase(@Nonnull final Map<CorrelationIdentifier, CorrelationIdentifier> translationMap) {", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/988#discussion_r452387981", "createdAt": "2020-07-09T17:47:18Z", "author": {"login": "nschiefer"}, "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/plans/RecordQueryScanPlan.java", "diffHunk": "@@ -147,26 +151,52 @@ public String toString() {\n         return \"Scan(\" + range + \")\";\n     }\n \n+    @Nonnull\n     @Override\n     @API(API.Status.EXPERIMENTAL)\n-    public boolean equalsWithoutChildren(@Nonnull RelationalExpression otherExpression) {\n-        return equals(otherExpression);\n+    public Set<CorrelationIdentifier> getCorrelatedTo() {\n+        return ImmutableSet.of();\n     }\n \n+    @Nonnull\n     @Override\n-    public boolean equals(Object o) {\n-        if (this == o) {\n-            return true;\n-        }\n-        if (o == null || getClass() != o.getClass()) {\n+    @API(API.Status.EXPERIMENTAL)\n+    public RecordQueryScanPlan rebase(final Map<CorrelationIdentifier, CorrelationIdentifier> translationMap) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6eb7142ab316ffbec53e375804118f722f1d2bcc"}, "originalPosition": 45}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgyMDYyNDU1OnYy", "diffSide": "RIGHT", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/plans/RecordQueryScanPlan.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOVQxNzo0NzozNlrOGvblMA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNVQyMDo0NjoyNFrOG8aAGw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjM4ODE0NA==", "bodyText": "Couldn't this just return this, since it's uncorrelated?", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/988#discussion_r452388144", "createdAt": "2020-07-09T17:47:36Z", "author": {"login": "nschiefer"}, "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/plans/RecordQueryScanPlan.java", "diffHunk": "@@ -147,26 +151,52 @@ public String toString() {\n         return \"Scan(\" + range + \")\";\n     }\n \n+    @Nonnull\n     @Override\n     @API(API.Status.EXPERIMENTAL)\n-    public boolean equalsWithoutChildren(@Nonnull RelationalExpression otherExpression) {\n-        return equals(otherExpression);\n+    public Set<CorrelationIdentifier> getCorrelatedTo() {\n+        return ImmutableSet.of();\n     }\n \n+    @Nonnull\n     @Override\n-    public boolean equals(Object o) {\n-        if (this == o) {\n-            return true;\n-        }\n-        if (o == null || getClass() != o.getClass()) {\n+    @API(API.Status.EXPERIMENTAL)\n+    public RecordQueryScanPlan rebase(final Map<CorrelationIdentifier, CorrelationIdentifier> translationMap) {\n+        return new RecordQueryScanPlan(getComparisons(), isReverse());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6eb7142ab316ffbec53e375804118f722f1d2bcc"}, "originalPosition": 46}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDYzODE0Nw==", "bodyText": "^", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/988#discussion_r464638147", "createdAt": "2020-08-03T20:14:34Z", "author": {"login": "nschiefer"}, "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/plans/RecordQueryScanPlan.java", "diffHunk": "@@ -147,26 +151,52 @@ public String toString() {\n         return \"Scan(\" + range + \")\";\n     }\n \n+    @Nonnull\n     @Override\n     @API(API.Status.EXPERIMENTAL)\n-    public boolean equalsWithoutChildren(@Nonnull RelationalExpression otherExpression) {\n-        return equals(otherExpression);\n+    public Set<CorrelationIdentifier> getCorrelatedTo() {\n+        return ImmutableSet.of();\n     }\n \n+    @Nonnull\n     @Override\n-    public boolean equals(Object o) {\n-        if (this == o) {\n-            return true;\n-        }\n-        if (o == null || getClass() != o.getClass()) {\n+    @API(API.Status.EXPERIMENTAL)\n+    public RecordQueryScanPlan rebase(final Map<CorrelationIdentifier, CorrelationIdentifier> translationMap) {\n+        return new RecordQueryScanPlan(getComparisons(), isReverse());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjM4ODE0NA=="}, "originalCommit": {"oid": "6eb7142ab316ffbec53e375804118f722f1d2bcc"}, "originalPosition": 46}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTk5Mzc1NQ==", "bodyText": "^", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/988#discussion_r465993755", "createdAt": "2020-08-05T20:46:24Z", "author": {"login": "nschiefer"}, "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/plans/RecordQueryScanPlan.java", "diffHunk": "@@ -147,26 +151,52 @@ public String toString() {\n         return \"Scan(\" + range + \")\";\n     }\n \n+    @Nonnull\n     @Override\n     @API(API.Status.EXPERIMENTAL)\n-    public boolean equalsWithoutChildren(@Nonnull RelationalExpression otherExpression) {\n-        return equals(otherExpression);\n+    public Set<CorrelationIdentifier> getCorrelatedTo() {\n+        return ImmutableSet.of();\n     }\n \n+    @Nonnull\n     @Override\n-    public boolean equals(Object o) {\n-        if (this == o) {\n-            return true;\n-        }\n-        if (o == null || getClass() != o.getClass()) {\n+    @API(API.Status.EXPERIMENTAL)\n+    public RecordQueryScanPlan rebase(final Map<CorrelationIdentifier, CorrelationIdentifier> translationMap) {\n+        return new RecordQueryScanPlan(getComparisons(), isReverse());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjM4ODE0NA=="}, "originalCommit": {"oid": "6eb7142ab316ffbec53e375804118f722f1d2bcc"}, "originalPosition": 46}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgyMDYyNTAzOnYy", "diffSide": "RIGHT", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/plans/RecordQueryScanPlan.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOVQxNzo0Nzo0OFrOGvbllA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOVQxNzo0Nzo0OFrOGvbllA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjM4ODI0NA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public boolean equalsWithoutChildren(@Nonnull RelationalExpression otherExpression, final BiMap<CorrelationIdentifier, CorrelationIdentifier> equivalencesMap) {\n          \n          \n            \n                public boolean equalsWithoutChildren(@Nonnull RelationalExpression otherExpression, @Nonnull final BiMap<CorrelationIdentifier, CorrelationIdentifier> equivalencesMap) {", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/988#discussion_r452388244", "createdAt": "2020-07-09T17:47:48Z", "author": {"login": "nschiefer"}, "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/plans/RecordQueryScanPlan.java", "diffHunk": "@@ -147,26 +151,52 @@ public String toString() {\n         return \"Scan(\" + range + \")\";\n     }\n \n+    @Nonnull\n     @Override\n     @API(API.Status.EXPERIMENTAL)\n-    public boolean equalsWithoutChildren(@Nonnull RelationalExpression otherExpression) {\n-        return equals(otherExpression);\n+    public Set<CorrelationIdentifier> getCorrelatedTo() {\n+        return ImmutableSet.of();\n     }\n \n+    @Nonnull\n     @Override\n-    public boolean equals(Object o) {\n-        if (this == o) {\n-            return true;\n-        }\n-        if (o == null || getClass() != o.getClass()) {\n+    @API(API.Status.EXPERIMENTAL)\n+    public RecordQueryScanPlan rebase(final Map<CorrelationIdentifier, CorrelationIdentifier> translationMap) {\n+        return new RecordQueryScanPlan(getComparisons(), isReverse());\n+    }\n+\n+    @Override\n+    @API(API.Status.EXPERIMENTAL)\n+    public boolean equalsWithoutChildren(@Nonnull RelationalExpression otherExpression, final BiMap<CorrelationIdentifier, CorrelationIdentifier> equivalencesMap) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6eb7142ab316ffbec53e375804118f722f1d2bcc"}, "originalPosition": 51}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgyMDYyNzU5OnYy", "diffSide": "RIGHT", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/plans/RecordQueryScoreForRankPlan.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOVQxNzo0ODo0M1rOGvbnSg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOVQxNzo0ODo0M1rOGvbnSg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjM4ODY4Mg==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public RecordQueryScoreForRankPlan rebaseWithRebasedQuantifiers(final Map<CorrelationIdentifier, CorrelationIdentifier> translationMap, final List<Quantifier> rebasedQuantifiers) {\n          \n          \n            \n                public RecordQueryScoreForRankPlan rebaseWithRebasedQuantifiers(@Nonnull final Map<CorrelationIdentifier, CorrelationIdentifier> translationMap, @Nonnull final List<Quantifier> rebasedQuantifiers) {", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/988#discussion_r452388682", "createdAt": "2020-07-09T17:48:43Z", "author": {"login": "nschiefer"}, "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/plans/RecordQueryScoreForRankPlan.java", "diffHunk": "@@ -139,24 +150,32 @@ public String toString() {\n         return getChild() + \" WHERE \" + ranks.stream().map(Object::toString).collect(Collectors.joining(\", \"));\n     }\n \n+    @Nonnull\n+    @Override\n+    @API(API.Status.EXPERIMENTAL)\n+    public Set<CorrelationIdentifier> getCorrelatedToWithoutChildren() {\n+        return ImmutableSet.of();\n+    }\n+\n+    @Nonnull\n     @Override\n     @API(API.Status.EXPERIMENTAL)\n-    public boolean equalsWithoutChildren(@Nonnull RelationalExpression otherExpression) {\n+    public RecordQueryScoreForRankPlan rebaseWithRebasedQuantifiers(final Map<CorrelationIdentifier, CorrelationIdentifier> translationMap, final List<Quantifier> rebasedQuantifiers) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6eb7142ab316ffbec53e375804118f722f1d2bcc"}, "originalPosition": 81}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgyMDYyODI2OnYy", "diffSide": "RIGHT", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/plans/RecordQueryScoreForRankPlan.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOVQxNzo0ODo1NlrOGvbnvA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOVQxNzo0ODo1NlrOGvbnvA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjM4ODc5Ng==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public boolean equalsWithoutChildren(@Nonnull RelationalExpression otherExpression, final BiMap<CorrelationIdentifier, CorrelationIdentifier> equivalencesMap) {\n          \n          \n            \n                public boolean equalsWithoutChildren(@Nonnull RelationalExpression otherExpression, @Nonnull final BiMap<CorrelationIdentifier, CorrelationIdentifier> equivalencesMap) {", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/988#discussion_r452388796", "createdAt": "2020-07-09T17:48:56Z", "author": {"login": "nschiefer"}, "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/plans/RecordQueryScoreForRankPlan.java", "diffHunk": "@@ -139,24 +150,32 @@ public String toString() {\n         return getChild() + \" WHERE \" + ranks.stream().map(Object::toString).collect(Collectors.joining(\", \"));\n     }\n \n+    @Nonnull\n+    @Override\n+    @API(API.Status.EXPERIMENTAL)\n+    public Set<CorrelationIdentifier> getCorrelatedToWithoutChildren() {\n+        return ImmutableSet.of();\n+    }\n+\n+    @Nonnull\n     @Override\n     @API(API.Status.EXPERIMENTAL)\n-    public boolean equalsWithoutChildren(@Nonnull RelationalExpression otherExpression) {\n+    public RecordQueryScoreForRankPlan rebaseWithRebasedQuantifiers(final Map<CorrelationIdentifier, CorrelationIdentifier> translationMap, final List<Quantifier> rebasedQuantifiers) {\n+        return new RecordQueryScoreForRankPlan((Quantifier.Physical)Iterables.getOnlyElement(rebasedQuantifiers),\n+                getRanks());\n+    }\n+\n+    @Override\n+    @API(API.Status.EXPERIMENTAL)\n+    public boolean equalsWithoutChildren(@Nonnull RelationalExpression otherExpression, final BiMap<CorrelationIdentifier, CorrelationIdentifier> equivalencesMap) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6eb7142ab316ffbec53e375804118f722f1d2bcc"}, "originalPosition": 88}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgyMDYzMTE5OnYy", "diffSide": "RIGHT", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/plans/RecordQueryScoreForRankPlan.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOVQxNzo0OTo1OFrOGvbp6g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMFQxNjoyMzo0MVrOG0VzuA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjM4OTM1NA==", "bodyText": "Where is resultEquals() for this class?", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/988#discussion_r452389354", "createdAt": "2020-07-09T17:49:58Z", "author": {"login": "nschiefer"}, "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/plans/RecordQueryScoreForRankPlan.java", "diffHunk": "@@ -139,24 +150,32 @@ public String toString() {\n         return getChild() + \" WHERE \" + ranks.stream().map(Object::toString).collect(Collectors.joining(\", \"));\n     }\n \n+    @Nonnull\n+    @Override\n+    @API(API.Status.EXPERIMENTAL)\n+    public Set<CorrelationIdentifier> getCorrelatedToWithoutChildren() {\n+        return ImmutableSet.of();\n+    }\n+\n+    @Nonnull\n     @Override\n     @API(API.Status.EXPERIMENTAL)\n-    public boolean equalsWithoutChildren(@Nonnull RelationalExpression otherExpression) {\n+    public RecordQueryScoreForRankPlan rebaseWithRebasedQuantifiers(final Map<CorrelationIdentifier, CorrelationIdentifier> translationMap, final List<Quantifier> rebasedQuantifiers) {\n+        return new RecordQueryScoreForRankPlan((Quantifier.Physical)Iterables.getOnlyElement(rebasedQuantifiers),\n+                getRanks());\n+    }\n+\n+    @Override\n+    @API(API.Status.EXPERIMENTAL)\n+    public boolean equalsWithoutChildren(@Nonnull RelationalExpression otherExpression, final BiMap<CorrelationIdentifier, CorrelationIdentifier> equivalencesMap) {\n         return otherExpression instanceof RecordQueryScoreForRankPlan &&\n                ranks.equals(((RecordQueryScoreForRankPlan) otherExpression).ranks);\n     }\n \n+    @SuppressWarnings(\"EqualsWhichDoesntCheckParameterClass\")\n     @Override\n-    public boolean equals(Object o) {\n-        if (this == o) {\n-            return true;\n-        }\n-        if (o == null || getClass() != o.getClass()) {\n-            return false;\n-        }\n-        RecordQueryScoreForRankPlan that = (RecordQueryScoreForRankPlan) o;\n-        return Objects.equals(getChild(), that.getChild()) &&\n-                Objects.equals(ranks, that.ranks);\n+    public boolean equals(final Object other) {\n+        return resultEquals(other, ImmutableBiMap.of());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6eb7142ab316ffbec53e375804118f722f1d2bcc"}, "originalPosition": 106}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzUzNjQ0MA==", "bodyText": "This has changed in general since you reviewed this. resultEquals() is only implemented in RelationalExpression which is much nicer. That generic implementation then does the necessary things and defers to equalsWithoutChildren() after establishing result equality of the children.", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/988#discussion_r457536440", "createdAt": "2020-07-20T16:23:41Z", "author": {"login": "normen662"}, "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/plans/RecordQueryScoreForRankPlan.java", "diffHunk": "@@ -139,24 +150,32 @@ public String toString() {\n         return getChild() + \" WHERE \" + ranks.stream().map(Object::toString).collect(Collectors.joining(\", \"));\n     }\n \n+    @Nonnull\n+    @Override\n+    @API(API.Status.EXPERIMENTAL)\n+    public Set<CorrelationIdentifier> getCorrelatedToWithoutChildren() {\n+        return ImmutableSet.of();\n+    }\n+\n+    @Nonnull\n     @Override\n     @API(API.Status.EXPERIMENTAL)\n-    public boolean equalsWithoutChildren(@Nonnull RelationalExpression otherExpression) {\n+    public RecordQueryScoreForRankPlan rebaseWithRebasedQuantifiers(final Map<CorrelationIdentifier, CorrelationIdentifier> translationMap, final List<Quantifier> rebasedQuantifiers) {\n+        return new RecordQueryScoreForRankPlan((Quantifier.Physical)Iterables.getOnlyElement(rebasedQuantifiers),\n+                getRanks());\n+    }\n+\n+    @Override\n+    @API(API.Status.EXPERIMENTAL)\n+    public boolean equalsWithoutChildren(@Nonnull RelationalExpression otherExpression, final BiMap<CorrelationIdentifier, CorrelationIdentifier> equivalencesMap) {\n         return otherExpression instanceof RecordQueryScoreForRankPlan &&\n                ranks.equals(((RecordQueryScoreForRankPlan) otherExpression).ranks);\n     }\n \n+    @SuppressWarnings(\"EqualsWhichDoesntCheckParameterClass\")\n     @Override\n-    public boolean equals(Object o) {\n-        if (this == o) {\n-            return true;\n-        }\n-        if (o == null || getClass() != o.getClass()) {\n-            return false;\n-        }\n-        RecordQueryScoreForRankPlan that = (RecordQueryScoreForRankPlan) o;\n-        return Objects.equals(getChild(), that.getChild()) &&\n-                Objects.equals(ranks, that.ranks);\n+    public boolean equals(final Object other) {\n+        return resultEquals(other, ImmutableBiMap.of());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjM4OTM1NA=="}, "originalCommit": {"oid": "6eb7142ab316ffbec53e375804118f722f1d2bcc"}, "originalPosition": 106}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgyMDYzNDM4OnYy", "diffSide": "RIGHT", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/plans/RecordQueryTextIndexPlan.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOVQxNzo1MDo1MlrOGvbr5Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOVQxNzo1MDo1MlrOGvbr5Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjM4OTg2MQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public RecordQueryTextIndexPlan rebase(final Map<CorrelationIdentifier, CorrelationIdentifier> translationMap) {\n          \n          \n            \n                public RecordQueryTextIndexPlan rebase(@Nonnull final Map<CorrelationIdentifier, CorrelationIdentifier> translationMap) {", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/988#discussion_r452389861", "createdAt": "2020-07-09T17:50:52Z", "author": {"login": "nschiefer"}, "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/plans/RecordQueryTextIndexPlan.java", "diffHunk": "@@ -132,27 +136,52 @@ public int getComplexity() {\n         return 1;\n     }\n \n+    @Nonnull\n+    @Override\n+    @API(API.Status.EXPERIMENTAL)\n+    public Set<CorrelationIdentifier> getCorrelatedTo() {\n+        return ImmutableSet.of();\n+    }\n+\n+    @Nonnull\n+    @Override\n+    @API(API.Status.EXPERIMENTAL)\n+    public RecordQueryTextIndexPlan rebase(final Map<CorrelationIdentifier, CorrelationIdentifier> translationMap) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6eb7142ab316ffbec53e375804118f722f1d2bcc"}, "originalPosition": 26}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgyMDYzNTIyOnYy", "diffSide": "RIGHT", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/plans/RecordQueryTextIndexPlan.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOVQxNzo1MTowN1rOGvbscg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOVQxNzo1MTowN1rOGvbscg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjM5MDAwMg==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    return new RecordQueryTextIndexPlan(getIndexName(),\n          \n          \n            \n                            getTextScan(),\n          \n          \n            \n                            isReverse());\n          \n          \n            \n                    return new RecordQueryTextIndexPlan(getIndexName(), getTextScan(), isReverse());", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/988#discussion_r452390002", "createdAt": "2020-07-09T17:51:07Z", "author": {"login": "nschiefer"}, "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/plans/RecordQueryTextIndexPlan.java", "diffHunk": "@@ -132,27 +136,52 @@ public int getComplexity() {\n         return 1;\n     }\n \n+    @Nonnull\n+    @Override\n+    @API(API.Status.EXPERIMENTAL)\n+    public Set<CorrelationIdentifier> getCorrelatedTo() {\n+        return ImmutableSet.of();\n+    }\n+\n+    @Nonnull\n+    @Override\n+    @API(API.Status.EXPERIMENTAL)\n+    public RecordQueryTextIndexPlan rebase(final Map<CorrelationIdentifier, CorrelationIdentifier> translationMap) {\n+        return new RecordQueryTextIndexPlan(getIndexName(),\n+                getTextScan(),\n+                isReverse());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6eb7142ab316ffbec53e375804118f722f1d2bcc"}, "originalPosition": 29}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgyMDYzNTgxOnYy", "diffSide": "RIGHT", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/plans/RecordQueryTextIndexPlan.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOVQxNzo1MToyMFrOGvbs2A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOVQxNzo1MToyMFrOGvbs2A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjM5MDEwNA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public boolean equalsWithoutChildren(@Nonnull RelationalExpression otherExpression, final BiMap<CorrelationIdentifier, CorrelationIdentifier> equivalencesMap) {\n          \n          \n            \n                public boolean equalsWithoutChildren(@Nonnull RelationalExpression otherExpression, @Nonnull final BiMap<CorrelationIdentifier, CorrelationIdentifier> equivalencesMap) {", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/988#discussion_r452390104", "createdAt": "2020-07-09T17:51:20Z", "author": {"login": "nschiefer"}, "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/plans/RecordQueryTextIndexPlan.java", "diffHunk": "@@ -132,27 +136,52 @@ public int getComplexity() {\n         return 1;\n     }\n \n+    @Nonnull\n+    @Override\n+    @API(API.Status.EXPERIMENTAL)\n+    public Set<CorrelationIdentifier> getCorrelatedTo() {\n+        return ImmutableSet.of();\n+    }\n+\n+    @Nonnull\n+    @Override\n+    @API(API.Status.EXPERIMENTAL)\n+    public RecordQueryTextIndexPlan rebase(final Map<CorrelationIdentifier, CorrelationIdentifier> translationMap) {\n+        return new RecordQueryTextIndexPlan(getIndexName(),\n+                getTextScan(),\n+                isReverse());\n+    }\n+\n     @Override\n     @API(API.Status.EXPERIMENTAL)\n-    public boolean equalsWithoutChildren(@Nonnull RelationalExpression otherExpression) {\n+    public boolean equalsWithoutChildren(@Nonnull RelationalExpression otherExpression, final BiMap<CorrelationIdentifier, CorrelationIdentifier> equivalencesMap) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6eb7142ab316ffbec53e375804118f722f1d2bcc"}, "originalPosition": 35}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgyMDYzNzYyOnYy", "diffSide": "RIGHT", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/plans/RecordQueryTextIndexPlan.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOVQxNzo1MTo1NVrOGvbuCw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOVQxNzo1MTo1NVrOGvbuCw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjM5MDQxMQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public boolean resultEquals(final Object other, final BiMap<CorrelationIdentifier, CorrelationIdentifier> equivalenceMap) {\n          \n          \n            \n                public boolean resultEquals(@Nullable final Object other, @Nonnull final BiMap<CorrelationIdentifier, CorrelationIdentifier> equivalenceMap) {", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/988#discussion_r452390411", "createdAt": "2020-07-09T17:51:55Z", "author": {"login": "nschiefer"}, "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/plans/RecordQueryTextIndexPlan.java", "diffHunk": "@@ -132,27 +136,52 @@ public int getComplexity() {\n         return 1;\n     }\n \n+    @Nonnull\n+    @Override\n+    @API(API.Status.EXPERIMENTAL)\n+    public Set<CorrelationIdentifier> getCorrelatedTo() {\n+        return ImmutableSet.of();\n+    }\n+\n+    @Nonnull\n+    @Override\n+    @API(API.Status.EXPERIMENTAL)\n+    public RecordQueryTextIndexPlan rebase(final Map<CorrelationIdentifier, CorrelationIdentifier> translationMap) {\n+        return new RecordQueryTextIndexPlan(getIndexName(),\n+                getTextScan(),\n+                isReverse());\n+    }\n+\n     @Override\n     @API(API.Status.EXPERIMENTAL)\n-    public boolean equalsWithoutChildren(@Nonnull RelationalExpression otherExpression) {\n+    public boolean equalsWithoutChildren(@Nonnull RelationalExpression otherExpression, final BiMap<CorrelationIdentifier, CorrelationIdentifier> equivalencesMap) {\n         if (!(otherExpression instanceof RecordQueryTextIndexPlan)) {\n             return false;\n         }\n-        final RecordQueryTextIndexPlan other = (RecordQueryTextIndexPlan) otherExpression;\n-        return reverse == other.reverse && indexName.equals(other.indexName) && textScan.equals(other.textScan);\n+\n+        final RecordQueryTextIndexPlan that = (RecordQueryTextIndexPlan)otherExpression;\n+        return this.reverse == that.reverse &&\n+               this.indexName.equals(that.indexName) &&\n+               this.textScan.equals(that.textScan);\n     }\n \n     @Override\n-    public boolean equals(Object o) {\n-        if (this == o) {\n+    @API(API.Status.EXPERIMENTAL)\n+    public boolean resultEquals(final Object other, final BiMap<CorrelationIdentifier, CorrelationIdentifier> equivalenceMap) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6eb7142ab316ffbec53e375804118f722f1d2bcc"}, "originalPosition": 52}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgyMDYzOTA0OnYy", "diffSide": "RIGHT", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/plans/RecordQueryTypeFilterPlan.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOVQxNzo1MjoyMFrOGvbu8g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOVQxNzo1MjoyMFrOGvbu8g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjM5MDY0Mg==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public RecordQueryTypeFilterPlan rebaseWithRebasedQuantifiers(final Map<CorrelationIdentifier, CorrelationIdentifier> translationMap, final List<Quantifier> rebasedQuantifiers) {\n          \n          \n            \n                public RecordQueryTypeFilterPlan rebaseWithRebasedQuantifiers(@Nonnull final Map<CorrelationIdentifier, CorrelationIdentifier> translationMap, @Nonnull final List<Quantifier> rebasedQuantifiers) {", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/988#discussion_r452390642", "createdAt": "2020-07-09T17:52:20Z", "author": {"login": "nschiefer"}, "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/plans/RecordQueryTypeFilterPlan.java", "diffHunk": "@@ -113,24 +115,17 @@ public String toString() {\n         return getInner() + \" | \" + recordTypes;\n     }\n \n+    @Nonnull\n     @Override\n     @API(API.Status.EXPERIMENTAL)\n-    public boolean equalsWithoutChildren(@Nonnull RelationalExpression otherExpression) {\n-        return otherExpression instanceof RecordQueryTypeFilterPlan &&\n-               recordTypes.equals(((RecordQueryTypeFilterPlan)otherExpression).recordTypes);\n+    public RecordQueryTypeFilterPlan rebaseWithRebasedQuantifiers(final Map<CorrelationIdentifier, CorrelationIdentifier> translationMap, final List<Quantifier> rebasedQuantifiers) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6eb7142ab316ffbec53e375804118f722f1d2bcc"}, "originalPosition": 70}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgyMDY0MjA1OnYy", "diffSide": "RIGHT", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/plans/RecordQueryTypeFilterPlan.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOVQxNzo1MzoxNlrOGvbw6w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMFQyMjo0NToyMlrOG0h1QA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjM5MTE0Nw==", "bodyText": "This patterns shows up so often (and looks sufficiently confusing if you don't know what specifically is going on) that I think we should make it into a utility method on RecordQueryPlan or something along those lines.", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/988#discussion_r452391147", "createdAt": "2020-07-09T17:53:16Z", "author": {"login": "nschiefer"}, "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/plans/RecordQueryTypeFilterPlan.java", "diffHunk": "@@ -113,24 +115,17 @@ public String toString() {\n         return getInner() + \" | \" + recordTypes;\n     }\n \n+    @Nonnull\n     @Override\n     @API(API.Status.EXPERIMENTAL)\n-    public boolean equalsWithoutChildren(@Nonnull RelationalExpression otherExpression) {\n-        return otherExpression instanceof RecordQueryTypeFilterPlan &&\n-               recordTypes.equals(((RecordQueryTypeFilterPlan)otherExpression).recordTypes);\n+    public RecordQueryTypeFilterPlan rebaseWithRebasedQuantifiers(final Map<CorrelationIdentifier, CorrelationIdentifier> translationMap, final List<Quantifier> rebasedQuantifiers) {\n+        return new RecordQueryTypeFilterPlan((Quantifier.Physical)Iterables.getOnlyElement(rebasedQuantifiers), getRecordTypes());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6eb7142ab316ffbec53e375804118f722f1d2bcc"}, "originalPosition": 71}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzczMzQ0MA==", "bodyText": "Added a helper to narrow the type.", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/988#discussion_r457733440", "createdAt": "2020-07-20T22:45:22Z", "author": {"login": "normen662"}, "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/plans/RecordQueryTypeFilterPlan.java", "diffHunk": "@@ -113,24 +115,17 @@ public String toString() {\n         return getInner() + \" | \" + recordTypes;\n     }\n \n+    @Nonnull\n     @Override\n     @API(API.Status.EXPERIMENTAL)\n-    public boolean equalsWithoutChildren(@Nonnull RelationalExpression otherExpression) {\n-        return otherExpression instanceof RecordQueryTypeFilterPlan &&\n-               recordTypes.equals(((RecordQueryTypeFilterPlan)otherExpression).recordTypes);\n+    public RecordQueryTypeFilterPlan rebaseWithRebasedQuantifiers(final Map<CorrelationIdentifier, CorrelationIdentifier> translationMap, final List<Quantifier> rebasedQuantifiers) {\n+        return new RecordQueryTypeFilterPlan((Quantifier.Physical)Iterables.getOnlyElement(rebasedQuantifiers), getRecordTypes());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjM5MTE0Nw=="}, "originalCommit": {"oid": "6eb7142ab316ffbec53e375804118f722f1d2bcc"}, "originalPosition": 71}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgyMDY0NTYwOnYy", "diffSide": "RIGHT", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/plans/RecordQueryUnionPlan.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOVQxNzo1NDozMVrOGvbzYw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wM1QyMDoxNToyMVrOG7HSWA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjM5MTc3OQ==", "bodyText": "This code style (here and elsewhere) feels pretty unidiomatic in the Record Layer when all of the parameters are \"short\". Can you collapse them down into a single second line here and elsewhere among the RecordQueryPlan classes?", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/988#discussion_r452391779", "createdAt": "2020-07-09T17:54:31Z", "author": {"login": "nschiefer"}, "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/plans/RecordQueryUnionPlan.java", "diffHunk": "@@ -92,18 +103,24 @@ public RecordQueryUnionPlan(@Nonnull RecordQueryPlan left, @Nonnull RecordQueryP\n      */\n     @API(API.Status.DEPRECATED)\n     @Deprecated\n-    public RecordQueryUnionPlan(@Nonnull List<RecordQueryPlan> children,\n-                                @Nonnull KeyExpression comparisonKey, boolean reverse, boolean showComparisonKey) {\n-        this(children.stream().map(GroupExpressionRef::of).collect(Collectors.toList()), comparisonKey,\n-                reverse, showComparisonKey, false);\n+    public RecordQueryUnionPlan(@Nonnull final List<RecordQueryPlan> children,\n+                                @Nonnull final KeyExpression comparisonKey,\n+                                final boolean reverse,\n+                                final boolean showComparisonKey) {\n+        this(Quantifiers.fromPlans(children.stream().map(GroupExpressionRef::of).collect(Collectors.toList())),\n+                comparisonKey,\n+                reverse,\n+                showComparisonKey,\n+                false);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6eb7142ab316ffbec53e375804118f722f1d2bcc"}, "originalPosition": 66}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzUzODU3Mw==", "bodyText": "I actually have significant trouble quick-parsing that in my head if it is collapsed. Are you okay with leaving this and other places?", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/988#discussion_r457538573", "createdAt": "2020-07-20T16:26:58Z", "author": {"login": "normen662"}, "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/plans/RecordQueryUnionPlan.java", "diffHunk": "@@ -92,18 +103,24 @@ public RecordQueryUnionPlan(@Nonnull RecordQueryPlan left, @Nonnull RecordQueryP\n      */\n     @API(API.Status.DEPRECATED)\n     @Deprecated\n-    public RecordQueryUnionPlan(@Nonnull List<RecordQueryPlan> children,\n-                                @Nonnull KeyExpression comparisonKey, boolean reverse, boolean showComparisonKey) {\n-        this(children.stream().map(GroupExpressionRef::of).collect(Collectors.toList()), comparisonKey,\n-                reverse, showComparisonKey, false);\n+    public RecordQueryUnionPlan(@Nonnull final List<RecordQueryPlan> children,\n+                                @Nonnull final KeyExpression comparisonKey,\n+                                final boolean reverse,\n+                                final boolean showComparisonKey) {\n+        this(Quantifiers.fromPlans(children.stream().map(GroupExpressionRef::of).collect(Collectors.toList())),\n+                comparisonKey,\n+                reverse,\n+                showComparisonKey,\n+                false);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjM5MTc3OQ=="}, "originalCommit": {"oid": "6eb7142ab316ffbec53e375804118f722f1d2bcc"}, "originalPosition": 66}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDYzODU1Mg==", "bodyText": "Yeah, that's fine.", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/988#discussion_r464638552", "createdAt": "2020-08-03T20:15:21Z", "author": {"login": "nschiefer"}, "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/plans/RecordQueryUnionPlan.java", "diffHunk": "@@ -92,18 +103,24 @@ public RecordQueryUnionPlan(@Nonnull RecordQueryPlan left, @Nonnull RecordQueryP\n      */\n     @API(API.Status.DEPRECATED)\n     @Deprecated\n-    public RecordQueryUnionPlan(@Nonnull List<RecordQueryPlan> children,\n-                                @Nonnull KeyExpression comparisonKey, boolean reverse, boolean showComparisonKey) {\n-        this(children.stream().map(GroupExpressionRef::of).collect(Collectors.toList()), comparisonKey,\n-                reverse, showComparisonKey, false);\n+    public RecordQueryUnionPlan(@Nonnull final List<RecordQueryPlan> children,\n+                                @Nonnull final KeyExpression comparisonKey,\n+                                final boolean reverse,\n+                                final boolean showComparisonKey) {\n+        this(Quantifiers.fromPlans(children.stream().map(GroupExpressionRef::of).collect(Collectors.toList())),\n+                comparisonKey,\n+                reverse,\n+                showComparisonKey,\n+                false);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjM5MTc3OQ=="}, "originalCommit": {"oid": "6eb7142ab316ffbec53e375804118f722f1d2bcc"}, "originalPosition": 66}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgyMDY0NjQ1OnYy", "diffSide": "RIGHT", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/plans/RecordQueryUnionPlan.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOVQxNzo1NDo1MFrOGvb0Fw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOVQxNzo1NDo1MFrOGvb0Fw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjM5MTk1OQ==", "bodyText": "Same here, for that matter.", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/988#discussion_r452391959", "createdAt": "2020-07-09T17:54:50Z", "author": {"login": "nschiefer"}, "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/plans/RecordQueryUnionPlan.java", "diffHunk": "@@ -121,27 +138,31 @@ public KeyExpression getComparisonKey() {\n         return comparisonKey;\n     }\n \n+    @Nonnull\n     @Override\n     @API(API.Status.EXPERIMENTAL)\n-    public boolean equalsWithoutChildren(@Nonnull RelationalExpression otherExpression) {\n-        if (!(otherExpression instanceof RecordQueryUnionPlan)) {\n-            return false;\n-        }\n-        final RecordQueryUnionPlan other = (RecordQueryUnionPlan) otherExpression;\n-        return comparisonKey.equals(other.comparisonKey) &&\n-               isReverse() == other.isReverse();\n+    public Set<CorrelationIdentifier> getCorrelatedToWithoutChildren() {\n+        return ImmutableSet.of();\n     }\n \n+    @Nonnull\n     @Override\n-    public boolean equals(Object o) {\n-        if (this == o) {\n-            return true;\n-        }\n-        if (o == null || getClass() != o.getClass()) {\n+    public RecordQueryUnionPlan rebaseWithRebasedQuantifiers(final Map<CorrelationIdentifier, CorrelationIdentifier> translationMap, final List<Quantifier> rebasedQuantifiers) {\n+        return new RecordQueryUnionPlan(rebasedQuantifiers.stream().map(quantifier -> (Quantifier.Physical)quantifier).collect(Collectors.toList()),\n+                getComparisonKey(),\n+                isReverse(),\n+                showComparisonKey,\n+                false);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6eb7142ab316ffbec53e375804118f722f1d2bcc"}, "originalPosition": 113}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgyMDY0NjkzOnYy", "diffSide": "RIGHT", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/plans/RecordQueryUnionPlan.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOVQxNzo1NTowM1rOGvb0aQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOVQxNzo1NTowM1rOGvb0aQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjM5MjA0MQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public RecordQueryUnionPlan rebaseWithRebasedQuantifiers(final Map<CorrelationIdentifier, CorrelationIdentifier> translationMap, final List<Quantifier> rebasedQuantifiers) {\n          \n          \n            \n                public RecordQueryUnionPlan rebaseWithRebasedQuantifiers(@Nonnull final Map<CorrelationIdentifier, CorrelationIdentifier> translationMap, @Nonnull final List<Quantifier> rebasedQuantifiers) {", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/988#discussion_r452392041", "createdAt": "2020-07-09T17:55:03Z", "author": {"login": "nschiefer"}, "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/plans/RecordQueryUnionPlan.java", "diffHunk": "@@ -121,27 +138,31 @@ public KeyExpression getComparisonKey() {\n         return comparisonKey;\n     }\n \n+    @Nonnull\n     @Override\n     @API(API.Status.EXPERIMENTAL)\n-    public boolean equalsWithoutChildren(@Nonnull RelationalExpression otherExpression) {\n-        if (!(otherExpression instanceof RecordQueryUnionPlan)) {\n-            return false;\n-        }\n-        final RecordQueryUnionPlan other = (RecordQueryUnionPlan) otherExpression;\n-        return comparisonKey.equals(other.comparisonKey) &&\n-               isReverse() == other.isReverse();\n+    public Set<CorrelationIdentifier> getCorrelatedToWithoutChildren() {\n+        return ImmutableSet.of();\n     }\n \n+    @Nonnull\n     @Override\n-    public boolean equals(Object o) {\n-        if (this == o) {\n-            return true;\n-        }\n-        if (o == null || getClass() != o.getClass()) {\n+    public RecordQueryUnionPlan rebaseWithRebasedQuantifiers(final Map<CorrelationIdentifier, CorrelationIdentifier> translationMap, final List<Quantifier> rebasedQuantifiers) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6eb7142ab316ffbec53e375804118f722f1d2bcc"}, "originalPosition": 108}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgyMDY0ODY5OnYy", "diffSide": "RIGHT", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/plans/RecordQueryUnionPlan.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOVQxNzo1NTozNlrOGvb1kw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOVQxNzo1NTozNlrOGvb1kw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjM5MjMzOQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public boolean equalsWithoutChildren(@Nonnull RelationalExpression otherExpression, final BiMap<CorrelationIdentifier, CorrelationIdentifier> equivalencesMap) {\n          \n          \n            \n                public boolean equalsWithoutChildren(@Nonnull RelationalExpression otherExpression, @Nonnull final BiMap<CorrelationIdentifier, CorrelationIdentifier> equivalencesMap) {", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/988#discussion_r452392339", "createdAt": "2020-07-09T17:55:36Z", "author": {"login": "nschiefer"}, "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/plans/RecordQueryUnionPlan.java", "diffHunk": "@@ -121,27 +138,31 @@ public KeyExpression getComparisonKey() {\n         return comparisonKey;\n     }\n \n+    @Nonnull\n     @Override\n     @API(API.Status.EXPERIMENTAL)\n-    public boolean equalsWithoutChildren(@Nonnull RelationalExpression otherExpression) {\n-        if (!(otherExpression instanceof RecordQueryUnionPlan)) {\n-            return false;\n-        }\n-        final RecordQueryUnionPlan other = (RecordQueryUnionPlan) otherExpression;\n-        return comparisonKey.equals(other.comparisonKey) &&\n-               isReverse() == other.isReverse();\n+    public Set<CorrelationIdentifier> getCorrelatedToWithoutChildren() {\n+        return ImmutableSet.of();\n     }\n \n+    @Nonnull\n     @Override\n-    public boolean equals(Object o) {\n-        if (this == o) {\n-            return true;\n-        }\n-        if (o == null || getClass() != o.getClass()) {\n+    public RecordQueryUnionPlan rebaseWithRebasedQuantifiers(final Map<CorrelationIdentifier, CorrelationIdentifier> translationMap, final List<Quantifier> rebasedQuantifiers) {\n+        return new RecordQueryUnionPlan(rebasedQuantifiers.stream().map(quantifier -> (Quantifier.Physical)quantifier).collect(Collectors.toList()),\n+                getComparisonKey(),\n+                isReverse(),\n+                showComparisonKey,\n+                false);\n+    }\n+\n+    @Override\n+    @API(API.Status.EXPERIMENTAL)\n+    public boolean equalsWithoutChildren(@Nonnull RelationalExpression otherExpression, final BiMap<CorrelationIdentifier, CorrelationIdentifier> equivalencesMap) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6eb7142ab316ffbec53e375804118f722f1d2bcc"}, "originalPosition": 118}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgyMDY1Mjk0OnYy", "diffSide": "RIGHT", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/plans/RecordQueryUnionPlanBase.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOVQxNzo1Njo1OFrOGvb4Qw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOVQxNzo1Njo1OFrOGvb4Qw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjM5MzAyNw==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                                     final BiMap<CorrelationIdentifier, CorrelationIdentifier> equivalences) {\n          \n          \n            \n                                                     @Nonnull final BiMap<CorrelationIdentifier, CorrelationIdentifier> equivalences) {", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/988#discussion_r452393027", "createdAt": "2020-07-09T17:56:58Z", "author": {"login": "nschiefer"}, "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/plans/RecordQueryUnionPlanBase.java", "diffHunk": "@@ -115,20 +121,42 @@ public boolean isReverse() {\n     @Override\n     @API(API.Status.EXPERIMENTAL)\n     public List<? extends Quantifier> getQuantifiers() {\n-        return Quantifiers.fromPlans(children);\n+        return quantifiers;\n     }\n \n     @Override\n-    public boolean equals(Object o) {\n-        if (this == o) {\n-            return true;\n+    public boolean equalsWithoutChildren(@Nonnull final RelationalExpression other,\n+                                         final BiMap<CorrelationIdentifier, CorrelationIdentifier> equivalences) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6eb7142ab316ffbec53e375804118f722f1d2bcc"}, "originalPosition": 68}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgyMDY1MzY4OnYy", "diffSide": "RIGHT", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/plans/RecordQueryUnionPlanBase.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOVQxNzo1NzoxMlrOGvb4xg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOVQxNzo1NzoxMlrOGvb4xg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjM5MzE1OA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public boolean resultEquals(final Object other, final BiMap<CorrelationIdentifier, CorrelationIdentifier> equivalenceMap) {\n          \n          \n            \n                public boolean resultEquals(@Nullable final Object other, @Nonnull final BiMap<CorrelationIdentifier, CorrelationIdentifier> equivalenceMap) {", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/988#discussion_r452393158", "createdAt": "2020-07-09T17:57:12Z", "author": {"login": "nschiefer"}, "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/plans/RecordQueryUnionPlanBase.java", "diffHunk": "@@ -115,20 +121,42 @@ public boolean isReverse() {\n     @Override\n     @API(API.Status.EXPERIMENTAL)\n     public List<? extends Quantifier> getQuantifiers() {\n-        return Quantifiers.fromPlans(children);\n+        return quantifiers;\n     }\n \n     @Override\n-    public boolean equals(Object o) {\n-        if (this == o) {\n-            return true;\n+    public boolean equalsWithoutChildren(@Nonnull final RelationalExpression other,\n+                                         final BiMap<CorrelationIdentifier, CorrelationIdentifier> equivalences) {\n+        if (!RecordQueryPlanWithChildren.super.equalsWithoutChildren(other, equivalences)) {\n+            return false;\n         }\n-        if (o == null || getClass() != o.getClass()) {\n+        return reverse == ((RecordQueryUnionPlanBase)other).reverse;\n+    }\n+\n+    @Override\n+    public boolean resultEquals(final Object other, final BiMap<CorrelationIdentifier, CorrelationIdentifier> equivalenceMap) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6eb7142ab316ffbec53e375804118f722f1d2bcc"}, "originalPosition": 77}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgyMDY2NTE4OnYy", "diffSide": "RIGHT", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/RelationalExpression.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOVQxODowMDo0OVrOGvcAhw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMFQxNjoyNzozN1rOG0V9yg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjM5NTE0Mw==", "bodyText": "I don't love this as a default method on RelationalExpression since, as far as I can tell, it's only ever used in the implementation of the RelationalExpression interface and never by a consumer of that interface. It also doesn't seem to actually use anything internal to the class.\nCan we pull this out into a utility method instead?", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/988#discussion_r452395143", "createdAt": "2020-07-09T18:00:49Z", "author": {"login": "nschiefer"}, "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/RelationalExpression.java", "diffHunk": "@@ -136,7 +148,160 @@ static RelationalExpression fromRecordQuery(@Nonnull RecordQuery query, @Nonnull\n     @Nonnull\n     List<? extends Quantifier> getQuantifiers();\n \n-    boolean equalsWithoutChildren(@Nonnull RelationalExpression otherExpression);\n+    default boolean canCorrelate() {\n+        return false;\n+    }\n+\n+    boolean equalsWithoutChildren(@Nonnull RelationalExpression otherExpression, final BiMap<CorrelationIdentifier, CorrelationIdentifier> equivalencesMap);\n+\n+    default Optional<BiMap<Quantifier, Quantifier>> resultEqualsQuantifiers(@Nonnull final Set<? extends Quantifier> otherQuantifiers,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6eb7142ab316ffbec53e375804118f722f1d2bcc"}, "originalPosition": 88}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzUzOTAxOA==", "bodyText": "Done.", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/988#discussion_r457539018", "createdAt": "2020-07-20T16:27:37Z", "author": {"login": "normen662"}, "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/RelationalExpression.java", "diffHunk": "@@ -136,7 +148,160 @@ static RelationalExpression fromRecordQuery(@Nonnull RecordQuery query, @Nonnull\n     @Nonnull\n     List<? extends Quantifier> getQuantifiers();\n \n-    boolean equalsWithoutChildren(@Nonnull RelationalExpression otherExpression);\n+    default boolean canCorrelate() {\n+        return false;\n+    }\n+\n+    boolean equalsWithoutChildren(@Nonnull RelationalExpression otherExpression, final BiMap<CorrelationIdentifier, CorrelationIdentifier> equivalencesMap);\n+\n+    default Optional<BiMap<Quantifier, Quantifier>> resultEqualsQuantifiers(@Nonnull final Set<? extends Quantifier> otherQuantifiers,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjM5NTE0Mw=="}, "originalCommit": {"oid": "6eb7142ab316ffbec53e375804118f722f1d2bcc"}, "originalPosition": 88}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgyMDY2ODA4OnYy", "diffSide": "RIGHT", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/RelationalExpression.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOVQxODowMTo0M1rOGvcCkg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMFQxOTo1NToxOVrOG0dE0g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjM5NTY2Ng==", "bodyText": "I also think that matchQuantifiers is confusing as a default method on the RelationalExpression interface and should also be pulled out into a utility class.", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/988#discussion_r452395666", "createdAt": "2020-07-09T18:01:43Z", "author": {"login": "nschiefer"}, "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/RelationalExpression.java", "diffHunk": "@@ -136,7 +148,160 @@ static RelationalExpression fromRecordQuery(@Nonnull RecordQuery query, @Nonnull\n     @Nonnull\n     List<? extends Quantifier> getQuantifiers();\n \n-    boolean equalsWithoutChildren(@Nonnull RelationalExpression otherExpression);\n+    default boolean canCorrelate() {\n+        return false;\n+    }\n+\n+    boolean equalsWithoutChildren(@Nonnull RelationalExpression otherExpression, final BiMap<CorrelationIdentifier, CorrelationIdentifier> equivalencesMap);\n+\n+    default Optional<BiMap<Quantifier, Quantifier>> resultEqualsQuantifiers(@Nonnull final Set<? extends Quantifier> otherQuantifiers,\n+                                                                            @Nonnull final BiMap<CorrelationIdentifier, CorrelationIdentifier> equivalenceMap) {\n+        return matchQuantifiers(otherQuantifiers,\n+                equivalenceMap,\n+                (quantifier, otherQuantifier, nestedEquivalenceMap) -> {\n+                    if (quantifier.hashCode() != otherQuantifier.hashCode()) {\n+                        return false;\n+                    }\n+                    return quantifier.resultEquals(otherQuantifier, nestedEquivalenceMap);\n+                });\n+    }\n+\n+    /**\n+     * An predicate that tests for a match between quantifiers also taking into account an equivalence maps between\n+     * {@link CorrelationIdentifier}s.\n+     */\n+    @FunctionalInterface\n+    interface MatchingPredicate {\n+        boolean test(@Nonnull Quantifier quantifier,\n+                     @Nonnull Quantifier otherQuantifier,\n+                     @Nonnull final BiMap<CorrelationIdentifier, CorrelationIdentifier> equivalencesMap);\n+    }\n+\n+\n+    /**\n+     * Method to match up the quantifiers this expression owns with the given set of other quantifiers and an\n+     * equivalence map.\n+     *\n+     * Two quantifiers can be considered equal if their extended equality method {@link Quantifier#resultEquals} returns\n+     * {@code true} for the given the correct equality map. This method attempts to match up each quantifier from the\n+     * set of quantifiers this expression owns to the given other set of quantifiers.\n+     *\n+     * Now this method returns an empty mapping if e.g. the number quantifiers in the respetive sets doesn't match.\n+     *\n+     * For expressions that cannot introduce correlations, this method is simply {@code O(n!)} where is the\n+     * number of quantifiers (which is equal for both sets). This path is taken by UNIONs and other set operations.\n+     *\n+     * For expressions that introduce correlations, the matching process is more complicated. First, we determine one\n+     * topologically correct ordering. Then we iterate through all topologically correct orderings of the set of\n+     * quantifiers this expression owns. For each element in the permutation of quantifiers that is returned by\n+     * the {@link com.apple.foundationdb.record.query.plan.temp.TopologicalSort.TopologicalOrderPermutationIterator}\n+     * we try to math the quantifiers between the sets topologically from left to right (using {@code predicate}).\n+     * For each match we find we add an equivalence between the alias of this and the other quantifier that matched\n+     * in an equivalence map that extends the given equivalence map.\n+     * @param otherQuantifiers other quantifiers\n+     * @param equivalencesMap equivalence map\n+     * @param predicate that tests if two quantifiers and their graph they range over can be considered equivalent\n+     * @return A bi-map containing a mapping from the quantifiers this expression owns to the quantifiers in\n+     *         {@code otherQuantifiers}. Note that the mapping is bijective and can therefore be inverted.\n+     */\n+    @SuppressWarnings({\"UnstableApiUsage\", \"squid:S135\"})\n+    default Optional<BiMap<Quantifier, Quantifier>> matchQuantifiers(@Nonnull Set<? extends Quantifier> otherQuantifiers,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6eb7142ab316ffbec53e375804118f722f1d2bcc"}, "originalPosition": 139}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzY1NTUwNg==", "bodyText": "It is now in Quantifiers.", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/988#discussion_r457655506", "createdAt": "2020-07-20T19:55:19Z", "author": {"login": "normen662"}, "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/RelationalExpression.java", "diffHunk": "@@ -136,7 +148,160 @@ static RelationalExpression fromRecordQuery(@Nonnull RecordQuery query, @Nonnull\n     @Nonnull\n     List<? extends Quantifier> getQuantifiers();\n \n-    boolean equalsWithoutChildren(@Nonnull RelationalExpression otherExpression);\n+    default boolean canCorrelate() {\n+        return false;\n+    }\n+\n+    boolean equalsWithoutChildren(@Nonnull RelationalExpression otherExpression, final BiMap<CorrelationIdentifier, CorrelationIdentifier> equivalencesMap);\n+\n+    default Optional<BiMap<Quantifier, Quantifier>> resultEqualsQuantifiers(@Nonnull final Set<? extends Quantifier> otherQuantifiers,\n+                                                                            @Nonnull final BiMap<CorrelationIdentifier, CorrelationIdentifier> equivalenceMap) {\n+        return matchQuantifiers(otherQuantifiers,\n+                equivalenceMap,\n+                (quantifier, otherQuantifier, nestedEquivalenceMap) -> {\n+                    if (quantifier.hashCode() != otherQuantifier.hashCode()) {\n+                        return false;\n+                    }\n+                    return quantifier.resultEquals(otherQuantifier, nestedEquivalenceMap);\n+                });\n+    }\n+\n+    /**\n+     * An predicate that tests for a match between quantifiers also taking into account an equivalence maps between\n+     * {@link CorrelationIdentifier}s.\n+     */\n+    @FunctionalInterface\n+    interface MatchingPredicate {\n+        boolean test(@Nonnull Quantifier quantifier,\n+                     @Nonnull Quantifier otherQuantifier,\n+                     @Nonnull final BiMap<CorrelationIdentifier, CorrelationIdentifier> equivalencesMap);\n+    }\n+\n+\n+    /**\n+     * Method to match up the quantifiers this expression owns with the given set of other quantifiers and an\n+     * equivalence map.\n+     *\n+     * Two quantifiers can be considered equal if their extended equality method {@link Quantifier#resultEquals} returns\n+     * {@code true} for the given the correct equality map. This method attempts to match up each quantifier from the\n+     * set of quantifiers this expression owns to the given other set of quantifiers.\n+     *\n+     * Now this method returns an empty mapping if e.g. the number quantifiers in the respetive sets doesn't match.\n+     *\n+     * For expressions that cannot introduce correlations, this method is simply {@code O(n!)} where is the\n+     * number of quantifiers (which is equal for both sets). This path is taken by UNIONs and other set operations.\n+     *\n+     * For expressions that introduce correlations, the matching process is more complicated. First, we determine one\n+     * topologically correct ordering. Then we iterate through all topologically correct orderings of the set of\n+     * quantifiers this expression owns. For each element in the permutation of quantifiers that is returned by\n+     * the {@link com.apple.foundationdb.record.query.plan.temp.TopologicalSort.TopologicalOrderPermutationIterator}\n+     * we try to math the quantifiers between the sets topologically from left to right (using {@code predicate}).\n+     * For each match we find we add an equivalence between the alias of this and the other quantifier that matched\n+     * in an equivalence map that extends the given equivalence map.\n+     * @param otherQuantifiers other quantifiers\n+     * @param equivalencesMap equivalence map\n+     * @param predicate that tests if two quantifiers and their graph they range over can be considered equivalent\n+     * @return A bi-map containing a mapping from the quantifiers this expression owns to the quantifiers in\n+     *         {@code otherQuantifiers}. Note that the mapping is bijective and can therefore be inverted.\n+     */\n+    @SuppressWarnings({\"UnstableApiUsage\", \"squid:S135\"})\n+    default Optional<BiMap<Quantifier, Quantifier>> matchQuantifiers(@Nonnull Set<? extends Quantifier> otherQuantifiers,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjM5NTY2Ng=="}, "originalCommit": {"oid": "6eb7142ab316ffbec53e375804118f722f1d2bcc"}, "originalPosition": 139}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgyMDY3MTI3OnYy", "diffSide": "RIGHT", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/plans/RecordQueryUnionPlanBase.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOVQxODowMjo0NFrOGvcEuw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMFQxNjoyODoxNVrOG0V_ag==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjM5NjIxOQ==", "bodyText": "When we pick a new name for resultEqualsQuantifiers, I think it should be clearer that there's a non-trivial matching process going on here, rather than just some simple comparison. At the very least, we should add a comment similar to the one that was removed explicitly calling out that the order of the quantifiers is (mostly) not significant.", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/988#discussion_r452396219", "createdAt": "2020-07-09T18:02:44Z", "author": {"login": "nschiefer"}, "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/plans/RecordQueryUnionPlanBase.java", "diffHunk": "@@ -115,20 +121,42 @@ public boolean isReverse() {\n     @Override\n     @API(API.Status.EXPERIMENTAL)\n     public List<? extends Quantifier> getQuantifiers() {\n-        return Quantifiers.fromPlans(children);\n+        return quantifiers;\n     }\n \n     @Override\n-    public boolean equals(Object o) {\n-        if (this == o) {\n-            return true;\n+    public boolean equalsWithoutChildren(@Nonnull final RelationalExpression other,\n+                                         final BiMap<CorrelationIdentifier, CorrelationIdentifier> equivalences) {\n+        if (!RecordQueryPlanWithChildren.super.equalsWithoutChildren(other, equivalences)) {\n+            return false;\n         }\n-        if (o == null || getClass() != o.getClass()) {\n+        return reverse == ((RecordQueryUnionPlanBase)other).reverse;\n+    }\n+\n+    @Override\n+    public boolean resultEquals(final Object other, final BiMap<CorrelationIdentifier, CorrelationIdentifier> equivalenceMap) {\n+        if (other == null || getClass() != other.getClass()) {\n             return false;\n         }\n-        RecordQueryUnionPlanBase that = (RecordQueryUnionPlanBase) o;\n-        return reverse == that.reverse &&\n-               Objects.equals(Sets.newHashSet(getQueryPlanChildren()), Sets.newHashSet(that.getQueryPlanChildren()));  // isomorphic under re-ordering of children\n+        final RecordQueryUnionPlanBase otherPlan = (RecordQueryUnionPlanBase) other;\n+        \n+        final Optional<BiMap<Quantifier, Quantifier>> quantifierMapOptional =\n+                resultEqualsQuantifiers(ImmutableSet.copyOf(otherPlan.getQuantifiers()),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6eb7142ab316ffbec53e375804118f722f1d2bcc"}, "originalPosition": 87}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzUzOTQzNA==", "bodyText": "This method is now called match() and it lives in Quantifiers.", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/988#discussion_r457539434", "createdAt": "2020-07-20T16:28:15Z", "author": {"login": "normen662"}, "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/plans/RecordQueryUnionPlanBase.java", "diffHunk": "@@ -115,20 +121,42 @@ public boolean isReverse() {\n     @Override\n     @API(API.Status.EXPERIMENTAL)\n     public List<? extends Quantifier> getQuantifiers() {\n-        return Quantifiers.fromPlans(children);\n+        return quantifiers;\n     }\n \n     @Override\n-    public boolean equals(Object o) {\n-        if (this == o) {\n-            return true;\n+    public boolean equalsWithoutChildren(@Nonnull final RelationalExpression other,\n+                                         final BiMap<CorrelationIdentifier, CorrelationIdentifier> equivalences) {\n+        if (!RecordQueryPlanWithChildren.super.equalsWithoutChildren(other, equivalences)) {\n+            return false;\n         }\n-        if (o == null || getClass() != o.getClass()) {\n+        return reverse == ((RecordQueryUnionPlanBase)other).reverse;\n+    }\n+\n+    @Override\n+    public boolean resultEquals(final Object other, final BiMap<CorrelationIdentifier, CorrelationIdentifier> equivalenceMap) {\n+        if (other == null || getClass() != other.getClass()) {\n             return false;\n         }\n-        RecordQueryUnionPlanBase that = (RecordQueryUnionPlanBase) o;\n-        return reverse == that.reverse &&\n-               Objects.equals(Sets.newHashSet(getQueryPlanChildren()), Sets.newHashSet(that.getQueryPlanChildren()));  // isomorphic under re-ordering of children\n+        final RecordQueryUnionPlanBase otherPlan = (RecordQueryUnionPlanBase) other;\n+        \n+        final Optional<BiMap<Quantifier, Quantifier>> quantifierMapOptional =\n+                resultEqualsQuantifiers(ImmutableSet.copyOf(otherPlan.getQuantifiers()),", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjM5NjIxOQ=="}, "originalCommit": {"oid": "6eb7142ab316ffbec53e375804118f722f1d2bcc"}, "originalPosition": 87}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgyMDY3NDY0OnYy", "diffSide": "RIGHT", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/plans/RecordQueryUnorderedDistinctPlan.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOVQxODowMzo0OVrOGvcHHQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOVQxODowMzo0OVrOGvcHHQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjM5NjgyOQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public RecordQueryUnorderedDistinctPlan rebaseWithRebasedQuantifiers(final Map<CorrelationIdentifier, CorrelationIdentifier> translationMap, final List<Quantifier> rebasedQuantifiers) {\n          \n          \n            \n                public RecordQueryUnorderedDistinctPlan rebaseWithRebasedQuantifiers(@Nonnull final Map<CorrelationIdentifier, CorrelationIdentifier> translationMap, @Nonnull final List<Quantifier> rebasedQuantifiers) {", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/988#discussion_r452396829", "createdAt": "2020-07-09T18:03:49Z", "author": {"login": "nschiefer"}, "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/plans/RecordQueryUnorderedDistinctPlan.java", "diffHunk": "@@ -115,32 +124,43 @@ private KeyExpression getComparisonKey() {\n     @Override\n     @API(API.Status.EXPERIMENTAL)\n     public List<? extends Quantifier> getQuantifiers() {\n-        return ImmutableList.of(Quantifier.physical(inner));\n+        return ImmutableList.of(inner);\n     }\n \n     @Override\n     public String toString() {\n         return getInner() + \" | UnorderedDistinct(\" + getComparisonKey() + \")\";\n     }\n \n+    @Nonnull\n     @Override\n     @API(API.Status.EXPERIMENTAL)\n-    public boolean equalsWithoutChildren(@Nonnull RelationalExpression otherExpression) {\n-        return otherExpression instanceof RecordQueryUnorderedDistinctPlan &&\n-               comparisonKey.equals(((RecordQueryUnorderedDistinctPlan)otherExpression).comparisonKey);\n+    public Set<CorrelationIdentifier> getCorrelatedToWithoutChildren() {\n+        return ImmutableSet.of();\n     }\n \n+    @Nonnull\n     @Override\n-    public boolean equals(Object o) {\n-        if (this == o) {\n-            return true;\n-        }\n-        if (o == null || getClass() != o.getClass()) {\n+    public RecordQueryUnorderedDistinctPlan rebaseWithRebasedQuantifiers(final Map<CorrelationIdentifier, CorrelationIdentifier> translationMap, final List<Quantifier> rebasedQuantifiers) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6eb7142ab316ffbec53e375804118f722f1d2bcc"}, "originalPosition": 95}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgyMDY3NTQ1OnYy", "diffSide": "RIGHT", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/plans/RecordQueryUnorderedDistinctPlan.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOVQxODowNDowNFrOGvcHuA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOVQxODowNDowNFrOGvcHuA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjM5Njk4NA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public boolean equalsWithoutChildren(@Nonnull RelationalExpression otherExpression, final BiMap<CorrelationIdentifier, CorrelationIdentifier> equivalencesMap) {\n          \n          \n            \n                public boolean equalsWithoutChildren(@Nonnull RelationalExpression otherExpression, @Nonnull final BiMap<CorrelationIdentifier, CorrelationIdentifier> equivalencesMap) {", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/988#discussion_r452396984", "createdAt": "2020-07-09T18:04:04Z", "author": {"login": "nschiefer"}, "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/plans/RecordQueryUnorderedDistinctPlan.java", "diffHunk": "@@ -115,32 +124,43 @@ private KeyExpression getComparisonKey() {\n     @Override\n     @API(API.Status.EXPERIMENTAL)\n     public List<? extends Quantifier> getQuantifiers() {\n-        return ImmutableList.of(Quantifier.physical(inner));\n+        return ImmutableList.of(inner);\n     }\n \n     @Override\n     public String toString() {\n         return getInner() + \" | UnorderedDistinct(\" + getComparisonKey() + \")\";\n     }\n \n+    @Nonnull\n     @Override\n     @API(API.Status.EXPERIMENTAL)\n-    public boolean equalsWithoutChildren(@Nonnull RelationalExpression otherExpression) {\n-        return otherExpression instanceof RecordQueryUnorderedDistinctPlan &&\n-               comparisonKey.equals(((RecordQueryUnorderedDistinctPlan)otherExpression).comparisonKey);\n+    public Set<CorrelationIdentifier> getCorrelatedToWithoutChildren() {\n+        return ImmutableSet.of();\n     }\n \n+    @Nonnull\n     @Override\n-    public boolean equals(Object o) {\n-        if (this == o) {\n-            return true;\n-        }\n-        if (o == null || getClass() != o.getClass()) {\n+    public RecordQueryUnorderedDistinctPlan rebaseWithRebasedQuantifiers(final Map<CorrelationIdentifier, CorrelationIdentifier> translationMap, final List<Quantifier> rebasedQuantifiers) {\n+        return new RecordQueryUnorderedDistinctPlan((Quantifier.Physical)Iterables.getOnlyElement(rebasedQuantifiers),\n+                getComparisonKey());\n+    }\n+\n+    @Override\n+    @API(API.Status.EXPERIMENTAL)\n+    public boolean equalsWithoutChildren(@Nonnull RelationalExpression otherExpression, final BiMap<CorrelationIdentifier, CorrelationIdentifier> equivalencesMap) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6eb7142ab316ffbec53e375804118f722f1d2bcc"}, "originalPosition": 102}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgyMDY3OTI4OnYy", "diffSide": "RIGHT", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/plans/RecordQueryUnorderedDistinctPlan.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOVQxODowNToxNVrOGvcKPw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMFQxNjoyODo0NlrOG0WAug==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjM5NzYzMQ==", "bodyText": "Where is resultEquals() for RecordQueryUnorderedDistinctPlan?", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/988#discussion_r452397631", "createdAt": "2020-07-09T18:05:15Z", "author": {"login": "nschiefer"}, "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/plans/RecordQueryUnorderedDistinctPlan.java", "diffHunk": "@@ -115,32 +124,43 @@ private KeyExpression getComparisonKey() {\n     @Override\n     @API(API.Status.EXPERIMENTAL)\n     public List<? extends Quantifier> getQuantifiers() {\n-        return ImmutableList.of(Quantifier.physical(inner));\n+        return ImmutableList.of(inner);\n     }\n \n     @Override\n     public String toString() {\n         return getInner() + \" | UnorderedDistinct(\" + getComparisonKey() + \")\";\n     }\n \n+    @Nonnull\n     @Override\n     @API(API.Status.EXPERIMENTAL)\n-    public boolean equalsWithoutChildren(@Nonnull RelationalExpression otherExpression) {\n-        return otherExpression instanceof RecordQueryUnorderedDistinctPlan &&\n-               comparisonKey.equals(((RecordQueryUnorderedDistinctPlan)otherExpression).comparisonKey);\n+    public Set<CorrelationIdentifier> getCorrelatedToWithoutChildren() {\n+        return ImmutableSet.of();\n     }\n \n+    @Nonnull\n     @Override\n-    public boolean equals(Object o) {\n-        if (this == o) {\n-            return true;\n-        }\n-        if (o == null || getClass() != o.getClass()) {\n+    public RecordQueryUnorderedDistinctPlan rebaseWithRebasedQuantifiers(final Map<CorrelationIdentifier, CorrelationIdentifier> translationMap, final List<Quantifier> rebasedQuantifiers) {\n+        return new RecordQueryUnorderedDistinctPlan((Quantifier.Physical)Iterables.getOnlyElement(rebasedQuantifiers),\n+                getComparisonKey());\n+    }\n+\n+    @Override\n+    @API(API.Status.EXPERIMENTAL)\n+    public boolean equalsWithoutChildren(@Nonnull RelationalExpression otherExpression, final BiMap<CorrelationIdentifier, CorrelationIdentifier> equivalencesMap) {\n+        if (!RecordQueryPlanWithChild.super.equalsWithoutChildren(otherExpression, equivalencesMap)) {\n             return false;\n         }\n-        RecordQueryUnorderedDistinctPlan that = (RecordQueryUnorderedDistinctPlan) o;\n-        return Objects.equals(getInner(), that.getInner()) &&\n-                Objects.equals(getComparisonKey(), that.getComparisonKey());\n+\n+        return otherExpression instanceof RecordQueryUnorderedDistinctPlan &&\n+               comparisonKey.equals(((RecordQueryUnorderedDistinctPlan)otherExpression).comparisonKey);\n+    }\n+\n+    @SuppressWarnings(\"EqualsWhichDoesntCheckParameterClass\")\n+    @Override\n+    public boolean equals(final Object other) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6eb7142ab316ffbec53e375804118f722f1d2bcc"}, "originalPosition": 116}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzUzOTc3MA==", "bodyText": "Refactored. Generic implementation in RelationalExpression.", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/988#discussion_r457539770", "createdAt": "2020-07-20T16:28:46Z", "author": {"login": "normen662"}, "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/plans/RecordQueryUnorderedDistinctPlan.java", "diffHunk": "@@ -115,32 +124,43 @@ private KeyExpression getComparisonKey() {\n     @Override\n     @API(API.Status.EXPERIMENTAL)\n     public List<? extends Quantifier> getQuantifiers() {\n-        return ImmutableList.of(Quantifier.physical(inner));\n+        return ImmutableList.of(inner);\n     }\n \n     @Override\n     public String toString() {\n         return getInner() + \" | UnorderedDistinct(\" + getComparisonKey() + \")\";\n     }\n \n+    @Nonnull\n     @Override\n     @API(API.Status.EXPERIMENTAL)\n-    public boolean equalsWithoutChildren(@Nonnull RelationalExpression otherExpression) {\n-        return otherExpression instanceof RecordQueryUnorderedDistinctPlan &&\n-               comparisonKey.equals(((RecordQueryUnorderedDistinctPlan)otherExpression).comparisonKey);\n+    public Set<CorrelationIdentifier> getCorrelatedToWithoutChildren() {\n+        return ImmutableSet.of();\n     }\n \n+    @Nonnull\n     @Override\n-    public boolean equals(Object o) {\n-        if (this == o) {\n-            return true;\n-        }\n-        if (o == null || getClass() != o.getClass()) {\n+    public RecordQueryUnorderedDistinctPlan rebaseWithRebasedQuantifiers(final Map<CorrelationIdentifier, CorrelationIdentifier> translationMap, final List<Quantifier> rebasedQuantifiers) {\n+        return new RecordQueryUnorderedDistinctPlan((Quantifier.Physical)Iterables.getOnlyElement(rebasedQuantifiers),\n+                getComparisonKey());\n+    }\n+\n+    @Override\n+    @API(API.Status.EXPERIMENTAL)\n+    public boolean equalsWithoutChildren(@Nonnull RelationalExpression otherExpression, final BiMap<CorrelationIdentifier, CorrelationIdentifier> equivalencesMap) {\n+        if (!RecordQueryPlanWithChild.super.equalsWithoutChildren(otherExpression, equivalencesMap)) {\n             return false;\n         }\n-        RecordQueryUnorderedDistinctPlan that = (RecordQueryUnorderedDistinctPlan) o;\n-        return Objects.equals(getInner(), that.getInner()) &&\n-                Objects.equals(getComparisonKey(), that.getComparisonKey());\n+\n+        return otherExpression instanceof RecordQueryUnorderedDistinctPlan &&\n+               comparisonKey.equals(((RecordQueryUnorderedDistinctPlan)otherExpression).comparisonKey);\n+    }\n+\n+    @SuppressWarnings(\"EqualsWhichDoesntCheckParameterClass\")\n+    @Override\n+    public boolean equals(final Object other) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjM5NzYzMQ=="}, "originalCommit": {"oid": "6eb7142ab316ffbec53e375804118f722f1d2bcc"}, "originalPosition": 116}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgyMDY4MDM2OnYy", "diffSide": "RIGHT", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/plans/RecordQueryUnorderedPrimaryKeyDistinctPlan.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOVQxODowNTozNlrOGvcK9w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOVQxODowNTozNlrOGvcK9w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjM5NzgxNQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public RecordQueryUnorderedPrimaryKeyDistinctPlan rebaseWithRebasedQuantifiers(final Map<CorrelationIdentifier, CorrelationIdentifier> translationMap, final List<Quantifier> rebasedQuantifiers) {\n          \n          \n            \n                public RecordQueryUnorderedPrimaryKeyDistinctPlan rebaseWithRebasedQuantifiers(@Nonnull final Map<CorrelationIdentifier, CorrelationIdentifier> translationMap, @Nonnull final List<Quantifier> rebasedQuantifiers) {", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/988#discussion_r452397815", "createdAt": "2020-07-09T18:05:36Z", "author": {"login": "nschiefer"}, "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/plans/RecordQueryUnorderedPrimaryKeyDistinctPlan.java", "diffHunk": "@@ -107,30 +111,42 @@ public RecordQueryPlan getChild() {\n     @Override\n     @API(API.Status.EXPERIMENTAL)\n     public List<? extends Quantifier> getQuantifiers() {\n-        return ImmutableList.of(Quantifier.physical(inner));\n+        return ImmutableList.of(inner);\n     }\n \n     @Override\n     public String toString() {\n         return getInner() + \" | UnorderedPrimaryKeyDistinct()\";\n     }\n \n+    @Nonnull\n     @Override\n     @API(API.Status.EXPERIMENTAL)\n-    public boolean equalsWithoutChildren(@Nonnull RelationalExpression otherExpression) {\n-        return otherExpression instanceof RecordQueryUnorderedPrimaryKeyDistinctPlan;\n+    public Set<CorrelationIdentifier> getCorrelatedToWithoutChildren() {\n+        return ImmutableSet.of();\n     }\n \n+    @Nonnull\n     @Override\n-    public boolean equals(Object o) {\n-        if (this == o) {\n-            return true;\n-        }\n-        if (o == null || getClass() != o.getClass()) {\n+    @API(API.Status.EXPERIMENTAL)\n+    public RecordQueryUnorderedPrimaryKeyDistinctPlan rebaseWithRebasedQuantifiers(final Map<CorrelationIdentifier, CorrelationIdentifier> translationMap, final List<Quantifier> rebasedQuantifiers) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6eb7142ab316ffbec53e375804118f722f1d2bcc"}, "originalPosition": 91}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgyMDY4MTIyOnYy", "diffSide": "RIGHT", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/plans/RecordQueryUnorderedPrimaryKeyDistinctPlan.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOVQxODowNTo0N1rOGvcLbA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOVQxODowNTo0N1rOGvcLbA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjM5NzkzMg==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public boolean equalsWithoutChildren(@Nonnull RelationalExpression otherExpression, final BiMap<CorrelationIdentifier, CorrelationIdentifier> equivalencesMap) {\n          \n          \n            \n                public boolean equalsWithoutChildren(@Nonnull RelationalExpression otherExpression, @Nonnull final BiMap<CorrelationIdentifier, CorrelationIdentifier> equivalencesMap) {", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/988#discussion_r452397932", "createdAt": "2020-07-09T18:05:47Z", "author": {"login": "nschiefer"}, "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/plans/RecordQueryUnorderedPrimaryKeyDistinctPlan.java", "diffHunk": "@@ -107,30 +111,42 @@ public RecordQueryPlan getChild() {\n     @Override\n     @API(API.Status.EXPERIMENTAL)\n     public List<? extends Quantifier> getQuantifiers() {\n-        return ImmutableList.of(Quantifier.physical(inner));\n+        return ImmutableList.of(inner);\n     }\n \n     @Override\n     public String toString() {\n         return getInner() + \" | UnorderedPrimaryKeyDistinct()\";\n     }\n \n+    @Nonnull\n     @Override\n     @API(API.Status.EXPERIMENTAL)\n-    public boolean equalsWithoutChildren(@Nonnull RelationalExpression otherExpression) {\n-        return otherExpression instanceof RecordQueryUnorderedPrimaryKeyDistinctPlan;\n+    public Set<CorrelationIdentifier> getCorrelatedToWithoutChildren() {\n+        return ImmutableSet.of();\n     }\n \n+    @Nonnull\n     @Override\n-    public boolean equals(Object o) {\n-        if (this == o) {\n-            return true;\n-        }\n-        if (o == null || getClass() != o.getClass()) {\n+    @API(API.Status.EXPERIMENTAL)\n+    public RecordQueryUnorderedPrimaryKeyDistinctPlan rebaseWithRebasedQuantifiers(final Map<CorrelationIdentifier, CorrelationIdentifier> translationMap, final List<Quantifier> rebasedQuantifiers) {\n+        return new RecordQueryUnorderedPrimaryKeyDistinctPlan((Quantifier.Physical)Iterables.getOnlyElement(rebasedQuantifiers));\n+    }\n+\n+    @Override\n+    @API(API.Status.EXPERIMENTAL)\n+    public boolean equalsWithoutChildren(@Nonnull RelationalExpression otherExpression, final BiMap<CorrelationIdentifier, CorrelationIdentifier> equivalencesMap) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6eb7142ab316ffbec53e375804118f722f1d2bcc"}, "originalPosition": 97}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgyMDY4MjAzOnYy", "diffSide": "RIGHT", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/plans/RecordQueryUnorderedPrimaryKeyDistinctPlan.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOVQxODowNjowNVrOGvcL-w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOVQxODowNjowNVrOGvcL-w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjM5ODA3NQ==", "bodyText": "Similarly, where is resultEquals() for this class?", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/988#discussion_r452398075", "createdAt": "2020-07-09T18:06:05Z", "author": {"login": "nschiefer"}, "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/plans/RecordQueryUnorderedPrimaryKeyDistinctPlan.java", "diffHunk": "@@ -107,30 +111,42 @@ public RecordQueryPlan getChild() {\n     @Override\n     @API(API.Status.EXPERIMENTAL)\n     public List<? extends Quantifier> getQuantifiers() {\n-        return ImmutableList.of(Quantifier.physical(inner));\n+        return ImmutableList.of(inner);\n     }\n \n     @Override\n     public String toString() {\n         return getInner() + \" | UnorderedPrimaryKeyDistinct()\";\n     }\n \n+    @Nonnull\n     @Override\n     @API(API.Status.EXPERIMENTAL)\n-    public boolean equalsWithoutChildren(@Nonnull RelationalExpression otherExpression) {\n-        return otherExpression instanceof RecordQueryUnorderedPrimaryKeyDistinctPlan;\n+    public Set<CorrelationIdentifier> getCorrelatedToWithoutChildren() {\n+        return ImmutableSet.of();\n     }\n \n+    @Nonnull\n     @Override\n-    public boolean equals(Object o) {\n-        if (this == o) {\n-            return true;\n-        }\n-        if (o == null || getClass() != o.getClass()) {\n+    @API(API.Status.EXPERIMENTAL)\n+    public RecordQueryUnorderedPrimaryKeyDistinctPlan rebaseWithRebasedQuantifiers(final Map<CorrelationIdentifier, CorrelationIdentifier> translationMap, final List<Quantifier> rebasedQuantifiers) {\n+        return new RecordQueryUnorderedPrimaryKeyDistinctPlan((Quantifier.Physical)Iterables.getOnlyElement(rebasedQuantifiers));\n+    }\n+\n+    @Override\n+    @API(API.Status.EXPERIMENTAL)\n+    public boolean equalsWithoutChildren(@Nonnull RelationalExpression otherExpression, final BiMap<CorrelationIdentifier, CorrelationIdentifier> equivalencesMap) {\n+        if (!RecordQueryPlanWithChild.super.equalsWithoutChildren(otherExpression, equivalencesMap)) {\n             return false;\n         }\n-        RecordQueryUnorderedPrimaryKeyDistinctPlan that = (RecordQueryUnorderedPrimaryKeyDistinctPlan) o;\n-        return Objects.equals(getInner(), that.getInner());\n+\n+        return otherExpression instanceof RecordQueryUnorderedPrimaryKeyDistinctPlan;\n+    }\n+\n+    @SuppressWarnings(\"EqualsWhichDoesntCheckParameterClass\")\n+    @Override\n+    public boolean equals(final Object other) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6eb7142ab316ffbec53e375804118f722f1d2bcc"}, "originalPosition": 109}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgyMDY4MzIyOnYy", "diffSide": "RIGHT", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/plans/RecordQueryUnorderedUnionPlan.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOVQxODowNjoyN1rOGvcMzA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOVQxODowNjoyN1rOGvcMzA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjM5ODI4NA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public RecordQueryUnorderedUnionPlan rebaseWithRebasedQuantifiers(final Map<CorrelationIdentifier, CorrelationIdentifier> translationMap, final List<Quantifier> rebasedQuantifiers) {\n          \n          \n            \n                public RecordQueryUnorderedUnionPlan rebaseWithRebasedQuantifiers(@Nonnull final Map<CorrelationIdentifier, CorrelationIdentifier> translationMap, @Nonnull final List<Quantifier> rebasedQuantifiers) {", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/988#discussion_r452398284", "createdAt": "2020-07-09T18:06:27Z", "author": {"login": "nschiefer"}, "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/plans/RecordQueryUnorderedUnionPlan.java", "diffHunk": "@@ -86,29 +95,30 @@ public static RecordQueryUnorderedUnionPlan from(@Nonnull List<RecordQueryPlan>\n         for (RecordQueryPlan child : children) {\n             builder.add(GroupExpressionRef.of(child));\n         }\n-        return new RecordQueryUnorderedUnionPlan(builder.build(), reverse);\n+        return new RecordQueryUnorderedUnionPlan(Quantifiers.fromPlans(builder.build()), reverse);\n     }\n \n     @Nonnull\n     public static RecordQueryUnorderedUnionPlan from(@Nonnull RecordQueryPlan left, @Nonnull RecordQueryPlan right) {\n-        return new RecordQueryUnorderedUnionPlan(ImmutableList.of(GroupExpressionRef.of(left), GroupExpressionRef.of(right)), left.isReverse());\n+        return new RecordQueryUnorderedUnionPlan(Quantifiers.fromPlans(ImmutableList.of(GroupExpressionRef.of(left), GroupExpressionRef.of(right))),\n+                left.isReverse());\n     }\n \n-    @API(API.Status.EXPERIMENTAL)\n     @Nonnull\n-    public static RecordQueryUnorderedUnionPlan fromRefs(@Nonnull List<ExpressionRef<RecordQueryPlan>> children) {\n-        return new RecordQueryUnorderedUnionPlan(children, false);\n+    @Override\n+    public Set<CorrelationIdentifier> getCorrelatedToWithoutChildren() {\n+        return ImmutableSet.of();\n     }\n \n-    @API(API.Status.EXPERIMENTAL)\n     @Nonnull\n-    public static RecordQueryUnorderedUnionPlan fromRefs(@Nonnull ExpressionRef<RecordQueryPlan> left, @Nonnull ExpressionRef<RecordQueryPlan> right) {\n-        return new RecordQueryUnorderedUnionPlan(ImmutableList.of(left, right), false);\n+    @Override\n+    public RecordQueryUnorderedUnionPlan rebaseWithRebasedQuantifiers(final Map<CorrelationIdentifier, CorrelationIdentifier> translationMap, final List<Quantifier> rebasedQuantifiers) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6eb7142ab316ffbec53e375804118f722f1d2bcc"}, "originalPosition": 68}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgyMDY4MzgzOnYy", "diffSide": "RIGHT", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/plans/RecordQueryUnorderedUnionPlan.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOVQxODowNjozOVrOGvcNMA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOVQxODowNjozOVrOGvcNMA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjM5ODM4NA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public boolean equalsWithoutChildren(@Nonnull RelationalExpression otherExpression, final BiMap<CorrelationIdentifier, CorrelationIdentifier> equivalencesMap) {\n          \n          \n            \n                public boolean equalsWithoutChildren(@Nonnull RelationalExpression otherExpression, @Nonnull final BiMap<CorrelationIdentifier, CorrelationIdentifier> equivalencesMap) {", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/988#discussion_r452398384", "createdAt": "2020-07-09T18:06:39Z", "author": {"login": "nschiefer"}, "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/plans/RecordQueryUnorderedUnionPlan.java", "diffHunk": "@@ -86,29 +95,30 @@ public static RecordQueryUnorderedUnionPlan from(@Nonnull List<RecordQueryPlan>\n         for (RecordQueryPlan child : children) {\n             builder.add(GroupExpressionRef.of(child));\n         }\n-        return new RecordQueryUnorderedUnionPlan(builder.build(), reverse);\n+        return new RecordQueryUnorderedUnionPlan(Quantifiers.fromPlans(builder.build()), reverse);\n     }\n \n     @Nonnull\n     public static RecordQueryUnorderedUnionPlan from(@Nonnull RecordQueryPlan left, @Nonnull RecordQueryPlan right) {\n-        return new RecordQueryUnorderedUnionPlan(ImmutableList.of(GroupExpressionRef.of(left), GroupExpressionRef.of(right)), left.isReverse());\n+        return new RecordQueryUnorderedUnionPlan(Quantifiers.fromPlans(ImmutableList.of(GroupExpressionRef.of(left), GroupExpressionRef.of(right))),\n+                left.isReverse());\n     }\n \n-    @API(API.Status.EXPERIMENTAL)\n     @Nonnull\n-    public static RecordQueryUnorderedUnionPlan fromRefs(@Nonnull List<ExpressionRef<RecordQueryPlan>> children) {\n-        return new RecordQueryUnorderedUnionPlan(children, false);\n+    @Override\n+    public Set<CorrelationIdentifier> getCorrelatedToWithoutChildren() {\n+        return ImmutableSet.of();\n     }\n \n-    @API(API.Status.EXPERIMENTAL)\n     @Nonnull\n-    public static RecordQueryUnorderedUnionPlan fromRefs(@Nonnull ExpressionRef<RecordQueryPlan> left, @Nonnull ExpressionRef<RecordQueryPlan> right) {\n-        return new RecordQueryUnorderedUnionPlan(ImmutableList.of(left, right), false);\n+    @Override\n+    public RecordQueryUnorderedUnionPlan rebaseWithRebasedQuantifiers(final Map<CorrelationIdentifier, CorrelationIdentifier> translationMap, final List<Quantifier> rebasedQuantifiers) {\n+        return new RecordQueryUnorderedUnionPlan(rebasedQuantifiers.stream().map(quantifier -> (Quantifier.Physical)quantifier).collect(Collectors.toList()),\n+                isReverse());\n     }\n \n     @Override\n-    @API(API.Status.EXPERIMENTAL)\n-    public boolean equalsWithoutChildren(@Nonnull RelationalExpression otherExpression) {\n+    public boolean equalsWithoutChildren(@Nonnull RelationalExpression otherExpression, final BiMap<CorrelationIdentifier, CorrelationIdentifier> equivalencesMap) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6eb7142ab316ffbec53e375804118f722f1d2bcc"}, "originalPosition": 76}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgyMDcxNDQ1OnYy", "diffSide": "RIGHT", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/Correlated.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOVQxODoxNjowM1rOGvchEg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOVQxODoxNjowM1rOGvchEg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjQwMzQ3NA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n             * Interface for classes to implement entities which can be correlated to some other entity (usually a {@link Quantifier})\n          \n          \n            \n             * that is disambiguated by means of a {@link CorrelationIdentifier}. Objects of implementors of this class are said\n          \n          \n            \n             * to be correlated to a quantifier {@code q} if the identifiers returned by {@link #getCorrelatedTo()} set contain\n          \n          \n            \n             * the alias identifier that {@code q} uses.\n          \n          \n            \n             * A <em>correlated</em> entity is one which can only be evaluated as a function of some input (usually a {@link Quantifier}) from its relational parent.\n          \n          \n            \n             * Since a correlated entity can have multiple correlations to similar quantifiers, a correlation is disambiguated by a {@link CorrelationIdentifier}. Correlated entities are said\n          \n          \n            \n             * to be correlated to a quantifier {@code q} if the identifiers returned by {@link #getCorrelatedTo()} set contain\n          \n          \n            \n             * the correlation identifier that {@code q} uses.", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/988#discussion_r452403474", "createdAt": "2020-07-09T18:16:03Z", "author": {"login": "nschiefer"}, "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/Correlated.java", "diffHunk": "@@ -0,0 +1,144 @@\n+/*\n+ * Correlated.java\n+ *\n+ * This source file is part of the FoundationDB open source project\n+ *\n+ * Copyright 2015-2020 Apple Inc. and the FoundationDB project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.apple.foundationdb.record.query.plan.temp;\n+\n+import com.google.common.collect.BiMap;\n+\n+import javax.annotation.Nonnull;\n+import java.util.Map;\n+import java.util.Set;\n+\n+/**\n+ * Interface for classes to implement entities which can be correlated to some other entity (usually a {@link Quantifier})\n+ * that is disambiguated by means of a {@link CorrelationIdentifier}. Objects of implementors of this class are said\n+ * to be correlated to a quantifier {@code q} if the identifiers returned by {@link #getCorrelatedTo()} set contain\n+ * the alias identifier that {@code q} uses.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6eb7142ab316ffbec53e375804118f722f1d2bcc"}, "originalPosition": 33}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgyMDcxNzI5OnYy", "diffSide": "RIGHT", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/Correlated.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOVQxODoxNjo1N1rOGvci4g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOVQxODoxNjo1N1rOGvci4g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjQwMzkzOA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n             * Note that this level of indirection simplifies modifications of the graph e.g. as result of applied transformations\n          \n          \n            \n             * during the planning stage of a query.\n          \n          \n            \n            * Distinguishing the correlation identifier from the identity of of the quantifier object simplifies modifications of the graph, for example while applying transformations during query planning.", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/988#discussion_r452403938", "createdAt": "2020-07-09T18:16:57Z", "author": {"login": "nschiefer"}, "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/Correlated.java", "diffHunk": "@@ -0,0 +1,144 @@\n+/*\n+ * Correlated.java\n+ *\n+ * This source file is part of the FoundationDB open source project\n+ *\n+ * Copyright 2015-2020 Apple Inc. and the FoundationDB project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.apple.foundationdb.record.query.plan.temp;\n+\n+import com.google.common.collect.BiMap;\n+\n+import javax.annotation.Nonnull;\n+import java.util.Map;\n+import java.util.Set;\n+\n+/**\n+ * Interface for classes to implement entities which can be correlated to some other entity (usually a {@link Quantifier})\n+ * that is disambiguated by means of a {@link CorrelationIdentifier}. Objects of implementors of this class are said\n+ * to be correlated to a quantifier {@code q} if the identifiers returned by {@link #getCorrelatedTo()} set contain\n+ * the alias identifier that {@code q} uses.\n+ *\n+ * Note that this level of indirection simplifies modifications of the graph e.g. as result of applied transformations\n+ * during the planning stage of a query.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6eb7142ab316ffbec53e375804118f722f1d2bcc"}, "originalPosition": 36}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgyMDcyNzA4OnYy", "diffSide": "RIGHT", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/Correlated.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOVQxODoxOTo0MlrOGvco7g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOVQxODoxOTo0MlrOGvco7g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjQwNTQ4Ng==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n             * An object that is correlated to some other object can be _rebased_ by means of invoking {@link #rebase} using\n          \n          \n            \n             * a translation {@code id} to {@code id'}. The result of that invocation is a new object of type {@code S} that is\n          \n          \n            \n             * identical the original {@code this} except that all correlated references to {@code id} of the new object as well as\n          \n          \n            \n             * all objects {@code this} owns (i.e. other objects this object is composed of, e.g. children, etc.) now refer to a\n          \n          \n            \n             * new {@link CorrelationIdentifier} {@code id'}.\n          \n          \n            \n             * An correlated object can be <em>rebased</em> using {@link #rebase} and\n          \n          \n            \n             * a map of translations from one correlation identifier to another, resulting in a new object of type {@code S} that is\n          \n          \n            \n             * identical to {@code this} except that all correlated references in the subtree rooted at this entity  (i.e., this object's relational children, predicates, etc.) are replaced with their corresponding identifiers per the map.", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/988#discussion_r452405486", "createdAt": "2020-07-09T18:19:42Z", "author": {"login": "nschiefer"}, "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/Correlated.java", "diffHunk": "@@ -0,0 +1,144 @@\n+/*\n+ * Correlated.java\n+ *\n+ * This source file is part of the FoundationDB open source project\n+ *\n+ * Copyright 2015-2020 Apple Inc. and the FoundationDB project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.apple.foundationdb.record.query.plan.temp;\n+\n+import com.google.common.collect.BiMap;\n+\n+import javax.annotation.Nonnull;\n+import java.util.Map;\n+import java.util.Set;\n+\n+/**\n+ * Interface for classes to implement entities which can be correlated to some other entity (usually a {@link Quantifier})\n+ * that is disambiguated by means of a {@link CorrelationIdentifier}. Objects of implementors of this class are said\n+ * to be correlated to a quantifier {@code q} if the identifiers returned by {@link #getCorrelatedTo()} set contain\n+ * the alias identifier that {@code q} uses.\n+ *\n+ * Note that this level of indirection simplifies modifications of the graph e.g. as result of applied transformations\n+ * during the planning stage of a query.\n+ *\n+ * An object that is correlated to some other object can be _rebased_ by means of invoking {@link #rebase} using\n+ * a translation {@code id} to {@code id'}. The result of that invocation is a new object of type {@code S} that is\n+ * identical the original {@code this} except that all correlated references to {@code id} of the new object as well as\n+ * all objects {@code this} owns (i.e. other objects this object is composed of, e.g. children, etc.) now refer to a\n+ * new {@link CorrelationIdentifier} {@code id'}.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6eb7142ab316ffbec53e375804118f722f1d2bcc"}, "originalPosition": 42}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgyMDcyODc4OnYy", "diffSide": "RIGHT", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/Correlated.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOVQxODoyMDoxNFrOGvcqBw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOVQxODoyMDoxNFrOGvcqBw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjQwNTc2Nw==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n             * As the planner DAG objects are immutable, a rebase operation can be expensive as objects have to be recreated\n          \n          \n            \n             * as needed. We follow the ideas of other persistent data structures as we do not require a copy to be made.\n          \n          \n            \n             * It is perfectly acceptable to return {@code this} as long as it can be proven that {@code this} is not correlated to\n          \n          \n            \n             * any identifier participating in the translation.\n          \n          \n            \n             * As the planner DAG objects are immutable, a rebase operation can be expensive as objects have to be recreated\n          \n          \n            \n             * as needed. We follow the ideas of other persistent data structures as we do not require a copy to be made.\n          \n          \n            \n             * It is perfectly acceptable to return {@code this} if {@code this} is not correlated to any identifier participating in the translation.", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/988#discussion_r452405767", "createdAt": "2020-07-09T18:20:14Z", "author": {"login": "nschiefer"}, "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/Correlated.java", "diffHunk": "@@ -0,0 +1,144 @@\n+/*\n+ * Correlated.java\n+ *\n+ * This source file is part of the FoundationDB open source project\n+ *\n+ * Copyright 2015-2020 Apple Inc. and the FoundationDB project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.apple.foundationdb.record.query.plan.temp;\n+\n+import com.google.common.collect.BiMap;\n+\n+import javax.annotation.Nonnull;\n+import java.util.Map;\n+import java.util.Set;\n+\n+/**\n+ * Interface for classes to implement entities which can be correlated to some other entity (usually a {@link Quantifier})\n+ * that is disambiguated by means of a {@link CorrelationIdentifier}. Objects of implementors of this class are said\n+ * to be correlated to a quantifier {@code q} if the identifiers returned by {@link #getCorrelatedTo()} set contain\n+ * the alias identifier that {@code q} uses.\n+ *\n+ * Note that this level of indirection simplifies modifications of the graph e.g. as result of applied transformations\n+ * during the planning stage of a query.\n+ *\n+ * An object that is correlated to some other object can be _rebased_ by means of invoking {@link #rebase} using\n+ * a translation {@code id} to {@code id'}. The result of that invocation is a new object of type {@code S} that is\n+ * identical the original {@code this} except that all correlated references to {@code id} of the new object as well as\n+ * all objects {@code this} owns (i.e. other objects this object is composed of, e.g. children, etc.) now refer to a\n+ * new {@link CorrelationIdentifier} {@code id'}.\n+ *\n+ * Since translations are associative we allow to rebase many identifiers in the same {@link #rebase} invocation.\n+ *\n+ * As the planner DAG objects are immutable, a rebase operation can be expensive as objects have to be recreated\n+ * as needed. We follow the ideas of other persistent data structures as we do not require a copy to be made.\n+ * It is perfectly acceptable to return {@code this} as long as it can be proven that {@code this} is not correlated to\n+ * any identifier participating in the translation.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6eb7142ab316ffbec53e375804118f722f1d2bcc"}, "originalPosition": 49}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgyMDczNTk2OnYy", "diffSide": "RIGHT", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/Correlated.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOVQxODoyMjowNFrOGvcuYQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOVQxODoyMjowNFrOGvcuYQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjQwNjg4MQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n             * This interface defines {@code equals()} using an equivalence map. Names are smoke and sound! Two sub-graphs\n          \n          \n            \n             * may be considered equal even though their used correlation identifiers are different:\n          \n          \n            \n             * This interface defines a {@link #resultEquals()} method that also takes an equivalence map, and determines equality up to the equivalences defined therein. Two correlated entities are equivalent even if they use different names, as long as un-bound correlations can be aligned. For example, in:", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/988#discussion_r452406881", "createdAt": "2020-07-09T18:22:04Z", "author": {"login": "nschiefer"}, "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/Correlated.java", "diffHunk": "@@ -0,0 +1,144 @@\n+/*\n+ * Correlated.java\n+ *\n+ * This source file is part of the FoundationDB open source project\n+ *\n+ * Copyright 2015-2020 Apple Inc. and the FoundationDB project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.apple.foundationdb.record.query.plan.temp;\n+\n+import com.google.common.collect.BiMap;\n+\n+import javax.annotation.Nonnull;\n+import java.util.Map;\n+import java.util.Set;\n+\n+/**\n+ * Interface for classes to implement entities which can be correlated to some other entity (usually a {@link Quantifier})\n+ * that is disambiguated by means of a {@link CorrelationIdentifier}. Objects of implementors of this class are said\n+ * to be correlated to a quantifier {@code q} if the identifiers returned by {@link #getCorrelatedTo()} set contain\n+ * the alias identifier that {@code q} uses.\n+ *\n+ * Note that this level of indirection simplifies modifications of the graph e.g. as result of applied transformations\n+ * during the planning stage of a query.\n+ *\n+ * An object that is correlated to some other object can be _rebased_ by means of invoking {@link #rebase} using\n+ * a translation {@code id} to {@code id'}. The result of that invocation is a new object of type {@code S} that is\n+ * identical the original {@code this} except that all correlated references to {@code id} of the new object as well as\n+ * all objects {@code this} owns (i.e. other objects this object is composed of, e.g. children, etc.) now refer to a\n+ * new {@link CorrelationIdentifier} {@code id'}.\n+ *\n+ * Since translations are associative we allow to rebase many identifiers in the same {@link #rebase} invocation.\n+ *\n+ * As the planner DAG objects are immutable, a rebase operation can be expensive as objects have to be recreated\n+ * as needed. We follow the ideas of other persistent data structures as we do not require a copy to be made.\n+ * It is perfectly acceptable to return {@code this} as long as it can be proven that {@code this} is not correlated to\n+ * any identifier participating in the translation.\n+ *\n+ * This interface defines {@code equals()} using an equivalence map. Names are smoke and sound! Two sub-graphs\n+ * may be considered equal even though their used correlation identifiers are different:", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6eb7142ab316ffbec53e375804118f722f1d2bcc"}, "originalPosition": 52}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgyMDczNzkzOnYy", "diffSide": "RIGHT", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/Correlated.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOVQxODoyMjo0MFrOGvcvpQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOVQxODoyMjo0MFrOGvcvpQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjQwNzIwNQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n             * SELECT *\n          \n          \n            \n             * FROM T1 a, T2 b\n          \n          \n            \n             * WHERE a.x = b.y\n          \n          \n            \n             * UNION (SELECT *\n          \n          \n            \n             *        FROM T1 c, T2 d\n          \n          \n            \n             *        WHERE c.x = d.y)\n          \n          \n            \n            * <pre>\n          \n          \n            \n             * SELECT *\n          \n          \n            \n             * FROM T1 a, T2 b\n          \n          \n            \n             * WHERE a.x = b.y\n          \n          \n            \n             * UNION (SELECT *\n          \n          \n            \n             *        FROM T1 c, T2 d\n          \n          \n            \n             *        WHERE c.x = d.y)\n          \n          \n            \n             * </pre>", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/988#discussion_r452407205", "createdAt": "2020-07-09T18:22:40Z", "author": {"login": "nschiefer"}, "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/Correlated.java", "diffHunk": "@@ -0,0 +1,144 @@\n+/*\n+ * Correlated.java\n+ *\n+ * This source file is part of the FoundationDB open source project\n+ *\n+ * Copyright 2015-2020 Apple Inc. and the FoundationDB project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.apple.foundationdb.record.query.plan.temp;\n+\n+import com.google.common.collect.BiMap;\n+\n+import javax.annotation.Nonnull;\n+import java.util.Map;\n+import java.util.Set;\n+\n+/**\n+ * Interface for classes to implement entities which can be correlated to some other entity (usually a {@link Quantifier})\n+ * that is disambiguated by means of a {@link CorrelationIdentifier}. Objects of implementors of this class are said\n+ * to be correlated to a quantifier {@code q} if the identifiers returned by {@link #getCorrelatedTo()} set contain\n+ * the alias identifier that {@code q} uses.\n+ *\n+ * Note that this level of indirection simplifies modifications of the graph e.g. as result of applied transformations\n+ * during the planning stage of a query.\n+ *\n+ * An object that is correlated to some other object can be _rebased_ by means of invoking {@link #rebase} using\n+ * a translation {@code id} to {@code id'}. The result of that invocation is a new object of type {@code S} that is\n+ * identical the original {@code this} except that all correlated references to {@code id} of the new object as well as\n+ * all objects {@code this} owns (i.e. other objects this object is composed of, e.g. children, etc.) now refer to a\n+ * new {@link CorrelationIdentifier} {@code id'}.\n+ *\n+ * Since translations are associative we allow to rebase many identifiers in the same {@link #rebase} invocation.\n+ *\n+ * As the planner DAG objects are immutable, a rebase operation can be expensive as objects have to be recreated\n+ * as needed. We follow the ideas of other persistent data structures as we do not require a copy to be made.\n+ * It is perfectly acceptable to return {@code this} as long as it can be proven that {@code this} is not correlated to\n+ * any identifier participating in the translation.\n+ *\n+ * This interface defines {@code equals()} using an equivalence map. Names are smoke and sound! Two sub-graphs\n+ * may be considered equal even though their used correlation identifiers are different:\n+ *\n+ * SELECT *\n+ * FROM T1 a, T2 b\n+ * WHERE a.x = b.y\n+ * UNION (SELECT *\n+ *        FROM T1 c, T2 d\n+ *        WHERE c.x = d.y)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6eb7142ab316ffbec53e375804118f722f1d2bcc"}, "originalPosition": 59}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgyMDc0MDc5OnYy", "diffSide": "RIGHT", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/Correlated.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOVQxODoyMzozNVrOGvcxdw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOVQxODoyMzozNVrOGvcxdw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjQwNzY3MQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * Determines the set of {@link CorrelationIdentifier}s this entity is correlated to, in a sense dependent upon.\n          \n          \n            \n                 * Return the set of {@link CorrelationIdentifier}s this entity is correlated to.", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/988#discussion_r452407671", "createdAt": "2020-07-09T18:23:35Z", "author": {"login": "nschiefer"}, "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/Correlated.java", "diffHunk": "@@ -0,0 +1,144 @@\n+/*\n+ * Correlated.java\n+ *\n+ * This source file is part of the FoundationDB open source project\n+ *\n+ * Copyright 2015-2020 Apple Inc. and the FoundationDB project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.apple.foundationdb.record.query.plan.temp;\n+\n+import com.google.common.collect.BiMap;\n+\n+import javax.annotation.Nonnull;\n+import java.util.Map;\n+import java.util.Set;\n+\n+/**\n+ * Interface for classes to implement entities which can be correlated to some other entity (usually a {@link Quantifier})\n+ * that is disambiguated by means of a {@link CorrelationIdentifier}. Objects of implementors of this class are said\n+ * to be correlated to a quantifier {@code q} if the identifiers returned by {@link #getCorrelatedTo()} set contain\n+ * the alias identifier that {@code q} uses.\n+ *\n+ * Note that this level of indirection simplifies modifications of the graph e.g. as result of applied transformations\n+ * during the planning stage of a query.\n+ *\n+ * An object that is correlated to some other object can be _rebased_ by means of invoking {@link #rebase} using\n+ * a translation {@code id} to {@code id'}. The result of that invocation is a new object of type {@code S} that is\n+ * identical the original {@code this} except that all correlated references to {@code id} of the new object as well as\n+ * all objects {@code this} owns (i.e. other objects this object is composed of, e.g. children, etc.) now refer to a\n+ * new {@link CorrelationIdentifier} {@code id'}.\n+ *\n+ * Since translations are associative we allow to rebase many identifiers in the same {@link #rebase} invocation.\n+ *\n+ * As the planner DAG objects are immutable, a rebase operation can be expensive as objects have to be recreated\n+ * as needed. We follow the ideas of other persistent data structures as we do not require a copy to be made.\n+ * It is perfectly acceptable to return {@code this} as long as it can be proven that {@code this} is not correlated to\n+ * any identifier participating in the translation.\n+ *\n+ * This interface defines {@code equals()} using an equivalence map. Names are smoke and sound! Two sub-graphs\n+ * may be considered equal even though their used correlation identifiers are different:\n+ *\n+ * SELECT *\n+ * FROM T1 a, T2 b\n+ * WHERE a.x = b.y\n+ * UNION (SELECT *\n+ *        FROM T1 c, T2 d\n+ *        WHERE c.x = d.y)\n+ *\n+ * The two SELECT blocks should be considered equal even though they use different correlation names. The\n+ * {@link #resultEquals} introduced here considers these blocks equal using a bi-map that allows for the definition\n+ * of equivalences among correlation identifiers. In this case\n+ *\n+ * <pre>\n+ * {@code\n+ * (SELECT * FROM T1 a, T2 b WHERE a.x = b.y).equals(SELECT * FROM T1 c, T2 d WHERE c.x = d.y, ImmutableBiMap.of())\n+ * }\n+ * </pre>\n+ *\n+ * result (through a series of other steps) in an invocation of\n+ *\n+ * <pre>\n+ * {@code\n+ * (WHERE a.x = b.y).equals(WHERE c.x = d.y, ImmutableBiMap.of(a -> b, c -> d))\n+ * }\n+ * </pre>\n+ *\n+ * which then results in a {@code true} as {@code a} is considered to be equal to {@code c} and {@code b} is considered\n+ * to be equal to {@code d}.\n+ *\n+ * @param <S> self type of this. Needed for rebasing to a proper constrained at-least type\n+ */\n+public interface Correlated<S extends Correlated<S>> {\n+    /**\n+     * Determines the set of {@link CorrelationIdentifier}s this entity is correlated to, in a sense dependent upon.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6eb7142ab316ffbec53e375804118f722f1d2bcc"}, "originalPosition": 86}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgyMDc0MzU0OnYy", "diffSide": "RIGHT", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/Correlated.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOVQxODoyNDoyOFrOGvczPg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOVQxODoyNDoyOFrOGvczPg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjQwODEyNg==", "bodyText": "Does RecordQuery implement Correlated? I think you might mean RecordQueryPlan, which is probably redundant because aRecordQueryPlan is a RelationalExpression.", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/988#discussion_r452408126", "createdAt": "2020-07-09T18:24:28Z", "author": {"login": "nschiefer"}, "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/Correlated.java", "diffHunk": "@@ -0,0 +1,144 @@\n+/*\n+ * Correlated.java\n+ *\n+ * This source file is part of the FoundationDB open source project\n+ *\n+ * Copyright 2015-2020 Apple Inc. and the FoundationDB project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.apple.foundationdb.record.query.plan.temp;\n+\n+import com.google.common.collect.BiMap;\n+\n+import javax.annotation.Nonnull;\n+import java.util.Map;\n+import java.util.Set;\n+\n+/**\n+ * Interface for classes to implement entities which can be correlated to some other entity (usually a {@link Quantifier})\n+ * that is disambiguated by means of a {@link CorrelationIdentifier}. Objects of implementors of this class are said\n+ * to be correlated to a quantifier {@code q} if the identifiers returned by {@link #getCorrelatedTo()} set contain\n+ * the alias identifier that {@code q} uses.\n+ *\n+ * Note that this level of indirection simplifies modifications of the graph e.g. as result of applied transformations\n+ * during the planning stage of a query.\n+ *\n+ * An object that is correlated to some other object can be _rebased_ by means of invoking {@link #rebase} using\n+ * a translation {@code id} to {@code id'}. The result of that invocation is a new object of type {@code S} that is\n+ * identical the original {@code this} except that all correlated references to {@code id} of the new object as well as\n+ * all objects {@code this} owns (i.e. other objects this object is composed of, e.g. children, etc.) now refer to a\n+ * new {@link CorrelationIdentifier} {@code id'}.\n+ *\n+ * Since translations are associative we allow to rebase many identifiers in the same {@link #rebase} invocation.\n+ *\n+ * As the planner DAG objects are immutable, a rebase operation can be expensive as objects have to be recreated\n+ * as needed. We follow the ideas of other persistent data structures as we do not require a copy to be made.\n+ * It is perfectly acceptable to return {@code this} as long as it can be proven that {@code this} is not correlated to\n+ * any identifier participating in the translation.\n+ *\n+ * This interface defines {@code equals()} using an equivalence map. Names are smoke and sound! Two sub-graphs\n+ * may be considered equal even though their used correlation identifiers are different:\n+ *\n+ * SELECT *\n+ * FROM T1 a, T2 b\n+ * WHERE a.x = b.y\n+ * UNION (SELECT *\n+ *        FROM T1 c, T2 d\n+ *        WHERE c.x = d.y)\n+ *\n+ * The two SELECT blocks should be considered equal even though they use different correlation names. The\n+ * {@link #resultEquals} introduced here considers these blocks equal using a bi-map that allows for the definition\n+ * of equivalences among correlation identifiers. In this case\n+ *\n+ * <pre>\n+ * {@code\n+ * (SELECT * FROM T1 a, T2 b WHERE a.x = b.y).equals(SELECT * FROM T1 c, T2 d WHERE c.x = d.y, ImmutableBiMap.of())\n+ * }\n+ * </pre>\n+ *\n+ * result (through a series of other steps) in an invocation of\n+ *\n+ * <pre>\n+ * {@code\n+ * (WHERE a.x = b.y).equals(WHERE c.x = d.y, ImmutableBiMap.of(a -> b, c -> d))\n+ * }\n+ * </pre>\n+ *\n+ * which then results in a {@code true} as {@code a} is considered to be equal to {@code c} and {@code b} is considered\n+ * to be equal to {@code d}.\n+ *\n+ * @param <S> self type of this. Needed for rebasing to a proper constrained at-least type\n+ */\n+public interface Correlated<S extends Correlated<S>> {\n+    /**\n+     * Determines the set of {@link CorrelationIdentifier}s this entity is correlated to, in a sense dependent upon.\n+     * This means that without a process that binds these correlations to values, the expression, either\n+     * a {@link RelationalExpression}, a {@link com.apple.foundationdb.record.query.RecordQuery} (or others that", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6eb7142ab316ffbec53e375804118f722f1d2bcc"}, "originalPosition": 88}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgyMDc0NTk5OnYy", "diffSide": "RIGHT", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/Correlated.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOVQxODoyNTowN1rOGvc0wA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOVQxODoyNTowN1rOGvc0wA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjQwODUxMg==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * implement this interface) cannot even conceptually produce a meaningful result. As often times entities that\n          \n          \n            \n                 * implement this interface) cannot even in principle produce a meaningful result. As often times entities that", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/988#discussion_r452408512", "createdAt": "2020-07-09T18:25:07Z", "author": {"login": "nschiefer"}, "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/Correlated.java", "diffHunk": "@@ -0,0 +1,144 @@\n+/*\n+ * Correlated.java\n+ *\n+ * This source file is part of the FoundationDB open source project\n+ *\n+ * Copyright 2015-2020 Apple Inc. and the FoundationDB project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.apple.foundationdb.record.query.plan.temp;\n+\n+import com.google.common.collect.BiMap;\n+\n+import javax.annotation.Nonnull;\n+import java.util.Map;\n+import java.util.Set;\n+\n+/**\n+ * Interface for classes to implement entities which can be correlated to some other entity (usually a {@link Quantifier})\n+ * that is disambiguated by means of a {@link CorrelationIdentifier}. Objects of implementors of this class are said\n+ * to be correlated to a quantifier {@code q} if the identifiers returned by {@link #getCorrelatedTo()} set contain\n+ * the alias identifier that {@code q} uses.\n+ *\n+ * Note that this level of indirection simplifies modifications of the graph e.g. as result of applied transformations\n+ * during the planning stage of a query.\n+ *\n+ * An object that is correlated to some other object can be _rebased_ by means of invoking {@link #rebase} using\n+ * a translation {@code id} to {@code id'}. The result of that invocation is a new object of type {@code S} that is\n+ * identical the original {@code this} except that all correlated references to {@code id} of the new object as well as\n+ * all objects {@code this} owns (i.e. other objects this object is composed of, e.g. children, etc.) now refer to a\n+ * new {@link CorrelationIdentifier} {@code id'}.\n+ *\n+ * Since translations are associative we allow to rebase many identifiers in the same {@link #rebase} invocation.\n+ *\n+ * As the planner DAG objects are immutable, a rebase operation can be expensive as objects have to be recreated\n+ * as needed. We follow the ideas of other persistent data structures as we do not require a copy to be made.\n+ * It is perfectly acceptable to return {@code this} as long as it can be proven that {@code this} is not correlated to\n+ * any identifier participating in the translation.\n+ *\n+ * This interface defines {@code equals()} using an equivalence map. Names are smoke and sound! Two sub-graphs\n+ * may be considered equal even though their used correlation identifiers are different:\n+ *\n+ * SELECT *\n+ * FROM T1 a, T2 b\n+ * WHERE a.x = b.y\n+ * UNION (SELECT *\n+ *        FROM T1 c, T2 d\n+ *        WHERE c.x = d.y)\n+ *\n+ * The two SELECT blocks should be considered equal even though they use different correlation names. The\n+ * {@link #resultEquals} introduced here considers these blocks equal using a bi-map that allows for the definition\n+ * of equivalences among correlation identifiers. In this case\n+ *\n+ * <pre>\n+ * {@code\n+ * (SELECT * FROM T1 a, T2 b WHERE a.x = b.y).equals(SELECT * FROM T1 c, T2 d WHERE c.x = d.y, ImmutableBiMap.of())\n+ * }\n+ * </pre>\n+ *\n+ * result (through a series of other steps) in an invocation of\n+ *\n+ * <pre>\n+ * {@code\n+ * (WHERE a.x = b.y).equals(WHERE c.x = d.y, ImmutableBiMap.of(a -> b, c -> d))\n+ * }\n+ * </pre>\n+ *\n+ * which then results in a {@code true} as {@code a} is considered to be equal to {@code c} and {@code b} is considered\n+ * to be equal to {@code d}.\n+ *\n+ * @param <S> self type of this. Needed for rebasing to a proper constrained at-least type\n+ */\n+public interface Correlated<S extends Correlated<S>> {\n+    /**\n+     * Determines the set of {@link CorrelationIdentifier}s this entity is correlated to, in a sense dependent upon.\n+     * This means that without a process that binds these correlations to values, the expression, either\n+     * a {@link RelationalExpression}, a {@link com.apple.foundationdb.record.query.RecordQuery} (or others that\n+     * implement this interface) cannot even conceptually produce a meaningful result. As often times entities that", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6eb7142ab316ffbec53e375804118f722f1d2bcc"}, "originalPosition": 89}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgyMDc0NzkxOnYy", "diffSide": "RIGHT", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/Correlated.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOVQxODoyNTozMVrOGvc1zQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOVQxODoyNTozMVrOGvc1zQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjQwODc4MQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * Rebases this and all other objects this objects is composed of against a given translation map.\n          \n          \n            \n                 * Rebases this and all other objects this objects is composed of using the given translation map.", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/988#discussion_r452408781", "createdAt": "2020-07-09T18:25:31Z", "author": {"login": "nschiefer"}, "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/Correlated.java", "diffHunk": "@@ -0,0 +1,144 @@\n+/*\n+ * Correlated.java\n+ *\n+ * This source file is part of the FoundationDB open source project\n+ *\n+ * Copyright 2015-2020 Apple Inc. and the FoundationDB project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.apple.foundationdb.record.query.plan.temp;\n+\n+import com.google.common.collect.BiMap;\n+\n+import javax.annotation.Nonnull;\n+import java.util.Map;\n+import java.util.Set;\n+\n+/**\n+ * Interface for classes to implement entities which can be correlated to some other entity (usually a {@link Quantifier})\n+ * that is disambiguated by means of a {@link CorrelationIdentifier}. Objects of implementors of this class are said\n+ * to be correlated to a quantifier {@code q} if the identifiers returned by {@link #getCorrelatedTo()} set contain\n+ * the alias identifier that {@code q} uses.\n+ *\n+ * Note that this level of indirection simplifies modifications of the graph e.g. as result of applied transformations\n+ * during the planning stage of a query.\n+ *\n+ * An object that is correlated to some other object can be _rebased_ by means of invoking {@link #rebase} using\n+ * a translation {@code id} to {@code id'}. The result of that invocation is a new object of type {@code S} that is\n+ * identical the original {@code this} except that all correlated references to {@code id} of the new object as well as\n+ * all objects {@code this} owns (i.e. other objects this object is composed of, e.g. children, etc.) now refer to a\n+ * new {@link CorrelationIdentifier} {@code id'}.\n+ *\n+ * Since translations are associative we allow to rebase many identifiers in the same {@link #rebase} invocation.\n+ *\n+ * As the planner DAG objects are immutable, a rebase operation can be expensive as objects have to be recreated\n+ * as needed. We follow the ideas of other persistent data structures as we do not require a copy to be made.\n+ * It is perfectly acceptable to return {@code this} as long as it can be proven that {@code this} is not correlated to\n+ * any identifier participating in the translation.\n+ *\n+ * This interface defines {@code equals()} using an equivalence map. Names are smoke and sound! Two sub-graphs\n+ * may be considered equal even though their used correlation identifiers are different:\n+ *\n+ * SELECT *\n+ * FROM T1 a, T2 b\n+ * WHERE a.x = b.y\n+ * UNION (SELECT *\n+ *        FROM T1 c, T2 d\n+ *        WHERE c.x = d.y)\n+ *\n+ * The two SELECT blocks should be considered equal even though they use different correlation names. The\n+ * {@link #resultEquals} introduced here considers these blocks equal using a bi-map that allows for the definition\n+ * of equivalences among correlation identifiers. In this case\n+ *\n+ * <pre>\n+ * {@code\n+ * (SELECT * FROM T1 a, T2 b WHERE a.x = b.y).equals(SELECT * FROM T1 c, T2 d WHERE c.x = d.y, ImmutableBiMap.of())\n+ * }\n+ * </pre>\n+ *\n+ * result (through a series of other steps) in an invocation of\n+ *\n+ * <pre>\n+ * {@code\n+ * (WHERE a.x = b.y).equals(WHERE c.x = d.y, ImmutableBiMap.of(a -> b, c -> d))\n+ * }\n+ * </pre>\n+ *\n+ * which then results in a {@code true} as {@code a} is considered to be equal to {@code c} and {@code b} is considered\n+ * to be equal to {@code d}.\n+ *\n+ * @param <S> self type of this. Needed for rebasing to a proper constrained at-least type\n+ */\n+public interface Correlated<S extends Correlated<S>> {\n+    /**\n+     * Determines the set of {@link CorrelationIdentifier}s this entity is correlated to, in a sense dependent upon.\n+     * This means that without a process that binds these correlations to values, the expression, either\n+     * a {@link RelationalExpression}, a {@link com.apple.foundationdb.record.query.RecordQuery} (or others that\n+     * implement this interface) cannot even conceptually produce a meaningful result. As often times entities that\n+     * implement this interface use composition and effectively describe trees or DAGs, this method should be the\n+     * set union of the {@link CorrelationIdentifier}s this object is correlated to as well as all children,\n+     * constituent parts, etc.\n+     * @return the set of {@link CorrelationIdentifier}s this entity is correlated to\n+     */\n+    @Nonnull\n+    Set<CorrelationIdentifier> getCorrelatedTo();\n+\n+    /**\n+     * Rebases this and all other objects this objects is composed of against a given translation map.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6eb7142ab316ffbec53e375804118f722f1d2bcc"}, "originalPosition": 99}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgyMDc0ODk4OnYy", "diffSide": "RIGHT", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/Correlated.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOVQxODoyNTo0N1rOGvc2Zg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOVQxODoyNTo0N1rOGvc2Zg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjQwODkzNA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 *        been transformed to use the mapped counterpart of {@code id} {@code id'} in {@code ids'}. Ids not\n          \n          \n            \n                 *        been transformed to use the mapped counterpart of {@code id} {@code id'} in {@code ids'}. IDs not", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/988#discussion_r452408934", "createdAt": "2020-07-09T18:25:47Z", "author": {"login": "nschiefer"}, "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/Correlated.java", "diffHunk": "@@ -0,0 +1,144 @@\n+/*\n+ * Correlated.java\n+ *\n+ * This source file is part of the FoundationDB open source project\n+ *\n+ * Copyright 2015-2020 Apple Inc. and the FoundationDB project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.apple.foundationdb.record.query.plan.temp;\n+\n+import com.google.common.collect.BiMap;\n+\n+import javax.annotation.Nonnull;\n+import java.util.Map;\n+import java.util.Set;\n+\n+/**\n+ * Interface for classes to implement entities which can be correlated to some other entity (usually a {@link Quantifier})\n+ * that is disambiguated by means of a {@link CorrelationIdentifier}. Objects of implementors of this class are said\n+ * to be correlated to a quantifier {@code q} if the identifiers returned by {@link #getCorrelatedTo()} set contain\n+ * the alias identifier that {@code q} uses.\n+ *\n+ * Note that this level of indirection simplifies modifications of the graph e.g. as result of applied transformations\n+ * during the planning stage of a query.\n+ *\n+ * An object that is correlated to some other object can be _rebased_ by means of invoking {@link #rebase} using\n+ * a translation {@code id} to {@code id'}. The result of that invocation is a new object of type {@code S} that is\n+ * identical the original {@code this} except that all correlated references to {@code id} of the new object as well as\n+ * all objects {@code this} owns (i.e. other objects this object is composed of, e.g. children, etc.) now refer to a\n+ * new {@link CorrelationIdentifier} {@code id'}.\n+ *\n+ * Since translations are associative we allow to rebase many identifiers in the same {@link #rebase} invocation.\n+ *\n+ * As the planner DAG objects are immutable, a rebase operation can be expensive as objects have to be recreated\n+ * as needed. We follow the ideas of other persistent data structures as we do not require a copy to be made.\n+ * It is perfectly acceptable to return {@code this} as long as it can be proven that {@code this} is not correlated to\n+ * any identifier participating in the translation.\n+ *\n+ * This interface defines {@code equals()} using an equivalence map. Names are smoke and sound! Two sub-graphs\n+ * may be considered equal even though their used correlation identifiers are different:\n+ *\n+ * SELECT *\n+ * FROM T1 a, T2 b\n+ * WHERE a.x = b.y\n+ * UNION (SELECT *\n+ *        FROM T1 c, T2 d\n+ *        WHERE c.x = d.y)\n+ *\n+ * The two SELECT blocks should be considered equal even though they use different correlation names. The\n+ * {@link #resultEquals} introduced here considers these blocks equal using a bi-map that allows for the definition\n+ * of equivalences among correlation identifiers. In this case\n+ *\n+ * <pre>\n+ * {@code\n+ * (SELECT * FROM T1 a, T2 b WHERE a.x = b.y).equals(SELECT * FROM T1 c, T2 d WHERE c.x = d.y, ImmutableBiMap.of())\n+ * }\n+ * </pre>\n+ *\n+ * result (through a series of other steps) in an invocation of\n+ *\n+ * <pre>\n+ * {@code\n+ * (WHERE a.x = b.y).equals(WHERE c.x = d.y, ImmutableBiMap.of(a -> b, c -> d))\n+ * }\n+ * </pre>\n+ *\n+ * which then results in a {@code true} as {@code a} is considered to be equal to {@code c} and {@code b} is considered\n+ * to be equal to {@code d}.\n+ *\n+ * @param <S> self type of this. Needed for rebasing to a proper constrained at-least type\n+ */\n+public interface Correlated<S extends Correlated<S>> {\n+    /**\n+     * Determines the set of {@link CorrelationIdentifier}s this entity is correlated to, in a sense dependent upon.\n+     * This means that without a process that binds these correlations to values, the expression, either\n+     * a {@link RelationalExpression}, a {@link com.apple.foundationdb.record.query.RecordQuery} (or others that\n+     * implement this interface) cannot even conceptually produce a meaningful result. As often times entities that\n+     * implement this interface use composition and effectively describe trees or DAGs, this method should be the\n+     * set union of the {@link CorrelationIdentifier}s this object is correlated to as well as all children,\n+     * constituent parts, etc.\n+     * @return the set of {@link CorrelationIdentifier}s this entity is correlated to\n+     */\n+    @Nonnull\n+    Set<CorrelationIdentifier> getCorrelatedTo();\n+\n+    /**\n+     * Rebases this and all other objects this objects is composed of against a given translation map.\n+     * @param translationMap a map defining a translation from {@link CorrelationIdentifier}s {@code ids} to\n+     *        {@link CorrelationIdentifier}s {@code ids'}. After the rebase, every correlation to an {@code id}\n+     *        contained {@code ids} that is contained or referred to directly or indirectly by {@code this} must have\n+     *        been transformed to use the mapped counterpart of {@code id} {@code id'} in {@code ids'}. Ids not", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6eb7142ab316ffbec53e375804118f722f1d2bcc"}, "originalPosition": 103}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgyMDc0OTYzOnYy", "diffSide": "RIGHT", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/Correlated.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOVQxODoyNjowMFrOGvc2zA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xM1QyMjoyNDoxNFrOGw8nhQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjQwOTAzNg==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                S rebase(Map<CorrelationIdentifier, CorrelationIdentifier> translationMap);\n          \n          \n            \n                S rebase(@Nonnull Map<CorrelationIdentifier, CorrelationIdentifier> translationMap);", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/988#discussion_r452409036", "createdAt": "2020-07-09T18:26:00Z", "author": {"login": "nschiefer"}, "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/Correlated.java", "diffHunk": "@@ -0,0 +1,144 @@\n+/*\n+ * Correlated.java\n+ *\n+ * This source file is part of the FoundationDB open source project\n+ *\n+ * Copyright 2015-2020 Apple Inc. and the FoundationDB project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.apple.foundationdb.record.query.plan.temp;\n+\n+import com.google.common.collect.BiMap;\n+\n+import javax.annotation.Nonnull;\n+import java.util.Map;\n+import java.util.Set;\n+\n+/**\n+ * Interface for classes to implement entities which can be correlated to some other entity (usually a {@link Quantifier})\n+ * that is disambiguated by means of a {@link CorrelationIdentifier}. Objects of implementors of this class are said\n+ * to be correlated to a quantifier {@code q} if the identifiers returned by {@link #getCorrelatedTo()} set contain\n+ * the alias identifier that {@code q} uses.\n+ *\n+ * Note that this level of indirection simplifies modifications of the graph e.g. as result of applied transformations\n+ * during the planning stage of a query.\n+ *\n+ * An object that is correlated to some other object can be _rebased_ by means of invoking {@link #rebase} using\n+ * a translation {@code id} to {@code id'}. The result of that invocation is a new object of type {@code S} that is\n+ * identical the original {@code this} except that all correlated references to {@code id} of the new object as well as\n+ * all objects {@code this} owns (i.e. other objects this object is composed of, e.g. children, etc.) now refer to a\n+ * new {@link CorrelationIdentifier} {@code id'}.\n+ *\n+ * Since translations are associative we allow to rebase many identifiers in the same {@link #rebase} invocation.\n+ *\n+ * As the planner DAG objects are immutable, a rebase operation can be expensive as objects have to be recreated\n+ * as needed. We follow the ideas of other persistent data structures as we do not require a copy to be made.\n+ * It is perfectly acceptable to return {@code this} as long as it can be proven that {@code this} is not correlated to\n+ * any identifier participating in the translation.\n+ *\n+ * This interface defines {@code equals()} using an equivalence map. Names are smoke and sound! Two sub-graphs\n+ * may be considered equal even though their used correlation identifiers are different:\n+ *\n+ * SELECT *\n+ * FROM T1 a, T2 b\n+ * WHERE a.x = b.y\n+ * UNION (SELECT *\n+ *        FROM T1 c, T2 d\n+ *        WHERE c.x = d.y)\n+ *\n+ * The two SELECT blocks should be considered equal even though they use different correlation names. The\n+ * {@link #resultEquals} introduced here considers these blocks equal using a bi-map that allows for the definition\n+ * of equivalences among correlation identifiers. In this case\n+ *\n+ * <pre>\n+ * {@code\n+ * (SELECT * FROM T1 a, T2 b WHERE a.x = b.y).equals(SELECT * FROM T1 c, T2 d WHERE c.x = d.y, ImmutableBiMap.of())\n+ * }\n+ * </pre>\n+ *\n+ * result (through a series of other steps) in an invocation of\n+ *\n+ * <pre>\n+ * {@code\n+ * (WHERE a.x = b.y).equals(WHERE c.x = d.y, ImmutableBiMap.of(a -> b, c -> d))\n+ * }\n+ * </pre>\n+ *\n+ * which then results in a {@code true} as {@code a} is considered to be equal to {@code c} and {@code b} is considered\n+ * to be equal to {@code d}.\n+ *\n+ * @param <S> self type of this. Needed for rebasing to a proper constrained at-least type\n+ */\n+public interface Correlated<S extends Correlated<S>> {\n+    /**\n+     * Determines the set of {@link CorrelationIdentifier}s this entity is correlated to, in a sense dependent upon.\n+     * This means that without a process that binds these correlations to values, the expression, either\n+     * a {@link RelationalExpression}, a {@link com.apple.foundationdb.record.query.RecordQuery} (or others that\n+     * implement this interface) cannot even conceptually produce a meaningful result. As often times entities that\n+     * implement this interface use composition and effectively describe trees or DAGs, this method should be the\n+     * set union of the {@link CorrelationIdentifier}s this object is correlated to as well as all children,\n+     * constituent parts, etc.\n+     * @return the set of {@link CorrelationIdentifier}s this entity is correlated to\n+     */\n+    @Nonnull\n+    Set<CorrelationIdentifier> getCorrelatedTo();\n+\n+    /**\n+     * Rebases this and all other objects this objects is composed of against a given translation map.\n+     * @param translationMap a map defining a translation from {@link CorrelationIdentifier}s {@code ids} to\n+     *        {@link CorrelationIdentifier}s {@code ids'}. After the rebase, every correlation to an {@code id}\n+     *        contained {@code ids} that is contained or referred to directly or indirectly by {@code this} must have\n+     *        been transformed to use the mapped counterpart of {@code id} {@code id'} in {@code ids'}. Ids not\n+     *        contained in the translation map must remain unmodified by the rebase operation.\n+     * @return a new entity that has been rebased\n+     */\n+    @Nonnull\n+    S rebase(Map<CorrelationIdentifier, CorrelationIdentifier> translationMap);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6eb7142ab316ffbec53e375804118f722f1d2bcc"}, "originalPosition": 108}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mzk3Nzk4OQ==", "bodyText": "See comment below about giving the translation maps a nicer interface.", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/988#discussion_r453977989", "createdAt": "2020-07-13T22:24:14Z", "author": {"login": "nschiefer"}, "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/Correlated.java", "diffHunk": "@@ -0,0 +1,144 @@\n+/*\n+ * Correlated.java\n+ *\n+ * This source file is part of the FoundationDB open source project\n+ *\n+ * Copyright 2015-2020 Apple Inc. and the FoundationDB project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.apple.foundationdb.record.query.plan.temp;\n+\n+import com.google.common.collect.BiMap;\n+\n+import javax.annotation.Nonnull;\n+import java.util.Map;\n+import java.util.Set;\n+\n+/**\n+ * Interface for classes to implement entities which can be correlated to some other entity (usually a {@link Quantifier})\n+ * that is disambiguated by means of a {@link CorrelationIdentifier}. Objects of implementors of this class are said\n+ * to be correlated to a quantifier {@code q} if the identifiers returned by {@link #getCorrelatedTo()} set contain\n+ * the alias identifier that {@code q} uses.\n+ *\n+ * Note that this level of indirection simplifies modifications of the graph e.g. as result of applied transformations\n+ * during the planning stage of a query.\n+ *\n+ * An object that is correlated to some other object can be _rebased_ by means of invoking {@link #rebase} using\n+ * a translation {@code id} to {@code id'}. The result of that invocation is a new object of type {@code S} that is\n+ * identical the original {@code this} except that all correlated references to {@code id} of the new object as well as\n+ * all objects {@code this} owns (i.e. other objects this object is composed of, e.g. children, etc.) now refer to a\n+ * new {@link CorrelationIdentifier} {@code id'}.\n+ *\n+ * Since translations are associative we allow to rebase many identifiers in the same {@link #rebase} invocation.\n+ *\n+ * As the planner DAG objects are immutable, a rebase operation can be expensive as objects have to be recreated\n+ * as needed. We follow the ideas of other persistent data structures as we do not require a copy to be made.\n+ * It is perfectly acceptable to return {@code this} as long as it can be proven that {@code this} is not correlated to\n+ * any identifier participating in the translation.\n+ *\n+ * This interface defines {@code equals()} using an equivalence map. Names are smoke and sound! Two sub-graphs\n+ * may be considered equal even though their used correlation identifiers are different:\n+ *\n+ * SELECT *\n+ * FROM T1 a, T2 b\n+ * WHERE a.x = b.y\n+ * UNION (SELECT *\n+ *        FROM T1 c, T2 d\n+ *        WHERE c.x = d.y)\n+ *\n+ * The two SELECT blocks should be considered equal even though they use different correlation names. The\n+ * {@link #resultEquals} introduced here considers these blocks equal using a bi-map that allows for the definition\n+ * of equivalences among correlation identifiers. In this case\n+ *\n+ * <pre>\n+ * {@code\n+ * (SELECT * FROM T1 a, T2 b WHERE a.x = b.y).equals(SELECT * FROM T1 c, T2 d WHERE c.x = d.y, ImmutableBiMap.of())\n+ * }\n+ * </pre>\n+ *\n+ * result (through a series of other steps) in an invocation of\n+ *\n+ * <pre>\n+ * {@code\n+ * (WHERE a.x = b.y).equals(WHERE c.x = d.y, ImmutableBiMap.of(a -> b, c -> d))\n+ * }\n+ * </pre>\n+ *\n+ * which then results in a {@code true} as {@code a} is considered to be equal to {@code c} and {@code b} is considered\n+ * to be equal to {@code d}.\n+ *\n+ * @param <S> self type of this. Needed for rebasing to a proper constrained at-least type\n+ */\n+public interface Correlated<S extends Correlated<S>> {\n+    /**\n+     * Determines the set of {@link CorrelationIdentifier}s this entity is correlated to, in a sense dependent upon.\n+     * This means that without a process that binds these correlations to values, the expression, either\n+     * a {@link RelationalExpression}, a {@link com.apple.foundationdb.record.query.RecordQuery} (or others that\n+     * implement this interface) cannot even conceptually produce a meaningful result. As often times entities that\n+     * implement this interface use composition and effectively describe trees or DAGs, this method should be the\n+     * set union of the {@link CorrelationIdentifier}s this object is correlated to as well as all children,\n+     * constituent parts, etc.\n+     * @return the set of {@link CorrelationIdentifier}s this entity is correlated to\n+     */\n+    @Nonnull\n+    Set<CorrelationIdentifier> getCorrelatedTo();\n+\n+    /**\n+     * Rebases this and all other objects this objects is composed of against a given translation map.\n+     * @param translationMap a map defining a translation from {@link CorrelationIdentifier}s {@code ids} to\n+     *        {@link CorrelationIdentifier}s {@code ids'}. After the rebase, every correlation to an {@code id}\n+     *        contained {@code ids} that is contained or referred to directly or indirectly by {@code this} must have\n+     *        been transformed to use the mapped counterpart of {@code id} {@code id'} in {@code ids'}. Ids not\n+     *        contained in the translation map must remain unmodified by the rebase operation.\n+     * @return a new entity that has been rebased\n+     */\n+    @Nonnull\n+    S rebase(Map<CorrelationIdentifier, CorrelationIdentifier> translationMap);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjQwOTAzNg=="}, "originalCommit": {"oid": "6eb7142ab316ffbec53e375804118f722f1d2bcc"}, "originalPosition": 108}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgyMDg2NzM2OnYy", "diffSide": "RIGHT", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/Correlated.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOVQxOTowMToxOFrOGveAUw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOVQxOTowMToxOFrOGveAUw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjQyNzg1OQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * Determine equality under the additional consideration of an equivalence map between {@link CorrelationIdentifier}s.\n          \n          \n            \n                 * Determine equality with respect to an equivalence map between {@link CorrelationIdentifier}s.", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/988#discussion_r452427859", "createdAt": "2020-07-09T19:01:18Z", "author": {"login": "nschiefer"}, "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/Correlated.java", "diffHunk": "@@ -0,0 +1,144 @@\n+/*\n+ * Correlated.java\n+ *\n+ * This source file is part of the FoundationDB open source project\n+ *\n+ * Copyright 2015-2020 Apple Inc. and the FoundationDB project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.apple.foundationdb.record.query.plan.temp;\n+\n+import com.google.common.collect.BiMap;\n+\n+import javax.annotation.Nonnull;\n+import java.util.Map;\n+import java.util.Set;\n+\n+/**\n+ * Interface for classes to implement entities which can be correlated to some other entity (usually a {@link Quantifier})\n+ * that is disambiguated by means of a {@link CorrelationIdentifier}. Objects of implementors of this class are said\n+ * to be correlated to a quantifier {@code q} if the identifiers returned by {@link #getCorrelatedTo()} set contain\n+ * the alias identifier that {@code q} uses.\n+ *\n+ * Note that this level of indirection simplifies modifications of the graph e.g. as result of applied transformations\n+ * during the planning stage of a query.\n+ *\n+ * An object that is correlated to some other object can be _rebased_ by means of invoking {@link #rebase} using\n+ * a translation {@code id} to {@code id'}. The result of that invocation is a new object of type {@code S} that is\n+ * identical the original {@code this} except that all correlated references to {@code id} of the new object as well as\n+ * all objects {@code this} owns (i.e. other objects this object is composed of, e.g. children, etc.) now refer to a\n+ * new {@link CorrelationIdentifier} {@code id'}.\n+ *\n+ * Since translations are associative we allow to rebase many identifiers in the same {@link #rebase} invocation.\n+ *\n+ * As the planner DAG objects are immutable, a rebase operation can be expensive as objects have to be recreated\n+ * as needed. We follow the ideas of other persistent data structures as we do not require a copy to be made.\n+ * It is perfectly acceptable to return {@code this} as long as it can be proven that {@code this} is not correlated to\n+ * any identifier participating in the translation.\n+ *\n+ * This interface defines {@code equals()} using an equivalence map. Names are smoke and sound! Two sub-graphs\n+ * may be considered equal even though their used correlation identifiers are different:\n+ *\n+ * SELECT *\n+ * FROM T1 a, T2 b\n+ * WHERE a.x = b.y\n+ * UNION (SELECT *\n+ *        FROM T1 c, T2 d\n+ *        WHERE c.x = d.y)\n+ *\n+ * The two SELECT blocks should be considered equal even though they use different correlation names. The\n+ * {@link #resultEquals} introduced here considers these blocks equal using a bi-map that allows for the definition\n+ * of equivalences among correlation identifiers. In this case\n+ *\n+ * <pre>\n+ * {@code\n+ * (SELECT * FROM T1 a, T2 b WHERE a.x = b.y).equals(SELECT * FROM T1 c, T2 d WHERE c.x = d.y, ImmutableBiMap.of())\n+ * }\n+ * </pre>\n+ *\n+ * result (through a series of other steps) in an invocation of\n+ *\n+ * <pre>\n+ * {@code\n+ * (WHERE a.x = b.y).equals(WHERE c.x = d.y, ImmutableBiMap.of(a -> b, c -> d))\n+ * }\n+ * </pre>\n+ *\n+ * which then results in a {@code true} as {@code a} is considered to be equal to {@code c} and {@code b} is considered\n+ * to be equal to {@code d}.\n+ *\n+ * @param <S> self type of this. Needed for rebasing to a proper constrained at-least type\n+ */\n+public interface Correlated<S extends Correlated<S>> {\n+    /**\n+     * Determines the set of {@link CorrelationIdentifier}s this entity is correlated to, in a sense dependent upon.\n+     * This means that without a process that binds these correlations to values, the expression, either\n+     * a {@link RelationalExpression}, a {@link com.apple.foundationdb.record.query.RecordQuery} (or others that\n+     * implement this interface) cannot even conceptually produce a meaningful result. As often times entities that\n+     * implement this interface use composition and effectively describe trees or DAGs, this method should be the\n+     * set union of the {@link CorrelationIdentifier}s this object is correlated to as well as all children,\n+     * constituent parts, etc.\n+     * @return the set of {@link CorrelationIdentifier}s this entity is correlated to\n+     */\n+    @Nonnull\n+    Set<CorrelationIdentifier> getCorrelatedTo();\n+\n+    /**\n+     * Rebases this and all other objects this objects is composed of against a given translation map.\n+     * @param translationMap a map defining a translation from {@link CorrelationIdentifier}s {@code ids} to\n+     *        {@link CorrelationIdentifier}s {@code ids'}. After the rebase, every correlation to an {@code id}\n+     *        contained {@code ids} that is contained or referred to directly or indirectly by {@code this} must have\n+     *        been transformed to use the mapped counterpart of {@code id} {@code id'} in {@code ids'}. Ids not\n+     *        contained in the translation map must remain unmodified by the rebase operation.\n+     * @return a new entity that has been rebased\n+     */\n+    @Nonnull\n+    S rebase(Map<CorrelationIdentifier, CorrelationIdentifier> translationMap);\n+\n+    /**\n+     * Determine equality under the additional consideration of an equivalence map between {@link CorrelationIdentifier}s.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6eb7142ab316ffbec53e375804118f722f1d2bcc"}, "originalPosition": 111}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgyMDg2OTY5OnYy", "diffSide": "RIGHT", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/Correlated.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOVQxOTowMjowMVrOGveB2A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOVQxOTowMjowMVrOGveB2A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjQyODI0OA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * and {@code q2} refer to a table {@code T} which presumably is the same table. Therefore, these two query blocks\n          \n          \n            \n                 * and {@code q2} refer to a record type {@code T} which presumably is the same type. Therefore, these two query blocks", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/988#discussion_r452428248", "createdAt": "2020-07-09T19:02:01Z", "author": {"login": "nschiefer"}, "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/Correlated.java", "diffHunk": "@@ -0,0 +1,144 @@\n+/*\n+ * Correlated.java\n+ *\n+ * This source file is part of the FoundationDB open source project\n+ *\n+ * Copyright 2015-2020 Apple Inc. and the FoundationDB project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.apple.foundationdb.record.query.plan.temp;\n+\n+import com.google.common.collect.BiMap;\n+\n+import javax.annotation.Nonnull;\n+import java.util.Map;\n+import java.util.Set;\n+\n+/**\n+ * Interface for classes to implement entities which can be correlated to some other entity (usually a {@link Quantifier})\n+ * that is disambiguated by means of a {@link CorrelationIdentifier}. Objects of implementors of this class are said\n+ * to be correlated to a quantifier {@code q} if the identifiers returned by {@link #getCorrelatedTo()} set contain\n+ * the alias identifier that {@code q} uses.\n+ *\n+ * Note that this level of indirection simplifies modifications of the graph e.g. as result of applied transformations\n+ * during the planning stage of a query.\n+ *\n+ * An object that is correlated to some other object can be _rebased_ by means of invoking {@link #rebase} using\n+ * a translation {@code id} to {@code id'}. The result of that invocation is a new object of type {@code S} that is\n+ * identical the original {@code this} except that all correlated references to {@code id} of the new object as well as\n+ * all objects {@code this} owns (i.e. other objects this object is composed of, e.g. children, etc.) now refer to a\n+ * new {@link CorrelationIdentifier} {@code id'}.\n+ *\n+ * Since translations are associative we allow to rebase many identifiers in the same {@link #rebase} invocation.\n+ *\n+ * As the planner DAG objects are immutable, a rebase operation can be expensive as objects have to be recreated\n+ * as needed. We follow the ideas of other persistent data structures as we do not require a copy to be made.\n+ * It is perfectly acceptable to return {@code this} as long as it can be proven that {@code this} is not correlated to\n+ * any identifier participating in the translation.\n+ *\n+ * This interface defines {@code equals()} using an equivalence map. Names are smoke and sound! Two sub-graphs\n+ * may be considered equal even though their used correlation identifiers are different:\n+ *\n+ * SELECT *\n+ * FROM T1 a, T2 b\n+ * WHERE a.x = b.y\n+ * UNION (SELECT *\n+ *        FROM T1 c, T2 d\n+ *        WHERE c.x = d.y)\n+ *\n+ * The two SELECT blocks should be considered equal even though they use different correlation names. The\n+ * {@link #resultEquals} introduced here considers these blocks equal using a bi-map that allows for the definition\n+ * of equivalences among correlation identifiers. In this case\n+ *\n+ * <pre>\n+ * {@code\n+ * (SELECT * FROM T1 a, T2 b WHERE a.x = b.y).equals(SELECT * FROM T1 c, T2 d WHERE c.x = d.y, ImmutableBiMap.of())\n+ * }\n+ * </pre>\n+ *\n+ * result (through a series of other steps) in an invocation of\n+ *\n+ * <pre>\n+ * {@code\n+ * (WHERE a.x = b.y).equals(WHERE c.x = d.y, ImmutableBiMap.of(a -> b, c -> d))\n+ * }\n+ * </pre>\n+ *\n+ * which then results in a {@code true} as {@code a} is considered to be equal to {@code c} and {@code b} is considered\n+ * to be equal to {@code d}.\n+ *\n+ * @param <S> self type of this. Needed for rebasing to a proper constrained at-least type\n+ */\n+public interface Correlated<S extends Correlated<S>> {\n+    /**\n+     * Determines the set of {@link CorrelationIdentifier}s this entity is correlated to, in a sense dependent upon.\n+     * This means that without a process that binds these correlations to values, the expression, either\n+     * a {@link RelationalExpression}, a {@link com.apple.foundationdb.record.query.RecordQuery} (or others that\n+     * implement this interface) cannot even conceptually produce a meaningful result. As often times entities that\n+     * implement this interface use composition and effectively describe trees or DAGs, this method should be the\n+     * set union of the {@link CorrelationIdentifier}s this object is correlated to as well as all children,\n+     * constituent parts, etc.\n+     * @return the set of {@link CorrelationIdentifier}s this entity is correlated to\n+     */\n+    @Nonnull\n+    Set<CorrelationIdentifier> getCorrelatedTo();\n+\n+    /**\n+     * Rebases this and all other objects this objects is composed of against a given translation map.\n+     * @param translationMap a map defining a translation from {@link CorrelationIdentifier}s {@code ids} to\n+     *        {@link CorrelationIdentifier}s {@code ids'}. After the rebase, every correlation to an {@code id}\n+     *        contained {@code ids} that is contained or referred to directly or indirectly by {@code this} must have\n+     *        been transformed to use the mapped counterpart of {@code id} {@code id'} in {@code ids'}. Ids not\n+     *        contained in the translation map must remain unmodified by the rebase operation.\n+     * @return a new entity that has been rebased\n+     */\n+    @Nonnull\n+    S rebase(Map<CorrelationIdentifier, CorrelationIdentifier> translationMap);\n+\n+    /**\n+     * Determine equality under the additional consideration of an equivalence map between {@link CorrelationIdentifier}s.\n+     * The contract of this variant of {@code equals()} differs from its regular Java counterpart.\n+     * A correlation is mostly just one part inside of composition of objects that expresses a more complicated\n+     * (correlated) structure, e.g. a filter. For instance {@code q1.x = 5} uses a correlation to {@code q1}.\n+     * That entity representing the filter is correlated to {@code q1} for obvious reasons. Also obvious is that\n+     * {@code q1.x = 6} is a different filter and should not be considered equal at all. The same is true if we\n+     * consider {@code q2.x = 5} (i.e. a filter where everything but the correlation is equal. Without further context\n+     * these two filters are not the same. However, the filters may be a part of some other entity that can express\n+     * correlations:\n+     * {@code SELECT * FROM T as q1 WHERE q1.x = 5} is equal to\n+     * {@code SELECT * FROM T as q2 WHERE q2.x = 5}. It does not matter that {@code q1} and {@code q2} are named\n+     * differently. It is important, however, that their semantic meaning is the same. In the example both {@code q1}\n+     * and {@code q2} refer to a table {@code T} which presumably is the same table. Therefore, these two query blocks", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6eb7142ab316ffbec53e375804118f722f1d2bcc"}, "originalPosition": 123}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgyMDg3MDIxOnYy", "diffSide": "RIGHT", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/Correlated.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOVQxOTowMjoxNFrOGveCMg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOVQxOTowMjoxNFrOGveCMg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjQyODMzOA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * ARE the same.\n          \n          \n            \n                 * <em>are</em> the same.", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/988#discussion_r452428338", "createdAt": "2020-07-09T19:02:14Z", "author": {"login": "nschiefer"}, "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/Correlated.java", "diffHunk": "@@ -0,0 +1,144 @@\n+/*\n+ * Correlated.java\n+ *\n+ * This source file is part of the FoundationDB open source project\n+ *\n+ * Copyright 2015-2020 Apple Inc. and the FoundationDB project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.apple.foundationdb.record.query.plan.temp;\n+\n+import com.google.common.collect.BiMap;\n+\n+import javax.annotation.Nonnull;\n+import java.util.Map;\n+import java.util.Set;\n+\n+/**\n+ * Interface for classes to implement entities which can be correlated to some other entity (usually a {@link Quantifier})\n+ * that is disambiguated by means of a {@link CorrelationIdentifier}. Objects of implementors of this class are said\n+ * to be correlated to a quantifier {@code q} if the identifiers returned by {@link #getCorrelatedTo()} set contain\n+ * the alias identifier that {@code q} uses.\n+ *\n+ * Note that this level of indirection simplifies modifications of the graph e.g. as result of applied transformations\n+ * during the planning stage of a query.\n+ *\n+ * An object that is correlated to some other object can be _rebased_ by means of invoking {@link #rebase} using\n+ * a translation {@code id} to {@code id'}. The result of that invocation is a new object of type {@code S} that is\n+ * identical the original {@code this} except that all correlated references to {@code id} of the new object as well as\n+ * all objects {@code this} owns (i.e. other objects this object is composed of, e.g. children, etc.) now refer to a\n+ * new {@link CorrelationIdentifier} {@code id'}.\n+ *\n+ * Since translations are associative we allow to rebase many identifiers in the same {@link #rebase} invocation.\n+ *\n+ * As the planner DAG objects are immutable, a rebase operation can be expensive as objects have to be recreated\n+ * as needed. We follow the ideas of other persistent data structures as we do not require a copy to be made.\n+ * It is perfectly acceptable to return {@code this} as long as it can be proven that {@code this} is not correlated to\n+ * any identifier participating in the translation.\n+ *\n+ * This interface defines {@code equals()} using an equivalence map. Names are smoke and sound! Two sub-graphs\n+ * may be considered equal even though their used correlation identifiers are different:\n+ *\n+ * SELECT *\n+ * FROM T1 a, T2 b\n+ * WHERE a.x = b.y\n+ * UNION (SELECT *\n+ *        FROM T1 c, T2 d\n+ *        WHERE c.x = d.y)\n+ *\n+ * The two SELECT blocks should be considered equal even though they use different correlation names. The\n+ * {@link #resultEquals} introduced here considers these blocks equal using a bi-map that allows for the definition\n+ * of equivalences among correlation identifiers. In this case\n+ *\n+ * <pre>\n+ * {@code\n+ * (SELECT * FROM T1 a, T2 b WHERE a.x = b.y).equals(SELECT * FROM T1 c, T2 d WHERE c.x = d.y, ImmutableBiMap.of())\n+ * }\n+ * </pre>\n+ *\n+ * result (through a series of other steps) in an invocation of\n+ *\n+ * <pre>\n+ * {@code\n+ * (WHERE a.x = b.y).equals(WHERE c.x = d.y, ImmutableBiMap.of(a -> b, c -> d))\n+ * }\n+ * </pre>\n+ *\n+ * which then results in a {@code true} as {@code a} is considered to be equal to {@code c} and {@code b} is considered\n+ * to be equal to {@code d}.\n+ *\n+ * @param <S> self type of this. Needed for rebasing to a proper constrained at-least type\n+ */\n+public interface Correlated<S extends Correlated<S>> {\n+    /**\n+     * Determines the set of {@link CorrelationIdentifier}s this entity is correlated to, in a sense dependent upon.\n+     * This means that without a process that binds these correlations to values, the expression, either\n+     * a {@link RelationalExpression}, a {@link com.apple.foundationdb.record.query.RecordQuery} (or others that\n+     * implement this interface) cannot even conceptually produce a meaningful result. As often times entities that\n+     * implement this interface use composition and effectively describe trees or DAGs, this method should be the\n+     * set union of the {@link CorrelationIdentifier}s this object is correlated to as well as all children,\n+     * constituent parts, etc.\n+     * @return the set of {@link CorrelationIdentifier}s this entity is correlated to\n+     */\n+    @Nonnull\n+    Set<CorrelationIdentifier> getCorrelatedTo();\n+\n+    /**\n+     * Rebases this and all other objects this objects is composed of against a given translation map.\n+     * @param translationMap a map defining a translation from {@link CorrelationIdentifier}s {@code ids} to\n+     *        {@link CorrelationIdentifier}s {@code ids'}. After the rebase, every correlation to an {@code id}\n+     *        contained {@code ids} that is contained or referred to directly or indirectly by {@code this} must have\n+     *        been transformed to use the mapped counterpart of {@code id} {@code id'} in {@code ids'}. Ids not\n+     *        contained in the translation map must remain unmodified by the rebase operation.\n+     * @return a new entity that has been rebased\n+     */\n+    @Nonnull\n+    S rebase(Map<CorrelationIdentifier, CorrelationIdentifier> translationMap);\n+\n+    /**\n+     * Determine equality under the additional consideration of an equivalence map between {@link CorrelationIdentifier}s.\n+     * The contract of this variant of {@code equals()} differs from its regular Java counterpart.\n+     * A correlation is mostly just one part inside of composition of objects that expresses a more complicated\n+     * (correlated) structure, e.g. a filter. For instance {@code q1.x = 5} uses a correlation to {@code q1}.\n+     * That entity representing the filter is correlated to {@code q1} for obvious reasons. Also obvious is that\n+     * {@code q1.x = 6} is a different filter and should not be considered equal at all. The same is true if we\n+     * consider {@code q2.x = 5} (i.e. a filter where everything but the correlation is equal. Without further context\n+     * these two filters are not the same. However, the filters may be a part of some other entity that can express\n+     * correlations:\n+     * {@code SELECT * FROM T as q1 WHERE q1.x = 5} is equal to\n+     * {@code SELECT * FROM T as q2 WHERE q2.x = 5}. It does not matter that {@code q1} and {@code q2} are named\n+     * differently. It is important, however, that their semantic meaning is the same. In the example both {@code q1}\n+     * and {@code q2} refer to a table {@code T} which presumably is the same table. Therefore, these two query blocks\n+     * ARE the same.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6eb7142ab316ffbec53e375804118f722f1d2bcc"}, "originalPosition": 124}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgyMDg3MTAyOnYy", "diffSide": "RIGHT", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/Correlated.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOVQxOTowMjozMVrOGveCtQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOVQxOTowMjozMVrOGveCtQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjQyODQ2OQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 *       method. As we can only ever establish tru equality using equivalence maps, {@code hashCode()}\n          \n          \n            \n                 *       method. As we can only ever establish true equality using equivalence maps, {@code hashCode()}", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/988#discussion_r452428469", "createdAt": "2020-07-09T19:02:31Z", "author": {"login": "nschiefer"}, "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/Correlated.java", "diffHunk": "@@ -0,0 +1,144 @@\n+/*\n+ * Correlated.java\n+ *\n+ * This source file is part of the FoundationDB open source project\n+ *\n+ * Copyright 2015-2020 Apple Inc. and the FoundationDB project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.apple.foundationdb.record.query.plan.temp;\n+\n+import com.google.common.collect.BiMap;\n+\n+import javax.annotation.Nonnull;\n+import java.util.Map;\n+import java.util.Set;\n+\n+/**\n+ * Interface for classes to implement entities which can be correlated to some other entity (usually a {@link Quantifier})\n+ * that is disambiguated by means of a {@link CorrelationIdentifier}. Objects of implementors of this class are said\n+ * to be correlated to a quantifier {@code q} if the identifiers returned by {@link #getCorrelatedTo()} set contain\n+ * the alias identifier that {@code q} uses.\n+ *\n+ * Note that this level of indirection simplifies modifications of the graph e.g. as result of applied transformations\n+ * during the planning stage of a query.\n+ *\n+ * An object that is correlated to some other object can be _rebased_ by means of invoking {@link #rebase} using\n+ * a translation {@code id} to {@code id'}. The result of that invocation is a new object of type {@code S} that is\n+ * identical the original {@code this} except that all correlated references to {@code id} of the new object as well as\n+ * all objects {@code this} owns (i.e. other objects this object is composed of, e.g. children, etc.) now refer to a\n+ * new {@link CorrelationIdentifier} {@code id'}.\n+ *\n+ * Since translations are associative we allow to rebase many identifiers in the same {@link #rebase} invocation.\n+ *\n+ * As the planner DAG objects are immutable, a rebase operation can be expensive as objects have to be recreated\n+ * as needed. We follow the ideas of other persistent data structures as we do not require a copy to be made.\n+ * It is perfectly acceptable to return {@code this} as long as it can be proven that {@code this} is not correlated to\n+ * any identifier participating in the translation.\n+ *\n+ * This interface defines {@code equals()} using an equivalence map. Names are smoke and sound! Two sub-graphs\n+ * may be considered equal even though their used correlation identifiers are different:\n+ *\n+ * SELECT *\n+ * FROM T1 a, T2 b\n+ * WHERE a.x = b.y\n+ * UNION (SELECT *\n+ *        FROM T1 c, T2 d\n+ *        WHERE c.x = d.y)\n+ *\n+ * The two SELECT blocks should be considered equal even though they use different correlation names. The\n+ * {@link #resultEquals} introduced here considers these blocks equal using a bi-map that allows for the definition\n+ * of equivalences among correlation identifiers. In this case\n+ *\n+ * <pre>\n+ * {@code\n+ * (SELECT * FROM T1 a, T2 b WHERE a.x = b.y).equals(SELECT * FROM T1 c, T2 d WHERE c.x = d.y, ImmutableBiMap.of())\n+ * }\n+ * </pre>\n+ *\n+ * result (through a series of other steps) in an invocation of\n+ *\n+ * <pre>\n+ * {@code\n+ * (WHERE a.x = b.y).equals(WHERE c.x = d.y, ImmutableBiMap.of(a -> b, c -> d))\n+ * }\n+ * </pre>\n+ *\n+ * which then results in a {@code true} as {@code a} is considered to be equal to {@code c} and {@code b} is considered\n+ * to be equal to {@code d}.\n+ *\n+ * @param <S> self type of this. Needed for rebasing to a proper constrained at-least type\n+ */\n+public interface Correlated<S extends Correlated<S>> {\n+    /**\n+     * Determines the set of {@link CorrelationIdentifier}s this entity is correlated to, in a sense dependent upon.\n+     * This means that without a process that binds these correlations to values, the expression, either\n+     * a {@link RelationalExpression}, a {@link com.apple.foundationdb.record.query.RecordQuery} (or others that\n+     * implement this interface) cannot even conceptually produce a meaningful result. As often times entities that\n+     * implement this interface use composition and effectively describe trees or DAGs, this method should be the\n+     * set union of the {@link CorrelationIdentifier}s this object is correlated to as well as all children,\n+     * constituent parts, etc.\n+     * @return the set of {@link CorrelationIdentifier}s this entity is correlated to\n+     */\n+    @Nonnull\n+    Set<CorrelationIdentifier> getCorrelatedTo();\n+\n+    /**\n+     * Rebases this and all other objects this objects is composed of against a given translation map.\n+     * @param translationMap a map defining a translation from {@link CorrelationIdentifier}s {@code ids} to\n+     *        {@link CorrelationIdentifier}s {@code ids'}. After the rebase, every correlation to an {@code id}\n+     *        contained {@code ids} that is contained or referred to directly or indirectly by {@code this} must have\n+     *        been transformed to use the mapped counterpart of {@code id} {@code id'} in {@code ids'}. Ids not\n+     *        contained in the translation map must remain unmodified by the rebase operation.\n+     * @return a new entity that has been rebased\n+     */\n+    @Nonnull\n+    S rebase(Map<CorrelationIdentifier, CorrelationIdentifier> translationMap);\n+\n+    /**\n+     * Determine equality under the additional consideration of an equivalence map between {@link CorrelationIdentifier}s.\n+     * The contract of this variant of {@code equals()} differs from its regular Java counterpart.\n+     * A correlation is mostly just one part inside of composition of objects that expresses a more complicated\n+     * (correlated) structure, e.g. a filter. For instance {@code q1.x = 5} uses a correlation to {@code q1}.\n+     * That entity representing the filter is correlated to {@code q1} for obvious reasons. Also obvious is that\n+     * {@code q1.x = 6} is a different filter and should not be considered equal at all. The same is true if we\n+     * consider {@code q2.x = 5} (i.e. a filter where everything but the correlation is equal. Without further context\n+     * these two filters are not the same. However, the filters may be a part of some other entity that can express\n+     * correlations:\n+     * {@code SELECT * FROM T as q1 WHERE q1.x = 5} is equal to\n+     * {@code SELECT * FROM T as q2 WHERE q2.x = 5}. It does not matter that {@code q1} and {@code q2} are named\n+     * differently. It is important, however, that their semantic meaning is the same. In the example both {@code q1}\n+     * and {@code q2} refer to a table {@code T} which presumably is the same table. Therefore, these two query blocks\n+     * ARE the same.\n+     * In the context of this method, we can establish equality between {@code q1.x = 5} and {@code q2.x = 5} if\n+     * we know that {@code q1} and {@code q2} refer to the same underlying entity. The equivalence map passed in\n+     * encodes that equality between {@link CorrelationIdentifier}s.\n+     *\n+     * Note: This method has the same interaction with {@link Object#hashCode()} as the regular {@code equals()}\n+     *       method. As we can only ever establish tru equality using equivalence maps, {@code hashCode()}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6eb7142ab316ffbec53e375804118f722f1d2bcc"}, "originalPosition": 130}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgyMDg3MTY2OnYy", "diffSide": "RIGHT", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/Correlated.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOVQxOTowMjo0M1rOGveDHw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOVQxOTowMjo0M1rOGveDHw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjQyODU3NQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 *       implementations in implementors of this interface MUST NOT be dependent on any correlation identifiers\n          \n          \n            \n                 *       implementations in implementors of this interface <em>must not</em> be dependent on any correlation identifiers", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/988#discussion_r452428575", "createdAt": "2020-07-09T19:02:43Z", "author": {"login": "nschiefer"}, "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/Correlated.java", "diffHunk": "@@ -0,0 +1,144 @@\n+/*\n+ * Correlated.java\n+ *\n+ * This source file is part of the FoundationDB open source project\n+ *\n+ * Copyright 2015-2020 Apple Inc. and the FoundationDB project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.apple.foundationdb.record.query.plan.temp;\n+\n+import com.google.common.collect.BiMap;\n+\n+import javax.annotation.Nonnull;\n+import java.util.Map;\n+import java.util.Set;\n+\n+/**\n+ * Interface for classes to implement entities which can be correlated to some other entity (usually a {@link Quantifier})\n+ * that is disambiguated by means of a {@link CorrelationIdentifier}. Objects of implementors of this class are said\n+ * to be correlated to a quantifier {@code q} if the identifiers returned by {@link #getCorrelatedTo()} set contain\n+ * the alias identifier that {@code q} uses.\n+ *\n+ * Note that this level of indirection simplifies modifications of the graph e.g. as result of applied transformations\n+ * during the planning stage of a query.\n+ *\n+ * An object that is correlated to some other object can be _rebased_ by means of invoking {@link #rebase} using\n+ * a translation {@code id} to {@code id'}. The result of that invocation is a new object of type {@code S} that is\n+ * identical the original {@code this} except that all correlated references to {@code id} of the new object as well as\n+ * all objects {@code this} owns (i.e. other objects this object is composed of, e.g. children, etc.) now refer to a\n+ * new {@link CorrelationIdentifier} {@code id'}.\n+ *\n+ * Since translations are associative we allow to rebase many identifiers in the same {@link #rebase} invocation.\n+ *\n+ * As the planner DAG objects are immutable, a rebase operation can be expensive as objects have to be recreated\n+ * as needed. We follow the ideas of other persistent data structures as we do not require a copy to be made.\n+ * It is perfectly acceptable to return {@code this} as long as it can be proven that {@code this} is not correlated to\n+ * any identifier participating in the translation.\n+ *\n+ * This interface defines {@code equals()} using an equivalence map. Names are smoke and sound! Two sub-graphs\n+ * may be considered equal even though their used correlation identifiers are different:\n+ *\n+ * SELECT *\n+ * FROM T1 a, T2 b\n+ * WHERE a.x = b.y\n+ * UNION (SELECT *\n+ *        FROM T1 c, T2 d\n+ *        WHERE c.x = d.y)\n+ *\n+ * The two SELECT blocks should be considered equal even though they use different correlation names. The\n+ * {@link #resultEquals} introduced here considers these blocks equal using a bi-map that allows for the definition\n+ * of equivalences among correlation identifiers. In this case\n+ *\n+ * <pre>\n+ * {@code\n+ * (SELECT * FROM T1 a, T2 b WHERE a.x = b.y).equals(SELECT * FROM T1 c, T2 d WHERE c.x = d.y, ImmutableBiMap.of())\n+ * }\n+ * </pre>\n+ *\n+ * result (through a series of other steps) in an invocation of\n+ *\n+ * <pre>\n+ * {@code\n+ * (WHERE a.x = b.y).equals(WHERE c.x = d.y, ImmutableBiMap.of(a -> b, c -> d))\n+ * }\n+ * </pre>\n+ *\n+ * which then results in a {@code true} as {@code a} is considered to be equal to {@code c} and {@code b} is considered\n+ * to be equal to {@code d}.\n+ *\n+ * @param <S> self type of this. Needed for rebasing to a proper constrained at-least type\n+ */\n+public interface Correlated<S extends Correlated<S>> {\n+    /**\n+     * Determines the set of {@link CorrelationIdentifier}s this entity is correlated to, in a sense dependent upon.\n+     * This means that without a process that binds these correlations to values, the expression, either\n+     * a {@link RelationalExpression}, a {@link com.apple.foundationdb.record.query.RecordQuery} (or others that\n+     * implement this interface) cannot even conceptually produce a meaningful result. As often times entities that\n+     * implement this interface use composition and effectively describe trees or DAGs, this method should be the\n+     * set union of the {@link CorrelationIdentifier}s this object is correlated to as well as all children,\n+     * constituent parts, etc.\n+     * @return the set of {@link CorrelationIdentifier}s this entity is correlated to\n+     */\n+    @Nonnull\n+    Set<CorrelationIdentifier> getCorrelatedTo();\n+\n+    /**\n+     * Rebases this and all other objects this objects is composed of against a given translation map.\n+     * @param translationMap a map defining a translation from {@link CorrelationIdentifier}s {@code ids} to\n+     *        {@link CorrelationIdentifier}s {@code ids'}. After the rebase, every correlation to an {@code id}\n+     *        contained {@code ids} that is contained or referred to directly or indirectly by {@code this} must have\n+     *        been transformed to use the mapped counterpart of {@code id} {@code id'} in {@code ids'}. Ids not\n+     *        contained in the translation map must remain unmodified by the rebase operation.\n+     * @return a new entity that has been rebased\n+     */\n+    @Nonnull\n+    S rebase(Map<CorrelationIdentifier, CorrelationIdentifier> translationMap);\n+\n+    /**\n+     * Determine equality under the additional consideration of an equivalence map between {@link CorrelationIdentifier}s.\n+     * The contract of this variant of {@code equals()} differs from its regular Java counterpart.\n+     * A correlation is mostly just one part inside of composition of objects that expresses a more complicated\n+     * (correlated) structure, e.g. a filter. For instance {@code q1.x = 5} uses a correlation to {@code q1}.\n+     * That entity representing the filter is correlated to {@code q1} for obvious reasons. Also obvious is that\n+     * {@code q1.x = 6} is a different filter and should not be considered equal at all. The same is true if we\n+     * consider {@code q2.x = 5} (i.e. a filter where everything but the correlation is equal. Without further context\n+     * these two filters are not the same. However, the filters may be a part of some other entity that can express\n+     * correlations:\n+     * {@code SELECT * FROM T as q1 WHERE q1.x = 5} is equal to\n+     * {@code SELECT * FROM T as q2 WHERE q2.x = 5}. It does not matter that {@code q1} and {@code q2} are named\n+     * differently. It is important, however, that their semantic meaning is the same. In the example both {@code q1}\n+     * and {@code q2} refer to a table {@code T} which presumably is the same table. Therefore, these two query blocks\n+     * ARE the same.\n+     * In the context of this method, we can establish equality between {@code q1.x = 5} and {@code q2.x = 5} if\n+     * we know that {@code q1} and {@code q2} refer to the same underlying entity. The equivalence map passed in\n+     * encodes that equality between {@link CorrelationIdentifier}s.\n+     *\n+     * Note: This method has the same interaction with {@link Object#hashCode()} as the regular {@code equals()}\n+     *       method. As we can only ever establish tru equality using equivalence maps, {@code hashCode()}\n+     *       implementations in implementors of this interface MUST NOT be dependent on any correlation identifiers", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6eb7142ab316ffbec53e375804118f722f1d2bcc"}, "originalPosition": 131}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgyMDg3MzA3OnYy", "diffSide": "RIGHT", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/Correlated.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOVQxOTowMzoxNFrOGveEAA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOVQxOTowMzoxNFrOGveEAA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjQyODgwMA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 *       used in the structure of the entity. Doing so might violate the fundamental assumption:\n          \n          \n            \n                 *       used in the structure of the entity. Doing so might violate the fundamental property of hash codes:", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/988#discussion_r452428800", "createdAt": "2020-07-09T19:03:14Z", "author": {"login": "nschiefer"}, "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/Correlated.java", "diffHunk": "@@ -0,0 +1,144 @@\n+/*\n+ * Correlated.java\n+ *\n+ * This source file is part of the FoundationDB open source project\n+ *\n+ * Copyright 2015-2020 Apple Inc. and the FoundationDB project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.apple.foundationdb.record.query.plan.temp;\n+\n+import com.google.common.collect.BiMap;\n+\n+import javax.annotation.Nonnull;\n+import java.util.Map;\n+import java.util.Set;\n+\n+/**\n+ * Interface for classes to implement entities which can be correlated to some other entity (usually a {@link Quantifier})\n+ * that is disambiguated by means of a {@link CorrelationIdentifier}. Objects of implementors of this class are said\n+ * to be correlated to a quantifier {@code q} if the identifiers returned by {@link #getCorrelatedTo()} set contain\n+ * the alias identifier that {@code q} uses.\n+ *\n+ * Note that this level of indirection simplifies modifications of the graph e.g. as result of applied transformations\n+ * during the planning stage of a query.\n+ *\n+ * An object that is correlated to some other object can be _rebased_ by means of invoking {@link #rebase} using\n+ * a translation {@code id} to {@code id'}. The result of that invocation is a new object of type {@code S} that is\n+ * identical the original {@code this} except that all correlated references to {@code id} of the new object as well as\n+ * all objects {@code this} owns (i.e. other objects this object is composed of, e.g. children, etc.) now refer to a\n+ * new {@link CorrelationIdentifier} {@code id'}.\n+ *\n+ * Since translations are associative we allow to rebase many identifiers in the same {@link #rebase} invocation.\n+ *\n+ * As the planner DAG objects are immutable, a rebase operation can be expensive as objects have to be recreated\n+ * as needed. We follow the ideas of other persistent data structures as we do not require a copy to be made.\n+ * It is perfectly acceptable to return {@code this} as long as it can be proven that {@code this} is not correlated to\n+ * any identifier participating in the translation.\n+ *\n+ * This interface defines {@code equals()} using an equivalence map. Names are smoke and sound! Two sub-graphs\n+ * may be considered equal even though their used correlation identifiers are different:\n+ *\n+ * SELECT *\n+ * FROM T1 a, T2 b\n+ * WHERE a.x = b.y\n+ * UNION (SELECT *\n+ *        FROM T1 c, T2 d\n+ *        WHERE c.x = d.y)\n+ *\n+ * The two SELECT blocks should be considered equal even though they use different correlation names. The\n+ * {@link #resultEquals} introduced here considers these blocks equal using a bi-map that allows for the definition\n+ * of equivalences among correlation identifiers. In this case\n+ *\n+ * <pre>\n+ * {@code\n+ * (SELECT * FROM T1 a, T2 b WHERE a.x = b.y).equals(SELECT * FROM T1 c, T2 d WHERE c.x = d.y, ImmutableBiMap.of())\n+ * }\n+ * </pre>\n+ *\n+ * result (through a series of other steps) in an invocation of\n+ *\n+ * <pre>\n+ * {@code\n+ * (WHERE a.x = b.y).equals(WHERE c.x = d.y, ImmutableBiMap.of(a -> b, c -> d))\n+ * }\n+ * </pre>\n+ *\n+ * which then results in a {@code true} as {@code a} is considered to be equal to {@code c} and {@code b} is considered\n+ * to be equal to {@code d}.\n+ *\n+ * @param <S> self type of this. Needed for rebasing to a proper constrained at-least type\n+ */\n+public interface Correlated<S extends Correlated<S>> {\n+    /**\n+     * Determines the set of {@link CorrelationIdentifier}s this entity is correlated to, in a sense dependent upon.\n+     * This means that without a process that binds these correlations to values, the expression, either\n+     * a {@link RelationalExpression}, a {@link com.apple.foundationdb.record.query.RecordQuery} (or others that\n+     * implement this interface) cannot even conceptually produce a meaningful result. As often times entities that\n+     * implement this interface use composition and effectively describe trees or DAGs, this method should be the\n+     * set union of the {@link CorrelationIdentifier}s this object is correlated to as well as all children,\n+     * constituent parts, etc.\n+     * @return the set of {@link CorrelationIdentifier}s this entity is correlated to\n+     */\n+    @Nonnull\n+    Set<CorrelationIdentifier> getCorrelatedTo();\n+\n+    /**\n+     * Rebases this and all other objects this objects is composed of against a given translation map.\n+     * @param translationMap a map defining a translation from {@link CorrelationIdentifier}s {@code ids} to\n+     *        {@link CorrelationIdentifier}s {@code ids'}. After the rebase, every correlation to an {@code id}\n+     *        contained {@code ids} that is contained or referred to directly or indirectly by {@code this} must have\n+     *        been transformed to use the mapped counterpart of {@code id} {@code id'} in {@code ids'}. Ids not\n+     *        contained in the translation map must remain unmodified by the rebase operation.\n+     * @return a new entity that has been rebased\n+     */\n+    @Nonnull\n+    S rebase(Map<CorrelationIdentifier, CorrelationIdentifier> translationMap);\n+\n+    /**\n+     * Determine equality under the additional consideration of an equivalence map between {@link CorrelationIdentifier}s.\n+     * The contract of this variant of {@code equals()} differs from its regular Java counterpart.\n+     * A correlation is mostly just one part inside of composition of objects that expresses a more complicated\n+     * (correlated) structure, e.g. a filter. For instance {@code q1.x = 5} uses a correlation to {@code q1}.\n+     * That entity representing the filter is correlated to {@code q1} for obvious reasons. Also obvious is that\n+     * {@code q1.x = 6} is a different filter and should not be considered equal at all. The same is true if we\n+     * consider {@code q2.x = 5} (i.e. a filter where everything but the correlation is equal. Without further context\n+     * these two filters are not the same. However, the filters may be a part of some other entity that can express\n+     * correlations:\n+     * {@code SELECT * FROM T as q1 WHERE q1.x = 5} is equal to\n+     * {@code SELECT * FROM T as q2 WHERE q2.x = 5}. It does not matter that {@code q1} and {@code q2} are named\n+     * differently. It is important, however, that their semantic meaning is the same. In the example both {@code q1}\n+     * and {@code q2} refer to a table {@code T} which presumably is the same table. Therefore, these two query blocks\n+     * ARE the same.\n+     * In the context of this method, we can establish equality between {@code q1.x = 5} and {@code q2.x = 5} if\n+     * we know that {@code q1} and {@code q2} refer to the same underlying entity. The equivalence map passed in\n+     * encodes that equality between {@link CorrelationIdentifier}s.\n+     *\n+     * Note: This method has the same interaction with {@link Object#hashCode()} as the regular {@code equals()}\n+     *       method. As we can only ever establish tru equality using equivalence maps, {@code hashCode()}\n+     *       implementations in implementors of this interface MUST NOT be dependent on any correlation identifiers\n+     *       used in the structure of the entity. Doing so might violate the fundamental assumption:", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6eb7142ab316ffbec53e375804118f722f1d2bcc"}, "originalPosition": 132}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgyMDg3NDA4OnYy", "diffSide": "RIGHT", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/Correlated.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOVQxOTowMzozOVrOGveEuA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOVQxOTowMzozOVrOGveEuA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjQyODk4NA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 *        {@code id'} used in {@code other} if either they are the same by regular java {@link Object#equals}\n          \n          \n            \n                 *        {@code id'} used in {@code other} if either they are the same by {@link Object#equals}", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/988#discussion_r452428984", "createdAt": "2020-07-09T19:03:39Z", "author": {"login": "nschiefer"}, "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/Correlated.java", "diffHunk": "@@ -0,0 +1,144 @@\n+/*\n+ * Correlated.java\n+ *\n+ * This source file is part of the FoundationDB open source project\n+ *\n+ * Copyright 2015-2020 Apple Inc. and the FoundationDB project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.apple.foundationdb.record.query.plan.temp;\n+\n+import com.google.common.collect.BiMap;\n+\n+import javax.annotation.Nonnull;\n+import java.util.Map;\n+import java.util.Set;\n+\n+/**\n+ * Interface for classes to implement entities which can be correlated to some other entity (usually a {@link Quantifier})\n+ * that is disambiguated by means of a {@link CorrelationIdentifier}. Objects of implementors of this class are said\n+ * to be correlated to a quantifier {@code q} if the identifiers returned by {@link #getCorrelatedTo()} set contain\n+ * the alias identifier that {@code q} uses.\n+ *\n+ * Note that this level of indirection simplifies modifications of the graph e.g. as result of applied transformations\n+ * during the planning stage of a query.\n+ *\n+ * An object that is correlated to some other object can be _rebased_ by means of invoking {@link #rebase} using\n+ * a translation {@code id} to {@code id'}. The result of that invocation is a new object of type {@code S} that is\n+ * identical the original {@code this} except that all correlated references to {@code id} of the new object as well as\n+ * all objects {@code this} owns (i.e. other objects this object is composed of, e.g. children, etc.) now refer to a\n+ * new {@link CorrelationIdentifier} {@code id'}.\n+ *\n+ * Since translations are associative we allow to rebase many identifiers in the same {@link #rebase} invocation.\n+ *\n+ * As the planner DAG objects are immutable, a rebase operation can be expensive as objects have to be recreated\n+ * as needed. We follow the ideas of other persistent data structures as we do not require a copy to be made.\n+ * It is perfectly acceptable to return {@code this} as long as it can be proven that {@code this} is not correlated to\n+ * any identifier participating in the translation.\n+ *\n+ * This interface defines {@code equals()} using an equivalence map. Names are smoke and sound! Two sub-graphs\n+ * may be considered equal even though their used correlation identifiers are different:\n+ *\n+ * SELECT *\n+ * FROM T1 a, T2 b\n+ * WHERE a.x = b.y\n+ * UNION (SELECT *\n+ *        FROM T1 c, T2 d\n+ *        WHERE c.x = d.y)\n+ *\n+ * The two SELECT blocks should be considered equal even though they use different correlation names. The\n+ * {@link #resultEquals} introduced here considers these blocks equal using a bi-map that allows for the definition\n+ * of equivalences among correlation identifiers. In this case\n+ *\n+ * <pre>\n+ * {@code\n+ * (SELECT * FROM T1 a, T2 b WHERE a.x = b.y).equals(SELECT * FROM T1 c, T2 d WHERE c.x = d.y, ImmutableBiMap.of())\n+ * }\n+ * </pre>\n+ *\n+ * result (through a series of other steps) in an invocation of\n+ *\n+ * <pre>\n+ * {@code\n+ * (WHERE a.x = b.y).equals(WHERE c.x = d.y, ImmutableBiMap.of(a -> b, c -> d))\n+ * }\n+ * </pre>\n+ *\n+ * which then results in a {@code true} as {@code a} is considered to be equal to {@code c} and {@code b} is considered\n+ * to be equal to {@code d}.\n+ *\n+ * @param <S> self type of this. Needed for rebasing to a proper constrained at-least type\n+ */\n+public interface Correlated<S extends Correlated<S>> {\n+    /**\n+     * Determines the set of {@link CorrelationIdentifier}s this entity is correlated to, in a sense dependent upon.\n+     * This means that without a process that binds these correlations to values, the expression, either\n+     * a {@link RelationalExpression}, a {@link com.apple.foundationdb.record.query.RecordQuery} (or others that\n+     * implement this interface) cannot even conceptually produce a meaningful result. As often times entities that\n+     * implement this interface use composition and effectively describe trees or DAGs, this method should be the\n+     * set union of the {@link CorrelationIdentifier}s this object is correlated to as well as all children,\n+     * constituent parts, etc.\n+     * @return the set of {@link CorrelationIdentifier}s this entity is correlated to\n+     */\n+    @Nonnull\n+    Set<CorrelationIdentifier> getCorrelatedTo();\n+\n+    /**\n+     * Rebases this and all other objects this objects is composed of against a given translation map.\n+     * @param translationMap a map defining a translation from {@link CorrelationIdentifier}s {@code ids} to\n+     *        {@link CorrelationIdentifier}s {@code ids'}. After the rebase, every correlation to an {@code id}\n+     *        contained {@code ids} that is contained or referred to directly or indirectly by {@code this} must have\n+     *        been transformed to use the mapped counterpart of {@code id} {@code id'} in {@code ids'}. Ids not\n+     *        contained in the translation map must remain unmodified by the rebase operation.\n+     * @return a new entity that has been rebased\n+     */\n+    @Nonnull\n+    S rebase(Map<CorrelationIdentifier, CorrelationIdentifier> translationMap);\n+\n+    /**\n+     * Determine equality under the additional consideration of an equivalence map between {@link CorrelationIdentifier}s.\n+     * The contract of this variant of {@code equals()} differs from its regular Java counterpart.\n+     * A correlation is mostly just one part inside of composition of objects that expresses a more complicated\n+     * (correlated) structure, e.g. a filter. For instance {@code q1.x = 5} uses a correlation to {@code q1}.\n+     * That entity representing the filter is correlated to {@code q1} for obvious reasons. Also obvious is that\n+     * {@code q1.x = 6} is a different filter and should not be considered equal at all. The same is true if we\n+     * consider {@code q2.x = 5} (i.e. a filter where everything but the correlation is equal. Without further context\n+     * these two filters are not the same. However, the filters may be a part of some other entity that can express\n+     * correlations:\n+     * {@code SELECT * FROM T as q1 WHERE q1.x = 5} is equal to\n+     * {@code SELECT * FROM T as q2 WHERE q2.x = 5}. It does not matter that {@code q1} and {@code q2} are named\n+     * differently. It is important, however, that their semantic meaning is the same. In the example both {@code q1}\n+     * and {@code q2} refer to a table {@code T} which presumably is the same table. Therefore, these two query blocks\n+     * ARE the same.\n+     * In the context of this method, we can establish equality between {@code q1.x = 5} and {@code q2.x = 5} if\n+     * we know that {@code q1} and {@code q2} refer to the same underlying entity. The equivalence map passed in\n+     * encodes that equality between {@link CorrelationIdentifier}s.\n+     *\n+     * Note: This method has the same interaction with {@link Object#hashCode()} as the regular {@code equals()}\n+     *       method. As we can only ever establish tru equality using equivalence maps, {@code hashCode()}\n+     *       implementations in implementors of this interface MUST NOT be dependent on any correlation identifiers\n+     *       used in the structure of the entity. Doing so might violate the fundamental assumption:\n+     *       {@code e1.equals(e2, ...) => e1.hashCode() == e2.hashCode()}\n+     *\n+     * @param other the other object to establish equality with\n+     * @param equivalenceMap a map of {@link CorrelationIdentifier}s {@code ids} to {@code ids'}. A correlation\n+     *        identifier {@code id} used in {@code this} should be considered equal to another correlation identifier\n+     *        {@code id'} used in {@code other} if either they are the same by regular java {@link Object#equals}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6eb7142ab316ffbec53e375804118f722f1d2bcc"}, "originalPosition": 138}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgyMDg3NDg1OnYy", "diffSide": "RIGHT", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/Correlated.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOVQxOTowMzo1NVrOGveFQw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMFQxNjo0Njo0MFrOG0Wrjg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjQyOTEyMw==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                boolean resultEquals(Object other, BiMap<CorrelationIdentifier, CorrelationIdentifier> equivalenceMap);\n          \n          \n            \n                boolean resultEquals(@Nullable Object other, @Nonnull BiMap<CorrelationIdentifier, CorrelationIdentifier> equivalenceMap);", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/988#discussion_r452429123", "createdAt": "2020-07-09T19:03:55Z", "author": {"login": "nschiefer"}, "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/Correlated.java", "diffHunk": "@@ -0,0 +1,144 @@\n+/*\n+ * Correlated.java\n+ *\n+ * This source file is part of the FoundationDB open source project\n+ *\n+ * Copyright 2015-2020 Apple Inc. and the FoundationDB project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.apple.foundationdb.record.query.plan.temp;\n+\n+import com.google.common.collect.BiMap;\n+\n+import javax.annotation.Nonnull;\n+import java.util.Map;\n+import java.util.Set;\n+\n+/**\n+ * Interface for classes to implement entities which can be correlated to some other entity (usually a {@link Quantifier})\n+ * that is disambiguated by means of a {@link CorrelationIdentifier}. Objects of implementors of this class are said\n+ * to be correlated to a quantifier {@code q} if the identifiers returned by {@link #getCorrelatedTo()} set contain\n+ * the alias identifier that {@code q} uses.\n+ *\n+ * Note that this level of indirection simplifies modifications of the graph e.g. as result of applied transformations\n+ * during the planning stage of a query.\n+ *\n+ * An object that is correlated to some other object can be _rebased_ by means of invoking {@link #rebase} using\n+ * a translation {@code id} to {@code id'}. The result of that invocation is a new object of type {@code S} that is\n+ * identical the original {@code this} except that all correlated references to {@code id} of the new object as well as\n+ * all objects {@code this} owns (i.e. other objects this object is composed of, e.g. children, etc.) now refer to a\n+ * new {@link CorrelationIdentifier} {@code id'}.\n+ *\n+ * Since translations are associative we allow to rebase many identifiers in the same {@link #rebase} invocation.\n+ *\n+ * As the planner DAG objects are immutable, a rebase operation can be expensive as objects have to be recreated\n+ * as needed. We follow the ideas of other persistent data structures as we do not require a copy to be made.\n+ * It is perfectly acceptable to return {@code this} as long as it can be proven that {@code this} is not correlated to\n+ * any identifier participating in the translation.\n+ *\n+ * This interface defines {@code equals()} using an equivalence map. Names are smoke and sound! Two sub-graphs\n+ * may be considered equal even though their used correlation identifiers are different:\n+ *\n+ * SELECT *\n+ * FROM T1 a, T2 b\n+ * WHERE a.x = b.y\n+ * UNION (SELECT *\n+ *        FROM T1 c, T2 d\n+ *        WHERE c.x = d.y)\n+ *\n+ * The two SELECT blocks should be considered equal even though they use different correlation names. The\n+ * {@link #resultEquals} introduced here considers these blocks equal using a bi-map that allows for the definition\n+ * of equivalences among correlation identifiers. In this case\n+ *\n+ * <pre>\n+ * {@code\n+ * (SELECT * FROM T1 a, T2 b WHERE a.x = b.y).equals(SELECT * FROM T1 c, T2 d WHERE c.x = d.y, ImmutableBiMap.of())\n+ * }\n+ * </pre>\n+ *\n+ * result (through a series of other steps) in an invocation of\n+ *\n+ * <pre>\n+ * {@code\n+ * (WHERE a.x = b.y).equals(WHERE c.x = d.y, ImmutableBiMap.of(a -> b, c -> d))\n+ * }\n+ * </pre>\n+ *\n+ * which then results in a {@code true} as {@code a} is considered to be equal to {@code c} and {@code b} is considered\n+ * to be equal to {@code d}.\n+ *\n+ * @param <S> self type of this. Needed for rebasing to a proper constrained at-least type\n+ */\n+public interface Correlated<S extends Correlated<S>> {\n+    /**\n+     * Determines the set of {@link CorrelationIdentifier}s this entity is correlated to, in a sense dependent upon.\n+     * This means that without a process that binds these correlations to values, the expression, either\n+     * a {@link RelationalExpression}, a {@link com.apple.foundationdb.record.query.RecordQuery} (or others that\n+     * implement this interface) cannot even conceptually produce a meaningful result. As often times entities that\n+     * implement this interface use composition and effectively describe trees or DAGs, this method should be the\n+     * set union of the {@link CorrelationIdentifier}s this object is correlated to as well as all children,\n+     * constituent parts, etc.\n+     * @return the set of {@link CorrelationIdentifier}s this entity is correlated to\n+     */\n+    @Nonnull\n+    Set<CorrelationIdentifier> getCorrelatedTo();\n+\n+    /**\n+     * Rebases this and all other objects this objects is composed of against a given translation map.\n+     * @param translationMap a map defining a translation from {@link CorrelationIdentifier}s {@code ids} to\n+     *        {@link CorrelationIdentifier}s {@code ids'}. After the rebase, every correlation to an {@code id}\n+     *        contained {@code ids} that is contained or referred to directly or indirectly by {@code this} must have\n+     *        been transformed to use the mapped counterpart of {@code id} {@code id'} in {@code ids'}. Ids not\n+     *        contained in the translation map must remain unmodified by the rebase operation.\n+     * @return a new entity that has been rebased\n+     */\n+    @Nonnull\n+    S rebase(Map<CorrelationIdentifier, CorrelationIdentifier> translationMap);\n+\n+    /**\n+     * Determine equality under the additional consideration of an equivalence map between {@link CorrelationIdentifier}s.\n+     * The contract of this variant of {@code equals()} differs from its regular Java counterpart.\n+     * A correlation is mostly just one part inside of composition of objects that expresses a more complicated\n+     * (correlated) structure, e.g. a filter. For instance {@code q1.x = 5} uses a correlation to {@code q1}.\n+     * That entity representing the filter is correlated to {@code q1} for obvious reasons. Also obvious is that\n+     * {@code q1.x = 6} is a different filter and should not be considered equal at all. The same is true if we\n+     * consider {@code q2.x = 5} (i.e. a filter where everything but the correlation is equal. Without further context\n+     * these two filters are not the same. However, the filters may be a part of some other entity that can express\n+     * correlations:\n+     * {@code SELECT * FROM T as q1 WHERE q1.x = 5} is equal to\n+     * {@code SELECT * FROM T as q2 WHERE q2.x = 5}. It does not matter that {@code q1} and {@code q2} are named\n+     * differently. It is important, however, that their semantic meaning is the same. In the example both {@code q1}\n+     * and {@code q2} refer to a table {@code T} which presumably is the same table. Therefore, these two query blocks\n+     * ARE the same.\n+     * In the context of this method, we can establish equality between {@code q1.x = 5} and {@code q2.x = 5} if\n+     * we know that {@code q1} and {@code q2} refer to the same underlying entity. The equivalence map passed in\n+     * encodes that equality between {@link CorrelationIdentifier}s.\n+     *\n+     * Note: This method has the same interaction with {@link Object#hashCode()} as the regular {@code equals()}\n+     *       method. As we can only ever establish tru equality using equivalence maps, {@code hashCode()}\n+     *       implementations in implementors of this interface MUST NOT be dependent on any correlation identifiers\n+     *       used in the structure of the entity. Doing so might violate the fundamental assumption:\n+     *       {@code e1.equals(e2, ...) => e1.hashCode() == e2.hashCode()}\n+     *\n+     * @param other the other object to establish equality with\n+     * @param equivalenceMap a map of {@link CorrelationIdentifier}s {@code ids} to {@code ids'}. A correlation\n+     *        identifier {@code id} used in {@code this} should be considered equal to another correlation identifier\n+     *        {@code id'} used in {@code other} if either they are the same by regular java {@link Object#equals}\n+     *        of if there is a mapping from {@code id} to {@code id'}.\n+     * @return {@code true} if both entities are considered equal using the equivalences passed in, {@code false}\n+     *         otherwise\n+     */\n+    boolean resultEquals(Object other, BiMap<CorrelationIdentifier, CorrelationIdentifier> equivalenceMap);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6eb7142ab316ffbec53e375804118f722f1d2bcc"}, "originalPosition": 143}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mzk3NzczOQ==", "bodyText": "I think it would be nice to wrap up these maps/bimaps into some kind of custom helper object (which can of course be backed by a Guava bimap). It should make a lot of these signatures a lot clearer, at least if it was given a good name (CorrelationTranslationMap?).", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/988#discussion_r453977739", "createdAt": "2020-07-13T22:23:51Z", "author": {"login": "nschiefer"}, "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/Correlated.java", "diffHunk": "@@ -0,0 +1,144 @@\n+/*\n+ * Correlated.java\n+ *\n+ * This source file is part of the FoundationDB open source project\n+ *\n+ * Copyright 2015-2020 Apple Inc. and the FoundationDB project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.apple.foundationdb.record.query.plan.temp;\n+\n+import com.google.common.collect.BiMap;\n+\n+import javax.annotation.Nonnull;\n+import java.util.Map;\n+import java.util.Set;\n+\n+/**\n+ * Interface for classes to implement entities which can be correlated to some other entity (usually a {@link Quantifier})\n+ * that is disambiguated by means of a {@link CorrelationIdentifier}. Objects of implementors of this class are said\n+ * to be correlated to a quantifier {@code q} if the identifiers returned by {@link #getCorrelatedTo()} set contain\n+ * the alias identifier that {@code q} uses.\n+ *\n+ * Note that this level of indirection simplifies modifications of the graph e.g. as result of applied transformations\n+ * during the planning stage of a query.\n+ *\n+ * An object that is correlated to some other object can be _rebased_ by means of invoking {@link #rebase} using\n+ * a translation {@code id} to {@code id'}. The result of that invocation is a new object of type {@code S} that is\n+ * identical the original {@code this} except that all correlated references to {@code id} of the new object as well as\n+ * all objects {@code this} owns (i.e. other objects this object is composed of, e.g. children, etc.) now refer to a\n+ * new {@link CorrelationIdentifier} {@code id'}.\n+ *\n+ * Since translations are associative we allow to rebase many identifiers in the same {@link #rebase} invocation.\n+ *\n+ * As the planner DAG objects are immutable, a rebase operation can be expensive as objects have to be recreated\n+ * as needed. We follow the ideas of other persistent data structures as we do not require a copy to be made.\n+ * It is perfectly acceptable to return {@code this} as long as it can be proven that {@code this} is not correlated to\n+ * any identifier participating in the translation.\n+ *\n+ * This interface defines {@code equals()} using an equivalence map. Names are smoke and sound! Two sub-graphs\n+ * may be considered equal even though their used correlation identifiers are different:\n+ *\n+ * SELECT *\n+ * FROM T1 a, T2 b\n+ * WHERE a.x = b.y\n+ * UNION (SELECT *\n+ *        FROM T1 c, T2 d\n+ *        WHERE c.x = d.y)\n+ *\n+ * The two SELECT blocks should be considered equal even though they use different correlation names. The\n+ * {@link #resultEquals} introduced here considers these blocks equal using a bi-map that allows for the definition\n+ * of equivalences among correlation identifiers. In this case\n+ *\n+ * <pre>\n+ * {@code\n+ * (SELECT * FROM T1 a, T2 b WHERE a.x = b.y).equals(SELECT * FROM T1 c, T2 d WHERE c.x = d.y, ImmutableBiMap.of())\n+ * }\n+ * </pre>\n+ *\n+ * result (through a series of other steps) in an invocation of\n+ *\n+ * <pre>\n+ * {@code\n+ * (WHERE a.x = b.y).equals(WHERE c.x = d.y, ImmutableBiMap.of(a -> b, c -> d))\n+ * }\n+ * </pre>\n+ *\n+ * which then results in a {@code true} as {@code a} is considered to be equal to {@code c} and {@code b} is considered\n+ * to be equal to {@code d}.\n+ *\n+ * @param <S> self type of this. Needed for rebasing to a proper constrained at-least type\n+ */\n+public interface Correlated<S extends Correlated<S>> {\n+    /**\n+     * Determines the set of {@link CorrelationIdentifier}s this entity is correlated to, in a sense dependent upon.\n+     * This means that without a process that binds these correlations to values, the expression, either\n+     * a {@link RelationalExpression}, a {@link com.apple.foundationdb.record.query.RecordQuery} (or others that\n+     * implement this interface) cannot even conceptually produce a meaningful result. As often times entities that\n+     * implement this interface use composition and effectively describe trees or DAGs, this method should be the\n+     * set union of the {@link CorrelationIdentifier}s this object is correlated to as well as all children,\n+     * constituent parts, etc.\n+     * @return the set of {@link CorrelationIdentifier}s this entity is correlated to\n+     */\n+    @Nonnull\n+    Set<CorrelationIdentifier> getCorrelatedTo();\n+\n+    /**\n+     * Rebases this and all other objects this objects is composed of against a given translation map.\n+     * @param translationMap a map defining a translation from {@link CorrelationIdentifier}s {@code ids} to\n+     *        {@link CorrelationIdentifier}s {@code ids'}. After the rebase, every correlation to an {@code id}\n+     *        contained {@code ids} that is contained or referred to directly or indirectly by {@code this} must have\n+     *        been transformed to use the mapped counterpart of {@code id} {@code id'} in {@code ids'}. Ids not\n+     *        contained in the translation map must remain unmodified by the rebase operation.\n+     * @return a new entity that has been rebased\n+     */\n+    @Nonnull\n+    S rebase(Map<CorrelationIdentifier, CorrelationIdentifier> translationMap);\n+\n+    /**\n+     * Determine equality under the additional consideration of an equivalence map between {@link CorrelationIdentifier}s.\n+     * The contract of this variant of {@code equals()} differs from its regular Java counterpart.\n+     * A correlation is mostly just one part inside of composition of objects that expresses a more complicated\n+     * (correlated) structure, e.g. a filter. For instance {@code q1.x = 5} uses a correlation to {@code q1}.\n+     * That entity representing the filter is correlated to {@code q1} for obvious reasons. Also obvious is that\n+     * {@code q1.x = 6} is a different filter and should not be considered equal at all. The same is true if we\n+     * consider {@code q2.x = 5} (i.e. a filter where everything but the correlation is equal. Without further context\n+     * these two filters are not the same. However, the filters may be a part of some other entity that can express\n+     * correlations:\n+     * {@code SELECT * FROM T as q1 WHERE q1.x = 5} is equal to\n+     * {@code SELECT * FROM T as q2 WHERE q2.x = 5}. It does not matter that {@code q1} and {@code q2} are named\n+     * differently. It is important, however, that their semantic meaning is the same. In the example both {@code q1}\n+     * and {@code q2} refer to a table {@code T} which presumably is the same table. Therefore, these two query blocks\n+     * ARE the same.\n+     * In the context of this method, we can establish equality between {@code q1.x = 5} and {@code q2.x = 5} if\n+     * we know that {@code q1} and {@code q2} refer to the same underlying entity. The equivalence map passed in\n+     * encodes that equality between {@link CorrelationIdentifier}s.\n+     *\n+     * Note: This method has the same interaction with {@link Object#hashCode()} as the regular {@code equals()}\n+     *       method. As we can only ever establish tru equality using equivalence maps, {@code hashCode()}\n+     *       implementations in implementors of this interface MUST NOT be dependent on any correlation identifiers\n+     *       used in the structure of the entity. Doing so might violate the fundamental assumption:\n+     *       {@code e1.equals(e2, ...) => e1.hashCode() == e2.hashCode()}\n+     *\n+     * @param other the other object to establish equality with\n+     * @param equivalenceMap a map of {@link CorrelationIdentifier}s {@code ids} to {@code ids'}. A correlation\n+     *        identifier {@code id} used in {@code this} should be considered equal to another correlation identifier\n+     *        {@code id'} used in {@code other} if either they are the same by regular java {@link Object#equals}\n+     *        of if there is a mapping from {@code id} to {@code id'}.\n+     * @return {@code true} if both entities are considered equal using the equivalences passed in, {@code false}\n+     *         otherwise\n+     */\n+    boolean resultEquals(Object other, BiMap<CorrelationIdentifier, CorrelationIdentifier> equivalenceMap);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjQyOTEyMw=="}, "originalCommit": {"oid": "6eb7142ab316ffbec53e375804118f722f1d2bcc"}, "originalPosition": 143}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzU1MDczNA==", "bodyText": "Done.", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/988#discussion_r457550734", "createdAt": "2020-07-20T16:46:40Z", "author": {"login": "normen662"}, "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/Correlated.java", "diffHunk": "@@ -0,0 +1,144 @@\n+/*\n+ * Correlated.java\n+ *\n+ * This source file is part of the FoundationDB open source project\n+ *\n+ * Copyright 2015-2020 Apple Inc. and the FoundationDB project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.apple.foundationdb.record.query.plan.temp;\n+\n+import com.google.common.collect.BiMap;\n+\n+import javax.annotation.Nonnull;\n+import java.util.Map;\n+import java.util.Set;\n+\n+/**\n+ * Interface for classes to implement entities which can be correlated to some other entity (usually a {@link Quantifier})\n+ * that is disambiguated by means of a {@link CorrelationIdentifier}. Objects of implementors of this class are said\n+ * to be correlated to a quantifier {@code q} if the identifiers returned by {@link #getCorrelatedTo()} set contain\n+ * the alias identifier that {@code q} uses.\n+ *\n+ * Note that this level of indirection simplifies modifications of the graph e.g. as result of applied transformations\n+ * during the planning stage of a query.\n+ *\n+ * An object that is correlated to some other object can be _rebased_ by means of invoking {@link #rebase} using\n+ * a translation {@code id} to {@code id'}. The result of that invocation is a new object of type {@code S} that is\n+ * identical the original {@code this} except that all correlated references to {@code id} of the new object as well as\n+ * all objects {@code this} owns (i.e. other objects this object is composed of, e.g. children, etc.) now refer to a\n+ * new {@link CorrelationIdentifier} {@code id'}.\n+ *\n+ * Since translations are associative we allow to rebase many identifiers in the same {@link #rebase} invocation.\n+ *\n+ * As the planner DAG objects are immutable, a rebase operation can be expensive as objects have to be recreated\n+ * as needed. We follow the ideas of other persistent data structures as we do not require a copy to be made.\n+ * It is perfectly acceptable to return {@code this} as long as it can be proven that {@code this} is not correlated to\n+ * any identifier participating in the translation.\n+ *\n+ * This interface defines {@code equals()} using an equivalence map. Names are smoke and sound! Two sub-graphs\n+ * may be considered equal even though their used correlation identifiers are different:\n+ *\n+ * SELECT *\n+ * FROM T1 a, T2 b\n+ * WHERE a.x = b.y\n+ * UNION (SELECT *\n+ *        FROM T1 c, T2 d\n+ *        WHERE c.x = d.y)\n+ *\n+ * The two SELECT blocks should be considered equal even though they use different correlation names. The\n+ * {@link #resultEquals} introduced here considers these blocks equal using a bi-map that allows for the definition\n+ * of equivalences among correlation identifiers. In this case\n+ *\n+ * <pre>\n+ * {@code\n+ * (SELECT * FROM T1 a, T2 b WHERE a.x = b.y).equals(SELECT * FROM T1 c, T2 d WHERE c.x = d.y, ImmutableBiMap.of())\n+ * }\n+ * </pre>\n+ *\n+ * result (through a series of other steps) in an invocation of\n+ *\n+ * <pre>\n+ * {@code\n+ * (WHERE a.x = b.y).equals(WHERE c.x = d.y, ImmutableBiMap.of(a -> b, c -> d))\n+ * }\n+ * </pre>\n+ *\n+ * which then results in a {@code true} as {@code a} is considered to be equal to {@code c} and {@code b} is considered\n+ * to be equal to {@code d}.\n+ *\n+ * @param <S> self type of this. Needed for rebasing to a proper constrained at-least type\n+ */\n+public interface Correlated<S extends Correlated<S>> {\n+    /**\n+     * Determines the set of {@link CorrelationIdentifier}s this entity is correlated to, in a sense dependent upon.\n+     * This means that without a process that binds these correlations to values, the expression, either\n+     * a {@link RelationalExpression}, a {@link com.apple.foundationdb.record.query.RecordQuery} (or others that\n+     * implement this interface) cannot even conceptually produce a meaningful result. As often times entities that\n+     * implement this interface use composition and effectively describe trees or DAGs, this method should be the\n+     * set union of the {@link CorrelationIdentifier}s this object is correlated to as well as all children,\n+     * constituent parts, etc.\n+     * @return the set of {@link CorrelationIdentifier}s this entity is correlated to\n+     */\n+    @Nonnull\n+    Set<CorrelationIdentifier> getCorrelatedTo();\n+\n+    /**\n+     * Rebases this and all other objects this objects is composed of against a given translation map.\n+     * @param translationMap a map defining a translation from {@link CorrelationIdentifier}s {@code ids} to\n+     *        {@link CorrelationIdentifier}s {@code ids'}. After the rebase, every correlation to an {@code id}\n+     *        contained {@code ids} that is contained or referred to directly or indirectly by {@code this} must have\n+     *        been transformed to use the mapped counterpart of {@code id} {@code id'} in {@code ids'}. Ids not\n+     *        contained in the translation map must remain unmodified by the rebase operation.\n+     * @return a new entity that has been rebased\n+     */\n+    @Nonnull\n+    S rebase(Map<CorrelationIdentifier, CorrelationIdentifier> translationMap);\n+\n+    /**\n+     * Determine equality under the additional consideration of an equivalence map between {@link CorrelationIdentifier}s.\n+     * The contract of this variant of {@code equals()} differs from its regular Java counterpart.\n+     * A correlation is mostly just one part inside of composition of objects that expresses a more complicated\n+     * (correlated) structure, e.g. a filter. For instance {@code q1.x = 5} uses a correlation to {@code q1}.\n+     * That entity representing the filter is correlated to {@code q1} for obvious reasons. Also obvious is that\n+     * {@code q1.x = 6} is a different filter and should not be considered equal at all. The same is true if we\n+     * consider {@code q2.x = 5} (i.e. a filter where everything but the correlation is equal. Without further context\n+     * these two filters are not the same. However, the filters may be a part of some other entity that can express\n+     * correlations:\n+     * {@code SELECT * FROM T as q1 WHERE q1.x = 5} is equal to\n+     * {@code SELECT * FROM T as q2 WHERE q2.x = 5}. It does not matter that {@code q1} and {@code q2} are named\n+     * differently. It is important, however, that their semantic meaning is the same. In the example both {@code q1}\n+     * and {@code q2} refer to a table {@code T} which presumably is the same table. Therefore, these two query blocks\n+     * ARE the same.\n+     * In the context of this method, we can establish equality between {@code q1.x = 5} and {@code q2.x = 5} if\n+     * we know that {@code q1} and {@code q2} refer to the same underlying entity. The equivalence map passed in\n+     * encodes that equality between {@link CorrelationIdentifier}s.\n+     *\n+     * Note: This method has the same interaction with {@link Object#hashCode()} as the regular {@code equals()}\n+     *       method. As we can only ever establish tru equality using equivalence maps, {@code hashCode()}\n+     *       implementations in implementors of this interface MUST NOT be dependent on any correlation identifiers\n+     *       used in the structure of the entity. Doing so might violate the fundamental assumption:\n+     *       {@code e1.equals(e2, ...) => e1.hashCode() == e2.hashCode()}\n+     *\n+     * @param other the other object to establish equality with\n+     * @param equivalenceMap a map of {@link CorrelationIdentifier}s {@code ids} to {@code ids'}. A correlation\n+     *        identifier {@code id} used in {@code this} should be considered equal to another correlation identifier\n+     *        {@code id'} used in {@code other} if either they are the same by regular java {@link Object#equals}\n+     *        of if there is a mapping from {@code id} to {@code id'}.\n+     * @return {@code true} if both entities are considered equal using the equivalences passed in, {@code false}\n+     *         otherwise\n+     */\n+    boolean resultEquals(Object other, BiMap<CorrelationIdentifier, CorrelationIdentifier> equivalenceMap);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjQyOTEyMw=="}, "originalCommit": {"oid": "6eb7142ab316ffbec53e375804118f722f1d2bcc"}, "originalPosition": 143}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgyMDg3NTc2OnYy", "diffSide": "RIGHT", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/CorrelationIdentifier.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOVQxOTowNDoxM1rOGveF0Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOVQxOTowNDoxM1rOGveF0Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjQyOTI2NQ==", "bodyText": "I think this should be filled in: :-)", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/988#discussion_r452429265", "createdAt": "2020-07-09T19:04:13Z", "author": {"login": "nschiefer"}, "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/CorrelationIdentifier.java", "diffHunk": "@@ -0,0 +1,68 @@\n+/*\n+ * CorrelationIdentifier.java\n+ *\n+ * This source file is part of the FoundationDB open source project\n+ *\n+ * Copyright 2015-2020 Apple Inc. and the FoundationDB project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.apple.foundationdb.record.query.plan.temp;\n+\n+import javax.annotation.Nonnull;\n+import java.util.Objects;\n+import java.util.UUID;\n+\n+/**\n+ * TBD.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6eb7142ab316ffbec53e375804118f722f1d2bcc"}, "originalPosition": 28}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgyMDg3NzI3OnYy", "diffSide": "RIGHT", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/CorrelationIdentifier.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOVQxOTowNDo0MlrOGveG2g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOVQxOTowNDo0MlrOGveG2g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjQyOTUzMA==", "bodyText": "I think, but am not sure, that randomID() is more idiomatic in our code base.", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/988#discussion_r452429530", "createdAt": "2020-07-09T19:04:42Z", "author": {"login": "nschiefer"}, "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/CorrelationIdentifier.java", "diffHunk": "@@ -0,0 +1,68 @@\n+/*\n+ * CorrelationIdentifier.java\n+ *\n+ * This source file is part of the FoundationDB open source project\n+ *\n+ * Copyright 2015-2020 Apple Inc. and the FoundationDB project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.apple.foundationdb.record.query.plan.temp;\n+\n+import javax.annotation.Nonnull;\n+import java.util.Objects;\n+import java.util.UUID;\n+\n+/**\n+ * TBD.\n+ */\n+public class CorrelationIdentifier {\n+    @Nonnull final String id;\n+\n+    @Nonnull\n+    public static CorrelationIdentifier of(final String id) {\n+        return new CorrelationIdentifier(id);\n+    }\n+\n+    @Nonnull\n+    public static CorrelationIdentifier randomId() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6eb7142ab316ffbec53e375804118f722f1d2bcc"}, "originalPosition": 39}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgyMDg4MDI1OnYy", "diffSide": "RIGHT", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/ExpressionRef.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOVQxOTowNTozNVrOGveItw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOVQxOTowNTozNVrOGveItw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjQzMDAwNw==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * Insert a new expression into this expression ref.\n          \n          \n            \n                 * Insert a new expression into this reference.", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/988#discussion_r452430007", "createdAt": "2020-07-09T19:05:35Z", "author": {"login": "nschiefer"}, "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/ExpressionRef.java", "diffHunk": "@@ -36,8 +37,14 @@\n  * @param <T> the type of planner expression that is contained in this reference\n  */\n @API(API.Status.EXPERIMENTAL)\n-public interface ExpressionRef<T extends RelationalExpression> extends Bindable {\n-    void insert(@Nonnull T newValue);\n+public interface ExpressionRef<T extends RelationalExpression> extends Bindable, Correlated<ExpressionRef<T>> {\n+    /**\n+     * Insert a new expression into this expression ref.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6eb7142ab316ffbec53e375804118f722f1d2bcc"}, "originalPosition": 16}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgyMDg4MTA3OnYy", "diffSide": "RIGHT", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/ExpressionRef.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOVQxOTowNTo1MFrOGveJOA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOVQxOTowNTo1MFrOGveJOA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjQzMDEzNg==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * @return {@code true} if the value was not already part of the ref and was inserted, {@code false} if\n          \n          \n            \n                 * @return {@code true} if the value was not already part of the reference and was inserted, {@code false} if", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/988#discussion_r452430136", "createdAt": "2020-07-09T19:05:50Z", "author": {"login": "nschiefer"}, "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/ExpressionRef.java", "diffHunk": "@@ -36,8 +37,14 @@\n  * @param <T> the type of planner expression that is contained in this reference\n  */\n @API(API.Status.EXPERIMENTAL)\n-public interface ExpressionRef<T extends RelationalExpression> extends Bindable {\n-    void insert(@Nonnull T newValue);\n+public interface ExpressionRef<T extends RelationalExpression> extends Bindable, Correlated<ExpressionRef<T>> {\n+    /**\n+     * Insert a new expression into this expression ref.\n+     * @param newValue the value to be inserted\n+     * @return {@code true} if the value was not already part of the ref and was inserted, {@code false} if", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6eb7142ab316ffbec53e375804118f722f1d2bcc"}, "originalPosition": 18}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgyMDg4MTQzOnYy", "diffSide": "RIGHT", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/ExpressionRef.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOVQxOTowNTo1OVrOGveJfg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOVQxOTowNTo1OVrOGveJfg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjQzMDIwNg==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 *         the given value was already contained in the ref and was therefore not inserted.\n          \n          \n            \n                 *         the given value was already contained in the reference and was therefore not inserted.", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/988#discussion_r452430206", "createdAt": "2020-07-09T19:05:59Z", "author": {"login": "nschiefer"}, "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/ExpressionRef.java", "diffHunk": "@@ -36,8 +37,14 @@\n  * @param <T> the type of planner expression that is contained in this reference\n  */\n @API(API.Status.EXPERIMENTAL)\n-public interface ExpressionRef<T extends RelationalExpression> extends Bindable {\n-    void insert(@Nonnull T newValue);\n+public interface ExpressionRef<T extends RelationalExpression> extends Bindable, Correlated<ExpressionRef<T>> {\n+    /**\n+     * Insert a new expression into this expression ref.\n+     * @param newValue the value to be inserted\n+     * @return {@code true} if the value was not already part of the ref and was inserted, {@code false} if\n+     *         the given value was already contained in the ref and was therefore not inserted.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6eb7142ab316ffbec53e375804118f722f1d2bcc"}, "originalPosition": 19}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgyMDkzODQ0OnYy", "diffSide": "RIGHT", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/GroupExpressionRef.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOVQxOToyMzozNVrOGvesyw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOVQxOToyMzozNVrOGvesyw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjQzOTI0Mw==", "bodyText": "Do we need the extra set of parentheses here?", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/988#discussion_r452439243", "createdAt": "2020-07-09T19:23:35Z", "author": {"login": "nschiefer"}, "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/GroupExpressionRef.java", "diffHunk": "@@ -84,73 +92,92 @@ public T get() {\n     }\n \n     @Override\n-    public void insert(@Nonnull T newValue) {\n+    public boolean insert(@Nonnull T newValue) {\n         if (!containsInMemo(newValue)) {\n             members.add(newValue);\n+            return true;\n         }\n+        return false;\n     }\n-\n-    public void insertAll(@Nonnull GroupExpressionRef<T> newValues) {\n-        for (T member : newValues.members) {\n-            insert(member);\n-        }\n-    }\n-\n-    public void removeMemberIfPresent(@Nonnull T member) {\n-        members.remove(member);\n-    }\n-\n-    public void removeMember(@Nonnull T member) {\n-        if (!members.remove(member)) {\n-            throw new RecordCoreArgumentException(\"tried to remove member that isn't present\")\n-                    .addLogInfo(\"member\", member);\n-        }\n-    }\n-\n+    \n+    @SuppressWarnings(\"BooleanMethodIsAlwaysInverted\")\n     public boolean containsExactly(@Nonnull T expression) {\n         return members.contains(expression);\n     }\n \n     @Override\n-    public boolean containsAllInMemo(@Nonnull ExpressionRef<? extends RelationalExpression> otherRef) {\n-        for (RelationalExpression otherMember : otherRef.getMembers()) {\n-            if (!containsInMemo(otherMember)) {\n+    public boolean containsAllInMemo(@Nonnull final ExpressionRef<? extends RelationalExpression> otherRef,\n+                                     @Nonnull final BiMap<CorrelationIdentifier, CorrelationIdentifier> equivalenceMap) {\n+        for (final RelationalExpression otherMember : otherRef.getMembers()) {\n+            if (!containsInMemo(otherMember, equivalenceMap)) {\n                 return false;\n             }\n         }\n         return true;\n     }\n \n-    public boolean containsInMemo(@Nonnull RelationalExpression expression) {\n-        for (RelationalExpression member : members) {\n-            if (containsInMember(member, expression)) {\n+    public boolean containsInMemo(@Nonnull final RelationalExpression expression) {\n+        return containsInMemo(expression, ImmutableBiMap.of());\n+    }\n+\n+    public boolean containsInMemo(@Nonnull final RelationalExpression expression,\n+                                  @Nonnull final BiMap<CorrelationIdentifier, CorrelationIdentifier> equivalenceMap) {\n+        for (final RelationalExpression member : members) {\n+            if (containsInMember(member, expression, equivalenceMap)) {\n                 return true;\n             }\n         }\n         return false;\n     }\n \n-    private boolean containsInMember(@Nonnull RelationalExpression member, @Nonnull RelationalExpression otherMember) {\n-        if (!member.equalsWithoutChildren(otherMember)) {\n+    private static boolean containsInMember(@Nonnull RelationalExpression member,\n+                                            @Nonnull RelationalExpression otherMember,\n+                                            @Nonnull final BiMap<CorrelationIdentifier, CorrelationIdentifier> equivalenceMap) {\n+        if (member.getClass() != otherMember.getClass()) {\n             return false;\n         }\n \n-        final List<? extends Quantifier> memberQuantifiers = member.getQuantifiers();\n-        final List<? extends Quantifier> otherMemberQuantifiers = otherMember.getQuantifiers();\n-        if (memberQuantifiers.size() != otherMemberQuantifiers.size()) {\n+        final Optional<BiMap<Quantifier, Quantifier>> quantifierMapOptional =\n+                member.matchQuantifiers(ImmutableSet.copyOf(otherMember.getQuantifiers()),\n+                        equivalenceMap,\n+                        ((quantifier, otherQuantifier, nestedEquivalencesMap) -> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6eb7142ab316ffbec53e375804118f722f1d2bcc"}, "originalPosition": 109}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgyMDk2OTA4OnYy", "diffSide": "RIGHT", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/GroupExpressionRef.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOVQxOTozMzoyOFrOGve_3w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOVQxOTozMzoyOFrOGve_3w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjQ0NDEyNw==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public GroupExpressionRef<T> rebase(final Map<CorrelationIdentifier, CorrelationIdentifier> translationMap) {\n          \n          \n            \n                public GroupExpressionRef<T> rebase(@Nonnull final Map<CorrelationIdentifier, CorrelationIdentifier> translationMap) {", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/988#discussion_r452444127", "createdAt": "2020-07-09T19:33:28Z", "author": {"login": "nschiefer"}, "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/GroupExpressionRef.java", "diffHunk": "@@ -84,73 +92,92 @@ public T get() {\n     }\n \n     @Override\n-    public void insert(@Nonnull T newValue) {\n+    public boolean insert(@Nonnull T newValue) {\n         if (!containsInMemo(newValue)) {\n             members.add(newValue);\n+            return true;\n         }\n+        return false;\n     }\n-\n-    public void insertAll(@Nonnull GroupExpressionRef<T> newValues) {\n-        for (T member : newValues.members) {\n-            insert(member);\n-        }\n-    }\n-\n-    public void removeMemberIfPresent(@Nonnull T member) {\n-        members.remove(member);\n-    }\n-\n-    public void removeMember(@Nonnull T member) {\n-        if (!members.remove(member)) {\n-            throw new RecordCoreArgumentException(\"tried to remove member that isn't present\")\n-                    .addLogInfo(\"member\", member);\n-        }\n-    }\n-\n+    \n+    @SuppressWarnings(\"BooleanMethodIsAlwaysInverted\")\n     public boolean containsExactly(@Nonnull T expression) {\n         return members.contains(expression);\n     }\n \n     @Override\n-    public boolean containsAllInMemo(@Nonnull ExpressionRef<? extends RelationalExpression> otherRef) {\n-        for (RelationalExpression otherMember : otherRef.getMembers()) {\n-            if (!containsInMemo(otherMember)) {\n+    public boolean containsAllInMemo(@Nonnull final ExpressionRef<? extends RelationalExpression> otherRef,\n+                                     @Nonnull final BiMap<CorrelationIdentifier, CorrelationIdentifier> equivalenceMap) {\n+        for (final RelationalExpression otherMember : otherRef.getMembers()) {\n+            if (!containsInMemo(otherMember, equivalenceMap)) {\n                 return false;\n             }\n         }\n         return true;\n     }\n \n-    public boolean containsInMemo(@Nonnull RelationalExpression expression) {\n-        for (RelationalExpression member : members) {\n-            if (containsInMember(member, expression)) {\n+    public boolean containsInMemo(@Nonnull final RelationalExpression expression) {\n+        return containsInMemo(expression, ImmutableBiMap.of());\n+    }\n+\n+    public boolean containsInMemo(@Nonnull final RelationalExpression expression,\n+                                  @Nonnull final BiMap<CorrelationIdentifier, CorrelationIdentifier> equivalenceMap) {\n+        for (final RelationalExpression member : members) {\n+            if (containsInMember(member, expression, equivalenceMap)) {\n                 return true;\n             }\n         }\n         return false;\n     }\n \n-    private boolean containsInMember(@Nonnull RelationalExpression member, @Nonnull RelationalExpression otherMember) {\n-        if (!member.equalsWithoutChildren(otherMember)) {\n+    private static boolean containsInMember(@Nonnull RelationalExpression member,\n+                                            @Nonnull RelationalExpression otherMember,\n+                                            @Nonnull final BiMap<CorrelationIdentifier, CorrelationIdentifier> equivalenceMap) {\n+        if (member.getClass() != otherMember.getClass()) {\n             return false;\n         }\n \n-        final List<? extends Quantifier> memberQuantifiers = member.getQuantifiers();\n-        final List<? extends Quantifier> otherMemberQuantifiers = otherMember.getQuantifiers();\n-        if (memberQuantifiers.size() != otherMemberQuantifiers.size()) {\n+        final Optional<BiMap<Quantifier, Quantifier>> quantifierMapOptional =\n+                member.matchQuantifiers(ImmutableSet.copyOf(otherMember.getQuantifiers()),\n+                        equivalenceMap,\n+                        ((quantifier, otherQuantifier, nestedEquivalencesMap) -> {\n+                            final ExpressionRef<? extends RelationalExpression> rangesOver = quantifier.getRangesOver();\n+                            final ExpressionRef<? extends RelationalExpression> otherRangesOver = otherQuantifier.getRangesOver();\n+                            return rangesOver.containsAllInMemo(otherRangesOver, nestedEquivalencesMap);\n+                        }));\n+\n+        if (!quantifierMapOptional.isPresent()) {\n             return false;\n         }\n+        final BiMap<Quantifier, Quantifier> quantifierMap = quantifierMapOptional.get();\n \n-        for (int i = 0; i < memberQuantifiers.size(); i++) {\n-            final ExpressionRef<? extends RelationalExpression> memberRangesOver = memberQuantifiers.get(i).getRangesOver();\n-            final ExpressionRef<? extends RelationalExpression> otherMemberRangesOver = otherMemberQuantifiers.get(i).getRangesOver();\n+        return member.equalsWithoutChildren(otherMember,\n+                Quantifiers.compose(equivalenceMap, Quantifiers.toIdMap(quantifierMap)));\n+    }\n \n-            if (!memberRangesOver.containsAllInMemo(otherMemberRangesOver)) {\n-                return false;\n-            }\n+    @Nonnull\n+    @Override\n+    public Set<CorrelationIdentifier> getCorrelatedTo() {\n+        final ImmutableSet.Builder<CorrelationIdentifier> builder = ImmutableSet.builder();\n+        for (final T member : getMembers()) {\n+            builder.addAll(member.getCorrelatedTo());\n         }\n+        return builder.build();\n+    }\n \n-        return true;\n+    @SuppressWarnings(\"unchecked\")\n+    @Nonnull\n+    @Override\n+    public GroupExpressionRef<T> rebase(final Map<CorrelationIdentifier, CorrelationIdentifier> translationMap) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6eb7142ab316ffbec53e375804118f722f1d2bcc"}, "originalPosition": 144}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgyMDk3MDMyOnYy", "diffSide": "RIGHT", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/GroupExpressionRef.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOVQxOTozMzo1M1rOGvfAow==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOVQxOTozMzo1M1rOGvfAow==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjQ0NDMyMw==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public boolean resultEquals(final Object other, final BiMap<CorrelationIdentifier, CorrelationIdentifier> equivalenceMap) {\n          \n          \n            \n                public boolean resultEquals(@Nullable final Object other, @Nonnull final BiMap<CorrelationIdentifier, CorrelationIdentifier> equivalenceMap) {", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/988#discussion_r452444323", "createdAt": "2020-07-09T19:33:53Z", "author": {"login": "nschiefer"}, "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/GroupExpressionRef.java", "diffHunk": "@@ -244,4 +271,36 @@ public String toString() {\n         members.addAll(expressions);\n         return new GroupExpressionRef<>(members);\n     }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    @Override\n+    public boolean resultEquals(final Object other, final BiMap<CorrelationIdentifier, CorrelationIdentifier> equivalenceMap) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6eb7142ab316ffbec53e375804118f722f1d2bcc"}, "originalPosition": 164}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgyMDk5Mzg1OnYy", "diffSide": "RIGHT", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/Quantifier.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOVQxOTo0MToxNFrOGvfOzg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOVQxOTo0MToxNFrOGvfOzg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjQ0Nzk1MA==", "bodyText": "I think this should be filled out.", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/988#discussion_r452447950", "createdAt": "2020-07-09T19:41:14Z", "author": {"login": "nschiefer"}, "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/Quantifier.java", "diffHunk": "@@ -54,16 +59,65 @@\n  * at the owning (join) expression.\n  * </p>\n  */\n-public abstract class Quantifier implements Bindable {\n+@SuppressWarnings(\"unused\")\n+public abstract class Quantifier implements Bindable, Correlated<Quantifier> {\n+    /**\n+     * The alias (some identification) for this quantifier.\n+     */\n+    @Nonnull\n+    private final CorrelationIdentifier alias;\n+\n+    /**\n+     * As a quantifier is immutable the correlated set can be computed lazily and then cached. This supplier\n+     * represents that cached set.\n+     */\n+    @Nonnull\n+    private final Supplier<Set<CorrelationIdentifier>> correlatedToSupplier;\n+\n+    /**\n+     * Builder class for quantifiers.\n+     * @param <Q> quantifier type\n+     * @param <B> builder type\n+     */\n+    public abstract static class Builder<Q extends Quantifier, B extends Builder<Q, B>> {\n+        @Nullable\n+        protected CorrelationIdentifier alias;\n+\n+        @Nonnull\n+        public B from(final Q quantifier) {\n+            return withAlias(quantifier.getAlias());\n+        }\n+\n+        @SuppressWarnings(\"unchecked\")\n+        @Nonnull\n+        public B withAlias(final CorrelationIdentifier alias) {\n+            this.alias = alias;\n+            return (B)this;\n+        }\n+    }\n+\n     /**\n      * A quantifier that conceptually flows one item at a time from the expression it ranges over to\n      * the owning expression.\n      */\n     @SuppressWarnings(\"squid:S2160\") // sonarqube thinks .equals() and hashCode() should be overwritten which is not necessary\n     public static final class ForEach extends Quantifier {\n-        private final ExpressionRef<? extends RelationalExpression> rangesOver;\n+        @Nonnull private final ExpressionRef<? extends RelationalExpression> rangesOver;\n \n-        private ForEach(ExpressionRef<? extends RelationalExpression> rangesOver) {\n+        /**\n+         * TBD.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6eb7142ab316ffbec53e375804118f722f1d2bcc"}, "originalPosition": 71}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgyMDk5NTcxOnYy", "diffSide": "RIGHT", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/Quantifier.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOVQxOTo0MTo0M1rOGvfP5A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOVQxOTo0MTo0M1rOGvfP5A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjQ0ODIyOA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    public ForEach rebase(final Map<CorrelationIdentifier, CorrelationIdentifier> translationMap) {\n          \n          \n            \n                    public ForEach rebase(@Nonnull final Map<CorrelationIdentifier, CorrelationIdentifier> translationMap) {", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/988#discussion_r452448228", "createdAt": "2020-07-09T19:41:43Z", "author": {"login": "nschiefer"}, "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/Quantifier.java", "diffHunk": "@@ -78,31 +132,76 @@ private ForEach(ExpressionRef<? extends RelationalExpression> rangesOver) {\n         public String getShorthand() {\n             return \"\u0192\";\n         }\n+\n+        @Override\n+        @Nonnull\n+        public ForEach rebase(final Map<CorrelationIdentifier, CorrelationIdentifier> translationMap) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6eb7142ab316ffbec53e375804118f722f1d2bcc"}, "originalPosition": 94}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgyMDk5NzI5OnYy", "diffSide": "RIGHT", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/Quantifier.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOVQxOTo0MjoxMlrOGvfQzA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOVQxOTo0MjoxMlrOGvfQzA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjQ0ODQ2MA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * Create a builder for a for-each quantifier containing relational\n          \n          \n            \n                 * expressions.\n          \n          \n            \n                 * Create a builder for a for-each quantifier containing relational expressions.", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/988#discussion_r452448460", "createdAt": "2020-07-09T19:42:12Z", "author": {"login": "nschiefer"}, "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/Quantifier.java", "diffHunk": "@@ -78,31 +132,76 @@ private ForEach(ExpressionRef<? extends RelationalExpression> rangesOver) {\n         public String getShorthand() {\n             return \"\u0192\";\n         }\n+\n+        @Override\n+        @Nonnull\n+        public ForEach rebase(final Map<CorrelationIdentifier, CorrelationIdentifier> translationMap) {\n+            return Quantifier.forEachBuilder()\n+                    .from(this)\n+                    .build(needsRebase(translationMap) ? getRangesOver().rebase(translationMap) : getRangesOver());\n+        }\n     }\n \n     /**\n-     * Factory method to create a for-each quantifier over a given expression reference containing relational\n+     * Create a builder for a for-each quantifier containing relational\n      * expressions.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6eb7142ab316ffbec53e375804118f722f1d2bcc"}, "originalPosition": 104}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgyMTAwMTA0OnYy", "diffSide": "RIGHT", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/Quantifier.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOVQxOTo0MzoyNlrOGvfTGQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOVQxOTo0MzoyNlrOGvfTGQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjQ0OTA0OQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * Shorthand to create a for-each quantifier ranging over an expression ref.\n          \n          \n            \n                 * Shorthand to create a for-each quantifier ranging over a reference.", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/988#discussion_r452449049", "createdAt": "2020-07-09T19:43:26Z", "author": {"login": "nschiefer"}, "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/Quantifier.java", "diffHunk": "@@ -78,31 +132,76 @@ private ForEach(ExpressionRef<? extends RelationalExpression> rangesOver) {\n         public String getShorthand() {\n             return \"\u0192\";\n         }\n+\n+        @Override\n+        @Nonnull\n+        public ForEach rebase(final Map<CorrelationIdentifier, CorrelationIdentifier> translationMap) {\n+            return Quantifier.forEachBuilder()\n+                    .from(this)\n+                    .build(needsRebase(translationMap) ? getRangesOver().rebase(translationMap) : getRangesOver());\n+        }\n     }\n \n     /**\n-     * Factory method to create a for-each quantifier over a given expression reference containing relational\n+     * Create a builder for a for-each quantifier containing relational\n      * expressions.\n-     * @param rangesOver expression reference to {@link RelationalExpression}s\n-     * @return a for-each quantifier ranging over the given expression reference\n+     * @return a for-each quantifier builder\n      */\n     @Nonnull\n-    public static ForEach forEach(final ExpressionRef<? extends RelationalExpression> rangesOver) {\n-        return new ForEach(rangesOver);\n+    public static ForEach.ForEachBuilder forEachBuilder() {\n+        return new ForEach.ForEachBuilder();\n+    }\n+\n+    /**\n+     * Shorthand to create a for-each quantifier ranging over an expression ref.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6eb7142ab316ffbec53e375804118f722f1d2bcc"}, "originalPosition": 117}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgyMTAwMTM1OnYy", "diffSide": "RIGHT", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/Quantifier.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOVQxOTo0MzozM1rOGvfTSA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOVQxOTo0MzozM1rOGvfTSA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjQ0OTA5Ng==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * @param ref the ref\n          \n          \n            \n                 * @param ref the reference", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/988#discussion_r452449096", "createdAt": "2020-07-09T19:43:33Z", "author": {"login": "nschiefer"}, "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/Quantifier.java", "diffHunk": "@@ -78,31 +132,76 @@ private ForEach(ExpressionRef<? extends RelationalExpression> rangesOver) {\n         public String getShorthand() {\n             return \"\u0192\";\n         }\n+\n+        @Override\n+        @Nonnull\n+        public ForEach rebase(final Map<CorrelationIdentifier, CorrelationIdentifier> translationMap) {\n+            return Quantifier.forEachBuilder()\n+                    .from(this)\n+                    .build(needsRebase(translationMap) ? getRangesOver().rebase(translationMap) : getRangesOver());\n+        }\n     }\n \n     /**\n-     * Factory method to create a for-each quantifier over a given expression reference containing relational\n+     * Create a builder for a for-each quantifier containing relational\n      * expressions.\n-     * @param rangesOver expression reference to {@link RelationalExpression}s\n-     * @return a for-each quantifier ranging over the given expression reference\n+     * @return a for-each quantifier builder\n      */\n     @Nonnull\n-    public static ForEach forEach(final ExpressionRef<? extends RelationalExpression> rangesOver) {\n-        return new ForEach(rangesOver);\n+    public static ForEach.ForEachBuilder forEachBuilder() {\n+        return new ForEach.ForEachBuilder();\n+    }\n+\n+    /**\n+     * Shorthand to create a for-each quantifier ranging over an expression ref.\n+     * @param ref the ref", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6eb7142ab316ffbec53e375804118f722f1d2bcc"}, "originalPosition": 118}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgyMTA1MTA3OnYy", "diffSide": "RIGHT", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/RelationalExpressionWithPredicate.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOVQxOTo1OToxNlrOGvfyMA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOVQxOTo1OToxNlrOGvfyMA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjQ1NzAwOA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                RelationalExpression rebaseWithRebasedQuantifiers(final Map<CorrelationIdentifier, CorrelationIdentifier> translationMap, final List<Quantifier> rebasedQuantifiers);\n          \n          \n            \n                RelationalExpression rebaseWithRebasedQuantifiers(@Nonnull final Map<CorrelationIdentifier, CorrelationIdentifier> translationMap, @Nonnull final List<Quantifier> rebasedQuantifiers);", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/988#discussion_r452457008", "createdAt": "2020-07-09T19:59:16Z", "author": {"login": "nschiefer"}, "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/RelationalExpressionWithPredicate.java", "diffHunk": "@@ -23,11 +23,16 @@\n import com.apple.foundationdb.record.query.predicates.QueryPredicate;\n \n import javax.annotation.Nonnull;\n+import java.util.List;\n+import java.util.Map;\n \n /**\n  * A (relational) expression that has a predicate on it.\n  */\n public interface RelationalExpressionWithPredicate extends RelationalExpression {\n     @Nonnull\n     QueryPredicate getPredicate();\n+\n+    @Nonnull\n+    RelationalExpression rebaseWithRebasedQuantifiers(final Map<CorrelationIdentifier, CorrelationIdentifier> translationMap, final List<Quantifier> rebasedQuantifiers);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6eb7142ab316ffbec53e375804118f722f1d2bcc"}, "originalPosition": 15}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgyMTA1NTY1OnYy", "diffSide": "RIGHT", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/TopologicalSort.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOVQyMDowMDo0MVrOGvf07Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOVQyMDowMDo0MVrOGvf07Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjQ1NzcwOQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n             * to allow skipping at a provided prefix.\n          \n          \n            \n             * to allow skipping to a given prefix.", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/988#discussion_r452457709", "createdAt": "2020-07-09T20:00:41Z", "author": {"login": "nschiefer"}, "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/TopologicalSort.java", "diffHunk": "@@ -0,0 +1,416 @@\n+/*\n+ * TopologicalSort.java\n+ *\n+ * This source file is part of the FoundationDB open source project\n+ *\n+ * Copyright 2015-2020 Apple Inc. and the FoundationDB project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.apple.foundationdb.record.query.plan.temp;\n+\n+import com.google.common.base.Verify;\n+import com.google.common.collect.AbstractIterator;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.collect.Iterables;\n+import com.google.common.collect.Iterators;\n+import com.google.common.collect.Lists;\n+import com.google.common.collect.PeekingIterator;\n+import com.google.common.collect.Sets;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.function.Function;\n+\n+/**\n+ * Utility class to provide helpers related to topological sorts.\n+ *\n+ * The main purpose on this class is to provide a specific iterable that can efficiently traverse\n+ * all possible permutations of the input set that do not violate the given dependency constraints.\n+ *\n+ * The iterable {@link TopologicalOrderPermutationIterable} adheres to the following requirements:\n+ * 1. it does not violate the given constraints\n+ * 2. it produces all possible orderings under the given constraints\n+ * 3. it reacts appropriately to give circular dependency constraints between elements (i.e. no infinite loops)\n+ * 4. it iterates all orderings on the fly, i.e. it only stores state (i.e. does not (pre)create the orderings in memory).\n+ *\n+ * {@link TopologicalOrderPermutationIterable} subclasses {@link Iterable} in order to provide an additional feature\n+ * that allows for skipping. Assume we have a set\n+ * <pre>\n+ * {@code\n+ * { a, b, c, d } with constraints { b -> c, b -> d } (c depends on b, d depends on b)\n+ * }\n+ * </pre>\n+ *\n+ * Possible orderings are\n+ * <pre>\n+ * {@code\n+ * (a, b, c, d)\n+ * (a, b, d, c)\n+ * (b, a, c, d)\n+ * (b, a, d, c)\n+ * (b, c, a, d)\n+ * (b, c, d, a)\n+ * (b, d, a, c)\n+ * (b, d, c, a)\n+ * }\n+ * </pre>\n+ *\n+ * Frequently we test for a certain property or perform a particular operation given one possible ordering but it is clear\n+ * that it is not necessary to consider more such orderings that share a common prefix. In the example, it may be\n+ * beneficial to skip the rest of the {@code (b, a, ...)} orderings after the first one was returned\n+ * ({@code (b, a, c, d}). In this case we would like to instruct the iterator to skip all such orderings and continue\n+ * iteration at {@code (b, c, a, d)}. Similarly, we want to skip all orderings starting with {@code (b, ...)} once we\n+ * encountered the first such ordering. This the iterators created by the provided {@link TopologicalOrderPermutationIterable}\n+ * of type {@link TopologicalOrderPermutationIterator} provide a method {@link TopologicalOrderPermutationIterator#skip}\n+ * to allow skipping at a provided prefix.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6eb7142ab316ffbec53e375804118f722f1d2bcc"}, "originalPosition": 82}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgzMTI4Nzg5OnYy", "diffSide": "RIGHT", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/Quantifier.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xM1QyMjowNTo0OFrOGw734g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xM1QyMjowNTo0OFrOGw734g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mzk2NTc5NA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * @param ref the ref\n          \n          \n            \n                 * @param ref the reference", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/988#discussion_r453965794", "createdAt": "2020-07-13T22:05:48Z", "author": {"login": "nschiefer"}, "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/Quantifier.java", "diffHunk": "@@ -78,31 +132,76 @@ private ForEach(ExpressionRef<? extends RelationalExpression> rangesOver) {\n         public String getShorthand() {\n             return \"\u0192\";\n         }\n+\n+        @Override\n+        @Nonnull\n+        public ForEach rebase(final Map<CorrelationIdentifier, CorrelationIdentifier> translationMap) {\n+            return Quantifier.forEachBuilder()\n+                    .from(this)\n+                    .build(needsRebase(translationMap) ? getRangesOver().rebase(translationMap) : getRangesOver());\n+        }\n     }\n \n     /**\n-     * Factory method to create a for-each quantifier over a given expression reference containing relational\n+     * Create a builder for a for-each quantifier containing relational\n      * expressions.\n-     * @param rangesOver expression reference to {@link RelationalExpression}s\n-     * @return a for-each quantifier ranging over the given expression reference\n+     * @return a for-each quantifier builder\n      */\n     @Nonnull\n-    public static ForEach forEach(final ExpressionRef<? extends RelationalExpression> rangesOver) {\n-        return new ForEach(rangesOver);\n+    public static ForEach.ForEachBuilder forEachBuilder() {\n+        return new ForEach.ForEachBuilder();\n+    }\n+\n+    /**\n+     * Shorthand to create a for-each quantifier ranging over an expression ref.\n+     * @param ref the ref\n+     * @return a new for-each quantifier ranging over {@code ref}\n+     */\n+    @Nonnull\n+    public static ForEach forEach(@Nonnull final ExpressionRef<? extends RelationalExpression> ref) {\n+        return forEachBuilder()\n+                .build(ref);\n+    }\n+\n+    /**\n+     * Shorthand to create a for-each quantifier ranging over an expression ref using a given alias.\n+     * @param ref the ref", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6eb7142ab316ffbec53e375804118f722f1d2bcc"}, "originalPosition": 129}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgzMTI4ODYxOnYy", "diffSide": "RIGHT", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/Quantifier.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xM1QyMjowNTo1OFrOGw74WQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xM1QyMjowNTo1OFrOGw74WQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mzk2NTkxMw==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * Shorthand to create a for-each quantifier ranging over an expression ref using a given alias.\n          \n          \n            \n                 * Shorthand to create a for-each quantifier ranging over a reference using a given alias.", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/988#discussion_r453965913", "createdAt": "2020-07-13T22:05:58Z", "author": {"login": "nschiefer"}, "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/Quantifier.java", "diffHunk": "@@ -78,31 +132,76 @@ private ForEach(ExpressionRef<? extends RelationalExpression> rangesOver) {\n         public String getShorthand() {\n             return \"\u0192\";\n         }\n+\n+        @Override\n+        @Nonnull\n+        public ForEach rebase(final Map<CorrelationIdentifier, CorrelationIdentifier> translationMap) {\n+            return Quantifier.forEachBuilder()\n+                    .from(this)\n+                    .build(needsRebase(translationMap) ? getRangesOver().rebase(translationMap) : getRangesOver());\n+        }\n     }\n \n     /**\n-     * Factory method to create a for-each quantifier over a given expression reference containing relational\n+     * Create a builder for a for-each quantifier containing relational\n      * expressions.\n-     * @param rangesOver expression reference to {@link RelationalExpression}s\n-     * @return a for-each quantifier ranging over the given expression reference\n+     * @return a for-each quantifier builder\n      */\n     @Nonnull\n-    public static ForEach forEach(final ExpressionRef<? extends RelationalExpression> rangesOver) {\n-        return new ForEach(rangesOver);\n+    public static ForEach.ForEachBuilder forEachBuilder() {\n+        return new ForEach.ForEachBuilder();\n+    }\n+\n+    /**\n+     * Shorthand to create a for-each quantifier ranging over an expression ref.\n+     * @param ref the ref\n+     * @return a new for-each quantifier ranging over {@code ref}\n+     */\n+    @Nonnull\n+    public static ForEach forEach(@Nonnull final ExpressionRef<? extends RelationalExpression> ref) {\n+        return forEachBuilder()\n+                .build(ref);\n+    }\n+\n+    /**\n+     * Shorthand to create a for-each quantifier ranging over an expression ref using a given alias.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6eb7142ab316ffbec53e375804118f722f1d2bcc"}, "originalPosition": 128}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgzMTI5MzM2OnYy", "diffSide": "RIGHT", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/Quantifier.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xM1QyMjowNjo1MFrOGw76tA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xM1QyMjowNjo1MFrOGw76tA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mzk2NjUxNg==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    public Existential rebase(final Map<CorrelationIdentifier, CorrelationIdentifier> translationMap) {\n          \n          \n            \n                    public Existential rebase(@Nonnull final Map<CorrelationIdentifier, CorrelationIdentifier> translationMap) {", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/988#discussion_r453966516", "createdAt": "2020-07-13T22:06:50Z", "author": {"login": "nschiefer"}, "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/Quantifier.java", "diffHunk": "@@ -117,17 +216,49 @@ private Existential(final ExpressionRef<? extends RelationalExpression> rangesOv\n         public String getShorthand() {\n             return \"\u2203\";\n         }\n+\n+        @Override\n+        @Nonnull\n+        public Existential rebase(final Map<CorrelationIdentifier, CorrelationIdentifier> translationMap) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6eb7142ab316ffbec53e375804118f722f1d2bcc"}, "originalPosition": 178}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgzMTI5NTk5OnYy", "diffSide": "RIGHT", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/Quantifier.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xM1QyMjowNzoxN1rOGw77_A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xM1QyMjowNzoxN1rOGw77_A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mzk2Njg0NA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * Shorthand to create an existential quantifier ranging over an expression ref.\n          \n          \n            \n                 * Shorthand to create an existential quantifier ranging over a reference.", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/988#discussion_r453966844", "createdAt": "2020-07-13T22:07:17Z", "author": {"login": "nschiefer"}, "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/Quantifier.java", "diffHunk": "@@ -117,17 +216,49 @@ private Existential(final ExpressionRef<? extends RelationalExpression> rangesOv\n         public String getShorthand() {\n             return \"\u2203\";\n         }\n+\n+        @Override\n+        @Nonnull\n+        public Existential rebase(final Map<CorrelationIdentifier, CorrelationIdentifier> translationMap) {\n+            return Quantifier.existentialBuilder()\n+                    .from(this)\n+                    .build(needsRebase(translationMap) ? getRangesOver().rebase(translationMap) : getRangesOver());\n+        }\n     }\n \n     /**\n-     * Factory method to create an existential quantifier over a given expression reference containing relational\n+     * Create a builder for an existential quantifier containing relational\n      * expressions.\n-     * @param rangesOver expression reference to {@link RelationalExpression}s\n-     * @return a for-each quantifier ranging over the given expression reference\n+     * @return an existential quantifier builder\n+     */\n+    @Nonnull\n+    public static Existential.ExistentialBuilder existentialBuilder() {\n+        return new Existential.ExistentialBuilder();\n+    }\n+\n+    /**\n+     * Shorthand to create an existential quantifier ranging over an expression ref.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6eb7142ab316ffbec53e375804118f722f1d2bcc"}, "originalPosition": 199}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgzMTI5NjYwOnYy", "diffSide": "RIGHT", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/Quantifier.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xM1QyMjowNzoyNVrOGw78Vg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xM1QyMjowNzoyNVrOGw78Vg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mzk2NjkzNA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * @param ref the ref\n          \n          \n            \n                 * @param ref the reference", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/988#discussion_r453966934", "createdAt": "2020-07-13T22:07:25Z", "author": {"login": "nschiefer"}, "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/Quantifier.java", "diffHunk": "@@ -117,17 +216,49 @@ private Existential(final ExpressionRef<? extends RelationalExpression> rangesOv\n         public String getShorthand() {\n             return \"\u2203\";\n         }\n+\n+        @Override\n+        @Nonnull\n+        public Existential rebase(final Map<CorrelationIdentifier, CorrelationIdentifier> translationMap) {\n+            return Quantifier.existentialBuilder()\n+                    .from(this)\n+                    .build(needsRebase(translationMap) ? getRangesOver().rebase(translationMap) : getRangesOver());\n+        }\n     }\n \n     /**\n-     * Factory method to create an existential quantifier over a given expression reference containing relational\n+     * Create a builder for an existential quantifier containing relational\n      * expressions.\n-     * @param rangesOver expression reference to {@link RelationalExpression}s\n-     * @return a for-each quantifier ranging over the given expression reference\n+     * @return an existential quantifier builder\n+     */\n+    @Nonnull\n+    public static Existential.ExistentialBuilder existentialBuilder() {\n+        return new Existential.ExistentialBuilder();\n+    }\n+\n+    /**\n+     * Shorthand to create an existential quantifier ranging over an expression ref.\n+     * @param ref the ref", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6eb7142ab316ffbec53e375804118f722f1d2bcc"}, "originalPosition": 200}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgzMTI5NzM1OnYy", "diffSide": "RIGHT", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/Quantifier.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xM1QyMjowNzozN1rOGw78yg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xM1QyMjowNzozN1rOGw78yg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mzk2NzA1MA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public static Existential existential(final ExpressionRef<? extends RelationalExpression> ref) {\n          \n          \n            \n                public static Existential existential(@Nonnull final ExpressionRef<? extends RelationalExpression> ref) {", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/988#discussion_r453967050", "createdAt": "2020-07-13T22:07:37Z", "author": {"login": "nschiefer"}, "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/Quantifier.java", "diffHunk": "@@ -117,17 +216,49 @@ private Existential(final ExpressionRef<? extends RelationalExpression> rangesOv\n         public String getShorthand() {\n             return \"\u2203\";\n         }\n+\n+        @Override\n+        @Nonnull\n+        public Existential rebase(final Map<CorrelationIdentifier, CorrelationIdentifier> translationMap) {\n+            return Quantifier.existentialBuilder()\n+                    .from(this)\n+                    .build(needsRebase(translationMap) ? getRangesOver().rebase(translationMap) : getRangesOver());\n+        }\n     }\n \n     /**\n-     * Factory method to create an existential quantifier over a given expression reference containing relational\n+     * Create a builder for an existential quantifier containing relational\n      * expressions.\n-     * @param rangesOver expression reference to {@link RelationalExpression}s\n-     * @return a for-each quantifier ranging over the given expression reference\n+     * @return an existential quantifier builder\n+     */\n+    @Nonnull\n+    public static Existential.ExistentialBuilder existentialBuilder() {\n+        return new Existential.ExistentialBuilder();\n+    }\n+\n+    /**\n+     * Shorthand to create an existential quantifier ranging over an expression ref.\n+     * @param ref the ref\n+     * @return a new existential quantifier ranging over {@code ref}\n      */\n     @Nonnull\n-    public static Existential existential(@Nonnull final ExpressionRef<? extends RelationalExpression> rangesOver) {\n-        return new Existential(rangesOver);\n+    public static Existential existential(final ExpressionRef<? extends RelationalExpression> ref) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6eb7142ab316ffbec53e375804118f722f1d2bcc"}, "originalPosition": 206}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgzMTI5OTQ5OnYy", "diffSide": "RIGHT", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/Quantifier.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xM1QyMjowODowMlrOGw795Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xM1QyMjowODowMlrOGw795Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mzk2NzMzMw==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * Shorthand to create an existential quantifier ranging over an expression ref using a given alias.\n          \n          \n            \n                 * Shorthand to create an existential quantifier ranging over a reference using a given alias.", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/988#discussion_r453967333", "createdAt": "2020-07-13T22:08:02Z", "author": {"login": "nschiefer"}, "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/Quantifier.java", "diffHunk": "@@ -117,17 +216,49 @@ private Existential(final ExpressionRef<? extends RelationalExpression> rangesOv\n         public String getShorthand() {\n             return \"\u2203\";\n         }\n+\n+        @Override\n+        @Nonnull\n+        public Existential rebase(final Map<CorrelationIdentifier, CorrelationIdentifier> translationMap) {\n+            return Quantifier.existentialBuilder()\n+                    .from(this)\n+                    .build(needsRebase(translationMap) ? getRangesOver().rebase(translationMap) : getRangesOver());\n+        }\n     }\n \n     /**\n-     * Factory method to create an existential quantifier over a given expression reference containing relational\n+     * Create a builder for an existential quantifier containing relational\n      * expressions.\n-     * @param rangesOver expression reference to {@link RelationalExpression}s\n-     * @return a for-each quantifier ranging over the given expression reference\n+     * @return an existential quantifier builder\n+     */\n+    @Nonnull\n+    public static Existential.ExistentialBuilder existentialBuilder() {\n+        return new Existential.ExistentialBuilder();\n+    }\n+\n+    /**\n+     * Shorthand to create an existential quantifier ranging over an expression ref.\n+     * @param ref the ref\n+     * @return a new existential quantifier ranging over {@code ref}\n      */\n     @Nonnull\n-    public static Existential existential(@Nonnull final ExpressionRef<? extends RelationalExpression> rangesOver) {\n-        return new Existential(rangesOver);\n+    public static Existential existential(final ExpressionRef<? extends RelationalExpression> ref) {\n+        return existentialBuilder()\n+                .build(ref);\n+    }\n+\n+    /**\n+     * Shorthand to create an existential quantifier ranging over an expression ref using a given alias.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6eb7142ab316ffbec53e375804118f722f1d2bcc"}, "originalPosition": 212}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgzMTMwMDMyOnYy", "diffSide": "RIGHT", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/Quantifier.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xM1QyMjowODoxMFrOGw7-Tg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xM1QyMjowODoxMFrOGw7-Tg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mzk2NzQzOA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * @param ref the ref\n          \n          \n            \n                 * @param ref the reference", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/988#discussion_r453967438", "createdAt": "2020-07-13T22:08:10Z", "author": {"login": "nschiefer"}, "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/Quantifier.java", "diffHunk": "@@ -117,17 +216,49 @@ private Existential(final ExpressionRef<? extends RelationalExpression> rangesOv\n         public String getShorthand() {\n             return \"\u2203\";\n         }\n+\n+        @Override\n+        @Nonnull\n+        public Existential rebase(final Map<CorrelationIdentifier, CorrelationIdentifier> translationMap) {\n+            return Quantifier.existentialBuilder()\n+                    .from(this)\n+                    .build(needsRebase(translationMap) ? getRangesOver().rebase(translationMap) : getRangesOver());\n+        }\n     }\n \n     /**\n-     * Factory method to create an existential quantifier over a given expression reference containing relational\n+     * Create a builder for an existential quantifier containing relational\n      * expressions.\n-     * @param rangesOver expression reference to {@link RelationalExpression}s\n-     * @return a for-each quantifier ranging over the given expression reference\n+     * @return an existential quantifier builder\n+     */\n+    @Nonnull\n+    public static Existential.ExistentialBuilder existentialBuilder() {\n+        return new Existential.ExistentialBuilder();\n+    }\n+\n+    /**\n+     * Shorthand to create an existential quantifier ranging over an expression ref.\n+     * @param ref the ref\n+     * @return a new existential quantifier ranging over {@code ref}\n      */\n     @Nonnull\n-    public static Existential existential(@Nonnull final ExpressionRef<? extends RelationalExpression> rangesOver) {\n-        return new Existential(rangesOver);\n+    public static Existential existential(final ExpressionRef<? extends RelationalExpression> ref) {\n+        return existentialBuilder()\n+                .build(ref);\n+    }\n+\n+    /**\n+     * Shorthand to create an existential quantifier ranging over an expression ref using a given alias.\n+     * @param ref the ref", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6eb7142ab316ffbec53e375804118f722f1d2bcc"}, "originalPosition": 213}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgzMTMwNjE1OnYy", "diffSide": "RIGHT", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/Quantifier.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xM1QyMjowOToxNFrOGw8BMw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xM1QyMjowOToxNFrOGw8BMw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mzk2ODE3OQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                         * Often times a for-each quantifier needs to \"turn\" into a physical quantifier e.g. when a logical\n          \n          \n            \n                         * operator is implemented by a physical one.\n          \n          \n            \n                         * Build a new physical quantifier from a for-each quantifier with the same alias.\n          \n          \n            \n                         * Often times a for-each quantifier needs to \"turn\" into a physical quantifier e.g. when a logical\n          \n          \n            \n                         * operator is implemented by a physical one.", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/988#discussion_r453968179", "createdAt": "2020-07-13T22:09:14Z", "author": {"login": "nschiefer"}, "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/Quantifier.java", "diffHunk": "@@ -137,9 +268,32 @@ public static Existential existential(@Nonnull final ExpressionRef<? extends Rel\n      */\n     @SuppressWarnings(\"squid:S2160\") // sonarqube thinks .equals() and hashCode() should be overwritten which is not necessary\n     public static final class Physical extends Quantifier {\n-        private final ExpressionRef<? extends RecordQueryPlan> rangesOver;\n+        @Nonnull private final ExpressionRef<? extends RecordQueryPlan> rangesOver;\n+\n+        /**\n+         * Builder subclass for physical quantifiers.\n+         */\n+        public static class PhysicalBuilder extends Builder<Physical, PhysicalBuilder> {\n+            @Nonnull\n+            public Physical build(@Nonnull final ExpressionRef<? extends RecordQueryPlan> rangesOver) {\n+                return new Physical(alias == null ? CorrelationIdentifier.randomId() : alias, rangesOver);\n+            }\n+\n+            /**\n+             * Often times a for-each quantifier needs to \"turn\" into a physical quantifier e.g. when a logical\n+             * operator is implemented by a physical one.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6eb7142ab316ffbec53e375804118f722f1d2bcc"}, "originalPosition": 244}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4968, "cost": 1, "resetAt": "2021-11-12T19:05:54Z"}}}