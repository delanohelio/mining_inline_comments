{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzkwNjc1OTEz", "number": 861, "title": "Resolves #860: Try planning an IN predicate as an OR of equalities.", "bodyText": "If the planner detects that it can't implement an IN predicate using an in-join (for example, because of an incompatible sort order), it tries to rewrite it as an OR predicate instead.\nSee #860 for a description of the specific problem that this solves.\nThe implementation is a bit hacky and ends up relying on pieces of the new planner to make decisions. This might not be great hygiene, but it seemed like the right tool for determining when to use one plan or another.", "createdAt": "2020-03-18T21:32:16Z", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/861", "merged": true, "mergeCommit": {"oid": "b109ede4efe8366b29514b548b2206fa2250324c"}, "closed": true, "closedAt": "2020-03-25T19:00:49Z", "author": {"login": "nschiefer"}, "timelineItems": {"totalCount": 11, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcPPVergFqTM3NzkzOTQ2OA==", "endCursor": "Y3Vyc29yOnYyOpPPAAABcRMLWPgFqTM4MTQ0NDg1NQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzc3OTM5NDY4", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/861#pullrequestreview-377939468", "createdAt": "2020-03-19T17:26:52Z", "commit": {"oid": "916964d87e7551126e234b29d292eb77604d0962"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOVQxNzoyNjo1M1rOF447sw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOVQxNzoyNjo1M1rOF447sw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTE5NzM2Mw==", "bodyText": "Do we want to have some switch / threshold in the planner config to allow this to be introduced gracefully?", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/861#discussion_r395197363", "createdAt": "2020-03-19T17:26:53Z", "author": {"login": "MMcM"}, "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/RecordQueryPlanner.java", "diffHunk": "@@ -340,12 +341,27 @@ private ScoredPlan planFilter(@Nonnull PlanContext planContext, @Nonnull QueryCo\n     @Nullable\n     private ScoredPlan planFilter(@Nonnull PlanContext planContext, @Nonnull QueryComponent filter, boolean needOrdering) {\n         final InExtractor inExtractor = new InExtractor(filter);\n+        ScoredPlan withInAsOr = null;\n         if (planContext.query.getSort() != null) {\n-            inExtractor.setSort(planContext.query.getSort(), planContext.query.isSortReverse());\n+            if (!inExtractor.setSort(planContext.query.getSort(), planContext.query.isSortReverse())) {\n+                // Can't implement as an in join because of the sort order. Try as an OR instead.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "916964d87e7551126e234b29d292eb77604d0962"}, "originalPosition": 16}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "916964d87e7551126e234b29d292eb77604d0962", "author": {"user": {"login": "nschiefer", "name": "Nicholas Schiefer"}}, "url": "https://github.com/FoundationDB/fdb-record-layer/commit/916964d87e7551126e234b29d292eb77604d0962", "committedDate": "2020-03-18T21:20:01Z", "message": "Resolves #860: Try planning an IN predicate as an OR of equalities.\n\nIf the planner detects that it can't implement an IN predicate using an\nin-join (for example, because of an incompatible sort order), it tries\nto rewrite it as an OR predicate instead."}, "afterCommit": {"oid": "f1c7399ad0eed082a028139c477257144230db5b", "author": {"user": {"login": "nschiefer", "name": "Nicholas Schiefer"}}, "url": "https://github.com/FoundationDB/fdb-record-layer/commit/f1c7399ad0eed082a028139c477257144230db5b", "committedDate": "2020-03-19T17:49:54Z", "message": "Resolves #860: Try planning an IN predicate as an OR of equalities.\n\nIf the planner detects that it can't implement an IN predicate using an\nin-join (for example, because of an incompatible sort order), it tries\nto rewrite it as an OR predicate instead."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "f1c7399ad0eed082a028139c477257144230db5b", "author": {"user": {"login": "nschiefer", "name": "Nicholas Schiefer"}}, "url": "https://github.com/FoundationDB/fdb-record-layer/commit/f1c7399ad0eed082a028139c477257144230db5b", "committedDate": "2020-03-19T17:49:54Z", "message": "Resolves #860: Try planning an IN predicate as an OR of equalities.\n\nIf the planner detects that it can't implement an IN predicate using an\nin-join (for example, because of an incompatible sort order), it tries\nto rewrite it as an OR predicate instead."}, "afterCommit": {"oid": "4ce8f795862004af1d7312b958b0b342d347ea15", "author": {"user": {"login": "nschiefer", "name": "Nicholas Schiefer"}}, "url": "https://github.com/FoundationDB/fdb-record-layer/commit/4ce8f795862004af1d7312b958b0b342d347ea15", "committedDate": "2020-03-25T15:10:08Z", "message": "Resolves #860: Try planning an IN predicate as an OR of equalities.\n\nIf the planner detects that it can't implement an IN predicate using an\nin-join (for example, because of an incompatible sort order), it tries\nto rewrite it as an OR predicate instead.\n\nThis attempt is controlled by a configuration object, which also\nincludes the IndexScanPreference."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzgxMjU2NTQ2", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/861#pullrequestreview-381256546", "createdAt": "2020-03-25T15:22:40Z", "commit": {"oid": "4ce8f795862004af1d7312b958b0b342d347ea15"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNVQxNToyMjo0MFrOF7gaKg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNVQxNToyMjo0MFrOF7gaKg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Nzk0MTI5MA==", "bodyText": "I'm not sure whether to gate this behind the config parameter, too. That feels hacky, but is probably safer.", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/861#discussion_r397941290", "createdAt": "2020-03-25T15:22:40Z", "author": {"login": "nschiefer"}, "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/RecordQueryPlanner.java", "diffHunk": "@@ -1195,7 +1236,7 @@ private ScoredPlan planOrderedUnion(@Nonnull PlanContext planContext, @Nonnull L\n         if (unionPlan.getComplexity() > complexityThreshold) {\n             throw new RecordQueryPlanComplexityException(unionPlan);\n         }\n-        return new ScoredPlan(1, unionPlan, Collections.emptyList(), anyDuplicates, includedRankComparisons);\n+        return new ScoredPlan(0, unionPlan, Collections.emptyList(), anyDuplicates, includedRankComparisons);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4ce8f795862004af1d7312b958b0b342d347ea15"}, "originalPosition": 119}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "4ce8f795862004af1d7312b958b0b342d347ea15", "author": {"user": {"login": "nschiefer", "name": "Nicholas Schiefer"}}, "url": "https://github.com/FoundationDB/fdb-record-layer/commit/4ce8f795862004af1d7312b958b0b342d347ea15", "committedDate": "2020-03-25T15:10:08Z", "message": "Resolves #860: Try planning an IN predicate as an OR of equalities.\n\nIf the planner detects that it can't implement an IN predicate using an\nin-join (for example, because of an incompatible sort order), it tries\nto rewrite it as an OR predicate instead.\n\nThis attempt is controlled by a configuration object, which also\nincludes the IndexScanPreference."}, "afterCommit": {"oid": "4791a9d843b3bd3059cbf8babd1a59a6b20b9f31", "author": {"user": {"login": "nschiefer", "name": "Nicholas Schiefer"}}, "url": "https://github.com/FoundationDB/fdb-record-layer/commit/4791a9d843b3bd3059cbf8babd1a59a6b20b9f31", "committedDate": "2020-03-25T15:36:12Z", "message": "Resolves #860: Try planning an IN predicate as an OR of equalities.\n\nIf the planner detects that it can't implement an IN predicate using an\nin-join (for example, because of an incompatible sort order), it tries\nto rewrite it as an OR predicate instead.\n\nThis attempt is controlled by a configuration object, which also\nincludes the IndexScanPreference."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzgxMjcxNjUx", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/861#pullrequestreview-381271651", "createdAt": "2020-03-25T15:37:26Z", "commit": {"oid": "4791a9d843b3bd3059cbf8babd1a59a6b20b9f31"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0546106d225ce2c1e9e61012ad27bb0f6298d4b1", "author": {"user": {"login": "nschiefer", "name": "Nicholas Schiefer"}}, "url": "https://github.com/FoundationDB/fdb-record-layer/commit/0546106d225ce2c1e9e61012ad27bb0f6298d4b1", "committedDate": "2020-03-25T16:00:00Z", "message": "Resolves #860: Try planning an IN predicate as an OR of equalities.\n\nIf the planner detects that it can't implement an IN predicate using an\nin-join (for example, because of an incompatible sort order), it tries\nto rewrite it as an OR predicate instead.\n\nThis attempt is controlled by a configuration object, which also\nincludes the IndexScanPreference."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "4791a9d843b3bd3059cbf8babd1a59a6b20b9f31", "author": {"user": {"login": "nschiefer", "name": "Nicholas Schiefer"}}, "url": "https://github.com/FoundationDB/fdb-record-layer/commit/4791a9d843b3bd3059cbf8babd1a59a6b20b9f31", "committedDate": "2020-03-25T15:36:12Z", "message": "Resolves #860: Try planning an IN predicate as an OR of equalities.\n\nIf the planner detects that it can't implement an IN predicate using an\nin-join (for example, because of an incompatible sort order), it tries\nto rewrite it as an OR predicate instead.\n\nThis attempt is controlled by a configuration object, which also\nincludes the IndexScanPreference."}, "afterCommit": {"oid": "0546106d225ce2c1e9e61012ad27bb0f6298d4b1", "author": {"user": {"login": "nschiefer", "name": "Nicholas Schiefer"}}, "url": "https://github.com/FoundationDB/fdb-record-layer/commit/0546106d225ce2c1e9e61012ad27bb0f6298d4b1", "committedDate": "2020-03-25T16:00:00Z", "message": "Resolves #860: Try planning an IN predicate as an OR of equalities.\n\nIf the planner detects that it can't implement an IN predicate using an\nin-join (for example, because of an incompatible sort order), it tries\nto rewrite it as an OR predicate instead.\n\nThis attempt is controlled by a configuration object, which also\nincludes the IndexScanPreference."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzgxMzc3MTQ2", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/861#pullrequestreview-381377146", "createdAt": "2020-03-25T17:29:59Z", "commit": {"oid": "0546106d225ce2c1e9e61012ad27bb0f6298d4b1"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNVQxNzoyOTo1OVrOF7mYZA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNVQxNzo1NzozNFrOF7nigw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODAzOTE0MA==", "bodyText": "Oh, hm. So this essentially relies on the side effect from this operation? I don't love having this happen within the if-condition (rather than it happening on the previous line and capturing the success or failure as an explicit boolean) as I don't think people expect side effects there. But it's probably acceptable if we want to keep it like this and take the PR prior to changing it (and the comment helps).", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/861#discussion_r398039140", "createdAt": "2020-03-25T17:29:59Z", "author": {"login": "alecgrieser"}, "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/RecordQueryPlanner.java", "diffHunk": "@@ -341,12 +366,28 @@ private ScoredPlan planFilter(@Nonnull PlanContext planContext, @Nonnull QueryCo\n     @Nullable\n     private ScoredPlan planFilter(@Nonnull PlanContext planContext, @Nonnull QueryComponent filter, boolean needOrdering) {\n         final InExtractor inExtractor = new InExtractor(filter);\n+        ScoredPlan withInAsOr = null;\n         if (planContext.query.getSort() != null) {\n-            inExtractor.setSort(planContext.query.getSort(), planContext.query.isSortReverse());\n+            if (!inExtractor.setSort(planContext.query.getSort(), planContext.query.isSortReverse()) && // needs to come first, to clear sort", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0546106d225ce2c1e9e61012ad27bb0f6298d4b1"}, "originalPosition": 90}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODA0MDU4NQ==", "bodyText": "At some point, we'll probably want to document what these configuration parameters actually do, but perhaps not today.", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/861#discussion_r398040585", "createdAt": "2020-03-25T17:32:07Z", "author": {"login": "alecgrieser"}, "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/RecordQueryPlannerConfiguration.java", "diffHunk": "@@ -0,0 +1,91 @@\n+/*\n+ * RecordQueryPlannerConfiguration.java\n+ *\n+ * This source file is part of the FoundationDB open source project\n+ *\n+ * Copyright 2015-2020 Apple Inc. and the FoundationDB project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.apple.foundationdb.record.query.plan;\n+\n+import com.apple.foundationdb.annotation.API;\n+\n+import javax.annotation.Nonnull;\n+\n+/**\n+ * A set of configuration options for the {@link RecordQueryPlanner}.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0546106d225ce2c1e9e61012ad27bb0f6298d4b1"}, "originalPosition": 28}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODA0MTEwNQ==", "bodyText": "Looks like you dropped this: \\", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/861#discussion_r398041105", "createdAt": "2020-03-25T17:32:53Z", "author": {"login": "alecgrieser"}, "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/RecordQueryPlanner.java", "diffHunk": "@@ -340,12 +341,27 @@ private ScoredPlan planFilter(@Nonnull PlanContext planContext, @Nonnull QueryCo\n     @Nullable\n     private ScoredPlan planFilter(@Nonnull PlanContext planContext, @Nonnull QueryComponent filter, boolean needOrdering) {\n         final InExtractor inExtractor = new InExtractor(filter);\n+        ScoredPlan withInAsOr = null;\n         if (planContext.query.getSort() != null) {\n-            inExtractor.setSort(planContext.query.getSort(), planContext.query.isSortReverse());\n+            if (!inExtractor.setSort(planContext.query.getSort(), planContext.query.isSortReverse())) {\n+                // Can't implement as an in join because of the sort order. Try as an OR instead.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTE5NzM2Mw=="}, "originalCommit": {"oid": "916964d87e7551126e234b29d292eb77604d0962"}, "originalPosition": 16}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODA1Mzc0Mg==", "bodyText": "It feels a little weird that this still calls cancel, with the new stuff. Like, in theory, it should be able to use the extracted sort components from the IN and then use a UnionPlan for the rest. Though I think it's still safe to do it as it is here, so perhaps an optimization for another time.", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/861#discussion_r398053742", "createdAt": "2020-03-25T17:51:22Z", "author": {"login": "alecgrieser"}, "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/planning/InExtractor.java", "diffHunk": "@@ -157,10 +193,11 @@ public void setSort(@Nonnull KeyExpression key, boolean reverse) {\n             if (!found) {\n                 // There is a requested sort ahead of the ones from the IN's, so we can't do it.\n                 cancel();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0546106d225ce2c1e9e61012ad27bb0f6298d4b1"}, "originalPosition": 101}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODA1NDM0MQ==", "bodyText": "Hmm, interesting. Should the logic in the join filter that chooses between the Union and the InJoin be changed then (maybe ignoring the score if we can't trust it?).", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/861#discussion_r398054341", "createdAt": "2020-03-25T17:52:15Z", "author": {"login": "alecgrieser"}, "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/RecordQueryPlanner.java", "diffHunk": "@@ -1196,7 +1237,12 @@ private ScoredPlan planOrderedUnion(@Nonnull PlanContext planContext, @Nonnull L\n         if (unionPlan.getComplexity() > complexityThreshold) {\n             throw new RecordQueryPlanComplexityException(unionPlan);\n         }\n-        return new ScoredPlan(1, unionPlan, Collections.emptyList(), anyDuplicates, includedRankComparisons);\n+\n+        // If we don't change this when shouldAttemptFailedInJoinAsOr() is true, then we _always_ pick the union plan,\n+        // rather than the in join plan.\n+        int score = getConfiguration().shouldAttemptFailedInJoinAsOr() ? 0 : 1;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0546106d225ce2c1e9e61012ad27bb0f6298d4b1"}, "originalPosition": 122}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODA1NTQwNQ==", "bodyText": "I suppose technically, this could be a @DualPlannerTest, then (though not saying it should).\nOr this could assert the planner type so that if someone were to make it a DualPlannerTest at some point, they get an error rather than it succeeding for the wrong reasons.", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/861#discussion_r398055405", "createdAt": "2020-03-25T17:53:46Z", "author": {"login": "alecgrieser"}, "path": "fdb-record-layer-core/src/test/java/com/apple/foundationdb/record/provider/foundationdb/query/FDBInQueryTest.java", "diffHunk": "@@ -261,6 +267,77 @@ public void testInQueryIndexSortedDifferently() throws Exception {\n                 context -> TestHelpers.assertDiscardedAtMost(40, context)));\n     }\n \n+    /**\n+     * Verify that an IN query with a sort can be implemented as an ordered union of compound indexes that can satisfy\n+     * the sort once the equality predicates from the IN have been pushed onto the indexes.\n+     * @see com.apple.foundationdb.record.query.plan.planning.InExtractor#asOr()\n+     */\n+    @ParameterizedTest\n+    @BooleanSource\n+    public void inQueryWithSortBySecondFieldOfCompoundIndex(boolean shouldAttemptInAsOr) throws Exception {\n+        RecordMetaDataHook hook = metaData ->\n+                metaData.addIndex(\"MySimpleRecord\", \"compoundIndex\",\n+                        concat(field(\"num_value_3_indexed\"), field(\"str_value_indexed\")));\n+        complexQuerySetup(hook);\n+        final List<Integer> inList = asList(1, 4, 2);\n+        RecordQuery query = RecordQuery.newBuilder()\n+                .setRecordType(\"MySimpleRecord\")\n+                .setFilter(Query.field(\"num_value_3_indexed\").in(inList))\n+                .setSort(field(\"str_value_indexed\"))\n+                .build();\n+\n+        if (planner instanceof RecordQueryPlanner) { // will always be true, but it's good to check before casting", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0546106d225ce2c1e9e61012ad27bb0f6298d4b1"}, "originalPosition": 49}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODA1NzI3NA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    // A CNF who's DNF size doesn't fit in an int, expressed with IN predicates.\n          \n          \n            \n                    // A CNF whose DNF size doesn't fit in an int, expressed with IN predicates.\n          \n      \n    \n    \n  \n\nI'm sorry", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/861#discussion_r398057274", "createdAt": "2020-03-25T17:56:20Z", "author": {"login": "alecgrieser"}, "path": "fdb-record-layer-core/src/test/java/com/apple/foundationdb/record/provider/foundationdb/query/FDBInQueryTest.java", "diffHunk": "@@ -261,6 +267,77 @@ public void testInQueryIndexSortedDifferently() throws Exception {\n                 context -> TestHelpers.assertDiscardedAtMost(40, context)));\n     }\n \n+    /**\n+     * Verify that an IN query with a sort can be implemented as an ordered union of compound indexes that can satisfy\n+     * the sort once the equality predicates from the IN have been pushed onto the indexes.\n+     * @see com.apple.foundationdb.record.query.plan.planning.InExtractor#asOr()\n+     */\n+    @ParameterizedTest\n+    @BooleanSource\n+    public void inQueryWithSortBySecondFieldOfCompoundIndex(boolean shouldAttemptInAsOr) throws Exception {\n+        RecordMetaDataHook hook = metaData ->\n+                metaData.addIndex(\"MySimpleRecord\", \"compoundIndex\",\n+                        concat(field(\"num_value_3_indexed\"), field(\"str_value_indexed\")));\n+        complexQuerySetup(hook);\n+        final List<Integer> inList = asList(1, 4, 2);\n+        RecordQuery query = RecordQuery.newBuilder()\n+                .setRecordType(\"MySimpleRecord\")\n+                .setFilter(Query.field(\"num_value_3_indexed\").in(inList))\n+                .setSort(field(\"str_value_indexed\"))\n+                .build();\n+\n+        if (planner instanceof RecordQueryPlanner) { // will always be true, but it's good to check before casting\n+            RecordQueryPlanner recordQueryPlanner = (RecordQueryPlanner)planner;\n+            RecordQueryPlannerConfiguration configuration = recordQueryPlanner.getConfiguration();\n+            recordQueryPlanner.setConfiguration(recordQueryPlanner.getConfiguration().asBuilder()\n+                    .setAttemptFailedInJoinAsOr(shouldAttemptInAsOr)\n+                    .build());\n+\n+            RecordQueryPlan plan = planner.plan(query);\n+            if (shouldAttemptInAsOr) {\n+                // IN join is impossible because of incompatible sorting, but we can still plan as an OR on the compound index.\n+                assertThat(plan, union(inList.stream().map(number -> indexScan(allOf(indexName(\"compoundIndex\"),\n+                        bounds(hasTupleString(String.format(\"[[%d],[%d]]\", number, number)))))).collect(Collectors.toList()),\n+                        equalTo(concat(field(\"str_value_indexed\"), primaryKey(\"MySimpleRecord\")))));\n+                assertEquals(-1813975352, plan.planHash());\n+            } else {\n+                assertThat(plan, filter(equalTo(query.getFilter()), indexScan(allOf(indexName(\"MySimpleRecord$str_value_indexed\"), unbounded()))));\n+                assertEquals(1775865786, plan.planHash());\n+            }\n+\n+            assertEquals(60, querySimpleRecordStore(hook, plan, EvaluationContext::empty,\n+                    record -> assertThat(record.getNumValue3Indexed(), anyOf(is(1), is(2), is(4))),\n+                    context -> TestHelpers.assertDiscardedAtMost(40, context)));\n+        }\n+    }\n+\n+    /**\n+     * Verify that an IN predicate that, when converted to an OR of equality predicates, would lead to a very large DNF\n+     * gets planned as a normal IN query rather than throwing an exception.\n+     */\n+    @Test\n+    public void cnfAsInQuery() throws Exception {\n+        RecordMetaDataHook hook = metaData ->\n+                metaData.addIndex(\"MySimpleRecord\", \"compoundIndex\",\n+                        concat(field(\"num_value_3_indexed\"), field(\"str_value_indexed\")));\n+        complexQuerySetup(hook);\n+\n+        // A CNF who's DNF size doesn't fit in an int, expressed with IN predicates.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0546106d225ce2c1e9e61012ad27bb0f6298d4b1"}, "originalPosition": 85}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODA1ODExNQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            RecordMetaData.newBuilder().setRecords(TestRecordsEnumProto.getDescriptor()).build(),\n          \n          \n            \n                            RecordMetaData.build(TestRecordsEnumProto.getDescriptor()),\n          \n      \n    \n    \n  \n\nEquivalent, but perhaps more idiomatic", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/861#discussion_r398058115", "createdAt": "2020-03-25T17:57:34Z", "author": {"login": "alecgrieser"}, "path": "fdb-record-layer-core/src/test/java/com/apple/foundationdb/record/query/plan/RecordQueryPlannerConfigurationTest.java", "diffHunk": "@@ -0,0 +1,73 @@\n+/*\n+ * RecordQueryPlannerConfigurationTest.java\n+ *\n+ * This source file is part of the FoundationDB open source project\n+ *\n+ * Copyright 2015-2020 Apple Inc. and the FoundationDB project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.apple.foundationdb.record.query.plan;\n+\n+import com.apple.foundationdb.record.RecordMetaData;\n+import com.apple.foundationdb.record.RecordStoreState;\n+import com.apple.foundationdb.record.TestRecordsEnumProto;\n+import org.junit.jupiter.api.Test;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+/**\n+ * Test of the semantics of setting configuration options on {@link RecordQueryPlanner}.\n+ * This is mostly \"executable documentation\" that makes sure that we never change the contract without meaning to.\n+ */\n+public class RecordQueryPlannerConfigurationTest {\n+    private static RecordQueryPlanner blankPlanner() {\n+        return new RecordQueryPlanner(\n+                RecordMetaData.newBuilder().setRecords(TestRecordsEnumProto.getDescriptor()).build(),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0546106d225ce2c1e9e61012ad27bb0f6298d4b1"}, "originalPosition": 38}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "797dec751b53066061becd3fe238b94c282aacfb", "author": {"user": {"login": "nschiefer", "name": "Nicholas Schiefer"}}, "url": "https://github.com/FoundationDB/fdb-record-layer/commit/797dec751b53066061becd3fe238b94c282aacfb", "committedDate": "2020-03-25T18:43:29Z", "message": "Respond to review comments."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzgxNDQ0ODU1", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/861#pullrequestreview-381444855", "createdAt": "2020-03-25T18:54:03Z", "commit": {"oid": "797dec751b53066061becd3fe238b94c282aacfb"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2544, "cost": 1, "resetAt": "2021-11-01T14:20:25Z"}}}