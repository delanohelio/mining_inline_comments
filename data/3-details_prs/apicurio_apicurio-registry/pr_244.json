{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzY4MDMxNjcz", "number": 244, "title": "Implemented JSON Schema serde support", "bodyText": "", "createdAt": "2020-01-28T14:04:40Z", "url": "https://github.com/Apicurio/apicurio-registry/pull/244", "merged": true, "mergeCommit": {"oid": "3672be917fda1e7c730b6127f812435fd615adfb"}, "closed": true, "closedAt": "2020-01-29T14:50:41Z", "author": {"login": "EricWittmann"}, "timelineItems": {"totalCount": 16, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABb9kuOfgH2gAyMzY4MDMxNjczOjgxNDYxNzJkYTQyYjNmYjUyMmFlYjQ3MTRmYjVmYzM1YzE1ZTBmNzU=", "endCursor": "Y3Vyc29yOnYyOpPPAAABb_GSMwAH2gAyMzY4MDMxNjczOmY1ZGQyZGQwMTBmYjMxMTE2MDcxNzRlNjk3YzQzMTA4ZjMyMTg0YTg=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "8146172da42b3fb522aeb4714fb5fc35c15e0f75", "author": {"user": {"login": "EricWittmann", "name": "Eric Wittmann"}}, "url": "https://github.com/Apicurio/apicurio-registry/commit/8146172da42b3fb522aeb4714fb5fc35c15e0f75", "committedDate": "2020-01-24T20:11:23Z", "message": "Initial impl of \"serde\" for JSON Schema.  Fixes #180"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "bc40f115f0961e3467f9d1614f7d4f6be7c7f2f8", "author": {"user": {"login": "EricWittmann", "name": "Eric Wittmann"}}, "url": "https://github.com/Apicurio/apicurio-registry/commit/bc40f115f0961e3467f9d1614f7d4f6be7c7f2f8", "committedDate": "2020-01-27T19:21:04Z", "message": "updates to the JSON Schema serde based on feedback"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzUwMDY4ODQ2", "url": "https://github.com/Apicurio/apicurio-registry/pull/244#pullrequestreview-350068846", "createdAt": "2020-01-29T12:28:27Z", "commit": {"oid": "bc40f115f0961e3467f9d1614f7d4f6be7c7f2f8"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yOVQxMjoyODoyN1rOFjGr9A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yOVQxMjoyODoyN1rOFjGr9A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjM1NDAzNg==", "bodyText": "Should not be needed ... getIdHandler() takes care of null ...", "url": "https://github.com/Apicurio/apicurio-registry/pull/244#discussion_r372354036", "createdAt": "2020-01-29T12:28:27Z", "author": {"login": "alesj"}, "path": "utils/serde/src/main/java/io/apicurio/registry/utils/serde/AbstractKafkaSerDe.java", "diffHunk": "@@ -109,6 +107,9 @@ protected void configure(Map<String, ?> configs) {\n         }\n         if (idHandler == null) {\n             Object idh = configs.get(REGISTRY_ID_HANDLER_CONFIG_PARAM);\n+            if (idh == null) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bc40f115f0961e3467f9d1614f7d4f6be7c7f2f8"}, "originalPosition": 22}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzUwMDcwNjY0", "url": "https://github.com/Apicurio/apicurio-registry/pull/244#pullrequestreview-350070664", "createdAt": "2020-01-29T12:31:53Z", "commit": {"oid": "bc40f115f0961e3467f9d1614f7d4f6be7c7f2f8"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yOVQxMjozMTo1M1rOFjGxIg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yOVQxMjozMTo1M1rOFjGxIg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjM1NTM2Mg==", "bodyText": "Just use ByteBuffer.allocate(header.value()) ?", "url": "https://github.com/Apicurio/apicurio-registry/pull/244#discussion_r372355362", "createdAt": "2020-01-29T12:31:53Z", "author": {"login": "alesj"}, "path": "utils/serde/src/main/java/io/apicurio/registry/utils/serde/JsonSchemaKafkaDeserializer.java", "diffHunk": "@@ -0,0 +1,217 @@\n+/*\n+ * Copyright 2020 Red Hat\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.apicurio.registry.utils.serde;\n+\n+import java.io.IOException;\n+import java.io.UncheckedIOException;\n+import java.nio.ByteBuffer;\n+import java.nio.charset.StandardCharsets;\n+import java.util.Map;\n+\n+import javax.ws.rs.core.Response;\n+\n+import org.apache.kafka.common.header.Header;\n+import org.apache.kafka.common.header.Headers;\n+import org.apache.kafka.common.serialization.Deserializer;\n+\n+import com.fasterxml.jackson.core.JsonParser;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.worldturner.medeia.api.StringSchemaSource;\n+import com.worldturner.medeia.api.jackson.MedeiaJacksonApi;\n+import com.worldturner.medeia.schema.validation.SchemaValidator;\n+\n+import io.apicurio.registry.client.RegistryService;\n+import io.apicurio.registry.rest.beans.ArtifactMetaData;\n+import io.apicurio.registry.rest.beans.VersionMetaData;\n+import io.apicurio.registry.utils.serde.util.Utils;\n+\n+/**\n+ * @author eric.wittmann@gmail.com\n+ */\n+public class JsonSchemaKafkaDeserializer<T> extends AbstractKafkaSerDe<JsonSchemaKafkaDeserializer<T>> implements Deserializer<T> {\n+\n+    public static final String REGISTRY_JSON_SCHEMA_DESERIALIZER_VALIDATION_ENABLED = \"apicurio.registry.serdes.json-schema.validation-enabled\";\n+\n+    private static MedeiaJacksonApi api = new MedeiaJacksonApi();\n+    private static ObjectMapper mapper = new ObjectMapper();\n+    \n+    private boolean validationEnabled = false;\n+    private SchemaCache<SchemaValidator> schemaCache;\n+\n+    /**\n+     * Constructor.\n+     */\n+    public JsonSchemaKafkaDeserializer() {\n+        this(null);\n+    }\n+\n+    /**\n+     * Constructor.\n+     * @param client\n+     */\n+    public JsonSchemaKafkaDeserializer(RegistryService client) {\n+        super(client);\n+    }\n+\n+    /**\n+     * @see org.apache.kafka.common.serialization.Deserializer#configure(java.util.Map, boolean)\n+     */\n+    @Override\n+    public void configure(Map<String, ?> configs, boolean isKey) {\n+        super.configure(configs);\n+\n+        Object ve = configs.get(REGISTRY_JSON_SCHEMA_DESERIALIZER_VALIDATION_ENABLED);\n+        this.validationEnabled = Utils.isTrue(ve);\n+\n+        this.schemaCache = new SchemaCache<SchemaValidator>(getClient()) {\n+            @Override\n+            protected SchemaValidator toSchema(Response response) {\n+                String schema = response.readEntity(String.class);\n+                return api.loadSchema(new StringSchemaSource(schema));\n+            }\n+        };\n+    }\n+    \n+    /**\n+     * @see org.apache.kafka.common.serialization.Deserializer#deserialize(java.lang.String, byte[])\n+     */\n+    @Override\n+    public T deserialize(String topic, byte[] data) {\n+        throw new UnsupportedOperationException();\n+    }\n+    \n+    /**\n+     * @see org.apache.kafka.common.serialization.Deserializer#deserialize(java.lang.String, org.apache.kafka.common.header.Headers, byte[])\n+     */\n+    @Override\n+    public T deserialize(String topic, Headers headers, byte[] data) {\n+        if (data == null) {\n+            return null;\n+        }\n+        \n+        try {\n+            JsonParser parser = mapper.getFactory().createParser(data);\n+            if (validationEnabled) {\n+                Long globalId = getGlobalId(headers);\n+                \n+                // If no globalId is provided, check the alternative - which is to check for artifactId and \n+                // (optionally) version.  If these are found, then convert that info to globalId.\n+                if (globalId == null) {\n+                    String artifactId = getArtifactId(headers);\n+                    Integer version = getVersion(headers);\n+                    if (version == null) {\n+                        version = getLatestVersion(artifactId);\n+                    }\n+                    globalId = toGlobalId(artifactId, version);\n+                }\n+                \n+                SchemaValidator schema = schemaCache.getSchema(globalId);\n+                parser = api.decorateJsonParser(schema, parser);\n+            }\n+            \n+            Class<T> messageType = getMessageType(headers);\n+\n+            return mapper.readValue(parser, messageType);\n+        } catch (IOException e) {\n+            throw new UncheckedIOException(e);\n+        }\n+    }\n+\n+    /**\n+     * Gets the global id from the headers.  Returns null if not found.\n+     * @param headers\n+     */\n+    protected Long getGlobalId(Headers headers) {\n+        Header header = headers.lastHeader(JsonSchemaSerDeConstants.HEADER_GLOBAL_ID);\n+        if (header == null) {\n+            return null;\n+        }\n+        ByteBuffer buffer = ByteBuffer.allocate(8);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bc40f115f0961e3467f9d1614f7d4f6be7c7f2f8"}, "originalPosition": 143}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzUwMDcxMTM3", "url": "https://github.com/Apicurio/apicurio-registry/pull/244#pullrequestreview-350071137", "createdAt": "2020-01-29T12:32:45Z", "commit": {"oid": "bc40f115f0961e3467f9d1614f7d4f6be7c7f2f8"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yOVQxMjozMjo0NVrOFjGyqQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yOVQxMjozMjo0NVrOFjGyqQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjM1NTc1Mw==", "bodyText": "Use IoUtils to handle byte[] --> String ...\n(a single place to handle such things)", "url": "https://github.com/Apicurio/apicurio-registry/pull/244#discussion_r372355753", "createdAt": "2020-01-29T12:32:45Z", "author": {"login": "alesj"}, "path": "utils/serde/src/main/java/io/apicurio/registry/utils/serde/JsonSchemaKafkaDeserializer.java", "diffHunk": "@@ -0,0 +1,217 @@\n+/*\n+ * Copyright 2020 Red Hat\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.apicurio.registry.utils.serde;\n+\n+import java.io.IOException;\n+import java.io.UncheckedIOException;\n+import java.nio.ByteBuffer;\n+import java.nio.charset.StandardCharsets;\n+import java.util.Map;\n+\n+import javax.ws.rs.core.Response;\n+\n+import org.apache.kafka.common.header.Header;\n+import org.apache.kafka.common.header.Headers;\n+import org.apache.kafka.common.serialization.Deserializer;\n+\n+import com.fasterxml.jackson.core.JsonParser;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.worldturner.medeia.api.StringSchemaSource;\n+import com.worldturner.medeia.api.jackson.MedeiaJacksonApi;\n+import com.worldturner.medeia.schema.validation.SchemaValidator;\n+\n+import io.apicurio.registry.client.RegistryService;\n+import io.apicurio.registry.rest.beans.ArtifactMetaData;\n+import io.apicurio.registry.rest.beans.VersionMetaData;\n+import io.apicurio.registry.utils.serde.util.Utils;\n+\n+/**\n+ * @author eric.wittmann@gmail.com\n+ */\n+public class JsonSchemaKafkaDeserializer<T> extends AbstractKafkaSerDe<JsonSchemaKafkaDeserializer<T>> implements Deserializer<T> {\n+\n+    public static final String REGISTRY_JSON_SCHEMA_DESERIALIZER_VALIDATION_ENABLED = \"apicurio.registry.serdes.json-schema.validation-enabled\";\n+\n+    private static MedeiaJacksonApi api = new MedeiaJacksonApi();\n+    private static ObjectMapper mapper = new ObjectMapper();\n+    \n+    private boolean validationEnabled = false;\n+    private SchemaCache<SchemaValidator> schemaCache;\n+\n+    /**\n+     * Constructor.\n+     */\n+    public JsonSchemaKafkaDeserializer() {\n+        this(null);\n+    }\n+\n+    /**\n+     * Constructor.\n+     * @param client\n+     */\n+    public JsonSchemaKafkaDeserializer(RegistryService client) {\n+        super(client);\n+    }\n+\n+    /**\n+     * @see org.apache.kafka.common.serialization.Deserializer#configure(java.util.Map, boolean)\n+     */\n+    @Override\n+    public void configure(Map<String, ?> configs, boolean isKey) {\n+        super.configure(configs);\n+\n+        Object ve = configs.get(REGISTRY_JSON_SCHEMA_DESERIALIZER_VALIDATION_ENABLED);\n+        this.validationEnabled = Utils.isTrue(ve);\n+\n+        this.schemaCache = new SchemaCache<SchemaValidator>(getClient()) {\n+            @Override\n+            protected SchemaValidator toSchema(Response response) {\n+                String schema = response.readEntity(String.class);\n+                return api.loadSchema(new StringSchemaSource(schema));\n+            }\n+        };\n+    }\n+    \n+    /**\n+     * @see org.apache.kafka.common.serialization.Deserializer#deserialize(java.lang.String, byte[])\n+     */\n+    @Override\n+    public T deserialize(String topic, byte[] data) {\n+        throw new UnsupportedOperationException();\n+    }\n+    \n+    /**\n+     * @see org.apache.kafka.common.serialization.Deserializer#deserialize(java.lang.String, org.apache.kafka.common.header.Headers, byte[])\n+     */\n+    @Override\n+    public T deserialize(String topic, Headers headers, byte[] data) {\n+        if (data == null) {\n+            return null;\n+        }\n+        \n+        try {\n+            JsonParser parser = mapper.getFactory().createParser(data);\n+            if (validationEnabled) {\n+                Long globalId = getGlobalId(headers);\n+                \n+                // If no globalId is provided, check the alternative - which is to check for artifactId and \n+                // (optionally) version.  If these are found, then convert that info to globalId.\n+                if (globalId == null) {\n+                    String artifactId = getArtifactId(headers);\n+                    Integer version = getVersion(headers);\n+                    if (version == null) {\n+                        version = getLatestVersion(artifactId);\n+                    }\n+                    globalId = toGlobalId(artifactId, version);\n+                }\n+                \n+                SchemaValidator schema = schemaCache.getSchema(globalId);\n+                parser = api.decorateJsonParser(schema, parser);\n+            }\n+            \n+            Class<T> messageType = getMessageType(headers);\n+\n+            return mapper.readValue(parser, messageType);\n+        } catch (IOException e) {\n+            throw new UncheckedIOException(e);\n+        }\n+    }\n+\n+    /**\n+     * Gets the global id from the headers.  Returns null if not found.\n+     * @param headers\n+     */\n+    protected Long getGlobalId(Headers headers) {\n+        Header header = headers.lastHeader(JsonSchemaSerDeConstants.HEADER_GLOBAL_ID);\n+        if (header == null) {\n+            return null;\n+        }\n+        ByteBuffer buffer = ByteBuffer.allocate(8);\n+        buffer.put(header.value());\n+        buffer.position(0);\n+        return buffer.getLong();\n+    }\n+\n+    /**\n+     * Gets the artifact id from the headers.  Throws if not found.\n+     * @param headers\n+     */\n+    protected String getArtifactId(Headers headers) {\n+        Header header = headers.lastHeader(JsonSchemaSerDeConstants.HEADER_ARTIFACT_ID);\n+        if (header == null) {\n+            throw new RuntimeException(\"ArtifactId not found in headers.\");\n+        }\n+        return new String(header.value(), StandardCharsets.UTF_8);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bc40f115f0961e3467f9d1614f7d4f6be7c7f2f8"}, "originalPosition": 158}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzUwMDcyMzI1", "url": "https://github.com/Apicurio/apicurio-registry/pull/244#pullrequestreview-350072325", "createdAt": "2020-01-29T12:35:01Z", "commit": {"oid": "bc40f115f0961e3467f9d1614f7d4f6be7c7f2f8"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yOVQxMjozNTowMVrOFjG2TA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yOVQxMjozNTowMVrOFjG2TA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjM1NjY4NA==", "bodyText": "No need for this call ... just diff between when looking up metadata when you have the version and when not == single call.", "url": "https://github.com/Apicurio/apicurio-registry/pull/244#discussion_r372356684", "createdAt": "2020-01-29T12:35:01Z", "author": {"login": "alesj"}, "path": "utils/serde/src/main/java/io/apicurio/registry/utils/serde/JsonSchemaKafkaDeserializer.java", "diffHunk": "@@ -0,0 +1,217 @@\n+/*\n+ * Copyright 2020 Red Hat\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.apicurio.registry.utils.serde;\n+\n+import java.io.IOException;\n+import java.io.UncheckedIOException;\n+import java.nio.ByteBuffer;\n+import java.nio.charset.StandardCharsets;\n+import java.util.Map;\n+\n+import javax.ws.rs.core.Response;\n+\n+import org.apache.kafka.common.header.Header;\n+import org.apache.kafka.common.header.Headers;\n+import org.apache.kafka.common.serialization.Deserializer;\n+\n+import com.fasterxml.jackson.core.JsonParser;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.worldturner.medeia.api.StringSchemaSource;\n+import com.worldturner.medeia.api.jackson.MedeiaJacksonApi;\n+import com.worldturner.medeia.schema.validation.SchemaValidator;\n+\n+import io.apicurio.registry.client.RegistryService;\n+import io.apicurio.registry.rest.beans.ArtifactMetaData;\n+import io.apicurio.registry.rest.beans.VersionMetaData;\n+import io.apicurio.registry.utils.serde.util.Utils;\n+\n+/**\n+ * @author eric.wittmann@gmail.com\n+ */\n+public class JsonSchemaKafkaDeserializer<T> extends AbstractKafkaSerDe<JsonSchemaKafkaDeserializer<T>> implements Deserializer<T> {\n+\n+    public static final String REGISTRY_JSON_SCHEMA_DESERIALIZER_VALIDATION_ENABLED = \"apicurio.registry.serdes.json-schema.validation-enabled\";\n+\n+    private static MedeiaJacksonApi api = new MedeiaJacksonApi();\n+    private static ObjectMapper mapper = new ObjectMapper();\n+    \n+    private boolean validationEnabled = false;\n+    private SchemaCache<SchemaValidator> schemaCache;\n+\n+    /**\n+     * Constructor.\n+     */\n+    public JsonSchemaKafkaDeserializer() {\n+        this(null);\n+    }\n+\n+    /**\n+     * Constructor.\n+     * @param client\n+     */\n+    public JsonSchemaKafkaDeserializer(RegistryService client) {\n+        super(client);\n+    }\n+\n+    /**\n+     * @see org.apache.kafka.common.serialization.Deserializer#configure(java.util.Map, boolean)\n+     */\n+    @Override\n+    public void configure(Map<String, ?> configs, boolean isKey) {\n+        super.configure(configs);\n+\n+        Object ve = configs.get(REGISTRY_JSON_SCHEMA_DESERIALIZER_VALIDATION_ENABLED);\n+        this.validationEnabled = Utils.isTrue(ve);\n+\n+        this.schemaCache = new SchemaCache<SchemaValidator>(getClient()) {\n+            @Override\n+            protected SchemaValidator toSchema(Response response) {\n+                String schema = response.readEntity(String.class);\n+                return api.loadSchema(new StringSchemaSource(schema));\n+            }\n+        };\n+    }\n+    \n+    /**\n+     * @see org.apache.kafka.common.serialization.Deserializer#deserialize(java.lang.String, byte[])\n+     */\n+    @Override\n+    public T deserialize(String topic, byte[] data) {\n+        throw new UnsupportedOperationException();\n+    }\n+    \n+    /**\n+     * @see org.apache.kafka.common.serialization.Deserializer#deserialize(java.lang.String, org.apache.kafka.common.header.Headers, byte[])\n+     */\n+    @Override\n+    public T deserialize(String topic, Headers headers, byte[] data) {\n+        if (data == null) {\n+            return null;\n+        }\n+        \n+        try {\n+            JsonParser parser = mapper.getFactory().createParser(data);\n+            if (validationEnabled) {\n+                Long globalId = getGlobalId(headers);\n+                \n+                // If no globalId is provided, check the alternative - which is to check for artifactId and \n+                // (optionally) version.  If these are found, then convert that info to globalId.\n+                if (globalId == null) {\n+                    String artifactId = getArtifactId(headers);\n+                    Integer version = getVersion(headers);\n+                    if (version == null) {\n+                        version = getLatestVersion(artifactId);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bc40f115f0961e3467f9d1614f7d4f6be7c7f2f8"}, "originalPosition": 117}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzUwMDcyOTg2", "url": "https://github.com/Apicurio/apicurio-registry/pull/244#pullrequestreview-350072986", "createdAt": "2020-01-29T12:36:13Z", "commit": {"oid": "bc40f115f0961e3467f9d1614f7d4f6be7c7f2f8"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yOVQxMjozNjoxM1rOFjG4Sw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yOVQxMjozNjoxM1rOFjG4Sw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjM1NzE5NQ==", "bodyText": "There is already an instance of GlobalIdStrategy in AbstractKafkaStrategyAwareSerDe ... which this class extends, so I would just use that one.", "url": "https://github.com/Apicurio/apicurio-registry/pull/244#discussion_r372357195", "createdAt": "2020-01-29T12:36:13Z", "author": {"login": "alesj"}, "path": "utils/serde/src/main/java/io/apicurio/registry/utils/serde/JsonSchemaKafkaSerializer.java", "diffHunk": "@@ -0,0 +1,188 @@\n+/*\n+ * Copyright 2020 Red Hat\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.apicurio.registry.utils.serde;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.nio.charset.StandardCharsets;\n+import java.util.Map;\n+\n+import javax.ws.rs.core.Response;\n+\n+import org.apache.kafka.common.errors.SerializationException;\n+import org.apache.kafka.common.header.Headers;\n+import org.apache.kafka.common.serialization.Serializer;\n+\n+import com.fasterxml.jackson.core.JsonGenerator;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.worldturner.medeia.api.StringSchemaSource;\n+import com.worldturner.medeia.api.jackson.MedeiaJacksonApi;\n+import com.worldturner.medeia.schema.validation.SchemaValidator;\n+\n+import io.apicurio.registry.client.RegistryService;\n+import io.apicurio.registry.types.ArtifactType;\n+import io.apicurio.registry.utils.serde.strategy.FindLatestIdStrategy;\n+import io.apicurio.registry.utils.serde.strategy.GlobalIdStrategy;\n+import io.apicurio.registry.utils.serde.util.Utils;\n+\n+/**\n+ * An implementation of the Kafka Serializer for JSON Schema use-cases. This serializer assumes that the\n+ * user's application needs to serialize a Java Bean to JSON data using Jackson. In addition to standard\n+ * serialization of the bean, this implementation can also optionally validate it against a JSON schema.\n+ * \n+ * @author eric.wittmann@gmail.com\n+ */\n+public class JsonSchemaKafkaSerializer<T>\n+        extends AbstractKafkaStrategyAwareSerDe<SchemaValidator, JsonSchemaKafkaSerializer<T>>\n+        implements Serializer<T> {\n+    \n+    public static final String REGISTRY_JSON_SCHEMA_SERIALIZER_VALIDATION_ENABLED = \"apicurio.registry.serdes.json-schema.validation-enabled\";\n+\n+    private static MedeiaJacksonApi api = new MedeiaJacksonApi();\n+    private static ObjectMapper mapper = new ObjectMapper();\n+    private static GlobalIdStrategy<SchemaValidator> latestVersionStrategy = new FindLatestIdStrategy<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bc40f115f0961e3467f9d1614f7d4f6be7c7f2f8"}, "originalPosition": 58}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzUwMDc0MDEz", "url": "https://github.com/Apicurio/apicurio-registry/pull/244#pullrequestreview-350074013", "createdAt": "2020-01-29T12:37:58Z", "commit": {"oid": "bc40f115f0961e3467f9d1614f7d4f6be7c7f2f8"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yOVQxMjozNzo1OFrOFjG7eA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yOVQxMjozNzo1OFrOFjG7eA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjM1ODAwOA==", "bodyText": "Cache needs to be instantiated outside configure() ... as this method might not be called -- when this deserializer is instantiated outside Kafka code.", "url": "https://github.com/Apicurio/apicurio-registry/pull/244#discussion_r372358008", "createdAt": "2020-01-29T12:37:58Z", "author": {"login": "alesj"}, "path": "utils/serde/src/main/java/io/apicurio/registry/utils/serde/JsonSchemaKafkaDeserializer.java", "diffHunk": "@@ -0,0 +1,217 @@\n+/*\n+ * Copyright 2020 Red Hat\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.apicurio.registry.utils.serde;\n+\n+import java.io.IOException;\n+import java.io.UncheckedIOException;\n+import java.nio.ByteBuffer;\n+import java.nio.charset.StandardCharsets;\n+import java.util.Map;\n+\n+import javax.ws.rs.core.Response;\n+\n+import org.apache.kafka.common.header.Header;\n+import org.apache.kafka.common.header.Headers;\n+import org.apache.kafka.common.serialization.Deserializer;\n+\n+import com.fasterxml.jackson.core.JsonParser;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.worldturner.medeia.api.StringSchemaSource;\n+import com.worldturner.medeia.api.jackson.MedeiaJacksonApi;\n+import com.worldturner.medeia.schema.validation.SchemaValidator;\n+\n+import io.apicurio.registry.client.RegistryService;\n+import io.apicurio.registry.rest.beans.ArtifactMetaData;\n+import io.apicurio.registry.rest.beans.VersionMetaData;\n+import io.apicurio.registry.utils.serde.util.Utils;\n+\n+/**\n+ * @author eric.wittmann@gmail.com\n+ */\n+public class JsonSchemaKafkaDeserializer<T> extends AbstractKafkaSerDe<JsonSchemaKafkaDeserializer<T>> implements Deserializer<T> {\n+\n+    public static final String REGISTRY_JSON_SCHEMA_DESERIALIZER_VALIDATION_ENABLED = \"apicurio.registry.serdes.json-schema.validation-enabled\";\n+\n+    private static MedeiaJacksonApi api = new MedeiaJacksonApi();\n+    private static ObjectMapper mapper = new ObjectMapper();\n+    \n+    private boolean validationEnabled = false;\n+    private SchemaCache<SchemaValidator> schemaCache;\n+\n+    /**\n+     * Constructor.\n+     */\n+    public JsonSchemaKafkaDeserializer() {\n+        this(null);\n+    }\n+\n+    /**\n+     * Constructor.\n+     * @param client\n+     */\n+    public JsonSchemaKafkaDeserializer(RegistryService client) {\n+        super(client);\n+    }\n+\n+    /**\n+     * @see org.apache.kafka.common.serialization.Deserializer#configure(java.util.Map, boolean)\n+     */\n+    @Override\n+    public void configure(Map<String, ?> configs, boolean isKey) {\n+        super.configure(configs);\n+\n+        Object ve = configs.get(REGISTRY_JSON_SCHEMA_DESERIALIZER_VALIDATION_ENABLED);\n+        this.validationEnabled = Utils.isTrue(ve);\n+\n+        this.schemaCache = new SchemaCache<SchemaValidator>(getClient()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bc40f115f0961e3467f9d1614f7d4f6be7c7f2f8"}, "originalPosition": 80}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzUwMDc1NDAy", "url": "https://github.com/Apicurio/apicurio-registry/pull/244#pullrequestreview-350075402", "createdAt": "2020-01-29T12:40:30Z", "commit": {"oid": "bc40f115f0961e3467f9d1614f7d4f6be7c7f2f8"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yOVQxMjo0MDozMVrOFjG_jA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yOVQxMjo0MDozMVrOFjG_jA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjM1OTA1Mg==", "bodyText": "Perhaps a common constant for both serde ?", "url": "https://github.com/Apicurio/apicurio-registry/pull/244#discussion_r372359052", "createdAt": "2020-01-29T12:40:31Z", "author": {"login": "alesj"}, "path": "utils/serde/src/main/java/io/apicurio/registry/utils/serde/JsonSchemaKafkaSerializer.java", "diffHunk": "@@ -0,0 +1,188 @@\n+/*\n+ * Copyright 2020 Red Hat\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.apicurio.registry.utils.serde;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.nio.charset.StandardCharsets;\n+import java.util.Map;\n+\n+import javax.ws.rs.core.Response;\n+\n+import org.apache.kafka.common.errors.SerializationException;\n+import org.apache.kafka.common.header.Headers;\n+import org.apache.kafka.common.serialization.Serializer;\n+\n+import com.fasterxml.jackson.core.JsonGenerator;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.worldturner.medeia.api.StringSchemaSource;\n+import com.worldturner.medeia.api.jackson.MedeiaJacksonApi;\n+import com.worldturner.medeia.schema.validation.SchemaValidator;\n+\n+import io.apicurio.registry.client.RegistryService;\n+import io.apicurio.registry.types.ArtifactType;\n+import io.apicurio.registry.utils.serde.strategy.FindLatestIdStrategy;\n+import io.apicurio.registry.utils.serde.strategy.GlobalIdStrategy;\n+import io.apicurio.registry.utils.serde.util.Utils;\n+\n+/**\n+ * An implementation of the Kafka Serializer for JSON Schema use-cases. This serializer assumes that the\n+ * user's application needs to serialize a Java Bean to JSON data using Jackson. In addition to standard\n+ * serialization of the bean, this implementation can also optionally validate it against a JSON schema.\n+ * \n+ * @author eric.wittmann@gmail.com\n+ */\n+public class JsonSchemaKafkaSerializer<T>\n+        extends AbstractKafkaStrategyAwareSerDe<SchemaValidator, JsonSchemaKafkaSerializer<T>>\n+        implements Serializer<T> {\n+    \n+    public static final String REGISTRY_JSON_SCHEMA_SERIALIZER_VALIDATION_ENABLED = \"apicurio.registry.serdes.json-schema.validation-enabled\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bc40f115f0961e3467f9d1614f7d4f6be7c7f2f8"}, "originalPosition": 54}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzUwMDgxMDYy", "url": "https://github.com/Apicurio/apicurio-registry/pull/244#pullrequestreview-350081062", "createdAt": "2020-01-29T12:50:39Z", "commit": {"oid": "bc40f115f0961e3467f9d1614f7d4f6be7c7f2f8"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yOVQxMjo1MDozOVrOFjHQaA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yOVQxMjo1MDozOVrOFjHQaA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjM2MzM2OA==", "bodyText": "Hmmm ... why exactly 2 tries ?", "url": "https://github.com/Apicurio/apicurio-registry/pull/244#discussion_r372363368", "createdAt": "2020-01-29T12:50:39Z", "author": {"login": "alesj"}, "path": "utils/serde/src/main/java/io/apicurio/registry/utils/serde/JsonSchemaKafkaSerializer.java", "diffHunk": "@@ -0,0 +1,188 @@\n+/*\n+ * Copyright 2020 Red Hat\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.apicurio.registry.utils.serde;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.nio.charset.StandardCharsets;\n+import java.util.Map;\n+\n+import javax.ws.rs.core.Response;\n+\n+import org.apache.kafka.common.errors.SerializationException;\n+import org.apache.kafka.common.header.Headers;\n+import org.apache.kafka.common.serialization.Serializer;\n+\n+import com.fasterxml.jackson.core.JsonGenerator;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.worldturner.medeia.api.StringSchemaSource;\n+import com.worldturner.medeia.api.jackson.MedeiaJacksonApi;\n+import com.worldturner.medeia.schema.validation.SchemaValidator;\n+\n+import io.apicurio.registry.client.RegistryService;\n+import io.apicurio.registry.types.ArtifactType;\n+import io.apicurio.registry.utils.serde.strategy.FindLatestIdStrategy;\n+import io.apicurio.registry.utils.serde.strategy.GlobalIdStrategy;\n+import io.apicurio.registry.utils.serde.util.Utils;\n+\n+/**\n+ * An implementation of the Kafka Serializer for JSON Schema use-cases. This serializer assumes that the\n+ * user's application needs to serialize a Java Bean to JSON data using Jackson. In addition to standard\n+ * serialization of the bean, this implementation can also optionally validate it against a JSON schema.\n+ * \n+ * @author eric.wittmann@gmail.com\n+ */\n+public class JsonSchemaKafkaSerializer<T>\n+        extends AbstractKafkaStrategyAwareSerDe<SchemaValidator, JsonSchemaKafkaSerializer<T>>\n+        implements Serializer<T> {\n+    \n+    public static final String REGISTRY_JSON_SCHEMA_SERIALIZER_VALIDATION_ENABLED = \"apicurio.registry.serdes.json-schema.validation-enabled\";\n+\n+    private static MedeiaJacksonApi api = new MedeiaJacksonApi();\n+    private static ObjectMapper mapper = new ObjectMapper();\n+    private static GlobalIdStrategy<SchemaValidator> latestVersionStrategy = new FindLatestIdStrategy<>();\n+    \n+    private boolean validationEnabled = false;\n+    private SchemaCache<SchemaValidator> schemaCache;\n+\n+    /**\n+     * Constructor.\n+     */\n+    public JsonSchemaKafkaSerializer() {\n+    }\n+\n+    /**\n+     * Constructor.\n+     * @param client\n+     */\n+    public JsonSchemaKafkaSerializer(RegistryService client) {\n+        super(client);\n+    }\n+\n+    /**\n+     * @see org.apache.kafka.common.serialization.Serializer#configure(java.util.Map, boolean)\n+     */\n+    @Override\n+    public void configure(Map<String, ?> configs, boolean isKey) {\n+        super.configure(configs, isKey);\n+        \n+        Object ve = configs.get(REGISTRY_JSON_SCHEMA_SERIALIZER_VALIDATION_ENABLED);\n+        this.validationEnabled = Utils.isTrue(ve);\n+        \n+        this.schemaCache = new SchemaCache<SchemaValidator>(getClient()) {\n+            @Override\n+            protected SchemaValidator toSchema(Response response) {\n+                String schema = response.readEntity(String.class);\n+                return api.loadSchema(new StringSchemaSource(schema));\n+            }\n+        };\n+    }\n+    \n+    /**\n+     * @see org.apache.kafka.common.serialization.Serializer#serialize(java.lang.String, java.lang.Object)\n+     */\n+    @Override\n+    public byte[] serialize(String topic, T data) {\n+        // Headers are required when sending data using this serdes impl\n+        throw new UnsupportedOperationException();\n+    }\n+    \n+    /**\n+     * @see org.apache.kafka.common.serialization.Serializer#serialize(java.lang.String, org.apache.kafka.common.header.Headers, java.lang.Object)\n+     */\n+    @Override\n+    public byte[] serialize(String topic, Headers headers, T data) {\n+        if (data == null) {\n+            return new byte[0];\n+        }\n+\n+        // Now serialize the data\n+        try {\n+            ByteArrayOutputStream baos = new ByteArrayOutputStream();\n+            JsonGenerator generator = mapper.getFactory().createGenerator(baos);\n+            if (validationEnabled) {\n+                String artifactId = getArtifactId(topic, data);\n+                Long globalId = getArtifactVersionGlobalId(artifactId, topic, data);\n+                if (globalId == null) {\n+                    globalId = latestVersionStrategy.findId(getClient(), artifactId, ArtifactType.JSON, null);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bc40f115f0961e3467f9d1614f7d4f6be7c7f2f8"}, "originalPosition": 122}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzUwMDgyNTEw", "url": "https://github.com/Apicurio/apicurio-registry/pull/244#pullrequestreview-350082510", "createdAt": "2020-01-29T12:53:08Z", "commit": {"oid": "bc40f115f0961e3467f9d1614f7d4f6be7c7f2f8"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yOVQxMjo1MzowOFrOFjHU1w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yOVQxMjo1MzowOFrOFjHU1w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjM2NDUwMw==", "bodyText": "We said we're gonna add another strategy for this - ToStreamStrategy ...", "url": "https://github.com/Apicurio/apicurio-registry/pull/244#discussion_r372364503", "createdAt": "2020-01-29T12:53:08Z", "author": {"login": "alesj"}, "path": "utils/serde/src/main/java/io/apicurio/registry/utils/serde/strategy/GlobalIdStrategy.java", "diffHunk": "@@ -47,14 +47,15 @@\n     /**\n      * Create InputStream from schema.\n      * By default we just take string bytes.\n-     *\n+     * \n      * @param schema the schema\n      * @return schema's input stream\n      */\n     default InputStream toStream(T schema) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bc40f115f0961e3467f9d1614f7d4f6be7c7f2f8"}, "originalPosition": 9}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "09138bae00a771bd38bbcc79ca587347219ac783", "author": {"user": {"login": "EricWittmann", "name": "Eric Wittmann"}}, "url": "https://github.com/Apicurio/apicurio-registry/commit/09138bae00a771bd38bbcc79ca587347219ac783", "committedDate": "2020-01-29T13:16:12Z", "message": "Additional changes based on PR review"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b062d6e3e47bc873c06133ad2c21e59166f37e88", "author": {"user": {"login": "EricWittmann", "name": "Eric Wittmann"}}, "url": "https://github.com/Apicurio/apicurio-registry/commit/b062d6e3e47bc873c06133ad2c21e59166f37e88", "committedDate": "2020-01-29T13:19:25Z", "message": "use IoUtil"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzUwMTAxMDEw", "url": "https://github.com/Apicurio/apicurio-registry/pull/244#pullrequestreview-350101010", "createdAt": "2020-01-29T13:24:42Z", "commit": {"oid": "b062d6e3e47bc873c06133ad2c21e59166f37e88"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yOVQxMzoyNDo0MlrOFjIM_w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yOVQxMzoyNDo0MlrOFjIM_w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjM3ODg3OQ==", "bodyText": "BB::wrap ...", "url": "https://github.com/Apicurio/apicurio-registry/pull/244#discussion_r372378879", "createdAt": "2020-01-29T13:24:42Z", "author": {"login": "alesj"}, "path": "utils/serde/src/main/java/io/apicurio/registry/utils/serde/JsonSchemaKafkaDeserializer.java", "diffHunk": "@@ -0,0 +1,210 @@\n+/*\n+ * Copyright 2020 Red Hat\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.apicurio.registry.utils.serde;\n+\n+import java.io.IOException;\n+import java.io.UncheckedIOException;\n+import java.nio.ByteBuffer;\n+import java.util.Map;\n+\n+import javax.ws.rs.core.Response;\n+\n+import org.apache.kafka.common.header.Header;\n+import org.apache.kafka.common.header.Headers;\n+import org.apache.kafka.common.serialization.Deserializer;\n+\n+import com.fasterxml.jackson.core.JsonParser;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.worldturner.medeia.api.StringSchemaSource;\n+import com.worldturner.medeia.api.jackson.MedeiaJacksonApi;\n+import com.worldturner.medeia.schema.validation.SchemaValidator;\n+\n+import io.apicurio.registry.client.RegistryService;\n+import io.apicurio.registry.rest.beans.ArtifactMetaData;\n+import io.apicurio.registry.rest.beans.VersionMetaData;\n+import io.apicurio.registry.utils.IoUtil;\n+import io.apicurio.registry.utils.serde.util.Utils;\n+\n+/**\n+ * @author eric.wittmann@gmail.com\n+ */\n+public class JsonSchemaKafkaDeserializer<T> extends AbstractKafkaSerDe<JsonSchemaKafkaDeserializer<T>> implements Deserializer<T> {\n+\n+    private static MedeiaJacksonApi api = new MedeiaJacksonApi();\n+    private static ObjectMapper mapper = new ObjectMapper();\n+    \n+    private boolean validationEnabled = false;\n+    private SchemaCache<SchemaValidator> schemaCache;\n+\n+    /**\n+     * Constructor.\n+     */\n+    public JsonSchemaKafkaDeserializer() {\n+        this(null, false);\n+    }\n+\n+    /**\n+     * Constructor.\n+     * @param client\n+     */\n+    public JsonSchemaKafkaDeserializer(RegistryService client, boolean validationEnabled) {\n+        super(client);\n+        \n+        this.validationEnabled = validationEnabled;\n+        \n+        this.schemaCache = new SchemaCache<SchemaValidator>(getClient()) {\n+            @Override\n+            protected SchemaValidator toSchema(Response response) {\n+                String schema = response.readEntity(String.class);\n+                return api.loadSchema(new StringSchemaSource(schema));\n+            }\n+        };\n+    }\n+\n+    /**\n+     * @see org.apache.kafka.common.serialization.Deserializer#configure(java.util.Map, boolean)\n+     */\n+    @Override\n+    public void configure(Map<String, ?> configs, boolean isKey) {\n+        super.configure(configs);\n+\n+        Object ve = configs.get(JsonSchemaSerDeConstants.REGISTRY_JSON_SCHEMA_VALIDATION_ENABLED);\n+        this.validationEnabled = Utils.isTrue(ve);\n+    }\n+    \n+    /**\n+     * @see org.apache.kafka.common.serialization.Deserializer#deserialize(java.lang.String, byte[])\n+     */\n+    @Override\n+    public T deserialize(String topic, byte[] data) {\n+        throw new UnsupportedOperationException();\n+    }\n+    \n+    /**\n+     * @see org.apache.kafka.common.serialization.Deserializer#deserialize(java.lang.String, org.apache.kafka.common.header.Headers, byte[])\n+     */\n+    @Override\n+    public T deserialize(String topic, Headers headers, byte[] data) {\n+        if (data == null) {\n+            return null;\n+        }\n+        \n+        try {\n+            JsonParser parser = mapper.getFactory().createParser(data);\n+            if (validationEnabled) {\n+                Long globalId = getGlobalId(headers);\n+                \n+                // If no globalId is provided, check the alternative - which is to check for artifactId and \n+                // (optionally) version.  If these are found, then convert that info to globalId.\n+                if (globalId == null) {\n+                    String artifactId = getArtifactId(headers);\n+                    Integer version = getVersion(headers);\n+                    globalId = toGlobalId(artifactId, version);\n+                }\n+                \n+                SchemaValidator schema = schemaCache.getSchema(globalId);\n+                parser = api.decorateJsonParser(schema, parser);\n+            }\n+            \n+            Class<T> messageType = getMessageType(headers);\n+\n+            return mapper.readValue(parser, messageType);\n+        } catch (IOException e) {\n+            throw new UncheckedIOException(e);\n+        }\n+    }\n+\n+    /**\n+     * Gets the global id from the headers.  Returns null if not found.\n+     * @param headers\n+     */\n+    protected Long getGlobalId(Headers headers) {\n+        Header header = headers.lastHeader(JsonSchemaSerDeConstants.HEADER_GLOBAL_ID);\n+        if (header == null) {\n+            return null;\n+        }\n+        ByteBuffer buffer = ByteBuffer.allocate(header.value().length);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b062d6e3e47bc873c06133ad2c21e59166f37e88"}, "originalPosition": 140}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzUwMTAyNzQ5", "url": "https://github.com/Apicurio/apicurio-registry/pull/244#pullrequestreview-350102749", "createdAt": "2020-01-29T13:27:24Z", "commit": {"oid": "b062d6e3e47bc873c06133ad2c21e59166f37e88"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yOVQxMzoyNzoyNFrOFjISLw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yOVQxMzoyNzoyNFrOFjISLw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjM4MDIwNw==", "bodyText": "Why not really just use existing globalIdStrategy instance? I still don't see why the 2?", "url": "https://github.com/Apicurio/apicurio-registry/pull/244#discussion_r372380207", "createdAt": "2020-01-29T13:27:24Z", "author": {"login": "alesj"}, "path": "utils/serde/src/main/java/io/apicurio/registry/utils/serde/JsonSchemaKafkaSerializer.java", "diffHunk": "@@ -0,0 +1,186 @@\n+/*\n+ * Copyright 2020 Red Hat\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.apicurio.registry.utils.serde;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.util.Map;\n+\n+import javax.ws.rs.core.Response;\n+\n+import org.apache.kafka.common.errors.SerializationException;\n+import org.apache.kafka.common.header.Headers;\n+import org.apache.kafka.common.serialization.Serializer;\n+\n+import com.fasterxml.jackson.core.JsonGenerator;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.worldturner.medeia.api.StringSchemaSource;\n+import com.worldturner.medeia.api.jackson.MedeiaJacksonApi;\n+import com.worldturner.medeia.schema.validation.SchemaValidator;\n+\n+import io.apicurio.registry.client.RegistryService;\n+import io.apicurio.registry.types.ArtifactType;\n+import io.apicurio.registry.utils.IoUtil;\n+import io.apicurio.registry.utils.serde.strategy.FindLatestIdStrategy;\n+import io.apicurio.registry.utils.serde.strategy.GlobalIdStrategy;\n+import io.apicurio.registry.utils.serde.util.Utils;\n+\n+/**\n+ * An implementation of the Kafka Serializer for JSON Schema use-cases. This serializer assumes that the\n+ * user's application needs to serialize a Java Bean to JSON data using Jackson. In addition to standard\n+ * serialization of the bean, this implementation can also optionally validate it against a JSON schema.\n+ * \n+ * @author eric.wittmann@gmail.com\n+ */\n+public class JsonSchemaKafkaSerializer<T>\n+        extends AbstractKafkaStrategyAwareSerDe<SchemaValidator, JsonSchemaKafkaSerializer<T>>\n+        implements Serializer<T> {\n+    \n+    private static MedeiaJacksonApi api = new MedeiaJacksonApi();\n+    private static ObjectMapper mapper = new ObjectMapper();\n+    private static GlobalIdStrategy<SchemaValidator> latestVersionStrategy = new FindLatestIdStrategy<>();\n+    \n+    private boolean validationEnabled = false;\n+    private SchemaCache<SchemaValidator> schemaCache;\n+\n+    /**\n+     * Constructor.\n+     */\n+    public JsonSchemaKafkaSerializer() {\n+    }\n+\n+    /**\n+     * Constructor.\n+     * @param client\n+     * @param validationEnabled\n+     */\n+    public JsonSchemaKafkaSerializer(RegistryService client, boolean validationEnabled) {\n+        super(client);\n+        \n+        this.validationEnabled = validationEnabled;\n+        this.schemaCache = new SchemaCache<SchemaValidator>(getClient()) {\n+            @Override\n+            protected SchemaValidator toSchema(Response response) {\n+                String schema = response.readEntity(String.class);\n+                return api.loadSchema(new StringSchemaSource(schema));\n+            }\n+        };\n+\n+    }\n+\n+    /**\n+     * @see org.apache.kafka.common.serialization.Serializer#configure(java.util.Map, boolean)\n+     */\n+    @Override\n+    public void configure(Map<String, ?> configs, boolean isKey) {\n+        super.configure(configs, isKey);\n+        \n+        Object ve = configs.get(JsonSchemaSerDeConstants.REGISTRY_JSON_SCHEMA_VALIDATION_ENABLED);\n+        this.validationEnabled = Utils.isTrue(ve);\n+    }\n+    \n+    /**\n+     * @see org.apache.kafka.common.serialization.Serializer#serialize(java.lang.String, java.lang.Object)\n+     */\n+    @Override\n+    public byte[] serialize(String topic, T data) {\n+        // Headers are required when sending data using this serdes impl\n+        throw new UnsupportedOperationException();\n+    }\n+    \n+    /**\n+     * @see org.apache.kafka.common.serialization.Serializer#serialize(java.lang.String, org.apache.kafka.common.header.Headers, java.lang.Object)\n+     */\n+    @Override\n+    public byte[] serialize(String topic, Headers headers, T data) {\n+        if (data == null) {\n+            return new byte[0];\n+        }\n+\n+        // Now serialize the data\n+        try {\n+            ByteArrayOutputStream baos = new ByteArrayOutputStream();\n+            JsonGenerator generator = mapper.getFactory().createGenerator(baos);\n+            if (validationEnabled) {\n+                String artifactId = getArtifactId(topic, data);\n+                Long globalId = getArtifactVersionGlobalId(artifactId, topic, data);\n+                addSchemaHeaders(headers, artifactId, globalId);\n+\n+                SchemaValidator schemaValidator = schemaCache.getSchema(globalId);\n+                generator = api.decorateJsonGenerator(schemaValidator, generator);\n+            }\n+            addTypeHeaders(headers, data);\n+\n+            mapper.writeValue(generator, data);\n+            \n+            return baos.toByteArray();\n+        } catch (IOException e) {\n+            throw new SerializationException(e);\n+        }\n+    }\n+\n+    /**\n+     * Figure out the artifact ID from the topic name and data.\n+     * @param topic\n+     * @param data\n+     */\n+    protected String getArtifactId(String topic, T data) {\n+        // Note - for JSON Schema, we don't yet have the schema so we pass null to the strategy.\n+        return getArtifactIdStrategy().artifactId(topic, isKey(), null);\n+    }\n+\n+    /**\n+     * Gets the global id of the schema to use for validation.\n+     * @param artifactId\n+     * @param topic\n+     * @param data\n+     */\n+    protected Long getArtifactVersionGlobalId(String artifactId, String topic, T data) {\n+        if (getGlobalIdStrategy() == null) {\n+            return latestVersionStrategy.findId(getClient(), artifactId, ArtifactType.JSON, null);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b062d6e3e47bc873c06133ad2c21e59166f37e88"}, "originalPosition": 155}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f5dd2dd010fb3111607174e697c43108f32184a8", "author": {"user": {"login": "EricWittmann", "name": "Eric Wittmann"}}, "url": "https://github.com/Apicurio/apicurio-registry/commit/f5dd2dd010fb3111607174e697c43108f32184a8", "committedDate": "2020-01-29T13:51:28Z", "message": "make the default global id strategy clearer"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3499, "cost": 1, "resetAt": "2021-11-01T11:59:11Z"}}}