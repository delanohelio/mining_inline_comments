{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTE0MDE0NzU2", "number": 972, "reviewThreads": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMVQxMDozMDowMlrOE3pV4Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMVQxMDozNDoxOFrOE3pb1A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI2Nzg0NDgxOnYy", "diffSide": "RIGHT", "path": "storage/streams/src/main/java/io/apicurio/registry/streams/events/KafkaEventSink.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMVQxMDozMDowMlrOHxHVEw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMVQxMTo0NzowNFrOHxJycw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTI2MjM1NQ==", "bodyText": "Is producerPproperties or producerProperties?", "url": "https://github.com/Apicurio/apicurio-registry/pull/972#discussion_r521262355", "createdAt": "2020-11-11T10:30:02Z", "author": {"login": "antonmry"}, "path": "storage/streams/src/main/java/io/apicurio/registry/streams/events/KafkaEventSink.java", "diffHunk": "@@ -0,0 +1,103 @@\n+package io.apicurio.registry.streams.events;\n+\n+import java.time.Instant;\n+import java.util.Optional;\n+import java.util.Properties;\n+import java.util.UUID;\n+\n+import javax.annotation.PostConstruct;\n+import javax.enterprise.context.ApplicationScoped;\n+import javax.inject.Inject;\n+\n+import org.apache.kafka.clients.producer.ProducerRecord;\n+import org.apache.kafka.common.header.Headers;\n+import org.apache.kafka.common.header.internals.RecordHeaders;\n+import org.apache.kafka.common.serialization.Serdes;\n+import org.eclipse.microprofile.config.inject.ConfigProperty;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import io.apicurio.registry.events.EventSink;\n+import io.apicurio.registry.utils.RegistryProperties;\n+import io.apicurio.registry.utils.kafka.AsyncProducer;\n+import io.apicurio.registry.utils.kafka.ProducerActions;\n+import io.vertx.core.buffer.Buffer;\n+import io.vertx.core.eventbus.Message;\n+\n+/**\n+ * @author Fabian Martinez\n+ */\n+@ApplicationScoped\n+public class KafkaEventSink implements EventSink {\n+\n+    private static final Logger log = LoggerFactory.getLogger(KafkaEventSink.class);\n+\n+    @Inject\n+    @RegistryProperties(\n+            value = {\"registry.streams.common\", \"registry.streams.events\"},\n+            empties = {\"ssl.endpoint.identification.algorithm=\"}\n+    )\n+    Properties producerPproperties;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c198622ea1721d35d325218576f85b4e7e2a6c6e"}, "originalPosition": 40}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTMwMjY0Mw==", "bodyText": "that's a typo", "url": "https://github.com/Apicurio/apicurio-registry/pull/972#discussion_r521302643", "createdAt": "2020-11-11T11:47:04Z", "author": {"login": "famartinrh"}, "path": "storage/streams/src/main/java/io/apicurio/registry/streams/events/KafkaEventSink.java", "diffHunk": "@@ -0,0 +1,103 @@\n+package io.apicurio.registry.streams.events;\n+\n+import java.time.Instant;\n+import java.util.Optional;\n+import java.util.Properties;\n+import java.util.UUID;\n+\n+import javax.annotation.PostConstruct;\n+import javax.enterprise.context.ApplicationScoped;\n+import javax.inject.Inject;\n+\n+import org.apache.kafka.clients.producer.ProducerRecord;\n+import org.apache.kafka.common.header.Headers;\n+import org.apache.kafka.common.header.internals.RecordHeaders;\n+import org.apache.kafka.common.serialization.Serdes;\n+import org.eclipse.microprofile.config.inject.ConfigProperty;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import io.apicurio.registry.events.EventSink;\n+import io.apicurio.registry.utils.RegistryProperties;\n+import io.apicurio.registry.utils.kafka.AsyncProducer;\n+import io.apicurio.registry.utils.kafka.ProducerActions;\n+import io.vertx.core.buffer.Buffer;\n+import io.vertx.core.eventbus.Message;\n+\n+/**\n+ * @author Fabian Martinez\n+ */\n+@ApplicationScoped\n+public class KafkaEventSink implements EventSink {\n+\n+    private static final Logger log = LoggerFactory.getLogger(KafkaEventSink.class);\n+\n+    @Inject\n+    @RegistryProperties(\n+            value = {\"registry.streams.common\", \"registry.streams.events\"},\n+            empties = {\"ssl.endpoint.identification.algorithm=\"}\n+    )\n+    Properties producerPproperties;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTI2MjM1NQ=="}, "originalCommit": {"oid": "c198622ea1721d35d325218576f85b4e7e2a6c6e"}, "originalPosition": 40}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI2Nzg1NjI1OnYy", "diffSide": "RIGHT", "path": "storage/streams/src/main/java/io/apicurio/registry/streams/events/KafkaEventSink.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMVQxMDozMzoyNFrOHxHcDQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMVQxMTo0ODo0NFrOHxJ1tw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTI2NDE0MQ==", "bodyText": "It should be Optional or Mandatory?", "url": "https://github.com/Apicurio/apicurio-registry/pull/972#discussion_r521264141", "createdAt": "2020-11-11T10:33:24Z", "author": {"login": "antonmry"}, "path": "storage/streams/src/main/java/io/apicurio/registry/streams/events/KafkaEventSink.java", "diffHunk": "@@ -0,0 +1,103 @@\n+package io.apicurio.registry.streams.events;\n+\n+import java.time.Instant;\n+import java.util.Optional;\n+import java.util.Properties;\n+import java.util.UUID;\n+\n+import javax.annotation.PostConstruct;\n+import javax.enterprise.context.ApplicationScoped;\n+import javax.inject.Inject;\n+\n+import org.apache.kafka.clients.producer.ProducerRecord;\n+import org.apache.kafka.common.header.Headers;\n+import org.apache.kafka.common.header.internals.RecordHeaders;\n+import org.apache.kafka.common.serialization.Serdes;\n+import org.eclipse.microprofile.config.inject.ConfigProperty;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import io.apicurio.registry.events.EventSink;\n+import io.apicurio.registry.utils.RegistryProperties;\n+import io.apicurio.registry.utils.kafka.AsyncProducer;\n+import io.apicurio.registry.utils.kafka.ProducerActions;\n+import io.vertx.core.buffer.Buffer;\n+import io.vertx.core.eventbus.Message;\n+\n+/**\n+ * @author Fabian Martinez\n+ */\n+@ApplicationScoped\n+public class KafkaEventSink implements EventSink {\n+\n+    private static final Logger log = LoggerFactory.getLogger(KafkaEventSink.class);\n+\n+    @Inject\n+    @RegistryProperties(\n+            value = {\"registry.streams.common\", \"registry.streams.events\"},\n+            empties = {\"ssl.endpoint.identification.algorithm=\"}\n+    )\n+    Properties producerPproperties;\n+\n+    private ProducerActions<UUID, byte[]> producer;\n+    private Integer partition;\n+\n+    @ConfigProperty(name = \"registry.events.kafka.topic\")\n+    Optional<String> eventsTopic;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c198622ea1721d35d325218576f85b4e7e2a6c6e"}, "originalPosition": 46}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTMwMzQ3OQ==", "bodyText": "it's optional, it's possible to do not define a topic, and of course, no events will be triggered in that case.", "url": "https://github.com/Apicurio/apicurio-registry/pull/972#discussion_r521303479", "createdAt": "2020-11-11T11:48:44Z", "author": {"login": "famartinrh"}, "path": "storage/streams/src/main/java/io/apicurio/registry/streams/events/KafkaEventSink.java", "diffHunk": "@@ -0,0 +1,103 @@\n+package io.apicurio.registry.streams.events;\n+\n+import java.time.Instant;\n+import java.util.Optional;\n+import java.util.Properties;\n+import java.util.UUID;\n+\n+import javax.annotation.PostConstruct;\n+import javax.enterprise.context.ApplicationScoped;\n+import javax.inject.Inject;\n+\n+import org.apache.kafka.clients.producer.ProducerRecord;\n+import org.apache.kafka.common.header.Headers;\n+import org.apache.kafka.common.header.internals.RecordHeaders;\n+import org.apache.kafka.common.serialization.Serdes;\n+import org.eclipse.microprofile.config.inject.ConfigProperty;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import io.apicurio.registry.events.EventSink;\n+import io.apicurio.registry.utils.RegistryProperties;\n+import io.apicurio.registry.utils.kafka.AsyncProducer;\n+import io.apicurio.registry.utils.kafka.ProducerActions;\n+import io.vertx.core.buffer.Buffer;\n+import io.vertx.core.eventbus.Message;\n+\n+/**\n+ * @author Fabian Martinez\n+ */\n+@ApplicationScoped\n+public class KafkaEventSink implements EventSink {\n+\n+    private static final Logger log = LoggerFactory.getLogger(KafkaEventSink.class);\n+\n+    @Inject\n+    @RegistryProperties(\n+            value = {\"registry.streams.common\", \"registry.streams.events\"},\n+            empties = {\"ssl.endpoint.identification.algorithm=\"}\n+    )\n+    Properties producerPproperties;\n+\n+    private ProducerActions<UUID, byte[]> producer;\n+    private Integer partition;\n+\n+    @ConfigProperty(name = \"registry.events.kafka.topic\")\n+    Optional<String> eventsTopic;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTI2NDE0MQ=="}, "originalCommit": {"oid": "c198622ea1721d35d325218576f85b4e7e2a6c6e"}, "originalPosition": 46}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI2Nzg2MDA0OnYy", "diffSide": "RIGHT", "path": "storage/streams/src/main/java/io/apicurio/registry/streams/events/KafkaEventSink.java", "isResolved": false, "comments": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMVQxMDozNDoxOFrOHxHeTA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMlQxNjo0OToxNFrOHyD98A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTI2NDcxNg==", "bodyText": "Where are the rest of Kafka properties defined? BOOTSTRAP_SERVERS_CONFIG, Auth, etc.", "url": "https://github.com/Apicurio/apicurio-registry/pull/972#discussion_r521264716", "createdAt": "2020-11-11T10:34:18Z", "author": {"login": "antonmry"}, "path": "storage/streams/src/main/java/io/apicurio/registry/streams/events/KafkaEventSink.java", "diffHunk": "@@ -0,0 +1,103 @@\n+package io.apicurio.registry.streams.events;\n+\n+import java.time.Instant;\n+import java.util.Optional;\n+import java.util.Properties;\n+import java.util.UUID;\n+\n+import javax.annotation.PostConstruct;\n+import javax.enterprise.context.ApplicationScoped;\n+import javax.inject.Inject;\n+\n+import org.apache.kafka.clients.producer.ProducerRecord;\n+import org.apache.kafka.common.header.Headers;\n+import org.apache.kafka.common.header.internals.RecordHeaders;\n+import org.apache.kafka.common.serialization.Serdes;\n+import org.eclipse.microprofile.config.inject.ConfigProperty;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import io.apicurio.registry.events.EventSink;\n+import io.apicurio.registry.utils.RegistryProperties;\n+import io.apicurio.registry.utils.kafka.AsyncProducer;\n+import io.apicurio.registry.utils.kafka.ProducerActions;\n+import io.vertx.core.buffer.Buffer;\n+import io.vertx.core.eventbus.Message;\n+\n+/**\n+ * @author Fabian Martinez\n+ */\n+@ApplicationScoped\n+public class KafkaEventSink implements EventSink {\n+\n+    private static final Logger log = LoggerFactory.getLogger(KafkaEventSink.class);\n+\n+    @Inject\n+    @RegistryProperties(\n+            value = {\"registry.streams.common\", \"registry.streams.events\"},\n+            empties = {\"ssl.endpoint.identification.algorithm=\"}\n+    )\n+    Properties producerPproperties;\n+\n+    private ProducerActions<UUID, byte[]> producer;\n+    private Integer partition;\n+\n+    @ConfigProperty(name = \"registry.events.kafka.topic\")\n+    Optional<String> eventsTopic;\n+\n+    @ConfigProperty(name = \"registry.events.kafka.topic-partition\")\n+    Optional<Integer> eventsTopicPartition;\n+\n+    @PostConstruct\n+    void init() {\n+        partition = eventsTopicPartition.orElse(0);\n+    }\n+\n+    @Override\n+    public String name() {\n+        return \"Kafka Sink\";\n+    }\n+\n+    @Override\n+    public boolean isConfigured() {\n+        return eventsTopic.isPresent();\n+    }\n+\n+    @Override\n+    public void handle(Message<Buffer> message) {\n+        String type = message.headers().get(\"type\");\n+\n+        log.info(\"Firing event \" + type);\n+\n+        UUID uuid = UUID.randomUUID();\n+\n+        Headers headers = new RecordHeaders();\n+        headers.add(\"ce_id\", uuid.toString().getBytes());\n+        headers.add(\"ce_specversion\", \"1.0\".getBytes());\n+        headers.add(\"ce_source\", \"apicurio-registry\".getBytes());\n+        headers.add(\"ce_type\", type.getBytes());\n+        headers.add(\"ce_time\", Instant.now().toString().getBytes());\n+        headers.add(\"content-type\", \"application/json\".getBytes());\n+\n+        getProducer()\n+            .apply(new ProducerRecord<UUID, byte[]>(\n+                    eventsTopic.get(),\n+                    partition,\n+                    uuid,\n+                    message.body().getBytes(),\n+                    headers));\n+\n+    }\n+\n+    public synchronized ProducerActions<UUID, byte[]> getProducer() {\n+        if (producer == null) {\n+            producer = new AsyncProducer<UUID, byte[]>(\n+                    producerPproperties,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c198622ea1721d35d325218576f85b4e7e2a6c6e"}, "originalPosition": 95}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTMwNDA4Mg==", "bodyText": "they are picked from the main apicurio registry configuration. This means, events will be sent to the same kafka using the same connection config, authentication/authorization config as the registry is using for the storage", "url": "https://github.com/Apicurio/apicurio-registry/pull/972#discussion_r521304082", "createdAt": "2020-11-11T11:49:58Z", "author": {"login": "famartinrh"}, "path": "storage/streams/src/main/java/io/apicurio/registry/streams/events/KafkaEventSink.java", "diffHunk": "@@ -0,0 +1,103 @@\n+package io.apicurio.registry.streams.events;\n+\n+import java.time.Instant;\n+import java.util.Optional;\n+import java.util.Properties;\n+import java.util.UUID;\n+\n+import javax.annotation.PostConstruct;\n+import javax.enterprise.context.ApplicationScoped;\n+import javax.inject.Inject;\n+\n+import org.apache.kafka.clients.producer.ProducerRecord;\n+import org.apache.kafka.common.header.Headers;\n+import org.apache.kafka.common.header.internals.RecordHeaders;\n+import org.apache.kafka.common.serialization.Serdes;\n+import org.eclipse.microprofile.config.inject.ConfigProperty;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import io.apicurio.registry.events.EventSink;\n+import io.apicurio.registry.utils.RegistryProperties;\n+import io.apicurio.registry.utils.kafka.AsyncProducer;\n+import io.apicurio.registry.utils.kafka.ProducerActions;\n+import io.vertx.core.buffer.Buffer;\n+import io.vertx.core.eventbus.Message;\n+\n+/**\n+ * @author Fabian Martinez\n+ */\n+@ApplicationScoped\n+public class KafkaEventSink implements EventSink {\n+\n+    private static final Logger log = LoggerFactory.getLogger(KafkaEventSink.class);\n+\n+    @Inject\n+    @RegistryProperties(\n+            value = {\"registry.streams.common\", \"registry.streams.events\"},\n+            empties = {\"ssl.endpoint.identification.algorithm=\"}\n+    )\n+    Properties producerPproperties;\n+\n+    private ProducerActions<UUID, byte[]> producer;\n+    private Integer partition;\n+\n+    @ConfigProperty(name = \"registry.events.kafka.topic\")\n+    Optional<String> eventsTopic;\n+\n+    @ConfigProperty(name = \"registry.events.kafka.topic-partition\")\n+    Optional<Integer> eventsTopicPartition;\n+\n+    @PostConstruct\n+    void init() {\n+        partition = eventsTopicPartition.orElse(0);\n+    }\n+\n+    @Override\n+    public String name() {\n+        return \"Kafka Sink\";\n+    }\n+\n+    @Override\n+    public boolean isConfigured() {\n+        return eventsTopic.isPresent();\n+    }\n+\n+    @Override\n+    public void handle(Message<Buffer> message) {\n+        String type = message.headers().get(\"type\");\n+\n+        log.info(\"Firing event \" + type);\n+\n+        UUID uuid = UUID.randomUUID();\n+\n+        Headers headers = new RecordHeaders();\n+        headers.add(\"ce_id\", uuid.toString().getBytes());\n+        headers.add(\"ce_specversion\", \"1.0\".getBytes());\n+        headers.add(\"ce_source\", \"apicurio-registry\".getBytes());\n+        headers.add(\"ce_type\", type.getBytes());\n+        headers.add(\"ce_time\", Instant.now().toString().getBytes());\n+        headers.add(\"content-type\", \"application/json\".getBytes());\n+\n+        getProducer()\n+            .apply(new ProducerRecord<UUID, byte[]>(\n+                    eventsTopic.get(),\n+                    partition,\n+                    uuid,\n+                    message.body().getBytes(),\n+                    headers));\n+\n+    }\n+\n+    public synchronized ProducerActions<UUID, byte[]> getProducer() {\n+        if (producer == null) {\n+            producer = new AsyncProducer<UUID, byte[]>(\n+                    producerPproperties,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTI2NDcxNg=="}, "originalCommit": {"oid": "c198622ea1721d35d325218576f85b4e7e2a6c6e"}, "originalPosition": 95}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTMwNjEzMQ==", "bodyText": "That works for us but it may be a problem for someone using a different storage but they want to use Kafka to replicate schemas. I'm not sure if that's something you would like to approach in this stage. It works as it is for us", "url": "https://github.com/Apicurio/apicurio-registry/pull/972#discussion_r521306131", "createdAt": "2020-11-11T11:54:12Z", "author": {"login": "antonmry"}, "path": "storage/streams/src/main/java/io/apicurio/registry/streams/events/KafkaEventSink.java", "diffHunk": "@@ -0,0 +1,103 @@\n+package io.apicurio.registry.streams.events;\n+\n+import java.time.Instant;\n+import java.util.Optional;\n+import java.util.Properties;\n+import java.util.UUID;\n+\n+import javax.annotation.PostConstruct;\n+import javax.enterprise.context.ApplicationScoped;\n+import javax.inject.Inject;\n+\n+import org.apache.kafka.clients.producer.ProducerRecord;\n+import org.apache.kafka.common.header.Headers;\n+import org.apache.kafka.common.header.internals.RecordHeaders;\n+import org.apache.kafka.common.serialization.Serdes;\n+import org.eclipse.microprofile.config.inject.ConfigProperty;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import io.apicurio.registry.events.EventSink;\n+import io.apicurio.registry.utils.RegistryProperties;\n+import io.apicurio.registry.utils.kafka.AsyncProducer;\n+import io.apicurio.registry.utils.kafka.ProducerActions;\n+import io.vertx.core.buffer.Buffer;\n+import io.vertx.core.eventbus.Message;\n+\n+/**\n+ * @author Fabian Martinez\n+ */\n+@ApplicationScoped\n+public class KafkaEventSink implements EventSink {\n+\n+    private static final Logger log = LoggerFactory.getLogger(KafkaEventSink.class);\n+\n+    @Inject\n+    @RegistryProperties(\n+            value = {\"registry.streams.common\", \"registry.streams.events\"},\n+            empties = {\"ssl.endpoint.identification.algorithm=\"}\n+    )\n+    Properties producerPproperties;\n+\n+    private ProducerActions<UUID, byte[]> producer;\n+    private Integer partition;\n+\n+    @ConfigProperty(name = \"registry.events.kafka.topic\")\n+    Optional<String> eventsTopic;\n+\n+    @ConfigProperty(name = \"registry.events.kafka.topic-partition\")\n+    Optional<Integer> eventsTopicPartition;\n+\n+    @PostConstruct\n+    void init() {\n+        partition = eventsTopicPartition.orElse(0);\n+    }\n+\n+    @Override\n+    public String name() {\n+        return \"Kafka Sink\";\n+    }\n+\n+    @Override\n+    public boolean isConfigured() {\n+        return eventsTopic.isPresent();\n+    }\n+\n+    @Override\n+    public void handle(Message<Buffer> message) {\n+        String type = message.headers().get(\"type\");\n+\n+        log.info(\"Firing event \" + type);\n+\n+        UUID uuid = UUID.randomUUID();\n+\n+        Headers headers = new RecordHeaders();\n+        headers.add(\"ce_id\", uuid.toString().getBytes());\n+        headers.add(\"ce_specversion\", \"1.0\".getBytes());\n+        headers.add(\"ce_source\", \"apicurio-registry\".getBytes());\n+        headers.add(\"ce_type\", type.getBytes());\n+        headers.add(\"ce_time\", Instant.now().toString().getBytes());\n+        headers.add(\"content-type\", \"application/json\".getBytes());\n+\n+        getProducer()\n+            .apply(new ProducerRecord<UUID, byte[]>(\n+                    eventsTopic.get(),\n+                    partition,\n+                    uuid,\n+                    message.body().getBytes(),\n+                    headers));\n+\n+    }\n+\n+    public synchronized ProducerActions<UUID, byte[]> getProducer() {\n+        if (producer == null) {\n+            producer = new AsyncProducer<UUID, byte[]>(\n+                    producerPproperties,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTI2NDcxNg=="}, "originalCommit": {"oid": "c198622ea1721d35d325218576f85b4e7e2a6c6e"}, "originalPosition": 95}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTMxMTcxOQ==", "bodyText": "great! I don't think it's necessary to add that possibility at this point. I'll prefer to wait until someone has a requirement for that.", "url": "https://github.com/Apicurio/apicurio-registry/pull/972#discussion_r521311719", "createdAt": "2020-11-11T12:05:07Z", "author": {"login": "famartinrh"}, "path": "storage/streams/src/main/java/io/apicurio/registry/streams/events/KafkaEventSink.java", "diffHunk": "@@ -0,0 +1,103 @@\n+package io.apicurio.registry.streams.events;\n+\n+import java.time.Instant;\n+import java.util.Optional;\n+import java.util.Properties;\n+import java.util.UUID;\n+\n+import javax.annotation.PostConstruct;\n+import javax.enterprise.context.ApplicationScoped;\n+import javax.inject.Inject;\n+\n+import org.apache.kafka.clients.producer.ProducerRecord;\n+import org.apache.kafka.common.header.Headers;\n+import org.apache.kafka.common.header.internals.RecordHeaders;\n+import org.apache.kafka.common.serialization.Serdes;\n+import org.eclipse.microprofile.config.inject.ConfigProperty;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import io.apicurio.registry.events.EventSink;\n+import io.apicurio.registry.utils.RegistryProperties;\n+import io.apicurio.registry.utils.kafka.AsyncProducer;\n+import io.apicurio.registry.utils.kafka.ProducerActions;\n+import io.vertx.core.buffer.Buffer;\n+import io.vertx.core.eventbus.Message;\n+\n+/**\n+ * @author Fabian Martinez\n+ */\n+@ApplicationScoped\n+public class KafkaEventSink implements EventSink {\n+\n+    private static final Logger log = LoggerFactory.getLogger(KafkaEventSink.class);\n+\n+    @Inject\n+    @RegistryProperties(\n+            value = {\"registry.streams.common\", \"registry.streams.events\"},\n+            empties = {\"ssl.endpoint.identification.algorithm=\"}\n+    )\n+    Properties producerPproperties;\n+\n+    private ProducerActions<UUID, byte[]> producer;\n+    private Integer partition;\n+\n+    @ConfigProperty(name = \"registry.events.kafka.topic\")\n+    Optional<String> eventsTopic;\n+\n+    @ConfigProperty(name = \"registry.events.kafka.topic-partition\")\n+    Optional<Integer> eventsTopicPartition;\n+\n+    @PostConstruct\n+    void init() {\n+        partition = eventsTopicPartition.orElse(0);\n+    }\n+\n+    @Override\n+    public String name() {\n+        return \"Kafka Sink\";\n+    }\n+\n+    @Override\n+    public boolean isConfigured() {\n+        return eventsTopic.isPresent();\n+    }\n+\n+    @Override\n+    public void handle(Message<Buffer> message) {\n+        String type = message.headers().get(\"type\");\n+\n+        log.info(\"Firing event \" + type);\n+\n+        UUID uuid = UUID.randomUUID();\n+\n+        Headers headers = new RecordHeaders();\n+        headers.add(\"ce_id\", uuid.toString().getBytes());\n+        headers.add(\"ce_specversion\", \"1.0\".getBytes());\n+        headers.add(\"ce_source\", \"apicurio-registry\".getBytes());\n+        headers.add(\"ce_type\", type.getBytes());\n+        headers.add(\"ce_time\", Instant.now().toString().getBytes());\n+        headers.add(\"content-type\", \"application/json\".getBytes());\n+\n+        getProducer()\n+            .apply(new ProducerRecord<UUID, byte[]>(\n+                    eventsTopic.get(),\n+                    partition,\n+                    uuid,\n+                    message.body().getBytes(),\n+                    headers));\n+\n+    }\n+\n+    public synchronized ProducerActions<UUID, byte[]> getProducer() {\n+        if (producer == null) {\n+            producer = new AsyncProducer<UUID, byte[]>(\n+                    producerPproperties,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTI2NDcxNg=="}, "originalCommit": {"oid": "c198622ea1721d35d325218576f85b4e7e2a6c6e"}, "originalPosition": 95}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTU1NDgyNA==", "bodyText": "I disagree - I think we'll definitely want the ability to send messages to Kafka even if the storage variant is e.g. SQL.", "url": "https://github.com/Apicurio/apicurio-registry/pull/972#discussion_r521554824", "createdAt": "2020-11-11T18:25:09Z", "author": {"login": "EricWittmann"}, "path": "storage/streams/src/main/java/io/apicurio/registry/streams/events/KafkaEventSink.java", "diffHunk": "@@ -0,0 +1,103 @@\n+package io.apicurio.registry.streams.events;\n+\n+import java.time.Instant;\n+import java.util.Optional;\n+import java.util.Properties;\n+import java.util.UUID;\n+\n+import javax.annotation.PostConstruct;\n+import javax.enterprise.context.ApplicationScoped;\n+import javax.inject.Inject;\n+\n+import org.apache.kafka.clients.producer.ProducerRecord;\n+import org.apache.kafka.common.header.Headers;\n+import org.apache.kafka.common.header.internals.RecordHeaders;\n+import org.apache.kafka.common.serialization.Serdes;\n+import org.eclipse.microprofile.config.inject.ConfigProperty;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import io.apicurio.registry.events.EventSink;\n+import io.apicurio.registry.utils.RegistryProperties;\n+import io.apicurio.registry.utils.kafka.AsyncProducer;\n+import io.apicurio.registry.utils.kafka.ProducerActions;\n+import io.vertx.core.buffer.Buffer;\n+import io.vertx.core.eventbus.Message;\n+\n+/**\n+ * @author Fabian Martinez\n+ */\n+@ApplicationScoped\n+public class KafkaEventSink implements EventSink {\n+\n+    private static final Logger log = LoggerFactory.getLogger(KafkaEventSink.class);\n+\n+    @Inject\n+    @RegistryProperties(\n+            value = {\"registry.streams.common\", \"registry.streams.events\"},\n+            empties = {\"ssl.endpoint.identification.algorithm=\"}\n+    )\n+    Properties producerPproperties;\n+\n+    private ProducerActions<UUID, byte[]> producer;\n+    private Integer partition;\n+\n+    @ConfigProperty(name = \"registry.events.kafka.topic\")\n+    Optional<String> eventsTopic;\n+\n+    @ConfigProperty(name = \"registry.events.kafka.topic-partition\")\n+    Optional<Integer> eventsTopicPartition;\n+\n+    @PostConstruct\n+    void init() {\n+        partition = eventsTopicPartition.orElse(0);\n+    }\n+\n+    @Override\n+    public String name() {\n+        return \"Kafka Sink\";\n+    }\n+\n+    @Override\n+    public boolean isConfigured() {\n+        return eventsTopic.isPresent();\n+    }\n+\n+    @Override\n+    public void handle(Message<Buffer> message) {\n+        String type = message.headers().get(\"type\");\n+\n+        log.info(\"Firing event \" + type);\n+\n+        UUID uuid = UUID.randomUUID();\n+\n+        Headers headers = new RecordHeaders();\n+        headers.add(\"ce_id\", uuid.toString().getBytes());\n+        headers.add(\"ce_specversion\", \"1.0\".getBytes());\n+        headers.add(\"ce_source\", \"apicurio-registry\".getBytes());\n+        headers.add(\"ce_type\", type.getBytes());\n+        headers.add(\"ce_time\", Instant.now().toString().getBytes());\n+        headers.add(\"content-type\", \"application/json\".getBytes());\n+\n+        getProducer()\n+            .apply(new ProducerRecord<UUID, byte[]>(\n+                    eventsTopic.get(),\n+                    partition,\n+                    uuid,\n+                    message.body().getBytes(),\n+                    headers));\n+\n+    }\n+\n+    public synchronized ProducerActions<UUID, byte[]> getProducer() {\n+        if (producer == null) {\n+            producer = new AsyncProducer<UUID, byte[]>(\n+                    producerPproperties,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTI2NDcxNg=="}, "originalCommit": {"oid": "c198622ea1721d35d325218576f85b4e7e2a6c6e"}, "originalPosition": 95}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTU1NTE3Mg==", "bodyText": "Also for many deployments that are using the Streams storage, the Kafka cluster used for registry storage may be different from the one handling registry events.", "url": "https://github.com/Apicurio/apicurio-registry/pull/972#discussion_r521555172", "createdAt": "2020-11-11T18:25:48Z", "author": {"login": "EricWittmann"}, "path": "storage/streams/src/main/java/io/apicurio/registry/streams/events/KafkaEventSink.java", "diffHunk": "@@ -0,0 +1,103 @@\n+package io.apicurio.registry.streams.events;\n+\n+import java.time.Instant;\n+import java.util.Optional;\n+import java.util.Properties;\n+import java.util.UUID;\n+\n+import javax.annotation.PostConstruct;\n+import javax.enterprise.context.ApplicationScoped;\n+import javax.inject.Inject;\n+\n+import org.apache.kafka.clients.producer.ProducerRecord;\n+import org.apache.kafka.common.header.Headers;\n+import org.apache.kafka.common.header.internals.RecordHeaders;\n+import org.apache.kafka.common.serialization.Serdes;\n+import org.eclipse.microprofile.config.inject.ConfigProperty;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import io.apicurio.registry.events.EventSink;\n+import io.apicurio.registry.utils.RegistryProperties;\n+import io.apicurio.registry.utils.kafka.AsyncProducer;\n+import io.apicurio.registry.utils.kafka.ProducerActions;\n+import io.vertx.core.buffer.Buffer;\n+import io.vertx.core.eventbus.Message;\n+\n+/**\n+ * @author Fabian Martinez\n+ */\n+@ApplicationScoped\n+public class KafkaEventSink implements EventSink {\n+\n+    private static final Logger log = LoggerFactory.getLogger(KafkaEventSink.class);\n+\n+    @Inject\n+    @RegistryProperties(\n+            value = {\"registry.streams.common\", \"registry.streams.events\"},\n+            empties = {\"ssl.endpoint.identification.algorithm=\"}\n+    )\n+    Properties producerPproperties;\n+\n+    private ProducerActions<UUID, byte[]> producer;\n+    private Integer partition;\n+\n+    @ConfigProperty(name = \"registry.events.kafka.topic\")\n+    Optional<String> eventsTopic;\n+\n+    @ConfigProperty(name = \"registry.events.kafka.topic-partition\")\n+    Optional<Integer> eventsTopicPartition;\n+\n+    @PostConstruct\n+    void init() {\n+        partition = eventsTopicPartition.orElse(0);\n+    }\n+\n+    @Override\n+    public String name() {\n+        return \"Kafka Sink\";\n+    }\n+\n+    @Override\n+    public boolean isConfigured() {\n+        return eventsTopic.isPresent();\n+    }\n+\n+    @Override\n+    public void handle(Message<Buffer> message) {\n+        String type = message.headers().get(\"type\");\n+\n+        log.info(\"Firing event \" + type);\n+\n+        UUID uuid = UUID.randomUUID();\n+\n+        Headers headers = new RecordHeaders();\n+        headers.add(\"ce_id\", uuid.toString().getBytes());\n+        headers.add(\"ce_specversion\", \"1.0\".getBytes());\n+        headers.add(\"ce_source\", \"apicurio-registry\".getBytes());\n+        headers.add(\"ce_type\", type.getBytes());\n+        headers.add(\"ce_time\", Instant.now().toString().getBytes());\n+        headers.add(\"content-type\", \"application/json\".getBytes());\n+\n+        getProducer()\n+            .apply(new ProducerRecord<UUID, byte[]>(\n+                    eventsTopic.get(),\n+                    partition,\n+                    uuid,\n+                    message.body().getBytes(),\n+                    headers));\n+\n+    }\n+\n+    public synchronized ProducerActions<UUID, byte[]> getProducer() {\n+        if (producer == null) {\n+            producer = new AsyncProducer<UUID, byte[]>(\n+                    producerPproperties,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTI2NDcxNg=="}, "originalCommit": {"oid": "c198622ea1721d35d325218576f85b4e7e2a6c6e"}, "originalPosition": 95}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTYyNDQ2Nw==", "bodyText": "@famartinrh the original idea was send all events to the EventBus from storage and every consumer which is registered and configured can receive it and send to the destination regarding implemented technology i.e. Kafka, http, cloud event, etc.", "url": "https://github.com/Apicurio/apicurio-registry/pull/972#discussion_r521624467", "createdAt": "2020-11-11T20:38:44Z", "author": {"login": "dmvolod"}, "path": "storage/streams/src/main/java/io/apicurio/registry/streams/events/KafkaEventSink.java", "diffHunk": "@@ -0,0 +1,103 @@\n+package io.apicurio.registry.streams.events;\n+\n+import java.time.Instant;\n+import java.util.Optional;\n+import java.util.Properties;\n+import java.util.UUID;\n+\n+import javax.annotation.PostConstruct;\n+import javax.enterprise.context.ApplicationScoped;\n+import javax.inject.Inject;\n+\n+import org.apache.kafka.clients.producer.ProducerRecord;\n+import org.apache.kafka.common.header.Headers;\n+import org.apache.kafka.common.header.internals.RecordHeaders;\n+import org.apache.kafka.common.serialization.Serdes;\n+import org.eclipse.microprofile.config.inject.ConfigProperty;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import io.apicurio.registry.events.EventSink;\n+import io.apicurio.registry.utils.RegistryProperties;\n+import io.apicurio.registry.utils.kafka.AsyncProducer;\n+import io.apicurio.registry.utils.kafka.ProducerActions;\n+import io.vertx.core.buffer.Buffer;\n+import io.vertx.core.eventbus.Message;\n+\n+/**\n+ * @author Fabian Martinez\n+ */\n+@ApplicationScoped\n+public class KafkaEventSink implements EventSink {\n+\n+    private static final Logger log = LoggerFactory.getLogger(KafkaEventSink.class);\n+\n+    @Inject\n+    @RegistryProperties(\n+            value = {\"registry.streams.common\", \"registry.streams.events\"},\n+            empties = {\"ssl.endpoint.identification.algorithm=\"}\n+    )\n+    Properties producerPproperties;\n+\n+    private ProducerActions<UUID, byte[]> producer;\n+    private Integer partition;\n+\n+    @ConfigProperty(name = \"registry.events.kafka.topic\")\n+    Optional<String> eventsTopic;\n+\n+    @ConfigProperty(name = \"registry.events.kafka.topic-partition\")\n+    Optional<Integer> eventsTopicPartition;\n+\n+    @PostConstruct\n+    void init() {\n+        partition = eventsTopicPartition.orElse(0);\n+    }\n+\n+    @Override\n+    public String name() {\n+        return \"Kafka Sink\";\n+    }\n+\n+    @Override\n+    public boolean isConfigured() {\n+        return eventsTopic.isPresent();\n+    }\n+\n+    @Override\n+    public void handle(Message<Buffer> message) {\n+        String type = message.headers().get(\"type\");\n+\n+        log.info(\"Firing event \" + type);\n+\n+        UUID uuid = UUID.randomUUID();\n+\n+        Headers headers = new RecordHeaders();\n+        headers.add(\"ce_id\", uuid.toString().getBytes());\n+        headers.add(\"ce_specversion\", \"1.0\".getBytes());\n+        headers.add(\"ce_source\", \"apicurio-registry\".getBytes());\n+        headers.add(\"ce_type\", type.getBytes());\n+        headers.add(\"ce_time\", Instant.now().toString().getBytes());\n+        headers.add(\"content-type\", \"application/json\".getBytes());\n+\n+        getProducer()\n+            .apply(new ProducerRecord<UUID, byte[]>(\n+                    eventsTopic.get(),\n+                    partition,\n+                    uuid,\n+                    message.body().getBytes(),\n+                    headers));\n+\n+    }\n+\n+    public synchronized ProducerActions<UUID, byte[]> getProducer() {\n+        if (producer == null) {\n+            producer = new AsyncProducer<UUID, byte[]>(\n+                    producerPproperties,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTI2NDcxNg=="}, "originalCommit": {"oid": "c198622ea1721d35d325218576f85b4e7e2a6c6e"}, "originalPosition": 95}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjI1NTg1Ng==", "bodyText": "ok, I reorganized things so kafka events are available for all registry variants", "url": "https://github.com/Apicurio/apicurio-registry/pull/972#discussion_r522255856", "createdAt": "2020-11-12T16:49:14Z", "author": {"login": "famartinrh"}, "path": "storage/streams/src/main/java/io/apicurio/registry/streams/events/KafkaEventSink.java", "diffHunk": "@@ -0,0 +1,103 @@\n+package io.apicurio.registry.streams.events;\n+\n+import java.time.Instant;\n+import java.util.Optional;\n+import java.util.Properties;\n+import java.util.UUID;\n+\n+import javax.annotation.PostConstruct;\n+import javax.enterprise.context.ApplicationScoped;\n+import javax.inject.Inject;\n+\n+import org.apache.kafka.clients.producer.ProducerRecord;\n+import org.apache.kafka.common.header.Headers;\n+import org.apache.kafka.common.header.internals.RecordHeaders;\n+import org.apache.kafka.common.serialization.Serdes;\n+import org.eclipse.microprofile.config.inject.ConfigProperty;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import io.apicurio.registry.events.EventSink;\n+import io.apicurio.registry.utils.RegistryProperties;\n+import io.apicurio.registry.utils.kafka.AsyncProducer;\n+import io.apicurio.registry.utils.kafka.ProducerActions;\n+import io.vertx.core.buffer.Buffer;\n+import io.vertx.core.eventbus.Message;\n+\n+/**\n+ * @author Fabian Martinez\n+ */\n+@ApplicationScoped\n+public class KafkaEventSink implements EventSink {\n+\n+    private static final Logger log = LoggerFactory.getLogger(KafkaEventSink.class);\n+\n+    @Inject\n+    @RegistryProperties(\n+            value = {\"registry.streams.common\", \"registry.streams.events\"},\n+            empties = {\"ssl.endpoint.identification.algorithm=\"}\n+    )\n+    Properties producerPproperties;\n+\n+    private ProducerActions<UUID, byte[]> producer;\n+    private Integer partition;\n+\n+    @ConfigProperty(name = \"registry.events.kafka.topic\")\n+    Optional<String> eventsTopic;\n+\n+    @ConfigProperty(name = \"registry.events.kafka.topic-partition\")\n+    Optional<Integer> eventsTopicPartition;\n+\n+    @PostConstruct\n+    void init() {\n+        partition = eventsTopicPartition.orElse(0);\n+    }\n+\n+    @Override\n+    public String name() {\n+        return \"Kafka Sink\";\n+    }\n+\n+    @Override\n+    public boolean isConfigured() {\n+        return eventsTopic.isPresent();\n+    }\n+\n+    @Override\n+    public void handle(Message<Buffer> message) {\n+        String type = message.headers().get(\"type\");\n+\n+        log.info(\"Firing event \" + type);\n+\n+        UUID uuid = UUID.randomUUID();\n+\n+        Headers headers = new RecordHeaders();\n+        headers.add(\"ce_id\", uuid.toString().getBytes());\n+        headers.add(\"ce_specversion\", \"1.0\".getBytes());\n+        headers.add(\"ce_source\", \"apicurio-registry\".getBytes());\n+        headers.add(\"ce_type\", type.getBytes());\n+        headers.add(\"ce_time\", Instant.now().toString().getBytes());\n+        headers.add(\"content-type\", \"application/json\".getBytes());\n+\n+        getProducer()\n+            .apply(new ProducerRecord<UUID, byte[]>(\n+                    eventsTopic.get(),\n+                    partition,\n+                    uuid,\n+                    message.body().getBytes(),\n+                    headers));\n+\n+    }\n+\n+    public synchronized ProducerActions<UUID, byte[]> getProducer() {\n+        if (producer == null) {\n+            producer = new AsyncProducer<UUID, byte[]>(\n+                    producerPproperties,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTI2NDcxNg=="}, "originalCommit": {"oid": "c198622ea1721d35d325218576f85b4e7e2a6c6e"}, "originalPosition": 95}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3476, "cost": 1, "resetAt": "2021-11-12T09:44:50Z"}}}