{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTMyMDM1MzA1", "number": 1054, "reviewThreads": {"totalCount": 12, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wNFQwOTozNDozM1rOFAtetA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wNFQxMTowMDo0OFrOFAvvsQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM2Mjg5NDYwOnYy", "diffSide": "RIGHT", "path": "storage/ksql/src/main/java/io/apicurio/registry/storage/impl/ksql/sql/KafkaSqlStore.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wNFQwOTozNDozM1rOH_IgTg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wNFQxNjo0NDozOFrOH_ZEGQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTk2MTY3OA==", "bodyText": "I think this requires @Transactional", "url": "https://github.com/Apicurio/apicurio-registry/pull/1054#discussion_r535961678", "createdAt": "2020-12-04T09:34:33Z", "author": {"login": "famartinrh"}, "path": "storage/ksql/src/main/java/io/apicurio/registry/storage/impl/ksql/sql/KafkaSqlStore.java", "diffHunk": "@@ -0,0 +1,158 @@\n+package io.apicurio.registry.storage.impl.ksql.sql;\n+\n+import java.util.Date;\n+import java.util.concurrent.CompletionStage;\n+\n+import javax.annotation.PostConstruct;\n+import javax.enterprise.context.ApplicationScoped;\n+import javax.inject.Named;\n+\n+import org.jdbi.v3.core.HandleCallback;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import io.apicurio.registry.content.ContentHandle;\n+import io.apicurio.registry.storage.ArtifactMetaDataDto;\n+import io.apicurio.registry.storage.ArtifactNotFoundException;\n+import io.apicurio.registry.storage.EditableArtifactMetaDataDto;\n+import io.apicurio.registry.storage.RegistryStorageException;\n+import io.apicurio.registry.storage.impl.sql.AbstractSqlRegistryStorage;\n+import io.apicurio.registry.storage.impl.sql.GlobalIdGenerator;\n+import io.apicurio.registry.storage.impl.sql.mappers.ContentMapper;\n+import io.apicurio.registry.types.ArtifactState;\n+import io.apicurio.registry.types.ArtifactType;\n+import io.apicurio.registry.types.RuleType;\n+\n+/**\n+ * The SQL store used by the KSQL registry storage implementation.  This is ultimately where each\n+ * application replica stores its data after consuming it from the Kafka topic.  Often this is a \n+ * H2 in-memory database, but it could be something else (e.g. a local postgresql sidecar DB).\n+ * This class extends the core SQL registry storage to leverage as much of the existing SQL \n+ * support as possible.  However, this class extends the SQL support to include some functionality\n+ * only needed by the KSQL storage.\n+ * \n+ * @author eric.wittmann@gmail.com\n+ */\n+@ApplicationScoped\n+@Named(\"KafkaSqlStore\")\n+public class KafkaSqlStore extends AbstractSqlRegistryStorage {\n+\n+    private static final Logger log = LoggerFactory.getLogger(KafkaSqlStore.class);\n+\n+    @PostConstruct\n+    void onConstruct() {\n+        log.info(\"Using internal SQL storage.\");\n+    }\n+\n+    public <R, X extends Exception> R withHandle(HandleCallback<R, X> callback) {\n+        try {\n+            return this.jdbi.withHandle(callback);\n+        } catch (Exception e) {\n+            throw new RegistryStorageException(e);\n+        }\n+    }\n+\n+    public boolean isArtifactExists(String artifactId) throws RegistryStorageException {\n+        return withHandle( handle -> {\n+            String sql = sqlStatements().selectArtifactCountById();\n+            return handle.createQuery(sql)\n+                    .bind(0, artifactId)\n+                    .mapTo(Integer.class)\n+                    .one() > 0;\n+        });\n+    }\n+\n+    public boolean isContentExists(String contentHash) throws RegistryStorageException {\n+        return withHandle( handle -> {\n+            String sql = sqlStatements().selectContentCountByHash();\n+            return handle.createQuery(sql)\n+                    .bind(0, contentHash)\n+                    .mapTo(Integer.class)\n+                    .one() > 0;\n+        });\n+    }\n+\n+    public boolean isArtifactRuleExists(String artifactId, RuleType rule) throws RegistryStorageException {\n+        return withHandle( handle -> {\n+            String sql = sqlStatements().selectArtifactRuleCountByType();\n+            return handle.createQuery(sql)\n+                    .bind(0, artifactId)\n+                    .bind(1, rule.name())\n+                    .mapTo(Integer.class)\n+                    .one() > 0;\n+        });\n+    }\n+\n+    public boolean isGlobalRuleExists(RuleType rule) throws RegistryStorageException {\n+        return withHandle( handle -> {\n+            String sql = sqlStatements().selectGlobalRuleCountByType();\n+            return handle.createQuery(sql)\n+                    .bind(0, rule.name())\n+                    .mapTo(Integer.class)\n+                    .one() > 0;\n+        });\n+    }\n+    \n+    public void storeContent(String contentHash, ArtifactType artifactType, ContentHandle content) throws RegistryStorageException {\n+        withHandle( handle -> {\n+            super.createOrUpdateContent(handle, artifactType, content);\n+            return null;\n+        });\n+    }\n+    \n+    private ContentHandle getContent(long contentId) {\n+        return withHandle( handle -> {\n+            String sql = sqlStatements().selectContentById();\n+            return handle.createQuery(sql)\n+                    .bind(0, contentId)\n+                    .map(ContentMapper.instance)\n+                    .one();\n+        });\n+    }\n+\n+    public CompletionStage<ArtifactMetaDataDto> createArtifactWithMetadata(String artifactId,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "34f4d43b0fd02bee41028352cc2fc883c02d1f04"}, "originalPosition": 113}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjAzNDI5NA==", "bodyText": "The parent method that this method is calling is annotated. I don't think this is needed.", "url": "https://github.com/Apicurio/apicurio-registry/pull/1054#discussion_r536034294", "createdAt": "2020-12-04T11:32:30Z", "author": {"login": "carlesarnal"}, "path": "storage/ksql/src/main/java/io/apicurio/registry/storage/impl/ksql/sql/KafkaSqlStore.java", "diffHunk": "@@ -0,0 +1,158 @@\n+package io.apicurio.registry.storage.impl.ksql.sql;\n+\n+import java.util.Date;\n+import java.util.concurrent.CompletionStage;\n+\n+import javax.annotation.PostConstruct;\n+import javax.enterprise.context.ApplicationScoped;\n+import javax.inject.Named;\n+\n+import org.jdbi.v3.core.HandleCallback;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import io.apicurio.registry.content.ContentHandle;\n+import io.apicurio.registry.storage.ArtifactMetaDataDto;\n+import io.apicurio.registry.storage.ArtifactNotFoundException;\n+import io.apicurio.registry.storage.EditableArtifactMetaDataDto;\n+import io.apicurio.registry.storage.RegistryStorageException;\n+import io.apicurio.registry.storage.impl.sql.AbstractSqlRegistryStorage;\n+import io.apicurio.registry.storage.impl.sql.GlobalIdGenerator;\n+import io.apicurio.registry.storage.impl.sql.mappers.ContentMapper;\n+import io.apicurio.registry.types.ArtifactState;\n+import io.apicurio.registry.types.ArtifactType;\n+import io.apicurio.registry.types.RuleType;\n+\n+/**\n+ * The SQL store used by the KSQL registry storage implementation.  This is ultimately where each\n+ * application replica stores its data after consuming it from the Kafka topic.  Often this is a \n+ * H2 in-memory database, but it could be something else (e.g. a local postgresql sidecar DB).\n+ * This class extends the core SQL registry storage to leverage as much of the existing SQL \n+ * support as possible.  However, this class extends the SQL support to include some functionality\n+ * only needed by the KSQL storage.\n+ * \n+ * @author eric.wittmann@gmail.com\n+ */\n+@ApplicationScoped\n+@Named(\"KafkaSqlStore\")\n+public class KafkaSqlStore extends AbstractSqlRegistryStorage {\n+\n+    private static final Logger log = LoggerFactory.getLogger(KafkaSqlStore.class);\n+\n+    @PostConstruct\n+    void onConstruct() {\n+        log.info(\"Using internal SQL storage.\");\n+    }\n+\n+    public <R, X extends Exception> R withHandle(HandleCallback<R, X> callback) {\n+        try {\n+            return this.jdbi.withHandle(callback);\n+        } catch (Exception e) {\n+            throw new RegistryStorageException(e);\n+        }\n+    }\n+\n+    public boolean isArtifactExists(String artifactId) throws RegistryStorageException {\n+        return withHandle( handle -> {\n+            String sql = sqlStatements().selectArtifactCountById();\n+            return handle.createQuery(sql)\n+                    .bind(0, artifactId)\n+                    .mapTo(Integer.class)\n+                    .one() > 0;\n+        });\n+    }\n+\n+    public boolean isContentExists(String contentHash) throws RegistryStorageException {\n+        return withHandle( handle -> {\n+            String sql = sqlStatements().selectContentCountByHash();\n+            return handle.createQuery(sql)\n+                    .bind(0, contentHash)\n+                    .mapTo(Integer.class)\n+                    .one() > 0;\n+        });\n+    }\n+\n+    public boolean isArtifactRuleExists(String artifactId, RuleType rule) throws RegistryStorageException {\n+        return withHandle( handle -> {\n+            String sql = sqlStatements().selectArtifactRuleCountByType();\n+            return handle.createQuery(sql)\n+                    .bind(0, artifactId)\n+                    .bind(1, rule.name())\n+                    .mapTo(Integer.class)\n+                    .one() > 0;\n+        });\n+    }\n+\n+    public boolean isGlobalRuleExists(RuleType rule) throws RegistryStorageException {\n+        return withHandle( handle -> {\n+            String sql = sqlStatements().selectGlobalRuleCountByType();\n+            return handle.createQuery(sql)\n+                    .bind(0, rule.name())\n+                    .mapTo(Integer.class)\n+                    .one() > 0;\n+        });\n+    }\n+    \n+    public void storeContent(String contentHash, ArtifactType artifactType, ContentHandle content) throws RegistryStorageException {\n+        withHandle( handle -> {\n+            super.createOrUpdateContent(handle, artifactType, content);\n+            return null;\n+        });\n+    }\n+    \n+    private ContentHandle getContent(long contentId) {\n+        return withHandle( handle -> {\n+            String sql = sqlStatements().selectContentById();\n+            return handle.createQuery(sql)\n+                    .bind(0, contentId)\n+                    .map(ContentMapper.instance)\n+                    .one();\n+        });\n+    }\n+\n+    public CompletionStage<ArtifactMetaDataDto> createArtifactWithMetadata(String artifactId,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTk2MTY3OA=="}, "originalCommit": {"oid": "34f4d43b0fd02bee41028352cc2fc883c02d1f04"}, "originalPosition": 113}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjAzNjk1MA==", "bodyText": "Sorry, you were right, here we're also calling the protected method without annotation.", "url": "https://github.com/Apicurio/apicurio-registry/pull/1054#discussion_r536036950", "createdAt": "2020-12-04T11:37:34Z", "author": {"login": "carlesarnal"}, "path": "storage/ksql/src/main/java/io/apicurio/registry/storage/impl/ksql/sql/KafkaSqlStore.java", "diffHunk": "@@ -0,0 +1,158 @@\n+package io.apicurio.registry.storage.impl.ksql.sql;\n+\n+import java.util.Date;\n+import java.util.concurrent.CompletionStage;\n+\n+import javax.annotation.PostConstruct;\n+import javax.enterprise.context.ApplicationScoped;\n+import javax.inject.Named;\n+\n+import org.jdbi.v3.core.HandleCallback;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import io.apicurio.registry.content.ContentHandle;\n+import io.apicurio.registry.storage.ArtifactMetaDataDto;\n+import io.apicurio.registry.storage.ArtifactNotFoundException;\n+import io.apicurio.registry.storage.EditableArtifactMetaDataDto;\n+import io.apicurio.registry.storage.RegistryStorageException;\n+import io.apicurio.registry.storage.impl.sql.AbstractSqlRegistryStorage;\n+import io.apicurio.registry.storage.impl.sql.GlobalIdGenerator;\n+import io.apicurio.registry.storage.impl.sql.mappers.ContentMapper;\n+import io.apicurio.registry.types.ArtifactState;\n+import io.apicurio.registry.types.ArtifactType;\n+import io.apicurio.registry.types.RuleType;\n+\n+/**\n+ * The SQL store used by the KSQL registry storage implementation.  This is ultimately where each\n+ * application replica stores its data after consuming it from the Kafka topic.  Often this is a \n+ * H2 in-memory database, but it could be something else (e.g. a local postgresql sidecar DB).\n+ * This class extends the core SQL registry storage to leverage as much of the existing SQL \n+ * support as possible.  However, this class extends the SQL support to include some functionality\n+ * only needed by the KSQL storage.\n+ * \n+ * @author eric.wittmann@gmail.com\n+ */\n+@ApplicationScoped\n+@Named(\"KafkaSqlStore\")\n+public class KafkaSqlStore extends AbstractSqlRegistryStorage {\n+\n+    private static final Logger log = LoggerFactory.getLogger(KafkaSqlStore.class);\n+\n+    @PostConstruct\n+    void onConstruct() {\n+        log.info(\"Using internal SQL storage.\");\n+    }\n+\n+    public <R, X extends Exception> R withHandle(HandleCallback<R, X> callback) {\n+        try {\n+            return this.jdbi.withHandle(callback);\n+        } catch (Exception e) {\n+            throw new RegistryStorageException(e);\n+        }\n+    }\n+\n+    public boolean isArtifactExists(String artifactId) throws RegistryStorageException {\n+        return withHandle( handle -> {\n+            String sql = sqlStatements().selectArtifactCountById();\n+            return handle.createQuery(sql)\n+                    .bind(0, artifactId)\n+                    .mapTo(Integer.class)\n+                    .one() > 0;\n+        });\n+    }\n+\n+    public boolean isContentExists(String contentHash) throws RegistryStorageException {\n+        return withHandle( handle -> {\n+            String sql = sqlStatements().selectContentCountByHash();\n+            return handle.createQuery(sql)\n+                    .bind(0, contentHash)\n+                    .mapTo(Integer.class)\n+                    .one() > 0;\n+        });\n+    }\n+\n+    public boolean isArtifactRuleExists(String artifactId, RuleType rule) throws RegistryStorageException {\n+        return withHandle( handle -> {\n+            String sql = sqlStatements().selectArtifactRuleCountByType();\n+            return handle.createQuery(sql)\n+                    .bind(0, artifactId)\n+                    .bind(1, rule.name())\n+                    .mapTo(Integer.class)\n+                    .one() > 0;\n+        });\n+    }\n+\n+    public boolean isGlobalRuleExists(RuleType rule) throws RegistryStorageException {\n+        return withHandle( handle -> {\n+            String sql = sqlStatements().selectGlobalRuleCountByType();\n+            return handle.createQuery(sql)\n+                    .bind(0, rule.name())\n+                    .mapTo(Integer.class)\n+                    .one() > 0;\n+        });\n+    }\n+    \n+    public void storeContent(String contentHash, ArtifactType artifactType, ContentHandle content) throws RegistryStorageException {\n+        withHandle( handle -> {\n+            super.createOrUpdateContent(handle, artifactType, content);\n+            return null;\n+        });\n+    }\n+    \n+    private ContentHandle getContent(long contentId) {\n+        return withHandle( handle -> {\n+            String sql = sqlStatements().selectContentById();\n+            return handle.createQuery(sql)\n+                    .bind(0, contentId)\n+                    .map(ContentMapper.instance)\n+                    .one();\n+        });\n+    }\n+\n+    public CompletionStage<ArtifactMetaDataDto> createArtifactWithMetadata(String artifactId,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTk2MTY3OA=="}, "originalCommit": {"oid": "34f4d43b0fd02bee41028352cc2fc883c02d1f04"}, "originalPosition": 113}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjIzMjk4NQ==", "bodyText": "Technically this does not need to be transactional right now, because writes are single-threaded.  But still, it is more logically correct and consistent to make it transactional, so I will do that. :)", "url": "https://github.com/Apicurio/apicurio-registry/pull/1054#discussion_r536232985", "createdAt": "2020-12-04T16:44:38Z", "author": {"login": "EricWittmann"}, "path": "storage/ksql/src/main/java/io/apicurio/registry/storage/impl/ksql/sql/KafkaSqlStore.java", "diffHunk": "@@ -0,0 +1,158 @@\n+package io.apicurio.registry.storage.impl.ksql.sql;\n+\n+import java.util.Date;\n+import java.util.concurrent.CompletionStage;\n+\n+import javax.annotation.PostConstruct;\n+import javax.enterprise.context.ApplicationScoped;\n+import javax.inject.Named;\n+\n+import org.jdbi.v3.core.HandleCallback;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import io.apicurio.registry.content.ContentHandle;\n+import io.apicurio.registry.storage.ArtifactMetaDataDto;\n+import io.apicurio.registry.storage.ArtifactNotFoundException;\n+import io.apicurio.registry.storage.EditableArtifactMetaDataDto;\n+import io.apicurio.registry.storage.RegistryStorageException;\n+import io.apicurio.registry.storage.impl.sql.AbstractSqlRegistryStorage;\n+import io.apicurio.registry.storage.impl.sql.GlobalIdGenerator;\n+import io.apicurio.registry.storage.impl.sql.mappers.ContentMapper;\n+import io.apicurio.registry.types.ArtifactState;\n+import io.apicurio.registry.types.ArtifactType;\n+import io.apicurio.registry.types.RuleType;\n+\n+/**\n+ * The SQL store used by the KSQL registry storage implementation.  This is ultimately where each\n+ * application replica stores its data after consuming it from the Kafka topic.  Often this is a \n+ * H2 in-memory database, but it could be something else (e.g. a local postgresql sidecar DB).\n+ * This class extends the core SQL registry storage to leverage as much of the existing SQL \n+ * support as possible.  However, this class extends the SQL support to include some functionality\n+ * only needed by the KSQL storage.\n+ * \n+ * @author eric.wittmann@gmail.com\n+ */\n+@ApplicationScoped\n+@Named(\"KafkaSqlStore\")\n+public class KafkaSqlStore extends AbstractSqlRegistryStorage {\n+\n+    private static final Logger log = LoggerFactory.getLogger(KafkaSqlStore.class);\n+\n+    @PostConstruct\n+    void onConstruct() {\n+        log.info(\"Using internal SQL storage.\");\n+    }\n+\n+    public <R, X extends Exception> R withHandle(HandleCallback<R, X> callback) {\n+        try {\n+            return this.jdbi.withHandle(callback);\n+        } catch (Exception e) {\n+            throw new RegistryStorageException(e);\n+        }\n+    }\n+\n+    public boolean isArtifactExists(String artifactId) throws RegistryStorageException {\n+        return withHandle( handle -> {\n+            String sql = sqlStatements().selectArtifactCountById();\n+            return handle.createQuery(sql)\n+                    .bind(0, artifactId)\n+                    .mapTo(Integer.class)\n+                    .one() > 0;\n+        });\n+    }\n+\n+    public boolean isContentExists(String contentHash) throws RegistryStorageException {\n+        return withHandle( handle -> {\n+            String sql = sqlStatements().selectContentCountByHash();\n+            return handle.createQuery(sql)\n+                    .bind(0, contentHash)\n+                    .mapTo(Integer.class)\n+                    .one() > 0;\n+        });\n+    }\n+\n+    public boolean isArtifactRuleExists(String artifactId, RuleType rule) throws RegistryStorageException {\n+        return withHandle( handle -> {\n+            String sql = sqlStatements().selectArtifactRuleCountByType();\n+            return handle.createQuery(sql)\n+                    .bind(0, artifactId)\n+                    .bind(1, rule.name())\n+                    .mapTo(Integer.class)\n+                    .one() > 0;\n+        });\n+    }\n+\n+    public boolean isGlobalRuleExists(RuleType rule) throws RegistryStorageException {\n+        return withHandle( handle -> {\n+            String sql = sqlStatements().selectGlobalRuleCountByType();\n+            return handle.createQuery(sql)\n+                    .bind(0, rule.name())\n+                    .mapTo(Integer.class)\n+                    .one() > 0;\n+        });\n+    }\n+    \n+    public void storeContent(String contentHash, ArtifactType artifactType, ContentHandle content) throws RegistryStorageException {\n+        withHandle( handle -> {\n+            super.createOrUpdateContent(handle, artifactType, content);\n+            return null;\n+        });\n+    }\n+    \n+    private ContentHandle getContent(long contentId) {\n+        return withHandle( handle -> {\n+            String sql = sqlStatements().selectContentById();\n+            return handle.createQuery(sql)\n+                    .bind(0, contentId)\n+                    .map(ContentMapper.instance)\n+                    .one();\n+        });\n+    }\n+\n+    public CompletionStage<ArtifactMetaDataDto> createArtifactWithMetadata(String artifactId,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTk2MTY3OA=="}, "originalCommit": {"oid": "34f4d43b0fd02bee41028352cc2fc883c02d1f04"}, "originalPosition": 113}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM2Mjg5ODE2OnYy", "diffSide": "RIGHT", "path": "storage/ksql/src/main/java/io/apicurio/registry/storage/impl/ksql/sql/KafkaSqlStore.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wNFQwOTozNToyN1rOH_Iidg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wNFQxMTozNTo1M1rOH_NDCg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTk2MjIzMA==", "bodyText": "same as above and in some other places, I think we need to add @Transactional", "url": "https://github.com/Apicurio/apicurio-registry/pull/1054#discussion_r535962230", "createdAt": "2020-12-04T09:35:27Z", "author": {"login": "famartinrh"}, "path": "storage/ksql/src/main/java/io/apicurio/registry/storage/impl/ksql/sql/KafkaSqlStore.java", "diffHunk": "@@ -0,0 +1,158 @@\n+package io.apicurio.registry.storage.impl.ksql.sql;\n+\n+import java.util.Date;\n+import java.util.concurrent.CompletionStage;\n+\n+import javax.annotation.PostConstruct;\n+import javax.enterprise.context.ApplicationScoped;\n+import javax.inject.Named;\n+\n+import org.jdbi.v3.core.HandleCallback;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import io.apicurio.registry.content.ContentHandle;\n+import io.apicurio.registry.storage.ArtifactMetaDataDto;\n+import io.apicurio.registry.storage.ArtifactNotFoundException;\n+import io.apicurio.registry.storage.EditableArtifactMetaDataDto;\n+import io.apicurio.registry.storage.RegistryStorageException;\n+import io.apicurio.registry.storage.impl.sql.AbstractSqlRegistryStorage;\n+import io.apicurio.registry.storage.impl.sql.GlobalIdGenerator;\n+import io.apicurio.registry.storage.impl.sql.mappers.ContentMapper;\n+import io.apicurio.registry.types.ArtifactState;\n+import io.apicurio.registry.types.ArtifactType;\n+import io.apicurio.registry.types.RuleType;\n+\n+/**\n+ * The SQL store used by the KSQL registry storage implementation.  This is ultimately where each\n+ * application replica stores its data after consuming it from the Kafka topic.  Often this is a \n+ * H2 in-memory database, but it could be something else (e.g. a local postgresql sidecar DB).\n+ * This class extends the core SQL registry storage to leverage as much of the existing SQL \n+ * support as possible.  However, this class extends the SQL support to include some functionality\n+ * only needed by the KSQL storage.\n+ * \n+ * @author eric.wittmann@gmail.com\n+ */\n+@ApplicationScoped\n+@Named(\"KafkaSqlStore\")\n+public class KafkaSqlStore extends AbstractSqlRegistryStorage {\n+\n+    private static final Logger log = LoggerFactory.getLogger(KafkaSqlStore.class);\n+\n+    @PostConstruct\n+    void onConstruct() {\n+        log.info(\"Using internal SQL storage.\");\n+    }\n+\n+    public <R, X extends Exception> R withHandle(HandleCallback<R, X> callback) {\n+        try {\n+            return this.jdbi.withHandle(callback);\n+        } catch (Exception e) {\n+            throw new RegistryStorageException(e);\n+        }\n+    }\n+\n+    public boolean isArtifactExists(String artifactId) throws RegistryStorageException {\n+        return withHandle( handle -> {\n+            String sql = sqlStatements().selectArtifactCountById();\n+            return handle.createQuery(sql)\n+                    .bind(0, artifactId)\n+                    .mapTo(Integer.class)\n+                    .one() > 0;\n+        });\n+    }\n+\n+    public boolean isContentExists(String contentHash) throws RegistryStorageException {\n+        return withHandle( handle -> {\n+            String sql = sqlStatements().selectContentCountByHash();\n+            return handle.createQuery(sql)\n+                    .bind(0, contentHash)\n+                    .mapTo(Integer.class)\n+                    .one() > 0;\n+        });\n+    }\n+\n+    public boolean isArtifactRuleExists(String artifactId, RuleType rule) throws RegistryStorageException {\n+        return withHandle( handle -> {\n+            String sql = sqlStatements().selectArtifactRuleCountByType();\n+            return handle.createQuery(sql)\n+                    .bind(0, artifactId)\n+                    .bind(1, rule.name())\n+                    .mapTo(Integer.class)\n+                    .one() > 0;\n+        });\n+    }\n+\n+    public boolean isGlobalRuleExists(RuleType rule) throws RegistryStorageException {\n+        return withHandle( handle -> {\n+            String sql = sqlStatements().selectGlobalRuleCountByType();\n+            return handle.createQuery(sql)\n+                    .bind(0, rule.name())\n+                    .mapTo(Integer.class)\n+                    .one() > 0;\n+        });\n+    }\n+    \n+    public void storeContent(String contentHash, ArtifactType artifactType, ContentHandle content) throws RegistryStorageException {\n+        withHandle( handle -> {\n+            super.createOrUpdateContent(handle, artifactType, content);\n+            return null;\n+        });\n+    }\n+    \n+    private ContentHandle getContent(long contentId) {\n+        return withHandle( handle -> {\n+            String sql = sqlStatements().selectContentById();\n+            return handle.createQuery(sql)\n+                    .bind(0, contentId)\n+                    .map(ContentMapper.instance)\n+                    .one();\n+        });\n+    }\n+\n+    public CompletionStage<ArtifactMetaDataDto> createArtifactWithMetadata(String artifactId,\n+            ArtifactType artifactType, String contentHash, String createdBy,\n+            Date createdOn, EditableArtifactMetaDataDto metaData, GlobalIdGenerator globalIdGenerator)\n+            throws ArtifactNotFoundException, RegistryStorageException {\n+        long contentId = this.contentIdFromHash(contentHash);\n+        \n+        if (metaData == null) {\n+            ContentHandle content = this.getContent(contentId);\n+            metaData = this.extractMetaData(artifactType, content);\n+        }\n+        \n+        return super.createArtifactWithMetadata(artifactId, artifactType, contentId, createdBy, createdOn,\n+                metaData, globalIdGenerator);\n+    }\n+    \n+    public CompletionStage<ArtifactMetaDataDto> updateArtifactWithMetadata(String artifactId,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "34f4d43b0fd02bee41028352cc2fc883c02d1f04"}, "originalPosition": 128}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjAzNjEwNg==", "bodyText": "This may be true here since here we're calling the protected method directly and that method doesn't have the annotation.", "url": "https://github.com/Apicurio/apicurio-registry/pull/1054#discussion_r536036106", "createdAt": "2020-12-04T11:35:53Z", "author": {"login": "carlesarnal"}, "path": "storage/ksql/src/main/java/io/apicurio/registry/storage/impl/ksql/sql/KafkaSqlStore.java", "diffHunk": "@@ -0,0 +1,158 @@\n+package io.apicurio.registry.storage.impl.ksql.sql;\n+\n+import java.util.Date;\n+import java.util.concurrent.CompletionStage;\n+\n+import javax.annotation.PostConstruct;\n+import javax.enterprise.context.ApplicationScoped;\n+import javax.inject.Named;\n+\n+import org.jdbi.v3.core.HandleCallback;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import io.apicurio.registry.content.ContentHandle;\n+import io.apicurio.registry.storage.ArtifactMetaDataDto;\n+import io.apicurio.registry.storage.ArtifactNotFoundException;\n+import io.apicurio.registry.storage.EditableArtifactMetaDataDto;\n+import io.apicurio.registry.storage.RegistryStorageException;\n+import io.apicurio.registry.storage.impl.sql.AbstractSqlRegistryStorage;\n+import io.apicurio.registry.storage.impl.sql.GlobalIdGenerator;\n+import io.apicurio.registry.storage.impl.sql.mappers.ContentMapper;\n+import io.apicurio.registry.types.ArtifactState;\n+import io.apicurio.registry.types.ArtifactType;\n+import io.apicurio.registry.types.RuleType;\n+\n+/**\n+ * The SQL store used by the KSQL registry storage implementation.  This is ultimately where each\n+ * application replica stores its data after consuming it from the Kafka topic.  Often this is a \n+ * H2 in-memory database, but it could be something else (e.g. a local postgresql sidecar DB).\n+ * This class extends the core SQL registry storage to leverage as much of the existing SQL \n+ * support as possible.  However, this class extends the SQL support to include some functionality\n+ * only needed by the KSQL storage.\n+ * \n+ * @author eric.wittmann@gmail.com\n+ */\n+@ApplicationScoped\n+@Named(\"KafkaSqlStore\")\n+public class KafkaSqlStore extends AbstractSqlRegistryStorage {\n+\n+    private static final Logger log = LoggerFactory.getLogger(KafkaSqlStore.class);\n+\n+    @PostConstruct\n+    void onConstruct() {\n+        log.info(\"Using internal SQL storage.\");\n+    }\n+\n+    public <R, X extends Exception> R withHandle(HandleCallback<R, X> callback) {\n+        try {\n+            return this.jdbi.withHandle(callback);\n+        } catch (Exception e) {\n+            throw new RegistryStorageException(e);\n+        }\n+    }\n+\n+    public boolean isArtifactExists(String artifactId) throws RegistryStorageException {\n+        return withHandle( handle -> {\n+            String sql = sqlStatements().selectArtifactCountById();\n+            return handle.createQuery(sql)\n+                    .bind(0, artifactId)\n+                    .mapTo(Integer.class)\n+                    .one() > 0;\n+        });\n+    }\n+\n+    public boolean isContentExists(String contentHash) throws RegistryStorageException {\n+        return withHandle( handle -> {\n+            String sql = sqlStatements().selectContentCountByHash();\n+            return handle.createQuery(sql)\n+                    .bind(0, contentHash)\n+                    .mapTo(Integer.class)\n+                    .one() > 0;\n+        });\n+    }\n+\n+    public boolean isArtifactRuleExists(String artifactId, RuleType rule) throws RegistryStorageException {\n+        return withHandle( handle -> {\n+            String sql = sqlStatements().selectArtifactRuleCountByType();\n+            return handle.createQuery(sql)\n+                    .bind(0, artifactId)\n+                    .bind(1, rule.name())\n+                    .mapTo(Integer.class)\n+                    .one() > 0;\n+        });\n+    }\n+\n+    public boolean isGlobalRuleExists(RuleType rule) throws RegistryStorageException {\n+        return withHandle( handle -> {\n+            String sql = sqlStatements().selectGlobalRuleCountByType();\n+            return handle.createQuery(sql)\n+                    .bind(0, rule.name())\n+                    .mapTo(Integer.class)\n+                    .one() > 0;\n+        });\n+    }\n+    \n+    public void storeContent(String contentHash, ArtifactType artifactType, ContentHandle content) throws RegistryStorageException {\n+        withHandle( handle -> {\n+            super.createOrUpdateContent(handle, artifactType, content);\n+            return null;\n+        });\n+    }\n+    \n+    private ContentHandle getContent(long contentId) {\n+        return withHandle( handle -> {\n+            String sql = sqlStatements().selectContentById();\n+            return handle.createQuery(sql)\n+                    .bind(0, contentId)\n+                    .map(ContentMapper.instance)\n+                    .one();\n+        });\n+    }\n+\n+    public CompletionStage<ArtifactMetaDataDto> createArtifactWithMetadata(String artifactId,\n+            ArtifactType artifactType, String contentHash, String createdBy,\n+            Date createdOn, EditableArtifactMetaDataDto metaData, GlobalIdGenerator globalIdGenerator)\n+            throws ArtifactNotFoundException, RegistryStorageException {\n+        long contentId = this.contentIdFromHash(contentHash);\n+        \n+        if (metaData == null) {\n+            ContentHandle content = this.getContent(contentId);\n+            metaData = this.extractMetaData(artifactType, content);\n+        }\n+        \n+        return super.createArtifactWithMetadata(artifactId, artifactType, contentId, createdBy, createdOn,\n+                metaData, globalIdGenerator);\n+    }\n+    \n+    public CompletionStage<ArtifactMetaDataDto> updateArtifactWithMetadata(String artifactId,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTk2MjIzMA=="}, "originalCommit": {"oid": "34f4d43b0fd02bee41028352cc2fc883c02d1f04"}, "originalPosition": 128}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM2MjkxMzc5OnYy", "diffSide": "RIGHT", "path": "storage/ksql/src/main/java/io/apicurio/registry/storage/impl/ksql/KafkaSqlRegistryStorage.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wNFQwOTozOTowNVrOH_IrbQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wNFQxNzowNjoyM1rOH_Z4UQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTk2NDUyNQ==", "bodyText": "in createArtifactWithMetadata you are not doing this, I guess because the SQL store is doing it when receiving the kafka message, so, should we remove this here or add it to createArtifactWithMetadata?", "url": "https://github.com/Apicurio/apicurio-registry/pull/1054#discussion_r535964525", "createdAt": "2020-12-04T09:39:05Z", "author": {"login": "famartinrh"}, "path": "storage/ksql/src/main/java/io/apicurio/registry/storage/impl/ksql/KafkaSqlRegistryStorage.java", "diffHunk": "@@ -253,125 +256,139 @@ private void startConsumerThread(final KafkaConsumer<String, Str.StorageValue> c\n         props.putIfAbsent(ConsumerConfig.AUTO_OFFSET_RESET_CONFIG, \"earliest\");\n \n         // Create the Kafka Consumer\n-        KafkaConsumer<String, Str.StorageValue> consumer = new KafkaConsumer<>(props,\n-                Serdes.String().deserializer(),\n-                ProtoSerde.parsedWith(Str.StorageValue.parser()));\n+        KafkaSqlKeyDeserializer keyDeserializer = new KafkaSqlKeyDeserializer();\n+        KafkaSqlValueDeserializer valueDeserializer = new KafkaSqlValueDeserializer();\n+        KafkaConsumer<MessageKey, MessageValue> consumer = new KafkaConsumer<>(props, keyDeserializer, valueDeserializer);\n         return consumer;\n     }\n \n-    private void updateArtifactState(ArtifactState currentState, String artifactId, Integer version, ArtifactState state) {\n-        ArtifactStateExt.applyState(\n-            s ->  {\n-                UUID reqId = ConcurrentUtil.get(submitter.submitState(artifactId, version.longValue(), s));\n-                coordinator.waitForResponse(reqId);\n-            },\n-            currentState,\n-            state\n-        );\n+    /**\n+     * Ensures that the given content exists in the database.  If it's already in the DB, then this just \n+     * returns the content hash.  If the content does not yet exist in the DB, then it is added (by sending\n+     * the appropriate message to the Kafka topic and awaiting the response).\n+     * \n+     * @param content\n+     * @param artifactId\n+     * @param artifactType\n+     */\n+    private String ensureContent(ContentHandle content, String artifactId, ArtifactType artifactType) {\n+        byte[] contentBytes = content.bytes();\n+        String contentHash = DigestUtils.sha256Hex(contentBytes);\n+        \n+        if (!sqlStore.isContentExists(contentHash)) {\n+            CompletableFuture<UUID> future = submitter.submitContent(artifactId, contentHash, artifactType, content);\n+            UUID uuid = ConcurrentUtil.get(future);\n+            coordinator.waitForResponse(uuid);\n+        }\n+        \n+        return contentHash;\n     }\n \n+    \n     //TODO implement is Ready and is alive checking if the state is fully updated\n \n-    @Override\n-    public void updateArtifactState(String artifactId, ArtifactState state) {\n-        ArtifactMetaDataDto metadata = sqlStorage.getArtifactMetaData(artifactId);\n-        updateArtifactState(metadata.getState(), artifactId, metadata.getVersion(), state);\n-    }\n-\n-    @Override\n-    public void updateArtifactState(String artifactId, ArtifactState state, Integer version) {\n-        ArtifactVersionMetaDataDto metadata = sqlStorage.getArtifactVersionMetaData(artifactId, version);\n-        updateArtifactState(metadata.getState(), artifactId, version, state);\n-    }\n-\n+    /**\n+     * @see io.apicurio.registry.storage.RegistryStorage#createArtifact(java.lang.String, io.apicurio.registry.types.ArtifactType, io.apicurio.registry.content.ContentHandle)\n+     */\n     @Override\n     public CompletionStage<ArtifactMetaDataDto> createArtifact(String artifactId, ArtifactType artifactType, ContentHandle content) throws ArtifactAlreadyExistsException, RegistryStorageException {\n-\n-        try {\n-            sqlStorage.getArtifactMetaData(artifactId);\n-            throw new ArtifactAlreadyExistsException(artifactId);\n-        } catch (ArtifactNotFoundException e) {\n-            //ignored\n-            //artifact does not exist, we can create it\n-        }\n-\n-        return submitter\n-                .submitArtifact(Str.ActionType.CREATE, artifactId, -1, artifactType, content.bytes())\n-                .thenCompose(reqId -> {\n-                    return (CompletionStage<ArtifactMetaDataDto>) coordinator.waitForResponse(reqId);\n-                });\n+        return createArtifactWithMetadata(artifactId, artifactType, content, null);\n     }\n \n+    /**\n+     * @see io.apicurio.registry.storage.RegistryStorage#createArtifactWithMetadata(java.lang.String, io.apicurio.registry.types.ArtifactType, io.apicurio.registry.content.ContentHandle, io.apicurio.registry.storage.EditableArtifactMetaDataDto)\n+     */\n     @Override\n     public CompletionStage<ArtifactMetaDataDto> createArtifactWithMetadata(String artifactId, ArtifactType artifactType,\n             ContentHandle content, EditableArtifactMetaDataDto metaData) throws ArtifactAlreadyExistsException, RegistryStorageException {\n-        return createArtifact(artifactId, artifactType, content)\n-            .thenCompose(amdd ->\n-                submitter.submitMetadata(Str.ActionType.UPDATE, artifactId, -1, metaData.getName(), metaData.getDescription(), metaData.getLabels(), metaData.getProperties())\n-                    .thenAccept(reqId -> coordinator.waitForResponse(reqId))\n-                    .thenApply(v -> DtoUtil.setEditableMetaDataInArtifact(amdd, metaData))\n-            );\n-\n+        if (sqlStore.isArtifactExists(artifactId)) {\n+            throw new ArtifactAlreadyExistsException(artifactId);\n+        }\n+        \n+        String contentHash = ensureContent(content, artifactId, artifactType);\n+        String createdBy = null; // TODO populate when authentication is available\n+        Date createdOn = new Date();\n+        \n+        return submitter\n+                .submitArtifact(artifactId, ActionType.Create, artifactType, contentHash, createdBy, createdOn, metaData)\n+                .thenCompose(reqId -> (CompletionStage<ArtifactMetaDataDto>) coordinator.waitForResponse(reqId));\n     }\n \n+    /**\n+     * @see io.apicurio.registry.storage.RegistryStorage#deleteArtifact(java.lang.String)\n+     */\n     @Override\n     public SortedSet<Long> deleteArtifact(String artifactId) throws ArtifactNotFoundException, RegistryStorageException {\n+        if (!sqlStore.isArtifactExists(artifactId)) {\n+            throw new ArtifactNotFoundException(artifactId);\n+        }\n \n-        //to verify artifact exists\n-        //TODO implement a low level storage api that provides methods like, exists, ...\n-        sqlStorage.getArtifactMetaData(artifactId);\n-\n-        UUID reqId = ConcurrentUtil.get(submitter.submitArtifact(Str.ActionType.DELETE, artifactId, -1, null, null));\n+        UUID reqId = ConcurrentUtil.get(submitter.submitArtifact(artifactId, ActionType.Delete));\n         SortedSet<Long> versionIds = (SortedSet<Long>) coordinator.waitForResponse(reqId);\n \n         return versionIds;\n     }\n \n+    /**\n+     * @see io.apicurio.registry.storage.RegistryStorage#getArtifact(java.lang.String)\n+     */\n     @Override\n     public StoredArtifact getArtifact(String artifactId) throws ArtifactNotFoundException, RegistryStorageException {\n-        return sqlStorage.getArtifact(artifactId);\n+        return sqlStore.getArtifact(artifactId);\n     }\n \n+    /**\n+     * @see io.apicurio.registry.storage.RegistryStorage#updateArtifact(java.lang.String, io.apicurio.registry.types.ArtifactType, io.apicurio.registry.content.ContentHandle)\n+     */\n     @Override\n     public CompletionStage<ArtifactMetaDataDto> updateArtifact(String artifactId, ArtifactType artifactType, ContentHandle content) throws ArtifactNotFoundException, RegistryStorageException {\n+        return updateArtifactWithMetadata(artifactId, artifactType, content, null);\n+    }\n \n-        try {\n-            sqlStorage.getArtifactMetaData(artifactId);\n-        } catch (ArtifactNotFoundException e) {\n-            throw e;\n+    /**\n+     * @see io.apicurio.registry.storage.RegistryStorage#updateArtifactWithMetadata(java.lang.String, io.apicurio.registry.types.ArtifactType, io.apicurio.registry.content.ContentHandle, io.apicurio.registry.storage.EditableArtifactMetaDataDto)\n+     */\n+    @Override\n+    public CompletionStage<ArtifactMetaDataDto> updateArtifactWithMetadata(String artifactId, ArtifactType artifactType, ContentHandle content, EditableArtifactMetaDataDto metaData) throws ArtifactAlreadyExistsException, RegistryStorageException {\n+        if (!sqlStore.isArtifactExists(artifactId)) {\n+            throw new ArtifactNotFoundException(artifactId);\n         }\n \n+        String contentHash = ensureContent(content, artifactId, artifactType);\n+        String createdBy = null; // TODO populate when authentication is available\n+        Date createdOn = new Date();\n+        \n+        if (metaData == null) {\n+            metaData = extractMetaData(artifactType, content);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "34f4d43b0fd02bee41028352cc2fc883c02d1f04"}, "originalPosition": 392}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjI0NDgwNw==", "bodyText": "Yes good point.  I'll think about this a little bit more.  The logic is a little bit twisted right now and might be subtly different between the CREATE and UPDATE cases.", "url": "https://github.com/Apicurio/apicurio-registry/pull/1054#discussion_r536244807", "createdAt": "2020-12-04T17:02:56Z", "author": {"login": "EricWittmann"}, "path": "storage/ksql/src/main/java/io/apicurio/registry/storage/impl/ksql/KafkaSqlRegistryStorage.java", "diffHunk": "@@ -253,125 +256,139 @@ private void startConsumerThread(final KafkaConsumer<String, Str.StorageValue> c\n         props.putIfAbsent(ConsumerConfig.AUTO_OFFSET_RESET_CONFIG, \"earliest\");\n \n         // Create the Kafka Consumer\n-        KafkaConsumer<String, Str.StorageValue> consumer = new KafkaConsumer<>(props,\n-                Serdes.String().deserializer(),\n-                ProtoSerde.parsedWith(Str.StorageValue.parser()));\n+        KafkaSqlKeyDeserializer keyDeserializer = new KafkaSqlKeyDeserializer();\n+        KafkaSqlValueDeserializer valueDeserializer = new KafkaSqlValueDeserializer();\n+        KafkaConsumer<MessageKey, MessageValue> consumer = new KafkaConsumer<>(props, keyDeserializer, valueDeserializer);\n         return consumer;\n     }\n \n-    private void updateArtifactState(ArtifactState currentState, String artifactId, Integer version, ArtifactState state) {\n-        ArtifactStateExt.applyState(\n-            s ->  {\n-                UUID reqId = ConcurrentUtil.get(submitter.submitState(artifactId, version.longValue(), s));\n-                coordinator.waitForResponse(reqId);\n-            },\n-            currentState,\n-            state\n-        );\n+    /**\n+     * Ensures that the given content exists in the database.  If it's already in the DB, then this just \n+     * returns the content hash.  If the content does not yet exist in the DB, then it is added (by sending\n+     * the appropriate message to the Kafka topic and awaiting the response).\n+     * \n+     * @param content\n+     * @param artifactId\n+     * @param artifactType\n+     */\n+    private String ensureContent(ContentHandle content, String artifactId, ArtifactType artifactType) {\n+        byte[] contentBytes = content.bytes();\n+        String contentHash = DigestUtils.sha256Hex(contentBytes);\n+        \n+        if (!sqlStore.isContentExists(contentHash)) {\n+            CompletableFuture<UUID> future = submitter.submitContent(artifactId, contentHash, artifactType, content);\n+            UUID uuid = ConcurrentUtil.get(future);\n+            coordinator.waitForResponse(uuid);\n+        }\n+        \n+        return contentHash;\n     }\n \n+    \n     //TODO implement is Ready and is alive checking if the state is fully updated\n \n-    @Override\n-    public void updateArtifactState(String artifactId, ArtifactState state) {\n-        ArtifactMetaDataDto metadata = sqlStorage.getArtifactMetaData(artifactId);\n-        updateArtifactState(metadata.getState(), artifactId, metadata.getVersion(), state);\n-    }\n-\n-    @Override\n-    public void updateArtifactState(String artifactId, ArtifactState state, Integer version) {\n-        ArtifactVersionMetaDataDto metadata = sqlStorage.getArtifactVersionMetaData(artifactId, version);\n-        updateArtifactState(metadata.getState(), artifactId, version, state);\n-    }\n-\n+    /**\n+     * @see io.apicurio.registry.storage.RegistryStorage#createArtifact(java.lang.String, io.apicurio.registry.types.ArtifactType, io.apicurio.registry.content.ContentHandle)\n+     */\n     @Override\n     public CompletionStage<ArtifactMetaDataDto> createArtifact(String artifactId, ArtifactType artifactType, ContentHandle content) throws ArtifactAlreadyExistsException, RegistryStorageException {\n-\n-        try {\n-            sqlStorage.getArtifactMetaData(artifactId);\n-            throw new ArtifactAlreadyExistsException(artifactId);\n-        } catch (ArtifactNotFoundException e) {\n-            //ignored\n-            //artifact does not exist, we can create it\n-        }\n-\n-        return submitter\n-                .submitArtifact(Str.ActionType.CREATE, artifactId, -1, artifactType, content.bytes())\n-                .thenCompose(reqId -> {\n-                    return (CompletionStage<ArtifactMetaDataDto>) coordinator.waitForResponse(reqId);\n-                });\n+        return createArtifactWithMetadata(artifactId, artifactType, content, null);\n     }\n \n+    /**\n+     * @see io.apicurio.registry.storage.RegistryStorage#createArtifactWithMetadata(java.lang.String, io.apicurio.registry.types.ArtifactType, io.apicurio.registry.content.ContentHandle, io.apicurio.registry.storage.EditableArtifactMetaDataDto)\n+     */\n     @Override\n     public CompletionStage<ArtifactMetaDataDto> createArtifactWithMetadata(String artifactId, ArtifactType artifactType,\n             ContentHandle content, EditableArtifactMetaDataDto metaData) throws ArtifactAlreadyExistsException, RegistryStorageException {\n-        return createArtifact(artifactId, artifactType, content)\n-            .thenCompose(amdd ->\n-                submitter.submitMetadata(Str.ActionType.UPDATE, artifactId, -1, metaData.getName(), metaData.getDescription(), metaData.getLabels(), metaData.getProperties())\n-                    .thenAccept(reqId -> coordinator.waitForResponse(reqId))\n-                    .thenApply(v -> DtoUtil.setEditableMetaDataInArtifact(amdd, metaData))\n-            );\n-\n+        if (sqlStore.isArtifactExists(artifactId)) {\n+            throw new ArtifactAlreadyExistsException(artifactId);\n+        }\n+        \n+        String contentHash = ensureContent(content, artifactId, artifactType);\n+        String createdBy = null; // TODO populate when authentication is available\n+        Date createdOn = new Date();\n+        \n+        return submitter\n+                .submitArtifact(artifactId, ActionType.Create, artifactType, contentHash, createdBy, createdOn, metaData)\n+                .thenCompose(reqId -> (CompletionStage<ArtifactMetaDataDto>) coordinator.waitForResponse(reqId));\n     }\n \n+    /**\n+     * @see io.apicurio.registry.storage.RegistryStorage#deleteArtifact(java.lang.String)\n+     */\n     @Override\n     public SortedSet<Long> deleteArtifact(String artifactId) throws ArtifactNotFoundException, RegistryStorageException {\n+        if (!sqlStore.isArtifactExists(artifactId)) {\n+            throw new ArtifactNotFoundException(artifactId);\n+        }\n \n-        //to verify artifact exists\n-        //TODO implement a low level storage api that provides methods like, exists, ...\n-        sqlStorage.getArtifactMetaData(artifactId);\n-\n-        UUID reqId = ConcurrentUtil.get(submitter.submitArtifact(Str.ActionType.DELETE, artifactId, -1, null, null));\n+        UUID reqId = ConcurrentUtil.get(submitter.submitArtifact(artifactId, ActionType.Delete));\n         SortedSet<Long> versionIds = (SortedSet<Long>) coordinator.waitForResponse(reqId);\n \n         return versionIds;\n     }\n \n+    /**\n+     * @see io.apicurio.registry.storage.RegistryStorage#getArtifact(java.lang.String)\n+     */\n     @Override\n     public StoredArtifact getArtifact(String artifactId) throws ArtifactNotFoundException, RegistryStorageException {\n-        return sqlStorage.getArtifact(artifactId);\n+        return sqlStore.getArtifact(artifactId);\n     }\n \n+    /**\n+     * @see io.apicurio.registry.storage.RegistryStorage#updateArtifact(java.lang.String, io.apicurio.registry.types.ArtifactType, io.apicurio.registry.content.ContentHandle)\n+     */\n     @Override\n     public CompletionStage<ArtifactMetaDataDto> updateArtifact(String artifactId, ArtifactType artifactType, ContentHandle content) throws ArtifactNotFoundException, RegistryStorageException {\n+        return updateArtifactWithMetadata(artifactId, artifactType, content, null);\n+    }\n \n-        try {\n-            sqlStorage.getArtifactMetaData(artifactId);\n-        } catch (ArtifactNotFoundException e) {\n-            throw e;\n+    /**\n+     * @see io.apicurio.registry.storage.RegistryStorage#updateArtifactWithMetadata(java.lang.String, io.apicurio.registry.types.ArtifactType, io.apicurio.registry.content.ContentHandle, io.apicurio.registry.storage.EditableArtifactMetaDataDto)\n+     */\n+    @Override\n+    public CompletionStage<ArtifactMetaDataDto> updateArtifactWithMetadata(String artifactId, ArtifactType artifactType, ContentHandle content, EditableArtifactMetaDataDto metaData) throws ArtifactAlreadyExistsException, RegistryStorageException {\n+        if (!sqlStore.isArtifactExists(artifactId)) {\n+            throw new ArtifactNotFoundException(artifactId);\n         }\n \n+        String contentHash = ensureContent(content, artifactId, artifactType);\n+        String createdBy = null; // TODO populate when authentication is available\n+        Date createdOn = new Date();\n+        \n+        if (metaData == null) {\n+            metaData = extractMetaData(artifactType, content);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTk2NDUyNQ=="}, "originalCommit": {"oid": "34f4d43b0fd02bee41028352cc2fc883c02d1f04"}, "originalPosition": 392}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjI0NTk1MQ==", "bodyText": "I attacked Create and Update at different times and hilariously came up with different solutions.  In the Create case I'm re-loading the content from the DB in order to extract the metadata when processing the Kafka message.  In the Update case I'm extracting the metadata first and then sending it along as part of the Kafka message.  I think the latter is better so I will change the Create case to follow that pattern.", "url": "https://github.com/Apicurio/apicurio-registry/pull/1054#discussion_r536245951", "createdAt": "2020-12-04T17:05:26Z", "author": {"login": "EricWittmann"}, "path": "storage/ksql/src/main/java/io/apicurio/registry/storage/impl/ksql/KafkaSqlRegistryStorage.java", "diffHunk": "@@ -253,125 +256,139 @@ private void startConsumerThread(final KafkaConsumer<String, Str.StorageValue> c\n         props.putIfAbsent(ConsumerConfig.AUTO_OFFSET_RESET_CONFIG, \"earliest\");\n \n         // Create the Kafka Consumer\n-        KafkaConsumer<String, Str.StorageValue> consumer = new KafkaConsumer<>(props,\n-                Serdes.String().deserializer(),\n-                ProtoSerde.parsedWith(Str.StorageValue.parser()));\n+        KafkaSqlKeyDeserializer keyDeserializer = new KafkaSqlKeyDeserializer();\n+        KafkaSqlValueDeserializer valueDeserializer = new KafkaSqlValueDeserializer();\n+        KafkaConsumer<MessageKey, MessageValue> consumer = new KafkaConsumer<>(props, keyDeserializer, valueDeserializer);\n         return consumer;\n     }\n \n-    private void updateArtifactState(ArtifactState currentState, String artifactId, Integer version, ArtifactState state) {\n-        ArtifactStateExt.applyState(\n-            s ->  {\n-                UUID reqId = ConcurrentUtil.get(submitter.submitState(artifactId, version.longValue(), s));\n-                coordinator.waitForResponse(reqId);\n-            },\n-            currentState,\n-            state\n-        );\n+    /**\n+     * Ensures that the given content exists in the database.  If it's already in the DB, then this just \n+     * returns the content hash.  If the content does not yet exist in the DB, then it is added (by sending\n+     * the appropriate message to the Kafka topic and awaiting the response).\n+     * \n+     * @param content\n+     * @param artifactId\n+     * @param artifactType\n+     */\n+    private String ensureContent(ContentHandle content, String artifactId, ArtifactType artifactType) {\n+        byte[] contentBytes = content.bytes();\n+        String contentHash = DigestUtils.sha256Hex(contentBytes);\n+        \n+        if (!sqlStore.isContentExists(contentHash)) {\n+            CompletableFuture<UUID> future = submitter.submitContent(artifactId, contentHash, artifactType, content);\n+            UUID uuid = ConcurrentUtil.get(future);\n+            coordinator.waitForResponse(uuid);\n+        }\n+        \n+        return contentHash;\n     }\n \n+    \n     //TODO implement is Ready and is alive checking if the state is fully updated\n \n-    @Override\n-    public void updateArtifactState(String artifactId, ArtifactState state) {\n-        ArtifactMetaDataDto metadata = sqlStorage.getArtifactMetaData(artifactId);\n-        updateArtifactState(metadata.getState(), artifactId, metadata.getVersion(), state);\n-    }\n-\n-    @Override\n-    public void updateArtifactState(String artifactId, ArtifactState state, Integer version) {\n-        ArtifactVersionMetaDataDto metadata = sqlStorage.getArtifactVersionMetaData(artifactId, version);\n-        updateArtifactState(metadata.getState(), artifactId, version, state);\n-    }\n-\n+    /**\n+     * @see io.apicurio.registry.storage.RegistryStorage#createArtifact(java.lang.String, io.apicurio.registry.types.ArtifactType, io.apicurio.registry.content.ContentHandle)\n+     */\n     @Override\n     public CompletionStage<ArtifactMetaDataDto> createArtifact(String artifactId, ArtifactType artifactType, ContentHandle content) throws ArtifactAlreadyExistsException, RegistryStorageException {\n-\n-        try {\n-            sqlStorage.getArtifactMetaData(artifactId);\n-            throw new ArtifactAlreadyExistsException(artifactId);\n-        } catch (ArtifactNotFoundException e) {\n-            //ignored\n-            //artifact does not exist, we can create it\n-        }\n-\n-        return submitter\n-                .submitArtifact(Str.ActionType.CREATE, artifactId, -1, artifactType, content.bytes())\n-                .thenCompose(reqId -> {\n-                    return (CompletionStage<ArtifactMetaDataDto>) coordinator.waitForResponse(reqId);\n-                });\n+        return createArtifactWithMetadata(artifactId, artifactType, content, null);\n     }\n \n+    /**\n+     * @see io.apicurio.registry.storage.RegistryStorage#createArtifactWithMetadata(java.lang.String, io.apicurio.registry.types.ArtifactType, io.apicurio.registry.content.ContentHandle, io.apicurio.registry.storage.EditableArtifactMetaDataDto)\n+     */\n     @Override\n     public CompletionStage<ArtifactMetaDataDto> createArtifactWithMetadata(String artifactId, ArtifactType artifactType,\n             ContentHandle content, EditableArtifactMetaDataDto metaData) throws ArtifactAlreadyExistsException, RegistryStorageException {\n-        return createArtifact(artifactId, artifactType, content)\n-            .thenCompose(amdd ->\n-                submitter.submitMetadata(Str.ActionType.UPDATE, artifactId, -1, metaData.getName(), metaData.getDescription(), metaData.getLabels(), metaData.getProperties())\n-                    .thenAccept(reqId -> coordinator.waitForResponse(reqId))\n-                    .thenApply(v -> DtoUtil.setEditableMetaDataInArtifact(amdd, metaData))\n-            );\n-\n+        if (sqlStore.isArtifactExists(artifactId)) {\n+            throw new ArtifactAlreadyExistsException(artifactId);\n+        }\n+        \n+        String contentHash = ensureContent(content, artifactId, artifactType);\n+        String createdBy = null; // TODO populate when authentication is available\n+        Date createdOn = new Date();\n+        \n+        return submitter\n+                .submitArtifact(artifactId, ActionType.Create, artifactType, contentHash, createdBy, createdOn, metaData)\n+                .thenCompose(reqId -> (CompletionStage<ArtifactMetaDataDto>) coordinator.waitForResponse(reqId));\n     }\n \n+    /**\n+     * @see io.apicurio.registry.storage.RegistryStorage#deleteArtifact(java.lang.String)\n+     */\n     @Override\n     public SortedSet<Long> deleteArtifact(String artifactId) throws ArtifactNotFoundException, RegistryStorageException {\n+        if (!sqlStore.isArtifactExists(artifactId)) {\n+            throw new ArtifactNotFoundException(artifactId);\n+        }\n \n-        //to verify artifact exists\n-        //TODO implement a low level storage api that provides methods like, exists, ...\n-        sqlStorage.getArtifactMetaData(artifactId);\n-\n-        UUID reqId = ConcurrentUtil.get(submitter.submitArtifact(Str.ActionType.DELETE, artifactId, -1, null, null));\n+        UUID reqId = ConcurrentUtil.get(submitter.submitArtifact(artifactId, ActionType.Delete));\n         SortedSet<Long> versionIds = (SortedSet<Long>) coordinator.waitForResponse(reqId);\n \n         return versionIds;\n     }\n \n+    /**\n+     * @see io.apicurio.registry.storage.RegistryStorage#getArtifact(java.lang.String)\n+     */\n     @Override\n     public StoredArtifact getArtifact(String artifactId) throws ArtifactNotFoundException, RegistryStorageException {\n-        return sqlStorage.getArtifact(artifactId);\n+        return sqlStore.getArtifact(artifactId);\n     }\n \n+    /**\n+     * @see io.apicurio.registry.storage.RegistryStorage#updateArtifact(java.lang.String, io.apicurio.registry.types.ArtifactType, io.apicurio.registry.content.ContentHandle)\n+     */\n     @Override\n     public CompletionStage<ArtifactMetaDataDto> updateArtifact(String artifactId, ArtifactType artifactType, ContentHandle content) throws ArtifactNotFoundException, RegistryStorageException {\n+        return updateArtifactWithMetadata(artifactId, artifactType, content, null);\n+    }\n \n-        try {\n-            sqlStorage.getArtifactMetaData(artifactId);\n-        } catch (ArtifactNotFoundException e) {\n-            throw e;\n+    /**\n+     * @see io.apicurio.registry.storage.RegistryStorage#updateArtifactWithMetadata(java.lang.String, io.apicurio.registry.types.ArtifactType, io.apicurio.registry.content.ContentHandle, io.apicurio.registry.storage.EditableArtifactMetaDataDto)\n+     */\n+    @Override\n+    public CompletionStage<ArtifactMetaDataDto> updateArtifactWithMetadata(String artifactId, ArtifactType artifactType, ContentHandle content, EditableArtifactMetaDataDto metaData) throws ArtifactAlreadyExistsException, RegistryStorageException {\n+        if (!sqlStore.isArtifactExists(artifactId)) {\n+            throw new ArtifactNotFoundException(artifactId);\n         }\n \n+        String contentHash = ensureContent(content, artifactId, artifactType);\n+        String createdBy = null; // TODO populate when authentication is available\n+        Date createdOn = new Date();\n+        \n+        if (metaData == null) {\n+            metaData = extractMetaData(artifactType, content);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTk2NDUyNQ=="}, "originalCommit": {"oid": "34f4d43b0fd02bee41028352cc2fc883c02d1f04"}, "originalPosition": 392}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjI0NjM1Mw==", "bodyText": "The net result of that change is we'll have more information in the Kafka message and thus less processing to do when consuming it.", "url": "https://github.com/Apicurio/apicurio-registry/pull/1054#discussion_r536246353", "createdAt": "2020-12-04T17:06:23Z", "author": {"login": "EricWittmann"}, "path": "storage/ksql/src/main/java/io/apicurio/registry/storage/impl/ksql/KafkaSqlRegistryStorage.java", "diffHunk": "@@ -253,125 +256,139 @@ private void startConsumerThread(final KafkaConsumer<String, Str.StorageValue> c\n         props.putIfAbsent(ConsumerConfig.AUTO_OFFSET_RESET_CONFIG, \"earliest\");\n \n         // Create the Kafka Consumer\n-        KafkaConsumer<String, Str.StorageValue> consumer = new KafkaConsumer<>(props,\n-                Serdes.String().deserializer(),\n-                ProtoSerde.parsedWith(Str.StorageValue.parser()));\n+        KafkaSqlKeyDeserializer keyDeserializer = new KafkaSqlKeyDeserializer();\n+        KafkaSqlValueDeserializer valueDeserializer = new KafkaSqlValueDeserializer();\n+        KafkaConsumer<MessageKey, MessageValue> consumer = new KafkaConsumer<>(props, keyDeserializer, valueDeserializer);\n         return consumer;\n     }\n \n-    private void updateArtifactState(ArtifactState currentState, String artifactId, Integer version, ArtifactState state) {\n-        ArtifactStateExt.applyState(\n-            s ->  {\n-                UUID reqId = ConcurrentUtil.get(submitter.submitState(artifactId, version.longValue(), s));\n-                coordinator.waitForResponse(reqId);\n-            },\n-            currentState,\n-            state\n-        );\n+    /**\n+     * Ensures that the given content exists in the database.  If it's already in the DB, then this just \n+     * returns the content hash.  If the content does not yet exist in the DB, then it is added (by sending\n+     * the appropriate message to the Kafka topic and awaiting the response).\n+     * \n+     * @param content\n+     * @param artifactId\n+     * @param artifactType\n+     */\n+    private String ensureContent(ContentHandle content, String artifactId, ArtifactType artifactType) {\n+        byte[] contentBytes = content.bytes();\n+        String contentHash = DigestUtils.sha256Hex(contentBytes);\n+        \n+        if (!sqlStore.isContentExists(contentHash)) {\n+            CompletableFuture<UUID> future = submitter.submitContent(artifactId, contentHash, artifactType, content);\n+            UUID uuid = ConcurrentUtil.get(future);\n+            coordinator.waitForResponse(uuid);\n+        }\n+        \n+        return contentHash;\n     }\n \n+    \n     //TODO implement is Ready and is alive checking if the state is fully updated\n \n-    @Override\n-    public void updateArtifactState(String artifactId, ArtifactState state) {\n-        ArtifactMetaDataDto metadata = sqlStorage.getArtifactMetaData(artifactId);\n-        updateArtifactState(metadata.getState(), artifactId, metadata.getVersion(), state);\n-    }\n-\n-    @Override\n-    public void updateArtifactState(String artifactId, ArtifactState state, Integer version) {\n-        ArtifactVersionMetaDataDto metadata = sqlStorage.getArtifactVersionMetaData(artifactId, version);\n-        updateArtifactState(metadata.getState(), artifactId, version, state);\n-    }\n-\n+    /**\n+     * @see io.apicurio.registry.storage.RegistryStorage#createArtifact(java.lang.String, io.apicurio.registry.types.ArtifactType, io.apicurio.registry.content.ContentHandle)\n+     */\n     @Override\n     public CompletionStage<ArtifactMetaDataDto> createArtifact(String artifactId, ArtifactType artifactType, ContentHandle content) throws ArtifactAlreadyExistsException, RegistryStorageException {\n-\n-        try {\n-            sqlStorage.getArtifactMetaData(artifactId);\n-            throw new ArtifactAlreadyExistsException(artifactId);\n-        } catch (ArtifactNotFoundException e) {\n-            //ignored\n-            //artifact does not exist, we can create it\n-        }\n-\n-        return submitter\n-                .submitArtifact(Str.ActionType.CREATE, artifactId, -1, artifactType, content.bytes())\n-                .thenCompose(reqId -> {\n-                    return (CompletionStage<ArtifactMetaDataDto>) coordinator.waitForResponse(reqId);\n-                });\n+        return createArtifactWithMetadata(artifactId, artifactType, content, null);\n     }\n \n+    /**\n+     * @see io.apicurio.registry.storage.RegistryStorage#createArtifactWithMetadata(java.lang.String, io.apicurio.registry.types.ArtifactType, io.apicurio.registry.content.ContentHandle, io.apicurio.registry.storage.EditableArtifactMetaDataDto)\n+     */\n     @Override\n     public CompletionStage<ArtifactMetaDataDto> createArtifactWithMetadata(String artifactId, ArtifactType artifactType,\n             ContentHandle content, EditableArtifactMetaDataDto metaData) throws ArtifactAlreadyExistsException, RegistryStorageException {\n-        return createArtifact(artifactId, artifactType, content)\n-            .thenCompose(amdd ->\n-                submitter.submitMetadata(Str.ActionType.UPDATE, artifactId, -1, metaData.getName(), metaData.getDescription(), metaData.getLabels(), metaData.getProperties())\n-                    .thenAccept(reqId -> coordinator.waitForResponse(reqId))\n-                    .thenApply(v -> DtoUtil.setEditableMetaDataInArtifact(amdd, metaData))\n-            );\n-\n+        if (sqlStore.isArtifactExists(artifactId)) {\n+            throw new ArtifactAlreadyExistsException(artifactId);\n+        }\n+        \n+        String contentHash = ensureContent(content, artifactId, artifactType);\n+        String createdBy = null; // TODO populate when authentication is available\n+        Date createdOn = new Date();\n+        \n+        return submitter\n+                .submitArtifact(artifactId, ActionType.Create, artifactType, contentHash, createdBy, createdOn, metaData)\n+                .thenCompose(reqId -> (CompletionStage<ArtifactMetaDataDto>) coordinator.waitForResponse(reqId));\n     }\n \n+    /**\n+     * @see io.apicurio.registry.storage.RegistryStorage#deleteArtifact(java.lang.String)\n+     */\n     @Override\n     public SortedSet<Long> deleteArtifact(String artifactId) throws ArtifactNotFoundException, RegistryStorageException {\n+        if (!sqlStore.isArtifactExists(artifactId)) {\n+            throw new ArtifactNotFoundException(artifactId);\n+        }\n \n-        //to verify artifact exists\n-        //TODO implement a low level storage api that provides methods like, exists, ...\n-        sqlStorage.getArtifactMetaData(artifactId);\n-\n-        UUID reqId = ConcurrentUtil.get(submitter.submitArtifact(Str.ActionType.DELETE, artifactId, -1, null, null));\n+        UUID reqId = ConcurrentUtil.get(submitter.submitArtifact(artifactId, ActionType.Delete));\n         SortedSet<Long> versionIds = (SortedSet<Long>) coordinator.waitForResponse(reqId);\n \n         return versionIds;\n     }\n \n+    /**\n+     * @see io.apicurio.registry.storage.RegistryStorage#getArtifact(java.lang.String)\n+     */\n     @Override\n     public StoredArtifact getArtifact(String artifactId) throws ArtifactNotFoundException, RegistryStorageException {\n-        return sqlStorage.getArtifact(artifactId);\n+        return sqlStore.getArtifact(artifactId);\n     }\n \n+    /**\n+     * @see io.apicurio.registry.storage.RegistryStorage#updateArtifact(java.lang.String, io.apicurio.registry.types.ArtifactType, io.apicurio.registry.content.ContentHandle)\n+     */\n     @Override\n     public CompletionStage<ArtifactMetaDataDto> updateArtifact(String artifactId, ArtifactType artifactType, ContentHandle content) throws ArtifactNotFoundException, RegistryStorageException {\n+        return updateArtifactWithMetadata(artifactId, artifactType, content, null);\n+    }\n \n-        try {\n-            sqlStorage.getArtifactMetaData(artifactId);\n-        } catch (ArtifactNotFoundException e) {\n-            throw e;\n+    /**\n+     * @see io.apicurio.registry.storage.RegistryStorage#updateArtifactWithMetadata(java.lang.String, io.apicurio.registry.types.ArtifactType, io.apicurio.registry.content.ContentHandle, io.apicurio.registry.storage.EditableArtifactMetaDataDto)\n+     */\n+    @Override\n+    public CompletionStage<ArtifactMetaDataDto> updateArtifactWithMetadata(String artifactId, ArtifactType artifactType, ContentHandle content, EditableArtifactMetaDataDto metaData) throws ArtifactAlreadyExistsException, RegistryStorageException {\n+        if (!sqlStore.isArtifactExists(artifactId)) {\n+            throw new ArtifactNotFoundException(artifactId);\n         }\n \n+        String contentHash = ensureContent(content, artifactId, artifactType);\n+        String createdBy = null; // TODO populate when authentication is available\n+        Date createdOn = new Date();\n+        \n+        if (metaData == null) {\n+            metaData = extractMetaData(artifactType, content);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTk2NDUyNQ=="}, "originalCommit": {"oid": "34f4d43b0fd02bee41028352cc2fc883c02d1f04"}, "originalPosition": 392}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM2Mjk0ODc4OnYy", "diffSide": "RIGHT", "path": "storage/ksql/src/main/java/io/apicurio/registry/storage/impl/ksql/KafkaSqlRegistryStorage.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wNFQwOTo0NjozMlrOH_I_IA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wNFQxNzoxNTozOFrOH_aKdA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTk2OTU2OA==", "bodyText": "use here log compaction to remove all global rules at once? It's ok if not implemented now, but add a note here then", "url": "https://github.com/Apicurio/apicurio-registry/pull/1054#discussion_r535969568", "createdAt": "2020-12-04T09:46:32Z", "author": {"login": "famartinrh"}, "path": "storage/ksql/src/main/java/io/apicurio/registry/storage/impl/ksql/KafkaSqlRegistryStorage.java", "diffHunk": "@@ -380,209 +397,324 @@ public ArtifactMetaDataDto getArtifactMetaData(String artifactId) throws Artifac\n     @Override\n     public ArtifactVersionMetaDataDto getArtifactVersionMetaData(String artifactId, boolean canonical,\n             ContentHandle content) throws ArtifactNotFoundException, RegistryStorageException {\n-        return sqlStorage.getArtifactVersionMetaData(artifactId, canonical, content);\n+        return sqlStore.getArtifactVersionMetaData(artifactId, canonical, content);\n     }\n \n+    /**\n+     * @see io.apicurio.registry.storage.RegistryStorage#getArtifactMetaData(long)\n+     */\n     @Override\n     public ArtifactMetaDataDto getArtifactMetaData(long id) throws ArtifactNotFoundException, RegistryStorageException {\n-        return sqlStorage.getArtifactMetaData(id);\n+        return sqlStore.getArtifactMetaData(id);\n     }\n \n+    /**\n+     * @see io.apicurio.registry.storage.RegistryStorage#updateArtifactMetaData(java.lang.String, io.apicurio.registry.storage.EditableArtifactMetaDataDto)\n+     */\n     @Override\n     public void updateArtifactMetaData(String artifactId, EditableArtifactMetaDataDto metaData) throws ArtifactNotFoundException, RegistryStorageException {\n-\n-        try {\n-            sqlStorage.getArtifactMetaData(artifactId);\n-        } catch (ArtifactNotFoundException e) {\n-            throw e;\n-        }\n-\n-        UUID reqId = ConcurrentUtil.get(submitter\n-                .submitMetadata(Str.ActionType.UPDATE, artifactId, -1, metaData.getName(), metaData.getDescription(), metaData.getLabels(), metaData.getProperties()));\n+        // Note: the next line will throw ArtifactNotFoundException if the artifact does not exist, so there is no need for an extra check.\n+        ArtifactMetaDataDto metaDataDto = sqlStore.getArtifactMetaData(artifactId);\n+        \n+        UUID reqId = ConcurrentUtil.get(submitter.submitArtifactVersion(artifactId, metaDataDto.getVersion(), ActionType.Update, metaDataDto.getState(), metaData));\n         coordinator.waitForResponse(reqId);\n     }\n \n+    /**\n+     * @see io.apicurio.registry.storage.RegistryStorage#getArtifactRules(java.lang.String)\n+     */\n     @Override\n     public List<RuleType> getArtifactRules(String artifactId) throws ArtifactNotFoundException, RegistryStorageException {\n-        return sqlStorage.getArtifactRules(artifactId);\n+        return sqlStore.getArtifactRules(artifactId);\n     }\n \n+    /**\n+     * @see io.apicurio.registry.storage.RegistryStorage#createArtifactRuleAsync(java.lang.String, io.apicurio.registry.types.RuleType, io.apicurio.registry.storage.RuleConfigurationDto)\n+     */\n     @Override\n     public CompletionStage<Void> createArtifactRuleAsync(String artifactId, RuleType rule, RuleConfigurationDto config) throws ArtifactNotFoundException, RuleAlreadyExistsException, RegistryStorageException {\n-\n-        try {\n-            sqlStorage.getArtifactRule(artifactId, rule);\n+        if (sqlStore.isArtifactRuleExists(artifactId, rule)) {\n             throw new RuleAlreadyExistsException(rule);\n-        } catch (RuleNotFoundException e) {\n-            //rule does not exist, we can create it\n         }\n \n         return submitter\n-                .submitRule(Str.ActionType.CREATE, artifactId, rule, config.getConfiguration())\n-                .thenCompose(reqId -> (CompletionStage<Void>) coordinator.waitForResponse(reqId));\n+                .submitArtifactRule(artifactId, rule, ActionType.Create, config)\n+                .thenCompose(reqId -> {\n+                    CompletionStage<Void> rval = (CompletionStage<Void>) coordinator.waitForResponse(reqId);\n+                    log.debug(\"===============> Artifact rule (async) completed.  Rval: {}\", rval);\n+                    return rval;\n+                });\n     }\n \n+    /**\n+     * @see io.apicurio.registry.storage.RegistryStorage#deleteArtifactRules(java.lang.String)\n+     */\n     @Override\n     public void deleteArtifactRules(String artifactId) throws ArtifactNotFoundException, RegistryStorageException {\n-        try {\n-            sqlStorage.getArtifactMetaData(artifactId);\n-        } catch (ArtifactNotFoundException e) {\n-            throw e;\n+        if (!sqlStore.isArtifactExists(artifactId)) {\n+            throw new ArtifactNotFoundException(artifactId);\n         }\n \n-        deleteArtifactRulesInternal(artifactId);\n-    }\n-\n-    private void deleteArtifactRulesInternal(String artifactId) {\n-        UUID reqId = ConcurrentUtil.get(submitter.submitRule(Str.ActionType.DELETE, artifactId, null, null));\n-        coordinator.waitForResponse(reqId);\n+        // TODO find a better way to implement deleting all rules?  This isn't very scalable if we add more rules.\n+        \n+        submitter.submitArtifactRule(artifactId, RuleType.COMPATIBILITY, ActionType.Delete);\n+        \n+        UUID reqId = ConcurrentUtil.get(submitter.submitArtifactRule(artifactId, RuleType.VALIDITY, ActionType.Delete));\n+        try {\n+            coordinator.waitForResponse(reqId);\n+        } catch (RuleNotFoundException e) {\n+            // Eat this exception - we don't care if the rule didn't exist.\n+        }\n     }\n \n+    /**\n+     * @see io.apicurio.registry.storage.RegistryStorage#getArtifactRule(java.lang.String, io.apicurio.registry.types.RuleType)\n+     */\n     @Override\n     public RuleConfigurationDto getArtifactRule(String artifactId, RuleType rule) throws ArtifactNotFoundException, RuleNotFoundException, RegistryStorageException {\n-        return sqlStorage.getArtifactRule(artifactId, rule);\n+        return sqlStore.getArtifactRule(artifactId, rule);\n     }\n \n+    /**\n+     * @see io.apicurio.registry.storage.RegistryStorage#updateArtifactRule(java.lang.String, io.apicurio.registry.types.RuleType, io.apicurio.registry.storage.RuleConfigurationDto)\n+     */\n     @Override\n     public void updateArtifactRule(String artifactId, RuleType rule, RuleConfigurationDto config) throws ArtifactNotFoundException, RuleNotFoundException, RegistryStorageException {\n-\n-        try {\n-            sqlStorage.getArtifactRule(artifactId, rule);\n-        } catch (RuleNotFoundException e) {\n-            throw e;\n+        if (!sqlStore.isArtifactRuleExists(artifactId, rule)) {\n+            throw new RuleNotFoundException(rule);\n         }\n \n-        UUID reqId = ConcurrentUtil.get(submitter.submitRule(Str.ActionType.UPDATE, artifactId, rule, config.getConfiguration()));\n+        UUID reqId = ConcurrentUtil.get(submitter.submitArtifactRule(artifactId, rule, ActionType.Update, config));\n         coordinator.waitForResponse(reqId);\n     }\n \n+    /**\n+     * @see io.apicurio.registry.storage.RegistryStorage#deleteArtifactRule(java.lang.String, io.apicurio.registry.types.RuleType)\n+     */\n     @Override\n     public void deleteArtifactRule(String artifactId, RuleType rule) throws ArtifactNotFoundException, RuleNotFoundException, RegistryStorageException {\n-        try {\n-            sqlStorage.getArtifactRule(artifactId, rule);\n-        } catch (RuleNotFoundException e) {\n-            throw e;\n+        if (!sqlStore.isArtifactRuleExists(artifactId, rule)) {\n+            throw new RuleNotFoundException(rule);\n         }\n-        UUID reqId = ConcurrentUtil.get(submitter.submitRule(Str.ActionType.DELETE, artifactId, rule, null));\n+\n+        UUID reqId = ConcurrentUtil.get(submitter.submitArtifactRule(artifactId, rule, ActionType.Delete));\n         coordinator.waitForResponse(reqId);\n     }\n \n+    /**\n+     * @see io.apicurio.registry.storage.RegistryStorage#getArtifactVersions(java.lang.String)\n+     */\n     @Override\n     public SortedSet<Long> getArtifactVersions(String artifactId) throws ArtifactNotFoundException, RegistryStorageException {\n-        return sqlStorage.getArtifactVersions(artifactId);\n+        return sqlStore.getArtifactVersions(artifactId);\n     }\n \n+    /**\n+     * @see io.apicurio.registry.storage.RegistryStorage#searchVersions(java.lang.String, int, int)\n+     */\n     @Override\n     public VersionSearchResults searchVersions(String artifactId, int offset, int limit) {\n-        return sqlStorage.searchVersions(artifactId, offset, limit);\n+        return sqlStore.searchVersions(artifactId, offset, limit);\n     }\n \n+    /**\n+     * @see io.apicurio.registry.storage.RegistryStorage#getArtifactVersion(long)\n+     */\n     @Override\n     public StoredArtifact getArtifactVersion(long id) throws ArtifactNotFoundException, RegistryStorageException {\n-        return sqlStorage.getArtifactVersion(id);\n+        return sqlStore.getArtifactVersion(id);\n     }\n \n+    /**\n+     * @see io.apicurio.registry.storage.RegistryStorage#getArtifactVersion(java.lang.String, long)\n+     */\n     @Override\n     public StoredArtifact getArtifactVersion(String artifactId, long version) throws ArtifactNotFoundException, VersionNotFoundException, RegistryStorageException {\n-        return sqlStorage.getArtifactVersion(artifactId, version);\n+        return sqlStore.getArtifactVersion(artifactId, version);\n     }\n \n+    /**\n+     * @see io.apicurio.registry.storage.RegistryStorage#getArtifactVersionMetaData(java.lang.String, long)\n+     */\n     @Override\n     public ArtifactVersionMetaDataDto getArtifactVersionMetaData(String artifactId, long version) throws ArtifactNotFoundException, VersionNotFoundException, RegistryStorageException {\n-        return sqlStorage.getArtifactVersionMetaData(artifactId, version);\n+        return sqlStore.getArtifactVersionMetaData(artifactId, version);\n     }\n \n+    /**\n+     * @see io.apicurio.registry.storage.RegistryStorage#deleteArtifactVersion(java.lang.String, long)\n+     */\n     @Override\n     public void deleteArtifactVersion(String artifactId, long version) throws ArtifactNotFoundException, VersionNotFoundException, RegistryStorageException {\n         handleVersion(artifactId, version, null, value -> {\n-            UUID reqId = ConcurrentUtil.get(submitter.submitArtifact(Str.ActionType.DELETE, artifactId, version, null, null));\n+            UUID reqId = ConcurrentUtil.get(submitter.submitVersion(artifactId, (int) version, ActionType.Delete));\n             coordinator.waitForResponse(reqId);\n             return null;\n         });\n     }\n \n+    /**\n+     * @see io.apicurio.registry.storage.RegistryStorage#updateArtifactVersionMetaData(java.lang.String, long, io.apicurio.registry.storage.EditableArtifactMetaDataDto)\n+     */\n     @Override\n     public void updateArtifactVersionMetaData(String artifactId, long version, EditableArtifactMetaDataDto metaData) throws ArtifactNotFoundException, VersionNotFoundException, RegistryStorageException {\n-        handleVersion(\n-            artifactId,\n-            version,\n-            ArtifactStateExt.ACTIVE_STATES,\n-            value -> {\n-                UUID reqId = ConcurrentUtil.get(submitter\n-                        .submitMetadata(Str.ActionType.UPDATE, artifactId, version, metaData.getName(), metaData.getDescription(), metaData.getLabels(), metaData.getProperties()));\n-                coordinator.waitForResponse(reqId);\n-                return null;\n-            }\n-        );\n+        handleVersion(artifactId, version, ArtifactStateExt.ACTIVE_STATES, value -> {\n+            UUID reqId = ConcurrentUtil.get(submitter.submitArtifactVersion(artifactId, (int) version, ActionType.Update, value.getState(), metaData));\n+            return coordinator.waitForResponse(reqId);\n+        });\n     }\n \n+    /**\n+     * @see io.apicurio.registry.storage.RegistryStorage#deleteArtifactVersionMetaData(java.lang.String, long)\n+     */\n     @Override\n     public void deleteArtifactVersionMetaData(String artifactId, long version) throws ArtifactNotFoundException, VersionNotFoundException, RegistryStorageException {\n-        handleVersion(\n-            artifactId,\n-            version,\n-            null,\n-            value -> {\n-                UUID reqId = ConcurrentUtil.get(submitter.submitMetadata(Str.ActionType.DELETE, artifactId, version, null, null, Collections.emptyList(), Collections.emptyMap()));\n-                coordinator.waitForResponse(reqId);\n-                return null;\n-            }\n-        );\n+        handleVersion(artifactId, version, null, value -> {\n+            UUID reqId = ConcurrentUtil.get(submitter.submitVersion(artifactId, (int) version, ActionType.Clear));\n+            return coordinator.waitForResponse(reqId);\n+        });\n     }\n \n-    private <T> T handleVersion(String artifactId, long version, EnumSet<ArtifactState> states, Function<ArtifactVersionMetaDataDto, T> handler) throws ArtifactNotFoundException, RegistryStorageException {\n-        ArtifactVersionMetaDataDto metadata = sqlStorage.getArtifactVersionMetaData(artifactId, version);\n+    /**\n+     * Fetches the meta data for the given artifact version, validates the state (optionally), and then calls back the handler\n+     * with the metadata.  If the artifact is not found, this will throw an exception.\n+     * \n+     * @param artifactId\n+     * @param version\n+     * @param states\n+     * @param handler\n+     * @throws ArtifactNotFoundException\n+     * @throws RegistryStorageException\n+     */\n+    private <T> T handleVersion(String artifactId, long version, EnumSet<ArtifactState> states, Function<ArtifactVersionMetaDataDto, T> handler) \n+            throws ArtifactNotFoundException, RegistryStorageException {\n+        \n+        ArtifactVersionMetaDataDto metadata = sqlStore.getArtifactVersionMetaData(artifactId, version);\n \n         ArtifactState state = metadata.getState();\n         ArtifactStateExt.validateState(states, state, artifactId, version);\n         return handler.apply(metadata);\n     }\n \n+    /**\n+     * @see io.apicurio.registry.storage.RegistryStorage#getGlobalRules()\n+     */\n     @Override\n     public List<RuleType> getGlobalRules() throws RegistryStorageException {\n-        return sqlStorage.getGlobalRules();\n+        return sqlStore.getGlobalRules();\n     }\n \n+    /**\n+     * @see io.apicurio.registry.storage.RegistryStorage#createGlobalRule(io.apicurio.registry.types.RuleType, io.apicurio.registry.storage.RuleConfigurationDto)\n+     */\n     @Override\n     public void createGlobalRule(RuleType rule, RuleConfigurationDto config) throws RuleAlreadyExistsException, RegistryStorageException {\n-        UUID reqId = ConcurrentUtil.get(submitter.submitRule(Str.ActionType.CREATE, GLOBAL_RULES_ID, rule, config.getConfiguration()));\n+        UUID reqId = ConcurrentUtil.get(submitter.submitGlobalRule(rule, ActionType.Create, config));\n         coordinator.waitForResponse(reqId);\n     }\n \n+    /**\n+     * @see io.apicurio.registry.storage.RegistryStorage#deleteGlobalRules()\n+     */\n     @Override\n     public void deleteGlobalRules() throws RegistryStorageException {\n-        UUID reqId = ConcurrentUtil.get(submitter.submitRule(Str.ActionType.DELETE, GLOBAL_RULES_ID, null, null));\n-        coordinator.waitForResponse(reqId);\n-\n+        // TODO find a better way to implement deleting all global rules?  This isn't very scalable if we add more rules.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "34f4d43b0fd02bee41028352cc2fc883c02d1f04"}, "originalPosition": 742}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjI1MDk5Ng==", "bodyText": "How would we use log compaction for this?  We need multiple messages - one for each rule.  No?", "url": "https://github.com/Apicurio/apicurio-registry/pull/1054#discussion_r536250996", "createdAt": "2020-12-04T17:15:38Z", "author": {"login": "EricWittmann"}, "path": "storage/ksql/src/main/java/io/apicurio/registry/storage/impl/ksql/KafkaSqlRegistryStorage.java", "diffHunk": "@@ -380,209 +397,324 @@ public ArtifactMetaDataDto getArtifactMetaData(String artifactId) throws Artifac\n     @Override\n     public ArtifactVersionMetaDataDto getArtifactVersionMetaData(String artifactId, boolean canonical,\n             ContentHandle content) throws ArtifactNotFoundException, RegistryStorageException {\n-        return sqlStorage.getArtifactVersionMetaData(artifactId, canonical, content);\n+        return sqlStore.getArtifactVersionMetaData(artifactId, canonical, content);\n     }\n \n+    /**\n+     * @see io.apicurio.registry.storage.RegistryStorage#getArtifactMetaData(long)\n+     */\n     @Override\n     public ArtifactMetaDataDto getArtifactMetaData(long id) throws ArtifactNotFoundException, RegistryStorageException {\n-        return sqlStorage.getArtifactMetaData(id);\n+        return sqlStore.getArtifactMetaData(id);\n     }\n \n+    /**\n+     * @see io.apicurio.registry.storage.RegistryStorage#updateArtifactMetaData(java.lang.String, io.apicurio.registry.storage.EditableArtifactMetaDataDto)\n+     */\n     @Override\n     public void updateArtifactMetaData(String artifactId, EditableArtifactMetaDataDto metaData) throws ArtifactNotFoundException, RegistryStorageException {\n-\n-        try {\n-            sqlStorage.getArtifactMetaData(artifactId);\n-        } catch (ArtifactNotFoundException e) {\n-            throw e;\n-        }\n-\n-        UUID reqId = ConcurrentUtil.get(submitter\n-                .submitMetadata(Str.ActionType.UPDATE, artifactId, -1, metaData.getName(), metaData.getDescription(), metaData.getLabels(), metaData.getProperties()));\n+        // Note: the next line will throw ArtifactNotFoundException if the artifact does not exist, so there is no need for an extra check.\n+        ArtifactMetaDataDto metaDataDto = sqlStore.getArtifactMetaData(artifactId);\n+        \n+        UUID reqId = ConcurrentUtil.get(submitter.submitArtifactVersion(artifactId, metaDataDto.getVersion(), ActionType.Update, metaDataDto.getState(), metaData));\n         coordinator.waitForResponse(reqId);\n     }\n \n+    /**\n+     * @see io.apicurio.registry.storage.RegistryStorage#getArtifactRules(java.lang.String)\n+     */\n     @Override\n     public List<RuleType> getArtifactRules(String artifactId) throws ArtifactNotFoundException, RegistryStorageException {\n-        return sqlStorage.getArtifactRules(artifactId);\n+        return sqlStore.getArtifactRules(artifactId);\n     }\n \n+    /**\n+     * @see io.apicurio.registry.storage.RegistryStorage#createArtifactRuleAsync(java.lang.String, io.apicurio.registry.types.RuleType, io.apicurio.registry.storage.RuleConfigurationDto)\n+     */\n     @Override\n     public CompletionStage<Void> createArtifactRuleAsync(String artifactId, RuleType rule, RuleConfigurationDto config) throws ArtifactNotFoundException, RuleAlreadyExistsException, RegistryStorageException {\n-\n-        try {\n-            sqlStorage.getArtifactRule(artifactId, rule);\n+        if (sqlStore.isArtifactRuleExists(artifactId, rule)) {\n             throw new RuleAlreadyExistsException(rule);\n-        } catch (RuleNotFoundException e) {\n-            //rule does not exist, we can create it\n         }\n \n         return submitter\n-                .submitRule(Str.ActionType.CREATE, artifactId, rule, config.getConfiguration())\n-                .thenCompose(reqId -> (CompletionStage<Void>) coordinator.waitForResponse(reqId));\n+                .submitArtifactRule(artifactId, rule, ActionType.Create, config)\n+                .thenCompose(reqId -> {\n+                    CompletionStage<Void> rval = (CompletionStage<Void>) coordinator.waitForResponse(reqId);\n+                    log.debug(\"===============> Artifact rule (async) completed.  Rval: {}\", rval);\n+                    return rval;\n+                });\n     }\n \n+    /**\n+     * @see io.apicurio.registry.storage.RegistryStorage#deleteArtifactRules(java.lang.String)\n+     */\n     @Override\n     public void deleteArtifactRules(String artifactId) throws ArtifactNotFoundException, RegistryStorageException {\n-        try {\n-            sqlStorage.getArtifactMetaData(artifactId);\n-        } catch (ArtifactNotFoundException e) {\n-            throw e;\n+        if (!sqlStore.isArtifactExists(artifactId)) {\n+            throw new ArtifactNotFoundException(artifactId);\n         }\n \n-        deleteArtifactRulesInternal(artifactId);\n-    }\n-\n-    private void deleteArtifactRulesInternal(String artifactId) {\n-        UUID reqId = ConcurrentUtil.get(submitter.submitRule(Str.ActionType.DELETE, artifactId, null, null));\n-        coordinator.waitForResponse(reqId);\n+        // TODO find a better way to implement deleting all rules?  This isn't very scalable if we add more rules.\n+        \n+        submitter.submitArtifactRule(artifactId, RuleType.COMPATIBILITY, ActionType.Delete);\n+        \n+        UUID reqId = ConcurrentUtil.get(submitter.submitArtifactRule(artifactId, RuleType.VALIDITY, ActionType.Delete));\n+        try {\n+            coordinator.waitForResponse(reqId);\n+        } catch (RuleNotFoundException e) {\n+            // Eat this exception - we don't care if the rule didn't exist.\n+        }\n     }\n \n+    /**\n+     * @see io.apicurio.registry.storage.RegistryStorage#getArtifactRule(java.lang.String, io.apicurio.registry.types.RuleType)\n+     */\n     @Override\n     public RuleConfigurationDto getArtifactRule(String artifactId, RuleType rule) throws ArtifactNotFoundException, RuleNotFoundException, RegistryStorageException {\n-        return sqlStorage.getArtifactRule(artifactId, rule);\n+        return sqlStore.getArtifactRule(artifactId, rule);\n     }\n \n+    /**\n+     * @see io.apicurio.registry.storage.RegistryStorage#updateArtifactRule(java.lang.String, io.apicurio.registry.types.RuleType, io.apicurio.registry.storage.RuleConfigurationDto)\n+     */\n     @Override\n     public void updateArtifactRule(String artifactId, RuleType rule, RuleConfigurationDto config) throws ArtifactNotFoundException, RuleNotFoundException, RegistryStorageException {\n-\n-        try {\n-            sqlStorage.getArtifactRule(artifactId, rule);\n-        } catch (RuleNotFoundException e) {\n-            throw e;\n+        if (!sqlStore.isArtifactRuleExists(artifactId, rule)) {\n+            throw new RuleNotFoundException(rule);\n         }\n \n-        UUID reqId = ConcurrentUtil.get(submitter.submitRule(Str.ActionType.UPDATE, artifactId, rule, config.getConfiguration()));\n+        UUID reqId = ConcurrentUtil.get(submitter.submitArtifactRule(artifactId, rule, ActionType.Update, config));\n         coordinator.waitForResponse(reqId);\n     }\n \n+    /**\n+     * @see io.apicurio.registry.storage.RegistryStorage#deleteArtifactRule(java.lang.String, io.apicurio.registry.types.RuleType)\n+     */\n     @Override\n     public void deleteArtifactRule(String artifactId, RuleType rule) throws ArtifactNotFoundException, RuleNotFoundException, RegistryStorageException {\n-        try {\n-            sqlStorage.getArtifactRule(artifactId, rule);\n-        } catch (RuleNotFoundException e) {\n-            throw e;\n+        if (!sqlStore.isArtifactRuleExists(artifactId, rule)) {\n+            throw new RuleNotFoundException(rule);\n         }\n-        UUID reqId = ConcurrentUtil.get(submitter.submitRule(Str.ActionType.DELETE, artifactId, rule, null));\n+\n+        UUID reqId = ConcurrentUtil.get(submitter.submitArtifactRule(artifactId, rule, ActionType.Delete));\n         coordinator.waitForResponse(reqId);\n     }\n \n+    /**\n+     * @see io.apicurio.registry.storage.RegistryStorage#getArtifactVersions(java.lang.String)\n+     */\n     @Override\n     public SortedSet<Long> getArtifactVersions(String artifactId) throws ArtifactNotFoundException, RegistryStorageException {\n-        return sqlStorage.getArtifactVersions(artifactId);\n+        return sqlStore.getArtifactVersions(artifactId);\n     }\n \n+    /**\n+     * @see io.apicurio.registry.storage.RegistryStorage#searchVersions(java.lang.String, int, int)\n+     */\n     @Override\n     public VersionSearchResults searchVersions(String artifactId, int offset, int limit) {\n-        return sqlStorage.searchVersions(artifactId, offset, limit);\n+        return sqlStore.searchVersions(artifactId, offset, limit);\n     }\n \n+    /**\n+     * @see io.apicurio.registry.storage.RegistryStorage#getArtifactVersion(long)\n+     */\n     @Override\n     public StoredArtifact getArtifactVersion(long id) throws ArtifactNotFoundException, RegistryStorageException {\n-        return sqlStorage.getArtifactVersion(id);\n+        return sqlStore.getArtifactVersion(id);\n     }\n \n+    /**\n+     * @see io.apicurio.registry.storage.RegistryStorage#getArtifactVersion(java.lang.String, long)\n+     */\n     @Override\n     public StoredArtifact getArtifactVersion(String artifactId, long version) throws ArtifactNotFoundException, VersionNotFoundException, RegistryStorageException {\n-        return sqlStorage.getArtifactVersion(artifactId, version);\n+        return sqlStore.getArtifactVersion(artifactId, version);\n     }\n \n+    /**\n+     * @see io.apicurio.registry.storage.RegistryStorage#getArtifactVersionMetaData(java.lang.String, long)\n+     */\n     @Override\n     public ArtifactVersionMetaDataDto getArtifactVersionMetaData(String artifactId, long version) throws ArtifactNotFoundException, VersionNotFoundException, RegistryStorageException {\n-        return sqlStorage.getArtifactVersionMetaData(artifactId, version);\n+        return sqlStore.getArtifactVersionMetaData(artifactId, version);\n     }\n \n+    /**\n+     * @see io.apicurio.registry.storage.RegistryStorage#deleteArtifactVersion(java.lang.String, long)\n+     */\n     @Override\n     public void deleteArtifactVersion(String artifactId, long version) throws ArtifactNotFoundException, VersionNotFoundException, RegistryStorageException {\n         handleVersion(artifactId, version, null, value -> {\n-            UUID reqId = ConcurrentUtil.get(submitter.submitArtifact(Str.ActionType.DELETE, artifactId, version, null, null));\n+            UUID reqId = ConcurrentUtil.get(submitter.submitVersion(artifactId, (int) version, ActionType.Delete));\n             coordinator.waitForResponse(reqId);\n             return null;\n         });\n     }\n \n+    /**\n+     * @see io.apicurio.registry.storage.RegistryStorage#updateArtifactVersionMetaData(java.lang.String, long, io.apicurio.registry.storage.EditableArtifactMetaDataDto)\n+     */\n     @Override\n     public void updateArtifactVersionMetaData(String artifactId, long version, EditableArtifactMetaDataDto metaData) throws ArtifactNotFoundException, VersionNotFoundException, RegistryStorageException {\n-        handleVersion(\n-            artifactId,\n-            version,\n-            ArtifactStateExt.ACTIVE_STATES,\n-            value -> {\n-                UUID reqId = ConcurrentUtil.get(submitter\n-                        .submitMetadata(Str.ActionType.UPDATE, artifactId, version, metaData.getName(), metaData.getDescription(), metaData.getLabels(), metaData.getProperties()));\n-                coordinator.waitForResponse(reqId);\n-                return null;\n-            }\n-        );\n+        handleVersion(artifactId, version, ArtifactStateExt.ACTIVE_STATES, value -> {\n+            UUID reqId = ConcurrentUtil.get(submitter.submitArtifactVersion(artifactId, (int) version, ActionType.Update, value.getState(), metaData));\n+            return coordinator.waitForResponse(reqId);\n+        });\n     }\n \n+    /**\n+     * @see io.apicurio.registry.storage.RegistryStorage#deleteArtifactVersionMetaData(java.lang.String, long)\n+     */\n     @Override\n     public void deleteArtifactVersionMetaData(String artifactId, long version) throws ArtifactNotFoundException, VersionNotFoundException, RegistryStorageException {\n-        handleVersion(\n-            artifactId,\n-            version,\n-            null,\n-            value -> {\n-                UUID reqId = ConcurrentUtil.get(submitter.submitMetadata(Str.ActionType.DELETE, artifactId, version, null, null, Collections.emptyList(), Collections.emptyMap()));\n-                coordinator.waitForResponse(reqId);\n-                return null;\n-            }\n-        );\n+        handleVersion(artifactId, version, null, value -> {\n+            UUID reqId = ConcurrentUtil.get(submitter.submitVersion(artifactId, (int) version, ActionType.Clear));\n+            return coordinator.waitForResponse(reqId);\n+        });\n     }\n \n-    private <T> T handleVersion(String artifactId, long version, EnumSet<ArtifactState> states, Function<ArtifactVersionMetaDataDto, T> handler) throws ArtifactNotFoundException, RegistryStorageException {\n-        ArtifactVersionMetaDataDto metadata = sqlStorage.getArtifactVersionMetaData(artifactId, version);\n+    /**\n+     * Fetches the meta data for the given artifact version, validates the state (optionally), and then calls back the handler\n+     * with the metadata.  If the artifact is not found, this will throw an exception.\n+     * \n+     * @param artifactId\n+     * @param version\n+     * @param states\n+     * @param handler\n+     * @throws ArtifactNotFoundException\n+     * @throws RegistryStorageException\n+     */\n+    private <T> T handleVersion(String artifactId, long version, EnumSet<ArtifactState> states, Function<ArtifactVersionMetaDataDto, T> handler) \n+            throws ArtifactNotFoundException, RegistryStorageException {\n+        \n+        ArtifactVersionMetaDataDto metadata = sqlStore.getArtifactVersionMetaData(artifactId, version);\n \n         ArtifactState state = metadata.getState();\n         ArtifactStateExt.validateState(states, state, artifactId, version);\n         return handler.apply(metadata);\n     }\n \n+    /**\n+     * @see io.apicurio.registry.storage.RegistryStorage#getGlobalRules()\n+     */\n     @Override\n     public List<RuleType> getGlobalRules() throws RegistryStorageException {\n-        return sqlStorage.getGlobalRules();\n+        return sqlStore.getGlobalRules();\n     }\n \n+    /**\n+     * @see io.apicurio.registry.storage.RegistryStorage#createGlobalRule(io.apicurio.registry.types.RuleType, io.apicurio.registry.storage.RuleConfigurationDto)\n+     */\n     @Override\n     public void createGlobalRule(RuleType rule, RuleConfigurationDto config) throws RuleAlreadyExistsException, RegistryStorageException {\n-        UUID reqId = ConcurrentUtil.get(submitter.submitRule(Str.ActionType.CREATE, GLOBAL_RULES_ID, rule, config.getConfiguration()));\n+        UUID reqId = ConcurrentUtil.get(submitter.submitGlobalRule(rule, ActionType.Create, config));\n         coordinator.waitForResponse(reqId);\n     }\n \n+    /**\n+     * @see io.apicurio.registry.storage.RegistryStorage#deleteGlobalRules()\n+     */\n     @Override\n     public void deleteGlobalRules() throws RegistryStorageException {\n-        UUID reqId = ConcurrentUtil.get(submitter.submitRule(Str.ActionType.DELETE, GLOBAL_RULES_ID, null, null));\n-        coordinator.waitForResponse(reqId);\n-\n+        // TODO find a better way to implement deleting all global rules?  This isn't very scalable if we add more rules.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTk2OTU2OA=="}, "originalCommit": {"oid": "34f4d43b0fd02bee41028352cc2fc883c02d1f04"}, "originalPosition": 742}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM2Mjk1OTIwOnYy", "diffSide": "RIGHT", "path": "storage/ksql/src/main/java/io/apicurio/registry/storage/impl/ksql/keys/MessageType.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wNFQwOTo0ODo0NVrOH_JFGA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wNFQxNzo0OToyNFrOH_bcaA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTk3MTA5Ng==", "bodyText": "what about adding a field with the ordinal value in order to make the ordinal explicit, just in case in the future someone changes the order of the values of this enum and messeses everything up", "url": "https://github.com/Apicurio/apicurio-registry/pull/1054#discussion_r535971096", "createdAt": "2020-12-04T09:48:45Z", "author": {"login": "famartinrh"}, "path": "storage/ksql/src/main/java/io/apicurio/registry/storage/impl/ksql/keys/MessageType.java", "diffHunk": "@@ -0,0 +1,26 @@\n+/*\n+ * Copyright 2020 Red Hat\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.apicurio.registry.storage.impl.ksql.keys;\n+\n+/**\n+ * @author eric.wittmann@gmail.com\n+ */\n+public enum MessageType {\n+\n+    GlobalRule, Content, Artifact, ArtifactRule, ArtifactVersion", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "34f4d43b0fd02bee41028352cc2fc883c02d1f04"}, "originalPosition": 24}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjAyNjIwNw==", "bodyText": "+1", "url": "https://github.com/Apicurio/apicurio-registry/pull/1054#discussion_r536026207", "createdAt": "2020-12-04T11:17:42Z", "author": {"login": "carlesarnal"}, "path": "storage/ksql/src/main/java/io/apicurio/registry/storage/impl/ksql/keys/MessageType.java", "diffHunk": "@@ -0,0 +1,26 @@\n+/*\n+ * Copyright 2020 Red Hat\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.apicurio.registry.storage.impl.ksql.keys;\n+\n+/**\n+ * @author eric.wittmann@gmail.com\n+ */\n+public enum MessageType {\n+\n+    GlobalRule, Content, Artifact, ArtifactRule, ArtifactVersion", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTk3MTA5Ng=="}, "originalCommit": {"oid": "34f4d43b0fd02bee41028352cc2fc883c02d1f04"}, "originalPosition": 24}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjI3MTk3Ng==", "bodyText": "Agreed - I'll change this.  Also will change ActionType and do something for ArtifactType as well.", "url": "https://github.com/Apicurio/apicurio-registry/pull/1054#discussion_r536271976", "createdAt": "2020-12-04T17:49:24Z", "author": {"login": "EricWittmann"}, "path": "storage/ksql/src/main/java/io/apicurio/registry/storage/impl/ksql/keys/MessageType.java", "diffHunk": "@@ -0,0 +1,26 @@\n+/*\n+ * Copyright 2020 Red Hat\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.apicurio.registry.storage.impl.ksql.keys;\n+\n+/**\n+ * @author eric.wittmann@gmail.com\n+ */\n+public enum MessageType {\n+\n+    GlobalRule, Content, Artifact, ArtifactRule, ArtifactVersion", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTk3MTA5Ng=="}, "originalCommit": {"oid": "34f4d43b0fd02bee41028352cc2fc883c02d1f04"}, "originalPosition": 24}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM2MzAwMjk5OnYy", "diffSide": "RIGHT", "path": "storage/ksql/src/main/java/io/apicurio/registry/storage/impl/ksql/values/ActionType.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wNFQwOTo1ODozM1rOH_JeZg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wNFQxMTozOTozNlrOH_NKhQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTk3NzU3NA==", "bodyText": "same as MessageType, maybe explicitly add ordinal values?", "url": "https://github.com/Apicurio/apicurio-registry/pull/1054#discussion_r535977574", "createdAt": "2020-12-04T09:58:33Z", "author": {"login": "famartinrh"}, "path": "storage/ksql/src/main/java/io/apicurio/registry/storage/impl/ksql/values/ActionType.java", "diffHunk": "@@ -0,0 +1,26 @@\n+/*\n+ * Copyright 2020 Red Hat\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.apicurio.registry.storage.impl.ksql.values;\n+\n+/**\n+ * @author eric.wittmann@gmail.com\n+ */\n+public enum ActionType {\n+\n+    Create, Update, Delete, Clear", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "34f4d43b0fd02bee41028352cc2fc883c02d1f04"}, "originalPosition": 24}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjAzODAyMQ==", "bodyText": "+1", "url": "https://github.com/Apicurio/apicurio-registry/pull/1054#discussion_r536038021", "createdAt": "2020-12-04T11:39:36Z", "author": {"login": "carlesarnal"}, "path": "storage/ksql/src/main/java/io/apicurio/registry/storage/impl/ksql/values/ActionType.java", "diffHunk": "@@ -0,0 +1,26 @@\n+/*\n+ * Copyright 2020 Red Hat\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.apicurio.registry.storage.impl.ksql.values;\n+\n+/**\n+ * @author eric.wittmann@gmail.com\n+ */\n+public enum ActionType {\n+\n+    Create, Update, Delete, Clear", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTk3NzU3NA=="}, "originalCommit": {"oid": "34f4d43b0fd02bee41028352cc2fc883c02d1f04"}, "originalPosition": 24}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM2MzA2MDg1OnYy", "diffSide": "RIGHT", "path": "storage/ksql/src/main/java/io/apicurio/registry/storage/impl/ksql/KafkaSqlRegistryStorage.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wNFQxMDoxMjoxMFrOH_KARw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wNFQxNzo0OTo1N1rOH_bduQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTk4NjI0Nw==", "bodyText": "here we would catch if there is any error, and we would use log compaction to remove the specific kafka message for this action (using it's uuid)", "url": "https://github.com/Apicurio/apicurio-registry/pull/1054#discussion_r535986247", "createdAt": "2020-12-04T10:12:10Z", "author": {"login": "famartinrh"}, "path": "storage/ksql/src/main/java/io/apicurio/registry/storage/impl/ksql/KafkaSqlRegistryStorage.java", "diffHunk": "@@ -253,125 +256,139 @@ private void startConsumerThread(final KafkaConsumer<String, Str.StorageValue> c\n         props.putIfAbsent(ConsumerConfig.AUTO_OFFSET_RESET_CONFIG, \"earliest\");\n \n         // Create the Kafka Consumer\n-        KafkaConsumer<String, Str.StorageValue> consumer = new KafkaConsumer<>(props,\n-                Serdes.String().deserializer(),\n-                ProtoSerde.parsedWith(Str.StorageValue.parser()));\n+        KafkaSqlKeyDeserializer keyDeserializer = new KafkaSqlKeyDeserializer();\n+        KafkaSqlValueDeserializer valueDeserializer = new KafkaSqlValueDeserializer();\n+        KafkaConsumer<MessageKey, MessageValue> consumer = new KafkaConsumer<>(props, keyDeserializer, valueDeserializer);\n         return consumer;\n     }\n \n-    private void updateArtifactState(ArtifactState currentState, String artifactId, Integer version, ArtifactState state) {\n-        ArtifactStateExt.applyState(\n-            s ->  {\n-                UUID reqId = ConcurrentUtil.get(submitter.submitState(artifactId, version.longValue(), s));\n-                coordinator.waitForResponse(reqId);\n-            },\n-            currentState,\n-            state\n-        );\n+    /**\n+     * Ensures that the given content exists in the database.  If it's already in the DB, then this just \n+     * returns the content hash.  If the content does not yet exist in the DB, then it is added (by sending\n+     * the appropriate message to the Kafka topic and awaiting the response).\n+     * \n+     * @param content\n+     * @param artifactId\n+     * @param artifactType\n+     */\n+    private String ensureContent(ContentHandle content, String artifactId, ArtifactType artifactType) {\n+        byte[] contentBytes = content.bytes();\n+        String contentHash = DigestUtils.sha256Hex(contentBytes);\n+        \n+        if (!sqlStore.isContentExists(contentHash)) {\n+            CompletableFuture<UUID> future = submitter.submitContent(artifactId, contentHash, artifactType, content);\n+            UUID uuid = ConcurrentUtil.get(future);\n+            coordinator.waitForResponse(uuid);\n+        }\n+        \n+        return contentHash;\n     }\n \n+    \n     //TODO implement is Ready and is alive checking if the state is fully updated\n \n-    @Override\n-    public void updateArtifactState(String artifactId, ArtifactState state) {\n-        ArtifactMetaDataDto metadata = sqlStorage.getArtifactMetaData(artifactId);\n-        updateArtifactState(metadata.getState(), artifactId, metadata.getVersion(), state);\n-    }\n-\n-    @Override\n-    public void updateArtifactState(String artifactId, ArtifactState state, Integer version) {\n-        ArtifactVersionMetaDataDto metadata = sqlStorage.getArtifactVersionMetaData(artifactId, version);\n-        updateArtifactState(metadata.getState(), artifactId, version, state);\n-    }\n-\n+    /**\n+     * @see io.apicurio.registry.storage.RegistryStorage#createArtifact(java.lang.String, io.apicurio.registry.types.ArtifactType, io.apicurio.registry.content.ContentHandle)\n+     */\n     @Override\n     public CompletionStage<ArtifactMetaDataDto> createArtifact(String artifactId, ArtifactType artifactType, ContentHandle content) throws ArtifactAlreadyExistsException, RegistryStorageException {\n-\n-        try {\n-            sqlStorage.getArtifactMetaData(artifactId);\n-            throw new ArtifactAlreadyExistsException(artifactId);\n-        } catch (ArtifactNotFoundException e) {\n-            //ignored\n-            //artifact does not exist, we can create it\n-        }\n-\n-        return submitter\n-                .submitArtifact(Str.ActionType.CREATE, artifactId, -1, artifactType, content.bytes())\n-                .thenCompose(reqId -> {\n-                    return (CompletionStage<ArtifactMetaDataDto>) coordinator.waitForResponse(reqId);\n-                });\n+        return createArtifactWithMetadata(artifactId, artifactType, content, null);\n     }\n \n+    /**\n+     * @see io.apicurio.registry.storage.RegistryStorage#createArtifactWithMetadata(java.lang.String, io.apicurio.registry.types.ArtifactType, io.apicurio.registry.content.ContentHandle, io.apicurio.registry.storage.EditableArtifactMetaDataDto)\n+     */\n     @Override\n     public CompletionStage<ArtifactMetaDataDto> createArtifactWithMetadata(String artifactId, ArtifactType artifactType,\n             ContentHandle content, EditableArtifactMetaDataDto metaData) throws ArtifactAlreadyExistsException, RegistryStorageException {\n-        return createArtifact(artifactId, artifactType, content)\n-            .thenCompose(amdd ->\n-                submitter.submitMetadata(Str.ActionType.UPDATE, artifactId, -1, metaData.getName(), metaData.getDescription(), metaData.getLabels(), metaData.getProperties())\n-                    .thenAccept(reqId -> coordinator.waitForResponse(reqId))\n-                    .thenApply(v -> DtoUtil.setEditableMetaDataInArtifact(amdd, metaData))\n-            );\n-\n+        if (sqlStore.isArtifactExists(artifactId)) {\n+            throw new ArtifactAlreadyExistsException(artifactId);\n+        }\n+        \n+        String contentHash = ensureContent(content, artifactId, artifactType);\n+        String createdBy = null; // TODO populate when authentication is available\n+        Date createdOn = new Date();\n+        \n+        return submitter\n+                .submitArtifact(artifactId, ActionType.Create, artifactType, contentHash, createdBy, createdOn, metaData)\n+                .thenCompose(reqId -> (CompletionStage<ArtifactMetaDataDto>) coordinator.waitForResponse(reqId));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "34f4d43b0fd02bee41028352cc2fc883c02d1f04"}, "originalPosition": 334}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjI3MjMxMw==", "bodyText": "Yes I will create a GH issue for this.", "url": "https://github.com/Apicurio/apicurio-registry/pull/1054#discussion_r536272313", "createdAt": "2020-12-04T17:49:57Z", "author": {"login": "EricWittmann"}, "path": "storage/ksql/src/main/java/io/apicurio/registry/storage/impl/ksql/KafkaSqlRegistryStorage.java", "diffHunk": "@@ -253,125 +256,139 @@ private void startConsumerThread(final KafkaConsumer<String, Str.StorageValue> c\n         props.putIfAbsent(ConsumerConfig.AUTO_OFFSET_RESET_CONFIG, \"earliest\");\n \n         // Create the Kafka Consumer\n-        KafkaConsumer<String, Str.StorageValue> consumer = new KafkaConsumer<>(props,\n-                Serdes.String().deserializer(),\n-                ProtoSerde.parsedWith(Str.StorageValue.parser()));\n+        KafkaSqlKeyDeserializer keyDeserializer = new KafkaSqlKeyDeserializer();\n+        KafkaSqlValueDeserializer valueDeserializer = new KafkaSqlValueDeserializer();\n+        KafkaConsumer<MessageKey, MessageValue> consumer = new KafkaConsumer<>(props, keyDeserializer, valueDeserializer);\n         return consumer;\n     }\n \n-    private void updateArtifactState(ArtifactState currentState, String artifactId, Integer version, ArtifactState state) {\n-        ArtifactStateExt.applyState(\n-            s ->  {\n-                UUID reqId = ConcurrentUtil.get(submitter.submitState(artifactId, version.longValue(), s));\n-                coordinator.waitForResponse(reqId);\n-            },\n-            currentState,\n-            state\n-        );\n+    /**\n+     * Ensures that the given content exists in the database.  If it's already in the DB, then this just \n+     * returns the content hash.  If the content does not yet exist in the DB, then it is added (by sending\n+     * the appropriate message to the Kafka topic and awaiting the response).\n+     * \n+     * @param content\n+     * @param artifactId\n+     * @param artifactType\n+     */\n+    private String ensureContent(ContentHandle content, String artifactId, ArtifactType artifactType) {\n+        byte[] contentBytes = content.bytes();\n+        String contentHash = DigestUtils.sha256Hex(contentBytes);\n+        \n+        if (!sqlStore.isContentExists(contentHash)) {\n+            CompletableFuture<UUID> future = submitter.submitContent(artifactId, contentHash, artifactType, content);\n+            UUID uuid = ConcurrentUtil.get(future);\n+            coordinator.waitForResponse(uuid);\n+        }\n+        \n+        return contentHash;\n     }\n \n+    \n     //TODO implement is Ready and is alive checking if the state is fully updated\n \n-    @Override\n-    public void updateArtifactState(String artifactId, ArtifactState state) {\n-        ArtifactMetaDataDto metadata = sqlStorage.getArtifactMetaData(artifactId);\n-        updateArtifactState(metadata.getState(), artifactId, metadata.getVersion(), state);\n-    }\n-\n-    @Override\n-    public void updateArtifactState(String artifactId, ArtifactState state, Integer version) {\n-        ArtifactVersionMetaDataDto metadata = sqlStorage.getArtifactVersionMetaData(artifactId, version);\n-        updateArtifactState(metadata.getState(), artifactId, version, state);\n-    }\n-\n+    /**\n+     * @see io.apicurio.registry.storage.RegistryStorage#createArtifact(java.lang.String, io.apicurio.registry.types.ArtifactType, io.apicurio.registry.content.ContentHandle)\n+     */\n     @Override\n     public CompletionStage<ArtifactMetaDataDto> createArtifact(String artifactId, ArtifactType artifactType, ContentHandle content) throws ArtifactAlreadyExistsException, RegistryStorageException {\n-\n-        try {\n-            sqlStorage.getArtifactMetaData(artifactId);\n-            throw new ArtifactAlreadyExistsException(artifactId);\n-        } catch (ArtifactNotFoundException e) {\n-            //ignored\n-            //artifact does not exist, we can create it\n-        }\n-\n-        return submitter\n-                .submitArtifact(Str.ActionType.CREATE, artifactId, -1, artifactType, content.bytes())\n-                .thenCompose(reqId -> {\n-                    return (CompletionStage<ArtifactMetaDataDto>) coordinator.waitForResponse(reqId);\n-                });\n+        return createArtifactWithMetadata(artifactId, artifactType, content, null);\n     }\n \n+    /**\n+     * @see io.apicurio.registry.storage.RegistryStorage#createArtifactWithMetadata(java.lang.String, io.apicurio.registry.types.ArtifactType, io.apicurio.registry.content.ContentHandle, io.apicurio.registry.storage.EditableArtifactMetaDataDto)\n+     */\n     @Override\n     public CompletionStage<ArtifactMetaDataDto> createArtifactWithMetadata(String artifactId, ArtifactType artifactType,\n             ContentHandle content, EditableArtifactMetaDataDto metaData) throws ArtifactAlreadyExistsException, RegistryStorageException {\n-        return createArtifact(artifactId, artifactType, content)\n-            .thenCompose(amdd ->\n-                submitter.submitMetadata(Str.ActionType.UPDATE, artifactId, -1, metaData.getName(), metaData.getDescription(), metaData.getLabels(), metaData.getProperties())\n-                    .thenAccept(reqId -> coordinator.waitForResponse(reqId))\n-                    .thenApply(v -> DtoUtil.setEditableMetaDataInArtifact(amdd, metaData))\n-            );\n-\n+        if (sqlStore.isArtifactExists(artifactId)) {\n+            throw new ArtifactAlreadyExistsException(artifactId);\n+        }\n+        \n+        String contentHash = ensureContent(content, artifactId, artifactType);\n+        String createdBy = null; // TODO populate when authentication is available\n+        Date createdOn = new Date();\n+        \n+        return submitter\n+                .submitArtifact(artifactId, ActionType.Create, artifactType, contentHash, createdBy, createdOn, metaData)\n+                .thenCompose(reqId -> (CompletionStage<ArtifactMetaDataDto>) coordinator.waitForResponse(reqId));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTk4NjI0Nw=="}, "originalCommit": {"oid": "34f4d43b0fd02bee41028352cc2fc883c02d1f04"}, "originalPosition": 334}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM2MzA2Njk3OnYy", "diffSide": "RIGHT", "path": "storage/ksql/src/main/java/io/apicurio/registry/storage/impl/ksql/sql/KafkaSqlSink.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wNFQxMDoxMzozMlrOH_KDrQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wNFQxNjo0ODoxMVrOH_ZNCw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTk4NzExNw==", "bodyText": "I was not aware we had overlapping concepts , having delete and clear is not perfect as the meaning is similar but I guess it's ok if we have no other option", "url": "https://github.com/Apicurio/apicurio-registry/pull/1054#discussion_r535987117", "createdAt": "2020-12-04T10:13:32Z", "author": {"login": "famartinrh"}, "path": "storage/ksql/src/main/java/io/apicurio/registry/storage/impl/ksql/sql/KafkaSqlSink.java", "diffHunk": "@@ -0,0 +1,264 @@\n+package io.apicurio.registry.storage.impl.ksql.sql;\n+\n+import java.util.Optional;\n+import java.util.UUID;\n+\n+import javax.enterprise.context.ApplicationScoped;\n+import javax.inject.Inject;\n+\n+import org.apache.kafka.clients.consumer.ConsumerRecord;\n+import org.apache.kafka.common.header.Header;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import io.apicurio.registry.logging.Logged;\n+import io.apicurio.registry.storage.RegistryStorageException;\n+import io.apicurio.registry.storage.impl.ksql.KafkaSqlCoordinator;\n+import io.apicurio.registry.storage.impl.ksql.KafkaSqlRegistryStorage;\n+import io.apicurio.registry.storage.impl.ksql.keys.ArtifactKey;\n+import io.apicurio.registry.storage.impl.ksql.keys.ArtifactRuleKey;\n+import io.apicurio.registry.storage.impl.ksql.keys.ArtifactVersionKey;\n+import io.apicurio.registry.storage.impl.ksql.keys.ContentKey;\n+import io.apicurio.registry.storage.impl.ksql.keys.GlobalRuleKey;\n+import io.apicurio.registry.storage.impl.ksql.keys.MessageKey;\n+import io.apicurio.registry.storage.impl.ksql.keys.MessageType;\n+import io.apicurio.registry.storage.impl.ksql.values.ArtifactRuleValue;\n+import io.apicurio.registry.storage.impl.ksql.values.ArtifactValue;\n+import io.apicurio.registry.storage.impl.ksql.values.ArtifactVersionValue;\n+import io.apicurio.registry.storage.impl.ksql.values.ContentValue;\n+import io.apicurio.registry.storage.impl.ksql.values.GlobalRuleValue;\n+import io.apicurio.registry.storage.impl.ksql.values.MessageValue;\n+import io.apicurio.registry.storage.impl.sql.GlobalIdGenerator;\n+import io.apicurio.registry.types.RegistryException;\n+\n+/**\n+ * @author Fabian Martinez\n+ */\n+@ApplicationScoped\n+@Logged\n+public class KafkaSqlSink {\n+\n+    private final Logger log = LoggerFactory.getLogger(this.getClass().getName());\n+\n+    @Inject\n+    KafkaSqlCoordinator coordinator;\n+\n+    @Inject\n+    KafkaSqlStore sqlStore;\n+\n+    /**\n+     * Called by the {@link KafkaSqlRegistryStorage} main Kafka consumer loop to process a single\n+     * message in the topic.  Each message represents some attempt to modify the registry data.  So\n+     * each message much be consumed and applied to the in-memory SQL data store.\n+     * \n+     * This method extracts the UUID from the message headers, delegates the message processing\n+     * to <code>doProcessMessage()</code>, and handles any exceptions that might occur. Finally\n+     * it will report the result to any local threads that may be waiting (via the coordinator).\n+     * \n+     * @param record\n+     */\n+    public void processMessage(ConsumerRecord<MessageKey, MessageValue> record) {\n+        UUID requestId = extractUuid(record);\n+        log.debug(\"Processing Kafka message with UUID: {}\", requestId.toString());\n+\n+        try {\n+            Object result = doProcessMessage(record);\n+            log.debug(\"Kafka message successfully processed. Notifying listeners of response.\");\n+            coordinator.notifyResponse(requestId, result);\n+        } catch (RegistryException e) {\n+            log.debug(\"Registry exception detected: {}\", e.getMessage());\n+            coordinator.notifyResponse(requestId, e);\n+        } catch (Throwable e) {\n+            log.debug(\"Unexpected exception detected: {}\", e.getMessage());\n+            coordinator.notifyResponse(requestId, new RegistryException(e));\n+        }\n+    }\n+\n+    /**\n+     * Extracts the UUID from the message.  The UUID should be found in a message header.\n+     * @param record\n+     */\n+    private UUID extractUuid(ConsumerRecord<MessageKey, MessageValue> record) {\n+        return Optional.ofNullable(record.headers().headers(\"req\"))\n+                .map(Iterable::iterator)\n+                .map(it -> {\n+                    return it.hasNext() ? it.next() : null;\n+                })\n+                .map(Header::value)\n+                .map(String::new)\n+                .map(UUID::fromString)\n+                .orElse(null);\n+    }\n+\n+    /**\n+     * Process the message and return a result.  This method may also throw an exception if something\n+     * goes wrong.\n+     * @param record\n+     */\n+    private Object doProcessMessage(ConsumerRecord<MessageKey, MessageValue> record) {\n+        MessageKey key = record.key();\n+        MessageValue value = record.value();\n+\n+        GlobalIdGenerator globalIdGenerator = () -> {\n+            int partition = record.partition();\n+            long offset = record.offset();\n+            Long globalId = toGlobalId(offset, partition);\n+            return globalId;\n+        };\n+\n+        MessageType messageType = key.getType();\n+        switch (messageType) {\n+            case Artifact:\n+                return processArtifactMessage((ArtifactKey) key, (ArtifactValue) value, globalIdGenerator);\n+            case ArtifactRule:\n+                return processArtifactRuleMessage((ArtifactRuleKey) key, (ArtifactRuleValue) value);\n+            case ArtifactVersion:\n+                return processArtifactVersion((ArtifactVersionKey) key, (ArtifactVersionValue) value);\n+            case Content:\n+                return processContent((ContentKey) key, (ContentValue) value);\n+            case GlobalRule:\n+                return processGlobalRuleVersion((GlobalRuleKey) key, (GlobalRuleValue) value);\n+            default:\n+                log.warn(\"Unrecognized message type: %s\", record.key());\n+                throw new RegistryStorageException(\"Unexpected message type: \" + messageType.name());\n+        }\n+    }\n+    \n+    /**\n+     * Process a Kafka message of type \"artifact\".  This includes creating, updating, and deleting artifacts.\n+     * @param key\n+     * @param value\n+     * @param globalIdGenerator \n+     */\n+    private Object processArtifactMessage(ArtifactKey key, ArtifactValue value, GlobalIdGenerator globalIdGenerator) {\n+        switch (value.getAction()) {\n+            case Create:\n+                return sqlStore.createArtifactWithMetadata(key.getArtifactId(), value.getArtifactType(),\n+                        value.getContentHash(), value.getCreatedBy(), value.getCreatedOn(),\n+                        value.getMetaData(), globalIdGenerator);\n+            case Update:\n+                return sqlStore.updateArtifactWithMetadata(key.getArtifactId(), value.getArtifactType(),\n+                        value.getContentHash(), value.getCreatedBy(), value.getCreatedOn(),\n+                        value.getMetaData(), globalIdGenerator);\n+            case Delete:\n+                return sqlStore.deleteArtifact(key.getArtifactId());\n+            case Clear:\n+            default:\n+                log.warn(\"Unsupported artifact message action: %s\", key.getType().name());\n+                throw new RegistryStorageException(\"Unsupported artifact message action: \" + value.getAction());\n+        }\n+    }\n+\n+    /**\n+     * Process a Kafka message of type \"artifact rule\".  This includes creating, updating, and deleting\n+     * rules for a specific artifact.\n+     * @param key\n+     * @param value\n+     */\n+    private Object processArtifactRuleMessage(ArtifactRuleKey key, ArtifactRuleValue value) {\n+        switch (value.getAction()) {\n+            case Create:\n+                // Note: createArtifactRuleAsync() must be called instead of createArtifactRule() because that's what \n+                // KafkaSqlRegistryStorage::createArtifactRuleAsync() expects (a return value)\n+                return sqlStore.createArtifactRuleAsync(key.getArtifactId(), key.getRuleType(), value.getConfig());\n+            case Update:\n+                sqlStore.updateArtifactRule(key.getArtifactId(), key.getRuleType(), value.getConfig());\n+                return null;\n+            case Delete:\n+                sqlStore.deleteArtifactRule(key.getArtifactId(), key.getRuleType());\n+                return null;\n+            case Clear:\n+            default:\n+                log.warn(\"Unsupported artifact rule message action: %s\", key.getType().name());\n+                throw new RegistryStorageException(\"Unsupported artifact-rule message action: \" + value.getAction());\n+        }\n+    }\n+\n+    /**\n+     * Process a Kafka message of type \"artifact version\".  This includes:\n+     * \n+     *  - Updating version meta-data and state\n+     *  - Deleting version meta-data and state\n+     *  - Deleting an artifact version\n+     * \n+     * @param key\n+     * @param value\n+     */\n+    private Object processArtifactVersion(ArtifactVersionKey key, ArtifactVersionValue value) {\n+        switch (value.getAction()) {\n+            case Update:\n+                sqlStore.updateArtifactVersionMetaDataAndState(key.getArtifactId(), key.getVersion(), value.getMetaData(), value.getState());\n+                return null;\n+            case Delete:\n+                sqlStore.deleteArtifactVersion(key.getArtifactId(), key.getVersion());\n+                return null;\n+            case Clear:\n+                sqlStore.deleteArtifactVersionMetaData(key.getArtifactId(), key.getVersion());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "34f4d43b0fd02bee41028352cc2fc883c02d1f04"}, "originalPosition": 196}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjAyOTg0Nw==", "bodyText": "What about joining both operations into a single one? Maybe I am missing something, but if the version is deleted, then the metadata can be safely deleted as well.", "url": "https://github.com/Apicurio/apicurio-registry/pull/1054#discussion_r536029847", "createdAt": "2020-12-04T11:24:41Z", "author": {"login": "carlesarnal"}, "path": "storage/ksql/src/main/java/io/apicurio/registry/storage/impl/ksql/sql/KafkaSqlSink.java", "diffHunk": "@@ -0,0 +1,264 @@\n+package io.apicurio.registry.storage.impl.ksql.sql;\n+\n+import java.util.Optional;\n+import java.util.UUID;\n+\n+import javax.enterprise.context.ApplicationScoped;\n+import javax.inject.Inject;\n+\n+import org.apache.kafka.clients.consumer.ConsumerRecord;\n+import org.apache.kafka.common.header.Header;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import io.apicurio.registry.logging.Logged;\n+import io.apicurio.registry.storage.RegistryStorageException;\n+import io.apicurio.registry.storage.impl.ksql.KafkaSqlCoordinator;\n+import io.apicurio.registry.storage.impl.ksql.KafkaSqlRegistryStorage;\n+import io.apicurio.registry.storage.impl.ksql.keys.ArtifactKey;\n+import io.apicurio.registry.storage.impl.ksql.keys.ArtifactRuleKey;\n+import io.apicurio.registry.storage.impl.ksql.keys.ArtifactVersionKey;\n+import io.apicurio.registry.storage.impl.ksql.keys.ContentKey;\n+import io.apicurio.registry.storage.impl.ksql.keys.GlobalRuleKey;\n+import io.apicurio.registry.storage.impl.ksql.keys.MessageKey;\n+import io.apicurio.registry.storage.impl.ksql.keys.MessageType;\n+import io.apicurio.registry.storage.impl.ksql.values.ArtifactRuleValue;\n+import io.apicurio.registry.storage.impl.ksql.values.ArtifactValue;\n+import io.apicurio.registry.storage.impl.ksql.values.ArtifactVersionValue;\n+import io.apicurio.registry.storage.impl.ksql.values.ContentValue;\n+import io.apicurio.registry.storage.impl.ksql.values.GlobalRuleValue;\n+import io.apicurio.registry.storage.impl.ksql.values.MessageValue;\n+import io.apicurio.registry.storage.impl.sql.GlobalIdGenerator;\n+import io.apicurio.registry.types.RegistryException;\n+\n+/**\n+ * @author Fabian Martinez\n+ */\n+@ApplicationScoped\n+@Logged\n+public class KafkaSqlSink {\n+\n+    private final Logger log = LoggerFactory.getLogger(this.getClass().getName());\n+\n+    @Inject\n+    KafkaSqlCoordinator coordinator;\n+\n+    @Inject\n+    KafkaSqlStore sqlStore;\n+\n+    /**\n+     * Called by the {@link KafkaSqlRegistryStorage} main Kafka consumer loop to process a single\n+     * message in the topic.  Each message represents some attempt to modify the registry data.  So\n+     * each message much be consumed and applied to the in-memory SQL data store.\n+     * \n+     * This method extracts the UUID from the message headers, delegates the message processing\n+     * to <code>doProcessMessage()</code>, and handles any exceptions that might occur. Finally\n+     * it will report the result to any local threads that may be waiting (via the coordinator).\n+     * \n+     * @param record\n+     */\n+    public void processMessage(ConsumerRecord<MessageKey, MessageValue> record) {\n+        UUID requestId = extractUuid(record);\n+        log.debug(\"Processing Kafka message with UUID: {}\", requestId.toString());\n+\n+        try {\n+            Object result = doProcessMessage(record);\n+            log.debug(\"Kafka message successfully processed. Notifying listeners of response.\");\n+            coordinator.notifyResponse(requestId, result);\n+        } catch (RegistryException e) {\n+            log.debug(\"Registry exception detected: {}\", e.getMessage());\n+            coordinator.notifyResponse(requestId, e);\n+        } catch (Throwable e) {\n+            log.debug(\"Unexpected exception detected: {}\", e.getMessage());\n+            coordinator.notifyResponse(requestId, new RegistryException(e));\n+        }\n+    }\n+\n+    /**\n+     * Extracts the UUID from the message.  The UUID should be found in a message header.\n+     * @param record\n+     */\n+    private UUID extractUuid(ConsumerRecord<MessageKey, MessageValue> record) {\n+        return Optional.ofNullable(record.headers().headers(\"req\"))\n+                .map(Iterable::iterator)\n+                .map(it -> {\n+                    return it.hasNext() ? it.next() : null;\n+                })\n+                .map(Header::value)\n+                .map(String::new)\n+                .map(UUID::fromString)\n+                .orElse(null);\n+    }\n+\n+    /**\n+     * Process the message and return a result.  This method may also throw an exception if something\n+     * goes wrong.\n+     * @param record\n+     */\n+    private Object doProcessMessage(ConsumerRecord<MessageKey, MessageValue> record) {\n+        MessageKey key = record.key();\n+        MessageValue value = record.value();\n+\n+        GlobalIdGenerator globalIdGenerator = () -> {\n+            int partition = record.partition();\n+            long offset = record.offset();\n+            Long globalId = toGlobalId(offset, partition);\n+            return globalId;\n+        };\n+\n+        MessageType messageType = key.getType();\n+        switch (messageType) {\n+            case Artifact:\n+                return processArtifactMessage((ArtifactKey) key, (ArtifactValue) value, globalIdGenerator);\n+            case ArtifactRule:\n+                return processArtifactRuleMessage((ArtifactRuleKey) key, (ArtifactRuleValue) value);\n+            case ArtifactVersion:\n+                return processArtifactVersion((ArtifactVersionKey) key, (ArtifactVersionValue) value);\n+            case Content:\n+                return processContent((ContentKey) key, (ContentValue) value);\n+            case GlobalRule:\n+                return processGlobalRuleVersion((GlobalRuleKey) key, (GlobalRuleValue) value);\n+            default:\n+                log.warn(\"Unrecognized message type: %s\", record.key());\n+                throw new RegistryStorageException(\"Unexpected message type: \" + messageType.name());\n+        }\n+    }\n+    \n+    /**\n+     * Process a Kafka message of type \"artifact\".  This includes creating, updating, and deleting artifacts.\n+     * @param key\n+     * @param value\n+     * @param globalIdGenerator \n+     */\n+    private Object processArtifactMessage(ArtifactKey key, ArtifactValue value, GlobalIdGenerator globalIdGenerator) {\n+        switch (value.getAction()) {\n+            case Create:\n+                return sqlStore.createArtifactWithMetadata(key.getArtifactId(), value.getArtifactType(),\n+                        value.getContentHash(), value.getCreatedBy(), value.getCreatedOn(),\n+                        value.getMetaData(), globalIdGenerator);\n+            case Update:\n+                return sqlStore.updateArtifactWithMetadata(key.getArtifactId(), value.getArtifactType(),\n+                        value.getContentHash(), value.getCreatedBy(), value.getCreatedOn(),\n+                        value.getMetaData(), globalIdGenerator);\n+            case Delete:\n+                return sqlStore.deleteArtifact(key.getArtifactId());\n+            case Clear:\n+            default:\n+                log.warn(\"Unsupported artifact message action: %s\", key.getType().name());\n+                throw new RegistryStorageException(\"Unsupported artifact message action: \" + value.getAction());\n+        }\n+    }\n+\n+    /**\n+     * Process a Kafka message of type \"artifact rule\".  This includes creating, updating, and deleting\n+     * rules for a specific artifact.\n+     * @param key\n+     * @param value\n+     */\n+    private Object processArtifactRuleMessage(ArtifactRuleKey key, ArtifactRuleValue value) {\n+        switch (value.getAction()) {\n+            case Create:\n+                // Note: createArtifactRuleAsync() must be called instead of createArtifactRule() because that's what \n+                // KafkaSqlRegistryStorage::createArtifactRuleAsync() expects (a return value)\n+                return sqlStore.createArtifactRuleAsync(key.getArtifactId(), key.getRuleType(), value.getConfig());\n+            case Update:\n+                sqlStore.updateArtifactRule(key.getArtifactId(), key.getRuleType(), value.getConfig());\n+                return null;\n+            case Delete:\n+                sqlStore.deleteArtifactRule(key.getArtifactId(), key.getRuleType());\n+                return null;\n+            case Clear:\n+            default:\n+                log.warn(\"Unsupported artifact rule message action: %s\", key.getType().name());\n+                throw new RegistryStorageException(\"Unsupported artifact-rule message action: \" + value.getAction());\n+        }\n+    }\n+\n+    /**\n+     * Process a Kafka message of type \"artifact version\".  This includes:\n+     * \n+     *  - Updating version meta-data and state\n+     *  - Deleting version meta-data and state\n+     *  - Deleting an artifact version\n+     * \n+     * @param key\n+     * @param value\n+     */\n+    private Object processArtifactVersion(ArtifactVersionKey key, ArtifactVersionValue value) {\n+        switch (value.getAction()) {\n+            case Update:\n+                sqlStore.updateArtifactVersionMetaDataAndState(key.getArtifactId(), key.getVersion(), value.getMetaData(), value.getState());\n+                return null;\n+            case Delete:\n+                sqlStore.deleteArtifactVersion(key.getArtifactId(), key.getVersion());\n+                return null;\n+            case Clear:\n+                sqlStore.deleteArtifactVersionMetaData(key.getArtifactId(), key.getVersion());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTk4NzExNw=="}, "originalCommit": {"oid": "34f4d43b0fd02bee41028352cc2fc883c02d1f04"}, "originalPosition": 196}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjIzNTI3NQ==", "bodyText": "Yeah I didn't love this solution, but I didn't have a better one.  I'm open to other options.  The semantics here are actually:\n\nDelete == delete the artifact version\nClear == delete the artifact version metadata\n\nThey are different actions associated with the same message key, which is important IMO for log compaction.  If you can think of either a better action name, or another approach, I'm happy to hear it.", "url": "https://github.com/Apicurio/apicurio-registry/pull/1054#discussion_r536235275", "createdAt": "2020-12-04T16:48:11Z", "author": {"login": "EricWittmann"}, "path": "storage/ksql/src/main/java/io/apicurio/registry/storage/impl/ksql/sql/KafkaSqlSink.java", "diffHunk": "@@ -0,0 +1,264 @@\n+package io.apicurio.registry.storage.impl.ksql.sql;\n+\n+import java.util.Optional;\n+import java.util.UUID;\n+\n+import javax.enterprise.context.ApplicationScoped;\n+import javax.inject.Inject;\n+\n+import org.apache.kafka.clients.consumer.ConsumerRecord;\n+import org.apache.kafka.common.header.Header;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import io.apicurio.registry.logging.Logged;\n+import io.apicurio.registry.storage.RegistryStorageException;\n+import io.apicurio.registry.storage.impl.ksql.KafkaSqlCoordinator;\n+import io.apicurio.registry.storage.impl.ksql.KafkaSqlRegistryStorage;\n+import io.apicurio.registry.storage.impl.ksql.keys.ArtifactKey;\n+import io.apicurio.registry.storage.impl.ksql.keys.ArtifactRuleKey;\n+import io.apicurio.registry.storage.impl.ksql.keys.ArtifactVersionKey;\n+import io.apicurio.registry.storage.impl.ksql.keys.ContentKey;\n+import io.apicurio.registry.storage.impl.ksql.keys.GlobalRuleKey;\n+import io.apicurio.registry.storage.impl.ksql.keys.MessageKey;\n+import io.apicurio.registry.storage.impl.ksql.keys.MessageType;\n+import io.apicurio.registry.storage.impl.ksql.values.ArtifactRuleValue;\n+import io.apicurio.registry.storage.impl.ksql.values.ArtifactValue;\n+import io.apicurio.registry.storage.impl.ksql.values.ArtifactVersionValue;\n+import io.apicurio.registry.storage.impl.ksql.values.ContentValue;\n+import io.apicurio.registry.storage.impl.ksql.values.GlobalRuleValue;\n+import io.apicurio.registry.storage.impl.ksql.values.MessageValue;\n+import io.apicurio.registry.storage.impl.sql.GlobalIdGenerator;\n+import io.apicurio.registry.types.RegistryException;\n+\n+/**\n+ * @author Fabian Martinez\n+ */\n+@ApplicationScoped\n+@Logged\n+public class KafkaSqlSink {\n+\n+    private final Logger log = LoggerFactory.getLogger(this.getClass().getName());\n+\n+    @Inject\n+    KafkaSqlCoordinator coordinator;\n+\n+    @Inject\n+    KafkaSqlStore sqlStore;\n+\n+    /**\n+     * Called by the {@link KafkaSqlRegistryStorage} main Kafka consumer loop to process a single\n+     * message in the topic.  Each message represents some attempt to modify the registry data.  So\n+     * each message much be consumed and applied to the in-memory SQL data store.\n+     * \n+     * This method extracts the UUID from the message headers, delegates the message processing\n+     * to <code>doProcessMessage()</code>, and handles any exceptions that might occur. Finally\n+     * it will report the result to any local threads that may be waiting (via the coordinator).\n+     * \n+     * @param record\n+     */\n+    public void processMessage(ConsumerRecord<MessageKey, MessageValue> record) {\n+        UUID requestId = extractUuid(record);\n+        log.debug(\"Processing Kafka message with UUID: {}\", requestId.toString());\n+\n+        try {\n+            Object result = doProcessMessage(record);\n+            log.debug(\"Kafka message successfully processed. Notifying listeners of response.\");\n+            coordinator.notifyResponse(requestId, result);\n+        } catch (RegistryException e) {\n+            log.debug(\"Registry exception detected: {}\", e.getMessage());\n+            coordinator.notifyResponse(requestId, e);\n+        } catch (Throwable e) {\n+            log.debug(\"Unexpected exception detected: {}\", e.getMessage());\n+            coordinator.notifyResponse(requestId, new RegistryException(e));\n+        }\n+    }\n+\n+    /**\n+     * Extracts the UUID from the message.  The UUID should be found in a message header.\n+     * @param record\n+     */\n+    private UUID extractUuid(ConsumerRecord<MessageKey, MessageValue> record) {\n+        return Optional.ofNullable(record.headers().headers(\"req\"))\n+                .map(Iterable::iterator)\n+                .map(it -> {\n+                    return it.hasNext() ? it.next() : null;\n+                })\n+                .map(Header::value)\n+                .map(String::new)\n+                .map(UUID::fromString)\n+                .orElse(null);\n+    }\n+\n+    /**\n+     * Process the message and return a result.  This method may also throw an exception if something\n+     * goes wrong.\n+     * @param record\n+     */\n+    private Object doProcessMessage(ConsumerRecord<MessageKey, MessageValue> record) {\n+        MessageKey key = record.key();\n+        MessageValue value = record.value();\n+\n+        GlobalIdGenerator globalIdGenerator = () -> {\n+            int partition = record.partition();\n+            long offset = record.offset();\n+            Long globalId = toGlobalId(offset, partition);\n+            return globalId;\n+        };\n+\n+        MessageType messageType = key.getType();\n+        switch (messageType) {\n+            case Artifact:\n+                return processArtifactMessage((ArtifactKey) key, (ArtifactValue) value, globalIdGenerator);\n+            case ArtifactRule:\n+                return processArtifactRuleMessage((ArtifactRuleKey) key, (ArtifactRuleValue) value);\n+            case ArtifactVersion:\n+                return processArtifactVersion((ArtifactVersionKey) key, (ArtifactVersionValue) value);\n+            case Content:\n+                return processContent((ContentKey) key, (ContentValue) value);\n+            case GlobalRule:\n+                return processGlobalRuleVersion((GlobalRuleKey) key, (GlobalRuleValue) value);\n+            default:\n+                log.warn(\"Unrecognized message type: %s\", record.key());\n+                throw new RegistryStorageException(\"Unexpected message type: \" + messageType.name());\n+        }\n+    }\n+    \n+    /**\n+     * Process a Kafka message of type \"artifact\".  This includes creating, updating, and deleting artifacts.\n+     * @param key\n+     * @param value\n+     * @param globalIdGenerator \n+     */\n+    private Object processArtifactMessage(ArtifactKey key, ArtifactValue value, GlobalIdGenerator globalIdGenerator) {\n+        switch (value.getAction()) {\n+            case Create:\n+                return sqlStore.createArtifactWithMetadata(key.getArtifactId(), value.getArtifactType(),\n+                        value.getContentHash(), value.getCreatedBy(), value.getCreatedOn(),\n+                        value.getMetaData(), globalIdGenerator);\n+            case Update:\n+                return sqlStore.updateArtifactWithMetadata(key.getArtifactId(), value.getArtifactType(),\n+                        value.getContentHash(), value.getCreatedBy(), value.getCreatedOn(),\n+                        value.getMetaData(), globalIdGenerator);\n+            case Delete:\n+                return sqlStore.deleteArtifact(key.getArtifactId());\n+            case Clear:\n+            default:\n+                log.warn(\"Unsupported artifact message action: %s\", key.getType().name());\n+                throw new RegistryStorageException(\"Unsupported artifact message action: \" + value.getAction());\n+        }\n+    }\n+\n+    /**\n+     * Process a Kafka message of type \"artifact rule\".  This includes creating, updating, and deleting\n+     * rules for a specific artifact.\n+     * @param key\n+     * @param value\n+     */\n+    private Object processArtifactRuleMessage(ArtifactRuleKey key, ArtifactRuleValue value) {\n+        switch (value.getAction()) {\n+            case Create:\n+                // Note: createArtifactRuleAsync() must be called instead of createArtifactRule() because that's what \n+                // KafkaSqlRegistryStorage::createArtifactRuleAsync() expects (a return value)\n+                return sqlStore.createArtifactRuleAsync(key.getArtifactId(), key.getRuleType(), value.getConfig());\n+            case Update:\n+                sqlStore.updateArtifactRule(key.getArtifactId(), key.getRuleType(), value.getConfig());\n+                return null;\n+            case Delete:\n+                sqlStore.deleteArtifactRule(key.getArtifactId(), key.getRuleType());\n+                return null;\n+            case Clear:\n+            default:\n+                log.warn(\"Unsupported artifact rule message action: %s\", key.getType().name());\n+                throw new RegistryStorageException(\"Unsupported artifact-rule message action: \" + value.getAction());\n+        }\n+    }\n+\n+    /**\n+     * Process a Kafka message of type \"artifact version\".  This includes:\n+     * \n+     *  - Updating version meta-data and state\n+     *  - Deleting version meta-data and state\n+     *  - Deleting an artifact version\n+     * \n+     * @param key\n+     * @param value\n+     */\n+    private Object processArtifactVersion(ArtifactVersionKey key, ArtifactVersionValue value) {\n+        switch (value.getAction()) {\n+            case Update:\n+                sqlStore.updateArtifactVersionMetaDataAndState(key.getArtifactId(), key.getVersion(), value.getMetaData(), value.getState());\n+                return null;\n+            case Delete:\n+                sqlStore.deleteArtifactVersion(key.getArtifactId(), key.getVersion());\n+                return null;\n+            case Clear:\n+                sqlStore.deleteArtifactVersionMetaData(key.getArtifactId(), key.getVersion());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTk4NzExNw=="}, "originalCommit": {"oid": "34f4d43b0fd02bee41028352cc2fc883c02d1f04"}, "originalPosition": 196}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM2MzA4MjUxOnYy", "diffSide": "RIGHT", "path": "storage/ksql/src/main/java/io/apicurio/registry/storage/impl/ksql/serde/KafkaSqlValueSerializer.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wNFQxMDoxNzowOVrOH_KMjQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wNFQxNzo1MTozNFrOH_bhbQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTk4OTM4OQ==", "bodyText": "this is not protobuf nor avro :) but it's ok , we could even leave it like this but the message keys... that is another story", "url": "https://github.com/Apicurio/apicurio-registry/pull/1054#discussion_r535989389", "createdAt": "2020-12-04T10:17:09Z", "author": {"login": "famartinrh"}, "path": "storage/ksql/src/main/java/io/apicurio/registry/storage/impl/ksql/serde/KafkaSqlValueSerializer.java", "diffHunk": "@@ -0,0 +1,83 @@\n+/*\n+ * Copyright 2020 Red Hat\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.apicurio.registry.storage.impl.ksql.serde;\n+\n+import java.io.IOException;\n+import java.io.UncheckedIOException;\n+import java.nio.ByteBuffer;\n+\n+import org.apache.commons.io.output.UnsynchronizedByteArrayOutputStream;\n+import org.apache.kafka.common.serialization.Serializer;\n+\n+import com.fasterxml.jackson.annotation.JsonInclude.Include;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+\n+import io.apicurio.registry.storage.impl.ksql.keys.MessageType;\n+import io.apicurio.registry.storage.impl.ksql.values.ContentValue;\n+import io.apicurio.registry.storage.impl.ksql.values.MessageValue;\n+\n+/**\n+ * Responsible for serializing the message key to bytes.\n+ * @author eric.wittmann@gmail.com\n+ */\n+public class KafkaSqlValueSerializer implements Serializer<MessageValue> {\n+    \n+    private static final ObjectMapper mapper = new ObjectMapper();\n+    static {\n+        mapper.setSerializationInclusion(Include.NON_NULL);\n+    }\n+\n+    /**\n+     * @see org.apache.kafka.common.serialization.Serializer#serialize(java.lang.String, java.lang.Object)\n+     */\n+    @Override\n+    public byte[] serialize(String topic, MessageValue messageValue) {\n+        if (messageValue.getType() == MessageType.Content) {\n+            return this.serializeContent(topic, (ContentValue) messageValue);\n+        }\n+        try (UnsynchronizedByteArrayOutputStream out = new UnsynchronizedByteArrayOutputStream()) {\n+            out.write(ByteBuffer.allocate(1).put((byte) messageValue.getType().ordinal()).array());\n+            mapper.writeValue(out, messageValue);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "34f4d43b0fd02bee41028352cc2fc883c02d1f04"}, "originalPosition": 54}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjIzNjAwNA==", "bodyText": "Yeah, my intention was to solicit a volunteer to re-implement the Serdes (both key and value) to use something like protobuf.  I felt like that could easily be done in a followup PR.", "url": "https://github.com/Apicurio/apicurio-registry/pull/1054#discussion_r536236004", "createdAt": "2020-12-04T16:49:19Z", "author": {"login": "EricWittmann"}, "path": "storage/ksql/src/main/java/io/apicurio/registry/storage/impl/ksql/serde/KafkaSqlValueSerializer.java", "diffHunk": "@@ -0,0 +1,83 @@\n+/*\n+ * Copyright 2020 Red Hat\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.apicurio.registry.storage.impl.ksql.serde;\n+\n+import java.io.IOException;\n+import java.io.UncheckedIOException;\n+import java.nio.ByteBuffer;\n+\n+import org.apache.commons.io.output.UnsynchronizedByteArrayOutputStream;\n+import org.apache.kafka.common.serialization.Serializer;\n+\n+import com.fasterxml.jackson.annotation.JsonInclude.Include;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+\n+import io.apicurio.registry.storage.impl.ksql.keys.MessageType;\n+import io.apicurio.registry.storage.impl.ksql.values.ContentValue;\n+import io.apicurio.registry.storage.impl.ksql.values.MessageValue;\n+\n+/**\n+ * Responsible for serializing the message key to bytes.\n+ * @author eric.wittmann@gmail.com\n+ */\n+public class KafkaSqlValueSerializer implements Serializer<MessageValue> {\n+    \n+    private static final ObjectMapper mapper = new ObjectMapper();\n+    static {\n+        mapper.setSerializationInclusion(Include.NON_NULL);\n+    }\n+\n+    /**\n+     * @see org.apache.kafka.common.serialization.Serializer#serialize(java.lang.String, java.lang.Object)\n+     */\n+    @Override\n+    public byte[] serialize(String topic, MessageValue messageValue) {\n+        if (messageValue.getType() == MessageType.Content) {\n+            return this.serializeContent(topic, (ContentValue) messageValue);\n+        }\n+        try (UnsynchronizedByteArrayOutputStream out = new UnsynchronizedByteArrayOutputStream()) {\n+            out.write(ByteBuffer.allocate(1).put((byte) messageValue.getType().ordinal()).array());\n+            mapper.writeValue(out, messageValue);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTk4OTM4OQ=="}, "originalCommit": {"oid": "34f4d43b0fd02bee41028352cc2fc883c02d1f04"}, "originalPosition": 54}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjI3MzI2MQ==", "bodyText": "I will create a GH issue for this: #1059", "url": "https://github.com/Apicurio/apicurio-registry/pull/1054#discussion_r536273261", "createdAt": "2020-12-04T17:51:34Z", "author": {"login": "EricWittmann"}, "path": "storage/ksql/src/main/java/io/apicurio/registry/storage/impl/ksql/serde/KafkaSqlValueSerializer.java", "diffHunk": "@@ -0,0 +1,83 @@\n+/*\n+ * Copyright 2020 Red Hat\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.apicurio.registry.storage.impl.ksql.serde;\n+\n+import java.io.IOException;\n+import java.io.UncheckedIOException;\n+import java.nio.ByteBuffer;\n+\n+import org.apache.commons.io.output.UnsynchronizedByteArrayOutputStream;\n+import org.apache.kafka.common.serialization.Serializer;\n+\n+import com.fasterxml.jackson.annotation.JsonInclude.Include;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+\n+import io.apicurio.registry.storage.impl.ksql.keys.MessageType;\n+import io.apicurio.registry.storage.impl.ksql.values.ContentValue;\n+import io.apicurio.registry.storage.impl.ksql.values.MessageValue;\n+\n+/**\n+ * Responsible for serializing the message key to bytes.\n+ * @author eric.wittmann@gmail.com\n+ */\n+public class KafkaSqlValueSerializer implements Serializer<MessageValue> {\n+    \n+    private static final ObjectMapper mapper = new ObjectMapper();\n+    static {\n+        mapper.setSerializationInclusion(Include.NON_NULL);\n+    }\n+\n+    /**\n+     * @see org.apache.kafka.common.serialization.Serializer#serialize(java.lang.String, java.lang.Object)\n+     */\n+    @Override\n+    public byte[] serialize(String topic, MessageValue messageValue) {\n+        if (messageValue.getType() == MessageType.Content) {\n+            return this.serializeContent(topic, (ContentValue) messageValue);\n+        }\n+        try (UnsynchronizedByteArrayOutputStream out = new UnsynchronizedByteArrayOutputStream()) {\n+            out.write(ByteBuffer.allocate(1).put((byte) messageValue.getType().ordinal()).array());\n+            mapper.writeValue(out, messageValue);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTk4OTM4OQ=="}, "originalCommit": {"oid": "34f4d43b0fd02bee41028352cc2fc883c02d1f04"}, "originalPosition": 54}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM2MzA4NzcyOnYy", "diffSide": "RIGHT", "path": "storage/ksql/src/main/java/io/apicurio/registry/storage/impl/ksql/serde/KafkaSqlKeySerializer.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wNFQxMDoxODoyMFrOH_KPgQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wNFQxNjo1MDowMFrOH_ZR0A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTk5MDE0NQ==", "bodyText": "using json for the message key does not look like a good idea to me", "url": "https://github.com/Apicurio/apicurio-registry/pull/1054#discussion_r535990145", "createdAt": "2020-12-04T10:18:20Z", "author": {"login": "famartinrh"}, "path": "storage/ksql/src/main/java/io/apicurio/registry/storage/impl/ksql/serde/KafkaSqlKeySerializer.java", "diffHunk": "@@ -0,0 +1,57 @@\n+/*\n+ * Copyright 2020 Red Hat\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.apicurio.registry.storage.impl.ksql.serde;\n+\n+import java.io.IOException;\n+import java.io.UncheckedIOException;\n+import java.nio.ByteBuffer;\n+\n+import org.apache.commons.io.output.UnsynchronizedByteArrayOutputStream;\n+import org.apache.kafka.common.serialization.Serializer;\n+\n+import com.fasterxml.jackson.annotation.JsonInclude.Include;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+\n+import io.apicurio.registry.storage.impl.ksql.keys.MessageKey;\n+\n+/**\n+ * Responsible for serializing the message key to bytes.\n+ * @author eric.wittmann@gmail.com\n+ */\n+public class KafkaSqlKeySerializer implements Serializer<MessageKey> {\n+    \n+    private static final ObjectMapper mapper = new ObjectMapper();\n+    static {\n+        mapper.setSerializationInclusion(Include.NON_NULL);\n+    }\n+\n+    /**\n+     * @see org.apache.kafka.common.serialization.Serializer#serialize(java.lang.String, java.lang.Object)\n+     */\n+    @Override\n+    public byte[] serialize(String topic, MessageKey messageKey) {\n+        try {\n+            UnsynchronizedByteArrayOutputStream out = new UnsynchronizedByteArrayOutputStream();\n+            out.write(ByteBuffer.allocate(1).put((byte) messageKey.getType().ordinal()).array());\n+            mapper.writeValue(out, messageKey);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "34f4d43b0fd02bee41028352cc2fc883c02d1f04"}, "originalPosition": 50}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjIzNjQ5Ng==", "bodyText": "Agree.  See previous comment.  :)  I didn't want to boil the ocean with this PR.  I have a list of improvements that need to be made.  I will create GitHub issues for them soon.", "url": "https://github.com/Apicurio/apicurio-registry/pull/1054#discussion_r536236496", "createdAt": "2020-12-04T16:50:00Z", "author": {"login": "EricWittmann"}, "path": "storage/ksql/src/main/java/io/apicurio/registry/storage/impl/ksql/serde/KafkaSqlKeySerializer.java", "diffHunk": "@@ -0,0 +1,57 @@\n+/*\n+ * Copyright 2020 Red Hat\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.apicurio.registry.storage.impl.ksql.serde;\n+\n+import java.io.IOException;\n+import java.io.UncheckedIOException;\n+import java.nio.ByteBuffer;\n+\n+import org.apache.commons.io.output.UnsynchronizedByteArrayOutputStream;\n+import org.apache.kafka.common.serialization.Serializer;\n+\n+import com.fasterxml.jackson.annotation.JsonInclude.Include;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+\n+import io.apicurio.registry.storage.impl.ksql.keys.MessageKey;\n+\n+/**\n+ * Responsible for serializing the message key to bytes.\n+ * @author eric.wittmann@gmail.com\n+ */\n+public class KafkaSqlKeySerializer implements Serializer<MessageKey> {\n+    \n+    private static final ObjectMapper mapper = new ObjectMapper();\n+    static {\n+        mapper.setSerializationInclusion(Include.NON_NULL);\n+    }\n+\n+    /**\n+     * @see org.apache.kafka.common.serialization.Serializer#serialize(java.lang.String, java.lang.Object)\n+     */\n+    @Override\n+    public byte[] serialize(String topic, MessageKey messageKey) {\n+        try {\n+            UnsynchronizedByteArrayOutputStream out = new UnsynchronizedByteArrayOutputStream();\n+            out.write(ByteBuffer.allocate(1).put((byte) messageKey.getType().ordinal()).array());\n+            mapper.writeValue(out, messageKey);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTk5MDE0NQ=="}, "originalCommit": {"oid": "34f4d43b0fd02bee41028352cc2fc883c02d1f04"}, "originalPosition": 50}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM2MzI2NTEwOnYy", "diffSide": "RIGHT", "path": "app/src/main/java/io/apicurio/registry/storage/RegistryStorageException.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wNFQxMTowMDozNVrOH_L2cg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wNFQxNjo1MDoxOVrOH_ZSvg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjAxNjQ5OA==", "bodyText": "Why is this needed?", "url": "https://github.com/Apicurio/apicurio-registry/pull/1054#discussion_r536016498", "createdAt": "2020-12-04T11:00:35Z", "author": {"login": "carlesarnal"}, "path": "app/src/main/java/io/apicurio/registry/storage/RegistryStorageException.java", "diffHunk": "@@ -29,6 +29,7 @@\n      */\n     public RegistryStorageException(Throwable cause) {\n         super(cause);\n+        cause.printStackTrace();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "34f4d43b0fd02bee41028352cc2fc883c02d1f04"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjIzNjczNA==", "bodyText": "Debugging leftover.  I will remove.", "url": "https://github.com/Apicurio/apicurio-registry/pull/1054#discussion_r536236734", "createdAt": "2020-12-04T16:50:19Z", "author": {"login": "EricWittmann"}, "path": "app/src/main/java/io/apicurio/registry/storage/RegistryStorageException.java", "diffHunk": "@@ -29,6 +29,7 @@\n      */\n     public RegistryStorageException(Throwable cause) {\n         super(cause);\n+        cause.printStackTrace();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjAxNjQ5OA=="}, "originalCommit": {"oid": "34f4d43b0fd02bee41028352cc2fc883c02d1f04"}, "originalPosition": 4}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM2MzI2NTc3OnYy", "diffSide": "RIGHT", "path": "app/src/main/java/io/apicurio/registry/storage/RegistryStorageException.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wNFQxMTowMDo0OFrOH_L23w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wNFQxMTowMDo0OFrOH_L23w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjAxNjYwNw==", "bodyText": "Same as above", "url": "https://github.com/Apicurio/apicurio-registry/pull/1054#discussion_r536016607", "createdAt": "2020-12-04T11:00:48Z", "author": {"login": "carlesarnal"}, "path": "app/src/main/java/io/apicurio/registry/storage/RegistryStorageException.java", "diffHunk": "@@ -38,6 +39,7 @@ public RegistryStorageException(Throwable cause) {\n      */\n     public RegistryStorageException(String reason, Throwable cause) {\n         super(reason, cause);\n+        cause.printStackTrace();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "34f4d43b0fd02bee41028352cc2fc883c02d1f04"}, "originalPosition": 12}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3437, "cost": 1, "resetAt": "2021-11-12T09:44:50Z"}}}