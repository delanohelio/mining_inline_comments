{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDU2MzYxODk4", "number": 708, "title": "Enhance ibmcompat API methods", "bodyText": "This commit improves the data returned by the ibmcompat API GET\nendpoints to include metadata already stored with the artifact.\nIt also improves the ibmcompat API POST endpoints by returning\nmetadata stored with the artifact.\nIt also adds a set of initial tests for the functionality that follow\nthe ccompat API and artifact API tests.\nIt also improves the ibmcompat API PATCH endpoints by setting the\nmetadata stored with the artifact.\n\nSigned-off-by: Andrew Borley borley@uk.ibm.com", "createdAt": "2020-07-24T15:50:51Z", "url": "https://github.com/Apicurio/apicurio-registry/pull/708", "merged": true, "mergeCommit": {"oid": "614f66f099b9a6e76ecf53fad67e5f1582f8af47"}, "closed": true, "closedAt": "2020-08-11T17:23:56Z", "author": {"login": "ajborley"}, "timelineItems": {"totalCount": 10, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABc4NXbmABqjM1ODU4MDc3ODI=", "endCursor": "Y3Vyc29yOnYyOpPPAAABc9xokDgBqjM2NDE4MDc1NDE=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "e51655f3861315d8078c524894163ba837fc8b46", "author": {"user": {"login": "ajborley", "name": "Andrew Borley"}}, "url": "https://github.com/Apicurio/apicurio-registry/commit/e51655f3861315d8078c524894163ba837fc8b46", "committedDate": "2020-07-24T15:47:42Z", "message": "Enhance ibmcompat API GET and POST methods\n\n- This commit improves the data returned by the ibmcompat API GET\nendpoints to include metadata already stored with the artifact.\n- It also improves the ibmcompat API POST endpoints by returning\nmetadata stored with the artifact.\n- It also adds a set of initial tests for the functionality that follow\nthe ccompat API and artifact API tests.\n\nSigned-off-by: Andrew Borley <borley@uk.ibm.com>"}, "afterCommit": {"oid": "685c7c7ca35b119f1d8c3469faacdc378aad062c", "author": {"user": {"login": "ajborley", "name": "Andrew Borley"}}, "url": "https://github.com/Apicurio/apicurio-registry/commit/685c7c7ca35b119f1d8c3469faacdc378aad062c", "committedDate": "2020-07-25T00:20:00Z", "message": "Enhance ibmcompat API GET and POST methods\n\n- This commit improves the data returned by the ibmcompat API GET\nendpoints to include metadata already stored with the artifact.\n- It also improves the ibmcompat API POST endpoints by returning\nmetadata stored with the artifact.\n- It also adds a set of initial tests for the functionality that follow\nthe ccompat API and artifact API tests.\n\nSigned-off-by: Andrew Borley <borley@uk.ibm.com>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "685c7c7ca35b119f1d8c3469faacdc378aad062c", "author": {"user": {"login": "ajborley", "name": "Andrew Borley"}}, "url": "https://github.com/Apicurio/apicurio-registry/commit/685c7c7ca35b119f1d8c3469faacdc378aad062c", "committedDate": "2020-07-25T00:20:00Z", "message": "Enhance ibmcompat API GET and POST methods\n\n- This commit improves the data returned by the ibmcompat API GET\nendpoints to include metadata already stored with the artifact.\n- It also improves the ibmcompat API POST endpoints by returning\nmetadata stored with the artifact.\n- It also adds a set of initial tests for the functionality that follow\nthe ccompat API and artifact API tests.\n\nSigned-off-by: Andrew Borley <borley@uk.ibm.com>"}, "afterCommit": {"oid": "ceb8eae9cd931724e37ca28a334e48d1c91bc827", "author": {"user": {"login": "ajborley", "name": "Andrew Borley"}}, "url": "https://github.com/Apicurio/apicurio-registry/commit/ceb8eae9cd931724e37ca28a334e48d1c91bc827", "committedDate": "2020-07-25T23:17:17Z", "message": "Enhance ibmcompat API GET and POST methods\n\n- This commit improves the data returned by the ibmcompat API GET\nendpoints to include metadata already stored with the artifact.\n- It also improves the ibmcompat API POST endpoints by returning\nmetadata stored with the artifact.\n- It also adds a set of initial tests for the functionality that follow\nthe ccompat API and artifact API tests.\n\nSigned-off-by: Andrew Borley <borley@uk.ibm.com>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "850089d4e2ee83e7ca8be4591d905a73ef7a479d", "author": {"user": {"login": "ajborley", "name": "Andrew Borley"}}, "url": "https://github.com/Apicurio/apicurio-registry/commit/850089d4e2ee83e7ca8be4591d905a73ef7a479d", "committedDate": "2020-07-28T08:33:44Z", "message": "Merge branch 'master' into ibmcompat-api-enhancements"}, "afterCommit": {"oid": "64a78a7ae61b080ec02c78d17ace6528ca57ce7b", "author": {"user": {"login": "ajborley", "name": "Andrew Borley"}}, "url": "https://github.com/Apicurio/apicurio-registry/commit/64a78a7ae61b080ec02c78d17ace6528ca57ce7b", "committedDate": "2020-07-28T13:28:17Z", "message": "Enhance ibmcompat API GET and POST methods\n\n- This commit improves the data returned by the ibmcompat API GET\nendpoints to include metadata already stored with the artifact.\n- It also improves the ibmcompat API POST endpoints by returning\nmetadata stored with the artifact.\n- It also adds a set of initial tests for the functionality that follow\nthe ccompat API and artifact API tests.\n\nSigned-off-by: Andrew Borley <borley@uk.ibm.com>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "e072578de88022bcacc8d0cdc01a56a344a94621", "author": {"user": {"login": "ajborley", "name": "Andrew Borley"}}, "url": "https://github.com/Apicurio/apicurio-registry/commit/e072578de88022bcacc8d0cdc01a56a344a94621", "committedDate": "2020-07-29T15:49:29Z", "message": "Merge branch 'master' into ibmcompat-api-enhancements"}, "afterCommit": {"oid": "849b83085ae9e6920c589946828019b6d524bb51", "author": {"user": {"login": "ajborley", "name": "Andrew Borley"}}, "url": "https://github.com/Apicurio/apicurio-registry/commit/849b83085ae9e6920c589946828019b6d524bb51", "committedDate": "2020-07-30T10:00:33Z", "message": "Enhance ibmcompat API GET and POST methods\n\n- This commit improves the data returned by the ibmcompat API GET\nendpoints to include metadata already stored with the artifact.\n- It also improves the ibmcompat API POST endpoints by returning\nmetadata stored with the artifact.\n- It also adds a set of initial tests for the functionality that follow\nthe ccompat API and artifact API tests.\n\nSigned-off-by: Andrew Borley <borley@uk.ibm.com>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "849b83085ae9e6920c589946828019b6d524bb51", "author": {"user": {"login": "ajborley", "name": "Andrew Borley"}}, "url": "https://github.com/Apicurio/apicurio-registry/commit/849b83085ae9e6920c589946828019b6d524bb51", "committedDate": "2020-07-30T10:00:33Z", "message": "Enhance ibmcompat API GET and POST methods\n\n- This commit improves the data returned by the ibmcompat API GET\nendpoints to include metadata already stored with the artifact.\n- It also improves the ibmcompat API POST endpoints by returning\nmetadata stored with the artifact.\n- It also adds a set of initial tests for the functionality that follow\nthe ccompat API and artifact API tests.\n\nSigned-off-by: Andrew Borley <borley@uk.ibm.com>"}, "afterCommit": {"oid": "9aa2c005c1a7c0ed5b003c83e36fe6bbfb059ec0", "author": {"user": {"login": "ajborley", "name": "Andrew Borley"}}, "url": "https://github.com/Apicurio/apicurio-registry/commit/9aa2c005c1a7c0ed5b003c83e36fe6bbfb059ec0", "committedDate": "2020-07-31T15:37:58Z", "message": "Enhance ibmcompat API PATCH methods\n\n - This commit adds implementations and tests for the two lifecycle\nmanagement methods of the ibmcompat API:\n    - `PATCH ibmcompat/schemas/{schema-id}`\n    - `PATCH ibmcompat/schemas/{schema-id}/versions/{version-id}`\n\nSigned-off-by: Andrew Borley <borley@uk.ibm.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDU5MjcyNTMy", "url": "https://github.com/Apicurio/apicurio-registry/pull/708#pullrequestreview-459272532", "createdAt": "2020-07-31T15:39:49Z", "commit": {"oid": "849b83085ae9e6920c589946828019b6d524bb51"}, "state": "APPROVED", "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMVQxNTo0MTowOFrOG6NHqQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMVQxNTo1MDowN1rOG6Naew==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzY4NTU0NQ==", "bodyText": "This seems like an OK short term solution.  But it would be good to think about what other options we might have here to avoid this.  Especially since the current implementation is hard coded to wait for about 1s.  Any async storage (infinispan and kafka streams are both async) cannot make a 1s guarantee.  So we would at least need to make the wait time adjustable.  But even better would be if we could enhance the storage layer in some way to avoid this wait time.  I'm open to ideas!  :)", "url": "https://github.com/Apicurio/apicurio-registry/pull/708#discussion_r463685545", "createdAt": "2020-07-31T15:41:08Z", "author": {"login": "EricWittmann"}, "path": "app/src/main/java/io/apicurio/registry/ibmcompat/api/impl/ApiServiceImpl.java", "diffHunk": "@@ -52,12 +77,147 @@\n     private List<SchemaVersion> getSchemaVersions(String schemaid) {\n         return storage.getArtifactVersions(schemaid)\n                       .stream()\n-                      .map(l -> {\n-                          SchemaVersion sv = new SchemaVersion();\n-                          sv.setId(l.intValue());\n-                          sv.setEnabled(true);\n-                          return sv;\n-                      }).collect(Collectors.toList());\n+                      .map(versionid -> getSchemaVersion(schemaid, versionid))\n+                      .filter(schemaVersion -> schemaVersion != null)\n+                      .collect(Collectors.toList());\n+    }\n+\n+    private SchemaVersion getLatestSchemaVersion(String schemaid) {\n+        return getSchemaVersion(schemaid, storage.getArtifact(schemaid).getVersion());\n+    }\n+\n+    private SchemaVersion getSchemaVersion(String schemaid, Long versionid) {\n+        SchemaVersion schemaVersion = new SchemaVersion();\n+        try {\n+            ArtifactVersionMetaDataDto artifactMetaData = storage.getArtifactVersionMetaData(schemaid, versionid);\n+            schemaVersion.setId(versionid.intValue()); // TODO not safe!\n+            schemaVersion.setDate(new Date(artifactMetaData.getCreatedOn()));\n+            schemaVersion.setName(artifactMetaData.getName());\n+            schemaVersion.setEnabled(!ArtifactState.DISABLED.equals(artifactMetaData.getState()));\n+            SchemaState versionState = new SchemaState();\n+            if(ArtifactState.DEPRECATED.equals(artifactMetaData.getState())) {\n+                versionState.setState(SchemaState.StateEnum.DEPRECATED);\n+            } else {\n+                versionState.setState(SchemaState.StateEnum.ACTIVE);\n+            }\n+            schemaVersion.setState(versionState);\n+        } catch (ArtifactNotFoundException e) {\n+            return null;\n+        }\n+        return schemaVersion;\n+    }\n+\n+    private void populateSchemaSummary(String schemaid, SchemaSummary schemaSummary) {\n+        List<ArtifactState> versionStates = storage.getArtifactVersions(schemaid).stream()\n+            .map(version -> storage.getArtifactVersionMetaData(schemaid, version).getState())\n+            .collect(Collectors.toList());\n+\n+        schemaSummary.setId(schemaid);\n+        schemaSummary.setName(schemaid); // TODO - add mechanism to store an artifact-level name\n+\n+        // The schema is disabled if all versions are disabled\n+        boolean isSchemaDisabled = versionStates.stream().allMatch(versionState -> ArtifactState.DISABLED.equals(versionState));\n+        schemaSummary.setEnabled(!isSchemaDisabled);\n+\n+        // The schema is deprecated if all versions are deprecated\n+        boolean isSchemaDeprecated = versionStates.stream().allMatch(versionState -> ArtifactState.DEPRECATED.equals(versionState));\n+        SchemaState schemaState = new SchemaState();\n+        if(isSchemaDeprecated) {\n+            schemaState.setState(SchemaState.StateEnum.DEPRECATED);\n+        } else {\n+            schemaState.setState(SchemaState.StateEnum.ACTIVE);\n+        }\n+        schemaSummary.setState(schemaState);\n+    }\n+\n+    private void handleArtifactCreation(AsyncResponse response, String artifactId, String versionName, Throwable t) {\n+        if (t != null) {\n+            response.resume(t);\n+            return;\n+        }\n+\n+        if (!doesArtifactExist(artifactId)) {\n+            // Some storage (such as asyncmem) needs a wait before the artifact is available for updating\n+            try {\n+                waitForArtifactCreation(artifactId);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9aa2c005c1a7c0ed5b003c83e36fe6bbfb059ec0"}, "originalPosition": 146}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzY4NjA4NA==", "bodyText": "Right - this will not work. @alesj can provide a good explanation.  This has come up before and I was looking for a link to that explanation but I couldn't dig it up quickly.", "url": "https://github.com/Apicurio/apicurio-registry/pull/708#discussion_r463686084", "createdAt": "2020-07-31T15:42:11Z", "author": {"login": "EricWittmann"}, "path": "app/src/main/java/io/apicurio/registry/ibmcompat/api/impl/ApiServiceImpl.java", "diffHunk": "@@ -52,12 +77,147 @@\n     private List<SchemaVersion> getSchemaVersions(String schemaid) {\n         return storage.getArtifactVersions(schemaid)\n                       .stream()\n-                      .map(l -> {\n-                          SchemaVersion sv = new SchemaVersion();\n-                          sv.setId(l.intValue());\n-                          sv.setEnabled(true);\n-                          return sv;\n-                      }).collect(Collectors.toList());\n+                      .map(versionid -> getSchemaVersion(schemaid, versionid))\n+                      .filter(schemaVersion -> schemaVersion != null)\n+                      .collect(Collectors.toList());\n+    }\n+\n+    private SchemaVersion getLatestSchemaVersion(String schemaid) {\n+        return getSchemaVersion(schemaid, storage.getArtifact(schemaid).getVersion());\n+    }\n+\n+    private SchemaVersion getSchemaVersion(String schemaid, Long versionid) {\n+        SchemaVersion schemaVersion = new SchemaVersion();\n+        try {\n+            ArtifactVersionMetaDataDto artifactMetaData = storage.getArtifactVersionMetaData(schemaid, versionid);\n+            schemaVersion.setId(versionid.intValue()); // TODO not safe!\n+            schemaVersion.setDate(new Date(artifactMetaData.getCreatedOn()));\n+            schemaVersion.setName(artifactMetaData.getName());\n+            schemaVersion.setEnabled(!ArtifactState.DISABLED.equals(artifactMetaData.getState()));\n+            SchemaState versionState = new SchemaState();\n+            if(ArtifactState.DEPRECATED.equals(artifactMetaData.getState())) {\n+                versionState.setState(SchemaState.StateEnum.DEPRECATED);\n+            } else {\n+                versionState.setState(SchemaState.StateEnum.ACTIVE);\n+            }\n+            schemaVersion.setState(versionState);\n+        } catch (ArtifactNotFoundException e) {\n+            return null;\n+        }\n+        return schemaVersion;\n+    }\n+\n+    private void populateSchemaSummary(String schemaid, SchemaSummary schemaSummary) {\n+        List<ArtifactState> versionStates = storage.getArtifactVersions(schemaid).stream()\n+            .map(version -> storage.getArtifactVersionMetaData(schemaid, version).getState())\n+            .collect(Collectors.toList());\n+\n+        schemaSummary.setId(schemaid);\n+        schemaSummary.setName(schemaid); // TODO - add mechanism to store an artifact-level name\n+\n+        // The schema is disabled if all versions are disabled\n+        boolean isSchemaDisabled = versionStates.stream().allMatch(versionState -> ArtifactState.DISABLED.equals(versionState));\n+        schemaSummary.setEnabled(!isSchemaDisabled);\n+\n+        // The schema is deprecated if all versions are deprecated\n+        boolean isSchemaDeprecated = versionStates.stream().allMatch(versionState -> ArtifactState.DEPRECATED.equals(versionState));\n+        SchemaState schemaState = new SchemaState();\n+        if(isSchemaDeprecated) {\n+            schemaState.setState(SchemaState.StateEnum.DEPRECATED);\n+        } else {\n+            schemaState.setState(SchemaState.StateEnum.ACTIVE);\n+        }\n+        schemaSummary.setState(schemaState);\n+    }\n+\n+    private void handleArtifactCreation(AsyncResponse response, String artifactId, String versionName, Throwable t) {\n+        if (t != null) {\n+            response.resume(t);\n+            return;\n+        }\n+\n+        if (!doesArtifactExist(artifactId)) {\n+            // Some storage (such as asyncmem) needs a wait before the artifact is available for updating\n+            try {\n+                waitForArtifactCreation(artifactId);\n+            } catch (ArtifactNotFoundException e) {\n+                response.resume(e);\n+                return;\n+            }\n+        }\n+\n+        try {\n+            // Set the artifact name from the version name\n+            EditableArtifactMetaDataDto dto = new EditableArtifactMetaDataDto();\n+            dto.setName(versionName);\n+            //\n+            // TODO: On Kafka topic storage, this call to updateArtifactMetaData never returns.\n+            // The consumer thread appears to be blocked. Help needed here.\n+            //\n+            // storage.updateArtifactMetaData(artifactId, dto);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9aa2c005c1a7c0ed5b003c83e36fe6bbfb059ec0"}, "originalPosition": 161}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzY4NjUzNQ==", "bodyText": "Icky - at the very least needs to be configurable.  See my other comment on this.", "url": "https://github.com/Apicurio/apicurio-registry/pull/708#discussion_r463686535", "createdAt": "2020-07-31T15:43:01Z", "author": {"login": "EricWittmann"}, "path": "app/src/main/java/io/apicurio/registry/ibmcompat/api/impl/ApiServiceImpl.java", "diffHunk": "@@ -52,12 +77,147 @@\n     private List<SchemaVersion> getSchemaVersions(String schemaid) {\n         return storage.getArtifactVersions(schemaid)\n                       .stream()\n-                      .map(l -> {\n-                          SchemaVersion sv = new SchemaVersion();\n-                          sv.setId(l.intValue());\n-                          sv.setEnabled(true);\n-                          return sv;\n-                      }).collect(Collectors.toList());\n+                      .map(versionid -> getSchemaVersion(schemaid, versionid))\n+                      .filter(schemaVersion -> schemaVersion != null)\n+                      .collect(Collectors.toList());\n+    }\n+\n+    private SchemaVersion getLatestSchemaVersion(String schemaid) {\n+        return getSchemaVersion(schemaid, storage.getArtifact(schemaid).getVersion());\n+    }\n+\n+    private SchemaVersion getSchemaVersion(String schemaid, Long versionid) {\n+        SchemaVersion schemaVersion = new SchemaVersion();\n+        try {\n+            ArtifactVersionMetaDataDto artifactMetaData = storage.getArtifactVersionMetaData(schemaid, versionid);\n+            schemaVersion.setId(versionid.intValue()); // TODO not safe!\n+            schemaVersion.setDate(new Date(artifactMetaData.getCreatedOn()));\n+            schemaVersion.setName(artifactMetaData.getName());\n+            schemaVersion.setEnabled(!ArtifactState.DISABLED.equals(artifactMetaData.getState()));\n+            SchemaState versionState = new SchemaState();\n+            if(ArtifactState.DEPRECATED.equals(artifactMetaData.getState())) {\n+                versionState.setState(SchemaState.StateEnum.DEPRECATED);\n+            } else {\n+                versionState.setState(SchemaState.StateEnum.ACTIVE);\n+            }\n+            schemaVersion.setState(versionState);\n+        } catch (ArtifactNotFoundException e) {\n+            return null;\n+        }\n+        return schemaVersion;\n+    }\n+\n+    private void populateSchemaSummary(String schemaid, SchemaSummary schemaSummary) {\n+        List<ArtifactState> versionStates = storage.getArtifactVersions(schemaid).stream()\n+            .map(version -> storage.getArtifactVersionMetaData(schemaid, version).getState())\n+            .collect(Collectors.toList());\n+\n+        schemaSummary.setId(schemaid);\n+        schemaSummary.setName(schemaid); // TODO - add mechanism to store an artifact-level name\n+\n+        // The schema is disabled if all versions are disabled\n+        boolean isSchemaDisabled = versionStates.stream().allMatch(versionState -> ArtifactState.DISABLED.equals(versionState));\n+        schemaSummary.setEnabled(!isSchemaDisabled);\n+\n+        // The schema is deprecated if all versions are deprecated\n+        boolean isSchemaDeprecated = versionStates.stream().allMatch(versionState -> ArtifactState.DEPRECATED.equals(versionState));\n+        SchemaState schemaState = new SchemaState();\n+        if(isSchemaDeprecated) {\n+            schemaState.setState(SchemaState.StateEnum.DEPRECATED);\n+        } else {\n+            schemaState.setState(SchemaState.StateEnum.ACTIVE);\n+        }\n+        schemaSummary.setState(schemaState);\n+    }\n+\n+    private void handleArtifactCreation(AsyncResponse response, String artifactId, String versionName, Throwable t) {\n+        if (t != null) {\n+            response.resume(t);\n+            return;\n+        }\n+\n+        if (!doesArtifactExist(artifactId)) {\n+            // Some storage (such as asyncmem) needs a wait before the artifact is available for updating\n+            try {\n+                waitForArtifactCreation(artifactId);\n+            } catch (ArtifactNotFoundException e) {\n+                response.resume(e);\n+                return;\n+            }\n+        }\n+\n+        try {\n+            // Set the artifact name from the version name\n+            EditableArtifactMetaDataDto dto = new EditableArtifactMetaDataDto();\n+            dto.setName(versionName);\n+            //\n+            // TODO: On Kafka topic storage, this call to updateArtifactMetaData never returns.\n+            // The consumer thread appears to be blocked. Help needed here.\n+            //\n+            // storage.updateArtifactMetaData(artifactId, dto);\n+\n+            // Prepare the response\n+            SchemaInfo info = new SchemaInfo();\n+            populateSchemaSummary(artifactId, info);\n+            info.setVersions(getSchemaVersions(artifactId));\n+\n+            // updateArtifactMetaData call may be async, so also set the version name in the response\n+            List<SchemaVersion> versions = info.getVersions();\n+            versions.get(versions.size() - 1).setName(versionName);\n+\n+            response.resume(Response.status(Response.Status.CREATED).entity(info).build());\n+        } catch (Throwable throwable) {\n+            response.resume(throwable);\n+        }\n+    }\n+\n+    private void waitForArtifactCreation(String artifactId) throws ArtifactNotFoundException {\n+        for (int i = 0; i < 5 && !doesArtifactExist(artifactId); i++) {\n+            try {\n+                Thread.sleep(200L);\n+            } catch (InterruptedException e) {}\n+        }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9aa2c005c1a7c0ed5b003c83e36fe6bbfb059ec0"}, "originalPosition": 183}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzY4ODIyOQ==", "bodyText": "Good change in approach - but I would perhaps add back in a comment explaining what's happening.  i.e. that a race condition could cause the artifact to be not found, so we'll return null here and filter out nulls later.", "url": "https://github.com/Apicurio/apicurio-registry/pull/708#discussion_r463688229", "createdAt": "2020-07-31T15:46:04Z", "author": {"login": "EricWittmann"}, "path": "app/src/main/java/io/apicurio/registry/ibmcompat/api/impl/ApiServiceImpl.java", "diffHunk": "@@ -70,46 +230,34 @@\n                   .map(id -> {\n                       SchemaListItem item = new SchemaListItem();\n                       try {\n-                          StoredArtifact artifact = storage.getArtifact(id);\n-                          item.setId(id);\n-                          item.setEnabled(true);\n-                          SchemaVersion version = new SchemaVersion();\n-                          version.setId(artifact.getVersion().intValue()); // TODO not safe!\n-                          item.setLatest(version);\n+                          populateSchemaSummary(id, item);\n+                          item.setLatest(getLatestSchemaVersion(id));\n                       } catch (ArtifactNotFoundException e) {\n-                          // we can have deleted artifact ...\n+                          return null;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9aa2c005c1a7c0ed5b003c83e36fe6bbfb059ec0"}, "originalPosition": 242}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzY5MDM2Mw==", "bodyText": "Curious as to why.  Anti-capital letter bias?? ;)", "url": "https://github.com/Apicurio/apicurio-registry/pull/708#discussion_r463690363", "createdAt": "2020-07-31T15:50:07Z", "author": {"login": "EricWittmann"}, "path": "app/src/main/java/io/apicurio/registry/ibmcompat/api/impl/ApiServiceImpl.java", "diffHunk": "@@ -70,46 +230,34 @@\n                   .map(id -> {\n                       SchemaListItem item = new SchemaListItem();\n                       try {\n-                          StoredArtifact artifact = storage.getArtifact(id);\n-                          item.setId(id);\n-                          item.setEnabled(true);\n-                          SchemaVersion version = new SchemaVersion();\n-                          version.setId(artifact.getVersion().intValue()); // TODO not safe!\n-                          item.setLatest(version);\n+                          populateSchemaSummary(id, item);\n+                          item.setLatest(getLatestSchemaVersion(id));\n                       } catch (ArtifactNotFoundException e) {\n-                          // we can have deleted artifact ...\n+                          return null;\n                       }\n                       return item;\n                   })\n-                  .filter(SchemaListItem::isEnabled)\n+                  .filter(item -> item != null)\n                   .collect(Collectors.toList());\n     }\n \n     public void apiSchemasPost(AsyncResponse response, NewSchema schema, boolean verify)\n-    throws ArtifactNotFoundException {\n-        String artifactId = schema.getName();\n-        if (artifactId == null) {\n+    throws ArtifactNotFoundException, ArtifactAlreadyExistsException {\n+        String schemaName = schema.getName();\n+        final String artifactId;\n+        if (schemaName == null) {\n             artifactId = idGenerator.generate();\n+        } else {\n+            artifactId = schemaName.toLowerCase();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9aa2c005c1a7c0ed5b003c83e36fe6bbfb059ec0"}, "originalPosition": 261}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d99a179ca9de6a6c082a68c205fd698d3ed2eab2", "author": {"user": {"login": "ajborley", "name": "Andrew Borley"}}, "url": "https://github.com/Apicurio/apicurio-registry/commit/d99a179ca9de6a6c082a68c205fd698d3ed2eab2", "committedDate": "2020-08-11T07:24:20Z", "message": "Enhance ibmcompat API GET and POST methods\n\n- This commit improves the data returned by the ibmcompat API GET\nendpoints to include metadata already stored with the artifact.\n- It also improves the ibmcompat API POST endpoints by returning\nmetadata stored with the artifact.\n- It also adds a set of initial tests for the functionality that follow\nthe ccompat API and artifact API tests.\n\nSigned-off-by: Andrew Borley <borley@uk.ibm.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7c7a219aa5fa88f5fecadb50a7df2e732d68e000", "author": {"user": {"login": "ajborley", "name": "Andrew Borley"}}, "url": "https://github.com/Apicurio/apicurio-registry/commit/7c7a219aa5fa88f5fecadb50a7df2e732d68e000", "committedDate": "2020-08-11T07:24:20Z", "message": "Enhance ibmcompat API PATCH methods\n\n - This commit adds implementations and tests for the two lifecycle\nmanagement methods of the ibmcompat API:\n    - `PATCH ibmcompat/schemas/{schema-id}`\n    - `PATCH ibmcompat/schemas/{schema-id}/versions/{version-id}`\n\nSigned-off-by: Andrew Borley <borley@uk.ibm.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "844bc3b54650a56a998449bdc21cfad1538f1d67", "author": {"user": {"login": "ajborley", "name": "Andrew Borley"}}, "url": "https://github.com/Apicurio/apicurio-registry/commit/844bc3b54650a56a998449bdc21cfad1538f1d67", "committedDate": "2020-08-11T07:24:20Z", "message": "Fix test by ensuring ConcurrentException cause is returned\n\nSigned-off-by: Andrew Borley <borley@uk.ibm.com>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "28559d0f0618660bf86bb96c8b1d9e677f7bcb00", "author": {"user": {"login": "ajborley", "name": "Andrew Borley"}}, "url": "https://github.com/Apicurio/apicurio-registry/commit/28559d0f0618660bf86bb96c8b1d9e677f7bcb00", "committedDate": "2020-08-10T20:38:00Z", "message": "Fix test by ensuring ConcurrentException cause is returned\n\nSigned-off-by: Andrew Borley <borley@uk.ibm.com>"}, "afterCommit": {"oid": "844bc3b54650a56a998449bdc21cfad1538f1d67", "author": {"user": {"login": "ajborley", "name": "Andrew Borley"}}, "url": "https://github.com/Apicurio/apicurio-registry/commit/844bc3b54650a56a998449bdc21cfad1538f1d67", "committedDate": "2020-08-11T07:24:20Z", "message": "Fix test by ensuring ConcurrentException cause is returned\n\nSigned-off-by: Andrew Borley <borley@uk.ibm.com>"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4472, "cost": 1, "resetAt": "2021-11-01T11:59:11Z"}}}