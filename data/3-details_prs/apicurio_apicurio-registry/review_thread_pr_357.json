{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0Mzk3NDk2Mjcx", "number": 357, "reviewThreads": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMlQxMTo0Nzo0NFrODt6nfQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOFQxNzo0ODowMVrODwGXWw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ5NDcyODkzOnYy", "diffSide": "RIGHT", "path": "app/src/main/java/io/apicurio/registry/ccompat/rest/impl/CompatibilityResourceImpl.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMlQxMTo0Nzo0NFrOF_ndcw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMlQxMTo0Nzo0NFrOF_ndcw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjI1MTEyMw==", "bodyText": "Yeah, they now support different types as well.\nBut is this reflected in their API?", "url": "https://github.com/Apicurio/apicurio-registry/pull/357#discussion_r402251123", "createdAt": "2020-04-02T11:47:44Z", "author": {"login": "alesj"}, "path": "app/src/main/java/io/apicurio/registry/ccompat/rest/impl/CompatibilityResourceImpl.java", "diffHunk": "@@ -0,0 +1,77 @@\n+/*\r\n+ * Copyright 2019 Red Hat\r\n+ *\r\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n+ * you may not use this file except in compliance with the License.\r\n+ * You may obtain a copy of the License at\r\n+ *\r\n+ *      http://www.apache.org/licenses/LICENSE-2.0\r\n+ *\r\n+ * Unless required by applicable law or agreed to in writing, software\r\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n+ * See the License for the specific language governing permissions and\r\n+ * limitations under the License.\r\n+ */\r\n+\r\n+package io.apicurio.registry.ccompat.rest.impl;\r\n+\r\n+import io.apicurio.registry.ccompat.dto.CompatibilityCheckResponse;\r\n+import io.apicurio.registry.ccompat.dto.SchemaContent;\r\n+import io.apicurio.registry.ccompat.rest.CompatibilityResource;\r\n+import io.apicurio.registry.ccompat.store.RegistryStorageFacade;\r\n+import io.apicurio.registry.content.ContentHandle;\r\n+import io.apicurio.registry.metrics.ResponseErrorLivenessCheck;\r\n+import io.apicurio.registry.metrics.ResponseTimeoutReadinessCheck;\r\n+import io.apicurio.registry.metrics.RestMetricsApply;\r\n+import io.apicurio.registry.rules.RuleViolationException;\r\n+import io.apicurio.registry.rules.RulesService;\r\n+import io.apicurio.registry.types.ArtifactType;\r\n+import org.eclipse.microprofile.metrics.annotation.ConcurrentGauge;\r\n+import org.eclipse.microprofile.metrics.annotation.Counted;\r\n+import org.eclipse.microprofile.metrics.annotation.Timed;\r\n+\r\n+import javax.enterprise.context.ApplicationScoped;\r\n+import javax.inject.Inject;\r\n+import javax.interceptor.Interceptors;\r\n+\r\n+import static io.apicurio.registry.metrics.MetricIDs.*;\r\n+import static org.eclipse.microprofile.metrics.MetricUnits.MILLISECONDS;\r\n+\r\n+/**\r\n+ * @author Ales Justin\r\n+ * @author Jakub Senko <jsenko@redhat.com>\r\n+ */\r\n+\r\n+@ApplicationScoped\r\n+@Interceptors({ResponseErrorLivenessCheck.class, ResponseTimeoutReadinessCheck.class})\r\n+@RestMetricsApply\r\n+@Counted(name = REST_REQUEST_COUNT, description = REST_REQUEST_COUNT_DESC, tags = {\"group=\" + REST_GROUP_TAG, \"metric=\" + REST_REQUEST_COUNT})\r\n+@ConcurrentGauge(name = REST_CONCURRENT_REQUEST_COUNT, description = REST_CONCURRENT_REQUEST_COUNT_DESC, tags = {\"group=\" + REST_GROUP_TAG, \"metric=\" + REST_CONCURRENT_REQUEST_COUNT})\r\n+@Timed(name = REST_REQUEST_RESPONSE_TIME, description = REST_REQUEST_RESPONSE_TIME_DESC, tags = {\"group=\" + REST_GROUP_TAG, \"metric=\" + REST_REQUEST_RESPONSE_TIME}, unit = MILLISECONDS)\r\n+public class CompatibilityResourceImpl extends AbstractResource implements CompatibilityResource {\r\n+\r\n+    @Inject\r\n+    RulesService rules;\r\n+\r\n+    @Inject\r\n+    RegistryStorageFacade storage;\r\n+\r\n+    @Override\r\n+    public CompatibilityCheckResponse testCompatibilityBySubjectName(\r\n+            String subject,\r\n+            String versionString,\r\n+            SchemaContent request) throws Exception {\r\n+\r\n+        CompatibilityCheckResponse result = storage.parseVersionString(subject, versionString, version -> {\r\n+            // TODO are we safe to assume AVRO?\r", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f7f3a9b0aff2b74018d05308b7eb64c15953fc4f"}, "originalPosition": 67}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ5NDc0MTc1OnYy", "diffSide": "RIGHT", "path": "app/src/main/java/io/apicurio/registry/ccompat/store/FacadeConverter.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMlQxMTo1MToyOVrOF_nlEA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMlQxMTo1MToyOVrOF_nlEA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjI1MzA3Mg==", "bodyText": "Missing header ...", "url": "https://github.com/Apicurio/apicurio-registry/pull/357#discussion_r402253072", "createdAt": "2020-04-02T11:51:29Z", "author": {"login": "alesj"}, "path": "app/src/main/java/io/apicurio/registry/ccompat/store/FacadeConverter.java", "diffHunk": "@@ -0,0 +1,28 @@\n+package io.apicurio.registry.ccompat.store;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f7f3a9b0aff2b74018d05308b7eb64c15953fc4f"}, "originalPosition": 1}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ5NDc0NTg0OnYy", "diffSide": "RIGHT", "path": "app/src/main/java/io/apicurio/registry/ccompat/store/RegistryStorageFacade.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMlQxMTo1Mjo0MVrOF_nngA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMlQxMjo0NzoyM1rOF_pifg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjI1MzY5Ng==", "bodyText": "We need to check how they now support different types, and extend this facade accordingly.", "url": "https://github.com/Apicurio/apicurio-registry/pull/357#discussion_r402253696", "createdAt": "2020-04-02T11:52:41Z", "author": {"login": "alesj"}, "path": "app/src/main/java/io/apicurio/registry/ccompat/store/RegistryStorageFacade.java", "diffHunk": "@@ -17,39 +17,66 @@\n package io.apicurio.registry.ccompat.store;\n \n import io.apicurio.registry.ccompat.dto.Schema;\n+import io.apicurio.registry.ccompat.dto.SchemaContent;\n+import io.apicurio.registry.ccompat.rest.error.SchemaNotFoundException;\n import io.apicurio.registry.storage.ArtifactAlreadyExistsException;\n import io.apicurio.registry.storage.ArtifactNotFoundException;\n import io.apicurio.registry.storage.RegistryStorageException;\n+import io.apicurio.registry.storage.RuleConfigurationDto;\n import io.apicurio.registry.storage.VersionNotFoundException;\n+import io.apicurio.registry.types.RuleType;\n \n import java.util.List;\n-import java.util.Set;\n-import java.util.SortedSet;\n import java.util.concurrent.CompletionStage;\n+import java.util.function.Function;\n \n /**\n+ * Note: This facade is only expected to be used for AVRO artifact type.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f7f3a9b0aff2b74018d05308b7eb64c15953fc4f"}, "originalPosition": 20}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjI4NTE4Mg==", "bodyText": "Agreed.", "url": "https://github.com/Apicurio/apicurio-registry/pull/357#discussion_r402285182", "createdAt": "2020-04-02T12:47:23Z", "author": {"login": "EricWittmann"}, "path": "app/src/main/java/io/apicurio/registry/ccompat/store/RegistryStorageFacade.java", "diffHunk": "@@ -17,39 +17,66 @@\n package io.apicurio.registry.ccompat.store;\n \n import io.apicurio.registry.ccompat.dto.Schema;\n+import io.apicurio.registry.ccompat.dto.SchemaContent;\n+import io.apicurio.registry.ccompat.rest.error.SchemaNotFoundException;\n import io.apicurio.registry.storage.ArtifactAlreadyExistsException;\n import io.apicurio.registry.storage.ArtifactNotFoundException;\n import io.apicurio.registry.storage.RegistryStorageException;\n+import io.apicurio.registry.storage.RuleConfigurationDto;\n import io.apicurio.registry.storage.VersionNotFoundException;\n+import io.apicurio.registry.types.RuleType;\n \n import java.util.List;\n-import java.util.Set;\n-import java.util.SortedSet;\n import java.util.concurrent.CompletionStage;\n+import java.util.function.Function;\n \n /**\n+ * Note: This facade is only expected to be used for AVRO artifact type.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjI1MzY5Ng=="}, "originalCommit": {"oid": "f7f3a9b0aff2b74018d05308b7eb64c15953fc4f"}, "originalPosition": 20}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ5NDc2MTQ5OnYy", "diffSide": "RIGHT", "path": "app/src/main/java/io/apicurio/registry/ccompat/store/RegistryStorageFacadeImpl.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMlQxMTo1NzoxM1rOF_nw_A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMlQxOTo1NjowMFrOF_7LSA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjI1NjEyNA==", "bodyText": "This should rather be to catch AlreadyExists on create, then to do previous check.\nSince while you check for an existing artifact, and you get false, one can be created.\nHighly unlikely, but still better to handle it \"defensively\", as that way there is no concurrency error.", "url": "https://github.com/Apicurio/apicurio-registry/pull/357#discussion_r402256124", "createdAt": "2020-04-02T11:57:13Z", "author": {"login": "alesj"}, "path": "app/src/main/java/io/apicurio/registry/ccompat/store/RegistryStorageFacadeImpl.java", "diffHunk": "@@ -46,84 +53,144 @@\n     @Current\n     RegistryStorage storage;\n \n-    private static Schema toSchema(String subject, StoredArtifact storedArtifact) {\n-        return new Schema(\n-            subject,\n-            storedArtifact.version.intValue(),\n-            storedArtifact.id.intValue(),\n-            storedArtifact.content.content()\n-        );\n-    }\n \n-    public Set<String> listSubjects() {\n-        return storage.getArtifactIds();\n+    public List<String> getSubjects() {\n+        // TODO maybe not necessary...\n+        return new ArrayList<>(storage.getArtifactIds());\n     }\n \n     @Override\n-    public SortedSet<Long> deleteSubject(String subject) throws ArtifactNotFoundException, RegistryStorageException {\n-        return storage.deleteArtifact(subject);\n+    public List<Integer> deleteSubject(String subject) throws ArtifactNotFoundException, RegistryStorageException {\n+        return storage.deleteArtifact(subject)\n+                .stream()\n+                .map(FacadeConverter::convertUnsigned)\n+                .collect(Collectors.toList());\n     }\n \n     @Override\n-    public String getSchema(Integer id) throws ArtifactNotFoundException, RegistryStorageException {\n-        return storage.getArtifactVersion(id).content.content();\n+    public SchemaContent getSchemaContent(int globalId) throws ArtifactNotFoundException, RegistryStorageException {\n+        try {\n+            return FacadeConverter.convert(storage.getArtifactVersion(globalId));\n+            // TODO StoredArtifact should contain artifactId IF we are not treating globalId separately\n+        } catch (ArtifactNotFoundException ex) {\n+            throw new SchemaNotFoundException(ex);\n+        }\n     }\n \n     @Override\n     public Schema getSchema(String subject, String versionString) throws ArtifactNotFoundException, VersionNotFoundException, RegistryStorageException {\n-        try {\n-            long version = Long.parseLong(versionString);\n-            return toSchema(subject, storage.getArtifactVersion(subject, version));\n-        } catch (NumberFormatException e) {\n-            // return latest\n-            return toSchema(subject, storage.getArtifact(subject));\n-        }\n+        return parseVersionString(subject, versionString,\n+                version -> FacadeConverter.convert(subject, storage.getArtifactVersion(subject, version)));\n     }\n \n     @Override\n-    public List<Integer> listVersions(String subject) throws ArtifactNotFoundException, RegistryStorageException {\n+    public List<Integer> getVersions(String subject) throws ArtifactNotFoundException, RegistryStorageException {\n         return storage.getArtifactVersions(subject)\n-                      .stream()\n-                      .map(Long::intValue)\n-                      .collect(Collectors.toList());\n+                .stream()\n+                .map(FacadeConverter::convertUnsigned)\n+                .collect(Collectors.toList());\n     }\n \n     @Override\n-    public Schema findSchemaWithSubject(String subject, boolean checkDeletedSchema, String schema) throws ArtifactNotFoundException, RegistryStorageException {\n+    public Schema getSchema(String subject, SchemaContent schema) throws ArtifactNotFoundException, RegistryStorageException {\n         // TODO -- handle deleted?\n-        ArtifactMetaDataDto amd = storage.getArtifactMetaData(subject, ContentHandle.create(schema));\n+        ArtifactMetaDataDto amd = storage.getArtifactMetaData(subject, ContentHandle.create(schema.getSchema()));\n         StoredArtifact storedArtifact = storage.getArtifactVersion(subject, amd.getVersion());\n-        return toSchema(subject, storedArtifact);\n+        return FacadeConverter.convert(subject, storedArtifact);\n+    }\n+\n+    @Override\n+    public CompletionStage<Long> createSchema(String subject, String schema) throws ArtifactAlreadyExistsException, ArtifactNotFoundException, RegistryStorageException {\n+\n+        // TODO Should this creation and updating of an artifact be a different operation?\n+        // TODO method that returns a completion stage should not throw an exception\n+        CompletionStage<ArtifactMetaDataDto> artifactMeta = createOrUpdateArtifact(subject, schema);\n+\n+        return artifactMeta.thenApply(ArtifactMetaDataDto::getGlobalId);\n+    }\n+\n+    @Override\n+    public int deleteSchema(String subject, String versionString) throws ArtifactNotFoundException, VersionNotFoundException, RegistryStorageException {\n+        return FacadeConverter.convertUnsigned(parseVersionString(subject, versionString, version -> {\n+            storage.deleteArtifactVersion(subject, version);\n+            return version;\n+        }));\n+    }\n+\n+    @Override\n+    public void createOrUpdateArtifactRule(String subject, RuleType type, RuleConfigurationDto dto) {\n+        if (!doesArtifactRuleExist(subject, RuleType.COMPATIBILITY)) {\n+            storage.createArtifactRule(subject, RuleType.COMPATIBILITY, dto);\n+        } else {\n+            storage.updateArtifactRule(subject, RuleType.COMPATIBILITY, dto);\n+        }\n     }\n \n     @Override\n-    public CompletionStage<Long> registerSchema(String subject, Integer id, Integer version, String schema) throws ArtifactAlreadyExistsException, ArtifactNotFoundException, RegistryStorageException {\n-        ArtifactMetaDataDto metadata = null;\n+    public void createOrUpdateGlobalRule(RuleType type, RuleConfigurationDto dto) {\n+        if (!doesGlobalRuleExist(RuleType.COMPATIBILITY)) {\n+            storage.createGlobalRule(RuleType.COMPATIBILITY, dto);\n+        } else {\n+            storage.updateGlobalRule(RuleType.COMPATIBILITY, dto);\n+        }\n+    }\n+\n+    private CompletionStage<ArtifactMetaDataDto> createOrUpdateArtifact(String subject, String schema) {\n+        if (!doesArtifactExist(subject)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f7f3a9b0aff2b74018d05308b7eb64c15953fc4f"}, "originalPosition": 154}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjI4NjM0Mg==", "bodyText": "Even doing that we probably have a race condition in the Streams storage implementation when running more than one instance, right?", "url": "https://github.com/Apicurio/apicurio-registry/pull/357#discussion_r402286342", "createdAt": "2020-04-02T12:49:09Z", "author": {"login": "EricWittmann"}, "path": "app/src/main/java/io/apicurio/registry/ccompat/store/RegistryStorageFacadeImpl.java", "diffHunk": "@@ -46,84 +53,144 @@\n     @Current\n     RegistryStorage storage;\n \n-    private static Schema toSchema(String subject, StoredArtifact storedArtifact) {\n-        return new Schema(\n-            subject,\n-            storedArtifact.version.intValue(),\n-            storedArtifact.id.intValue(),\n-            storedArtifact.content.content()\n-        );\n-    }\n \n-    public Set<String> listSubjects() {\n-        return storage.getArtifactIds();\n+    public List<String> getSubjects() {\n+        // TODO maybe not necessary...\n+        return new ArrayList<>(storage.getArtifactIds());\n     }\n \n     @Override\n-    public SortedSet<Long> deleteSubject(String subject) throws ArtifactNotFoundException, RegistryStorageException {\n-        return storage.deleteArtifact(subject);\n+    public List<Integer> deleteSubject(String subject) throws ArtifactNotFoundException, RegistryStorageException {\n+        return storage.deleteArtifact(subject)\n+                .stream()\n+                .map(FacadeConverter::convertUnsigned)\n+                .collect(Collectors.toList());\n     }\n \n     @Override\n-    public String getSchema(Integer id) throws ArtifactNotFoundException, RegistryStorageException {\n-        return storage.getArtifactVersion(id).content.content();\n+    public SchemaContent getSchemaContent(int globalId) throws ArtifactNotFoundException, RegistryStorageException {\n+        try {\n+            return FacadeConverter.convert(storage.getArtifactVersion(globalId));\n+            // TODO StoredArtifact should contain artifactId IF we are not treating globalId separately\n+        } catch (ArtifactNotFoundException ex) {\n+            throw new SchemaNotFoundException(ex);\n+        }\n     }\n \n     @Override\n     public Schema getSchema(String subject, String versionString) throws ArtifactNotFoundException, VersionNotFoundException, RegistryStorageException {\n-        try {\n-            long version = Long.parseLong(versionString);\n-            return toSchema(subject, storage.getArtifactVersion(subject, version));\n-        } catch (NumberFormatException e) {\n-            // return latest\n-            return toSchema(subject, storage.getArtifact(subject));\n-        }\n+        return parseVersionString(subject, versionString,\n+                version -> FacadeConverter.convert(subject, storage.getArtifactVersion(subject, version)));\n     }\n \n     @Override\n-    public List<Integer> listVersions(String subject) throws ArtifactNotFoundException, RegistryStorageException {\n+    public List<Integer> getVersions(String subject) throws ArtifactNotFoundException, RegistryStorageException {\n         return storage.getArtifactVersions(subject)\n-                      .stream()\n-                      .map(Long::intValue)\n-                      .collect(Collectors.toList());\n+                .stream()\n+                .map(FacadeConverter::convertUnsigned)\n+                .collect(Collectors.toList());\n     }\n \n     @Override\n-    public Schema findSchemaWithSubject(String subject, boolean checkDeletedSchema, String schema) throws ArtifactNotFoundException, RegistryStorageException {\n+    public Schema getSchema(String subject, SchemaContent schema) throws ArtifactNotFoundException, RegistryStorageException {\n         // TODO -- handle deleted?\n-        ArtifactMetaDataDto amd = storage.getArtifactMetaData(subject, ContentHandle.create(schema));\n+        ArtifactMetaDataDto amd = storage.getArtifactMetaData(subject, ContentHandle.create(schema.getSchema()));\n         StoredArtifact storedArtifact = storage.getArtifactVersion(subject, amd.getVersion());\n-        return toSchema(subject, storedArtifact);\n+        return FacadeConverter.convert(subject, storedArtifact);\n+    }\n+\n+    @Override\n+    public CompletionStage<Long> createSchema(String subject, String schema) throws ArtifactAlreadyExistsException, ArtifactNotFoundException, RegistryStorageException {\n+\n+        // TODO Should this creation and updating of an artifact be a different operation?\n+        // TODO method that returns a completion stage should not throw an exception\n+        CompletionStage<ArtifactMetaDataDto> artifactMeta = createOrUpdateArtifact(subject, schema);\n+\n+        return artifactMeta.thenApply(ArtifactMetaDataDto::getGlobalId);\n+    }\n+\n+    @Override\n+    public int deleteSchema(String subject, String versionString) throws ArtifactNotFoundException, VersionNotFoundException, RegistryStorageException {\n+        return FacadeConverter.convertUnsigned(parseVersionString(subject, versionString, version -> {\n+            storage.deleteArtifactVersion(subject, version);\n+            return version;\n+        }));\n+    }\n+\n+    @Override\n+    public void createOrUpdateArtifactRule(String subject, RuleType type, RuleConfigurationDto dto) {\n+        if (!doesArtifactRuleExist(subject, RuleType.COMPATIBILITY)) {\n+            storage.createArtifactRule(subject, RuleType.COMPATIBILITY, dto);\n+        } else {\n+            storage.updateArtifactRule(subject, RuleType.COMPATIBILITY, dto);\n+        }\n     }\n \n     @Override\n-    public CompletionStage<Long> registerSchema(String subject, Integer id, Integer version, String schema) throws ArtifactAlreadyExistsException, ArtifactNotFoundException, RegistryStorageException {\n-        ArtifactMetaDataDto metadata = null;\n+    public void createOrUpdateGlobalRule(RuleType type, RuleConfigurationDto dto) {\n+        if (!doesGlobalRuleExist(RuleType.COMPATIBILITY)) {\n+            storage.createGlobalRule(RuleType.COMPATIBILITY, dto);\n+        } else {\n+            storage.updateGlobalRule(RuleType.COMPATIBILITY, dto);\n+        }\n+    }\n+\n+    private CompletionStage<ArtifactMetaDataDto> createOrUpdateArtifact(String subject, String schema) {\n+        if (!doesArtifactExist(subject)) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjI1NjEyNA=="}, "originalCommit": {"oid": "f7f3a9b0aff2b74018d05308b7eb64c15953fc4f"}, "originalPosition": 154}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjU3NDE1Mg==", "bodyText": "I'm not sure it would be a race condition, since all artifacts with same artifactId are handled on the same node, in ordered (sync) fashion.\nFor create, if two requests would be concurrent, one would fail -- see StreamsRegistryStorage impl.\nFor update, it would also fail -- if someone would delete the artifacts during that async op.", "url": "https://github.com/Apicurio/apicurio-registry/pull/357#discussion_r402574152", "createdAt": "2020-04-02T19:56:00Z", "author": {"login": "alesj"}, "path": "app/src/main/java/io/apicurio/registry/ccompat/store/RegistryStorageFacadeImpl.java", "diffHunk": "@@ -46,84 +53,144 @@\n     @Current\n     RegistryStorage storage;\n \n-    private static Schema toSchema(String subject, StoredArtifact storedArtifact) {\n-        return new Schema(\n-            subject,\n-            storedArtifact.version.intValue(),\n-            storedArtifact.id.intValue(),\n-            storedArtifact.content.content()\n-        );\n-    }\n \n-    public Set<String> listSubjects() {\n-        return storage.getArtifactIds();\n+    public List<String> getSubjects() {\n+        // TODO maybe not necessary...\n+        return new ArrayList<>(storage.getArtifactIds());\n     }\n \n     @Override\n-    public SortedSet<Long> deleteSubject(String subject) throws ArtifactNotFoundException, RegistryStorageException {\n-        return storage.deleteArtifact(subject);\n+    public List<Integer> deleteSubject(String subject) throws ArtifactNotFoundException, RegistryStorageException {\n+        return storage.deleteArtifact(subject)\n+                .stream()\n+                .map(FacadeConverter::convertUnsigned)\n+                .collect(Collectors.toList());\n     }\n \n     @Override\n-    public String getSchema(Integer id) throws ArtifactNotFoundException, RegistryStorageException {\n-        return storage.getArtifactVersion(id).content.content();\n+    public SchemaContent getSchemaContent(int globalId) throws ArtifactNotFoundException, RegistryStorageException {\n+        try {\n+            return FacadeConverter.convert(storage.getArtifactVersion(globalId));\n+            // TODO StoredArtifact should contain artifactId IF we are not treating globalId separately\n+        } catch (ArtifactNotFoundException ex) {\n+            throw new SchemaNotFoundException(ex);\n+        }\n     }\n \n     @Override\n     public Schema getSchema(String subject, String versionString) throws ArtifactNotFoundException, VersionNotFoundException, RegistryStorageException {\n-        try {\n-            long version = Long.parseLong(versionString);\n-            return toSchema(subject, storage.getArtifactVersion(subject, version));\n-        } catch (NumberFormatException e) {\n-            // return latest\n-            return toSchema(subject, storage.getArtifact(subject));\n-        }\n+        return parseVersionString(subject, versionString,\n+                version -> FacadeConverter.convert(subject, storage.getArtifactVersion(subject, version)));\n     }\n \n     @Override\n-    public List<Integer> listVersions(String subject) throws ArtifactNotFoundException, RegistryStorageException {\n+    public List<Integer> getVersions(String subject) throws ArtifactNotFoundException, RegistryStorageException {\n         return storage.getArtifactVersions(subject)\n-                      .stream()\n-                      .map(Long::intValue)\n-                      .collect(Collectors.toList());\n+                .stream()\n+                .map(FacadeConverter::convertUnsigned)\n+                .collect(Collectors.toList());\n     }\n \n     @Override\n-    public Schema findSchemaWithSubject(String subject, boolean checkDeletedSchema, String schema) throws ArtifactNotFoundException, RegistryStorageException {\n+    public Schema getSchema(String subject, SchemaContent schema) throws ArtifactNotFoundException, RegistryStorageException {\n         // TODO -- handle deleted?\n-        ArtifactMetaDataDto amd = storage.getArtifactMetaData(subject, ContentHandle.create(schema));\n+        ArtifactMetaDataDto amd = storage.getArtifactMetaData(subject, ContentHandle.create(schema.getSchema()));\n         StoredArtifact storedArtifact = storage.getArtifactVersion(subject, amd.getVersion());\n-        return toSchema(subject, storedArtifact);\n+        return FacadeConverter.convert(subject, storedArtifact);\n+    }\n+\n+    @Override\n+    public CompletionStage<Long> createSchema(String subject, String schema) throws ArtifactAlreadyExistsException, ArtifactNotFoundException, RegistryStorageException {\n+\n+        // TODO Should this creation and updating of an artifact be a different operation?\n+        // TODO method that returns a completion stage should not throw an exception\n+        CompletionStage<ArtifactMetaDataDto> artifactMeta = createOrUpdateArtifact(subject, schema);\n+\n+        return artifactMeta.thenApply(ArtifactMetaDataDto::getGlobalId);\n+    }\n+\n+    @Override\n+    public int deleteSchema(String subject, String versionString) throws ArtifactNotFoundException, VersionNotFoundException, RegistryStorageException {\n+        return FacadeConverter.convertUnsigned(parseVersionString(subject, versionString, version -> {\n+            storage.deleteArtifactVersion(subject, version);\n+            return version;\n+        }));\n+    }\n+\n+    @Override\n+    public void createOrUpdateArtifactRule(String subject, RuleType type, RuleConfigurationDto dto) {\n+        if (!doesArtifactRuleExist(subject, RuleType.COMPATIBILITY)) {\n+            storage.createArtifactRule(subject, RuleType.COMPATIBILITY, dto);\n+        } else {\n+            storage.updateArtifactRule(subject, RuleType.COMPATIBILITY, dto);\n+        }\n     }\n \n     @Override\n-    public CompletionStage<Long> registerSchema(String subject, Integer id, Integer version, String schema) throws ArtifactAlreadyExistsException, ArtifactNotFoundException, RegistryStorageException {\n-        ArtifactMetaDataDto metadata = null;\n+    public void createOrUpdateGlobalRule(RuleType type, RuleConfigurationDto dto) {\n+        if (!doesGlobalRuleExist(RuleType.COMPATIBILITY)) {\n+            storage.createGlobalRule(RuleType.COMPATIBILITY, dto);\n+        } else {\n+            storage.updateGlobalRule(RuleType.COMPATIBILITY, dto);\n+        }\n+    }\n+\n+    private CompletionStage<ArtifactMetaDataDto> createOrUpdateArtifact(String subject, String schema) {\n+        if (!doesArtifactExist(subject)) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjI1NjEyNA=="}, "originalCommit": {"oid": "f7f3a9b0aff2b74018d05308b7eb64c15953fc4f"}, "originalPosition": 154}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ5NDc2NjY2OnYy", "diffSide": "RIGHT", "path": "app/src/main/java/io/apicurio/registry/content/ContentHandle.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMlQxMTo1ODozOVrOF_n0IA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMlQxMTo1ODozOVrOF_n0IA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjI1NjkyOA==", "bodyText": "It should be -- that's the purpose of the handle!", "url": "https://github.com/Apicurio/apicurio-registry/pull/357#discussion_r402256928", "createdAt": "2020-04-02T11:58:39Z", "author": {"login": "alesj"}, "path": "app/src/main/java/io/apicurio/registry/content/ContentHandle.java", "diffHunk": "@@ -21,6 +21,7 @@\n /**\n  * @author Ales Justin\n  */\n+// TODO Can a single CH be used multiple times?", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f7f3a9b0aff2b74018d05308b7eb64c15953fc4f"}, "originalPosition": 4}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ5NDc2OTAyOnYy", "diffSide": "RIGHT", "path": "app/src/main/java/io/apicurio/registry/rest/RegistryExceptionMapper.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMlQxMTo1OToxMlrOF_n1hA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMlQxNzoyNDoyMVrOF_1mlw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjI1NzI4NA==", "bodyText": "No enum / constant for 422 ?", "url": "https://github.com/Apicurio/apicurio-registry/pull/357#discussion_r402257284", "createdAt": "2020-04-02T11:59:12Z", "author": {"login": "alesj"}, "path": "app/src/main/java/io/apicurio/registry/rest/RegistryExceptionMapper.java", "diffHunk": "@@ -76,6 +76,7 @@\n         map.put(RuleNotFoundException.class, HTTP_NOT_FOUND);\n         map.put(RuleViolationException.class, HTTP_BAD_REQUEST);\n         map.put(VersionNotFoundException.class, HTTP_NOT_FOUND);\n+        map.put(IllegalArgumentException.class, 422);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f7f3a9b0aff2b74018d05308b7eb64c15953fc4f"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjQ4MjgzOQ==", "bodyText": "There is no existing one so I've added it.", "url": "https://github.com/Apicurio/apicurio-registry/pull/357#discussion_r402482839", "createdAt": "2020-04-02T17:24:21Z", "author": {"login": "jsenko"}, "path": "app/src/main/java/io/apicurio/registry/rest/RegistryExceptionMapper.java", "diffHunk": "@@ -76,6 +76,7 @@\n         map.put(RuleNotFoundException.class, HTTP_NOT_FOUND);\n         map.put(RuleViolationException.class, HTTP_BAD_REQUEST);\n         map.put(VersionNotFoundException.class, HTTP_NOT_FOUND);\n+        map.put(IllegalArgumentException.class, 422);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjI1NzI4NA=="}, "originalCommit": {"oid": "f7f3a9b0aff2b74018d05308b7eb64c15953fc4f"}, "originalPosition": 4}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ5NDc4MDA2OnYy", "diffSide": "RIGHT", "path": "storage/jpa/src/main/java/io/apicurio/registry/storage/impl/jpa/JPARegistryStorage.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMlQxMjowMjozMlrOF_n8og==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMlQxMjowMjozMlrOF_n8og==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjI1OTEwNg==", "bodyText": "It looks like it could be, unless you have some constraint on the tuple (<aritfactId, version>) ?\nThen you must handle this constraint in a loop -- allowing it to fail, and get next version, ...", "url": "https://github.com/Apicurio/apicurio-registry/pull/357#discussion_r402259106", "createdAt": "2020-04-02T12:02:32Z", "author": {"login": "alesj"}, "path": "storage/jpa/src/main/java/io/apicurio/registry/storage/impl/jpa/JPARegistryStorage.java", "diffHunk": "@@ -95,6 +95,7 @@\n     @Inject\n     ArtifactTypeUtilProviderFactory factory;\n \n+    // TODO Could there be a race condition here? The new max+1 version is saved with a new artifact", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f7f3a9b0aff2b74018d05308b7eb64c15953fc4f"}, "originalPosition": 4}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUxNzYyNTIzOnYy", "diffSide": "RIGHT", "path": "app/src/main/java/io/apicurio/registry/ccompat/rest/README.md", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOFQxNzo0ODowMlrOGC6NrA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOFQxNzo0ODowMlrOGC6NrA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTcwNDEwOA==", "bodyText": "I think you can use any number for these, not always (1) ... fwiw.", "url": "https://github.com/Apicurio/apicurio-registry/pull/357#discussion_r405704108", "createdAt": "2020-04-08T17:48:02Z", "author": {"login": "EricWittmann"}, "path": "app/src/main/java/io/apicurio/registry/ccompat/rest/README.md", "diffHunk": "@@ -0,0 +1,20 @@\n+# Compatibility Notes\n+\n+1. The API should follow [Confluent spec](https://docs.confluent.io/5.4.1/schema-registry/develop/api.html)\n+\n+1. We expect only Avro schemas are supported\n+\n+1. Schema deleted using `SubjectVersionsResource#deleteSchemaVersion(java.lang.String, java.lang.String)`\n+   should still be accessible using global ID. This guarantee can not be kept in our implementation, \n+   since any schema must be part of an artifact.\n+   \n+1. Some endpoints expect raising error `422` if the schema is invalid, and error `409` if the schema is incompatible.\n+   Schema format validation is done only if such validation rule is configured. \n+   Therefore when creating a new subject, validation rule for it is also configured \n+   to possibly return `422` when a new version is added. If the rule is removed by another means\n+   (registry API), this check will not work.\n+\n+**TODO:**\n+\n+1. Registry provides a state API. If the state of the artifact (or version) is `DISABLED` or `DELETED`,\n+   it takes precedence and is not returned.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "47cd144b8d94b54324fc5ac5daeed1230b542b4e"}, "originalPosition": 20}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3381, "cost": 1, "resetAt": "2021-11-12T09:44:50Z"}}}