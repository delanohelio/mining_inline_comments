{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDIwNzcyMDc4", "number": 506, "reviewThreads": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMFQxNzozNzo1M1rOD-UpJQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMFQxNzo0MzowM1rOD-UwQg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY2Njc2NTE3OnYy", "diffSide": "RIGHT", "path": "app/src/main/java/io/apicurio/registry/ccompat/rest/impl/CompatibilityResourceImpl.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMFQxNzozNzo1M1rOGYWs5w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMFQxNzo1MzoyN1rOGYXRXA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODE5MDk1MQ==", "bodyText": "Are Confluent's schema type constants the same as ours??", "url": "https://github.com/Apicurio/apicurio-registry/pull/506#discussion_r428190951", "createdAt": "2020-05-20T17:37:53Z", "author": {"login": "EricWittmann"}, "path": "app/src/main/java/io/apicurio/registry/ccompat/rest/impl/CompatibilityResourceImpl.java", "diffHunk": "@@ -68,9 +68,8 @@ public CompatibilityCheckResponse testCompatibilityBySubjectName(\n             SchemaContent request) throws Exception {\r\n \r\n         CompatibilityCheckResponse result = facade.parseVersionString(subject, versionString, version -> {\r\n-            // TODO are we safe to assume AVRO?\r\n             try {\r\n-                rules.applyRule(subject, version, ArtifactType.AVRO, ContentHandle.create(request.getSchema()));\r\n+                rules.applyRule(subject, version, ArtifactType.fromValue(request.getSchemaType()), ContentHandle.create(request.getSchema()));\r", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "87fafda4565ccaab077cedc13bef08b771b1e4fe"}, "originalPosition": 7}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODIwMDI4NA==", "bodyText": "Yep, same constant values.", "url": "https://github.com/Apicurio/apicurio-registry/pull/506#discussion_r428200284", "createdAt": "2020-05-20T17:53:27Z", "author": {"login": "carlesarnal"}, "path": "app/src/main/java/io/apicurio/registry/ccompat/rest/impl/CompatibilityResourceImpl.java", "diffHunk": "@@ -68,9 +68,8 @@ public CompatibilityCheckResponse testCompatibilityBySubjectName(\n             SchemaContent request) throws Exception {\r\n \r\n         CompatibilityCheckResponse result = facade.parseVersionString(subject, versionString, version -> {\r\n-            // TODO are we safe to assume AVRO?\r\n             try {\r\n-                rules.applyRule(subject, version, ArtifactType.AVRO, ContentHandle.create(request.getSchema()));\r\n+                rules.applyRule(subject, version, ArtifactType.fromValue(request.getSchemaType()), ContentHandle.create(request.getSchema()));\r", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODE5MDk1MQ=="}, "originalCommit": {"oid": "87fafda4565ccaab077cedc13bef08b771b1e4fe"}, "originalPosition": 7}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY2Njc3NDc3OnYy", "diffSide": "RIGHT", "path": "app/src/test/java/io/apicurio/registry/ConfluentClientTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMFQxNzo0MDozN1rOGYWzQw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMFQxNzo1MDozNVrOGYXKdg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODE5MjU3OQ==", "bodyText": "I would prefer to not sure wildcards for imports.", "url": "https://github.com/Apicurio/apicurio-registry/pull/506#discussion_r428192579", "createdAt": "2020-05-20T17:40:37Z", "author": {"login": "EricWittmann"}, "path": "app/src/test/java/io/apicurio/registry/ConfluentClientTest.java", "diffHunk": "@@ -16,38 +16,43 @@\n \n package io.apicurio.registry;\n \n+import io.apicurio.registry.ccompat.dto.SchemaContent;\n import io.apicurio.registry.support.HealthUtils;\n-import io.confluent.connect.avro.AvroConverter;\n+import io.apicurio.registry.support.TestCmmn;\n+import io.confluent.kafka.schemaregistry.SchemaProvider;\n+import io.confluent.kafka.schemaregistry.avro.AvroSchemaProvider;\n import io.confluent.kafka.schemaregistry.client.CachedSchemaRegistryClient;\n import io.confluent.kafka.schemaregistry.client.SchemaRegistryClient;\n+import io.confluent.kafka.schemaregistry.client.rest.RestService;\n import io.confluent.kafka.schemaregistry.client.rest.exceptions.RestClientException;\n-import io.confluent.kafka.serializers.AbstractKafkaAvroSerDeConfig;\n+import io.confluent.kafka.schemaregistry.json.JsonSchemaProvider;\n+import io.confluent.kafka.schemaregistry.protobuf.ProtobufSchemaProvider;\n import io.confluent.kafka.serializers.KafkaAvroDeserializer;\n import io.confluent.kafka.serializers.KafkaAvroSerializer;\n+import io.confluent.kafka.serializers.json.KafkaJsonSchemaDeserializer;\n+import io.confluent.kafka.serializers.json.KafkaJsonSchemaSerializer;\n+import io.confluent.kafka.serializers.json.KafkaJsonSchemaSerializerConfig;\n+import io.confluent.kafka.serializers.protobuf.KafkaProtobufDeserializer;\n+import io.confluent.kafka.serializers.protobuf.KafkaProtobufSerializer;\n+import io.confluent.kafka.serializers.protobuf.KafkaProtobufSerializerConfig;\n import io.quarkus.test.junit.QuarkusTest;\n import org.apache.avro.Schema;\n import org.apache.avro.generic.GenericData;\n-import org.apache.kafka.connect.data.SchemaAndValue;\n-import org.apache.kafka.connect.data.Struct;\n import org.junit.jupiter.api.Assertions;\n import org.junit.jupiter.api.Test;\n \n import static io.apicurio.registry.utils.tests.TestUtils.retry;\n \n-import java.nio.ByteBuffer;\n-import java.util.Collection;\n-import java.util.HashMap;\n-import java.util.List;\n-import java.util.Map;\n-import java.util.concurrent.ThreadLocalRandom;\n-import java.util.function.BiConsumer;\n-import java.util.function.Consumer;\n+import java.util.*;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "87fafda4565ccaab077cedc13bef08b771b1e4fe"}, "originalPosition": 43}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODE5ODUxOA==", "bodyText": "Automatically changed by the IDE, I'll change that.", "url": "https://github.com/Apicurio/apicurio-registry/pull/506#discussion_r428198518", "createdAt": "2020-05-20T17:50:35Z", "author": {"login": "carlesarnal"}, "path": "app/src/test/java/io/apicurio/registry/ConfluentClientTest.java", "diffHunk": "@@ -16,38 +16,43 @@\n \n package io.apicurio.registry;\n \n+import io.apicurio.registry.ccompat.dto.SchemaContent;\n import io.apicurio.registry.support.HealthUtils;\n-import io.confluent.connect.avro.AvroConverter;\n+import io.apicurio.registry.support.TestCmmn;\n+import io.confluent.kafka.schemaregistry.SchemaProvider;\n+import io.confluent.kafka.schemaregistry.avro.AvroSchemaProvider;\n import io.confluent.kafka.schemaregistry.client.CachedSchemaRegistryClient;\n import io.confluent.kafka.schemaregistry.client.SchemaRegistryClient;\n+import io.confluent.kafka.schemaregistry.client.rest.RestService;\n import io.confluent.kafka.schemaregistry.client.rest.exceptions.RestClientException;\n-import io.confluent.kafka.serializers.AbstractKafkaAvroSerDeConfig;\n+import io.confluent.kafka.schemaregistry.json.JsonSchemaProvider;\n+import io.confluent.kafka.schemaregistry.protobuf.ProtobufSchemaProvider;\n import io.confluent.kafka.serializers.KafkaAvroDeserializer;\n import io.confluent.kafka.serializers.KafkaAvroSerializer;\n+import io.confluent.kafka.serializers.json.KafkaJsonSchemaDeserializer;\n+import io.confluent.kafka.serializers.json.KafkaJsonSchemaSerializer;\n+import io.confluent.kafka.serializers.json.KafkaJsonSchemaSerializerConfig;\n+import io.confluent.kafka.serializers.protobuf.KafkaProtobufDeserializer;\n+import io.confluent.kafka.serializers.protobuf.KafkaProtobufSerializer;\n+import io.confluent.kafka.serializers.protobuf.KafkaProtobufSerializerConfig;\n import io.quarkus.test.junit.QuarkusTest;\n import org.apache.avro.Schema;\n import org.apache.avro.generic.GenericData;\n-import org.apache.kafka.connect.data.SchemaAndValue;\n-import org.apache.kafka.connect.data.Struct;\n import org.junit.jupiter.api.Assertions;\n import org.junit.jupiter.api.Test;\n \n import static io.apicurio.registry.utils.tests.TestUtils.retry;\n \n-import java.nio.ByteBuffer;\n-import java.util.Collection;\n-import java.util.HashMap;\n-import java.util.List;\n-import java.util.Map;\n-import java.util.concurrent.ThreadLocalRandom;\n-import java.util.function.BiConsumer;\n-import java.util.function.Consumer;\n+import java.util.*;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODE5MjU3OQ=="}, "originalCommit": {"oid": "87fafda4565ccaab077cedc13bef08b771b1e4fe"}, "originalPosition": 43}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY2Njc4MzM4OnYy", "diffSide": "LEFT", "path": "app/src/test/java/io/apicurio/registry/ConfluentClientTest.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMFQxNzo0MzowM1rOGYW42g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMVQxNDoyMDoyMlrOGY0p1w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODE5NDAxMA==", "bodyText": "Why is this all removed?", "url": "https://github.com/Apicurio/apicurio-registry/pull/506#discussion_r428194010", "createdAt": "2020-05-20T17:43:03Z", "author": {"login": "EricWittmann"}, "path": "app/src/test/java/io/apicurio/registry/ConfluentClientTest.java", "diffHunk": "@@ -184,81 +233,4 @@ public void testDelete() throws Exception {\n             return null;\n         });\n     }\n-\n-    @Test\n-    public void testConverter_PreRegisterSchema() {\n-        String subject = generateArtifactId();\n-        String name = \"myr\" + ThreadLocalRandom.current().nextInt(0, Integer.MAX_VALUE);\n-        testConverter(\n-            subject,\n-            name,\n-            false,\n-            (client) -> {\n-                try {\n-                    Schema schema = new Schema.Parser().parse(String.format(\"{\\\"type\\\":\\\"record\\\",\\\"name\\\":\\\"%s\\\",\\\"fields\\\":[{\\\"name\\\":\\\"bar\\\",\\\"type\\\":\\\"string\\\"}],\\\"connect.name\\\":\\\"%s\\\"}\", name, name));\n-                    int id = client.register(subject + \"-value\", schema);\n-                    client.reset();\n-                    // can be async ...\n-                    Schema retry = retry(() -> client.getById(id));\n-                    Assertions.assertNotNull(retry);\n-                } catch (Exception e) {\n-                    throw new IllegalStateException(e);\n-                }\n-            },\n-            (c, b) -> {\n-            }\n-        );\n-    }\n-\n-    @Test\n-    public void testConverter_AutoRegisterSchema() {\n-        String name = \"myr\" + ThreadLocalRandom.current().nextInt(0, Integer.MAX_VALUE);\n-        testConverter(\n-            generateArtifactId(),\n-            name,\n-            true,\n-            (c) -> {\n-            },\n-            (client, bytes) -> {\n-                try {\n-                    client.reset();\n-                    Schema retry = retry(() -> {\n-                        ByteBuffer buffer = ByteBuffer.wrap(bytes);\n-                        buffer.get(); // magic-byte\n-                        int id = buffer.getInt();\n-                        return client.getById(id);\n-                    });\n-                    Assertions.assertNotNull(retry);\n-                } catch (Exception e) {\n-                    throw new IllegalStateException(e);\n-                }\n-            }\n-        );\n-    }\n-\n-    private void testConverter(String subject, String name, boolean autoRegister, Consumer<SchemaRegistryClient> pre, BiConsumer<SchemaRegistryClient, byte[]> post) {\n-        SchemaRegistryClient client = buildClient();\n-\n-        pre.accept(client);\n-\n-        org.apache.kafka.connect.data.Schema cs =\n-            org.apache.kafka.connect.data.SchemaBuilder.struct()\n-                                                       .name(name).field(\"bar\", org.apache.kafka.connect.data.Schema.STRING_SCHEMA);\n-        Struct struct = new Struct(cs);\n-        struct.put(\"bar\", \"somebar\");\n-\n-        AvroConverter converter = new AvroConverter(client);\n-        Map<String, Object> config = new HashMap<>();\n-        config.put(AbstractKafkaAvroSerDeConfig.SCHEMA_REGISTRY_URL_CONFIG, \"dummy\");\n-        config.put(AbstractKafkaAvroSerDeConfig.AUTO_REGISTER_SCHEMAS, autoRegister);\n-        converter.configure(config, false);\n-\n-        byte[] bytes = converter.fromConnectData(subject, cs, struct);\n-\n-        post.accept(client, bytes);\n-\n-        SchemaAndValue sav = converter.toConnectData(subject, bytes);\n-        Struct ir = (Struct) sav.value();\n-        Assertions.assertEquals(\"somebar\", ir.get(\"bar\").toString());\n-    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "87fafda4565ccaab077cedc13bef08b771b1e4fe"}, "originalPosition": 197}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODE5NDQ0NQ==", "bodyText": "And the converter classes too.  Why are they all gone?", "url": "https://github.com/Apicurio/apicurio-registry/pull/506#discussion_r428194445", "createdAt": "2020-05-20T17:43:45Z", "author": {"login": "EricWittmann"}, "path": "app/src/test/java/io/apicurio/registry/ConfluentClientTest.java", "diffHunk": "@@ -184,81 +233,4 @@ public void testDelete() throws Exception {\n             return null;\n         });\n     }\n-\n-    @Test\n-    public void testConverter_PreRegisterSchema() {\n-        String subject = generateArtifactId();\n-        String name = \"myr\" + ThreadLocalRandom.current().nextInt(0, Integer.MAX_VALUE);\n-        testConverter(\n-            subject,\n-            name,\n-            false,\n-            (client) -> {\n-                try {\n-                    Schema schema = new Schema.Parser().parse(String.format(\"{\\\"type\\\":\\\"record\\\",\\\"name\\\":\\\"%s\\\",\\\"fields\\\":[{\\\"name\\\":\\\"bar\\\",\\\"type\\\":\\\"string\\\"}],\\\"connect.name\\\":\\\"%s\\\"}\", name, name));\n-                    int id = client.register(subject + \"-value\", schema);\n-                    client.reset();\n-                    // can be async ...\n-                    Schema retry = retry(() -> client.getById(id));\n-                    Assertions.assertNotNull(retry);\n-                } catch (Exception e) {\n-                    throw new IllegalStateException(e);\n-                }\n-            },\n-            (c, b) -> {\n-            }\n-        );\n-    }\n-\n-    @Test\n-    public void testConverter_AutoRegisterSchema() {\n-        String name = \"myr\" + ThreadLocalRandom.current().nextInt(0, Integer.MAX_VALUE);\n-        testConverter(\n-            generateArtifactId(),\n-            name,\n-            true,\n-            (c) -> {\n-            },\n-            (client, bytes) -> {\n-                try {\n-                    client.reset();\n-                    Schema retry = retry(() -> {\n-                        ByteBuffer buffer = ByteBuffer.wrap(bytes);\n-                        buffer.get(); // magic-byte\n-                        int id = buffer.getInt();\n-                        return client.getById(id);\n-                    });\n-                    Assertions.assertNotNull(retry);\n-                } catch (Exception e) {\n-                    throw new IllegalStateException(e);\n-                }\n-            }\n-        );\n-    }\n-\n-    private void testConverter(String subject, String name, boolean autoRegister, Consumer<SchemaRegistryClient> pre, BiConsumer<SchemaRegistryClient, byte[]> post) {\n-        SchemaRegistryClient client = buildClient();\n-\n-        pre.accept(client);\n-\n-        org.apache.kafka.connect.data.Schema cs =\n-            org.apache.kafka.connect.data.SchemaBuilder.struct()\n-                                                       .name(name).field(\"bar\", org.apache.kafka.connect.data.Schema.STRING_SCHEMA);\n-        Struct struct = new Struct(cs);\n-        struct.put(\"bar\", \"somebar\");\n-\n-        AvroConverter converter = new AvroConverter(client);\n-        Map<String, Object> config = new HashMap<>();\n-        config.put(AbstractKafkaAvroSerDeConfig.SCHEMA_REGISTRY_URL_CONFIG, \"dummy\");\n-        config.put(AbstractKafkaAvroSerDeConfig.AUTO_REGISTER_SCHEMAS, autoRegister);\n-        converter.configure(config, false);\n-\n-        byte[] bytes = converter.fromConnectData(subject, cs, struct);\n-\n-        post.accept(client, bytes);\n-\n-        SchemaAndValue sav = converter.toConnectData(subject, bytes);\n-        Struct ir = (Struct) sav.value();\n-        Assertions.assertEquals(\"somebar\", ir.get(\"bar\").toString());\n-    }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODE5NDAxMA=="}, "originalCommit": {"oid": "87fafda4565ccaab077cedc13bef08b771b1e4fe"}, "originalPosition": 197}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODIwMjcyMg==", "bodyText": "The converter has a comment from @alesj indicating that can be removed once confluent changes Avro version from 1.8.x to 1.9.x and that's what happened in the version 5.5.0.", "url": "https://github.com/Apicurio/apicurio-registry/pull/506#discussion_r428202722", "createdAt": "2020-05-20T17:57:34Z", "author": {"login": "carlesarnal"}, "path": "app/src/test/java/io/apicurio/registry/ConfluentClientTest.java", "diffHunk": "@@ -184,81 +233,4 @@ public void testDelete() throws Exception {\n             return null;\n         });\n     }\n-\n-    @Test\n-    public void testConverter_PreRegisterSchema() {\n-        String subject = generateArtifactId();\n-        String name = \"myr\" + ThreadLocalRandom.current().nextInt(0, Integer.MAX_VALUE);\n-        testConverter(\n-            subject,\n-            name,\n-            false,\n-            (client) -> {\n-                try {\n-                    Schema schema = new Schema.Parser().parse(String.format(\"{\\\"type\\\":\\\"record\\\",\\\"name\\\":\\\"%s\\\",\\\"fields\\\":[{\\\"name\\\":\\\"bar\\\",\\\"type\\\":\\\"string\\\"}],\\\"connect.name\\\":\\\"%s\\\"}\", name, name));\n-                    int id = client.register(subject + \"-value\", schema);\n-                    client.reset();\n-                    // can be async ...\n-                    Schema retry = retry(() -> client.getById(id));\n-                    Assertions.assertNotNull(retry);\n-                } catch (Exception e) {\n-                    throw new IllegalStateException(e);\n-                }\n-            },\n-            (c, b) -> {\n-            }\n-        );\n-    }\n-\n-    @Test\n-    public void testConverter_AutoRegisterSchema() {\n-        String name = \"myr\" + ThreadLocalRandom.current().nextInt(0, Integer.MAX_VALUE);\n-        testConverter(\n-            generateArtifactId(),\n-            name,\n-            true,\n-            (c) -> {\n-            },\n-            (client, bytes) -> {\n-                try {\n-                    client.reset();\n-                    Schema retry = retry(() -> {\n-                        ByteBuffer buffer = ByteBuffer.wrap(bytes);\n-                        buffer.get(); // magic-byte\n-                        int id = buffer.getInt();\n-                        return client.getById(id);\n-                    });\n-                    Assertions.assertNotNull(retry);\n-                } catch (Exception e) {\n-                    throw new IllegalStateException(e);\n-                }\n-            }\n-        );\n-    }\n-\n-    private void testConverter(String subject, String name, boolean autoRegister, Consumer<SchemaRegistryClient> pre, BiConsumer<SchemaRegistryClient, byte[]> post) {\n-        SchemaRegistryClient client = buildClient();\n-\n-        pre.accept(client);\n-\n-        org.apache.kafka.connect.data.Schema cs =\n-            org.apache.kafka.connect.data.SchemaBuilder.struct()\n-                                                       .name(name).field(\"bar\", org.apache.kafka.connect.data.Schema.STRING_SCHEMA);\n-        Struct struct = new Struct(cs);\n-        struct.put(\"bar\", \"somebar\");\n-\n-        AvroConverter converter = new AvroConverter(client);\n-        Map<String, Object> config = new HashMap<>();\n-        config.put(AbstractKafkaAvroSerDeConfig.SCHEMA_REGISTRY_URL_CONFIG, \"dummy\");\n-        config.put(AbstractKafkaAvroSerDeConfig.AUTO_REGISTER_SCHEMAS, autoRegister);\n-        converter.configure(config, false);\n-\n-        byte[] bytes = converter.fromConnectData(subject, cs, struct);\n-\n-        post.accept(client, bytes);\n-\n-        SchemaAndValue sav = converter.toConnectData(subject, bytes);\n-        Struct ir = (Struct) sav.value();\n-        Assertions.assertEquals(\"somebar\", ir.get(\"bar\").toString());\n-    }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODE5NDAxMA=="}, "originalCommit": {"oid": "87fafda4565ccaab077cedc13bef08b771b1e4fe"}, "originalPosition": 197}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODY4MTY4Nw==", "bodyText": "OK great, thanks.", "url": "https://github.com/Apicurio/apicurio-registry/pull/506#discussion_r428681687", "createdAt": "2020-05-21T14:20:22Z", "author": {"login": "EricWittmann"}, "path": "app/src/test/java/io/apicurio/registry/ConfluentClientTest.java", "diffHunk": "@@ -184,81 +233,4 @@ public void testDelete() throws Exception {\n             return null;\n         });\n     }\n-\n-    @Test\n-    public void testConverter_PreRegisterSchema() {\n-        String subject = generateArtifactId();\n-        String name = \"myr\" + ThreadLocalRandom.current().nextInt(0, Integer.MAX_VALUE);\n-        testConverter(\n-            subject,\n-            name,\n-            false,\n-            (client) -> {\n-                try {\n-                    Schema schema = new Schema.Parser().parse(String.format(\"{\\\"type\\\":\\\"record\\\",\\\"name\\\":\\\"%s\\\",\\\"fields\\\":[{\\\"name\\\":\\\"bar\\\",\\\"type\\\":\\\"string\\\"}],\\\"connect.name\\\":\\\"%s\\\"}\", name, name));\n-                    int id = client.register(subject + \"-value\", schema);\n-                    client.reset();\n-                    // can be async ...\n-                    Schema retry = retry(() -> client.getById(id));\n-                    Assertions.assertNotNull(retry);\n-                } catch (Exception e) {\n-                    throw new IllegalStateException(e);\n-                }\n-            },\n-            (c, b) -> {\n-            }\n-        );\n-    }\n-\n-    @Test\n-    public void testConverter_AutoRegisterSchema() {\n-        String name = \"myr\" + ThreadLocalRandom.current().nextInt(0, Integer.MAX_VALUE);\n-        testConverter(\n-            generateArtifactId(),\n-            name,\n-            true,\n-            (c) -> {\n-            },\n-            (client, bytes) -> {\n-                try {\n-                    client.reset();\n-                    Schema retry = retry(() -> {\n-                        ByteBuffer buffer = ByteBuffer.wrap(bytes);\n-                        buffer.get(); // magic-byte\n-                        int id = buffer.getInt();\n-                        return client.getById(id);\n-                    });\n-                    Assertions.assertNotNull(retry);\n-                } catch (Exception e) {\n-                    throw new IllegalStateException(e);\n-                }\n-            }\n-        );\n-    }\n-\n-    private void testConverter(String subject, String name, boolean autoRegister, Consumer<SchemaRegistryClient> pre, BiConsumer<SchemaRegistryClient, byte[]> post) {\n-        SchemaRegistryClient client = buildClient();\n-\n-        pre.accept(client);\n-\n-        org.apache.kafka.connect.data.Schema cs =\n-            org.apache.kafka.connect.data.SchemaBuilder.struct()\n-                                                       .name(name).field(\"bar\", org.apache.kafka.connect.data.Schema.STRING_SCHEMA);\n-        Struct struct = new Struct(cs);\n-        struct.put(\"bar\", \"somebar\");\n-\n-        AvroConverter converter = new AvroConverter(client);\n-        Map<String, Object> config = new HashMap<>();\n-        config.put(AbstractKafkaAvroSerDeConfig.SCHEMA_REGISTRY_URL_CONFIG, \"dummy\");\n-        config.put(AbstractKafkaAvroSerDeConfig.AUTO_REGISTER_SCHEMAS, autoRegister);\n-        converter.configure(config, false);\n-\n-        byte[] bytes = converter.fromConnectData(subject, cs, struct);\n-\n-        post.accept(client, bytes);\n-\n-        SchemaAndValue sav = converter.toConnectData(subject, bytes);\n-        Struct ir = (Struct) sav.value();\n-        Assertions.assertEquals(\"somebar\", ir.get(\"bar\").toString());\n-    }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODE5NDAxMA=="}, "originalCommit": {"oid": "87fafda4565ccaab077cedc13bef08b771b1e4fe"}, "originalPosition": 197}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3350, "cost": 1, "resetAt": "2021-11-12T09:44:50Z"}}}