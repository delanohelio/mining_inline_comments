{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTMyODA1ODAx", "number": 8099, "reviewThreads": {"totalCount": 18, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOFQxNjozNjozMVrOFCdRbg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMVQxNzozMDowOFrOFEFuBA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM4MTIxMDcwOnYy", "diffSide": "RIGHT", "path": "core/src/main/java/org/mskcc/cbio/portal/util/RequestBodyGZipFilter.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOFQxNjozNjozMVrOIBoGUA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOFQxNjozNjozMVrOIBoGUA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODU3NjQ2NA==", "bodyText": "CountingInputStream is marked as beta, but it works well, and I haven't found a more mature solution. Open to suggestions here.", "url": "https://github.com/cBioPortal/cbioportal/pull/8099#discussion_r538576464", "createdAt": "2020-12-08T16:36:31Z", "author": {"login": "Luke-Sikina"}, "path": "core/src/main/java/org/mskcc/cbio/portal/util/RequestBodyGZipFilter.java", "diffHunk": "@@ -0,0 +1,123 @@\n+package org.mskcc.cbio.portal.util;\n+\n+import com.google.common.io.CountingInputStream;\n+import com.google.common.net.HttpHeaders;\n+import org.springframework.beans.factory.annotation.Value;\n+import org.springframework.stereotype.Component;\n+\n+import javax.servlet.*;\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletRequestWrapper;\n+import javax.servlet.http.HttpServletResponse;\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.util.zip.GZIPInputStream;\n+\n+@Component(\"requestBodyGZipFilter\")\n+public class RequestBodyGZipFilter implements Filter {\n+    /**\n+     * We need to limit the size of the gzipped request bodies to avoid denial of memory attacks.\n+     * Because gzip can achieve text compression rates of around 1000x, without a common sense limit for\n+     * request body size, it would be very easy to send a request body that, when inflated, consumes the\n+     * entirety of a server's memory.\n+     */\n+    @Value(\"${request_gzip_body_size_bytes:50000000}\")\n+    private int maxInflatedRequestBodySize;\n+    \n+    @Value(\"${enable_request_body_compression:false}\")\n+    private boolean enabled;\n+\n+    @Override\n+    public void init(FilterConfig filterConfig) throws ServletException {\n+        // Nothing to init (Sonar asks you to comment if you leave a method empty)\n+    }\n+\n+    /**\n+     * Analyzes servlet request for possible gzipped body.\n+     * When Content-Encoding header has \"gzip\" value and request method is POST we read all the\n+     * gzipped stream and is it haz any data unzip it. In case when gzip Content-Encoding header\n+     * specified but body is not actually in gzip format we will throw ZipException.\n+     *\n+     * @param servletRequest  servlet request\n+     * @param servletResponse servlet response\n+     * @param chain           filter chain\n+     * @throws IOException      throws when fails\n+     * @throws ServletException thrown when fails\n+     */\n+    @Override\n+    public final void doFilter(\n+        final ServletRequest servletRequest,\n+        final ServletResponse servletResponse,\n+        final FilterChain chain\n+    ) throws IOException, ServletException {\n+        HttpServletRequest request = (HttpServletRequest) servletRequest;\n+        HttpServletResponse response = (HttpServletResponse) servletResponse;\n+        boolean isGzipped = request.getHeader(HttpHeaders.CONTENT_ENCODING) != null\n+            && request.getHeader(HttpHeaders.CONTENT_ENCODING).contains(\"gzip\");\n+        boolean requestTypeSupported = \"POST\".equals(request.getMethod());\n+\n+        if (isGzipped) {\n+            if (!enabled) {\n+                throw new IllegalStateException(\n+                    \"Received gzipped request body, but enable_request_body_compression is not set or is false\"\n+                );\n+            }\n+            if (!requestTypeSupported) {\n+                throw new IllegalStateException(\n+                    \"Received request with a Content-Encoding: gzip header and a request method of: \" +\n+                    request.getMethod()\n+                    + \" Only POST requests are supported.\"\n+                );\n+            }\n+\n+            request = new GzippedInputStreamWrapper((HttpServletRequest) servletRequest, maxInflatedRequestBodySize);\n+        }\n+\n+        chain.doFilter(request, response);\n+    }\n+    \n+    @Override\n+    public final void destroy() {\n+        // Nothing to destroy (Sonar asks you to comment if you leave a method empty)\n+    }\n+\n+    static class GzippedInputStreamWrapper extends HttpServletRequestWrapper {\n+        private final int maxInflatedRequestBodySize;\n+        private final CountingInputStream inputStream;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9336b4cd7903af2e634b638f152f78f277cee580"}, "originalPosition": 87}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM4MTIyMjM4OnYy", "diffSide": "RIGHT", "path": "core/src/test/java/org/mskcc/cbio/portal/util/TestRequestBodyGZipFilter.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOFQxNjozODoxNlrOIBoN3g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMVQxODozODo0NVrOIEFKig==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODU3ODM5OA==", "bodyText": "Interested if anyone has an idea on how to do this better.", "url": "https://github.com/cBioPortal/cbioportal/pull/8099#discussion_r538578398", "createdAt": "2020-12-08T16:38:16Z", "author": {"login": "Luke-Sikina"}, "path": "core/src/test/java/org/mskcc/cbio/portal/util/TestRequestBodyGZipFilter.java", "diffHunk": "@@ -0,0 +1,174 @@\n+package org.mskcc.cbio.portal.util;\n+\n+import com.google.common.net.HttpHeaders;\n+import org.junit.Assert;\n+import org.junit.Test;\n+import org.mockito.ArgumentCaptor;\n+import org.mockito.Mockito;\n+import org.springframework.test.util.ReflectionTestUtils;\n+\n+import javax.servlet.FilterChain;\n+import javax.servlet.ServletInputStream;\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+import java.io.FileInputStream;\n+import java.io.IOException;\n+import java.io.UncheckedIOException;\n+import java.util.stream.Collectors;\n+\n+public class TestRequestBodyGZipFilter {\n+\n+    /**\n+     * When I filter a request that doesn't have the gzip header,\n+     * the request should not be wrapped, and chain.doFilter should\n+     * be called on the same request object passed to the method.\n+     */\n+    @Test\n+    public void testDoFilterEnabledNotGZipped() throws Exception {\n+        RequestBodyGZipFilter subject = createRequestBodyGZipFilter(true, 50000000);\n+\n+        HttpServletRequest request = createHttpServletRequest(null, \"POST\");\n+        HttpServletResponse response = Mockito.mock(HttpServletResponse.class);\n+        FilterChain chain = Mockito.mock(FilterChain.class);\n+\n+        subject.doFilter(request, response, chain);\n+        \n+        // request should not be wrapped\n+        Mockito.verify(chain, Mockito.times(1)).doFilter(request, response);\n+    }\n+\n+    /**\n+     * When I filter a request that has the gzip header, but the gzip\n+     * feature is disabled, the doFilter method should throw an exception.\n+     */\n+    @Test(expected = IllegalStateException.class)\n+    public void testDoFilterDisabledGZipped() throws Exception {\n+        RequestBodyGZipFilter subject = createRequestBodyGZipFilter(false, 50000000);\n+\n+        HttpServletRequest request = createHttpServletRequest(\"gzip\", \"POST\");\n+        HttpServletResponse response = Mockito.mock(HttpServletResponse.class);\n+        FilterChain chain = Mockito.mock(FilterChain.class);\n+\n+        subject.doFilter(request, response, chain);\n+    }\n+\n+    /**\n+     * When I filter a request that has the gzip header and the gzip\n+     * feature is enabled, but the method is something other than POST,\n+     * the doFilter method should throw an exception.\n+     */\n+    @Test(expected = IllegalStateException.class)\n+    public void testDoFilterEnabledGZippedBadMethod() throws Exception {\n+        RequestBodyGZipFilter subject = createRequestBodyGZipFilter(true, 50000000);\n+\n+        HttpServletRequest request = createHttpServletRequest(\"gzip\", \"GET\");\n+        HttpServletResponse response = Mockito.mock(HttpServletResponse.class);\n+        FilterChain chain = Mockito.mock(FilterChain.class);\n+\n+        subject.doFilter(request, response, chain);\n+    }\n+\n+    /**\n+     * When I filter a request that has the gzip header and the gzip\n+     * feature is enabled and the method is POST, the doFilter method\n+     * should wrap the request with a GzippedInputStreamWrapper.\n+     * The BufferedReader for this GzippedInputStreamWrapper should return\n+     * the contents of the gzipped file used to create the original input stream.\n+     */\n+    @Test\n+    public void testDoFilterEnabledGZipped() throws Exception {\n+        RequestBodyGZipFilter subject = createRequestBodyGZipFilter(true, 50000000);\n+\n+        // Not thrilled to be using the file system, but this was the most readable way to do this\n+        // that I could think of.\n+        // gzip_filter.json.gz is a gzip of a json file that contains the following: {\"field\":\"value\"}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9336b4cd7903af2e634b638f152f78f277cee580"}, "originalPosition": 84}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTA5ODI4NA==", "bodyText": "The total file size is 55 bytes .. perhaps it is reasonable to encode it directly as a byte array in code using escaped byte literals? The file is not human readable in any case (although I guess as a file it can be unzipped at the command line to \"look inside\" .. but the comment above handles that in the code.", "url": "https://github.com/cBioPortal/cbioportal/pull/8099#discussion_r541098284", "createdAt": "2020-12-11T17:11:38Z", "author": {"login": "sheridancbio"}, "path": "core/src/test/java/org/mskcc/cbio/portal/util/TestRequestBodyGZipFilter.java", "diffHunk": "@@ -0,0 +1,174 @@\n+package org.mskcc.cbio.portal.util;\n+\n+import com.google.common.net.HttpHeaders;\n+import org.junit.Assert;\n+import org.junit.Test;\n+import org.mockito.ArgumentCaptor;\n+import org.mockito.Mockito;\n+import org.springframework.test.util.ReflectionTestUtils;\n+\n+import javax.servlet.FilterChain;\n+import javax.servlet.ServletInputStream;\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+import java.io.FileInputStream;\n+import java.io.IOException;\n+import java.io.UncheckedIOException;\n+import java.util.stream.Collectors;\n+\n+public class TestRequestBodyGZipFilter {\n+\n+    /**\n+     * When I filter a request that doesn't have the gzip header,\n+     * the request should not be wrapped, and chain.doFilter should\n+     * be called on the same request object passed to the method.\n+     */\n+    @Test\n+    public void testDoFilterEnabledNotGZipped() throws Exception {\n+        RequestBodyGZipFilter subject = createRequestBodyGZipFilter(true, 50000000);\n+\n+        HttpServletRequest request = createHttpServletRequest(null, \"POST\");\n+        HttpServletResponse response = Mockito.mock(HttpServletResponse.class);\n+        FilterChain chain = Mockito.mock(FilterChain.class);\n+\n+        subject.doFilter(request, response, chain);\n+        \n+        // request should not be wrapped\n+        Mockito.verify(chain, Mockito.times(1)).doFilter(request, response);\n+    }\n+\n+    /**\n+     * When I filter a request that has the gzip header, but the gzip\n+     * feature is disabled, the doFilter method should throw an exception.\n+     */\n+    @Test(expected = IllegalStateException.class)\n+    public void testDoFilterDisabledGZipped() throws Exception {\n+        RequestBodyGZipFilter subject = createRequestBodyGZipFilter(false, 50000000);\n+\n+        HttpServletRequest request = createHttpServletRequest(\"gzip\", \"POST\");\n+        HttpServletResponse response = Mockito.mock(HttpServletResponse.class);\n+        FilterChain chain = Mockito.mock(FilterChain.class);\n+\n+        subject.doFilter(request, response, chain);\n+    }\n+\n+    /**\n+     * When I filter a request that has the gzip header and the gzip\n+     * feature is enabled, but the method is something other than POST,\n+     * the doFilter method should throw an exception.\n+     */\n+    @Test(expected = IllegalStateException.class)\n+    public void testDoFilterEnabledGZippedBadMethod() throws Exception {\n+        RequestBodyGZipFilter subject = createRequestBodyGZipFilter(true, 50000000);\n+\n+        HttpServletRequest request = createHttpServletRequest(\"gzip\", \"GET\");\n+        HttpServletResponse response = Mockito.mock(HttpServletResponse.class);\n+        FilterChain chain = Mockito.mock(FilterChain.class);\n+\n+        subject.doFilter(request, response, chain);\n+    }\n+\n+    /**\n+     * When I filter a request that has the gzip header and the gzip\n+     * feature is enabled and the method is POST, the doFilter method\n+     * should wrap the request with a GzippedInputStreamWrapper.\n+     * The BufferedReader for this GzippedInputStreamWrapper should return\n+     * the contents of the gzipped file used to create the original input stream.\n+     */\n+    @Test\n+    public void testDoFilterEnabledGZipped() throws Exception {\n+        RequestBodyGZipFilter subject = createRequestBodyGZipFilter(true, 50000000);\n+\n+        // Not thrilled to be using the file system, but this was the most readable way to do this\n+        // that I could think of.\n+        // gzip_filter.json.gz is a gzip of a json file that contains the following: {\"field\":\"value\"}", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODU3ODM5OA=="}, "originalCommit": {"oid": "9336b4cd7903af2e634b638f152f78f277cee580"}, "originalPosition": 84}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTE0OTgzNA==", "bodyText": "I like it. Thanks for the suggestion.", "url": "https://github.com/cBioPortal/cbioportal/pull/8099#discussion_r541149834", "createdAt": "2020-12-11T18:38:45Z", "author": {"login": "Luke-Sikina"}, "path": "core/src/test/java/org/mskcc/cbio/portal/util/TestRequestBodyGZipFilter.java", "diffHunk": "@@ -0,0 +1,174 @@\n+package org.mskcc.cbio.portal.util;\n+\n+import com.google.common.net.HttpHeaders;\n+import org.junit.Assert;\n+import org.junit.Test;\n+import org.mockito.ArgumentCaptor;\n+import org.mockito.Mockito;\n+import org.springframework.test.util.ReflectionTestUtils;\n+\n+import javax.servlet.FilterChain;\n+import javax.servlet.ServletInputStream;\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+import java.io.FileInputStream;\n+import java.io.IOException;\n+import java.io.UncheckedIOException;\n+import java.util.stream.Collectors;\n+\n+public class TestRequestBodyGZipFilter {\n+\n+    /**\n+     * When I filter a request that doesn't have the gzip header,\n+     * the request should not be wrapped, and chain.doFilter should\n+     * be called on the same request object passed to the method.\n+     */\n+    @Test\n+    public void testDoFilterEnabledNotGZipped() throws Exception {\n+        RequestBodyGZipFilter subject = createRequestBodyGZipFilter(true, 50000000);\n+\n+        HttpServletRequest request = createHttpServletRequest(null, \"POST\");\n+        HttpServletResponse response = Mockito.mock(HttpServletResponse.class);\n+        FilterChain chain = Mockito.mock(FilterChain.class);\n+\n+        subject.doFilter(request, response, chain);\n+        \n+        // request should not be wrapped\n+        Mockito.verify(chain, Mockito.times(1)).doFilter(request, response);\n+    }\n+\n+    /**\n+     * When I filter a request that has the gzip header, but the gzip\n+     * feature is disabled, the doFilter method should throw an exception.\n+     */\n+    @Test(expected = IllegalStateException.class)\n+    public void testDoFilterDisabledGZipped() throws Exception {\n+        RequestBodyGZipFilter subject = createRequestBodyGZipFilter(false, 50000000);\n+\n+        HttpServletRequest request = createHttpServletRequest(\"gzip\", \"POST\");\n+        HttpServletResponse response = Mockito.mock(HttpServletResponse.class);\n+        FilterChain chain = Mockito.mock(FilterChain.class);\n+\n+        subject.doFilter(request, response, chain);\n+    }\n+\n+    /**\n+     * When I filter a request that has the gzip header and the gzip\n+     * feature is enabled, but the method is something other than POST,\n+     * the doFilter method should throw an exception.\n+     */\n+    @Test(expected = IllegalStateException.class)\n+    public void testDoFilterEnabledGZippedBadMethod() throws Exception {\n+        RequestBodyGZipFilter subject = createRequestBodyGZipFilter(true, 50000000);\n+\n+        HttpServletRequest request = createHttpServletRequest(\"gzip\", \"GET\");\n+        HttpServletResponse response = Mockito.mock(HttpServletResponse.class);\n+        FilterChain chain = Mockito.mock(FilterChain.class);\n+\n+        subject.doFilter(request, response, chain);\n+    }\n+\n+    /**\n+     * When I filter a request that has the gzip header and the gzip\n+     * feature is enabled and the method is POST, the doFilter method\n+     * should wrap the request with a GzippedInputStreamWrapper.\n+     * The BufferedReader for this GzippedInputStreamWrapper should return\n+     * the contents of the gzipped file used to create the original input stream.\n+     */\n+    @Test\n+    public void testDoFilterEnabledGZipped() throws Exception {\n+        RequestBodyGZipFilter subject = createRequestBodyGZipFilter(true, 50000000);\n+\n+        // Not thrilled to be using the file system, but this was the most readable way to do this\n+        // that I could think of.\n+        // gzip_filter.json.gz is a gzip of a json file that contains the following: {\"field\":\"value\"}", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODU3ODM5OA=="}, "originalCommit": {"oid": "9336b4cd7903af2e634b638f152f78f277cee580"}, "originalPosition": 84}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM5ODAyNjQ4OnYy", "diffSide": "RIGHT", "path": "core/src/main/java/org/mskcc/cbio/portal/util/RequestBodyGZipFilter.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMVQxNjoyMTo1MFrOID__zA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMVQxNjoyMTo1MFrOID__zA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTA2NTE2NA==", "bodyText": "\"and is it haz\" ... typos maybe?", "url": "https://github.com/cBioPortal/cbioportal/pull/8099#discussion_r541065164", "createdAt": "2020-12-11T16:21:50Z", "author": {"login": "sheridancbio"}, "path": "core/src/main/java/org/mskcc/cbio/portal/util/RequestBodyGZipFilter.java", "diffHunk": "@@ -0,0 +1,123 @@\n+package org.mskcc.cbio.portal.util;\n+\n+import com.google.common.io.CountingInputStream;\n+import com.google.common.net.HttpHeaders;\n+import org.springframework.beans.factory.annotation.Value;\n+import org.springframework.stereotype.Component;\n+\n+import javax.servlet.*;\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletRequestWrapper;\n+import javax.servlet.http.HttpServletResponse;\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.util.zip.GZIPInputStream;\n+\n+@Component(\"requestBodyGZipFilter\")\n+public class RequestBodyGZipFilter implements Filter {\n+    /**\n+     * We need to limit the size of the gzipped request bodies to avoid denial of memory attacks.\n+     * Because gzip can achieve text compression rates of around 1000x, without a common sense limit for\n+     * request body size, it would be very easy to send a request body that, when inflated, consumes the\n+     * entirety of a server's memory.\n+     */\n+    @Value(\"${request_gzip_body_size_bytes:50000000}\")\n+    private int maxInflatedRequestBodySize;\n+    \n+    @Value(\"${enable_request_body_compression:false}\")\n+    private boolean enabled;\n+\n+    @Override\n+    public void init(FilterConfig filterConfig) throws ServletException {\n+        // Nothing to init (Sonar asks you to comment if you leave a method empty)\n+    }\n+\n+    /**\n+     * Analyzes servlet request for possible gzipped body.\n+     * When Content-Encoding header has \"gzip\" value and request method is POST we read all the\n+     * gzipped stream and is it haz any data unzip it. In case when gzip Content-Encoding header", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9336b4cd7903af2e634b638f152f78f277cee580"}, "originalPosition": 39}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM5ODA3NjQ2OnYy", "diffSide": "RIGHT", "path": "core/src/main/java/org/mskcc/cbio/portal/util/RequestBodyGZipFilter.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMVQxNjozMjo0M1rOIEAdKQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMVQxNjozMjo0M1rOIEAdKQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTA3MjY4MQ==", "bodyText": "what do you think about moving this class outside to a new standalone class (same package)? At least the declarations in the testing class could be simplified? (no important really)", "url": "https://github.com/cBioPortal/cbioportal/pull/8099#discussion_r541072681", "createdAt": "2020-12-11T16:32:43Z", "author": {"login": "sheridancbio"}, "path": "core/src/main/java/org/mskcc/cbio/portal/util/RequestBodyGZipFilter.java", "diffHunk": "@@ -0,0 +1,123 @@\n+package org.mskcc.cbio.portal.util;\n+\n+import com.google.common.io.CountingInputStream;\n+import com.google.common.net.HttpHeaders;\n+import org.springframework.beans.factory.annotation.Value;\n+import org.springframework.stereotype.Component;\n+\n+import javax.servlet.*;\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletRequestWrapper;\n+import javax.servlet.http.HttpServletResponse;\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.util.zip.GZIPInputStream;\n+\n+@Component(\"requestBodyGZipFilter\")\n+public class RequestBodyGZipFilter implements Filter {\n+    /**\n+     * We need to limit the size of the gzipped request bodies to avoid denial of memory attacks.\n+     * Because gzip can achieve text compression rates of around 1000x, without a common sense limit for\n+     * request body size, it would be very easy to send a request body that, when inflated, consumes the\n+     * entirety of a server's memory.\n+     */\n+    @Value(\"${request_gzip_body_size_bytes:50000000}\")\n+    private int maxInflatedRequestBodySize;\n+    \n+    @Value(\"${enable_request_body_compression:false}\")\n+    private boolean enabled;\n+\n+    @Override\n+    public void init(FilterConfig filterConfig) throws ServletException {\n+        // Nothing to init (Sonar asks you to comment if you leave a method empty)\n+    }\n+\n+    /**\n+     * Analyzes servlet request for possible gzipped body.\n+     * When Content-Encoding header has \"gzip\" value and request method is POST we read all the\n+     * gzipped stream and is it haz any data unzip it. In case when gzip Content-Encoding header\n+     * specified but body is not actually in gzip format we will throw ZipException.\n+     *\n+     * @param servletRequest  servlet request\n+     * @param servletResponse servlet response\n+     * @param chain           filter chain\n+     * @throws IOException      throws when fails\n+     * @throws ServletException thrown when fails\n+     */\n+    @Override\n+    public final void doFilter(\n+        final ServletRequest servletRequest,\n+        final ServletResponse servletResponse,\n+        final FilterChain chain\n+    ) throws IOException, ServletException {\n+        HttpServletRequest request = (HttpServletRequest) servletRequest;\n+        HttpServletResponse response = (HttpServletResponse) servletResponse;\n+        boolean isGzipped = request.getHeader(HttpHeaders.CONTENT_ENCODING) != null\n+            && request.getHeader(HttpHeaders.CONTENT_ENCODING).contains(\"gzip\");\n+        boolean requestTypeSupported = \"POST\".equals(request.getMethod());\n+\n+        if (isGzipped) {\n+            if (!enabled) {\n+                throw new IllegalStateException(\n+                    \"Received gzipped request body, but enable_request_body_compression is not set or is false\"\n+                );\n+            }\n+            if (!requestTypeSupported) {\n+                throw new IllegalStateException(\n+                    \"Received request with a Content-Encoding: gzip header and a request method of: \" +\n+                    request.getMethod()\n+                    + \" Only POST requests are supported.\"\n+                );\n+            }\n+\n+            request = new GzippedInputStreamWrapper((HttpServletRequest) servletRequest, maxInflatedRequestBodySize);\n+        }\n+\n+        chain.doFilter(request, response);\n+    }\n+    \n+    @Override\n+    public final void destroy() {\n+        // Nothing to destroy (Sonar asks you to comment if you leave a method empty)\n+    }\n+\n+    static class GzippedInputStreamWrapper extends HttpServletRequestWrapper {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9336b4cd7903af2e634b638f152f78f277cee580"}, "originalPosition": 85}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM5ODEwMDUxOnYy", "diffSide": "RIGHT", "path": "core/src/main/java/org/mskcc/cbio/portal/util/RequestBodyGZipFilter.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMVQxNjozNzo0NlrOIEAqwQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMVQxNjozNzo0NlrOIEAqwQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTA3NjE2MQ==", "bodyText": "just wondering why the close() method below is @OverRide annotated, but not this read() method", "url": "https://github.com/cBioPortal/cbioportal/pull/8099#discussion_r541076161", "createdAt": "2020-12-11T16:37:46Z", "author": {"login": "sheridancbio"}, "path": "core/src/main/java/org/mskcc/cbio/portal/util/RequestBodyGZipFilter.java", "diffHunk": "@@ -0,0 +1,123 @@\n+package org.mskcc.cbio.portal.util;\n+\n+import com.google.common.io.CountingInputStream;\n+import com.google.common.net.HttpHeaders;\n+import org.springframework.beans.factory.annotation.Value;\n+import org.springframework.stereotype.Component;\n+\n+import javax.servlet.*;\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletRequestWrapper;\n+import javax.servlet.http.HttpServletResponse;\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.util.zip.GZIPInputStream;\n+\n+@Component(\"requestBodyGZipFilter\")\n+public class RequestBodyGZipFilter implements Filter {\n+    /**\n+     * We need to limit the size of the gzipped request bodies to avoid denial of memory attacks.\n+     * Because gzip can achieve text compression rates of around 1000x, without a common sense limit for\n+     * request body size, it would be very easy to send a request body that, when inflated, consumes the\n+     * entirety of a server's memory.\n+     */\n+    @Value(\"${request_gzip_body_size_bytes:50000000}\")\n+    private int maxInflatedRequestBodySize;\n+    \n+    @Value(\"${enable_request_body_compression:false}\")\n+    private boolean enabled;\n+\n+    @Override\n+    public void init(FilterConfig filterConfig) throws ServletException {\n+        // Nothing to init (Sonar asks you to comment if you leave a method empty)\n+    }\n+\n+    /**\n+     * Analyzes servlet request for possible gzipped body.\n+     * When Content-Encoding header has \"gzip\" value and request method is POST we read all the\n+     * gzipped stream and is it haz any data unzip it. In case when gzip Content-Encoding header\n+     * specified but body is not actually in gzip format we will throw ZipException.\n+     *\n+     * @param servletRequest  servlet request\n+     * @param servletResponse servlet response\n+     * @param chain           filter chain\n+     * @throws IOException      throws when fails\n+     * @throws ServletException thrown when fails\n+     */\n+    @Override\n+    public final void doFilter(\n+        final ServletRequest servletRequest,\n+        final ServletResponse servletResponse,\n+        final FilterChain chain\n+    ) throws IOException, ServletException {\n+        HttpServletRequest request = (HttpServletRequest) servletRequest;\n+        HttpServletResponse response = (HttpServletResponse) servletResponse;\n+        boolean isGzipped = request.getHeader(HttpHeaders.CONTENT_ENCODING) != null\n+            && request.getHeader(HttpHeaders.CONTENT_ENCODING).contains(\"gzip\");\n+        boolean requestTypeSupported = \"POST\".equals(request.getMethod());\n+\n+        if (isGzipped) {\n+            if (!enabled) {\n+                throw new IllegalStateException(\n+                    \"Received gzipped request body, but enable_request_body_compression is not set or is false\"\n+                );\n+            }\n+            if (!requestTypeSupported) {\n+                throw new IllegalStateException(\n+                    \"Received request with a Content-Encoding: gzip header and a request method of: \" +\n+                    request.getMethod()\n+                    + \" Only POST requests are supported.\"\n+                );\n+            }\n+\n+            request = new GzippedInputStreamWrapper((HttpServletRequest) servletRequest, maxInflatedRequestBodySize);\n+        }\n+\n+        chain.doFilter(request, response);\n+    }\n+    \n+    @Override\n+    public final void destroy() {\n+        // Nothing to destroy (Sonar asks you to comment if you leave a method empty)\n+    }\n+\n+    static class GzippedInputStreamWrapper extends HttpServletRequestWrapper {\n+        private final int maxInflatedRequestBodySize;\n+        private final CountingInputStream inputStream;\n+\n+        GzippedInputStreamWrapper(final HttpServletRequest request, int maxInflatedRequestBodySize) throws IOException {\n+            super(request);\n+            this.maxInflatedRequestBodySize = maxInflatedRequestBodySize;\n+            inputStream = new CountingInputStream(new GZIPInputStream(request.getInputStream()));\n+        }\n+\n+        @Override\n+        public ServletInputStream getInputStream() throws IOException {\n+            return new ServletInputStream() {\n+                public int read() throws IOException {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9336b4cd7903af2e634b638f152f78f277cee580"}, "originalPosition": 98}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM5ODExNDE2OnYy", "diffSide": "RIGHT", "path": "core/src/main/java/org/mskcc/cbio/portal/util/RequestBodyGZipFilter.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMVQxNjo0MDo1NVrOIEAyww==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMVQxNjo0MDo1NVrOIEAyww==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTA3ODIxMQ==", "bodyText": "I guess the handler is only using the single byte at a time read() method?  Or should we also check the expanded size when using the other inputstream read() methods {  read(byte[]) and read(byte[], int, int) } ? The getReader() method below would also give access to the \"block at a time\" read methods (which are not checked for size yet)", "url": "https://github.com/cBioPortal/cbioportal/pull/8099#discussion_r541078211", "createdAt": "2020-12-11T16:40:55Z", "author": {"login": "sheridancbio"}, "path": "core/src/main/java/org/mskcc/cbio/portal/util/RequestBodyGZipFilter.java", "diffHunk": "@@ -0,0 +1,123 @@\n+package org.mskcc.cbio.portal.util;\n+\n+import com.google.common.io.CountingInputStream;\n+import com.google.common.net.HttpHeaders;\n+import org.springframework.beans.factory.annotation.Value;\n+import org.springframework.stereotype.Component;\n+\n+import javax.servlet.*;\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletRequestWrapper;\n+import javax.servlet.http.HttpServletResponse;\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.util.zip.GZIPInputStream;\n+\n+@Component(\"requestBodyGZipFilter\")\n+public class RequestBodyGZipFilter implements Filter {\n+    /**\n+     * We need to limit the size of the gzipped request bodies to avoid denial of memory attacks.\n+     * Because gzip can achieve text compression rates of around 1000x, without a common sense limit for\n+     * request body size, it would be very easy to send a request body that, when inflated, consumes the\n+     * entirety of a server's memory.\n+     */\n+    @Value(\"${request_gzip_body_size_bytes:50000000}\")\n+    private int maxInflatedRequestBodySize;\n+    \n+    @Value(\"${enable_request_body_compression:false}\")\n+    private boolean enabled;\n+\n+    @Override\n+    public void init(FilterConfig filterConfig) throws ServletException {\n+        // Nothing to init (Sonar asks you to comment if you leave a method empty)\n+    }\n+\n+    /**\n+     * Analyzes servlet request for possible gzipped body.\n+     * When Content-Encoding header has \"gzip\" value and request method is POST we read all the\n+     * gzipped stream and is it haz any data unzip it. In case when gzip Content-Encoding header\n+     * specified but body is not actually in gzip format we will throw ZipException.\n+     *\n+     * @param servletRequest  servlet request\n+     * @param servletResponse servlet response\n+     * @param chain           filter chain\n+     * @throws IOException      throws when fails\n+     * @throws ServletException thrown when fails\n+     */\n+    @Override\n+    public final void doFilter(\n+        final ServletRequest servletRequest,\n+        final ServletResponse servletResponse,\n+        final FilterChain chain\n+    ) throws IOException, ServletException {\n+        HttpServletRequest request = (HttpServletRequest) servletRequest;\n+        HttpServletResponse response = (HttpServletResponse) servletResponse;\n+        boolean isGzipped = request.getHeader(HttpHeaders.CONTENT_ENCODING) != null\n+            && request.getHeader(HttpHeaders.CONTENT_ENCODING).contains(\"gzip\");\n+        boolean requestTypeSupported = \"POST\".equals(request.getMethod());\n+\n+        if (isGzipped) {\n+            if (!enabled) {\n+                throw new IllegalStateException(\n+                    \"Received gzipped request body, but enable_request_body_compression is not set or is false\"\n+                );\n+            }\n+            if (!requestTypeSupported) {\n+                throw new IllegalStateException(\n+                    \"Received request with a Content-Encoding: gzip header and a request method of: \" +\n+                    request.getMethod()\n+                    + \" Only POST requests are supported.\"\n+                );\n+            }\n+\n+            request = new GzippedInputStreamWrapper((HttpServletRequest) servletRequest, maxInflatedRequestBodySize);\n+        }\n+\n+        chain.doFilter(request, response);\n+    }\n+    \n+    @Override\n+    public final void destroy() {\n+        // Nothing to destroy (Sonar asks you to comment if you leave a method empty)\n+    }\n+\n+    static class GzippedInputStreamWrapper extends HttpServletRequestWrapper {\n+        private final int maxInflatedRequestBodySize;\n+        private final CountingInputStream inputStream;\n+\n+        GzippedInputStreamWrapper(final HttpServletRequest request, int maxInflatedRequestBodySize) throws IOException {\n+            super(request);\n+            this.maxInflatedRequestBodySize = maxInflatedRequestBodySize;\n+            inputStream = new CountingInputStream(new GZIPInputStream(request.getInputStream()));\n+        }\n+\n+        @Override\n+        public ServletInputStream getInputStream() throws IOException {\n+            return new ServletInputStream() {\n+                public int read() throws IOException {\n+                    if (inputStream.getCount() > maxInflatedRequestBodySize) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9336b4cd7903af2e634b638f152f78f277cee580"}, "originalPosition": 99}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM5ODE3NDY5OnYy", "diffSide": "RIGHT", "path": "core/src/test/java/org/mskcc/cbio/portal/util/TestRequestBodyGZipFilter.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMVQxNjo1NDozNVrOIEBXEg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMVQxODozODoxMlrOIEFJZA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTA4NzUwNg==", "bodyText": "this is a new technique to me. Curious : did you try breaking the code so that the wrapping occurs even when the content_encoding header is not present? This test should fail under that condition right?", "url": "https://github.com/cBioPortal/cbioportal/pull/8099#discussion_r541087506", "createdAt": "2020-12-11T16:54:35Z", "author": {"login": "sheridancbio"}, "path": "core/src/test/java/org/mskcc/cbio/portal/util/TestRequestBodyGZipFilter.java", "diffHunk": "@@ -0,0 +1,174 @@\n+package org.mskcc.cbio.portal.util;\n+\n+import com.google.common.net.HttpHeaders;\n+import org.junit.Assert;\n+import org.junit.Test;\n+import org.mockito.ArgumentCaptor;\n+import org.mockito.Mockito;\n+import org.springframework.test.util.ReflectionTestUtils;\n+\n+import javax.servlet.FilterChain;\n+import javax.servlet.ServletInputStream;\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+import java.io.FileInputStream;\n+import java.io.IOException;\n+import java.io.UncheckedIOException;\n+import java.util.stream.Collectors;\n+\n+public class TestRequestBodyGZipFilter {\n+\n+    /**\n+     * When I filter a request that doesn't have the gzip header,\n+     * the request should not be wrapped, and chain.doFilter should\n+     * be called on the same request object passed to the method.\n+     */\n+    @Test\n+    public void testDoFilterEnabledNotGZipped() throws Exception {\n+        RequestBodyGZipFilter subject = createRequestBodyGZipFilter(true, 50000000);\n+\n+        HttpServletRequest request = createHttpServletRequest(null, \"POST\");\n+        HttpServletResponse response = Mockito.mock(HttpServletResponse.class);\n+        FilterChain chain = Mockito.mock(FilterChain.class);\n+\n+        subject.doFilter(request, response, chain);\n+        \n+        // request should not be wrapped\n+        Mockito.verify(chain, Mockito.times(1)).doFilter(request, response);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9336b4cd7903af2e634b638f152f78f277cee580"}, "originalPosition": 37}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTE0OTU0MA==", "bodyText": "Prior to you asking, I didn't, because I was pretty confident that this worked. Now that you asked though, I have verified that this test fails under that condition. If doFilter is not called with those exact request and response objects, the test fails.", "url": "https://github.com/cBioPortal/cbioportal/pull/8099#discussion_r541149540", "createdAt": "2020-12-11T18:38:12Z", "author": {"login": "Luke-Sikina"}, "path": "core/src/test/java/org/mskcc/cbio/portal/util/TestRequestBodyGZipFilter.java", "diffHunk": "@@ -0,0 +1,174 @@\n+package org.mskcc.cbio.portal.util;\n+\n+import com.google.common.net.HttpHeaders;\n+import org.junit.Assert;\n+import org.junit.Test;\n+import org.mockito.ArgumentCaptor;\n+import org.mockito.Mockito;\n+import org.springframework.test.util.ReflectionTestUtils;\n+\n+import javax.servlet.FilterChain;\n+import javax.servlet.ServletInputStream;\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+import java.io.FileInputStream;\n+import java.io.IOException;\n+import java.io.UncheckedIOException;\n+import java.util.stream.Collectors;\n+\n+public class TestRequestBodyGZipFilter {\n+\n+    /**\n+     * When I filter a request that doesn't have the gzip header,\n+     * the request should not be wrapped, and chain.doFilter should\n+     * be called on the same request object passed to the method.\n+     */\n+    @Test\n+    public void testDoFilterEnabledNotGZipped() throws Exception {\n+        RequestBodyGZipFilter subject = createRequestBodyGZipFilter(true, 50000000);\n+\n+        HttpServletRequest request = createHttpServletRequest(null, \"POST\");\n+        HttpServletResponse response = Mockito.mock(HttpServletResponse.class);\n+        FilterChain chain = Mockito.mock(FilterChain.class);\n+\n+        subject.doFilter(request, response, chain);\n+        \n+        // request should not be wrapped\n+        Mockito.verify(chain, Mockito.times(1)).doFilter(request, response);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTA4NzUwNg=="}, "originalCommit": {"oid": "9336b4cd7903af2e634b638f152f78f277cee580"}, "originalPosition": 37}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM5ODIwMTU5OnYy", "diffSide": "RIGHT", "path": "core/src/test/java/org/mskcc/cbio/portal/util/TestRequestBodyGZipFilter.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMVQxNzowMDo0MFrOIEBnCg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMVQxODo0MDoxM1rOIEFNhw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTA5MTU5NA==", "bodyText": "the \"post\" argument name is improper ... sometimes the string coming in is \"GET\", so rename to \"command\" or \"httpCommand\"", "url": "https://github.com/cBioPortal/cbioportal/pull/8099#discussion_r541091594", "createdAt": "2020-12-11T17:00:40Z", "author": {"login": "sheridancbio"}, "path": "core/src/test/java/org/mskcc/cbio/portal/util/TestRequestBodyGZipFilter.java", "diffHunk": "@@ -0,0 +1,174 @@\n+package org.mskcc.cbio.portal.util;\n+\n+import com.google.common.net.HttpHeaders;\n+import org.junit.Assert;\n+import org.junit.Test;\n+import org.mockito.ArgumentCaptor;\n+import org.mockito.Mockito;\n+import org.springframework.test.util.ReflectionTestUtils;\n+\n+import javax.servlet.FilterChain;\n+import javax.servlet.ServletInputStream;\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+import java.io.FileInputStream;\n+import java.io.IOException;\n+import java.io.UncheckedIOException;\n+import java.util.stream.Collectors;\n+\n+public class TestRequestBodyGZipFilter {\n+\n+    /**\n+     * When I filter a request that doesn't have the gzip header,\n+     * the request should not be wrapped, and chain.doFilter should\n+     * be called on the same request object passed to the method.\n+     */\n+    @Test\n+    public void testDoFilterEnabledNotGZipped() throws Exception {\n+        RequestBodyGZipFilter subject = createRequestBodyGZipFilter(true, 50000000);\n+\n+        HttpServletRequest request = createHttpServletRequest(null, \"POST\");\n+        HttpServletResponse response = Mockito.mock(HttpServletResponse.class);\n+        FilterChain chain = Mockito.mock(FilterChain.class);\n+\n+        subject.doFilter(request, response, chain);\n+        \n+        // request should not be wrapped\n+        Mockito.verify(chain, Mockito.times(1)).doFilter(request, response);\n+    }\n+\n+    /**\n+     * When I filter a request that has the gzip header, but the gzip\n+     * feature is disabled, the doFilter method should throw an exception.\n+     */\n+    @Test(expected = IllegalStateException.class)\n+    public void testDoFilterDisabledGZipped() throws Exception {\n+        RequestBodyGZipFilter subject = createRequestBodyGZipFilter(false, 50000000);\n+\n+        HttpServletRequest request = createHttpServletRequest(\"gzip\", \"POST\");\n+        HttpServletResponse response = Mockito.mock(HttpServletResponse.class);\n+        FilterChain chain = Mockito.mock(FilterChain.class);\n+\n+        subject.doFilter(request, response, chain);\n+    }\n+\n+    /**\n+     * When I filter a request that has the gzip header and the gzip\n+     * feature is enabled, but the method is something other than POST,\n+     * the doFilter method should throw an exception.\n+     */\n+    @Test(expected = IllegalStateException.class)\n+    public void testDoFilterEnabledGZippedBadMethod() throws Exception {\n+        RequestBodyGZipFilter subject = createRequestBodyGZipFilter(true, 50000000);\n+\n+        HttpServletRequest request = createHttpServletRequest(\"gzip\", \"GET\");\n+        HttpServletResponse response = Mockito.mock(HttpServletResponse.class);\n+        FilterChain chain = Mockito.mock(FilterChain.class);\n+\n+        subject.doFilter(request, response, chain);\n+    }\n+\n+    /**\n+     * When I filter a request that has the gzip header and the gzip\n+     * feature is enabled and the method is POST, the doFilter method\n+     * should wrap the request with a GzippedInputStreamWrapper.\n+     * The BufferedReader for this GzippedInputStreamWrapper should return\n+     * the contents of the gzipped file used to create the original input stream.\n+     */\n+    @Test\n+    public void testDoFilterEnabledGZipped() throws Exception {\n+        RequestBodyGZipFilter subject = createRequestBodyGZipFilter(true, 50000000);\n+\n+        // Not thrilled to be using the file system, but this was the most readable way to do this\n+        // that I could think of.\n+        // gzip_filter.json.gz is a gzip of a json file that contains the following: {\"field\":\"value\"}\n+        FileInputStream inputStream = new FileInputStream(\"src/test/resources/gzip_filter.json.gz\");\n+        TestInputStream stream = new TestInputStream(inputStream);\n+        HttpServletRequest request = createHttpServletRequest(\"gzip\", \"POST\");\n+        Mockito.when(request.getInputStream()).thenReturn(stream);\n+        \n+        HttpServletResponse response = Mockito.mock(HttpServletResponse.class);\n+        FilterChain chain = Mockito.mock(FilterChain.class);\n+\n+        \n+        subject.doFilter(request, response, chain);\n+\n+        // Request should be wrapped, so the request should now be a GzippedInputStreamWrapper\n+        ArgumentCaptor<RequestBodyGZipFilter.GzippedInputStreamWrapper> requestArg =\n+            ArgumentCaptor.forClass(RequestBodyGZipFilter.GzippedInputStreamWrapper.class);\n+        ArgumentCaptor<HttpServletResponse> responseArg = ArgumentCaptor.forClass(HttpServletResponse.class);\n+        Mockito.verify(chain, Mockito.times(1)).doFilter(requestArg.capture(), responseArg.capture());\n+        RequestBodyGZipFilter.GzippedInputStreamWrapper wrappedStream = requestArg.getValue();\n+        \n+        String actualRequestBody = wrappedStream.getReader().lines().collect(Collectors.joining());\n+        String expectedRequestBody = \"{\\\"field\\\":\\\"value\\\"}\";\n+        Assert.assertEquals(expectedRequestBody, actualRequestBody);\n+    }\n+\n+    /**\n+     * When I filter a request that has the gzip header and the gzip\n+     * feature is enabled and the method is POST, but the unzipped message\n+     * body is larger than maxInflatedRequestBodySize, the doFilter method\n+     * should wrap the request with a GzippedInputStreamWrapper.\n+     * The BufferedReader for this GzippedInputStreamWrapper should throw an\n+     * IOException as it is read. This exception gets turned into\n+     * an UncheckedIOException by something, so we'll check for that instead.\n+     */\n+    @Test(expected = UncheckedIOException.class)\n+    public void testDoFilterEnabledGZippedButTooLong() throws Exception {\n+        RequestBodyGZipFilter subject = createRequestBodyGZipFilter(true, 1);\n+\n+        FileInputStream inputStream = new FileInputStream(\"src/test/resources/gzip_filter.json.gz\");\n+        TestInputStream stream = new TestInputStream(inputStream);\n+        HttpServletRequest request = createHttpServletRequest(\"gzip\", \"POST\");\n+        Mockito.when(request.getInputStream()).thenReturn(stream);\n+\n+        HttpServletResponse response = Mockito.mock(HttpServletResponse.class);\n+        FilterChain chain = Mockito.mock(FilterChain.class);\n+\n+\n+        subject.doFilter(request, response, chain);\n+\n+        // Request should be wrapped, so the request should now be a GzippedInputStreamWrapper\n+        ArgumentCaptor<RequestBodyGZipFilter.GzippedInputStreamWrapper> requestArg =\n+            ArgumentCaptor.forClass(RequestBodyGZipFilter.GzippedInputStreamWrapper.class);\n+        ArgumentCaptor<HttpServletResponse> responseArg = ArgumentCaptor.forClass(HttpServletResponse.class);\n+        Mockito.verify(chain, Mockito.times(1)).doFilter(requestArg.capture(), responseArg.capture());\n+        RequestBodyGZipFilter.GzippedInputStreamWrapper wrappedStream = requestArg.getValue();\n+\n+        //this should cause an IOException\n+        wrappedStream.getReader().lines().collect(Collectors.joining());\n+    }\n+\n+\n+    private RequestBodyGZipFilter createRequestBodyGZipFilter(boolean enabled, int requestBodySize) {\n+        RequestBodyGZipFilter subject = new RequestBodyGZipFilter();\n+        ReflectionTestUtils.setField(subject, \"maxInflatedRequestBodySize\", requestBodySize);\n+        ReflectionTestUtils.setField(subject, \"enabled\", enabled);\n+        return subject;\n+    }\n+    \n+    private HttpServletRequest createHttpServletRequest(String gzip, String post) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9336b4cd7903af2e634b638f152f78f277cee580"}, "originalPosition": 151}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTE1MDU5OQ==", "bodyText": "This is what happens when you click through Intellij's method refactoring too quickly. I've changed it to httpMethod", "url": "https://github.com/cBioPortal/cbioportal/pull/8099#discussion_r541150599", "createdAt": "2020-12-11T18:40:13Z", "author": {"login": "Luke-Sikina"}, "path": "core/src/test/java/org/mskcc/cbio/portal/util/TestRequestBodyGZipFilter.java", "diffHunk": "@@ -0,0 +1,174 @@\n+package org.mskcc.cbio.portal.util;\n+\n+import com.google.common.net.HttpHeaders;\n+import org.junit.Assert;\n+import org.junit.Test;\n+import org.mockito.ArgumentCaptor;\n+import org.mockito.Mockito;\n+import org.springframework.test.util.ReflectionTestUtils;\n+\n+import javax.servlet.FilterChain;\n+import javax.servlet.ServletInputStream;\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+import java.io.FileInputStream;\n+import java.io.IOException;\n+import java.io.UncheckedIOException;\n+import java.util.stream.Collectors;\n+\n+public class TestRequestBodyGZipFilter {\n+\n+    /**\n+     * When I filter a request that doesn't have the gzip header,\n+     * the request should not be wrapped, and chain.doFilter should\n+     * be called on the same request object passed to the method.\n+     */\n+    @Test\n+    public void testDoFilterEnabledNotGZipped() throws Exception {\n+        RequestBodyGZipFilter subject = createRequestBodyGZipFilter(true, 50000000);\n+\n+        HttpServletRequest request = createHttpServletRequest(null, \"POST\");\n+        HttpServletResponse response = Mockito.mock(HttpServletResponse.class);\n+        FilterChain chain = Mockito.mock(FilterChain.class);\n+\n+        subject.doFilter(request, response, chain);\n+        \n+        // request should not be wrapped\n+        Mockito.verify(chain, Mockito.times(1)).doFilter(request, response);\n+    }\n+\n+    /**\n+     * When I filter a request that has the gzip header, but the gzip\n+     * feature is disabled, the doFilter method should throw an exception.\n+     */\n+    @Test(expected = IllegalStateException.class)\n+    public void testDoFilterDisabledGZipped() throws Exception {\n+        RequestBodyGZipFilter subject = createRequestBodyGZipFilter(false, 50000000);\n+\n+        HttpServletRequest request = createHttpServletRequest(\"gzip\", \"POST\");\n+        HttpServletResponse response = Mockito.mock(HttpServletResponse.class);\n+        FilterChain chain = Mockito.mock(FilterChain.class);\n+\n+        subject.doFilter(request, response, chain);\n+    }\n+\n+    /**\n+     * When I filter a request that has the gzip header and the gzip\n+     * feature is enabled, but the method is something other than POST,\n+     * the doFilter method should throw an exception.\n+     */\n+    @Test(expected = IllegalStateException.class)\n+    public void testDoFilterEnabledGZippedBadMethod() throws Exception {\n+        RequestBodyGZipFilter subject = createRequestBodyGZipFilter(true, 50000000);\n+\n+        HttpServletRequest request = createHttpServletRequest(\"gzip\", \"GET\");\n+        HttpServletResponse response = Mockito.mock(HttpServletResponse.class);\n+        FilterChain chain = Mockito.mock(FilterChain.class);\n+\n+        subject.doFilter(request, response, chain);\n+    }\n+\n+    /**\n+     * When I filter a request that has the gzip header and the gzip\n+     * feature is enabled and the method is POST, the doFilter method\n+     * should wrap the request with a GzippedInputStreamWrapper.\n+     * The BufferedReader for this GzippedInputStreamWrapper should return\n+     * the contents of the gzipped file used to create the original input stream.\n+     */\n+    @Test\n+    public void testDoFilterEnabledGZipped() throws Exception {\n+        RequestBodyGZipFilter subject = createRequestBodyGZipFilter(true, 50000000);\n+\n+        // Not thrilled to be using the file system, but this was the most readable way to do this\n+        // that I could think of.\n+        // gzip_filter.json.gz is a gzip of a json file that contains the following: {\"field\":\"value\"}\n+        FileInputStream inputStream = new FileInputStream(\"src/test/resources/gzip_filter.json.gz\");\n+        TestInputStream stream = new TestInputStream(inputStream);\n+        HttpServletRequest request = createHttpServletRequest(\"gzip\", \"POST\");\n+        Mockito.when(request.getInputStream()).thenReturn(stream);\n+        \n+        HttpServletResponse response = Mockito.mock(HttpServletResponse.class);\n+        FilterChain chain = Mockito.mock(FilterChain.class);\n+\n+        \n+        subject.doFilter(request, response, chain);\n+\n+        // Request should be wrapped, so the request should now be a GzippedInputStreamWrapper\n+        ArgumentCaptor<RequestBodyGZipFilter.GzippedInputStreamWrapper> requestArg =\n+            ArgumentCaptor.forClass(RequestBodyGZipFilter.GzippedInputStreamWrapper.class);\n+        ArgumentCaptor<HttpServletResponse> responseArg = ArgumentCaptor.forClass(HttpServletResponse.class);\n+        Mockito.verify(chain, Mockito.times(1)).doFilter(requestArg.capture(), responseArg.capture());\n+        RequestBodyGZipFilter.GzippedInputStreamWrapper wrappedStream = requestArg.getValue();\n+        \n+        String actualRequestBody = wrappedStream.getReader().lines().collect(Collectors.joining());\n+        String expectedRequestBody = \"{\\\"field\\\":\\\"value\\\"}\";\n+        Assert.assertEquals(expectedRequestBody, actualRequestBody);\n+    }\n+\n+    /**\n+     * When I filter a request that has the gzip header and the gzip\n+     * feature is enabled and the method is POST, but the unzipped message\n+     * body is larger than maxInflatedRequestBodySize, the doFilter method\n+     * should wrap the request with a GzippedInputStreamWrapper.\n+     * The BufferedReader for this GzippedInputStreamWrapper should throw an\n+     * IOException as it is read. This exception gets turned into\n+     * an UncheckedIOException by something, so we'll check for that instead.\n+     */\n+    @Test(expected = UncheckedIOException.class)\n+    public void testDoFilterEnabledGZippedButTooLong() throws Exception {\n+        RequestBodyGZipFilter subject = createRequestBodyGZipFilter(true, 1);\n+\n+        FileInputStream inputStream = new FileInputStream(\"src/test/resources/gzip_filter.json.gz\");\n+        TestInputStream stream = new TestInputStream(inputStream);\n+        HttpServletRequest request = createHttpServletRequest(\"gzip\", \"POST\");\n+        Mockito.when(request.getInputStream()).thenReturn(stream);\n+\n+        HttpServletResponse response = Mockito.mock(HttpServletResponse.class);\n+        FilterChain chain = Mockito.mock(FilterChain.class);\n+\n+\n+        subject.doFilter(request, response, chain);\n+\n+        // Request should be wrapped, so the request should now be a GzippedInputStreamWrapper\n+        ArgumentCaptor<RequestBodyGZipFilter.GzippedInputStreamWrapper> requestArg =\n+            ArgumentCaptor.forClass(RequestBodyGZipFilter.GzippedInputStreamWrapper.class);\n+        ArgumentCaptor<HttpServletResponse> responseArg = ArgumentCaptor.forClass(HttpServletResponse.class);\n+        Mockito.verify(chain, Mockito.times(1)).doFilter(requestArg.capture(), responseArg.capture());\n+        RequestBodyGZipFilter.GzippedInputStreamWrapper wrappedStream = requestArg.getValue();\n+\n+        //this should cause an IOException\n+        wrappedStream.getReader().lines().collect(Collectors.joining());\n+    }\n+\n+\n+    private RequestBodyGZipFilter createRequestBodyGZipFilter(boolean enabled, int requestBodySize) {\n+        RequestBodyGZipFilter subject = new RequestBodyGZipFilter();\n+        ReflectionTestUtils.setField(subject, \"maxInflatedRequestBodySize\", requestBodySize);\n+        ReflectionTestUtils.setField(subject, \"enabled\", enabled);\n+        return subject;\n+    }\n+    \n+    private HttpServletRequest createHttpServletRequest(String gzip, String post) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTA5MTU5NA=="}, "originalCommit": {"oid": "9336b4cd7903af2e634b638f152f78f277cee580"}, "originalPosition": 151}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM5ODIyMjU4OnYy", "diffSide": "RIGHT", "path": "core/src/test/java/org/mskcc/cbio/portal/util/TestRequestBodyGZipFilter.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMVQxNzowNTo1OVrOIEBzng==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMVQxNzowNTo1OVrOIEBzng==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTA5NDgxNA==", "bodyText": "The accepted strings for httpMethod can be referenced symbolically here perhaps? (from quick web search):\nhttps://javaee.github.io/javaee-spec/javadocs/javax/ws/rs/HttpMethod.html", "url": "https://github.com/cBioPortal/cbioportal/pull/8099#discussion_r541094814", "createdAt": "2020-12-11T17:05:59Z", "author": {"login": "sheridancbio"}, "path": "core/src/test/java/org/mskcc/cbio/portal/util/TestRequestBodyGZipFilter.java", "diffHunk": "@@ -0,0 +1,174 @@\n+package org.mskcc.cbio.portal.util;\n+\n+import com.google.common.net.HttpHeaders;\n+import org.junit.Assert;\n+import org.junit.Test;\n+import org.mockito.ArgumentCaptor;\n+import org.mockito.Mockito;\n+import org.springframework.test.util.ReflectionTestUtils;\n+\n+import javax.servlet.FilterChain;\n+import javax.servlet.ServletInputStream;\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+import java.io.FileInputStream;\n+import java.io.IOException;\n+import java.io.UncheckedIOException;\n+import java.util.stream.Collectors;\n+\n+public class TestRequestBodyGZipFilter {\n+\n+    /**\n+     * When I filter a request that doesn't have the gzip header,\n+     * the request should not be wrapped, and chain.doFilter should\n+     * be called on the same request object passed to the method.\n+     */\n+    @Test\n+    public void testDoFilterEnabledNotGZipped() throws Exception {\n+        RequestBodyGZipFilter subject = createRequestBodyGZipFilter(true, 50000000);\n+\n+        HttpServletRequest request = createHttpServletRequest(null, \"POST\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9336b4cd7903af2e634b638f152f78f277cee580"}, "originalPosition": 30}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM5ODIzMjk5OnYy", "diffSide": "RIGHT", "path": "core/src/test/java/org/mskcc/cbio/portal/util/TestRequestBodyGZipFilter.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMVQxNzowODoyOFrOIEB5mg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMVQxNzowODoyOFrOIEB5mg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTA5NjM0Ng==", "bodyText": "If we have not come up with a better way by the time we are ready to merge, we should drop this comment maybe", "url": "https://github.com/cBioPortal/cbioportal/pull/8099#discussion_r541096346", "createdAt": "2020-12-11T17:08:28Z", "author": {"login": "sheridancbio"}, "path": "core/src/test/java/org/mskcc/cbio/portal/util/TestRequestBodyGZipFilter.java", "diffHunk": "@@ -0,0 +1,174 @@\n+package org.mskcc.cbio.portal.util;\n+\n+import com.google.common.net.HttpHeaders;\n+import org.junit.Assert;\n+import org.junit.Test;\n+import org.mockito.ArgumentCaptor;\n+import org.mockito.Mockito;\n+import org.springframework.test.util.ReflectionTestUtils;\n+\n+import javax.servlet.FilterChain;\n+import javax.servlet.ServletInputStream;\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+import java.io.FileInputStream;\n+import java.io.IOException;\n+import java.io.UncheckedIOException;\n+import java.util.stream.Collectors;\n+\n+public class TestRequestBodyGZipFilter {\n+\n+    /**\n+     * When I filter a request that doesn't have the gzip header,\n+     * the request should not be wrapped, and chain.doFilter should\n+     * be called on the same request object passed to the method.\n+     */\n+    @Test\n+    public void testDoFilterEnabledNotGZipped() throws Exception {\n+        RequestBodyGZipFilter subject = createRequestBodyGZipFilter(true, 50000000);\n+\n+        HttpServletRequest request = createHttpServletRequest(null, \"POST\");\n+        HttpServletResponse response = Mockito.mock(HttpServletResponse.class);\n+        FilterChain chain = Mockito.mock(FilterChain.class);\n+\n+        subject.doFilter(request, response, chain);\n+        \n+        // request should not be wrapped\n+        Mockito.verify(chain, Mockito.times(1)).doFilter(request, response);\n+    }\n+\n+    /**\n+     * When I filter a request that has the gzip header, but the gzip\n+     * feature is disabled, the doFilter method should throw an exception.\n+     */\n+    @Test(expected = IllegalStateException.class)\n+    public void testDoFilterDisabledGZipped() throws Exception {\n+        RequestBodyGZipFilter subject = createRequestBodyGZipFilter(false, 50000000);\n+\n+        HttpServletRequest request = createHttpServletRequest(\"gzip\", \"POST\");\n+        HttpServletResponse response = Mockito.mock(HttpServletResponse.class);\n+        FilterChain chain = Mockito.mock(FilterChain.class);\n+\n+        subject.doFilter(request, response, chain);\n+    }\n+\n+    /**\n+     * When I filter a request that has the gzip header and the gzip\n+     * feature is enabled, but the method is something other than POST,\n+     * the doFilter method should throw an exception.\n+     */\n+    @Test(expected = IllegalStateException.class)\n+    public void testDoFilterEnabledGZippedBadMethod() throws Exception {\n+        RequestBodyGZipFilter subject = createRequestBodyGZipFilter(true, 50000000);\n+\n+        HttpServletRequest request = createHttpServletRequest(\"gzip\", \"GET\");\n+        HttpServletResponse response = Mockito.mock(HttpServletResponse.class);\n+        FilterChain chain = Mockito.mock(FilterChain.class);\n+\n+        subject.doFilter(request, response, chain);\n+    }\n+\n+    /**\n+     * When I filter a request that has the gzip header and the gzip\n+     * feature is enabled and the method is POST, the doFilter method\n+     * should wrap the request with a GzippedInputStreamWrapper.\n+     * The BufferedReader for this GzippedInputStreamWrapper should return\n+     * the contents of the gzipped file used to create the original input stream.\n+     */\n+    @Test\n+    public void testDoFilterEnabledGZipped() throws Exception {\n+        RequestBodyGZipFilter subject = createRequestBodyGZipFilter(true, 50000000);\n+\n+        // Not thrilled to be using the file system, but this was the most readable way to do this", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9336b4cd7903af2e634b638f152f78f277cee580"}, "originalPosition": 82}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM5ODI1Njc5OnYy", "diffSide": "RIGHT", "path": "core/src/test/java/org/mskcc/cbio/portal/util/TestRequestBodyGZipFilter.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMVQxNzoxNDoxMFrOIECHbA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMVQxNzoxNDoxMFrOIECHbA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTA5OTg4NA==", "bodyText": "don't need 2 blank lines here", "url": "https://github.com/cBioPortal/cbioportal/pull/8099#discussion_r541099884", "createdAt": "2020-12-11T17:14:10Z", "author": {"login": "sheridancbio"}, "path": "core/src/test/java/org/mskcc/cbio/portal/util/TestRequestBodyGZipFilter.java", "diffHunk": "@@ -0,0 +1,174 @@\n+package org.mskcc.cbio.portal.util;\n+\n+import com.google.common.net.HttpHeaders;\n+import org.junit.Assert;\n+import org.junit.Test;\n+import org.mockito.ArgumentCaptor;\n+import org.mockito.Mockito;\n+import org.springframework.test.util.ReflectionTestUtils;\n+\n+import javax.servlet.FilterChain;\n+import javax.servlet.ServletInputStream;\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+import java.io.FileInputStream;\n+import java.io.IOException;\n+import java.io.UncheckedIOException;\n+import java.util.stream.Collectors;\n+\n+public class TestRequestBodyGZipFilter {\n+\n+    /**\n+     * When I filter a request that doesn't have the gzip header,\n+     * the request should not be wrapped, and chain.doFilter should\n+     * be called on the same request object passed to the method.\n+     */\n+    @Test\n+    public void testDoFilterEnabledNotGZipped() throws Exception {\n+        RequestBodyGZipFilter subject = createRequestBodyGZipFilter(true, 50000000);\n+\n+        HttpServletRequest request = createHttpServletRequest(null, \"POST\");\n+        HttpServletResponse response = Mockito.mock(HttpServletResponse.class);\n+        FilterChain chain = Mockito.mock(FilterChain.class);\n+\n+        subject.doFilter(request, response, chain);\n+        \n+        // request should not be wrapped\n+        Mockito.verify(chain, Mockito.times(1)).doFilter(request, response);\n+    }\n+\n+    /**\n+     * When I filter a request that has the gzip header, but the gzip\n+     * feature is disabled, the doFilter method should throw an exception.\n+     */\n+    @Test(expected = IllegalStateException.class)\n+    public void testDoFilterDisabledGZipped() throws Exception {\n+        RequestBodyGZipFilter subject = createRequestBodyGZipFilter(false, 50000000);\n+\n+        HttpServletRequest request = createHttpServletRequest(\"gzip\", \"POST\");\n+        HttpServletResponse response = Mockito.mock(HttpServletResponse.class);\n+        FilterChain chain = Mockito.mock(FilterChain.class);\n+\n+        subject.doFilter(request, response, chain);\n+    }\n+\n+    /**\n+     * When I filter a request that has the gzip header and the gzip\n+     * feature is enabled, but the method is something other than POST,\n+     * the doFilter method should throw an exception.\n+     */\n+    @Test(expected = IllegalStateException.class)\n+    public void testDoFilterEnabledGZippedBadMethod() throws Exception {\n+        RequestBodyGZipFilter subject = createRequestBodyGZipFilter(true, 50000000);\n+\n+        HttpServletRequest request = createHttpServletRequest(\"gzip\", \"GET\");\n+        HttpServletResponse response = Mockito.mock(HttpServletResponse.class);\n+        FilterChain chain = Mockito.mock(FilterChain.class);\n+\n+        subject.doFilter(request, response, chain);\n+    }\n+\n+    /**\n+     * When I filter a request that has the gzip header and the gzip\n+     * feature is enabled and the method is POST, the doFilter method\n+     * should wrap the request with a GzippedInputStreamWrapper.\n+     * The BufferedReader for this GzippedInputStreamWrapper should return\n+     * the contents of the gzipped file used to create the original input stream.\n+     */\n+    @Test\n+    public void testDoFilterEnabledGZipped() throws Exception {\n+        RequestBodyGZipFilter subject = createRequestBodyGZipFilter(true, 50000000);\n+\n+        // Not thrilled to be using the file system, but this was the most readable way to do this\n+        // that I could think of.\n+        // gzip_filter.json.gz is a gzip of a json file that contains the following: {\"field\":\"value\"}\n+        FileInputStream inputStream = new FileInputStream(\"src/test/resources/gzip_filter.json.gz\");\n+        TestInputStream stream = new TestInputStream(inputStream);\n+        HttpServletRequest request = createHttpServletRequest(\"gzip\", \"POST\");\n+        Mockito.when(request.getInputStream()).thenReturn(stream);\n+        \n+        HttpServletResponse response = Mockito.mock(HttpServletResponse.class);\n+        FilterChain chain = Mockito.mock(FilterChain.class);\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9336b4cd7903af2e634b638f152f78f277cee580"}, "originalPosition": 92}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM5ODI2MTY5OnYy", "diffSide": "RIGHT", "path": "core/src/test/java/org/mskcc/cbio/portal/util/TestRequestBodyGZipFilter.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMVQxNzoxNToxNlrOIECKIg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMVQxNzoxNToxNlrOIECKIg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTEwMDU3OA==", "bodyText": "mysterious", "url": "https://github.com/cBioPortal/cbioportal/pull/8099#discussion_r541100578", "createdAt": "2020-12-11T17:15:16Z", "author": {"login": "sheridancbio"}, "path": "core/src/test/java/org/mskcc/cbio/portal/util/TestRequestBodyGZipFilter.java", "diffHunk": "@@ -0,0 +1,174 @@\n+package org.mskcc.cbio.portal.util;\n+\n+import com.google.common.net.HttpHeaders;\n+import org.junit.Assert;\n+import org.junit.Test;\n+import org.mockito.ArgumentCaptor;\n+import org.mockito.Mockito;\n+import org.springframework.test.util.ReflectionTestUtils;\n+\n+import javax.servlet.FilterChain;\n+import javax.servlet.ServletInputStream;\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+import java.io.FileInputStream;\n+import java.io.IOException;\n+import java.io.UncheckedIOException;\n+import java.util.stream.Collectors;\n+\n+public class TestRequestBodyGZipFilter {\n+\n+    /**\n+     * When I filter a request that doesn't have the gzip header,\n+     * the request should not be wrapped, and chain.doFilter should\n+     * be called on the same request object passed to the method.\n+     */\n+    @Test\n+    public void testDoFilterEnabledNotGZipped() throws Exception {\n+        RequestBodyGZipFilter subject = createRequestBodyGZipFilter(true, 50000000);\n+\n+        HttpServletRequest request = createHttpServletRequest(null, \"POST\");\n+        HttpServletResponse response = Mockito.mock(HttpServletResponse.class);\n+        FilterChain chain = Mockito.mock(FilterChain.class);\n+\n+        subject.doFilter(request, response, chain);\n+        \n+        // request should not be wrapped\n+        Mockito.verify(chain, Mockito.times(1)).doFilter(request, response);\n+    }\n+\n+    /**\n+     * When I filter a request that has the gzip header, but the gzip\n+     * feature is disabled, the doFilter method should throw an exception.\n+     */\n+    @Test(expected = IllegalStateException.class)\n+    public void testDoFilterDisabledGZipped() throws Exception {\n+        RequestBodyGZipFilter subject = createRequestBodyGZipFilter(false, 50000000);\n+\n+        HttpServletRequest request = createHttpServletRequest(\"gzip\", \"POST\");\n+        HttpServletResponse response = Mockito.mock(HttpServletResponse.class);\n+        FilterChain chain = Mockito.mock(FilterChain.class);\n+\n+        subject.doFilter(request, response, chain);\n+    }\n+\n+    /**\n+     * When I filter a request that has the gzip header and the gzip\n+     * feature is enabled, but the method is something other than POST,\n+     * the doFilter method should throw an exception.\n+     */\n+    @Test(expected = IllegalStateException.class)\n+    public void testDoFilterEnabledGZippedBadMethod() throws Exception {\n+        RequestBodyGZipFilter subject = createRequestBodyGZipFilter(true, 50000000);\n+\n+        HttpServletRequest request = createHttpServletRequest(\"gzip\", \"GET\");\n+        HttpServletResponse response = Mockito.mock(HttpServletResponse.class);\n+        FilterChain chain = Mockito.mock(FilterChain.class);\n+\n+        subject.doFilter(request, response, chain);\n+    }\n+\n+    /**\n+     * When I filter a request that has the gzip header and the gzip\n+     * feature is enabled and the method is POST, the doFilter method\n+     * should wrap the request with a GzippedInputStreamWrapper.\n+     * The BufferedReader for this GzippedInputStreamWrapper should return\n+     * the contents of the gzipped file used to create the original input stream.\n+     */\n+    @Test\n+    public void testDoFilterEnabledGZipped() throws Exception {\n+        RequestBodyGZipFilter subject = createRequestBodyGZipFilter(true, 50000000);\n+\n+        // Not thrilled to be using the file system, but this was the most readable way to do this\n+        // that I could think of.\n+        // gzip_filter.json.gz is a gzip of a json file that contains the following: {\"field\":\"value\"}\n+        FileInputStream inputStream = new FileInputStream(\"src/test/resources/gzip_filter.json.gz\");\n+        TestInputStream stream = new TestInputStream(inputStream);\n+        HttpServletRequest request = createHttpServletRequest(\"gzip\", \"POST\");\n+        Mockito.when(request.getInputStream()).thenReturn(stream);\n+        \n+        HttpServletResponse response = Mockito.mock(HttpServletResponse.class);\n+        FilterChain chain = Mockito.mock(FilterChain.class);\n+\n+        \n+        subject.doFilter(request, response, chain);\n+\n+        // Request should be wrapped, so the request should now be a GzippedInputStreamWrapper\n+        ArgumentCaptor<RequestBodyGZipFilter.GzippedInputStreamWrapper> requestArg =\n+            ArgumentCaptor.forClass(RequestBodyGZipFilter.GzippedInputStreamWrapper.class);\n+        ArgumentCaptor<HttpServletResponse> responseArg = ArgumentCaptor.forClass(HttpServletResponse.class);\n+        Mockito.verify(chain, Mockito.times(1)).doFilter(requestArg.capture(), responseArg.capture());\n+        RequestBodyGZipFilter.GzippedInputStreamWrapper wrappedStream = requestArg.getValue();\n+        \n+        String actualRequestBody = wrappedStream.getReader().lines().collect(Collectors.joining());\n+        String expectedRequestBody = \"{\\\"field\\\":\\\"value\\\"}\";\n+        Assert.assertEquals(expectedRequestBody, actualRequestBody);\n+    }\n+\n+    /**\n+     * When I filter a request that has the gzip header and the gzip\n+     * feature is enabled and the method is POST, but the unzipped message\n+     * body is larger than maxInflatedRequestBodySize, the doFilter method\n+     * should wrap the request with a GzippedInputStreamWrapper.\n+     * The BufferedReader for this GzippedInputStreamWrapper should throw an\n+     * IOException as it is read. This exception gets turned into\n+     * an UncheckedIOException by something, so we'll check for that instead.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9336b4cd7903af2e634b638f152f78f277cee580"}, "originalPosition": 115}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM5ODI3MDI4OnYy", "diffSide": "RIGHT", "path": "core/src/test/java/org/mskcc/cbio/portal/util/TestRequestBodyGZipFilter.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMVQxNzoxNzoyMVrOIECPBw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMVQxNzoxNzoyMVrOIECPBw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTEwMTgzMQ==", "bodyText": "since the test is working we can conclude that the Reader returned gets used with only the read() method by .lines()\nthis construction at least is not using read(byte[])", "url": "https://github.com/cBioPortal/cbioportal/pull/8099#discussion_r541101831", "createdAt": "2020-12-11T17:17:21Z", "author": {"login": "sheridancbio"}, "path": "core/src/test/java/org/mskcc/cbio/portal/util/TestRequestBodyGZipFilter.java", "diffHunk": "@@ -0,0 +1,174 @@\n+package org.mskcc.cbio.portal.util;\n+\n+import com.google.common.net.HttpHeaders;\n+import org.junit.Assert;\n+import org.junit.Test;\n+import org.mockito.ArgumentCaptor;\n+import org.mockito.Mockito;\n+import org.springframework.test.util.ReflectionTestUtils;\n+\n+import javax.servlet.FilterChain;\n+import javax.servlet.ServletInputStream;\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+import java.io.FileInputStream;\n+import java.io.IOException;\n+import java.io.UncheckedIOException;\n+import java.util.stream.Collectors;\n+\n+public class TestRequestBodyGZipFilter {\n+\n+    /**\n+     * When I filter a request that doesn't have the gzip header,\n+     * the request should not be wrapped, and chain.doFilter should\n+     * be called on the same request object passed to the method.\n+     */\n+    @Test\n+    public void testDoFilterEnabledNotGZipped() throws Exception {\n+        RequestBodyGZipFilter subject = createRequestBodyGZipFilter(true, 50000000);\n+\n+        HttpServletRequest request = createHttpServletRequest(null, \"POST\");\n+        HttpServletResponse response = Mockito.mock(HttpServletResponse.class);\n+        FilterChain chain = Mockito.mock(FilterChain.class);\n+\n+        subject.doFilter(request, response, chain);\n+        \n+        // request should not be wrapped\n+        Mockito.verify(chain, Mockito.times(1)).doFilter(request, response);\n+    }\n+\n+    /**\n+     * When I filter a request that has the gzip header, but the gzip\n+     * feature is disabled, the doFilter method should throw an exception.\n+     */\n+    @Test(expected = IllegalStateException.class)\n+    public void testDoFilterDisabledGZipped() throws Exception {\n+        RequestBodyGZipFilter subject = createRequestBodyGZipFilter(false, 50000000);\n+\n+        HttpServletRequest request = createHttpServletRequest(\"gzip\", \"POST\");\n+        HttpServletResponse response = Mockito.mock(HttpServletResponse.class);\n+        FilterChain chain = Mockito.mock(FilterChain.class);\n+\n+        subject.doFilter(request, response, chain);\n+    }\n+\n+    /**\n+     * When I filter a request that has the gzip header and the gzip\n+     * feature is enabled, but the method is something other than POST,\n+     * the doFilter method should throw an exception.\n+     */\n+    @Test(expected = IllegalStateException.class)\n+    public void testDoFilterEnabledGZippedBadMethod() throws Exception {\n+        RequestBodyGZipFilter subject = createRequestBodyGZipFilter(true, 50000000);\n+\n+        HttpServletRequest request = createHttpServletRequest(\"gzip\", \"GET\");\n+        HttpServletResponse response = Mockito.mock(HttpServletResponse.class);\n+        FilterChain chain = Mockito.mock(FilterChain.class);\n+\n+        subject.doFilter(request, response, chain);\n+    }\n+\n+    /**\n+     * When I filter a request that has the gzip header and the gzip\n+     * feature is enabled and the method is POST, the doFilter method\n+     * should wrap the request with a GzippedInputStreamWrapper.\n+     * The BufferedReader for this GzippedInputStreamWrapper should return\n+     * the contents of the gzipped file used to create the original input stream.\n+     */\n+    @Test\n+    public void testDoFilterEnabledGZipped() throws Exception {\n+        RequestBodyGZipFilter subject = createRequestBodyGZipFilter(true, 50000000);\n+\n+        // Not thrilled to be using the file system, but this was the most readable way to do this\n+        // that I could think of.\n+        // gzip_filter.json.gz is a gzip of a json file that contains the following: {\"field\":\"value\"}\n+        FileInputStream inputStream = new FileInputStream(\"src/test/resources/gzip_filter.json.gz\");\n+        TestInputStream stream = new TestInputStream(inputStream);\n+        HttpServletRequest request = createHttpServletRequest(\"gzip\", \"POST\");\n+        Mockito.when(request.getInputStream()).thenReturn(stream);\n+        \n+        HttpServletResponse response = Mockito.mock(HttpServletResponse.class);\n+        FilterChain chain = Mockito.mock(FilterChain.class);\n+\n+        \n+        subject.doFilter(request, response, chain);\n+\n+        // Request should be wrapped, so the request should now be a GzippedInputStreamWrapper\n+        ArgumentCaptor<RequestBodyGZipFilter.GzippedInputStreamWrapper> requestArg =\n+            ArgumentCaptor.forClass(RequestBodyGZipFilter.GzippedInputStreamWrapper.class);\n+        ArgumentCaptor<HttpServletResponse> responseArg = ArgumentCaptor.forClass(HttpServletResponse.class);\n+        Mockito.verify(chain, Mockito.times(1)).doFilter(requestArg.capture(), responseArg.capture());\n+        RequestBodyGZipFilter.GzippedInputStreamWrapper wrappedStream = requestArg.getValue();\n+        \n+        String actualRequestBody = wrappedStream.getReader().lines().collect(Collectors.joining());\n+        String expectedRequestBody = \"{\\\"field\\\":\\\"value\\\"}\";\n+        Assert.assertEquals(expectedRequestBody, actualRequestBody);\n+    }\n+\n+    /**\n+     * When I filter a request that has the gzip header and the gzip\n+     * feature is enabled and the method is POST, but the unzipped message\n+     * body is larger than maxInflatedRequestBodySize, the doFilter method\n+     * should wrap the request with a GzippedInputStreamWrapper.\n+     * The BufferedReader for this GzippedInputStreamWrapper should throw an\n+     * IOException as it is read. This exception gets turned into\n+     * an UncheckedIOException by something, so we'll check for that instead.\n+     */\n+    @Test(expected = UncheckedIOException.class)\n+    public void testDoFilterEnabledGZippedButTooLong() throws Exception {\n+        RequestBodyGZipFilter subject = createRequestBodyGZipFilter(true, 1);\n+\n+        FileInputStream inputStream = new FileInputStream(\"src/test/resources/gzip_filter.json.gz\");\n+        TestInputStream stream = new TestInputStream(inputStream);\n+        HttpServletRequest request = createHttpServletRequest(\"gzip\", \"POST\");\n+        Mockito.when(request.getInputStream()).thenReturn(stream);\n+\n+        HttpServletResponse response = Mockito.mock(HttpServletResponse.class);\n+        FilterChain chain = Mockito.mock(FilterChain.class);\n+\n+\n+        subject.doFilter(request, response, chain);\n+\n+        // Request should be wrapped, so the request should now be a GzippedInputStreamWrapper\n+        ArgumentCaptor<RequestBodyGZipFilter.GzippedInputStreamWrapper> requestArg =\n+            ArgumentCaptor.forClass(RequestBodyGZipFilter.GzippedInputStreamWrapper.class);\n+        ArgumentCaptor<HttpServletResponse> responseArg = ArgumentCaptor.forClass(HttpServletResponse.class);\n+        Mockito.verify(chain, Mockito.times(1)).doFilter(requestArg.capture(), responseArg.capture());\n+        RequestBodyGZipFilter.GzippedInputStreamWrapper wrappedStream = requestArg.getValue();\n+\n+        //this should cause an IOException\n+        wrappedStream.getReader().lines().collect(Collectors.joining());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9336b4cd7903af2e634b638f152f78f277cee580"}, "originalPosition": 140}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM5ODI3MjA5OnYy", "diffSide": "RIGHT", "path": "core/src/test/java/org/mskcc/cbio/portal/util/TestRequestBodyGZipFilter.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMVQxNzoxNzo0N1rOIECP_g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMVQxNzoxNzo0N1rOIECP_g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTEwMjA3OA==", "bodyText": "double blank line", "url": "https://github.com/cBioPortal/cbioportal/pull/8099#discussion_r541102078", "createdAt": "2020-12-11T17:17:47Z", "author": {"login": "sheridancbio"}, "path": "core/src/test/java/org/mskcc/cbio/portal/util/TestRequestBodyGZipFilter.java", "diffHunk": "@@ -0,0 +1,174 @@\n+package org.mskcc.cbio.portal.util;\n+\n+import com.google.common.net.HttpHeaders;\n+import org.junit.Assert;\n+import org.junit.Test;\n+import org.mockito.ArgumentCaptor;\n+import org.mockito.Mockito;\n+import org.springframework.test.util.ReflectionTestUtils;\n+\n+import javax.servlet.FilterChain;\n+import javax.servlet.ServletInputStream;\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+import java.io.FileInputStream;\n+import java.io.IOException;\n+import java.io.UncheckedIOException;\n+import java.util.stream.Collectors;\n+\n+public class TestRequestBodyGZipFilter {\n+\n+    /**\n+     * When I filter a request that doesn't have the gzip header,\n+     * the request should not be wrapped, and chain.doFilter should\n+     * be called on the same request object passed to the method.\n+     */\n+    @Test\n+    public void testDoFilterEnabledNotGZipped() throws Exception {\n+        RequestBodyGZipFilter subject = createRequestBodyGZipFilter(true, 50000000);\n+\n+        HttpServletRequest request = createHttpServletRequest(null, \"POST\");\n+        HttpServletResponse response = Mockito.mock(HttpServletResponse.class);\n+        FilterChain chain = Mockito.mock(FilterChain.class);\n+\n+        subject.doFilter(request, response, chain);\n+        \n+        // request should not be wrapped\n+        Mockito.verify(chain, Mockito.times(1)).doFilter(request, response);\n+    }\n+\n+    /**\n+     * When I filter a request that has the gzip header, but the gzip\n+     * feature is disabled, the doFilter method should throw an exception.\n+     */\n+    @Test(expected = IllegalStateException.class)\n+    public void testDoFilterDisabledGZipped() throws Exception {\n+        RequestBodyGZipFilter subject = createRequestBodyGZipFilter(false, 50000000);\n+\n+        HttpServletRequest request = createHttpServletRequest(\"gzip\", \"POST\");\n+        HttpServletResponse response = Mockito.mock(HttpServletResponse.class);\n+        FilterChain chain = Mockito.mock(FilterChain.class);\n+\n+        subject.doFilter(request, response, chain);\n+    }\n+\n+    /**\n+     * When I filter a request that has the gzip header and the gzip\n+     * feature is enabled, but the method is something other than POST,\n+     * the doFilter method should throw an exception.\n+     */\n+    @Test(expected = IllegalStateException.class)\n+    public void testDoFilterEnabledGZippedBadMethod() throws Exception {\n+        RequestBodyGZipFilter subject = createRequestBodyGZipFilter(true, 50000000);\n+\n+        HttpServletRequest request = createHttpServletRequest(\"gzip\", \"GET\");\n+        HttpServletResponse response = Mockito.mock(HttpServletResponse.class);\n+        FilterChain chain = Mockito.mock(FilterChain.class);\n+\n+        subject.doFilter(request, response, chain);\n+    }\n+\n+    /**\n+     * When I filter a request that has the gzip header and the gzip\n+     * feature is enabled and the method is POST, the doFilter method\n+     * should wrap the request with a GzippedInputStreamWrapper.\n+     * The BufferedReader for this GzippedInputStreamWrapper should return\n+     * the contents of the gzipped file used to create the original input stream.\n+     */\n+    @Test\n+    public void testDoFilterEnabledGZipped() throws Exception {\n+        RequestBodyGZipFilter subject = createRequestBodyGZipFilter(true, 50000000);\n+\n+        // Not thrilled to be using the file system, but this was the most readable way to do this\n+        // that I could think of.\n+        // gzip_filter.json.gz is a gzip of a json file that contains the following: {\"field\":\"value\"}\n+        FileInputStream inputStream = new FileInputStream(\"src/test/resources/gzip_filter.json.gz\");\n+        TestInputStream stream = new TestInputStream(inputStream);\n+        HttpServletRequest request = createHttpServletRequest(\"gzip\", \"POST\");\n+        Mockito.when(request.getInputStream()).thenReturn(stream);\n+        \n+        HttpServletResponse response = Mockito.mock(HttpServletResponse.class);\n+        FilterChain chain = Mockito.mock(FilterChain.class);\n+\n+        \n+        subject.doFilter(request, response, chain);\n+\n+        // Request should be wrapped, so the request should now be a GzippedInputStreamWrapper\n+        ArgumentCaptor<RequestBodyGZipFilter.GzippedInputStreamWrapper> requestArg =\n+            ArgumentCaptor.forClass(RequestBodyGZipFilter.GzippedInputStreamWrapper.class);\n+        ArgumentCaptor<HttpServletResponse> responseArg = ArgumentCaptor.forClass(HttpServletResponse.class);\n+        Mockito.verify(chain, Mockito.times(1)).doFilter(requestArg.capture(), responseArg.capture());\n+        RequestBodyGZipFilter.GzippedInputStreamWrapper wrappedStream = requestArg.getValue();\n+        \n+        String actualRequestBody = wrappedStream.getReader().lines().collect(Collectors.joining());\n+        String expectedRequestBody = \"{\\\"field\\\":\\\"value\\\"}\";\n+        Assert.assertEquals(expectedRequestBody, actualRequestBody);\n+    }\n+\n+    /**\n+     * When I filter a request that has the gzip header and the gzip\n+     * feature is enabled and the method is POST, but the unzipped message\n+     * body is larger than maxInflatedRequestBodySize, the doFilter method\n+     * should wrap the request with a GzippedInputStreamWrapper.\n+     * The BufferedReader for this GzippedInputStreamWrapper should throw an\n+     * IOException as it is read. This exception gets turned into\n+     * an UncheckedIOException by something, so we'll check for that instead.\n+     */\n+    @Test(expected = UncheckedIOException.class)\n+    public void testDoFilterEnabledGZippedButTooLong() throws Exception {\n+        RequestBodyGZipFilter subject = createRequestBodyGZipFilter(true, 1);\n+\n+        FileInputStream inputStream = new FileInputStream(\"src/test/resources/gzip_filter.json.gz\");\n+        TestInputStream stream = new TestInputStream(inputStream);\n+        HttpServletRequest request = createHttpServletRequest(\"gzip\", \"POST\");\n+        Mockito.when(request.getInputStream()).thenReturn(stream);\n+\n+        HttpServletResponse response = Mockito.mock(HttpServletResponse.class);\n+        FilterChain chain = Mockito.mock(FilterChain.class);\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9336b4cd7903af2e634b638f152f78f277cee580"}, "originalPosition": 128}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM5ODI5NDE3OnYy", "diffSide": "RIGHT", "path": "docs/portal.properties-Reference.md", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMVQxNzoyMzoxNVrOIECc4A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMVQxNzoyMzoxNVrOIECc4A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTEwNTM3Ng==", "bodyText": "maybe \"short-term solution\" (because when sample lists are 300000 samples we will again see this problem even with compression)", "url": "https://github.com/cBioPortal/cbioportal/pull/8099#discussion_r541105376", "createdAt": "2020-12-11T17:23:15Z", "author": {"login": "sheridancbio"}, "path": "docs/portal.properties-Reference.md", "diffHunk": "@@ -416,3 +417,44 @@ For more information on how Ehcache is implemented in cBioPortal refer to the [C\n ```\n skin.show_gsva=true\n ```\n+\n+# Request Body Compression\n+\n+## Background\n+Some REST endpoints that the cBioPortal frontend uses have request bodies that scale as your dataset increases. In\n+portals where users commonly query more than 100,000 samples, we found that some of these request bodies could\n+get as large as 20 Mb. These large request bodies pose a significant problem for users with poor upload speeds - some\n+users experienced upload times of more than five minutes for these requests. Request body compression is our solution to", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9336b4cd7903af2e634b638f152f78f277cee580"}, "originalPosition": 19}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM5ODMwMzA4OnYy", "diffSide": "RIGHT", "path": "docs/portal.properties-Reference.md", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMVQxNzoyNToyM1rOIECiEA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMVQxNzoyNToyM1rOIECiEA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTEwNjcwNA==", "bodyText": "good catch / comment", "url": "https://github.com/cBioPortal/cbioportal/pull/8099#discussion_r541106704", "createdAt": "2020-12-11T17:25:23Z", "author": {"login": "sheridancbio"}, "path": "docs/portal.properties-Reference.md", "diffHunk": "@@ -416,3 +417,44 @@ For more information on how Ehcache is implemented in cBioPortal refer to the [C\n ```\n skin.show_gsva=true\n ```\n+\n+# Request Body Compression\n+\n+## Background\n+Some REST endpoints that the cBioPortal frontend uses have request bodies that scale as your dataset increases. In\n+portals where users commonly query more than 100,000 samples, we found that some of these request bodies could\n+get as large as 20 Mb. These large request bodies pose a significant problem for users with poor upload speeds - some\n+users experienced upload times of more than five minutes for these requests. Request body compression is our solution to\n+this problem. When this feature is toggled on, we compress the request bodies of a few problematic endpoints.\n+\n+## Properties\n+There are two `portal.property` values related to this feature:\n+- `enable_request_body_compression`: when `true`, the feature will be enabled.\n+- `request_gzip_body_size_bytes`: the maximum allowable unzipped request body in bytes. Defaults to 50000000 (50 Mb).\n+\n+## Behavior\n+- This is a nonbreaking change. Any consumers of the cBioPortal API you have that send requests with uncompressed request\n+bodies will continue to work, regardless of whether you turn this feature on or off.\n+- If you turn this feature on, the cBioPortal API will now be able to handle any request with a gzipped request body,\n+provided:\n+  - It is a POST request.\n+  - It has a `Content-Encoding: gzip` header.\n+\n+## Reasons to Enable This Feature\n+- You have studies with tens of thousands of samples.\n+- You have users with poor upload speeds (< 1mb up).\n+\n+## Reasons to Disable This Feature\n+- It is harder to debug gzipped requests", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9336b4cd7903af2e634b638f152f78f277cee580"}, "originalPosition": 40}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM5ODMxNDgxOnYy", "diffSide": "RIGHT", "path": "docs/portal.properties-Reference.md", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMVQxNzoyODowNVrOIECo1w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMVQxNzoyODowNVrOIECo1w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTEwODQzOQ==", "bodyText": "right .. we need to find a way to stop sending very long identifier lists if we really want to improve performance for everybody", "url": "https://github.com/cBioPortal/cbioportal/pull/8099#discussion_r541108439", "createdAt": "2020-12-11T17:28:05Z", "author": {"login": "sheridancbio"}, "path": "docs/portal.properties-Reference.md", "diffHunk": "@@ -416,3 +417,44 @@ For more information on how Ehcache is implemented in cBioPortal refer to the [C\n ```\n skin.show_gsva=true\n ```\n+\n+# Request Body Compression\n+\n+## Background\n+Some REST endpoints that the cBioPortal frontend uses have request bodies that scale as your dataset increases. In\n+portals where users commonly query more than 100,000 samples, we found that some of these request bodies could\n+get as large as 20 Mb. These large request bodies pose a significant problem for users with poor upload speeds - some\n+users experienced upload times of more than five minutes for these requests. Request body compression is our solution to\n+this problem. When this feature is toggled on, we compress the request bodies of a few problematic endpoints.\n+\n+## Properties\n+There are two `portal.property` values related to this feature:\n+- `enable_request_body_compression`: when `true`, the feature will be enabled.\n+- `request_gzip_body_size_bytes`: the maximum allowable unzipped request body in bytes. Defaults to 50000000 (50 Mb).\n+\n+## Behavior\n+- This is a nonbreaking change. Any consumers of the cBioPortal API you have that send requests with uncompressed request\n+bodies will continue to work, regardless of whether you turn this feature on or off.\n+- If you turn this feature on, the cBioPortal API will now be able to handle any request with a gzipped request body,\n+provided:\n+  - It is a POST request.\n+  - It has a `Content-Encoding: gzip` header.\n+\n+## Reasons to Enable This Feature\n+- You have studies with tens of thousands of samples.\n+- You have users with poor upload speeds (< 1mb up).\n+\n+## Reasons to Disable This Feature\n+- It is harder to debug gzipped requests\n+  - Chrome's `copy request as CURL` will not work.\n+  - The compressed request body is not human-readable.\n+- It is a potential vector for denial of memory attacks.\n+  - Any request that has a body that takes significantly more space in memory than it does in the request body is\n+    potentially dangerous. We try to mitigate this by limiting the size of the unzipped request body via the\n+    `request_gzip_body_size_bytes` property, but at a fundamental level, this is still a concern.\n+  - Along these lines, if you do enable this feature, setting `request_gzip_body_size_bytes` to an arbitrarily large\n+    number would be unwise.\n+- This is not a cure-all for performance issues\n+  - Most requests the cBioPortal makes do not have large request bodies, so most requests will not be compressed, and\n+    will see no performance improvement.\n+  - Users with good upload speeds will see minimal performance improvements, as their upload speed is not a bottleneck.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9336b4cd7903af2e634b638f152f78f277cee580"}, "originalPosition": 52}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM5ODMyMzI0OnYy", "diffSide": "RIGHT", "path": "portal/src/main/webapp/config_service.jsp", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMVQxNzozMDowOFrOIECtwQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMVQxODo0MjoxM1rOIEFRxQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTEwOTY5Nw==", "bodyText": "I guess this reports the setting of the property to the frontend perhaps?  That way the front end will know whether it can use compression or not. Ok", "url": "https://github.com/cBioPortal/cbioportal/pull/8099#discussion_r541109697", "createdAt": "2020-12-11T17:30:08Z", "author": {"login": "sheridancbio"}, "path": "portal/src/main/webapp/config_service.jsp", "diffHunk": "@@ -114,6 +114,7 @@\n             \"oncoprint.custom_driver_annotation.tiers.default\",\n             \"ensembl.transcript_url\",\n             \"enable_persistent_cache\",\n+            \"enable_request_body_compression\",", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9336b4cd7903af2e634b638f152f78f277cee580"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTE1MTY4NQ==", "bodyText": "Exactly.", "url": "https://github.com/cBioPortal/cbioportal/pull/8099#discussion_r541151685", "createdAt": "2020-12-11T18:42:13Z", "author": {"login": "Luke-Sikina"}, "path": "portal/src/main/webapp/config_service.jsp", "diffHunk": "@@ -114,6 +114,7 @@\n             \"oncoprint.custom_driver_annotation.tiers.default\",\n             \"ensembl.transcript_url\",\n             \"enable_persistent_cache\",\n+            \"enable_request_body_compression\",", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTEwOTY5Nw=="}, "originalCommit": {"oid": "9336b4cd7903af2e634b638f152f78f277cee580"}, "originalPosition": 4}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3496, "cost": 1, "resetAt": "2021-11-12T18:49:56Z"}}}