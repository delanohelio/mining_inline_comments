{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0Mzg0NDU2NDY3", "number": 7270, "reviewThreads": {"totalCount": 36, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMlQxOTowMDozNVrODnlpVw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yM1QxNzoxOToyOFrODqedjQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQyODM3ODQ3OnYy", "diffSide": "RIGHT", "path": "docs/File-Formats.md", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMlQxOTowMDozNVrOF1raQQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMlQxOTowMDozNVrOF1raQQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTgzMDA4MQ==", "bodyText": "would be good to elaborate a bit more what resources are e.g. similar to the RFC:\nResources are URIs that can point to:\n\nFiles: pdf, txt, png, json, etc.\nWeb links: non-file links e.g. URLs to other systems", "url": "https://github.com/cBioPortal/cbioportal/pull/7270#discussion_r391830081", "createdAt": "2020-03-12T19:00:35Z", "author": {"login": "inodb"}, "path": "docs/File-Formats.md", "diffHunk": "@@ -1375,3 +1376,88 @@ Example with 2 generic entities and 3 samples:\n <tr><td>mut_sig_mean</td><td>name of mean</td><td>description of mean</td><td>0.370</td><td>0.010</td><td>0.005</td></tr>\n <tr><td>mut_sig_confidence</td><td>name of confidence</td><td>description of confidence</td><td>0.653</td><td>0.066</td><td>0.050</td></tr>\n </table>\n+\n+## Resource Data\n+\n+The resource data is used to capture resouce data in patients, samples and studies.  ", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "40cec718fc69678e066b4100e162f79234f7e63f"}, "originalPosition": 15}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQyODM4MjU2OnYy", "diffSide": "RIGHT", "path": "docs/File-Formats.md", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMlQxOTowMTozNlrOF1rciw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMlQxOTowNzozM1rOF1rnqQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTgzMDY2Nw==", "bodyText": "good to run a spellchecker e.g. difinition -> definition", "url": "https://github.com/cBioPortal/cbioportal/pull/7270#discussion_r391830667", "createdAt": "2020-03-12T19:01:36Z", "author": {"login": "inodb"}, "path": "docs/File-Formats.md", "diffHunk": "@@ -1375,3 +1376,88 @@ Example with 2 generic entities and 3 samples:\n <tr><td>mut_sig_mean</td><td>name of mean</td><td>description of mean</td><td>0.370</td><td>0.010</td><td>0.005</td></tr>\n <tr><td>mut_sig_confidence</td><td>name of confidence</td><td>description of confidence</td><td>0.653</td><td>0.066</td><td>0.050</td></tr>\n </table>\n+\n+## Resource Data\n+\n+The resource data is used to capture resouce data in patients, samples and studies.  \n+\n+the resource file is split into a resource difinition file, sample resource file, patient resource file and study resource file. All data files are required to have a matching meta file.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "40cec718fc69678e066b4100e162f79234f7e63f"}, "originalPosition": 17}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTgzMTM1MA==", "bodyText": "a command line checker is aspell https://www.howtoforge.com/linux-aspell-command/", "url": "https://github.com/cBioPortal/cbioportal/pull/7270#discussion_r391831350", "createdAt": "2020-03-12T19:03:10Z", "author": {"login": "inodb"}, "path": "docs/File-Formats.md", "diffHunk": "@@ -1375,3 +1376,88 @@ Example with 2 generic entities and 3 samples:\n <tr><td>mut_sig_mean</td><td>name of mean</td><td>description of mean</td><td>0.370</td><td>0.010</td><td>0.005</td></tr>\n <tr><td>mut_sig_confidence</td><td>name of confidence</td><td>description of confidence</td><td>0.653</td><td>0.066</td><td>0.050</td></tr>\n </table>\n+\n+## Resource Data\n+\n+The resource data is used to capture resouce data in patients, samples and studies.  \n+\n+the resource file is split into a resource difinition file, sample resource file, patient resource file and study resource file. All data files are required to have a matching meta file.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTgzMDY2Nw=="}, "originalCommit": {"oid": "40cec718fc69678e066b4100e162f79234f7e63f"}, "originalPosition": 17}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTgzMTU5Nw==", "bodyText": "we could maybe add that one as part of CI at some point \u261d\ufe0f", "url": "https://github.com/cBioPortal/cbioportal/pull/7270#discussion_r391831597", "createdAt": "2020-03-12T19:03:36Z", "author": {"login": "inodb"}, "path": "docs/File-Formats.md", "diffHunk": "@@ -1375,3 +1376,88 @@ Example with 2 generic entities and 3 samples:\n <tr><td>mut_sig_mean</td><td>name of mean</td><td>description of mean</td><td>0.370</td><td>0.010</td><td>0.005</td></tr>\n <tr><td>mut_sig_confidence</td><td>name of confidence</td><td>description of confidence</td><td>0.653</td><td>0.066</td><td>0.050</td></tr>\n </table>\n+\n+## Resource Data\n+\n+The resource data is used to capture resouce data in patients, samples and studies.  \n+\n+the resource file is split into a resource difinition file, sample resource file, patient resource file and study resource file. All data files are required to have a matching meta file.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTgzMDY2Nw=="}, "originalCommit": {"oid": "40cec718fc69678e066b4100e162f79234f7e63f"}, "originalPosition": 17}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTgzMzUxMw==", "bodyText": "This is pretty cool, good to know this!", "url": "https://github.com/cBioPortal/cbioportal/pull/7270#discussion_r391833513", "createdAt": "2020-03-12T19:07:33Z", "author": {"login": "dippindots"}, "path": "docs/File-Formats.md", "diffHunk": "@@ -1375,3 +1376,88 @@ Example with 2 generic entities and 3 samples:\n <tr><td>mut_sig_mean</td><td>name of mean</td><td>description of mean</td><td>0.370</td><td>0.010</td><td>0.005</td></tr>\n <tr><td>mut_sig_confidence</td><td>name of confidence</td><td>description of confidence</td><td>0.653</td><td>0.066</td><td>0.050</td></tr>\n </table>\n+\n+## Resource Data\n+\n+The resource data is used to capture resouce data in patients, samples and studies.  \n+\n+the resource file is split into a resource difinition file, sample resource file, patient resource file and study resource file. All data files are required to have a matching meta file.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTgzMDY2Nw=="}, "originalCommit": {"oid": "40cec718fc69678e066b4100e162f79234f7e63f"}, "originalPosition": 17}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQyODM5NDY3OnYy", "diffSide": "RIGHT", "path": "core/src/test/scripts/test_data/study_es_0/result_report.html", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMlQxOTowNTo1NVrOF1rknw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMlQxOTowNTo1NVrOF1rknw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTgzMjczNQ==", "bodyText": "still a bit weird i think that the whole report is checked in as part of testing - we should prolly test specific things inside of the report after parsing it. But this works for now", "url": "https://github.com/cBioPortal/cbioportal/pull/7270#discussion_r391832735", "createdAt": "2020-03-12T19:05:55Z", "author": {"login": "inodb"}, "path": "core/src/test/scripts/test_data/study_es_0/result_report.html", "diffHunk": "@@ -1279,6 +1279,218 @@ <h4 class=\"panel-title\">data_mutations_extended.maf</h4>\n         </div>\n       </div>\n \n+      <div class=\"panel panel-success\">", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "40cec718fc69678e066b4100e162f79234f7e63f"}, "originalPosition": 4}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQyODM5Nzk3OnYy", "diffSide": "RIGHT", "path": "core/src/main/java/org/mskcc/cbio/portal/scripts/ImportResourceData.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMlQxOTowNzowNVrOF1rm0Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xM1QxNzozMTozOFrOF2MgZA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTgzMzI5Nw==", "bodyText": "are these missing values different from some other enum already in the code? This seems like something that's not resource specific", "url": "https://github.com/cBioPortal/cbioportal/pull/7270#discussion_r391833297", "createdAt": "2020-03-12T19:07:05Z", "author": {"login": "inodb"}, "path": "core/src/main/java/org/mskcc/cbio/portal/scripts/ImportResourceData.java", "diffHunk": "@@ -0,0 +1,618 @@\n+package org.mskcc.cbio.portal.scripts;\n+\n+import org.mskcc.cbio.portal.dao.*;\n+import org.mskcc.cbio.portal.model.*;\n+import org.mskcc.cbio.portal.util.*;\n+\n+import java.io.*;\n+import joptsimple.*;\n+import java.util.*;\n+import java.util.regex.*;\n+import java.util.stream.Collectors;\n+\n+import org.apache.commons.collections.map.MultiKeyMap;\n+\n+public class ImportResourceData extends ConsoleRunnable {\n+\n+    public static final String DELIMITER = \"\\t\";\n+    public static final String METADATA_PREFIX = \"#\";\n+    public static final String SAMPLE_ID_COLUMN_NAME = \"SAMPLE_ID\";\n+    public static final String PATIENT_ID_COLUMN_NAME = \"PATIENT_ID\";\n+    public static final String RESOURCE_ID_COLUMN_NAME = \"RESOURCE_ID\";\n+    public static final String URL_COLUMN_NAME = \"URL\";\n+    public static final String SAMPLE_TYPE_COLUMN_NAME = \"SAMPLE_TYPE\";\n+    private int numSampleSpecificResourcesAdded = 0;\n+    private int numPatientSpecificResourcesAdded = 0;\n+    private int numStudySpecificResourcesAdded = 0;\n+    private int numEmptyResourcesSkipped = 0;\n+    private int numSamplesProcessed = 0;\n+\n+    private static Properties properties;\n+\n+    private File resourceDataFile;\n+    private CancerStudy cancerStudy;\n+    private ResourceTypes resourceType;\n+    private boolean relaxed;\n+    private Set<String> patientIds = new HashSet<String>();\n+\n+    public static enum MissingResourceValues {\n+        NOT_APPLICABLE(\"Not Applicable\"), NOT_AVAILABLE(\"Not Available\"), PENDING(\"Pending\"),\n+        DISCREPANCY(\"Discrepancy\"), COMPLETED(\"Completed\"), NULL(\"null\"), MISSING(\"\"), NA(\"NA\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "40cec718fc69678e066b4100e162f79234f7e63f"}, "originalPosition": 40}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTgzNDUwMQ==", "bodyText": "No, I borrow the same definition from the Clinical Data. I can import it from that class also.", "url": "https://github.com/cBioPortal/cbioportal/pull/7270#discussion_r391834501", "createdAt": "2020-03-12T19:09:35Z", "author": {"login": "dippindots"}, "path": "core/src/main/java/org/mskcc/cbio/portal/scripts/ImportResourceData.java", "diffHunk": "@@ -0,0 +1,618 @@\n+package org.mskcc.cbio.portal.scripts;\n+\n+import org.mskcc.cbio.portal.dao.*;\n+import org.mskcc.cbio.portal.model.*;\n+import org.mskcc.cbio.portal.util.*;\n+\n+import java.io.*;\n+import joptsimple.*;\n+import java.util.*;\n+import java.util.regex.*;\n+import java.util.stream.Collectors;\n+\n+import org.apache.commons.collections.map.MultiKeyMap;\n+\n+public class ImportResourceData extends ConsoleRunnable {\n+\n+    public static final String DELIMITER = \"\\t\";\n+    public static final String METADATA_PREFIX = \"#\";\n+    public static final String SAMPLE_ID_COLUMN_NAME = \"SAMPLE_ID\";\n+    public static final String PATIENT_ID_COLUMN_NAME = \"PATIENT_ID\";\n+    public static final String RESOURCE_ID_COLUMN_NAME = \"RESOURCE_ID\";\n+    public static final String URL_COLUMN_NAME = \"URL\";\n+    public static final String SAMPLE_TYPE_COLUMN_NAME = \"SAMPLE_TYPE\";\n+    private int numSampleSpecificResourcesAdded = 0;\n+    private int numPatientSpecificResourcesAdded = 0;\n+    private int numStudySpecificResourcesAdded = 0;\n+    private int numEmptyResourcesSkipped = 0;\n+    private int numSamplesProcessed = 0;\n+\n+    private static Properties properties;\n+\n+    private File resourceDataFile;\n+    private CancerStudy cancerStudy;\n+    private ResourceTypes resourceType;\n+    private boolean relaxed;\n+    private Set<String> patientIds = new HashSet<String>();\n+\n+    public static enum MissingResourceValues {\n+        NOT_APPLICABLE(\"Not Applicable\"), NOT_AVAILABLE(\"Not Available\"), PENDING(\"Pending\"),\n+        DISCREPANCY(\"Discrepancy\"), COMPLETED(\"Completed\"), NULL(\"null\"), MISSING(\"\"), NA(\"NA\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTgzMzI5Nw=="}, "originalCommit": {"oid": "40cec718fc69678e066b4100e162f79234f7e63f"}, "originalPosition": 40}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTg0MTIyNA==", "bodyText": "yeah there can maybe be some shared class with common N/A values. I do think some of these don't really look like N/A to me, e.g. Discrepancy, Pending and Completed. That seems very specific to some pipeline that we have set up", "url": "https://github.com/cBioPortal/cbioportal/pull/7270#discussion_r391841224", "createdAt": "2020-03-12T19:23:11Z", "author": {"login": "inodb"}, "path": "core/src/main/java/org/mskcc/cbio/portal/scripts/ImportResourceData.java", "diffHunk": "@@ -0,0 +1,618 @@\n+package org.mskcc.cbio.portal.scripts;\n+\n+import org.mskcc.cbio.portal.dao.*;\n+import org.mskcc.cbio.portal.model.*;\n+import org.mskcc.cbio.portal.util.*;\n+\n+import java.io.*;\n+import joptsimple.*;\n+import java.util.*;\n+import java.util.regex.*;\n+import java.util.stream.Collectors;\n+\n+import org.apache.commons.collections.map.MultiKeyMap;\n+\n+public class ImportResourceData extends ConsoleRunnable {\n+\n+    public static final String DELIMITER = \"\\t\";\n+    public static final String METADATA_PREFIX = \"#\";\n+    public static final String SAMPLE_ID_COLUMN_NAME = \"SAMPLE_ID\";\n+    public static final String PATIENT_ID_COLUMN_NAME = \"PATIENT_ID\";\n+    public static final String RESOURCE_ID_COLUMN_NAME = \"RESOURCE_ID\";\n+    public static final String URL_COLUMN_NAME = \"URL\";\n+    public static final String SAMPLE_TYPE_COLUMN_NAME = \"SAMPLE_TYPE\";\n+    private int numSampleSpecificResourcesAdded = 0;\n+    private int numPatientSpecificResourcesAdded = 0;\n+    private int numStudySpecificResourcesAdded = 0;\n+    private int numEmptyResourcesSkipped = 0;\n+    private int numSamplesProcessed = 0;\n+\n+    private static Properties properties;\n+\n+    private File resourceDataFile;\n+    private CancerStudy cancerStudy;\n+    private ResourceTypes resourceType;\n+    private boolean relaxed;\n+    private Set<String> patientIds = new HashSet<String>();\n+\n+    public static enum MissingResourceValues {\n+        NOT_APPLICABLE(\"Not Applicable\"), NOT_AVAILABLE(\"Not Available\"), PENDING(\"Pending\"),\n+        DISCREPANCY(\"Discrepancy\"), COMPLETED(\"Completed\"), NULL(\"null\"), MISSING(\"\"), NA(\"NA\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTgzMzI5Nw=="}, "originalCommit": {"oid": "40cec718fc69678e066b4100e162f79234f7e63f"}, "originalPosition": 40}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjM3MjMyNA==", "bodyText": "@inodb I haven't found common null values in the project, so I created one ValuesUtils.java", "url": "https://github.com/cBioPortal/cbioportal/pull/7270#discussion_r392372324", "createdAt": "2020-03-13T17:31:38Z", "author": {"login": "dippindots"}, "path": "core/src/main/java/org/mskcc/cbio/portal/scripts/ImportResourceData.java", "diffHunk": "@@ -0,0 +1,618 @@\n+package org.mskcc.cbio.portal.scripts;\n+\n+import org.mskcc.cbio.portal.dao.*;\n+import org.mskcc.cbio.portal.model.*;\n+import org.mskcc.cbio.portal.util.*;\n+\n+import java.io.*;\n+import joptsimple.*;\n+import java.util.*;\n+import java.util.regex.*;\n+import java.util.stream.Collectors;\n+\n+import org.apache.commons.collections.map.MultiKeyMap;\n+\n+public class ImportResourceData extends ConsoleRunnable {\n+\n+    public static final String DELIMITER = \"\\t\";\n+    public static final String METADATA_PREFIX = \"#\";\n+    public static final String SAMPLE_ID_COLUMN_NAME = \"SAMPLE_ID\";\n+    public static final String PATIENT_ID_COLUMN_NAME = \"PATIENT_ID\";\n+    public static final String RESOURCE_ID_COLUMN_NAME = \"RESOURCE_ID\";\n+    public static final String URL_COLUMN_NAME = \"URL\";\n+    public static final String SAMPLE_TYPE_COLUMN_NAME = \"SAMPLE_TYPE\";\n+    private int numSampleSpecificResourcesAdded = 0;\n+    private int numPatientSpecificResourcesAdded = 0;\n+    private int numStudySpecificResourcesAdded = 0;\n+    private int numEmptyResourcesSkipped = 0;\n+    private int numSamplesProcessed = 0;\n+\n+    private static Properties properties;\n+\n+    private File resourceDataFile;\n+    private CancerStudy cancerStudy;\n+    private ResourceTypes resourceType;\n+    private boolean relaxed;\n+    private Set<String> patientIds = new HashSet<String>();\n+\n+    public static enum MissingResourceValues {\n+        NOT_APPLICABLE(\"Not Applicable\"), NOT_AVAILABLE(\"Not Available\"), PENDING(\"Pending\"),\n+        DISCREPANCY(\"Discrepancy\"), COMPLETED(\"Completed\"), NULL(\"null\"), MISSING(\"\"), NA(\"NA\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTgzMzI5Nw=="}, "originalCommit": {"oid": "40cec718fc69678e066b4100e162f79234f7e63f"}, "originalPosition": 40}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQyOTA0Mzk0OnYy", "diffSide": "RIGHT", "path": "core/src/main/java/org/mskcc/cbio/portal/scripts/ImportResourceData.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMlQyMjowMDo0OVrOF1xfBw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xM1QxNDoxNzozNFrOF2FWgg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTkyOTYwNw==", "bodyText": "I would break these lines into multiple lines", "url": "https://github.com/cBioPortal/cbioportal/pull/7270#discussion_r391929607", "createdAt": "2020-03-12T22:00:49Z", "author": {"login": "onursumer"}, "path": "core/src/main/java/org/mskcc/cbio/portal/scripts/ImportResourceData.java", "diffHunk": "@@ -0,0 +1,618 @@\n+package org.mskcc.cbio.portal.scripts;\n+\n+import org.mskcc.cbio.portal.dao.*;\n+import org.mskcc.cbio.portal.model.*;\n+import org.mskcc.cbio.portal.util.*;\n+\n+import java.io.*;\n+import joptsimple.*;\n+import java.util.*;\n+import java.util.regex.*;\n+import java.util.stream.Collectors;\n+\n+import org.apache.commons.collections.map.MultiKeyMap;\n+\n+public class ImportResourceData extends ConsoleRunnable {\n+\n+    public static final String DELIMITER = \"\\t\";\n+    public static final String METADATA_PREFIX = \"#\";\n+    public static final String SAMPLE_ID_COLUMN_NAME = \"SAMPLE_ID\";\n+    public static final String PATIENT_ID_COLUMN_NAME = \"PATIENT_ID\";\n+    public static final String RESOURCE_ID_COLUMN_NAME = \"RESOURCE_ID\";\n+    public static final String URL_COLUMN_NAME = \"URL\";\n+    public static final String SAMPLE_TYPE_COLUMN_NAME = \"SAMPLE_TYPE\";\n+    private int numSampleSpecificResourcesAdded = 0;\n+    private int numPatientSpecificResourcesAdded = 0;\n+    private int numStudySpecificResourcesAdded = 0;\n+    private int numEmptyResourcesSkipped = 0;\n+    private int numSamplesProcessed = 0;\n+\n+    private static Properties properties;\n+\n+    private File resourceDataFile;\n+    private CancerStudy cancerStudy;\n+    private ResourceTypes resourceType;\n+    private boolean relaxed;\n+    private Set<String> patientIds = new HashSet<String>();\n+\n+    public static enum MissingResourceValues {\n+        NOT_APPLICABLE(\"Not Applicable\"), NOT_AVAILABLE(\"Not Available\"), PENDING(\"Pending\"),\n+        DISCREPANCY(\"Discrepancy\"), COMPLETED(\"Completed\"), NULL(\"null\"), MISSING(\"\"), NA(\"NA\");\n+\n+        private String propertyName;\n+\n+        MissingResourceValues(String propertyName) {\n+            this.propertyName = propertyName;\n+        }\n+\n+        public String toString() {\n+            return propertyName;\n+        }\n+\n+        static public boolean has(String value) {\n+            if (value == null)\n+                return false;\n+            if (value.trim().equals(\"\"))\n+                return true;\n+            try {\n+                value = value.replaceAll(\"[\\\\[|\\\\]]\", \"\");\n+                value = value.replaceAll(\" \", \"_\");\n+                return valueOf(value.toUpperCase()) != null;\n+            } catch (IllegalArgumentException x) {\n+                return false;\n+            }\n+        }\n+\n+        static public String getNotAvailable() {\n+            return \"[\" + NOT_AVAILABLE.toString() + \"]\";\n+        }\n+    }\n+\n+    public static enum ResourceTypes {\n+        PATIENT(\"PATIENT\"), SAMPLE(\"SAMPLE\"), STUDY(\"STUDY\");\n+\n+        private String resourceTypes;\n+\n+        ResourceTypes(String resourceTypes) {\n+            this.resourceTypes = resourceTypes;\n+        }\n+\n+        public String toString() {\n+            return resourceTypes;\n+        }\n+    }\n+\n+    public void setFile(CancerStudy cancerStudy, File resourceDataFile, String resourceType, boolean relaxed) {\n+        this.cancerStudy = cancerStudy;\n+        this.resourceDataFile = resourceDataFile;\n+        this.resourceType = ResourceTypes.valueOf(resourceType);\n+        this.relaxed = relaxed;\n+    }\n+\n+    public void importData() throws Exception {\n+        // if bulkLoading is ever turned off,\n+        // code has to be added to check whether\n+        // a resource data update should be\n+        // perform instead of an insert\n+        MySQLbulkLoader.bulkLoadOn();\n+\n+        if (relaxed) {\n+            MySQLbulkLoader.relaxedModeOn();\n+        }\n+\n+        FileReader reader = new FileReader(resourceDataFile);\n+        BufferedReader buff = new BufferedReader(reader);\n+        List<ResourceDefinition> resources = grabResources(buff);\n+        String currentLine = buff.readLine();\n+        String[] headerNames = currentLine.split(\"\\t\");\n+        \n+        int patientIdIndex = findPatientIdColumn(headerNames);\n+        int sampleIdIndex = findSampleIdColumn(headerNames);\n+        int resourceIdIndex = findResourceIdColumn(headerNames);\n+        int urlIndex = findURLColumn(headerNames);\n+\n+        // validate required columns:\n+        if (resourceIdIndex < 0) {\n+            throw new RuntimeException(\"Aborting owing to failure to find \" + RESOURCE_ID_COLUMN_NAME\n+                    + \" in file. Please check your file format and try again.\");\n+        }\n+        if (urlIndex < 0) {\n+            throw new RuntimeException(\"Aborting owing to failure to find \" + URL_COLUMN_NAME\n+                    + \" in file. Please check your file format and try again.\");\n+        }\n+        if ((resourceType.toString().equalsIgnoreCase(\"sample\") || resourceType.toString().equalsIgnoreCase(\"patient\")) && patientIdIndex < 0) {\n+            // PATIENT_ID is required in both patient and sample file types:\n+            throw new RuntimeException(\"Aborting owing to failure to find \" + PATIENT_ID_COLUMN_NAME\n+                    + \" in file. Please check your file format and try again.\");\n+        }\n+        if (resourceType.toString().equalsIgnoreCase(\"sample\") && sampleIdIndex < 0) {\n+            // SAMPLE_ID is required in SAMPLE file type:\n+            throw new RuntimeException(\"Aborting owing to failure to find \" + SAMPLE_ID_COLUMN_NAME\n+                    + \" in file. Please check your file format and try again.\");\n+        }\n+        importData(buff, resources, headerNames);\n+\n+        if (MySQLbulkLoader.isBulkLoad()) {\n+            MySQLbulkLoader.flushAll();\n+            MySQLbulkLoader.relaxedModeOff();\n+        }\n+    }\n+\n+    private List<ResourceDefinition> grabResources(BufferedReader buff) throws DaoException, IOException {\n+        List<ResourceDefinition> resources = new ArrayList<ResourceDefinition>();\n+        resources = DaoResourceDefinition.getDatumByStudy(cancerStudy.getInternalId());\n+        return resources;\n+    }\n+\n+    private String[] splitFields(String line) throws IOException {\n+        line = line.replaceAll(\"^\" + METADATA_PREFIX + \"+\", \"\");\n+        String[] fields = line.split(DELIMITER, -1);\n+\n+        return fields;\n+    }\n+\n+    private void importData(BufferedReader buff, List<ResourceDefinition> resources, String[] headerNames) throws Exception {\n+        String line;\n+        MultiKeyMap resourceMap = new MultiKeyMap();\n+        while ((line = buff.readLine()) != null) {\n+            if (skipLine(line.trim())) {\n+                continue;\n+            }\n+\n+            String[] fieldValues = getFieldValues(line, headerNames);\n+            addDatum(fieldValues, resources, resourceMap, headerNames);\n+        }\n+    }\n+\n+    private boolean skipLine(String line) {\n+        return (line.isEmpty() || line.substring(0, 1).equals(METADATA_PREFIX));\n+    }\n+\n+    /**\n+     * Takes in the given line and returns the list of field values by splitting the\n+     * line on DELIMITER.\n+     * \n+     * @param line\n+     * @param headerNames\n+     * @return the list of values, one for each column. Value will be \"\" for empty\n+     *         columns.\n+     */\n+    private String[] getFieldValues(String line, String[] headerNames) {\n+        // split on delimiter:\n+        String[] fieldValues = line.split(DELIMITER, -1);\n+\n+        // validate: if number of fields is incorrect, give exception\n+        if (fieldValues.length != headerNames.length) {\n+            throw new IllegalArgumentException(\"Number of columns in line is not as expected. Expected: \"\n+                    + headerNames.length + \" columns, found: \" + fieldValues.length + \", for line: \" + line);\n+        }\n+\n+        // now iterate over lines and trim each value:\n+        for (int i = 0; i < fieldValues.length; i++) {\n+            fieldValues[i] = fieldValues[i].trim();\n+        }\n+        return fieldValues;\n+    }\n+\n+    private boolean addDatum(String[] fields, List<ResourceDefinition> resources, MultiKeyMap resourceMap, String[] headerNames)\n+            throws Exception {\n+        int sampleIdIndex = findSampleIdColumn(headerNames);\n+        String stableSampleId = (sampleIdIndex >= 0) ? fields[sampleIdIndex] : \"\";\n+        stableSampleId = StableIdUtil.getSampleId(stableSampleId);\n+        int patientIdIndex = findPatientIdColumn(headerNames);\n+        String stablePatientId = (patientIdIndex >= 0) ? fields[patientIdIndex] : \"\";\n+        stablePatientId = StableIdUtil.getPatientId(stablePatientId);\n+        int resourceIdIndex = findResourceIdColumn(headerNames);\n+        int urlIndex = findURLColumn(headerNames);\n+        int internalSampleId = -1;\n+        int internalPatientId = -1;\n+\n+        // create resource_id set\n+        Set<String> patientResourceIdSet = resources.stream().filter(resource -> resource.getResourceType().equals(ResourceDefinition.PATIENT_RESOURCE_TYPE)).map(resource -> resource.getResourceId()).collect(Collectors.toSet());\n+        Set<String> sampleResourceIdSet = resources.stream().filter(resource -> resource.getResourceType().equals(ResourceDefinition.SAMPLE_RESOURCE_TYPE)).map(resource -> resource.getResourceId()).collect(Collectors.toSet());\n+        Set<String> studyResourceIdSet = resources.stream().filter(resource -> resource.getResourceType().equals(ResourceDefinition.STUDY_RESOURCE_TYPE)).map(resource -> resource.getResourceId()).collect(Collectors.toSet());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "40cec718fc69678e066b4100e162f79234f7e63f"}, "originalPosition": 213}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjI1NTEwNg==", "bodyText": "Yeah, that would be better.", "url": "https://github.com/cBioPortal/cbioportal/pull/7270#discussion_r392255106", "createdAt": "2020-03-13T14:17:34Z", "author": {"login": "dippindots"}, "path": "core/src/main/java/org/mskcc/cbio/portal/scripts/ImportResourceData.java", "diffHunk": "@@ -0,0 +1,618 @@\n+package org.mskcc.cbio.portal.scripts;\n+\n+import org.mskcc.cbio.portal.dao.*;\n+import org.mskcc.cbio.portal.model.*;\n+import org.mskcc.cbio.portal.util.*;\n+\n+import java.io.*;\n+import joptsimple.*;\n+import java.util.*;\n+import java.util.regex.*;\n+import java.util.stream.Collectors;\n+\n+import org.apache.commons.collections.map.MultiKeyMap;\n+\n+public class ImportResourceData extends ConsoleRunnable {\n+\n+    public static final String DELIMITER = \"\\t\";\n+    public static final String METADATA_PREFIX = \"#\";\n+    public static final String SAMPLE_ID_COLUMN_NAME = \"SAMPLE_ID\";\n+    public static final String PATIENT_ID_COLUMN_NAME = \"PATIENT_ID\";\n+    public static final String RESOURCE_ID_COLUMN_NAME = \"RESOURCE_ID\";\n+    public static final String URL_COLUMN_NAME = \"URL\";\n+    public static final String SAMPLE_TYPE_COLUMN_NAME = \"SAMPLE_TYPE\";\n+    private int numSampleSpecificResourcesAdded = 0;\n+    private int numPatientSpecificResourcesAdded = 0;\n+    private int numStudySpecificResourcesAdded = 0;\n+    private int numEmptyResourcesSkipped = 0;\n+    private int numSamplesProcessed = 0;\n+\n+    private static Properties properties;\n+\n+    private File resourceDataFile;\n+    private CancerStudy cancerStudy;\n+    private ResourceTypes resourceType;\n+    private boolean relaxed;\n+    private Set<String> patientIds = new HashSet<String>();\n+\n+    public static enum MissingResourceValues {\n+        NOT_APPLICABLE(\"Not Applicable\"), NOT_AVAILABLE(\"Not Available\"), PENDING(\"Pending\"),\n+        DISCREPANCY(\"Discrepancy\"), COMPLETED(\"Completed\"), NULL(\"null\"), MISSING(\"\"), NA(\"NA\");\n+\n+        private String propertyName;\n+\n+        MissingResourceValues(String propertyName) {\n+            this.propertyName = propertyName;\n+        }\n+\n+        public String toString() {\n+            return propertyName;\n+        }\n+\n+        static public boolean has(String value) {\n+            if (value == null)\n+                return false;\n+            if (value.trim().equals(\"\"))\n+                return true;\n+            try {\n+                value = value.replaceAll(\"[\\\\[|\\\\]]\", \"\");\n+                value = value.replaceAll(\" \", \"_\");\n+                return valueOf(value.toUpperCase()) != null;\n+            } catch (IllegalArgumentException x) {\n+                return false;\n+            }\n+        }\n+\n+        static public String getNotAvailable() {\n+            return \"[\" + NOT_AVAILABLE.toString() + \"]\";\n+        }\n+    }\n+\n+    public static enum ResourceTypes {\n+        PATIENT(\"PATIENT\"), SAMPLE(\"SAMPLE\"), STUDY(\"STUDY\");\n+\n+        private String resourceTypes;\n+\n+        ResourceTypes(String resourceTypes) {\n+            this.resourceTypes = resourceTypes;\n+        }\n+\n+        public String toString() {\n+            return resourceTypes;\n+        }\n+    }\n+\n+    public void setFile(CancerStudy cancerStudy, File resourceDataFile, String resourceType, boolean relaxed) {\n+        this.cancerStudy = cancerStudy;\n+        this.resourceDataFile = resourceDataFile;\n+        this.resourceType = ResourceTypes.valueOf(resourceType);\n+        this.relaxed = relaxed;\n+    }\n+\n+    public void importData() throws Exception {\n+        // if bulkLoading is ever turned off,\n+        // code has to be added to check whether\n+        // a resource data update should be\n+        // perform instead of an insert\n+        MySQLbulkLoader.bulkLoadOn();\n+\n+        if (relaxed) {\n+            MySQLbulkLoader.relaxedModeOn();\n+        }\n+\n+        FileReader reader = new FileReader(resourceDataFile);\n+        BufferedReader buff = new BufferedReader(reader);\n+        List<ResourceDefinition> resources = grabResources(buff);\n+        String currentLine = buff.readLine();\n+        String[] headerNames = currentLine.split(\"\\t\");\n+        \n+        int patientIdIndex = findPatientIdColumn(headerNames);\n+        int sampleIdIndex = findSampleIdColumn(headerNames);\n+        int resourceIdIndex = findResourceIdColumn(headerNames);\n+        int urlIndex = findURLColumn(headerNames);\n+\n+        // validate required columns:\n+        if (resourceIdIndex < 0) {\n+            throw new RuntimeException(\"Aborting owing to failure to find \" + RESOURCE_ID_COLUMN_NAME\n+                    + \" in file. Please check your file format and try again.\");\n+        }\n+        if (urlIndex < 0) {\n+            throw new RuntimeException(\"Aborting owing to failure to find \" + URL_COLUMN_NAME\n+                    + \" in file. Please check your file format and try again.\");\n+        }\n+        if ((resourceType.toString().equalsIgnoreCase(\"sample\") || resourceType.toString().equalsIgnoreCase(\"patient\")) && patientIdIndex < 0) {\n+            // PATIENT_ID is required in both patient and sample file types:\n+            throw new RuntimeException(\"Aborting owing to failure to find \" + PATIENT_ID_COLUMN_NAME\n+                    + \" in file. Please check your file format and try again.\");\n+        }\n+        if (resourceType.toString().equalsIgnoreCase(\"sample\") && sampleIdIndex < 0) {\n+            // SAMPLE_ID is required in SAMPLE file type:\n+            throw new RuntimeException(\"Aborting owing to failure to find \" + SAMPLE_ID_COLUMN_NAME\n+                    + \" in file. Please check your file format and try again.\");\n+        }\n+        importData(buff, resources, headerNames);\n+\n+        if (MySQLbulkLoader.isBulkLoad()) {\n+            MySQLbulkLoader.flushAll();\n+            MySQLbulkLoader.relaxedModeOff();\n+        }\n+    }\n+\n+    private List<ResourceDefinition> grabResources(BufferedReader buff) throws DaoException, IOException {\n+        List<ResourceDefinition> resources = new ArrayList<ResourceDefinition>();\n+        resources = DaoResourceDefinition.getDatumByStudy(cancerStudy.getInternalId());\n+        return resources;\n+    }\n+\n+    private String[] splitFields(String line) throws IOException {\n+        line = line.replaceAll(\"^\" + METADATA_PREFIX + \"+\", \"\");\n+        String[] fields = line.split(DELIMITER, -1);\n+\n+        return fields;\n+    }\n+\n+    private void importData(BufferedReader buff, List<ResourceDefinition> resources, String[] headerNames) throws Exception {\n+        String line;\n+        MultiKeyMap resourceMap = new MultiKeyMap();\n+        while ((line = buff.readLine()) != null) {\n+            if (skipLine(line.trim())) {\n+                continue;\n+            }\n+\n+            String[] fieldValues = getFieldValues(line, headerNames);\n+            addDatum(fieldValues, resources, resourceMap, headerNames);\n+        }\n+    }\n+\n+    private boolean skipLine(String line) {\n+        return (line.isEmpty() || line.substring(0, 1).equals(METADATA_PREFIX));\n+    }\n+\n+    /**\n+     * Takes in the given line and returns the list of field values by splitting the\n+     * line on DELIMITER.\n+     * \n+     * @param line\n+     * @param headerNames\n+     * @return the list of values, one for each column. Value will be \"\" for empty\n+     *         columns.\n+     */\n+    private String[] getFieldValues(String line, String[] headerNames) {\n+        // split on delimiter:\n+        String[] fieldValues = line.split(DELIMITER, -1);\n+\n+        // validate: if number of fields is incorrect, give exception\n+        if (fieldValues.length != headerNames.length) {\n+            throw new IllegalArgumentException(\"Number of columns in line is not as expected. Expected: \"\n+                    + headerNames.length + \" columns, found: \" + fieldValues.length + \", for line: \" + line);\n+        }\n+\n+        // now iterate over lines and trim each value:\n+        for (int i = 0; i < fieldValues.length; i++) {\n+            fieldValues[i] = fieldValues[i].trim();\n+        }\n+        return fieldValues;\n+    }\n+\n+    private boolean addDatum(String[] fields, List<ResourceDefinition> resources, MultiKeyMap resourceMap, String[] headerNames)\n+            throws Exception {\n+        int sampleIdIndex = findSampleIdColumn(headerNames);\n+        String stableSampleId = (sampleIdIndex >= 0) ? fields[sampleIdIndex] : \"\";\n+        stableSampleId = StableIdUtil.getSampleId(stableSampleId);\n+        int patientIdIndex = findPatientIdColumn(headerNames);\n+        String stablePatientId = (patientIdIndex >= 0) ? fields[patientIdIndex] : \"\";\n+        stablePatientId = StableIdUtil.getPatientId(stablePatientId);\n+        int resourceIdIndex = findResourceIdColumn(headerNames);\n+        int urlIndex = findURLColumn(headerNames);\n+        int internalSampleId = -1;\n+        int internalPatientId = -1;\n+\n+        // create resource_id set\n+        Set<String> patientResourceIdSet = resources.stream().filter(resource -> resource.getResourceType().equals(ResourceDefinition.PATIENT_RESOURCE_TYPE)).map(resource -> resource.getResourceId()).collect(Collectors.toSet());\n+        Set<String> sampleResourceIdSet = resources.stream().filter(resource -> resource.getResourceType().equals(ResourceDefinition.SAMPLE_RESOURCE_TYPE)).map(resource -> resource.getResourceId()).collect(Collectors.toSet());\n+        Set<String> studyResourceIdSet = resources.stream().filter(resource -> resource.getResourceType().equals(ResourceDefinition.STUDY_RESOURCE_TYPE)).map(resource -> resource.getResourceId()).collect(Collectors.toSet());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTkyOTYwNw=="}, "originalCommit": {"oid": "40cec718fc69678e066b4100e162f79234f7e63f"}, "originalPosition": 213}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQyOTA1NDUxOnYy", "diffSide": "RIGHT", "path": "core/src/main/java/org/mskcc/cbio/portal/scripts/ImportResourceData.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMlQyMjowNToyM1rOF1xljA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xM1QyMjoyMDoyMFrOF2U-1A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTkzMTI3Ng==", "bodyText": "this else block seems to complex to review", "url": "https://github.com/cBioPortal/cbioportal/pull/7270#discussion_r391931276", "createdAt": "2020-03-12T22:05:23Z", "author": {"login": "onursumer"}, "path": "core/src/main/java/org/mskcc/cbio/portal/scripts/ImportResourceData.java", "diffHunk": "@@ -0,0 +1,618 @@\n+package org.mskcc.cbio.portal.scripts;\n+\n+import org.mskcc.cbio.portal.dao.*;\n+import org.mskcc.cbio.portal.model.*;\n+import org.mskcc.cbio.portal.util.*;\n+\n+import java.io.*;\n+import joptsimple.*;\n+import java.util.*;\n+import java.util.regex.*;\n+import java.util.stream.Collectors;\n+\n+import org.apache.commons.collections.map.MultiKeyMap;\n+\n+public class ImportResourceData extends ConsoleRunnable {\n+\n+    public static final String DELIMITER = \"\\t\";\n+    public static final String METADATA_PREFIX = \"#\";\n+    public static final String SAMPLE_ID_COLUMN_NAME = \"SAMPLE_ID\";\n+    public static final String PATIENT_ID_COLUMN_NAME = \"PATIENT_ID\";\n+    public static final String RESOURCE_ID_COLUMN_NAME = \"RESOURCE_ID\";\n+    public static final String URL_COLUMN_NAME = \"URL\";\n+    public static final String SAMPLE_TYPE_COLUMN_NAME = \"SAMPLE_TYPE\";\n+    private int numSampleSpecificResourcesAdded = 0;\n+    private int numPatientSpecificResourcesAdded = 0;\n+    private int numStudySpecificResourcesAdded = 0;\n+    private int numEmptyResourcesSkipped = 0;\n+    private int numSamplesProcessed = 0;\n+\n+    private static Properties properties;\n+\n+    private File resourceDataFile;\n+    private CancerStudy cancerStudy;\n+    private ResourceTypes resourceType;\n+    private boolean relaxed;\n+    private Set<String> patientIds = new HashSet<String>();\n+\n+    public static enum MissingResourceValues {\n+        NOT_APPLICABLE(\"Not Applicable\"), NOT_AVAILABLE(\"Not Available\"), PENDING(\"Pending\"),\n+        DISCREPANCY(\"Discrepancy\"), COMPLETED(\"Completed\"), NULL(\"null\"), MISSING(\"\"), NA(\"NA\");\n+\n+        private String propertyName;\n+\n+        MissingResourceValues(String propertyName) {\n+            this.propertyName = propertyName;\n+        }\n+\n+        public String toString() {\n+            return propertyName;\n+        }\n+\n+        static public boolean has(String value) {\n+            if (value == null)\n+                return false;\n+            if (value.trim().equals(\"\"))\n+                return true;\n+            try {\n+                value = value.replaceAll(\"[\\\\[|\\\\]]\", \"\");\n+                value = value.replaceAll(\" \", \"_\");\n+                return valueOf(value.toUpperCase()) != null;\n+            } catch (IllegalArgumentException x) {\n+                return false;\n+            }\n+        }\n+\n+        static public String getNotAvailable() {\n+            return \"[\" + NOT_AVAILABLE.toString() + \"]\";\n+        }\n+    }\n+\n+    public static enum ResourceTypes {\n+        PATIENT(\"PATIENT\"), SAMPLE(\"SAMPLE\"), STUDY(\"STUDY\");\n+\n+        private String resourceTypes;\n+\n+        ResourceTypes(String resourceTypes) {\n+            this.resourceTypes = resourceTypes;\n+        }\n+\n+        public String toString() {\n+            return resourceTypes;\n+        }\n+    }\n+\n+    public void setFile(CancerStudy cancerStudy, File resourceDataFile, String resourceType, boolean relaxed) {\n+        this.cancerStudy = cancerStudy;\n+        this.resourceDataFile = resourceDataFile;\n+        this.resourceType = ResourceTypes.valueOf(resourceType);\n+        this.relaxed = relaxed;\n+    }\n+\n+    public void importData() throws Exception {\n+        // if bulkLoading is ever turned off,\n+        // code has to be added to check whether\n+        // a resource data update should be\n+        // perform instead of an insert\n+        MySQLbulkLoader.bulkLoadOn();\n+\n+        if (relaxed) {\n+            MySQLbulkLoader.relaxedModeOn();\n+        }\n+\n+        FileReader reader = new FileReader(resourceDataFile);\n+        BufferedReader buff = new BufferedReader(reader);\n+        List<ResourceDefinition> resources = grabResources(buff);\n+        String currentLine = buff.readLine();\n+        String[] headerNames = currentLine.split(\"\\t\");\n+        \n+        int patientIdIndex = findPatientIdColumn(headerNames);\n+        int sampleIdIndex = findSampleIdColumn(headerNames);\n+        int resourceIdIndex = findResourceIdColumn(headerNames);\n+        int urlIndex = findURLColumn(headerNames);\n+\n+        // validate required columns:\n+        if (resourceIdIndex < 0) {\n+            throw new RuntimeException(\"Aborting owing to failure to find \" + RESOURCE_ID_COLUMN_NAME\n+                    + \" in file. Please check your file format and try again.\");\n+        }\n+        if (urlIndex < 0) {\n+            throw new RuntimeException(\"Aborting owing to failure to find \" + URL_COLUMN_NAME\n+                    + \" in file. Please check your file format and try again.\");\n+        }\n+        if ((resourceType.toString().equalsIgnoreCase(\"sample\") || resourceType.toString().equalsIgnoreCase(\"patient\")) && patientIdIndex < 0) {\n+            // PATIENT_ID is required in both patient and sample file types:\n+            throw new RuntimeException(\"Aborting owing to failure to find \" + PATIENT_ID_COLUMN_NAME\n+                    + \" in file. Please check your file format and try again.\");\n+        }\n+        if (resourceType.toString().equalsIgnoreCase(\"sample\") && sampleIdIndex < 0) {\n+            // SAMPLE_ID is required in SAMPLE file type:\n+            throw new RuntimeException(\"Aborting owing to failure to find \" + SAMPLE_ID_COLUMN_NAME\n+                    + \" in file. Please check your file format and try again.\");\n+        }\n+        importData(buff, resources, headerNames);\n+\n+        if (MySQLbulkLoader.isBulkLoad()) {\n+            MySQLbulkLoader.flushAll();\n+            MySQLbulkLoader.relaxedModeOff();\n+        }\n+    }\n+\n+    private List<ResourceDefinition> grabResources(BufferedReader buff) throws DaoException, IOException {\n+        List<ResourceDefinition> resources = new ArrayList<ResourceDefinition>();\n+        resources = DaoResourceDefinition.getDatumByStudy(cancerStudy.getInternalId());\n+        return resources;\n+    }\n+\n+    private String[] splitFields(String line) throws IOException {\n+        line = line.replaceAll(\"^\" + METADATA_PREFIX + \"+\", \"\");\n+        String[] fields = line.split(DELIMITER, -1);\n+\n+        return fields;\n+    }\n+\n+    private void importData(BufferedReader buff, List<ResourceDefinition> resources, String[] headerNames) throws Exception {\n+        String line;\n+        MultiKeyMap resourceMap = new MultiKeyMap();\n+        while ((line = buff.readLine()) != null) {\n+            if (skipLine(line.trim())) {\n+                continue;\n+            }\n+\n+            String[] fieldValues = getFieldValues(line, headerNames);\n+            addDatum(fieldValues, resources, resourceMap, headerNames);\n+        }\n+    }\n+\n+    private boolean skipLine(String line) {\n+        return (line.isEmpty() || line.substring(0, 1).equals(METADATA_PREFIX));\n+    }\n+\n+    /**\n+     * Takes in the given line and returns the list of field values by splitting the\n+     * line on DELIMITER.\n+     * \n+     * @param line\n+     * @param headerNames\n+     * @return the list of values, one for each column. Value will be \"\" for empty\n+     *         columns.\n+     */\n+    private String[] getFieldValues(String line, String[] headerNames) {\n+        // split on delimiter:\n+        String[] fieldValues = line.split(DELIMITER, -1);\n+\n+        // validate: if number of fields is incorrect, give exception\n+        if (fieldValues.length != headerNames.length) {\n+            throw new IllegalArgumentException(\"Number of columns in line is not as expected. Expected: \"\n+                    + headerNames.length + \" columns, found: \" + fieldValues.length + \", for line: \" + line);\n+        }\n+\n+        // now iterate over lines and trim each value:\n+        for (int i = 0; i < fieldValues.length; i++) {\n+            fieldValues[i] = fieldValues[i].trim();\n+        }\n+        return fieldValues;\n+    }\n+\n+    private boolean addDatum(String[] fields, List<ResourceDefinition> resources, MultiKeyMap resourceMap, String[] headerNames)\n+            throws Exception {\n+        int sampleIdIndex = findSampleIdColumn(headerNames);\n+        String stableSampleId = (sampleIdIndex >= 0) ? fields[sampleIdIndex] : \"\";\n+        stableSampleId = StableIdUtil.getSampleId(stableSampleId);\n+        int patientIdIndex = findPatientIdColumn(headerNames);\n+        String stablePatientId = (patientIdIndex >= 0) ? fields[patientIdIndex] : \"\";\n+        stablePatientId = StableIdUtil.getPatientId(stablePatientId);\n+        int resourceIdIndex = findResourceIdColumn(headerNames);\n+        int urlIndex = findURLColumn(headerNames);\n+        int internalSampleId = -1;\n+        int internalPatientId = -1;\n+\n+        // create resource_id set\n+        Set<String> patientResourceIdSet = resources.stream().filter(resource -> resource.getResourceType().equals(ResourceDefinition.PATIENT_RESOURCE_TYPE)).map(resource -> resource.getResourceId()).collect(Collectors.toSet());\n+        Set<String> sampleResourceIdSet = resources.stream().filter(resource -> resource.getResourceType().equals(ResourceDefinition.SAMPLE_RESOURCE_TYPE)).map(resource -> resource.getResourceId()).collect(Collectors.toSet());\n+        Set<String> studyResourceIdSet = resources.stream().filter(resource -> resource.getResourceType().equals(ResourceDefinition.STUDY_RESOURCE_TYPE)).map(resource -> resource.getResourceId()).collect(Collectors.toSet());\n+\n+        // check if sample is not already added:\n+        Sample sample = DaoSample.getSampleByCancerStudyAndSampleId(cancerStudy.getInternalId(), stableSampleId, false);\n+        if (sample != null) {\n+            // get internal sample id if sample exists\n+            internalSampleId = sample.getInternalId();\n+        } else {\n+            Patient patient = DaoPatient.getPatientByCancerStudyAndPatientId(cancerStudy.getInternalId(),\n+                    stablePatientId);\n+            if (patient != null) {\n+                // patient exists, get internal id:\n+                internalPatientId = patient.getInternalId();\n+            } else {\n+                // add patient:\n+                internalPatientId = (patientIdIndex >= 0) ? addPatientToDatabase(fields[patientIdIndex]) : -1;\n+            }\n+            // sample is new, so attempt to add to DB\n+            internalSampleId = (stableSampleId.length() > 0) ? addSampleToDatabase(stableSampleId, fields, headerNames)\n+                    : -1;\n+        }\n+\n+        // validate and count:\n+        if (internalSampleId != -1) {\n+            // some minimal validation/fail safe for now: only continue if patientId is same\n+            // as patient id in\n+            // existing sample (can occur in case of this.isSupplementalData or in case of\n+            // parsing bug in addSampleToDatabase):\n+            internalPatientId = DaoPatient\n+                    .getPatientByCancerStudyAndPatientId(cancerStudy.getInternalId(), stablePatientId).getInternalId();\n+            if (internalPatientId != DaoSample.getSampleById(internalSampleId).getInternalPatientId()) {\n+                throw new RuntimeException(\"Error: Sample \" + stableSampleId\n+                        + \" was previously linked to another patient, and not to \" + stablePatientId);\n+            }\n+            numSamplesProcessed++;\n+        }\n+\n+        // if the resource id or url matches one of the missing values, skip this resource:\n+        if ((resourceIdIndex != -1 && MissingResourceValues.has(fields[resourceIdIndex])) || (urlIndex != -1 && MissingResourceValues.has(fields[urlIndex]))) {\n+            numEmptyResourcesSkipped++;\n+        } else {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "40cec718fc69678e066b4100e162f79234f7e63f"}, "originalPosition": 253}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjM3MDcxNA==", "bodyText": "@onursumer I updated the solution, could you take a look if that's better?", "url": "https://github.com/cBioPortal/cbioportal/pull/7270#discussion_r392370714", "createdAt": "2020-03-13T17:28:40Z", "author": {"login": "dippindots"}, "path": "core/src/main/java/org/mskcc/cbio/portal/scripts/ImportResourceData.java", "diffHunk": "@@ -0,0 +1,618 @@\n+package org.mskcc.cbio.portal.scripts;\n+\n+import org.mskcc.cbio.portal.dao.*;\n+import org.mskcc.cbio.portal.model.*;\n+import org.mskcc.cbio.portal.util.*;\n+\n+import java.io.*;\n+import joptsimple.*;\n+import java.util.*;\n+import java.util.regex.*;\n+import java.util.stream.Collectors;\n+\n+import org.apache.commons.collections.map.MultiKeyMap;\n+\n+public class ImportResourceData extends ConsoleRunnable {\n+\n+    public static final String DELIMITER = \"\\t\";\n+    public static final String METADATA_PREFIX = \"#\";\n+    public static final String SAMPLE_ID_COLUMN_NAME = \"SAMPLE_ID\";\n+    public static final String PATIENT_ID_COLUMN_NAME = \"PATIENT_ID\";\n+    public static final String RESOURCE_ID_COLUMN_NAME = \"RESOURCE_ID\";\n+    public static final String URL_COLUMN_NAME = \"URL\";\n+    public static final String SAMPLE_TYPE_COLUMN_NAME = \"SAMPLE_TYPE\";\n+    private int numSampleSpecificResourcesAdded = 0;\n+    private int numPatientSpecificResourcesAdded = 0;\n+    private int numStudySpecificResourcesAdded = 0;\n+    private int numEmptyResourcesSkipped = 0;\n+    private int numSamplesProcessed = 0;\n+\n+    private static Properties properties;\n+\n+    private File resourceDataFile;\n+    private CancerStudy cancerStudy;\n+    private ResourceTypes resourceType;\n+    private boolean relaxed;\n+    private Set<String> patientIds = new HashSet<String>();\n+\n+    public static enum MissingResourceValues {\n+        NOT_APPLICABLE(\"Not Applicable\"), NOT_AVAILABLE(\"Not Available\"), PENDING(\"Pending\"),\n+        DISCREPANCY(\"Discrepancy\"), COMPLETED(\"Completed\"), NULL(\"null\"), MISSING(\"\"), NA(\"NA\");\n+\n+        private String propertyName;\n+\n+        MissingResourceValues(String propertyName) {\n+            this.propertyName = propertyName;\n+        }\n+\n+        public String toString() {\n+            return propertyName;\n+        }\n+\n+        static public boolean has(String value) {\n+            if (value == null)\n+                return false;\n+            if (value.trim().equals(\"\"))\n+                return true;\n+            try {\n+                value = value.replaceAll(\"[\\\\[|\\\\]]\", \"\");\n+                value = value.replaceAll(\" \", \"_\");\n+                return valueOf(value.toUpperCase()) != null;\n+            } catch (IllegalArgumentException x) {\n+                return false;\n+            }\n+        }\n+\n+        static public String getNotAvailable() {\n+            return \"[\" + NOT_AVAILABLE.toString() + \"]\";\n+        }\n+    }\n+\n+    public static enum ResourceTypes {\n+        PATIENT(\"PATIENT\"), SAMPLE(\"SAMPLE\"), STUDY(\"STUDY\");\n+\n+        private String resourceTypes;\n+\n+        ResourceTypes(String resourceTypes) {\n+            this.resourceTypes = resourceTypes;\n+        }\n+\n+        public String toString() {\n+            return resourceTypes;\n+        }\n+    }\n+\n+    public void setFile(CancerStudy cancerStudy, File resourceDataFile, String resourceType, boolean relaxed) {\n+        this.cancerStudy = cancerStudy;\n+        this.resourceDataFile = resourceDataFile;\n+        this.resourceType = ResourceTypes.valueOf(resourceType);\n+        this.relaxed = relaxed;\n+    }\n+\n+    public void importData() throws Exception {\n+        // if bulkLoading is ever turned off,\n+        // code has to be added to check whether\n+        // a resource data update should be\n+        // perform instead of an insert\n+        MySQLbulkLoader.bulkLoadOn();\n+\n+        if (relaxed) {\n+            MySQLbulkLoader.relaxedModeOn();\n+        }\n+\n+        FileReader reader = new FileReader(resourceDataFile);\n+        BufferedReader buff = new BufferedReader(reader);\n+        List<ResourceDefinition> resources = grabResources(buff);\n+        String currentLine = buff.readLine();\n+        String[] headerNames = currentLine.split(\"\\t\");\n+        \n+        int patientIdIndex = findPatientIdColumn(headerNames);\n+        int sampleIdIndex = findSampleIdColumn(headerNames);\n+        int resourceIdIndex = findResourceIdColumn(headerNames);\n+        int urlIndex = findURLColumn(headerNames);\n+\n+        // validate required columns:\n+        if (resourceIdIndex < 0) {\n+            throw new RuntimeException(\"Aborting owing to failure to find \" + RESOURCE_ID_COLUMN_NAME\n+                    + \" in file. Please check your file format and try again.\");\n+        }\n+        if (urlIndex < 0) {\n+            throw new RuntimeException(\"Aborting owing to failure to find \" + URL_COLUMN_NAME\n+                    + \" in file. Please check your file format and try again.\");\n+        }\n+        if ((resourceType.toString().equalsIgnoreCase(\"sample\") || resourceType.toString().equalsIgnoreCase(\"patient\")) && patientIdIndex < 0) {\n+            // PATIENT_ID is required in both patient and sample file types:\n+            throw new RuntimeException(\"Aborting owing to failure to find \" + PATIENT_ID_COLUMN_NAME\n+                    + \" in file. Please check your file format and try again.\");\n+        }\n+        if (resourceType.toString().equalsIgnoreCase(\"sample\") && sampleIdIndex < 0) {\n+            // SAMPLE_ID is required in SAMPLE file type:\n+            throw new RuntimeException(\"Aborting owing to failure to find \" + SAMPLE_ID_COLUMN_NAME\n+                    + \" in file. Please check your file format and try again.\");\n+        }\n+        importData(buff, resources, headerNames);\n+\n+        if (MySQLbulkLoader.isBulkLoad()) {\n+            MySQLbulkLoader.flushAll();\n+            MySQLbulkLoader.relaxedModeOff();\n+        }\n+    }\n+\n+    private List<ResourceDefinition> grabResources(BufferedReader buff) throws DaoException, IOException {\n+        List<ResourceDefinition> resources = new ArrayList<ResourceDefinition>();\n+        resources = DaoResourceDefinition.getDatumByStudy(cancerStudy.getInternalId());\n+        return resources;\n+    }\n+\n+    private String[] splitFields(String line) throws IOException {\n+        line = line.replaceAll(\"^\" + METADATA_PREFIX + \"+\", \"\");\n+        String[] fields = line.split(DELIMITER, -1);\n+\n+        return fields;\n+    }\n+\n+    private void importData(BufferedReader buff, List<ResourceDefinition> resources, String[] headerNames) throws Exception {\n+        String line;\n+        MultiKeyMap resourceMap = new MultiKeyMap();\n+        while ((line = buff.readLine()) != null) {\n+            if (skipLine(line.trim())) {\n+                continue;\n+            }\n+\n+            String[] fieldValues = getFieldValues(line, headerNames);\n+            addDatum(fieldValues, resources, resourceMap, headerNames);\n+        }\n+    }\n+\n+    private boolean skipLine(String line) {\n+        return (line.isEmpty() || line.substring(0, 1).equals(METADATA_PREFIX));\n+    }\n+\n+    /**\n+     * Takes in the given line and returns the list of field values by splitting the\n+     * line on DELIMITER.\n+     * \n+     * @param line\n+     * @param headerNames\n+     * @return the list of values, one for each column. Value will be \"\" for empty\n+     *         columns.\n+     */\n+    private String[] getFieldValues(String line, String[] headerNames) {\n+        // split on delimiter:\n+        String[] fieldValues = line.split(DELIMITER, -1);\n+\n+        // validate: if number of fields is incorrect, give exception\n+        if (fieldValues.length != headerNames.length) {\n+            throw new IllegalArgumentException(\"Number of columns in line is not as expected. Expected: \"\n+                    + headerNames.length + \" columns, found: \" + fieldValues.length + \", for line: \" + line);\n+        }\n+\n+        // now iterate over lines and trim each value:\n+        for (int i = 0; i < fieldValues.length; i++) {\n+            fieldValues[i] = fieldValues[i].trim();\n+        }\n+        return fieldValues;\n+    }\n+\n+    private boolean addDatum(String[] fields, List<ResourceDefinition> resources, MultiKeyMap resourceMap, String[] headerNames)\n+            throws Exception {\n+        int sampleIdIndex = findSampleIdColumn(headerNames);\n+        String stableSampleId = (sampleIdIndex >= 0) ? fields[sampleIdIndex] : \"\";\n+        stableSampleId = StableIdUtil.getSampleId(stableSampleId);\n+        int patientIdIndex = findPatientIdColumn(headerNames);\n+        String stablePatientId = (patientIdIndex >= 0) ? fields[patientIdIndex] : \"\";\n+        stablePatientId = StableIdUtil.getPatientId(stablePatientId);\n+        int resourceIdIndex = findResourceIdColumn(headerNames);\n+        int urlIndex = findURLColumn(headerNames);\n+        int internalSampleId = -1;\n+        int internalPatientId = -1;\n+\n+        // create resource_id set\n+        Set<String> patientResourceIdSet = resources.stream().filter(resource -> resource.getResourceType().equals(ResourceDefinition.PATIENT_RESOURCE_TYPE)).map(resource -> resource.getResourceId()).collect(Collectors.toSet());\n+        Set<String> sampleResourceIdSet = resources.stream().filter(resource -> resource.getResourceType().equals(ResourceDefinition.SAMPLE_RESOURCE_TYPE)).map(resource -> resource.getResourceId()).collect(Collectors.toSet());\n+        Set<String> studyResourceIdSet = resources.stream().filter(resource -> resource.getResourceType().equals(ResourceDefinition.STUDY_RESOURCE_TYPE)).map(resource -> resource.getResourceId()).collect(Collectors.toSet());\n+\n+        // check if sample is not already added:\n+        Sample sample = DaoSample.getSampleByCancerStudyAndSampleId(cancerStudy.getInternalId(), stableSampleId, false);\n+        if (sample != null) {\n+            // get internal sample id if sample exists\n+            internalSampleId = sample.getInternalId();\n+        } else {\n+            Patient patient = DaoPatient.getPatientByCancerStudyAndPatientId(cancerStudy.getInternalId(),\n+                    stablePatientId);\n+            if (patient != null) {\n+                // patient exists, get internal id:\n+                internalPatientId = patient.getInternalId();\n+            } else {\n+                // add patient:\n+                internalPatientId = (patientIdIndex >= 0) ? addPatientToDatabase(fields[patientIdIndex]) : -1;\n+            }\n+            // sample is new, so attempt to add to DB\n+            internalSampleId = (stableSampleId.length() > 0) ? addSampleToDatabase(stableSampleId, fields, headerNames)\n+                    : -1;\n+        }\n+\n+        // validate and count:\n+        if (internalSampleId != -1) {\n+            // some minimal validation/fail safe for now: only continue if patientId is same\n+            // as patient id in\n+            // existing sample (can occur in case of this.isSupplementalData or in case of\n+            // parsing bug in addSampleToDatabase):\n+            internalPatientId = DaoPatient\n+                    .getPatientByCancerStudyAndPatientId(cancerStudy.getInternalId(), stablePatientId).getInternalId();\n+            if (internalPatientId != DaoSample.getSampleById(internalSampleId).getInternalPatientId()) {\n+                throw new RuntimeException(\"Error: Sample \" + stableSampleId\n+                        + \" was previously linked to another patient, and not to \" + stablePatientId);\n+            }\n+            numSamplesProcessed++;\n+        }\n+\n+        // if the resource id or url matches one of the missing values, skip this resource:\n+        if ((resourceIdIndex != -1 && MissingResourceValues.has(fields[resourceIdIndex])) || (urlIndex != -1 && MissingResourceValues.has(fields[urlIndex]))) {\n+            numEmptyResourcesSkipped++;\n+        } else {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTkzMTI3Ng=="}, "originalCommit": {"oid": "40cec718fc69678e066b4100e162f79234f7e63f"}, "originalPosition": 253}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjUxMTE4OA==", "bodyText": "@dippindots looks better, thanks!", "url": "https://github.com/cBioPortal/cbioportal/pull/7270#discussion_r392511188", "createdAt": "2020-03-13T22:20:20Z", "author": {"login": "onursumer"}, "path": "core/src/main/java/org/mskcc/cbio/portal/scripts/ImportResourceData.java", "diffHunk": "@@ -0,0 +1,618 @@\n+package org.mskcc.cbio.portal.scripts;\n+\n+import org.mskcc.cbio.portal.dao.*;\n+import org.mskcc.cbio.portal.model.*;\n+import org.mskcc.cbio.portal.util.*;\n+\n+import java.io.*;\n+import joptsimple.*;\n+import java.util.*;\n+import java.util.regex.*;\n+import java.util.stream.Collectors;\n+\n+import org.apache.commons.collections.map.MultiKeyMap;\n+\n+public class ImportResourceData extends ConsoleRunnable {\n+\n+    public static final String DELIMITER = \"\\t\";\n+    public static final String METADATA_PREFIX = \"#\";\n+    public static final String SAMPLE_ID_COLUMN_NAME = \"SAMPLE_ID\";\n+    public static final String PATIENT_ID_COLUMN_NAME = \"PATIENT_ID\";\n+    public static final String RESOURCE_ID_COLUMN_NAME = \"RESOURCE_ID\";\n+    public static final String URL_COLUMN_NAME = \"URL\";\n+    public static final String SAMPLE_TYPE_COLUMN_NAME = \"SAMPLE_TYPE\";\n+    private int numSampleSpecificResourcesAdded = 0;\n+    private int numPatientSpecificResourcesAdded = 0;\n+    private int numStudySpecificResourcesAdded = 0;\n+    private int numEmptyResourcesSkipped = 0;\n+    private int numSamplesProcessed = 0;\n+\n+    private static Properties properties;\n+\n+    private File resourceDataFile;\n+    private CancerStudy cancerStudy;\n+    private ResourceTypes resourceType;\n+    private boolean relaxed;\n+    private Set<String> patientIds = new HashSet<String>();\n+\n+    public static enum MissingResourceValues {\n+        NOT_APPLICABLE(\"Not Applicable\"), NOT_AVAILABLE(\"Not Available\"), PENDING(\"Pending\"),\n+        DISCREPANCY(\"Discrepancy\"), COMPLETED(\"Completed\"), NULL(\"null\"), MISSING(\"\"), NA(\"NA\");\n+\n+        private String propertyName;\n+\n+        MissingResourceValues(String propertyName) {\n+            this.propertyName = propertyName;\n+        }\n+\n+        public String toString() {\n+            return propertyName;\n+        }\n+\n+        static public boolean has(String value) {\n+            if (value == null)\n+                return false;\n+            if (value.trim().equals(\"\"))\n+                return true;\n+            try {\n+                value = value.replaceAll(\"[\\\\[|\\\\]]\", \"\");\n+                value = value.replaceAll(\" \", \"_\");\n+                return valueOf(value.toUpperCase()) != null;\n+            } catch (IllegalArgumentException x) {\n+                return false;\n+            }\n+        }\n+\n+        static public String getNotAvailable() {\n+            return \"[\" + NOT_AVAILABLE.toString() + \"]\";\n+        }\n+    }\n+\n+    public static enum ResourceTypes {\n+        PATIENT(\"PATIENT\"), SAMPLE(\"SAMPLE\"), STUDY(\"STUDY\");\n+\n+        private String resourceTypes;\n+\n+        ResourceTypes(String resourceTypes) {\n+            this.resourceTypes = resourceTypes;\n+        }\n+\n+        public String toString() {\n+            return resourceTypes;\n+        }\n+    }\n+\n+    public void setFile(CancerStudy cancerStudy, File resourceDataFile, String resourceType, boolean relaxed) {\n+        this.cancerStudy = cancerStudy;\n+        this.resourceDataFile = resourceDataFile;\n+        this.resourceType = ResourceTypes.valueOf(resourceType);\n+        this.relaxed = relaxed;\n+    }\n+\n+    public void importData() throws Exception {\n+        // if bulkLoading is ever turned off,\n+        // code has to be added to check whether\n+        // a resource data update should be\n+        // perform instead of an insert\n+        MySQLbulkLoader.bulkLoadOn();\n+\n+        if (relaxed) {\n+            MySQLbulkLoader.relaxedModeOn();\n+        }\n+\n+        FileReader reader = new FileReader(resourceDataFile);\n+        BufferedReader buff = new BufferedReader(reader);\n+        List<ResourceDefinition> resources = grabResources(buff);\n+        String currentLine = buff.readLine();\n+        String[] headerNames = currentLine.split(\"\\t\");\n+        \n+        int patientIdIndex = findPatientIdColumn(headerNames);\n+        int sampleIdIndex = findSampleIdColumn(headerNames);\n+        int resourceIdIndex = findResourceIdColumn(headerNames);\n+        int urlIndex = findURLColumn(headerNames);\n+\n+        // validate required columns:\n+        if (resourceIdIndex < 0) {\n+            throw new RuntimeException(\"Aborting owing to failure to find \" + RESOURCE_ID_COLUMN_NAME\n+                    + \" in file. Please check your file format and try again.\");\n+        }\n+        if (urlIndex < 0) {\n+            throw new RuntimeException(\"Aborting owing to failure to find \" + URL_COLUMN_NAME\n+                    + \" in file. Please check your file format and try again.\");\n+        }\n+        if ((resourceType.toString().equalsIgnoreCase(\"sample\") || resourceType.toString().equalsIgnoreCase(\"patient\")) && patientIdIndex < 0) {\n+            // PATIENT_ID is required in both patient and sample file types:\n+            throw new RuntimeException(\"Aborting owing to failure to find \" + PATIENT_ID_COLUMN_NAME\n+                    + \" in file. Please check your file format and try again.\");\n+        }\n+        if (resourceType.toString().equalsIgnoreCase(\"sample\") && sampleIdIndex < 0) {\n+            // SAMPLE_ID is required in SAMPLE file type:\n+            throw new RuntimeException(\"Aborting owing to failure to find \" + SAMPLE_ID_COLUMN_NAME\n+                    + \" in file. Please check your file format and try again.\");\n+        }\n+        importData(buff, resources, headerNames);\n+\n+        if (MySQLbulkLoader.isBulkLoad()) {\n+            MySQLbulkLoader.flushAll();\n+            MySQLbulkLoader.relaxedModeOff();\n+        }\n+    }\n+\n+    private List<ResourceDefinition> grabResources(BufferedReader buff) throws DaoException, IOException {\n+        List<ResourceDefinition> resources = new ArrayList<ResourceDefinition>();\n+        resources = DaoResourceDefinition.getDatumByStudy(cancerStudy.getInternalId());\n+        return resources;\n+    }\n+\n+    private String[] splitFields(String line) throws IOException {\n+        line = line.replaceAll(\"^\" + METADATA_PREFIX + \"+\", \"\");\n+        String[] fields = line.split(DELIMITER, -1);\n+\n+        return fields;\n+    }\n+\n+    private void importData(BufferedReader buff, List<ResourceDefinition> resources, String[] headerNames) throws Exception {\n+        String line;\n+        MultiKeyMap resourceMap = new MultiKeyMap();\n+        while ((line = buff.readLine()) != null) {\n+            if (skipLine(line.trim())) {\n+                continue;\n+            }\n+\n+            String[] fieldValues = getFieldValues(line, headerNames);\n+            addDatum(fieldValues, resources, resourceMap, headerNames);\n+        }\n+    }\n+\n+    private boolean skipLine(String line) {\n+        return (line.isEmpty() || line.substring(0, 1).equals(METADATA_PREFIX));\n+    }\n+\n+    /**\n+     * Takes in the given line and returns the list of field values by splitting the\n+     * line on DELIMITER.\n+     * \n+     * @param line\n+     * @param headerNames\n+     * @return the list of values, one for each column. Value will be \"\" for empty\n+     *         columns.\n+     */\n+    private String[] getFieldValues(String line, String[] headerNames) {\n+        // split on delimiter:\n+        String[] fieldValues = line.split(DELIMITER, -1);\n+\n+        // validate: if number of fields is incorrect, give exception\n+        if (fieldValues.length != headerNames.length) {\n+            throw new IllegalArgumentException(\"Number of columns in line is not as expected. Expected: \"\n+                    + headerNames.length + \" columns, found: \" + fieldValues.length + \", for line: \" + line);\n+        }\n+\n+        // now iterate over lines and trim each value:\n+        for (int i = 0; i < fieldValues.length; i++) {\n+            fieldValues[i] = fieldValues[i].trim();\n+        }\n+        return fieldValues;\n+    }\n+\n+    private boolean addDatum(String[] fields, List<ResourceDefinition> resources, MultiKeyMap resourceMap, String[] headerNames)\n+            throws Exception {\n+        int sampleIdIndex = findSampleIdColumn(headerNames);\n+        String stableSampleId = (sampleIdIndex >= 0) ? fields[sampleIdIndex] : \"\";\n+        stableSampleId = StableIdUtil.getSampleId(stableSampleId);\n+        int patientIdIndex = findPatientIdColumn(headerNames);\n+        String stablePatientId = (patientIdIndex >= 0) ? fields[patientIdIndex] : \"\";\n+        stablePatientId = StableIdUtil.getPatientId(stablePatientId);\n+        int resourceIdIndex = findResourceIdColumn(headerNames);\n+        int urlIndex = findURLColumn(headerNames);\n+        int internalSampleId = -1;\n+        int internalPatientId = -1;\n+\n+        // create resource_id set\n+        Set<String> patientResourceIdSet = resources.stream().filter(resource -> resource.getResourceType().equals(ResourceDefinition.PATIENT_RESOURCE_TYPE)).map(resource -> resource.getResourceId()).collect(Collectors.toSet());\n+        Set<String> sampleResourceIdSet = resources.stream().filter(resource -> resource.getResourceType().equals(ResourceDefinition.SAMPLE_RESOURCE_TYPE)).map(resource -> resource.getResourceId()).collect(Collectors.toSet());\n+        Set<String> studyResourceIdSet = resources.stream().filter(resource -> resource.getResourceType().equals(ResourceDefinition.STUDY_RESOURCE_TYPE)).map(resource -> resource.getResourceId()).collect(Collectors.toSet());\n+\n+        // check if sample is not already added:\n+        Sample sample = DaoSample.getSampleByCancerStudyAndSampleId(cancerStudy.getInternalId(), stableSampleId, false);\n+        if (sample != null) {\n+            // get internal sample id if sample exists\n+            internalSampleId = sample.getInternalId();\n+        } else {\n+            Patient patient = DaoPatient.getPatientByCancerStudyAndPatientId(cancerStudy.getInternalId(),\n+                    stablePatientId);\n+            if (patient != null) {\n+                // patient exists, get internal id:\n+                internalPatientId = patient.getInternalId();\n+            } else {\n+                // add patient:\n+                internalPatientId = (patientIdIndex >= 0) ? addPatientToDatabase(fields[patientIdIndex]) : -1;\n+            }\n+            // sample is new, so attempt to add to DB\n+            internalSampleId = (stableSampleId.length() > 0) ? addSampleToDatabase(stableSampleId, fields, headerNames)\n+                    : -1;\n+        }\n+\n+        // validate and count:\n+        if (internalSampleId != -1) {\n+            // some minimal validation/fail safe for now: only continue if patientId is same\n+            // as patient id in\n+            // existing sample (can occur in case of this.isSupplementalData or in case of\n+            // parsing bug in addSampleToDatabase):\n+            internalPatientId = DaoPatient\n+                    .getPatientByCancerStudyAndPatientId(cancerStudy.getInternalId(), stablePatientId).getInternalId();\n+            if (internalPatientId != DaoSample.getSampleById(internalSampleId).getInternalPatientId()) {\n+                throw new RuntimeException(\"Error: Sample \" + stableSampleId\n+                        + \" was previously linked to another patient, and not to \" + stablePatientId);\n+            }\n+            numSamplesProcessed++;\n+        }\n+\n+        // if the resource id or url matches one of the missing values, skip this resource:\n+        if ((resourceIdIndex != -1 && MissingResourceValues.has(fields[resourceIdIndex])) || (urlIndex != -1 && MissingResourceValues.has(fields[urlIndex]))) {\n+            numEmptyResourcesSkipped++;\n+        } else {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTkzMTI3Ng=="}, "originalCommit": {"oid": "40cec718fc69678e066b4100e162f79234f7e63f"}, "originalPosition": 253}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQzNzI1MTEwOnYy", "diffSide": "RIGHT", "path": "core/src/main/scripts/importer/validateData.py", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xNlQxNzozMzoxNVrOF2-yyg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xNlQyMTo0Njo1OFrOF3G0_g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzE5NjIzNA==", "bodyText": "@dippindots i imagine pending/discrepancy/completed were prolly there for a reason. Did someone confirm they were no longer necessary? Otherwise I would leave them. I mostly meant that when writing the resource importer/validator code u prolly don't want to include them, since they are kind of weird NULL_VALUES. Like if I were to load data I would be surprised that these type of values are considered NULL. For backwards compatibility you would like to leave them but when introducing new code I would leave them out.\nSo maybe you have something like NULL_VALUES that make sense for all kinds of data and OTHER_CLINICAL_ATTRIBUTE_NULL_VALUES which are in addition to the NULL_VALUES and specific to clinical attributes only\nAnyway this is not super important but just wanted to clarify. You can have a single NULL_VALUES list but then to be safe I would include the previous values \"[pending]\", \"[discrepancy]\", \"[completed]\"", "url": "https://github.com/cBioPortal/cbioportal/pull/7270#discussion_r393196234", "createdAt": "2020-03-16T17:33:15Z", "author": {"login": "inodb"}, "path": "core/src/main/scripts/importer/validateData.py", "diffHunk": "@@ -3502,7 +3502,7 @@ class ResourceDefinitionValidator(Validator):\n     # 'RESOURCE_ID', 'RESOURCE_TYPE', 'DISPLAY_NAME' are required\n     REQUIRE_COLUMN_ORDER = False\n     REQUIRED_HEADERS = ['RESOURCE_ID', 'RESOURCE_TYPE', 'DISPLAY_NAME']\n-    NULL_VALUES = [\"[not applicable]\", \"[not available]\", \"[pending]\", \"[discrepancy]\", \"[completed]\", \"[null]\", \"\", \"na\"]\n+    NULL_VALUES = [\"[not applicable]\", \"[not available]\", \"[null]\", \"\", \"na\"]", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8660b2628cad9a9debde7b45830e22c8521ee21b"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzMyNzQ5NQ==", "bodyText": "Hi @inodb, I don't think I totally understand what you mean. I am not sure whether we want users to have NULL_VALUES in their data file?", "url": "https://github.com/cBioPortal/cbioportal/pull/7270#discussion_r393327495", "createdAt": "2020-03-16T21:46:01Z", "author": {"login": "dippindots"}, "path": "core/src/main/scripts/importer/validateData.py", "diffHunk": "@@ -3502,7 +3502,7 @@ class ResourceDefinitionValidator(Validator):\n     # 'RESOURCE_ID', 'RESOURCE_TYPE', 'DISPLAY_NAME' are required\n     REQUIRE_COLUMN_ORDER = False\n     REQUIRED_HEADERS = ['RESOURCE_ID', 'RESOURCE_TYPE', 'DISPLAY_NAME']\n-    NULL_VALUES = [\"[not applicable]\", \"[not available]\", \"[pending]\", \"[discrepancy]\", \"[completed]\", \"[null]\", \"\", \"na\"]\n+    NULL_VALUES = [\"[not applicable]\", \"[not available]\", \"[null]\", \"\", \"na\"]", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzE5NjIzNA=="}, "originalCommit": {"oid": "8660b2628cad9a9debde7b45830e22c8521ee21b"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzMyNzg3MA==", "bodyText": "Do you mean that we can remove the current NULL_VALUES definition?", "url": "https://github.com/cBioPortal/cbioportal/pull/7270#discussion_r393327870", "createdAt": "2020-03-16T21:46:58Z", "author": {"login": "dippindots"}, "path": "core/src/main/scripts/importer/validateData.py", "diffHunk": "@@ -3502,7 +3502,7 @@ class ResourceDefinitionValidator(Validator):\n     # 'RESOURCE_ID', 'RESOURCE_TYPE', 'DISPLAY_NAME' are required\n     REQUIRE_COLUMN_ORDER = False\n     REQUIRED_HEADERS = ['RESOURCE_ID', 'RESOURCE_TYPE', 'DISPLAY_NAME']\n-    NULL_VALUES = [\"[not applicable]\", \"[not available]\", \"[pending]\", \"[discrepancy]\", \"[completed]\", \"[null]\", \"\", \"na\"]\n+    NULL_VALUES = [\"[not applicable]\", \"[not available]\", \"[null]\", \"\", \"na\"]", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzE5NjIzNA=="}, "originalCommit": {"oid": "8660b2628cad9a9debde7b45830e22c8521ee21b"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ0NTkyOTU2OnYy", "diffSide": "RIGHT", "path": "core/src/main/scripts/importer/cbioportalImporter.py", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOFQyMDoxMDozNlrOF4VH6w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOVQxNDowMzoxOVrOF4v2Rw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDYxMDY2Nw==", "bodyText": "it should be definition not defination :)", "url": "https://github.com/cBioPortal/cbioportal/pull/7270#discussion_r394610667", "createdAt": "2020-03-18T20:10:36Z", "author": {"login": "onursumer"}, "path": "core/src/main/scripts/importer/cbioportalImporter.py", "diffHunk": "@@ -219,6 +219,8 @@ def process_directory(jvm_args, study_directory):\n     study_meta_dictionary = {}\n     cancer_type_filepairs = []\n     sample_attr_filepair = None\n+    sample_resource_filepair = None\n+    resource_defination_filepair = None", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e4d7e6e9eb5909cb7ebb019f68b6b13d5b33bfd4"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDYxNDAzNQ==", "bodyText": "I do need a spell checker!!", "url": "https://github.com/cBioPortal/cbioportal/pull/7270#discussion_r394614035", "createdAt": "2020-03-18T20:17:15Z", "author": {"login": "dippindots"}, "path": "core/src/main/scripts/importer/cbioportalImporter.py", "diffHunk": "@@ -219,6 +219,8 @@ def process_directory(jvm_args, study_directory):\n     study_meta_dictionary = {}\n     cancer_type_filepairs = []\n     sample_attr_filepair = None\n+    sample_resource_filepair = None\n+    resource_defination_filepair = None", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDYxMDY2Nw=="}, "originalCommit": {"oid": "e4d7e6e9eb5909cb7ebb019f68b6b13d5b33bfd4"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTA0ODUxOQ==", "bodyText": "updated!", "url": "https://github.com/cBioPortal/cbioportal/pull/7270#discussion_r395048519", "createdAt": "2020-03-19T14:03:19Z", "author": {"login": "dippindots"}, "path": "core/src/main/scripts/importer/cbioportalImporter.py", "diffHunk": "@@ -219,6 +219,8 @@ def process_directory(jvm_args, study_directory):\n     study_meta_dictionary = {}\n     cancer_type_filepairs = []\n     sample_attr_filepair = None\n+    sample_resource_filepair = None\n+    resource_defination_filepair = None", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDYxMDY2Nw=="}, "originalCommit": {"oid": "e4d7e6e9eb5909cb7ebb019f68b6b13d5b33bfd4"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ0ODc2MjIxOnYy", "diffSide": "RIGHT", "path": "core/src/main/java/org/mskcc/cbio/portal/dao/DaoResourceData.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOVQxNDoyOTowNFrOF4xB4w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOVQxODoxNjozNlrOF46z-w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTA2Nzg3NQ==", "bodyText": "note: DaoClinicalData also refers to the clinical_sample and clinical_patient tables simply as SAMPLE_TABLE and PATIENT_TABLE \ud83d\udc4d", "url": "https://github.com/cBioPortal/cbioportal/pull/7270#discussion_r395067875", "createdAt": "2020-03-19T14:29:04Z", "author": {"login": "ao508"}, "path": "core/src/main/java/org/mskcc/cbio/portal/dao/DaoResourceData.java", "diffHunk": "@@ -0,0 +1,219 @@\n+package org.mskcc.cbio.portal.dao;\n+\n+import org.mskcc.cbio.portal.model.*;\n+import org.mskcc.cbio.portal.util.InternalIdUtil;\n+\n+import org.apache.commons.lang.StringUtils;\n+\n+import java.sql.*;\n+import java.util.*;\n+\n+/**\n+ * Data Access Object for `resource` tables\n+ */\n+public final class DaoResourceData {\n+\n+    public static final String SAMPLE_TABLE = \"resource_sample\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ad5abf7c9634a54ebf671517257638ed6e6141d8"}, "originalPosition": 16}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTIyODE1NQ==", "bodyText": "I will rename them to RESOURCE_SAMPLE_TABLE and RESOURCE_PATIENT_TABLE", "url": "https://github.com/cBioPortal/cbioportal/pull/7270#discussion_r395228155", "createdAt": "2020-03-19T18:16:36Z", "author": {"login": "dippindots"}, "path": "core/src/main/java/org/mskcc/cbio/portal/dao/DaoResourceData.java", "diffHunk": "@@ -0,0 +1,219 @@\n+package org.mskcc.cbio.portal.dao;\n+\n+import org.mskcc.cbio.portal.model.*;\n+import org.mskcc.cbio.portal.util.InternalIdUtil;\n+\n+import org.apache.commons.lang.StringUtils;\n+\n+import java.sql.*;\n+import java.util.*;\n+\n+/**\n+ * Data Access Object for `resource` tables\n+ */\n+public final class DaoResourceData {\n+\n+    public static final String SAMPLE_TABLE = \"resource_sample\";", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTA2Nzg3NQ=="}, "originalCommit": {"oid": "ad5abf7c9634a54ebf671517257638ed6e6141d8"}, "originalPosition": 16}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ0ODkwNTI5OnYy", "diffSide": "RIGHT", "path": "core/src/main/java/org/mskcc/cbio/portal/model/ResourceDefinition.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOVQxNDo1OTowN1rOF4yeFA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOVQxODoxNzoyMFrOF461rw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTA5MTQ3Ng==", "bodyText": "This class looks similar to what's in https://github.com/cBioPortal/cbioportal/pull/7260/files#diff-9c956027ecfb618e20f86039fc7d88b5. Instead of two should be merge them?", "url": "https://github.com/cBioPortal/cbioportal/pull/7270#discussion_r395091476", "createdAt": "2020-03-19T14:59:07Z", "author": {"login": "kalletlak"}, "path": "core/src/main/java/org/mskcc/cbio/portal/model/ResourceDefinition.java", "diffHunk": "@@ -0,0 +1,93 @@\n+package org.mskcc.cbio.portal.model;\n+\n+public class ResourceDefinition {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ad5abf7c9634a54ebf671517257638ed6e6141d8"}, "originalPosition": 3}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTIyODU5MQ==", "bodyText": "Yes, definitely, I will rebase and use that one.", "url": "https://github.com/cBioPortal/cbioportal/pull/7270#discussion_r395228591", "createdAt": "2020-03-19T18:17:20Z", "author": {"login": "dippindots"}, "path": "core/src/main/java/org/mskcc/cbio/portal/model/ResourceDefinition.java", "diffHunk": "@@ -0,0 +1,93 @@\n+package org.mskcc.cbio.portal.model;\n+\n+public class ResourceDefinition {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTA5MTQ3Ng=="}, "originalCommit": {"oid": "ad5abf7c9634a54ebf671517257638ed6e6141d8"}, "originalPosition": 3}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ0ODkxNjM4OnYy", "diffSide": "RIGHT", "path": "core/src/main/java/org/mskcc/cbio/portal/model/ResourceDefinition.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOVQxNTowMTozNlrOF4yldg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOVQxNTowMTozNlrOF4yldg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTA5MzM2Ng==", "bodyText": "Instead of String this can be Enum https://github.com/cBioPortal/cbioportal/pull/7260/files#diff-c093101e82d85d9e9aa964dd73fec8ba", "url": "https://github.com/cBioPortal/cbioportal/pull/7270#discussion_r395093366", "createdAt": "2020-03-19T15:01:36Z", "author": {"login": "kalletlak"}, "path": "core/src/main/java/org/mskcc/cbio/portal/model/ResourceDefinition.java", "diffHunk": "@@ -0,0 +1,93 @@\n+package org.mskcc.cbio.portal.model;\n+\n+public class ResourceDefinition {\n+\n+    public static final String STUDY_RESOURCE_TYPE = \"STUDY\";\n+    public static final String SAMPLE_RESOURCE_TYPE = \"SAMPLE\";\n+    public static final String PATIENT_RESOURCE_TYPE = \"PATIENT\";\n+    public static final String MISSING = \"MISSING\";\n+\n+    private String resourceId;\n+    private String displayName;\n+    private String description;\n+    private String resourceType;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ad5abf7c9634a54ebf671517257638ed6e6141d8"}, "originalPosition": 13}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ0ODkyMTM2OnYy", "diffSide": "RIGHT", "path": "core/src/main/java/org/mskcc/cbio/portal/model/ResourceDefinition.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOVQxNTowMjozNlrOF4yofA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOVQxNTowMjozNlrOF4yofA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTA5NDE0MA==", "bodyText": "STUDY_RESOURCE_TYPE, SAMPLE_RESOURCE_TYPE, PATIENT_RESOURCE_TYPE can be replaced with https://github.com/cBioPortal/cbioportal/pull/7260/files#diff-c093101e82d85d9e9aa964dd73fec8ba", "url": "https://github.com/cBioPortal/cbioportal/pull/7270#discussion_r395094140", "createdAt": "2020-03-19T15:02:36Z", "author": {"login": "kalletlak"}, "path": "core/src/main/java/org/mskcc/cbio/portal/model/ResourceDefinition.java", "diffHunk": "@@ -0,0 +1,93 @@\n+package org.mskcc.cbio.portal.model;\n+\n+public class ResourceDefinition {\n+\n+    public static final String STUDY_RESOURCE_TYPE = \"STUDY\";\n+    public static final String SAMPLE_RESOURCE_TYPE = \"SAMPLE\";\n+    public static final String PATIENT_RESOURCE_TYPE = \"PATIENT\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ad5abf7c9634a54ebf671517257638ed6e6141d8"}, "originalPosition": 7}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ0ODkzODA0OnYy", "diffSide": "RIGHT", "path": "core/src/main/java/org/mskcc/cbio/portal/scripts/ImportResourceData.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOVQxNTowNjoxOVrOF4yzYw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOVQxNjoyODo0NFrOF42gXQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTA5NjkzMQ==", "bodyText": "This can just be instead of creating local variable\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    return resources;\n          \n          \n            \n                    return DaoResourceDefinition.getDatumByStudy(cancerStudy.getInternalId());", "url": "https://github.com/cBioPortal/cbioportal/pull/7270#discussion_r395096931", "createdAt": "2020-03-19T15:06:19Z", "author": {"login": "kalletlak"}, "path": "core/src/main/java/org/mskcc/cbio/portal/scripts/ImportResourceData.java", "diffHunk": "@@ -0,0 +1,574 @@\n+package org.mskcc.cbio.portal.scripts;\n+\n+import org.mskcc.cbio.portal.dao.*;\n+import org.mskcc.cbio.portal.model.*;\n+import org.mskcc.cbio.portal.util.*;\n+import org.mskcc.cbio.portal.util.ValuesUtils.MissingValues;\n+\n+import java.io.*;\n+import joptsimple.*;\n+import java.util.*;\n+import java.util.regex.*;\n+import java.util.stream.Collectors;\n+\n+import org.apache.commons.collections.map.MultiKeyMap;\n+\n+public class ImportResourceData extends ConsoleRunnable {\n+\n+    public static final String DELIMITER = \"\\t\";\n+    public static final String METADATA_PREFIX = \"#\";\n+    public static final String SAMPLE_ID_COLUMN_NAME = \"SAMPLE_ID\";\n+    public static final String PATIENT_ID_COLUMN_NAME = \"PATIENT_ID\";\n+    public static final String RESOURCE_ID_COLUMN_NAME = \"RESOURCE_ID\";\n+    public static final String URL_COLUMN_NAME = \"URL\";\n+    public static final String SAMPLE_TYPE_COLUMN_NAME = \"SAMPLE_TYPE\";\n+    private int numSampleSpecificResourcesAdded = 0;\n+    private int numPatientSpecificResourcesAdded = 0;\n+    private int numStudySpecificResourcesAdded = 0;\n+    private int numEmptyResourcesSkipped = 0;\n+    private int numSamplesProcessed = 0;\n+\n+    private static Properties properties;\n+\n+    private File resourceDataFile;\n+    private CancerStudy cancerStudy;\n+    private ResourceTypes resourceType;\n+    private boolean relaxed;\n+    private Set<String> patientIds = new HashSet<String>();\n+\n+    public static enum ResourceTypes {\n+        PATIENT(\"PATIENT\"), SAMPLE(\"SAMPLE\"), STUDY(\"STUDY\");\n+\n+        private String resourceTypes;\n+\n+        ResourceTypes(String resourceTypes) {\n+            this.resourceTypes = resourceTypes;\n+        }\n+\n+        public String toString() {\n+            return resourceTypes;\n+        }\n+    }\n+\n+    public void setFile(CancerStudy cancerStudy, File resourceDataFile, String resourceType, boolean relaxed) {\n+        this.cancerStudy = cancerStudy;\n+        this.resourceDataFile = resourceDataFile;\n+        this.resourceType = ResourceTypes.valueOf(resourceType);\n+        this.relaxed = relaxed;\n+    }\n+\n+    public void importData() throws Exception {\n+        // if bulkLoading is ever turned off,\n+        // code has to be added to check whether\n+        // a resource data update should be\n+        // perform instead of an insert\n+        MySQLbulkLoader.bulkLoadOn();\n+\n+        if (relaxed) {\n+            MySQLbulkLoader.relaxedModeOn();\n+        }\n+\n+        FileReader reader = new FileReader(resourceDataFile);\n+        BufferedReader buff = new BufferedReader(reader);\n+        List<ResourceDefinition> resources = grabResources(buff);\n+        String currentLine = buff.readLine();\n+        String[] headerNames = currentLine.split(\"\\t\");\n+        \n+        int patientIdIndex = findPatientIdColumn(headerNames);\n+        int sampleIdIndex = findSampleIdColumn(headerNames);\n+        int resourceIdIndex = findResourceIdColumn(headerNames);\n+        int urlIndex = findURLColumn(headerNames);\n+\n+        // validate required columns:\n+        if (resourceIdIndex < 0) {\n+            throw new RuntimeException(\"Aborting owing to failure to find \" + RESOURCE_ID_COLUMN_NAME\n+                    + \" in file. Please check your file format and try again.\");\n+        }\n+        if (urlIndex < 0) {\n+            throw new RuntimeException(\"Aborting owing to failure to find \" + URL_COLUMN_NAME\n+                    + \" in file. Please check your file format and try again.\");\n+        }\n+        if ((resourceType.toString().equalsIgnoreCase(\"sample\") || resourceType.toString().equalsIgnoreCase(\"patient\")) && patientIdIndex < 0) {\n+            // PATIENT_ID is required in both patient and sample file types:\n+            throw new RuntimeException(\"Aborting owing to failure to find \" + PATIENT_ID_COLUMN_NAME\n+                    + \" in file. Please check your file format and try again.\");\n+        }\n+        if (resourceType.toString().equalsIgnoreCase(\"sample\") && sampleIdIndex < 0) {\n+            // SAMPLE_ID is required in SAMPLE file type:\n+            throw new RuntimeException(\"Aborting owing to failure to find \" + SAMPLE_ID_COLUMN_NAME\n+                    + \" in file. Please check your file format and try again.\");\n+        }\n+        importData(buff, resources, headerNames);\n+\n+        if (MySQLbulkLoader.isBulkLoad()) {\n+            MySQLbulkLoader.flushAll();\n+            MySQLbulkLoader.relaxedModeOff();\n+        }\n+    }\n+\n+    private List<ResourceDefinition> grabResources(BufferedReader buff) throws DaoException, IOException {\n+        List<ResourceDefinition> resources = new ArrayList<ResourceDefinition>();\n+        resources = DaoResourceDefinition.getDatumByStudy(cancerStudy.getInternalId());\n+        return resources;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ad5abf7c9634a54ebf671517257638ed6e6141d8"}, "originalPosition": 112}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTE1NzU5Nw==", "bodyText": "or line 73 can be  List<ResourceDefinition> resources = DaoResourceDefinition.getDatumByStudy(cancerStudy.getInternalId());", "url": "https://github.com/cBioPortal/cbioportal/pull/7270#discussion_r395157597", "createdAt": "2020-03-19T16:28:44Z", "author": {"login": "kalletlak"}, "path": "core/src/main/java/org/mskcc/cbio/portal/scripts/ImportResourceData.java", "diffHunk": "@@ -0,0 +1,574 @@\n+package org.mskcc.cbio.portal.scripts;\n+\n+import org.mskcc.cbio.portal.dao.*;\n+import org.mskcc.cbio.portal.model.*;\n+import org.mskcc.cbio.portal.util.*;\n+import org.mskcc.cbio.portal.util.ValuesUtils.MissingValues;\n+\n+import java.io.*;\n+import joptsimple.*;\n+import java.util.*;\n+import java.util.regex.*;\n+import java.util.stream.Collectors;\n+\n+import org.apache.commons.collections.map.MultiKeyMap;\n+\n+public class ImportResourceData extends ConsoleRunnable {\n+\n+    public static final String DELIMITER = \"\\t\";\n+    public static final String METADATA_PREFIX = \"#\";\n+    public static final String SAMPLE_ID_COLUMN_NAME = \"SAMPLE_ID\";\n+    public static final String PATIENT_ID_COLUMN_NAME = \"PATIENT_ID\";\n+    public static final String RESOURCE_ID_COLUMN_NAME = \"RESOURCE_ID\";\n+    public static final String URL_COLUMN_NAME = \"URL\";\n+    public static final String SAMPLE_TYPE_COLUMN_NAME = \"SAMPLE_TYPE\";\n+    private int numSampleSpecificResourcesAdded = 0;\n+    private int numPatientSpecificResourcesAdded = 0;\n+    private int numStudySpecificResourcesAdded = 0;\n+    private int numEmptyResourcesSkipped = 0;\n+    private int numSamplesProcessed = 0;\n+\n+    private static Properties properties;\n+\n+    private File resourceDataFile;\n+    private CancerStudy cancerStudy;\n+    private ResourceTypes resourceType;\n+    private boolean relaxed;\n+    private Set<String> patientIds = new HashSet<String>();\n+\n+    public static enum ResourceTypes {\n+        PATIENT(\"PATIENT\"), SAMPLE(\"SAMPLE\"), STUDY(\"STUDY\");\n+\n+        private String resourceTypes;\n+\n+        ResourceTypes(String resourceTypes) {\n+            this.resourceTypes = resourceTypes;\n+        }\n+\n+        public String toString() {\n+            return resourceTypes;\n+        }\n+    }\n+\n+    public void setFile(CancerStudy cancerStudy, File resourceDataFile, String resourceType, boolean relaxed) {\n+        this.cancerStudy = cancerStudy;\n+        this.resourceDataFile = resourceDataFile;\n+        this.resourceType = ResourceTypes.valueOf(resourceType);\n+        this.relaxed = relaxed;\n+    }\n+\n+    public void importData() throws Exception {\n+        // if bulkLoading is ever turned off,\n+        // code has to be added to check whether\n+        // a resource data update should be\n+        // perform instead of an insert\n+        MySQLbulkLoader.bulkLoadOn();\n+\n+        if (relaxed) {\n+            MySQLbulkLoader.relaxedModeOn();\n+        }\n+\n+        FileReader reader = new FileReader(resourceDataFile);\n+        BufferedReader buff = new BufferedReader(reader);\n+        List<ResourceDefinition> resources = grabResources(buff);\n+        String currentLine = buff.readLine();\n+        String[] headerNames = currentLine.split(\"\\t\");\n+        \n+        int patientIdIndex = findPatientIdColumn(headerNames);\n+        int sampleIdIndex = findSampleIdColumn(headerNames);\n+        int resourceIdIndex = findResourceIdColumn(headerNames);\n+        int urlIndex = findURLColumn(headerNames);\n+\n+        // validate required columns:\n+        if (resourceIdIndex < 0) {\n+            throw new RuntimeException(\"Aborting owing to failure to find \" + RESOURCE_ID_COLUMN_NAME\n+                    + \" in file. Please check your file format and try again.\");\n+        }\n+        if (urlIndex < 0) {\n+            throw new RuntimeException(\"Aborting owing to failure to find \" + URL_COLUMN_NAME\n+                    + \" in file. Please check your file format and try again.\");\n+        }\n+        if ((resourceType.toString().equalsIgnoreCase(\"sample\") || resourceType.toString().equalsIgnoreCase(\"patient\")) && patientIdIndex < 0) {\n+            // PATIENT_ID is required in both patient and sample file types:\n+            throw new RuntimeException(\"Aborting owing to failure to find \" + PATIENT_ID_COLUMN_NAME\n+                    + \" in file. Please check your file format and try again.\");\n+        }\n+        if (resourceType.toString().equalsIgnoreCase(\"sample\") && sampleIdIndex < 0) {\n+            // SAMPLE_ID is required in SAMPLE file type:\n+            throw new RuntimeException(\"Aborting owing to failure to find \" + SAMPLE_ID_COLUMN_NAME\n+                    + \" in file. Please check your file format and try again.\");\n+        }\n+        importData(buff, resources, headerNames);\n+\n+        if (MySQLbulkLoader.isBulkLoad()) {\n+            MySQLbulkLoader.flushAll();\n+            MySQLbulkLoader.relaxedModeOff();\n+        }\n+    }\n+\n+    private List<ResourceDefinition> grabResources(BufferedReader buff) throws DaoException, IOException {\n+        List<ResourceDefinition> resources = new ArrayList<ResourceDefinition>();\n+        resources = DaoResourceDefinition.getDatumByStudy(cancerStudy.getInternalId());\n+        return resources;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTA5NjkzMQ=="}, "originalCommit": {"oid": "ad5abf7c9634a54ebf671517257638ed6e6141d8"}, "originalPosition": 112}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ0ODk3Mjc2OnYy", "diffSide": "RIGHT", "path": "core/src/main/java/org/mskcc/cbio/portal/scripts/ImportResourceData.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOVQxNToxNDowNFrOF4zKpQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOVQxNToxNDowNFrOF4zKpQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTEwMjg4NQ==", "bodyText": "typo pari --> pair", "url": "https://github.com/cBioPortal/cbioportal/pull/7270#discussion_r395102885", "createdAt": "2020-03-19T15:14:04Z", "author": {"login": "ao508"}, "path": "core/src/main/java/org/mskcc/cbio/portal/scripts/ImportResourceData.java", "diffHunk": "@@ -0,0 +1,574 @@\n+package org.mskcc.cbio.portal.scripts;\n+\n+import org.mskcc.cbio.portal.dao.*;\n+import org.mskcc.cbio.portal.model.*;\n+import org.mskcc.cbio.portal.util.*;\n+import org.mskcc.cbio.portal.util.ValuesUtils.MissingValues;\n+\n+import java.io.*;\n+import joptsimple.*;\n+import java.util.*;\n+import java.util.regex.*;\n+import java.util.stream.Collectors;\n+\n+import org.apache.commons.collections.map.MultiKeyMap;\n+\n+public class ImportResourceData extends ConsoleRunnable {\n+\n+    public static final String DELIMITER = \"\\t\";\n+    public static final String METADATA_PREFIX = \"#\";\n+    public static final String SAMPLE_ID_COLUMN_NAME = \"SAMPLE_ID\";\n+    public static final String PATIENT_ID_COLUMN_NAME = \"PATIENT_ID\";\n+    public static final String RESOURCE_ID_COLUMN_NAME = \"RESOURCE_ID\";\n+    public static final String URL_COLUMN_NAME = \"URL\";\n+    public static final String SAMPLE_TYPE_COLUMN_NAME = \"SAMPLE_TYPE\";\n+    private int numSampleSpecificResourcesAdded = 0;\n+    private int numPatientSpecificResourcesAdded = 0;\n+    private int numStudySpecificResourcesAdded = 0;\n+    private int numEmptyResourcesSkipped = 0;\n+    private int numSamplesProcessed = 0;\n+\n+    private static Properties properties;\n+\n+    private File resourceDataFile;\n+    private CancerStudy cancerStudy;\n+    private ResourceTypes resourceType;\n+    private boolean relaxed;\n+    private Set<String> patientIds = new HashSet<String>();\n+\n+    public static enum ResourceTypes {\n+        PATIENT(\"PATIENT\"), SAMPLE(\"SAMPLE\"), STUDY(\"STUDY\");\n+\n+        private String resourceTypes;\n+\n+        ResourceTypes(String resourceTypes) {\n+            this.resourceTypes = resourceTypes;\n+        }\n+\n+        public String toString() {\n+            return resourceTypes;\n+        }\n+    }\n+\n+    public void setFile(CancerStudy cancerStudy, File resourceDataFile, String resourceType, boolean relaxed) {\n+        this.cancerStudy = cancerStudy;\n+        this.resourceDataFile = resourceDataFile;\n+        this.resourceType = ResourceTypes.valueOf(resourceType);\n+        this.relaxed = relaxed;\n+    }\n+\n+    public void importData() throws Exception {\n+        // if bulkLoading is ever turned off,\n+        // code has to be added to check whether\n+        // a resource data update should be\n+        // perform instead of an insert\n+        MySQLbulkLoader.bulkLoadOn();\n+\n+        if (relaxed) {\n+            MySQLbulkLoader.relaxedModeOn();\n+        }\n+\n+        FileReader reader = new FileReader(resourceDataFile);\n+        BufferedReader buff = new BufferedReader(reader);\n+        List<ResourceDefinition> resources = grabResources(buff);\n+        String currentLine = buff.readLine();\n+        String[] headerNames = currentLine.split(\"\\t\");\n+        \n+        int patientIdIndex = findPatientIdColumn(headerNames);\n+        int sampleIdIndex = findSampleIdColumn(headerNames);\n+        int resourceIdIndex = findResourceIdColumn(headerNames);\n+        int urlIndex = findURLColumn(headerNames);\n+\n+        // validate required columns:\n+        if (resourceIdIndex < 0) {\n+            throw new RuntimeException(\"Aborting owing to failure to find \" + RESOURCE_ID_COLUMN_NAME\n+                    + \" in file. Please check your file format and try again.\");\n+        }\n+        if (urlIndex < 0) {\n+            throw new RuntimeException(\"Aborting owing to failure to find \" + URL_COLUMN_NAME\n+                    + \" in file. Please check your file format and try again.\");\n+        }\n+        if ((resourceType.toString().equalsIgnoreCase(\"sample\") || resourceType.toString().equalsIgnoreCase(\"patient\")) && patientIdIndex < 0) {\n+            // PATIENT_ID is required in both patient and sample file types:\n+            throw new RuntimeException(\"Aborting owing to failure to find \" + PATIENT_ID_COLUMN_NAME\n+                    + \" in file. Please check your file format and try again.\");\n+        }\n+        if (resourceType.toString().equalsIgnoreCase(\"sample\") && sampleIdIndex < 0) {\n+            // SAMPLE_ID is required in SAMPLE file type:\n+            throw new RuntimeException(\"Aborting owing to failure to find \" + SAMPLE_ID_COLUMN_NAME\n+                    + \" in file. Please check your file format and try again.\");\n+        }\n+        importData(buff, resources, headerNames);\n+\n+        if (MySQLbulkLoader.isBulkLoad()) {\n+            MySQLbulkLoader.flushAll();\n+            MySQLbulkLoader.relaxedModeOff();\n+        }\n+    }\n+\n+    private List<ResourceDefinition> grabResources(BufferedReader buff) throws DaoException, IOException {\n+        List<ResourceDefinition> resources = new ArrayList<ResourceDefinition>();\n+        resources = DaoResourceDefinition.getDatumByStudy(cancerStudy.getInternalId());\n+        return resources;\n+    }\n+\n+    private String[] splitFields(String line) throws IOException {\n+        line = line.replaceAll(\"^\" + METADATA_PREFIX + \"+\", \"\");\n+        String[] fields = line.split(DELIMITER, -1);\n+\n+        return fields;\n+    }\n+\n+    private void importData(BufferedReader buff, List<ResourceDefinition> resources, String[] headerNames) throws Exception {\n+        String line;\n+        MultiKeyMap resourceMap = new MultiKeyMap();\n+        while ((line = buff.readLine()) != null) {\n+            if (skipLine(line.trim())) {\n+                continue;\n+            }\n+\n+            String[] fieldValues = getFieldValues(line, headerNames);\n+            addDatum(fieldValues, resources, resourceMap, headerNames);\n+        }\n+    }\n+\n+    private boolean skipLine(String line) {\n+        return (line.isEmpty() || line.substring(0, 1).equals(METADATA_PREFIX));\n+    }\n+\n+    /**\n+     * Takes in the given line and returns the list of field values by splitting the\n+     * line on DELIMITER.\n+     * \n+     * @param line\n+     * @param headerNames\n+     * @return the list of values, one for each column. Value will be \"\" for empty\n+     *         columns.\n+     */\n+    private String[] getFieldValues(String line, String[] headerNames) {\n+        // split on delimiter:\n+        String[] fieldValues = line.split(DELIMITER, -1);\n+\n+        // validate: if number of fields is incorrect, give exception\n+        if (fieldValues.length != headerNames.length) {\n+            throw new IllegalArgumentException(\"Number of columns in line is not as expected. Expected: \"\n+                    + headerNames.length + \" columns, found: \" + fieldValues.length + \", for line: \" + line);\n+        }\n+\n+        // now iterate over lines and trim each value:\n+        for (int i = 0; i < fieldValues.length; i++) {\n+            fieldValues[i] = fieldValues[i].trim();\n+        }\n+        return fieldValues;\n+    }\n+\n+    private boolean addDatum(String[] fields, List<ResourceDefinition> resources, MultiKeyMap resourceMap, String[] headerNames)\n+            throws Exception {\n+        int sampleIdIndex = findSampleIdColumn(headerNames);\n+        String stableSampleId = (sampleIdIndex >= 0) ? fields[sampleIdIndex] : \"\";\n+        stableSampleId = StableIdUtil.getSampleId(stableSampleId);\n+        int patientIdIndex = findPatientIdColumn(headerNames);\n+        String stablePatientId = (patientIdIndex >= 0) ? fields[patientIdIndex] : \"\";\n+        stablePatientId = StableIdUtil.getPatientId(stablePatientId);\n+        int resourceIdIndex = findResourceIdColumn(headerNames);\n+        int urlIndex = findURLColumn(headerNames);\n+        int internalSampleId = -1;\n+        int internalPatientId = -1;\n+\n+        // create resource_id set\n+        Set<String> patientResourceIdSet = resources\n+                .stream()\n+                .filter(resource -> resource.getResourceType().equals(ResourceDefinition.PATIENT_RESOURCE_TYPE))\n+                .map(resource -> resource.getResourceId())\n+                .collect(Collectors.toSet());\n+        Set<String> sampleResourceIdSet = resources\n+                .stream()\n+                .filter(resource -> resource.getResourceType().equals(ResourceDefinition.SAMPLE_RESOURCE_TYPE))\n+                .map(resource -> resource.getResourceId())\n+                .collect(Collectors.toSet());\n+        Set<String> studyResourceIdSet = resources\n+                .stream()\n+                .filter(resource -> resource.getResourceType().equals(ResourceDefinition.STUDY_RESOURCE_TYPE))\n+                .map(resource -> resource.getResourceId())\n+                .collect(Collectors.toSet());\n+\n+        // check if sample is not already added:\n+        Sample sample = DaoSample.getSampleByCancerStudyAndSampleId(cancerStudy.getInternalId(), stableSampleId, false);\n+        if (sample != null) {\n+            // get internal sample id if sample exists\n+            internalSampleId = sample.getInternalId();\n+        } else {\n+            Patient patient = DaoPatient.getPatientByCancerStudyAndPatientId(cancerStudy.getInternalId(),\n+                    stablePatientId);\n+            if (patient != null) {\n+                // patient exists, get internal id:\n+                internalPatientId = patient.getInternalId();\n+            } else {\n+                // add patient:\n+                internalPatientId = (patientIdIndex >= 0) ? addPatientToDatabase(fields[patientIdIndex]) : -1;\n+            }\n+            // sample is new, so attempt to add to DB\n+            internalSampleId = (stableSampleId.length() > 0) ? addSampleToDatabase(stableSampleId, fields, headerNames)\n+                    : -1;\n+        }\n+\n+        // validate and count:\n+        if (internalSampleId != -1) {\n+            // some minimal validation/fail safe for now: only continue if patientId is same\n+            // as patient id in\n+            // existing sample (can occur in case of this.isSupplementalData or in case of\n+            // parsing bug in addSampleToDatabase):\n+            internalPatientId = DaoPatient\n+                    .getPatientByCancerStudyAndPatientId(cancerStudy.getInternalId(), stablePatientId).getInternalId();\n+            if (internalPatientId != DaoSample.getSampleById(internalSampleId).getInternalPatientId()) {\n+                throw new RuntimeException(\"Error: Sample \" + stableSampleId\n+                        + \" was previously linked to another patient, and not to \" + stablePatientId);\n+            }\n+            numSamplesProcessed++;\n+        }\n+\n+        // if the resource id or url matches one of the missing values, skip this resource:\n+        if ((resourceIdIndex != -1 && MissingValues.has(fields[resourceIdIndex])) || (urlIndex != -1 && MissingValues.has(fields[urlIndex]))) {\n+            numEmptyResourcesSkipped++;\n+        } else {\n+            // if patient_id column exists and resource type is patient\n+            if (getResourceType() == ImportResourceData.ResourceTypes.PATIENT && internalPatientId != -1) {\n+                validateAddDatum(internalPatientId, stablePatientId, fields[resourceIdIndex], fields[urlIndex], \n+                        ResourceDefinition.PATIENT_RESOURCE_TYPE, patientResourceIdSet, resourceMap);\n+            } \n+            // if sample_id column exists and resource type is sample\n+            else if (getResourceType() == ImportResourceData.ResourceTypes.SAMPLE && internalSampleId != -1) {\n+                validateAddDatum(internalSampleId, stableSampleId, fields[resourceIdIndex], fields[urlIndex], \n+                        ResourceDefinition.SAMPLE_RESOURCE_TYPE, sampleResourceIdSet, resourceMap);\n+            }\n+            // if resource type is study\n+            else if (getResourceType() == ImportResourceData.ResourceTypes.STUDY) {\n+                validateAddDatum(cancerStudy.getInternalId(), cancerStudy.getCancerStudyStableId(), fields[resourceIdIndex], fields[urlIndex], \n+                        ResourceDefinition.STUDY_RESOURCE_TYPE, studyResourceIdSet, resourceMap);\n+            }\n+        }\n+        return true;\n+    }\n+\n+    private int findPatientIdColumn(String[] headerNames) {\n+        return findColumnIndexInHeaders(PATIENT_ID_COLUMN_NAME, headerNames);\n+    }\n+\n+    private int findSampleIdColumn(String[] headerNames) {\n+        return findColumnIndexInHeaders(SAMPLE_ID_COLUMN_NAME, headerNames);\n+    }\n+\n+    private int findResourceIdColumn(String[] headerNames) {\n+        return findColumnIndexInHeaders(RESOURCE_ID_COLUMN_NAME, headerNames);\n+    }\n+\n+    private int findURLColumn(String[] headerNames) {\n+        return findColumnIndexInHeaders(URL_COLUMN_NAME, headerNames);\n+    }\n+\n+    private int findSampleTypeColumn(String[] headerNames) {\n+        return findColumnIndexInHeaders(SAMPLE_TYPE_COLUMN_NAME, headerNames);\n+    }\n+\n+    private int findColumnIndexInHeaders(String columnHeader, String[] headerNames) {\n+        for (int lc = 0; lc < headerNames.length; lc++) {\n+            if (headerNames[lc].equals(columnHeader)) {\n+                return lc;\n+            }\n+        }\n+        return -1;\n+    }\n+\n+    private int addPatientToDatabase(String patientId) throws Exception {\n+        int internalPatientId = -1;\n+        if (validPatientId(patientId)) {\n+            Patient patient = DaoPatient.getPatientByCancerStudyAndPatientId(cancerStudy.getInternalId(), patientId);\n+            // other validations:\n+            // in case of PATIENT data import, there are some special checks:\n+            if (getResourceType() == ImportResourceData.ResourceTypes.PATIENT) {\n+                // if resource data is already there, then something has gone wrong (e.g.\n+                // patient is duplicated in file), abort:\n+                if (patient != null\n+                        && DaoResourceData.getDataByPatientId(cancerStudy.getInternalId(), patientId).size() > 0) {\n+                    throw new RuntimeException(\n+                            \"Something has gone wrong. Patient \" + patientId + \" already has resource data loaded.\");\n+                }\n+                // if patient is duplicated, abort as well in this case:\n+                if (!patientIds.add(patientId)) {\n+                    throw new RuntimeException(\"Error. Patient \" + patientId + \" found to be duplicated in your file.\");\n+                }\n+            }\n+\n+            if (patient != null) {\n+                // in all cases (SAMPLE, PATIENT, or STUDY) this can be expected, so\n+                // just fetch it:\n+                internalPatientId = patient.getInternalId();\n+            } else {\n+                // in case of PATIENT data import and patient == null :\n+                if (getResourceType() == ImportResourceData.ResourceTypes.PATIENT) {\n+                    // not finding the patient it unexpected (as SAMPLE data import should always\n+                    // precede it), but\n+                    // can happen when this patient does not have any samples for example. In any\n+                    // case, warn about it:\n+                    ProgressMonitor.logWarning(\"Patient \" + patientId\n+                            + \" being added for the first time. Apparently this patient was not in the samples file, or the samples file is not yet loaded (should be loaded before this one)\");\n+                }\n+\n+                patient = new Patient(cancerStudy, patientId);\n+                internalPatientId = DaoPatient.addPatient(patient);\n+            }\n+        }\n+        return internalPatientId;\n+    }\n+\n+    private int addSampleToDatabase(String sampleId, String[] fields, String[] headerNames)\n+            throws Exception {\n+        int sampleTypeIndex = findSampleTypeColumn(headerNames);\n+        String sampleTypeStr = (sampleTypeIndex != -1) ? fields[sampleTypeIndex] : null;\n+        if (sampleTypeStr != null) {\n+            // want to match Sample.Type enum names\n+            sampleTypeStr = sampleTypeStr.trim().toUpperCase().replaceAll(\" \", \"_\");\n+        }\n+        Sample.Type sampleType = Sample.Type.has(sampleTypeStr) ? Sample.Type.valueOf(sampleTypeStr) : null;\n+\n+        int internalSampleId = -1;\n+        if (validSampleId(sampleId) && !StableIdUtil.isNormal(sampleId)) {\n+            // want to try and capture normal sample types based on value for SAMPLE_TYPE\n+            // if present in resource data\n+            if (sampleType != null && sampleType.isNormal()) {\n+                return internalSampleId;\n+            }\n+            String stablePatientId = getStablePatientId(sampleId, fields, headerNames);\n+            if (validPatientId(stablePatientId)) {\n+                Patient patient = DaoPatient.getPatientByCancerStudyAndPatientId(cancerStudy.getInternalId(),\n+                        stablePatientId);\n+                if (patient == null) {\n+                    addPatientToDatabase(stablePatientId);\n+                    patient = DaoPatient.getPatientByCancerStudyAndPatientId(cancerStudy.getInternalId(),\n+                            stablePatientId);\n+                }\n+                sampleId = StableIdUtil.getSampleId(sampleId);\n+                internalSampleId = DaoSample.addSample(\n+                        new Sample(sampleId, patient.getInternalId(), cancerStudy.getTypeOfCancerId(), sampleTypeStr));\n+            }\n+        }\n+\n+        return internalSampleId;\n+    }\n+\n+    private String getStablePatientId(String sampleId, String[] fields, String[] headerNames) {\n+        Matcher tcgaSampleBarcodeMatcher = StableIdUtil.TCGA_PATIENT_BARCODE_FROM_SAMPLE_REGEX.matcher(sampleId);\n+        if (tcgaSampleBarcodeMatcher.find()) {\n+            return tcgaSampleBarcodeMatcher.group(1);\n+        } else {\n+            // internal studies should have a patient id column\n+            int patientIdIndex = findPatientIdColumn(headerNames);\n+            if (patientIdIndex >= 0) {\n+                return fields[patientIdIndex];\n+            }\n+            // sample and patient id are the same\n+            else {\n+                return sampleId;\n+            }\n+        }\n+    }\n+\n+    private boolean validPatientId(String patientId) {\n+        return (patientId != null && !patientId.isEmpty());\n+    }\n+\n+    private boolean validSampleId(String sampleId) {\n+        return (sampleId != null && !sampleId.isEmpty());\n+    }\n+\n+    private void validateAddDatum(int internalId, String stableId, String resourceId, String resourceURL, String resourceType, Set<String> resourceSet, MultiKeyMap resourceMap) throws Exception {\n+        // throw exception if resource definition is not exist in the database\n+        if (!resourceSet.contains(resourceId)) {\n+            throw new RuntimeException(\"Error: \" + resourceType.toLowerCase() + \" \" + stableId\n+            + \" with resource \" + resourceId\n+            + \" does not have matching resources information in database, please make sure to include resource definition in the resource definition file\");\n+        }\n+        // The resourceMap makes sure a pari of (internalId/resource_id/url) is unique", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ad5abf7c9634a54ebf671517257638ed6e6141d8"}, "originalPosition": 391}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ0OTAyNTgxOnYy", "diffSide": "RIGHT", "path": "core/src/main/java/org/mskcc/cbio/portal/dao/DaoResourceData.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOVQxNToyNToyMlrOF4zsYA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOVQxNToyNToyMlrOF4zsYA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTExMTUyMA==", "bodyText": "looks like it is used just at one place and the method is just one line. better remove this method and replace line 116", "url": "https://github.com/cBioPortal/cbioportal/pull/7270#discussion_r395111520", "createdAt": "2020-03-19T15:25:22Z", "author": {"login": "kalletlak"}, "path": "core/src/main/java/org/mskcc/cbio/portal/dao/DaoResourceData.java", "diffHunk": "@@ -0,0 +1,219 @@\n+package org.mskcc.cbio.portal.dao;\n+\n+import org.mskcc.cbio.portal.model.*;\n+import org.mskcc.cbio.portal.util.InternalIdUtil;\n+\n+import org.apache.commons.lang.StringUtils;\n+\n+import java.sql.*;\n+import java.util.*;\n+\n+/**\n+ * Data Access Object for `resource` tables\n+ */\n+public final class DaoResourceData {\n+\n+    public static final String SAMPLE_TABLE = \"resource_sample\";\n+    public static final String PATIENT_TABLE = \"resource_patient\";\n+    public static final String STUDY_TABLE = \"resource_study\";\n+\n+    private static final String SAMPLE_INSERT = \"INSERT INTO \" + SAMPLE_TABLE\n+            + \"(`INTERNAL_ID`,`RESOURCE_ID`,`URL` VALUES(?,?,?)\";\n+    private static final String PATIENT_INSERT = \"INSERT INTO \" + PATIENT_TABLE\n+            + \"(`INTERNAL_ID`,`RESOURCE_ID`,`URL` VALUES(?,?,?)\";\n+    private static final String STUDY_INSERT = \"INSERT INTO \" + STUDY_TABLE\n+            + \"(`INTERNAL_ID`,`RESOURCE_ID`,`URL` VALUES(?,?,?)\";\n+\n+    private static final Map<String, String> sampleResources = new HashMap<String, String>();\n+    private static final Map<String, String> patientResources = new HashMap<String, String>();\n+    private static final Map<String, String> studyResources = new HashMap<String, String>();\n+\n+    private DaoResourceData() {\n+    }\n+\n+    public static synchronized void reCache() {\n+        clearCache();\n+        cacheResources(SAMPLE_TABLE, sampleResources);\n+        cacheResources(PATIENT_TABLE, patientResources);\n+        cacheResources(STUDY_TABLE, studyResources);\n+    }\n+\n+    private static void clearCache() {\n+        sampleResources.clear();\n+        patientResources.clear();\n+        studyResources.clear();\n+    }\n+\n+    private static void cacheResources(String table, Map<String, String> cache) {\n+        Connection con = null;\n+        PreparedStatement pstmt = null;\n+        ResultSet rs = null;\n+        try {\n+            con = JdbcUtil.getDbConnection(DaoResourceData.class);\n+            pstmt = con.prepareStatement(\"SELECT * FROM \" + table);\n+            rs = pstmt.executeQuery();\n+            while (rs.next()) {\n+                cache.put(rs.getString(\"RESOURCE_ID\"), rs.getString(\"RESOURCE_ID\"));\n+            }\n+        } catch (SQLException e) {\n+            e.printStackTrace();\n+        } finally {\n+            JdbcUtil.closeAll(DaoResourceData.class, con, pstmt, rs);\n+        }\n+    }\n+\n+    public static int addSampleDatum(int internalSampleId, String resourceId, String url) throws DaoException {\n+        sampleResources.put(resourceId, resourceId);\n+        return addDatum(SAMPLE_INSERT, SAMPLE_TABLE, internalSampleId, resourceId, url);\n+    }\n+\n+    public static int addPatientDatum(int internalPatientId, String resourceId, String url) throws DaoException {\n+        patientResources.put(resourceId, resourceId);\n+        return addDatum(PATIENT_INSERT, PATIENT_TABLE, internalPatientId, resourceId, url);\n+    }\n+\n+    public static int addStudyDatum(int internalStudyId, String resourceId, String url) throws DaoException {\n+        patientResources.put(resourceId, resourceId);\n+        return addDatum(STUDY_INSERT, STUDY_TABLE, internalStudyId, resourceId, url);\n+    }\n+\n+    public static int addDatum(String query, String tableName, int internalId, String resourceId, String url)\n+            throws DaoException {\n+        if (MySQLbulkLoader.isBulkLoad()) {\n+            MySQLbulkLoader.getMySQLbulkLoader(tableName).insertRecord(Integer.toString(internalId), resourceId, url);\n+            return 1;\n+        }\n+\n+        Connection con = null;\n+        PreparedStatement pstmt = null;\n+        ResultSet rs = null;\n+        try {\n+            con = JdbcUtil.getDbConnection(DaoResourceData.class);\n+\n+            pstmt = con.prepareStatement(query);\n+            pstmt.setInt(1, internalId);\n+            pstmt.setString(2, resourceId);\n+            pstmt.setString(3, url);\n+            int toReturn = pstmt.executeUpdate();\n+\n+            if (tableName.equals(PATIENT_TABLE)) {\n+                patientResources.put(resourceId, resourceId);\n+            } else if (tableName.equals(SAMPLE_TABLE)){\n+                sampleResources.put(resourceId, resourceId);\n+            } else {\n+                studyResources.put(resourceId, resourceId);\n+            }\n+\n+            return toReturn;\n+        } catch (SQLException e) {\n+            throw new DaoException(e);\n+        } finally {\n+            JdbcUtil.closeAll(DaoResourceData.class, con, pstmt, rs);\n+        }\n+    }\n+\n+    public static ResourceBaseData getDatum(String cancerStudyId, String patientId, String resourceId) throws DaoException {\n+        int internalCancerStudyId = getInternalCancerStudyId(cancerStudyId);\n+        String table = getResourceTable(resourceId);\n+        if (table == null) {\n+            return null;\n+        }\n+        return getDatum(internalCancerStudyId, table,\n+                DaoPatient.getPatientByCancerStudyAndPatientId(internalCancerStudyId, patientId).getInternalId(),\n+                resourceId);\n+    }\n+\n+    private static int getInternalCancerStudyId(String cancerStudyId) throws DaoException {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ad5abf7c9634a54ebf671517257638ed6e6141d8"}, "originalPosition": 126}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ0OTAzMDgzOnYy", "diffSide": "RIGHT", "path": "core/src/main/java/org/mskcc/cbio/portal/scripts/ImportResourceDefinition.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOVQxNToyNjoyNFrOF4zvew==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOVQxODoxNTozNVrOF46xug==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTExMjMxNQ==", "bodyText": "here you just want to parse the boolean value right? and if it's not \"true\" or \"false\" then the default would be false?\nthe Boolean java docs describes a built in method for parsing a boolean from a string and I think it's the exact behavior you're looking for too\nhttps://docs.oracle.com/javase/8/docs/api/java/lang/Boolean.html", "url": "https://github.com/cBioPortal/cbioportal/pull/7270#discussion_r395112315", "createdAt": "2020-03-19T15:26:24Z", "author": {"login": "ao508"}, "path": "core/src/main/java/org/mskcc/cbio/portal/scripts/ImportResourceDefinition.java", "diffHunk": "@@ -0,0 +1,330 @@\n+package org.mskcc.cbio.portal.scripts;\n+\n+import org.mskcc.cbio.portal.dao.*;\n+import org.mskcc.cbio.portal.model.*;\n+import org.mskcc.cbio.portal.scripts.ImportResourceData.ResourceTypes;\n+import org.mskcc.cbio.portal.util.*;\n+import org.mskcc.cbio.portal.util.ValuesUtils.MissingValues;\n+\n+import java.io.*;\n+import joptsimple.*;\n+import java.util.*;\n+\n+public class ImportResourceDefinition extends ConsoleRunnable {\n+\n+    public static final String DELIMITER = \"\\t\";\n+    public static final String RESOURCE_ID_COLUMN_NAME = \"RESOURCE_ID\";\n+    public static final String DISPLAY_NAME_COLUMN_NAME = \"DISPLAY_NAME\";\n+    public static final String DESCRIPTION_COLUMN_NAME = \"DESCRIPTION\";\n+    public static final String RESOURCE_TYPE_COLUMN_NAME = \"RESOURCE_TYPE\";\n+    public static final String OPEN_BY_DEFAULT_COLUMN_NAME = \"OPEN_BY_DEFAULT\";\n+    public static final String PRIORITY_COLUMN_NAME = \"PRIORITY\";\n+    private int numResourceDefinitionsAdded = 0;\n+\n+    private static Properties properties;\n+\n+    private File resourceDataFile;\n+    private CancerStudy cancerStudy;\n+    private boolean relaxed;\n+\n+    public void setFile(CancerStudy cancerStudy, File resourceDataFile, boolean relaxed) {\n+        this.cancerStudy = cancerStudy;\n+        this.resourceDataFile = resourceDataFile;\n+        this.relaxed = relaxed;\n+    }\n+\n+    public void importData() throws Exception {\n+        // if bulkLoading is ever turned off,\n+        // code has to be added to check whether\n+        // a resource data update should be\n+        // perform instead of an insert\n+        MySQLbulkLoader.bulkLoadOn();\n+\n+        if (relaxed) {\n+            MySQLbulkLoader.relaxedModeOn();\n+        }\n+\n+        FileReader reader = new FileReader(resourceDataFile);\n+        BufferedReader buff = new BufferedReader(reader);\n+\n+        String line = buff.readLine();\n+        String[] headerNames = splitFields(line);\n+\n+        // validate columns and get index\n+        int resourceIdIndex = findAndValidateResourceIdColumn(headerNames);\n+        int displayNameIndex = findAndValidateDisplayNameColumn(headerNames);\n+        int descriptionIndex = findAndValidateDescriptionColumn(headerNames);\n+        int resourceTypeIndex = findAndValidateResourceTypeColumn(headerNames);\n+        int openByDefaultIndex = findAndValidateOpenByDefaultColumn(headerNames);\n+        int priorityIndex = findAndValidatePriorityColumn(headerNames);\n+\n+        while ((line = buff.readLine()) != null) {\n+            if (skipLine(line.trim())) {\n+                continue;\n+            }\n+\n+            String[] fieldValues = getFieldValues(line, headerNames);\n+\n+            // set default value\n+            String resourceId = \"\";\n+            String displayName = \"\";\n+            String description = \"\";\n+            String resourceType = \"\";\n+            Boolean openByDefault = false;\n+            int priority = 1;\n+            // get resource definitions from columns\n+            // get resourceId\n+            if (resourceIdIndex != -1 && isValueNotMissing(fieldValues[resourceIdIndex].toUpperCase())) {\n+                resourceId = fieldValues[resourceIdIndex].toUpperCase();\n+            } else {\n+                throw new RuntimeException(\n+                        \"Please provide a valid resource id\");\n+            }\n+            // get displayName\n+            if (resourceIdIndex != -1 && isValueNotMissing(fieldValues[displayNameIndex])) {\n+                displayName = fieldValues[displayNameIndex];\n+            }\n+            else {\n+                throw new RuntimeException(\n+                        \"Please provide a valid display name\");\n+            }\n+            // get description (optional)\n+            if (descriptionIndex != -1 && isValueNotMissing(fieldValues[descriptionIndex])) {\n+                description = fieldValues[descriptionIndex];\n+            }\n+            // get resourceType (must be value of ResourceTypes)\n+            if (resourceTypeIndex != -1 && isValidResourceType(fieldValues[resourceTypeIndex])) {\n+                resourceType = fieldValues[resourceTypeIndex];\n+            }\n+            // get openByDefault (optional)\n+            if (openByDefaultIndex != -1 && isValidOpenByDefault(fieldValues[openByDefaultIndex])) {\n+                openByDefault = fieldValues[openByDefaultIndex].equalsIgnoreCase(\"true\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ad5abf7c9634a54ebf671517257638ed6e6141d8"}, "originalPosition": 101}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTIyNzU3OA==", "bodyText": "Thanks! Good to know this!", "url": "https://github.com/cBioPortal/cbioportal/pull/7270#discussion_r395227578", "createdAt": "2020-03-19T18:15:35Z", "author": {"login": "dippindots"}, "path": "core/src/main/java/org/mskcc/cbio/portal/scripts/ImportResourceDefinition.java", "diffHunk": "@@ -0,0 +1,330 @@\n+package org.mskcc.cbio.portal.scripts;\n+\n+import org.mskcc.cbio.portal.dao.*;\n+import org.mskcc.cbio.portal.model.*;\n+import org.mskcc.cbio.portal.scripts.ImportResourceData.ResourceTypes;\n+import org.mskcc.cbio.portal.util.*;\n+import org.mskcc.cbio.portal.util.ValuesUtils.MissingValues;\n+\n+import java.io.*;\n+import joptsimple.*;\n+import java.util.*;\n+\n+public class ImportResourceDefinition extends ConsoleRunnable {\n+\n+    public static final String DELIMITER = \"\\t\";\n+    public static final String RESOURCE_ID_COLUMN_NAME = \"RESOURCE_ID\";\n+    public static final String DISPLAY_NAME_COLUMN_NAME = \"DISPLAY_NAME\";\n+    public static final String DESCRIPTION_COLUMN_NAME = \"DESCRIPTION\";\n+    public static final String RESOURCE_TYPE_COLUMN_NAME = \"RESOURCE_TYPE\";\n+    public static final String OPEN_BY_DEFAULT_COLUMN_NAME = \"OPEN_BY_DEFAULT\";\n+    public static final String PRIORITY_COLUMN_NAME = \"PRIORITY\";\n+    private int numResourceDefinitionsAdded = 0;\n+\n+    private static Properties properties;\n+\n+    private File resourceDataFile;\n+    private CancerStudy cancerStudy;\n+    private boolean relaxed;\n+\n+    public void setFile(CancerStudy cancerStudy, File resourceDataFile, boolean relaxed) {\n+        this.cancerStudy = cancerStudy;\n+        this.resourceDataFile = resourceDataFile;\n+        this.relaxed = relaxed;\n+    }\n+\n+    public void importData() throws Exception {\n+        // if bulkLoading is ever turned off,\n+        // code has to be added to check whether\n+        // a resource data update should be\n+        // perform instead of an insert\n+        MySQLbulkLoader.bulkLoadOn();\n+\n+        if (relaxed) {\n+            MySQLbulkLoader.relaxedModeOn();\n+        }\n+\n+        FileReader reader = new FileReader(resourceDataFile);\n+        BufferedReader buff = new BufferedReader(reader);\n+\n+        String line = buff.readLine();\n+        String[] headerNames = splitFields(line);\n+\n+        // validate columns and get index\n+        int resourceIdIndex = findAndValidateResourceIdColumn(headerNames);\n+        int displayNameIndex = findAndValidateDisplayNameColumn(headerNames);\n+        int descriptionIndex = findAndValidateDescriptionColumn(headerNames);\n+        int resourceTypeIndex = findAndValidateResourceTypeColumn(headerNames);\n+        int openByDefaultIndex = findAndValidateOpenByDefaultColumn(headerNames);\n+        int priorityIndex = findAndValidatePriorityColumn(headerNames);\n+\n+        while ((line = buff.readLine()) != null) {\n+            if (skipLine(line.trim())) {\n+                continue;\n+            }\n+\n+            String[] fieldValues = getFieldValues(line, headerNames);\n+\n+            // set default value\n+            String resourceId = \"\";\n+            String displayName = \"\";\n+            String description = \"\";\n+            String resourceType = \"\";\n+            Boolean openByDefault = false;\n+            int priority = 1;\n+            // get resource definitions from columns\n+            // get resourceId\n+            if (resourceIdIndex != -1 && isValueNotMissing(fieldValues[resourceIdIndex].toUpperCase())) {\n+                resourceId = fieldValues[resourceIdIndex].toUpperCase();\n+            } else {\n+                throw new RuntimeException(\n+                        \"Please provide a valid resource id\");\n+            }\n+            // get displayName\n+            if (resourceIdIndex != -1 && isValueNotMissing(fieldValues[displayNameIndex])) {\n+                displayName = fieldValues[displayNameIndex];\n+            }\n+            else {\n+                throw new RuntimeException(\n+                        \"Please provide a valid display name\");\n+            }\n+            // get description (optional)\n+            if (descriptionIndex != -1 && isValueNotMissing(fieldValues[descriptionIndex])) {\n+                description = fieldValues[descriptionIndex];\n+            }\n+            // get resourceType (must be value of ResourceTypes)\n+            if (resourceTypeIndex != -1 && isValidResourceType(fieldValues[resourceTypeIndex])) {\n+                resourceType = fieldValues[resourceTypeIndex];\n+            }\n+            // get openByDefault (optional)\n+            if (openByDefaultIndex != -1 && isValidOpenByDefault(fieldValues[openByDefaultIndex])) {\n+                openByDefault = fieldValues[openByDefaultIndex].equalsIgnoreCase(\"true\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTExMjMxNQ=="}, "originalCommit": {"oid": "ad5abf7c9634a54ebf671517257638ed6e6141d8"}, "originalPosition": 101}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ0OTA0NDUwOnYy", "diffSide": "RIGHT", "path": "core/src/main/java/org/mskcc/cbio/portal/util/ValuesUtils.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOVQxNToyOToxN1rOF4z4RQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOVQxNToyOToxN1rOF4z4RQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTExNDU2NQ==", "bodyText": "for consistency would you mind putting these enum types on their own separate lines?", "url": "https://github.com/cBioPortal/cbioportal/pull/7270#discussion_r395114565", "createdAt": "2020-03-19T15:29:17Z", "author": {"login": "ao508"}, "path": "core/src/main/java/org/mskcc/cbio/portal/util/ValuesUtils.java", "diffHunk": "@@ -0,0 +1,36 @@\n+package org.mskcc.cbio.portal.util;\n+\n+public class ValuesUtils {\n+    public static enum MissingValues {\n+        NOT_APPLICABLE(\"Not Applicable\"), NOT_AVAILABLE(\"Not Available\"), PENDING(\"Pending\"),\t", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ad5abf7c9634a54ebf671517257638ed6e6141d8"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ0OTI5Mjk0OnYy", "diffSide": "RIGHT", "path": "core/src/main/java/org/mskcc/cbio/portal/scripts/ImportResourceData.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOVQxNjoyNjo0N1rOF42a2A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOVQxNjoyNjo0N1rOF42a2A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTE1NjE4NA==", "bodyText": "buff is never used", "url": "https://github.com/cBioPortal/cbioportal/pull/7270#discussion_r395156184", "createdAt": "2020-03-19T16:26:47Z", "author": {"login": "kalletlak"}, "path": "core/src/main/java/org/mskcc/cbio/portal/scripts/ImportResourceData.java", "diffHunk": "@@ -0,0 +1,574 @@\n+package org.mskcc.cbio.portal.scripts;\n+\n+import org.mskcc.cbio.portal.dao.*;\n+import org.mskcc.cbio.portal.model.*;\n+import org.mskcc.cbio.portal.util.*;\n+import org.mskcc.cbio.portal.util.ValuesUtils.MissingValues;\n+\n+import java.io.*;\n+import joptsimple.*;\n+import java.util.*;\n+import java.util.regex.*;\n+import java.util.stream.Collectors;\n+\n+import org.apache.commons.collections.map.MultiKeyMap;\n+\n+public class ImportResourceData extends ConsoleRunnable {\n+\n+    public static final String DELIMITER = \"\\t\";\n+    public static final String METADATA_PREFIX = \"#\";\n+    public static final String SAMPLE_ID_COLUMN_NAME = \"SAMPLE_ID\";\n+    public static final String PATIENT_ID_COLUMN_NAME = \"PATIENT_ID\";\n+    public static final String RESOURCE_ID_COLUMN_NAME = \"RESOURCE_ID\";\n+    public static final String URL_COLUMN_NAME = \"URL\";\n+    public static final String SAMPLE_TYPE_COLUMN_NAME = \"SAMPLE_TYPE\";\n+    private int numSampleSpecificResourcesAdded = 0;\n+    private int numPatientSpecificResourcesAdded = 0;\n+    private int numStudySpecificResourcesAdded = 0;\n+    private int numEmptyResourcesSkipped = 0;\n+    private int numSamplesProcessed = 0;\n+\n+    private static Properties properties;\n+\n+    private File resourceDataFile;\n+    private CancerStudy cancerStudy;\n+    private ResourceTypes resourceType;\n+    private boolean relaxed;\n+    private Set<String> patientIds = new HashSet<String>();\n+\n+    public static enum ResourceTypes {\n+        PATIENT(\"PATIENT\"), SAMPLE(\"SAMPLE\"), STUDY(\"STUDY\");\n+\n+        private String resourceTypes;\n+\n+        ResourceTypes(String resourceTypes) {\n+            this.resourceTypes = resourceTypes;\n+        }\n+\n+        public String toString() {\n+            return resourceTypes;\n+        }\n+    }\n+\n+    public void setFile(CancerStudy cancerStudy, File resourceDataFile, String resourceType, boolean relaxed) {\n+        this.cancerStudy = cancerStudy;\n+        this.resourceDataFile = resourceDataFile;\n+        this.resourceType = ResourceTypes.valueOf(resourceType);\n+        this.relaxed = relaxed;\n+    }\n+\n+    public void importData() throws Exception {\n+        // if bulkLoading is ever turned off,\n+        // code has to be added to check whether\n+        // a resource data update should be\n+        // perform instead of an insert\n+        MySQLbulkLoader.bulkLoadOn();\n+\n+        if (relaxed) {\n+            MySQLbulkLoader.relaxedModeOn();\n+        }\n+\n+        FileReader reader = new FileReader(resourceDataFile);\n+        BufferedReader buff = new BufferedReader(reader);\n+        List<ResourceDefinition> resources = grabResources(buff);\n+        String currentLine = buff.readLine();\n+        String[] headerNames = currentLine.split(\"\\t\");\n+        \n+        int patientIdIndex = findPatientIdColumn(headerNames);\n+        int sampleIdIndex = findSampleIdColumn(headerNames);\n+        int resourceIdIndex = findResourceIdColumn(headerNames);\n+        int urlIndex = findURLColumn(headerNames);\n+\n+        // validate required columns:\n+        if (resourceIdIndex < 0) {\n+            throw new RuntimeException(\"Aborting owing to failure to find \" + RESOURCE_ID_COLUMN_NAME\n+                    + \" in file. Please check your file format and try again.\");\n+        }\n+        if (urlIndex < 0) {\n+            throw new RuntimeException(\"Aborting owing to failure to find \" + URL_COLUMN_NAME\n+                    + \" in file. Please check your file format and try again.\");\n+        }\n+        if ((resourceType.toString().equalsIgnoreCase(\"sample\") || resourceType.toString().equalsIgnoreCase(\"patient\")) && patientIdIndex < 0) {\n+            // PATIENT_ID is required in both patient and sample file types:\n+            throw new RuntimeException(\"Aborting owing to failure to find \" + PATIENT_ID_COLUMN_NAME\n+                    + \" in file. Please check your file format and try again.\");\n+        }\n+        if (resourceType.toString().equalsIgnoreCase(\"sample\") && sampleIdIndex < 0) {\n+            // SAMPLE_ID is required in SAMPLE file type:\n+            throw new RuntimeException(\"Aborting owing to failure to find \" + SAMPLE_ID_COLUMN_NAME\n+                    + \" in file. Please check your file format and try again.\");\n+        }\n+        importData(buff, resources, headerNames);\n+\n+        if (MySQLbulkLoader.isBulkLoad()) {\n+            MySQLbulkLoader.flushAll();\n+            MySQLbulkLoader.relaxedModeOff();\n+        }\n+    }\n+\n+    private List<ResourceDefinition> grabResources(BufferedReader buff) throws DaoException, IOException {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ad5abf7c9634a54ebf671517257638ed6e6141d8"}, "originalPosition": 109}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ0OTMwNjc2OnYy", "diffSide": "RIGHT", "path": "core/src/main/java/org/mskcc/cbio/portal/scripts/ImportResourceData.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOVQxNjozMDowN1rOF42kEQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOVQxNjozMDowN1rOF42kEQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTE1ODU0NQ==", "bodyText": "Same here. I have already defined ResourceType in model directory", "url": "https://github.com/cBioPortal/cbioportal/pull/7270#discussion_r395158545", "createdAt": "2020-03-19T16:30:07Z", "author": {"login": "kalletlak"}, "path": "core/src/main/java/org/mskcc/cbio/portal/scripts/ImportResourceData.java", "diffHunk": "@@ -0,0 +1,574 @@\n+package org.mskcc.cbio.portal.scripts;\n+\n+import org.mskcc.cbio.portal.dao.*;\n+import org.mskcc.cbio.portal.model.*;\n+import org.mskcc.cbio.portal.util.*;\n+import org.mskcc.cbio.portal.util.ValuesUtils.MissingValues;\n+\n+import java.io.*;\n+import joptsimple.*;\n+import java.util.*;\n+import java.util.regex.*;\n+import java.util.stream.Collectors;\n+\n+import org.apache.commons.collections.map.MultiKeyMap;\n+\n+public class ImportResourceData extends ConsoleRunnable {\n+\n+    public static final String DELIMITER = \"\\t\";\n+    public static final String METADATA_PREFIX = \"#\";\n+    public static final String SAMPLE_ID_COLUMN_NAME = \"SAMPLE_ID\";\n+    public static final String PATIENT_ID_COLUMN_NAME = \"PATIENT_ID\";\n+    public static final String RESOURCE_ID_COLUMN_NAME = \"RESOURCE_ID\";\n+    public static final String URL_COLUMN_NAME = \"URL\";\n+    public static final String SAMPLE_TYPE_COLUMN_NAME = \"SAMPLE_TYPE\";\n+    private int numSampleSpecificResourcesAdded = 0;\n+    private int numPatientSpecificResourcesAdded = 0;\n+    private int numStudySpecificResourcesAdded = 0;\n+    private int numEmptyResourcesSkipped = 0;\n+    private int numSamplesProcessed = 0;\n+\n+    private static Properties properties;\n+\n+    private File resourceDataFile;\n+    private CancerStudy cancerStudy;\n+    private ResourceTypes resourceType;\n+    private boolean relaxed;\n+    private Set<String> patientIds = new HashSet<String>();\n+\n+    public static enum ResourceTypes {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ad5abf7c9634a54ebf671517257638ed6e6141d8"}, "originalPosition": 39}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ0OTMyNDE3OnYy", "diffSide": "RIGHT", "path": "core/src/main/java/org/mskcc/cbio/portal/scripts/ImportResourceData.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOVQxNjozNDoxOFrOF42vpA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOVQxNjozNDoxOFrOF42vpA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTE2MTUwOA==", "bodyText": "for each and every line block lines from 179-193 is executed which is not performance efficient. instead why not calculate them once and pass them as parameters", "url": "https://github.com/cBioPortal/cbioportal/pull/7270#discussion_r395161508", "createdAt": "2020-03-19T16:34:18Z", "author": {"login": "kalletlak"}, "path": "core/src/main/java/org/mskcc/cbio/portal/scripts/ImportResourceData.java", "diffHunk": "@@ -0,0 +1,574 @@\n+package org.mskcc.cbio.portal.scripts;\n+\n+import org.mskcc.cbio.portal.dao.*;\n+import org.mskcc.cbio.portal.model.*;\n+import org.mskcc.cbio.portal.util.*;\n+import org.mskcc.cbio.portal.util.ValuesUtils.MissingValues;\n+\n+import java.io.*;\n+import joptsimple.*;\n+import java.util.*;\n+import java.util.regex.*;\n+import java.util.stream.Collectors;\n+\n+import org.apache.commons.collections.map.MultiKeyMap;\n+\n+public class ImportResourceData extends ConsoleRunnable {\n+\n+    public static final String DELIMITER = \"\\t\";\n+    public static final String METADATA_PREFIX = \"#\";\n+    public static final String SAMPLE_ID_COLUMN_NAME = \"SAMPLE_ID\";\n+    public static final String PATIENT_ID_COLUMN_NAME = \"PATIENT_ID\";\n+    public static final String RESOURCE_ID_COLUMN_NAME = \"RESOURCE_ID\";\n+    public static final String URL_COLUMN_NAME = \"URL\";\n+    public static final String SAMPLE_TYPE_COLUMN_NAME = \"SAMPLE_TYPE\";\n+    private int numSampleSpecificResourcesAdded = 0;\n+    private int numPatientSpecificResourcesAdded = 0;\n+    private int numStudySpecificResourcesAdded = 0;\n+    private int numEmptyResourcesSkipped = 0;\n+    private int numSamplesProcessed = 0;\n+\n+    private static Properties properties;\n+\n+    private File resourceDataFile;\n+    private CancerStudy cancerStudy;\n+    private ResourceTypes resourceType;\n+    private boolean relaxed;\n+    private Set<String> patientIds = new HashSet<String>();\n+\n+    public static enum ResourceTypes {\n+        PATIENT(\"PATIENT\"), SAMPLE(\"SAMPLE\"), STUDY(\"STUDY\");\n+\n+        private String resourceTypes;\n+\n+        ResourceTypes(String resourceTypes) {\n+            this.resourceTypes = resourceTypes;\n+        }\n+\n+        public String toString() {\n+            return resourceTypes;\n+        }\n+    }\n+\n+    public void setFile(CancerStudy cancerStudy, File resourceDataFile, String resourceType, boolean relaxed) {\n+        this.cancerStudy = cancerStudy;\n+        this.resourceDataFile = resourceDataFile;\n+        this.resourceType = ResourceTypes.valueOf(resourceType);\n+        this.relaxed = relaxed;\n+    }\n+\n+    public void importData() throws Exception {\n+        // if bulkLoading is ever turned off,\n+        // code has to be added to check whether\n+        // a resource data update should be\n+        // perform instead of an insert\n+        MySQLbulkLoader.bulkLoadOn();\n+\n+        if (relaxed) {\n+            MySQLbulkLoader.relaxedModeOn();\n+        }\n+\n+        FileReader reader = new FileReader(resourceDataFile);\n+        BufferedReader buff = new BufferedReader(reader);\n+        List<ResourceDefinition> resources = grabResources(buff);\n+        String currentLine = buff.readLine();\n+        String[] headerNames = currentLine.split(\"\\t\");\n+        \n+        int patientIdIndex = findPatientIdColumn(headerNames);\n+        int sampleIdIndex = findSampleIdColumn(headerNames);\n+        int resourceIdIndex = findResourceIdColumn(headerNames);\n+        int urlIndex = findURLColumn(headerNames);\n+\n+        // validate required columns:\n+        if (resourceIdIndex < 0) {\n+            throw new RuntimeException(\"Aborting owing to failure to find \" + RESOURCE_ID_COLUMN_NAME\n+                    + \" in file. Please check your file format and try again.\");\n+        }\n+        if (urlIndex < 0) {\n+            throw new RuntimeException(\"Aborting owing to failure to find \" + URL_COLUMN_NAME\n+                    + \" in file. Please check your file format and try again.\");\n+        }\n+        if ((resourceType.toString().equalsIgnoreCase(\"sample\") || resourceType.toString().equalsIgnoreCase(\"patient\")) && patientIdIndex < 0) {\n+            // PATIENT_ID is required in both patient and sample file types:\n+            throw new RuntimeException(\"Aborting owing to failure to find \" + PATIENT_ID_COLUMN_NAME\n+                    + \" in file. Please check your file format and try again.\");\n+        }\n+        if (resourceType.toString().equalsIgnoreCase(\"sample\") && sampleIdIndex < 0) {\n+            // SAMPLE_ID is required in SAMPLE file type:\n+            throw new RuntimeException(\"Aborting owing to failure to find \" + SAMPLE_ID_COLUMN_NAME\n+                    + \" in file. Please check your file format and try again.\");\n+        }\n+        importData(buff, resources, headerNames);\n+\n+        if (MySQLbulkLoader.isBulkLoad()) {\n+            MySQLbulkLoader.flushAll();\n+            MySQLbulkLoader.relaxedModeOff();\n+        }\n+    }\n+\n+    private List<ResourceDefinition> grabResources(BufferedReader buff) throws DaoException, IOException {\n+        List<ResourceDefinition> resources = new ArrayList<ResourceDefinition>();\n+        resources = DaoResourceDefinition.getDatumByStudy(cancerStudy.getInternalId());\n+        return resources;\n+    }\n+\n+    private String[] splitFields(String line) throws IOException {\n+        line = line.replaceAll(\"^\" + METADATA_PREFIX + \"+\", \"\");\n+        String[] fields = line.split(DELIMITER, -1);\n+\n+        return fields;\n+    }\n+\n+    private void importData(BufferedReader buff, List<ResourceDefinition> resources, String[] headerNames) throws Exception {\n+        String line;\n+        MultiKeyMap resourceMap = new MultiKeyMap();\n+        while ((line = buff.readLine()) != null) {\n+            if (skipLine(line.trim())) {\n+                continue;\n+            }\n+\n+            String[] fieldValues = getFieldValues(line, headerNames);\n+            addDatum(fieldValues, resources, resourceMap, headerNames);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ad5abf7c9634a54ebf671517257638ed6e6141d8"}, "originalPosition": 131}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ0OTM4MjgxOnYy", "diffSide": "RIGHT", "path": "core/src/main/java/org/mskcc/cbio/portal/scripts/ImportResourceData.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOVQxNjo0ODoxNVrOF43V2A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOVQxNjo0ODozMlrOF43WkA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTE3MTI4OA==", "bodyText": "could be resourceType.equals(ResourceType.SAMPLE)", "url": "https://github.com/cBioPortal/cbioportal/pull/7270#discussion_r395171288", "createdAt": "2020-03-19T16:48:15Z", "author": {"login": "kalletlak"}, "path": "core/src/main/java/org/mskcc/cbio/portal/scripts/ImportResourceData.java", "diffHunk": "@@ -0,0 +1,574 @@\n+package org.mskcc.cbio.portal.scripts;\n+\n+import org.mskcc.cbio.portal.dao.*;\n+import org.mskcc.cbio.portal.model.*;\n+import org.mskcc.cbio.portal.util.*;\n+import org.mskcc.cbio.portal.util.ValuesUtils.MissingValues;\n+\n+import java.io.*;\n+import joptsimple.*;\n+import java.util.*;\n+import java.util.regex.*;\n+import java.util.stream.Collectors;\n+\n+import org.apache.commons.collections.map.MultiKeyMap;\n+\n+public class ImportResourceData extends ConsoleRunnable {\n+\n+    public static final String DELIMITER = \"\\t\";\n+    public static final String METADATA_PREFIX = \"#\";\n+    public static final String SAMPLE_ID_COLUMN_NAME = \"SAMPLE_ID\";\n+    public static final String PATIENT_ID_COLUMN_NAME = \"PATIENT_ID\";\n+    public static final String RESOURCE_ID_COLUMN_NAME = \"RESOURCE_ID\";\n+    public static final String URL_COLUMN_NAME = \"URL\";\n+    public static final String SAMPLE_TYPE_COLUMN_NAME = \"SAMPLE_TYPE\";\n+    private int numSampleSpecificResourcesAdded = 0;\n+    private int numPatientSpecificResourcesAdded = 0;\n+    private int numStudySpecificResourcesAdded = 0;\n+    private int numEmptyResourcesSkipped = 0;\n+    private int numSamplesProcessed = 0;\n+\n+    private static Properties properties;\n+\n+    private File resourceDataFile;\n+    private CancerStudy cancerStudy;\n+    private ResourceTypes resourceType;\n+    private boolean relaxed;\n+    private Set<String> patientIds = new HashSet<String>();\n+\n+    public static enum ResourceTypes {\n+        PATIENT(\"PATIENT\"), SAMPLE(\"SAMPLE\"), STUDY(\"STUDY\");\n+\n+        private String resourceTypes;\n+\n+        ResourceTypes(String resourceTypes) {\n+            this.resourceTypes = resourceTypes;\n+        }\n+\n+        public String toString() {\n+            return resourceTypes;\n+        }\n+    }\n+\n+    public void setFile(CancerStudy cancerStudy, File resourceDataFile, String resourceType, boolean relaxed) {\n+        this.cancerStudy = cancerStudy;\n+        this.resourceDataFile = resourceDataFile;\n+        this.resourceType = ResourceTypes.valueOf(resourceType);\n+        this.relaxed = relaxed;\n+    }\n+\n+    public void importData() throws Exception {\n+        // if bulkLoading is ever turned off,\n+        // code has to be added to check whether\n+        // a resource data update should be\n+        // perform instead of an insert\n+        MySQLbulkLoader.bulkLoadOn();\n+\n+        if (relaxed) {\n+            MySQLbulkLoader.relaxedModeOn();\n+        }\n+\n+        FileReader reader = new FileReader(resourceDataFile);\n+        BufferedReader buff = new BufferedReader(reader);\n+        List<ResourceDefinition> resources = grabResources(buff);\n+        String currentLine = buff.readLine();\n+        String[] headerNames = currentLine.split(\"\\t\");\n+        \n+        int patientIdIndex = findPatientIdColumn(headerNames);\n+        int sampleIdIndex = findSampleIdColumn(headerNames);\n+        int resourceIdIndex = findResourceIdColumn(headerNames);\n+        int urlIndex = findURLColumn(headerNames);\n+\n+        // validate required columns:\n+        if (resourceIdIndex < 0) {\n+            throw new RuntimeException(\"Aborting owing to failure to find \" + RESOURCE_ID_COLUMN_NAME\n+                    + \" in file. Please check your file format and try again.\");\n+        }\n+        if (urlIndex < 0) {\n+            throw new RuntimeException(\"Aborting owing to failure to find \" + URL_COLUMN_NAME\n+                    + \" in file. Please check your file format and try again.\");\n+        }\n+        if ((resourceType.toString().equalsIgnoreCase(\"sample\") || resourceType.toString().equalsIgnoreCase(\"patient\")) && patientIdIndex < 0) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ad5abf7c9634a54ebf671517257638ed6e6141d8"}, "originalPosition": 91}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTE3MTQ3Mg==", "bodyText": "same for patient and study", "url": "https://github.com/cBioPortal/cbioportal/pull/7270#discussion_r395171472", "createdAt": "2020-03-19T16:48:32Z", "author": {"login": "kalletlak"}, "path": "core/src/main/java/org/mskcc/cbio/portal/scripts/ImportResourceData.java", "diffHunk": "@@ -0,0 +1,574 @@\n+package org.mskcc.cbio.portal.scripts;\n+\n+import org.mskcc.cbio.portal.dao.*;\n+import org.mskcc.cbio.portal.model.*;\n+import org.mskcc.cbio.portal.util.*;\n+import org.mskcc.cbio.portal.util.ValuesUtils.MissingValues;\n+\n+import java.io.*;\n+import joptsimple.*;\n+import java.util.*;\n+import java.util.regex.*;\n+import java.util.stream.Collectors;\n+\n+import org.apache.commons.collections.map.MultiKeyMap;\n+\n+public class ImportResourceData extends ConsoleRunnable {\n+\n+    public static final String DELIMITER = \"\\t\";\n+    public static final String METADATA_PREFIX = \"#\";\n+    public static final String SAMPLE_ID_COLUMN_NAME = \"SAMPLE_ID\";\n+    public static final String PATIENT_ID_COLUMN_NAME = \"PATIENT_ID\";\n+    public static final String RESOURCE_ID_COLUMN_NAME = \"RESOURCE_ID\";\n+    public static final String URL_COLUMN_NAME = \"URL\";\n+    public static final String SAMPLE_TYPE_COLUMN_NAME = \"SAMPLE_TYPE\";\n+    private int numSampleSpecificResourcesAdded = 0;\n+    private int numPatientSpecificResourcesAdded = 0;\n+    private int numStudySpecificResourcesAdded = 0;\n+    private int numEmptyResourcesSkipped = 0;\n+    private int numSamplesProcessed = 0;\n+\n+    private static Properties properties;\n+\n+    private File resourceDataFile;\n+    private CancerStudy cancerStudy;\n+    private ResourceTypes resourceType;\n+    private boolean relaxed;\n+    private Set<String> patientIds = new HashSet<String>();\n+\n+    public static enum ResourceTypes {\n+        PATIENT(\"PATIENT\"), SAMPLE(\"SAMPLE\"), STUDY(\"STUDY\");\n+\n+        private String resourceTypes;\n+\n+        ResourceTypes(String resourceTypes) {\n+            this.resourceTypes = resourceTypes;\n+        }\n+\n+        public String toString() {\n+            return resourceTypes;\n+        }\n+    }\n+\n+    public void setFile(CancerStudy cancerStudy, File resourceDataFile, String resourceType, boolean relaxed) {\n+        this.cancerStudy = cancerStudy;\n+        this.resourceDataFile = resourceDataFile;\n+        this.resourceType = ResourceTypes.valueOf(resourceType);\n+        this.relaxed = relaxed;\n+    }\n+\n+    public void importData() throws Exception {\n+        // if bulkLoading is ever turned off,\n+        // code has to be added to check whether\n+        // a resource data update should be\n+        // perform instead of an insert\n+        MySQLbulkLoader.bulkLoadOn();\n+\n+        if (relaxed) {\n+            MySQLbulkLoader.relaxedModeOn();\n+        }\n+\n+        FileReader reader = new FileReader(resourceDataFile);\n+        BufferedReader buff = new BufferedReader(reader);\n+        List<ResourceDefinition> resources = grabResources(buff);\n+        String currentLine = buff.readLine();\n+        String[] headerNames = currentLine.split(\"\\t\");\n+        \n+        int patientIdIndex = findPatientIdColumn(headerNames);\n+        int sampleIdIndex = findSampleIdColumn(headerNames);\n+        int resourceIdIndex = findResourceIdColumn(headerNames);\n+        int urlIndex = findURLColumn(headerNames);\n+\n+        // validate required columns:\n+        if (resourceIdIndex < 0) {\n+            throw new RuntimeException(\"Aborting owing to failure to find \" + RESOURCE_ID_COLUMN_NAME\n+                    + \" in file. Please check your file format and try again.\");\n+        }\n+        if (urlIndex < 0) {\n+            throw new RuntimeException(\"Aborting owing to failure to find \" + URL_COLUMN_NAME\n+                    + \" in file. Please check your file format and try again.\");\n+        }\n+        if ((resourceType.toString().equalsIgnoreCase(\"sample\") || resourceType.toString().equalsIgnoreCase(\"patient\")) && patientIdIndex < 0) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTE3MTI4OA=="}, "originalCommit": {"oid": "ad5abf7c9634a54ebf671517257638ed6e6141d8"}, "originalPosition": 91}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ0OTQxMTk5OnYy", "diffSide": "RIGHT", "path": "core/src/main/java/org/mskcc/cbio/portal/scripts/ImportResourceData.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOVQxNjo1NToxMVrOF43olg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yMFQxNzoxMDo1N1rOF5cVHA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTE3NjA4Ng==", "bodyText": "instead of fetching sample for every record, why not fetch data(sample/patient) depending on the resource type?", "url": "https://github.com/cBioPortal/cbioportal/pull/7270#discussion_r395176086", "createdAt": "2020-03-19T16:55:11Z", "author": {"login": "kalletlak"}, "path": "core/src/main/java/org/mskcc/cbio/portal/scripts/ImportResourceData.java", "diffHunk": "@@ -0,0 +1,574 @@\n+package org.mskcc.cbio.portal.scripts;\n+\n+import org.mskcc.cbio.portal.dao.*;\n+import org.mskcc.cbio.portal.model.*;\n+import org.mskcc.cbio.portal.util.*;\n+import org.mskcc.cbio.portal.util.ValuesUtils.MissingValues;\n+\n+import java.io.*;\n+import joptsimple.*;\n+import java.util.*;\n+import java.util.regex.*;\n+import java.util.stream.Collectors;\n+\n+import org.apache.commons.collections.map.MultiKeyMap;\n+\n+public class ImportResourceData extends ConsoleRunnable {\n+\n+    public static final String DELIMITER = \"\\t\";\n+    public static final String METADATA_PREFIX = \"#\";\n+    public static final String SAMPLE_ID_COLUMN_NAME = \"SAMPLE_ID\";\n+    public static final String PATIENT_ID_COLUMN_NAME = \"PATIENT_ID\";\n+    public static final String RESOURCE_ID_COLUMN_NAME = \"RESOURCE_ID\";\n+    public static final String URL_COLUMN_NAME = \"URL\";\n+    public static final String SAMPLE_TYPE_COLUMN_NAME = \"SAMPLE_TYPE\";\n+    private int numSampleSpecificResourcesAdded = 0;\n+    private int numPatientSpecificResourcesAdded = 0;\n+    private int numStudySpecificResourcesAdded = 0;\n+    private int numEmptyResourcesSkipped = 0;\n+    private int numSamplesProcessed = 0;\n+\n+    private static Properties properties;\n+\n+    private File resourceDataFile;\n+    private CancerStudy cancerStudy;\n+    private ResourceTypes resourceType;\n+    private boolean relaxed;\n+    private Set<String> patientIds = new HashSet<String>();\n+\n+    public static enum ResourceTypes {\n+        PATIENT(\"PATIENT\"), SAMPLE(\"SAMPLE\"), STUDY(\"STUDY\");\n+\n+        private String resourceTypes;\n+\n+        ResourceTypes(String resourceTypes) {\n+            this.resourceTypes = resourceTypes;\n+        }\n+\n+        public String toString() {\n+            return resourceTypes;\n+        }\n+    }\n+\n+    public void setFile(CancerStudy cancerStudy, File resourceDataFile, String resourceType, boolean relaxed) {\n+        this.cancerStudy = cancerStudy;\n+        this.resourceDataFile = resourceDataFile;\n+        this.resourceType = ResourceTypes.valueOf(resourceType);\n+        this.relaxed = relaxed;\n+    }\n+\n+    public void importData() throws Exception {\n+        // if bulkLoading is ever turned off,\n+        // code has to be added to check whether\n+        // a resource data update should be\n+        // perform instead of an insert\n+        MySQLbulkLoader.bulkLoadOn();\n+\n+        if (relaxed) {\n+            MySQLbulkLoader.relaxedModeOn();\n+        }\n+\n+        FileReader reader = new FileReader(resourceDataFile);\n+        BufferedReader buff = new BufferedReader(reader);\n+        List<ResourceDefinition> resources = grabResources(buff);\n+        String currentLine = buff.readLine();\n+        String[] headerNames = currentLine.split(\"\\t\");\n+        \n+        int patientIdIndex = findPatientIdColumn(headerNames);\n+        int sampleIdIndex = findSampleIdColumn(headerNames);\n+        int resourceIdIndex = findResourceIdColumn(headerNames);\n+        int urlIndex = findURLColumn(headerNames);\n+\n+        // validate required columns:\n+        if (resourceIdIndex < 0) {\n+            throw new RuntimeException(\"Aborting owing to failure to find \" + RESOURCE_ID_COLUMN_NAME\n+                    + \" in file. Please check your file format and try again.\");\n+        }\n+        if (urlIndex < 0) {\n+            throw new RuntimeException(\"Aborting owing to failure to find \" + URL_COLUMN_NAME\n+                    + \" in file. Please check your file format and try again.\");\n+        }\n+        if ((resourceType.toString().equalsIgnoreCase(\"sample\") || resourceType.toString().equalsIgnoreCase(\"patient\")) && patientIdIndex < 0) {\n+            // PATIENT_ID is required in both patient and sample file types:\n+            throw new RuntimeException(\"Aborting owing to failure to find \" + PATIENT_ID_COLUMN_NAME\n+                    + \" in file. Please check your file format and try again.\");\n+        }\n+        if (resourceType.toString().equalsIgnoreCase(\"sample\") && sampleIdIndex < 0) {\n+            // SAMPLE_ID is required in SAMPLE file type:\n+            throw new RuntimeException(\"Aborting owing to failure to find \" + SAMPLE_ID_COLUMN_NAME\n+                    + \" in file. Please check your file format and try again.\");\n+        }\n+        importData(buff, resources, headerNames);\n+\n+        if (MySQLbulkLoader.isBulkLoad()) {\n+            MySQLbulkLoader.flushAll();\n+            MySQLbulkLoader.relaxedModeOff();\n+        }\n+    }\n+\n+    private List<ResourceDefinition> grabResources(BufferedReader buff) throws DaoException, IOException {\n+        List<ResourceDefinition> resources = new ArrayList<ResourceDefinition>();\n+        resources = DaoResourceDefinition.getDatumByStudy(cancerStudy.getInternalId());\n+        return resources;\n+    }\n+\n+    private String[] splitFields(String line) throws IOException {\n+        line = line.replaceAll(\"^\" + METADATA_PREFIX + \"+\", \"\");\n+        String[] fields = line.split(DELIMITER, -1);\n+\n+        return fields;\n+    }\n+\n+    private void importData(BufferedReader buff, List<ResourceDefinition> resources, String[] headerNames) throws Exception {\n+        String line;\n+        MultiKeyMap resourceMap = new MultiKeyMap();\n+        while ((line = buff.readLine()) != null) {\n+            if (skipLine(line.trim())) {\n+                continue;\n+            }\n+\n+            String[] fieldValues = getFieldValues(line, headerNames);\n+            addDatum(fieldValues, resources, resourceMap, headerNames);\n+        }\n+    }\n+\n+    private boolean skipLine(String line) {\n+        return (line.isEmpty() || line.substring(0, 1).equals(METADATA_PREFIX));\n+    }\n+\n+    /**\n+     * Takes in the given line and returns the list of field values by splitting the\n+     * line on DELIMITER.\n+     * \n+     * @param line\n+     * @param headerNames\n+     * @return the list of values, one for each column. Value will be \"\" for empty\n+     *         columns.\n+     */\n+    private String[] getFieldValues(String line, String[] headerNames) {\n+        // split on delimiter:\n+        String[] fieldValues = line.split(DELIMITER, -1);\n+\n+        // validate: if number of fields is incorrect, give exception\n+        if (fieldValues.length != headerNames.length) {\n+            throw new IllegalArgumentException(\"Number of columns in line is not as expected. Expected: \"\n+                    + headerNames.length + \" columns, found: \" + fieldValues.length + \", for line: \" + line);\n+        }\n+\n+        // now iterate over lines and trim each value:\n+        for (int i = 0; i < fieldValues.length; i++) {\n+            fieldValues[i] = fieldValues[i].trim();\n+        }\n+        return fieldValues;\n+    }\n+\n+    private boolean addDatum(String[] fields, List<ResourceDefinition> resources, MultiKeyMap resourceMap, String[] headerNames)\n+            throws Exception {\n+        int sampleIdIndex = findSampleIdColumn(headerNames);\n+        String stableSampleId = (sampleIdIndex >= 0) ? fields[sampleIdIndex] : \"\";\n+        stableSampleId = StableIdUtil.getSampleId(stableSampleId);\n+        int patientIdIndex = findPatientIdColumn(headerNames);\n+        String stablePatientId = (patientIdIndex >= 0) ? fields[patientIdIndex] : \"\";\n+        stablePatientId = StableIdUtil.getPatientId(stablePatientId);\n+        int resourceIdIndex = findResourceIdColumn(headerNames);\n+        int urlIndex = findURLColumn(headerNames);\n+        int internalSampleId = -1;\n+        int internalPatientId = -1;\n+\n+        // create resource_id set\n+        Set<String> patientResourceIdSet = resources\n+                .stream()\n+                .filter(resource -> resource.getResourceType().equals(ResourceDefinition.PATIENT_RESOURCE_TYPE))\n+                .map(resource -> resource.getResourceId())\n+                .collect(Collectors.toSet());\n+        Set<String> sampleResourceIdSet = resources\n+                .stream()\n+                .filter(resource -> resource.getResourceType().equals(ResourceDefinition.SAMPLE_RESOURCE_TYPE))\n+                .map(resource -> resource.getResourceId())\n+                .collect(Collectors.toSet());\n+        Set<String> studyResourceIdSet = resources\n+                .stream()\n+                .filter(resource -> resource.getResourceType().equals(ResourceDefinition.STUDY_RESOURCE_TYPE))\n+                .map(resource -> resource.getResourceId())\n+                .collect(Collectors.toSet());\n+\n+        // check if sample is not already added:\n+        Sample sample = DaoSample.getSampleByCancerStudyAndSampleId(cancerStudy.getInternalId(), stableSampleId, false);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ad5abf7c9634a54ebf671517257638ed6e6141d8"}, "originalPosition": 196}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTcyOTYyNQ==", "bodyText": "I don't think I can fetch data by resource type since the sample and patient can have no association with resources before we adding the resource data into the database.", "url": "https://github.com/cBioPortal/cbioportal/pull/7270#discussion_r395729625", "createdAt": "2020-03-20T15:52:26Z", "author": {"login": "dippindots"}, "path": "core/src/main/java/org/mskcc/cbio/portal/scripts/ImportResourceData.java", "diffHunk": "@@ -0,0 +1,574 @@\n+package org.mskcc.cbio.portal.scripts;\n+\n+import org.mskcc.cbio.portal.dao.*;\n+import org.mskcc.cbio.portal.model.*;\n+import org.mskcc.cbio.portal.util.*;\n+import org.mskcc.cbio.portal.util.ValuesUtils.MissingValues;\n+\n+import java.io.*;\n+import joptsimple.*;\n+import java.util.*;\n+import java.util.regex.*;\n+import java.util.stream.Collectors;\n+\n+import org.apache.commons.collections.map.MultiKeyMap;\n+\n+public class ImportResourceData extends ConsoleRunnable {\n+\n+    public static final String DELIMITER = \"\\t\";\n+    public static final String METADATA_PREFIX = \"#\";\n+    public static final String SAMPLE_ID_COLUMN_NAME = \"SAMPLE_ID\";\n+    public static final String PATIENT_ID_COLUMN_NAME = \"PATIENT_ID\";\n+    public static final String RESOURCE_ID_COLUMN_NAME = \"RESOURCE_ID\";\n+    public static final String URL_COLUMN_NAME = \"URL\";\n+    public static final String SAMPLE_TYPE_COLUMN_NAME = \"SAMPLE_TYPE\";\n+    private int numSampleSpecificResourcesAdded = 0;\n+    private int numPatientSpecificResourcesAdded = 0;\n+    private int numStudySpecificResourcesAdded = 0;\n+    private int numEmptyResourcesSkipped = 0;\n+    private int numSamplesProcessed = 0;\n+\n+    private static Properties properties;\n+\n+    private File resourceDataFile;\n+    private CancerStudy cancerStudy;\n+    private ResourceTypes resourceType;\n+    private boolean relaxed;\n+    private Set<String> patientIds = new HashSet<String>();\n+\n+    public static enum ResourceTypes {\n+        PATIENT(\"PATIENT\"), SAMPLE(\"SAMPLE\"), STUDY(\"STUDY\");\n+\n+        private String resourceTypes;\n+\n+        ResourceTypes(String resourceTypes) {\n+            this.resourceTypes = resourceTypes;\n+        }\n+\n+        public String toString() {\n+            return resourceTypes;\n+        }\n+    }\n+\n+    public void setFile(CancerStudy cancerStudy, File resourceDataFile, String resourceType, boolean relaxed) {\n+        this.cancerStudy = cancerStudy;\n+        this.resourceDataFile = resourceDataFile;\n+        this.resourceType = ResourceTypes.valueOf(resourceType);\n+        this.relaxed = relaxed;\n+    }\n+\n+    public void importData() throws Exception {\n+        // if bulkLoading is ever turned off,\n+        // code has to be added to check whether\n+        // a resource data update should be\n+        // perform instead of an insert\n+        MySQLbulkLoader.bulkLoadOn();\n+\n+        if (relaxed) {\n+            MySQLbulkLoader.relaxedModeOn();\n+        }\n+\n+        FileReader reader = new FileReader(resourceDataFile);\n+        BufferedReader buff = new BufferedReader(reader);\n+        List<ResourceDefinition> resources = grabResources(buff);\n+        String currentLine = buff.readLine();\n+        String[] headerNames = currentLine.split(\"\\t\");\n+        \n+        int patientIdIndex = findPatientIdColumn(headerNames);\n+        int sampleIdIndex = findSampleIdColumn(headerNames);\n+        int resourceIdIndex = findResourceIdColumn(headerNames);\n+        int urlIndex = findURLColumn(headerNames);\n+\n+        // validate required columns:\n+        if (resourceIdIndex < 0) {\n+            throw new RuntimeException(\"Aborting owing to failure to find \" + RESOURCE_ID_COLUMN_NAME\n+                    + \" in file. Please check your file format and try again.\");\n+        }\n+        if (urlIndex < 0) {\n+            throw new RuntimeException(\"Aborting owing to failure to find \" + URL_COLUMN_NAME\n+                    + \" in file. Please check your file format and try again.\");\n+        }\n+        if ((resourceType.toString().equalsIgnoreCase(\"sample\") || resourceType.toString().equalsIgnoreCase(\"patient\")) && patientIdIndex < 0) {\n+            // PATIENT_ID is required in both patient and sample file types:\n+            throw new RuntimeException(\"Aborting owing to failure to find \" + PATIENT_ID_COLUMN_NAME\n+                    + \" in file. Please check your file format and try again.\");\n+        }\n+        if (resourceType.toString().equalsIgnoreCase(\"sample\") && sampleIdIndex < 0) {\n+            // SAMPLE_ID is required in SAMPLE file type:\n+            throw new RuntimeException(\"Aborting owing to failure to find \" + SAMPLE_ID_COLUMN_NAME\n+                    + \" in file. Please check your file format and try again.\");\n+        }\n+        importData(buff, resources, headerNames);\n+\n+        if (MySQLbulkLoader.isBulkLoad()) {\n+            MySQLbulkLoader.flushAll();\n+            MySQLbulkLoader.relaxedModeOff();\n+        }\n+    }\n+\n+    private List<ResourceDefinition> grabResources(BufferedReader buff) throws DaoException, IOException {\n+        List<ResourceDefinition> resources = new ArrayList<ResourceDefinition>();\n+        resources = DaoResourceDefinition.getDatumByStudy(cancerStudy.getInternalId());\n+        return resources;\n+    }\n+\n+    private String[] splitFields(String line) throws IOException {\n+        line = line.replaceAll(\"^\" + METADATA_PREFIX + \"+\", \"\");\n+        String[] fields = line.split(DELIMITER, -1);\n+\n+        return fields;\n+    }\n+\n+    private void importData(BufferedReader buff, List<ResourceDefinition> resources, String[] headerNames) throws Exception {\n+        String line;\n+        MultiKeyMap resourceMap = new MultiKeyMap();\n+        while ((line = buff.readLine()) != null) {\n+            if (skipLine(line.trim())) {\n+                continue;\n+            }\n+\n+            String[] fieldValues = getFieldValues(line, headerNames);\n+            addDatum(fieldValues, resources, resourceMap, headerNames);\n+        }\n+    }\n+\n+    private boolean skipLine(String line) {\n+        return (line.isEmpty() || line.substring(0, 1).equals(METADATA_PREFIX));\n+    }\n+\n+    /**\n+     * Takes in the given line and returns the list of field values by splitting the\n+     * line on DELIMITER.\n+     * \n+     * @param line\n+     * @param headerNames\n+     * @return the list of values, one for each column. Value will be \"\" for empty\n+     *         columns.\n+     */\n+    private String[] getFieldValues(String line, String[] headerNames) {\n+        // split on delimiter:\n+        String[] fieldValues = line.split(DELIMITER, -1);\n+\n+        // validate: if number of fields is incorrect, give exception\n+        if (fieldValues.length != headerNames.length) {\n+            throw new IllegalArgumentException(\"Number of columns in line is not as expected. Expected: \"\n+                    + headerNames.length + \" columns, found: \" + fieldValues.length + \", for line: \" + line);\n+        }\n+\n+        // now iterate over lines and trim each value:\n+        for (int i = 0; i < fieldValues.length; i++) {\n+            fieldValues[i] = fieldValues[i].trim();\n+        }\n+        return fieldValues;\n+    }\n+\n+    private boolean addDatum(String[] fields, List<ResourceDefinition> resources, MultiKeyMap resourceMap, String[] headerNames)\n+            throws Exception {\n+        int sampleIdIndex = findSampleIdColumn(headerNames);\n+        String stableSampleId = (sampleIdIndex >= 0) ? fields[sampleIdIndex] : \"\";\n+        stableSampleId = StableIdUtil.getSampleId(stableSampleId);\n+        int patientIdIndex = findPatientIdColumn(headerNames);\n+        String stablePatientId = (patientIdIndex >= 0) ? fields[patientIdIndex] : \"\";\n+        stablePatientId = StableIdUtil.getPatientId(stablePatientId);\n+        int resourceIdIndex = findResourceIdColumn(headerNames);\n+        int urlIndex = findURLColumn(headerNames);\n+        int internalSampleId = -1;\n+        int internalPatientId = -1;\n+\n+        // create resource_id set\n+        Set<String> patientResourceIdSet = resources\n+                .stream()\n+                .filter(resource -> resource.getResourceType().equals(ResourceDefinition.PATIENT_RESOURCE_TYPE))\n+                .map(resource -> resource.getResourceId())\n+                .collect(Collectors.toSet());\n+        Set<String> sampleResourceIdSet = resources\n+                .stream()\n+                .filter(resource -> resource.getResourceType().equals(ResourceDefinition.SAMPLE_RESOURCE_TYPE))\n+                .map(resource -> resource.getResourceId())\n+                .collect(Collectors.toSet());\n+        Set<String> studyResourceIdSet = resources\n+                .stream()\n+                .filter(resource -> resource.getResourceType().equals(ResourceDefinition.STUDY_RESOURCE_TYPE))\n+                .map(resource -> resource.getResourceId())\n+                .collect(Collectors.toSet());\n+\n+        // check if sample is not already added:\n+        Sample sample = DaoSample.getSampleByCancerStudyAndSampleId(cancerStudy.getInternalId(), stableSampleId, false);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTE3NjA4Ng=="}, "originalCommit": {"oid": "ad5abf7c9634a54ebf671517257638ed6e6141d8"}, "originalPosition": 196}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTc0NzcwMg==", "bodyText": "I mean to say that for a study resource you don't need to fetch Sample. and similarly for patient resource", "url": "https://github.com/cBioPortal/cbioportal/pull/7270#discussion_r395747702", "createdAt": "2020-03-20T16:21:10Z", "author": {"login": "kalletlak"}, "path": "core/src/main/java/org/mskcc/cbio/portal/scripts/ImportResourceData.java", "diffHunk": "@@ -0,0 +1,574 @@\n+package org.mskcc.cbio.portal.scripts;\n+\n+import org.mskcc.cbio.portal.dao.*;\n+import org.mskcc.cbio.portal.model.*;\n+import org.mskcc.cbio.portal.util.*;\n+import org.mskcc.cbio.portal.util.ValuesUtils.MissingValues;\n+\n+import java.io.*;\n+import joptsimple.*;\n+import java.util.*;\n+import java.util.regex.*;\n+import java.util.stream.Collectors;\n+\n+import org.apache.commons.collections.map.MultiKeyMap;\n+\n+public class ImportResourceData extends ConsoleRunnable {\n+\n+    public static final String DELIMITER = \"\\t\";\n+    public static final String METADATA_PREFIX = \"#\";\n+    public static final String SAMPLE_ID_COLUMN_NAME = \"SAMPLE_ID\";\n+    public static final String PATIENT_ID_COLUMN_NAME = \"PATIENT_ID\";\n+    public static final String RESOURCE_ID_COLUMN_NAME = \"RESOURCE_ID\";\n+    public static final String URL_COLUMN_NAME = \"URL\";\n+    public static final String SAMPLE_TYPE_COLUMN_NAME = \"SAMPLE_TYPE\";\n+    private int numSampleSpecificResourcesAdded = 0;\n+    private int numPatientSpecificResourcesAdded = 0;\n+    private int numStudySpecificResourcesAdded = 0;\n+    private int numEmptyResourcesSkipped = 0;\n+    private int numSamplesProcessed = 0;\n+\n+    private static Properties properties;\n+\n+    private File resourceDataFile;\n+    private CancerStudy cancerStudy;\n+    private ResourceTypes resourceType;\n+    private boolean relaxed;\n+    private Set<String> patientIds = new HashSet<String>();\n+\n+    public static enum ResourceTypes {\n+        PATIENT(\"PATIENT\"), SAMPLE(\"SAMPLE\"), STUDY(\"STUDY\");\n+\n+        private String resourceTypes;\n+\n+        ResourceTypes(String resourceTypes) {\n+            this.resourceTypes = resourceTypes;\n+        }\n+\n+        public String toString() {\n+            return resourceTypes;\n+        }\n+    }\n+\n+    public void setFile(CancerStudy cancerStudy, File resourceDataFile, String resourceType, boolean relaxed) {\n+        this.cancerStudy = cancerStudy;\n+        this.resourceDataFile = resourceDataFile;\n+        this.resourceType = ResourceTypes.valueOf(resourceType);\n+        this.relaxed = relaxed;\n+    }\n+\n+    public void importData() throws Exception {\n+        // if bulkLoading is ever turned off,\n+        // code has to be added to check whether\n+        // a resource data update should be\n+        // perform instead of an insert\n+        MySQLbulkLoader.bulkLoadOn();\n+\n+        if (relaxed) {\n+            MySQLbulkLoader.relaxedModeOn();\n+        }\n+\n+        FileReader reader = new FileReader(resourceDataFile);\n+        BufferedReader buff = new BufferedReader(reader);\n+        List<ResourceDefinition> resources = grabResources(buff);\n+        String currentLine = buff.readLine();\n+        String[] headerNames = currentLine.split(\"\\t\");\n+        \n+        int patientIdIndex = findPatientIdColumn(headerNames);\n+        int sampleIdIndex = findSampleIdColumn(headerNames);\n+        int resourceIdIndex = findResourceIdColumn(headerNames);\n+        int urlIndex = findURLColumn(headerNames);\n+\n+        // validate required columns:\n+        if (resourceIdIndex < 0) {\n+            throw new RuntimeException(\"Aborting owing to failure to find \" + RESOURCE_ID_COLUMN_NAME\n+                    + \" in file. Please check your file format and try again.\");\n+        }\n+        if (urlIndex < 0) {\n+            throw new RuntimeException(\"Aborting owing to failure to find \" + URL_COLUMN_NAME\n+                    + \" in file. Please check your file format and try again.\");\n+        }\n+        if ((resourceType.toString().equalsIgnoreCase(\"sample\") || resourceType.toString().equalsIgnoreCase(\"patient\")) && patientIdIndex < 0) {\n+            // PATIENT_ID is required in both patient and sample file types:\n+            throw new RuntimeException(\"Aborting owing to failure to find \" + PATIENT_ID_COLUMN_NAME\n+                    + \" in file. Please check your file format and try again.\");\n+        }\n+        if (resourceType.toString().equalsIgnoreCase(\"sample\") && sampleIdIndex < 0) {\n+            // SAMPLE_ID is required in SAMPLE file type:\n+            throw new RuntimeException(\"Aborting owing to failure to find \" + SAMPLE_ID_COLUMN_NAME\n+                    + \" in file. Please check your file format and try again.\");\n+        }\n+        importData(buff, resources, headerNames);\n+\n+        if (MySQLbulkLoader.isBulkLoad()) {\n+            MySQLbulkLoader.flushAll();\n+            MySQLbulkLoader.relaxedModeOff();\n+        }\n+    }\n+\n+    private List<ResourceDefinition> grabResources(BufferedReader buff) throws DaoException, IOException {\n+        List<ResourceDefinition> resources = new ArrayList<ResourceDefinition>();\n+        resources = DaoResourceDefinition.getDatumByStudy(cancerStudy.getInternalId());\n+        return resources;\n+    }\n+\n+    private String[] splitFields(String line) throws IOException {\n+        line = line.replaceAll(\"^\" + METADATA_PREFIX + \"+\", \"\");\n+        String[] fields = line.split(DELIMITER, -1);\n+\n+        return fields;\n+    }\n+\n+    private void importData(BufferedReader buff, List<ResourceDefinition> resources, String[] headerNames) throws Exception {\n+        String line;\n+        MultiKeyMap resourceMap = new MultiKeyMap();\n+        while ((line = buff.readLine()) != null) {\n+            if (skipLine(line.trim())) {\n+                continue;\n+            }\n+\n+            String[] fieldValues = getFieldValues(line, headerNames);\n+            addDatum(fieldValues, resources, resourceMap, headerNames);\n+        }\n+    }\n+\n+    private boolean skipLine(String line) {\n+        return (line.isEmpty() || line.substring(0, 1).equals(METADATA_PREFIX));\n+    }\n+\n+    /**\n+     * Takes in the given line and returns the list of field values by splitting the\n+     * line on DELIMITER.\n+     * \n+     * @param line\n+     * @param headerNames\n+     * @return the list of values, one for each column. Value will be \"\" for empty\n+     *         columns.\n+     */\n+    private String[] getFieldValues(String line, String[] headerNames) {\n+        // split on delimiter:\n+        String[] fieldValues = line.split(DELIMITER, -1);\n+\n+        // validate: if number of fields is incorrect, give exception\n+        if (fieldValues.length != headerNames.length) {\n+            throw new IllegalArgumentException(\"Number of columns in line is not as expected. Expected: \"\n+                    + headerNames.length + \" columns, found: \" + fieldValues.length + \", for line: \" + line);\n+        }\n+\n+        // now iterate over lines and trim each value:\n+        for (int i = 0; i < fieldValues.length; i++) {\n+            fieldValues[i] = fieldValues[i].trim();\n+        }\n+        return fieldValues;\n+    }\n+\n+    private boolean addDatum(String[] fields, List<ResourceDefinition> resources, MultiKeyMap resourceMap, String[] headerNames)\n+            throws Exception {\n+        int sampleIdIndex = findSampleIdColumn(headerNames);\n+        String stableSampleId = (sampleIdIndex >= 0) ? fields[sampleIdIndex] : \"\";\n+        stableSampleId = StableIdUtil.getSampleId(stableSampleId);\n+        int patientIdIndex = findPatientIdColumn(headerNames);\n+        String stablePatientId = (patientIdIndex >= 0) ? fields[patientIdIndex] : \"\";\n+        stablePatientId = StableIdUtil.getPatientId(stablePatientId);\n+        int resourceIdIndex = findResourceIdColumn(headerNames);\n+        int urlIndex = findURLColumn(headerNames);\n+        int internalSampleId = -1;\n+        int internalPatientId = -1;\n+\n+        // create resource_id set\n+        Set<String> patientResourceIdSet = resources\n+                .stream()\n+                .filter(resource -> resource.getResourceType().equals(ResourceDefinition.PATIENT_RESOURCE_TYPE))\n+                .map(resource -> resource.getResourceId())\n+                .collect(Collectors.toSet());\n+        Set<String> sampleResourceIdSet = resources\n+                .stream()\n+                .filter(resource -> resource.getResourceType().equals(ResourceDefinition.SAMPLE_RESOURCE_TYPE))\n+                .map(resource -> resource.getResourceId())\n+                .collect(Collectors.toSet());\n+        Set<String> studyResourceIdSet = resources\n+                .stream()\n+                .filter(resource -> resource.getResourceType().equals(ResourceDefinition.STUDY_RESOURCE_TYPE))\n+                .map(resource -> resource.getResourceId())\n+                .collect(Collectors.toSet());\n+\n+        // check if sample is not already added:\n+        Sample sample = DaoSample.getSampleByCancerStudyAndSampleId(cancerStudy.getInternalId(), stableSampleId, false);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTE3NjA4Ng=="}, "originalCommit": {"oid": "ad5abf7c9634a54ebf671517257638ed6e6141d8"}, "originalPosition": 196}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTc3NzMwOA==", "bodyText": "I see! I will update this!", "url": "https://github.com/cBioPortal/cbioportal/pull/7270#discussion_r395777308", "createdAt": "2020-03-20T17:10:57Z", "author": {"login": "dippindots"}, "path": "core/src/main/java/org/mskcc/cbio/portal/scripts/ImportResourceData.java", "diffHunk": "@@ -0,0 +1,574 @@\n+package org.mskcc.cbio.portal.scripts;\n+\n+import org.mskcc.cbio.portal.dao.*;\n+import org.mskcc.cbio.portal.model.*;\n+import org.mskcc.cbio.portal.util.*;\n+import org.mskcc.cbio.portal.util.ValuesUtils.MissingValues;\n+\n+import java.io.*;\n+import joptsimple.*;\n+import java.util.*;\n+import java.util.regex.*;\n+import java.util.stream.Collectors;\n+\n+import org.apache.commons.collections.map.MultiKeyMap;\n+\n+public class ImportResourceData extends ConsoleRunnable {\n+\n+    public static final String DELIMITER = \"\\t\";\n+    public static final String METADATA_PREFIX = \"#\";\n+    public static final String SAMPLE_ID_COLUMN_NAME = \"SAMPLE_ID\";\n+    public static final String PATIENT_ID_COLUMN_NAME = \"PATIENT_ID\";\n+    public static final String RESOURCE_ID_COLUMN_NAME = \"RESOURCE_ID\";\n+    public static final String URL_COLUMN_NAME = \"URL\";\n+    public static final String SAMPLE_TYPE_COLUMN_NAME = \"SAMPLE_TYPE\";\n+    private int numSampleSpecificResourcesAdded = 0;\n+    private int numPatientSpecificResourcesAdded = 0;\n+    private int numStudySpecificResourcesAdded = 0;\n+    private int numEmptyResourcesSkipped = 0;\n+    private int numSamplesProcessed = 0;\n+\n+    private static Properties properties;\n+\n+    private File resourceDataFile;\n+    private CancerStudy cancerStudy;\n+    private ResourceTypes resourceType;\n+    private boolean relaxed;\n+    private Set<String> patientIds = new HashSet<String>();\n+\n+    public static enum ResourceTypes {\n+        PATIENT(\"PATIENT\"), SAMPLE(\"SAMPLE\"), STUDY(\"STUDY\");\n+\n+        private String resourceTypes;\n+\n+        ResourceTypes(String resourceTypes) {\n+            this.resourceTypes = resourceTypes;\n+        }\n+\n+        public String toString() {\n+            return resourceTypes;\n+        }\n+    }\n+\n+    public void setFile(CancerStudy cancerStudy, File resourceDataFile, String resourceType, boolean relaxed) {\n+        this.cancerStudy = cancerStudy;\n+        this.resourceDataFile = resourceDataFile;\n+        this.resourceType = ResourceTypes.valueOf(resourceType);\n+        this.relaxed = relaxed;\n+    }\n+\n+    public void importData() throws Exception {\n+        // if bulkLoading is ever turned off,\n+        // code has to be added to check whether\n+        // a resource data update should be\n+        // perform instead of an insert\n+        MySQLbulkLoader.bulkLoadOn();\n+\n+        if (relaxed) {\n+            MySQLbulkLoader.relaxedModeOn();\n+        }\n+\n+        FileReader reader = new FileReader(resourceDataFile);\n+        BufferedReader buff = new BufferedReader(reader);\n+        List<ResourceDefinition> resources = grabResources(buff);\n+        String currentLine = buff.readLine();\n+        String[] headerNames = currentLine.split(\"\\t\");\n+        \n+        int patientIdIndex = findPatientIdColumn(headerNames);\n+        int sampleIdIndex = findSampleIdColumn(headerNames);\n+        int resourceIdIndex = findResourceIdColumn(headerNames);\n+        int urlIndex = findURLColumn(headerNames);\n+\n+        // validate required columns:\n+        if (resourceIdIndex < 0) {\n+            throw new RuntimeException(\"Aborting owing to failure to find \" + RESOURCE_ID_COLUMN_NAME\n+                    + \" in file. Please check your file format and try again.\");\n+        }\n+        if (urlIndex < 0) {\n+            throw new RuntimeException(\"Aborting owing to failure to find \" + URL_COLUMN_NAME\n+                    + \" in file. Please check your file format and try again.\");\n+        }\n+        if ((resourceType.toString().equalsIgnoreCase(\"sample\") || resourceType.toString().equalsIgnoreCase(\"patient\")) && patientIdIndex < 0) {\n+            // PATIENT_ID is required in both patient and sample file types:\n+            throw new RuntimeException(\"Aborting owing to failure to find \" + PATIENT_ID_COLUMN_NAME\n+                    + \" in file. Please check your file format and try again.\");\n+        }\n+        if (resourceType.toString().equalsIgnoreCase(\"sample\") && sampleIdIndex < 0) {\n+            // SAMPLE_ID is required in SAMPLE file type:\n+            throw new RuntimeException(\"Aborting owing to failure to find \" + SAMPLE_ID_COLUMN_NAME\n+                    + \" in file. Please check your file format and try again.\");\n+        }\n+        importData(buff, resources, headerNames);\n+\n+        if (MySQLbulkLoader.isBulkLoad()) {\n+            MySQLbulkLoader.flushAll();\n+            MySQLbulkLoader.relaxedModeOff();\n+        }\n+    }\n+\n+    private List<ResourceDefinition> grabResources(BufferedReader buff) throws DaoException, IOException {\n+        List<ResourceDefinition> resources = new ArrayList<ResourceDefinition>();\n+        resources = DaoResourceDefinition.getDatumByStudy(cancerStudy.getInternalId());\n+        return resources;\n+    }\n+\n+    private String[] splitFields(String line) throws IOException {\n+        line = line.replaceAll(\"^\" + METADATA_PREFIX + \"+\", \"\");\n+        String[] fields = line.split(DELIMITER, -1);\n+\n+        return fields;\n+    }\n+\n+    private void importData(BufferedReader buff, List<ResourceDefinition> resources, String[] headerNames) throws Exception {\n+        String line;\n+        MultiKeyMap resourceMap = new MultiKeyMap();\n+        while ((line = buff.readLine()) != null) {\n+            if (skipLine(line.trim())) {\n+                continue;\n+            }\n+\n+            String[] fieldValues = getFieldValues(line, headerNames);\n+            addDatum(fieldValues, resources, resourceMap, headerNames);\n+        }\n+    }\n+\n+    private boolean skipLine(String line) {\n+        return (line.isEmpty() || line.substring(0, 1).equals(METADATA_PREFIX));\n+    }\n+\n+    /**\n+     * Takes in the given line and returns the list of field values by splitting the\n+     * line on DELIMITER.\n+     * \n+     * @param line\n+     * @param headerNames\n+     * @return the list of values, one for each column. Value will be \"\" for empty\n+     *         columns.\n+     */\n+    private String[] getFieldValues(String line, String[] headerNames) {\n+        // split on delimiter:\n+        String[] fieldValues = line.split(DELIMITER, -1);\n+\n+        // validate: if number of fields is incorrect, give exception\n+        if (fieldValues.length != headerNames.length) {\n+            throw new IllegalArgumentException(\"Number of columns in line is not as expected. Expected: \"\n+                    + headerNames.length + \" columns, found: \" + fieldValues.length + \", for line: \" + line);\n+        }\n+\n+        // now iterate over lines and trim each value:\n+        for (int i = 0; i < fieldValues.length; i++) {\n+            fieldValues[i] = fieldValues[i].trim();\n+        }\n+        return fieldValues;\n+    }\n+\n+    private boolean addDatum(String[] fields, List<ResourceDefinition> resources, MultiKeyMap resourceMap, String[] headerNames)\n+            throws Exception {\n+        int sampleIdIndex = findSampleIdColumn(headerNames);\n+        String stableSampleId = (sampleIdIndex >= 0) ? fields[sampleIdIndex] : \"\";\n+        stableSampleId = StableIdUtil.getSampleId(stableSampleId);\n+        int patientIdIndex = findPatientIdColumn(headerNames);\n+        String stablePatientId = (patientIdIndex >= 0) ? fields[patientIdIndex] : \"\";\n+        stablePatientId = StableIdUtil.getPatientId(stablePatientId);\n+        int resourceIdIndex = findResourceIdColumn(headerNames);\n+        int urlIndex = findURLColumn(headerNames);\n+        int internalSampleId = -1;\n+        int internalPatientId = -1;\n+\n+        // create resource_id set\n+        Set<String> patientResourceIdSet = resources\n+                .stream()\n+                .filter(resource -> resource.getResourceType().equals(ResourceDefinition.PATIENT_RESOURCE_TYPE))\n+                .map(resource -> resource.getResourceId())\n+                .collect(Collectors.toSet());\n+        Set<String> sampleResourceIdSet = resources\n+                .stream()\n+                .filter(resource -> resource.getResourceType().equals(ResourceDefinition.SAMPLE_RESOURCE_TYPE))\n+                .map(resource -> resource.getResourceId())\n+                .collect(Collectors.toSet());\n+        Set<String> studyResourceIdSet = resources\n+                .stream()\n+                .filter(resource -> resource.getResourceType().equals(ResourceDefinition.STUDY_RESOURCE_TYPE))\n+                .map(resource -> resource.getResourceId())\n+                .collect(Collectors.toSet());\n+\n+        // check if sample is not already added:\n+        Sample sample = DaoSample.getSampleByCancerStudyAndSampleId(cancerStudy.getInternalId(), stableSampleId, false);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTE3NjA4Ng=="}, "originalCommit": {"oid": "ad5abf7c9634a54ebf671517257638ed6e6141d8"}, "originalPosition": 196}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ0OTQ2NDQ4OnYy", "diffSide": "RIGHT", "path": "core/src/main/java/org/mskcc/cbio/portal/scripts/ImportResourceDefinition.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOVQxNzowNzo1NFrOF44KZg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOVQxNzowNzo1NFrOF44KZg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTE4NDc0Mg==", "bodyText": "could we send Map<String,Integer> of headerNames instead of array? checking in map is more efficient than iterating an array", "url": "https://github.com/cBioPortal/cbioportal/pull/7270#discussion_r395184742", "createdAt": "2020-03-19T17:07:54Z", "author": {"login": "kalletlak"}, "path": "core/src/main/java/org/mskcc/cbio/portal/scripts/ImportResourceDefinition.java", "diffHunk": "@@ -0,0 +1,330 @@\n+package org.mskcc.cbio.portal.scripts;\n+\n+import org.mskcc.cbio.portal.dao.*;\n+import org.mskcc.cbio.portal.model.*;\n+import org.mskcc.cbio.portal.scripts.ImportResourceData.ResourceTypes;\n+import org.mskcc.cbio.portal.util.*;\n+import org.mskcc.cbio.portal.util.ValuesUtils.MissingValues;\n+\n+import java.io.*;\n+import joptsimple.*;\n+import java.util.*;\n+\n+public class ImportResourceDefinition extends ConsoleRunnable {\n+\n+    public static final String DELIMITER = \"\\t\";\n+    public static final String RESOURCE_ID_COLUMN_NAME = \"RESOURCE_ID\";\n+    public static final String DISPLAY_NAME_COLUMN_NAME = \"DISPLAY_NAME\";\n+    public static final String DESCRIPTION_COLUMN_NAME = \"DESCRIPTION\";\n+    public static final String RESOURCE_TYPE_COLUMN_NAME = \"RESOURCE_TYPE\";\n+    public static final String OPEN_BY_DEFAULT_COLUMN_NAME = \"OPEN_BY_DEFAULT\";\n+    public static final String PRIORITY_COLUMN_NAME = \"PRIORITY\";\n+    private int numResourceDefinitionsAdded = 0;\n+\n+    private static Properties properties;\n+\n+    private File resourceDataFile;\n+    private CancerStudy cancerStudy;\n+    private boolean relaxed;\n+\n+    public void setFile(CancerStudy cancerStudy, File resourceDataFile, boolean relaxed) {\n+        this.cancerStudy = cancerStudy;\n+        this.resourceDataFile = resourceDataFile;\n+        this.relaxed = relaxed;\n+    }\n+\n+    public void importData() throws Exception {\n+        // if bulkLoading is ever turned off,\n+        // code has to be added to check whether\n+        // a resource data update should be\n+        // perform instead of an insert\n+        MySQLbulkLoader.bulkLoadOn();\n+\n+        if (relaxed) {\n+            MySQLbulkLoader.relaxedModeOn();\n+        }\n+\n+        FileReader reader = new FileReader(resourceDataFile);\n+        BufferedReader buff = new BufferedReader(reader);\n+\n+        String line = buff.readLine();\n+        String[] headerNames = splitFields(line);\n+\n+        // validate columns and get index\n+        int resourceIdIndex = findAndValidateResourceIdColumn(headerNames);\n+        int displayNameIndex = findAndValidateDisplayNameColumn(headerNames);\n+        int descriptionIndex = findAndValidateDescriptionColumn(headerNames);\n+        int resourceTypeIndex = findAndValidateResourceTypeColumn(headerNames);\n+        int openByDefaultIndex = findAndValidateOpenByDefaultColumn(headerNames);\n+        int priorityIndex = findAndValidatePriorityColumn(headerNames);\n+\n+        while ((line = buff.readLine()) != null) {\n+            if (skipLine(line.trim())) {\n+                continue;\n+            }\n+\n+            String[] fieldValues = getFieldValues(line, headerNames);\n+\n+            // set default value\n+            String resourceId = \"\";\n+            String displayName = \"\";\n+            String description = \"\";\n+            String resourceType = \"\";\n+            Boolean openByDefault = false;\n+            int priority = 1;\n+            // get resource definitions from columns\n+            // get resourceId\n+            if (resourceIdIndex != -1 && isValueNotMissing(fieldValues[resourceIdIndex].toUpperCase())) {\n+                resourceId = fieldValues[resourceIdIndex].toUpperCase();\n+            } else {\n+                throw new RuntimeException(\n+                        \"Please provide a valid resource id\");\n+            }\n+            // get displayName\n+            if (resourceIdIndex != -1 && isValueNotMissing(fieldValues[displayNameIndex])) {\n+                displayName = fieldValues[displayNameIndex];\n+            }\n+            else {\n+                throw new RuntimeException(\n+                        \"Please provide a valid display name\");\n+            }\n+            // get description (optional)\n+            if (descriptionIndex != -1 && isValueNotMissing(fieldValues[descriptionIndex])) {\n+                description = fieldValues[descriptionIndex];\n+            }\n+            // get resourceType (must be value of ResourceTypes)\n+            if (resourceTypeIndex != -1 && isValidResourceType(fieldValues[resourceTypeIndex])) {\n+                resourceType = fieldValues[resourceTypeIndex];\n+            }\n+            // get openByDefault (optional)\n+            if (openByDefaultIndex != -1 && isValidOpenByDefault(fieldValues[openByDefaultIndex])) {\n+                openByDefault = fieldValues[openByDefaultIndex].equalsIgnoreCase(\"true\");\n+            }\n+            // get priority (optional)\n+            try {\n+                priority = Integer.parseInt(fieldValues[priorityIndex]);\n+            } catch (NumberFormatException ex) {\n+                throw new DaoException(\n+                    \"priority cannot be parsed as an integer, all priority should be an integer.\");\n+            }\n+\n+            // add resource definitions into database\n+            ResourceDefinition resource = new ResourceDefinition(resourceId, displayName,\n+                    description, resourceType, openByDefault,\n+                    priority, cancerStudy.getInternalId());\n+\n+            ResourceDefinition resourceInDb = DaoResourceDefinition.getDatum(resource.getResourceId(),\n+                    cancerStudy.getInternalId());\n+            if (resourceInDb != null) {\n+                ProgressMonitor.logWarning(\"Resource \" + resourceInDb.getResourceId() + \" found twice in your study!\");\n+                continue;\n+            }\n+            if (DaoResourceDefinition.addDatum(resource) > 0) {\n+                numResourceDefinitionsAdded++;\n+            }\n+        }\n+        buff.close();\n+\n+        if (MySQLbulkLoader.isBulkLoad()) {\n+            MySQLbulkLoader.flushAll();\n+            MySQLbulkLoader.relaxedModeOff();\n+        }\n+    }\n+\n+    private String[] splitFields(String line) throws IOException {\n+        String[] fields = line.split(DELIMITER, -1);\n+\n+        return fields;\n+    }\n+\n+    private boolean skipLine(String line) {\n+        return line.isEmpty();\n+    }\n+\n+    /**\n+     * Takes in the given line and returns the list of field values by splitting the\n+     * line on DELIMITER.\n+     * \n+     * @param line\n+     * @param headerNames\n+     * @return the list of values, one for each column. Value will be \"\" for empty\n+     *         columns.\n+     */\n+    private String[] getFieldValues(String line, String[] headerNames) {\n+        // split on delimiter:\n+        String[] fieldValues = line.split(DELIMITER, -1);\n+\n+        // validate: if number of fields is incorrect, give exception\n+        if (fieldValues.length != headerNames.length) {\n+            throw new IllegalArgumentException(\"Number of columns in line is not as expected. Expected: \"\n+                    + headerNames.length + \" columns, found: \" + fieldValues.length + \", for line: \" + line);\n+        }\n+\n+        // now iterate over lines and trim each value:\n+        for (int i = 0; i < fieldValues.length; i++) {\n+            fieldValues[i] = fieldValues[i].trim();\n+        }\n+        return fieldValues;\n+    }\n+\n+    private Boolean isValueNotMissing(String value) {\n+        if (MissingValues.has(value)) {\n+            return false;\n+        }\n+        return true;\n+    }\n+\n+    private Boolean isValidResourceType(String value) {\n+        try {\n+            ResourceTypes.valueOf(value);\n+        } catch (IllegalArgumentException ex) {\n+            throw new IllegalArgumentException(\"Resource_Type should be one of the following : 'SAMPLE', 'PATIENT' or 'STUDY'.\"\n+                    + \"found: \" + value);\n+        }\n+        return true;\n+    }\n+\n+    private Boolean isValidOpenByDefault(String value) {\n+        if (value.equalsIgnoreCase(\"true\") || value.equalsIgnoreCase(\"false\")) {\n+            return true;\n+        }\n+        // open by default value not valid, will set as false by default\n+        ProgressMonitor.logWarning(\"OpenByDefault value is not true or false, set to false by default.\");\n+        return false;\n+    }\n+\n+    private int findAndValidateResourceIdColumn(String[] headerNames) {\n+        return findAndValidateColumnIndexInHeaders(RESOURCE_ID_COLUMN_NAME, headerNames);\n+    }\n+\n+    private int findAndValidateDisplayNameColumn(String[] headerNames) {\n+        return findAndValidateColumnIndexInHeaders(DISPLAY_NAME_COLUMN_NAME, headerNames);\n+    }\n+\n+    private int findAndValidateDescriptionColumn(String[] headerNames) {\n+        return findAndValidateColumnIndexInHeaders(DESCRIPTION_COLUMN_NAME, headerNames);\n+    }\n+\n+    private int findAndValidateResourceTypeColumn(String[] headerNames) {\n+        return findAndValidateColumnIndexInHeaders(RESOURCE_TYPE_COLUMN_NAME, headerNames);\n+    }\n+\n+    private int findAndValidateOpenByDefaultColumn(String[] headerNames) {\n+        return findAndValidateColumnIndexInHeaders(OPEN_BY_DEFAULT_COLUMN_NAME, headerNames);\n+    }\n+\n+    private int findAndValidatePriorityColumn(String[] headerNames) {\n+        return findAndValidateColumnIndexInHeaders(PRIORITY_COLUMN_NAME, headerNames);\n+    }\n+\n+    private int findAndValidateColumnIndexInHeaders(String columnHeader, String[] headerNames) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ad5abf7c9634a54ebf671517257638ed6e6141d8"}, "originalPosition": 220}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ1MzYyNzEwOnYy", "diffSide": "RIGHT", "path": "model/src/main/java/org/cbioportal/model/ResourceType.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yMFQxOTo1MDo1M1rOF5hSJg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yM1QxNjozNzo0MVrOF6N_4w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTg1ODQ3MA==", "bodyText": "Any specific reason for overriding the value? its better to keep simple", "url": "https://github.com/cBioPortal/cbioportal/pull/7270#discussion_r395858470", "createdAt": "2020-03-20T19:50:53Z", "author": {"login": "kalletlak"}, "path": "model/src/main/java/org/cbioportal/model/ResourceType.java", "diffHunk": "@@ -1,7 +1,17 @@\n package org.cbioportal.model;\n \n public enum ResourceType {\n-    STUDY,\n-    SAMPLE,\n-    PATIENT\n+    STUDY(\"STUDY\"),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7a02f1fe6d7876b81ccca114d9423e745129900e"}, "originalPosition": 7}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTg4NjM2MQ==", "bodyText": "I want to get the string value from the ResourceType, I didn't have a way to do that, so I overrode this.\nIs there a way to get the value of the ResourceType? For example https://github.com/cBioPortal/cbioportal/pull/7270/files#diff-5041ba5290d6be4231695bde8b85883bR28.", "url": "https://github.com/cBioPortal/cbioportal/pull/7270#discussion_r395886361", "createdAt": "2020-03-20T20:57:23Z", "author": {"login": "dippindots"}, "path": "model/src/main/java/org/cbioportal/model/ResourceType.java", "diffHunk": "@@ -1,7 +1,17 @@\n package org.cbioportal.model;\n \n public enum ResourceType {\n-    STUDY,\n-    SAMPLE,\n-    PATIENT\n+    STUDY(\"STUDY\"),", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTg1ODQ3MA=="}, "originalCommit": {"oid": "7a02f1fe6d7876b81ccca114d9423e745129900e"}, "originalPosition": 7}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjU1NzE0Nw==", "bodyText": "there is name() to get string value", "url": "https://github.com/cBioPortal/cbioportal/pull/7270#discussion_r396557147", "createdAt": "2020-03-23T15:53:03Z", "author": {"login": "kalletlak"}, "path": "model/src/main/java/org/cbioportal/model/ResourceType.java", "diffHunk": "@@ -1,7 +1,17 @@\n package org.cbioportal.model;\n \n public enum ResourceType {\n-    STUDY,\n-    SAMPLE,\n-    PATIENT\n+    STUDY(\"STUDY\"),", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTg1ODQ3MA=="}, "originalCommit": {"oid": "7a02f1fe6d7876b81ccca114d9423e745129900e"}, "originalPosition": 7}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjU5MTA3NQ==", "bodyText": "Thanks! Got it!", "url": "https://github.com/cBioPortal/cbioportal/pull/7270#discussion_r396591075", "createdAt": "2020-03-23T16:37:41Z", "author": {"login": "dippindots"}, "path": "model/src/main/java/org/cbioportal/model/ResourceType.java", "diffHunk": "@@ -1,7 +1,17 @@\n package org.cbioportal.model;\n \n public enum ResourceType {\n-    STUDY,\n-    SAMPLE,\n-    PATIENT\n+    STUDY(\"STUDY\"),", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTg1ODQ3MA=="}, "originalCommit": {"oid": "7a02f1fe6d7876b81ccca114d9423e745129900e"}, "originalPosition": 7}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ1MzY0MTMyOnYy", "diffSide": "RIGHT", "path": "core/src/main/java/org/mskcc/cbio/portal/scripts/ImportResourceDefinition.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yMFQxOTo1NjoxMFrOF5hbWw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yMFQxOTo1NjoxMFrOF5hbWw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTg2MDgyNw==", "bodyText": "looks like resourceIdIndex cannot be -1. It would throw RuntimeException", "url": "https://github.com/cBioPortal/cbioportal/pull/7270#discussion_r395860827", "createdAt": "2020-03-20T19:56:10Z", "author": {"login": "kalletlak"}, "path": "core/src/main/java/org/mskcc/cbio/portal/scripts/ImportResourceDefinition.java", "diffHunk": "@@ -0,0 +1,337 @@\n+package org.mskcc.cbio.portal.scripts;\n+\n+import org.cbioportal.model.ResourceType;\n+import org.mskcc.cbio.portal.dao.*;\n+import org.mskcc.cbio.portal.model.*;\n+import org.mskcc.cbio.portal.util.*;\n+import org.mskcc.cbio.portal.util.ValuesUtils.MissingValues;\n+\n+import java.io.*;\n+import joptsimple.*;\n+import java.util.*;\n+\n+public class ImportResourceDefinition extends ConsoleRunnable {\n+\n+    public static final String DELIMITER = \"\\t\";\n+    public static final String RESOURCE_ID_COLUMN_NAME = \"RESOURCE_ID\";\n+    public static final String DISPLAY_NAME_COLUMN_NAME = \"DISPLAY_NAME\";\n+    public static final String DESCRIPTION_COLUMN_NAME = \"DESCRIPTION\";\n+    public static final String RESOURCE_TYPE_COLUMN_NAME = \"RESOURCE_TYPE\";\n+    public static final String OPEN_BY_DEFAULT_COLUMN_NAME = \"OPEN_BY_DEFAULT\";\n+    public static final String PRIORITY_COLUMN_NAME = \"PRIORITY\";\n+    private int numResourceDefinitionsAdded = 0;\n+\n+    private static Properties properties;\n+\n+    private File resourceDataFile;\n+    private CancerStudy cancerStudy;\n+    private boolean relaxed;\n+\n+    public void setFile(CancerStudy cancerStudy, File resourceDataFile, boolean relaxed) {\n+        this.cancerStudy = cancerStudy;\n+        this.resourceDataFile = resourceDataFile;\n+        this.relaxed = relaxed;\n+    }\n+\n+    public void importData() throws Exception {\n+        // if bulkLoading is ever turned off,\n+        // code has to be added to check whether\n+        // a resource data update should be\n+        // perform instead of an insert\n+        MySQLbulkLoader.bulkLoadOn();\n+\n+        if (relaxed) {\n+            MySQLbulkLoader.relaxedModeOn();\n+        }\n+\n+        FileReader reader = new FileReader(resourceDataFile);\n+        BufferedReader buff = new BufferedReader(reader);\n+\n+        String line = buff.readLine();\n+        String[] headerNames = splitFields(line);\n+        Map<String, Integer> headerIndexMap = makeHeaderIndexMap(headerNames);\n+\n+        // validate columns and get index\n+        int resourceIdIndex = findAndValidateResourceIdColumn(headerIndexMap);\n+        int displayNameIndex = findAndValidateDisplayNameColumn(headerIndexMap);\n+        int descriptionIndex = findAndValidateDescriptionColumn(headerIndexMap);\n+        int resourceTypeIndex = findAndValidateResourceTypeColumn(headerIndexMap);\n+        int openByDefaultIndex = findAndValidateOpenByDefaultColumn(headerIndexMap);\n+        int priorityIndex = findAndValidatePriorityColumn(headerIndexMap);\n+\n+        while ((line = buff.readLine()) != null) {\n+            if (skipLine(line.trim())) {\n+                continue;\n+            }\n+\n+            String[] fieldValues = getFieldValues(line, headerIndexMap);\n+\n+            // set default value\n+            String resourceId = \"\";\n+            String displayName = \"\";\n+            String description = \"\";\n+            ResourceType resourceType = null;\n+            Boolean openByDefault = false;\n+            int priority = 1;\n+            // get resource definitions from columns\n+            // get resourceId\n+            if (resourceIdIndex != -1 && isValueNotMissing(fieldValues[resourceIdIndex].toUpperCase())) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7a02f1fe6d7876b81ccca114d9423e745129900e"}, "originalPosition": 78}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ1MzY0NTQ2OnYy", "diffSide": "RIGHT", "path": "core/src/main/java/org/mskcc/cbio/portal/scripts/ImportResourceDefinition.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yMFQxOTo1NzozNFrOF5hd7w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yMFQxOTo1NzozNFrOF5hd7w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTg2MTQ4Nw==", "bodyText": "should be displayNameIndex", "url": "https://github.com/cBioPortal/cbioportal/pull/7270#discussion_r395861487", "createdAt": "2020-03-20T19:57:34Z", "author": {"login": "kalletlak"}, "path": "core/src/main/java/org/mskcc/cbio/portal/scripts/ImportResourceDefinition.java", "diffHunk": "@@ -0,0 +1,337 @@\n+package org.mskcc.cbio.portal.scripts;\n+\n+import org.cbioportal.model.ResourceType;\n+import org.mskcc.cbio.portal.dao.*;\n+import org.mskcc.cbio.portal.model.*;\n+import org.mskcc.cbio.portal.util.*;\n+import org.mskcc.cbio.portal.util.ValuesUtils.MissingValues;\n+\n+import java.io.*;\n+import joptsimple.*;\n+import java.util.*;\n+\n+public class ImportResourceDefinition extends ConsoleRunnable {\n+\n+    public static final String DELIMITER = \"\\t\";\n+    public static final String RESOURCE_ID_COLUMN_NAME = \"RESOURCE_ID\";\n+    public static final String DISPLAY_NAME_COLUMN_NAME = \"DISPLAY_NAME\";\n+    public static final String DESCRIPTION_COLUMN_NAME = \"DESCRIPTION\";\n+    public static final String RESOURCE_TYPE_COLUMN_NAME = \"RESOURCE_TYPE\";\n+    public static final String OPEN_BY_DEFAULT_COLUMN_NAME = \"OPEN_BY_DEFAULT\";\n+    public static final String PRIORITY_COLUMN_NAME = \"PRIORITY\";\n+    private int numResourceDefinitionsAdded = 0;\n+\n+    private static Properties properties;\n+\n+    private File resourceDataFile;\n+    private CancerStudy cancerStudy;\n+    private boolean relaxed;\n+\n+    public void setFile(CancerStudy cancerStudy, File resourceDataFile, boolean relaxed) {\n+        this.cancerStudy = cancerStudy;\n+        this.resourceDataFile = resourceDataFile;\n+        this.relaxed = relaxed;\n+    }\n+\n+    public void importData() throws Exception {\n+        // if bulkLoading is ever turned off,\n+        // code has to be added to check whether\n+        // a resource data update should be\n+        // perform instead of an insert\n+        MySQLbulkLoader.bulkLoadOn();\n+\n+        if (relaxed) {\n+            MySQLbulkLoader.relaxedModeOn();\n+        }\n+\n+        FileReader reader = new FileReader(resourceDataFile);\n+        BufferedReader buff = new BufferedReader(reader);\n+\n+        String line = buff.readLine();\n+        String[] headerNames = splitFields(line);\n+        Map<String, Integer> headerIndexMap = makeHeaderIndexMap(headerNames);\n+\n+        // validate columns and get index\n+        int resourceIdIndex = findAndValidateResourceIdColumn(headerIndexMap);\n+        int displayNameIndex = findAndValidateDisplayNameColumn(headerIndexMap);\n+        int descriptionIndex = findAndValidateDescriptionColumn(headerIndexMap);\n+        int resourceTypeIndex = findAndValidateResourceTypeColumn(headerIndexMap);\n+        int openByDefaultIndex = findAndValidateOpenByDefaultColumn(headerIndexMap);\n+        int priorityIndex = findAndValidatePriorityColumn(headerIndexMap);\n+\n+        while ((line = buff.readLine()) != null) {\n+            if (skipLine(line.trim())) {\n+                continue;\n+            }\n+\n+            String[] fieldValues = getFieldValues(line, headerIndexMap);\n+\n+            // set default value\n+            String resourceId = \"\";\n+            String displayName = \"\";\n+            String description = \"\";\n+            ResourceType resourceType = null;\n+            Boolean openByDefault = false;\n+            int priority = 1;\n+            // get resource definitions from columns\n+            // get resourceId\n+            if (resourceIdIndex != -1 && isValueNotMissing(fieldValues[resourceIdIndex].toUpperCase())) {\n+                resourceId = fieldValues[resourceIdIndex].toUpperCase();\n+            } else {\n+                throw new RuntimeException(\n+                        \"Please provide a valid resource id\");\n+            }\n+            // get displayName\n+            if (resourceIdIndex != -1 && isValueNotMissing(fieldValues[displayNameIndex])) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7a02f1fe6d7876b81ccca114d9423e745129900e"}, "originalPosition": 85}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ1MzcwNzQ1OnYy", "diffSide": "RIGHT", "path": "core/src/main/java/org/mskcc/cbio/portal/util/ValuesUtils.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yMFQyMDoyMToyMVrOF5iFXw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yMFQyMDoyMToyMVrOF5iFXw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTg3MTU4Mw==", "bodyText": "why not MissingValues enum directly instead of ValuesUtils", "url": "https://github.com/cBioPortal/cbioportal/pull/7270#discussion_r395871583", "createdAt": "2020-03-20T20:21:21Z", "author": {"login": "kalletlak"}, "path": "core/src/main/java/org/mskcc/cbio/portal/util/ValuesUtils.java", "diffHunk": "@@ -0,0 +1,41 @@\n+package org.mskcc.cbio.portal.util;\n+\n+public class ValuesUtils {\n+    public static enum MissingValues {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7a02f1fe6d7876b81ccca114d9423e745129900e"}, "originalPosition": 4}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ1MzcxMDMxOnYy", "diffSide": "RIGHT", "path": "core/src/main/java/org/mskcc/cbio/portal/scripts/ImportResourceDefinition.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yMFQyMDoyMjozMVrOF5iHQA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yMFQyMDoyMjozMVrOF5iHQA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTg3MjA2NA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    String[] fields = line.split(DELIMITER, -1);\n          \n          \n            \n                   return line.split(DELIMITER, -1);", "url": "https://github.com/cBioPortal/cbioportal/pull/7270#discussion_r395872064", "createdAt": "2020-03-20T20:22:31Z", "author": {"login": "kalletlak"}, "path": "core/src/main/java/org/mskcc/cbio/portal/scripts/ImportResourceDefinition.java", "diffHunk": "@@ -0,0 +1,337 @@\n+package org.mskcc.cbio.portal.scripts;\n+\n+import org.cbioportal.model.ResourceType;\n+import org.mskcc.cbio.portal.dao.*;\n+import org.mskcc.cbio.portal.model.*;\n+import org.mskcc.cbio.portal.util.*;\n+import org.mskcc.cbio.portal.util.ValuesUtils.MissingValues;\n+\n+import java.io.*;\n+import joptsimple.*;\n+import java.util.*;\n+\n+public class ImportResourceDefinition extends ConsoleRunnable {\n+\n+    public static final String DELIMITER = \"\\t\";\n+    public static final String RESOURCE_ID_COLUMN_NAME = \"RESOURCE_ID\";\n+    public static final String DISPLAY_NAME_COLUMN_NAME = \"DISPLAY_NAME\";\n+    public static final String DESCRIPTION_COLUMN_NAME = \"DESCRIPTION\";\n+    public static final String RESOURCE_TYPE_COLUMN_NAME = \"RESOURCE_TYPE\";\n+    public static final String OPEN_BY_DEFAULT_COLUMN_NAME = \"OPEN_BY_DEFAULT\";\n+    public static final String PRIORITY_COLUMN_NAME = \"PRIORITY\";\n+    private int numResourceDefinitionsAdded = 0;\n+\n+    private static Properties properties;\n+\n+    private File resourceDataFile;\n+    private CancerStudy cancerStudy;\n+    private boolean relaxed;\n+\n+    public void setFile(CancerStudy cancerStudy, File resourceDataFile, boolean relaxed) {\n+        this.cancerStudy = cancerStudy;\n+        this.resourceDataFile = resourceDataFile;\n+        this.relaxed = relaxed;\n+    }\n+\n+    public void importData() throws Exception {\n+        // if bulkLoading is ever turned off,\n+        // code has to be added to check whether\n+        // a resource data update should be\n+        // perform instead of an insert\n+        MySQLbulkLoader.bulkLoadOn();\n+\n+        if (relaxed) {\n+            MySQLbulkLoader.relaxedModeOn();\n+        }\n+\n+        FileReader reader = new FileReader(resourceDataFile);\n+        BufferedReader buff = new BufferedReader(reader);\n+\n+        String line = buff.readLine();\n+        String[] headerNames = splitFields(line);\n+        Map<String, Integer> headerIndexMap = makeHeaderIndexMap(headerNames);\n+\n+        // validate columns and get index\n+        int resourceIdIndex = findAndValidateResourceIdColumn(headerIndexMap);\n+        int displayNameIndex = findAndValidateDisplayNameColumn(headerIndexMap);\n+        int descriptionIndex = findAndValidateDescriptionColumn(headerIndexMap);\n+        int resourceTypeIndex = findAndValidateResourceTypeColumn(headerIndexMap);\n+        int openByDefaultIndex = findAndValidateOpenByDefaultColumn(headerIndexMap);\n+        int priorityIndex = findAndValidatePriorityColumn(headerIndexMap);\n+\n+        while ((line = buff.readLine()) != null) {\n+            if (skipLine(line.trim())) {\n+                continue;\n+            }\n+\n+            String[] fieldValues = getFieldValues(line, headerIndexMap);\n+\n+            // set default value\n+            String resourceId = \"\";\n+            String displayName = \"\";\n+            String description = \"\";\n+            ResourceType resourceType = null;\n+            Boolean openByDefault = false;\n+            int priority = 1;\n+            // get resource definitions from columns\n+            // get resourceId\n+            if (resourceIdIndex != -1 && isValueNotMissing(fieldValues[resourceIdIndex].toUpperCase())) {\n+                resourceId = fieldValues[resourceIdIndex].toUpperCase();\n+            } else {\n+                throw new RuntimeException(\n+                        \"Please provide a valid resource id\");\n+            }\n+            // get displayName\n+            if (resourceIdIndex != -1 && isValueNotMissing(fieldValues[displayNameIndex])) {\n+                displayName = fieldValues[displayNameIndex];\n+            }\n+            else {\n+                throw new RuntimeException(\n+                        \"Please provide a valid display name\");\n+            }\n+            // get description (optional)\n+            if (descriptionIndex != -1 && isValueNotMissing(fieldValues[descriptionIndex])) {\n+                description = fieldValues[descriptionIndex];\n+            }\n+            // get resourceType (must be value of ResourceTypes)\n+            if (resourceTypeIndex != -1 && isValidResourceType(fieldValues[resourceTypeIndex])) {\n+                resourceType = ResourceType.valueOf(fieldValues[resourceTypeIndex]);\n+            }\n+            // get openByDefault (optional)\n+            if (openByDefaultIndex != -1 && isValidOpenByDefault(fieldValues[openByDefaultIndex])) {\n+                openByDefault = Boolean.parseBoolean(fieldValues[openByDefaultIndex]);\n+            }\n+            // get priority (optional)\n+            try {\n+                priority = Integer.parseInt(fieldValues[priorityIndex]);\n+            } catch (NumberFormatException ex) {\n+                throw new DaoException(\n+                    \"priority cannot be parsed as an integer, all priority should be an integer.\");\n+            }\n+\n+            // add resource definitions into database\n+            ResourceDefinition resource = new ResourceDefinition(resourceId, displayName,\n+                    description, resourceType, openByDefault,\n+                    priority, cancerStudy.getInternalId());\n+\n+            ResourceDefinition resourceInDb = DaoResourceDefinition.getDatum(resource.getResourceId(),\n+                    cancerStudy.getInternalId());\n+            if (resourceInDb != null) {\n+                ProgressMonitor.logWarning(\"Resource \" + resourceInDb.getResourceId() + \" found twice in your study!\");\n+                continue;\n+            }\n+            if (DaoResourceDefinition.addDatum(resource) > 0) {\n+                numResourceDefinitionsAdded++;\n+            }\n+        }\n+        buff.close();\n+\n+        if (MySQLbulkLoader.isBulkLoad()) {\n+            MySQLbulkLoader.flushAll();\n+            MySQLbulkLoader.relaxedModeOff();\n+        }\n+    }\n+\n+    private String[] splitFields(String line) throws IOException {\n+        String[] fields = line.split(DELIMITER, -1);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7a02f1fe6d7876b81ccca114d9423e745129900e"}, "originalPosition": 136}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ1MzcxMTk0OnYy", "diffSide": "RIGHT", "path": "core/src/main/java/org/mskcc/cbio/portal/scripts/ImportResourceDefinition.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yMFQyMDoyMzowN1rOF5iISw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yMFQyMDoyMzowN1rOF5iISw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTg3MjMzMQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    if (MissingValues.has(value)) {\n          \n          \n            \n                    return !MissingValues.has(value);", "url": "https://github.com/cBioPortal/cbioportal/pull/7270#discussion_r395872331", "createdAt": "2020-03-20T20:23:07Z", "author": {"login": "kalletlak"}, "path": "core/src/main/java/org/mskcc/cbio/portal/scripts/ImportResourceDefinition.java", "diffHunk": "@@ -0,0 +1,337 @@\n+package org.mskcc.cbio.portal.scripts;\n+\n+import org.cbioportal.model.ResourceType;\n+import org.mskcc.cbio.portal.dao.*;\n+import org.mskcc.cbio.portal.model.*;\n+import org.mskcc.cbio.portal.util.*;\n+import org.mskcc.cbio.portal.util.ValuesUtils.MissingValues;\n+\n+import java.io.*;\n+import joptsimple.*;\n+import java.util.*;\n+\n+public class ImportResourceDefinition extends ConsoleRunnable {\n+\n+    public static final String DELIMITER = \"\\t\";\n+    public static final String RESOURCE_ID_COLUMN_NAME = \"RESOURCE_ID\";\n+    public static final String DISPLAY_NAME_COLUMN_NAME = \"DISPLAY_NAME\";\n+    public static final String DESCRIPTION_COLUMN_NAME = \"DESCRIPTION\";\n+    public static final String RESOURCE_TYPE_COLUMN_NAME = \"RESOURCE_TYPE\";\n+    public static final String OPEN_BY_DEFAULT_COLUMN_NAME = \"OPEN_BY_DEFAULT\";\n+    public static final String PRIORITY_COLUMN_NAME = \"PRIORITY\";\n+    private int numResourceDefinitionsAdded = 0;\n+\n+    private static Properties properties;\n+\n+    private File resourceDataFile;\n+    private CancerStudy cancerStudy;\n+    private boolean relaxed;\n+\n+    public void setFile(CancerStudy cancerStudy, File resourceDataFile, boolean relaxed) {\n+        this.cancerStudy = cancerStudy;\n+        this.resourceDataFile = resourceDataFile;\n+        this.relaxed = relaxed;\n+    }\n+\n+    public void importData() throws Exception {\n+        // if bulkLoading is ever turned off,\n+        // code has to be added to check whether\n+        // a resource data update should be\n+        // perform instead of an insert\n+        MySQLbulkLoader.bulkLoadOn();\n+\n+        if (relaxed) {\n+            MySQLbulkLoader.relaxedModeOn();\n+        }\n+\n+        FileReader reader = new FileReader(resourceDataFile);\n+        BufferedReader buff = new BufferedReader(reader);\n+\n+        String line = buff.readLine();\n+        String[] headerNames = splitFields(line);\n+        Map<String, Integer> headerIndexMap = makeHeaderIndexMap(headerNames);\n+\n+        // validate columns and get index\n+        int resourceIdIndex = findAndValidateResourceIdColumn(headerIndexMap);\n+        int displayNameIndex = findAndValidateDisplayNameColumn(headerIndexMap);\n+        int descriptionIndex = findAndValidateDescriptionColumn(headerIndexMap);\n+        int resourceTypeIndex = findAndValidateResourceTypeColumn(headerIndexMap);\n+        int openByDefaultIndex = findAndValidateOpenByDefaultColumn(headerIndexMap);\n+        int priorityIndex = findAndValidatePriorityColumn(headerIndexMap);\n+\n+        while ((line = buff.readLine()) != null) {\n+            if (skipLine(line.trim())) {\n+                continue;\n+            }\n+\n+            String[] fieldValues = getFieldValues(line, headerIndexMap);\n+\n+            // set default value\n+            String resourceId = \"\";\n+            String displayName = \"\";\n+            String description = \"\";\n+            ResourceType resourceType = null;\n+            Boolean openByDefault = false;\n+            int priority = 1;\n+            // get resource definitions from columns\n+            // get resourceId\n+            if (resourceIdIndex != -1 && isValueNotMissing(fieldValues[resourceIdIndex].toUpperCase())) {\n+                resourceId = fieldValues[resourceIdIndex].toUpperCase();\n+            } else {\n+                throw new RuntimeException(\n+                        \"Please provide a valid resource id\");\n+            }\n+            // get displayName\n+            if (resourceIdIndex != -1 && isValueNotMissing(fieldValues[displayNameIndex])) {\n+                displayName = fieldValues[displayNameIndex];\n+            }\n+            else {\n+                throw new RuntimeException(\n+                        \"Please provide a valid display name\");\n+            }\n+            // get description (optional)\n+            if (descriptionIndex != -1 && isValueNotMissing(fieldValues[descriptionIndex])) {\n+                description = fieldValues[descriptionIndex];\n+            }\n+            // get resourceType (must be value of ResourceTypes)\n+            if (resourceTypeIndex != -1 && isValidResourceType(fieldValues[resourceTypeIndex])) {\n+                resourceType = ResourceType.valueOf(fieldValues[resourceTypeIndex]);\n+            }\n+            // get openByDefault (optional)\n+            if (openByDefaultIndex != -1 && isValidOpenByDefault(fieldValues[openByDefaultIndex])) {\n+                openByDefault = Boolean.parseBoolean(fieldValues[openByDefaultIndex]);\n+            }\n+            // get priority (optional)\n+            try {\n+                priority = Integer.parseInt(fieldValues[priorityIndex]);\n+            } catch (NumberFormatException ex) {\n+                throw new DaoException(\n+                    \"priority cannot be parsed as an integer, all priority should be an integer.\");\n+            }\n+\n+            // add resource definitions into database\n+            ResourceDefinition resource = new ResourceDefinition(resourceId, displayName,\n+                    description, resourceType, openByDefault,\n+                    priority, cancerStudy.getInternalId());\n+\n+            ResourceDefinition resourceInDb = DaoResourceDefinition.getDatum(resource.getResourceId(),\n+                    cancerStudy.getInternalId());\n+            if (resourceInDb != null) {\n+                ProgressMonitor.logWarning(\"Resource \" + resourceInDb.getResourceId() + \" found twice in your study!\");\n+                continue;\n+            }\n+            if (DaoResourceDefinition.addDatum(resource) > 0) {\n+                numResourceDefinitionsAdded++;\n+            }\n+        }\n+        buff.close();\n+\n+        if (MySQLbulkLoader.isBulkLoad()) {\n+            MySQLbulkLoader.flushAll();\n+            MySQLbulkLoader.relaxedModeOff();\n+        }\n+    }\n+\n+    private String[] splitFields(String line) throws IOException {\n+        String[] fields = line.split(DELIMITER, -1);\n+\n+        return fields;\n+    }\n+\n+    private boolean skipLine(String line) {\n+        return line.isEmpty();\n+    }\n+\n+    /**\n+     * Takes in the given line and returns the list of field values by splitting the\n+     * line on DELIMITER.\n+     * \n+     * @param line\n+     * @param headerIndexMap\n+     * @return the list of values, one for each column. Value will be \"\" for empty\n+     *         columns.\n+     */\n+    private String[] getFieldValues(String line, Map<String, Integer> headerIndexMap) {\n+        // split on delimiter:\n+        String[] fieldValues = line.split(DELIMITER, -1);\n+\n+        // validate: if number of fields is incorrect, give exception\n+        if (fieldValues.length != headerIndexMap.size()) {\n+            throw new IllegalArgumentException(\"Number of columns in line is not as expected. Expected: \"\n+                    + headerIndexMap.size() + \" columns, found: \" + fieldValues.length + \", for line: \" + line);\n+        }\n+\n+        // now iterate over lines and trim each value:\n+        for (int i = 0; i < fieldValues.length; i++) {\n+            fieldValues[i] = fieldValues[i].trim();\n+        }\n+        return fieldValues;\n+    }\n+\n+    private Boolean isValueNotMissing(String value) {\n+        if (MissingValues.has(value)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7a02f1fe6d7876b81ccca114d9423e745129900e"}, "originalPosition": 172}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ1MzczOTc5OnYy", "diffSide": "RIGHT", "path": "core/src/main/java/org/mskcc/cbio/portal/scripts/ImportResourceData.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yMFQyMDozNDoxMFrOF5iaVw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yMFQyMDozNDoxMFrOF5iaVw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTg3Njk1MQ==", "bodyText": "may be\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    if (headerIndexMap.containsKey(columnHeader)) {\n          \n          \n            \n                    return headerIndexMap.getOrDefault(columnHeader, -1);", "url": "https://github.com/cBioPortal/cbioportal/pull/7270#discussion_r395876951", "createdAt": "2020-03-20T20:34:10Z", "author": {"login": "kalletlak"}, "path": "core/src/main/java/org/mskcc/cbio/portal/scripts/ImportResourceData.java", "diffHunk": "@@ -0,0 +1,559 @@\n+package org.mskcc.cbio.portal.scripts;\n+\n+import org.mskcc.cbio.portal.dao.*;\n+import org.mskcc.cbio.portal.model.*;\n+import org.mskcc.cbio.portal.util.*;\n+import org.mskcc.cbio.portal.util.ValuesUtils.MissingValues;\n+\n+import java.io.*;\n+import joptsimple.*;\n+import java.util.*;\n+import java.util.regex.*;\n+import java.util.stream.Collectors;\n+\n+import org.apache.commons.collections.map.MultiKeyMap;\n+import org.cbioportal.model.ResourceType;\n+\n+public class ImportResourceData extends ConsoleRunnable {\n+\n+    public static final String DELIMITER = \"\\t\";\n+    public static final String METADATA_PREFIX = \"#\";\n+    public static final String SAMPLE_ID_COLUMN_NAME = \"SAMPLE_ID\";\n+    public static final String PATIENT_ID_COLUMN_NAME = \"PATIENT_ID\";\n+    public static final String RESOURCE_ID_COLUMN_NAME = \"RESOURCE_ID\";\n+    public static final String URL_COLUMN_NAME = \"URL\";\n+    public static final String SAMPLE_TYPE_COLUMN_NAME = \"SAMPLE_TYPE\";\n+    private int numSampleSpecificResourcesAdded = 0;\n+    private int numPatientSpecificResourcesAdded = 0;\n+    private int numStudySpecificResourcesAdded = 0;\n+    private int numEmptyResourcesSkipped = 0;\n+    private int numSamplesProcessed = 0;\n+\n+    private static Properties properties;\n+\n+    private File resourceDataFile;\n+    private CancerStudy cancerStudy;\n+    private ResourceType resourceType;\n+    private boolean relaxed;\n+    private Set<String> patientIds = new HashSet<String>();\n+\n+    public void setFile(CancerStudy cancerStudy, File resourceDataFile, String resourceType, boolean relaxed) {\n+        this.cancerStudy = cancerStudy;\n+        this.resourceDataFile = resourceDataFile;\n+        this.resourceType = ResourceType.valueOf(resourceType);\n+        this.relaxed = relaxed;\n+    }\n+\n+    public void importData() throws Exception {\n+        // if bulkLoading is ever turned off,\n+        // code has to be added to check whether\n+        // a resource data update should be\n+        // perform instead of an insert\n+        MySQLbulkLoader.bulkLoadOn();\n+\n+        if (relaxed) {\n+            MySQLbulkLoader.relaxedModeOn();\n+        }\n+\n+        FileReader reader = new FileReader(resourceDataFile);\n+        BufferedReader buff = new BufferedReader(reader);\n+        List<ResourceDefinition> resources = DaoResourceDefinition.getDatumByStudy(cancerStudy.getInternalId());\n+        String currentLine = buff.readLine();\n+        String[] headerNames = currentLine.split(\"\\t\");\n+        Map<String, Integer> headerIndexMap = makeHeaderIndexMap(headerNames);\n+        \n+        int patientIdIndex = findPatientIdColumn(headerIndexMap);\n+        int sampleIdIndex = findSampleIdColumn(headerIndexMap);\n+        int resourceIdIndex = findResourceIdColumn(headerIndexMap);\n+        int urlIndex = findURLColumn(headerIndexMap);\n+\n+        // validate required columns:\n+        if (resourceIdIndex < 0) {\n+            throw new RuntimeException(\"Aborting owing to failure to find \" + RESOURCE_ID_COLUMN_NAME\n+                    + \" in file. Please check your file format and try again.\");\n+        }\n+        if (urlIndex < 0) {\n+            throw new RuntimeException(\"Aborting owing to failure to find \" + URL_COLUMN_NAME\n+                    + \" in file. Please check your file format and try again.\");\n+        }\n+        if ((resourceType.equals(ResourceType.SAMPLE) || resourceType.equals(ResourceType.PATIENT)) && patientIdIndex < 0) {\n+            // PATIENT_ID is required in both patient and sample file types:\n+            throw new RuntimeException(\"Aborting owing to failure to find \" + PATIENT_ID_COLUMN_NAME\n+                    + \" in file. Please check your file format and try again.\");\n+        }\n+        if (resourceType.equals(ResourceType.SAMPLE) && sampleIdIndex < 0) {\n+            // SAMPLE_ID is required in SAMPLE file type:\n+            throw new RuntimeException(\"Aborting owing to failure to find \" + SAMPLE_ID_COLUMN_NAME\n+                    + \" in file. Please check your file format and try again.\");\n+        }\n+        importData(buff, resources, headerIndexMap);\n+        buff.close();\n+\n+        if (MySQLbulkLoader.isBulkLoad()) {\n+            MySQLbulkLoader.flushAll();\n+            MySQLbulkLoader.relaxedModeOff();\n+        }\n+    }\n+\n+    private void importData(BufferedReader buff, List<ResourceDefinition> resources, Map<String, Integer> headerIndexMap) throws Exception {\n+        String line;\n+        MultiKeyMap resourceMap = new MultiKeyMap();\n+        // create resource_id set\n+        Set<String> patientResourceIdSet = resources\n+                .stream()\n+                .filter(resource -> resource.getResourceType().equals(ResourceType.PATIENT))\n+                .map(resource -> resource.getResourceId())\n+                .collect(Collectors.toSet());\n+        Set<String> sampleResourceIdSet = resources\n+                .stream()\n+                .filter(resource -> resource.getResourceType().equals(ResourceType.SAMPLE))\n+                .map(resource -> resource.getResourceId())\n+                .collect(Collectors.toSet());\n+        Set<String> studyResourceIdSet = resources\n+                .stream()\n+                .filter(resource -> resource.getResourceType().equals(ResourceType.STUDY))\n+                .map(resource -> resource.getResourceId())\n+                .collect(Collectors.toSet());\n+\n+        while ((line = buff.readLine()) != null) {\n+            if (skipLine(line.trim())) {\n+                continue;\n+            }\n+\n+            String[] fieldValues = getFieldValues(line, headerIndexMap);\n+            addDatum(fieldValues, resources, resourceMap, headerIndexMap, patientResourceIdSet, sampleResourceIdSet, studyResourceIdSet);\n+        }\n+    }\n+\n+    private boolean skipLine(String line) {\n+        return (line.isEmpty() || line.substring(0, 1).equals(METADATA_PREFIX));\n+    }\n+\n+    /**\n+     * Takes in the given line and returns the list of field values by splitting the\n+     * line on DELIMITER.\n+     * \n+     * @param line\n+     * @param headerIndexMap\n+     * @return the list of values, one for each column. Value will be \"\" for empty\n+     *         columns.\n+     */\n+    private String[] getFieldValues(String line, Map<String, Integer> headerIndexMap) {\n+        // split on delimiter:\n+        String[] fieldValues = line.split(DELIMITER, -1);\n+\n+        // validate: if number of fields is incorrect, give exception\n+        if (fieldValues.length != headerIndexMap.size()) {\n+            throw new IllegalArgumentException(\"Number of columns in line is not as expected. Expected: \"\n+                    + headerIndexMap.size() + \" columns, found: \" + fieldValues.length + \", for line: \" + line);\n+        }\n+\n+        // now iterate over lines and trim each value:\n+        for (int i = 0; i < fieldValues.length; i++) {\n+            fieldValues[i] = fieldValues[i].trim();\n+        }\n+        return fieldValues;\n+    }\n+\n+    private boolean addDatum(String[] fields, List<ResourceDefinition> resources, MultiKeyMap resourceMap, Map<String, Integer> headerIndexMap, Set<String> patientResourceIdSet, Set<String> sampleResourceIdSet, Set<String> studyResourceIdSet)\n+            throws Exception {\n+        int sampleIdIndex = findSampleIdColumn(headerIndexMap);\n+        String stableSampleId = (sampleIdIndex >= 0) ? fields[sampleIdIndex] : \"\";\n+        stableSampleId = StableIdUtil.getSampleId(stableSampleId);\n+        int patientIdIndex = findPatientIdColumn(headerIndexMap);\n+        String stablePatientId = (patientIdIndex >= 0) ? fields[patientIdIndex] : \"\";\n+        stablePatientId = StableIdUtil.getPatientId(stablePatientId);\n+        int resourceIdIndex = findResourceIdColumn(headerIndexMap);\n+        int urlIndex = findURLColumn(headerIndexMap);\n+        int internalSampleId = -1;\n+        int internalPatientId = -1;\n+\n+        // validate sample and patient for sample or patient attibutes\n+        if (resourceType.equals(ResourceType.SAMPLE) || resourceType.equals(ResourceType.PATIENT)) {\n+            // check if sample is not already added:\n+            Sample sample = DaoSample.getSampleByCancerStudyAndSampleId(cancerStudy.getInternalId(), stableSampleId, false);\n+            if (sample != null) {\n+                // get internal sample id if sample exists\n+                internalSampleId = sample.getInternalId();\n+            } else {\n+                Patient patient = DaoPatient.getPatientByCancerStudyAndPatientId(cancerStudy.getInternalId(),\n+                        stablePatientId);\n+                if (patient != null) {\n+                    // patient exists, get internal id:\n+                    internalPatientId = patient.getInternalId();\n+                } else {\n+                    // add patient:\n+                    internalPatientId = (patientIdIndex >= 0) ? addPatientToDatabase(fields[patientIdIndex]) : -1;\n+                }\n+                // sample is new, so attempt to add to DB\n+                internalSampleId = (stableSampleId.length() > 0) ? addSampleToDatabase(stableSampleId, fields, headerIndexMap)\n+                        : -1;\n+            }\n+\n+            // validate and count:\n+            if (internalSampleId != -1) {\n+                // some minimal validation/fail safe for now: only continue if patientId is same\n+                // as patient id in\n+                // existing sample (can occur in case of this.isSupplementalData or in case of\n+                // parsing bug in addSampleToDatabase):\n+                internalPatientId = DaoPatient\n+                        .getPatientByCancerStudyAndPatientId(cancerStudy.getInternalId(), stablePatientId).getInternalId();\n+                if (internalPatientId != DaoSample.getSampleById(internalSampleId).getInternalPatientId()) {\n+                    throw new RuntimeException(\"Error: Sample \" + stableSampleId\n+                            + \" was previously linked to another patient, and not to \" + stablePatientId);\n+                }\n+                numSamplesProcessed++;\n+            }\n+        }\n+\n+        // if the resource id or url matches one of the missing values, skip this resource:\n+        if ((resourceIdIndex != -1 && MissingValues.has(fields[resourceIdIndex])) || (urlIndex != -1 && MissingValues.has(fields[urlIndex]))) {\n+            numEmptyResourcesSkipped++;\n+        } else {\n+            // if patient_id column exists and resource type is patient\n+            if (getResourceType() == ResourceType.PATIENT && internalPatientId != -1) {\n+                validateAddDatum(internalPatientId, stablePatientId, fields[resourceIdIndex], fields[urlIndex], \n+                        ResourceType.PATIENT, patientResourceIdSet, resourceMap);\n+            } \n+            // if sample_id column exists and resource type is sample\n+            else if (getResourceType() == ResourceType.SAMPLE && internalSampleId != -1) {\n+                validateAddDatum(internalSampleId, stableSampleId, fields[resourceIdIndex], fields[urlIndex], \n+                        ResourceType.SAMPLE, sampleResourceIdSet, resourceMap);\n+            }\n+            // if resource type is study\n+            else if (getResourceType() == ResourceType.STUDY) {\n+                validateAddDatum(cancerStudy.getInternalId(), cancerStudy.getCancerStudyStableId(), fields[resourceIdIndex], fields[urlIndex], \n+                        ResourceType.STUDY, studyResourceIdSet, resourceMap);\n+            }\n+        }\n+        return true;\n+    }\n+\n+    private Map<String, Integer> makeHeaderIndexMap(String[] headerNames) {\n+        Map<String, Integer> headerIndexMap = new HashMap<String, Integer>();\n+        for (int i= 0; i < headerNames.length; i++) {\n+            headerIndexMap.put(headerNames[i], i);\n+        }\n+        return headerIndexMap;\n+    }\n+\n+    private int findPatientIdColumn(Map<String, Integer> headerIndexMap) {\n+        return findColumnIndexInHeaders(PATIENT_ID_COLUMN_NAME, headerIndexMap);\n+    }\n+\n+    private int findSampleIdColumn(Map<String, Integer> headerIndexMap) {\n+        return findColumnIndexInHeaders(SAMPLE_ID_COLUMN_NAME, headerIndexMap);\n+    }\n+\n+    private int findResourceIdColumn(Map<String, Integer> headerIndexMap) {\n+        return findColumnIndexInHeaders(RESOURCE_ID_COLUMN_NAME, headerIndexMap);\n+    }\n+\n+    private int findURLColumn(Map<String, Integer> headerIndexMap) {\n+        return findColumnIndexInHeaders(URL_COLUMN_NAME, headerIndexMap);\n+    }\n+\n+    private int findSampleTypeColumn(Map<String, Integer> headerIndexMap) {\n+        return findColumnIndexInHeaders(SAMPLE_TYPE_COLUMN_NAME, headerIndexMap);\n+    }\n+\n+    private int findColumnIndexInHeaders(String columnHeader, Map<String, Integer> headerIndexMap) {\n+        if (headerIndexMap.containsKey(columnHeader)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7a02f1fe6d7876b81ccca114d9423e745129900e"}, "originalPosition": 261}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ1Nzc4NDk0OnYy", "diffSide": "RIGHT", "path": "core/src/main/java/org/mskcc/cbio/portal/dao/DaoResourceData.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yM1QxNDowNzowN1rOF6G_cw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yM1QxNDowNzowN1rOF6G_cw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjQ3NjI3NQ==", "bodyText": "looks like this method is never used", "url": "https://github.com/cBioPortal/cbioportal/pull/7270#discussion_r396476275", "createdAt": "2020-03-23T14:07:07Z", "author": {"login": "kalletlak"}, "path": "core/src/main/java/org/mskcc/cbio/portal/dao/DaoResourceData.java", "diffHunk": "@@ -0,0 +1,214 @@\n+package org.mskcc.cbio.portal.dao;\n+\n+import org.mskcc.cbio.portal.model.*;\n+\n+import org.apache.commons.lang.StringUtils;\n+\n+import java.sql.*;\n+import java.util.*;\n+\n+/**\n+ * Data Access Object for `resource` tables\n+ */\n+public final class DaoResourceData {\n+\n+    public static final String RESOURCE_SAMPLE_TABLE = \"resource_sample\";\n+    public static final String RESOURCE_PATIENT_TABLE = \"resource_patient\";\n+    public static final String RESOURCE_STUDY_TABLE = \"resource_study\";\n+\n+    private static final String SAMPLE_INSERT = \"INSERT INTO \" + RESOURCE_SAMPLE_TABLE\n+            + \"(`INTERNAL_ID`,`RESOURCE_ID`,`URL` VALUES(?,?,?)\";\n+    private static final String PATIENT_INSERT = \"INSERT INTO \" + RESOURCE_PATIENT_TABLE\n+            + \"(`INTERNAL_ID`,`RESOURCE_ID`,`URL` VALUES(?,?,?)\";\n+    private static final String STUDY_INSERT = \"INSERT INTO \" + RESOURCE_STUDY_TABLE\n+            + \"(`INTERNAL_ID`,`RESOURCE_ID`,`URL` VALUES(?,?,?)\";\n+\n+    private static final Map<String, String> sampleResources = new HashMap<String, String>();\n+    private static final Map<String, String> patientResources = new HashMap<String, String>();\n+    private static final Map<String, String> studyResources = new HashMap<String, String>();\n+\n+    private DaoResourceData() {\n+    }\n+\n+    public static synchronized void reCache() {\n+        clearCache();\n+        cacheResources(RESOURCE_SAMPLE_TABLE, sampleResources);\n+        cacheResources(RESOURCE_PATIENT_TABLE, patientResources);\n+        cacheResources(RESOURCE_STUDY_TABLE, studyResources);\n+    }\n+\n+    private static void clearCache() {\n+        sampleResources.clear();\n+        patientResources.clear();\n+        studyResources.clear();\n+    }\n+\n+    private static void cacheResources(String table, Map<String, String> cache) {\n+        Connection con = null;\n+        PreparedStatement pstmt = null;\n+        ResultSet rs = null;\n+        try {\n+            con = JdbcUtil.getDbConnection(DaoResourceData.class);\n+            pstmt = con.prepareStatement(\"SELECT * FROM \" + table);\n+            rs = pstmt.executeQuery();\n+            while (rs.next()) {\n+                cache.put(rs.getString(\"RESOURCE_ID\"), rs.getString(\"RESOURCE_ID\"));\n+            }\n+        } catch (SQLException e) {\n+            e.printStackTrace();\n+        } finally {\n+            JdbcUtil.closeAll(DaoResourceData.class, con, pstmt, rs);\n+        }\n+    }\n+\n+    public static int addSampleDatum(int internalSampleId, String resourceId, String url) throws DaoException {\n+        sampleResources.put(resourceId, resourceId);\n+        return addDatum(SAMPLE_INSERT, RESOURCE_SAMPLE_TABLE, internalSampleId, resourceId, url);\n+    }\n+\n+    public static int addPatientDatum(int internalPatientId, String resourceId, String url) throws DaoException {\n+        patientResources.put(resourceId, resourceId);\n+        return addDatum(PATIENT_INSERT, RESOURCE_PATIENT_TABLE, internalPatientId, resourceId, url);\n+    }\n+\n+    public static int addStudyDatum(int internalStudyId, String resourceId, String url) throws DaoException {\n+        patientResources.put(resourceId, resourceId);\n+        return addDatum(STUDY_INSERT, RESOURCE_STUDY_TABLE, internalStudyId, resourceId, url);\n+    }\n+\n+    public static int addDatum(String query, String tableName, int internalId, String resourceId, String url)\n+            throws DaoException {\n+        if (MySQLbulkLoader.isBulkLoad()) {\n+            MySQLbulkLoader.getMySQLbulkLoader(tableName).insertRecord(Integer.toString(internalId), resourceId, url);\n+            return 1;\n+        }\n+\n+        Connection con = null;\n+        PreparedStatement pstmt = null;\n+        ResultSet rs = null;\n+        try {\n+            con = JdbcUtil.getDbConnection(DaoResourceData.class);\n+\n+            pstmt = con.prepareStatement(query);\n+            pstmt.setInt(1, internalId);\n+            pstmt.setString(2, resourceId);\n+            pstmt.setString(3, url);\n+            int toReturn = pstmt.executeUpdate();\n+\n+            if (tableName.equals(RESOURCE_PATIENT_TABLE)) {\n+                patientResources.put(resourceId, resourceId);\n+            } else if (tableName.equals(RESOURCE_SAMPLE_TABLE)){\n+                sampleResources.put(resourceId, resourceId);\n+            } else {\n+                studyResources.put(resourceId, resourceId);\n+            }\n+\n+            return toReturn;\n+        } catch (SQLException e) {\n+            throw new DaoException(e);\n+        } finally {\n+            JdbcUtil.closeAll(DaoResourceData.class, con, pstmt, rs);\n+        }\n+    }\n+\n+    public static ResourceBaseData getDatum(String cancerStudyId, String patientId, String resourceId) throws DaoException {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7a02f1fe6d7876b81ccca114d9423e745129900e"}, "originalPosition": 114}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ1ODUzNTY1OnYy", "diffSide": "RIGHT", "path": "core/src/main/java/org/mskcc/cbio/portal/dao/DaoResourceData.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yM1QxNjo1MDoyNFrOF6OkMg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yM1QxNjo1MDoyNFrOF6OkMg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjYwMDM3MA==", "bodyText": "sampleResources, patientResources and studyResources are never used. only data is added or updated. I think all the cache related code can be removed", "url": "https://github.com/cBioPortal/cbioportal/pull/7270#discussion_r396600370", "createdAt": "2020-03-23T16:50:24Z", "author": {"login": "kalletlak"}, "path": "core/src/main/java/org/mskcc/cbio/portal/dao/DaoResourceData.java", "diffHunk": "@@ -0,0 +1,163 @@\n+package org.mskcc.cbio.portal.dao;\n+\n+import org.mskcc.cbio.portal.model.*;\n+import org.apache.commons.lang.StringUtils;\n+import java.sql.*;\n+import java.util.*;\n+\n+/**\n+ * Data Access Object for `resource` tables\n+ */\n+public final class DaoResourceData {\n+\n+    public static final String RESOURCE_SAMPLE_TABLE = \"resource_sample\";\n+    public static final String RESOURCE_PATIENT_TABLE = \"resource_patient\";\n+    public static final String RESOURCE_STUDY_TABLE = \"resource_study\";\n+\n+    private static final String SAMPLE_INSERT = \"INSERT INTO \" + RESOURCE_SAMPLE_TABLE\n+            + \"(`INTERNAL_ID`,`RESOURCE_ID`,`URL` VALUES(?,?,?)\";\n+    private static final String PATIENT_INSERT = \"INSERT INTO \" + RESOURCE_PATIENT_TABLE\n+            + \"(`INTERNAL_ID`,`RESOURCE_ID`,`URL` VALUES(?,?,?)\";\n+    private static final String STUDY_INSERT = \"INSERT INTO \" + RESOURCE_STUDY_TABLE\n+            + \"(`INTERNAL_ID`,`RESOURCE_ID`,`URL` VALUES(?,?,?)\";\n+\n+    private static final Map<String, String> sampleResources = new HashMap<String, String>();\n+    private static final Map<String, String> patientResources = new HashMap<String, String>();\n+    private static final Map<String, String> studyResources = new HashMap<String, String>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4e724ff759a02f25a33335b5d8aab57376718488"}, "originalPosition": 26}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ1ODU2MTUyOnYy", "diffSide": "RIGHT", "path": "core/src/main/java/org/mskcc/cbio/portal/scripts/ImportResourceData.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yM1QxNjo1Njo0MVrOF6O1Ow==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yM1QxNjo1Njo0MVrOF6O1Ow==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjYwNDczMQ==", "bodyText": "this method is executed when patient is null(i.e from line 185). any specific reason for fetching patient again?", "url": "https://github.com/cBioPortal/cbioportal/pull/7270#discussion_r396604731", "createdAt": "2020-03-23T16:56:41Z", "author": {"login": "kalletlak"}, "path": "core/src/main/java/org/mskcc/cbio/portal/scripts/ImportResourceData.java", "diffHunk": "@@ -0,0 +1,555 @@\n+package org.mskcc.cbio.portal.scripts;\n+\n+import org.mskcc.cbio.portal.dao.*;\n+import org.mskcc.cbio.portal.model.*;\n+import org.mskcc.cbio.portal.util.*;\n+\n+import java.io.*;\n+import joptsimple.*;\n+import java.util.*;\n+import java.util.regex.*;\n+import java.util.stream.Collectors;\n+\n+import org.apache.commons.collections.map.MultiKeyMap;\n+import org.cbioportal.model.ResourceType;\n+\n+public class ImportResourceData extends ConsoleRunnable {\n+\n+    public static final String DELIMITER = \"\\t\";\n+    public static final String METADATA_PREFIX = \"#\";\n+    public static final String SAMPLE_ID_COLUMN_NAME = \"SAMPLE_ID\";\n+    public static final String PATIENT_ID_COLUMN_NAME = \"PATIENT_ID\";\n+    public static final String RESOURCE_ID_COLUMN_NAME = \"RESOURCE_ID\";\n+    public static final String URL_COLUMN_NAME = \"URL\";\n+    public static final String SAMPLE_TYPE_COLUMN_NAME = \"SAMPLE_TYPE\";\n+    private int numSampleSpecificResourcesAdded = 0;\n+    private int numPatientSpecificResourcesAdded = 0;\n+    private int numStudySpecificResourcesAdded = 0;\n+    private int numEmptyResourcesSkipped = 0;\n+    private int numSamplesProcessed = 0;\n+\n+    private static Properties properties;\n+\n+    private File resourceDataFile;\n+    private CancerStudy cancerStudy;\n+    private ResourceType resourceType;\n+    private boolean relaxed;\n+    private Set<String> patientIds = new HashSet<String>();\n+\n+    public void setFile(CancerStudy cancerStudy, File resourceDataFile, String resourceType, boolean relaxed) {\n+        this.cancerStudy = cancerStudy;\n+        this.resourceDataFile = resourceDataFile;\n+        this.resourceType = ResourceType.valueOf(resourceType);\n+        this.relaxed = relaxed;\n+    }\n+\n+    public void importData() throws Exception {\n+        // if bulkLoading is ever turned off,\n+        // code has to be added to check whether\n+        // a resource data update should be\n+        // perform instead of an insert\n+        MySQLbulkLoader.bulkLoadOn();\n+\n+        if (relaxed) {\n+            MySQLbulkLoader.relaxedModeOn();\n+        }\n+\n+        FileReader reader = new FileReader(resourceDataFile);\n+        BufferedReader buff = new BufferedReader(reader);\n+        List<ResourceDefinition> resources = DaoResourceDefinition.getDatumByStudy(cancerStudy.getInternalId());\n+        String currentLine = buff.readLine();\n+        String[] headerNames = currentLine.split(\"\\t\");\n+        Map<String, Integer> headerIndexMap = makeHeaderIndexMap(headerNames);\n+        \n+        int patientIdIndex = findPatientIdColumn(headerIndexMap);\n+        int sampleIdIndex = findSampleIdColumn(headerIndexMap);\n+        int resourceIdIndex = findResourceIdColumn(headerIndexMap);\n+        int urlIndex = findURLColumn(headerIndexMap);\n+\n+        // validate required columns:\n+        if (resourceIdIndex < 0) {\n+            throw new RuntimeException(\"Aborting owing to failure to find \" + RESOURCE_ID_COLUMN_NAME\n+                    + \" in file. Please check your file format and try again.\");\n+        }\n+        if (urlIndex < 0) {\n+            throw new RuntimeException(\"Aborting owing to failure to find \" + URL_COLUMN_NAME\n+                    + \" in file. Please check your file format and try again.\");\n+        }\n+        if ((resourceType.equals(ResourceType.SAMPLE) || resourceType.equals(ResourceType.PATIENT)) && patientIdIndex < 0) {\n+            // PATIENT_ID is required in both patient and sample file types:\n+            throw new RuntimeException(\"Aborting owing to failure to find \" + PATIENT_ID_COLUMN_NAME\n+                    + \" in file. Please check your file format and try again.\");\n+        }\n+        if (resourceType.equals(ResourceType.SAMPLE) && sampleIdIndex < 0) {\n+            // SAMPLE_ID is required in SAMPLE file type:\n+            throw new RuntimeException(\"Aborting owing to failure to find \" + SAMPLE_ID_COLUMN_NAME\n+                    + \" in file. Please check your file format and try again.\");\n+        }\n+        importData(buff, resources, headerIndexMap);\n+        buff.close();\n+\n+        if (MySQLbulkLoader.isBulkLoad()) {\n+            MySQLbulkLoader.flushAll();\n+            MySQLbulkLoader.relaxedModeOff();\n+        }\n+    }\n+\n+    private void importData(BufferedReader buff, List<ResourceDefinition> resources, Map<String, Integer> headerIndexMap) throws Exception {\n+        String line;\n+        MultiKeyMap resourceMap = new MultiKeyMap();\n+        // create resource_id set\n+        Set<String> patientResourceIdSet = resources\n+                .stream()\n+                .filter(resource -> resource.getResourceType().equals(ResourceType.PATIENT))\n+                .map(resource -> resource.getResourceId())\n+                .collect(Collectors.toSet());\n+        Set<String> sampleResourceIdSet = resources\n+                .stream()\n+                .filter(resource -> resource.getResourceType().equals(ResourceType.SAMPLE))\n+                .map(resource -> resource.getResourceId())\n+                .collect(Collectors.toSet());\n+        Set<String> studyResourceIdSet = resources\n+                .stream()\n+                .filter(resource -> resource.getResourceType().equals(ResourceType.STUDY))\n+                .map(resource -> resource.getResourceId())\n+                .collect(Collectors.toSet());\n+\n+        while ((line = buff.readLine()) != null) {\n+            if (skipLine(line.trim())) {\n+                continue;\n+            }\n+\n+            String[] fieldValues = getFieldValues(line, headerIndexMap);\n+            addDatum(fieldValues, resources, resourceMap, headerIndexMap, patientResourceIdSet, sampleResourceIdSet, studyResourceIdSet);\n+        }\n+    }\n+\n+    private boolean skipLine(String line) {\n+        return (line.isEmpty() || line.substring(0, 1).equals(METADATA_PREFIX));\n+    }\n+\n+    /**\n+     * Takes in the given line and returns the list of field values by splitting the\n+     * line on DELIMITER.\n+     * \n+     * @param line\n+     * @param headerIndexMap\n+     * @return the list of values, one for each column. Value will be \"\" for empty\n+     *         columns.\n+     */\n+    private String[] getFieldValues(String line, Map<String, Integer> headerIndexMap) {\n+        // split on delimiter:\n+        String[] fieldValues = line.split(DELIMITER, -1);\n+\n+        // validate: if number of fields is incorrect, give exception\n+        if (fieldValues.length != headerIndexMap.size()) {\n+            throw new IllegalArgumentException(\"Number of columns in line is not as expected. Expected: \"\n+                    + headerIndexMap.size() + \" columns, found: \" + fieldValues.length + \", for line: \" + line);\n+        }\n+\n+        // now iterate over lines and trim each value:\n+        for (int i = 0; i < fieldValues.length; i++) {\n+            fieldValues[i] = fieldValues[i].trim();\n+        }\n+        return fieldValues;\n+    }\n+\n+    private boolean addDatum(String[] fields, List<ResourceDefinition> resources, MultiKeyMap resourceMap, Map<String, Integer> headerIndexMap, Set<String> patientResourceIdSet, Set<String> sampleResourceIdSet, Set<String> studyResourceIdSet)\n+            throws Exception {\n+        int sampleIdIndex = findSampleIdColumn(headerIndexMap);\n+        String stableSampleId = (sampleIdIndex >= 0) ? fields[sampleIdIndex] : \"\";\n+        stableSampleId = StableIdUtil.getSampleId(stableSampleId);\n+        int patientIdIndex = findPatientIdColumn(headerIndexMap);\n+        String stablePatientId = (patientIdIndex >= 0) ? fields[patientIdIndex] : \"\";\n+        stablePatientId = StableIdUtil.getPatientId(stablePatientId);\n+        int resourceIdIndex = findResourceIdColumn(headerIndexMap);\n+        int urlIndex = findURLColumn(headerIndexMap);\n+        int internalSampleId = -1;\n+        int internalPatientId = -1;\n+\n+        // validate sample and patient for sample or patient attibutes\n+        if (resourceType.equals(ResourceType.SAMPLE) || resourceType.equals(ResourceType.PATIENT)) {\n+            // check if sample is not already added:\n+            Sample sample = DaoSample.getSampleByCancerStudyAndSampleId(cancerStudy.getInternalId(), stableSampleId, false);\n+            if (sample != null) {\n+                // get internal sample id if sample exists\n+                internalSampleId = sample.getInternalId();\n+            } else {\n+                Patient patient = DaoPatient.getPatientByCancerStudyAndPatientId(cancerStudy.getInternalId(),\n+                        stablePatientId);\n+                if (patient != null) {\n+                    // patient exists, get internal id:\n+                    internalPatientId = patient.getInternalId();\n+                } else {\n+                    // add patient:\n+                    internalPatientId = (patientIdIndex >= 0) ? addPatientToDatabase(fields[patientIdIndex]) : -1;\n+                }\n+                // sample is new, so attempt to add to DB\n+                internalSampleId = (stableSampleId.length() > 0) ? addSampleToDatabase(stableSampleId, fields, headerIndexMap)\n+                        : -1;\n+            }\n+\n+            // validate and count:\n+            if (internalSampleId != -1) {\n+                // some minimal validation/fail safe for now: only continue if patientId is same\n+                // as patient id in\n+                // existing sample (can occur in case of this.isSupplementalData or in case of\n+                // parsing bug in addSampleToDatabase):\n+                internalPatientId = DaoPatient\n+                        .getPatientByCancerStudyAndPatientId(cancerStudy.getInternalId(), stablePatientId).getInternalId();\n+                if (internalPatientId != DaoSample.getSampleById(internalSampleId).getInternalPatientId()) {\n+                    throw new RuntimeException(\"Error: Sample \" + stableSampleId\n+                            + \" was previously linked to another patient, and not to \" + stablePatientId);\n+                }\n+                numSamplesProcessed++;\n+            }\n+        }\n+\n+        // if the resource id or url matches one of the missing values, skip this resource:\n+        if ((resourceIdIndex != -1 && MissingValues.has(fields[resourceIdIndex])) || (urlIndex != -1 && MissingValues.has(fields[urlIndex]))) {\n+            numEmptyResourcesSkipped++;\n+        } else {\n+            // if patient_id column exists and resource type is patient\n+            if (getResourceType() == ResourceType.PATIENT && internalPatientId != -1) {\n+                validateAddDatum(internalPatientId, stablePatientId, fields[resourceIdIndex], fields[urlIndex], \n+                        ResourceType.PATIENT, patientResourceIdSet, resourceMap);\n+            } \n+            // if sample_id column exists and resource type is sample\n+            else if (getResourceType() == ResourceType.SAMPLE && internalSampleId != -1) {\n+                validateAddDatum(internalSampleId, stableSampleId, fields[resourceIdIndex], fields[urlIndex], \n+                        ResourceType.SAMPLE, sampleResourceIdSet, resourceMap);\n+            }\n+            // if resource type is study\n+            else if (getResourceType() == ResourceType.STUDY) {\n+                validateAddDatum(cancerStudy.getInternalId(), cancerStudy.getCancerStudyStableId(), fields[resourceIdIndex], fields[urlIndex], \n+                        ResourceType.STUDY, studyResourceIdSet, resourceMap);\n+            }\n+        }\n+        return true;\n+    }\n+\n+    private Map<String, Integer> makeHeaderIndexMap(String[] headerNames) {\n+        Map<String, Integer> headerIndexMap = new HashMap<String, Integer>();\n+        for (int i= 0; i < headerNames.length; i++) {\n+            headerIndexMap.put(headerNames[i], i);\n+        }\n+        return headerIndexMap;\n+    }\n+\n+    private int findPatientIdColumn(Map<String, Integer> headerIndexMap) {\n+        return findColumnIndexInHeaders(PATIENT_ID_COLUMN_NAME, headerIndexMap);\n+    }\n+\n+    private int findSampleIdColumn(Map<String, Integer> headerIndexMap) {\n+        return findColumnIndexInHeaders(SAMPLE_ID_COLUMN_NAME, headerIndexMap);\n+    }\n+\n+    private int findResourceIdColumn(Map<String, Integer> headerIndexMap) {\n+        return findColumnIndexInHeaders(RESOURCE_ID_COLUMN_NAME, headerIndexMap);\n+    }\n+\n+    private int findURLColumn(Map<String, Integer> headerIndexMap) {\n+        return findColumnIndexInHeaders(URL_COLUMN_NAME, headerIndexMap);\n+    }\n+\n+    private int findSampleTypeColumn(Map<String, Integer> headerIndexMap) {\n+        return findColumnIndexInHeaders(SAMPLE_TYPE_COLUMN_NAME, headerIndexMap);\n+    }\n+\n+    private int findColumnIndexInHeaders(String columnHeader, Map<String, Integer> headerIndexMap) {\n+        return headerIndexMap.getOrDefault(columnHeader, -1);\n+    }\n+\n+    private int addPatientToDatabase(String patientId) throws Exception {\n+        int internalPatientId = -1;\n+        if (validPatientId(patientId)) {\n+            Patient patient = DaoPatient.getPatientByCancerStudyAndPatientId(cancerStudy.getInternalId(), patientId);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4e724ff759a02f25a33335b5d8aab57376718488"}, "originalPosition": 266}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ1ODYxMzM0OnYy", "diffSide": "RIGHT", "path": "core/src/main/java/org/mskcc/cbio/portal/scripts/ImportResourceData.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yM1QxNzowODo1N1rOF6PW8A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yM1QxOTo0MDo1NVrOF6VQkQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjYxMzM2MA==", "bodyText": "Are we going to have sampleType(SAMPLE_TYPE column) in data file?", "url": "https://github.com/cBioPortal/cbioportal/pull/7270#discussion_r396613360", "createdAt": "2020-03-23T17:08:57Z", "author": {"login": "kalletlak"}, "path": "core/src/main/java/org/mskcc/cbio/portal/scripts/ImportResourceData.java", "diffHunk": "@@ -0,0 +1,555 @@\n+package org.mskcc.cbio.portal.scripts;\n+\n+import org.mskcc.cbio.portal.dao.*;\n+import org.mskcc.cbio.portal.model.*;\n+import org.mskcc.cbio.portal.util.*;\n+\n+import java.io.*;\n+import joptsimple.*;\n+import java.util.*;\n+import java.util.regex.*;\n+import java.util.stream.Collectors;\n+\n+import org.apache.commons.collections.map.MultiKeyMap;\n+import org.cbioportal.model.ResourceType;\n+\n+public class ImportResourceData extends ConsoleRunnable {\n+\n+    public static final String DELIMITER = \"\\t\";\n+    public static final String METADATA_PREFIX = \"#\";\n+    public static final String SAMPLE_ID_COLUMN_NAME = \"SAMPLE_ID\";\n+    public static final String PATIENT_ID_COLUMN_NAME = \"PATIENT_ID\";\n+    public static final String RESOURCE_ID_COLUMN_NAME = \"RESOURCE_ID\";\n+    public static final String URL_COLUMN_NAME = \"URL\";\n+    public static final String SAMPLE_TYPE_COLUMN_NAME = \"SAMPLE_TYPE\";\n+    private int numSampleSpecificResourcesAdded = 0;\n+    private int numPatientSpecificResourcesAdded = 0;\n+    private int numStudySpecificResourcesAdded = 0;\n+    private int numEmptyResourcesSkipped = 0;\n+    private int numSamplesProcessed = 0;\n+\n+    private static Properties properties;\n+\n+    private File resourceDataFile;\n+    private CancerStudy cancerStudy;\n+    private ResourceType resourceType;\n+    private boolean relaxed;\n+    private Set<String> patientIds = new HashSet<String>();\n+\n+    public void setFile(CancerStudy cancerStudy, File resourceDataFile, String resourceType, boolean relaxed) {\n+        this.cancerStudy = cancerStudy;\n+        this.resourceDataFile = resourceDataFile;\n+        this.resourceType = ResourceType.valueOf(resourceType);\n+        this.relaxed = relaxed;\n+    }\n+\n+    public void importData() throws Exception {\n+        // if bulkLoading is ever turned off,\n+        // code has to be added to check whether\n+        // a resource data update should be\n+        // perform instead of an insert\n+        MySQLbulkLoader.bulkLoadOn();\n+\n+        if (relaxed) {\n+            MySQLbulkLoader.relaxedModeOn();\n+        }\n+\n+        FileReader reader = new FileReader(resourceDataFile);\n+        BufferedReader buff = new BufferedReader(reader);\n+        List<ResourceDefinition> resources = DaoResourceDefinition.getDatumByStudy(cancerStudy.getInternalId());\n+        String currentLine = buff.readLine();\n+        String[] headerNames = currentLine.split(\"\\t\");\n+        Map<String, Integer> headerIndexMap = makeHeaderIndexMap(headerNames);\n+        \n+        int patientIdIndex = findPatientIdColumn(headerIndexMap);\n+        int sampleIdIndex = findSampleIdColumn(headerIndexMap);\n+        int resourceIdIndex = findResourceIdColumn(headerIndexMap);\n+        int urlIndex = findURLColumn(headerIndexMap);\n+\n+        // validate required columns:\n+        if (resourceIdIndex < 0) {\n+            throw new RuntimeException(\"Aborting owing to failure to find \" + RESOURCE_ID_COLUMN_NAME\n+                    + \" in file. Please check your file format and try again.\");\n+        }\n+        if (urlIndex < 0) {\n+            throw new RuntimeException(\"Aborting owing to failure to find \" + URL_COLUMN_NAME\n+                    + \" in file. Please check your file format and try again.\");\n+        }\n+        if ((resourceType.equals(ResourceType.SAMPLE) || resourceType.equals(ResourceType.PATIENT)) && patientIdIndex < 0) {\n+            // PATIENT_ID is required in both patient and sample file types:\n+            throw new RuntimeException(\"Aborting owing to failure to find \" + PATIENT_ID_COLUMN_NAME\n+                    + \" in file. Please check your file format and try again.\");\n+        }\n+        if (resourceType.equals(ResourceType.SAMPLE) && sampleIdIndex < 0) {\n+            // SAMPLE_ID is required in SAMPLE file type:\n+            throw new RuntimeException(\"Aborting owing to failure to find \" + SAMPLE_ID_COLUMN_NAME\n+                    + \" in file. Please check your file format and try again.\");\n+        }\n+        importData(buff, resources, headerIndexMap);\n+        buff.close();\n+\n+        if (MySQLbulkLoader.isBulkLoad()) {\n+            MySQLbulkLoader.flushAll();\n+            MySQLbulkLoader.relaxedModeOff();\n+        }\n+    }\n+\n+    private void importData(BufferedReader buff, List<ResourceDefinition> resources, Map<String, Integer> headerIndexMap) throws Exception {\n+        String line;\n+        MultiKeyMap resourceMap = new MultiKeyMap();\n+        // create resource_id set\n+        Set<String> patientResourceIdSet = resources\n+                .stream()\n+                .filter(resource -> resource.getResourceType().equals(ResourceType.PATIENT))\n+                .map(resource -> resource.getResourceId())\n+                .collect(Collectors.toSet());\n+        Set<String> sampleResourceIdSet = resources\n+                .stream()\n+                .filter(resource -> resource.getResourceType().equals(ResourceType.SAMPLE))\n+                .map(resource -> resource.getResourceId())\n+                .collect(Collectors.toSet());\n+        Set<String> studyResourceIdSet = resources\n+                .stream()\n+                .filter(resource -> resource.getResourceType().equals(ResourceType.STUDY))\n+                .map(resource -> resource.getResourceId())\n+                .collect(Collectors.toSet());\n+\n+        while ((line = buff.readLine()) != null) {\n+            if (skipLine(line.trim())) {\n+                continue;\n+            }\n+\n+            String[] fieldValues = getFieldValues(line, headerIndexMap);\n+            addDatum(fieldValues, resources, resourceMap, headerIndexMap, patientResourceIdSet, sampleResourceIdSet, studyResourceIdSet);\n+        }\n+    }\n+\n+    private boolean skipLine(String line) {\n+        return (line.isEmpty() || line.substring(0, 1).equals(METADATA_PREFIX));\n+    }\n+\n+    /**\n+     * Takes in the given line and returns the list of field values by splitting the\n+     * line on DELIMITER.\n+     * \n+     * @param line\n+     * @param headerIndexMap\n+     * @return the list of values, one for each column. Value will be \"\" for empty\n+     *         columns.\n+     */\n+    private String[] getFieldValues(String line, Map<String, Integer> headerIndexMap) {\n+        // split on delimiter:\n+        String[] fieldValues = line.split(DELIMITER, -1);\n+\n+        // validate: if number of fields is incorrect, give exception\n+        if (fieldValues.length != headerIndexMap.size()) {\n+            throw new IllegalArgumentException(\"Number of columns in line is not as expected. Expected: \"\n+                    + headerIndexMap.size() + \" columns, found: \" + fieldValues.length + \", for line: \" + line);\n+        }\n+\n+        // now iterate over lines and trim each value:\n+        for (int i = 0; i < fieldValues.length; i++) {\n+            fieldValues[i] = fieldValues[i].trim();\n+        }\n+        return fieldValues;\n+    }\n+\n+    private boolean addDatum(String[] fields, List<ResourceDefinition> resources, MultiKeyMap resourceMap, Map<String, Integer> headerIndexMap, Set<String> patientResourceIdSet, Set<String> sampleResourceIdSet, Set<String> studyResourceIdSet)\n+            throws Exception {\n+        int sampleIdIndex = findSampleIdColumn(headerIndexMap);\n+        String stableSampleId = (sampleIdIndex >= 0) ? fields[sampleIdIndex] : \"\";\n+        stableSampleId = StableIdUtil.getSampleId(stableSampleId);\n+        int patientIdIndex = findPatientIdColumn(headerIndexMap);\n+        String stablePatientId = (patientIdIndex >= 0) ? fields[patientIdIndex] : \"\";\n+        stablePatientId = StableIdUtil.getPatientId(stablePatientId);\n+        int resourceIdIndex = findResourceIdColumn(headerIndexMap);\n+        int urlIndex = findURLColumn(headerIndexMap);\n+        int internalSampleId = -1;\n+        int internalPatientId = -1;\n+\n+        // validate sample and patient for sample or patient attibutes\n+        if (resourceType.equals(ResourceType.SAMPLE) || resourceType.equals(ResourceType.PATIENT)) {\n+            // check if sample is not already added:\n+            Sample sample = DaoSample.getSampleByCancerStudyAndSampleId(cancerStudy.getInternalId(), stableSampleId, false);\n+            if (sample != null) {\n+                // get internal sample id if sample exists\n+                internalSampleId = sample.getInternalId();\n+            } else {\n+                Patient patient = DaoPatient.getPatientByCancerStudyAndPatientId(cancerStudy.getInternalId(),\n+                        stablePatientId);\n+                if (patient != null) {\n+                    // patient exists, get internal id:\n+                    internalPatientId = patient.getInternalId();\n+                } else {\n+                    // add patient:\n+                    internalPatientId = (patientIdIndex >= 0) ? addPatientToDatabase(fields[patientIdIndex]) : -1;\n+                }\n+                // sample is new, so attempt to add to DB\n+                internalSampleId = (stableSampleId.length() > 0) ? addSampleToDatabase(stableSampleId, fields, headerIndexMap)\n+                        : -1;\n+            }\n+\n+            // validate and count:\n+            if (internalSampleId != -1) {\n+                // some minimal validation/fail safe for now: only continue if patientId is same\n+                // as patient id in\n+                // existing sample (can occur in case of this.isSupplementalData or in case of\n+                // parsing bug in addSampleToDatabase):\n+                internalPatientId = DaoPatient\n+                        .getPatientByCancerStudyAndPatientId(cancerStudy.getInternalId(), stablePatientId).getInternalId();\n+                if (internalPatientId != DaoSample.getSampleById(internalSampleId).getInternalPatientId()) {\n+                    throw new RuntimeException(\"Error: Sample \" + stableSampleId\n+                            + \" was previously linked to another patient, and not to \" + stablePatientId);\n+                }\n+                numSamplesProcessed++;\n+            }\n+        }\n+\n+        // if the resource id or url matches one of the missing values, skip this resource:\n+        if ((resourceIdIndex != -1 && MissingValues.has(fields[resourceIdIndex])) || (urlIndex != -1 && MissingValues.has(fields[urlIndex]))) {\n+            numEmptyResourcesSkipped++;\n+        } else {\n+            // if patient_id column exists and resource type is patient\n+            if (getResourceType() == ResourceType.PATIENT && internalPatientId != -1) {\n+                validateAddDatum(internalPatientId, stablePatientId, fields[resourceIdIndex], fields[urlIndex], \n+                        ResourceType.PATIENT, patientResourceIdSet, resourceMap);\n+            } \n+            // if sample_id column exists and resource type is sample\n+            else if (getResourceType() == ResourceType.SAMPLE && internalSampleId != -1) {\n+                validateAddDatum(internalSampleId, stableSampleId, fields[resourceIdIndex], fields[urlIndex], \n+                        ResourceType.SAMPLE, sampleResourceIdSet, resourceMap);\n+            }\n+            // if resource type is study\n+            else if (getResourceType() == ResourceType.STUDY) {\n+                validateAddDatum(cancerStudy.getInternalId(), cancerStudy.getCancerStudyStableId(), fields[resourceIdIndex], fields[urlIndex], \n+                        ResourceType.STUDY, studyResourceIdSet, resourceMap);\n+            }\n+        }\n+        return true;\n+    }\n+\n+    private Map<String, Integer> makeHeaderIndexMap(String[] headerNames) {\n+        Map<String, Integer> headerIndexMap = new HashMap<String, Integer>();\n+        for (int i= 0; i < headerNames.length; i++) {\n+            headerIndexMap.put(headerNames[i], i);\n+        }\n+        return headerIndexMap;\n+    }\n+\n+    private int findPatientIdColumn(Map<String, Integer> headerIndexMap) {\n+        return findColumnIndexInHeaders(PATIENT_ID_COLUMN_NAME, headerIndexMap);\n+    }\n+\n+    private int findSampleIdColumn(Map<String, Integer> headerIndexMap) {\n+        return findColumnIndexInHeaders(SAMPLE_ID_COLUMN_NAME, headerIndexMap);\n+    }\n+\n+    private int findResourceIdColumn(Map<String, Integer> headerIndexMap) {\n+        return findColumnIndexInHeaders(RESOURCE_ID_COLUMN_NAME, headerIndexMap);\n+    }\n+\n+    private int findURLColumn(Map<String, Integer> headerIndexMap) {\n+        return findColumnIndexInHeaders(URL_COLUMN_NAME, headerIndexMap);\n+    }\n+\n+    private int findSampleTypeColumn(Map<String, Integer> headerIndexMap) {\n+        return findColumnIndexInHeaders(SAMPLE_TYPE_COLUMN_NAME, headerIndexMap);\n+    }\n+\n+    private int findColumnIndexInHeaders(String columnHeader, Map<String, Integer> headerIndexMap) {\n+        return headerIndexMap.getOrDefault(columnHeader, -1);\n+    }\n+\n+    private int addPatientToDatabase(String patientId) throws Exception {\n+        int internalPatientId = -1;\n+        if (validPatientId(patientId)) {\n+            Patient patient = DaoPatient.getPatientByCancerStudyAndPatientId(cancerStudy.getInternalId(), patientId);\n+            // other validations:\n+            // in case of PATIENT data import, there are some special checks:\n+            if (getResourceType() == ResourceType.PATIENT) {\n+                // if resource data is already there, then something has gone wrong (e.g.\n+                // patient is duplicated in file), abort:\n+                if (patient != null\n+                        && DaoResourceData.getDataByPatientId(cancerStudy.getInternalId(), patientId).size() > 0) {\n+                    throw new RuntimeException(\n+                            \"Something has gone wrong. Patient \" + patientId + \" already has resource data loaded.\");\n+                }\n+                // if patient is duplicated, abort as well in this case:\n+                if (!patientIds.add(patientId)) {\n+                    throw new RuntimeException(\"Error. Patient \" + patientId + \" found to be duplicated in your file.\");\n+                }\n+            }\n+\n+            if (patient != null) {\n+                // in all cases (SAMPLE, PATIENT, or STUDY) this can be expected, so\n+                // just fetch it:\n+                internalPatientId = patient.getInternalId();\n+            } else {\n+                // in case of PATIENT data import and patient == null :\n+                if (getResourceType() == ResourceType.PATIENT) {\n+                    // not finding the patient it unexpected (as SAMPLE data import should always\n+                    // precede it), but\n+                    // can happen when this patient does not have any samples for example. In any\n+                    // case, warn about it:\n+                    ProgressMonitor.logWarning(\"Patient \" + patientId\n+                            + \" being added for the first time. Apparently this patient was not in the samples file, or the samples file is not yet loaded (should be loaded before this one)\");\n+                }\n+\n+                patient = new Patient(cancerStudy, patientId);\n+                internalPatientId = DaoPatient.addPatient(patient);\n+            }\n+        }\n+        return internalPatientId;\n+    }\n+\n+    private int addSampleToDatabase(String sampleId, String[] fields, Map<String, Integer> headerIndexMap)\n+            throws Exception {\n+        int sampleTypeIndex = findSampleTypeColumn(headerIndexMap);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4e724ff759a02f25a33335b5d8aab57376718488"}, "originalPosition": 307}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjcxMDAzMw==", "bodyText": "Yes, IMO, if someone introduces a new sample in the resource data file, SAMPLE_TYPE can be an optional column in the data file.", "url": "https://github.com/cBioPortal/cbioportal/pull/7270#discussion_r396710033", "createdAt": "2020-03-23T19:40:55Z", "author": {"login": "dippindots"}, "path": "core/src/main/java/org/mskcc/cbio/portal/scripts/ImportResourceData.java", "diffHunk": "@@ -0,0 +1,555 @@\n+package org.mskcc.cbio.portal.scripts;\n+\n+import org.mskcc.cbio.portal.dao.*;\n+import org.mskcc.cbio.portal.model.*;\n+import org.mskcc.cbio.portal.util.*;\n+\n+import java.io.*;\n+import joptsimple.*;\n+import java.util.*;\n+import java.util.regex.*;\n+import java.util.stream.Collectors;\n+\n+import org.apache.commons.collections.map.MultiKeyMap;\n+import org.cbioportal.model.ResourceType;\n+\n+public class ImportResourceData extends ConsoleRunnable {\n+\n+    public static final String DELIMITER = \"\\t\";\n+    public static final String METADATA_PREFIX = \"#\";\n+    public static final String SAMPLE_ID_COLUMN_NAME = \"SAMPLE_ID\";\n+    public static final String PATIENT_ID_COLUMN_NAME = \"PATIENT_ID\";\n+    public static final String RESOURCE_ID_COLUMN_NAME = \"RESOURCE_ID\";\n+    public static final String URL_COLUMN_NAME = \"URL\";\n+    public static final String SAMPLE_TYPE_COLUMN_NAME = \"SAMPLE_TYPE\";\n+    private int numSampleSpecificResourcesAdded = 0;\n+    private int numPatientSpecificResourcesAdded = 0;\n+    private int numStudySpecificResourcesAdded = 0;\n+    private int numEmptyResourcesSkipped = 0;\n+    private int numSamplesProcessed = 0;\n+\n+    private static Properties properties;\n+\n+    private File resourceDataFile;\n+    private CancerStudy cancerStudy;\n+    private ResourceType resourceType;\n+    private boolean relaxed;\n+    private Set<String> patientIds = new HashSet<String>();\n+\n+    public void setFile(CancerStudy cancerStudy, File resourceDataFile, String resourceType, boolean relaxed) {\n+        this.cancerStudy = cancerStudy;\n+        this.resourceDataFile = resourceDataFile;\n+        this.resourceType = ResourceType.valueOf(resourceType);\n+        this.relaxed = relaxed;\n+    }\n+\n+    public void importData() throws Exception {\n+        // if bulkLoading is ever turned off,\n+        // code has to be added to check whether\n+        // a resource data update should be\n+        // perform instead of an insert\n+        MySQLbulkLoader.bulkLoadOn();\n+\n+        if (relaxed) {\n+            MySQLbulkLoader.relaxedModeOn();\n+        }\n+\n+        FileReader reader = new FileReader(resourceDataFile);\n+        BufferedReader buff = new BufferedReader(reader);\n+        List<ResourceDefinition> resources = DaoResourceDefinition.getDatumByStudy(cancerStudy.getInternalId());\n+        String currentLine = buff.readLine();\n+        String[] headerNames = currentLine.split(\"\\t\");\n+        Map<String, Integer> headerIndexMap = makeHeaderIndexMap(headerNames);\n+        \n+        int patientIdIndex = findPatientIdColumn(headerIndexMap);\n+        int sampleIdIndex = findSampleIdColumn(headerIndexMap);\n+        int resourceIdIndex = findResourceIdColumn(headerIndexMap);\n+        int urlIndex = findURLColumn(headerIndexMap);\n+\n+        // validate required columns:\n+        if (resourceIdIndex < 0) {\n+            throw new RuntimeException(\"Aborting owing to failure to find \" + RESOURCE_ID_COLUMN_NAME\n+                    + \" in file. Please check your file format and try again.\");\n+        }\n+        if (urlIndex < 0) {\n+            throw new RuntimeException(\"Aborting owing to failure to find \" + URL_COLUMN_NAME\n+                    + \" in file. Please check your file format and try again.\");\n+        }\n+        if ((resourceType.equals(ResourceType.SAMPLE) || resourceType.equals(ResourceType.PATIENT)) && patientIdIndex < 0) {\n+            // PATIENT_ID is required in both patient and sample file types:\n+            throw new RuntimeException(\"Aborting owing to failure to find \" + PATIENT_ID_COLUMN_NAME\n+                    + \" in file. Please check your file format and try again.\");\n+        }\n+        if (resourceType.equals(ResourceType.SAMPLE) && sampleIdIndex < 0) {\n+            // SAMPLE_ID is required in SAMPLE file type:\n+            throw new RuntimeException(\"Aborting owing to failure to find \" + SAMPLE_ID_COLUMN_NAME\n+                    + \" in file. Please check your file format and try again.\");\n+        }\n+        importData(buff, resources, headerIndexMap);\n+        buff.close();\n+\n+        if (MySQLbulkLoader.isBulkLoad()) {\n+            MySQLbulkLoader.flushAll();\n+            MySQLbulkLoader.relaxedModeOff();\n+        }\n+    }\n+\n+    private void importData(BufferedReader buff, List<ResourceDefinition> resources, Map<String, Integer> headerIndexMap) throws Exception {\n+        String line;\n+        MultiKeyMap resourceMap = new MultiKeyMap();\n+        // create resource_id set\n+        Set<String> patientResourceIdSet = resources\n+                .stream()\n+                .filter(resource -> resource.getResourceType().equals(ResourceType.PATIENT))\n+                .map(resource -> resource.getResourceId())\n+                .collect(Collectors.toSet());\n+        Set<String> sampleResourceIdSet = resources\n+                .stream()\n+                .filter(resource -> resource.getResourceType().equals(ResourceType.SAMPLE))\n+                .map(resource -> resource.getResourceId())\n+                .collect(Collectors.toSet());\n+        Set<String> studyResourceIdSet = resources\n+                .stream()\n+                .filter(resource -> resource.getResourceType().equals(ResourceType.STUDY))\n+                .map(resource -> resource.getResourceId())\n+                .collect(Collectors.toSet());\n+\n+        while ((line = buff.readLine()) != null) {\n+            if (skipLine(line.trim())) {\n+                continue;\n+            }\n+\n+            String[] fieldValues = getFieldValues(line, headerIndexMap);\n+            addDatum(fieldValues, resources, resourceMap, headerIndexMap, patientResourceIdSet, sampleResourceIdSet, studyResourceIdSet);\n+        }\n+    }\n+\n+    private boolean skipLine(String line) {\n+        return (line.isEmpty() || line.substring(0, 1).equals(METADATA_PREFIX));\n+    }\n+\n+    /**\n+     * Takes in the given line and returns the list of field values by splitting the\n+     * line on DELIMITER.\n+     * \n+     * @param line\n+     * @param headerIndexMap\n+     * @return the list of values, one for each column. Value will be \"\" for empty\n+     *         columns.\n+     */\n+    private String[] getFieldValues(String line, Map<String, Integer> headerIndexMap) {\n+        // split on delimiter:\n+        String[] fieldValues = line.split(DELIMITER, -1);\n+\n+        // validate: if number of fields is incorrect, give exception\n+        if (fieldValues.length != headerIndexMap.size()) {\n+            throw new IllegalArgumentException(\"Number of columns in line is not as expected. Expected: \"\n+                    + headerIndexMap.size() + \" columns, found: \" + fieldValues.length + \", for line: \" + line);\n+        }\n+\n+        // now iterate over lines and trim each value:\n+        for (int i = 0; i < fieldValues.length; i++) {\n+            fieldValues[i] = fieldValues[i].trim();\n+        }\n+        return fieldValues;\n+    }\n+\n+    private boolean addDatum(String[] fields, List<ResourceDefinition> resources, MultiKeyMap resourceMap, Map<String, Integer> headerIndexMap, Set<String> patientResourceIdSet, Set<String> sampleResourceIdSet, Set<String> studyResourceIdSet)\n+            throws Exception {\n+        int sampleIdIndex = findSampleIdColumn(headerIndexMap);\n+        String stableSampleId = (sampleIdIndex >= 0) ? fields[sampleIdIndex] : \"\";\n+        stableSampleId = StableIdUtil.getSampleId(stableSampleId);\n+        int patientIdIndex = findPatientIdColumn(headerIndexMap);\n+        String stablePatientId = (patientIdIndex >= 0) ? fields[patientIdIndex] : \"\";\n+        stablePatientId = StableIdUtil.getPatientId(stablePatientId);\n+        int resourceIdIndex = findResourceIdColumn(headerIndexMap);\n+        int urlIndex = findURLColumn(headerIndexMap);\n+        int internalSampleId = -1;\n+        int internalPatientId = -1;\n+\n+        // validate sample and patient for sample or patient attibutes\n+        if (resourceType.equals(ResourceType.SAMPLE) || resourceType.equals(ResourceType.PATIENT)) {\n+            // check if sample is not already added:\n+            Sample sample = DaoSample.getSampleByCancerStudyAndSampleId(cancerStudy.getInternalId(), stableSampleId, false);\n+            if (sample != null) {\n+                // get internal sample id if sample exists\n+                internalSampleId = sample.getInternalId();\n+            } else {\n+                Patient patient = DaoPatient.getPatientByCancerStudyAndPatientId(cancerStudy.getInternalId(),\n+                        stablePatientId);\n+                if (patient != null) {\n+                    // patient exists, get internal id:\n+                    internalPatientId = patient.getInternalId();\n+                } else {\n+                    // add patient:\n+                    internalPatientId = (patientIdIndex >= 0) ? addPatientToDatabase(fields[patientIdIndex]) : -1;\n+                }\n+                // sample is new, so attempt to add to DB\n+                internalSampleId = (stableSampleId.length() > 0) ? addSampleToDatabase(stableSampleId, fields, headerIndexMap)\n+                        : -1;\n+            }\n+\n+            // validate and count:\n+            if (internalSampleId != -1) {\n+                // some minimal validation/fail safe for now: only continue if patientId is same\n+                // as patient id in\n+                // existing sample (can occur in case of this.isSupplementalData or in case of\n+                // parsing bug in addSampleToDatabase):\n+                internalPatientId = DaoPatient\n+                        .getPatientByCancerStudyAndPatientId(cancerStudy.getInternalId(), stablePatientId).getInternalId();\n+                if (internalPatientId != DaoSample.getSampleById(internalSampleId).getInternalPatientId()) {\n+                    throw new RuntimeException(\"Error: Sample \" + stableSampleId\n+                            + \" was previously linked to another patient, and not to \" + stablePatientId);\n+                }\n+                numSamplesProcessed++;\n+            }\n+        }\n+\n+        // if the resource id or url matches one of the missing values, skip this resource:\n+        if ((resourceIdIndex != -1 && MissingValues.has(fields[resourceIdIndex])) || (urlIndex != -1 && MissingValues.has(fields[urlIndex]))) {\n+            numEmptyResourcesSkipped++;\n+        } else {\n+            // if patient_id column exists and resource type is patient\n+            if (getResourceType() == ResourceType.PATIENT && internalPatientId != -1) {\n+                validateAddDatum(internalPatientId, stablePatientId, fields[resourceIdIndex], fields[urlIndex], \n+                        ResourceType.PATIENT, patientResourceIdSet, resourceMap);\n+            } \n+            // if sample_id column exists and resource type is sample\n+            else if (getResourceType() == ResourceType.SAMPLE && internalSampleId != -1) {\n+                validateAddDatum(internalSampleId, stableSampleId, fields[resourceIdIndex], fields[urlIndex], \n+                        ResourceType.SAMPLE, sampleResourceIdSet, resourceMap);\n+            }\n+            // if resource type is study\n+            else if (getResourceType() == ResourceType.STUDY) {\n+                validateAddDatum(cancerStudy.getInternalId(), cancerStudy.getCancerStudyStableId(), fields[resourceIdIndex], fields[urlIndex], \n+                        ResourceType.STUDY, studyResourceIdSet, resourceMap);\n+            }\n+        }\n+        return true;\n+    }\n+\n+    private Map<String, Integer> makeHeaderIndexMap(String[] headerNames) {\n+        Map<String, Integer> headerIndexMap = new HashMap<String, Integer>();\n+        for (int i= 0; i < headerNames.length; i++) {\n+            headerIndexMap.put(headerNames[i], i);\n+        }\n+        return headerIndexMap;\n+    }\n+\n+    private int findPatientIdColumn(Map<String, Integer> headerIndexMap) {\n+        return findColumnIndexInHeaders(PATIENT_ID_COLUMN_NAME, headerIndexMap);\n+    }\n+\n+    private int findSampleIdColumn(Map<String, Integer> headerIndexMap) {\n+        return findColumnIndexInHeaders(SAMPLE_ID_COLUMN_NAME, headerIndexMap);\n+    }\n+\n+    private int findResourceIdColumn(Map<String, Integer> headerIndexMap) {\n+        return findColumnIndexInHeaders(RESOURCE_ID_COLUMN_NAME, headerIndexMap);\n+    }\n+\n+    private int findURLColumn(Map<String, Integer> headerIndexMap) {\n+        return findColumnIndexInHeaders(URL_COLUMN_NAME, headerIndexMap);\n+    }\n+\n+    private int findSampleTypeColumn(Map<String, Integer> headerIndexMap) {\n+        return findColumnIndexInHeaders(SAMPLE_TYPE_COLUMN_NAME, headerIndexMap);\n+    }\n+\n+    private int findColumnIndexInHeaders(String columnHeader, Map<String, Integer> headerIndexMap) {\n+        return headerIndexMap.getOrDefault(columnHeader, -1);\n+    }\n+\n+    private int addPatientToDatabase(String patientId) throws Exception {\n+        int internalPatientId = -1;\n+        if (validPatientId(patientId)) {\n+            Patient patient = DaoPatient.getPatientByCancerStudyAndPatientId(cancerStudy.getInternalId(), patientId);\n+            // other validations:\n+            // in case of PATIENT data import, there are some special checks:\n+            if (getResourceType() == ResourceType.PATIENT) {\n+                // if resource data is already there, then something has gone wrong (e.g.\n+                // patient is duplicated in file), abort:\n+                if (patient != null\n+                        && DaoResourceData.getDataByPatientId(cancerStudy.getInternalId(), patientId).size() > 0) {\n+                    throw new RuntimeException(\n+                            \"Something has gone wrong. Patient \" + patientId + \" already has resource data loaded.\");\n+                }\n+                // if patient is duplicated, abort as well in this case:\n+                if (!patientIds.add(patientId)) {\n+                    throw new RuntimeException(\"Error. Patient \" + patientId + \" found to be duplicated in your file.\");\n+                }\n+            }\n+\n+            if (patient != null) {\n+                // in all cases (SAMPLE, PATIENT, or STUDY) this can be expected, so\n+                // just fetch it:\n+                internalPatientId = patient.getInternalId();\n+            } else {\n+                // in case of PATIENT data import and patient == null :\n+                if (getResourceType() == ResourceType.PATIENT) {\n+                    // not finding the patient it unexpected (as SAMPLE data import should always\n+                    // precede it), but\n+                    // can happen when this patient does not have any samples for example. In any\n+                    // case, warn about it:\n+                    ProgressMonitor.logWarning(\"Patient \" + patientId\n+                            + \" being added for the first time. Apparently this patient was not in the samples file, or the samples file is not yet loaded (should be loaded before this one)\");\n+                }\n+\n+                patient = new Patient(cancerStudy, patientId);\n+                internalPatientId = DaoPatient.addPatient(patient);\n+            }\n+        }\n+        return internalPatientId;\n+    }\n+\n+    private int addSampleToDatabase(String sampleId, String[] fields, Map<String, Integer> headerIndexMap)\n+            throws Exception {\n+        int sampleTypeIndex = findSampleTypeColumn(headerIndexMap);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjYxMzM2MA=="}, "originalCommit": {"oid": "4e724ff759a02f25a33335b5d8aab57376718488"}, "originalPosition": 307}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ1ODYyODM1OnYy", "diffSide": "RIGHT", "path": "core/src/main/java/org/mskcc/cbio/portal/scripts/ImportResourceData.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yM1QxNzoxMjoyMVrOF6Pgmw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yM1QxNzoxMjoyMVrOF6Pgmw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjYxNTgzNQ==", "bodyText": "addPatientToDatabase already return patient internal id. do we still need this query?", "url": "https://github.com/cBioPortal/cbioportal/pull/7270#discussion_r396615835", "createdAt": "2020-03-23T17:12:21Z", "author": {"login": "kalletlak"}, "path": "core/src/main/java/org/mskcc/cbio/portal/scripts/ImportResourceData.java", "diffHunk": "@@ -0,0 +1,555 @@\n+package org.mskcc.cbio.portal.scripts;\n+\n+import org.mskcc.cbio.portal.dao.*;\n+import org.mskcc.cbio.portal.model.*;\n+import org.mskcc.cbio.portal.util.*;\n+\n+import java.io.*;\n+import joptsimple.*;\n+import java.util.*;\n+import java.util.regex.*;\n+import java.util.stream.Collectors;\n+\n+import org.apache.commons.collections.map.MultiKeyMap;\n+import org.cbioportal.model.ResourceType;\n+\n+public class ImportResourceData extends ConsoleRunnable {\n+\n+    public static final String DELIMITER = \"\\t\";\n+    public static final String METADATA_PREFIX = \"#\";\n+    public static final String SAMPLE_ID_COLUMN_NAME = \"SAMPLE_ID\";\n+    public static final String PATIENT_ID_COLUMN_NAME = \"PATIENT_ID\";\n+    public static final String RESOURCE_ID_COLUMN_NAME = \"RESOURCE_ID\";\n+    public static final String URL_COLUMN_NAME = \"URL\";\n+    public static final String SAMPLE_TYPE_COLUMN_NAME = \"SAMPLE_TYPE\";\n+    private int numSampleSpecificResourcesAdded = 0;\n+    private int numPatientSpecificResourcesAdded = 0;\n+    private int numStudySpecificResourcesAdded = 0;\n+    private int numEmptyResourcesSkipped = 0;\n+    private int numSamplesProcessed = 0;\n+\n+    private static Properties properties;\n+\n+    private File resourceDataFile;\n+    private CancerStudy cancerStudy;\n+    private ResourceType resourceType;\n+    private boolean relaxed;\n+    private Set<String> patientIds = new HashSet<String>();\n+\n+    public void setFile(CancerStudy cancerStudy, File resourceDataFile, String resourceType, boolean relaxed) {\n+        this.cancerStudy = cancerStudy;\n+        this.resourceDataFile = resourceDataFile;\n+        this.resourceType = ResourceType.valueOf(resourceType);\n+        this.relaxed = relaxed;\n+    }\n+\n+    public void importData() throws Exception {\n+        // if bulkLoading is ever turned off,\n+        // code has to be added to check whether\n+        // a resource data update should be\n+        // perform instead of an insert\n+        MySQLbulkLoader.bulkLoadOn();\n+\n+        if (relaxed) {\n+            MySQLbulkLoader.relaxedModeOn();\n+        }\n+\n+        FileReader reader = new FileReader(resourceDataFile);\n+        BufferedReader buff = new BufferedReader(reader);\n+        List<ResourceDefinition> resources = DaoResourceDefinition.getDatumByStudy(cancerStudy.getInternalId());\n+        String currentLine = buff.readLine();\n+        String[] headerNames = currentLine.split(\"\\t\");\n+        Map<String, Integer> headerIndexMap = makeHeaderIndexMap(headerNames);\n+        \n+        int patientIdIndex = findPatientIdColumn(headerIndexMap);\n+        int sampleIdIndex = findSampleIdColumn(headerIndexMap);\n+        int resourceIdIndex = findResourceIdColumn(headerIndexMap);\n+        int urlIndex = findURLColumn(headerIndexMap);\n+\n+        // validate required columns:\n+        if (resourceIdIndex < 0) {\n+            throw new RuntimeException(\"Aborting owing to failure to find \" + RESOURCE_ID_COLUMN_NAME\n+                    + \" in file. Please check your file format and try again.\");\n+        }\n+        if (urlIndex < 0) {\n+            throw new RuntimeException(\"Aborting owing to failure to find \" + URL_COLUMN_NAME\n+                    + \" in file. Please check your file format and try again.\");\n+        }\n+        if ((resourceType.equals(ResourceType.SAMPLE) || resourceType.equals(ResourceType.PATIENT)) && patientIdIndex < 0) {\n+            // PATIENT_ID is required in both patient and sample file types:\n+            throw new RuntimeException(\"Aborting owing to failure to find \" + PATIENT_ID_COLUMN_NAME\n+                    + \" in file. Please check your file format and try again.\");\n+        }\n+        if (resourceType.equals(ResourceType.SAMPLE) && sampleIdIndex < 0) {\n+            // SAMPLE_ID is required in SAMPLE file type:\n+            throw new RuntimeException(\"Aborting owing to failure to find \" + SAMPLE_ID_COLUMN_NAME\n+                    + \" in file. Please check your file format and try again.\");\n+        }\n+        importData(buff, resources, headerIndexMap);\n+        buff.close();\n+\n+        if (MySQLbulkLoader.isBulkLoad()) {\n+            MySQLbulkLoader.flushAll();\n+            MySQLbulkLoader.relaxedModeOff();\n+        }\n+    }\n+\n+    private void importData(BufferedReader buff, List<ResourceDefinition> resources, Map<String, Integer> headerIndexMap) throws Exception {\n+        String line;\n+        MultiKeyMap resourceMap = new MultiKeyMap();\n+        // create resource_id set\n+        Set<String> patientResourceIdSet = resources\n+                .stream()\n+                .filter(resource -> resource.getResourceType().equals(ResourceType.PATIENT))\n+                .map(resource -> resource.getResourceId())\n+                .collect(Collectors.toSet());\n+        Set<String> sampleResourceIdSet = resources\n+                .stream()\n+                .filter(resource -> resource.getResourceType().equals(ResourceType.SAMPLE))\n+                .map(resource -> resource.getResourceId())\n+                .collect(Collectors.toSet());\n+        Set<String> studyResourceIdSet = resources\n+                .stream()\n+                .filter(resource -> resource.getResourceType().equals(ResourceType.STUDY))\n+                .map(resource -> resource.getResourceId())\n+                .collect(Collectors.toSet());\n+\n+        while ((line = buff.readLine()) != null) {\n+            if (skipLine(line.trim())) {\n+                continue;\n+            }\n+\n+            String[] fieldValues = getFieldValues(line, headerIndexMap);\n+            addDatum(fieldValues, resources, resourceMap, headerIndexMap, patientResourceIdSet, sampleResourceIdSet, studyResourceIdSet);\n+        }\n+    }\n+\n+    private boolean skipLine(String line) {\n+        return (line.isEmpty() || line.substring(0, 1).equals(METADATA_PREFIX));\n+    }\n+\n+    /**\n+     * Takes in the given line and returns the list of field values by splitting the\n+     * line on DELIMITER.\n+     * \n+     * @param line\n+     * @param headerIndexMap\n+     * @return the list of values, one for each column. Value will be \"\" for empty\n+     *         columns.\n+     */\n+    private String[] getFieldValues(String line, Map<String, Integer> headerIndexMap) {\n+        // split on delimiter:\n+        String[] fieldValues = line.split(DELIMITER, -1);\n+\n+        // validate: if number of fields is incorrect, give exception\n+        if (fieldValues.length != headerIndexMap.size()) {\n+            throw new IllegalArgumentException(\"Number of columns in line is not as expected. Expected: \"\n+                    + headerIndexMap.size() + \" columns, found: \" + fieldValues.length + \", for line: \" + line);\n+        }\n+\n+        // now iterate over lines and trim each value:\n+        for (int i = 0; i < fieldValues.length; i++) {\n+            fieldValues[i] = fieldValues[i].trim();\n+        }\n+        return fieldValues;\n+    }\n+\n+    private boolean addDatum(String[] fields, List<ResourceDefinition> resources, MultiKeyMap resourceMap, Map<String, Integer> headerIndexMap, Set<String> patientResourceIdSet, Set<String> sampleResourceIdSet, Set<String> studyResourceIdSet)\n+            throws Exception {\n+        int sampleIdIndex = findSampleIdColumn(headerIndexMap);\n+        String stableSampleId = (sampleIdIndex >= 0) ? fields[sampleIdIndex] : \"\";\n+        stableSampleId = StableIdUtil.getSampleId(stableSampleId);\n+        int patientIdIndex = findPatientIdColumn(headerIndexMap);\n+        String stablePatientId = (patientIdIndex >= 0) ? fields[patientIdIndex] : \"\";\n+        stablePatientId = StableIdUtil.getPatientId(stablePatientId);\n+        int resourceIdIndex = findResourceIdColumn(headerIndexMap);\n+        int urlIndex = findURLColumn(headerIndexMap);\n+        int internalSampleId = -1;\n+        int internalPatientId = -1;\n+\n+        // validate sample and patient for sample or patient attibutes\n+        if (resourceType.equals(ResourceType.SAMPLE) || resourceType.equals(ResourceType.PATIENT)) {\n+            // check if sample is not already added:\n+            Sample sample = DaoSample.getSampleByCancerStudyAndSampleId(cancerStudy.getInternalId(), stableSampleId, false);\n+            if (sample != null) {\n+                // get internal sample id if sample exists\n+                internalSampleId = sample.getInternalId();\n+            } else {\n+                Patient patient = DaoPatient.getPatientByCancerStudyAndPatientId(cancerStudy.getInternalId(),\n+                        stablePatientId);\n+                if (patient != null) {\n+                    // patient exists, get internal id:\n+                    internalPatientId = patient.getInternalId();\n+                } else {\n+                    // add patient:\n+                    internalPatientId = (patientIdIndex >= 0) ? addPatientToDatabase(fields[patientIdIndex]) : -1;\n+                }\n+                // sample is new, so attempt to add to DB\n+                internalSampleId = (stableSampleId.length() > 0) ? addSampleToDatabase(stableSampleId, fields, headerIndexMap)\n+                        : -1;\n+            }\n+\n+            // validate and count:\n+            if (internalSampleId != -1) {\n+                // some minimal validation/fail safe for now: only continue if patientId is same\n+                // as patient id in\n+                // existing sample (can occur in case of this.isSupplementalData or in case of\n+                // parsing bug in addSampleToDatabase):\n+                internalPatientId = DaoPatient\n+                        .getPatientByCancerStudyAndPatientId(cancerStudy.getInternalId(), stablePatientId).getInternalId();\n+                if (internalPatientId != DaoSample.getSampleById(internalSampleId).getInternalPatientId()) {\n+                    throw new RuntimeException(\"Error: Sample \" + stableSampleId\n+                            + \" was previously linked to another patient, and not to \" + stablePatientId);\n+                }\n+                numSamplesProcessed++;\n+            }\n+        }\n+\n+        // if the resource id or url matches one of the missing values, skip this resource:\n+        if ((resourceIdIndex != -1 && MissingValues.has(fields[resourceIdIndex])) || (urlIndex != -1 && MissingValues.has(fields[urlIndex]))) {\n+            numEmptyResourcesSkipped++;\n+        } else {\n+            // if patient_id column exists and resource type is patient\n+            if (getResourceType() == ResourceType.PATIENT && internalPatientId != -1) {\n+                validateAddDatum(internalPatientId, stablePatientId, fields[resourceIdIndex], fields[urlIndex], \n+                        ResourceType.PATIENT, patientResourceIdSet, resourceMap);\n+            } \n+            // if sample_id column exists and resource type is sample\n+            else if (getResourceType() == ResourceType.SAMPLE && internalSampleId != -1) {\n+                validateAddDatum(internalSampleId, stableSampleId, fields[resourceIdIndex], fields[urlIndex], \n+                        ResourceType.SAMPLE, sampleResourceIdSet, resourceMap);\n+            }\n+            // if resource type is study\n+            else if (getResourceType() == ResourceType.STUDY) {\n+                validateAddDatum(cancerStudy.getInternalId(), cancerStudy.getCancerStudyStableId(), fields[resourceIdIndex], fields[urlIndex], \n+                        ResourceType.STUDY, studyResourceIdSet, resourceMap);\n+            }\n+        }\n+        return true;\n+    }\n+\n+    private Map<String, Integer> makeHeaderIndexMap(String[] headerNames) {\n+        Map<String, Integer> headerIndexMap = new HashMap<String, Integer>();\n+        for (int i= 0; i < headerNames.length; i++) {\n+            headerIndexMap.put(headerNames[i], i);\n+        }\n+        return headerIndexMap;\n+    }\n+\n+    private int findPatientIdColumn(Map<String, Integer> headerIndexMap) {\n+        return findColumnIndexInHeaders(PATIENT_ID_COLUMN_NAME, headerIndexMap);\n+    }\n+\n+    private int findSampleIdColumn(Map<String, Integer> headerIndexMap) {\n+        return findColumnIndexInHeaders(SAMPLE_ID_COLUMN_NAME, headerIndexMap);\n+    }\n+\n+    private int findResourceIdColumn(Map<String, Integer> headerIndexMap) {\n+        return findColumnIndexInHeaders(RESOURCE_ID_COLUMN_NAME, headerIndexMap);\n+    }\n+\n+    private int findURLColumn(Map<String, Integer> headerIndexMap) {\n+        return findColumnIndexInHeaders(URL_COLUMN_NAME, headerIndexMap);\n+    }\n+\n+    private int findSampleTypeColumn(Map<String, Integer> headerIndexMap) {\n+        return findColumnIndexInHeaders(SAMPLE_TYPE_COLUMN_NAME, headerIndexMap);\n+    }\n+\n+    private int findColumnIndexInHeaders(String columnHeader, Map<String, Integer> headerIndexMap) {\n+        return headerIndexMap.getOrDefault(columnHeader, -1);\n+    }\n+\n+    private int addPatientToDatabase(String patientId) throws Exception {\n+        int internalPatientId = -1;\n+        if (validPatientId(patientId)) {\n+            Patient patient = DaoPatient.getPatientByCancerStudyAndPatientId(cancerStudy.getInternalId(), patientId);\n+            // other validations:\n+            // in case of PATIENT data import, there are some special checks:\n+            if (getResourceType() == ResourceType.PATIENT) {\n+                // if resource data is already there, then something has gone wrong (e.g.\n+                // patient is duplicated in file), abort:\n+                if (patient != null\n+                        && DaoResourceData.getDataByPatientId(cancerStudy.getInternalId(), patientId).size() > 0) {\n+                    throw new RuntimeException(\n+                            \"Something has gone wrong. Patient \" + patientId + \" already has resource data loaded.\");\n+                }\n+                // if patient is duplicated, abort as well in this case:\n+                if (!patientIds.add(patientId)) {\n+                    throw new RuntimeException(\"Error. Patient \" + patientId + \" found to be duplicated in your file.\");\n+                }\n+            }\n+\n+            if (patient != null) {\n+                // in all cases (SAMPLE, PATIENT, or STUDY) this can be expected, so\n+                // just fetch it:\n+                internalPatientId = patient.getInternalId();\n+            } else {\n+                // in case of PATIENT data import and patient == null :\n+                if (getResourceType() == ResourceType.PATIENT) {\n+                    // not finding the patient it unexpected (as SAMPLE data import should always\n+                    // precede it), but\n+                    // can happen when this patient does not have any samples for example. In any\n+                    // case, warn about it:\n+                    ProgressMonitor.logWarning(\"Patient \" + patientId\n+                            + \" being added for the first time. Apparently this patient was not in the samples file, or the samples file is not yet loaded (should be loaded before this one)\");\n+                }\n+\n+                patient = new Patient(cancerStudy, patientId);\n+                internalPatientId = DaoPatient.addPatient(patient);\n+            }\n+        }\n+        return internalPatientId;\n+    }\n+\n+    private int addSampleToDatabase(String sampleId, String[] fields, Map<String, Integer> headerIndexMap)\n+            throws Exception {\n+        int sampleTypeIndex = findSampleTypeColumn(headerIndexMap);\n+        String sampleTypeStr = (sampleTypeIndex != -1) ? fields[sampleTypeIndex] : null;\n+        if (sampleTypeStr != null) {\n+            // want to match Sample.Type enum names\n+            sampleTypeStr = sampleTypeStr.trim().toUpperCase().replaceAll(\" \", \"_\");\n+        }\n+        Sample.Type sampleType = Sample.Type.has(sampleTypeStr) ? Sample.Type.valueOf(sampleTypeStr) : null;\n+\n+        int internalSampleId = -1;\n+        if (validSampleId(sampleId) && !StableIdUtil.isNormal(sampleId)) {\n+            // want to try and capture normal sample types based on value for SAMPLE_TYPE\n+            // if present in resource data\n+            if (sampleType != null && sampleType.isNormal()) {\n+                return internalSampleId;\n+            }\n+            String stablePatientId = getStablePatientId(sampleId, fields, headerIndexMap);\n+            if (validPatientId(stablePatientId)) {\n+                Patient patient = DaoPatient.getPatientByCancerStudyAndPatientId(cancerStudy.getInternalId(),\n+                        stablePatientId);\n+                if (patient == null) {\n+                    addPatientToDatabase(stablePatientId);\n+                    patient = DaoPatient.getPatientByCancerStudyAndPatientId(cancerStudy.getInternalId(),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4e724ff759a02f25a33335b5d8aab57376718488"}, "originalPosition": 328}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ1ODY1ODY5OnYy", "diffSide": "RIGHT", "path": "core/src/main/java/org/mskcc/cbio/portal/scripts/ImportResourceData.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yM1QxNzoxOToyOFrOF6P0Rg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yM1QxNzoxOToyOFrOF6P0Rg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjYyMDg3MA==", "bodyText": "I think addSampleToDatabase should be executed only when patient is added. I prefer passing patient object in the method parameter. this would reduce the number of queries made to database to fetch patient(getPatientByCancerStudyAndPatientId)", "url": "https://github.com/cBioPortal/cbioportal/pull/7270#discussion_r396620870", "createdAt": "2020-03-23T17:19:28Z", "author": {"login": "kalletlak"}, "path": "core/src/main/java/org/mskcc/cbio/portal/scripts/ImportResourceData.java", "diffHunk": "@@ -0,0 +1,555 @@\n+package org.mskcc.cbio.portal.scripts;\n+\n+import org.mskcc.cbio.portal.dao.*;\n+import org.mskcc.cbio.portal.model.*;\n+import org.mskcc.cbio.portal.util.*;\n+\n+import java.io.*;\n+import joptsimple.*;\n+import java.util.*;\n+import java.util.regex.*;\n+import java.util.stream.Collectors;\n+\n+import org.apache.commons.collections.map.MultiKeyMap;\n+import org.cbioportal.model.ResourceType;\n+\n+public class ImportResourceData extends ConsoleRunnable {\n+\n+    public static final String DELIMITER = \"\\t\";\n+    public static final String METADATA_PREFIX = \"#\";\n+    public static final String SAMPLE_ID_COLUMN_NAME = \"SAMPLE_ID\";\n+    public static final String PATIENT_ID_COLUMN_NAME = \"PATIENT_ID\";\n+    public static final String RESOURCE_ID_COLUMN_NAME = \"RESOURCE_ID\";\n+    public static final String URL_COLUMN_NAME = \"URL\";\n+    public static final String SAMPLE_TYPE_COLUMN_NAME = \"SAMPLE_TYPE\";\n+    private int numSampleSpecificResourcesAdded = 0;\n+    private int numPatientSpecificResourcesAdded = 0;\n+    private int numStudySpecificResourcesAdded = 0;\n+    private int numEmptyResourcesSkipped = 0;\n+    private int numSamplesProcessed = 0;\n+\n+    private static Properties properties;\n+\n+    private File resourceDataFile;\n+    private CancerStudy cancerStudy;\n+    private ResourceType resourceType;\n+    private boolean relaxed;\n+    private Set<String> patientIds = new HashSet<String>();\n+\n+    public void setFile(CancerStudy cancerStudy, File resourceDataFile, String resourceType, boolean relaxed) {\n+        this.cancerStudy = cancerStudy;\n+        this.resourceDataFile = resourceDataFile;\n+        this.resourceType = ResourceType.valueOf(resourceType);\n+        this.relaxed = relaxed;\n+    }\n+\n+    public void importData() throws Exception {\n+        // if bulkLoading is ever turned off,\n+        // code has to be added to check whether\n+        // a resource data update should be\n+        // perform instead of an insert\n+        MySQLbulkLoader.bulkLoadOn();\n+\n+        if (relaxed) {\n+            MySQLbulkLoader.relaxedModeOn();\n+        }\n+\n+        FileReader reader = new FileReader(resourceDataFile);\n+        BufferedReader buff = new BufferedReader(reader);\n+        List<ResourceDefinition> resources = DaoResourceDefinition.getDatumByStudy(cancerStudy.getInternalId());\n+        String currentLine = buff.readLine();\n+        String[] headerNames = currentLine.split(\"\\t\");\n+        Map<String, Integer> headerIndexMap = makeHeaderIndexMap(headerNames);\n+        \n+        int patientIdIndex = findPatientIdColumn(headerIndexMap);\n+        int sampleIdIndex = findSampleIdColumn(headerIndexMap);\n+        int resourceIdIndex = findResourceIdColumn(headerIndexMap);\n+        int urlIndex = findURLColumn(headerIndexMap);\n+\n+        // validate required columns:\n+        if (resourceIdIndex < 0) {\n+            throw new RuntimeException(\"Aborting owing to failure to find \" + RESOURCE_ID_COLUMN_NAME\n+                    + \" in file. Please check your file format and try again.\");\n+        }\n+        if (urlIndex < 0) {\n+            throw new RuntimeException(\"Aborting owing to failure to find \" + URL_COLUMN_NAME\n+                    + \" in file. Please check your file format and try again.\");\n+        }\n+        if ((resourceType.equals(ResourceType.SAMPLE) || resourceType.equals(ResourceType.PATIENT)) && patientIdIndex < 0) {\n+            // PATIENT_ID is required in both patient and sample file types:\n+            throw new RuntimeException(\"Aborting owing to failure to find \" + PATIENT_ID_COLUMN_NAME\n+                    + \" in file. Please check your file format and try again.\");\n+        }\n+        if (resourceType.equals(ResourceType.SAMPLE) && sampleIdIndex < 0) {\n+            // SAMPLE_ID is required in SAMPLE file type:\n+            throw new RuntimeException(\"Aborting owing to failure to find \" + SAMPLE_ID_COLUMN_NAME\n+                    + \" in file. Please check your file format and try again.\");\n+        }\n+        importData(buff, resources, headerIndexMap);\n+        buff.close();\n+\n+        if (MySQLbulkLoader.isBulkLoad()) {\n+            MySQLbulkLoader.flushAll();\n+            MySQLbulkLoader.relaxedModeOff();\n+        }\n+    }\n+\n+    private void importData(BufferedReader buff, List<ResourceDefinition> resources, Map<String, Integer> headerIndexMap) throws Exception {\n+        String line;\n+        MultiKeyMap resourceMap = new MultiKeyMap();\n+        // create resource_id set\n+        Set<String> patientResourceIdSet = resources\n+                .stream()\n+                .filter(resource -> resource.getResourceType().equals(ResourceType.PATIENT))\n+                .map(resource -> resource.getResourceId())\n+                .collect(Collectors.toSet());\n+        Set<String> sampleResourceIdSet = resources\n+                .stream()\n+                .filter(resource -> resource.getResourceType().equals(ResourceType.SAMPLE))\n+                .map(resource -> resource.getResourceId())\n+                .collect(Collectors.toSet());\n+        Set<String> studyResourceIdSet = resources\n+                .stream()\n+                .filter(resource -> resource.getResourceType().equals(ResourceType.STUDY))\n+                .map(resource -> resource.getResourceId())\n+                .collect(Collectors.toSet());\n+\n+        while ((line = buff.readLine()) != null) {\n+            if (skipLine(line.trim())) {\n+                continue;\n+            }\n+\n+            String[] fieldValues = getFieldValues(line, headerIndexMap);\n+            addDatum(fieldValues, resources, resourceMap, headerIndexMap, patientResourceIdSet, sampleResourceIdSet, studyResourceIdSet);\n+        }\n+    }\n+\n+    private boolean skipLine(String line) {\n+        return (line.isEmpty() || line.substring(0, 1).equals(METADATA_PREFIX));\n+    }\n+\n+    /**\n+     * Takes in the given line and returns the list of field values by splitting the\n+     * line on DELIMITER.\n+     * \n+     * @param line\n+     * @param headerIndexMap\n+     * @return the list of values, one for each column. Value will be \"\" for empty\n+     *         columns.\n+     */\n+    private String[] getFieldValues(String line, Map<String, Integer> headerIndexMap) {\n+        // split on delimiter:\n+        String[] fieldValues = line.split(DELIMITER, -1);\n+\n+        // validate: if number of fields is incorrect, give exception\n+        if (fieldValues.length != headerIndexMap.size()) {\n+            throw new IllegalArgumentException(\"Number of columns in line is not as expected. Expected: \"\n+                    + headerIndexMap.size() + \" columns, found: \" + fieldValues.length + \", for line: \" + line);\n+        }\n+\n+        // now iterate over lines and trim each value:\n+        for (int i = 0; i < fieldValues.length; i++) {\n+            fieldValues[i] = fieldValues[i].trim();\n+        }\n+        return fieldValues;\n+    }\n+\n+    private boolean addDatum(String[] fields, List<ResourceDefinition> resources, MultiKeyMap resourceMap, Map<String, Integer> headerIndexMap, Set<String> patientResourceIdSet, Set<String> sampleResourceIdSet, Set<String> studyResourceIdSet)\n+            throws Exception {\n+        int sampleIdIndex = findSampleIdColumn(headerIndexMap);\n+        String stableSampleId = (sampleIdIndex >= 0) ? fields[sampleIdIndex] : \"\";\n+        stableSampleId = StableIdUtil.getSampleId(stableSampleId);\n+        int patientIdIndex = findPatientIdColumn(headerIndexMap);\n+        String stablePatientId = (patientIdIndex >= 0) ? fields[patientIdIndex] : \"\";\n+        stablePatientId = StableIdUtil.getPatientId(stablePatientId);\n+        int resourceIdIndex = findResourceIdColumn(headerIndexMap);\n+        int urlIndex = findURLColumn(headerIndexMap);\n+        int internalSampleId = -1;\n+        int internalPatientId = -1;\n+\n+        // validate sample and patient for sample or patient attibutes\n+        if (resourceType.equals(ResourceType.SAMPLE) || resourceType.equals(ResourceType.PATIENT)) {\n+            // check if sample is not already added:\n+            Sample sample = DaoSample.getSampleByCancerStudyAndSampleId(cancerStudy.getInternalId(), stableSampleId, false);\n+            if (sample != null) {\n+                // get internal sample id if sample exists\n+                internalSampleId = sample.getInternalId();\n+            } else {\n+                Patient patient = DaoPatient.getPatientByCancerStudyAndPatientId(cancerStudy.getInternalId(),\n+                        stablePatientId);\n+                if (patient != null) {\n+                    // patient exists, get internal id:\n+                    internalPatientId = patient.getInternalId();\n+                } else {\n+                    // add patient:\n+                    internalPatientId = (patientIdIndex >= 0) ? addPatientToDatabase(fields[patientIdIndex]) : -1;\n+                }\n+                // sample is new, so attempt to add to DB\n+                internalSampleId = (stableSampleId.length() > 0) ? addSampleToDatabase(stableSampleId, fields, headerIndexMap)\n+                        : -1;\n+            }\n+\n+            // validate and count:\n+            if (internalSampleId != -1) {\n+                // some minimal validation/fail safe for now: only continue if patientId is same\n+                // as patient id in\n+                // existing sample (can occur in case of this.isSupplementalData or in case of\n+                // parsing bug in addSampleToDatabase):\n+                internalPatientId = DaoPatient\n+                        .getPatientByCancerStudyAndPatientId(cancerStudy.getInternalId(), stablePatientId).getInternalId();\n+                if (internalPatientId != DaoSample.getSampleById(internalSampleId).getInternalPatientId()) {\n+                    throw new RuntimeException(\"Error: Sample \" + stableSampleId\n+                            + \" was previously linked to another patient, and not to \" + stablePatientId);\n+                }\n+                numSamplesProcessed++;\n+            }\n+        }\n+\n+        // if the resource id or url matches one of the missing values, skip this resource:\n+        if ((resourceIdIndex != -1 && MissingValues.has(fields[resourceIdIndex])) || (urlIndex != -1 && MissingValues.has(fields[urlIndex]))) {\n+            numEmptyResourcesSkipped++;\n+        } else {\n+            // if patient_id column exists and resource type is patient\n+            if (getResourceType() == ResourceType.PATIENT && internalPatientId != -1) {\n+                validateAddDatum(internalPatientId, stablePatientId, fields[resourceIdIndex], fields[urlIndex], \n+                        ResourceType.PATIENT, patientResourceIdSet, resourceMap);\n+            } \n+            // if sample_id column exists and resource type is sample\n+            else if (getResourceType() == ResourceType.SAMPLE && internalSampleId != -1) {\n+                validateAddDatum(internalSampleId, stableSampleId, fields[resourceIdIndex], fields[urlIndex], \n+                        ResourceType.SAMPLE, sampleResourceIdSet, resourceMap);\n+            }\n+            // if resource type is study\n+            else if (getResourceType() == ResourceType.STUDY) {\n+                validateAddDatum(cancerStudy.getInternalId(), cancerStudy.getCancerStudyStableId(), fields[resourceIdIndex], fields[urlIndex], \n+                        ResourceType.STUDY, studyResourceIdSet, resourceMap);\n+            }\n+        }\n+        return true;\n+    }\n+\n+    private Map<String, Integer> makeHeaderIndexMap(String[] headerNames) {\n+        Map<String, Integer> headerIndexMap = new HashMap<String, Integer>();\n+        for (int i= 0; i < headerNames.length; i++) {\n+            headerIndexMap.put(headerNames[i], i);\n+        }\n+        return headerIndexMap;\n+    }\n+\n+    private int findPatientIdColumn(Map<String, Integer> headerIndexMap) {\n+        return findColumnIndexInHeaders(PATIENT_ID_COLUMN_NAME, headerIndexMap);\n+    }\n+\n+    private int findSampleIdColumn(Map<String, Integer> headerIndexMap) {\n+        return findColumnIndexInHeaders(SAMPLE_ID_COLUMN_NAME, headerIndexMap);\n+    }\n+\n+    private int findResourceIdColumn(Map<String, Integer> headerIndexMap) {\n+        return findColumnIndexInHeaders(RESOURCE_ID_COLUMN_NAME, headerIndexMap);\n+    }\n+\n+    private int findURLColumn(Map<String, Integer> headerIndexMap) {\n+        return findColumnIndexInHeaders(URL_COLUMN_NAME, headerIndexMap);\n+    }\n+\n+    private int findSampleTypeColumn(Map<String, Integer> headerIndexMap) {\n+        return findColumnIndexInHeaders(SAMPLE_TYPE_COLUMN_NAME, headerIndexMap);\n+    }\n+\n+    private int findColumnIndexInHeaders(String columnHeader, Map<String, Integer> headerIndexMap) {\n+        return headerIndexMap.getOrDefault(columnHeader, -1);\n+    }\n+\n+    private int addPatientToDatabase(String patientId) throws Exception {\n+        int internalPatientId = -1;\n+        if (validPatientId(patientId)) {\n+            Patient patient = DaoPatient.getPatientByCancerStudyAndPatientId(cancerStudy.getInternalId(), patientId);\n+            // other validations:\n+            // in case of PATIENT data import, there are some special checks:\n+            if (getResourceType() == ResourceType.PATIENT) {\n+                // if resource data is already there, then something has gone wrong (e.g.\n+                // patient is duplicated in file), abort:\n+                if (patient != null\n+                        && DaoResourceData.getDataByPatientId(cancerStudy.getInternalId(), patientId).size() > 0) {\n+                    throw new RuntimeException(\n+                            \"Something has gone wrong. Patient \" + patientId + \" already has resource data loaded.\");\n+                }\n+                // if patient is duplicated, abort as well in this case:\n+                if (!patientIds.add(patientId)) {\n+                    throw new RuntimeException(\"Error. Patient \" + patientId + \" found to be duplicated in your file.\");\n+                }\n+            }\n+\n+            if (patient != null) {\n+                // in all cases (SAMPLE, PATIENT, or STUDY) this can be expected, so\n+                // just fetch it:\n+                internalPatientId = patient.getInternalId();\n+            } else {\n+                // in case of PATIENT data import and patient == null :\n+                if (getResourceType() == ResourceType.PATIENT) {\n+                    // not finding the patient it unexpected (as SAMPLE data import should always\n+                    // precede it), but\n+                    // can happen when this patient does not have any samples for example. In any\n+                    // case, warn about it:\n+                    ProgressMonitor.logWarning(\"Patient \" + patientId\n+                            + \" being added for the first time. Apparently this patient was not in the samples file, or the samples file is not yet loaded (should be loaded before this one)\");\n+                }\n+\n+                patient = new Patient(cancerStudy, patientId);\n+                internalPatientId = DaoPatient.addPatient(patient);\n+            }\n+        }\n+        return internalPatientId;\n+    }\n+\n+    private int addSampleToDatabase(String sampleId, String[] fields, Map<String, Integer> headerIndexMap)\n+            throws Exception {\n+        int sampleTypeIndex = findSampleTypeColumn(headerIndexMap);\n+        String sampleTypeStr = (sampleTypeIndex != -1) ? fields[sampleTypeIndex] : null;\n+        if (sampleTypeStr != null) {\n+            // want to match Sample.Type enum names\n+            sampleTypeStr = sampleTypeStr.trim().toUpperCase().replaceAll(\" \", \"_\");\n+        }\n+        Sample.Type sampleType = Sample.Type.has(sampleTypeStr) ? Sample.Type.valueOf(sampleTypeStr) : null;\n+\n+        int internalSampleId = -1;\n+        if (validSampleId(sampleId) && !StableIdUtil.isNormal(sampleId)) {\n+            // want to try and capture normal sample types based on value for SAMPLE_TYPE\n+            // if present in resource data\n+            if (sampleType != null && sampleType.isNormal()) {\n+                return internalSampleId;\n+            }\n+            String stablePatientId = getStablePatientId(sampleId, fields, headerIndexMap);\n+            if (validPatientId(stablePatientId)) {\n+                Patient patient = DaoPatient.getPatientByCancerStudyAndPatientId(cancerStudy.getInternalId(),\n+                        stablePatientId);\n+                if (patient == null) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4e724ff759a02f25a33335b5d8aab57376718488"}, "originalPosition": 326}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3597, "cost": 1, "resetAt": "2021-11-12T18:49:56Z"}}}